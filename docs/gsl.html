<!DOCTYPE html><html><head><title>Help for package gsl</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gsl}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gsl-package'>
<p>Wrappers for the Gnu Scientific Library</p></a></li>
<li><a href='#Airy'><p>Airy functions</p></a></li>
<li><a href='#Bessel'><p>Bessel functions</p></a></li>
<li><a href='#Clausen'><p>Clausen functions</p></a></li>
<li><a href='#Coulomb'><p>Coulomb functions</p></a></li>
<li><a href='#Coupling'><p>Coupling functions</p></a></li>
<li><a href='#Dawson'><p>Dawson functions</p></a></li>
<li><a href='#Debye'><p>Debye functions</p></a></li>
<li><a href='#Dilog'><p>Dilog functions</p></a></li>
<li><a href='#Ellint'><p>Elliptic functions</p></a></li>
<li><a href='#Elljac'><p>Elliptic functions</p></a></li>
<li><a href='#Error'><p>Error functions</p></a></li>
<li><a href='#Expint'><p>exponential functions</p></a></li>
<li><a href='#Fermi-Dirac'><p>Fermi-Dirac functions</p></a></li>
<li><a href='#Gamma'><p>gamma functions</p></a></li>
<li><a href='#Gegenbauer'><p>Gegenbauer functions</p></a></li>
<li><a href='#gsl-deprecated'><p>gsl-deprecated</p></a></li>
<li><a href='#Hyperg'><p>Hypergeometric functions</p></a></li>
<li><a href='#Laguerre'><p>Laguerre functions</p></a></li>
<li><a href='#Lambert'><p>Lambert's W function</p></a></li>
<li><a href='#Legendre'><p>Legendre functions</p></a></li>
<li><a href='#Log'><p>Log functions</p></a></li>
<li><a href='#Misc'><p>Argument processing and general info</p></a></li>
<li><a href='#multimin'><p>Function minimization</p></a></li>
<li><a href='#Poly'><p>Polynomials</p></a></li>
<li><a href='#Powint'><p>Power functions</p></a></li>
<li><a href='#Psi'><p>Psi (digamma) functions</p></a></li>
<li><a href='#Qrng'><p>Quasi-random sequences</p></a></li>
<li><a href='#Rng'><p>Random numbers generation</p></a></li>
<li><a href='#Synchrotron'><p>Synchrotron functions</p></a></li>
<li><a href='#Transport'><p>Transport functions</p></a></li>
<li><a href='#Trig'><p>Trig functions</p></a></li>
<li><a href='#Zeta'><p>Zeta functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Title:</td>
<td>Wrapper for the Gnu Scientific Library</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Gnu Scientific Library version &gt;= 2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>
 An R wrapper for some of the functionality of the
 Gnu Scientific Library.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/gsl">https://github.com/RobinHankin/gsl</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/gsl/issues">https://github.com/RobinHankin/gsl/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Andrew Clausen [ctb] (multimin functionality),
  Duncan Murdoch [ctb] (qrng functions)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-24 20:30:02 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-24 01:42:30 UTC; rhankin</td>
</tr>
</table>
<hr>
<h2 id='gsl-package'>
Wrappers for the Gnu Scientific Library
</h2><span id='topic+gsl-package'></span><span id='topic+gsl'></span><span id='topic+GSL'></span>

<h3>Description</h3>


<p> An R wrapper for some of the functionality of the
 Gnu Scientific Library.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> gsl</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.1-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 4.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Wrapper for the Gnu Scientific Library</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415")),
             person(given="Andrew",family="Clausen",role="ctb",comment="multimin functionality"),
             person(given="Duncan",family="Murdoch",role="ctb",comment="qrng functions"))</td>
</tr>
<tr>
 <td style="text-align: left;">
SystemRequirements: </td><td style="text-align: left;"> Gnu Scientific Library version &gt;= 2.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> 
 An R wrapper for some of the functionality of the
 Gnu Scientific Library.</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/gsl</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/gsl/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;),
  Andrew Clausen [ctb] (multimin functionality),
  Duncan Murdoch [ctb] (qrng functions)</td>
</tr>
<tr>
 <td style="text-align: left;">
Repository: </td><td style="text-align: left;"> CRAN</td>
</tr>
<tr>
 <td style="text-align: left;">
Date/Publication: </td><td style="text-align: left;"> 2019-03-25 09:10:03 UTC</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Airy                    Airy functions
Bessel                  Bessel functions
Clausen                 Clausen functions
Coulomb                 Coulomb functions
Coupling                Coupling functions
Dawson                  Dawson functions
Debye                   Debye functions
Dilog                   Dilog functions
Ellint                  Elliptic functions
Elljac                  Elliptic functions
Error                   Error functions
Expint                  exponential functions
Fermi_Dirac             Fermi-Dirac functions
Gamma                   gamma functions
Gegenbauer              Gegenbauer functions
Hyperg                  Hypergeometric functions
Laguerre                Laguerre functions
Lambert                 Lambert's W function
Legendre                Legendre functions
Log                     Log functions
Misc                    Argument processing and general info
Poly                    Polynomials
Psi                     Psi (digamma) functions
Qrng                    Quasi-random sequences
Rng                     Random numbers generation
Synchrotron             Synchrotron functions
Transport               Transport functions
Trig                    Trig functions
Zeta                    Zeta functions
gsl-deprecated          gsl-deprecated
gsl-package             Wrappers for the Gnu Scientific Library
multimin                Function minimization
pow_int                 Power functions
</pre>
<p>The function naming scheme directly copies the <abbr><span class="acronym">GSL</span></abbr> manual except that
leading <code>gsl_sf_</code> and, if present, the trailing <code>_e</code> is
stripped: thus <code>gsl_sf_Airy_Ai_e</code> goes to <span class="rlang"><b>R</b></span> function
<code>airy_Ai()</code>; however, some functions retain the prefix to avoid
conflicts (viz <code>gsl_sf_sin()</code>, <code>gsl_sf_cos()</code>,
<code>gsl_sf_gamma()</code>, <code>gsl_sf_ choose()</code>, <code>gsl_sf_beta()</code>).
</p>
<p><span class="rlang"><b>R</b></span> function arguments have the same names as in the <abbr><span class="acronym">GSL</span></abbr> reference 
manual, except for the quasirandom functions documented in the
<code>Qrng</code> manpage.
</p>
<p>The package is organized into units corresponding to <abbr><span class="acronym">GSL</span></abbr> header files;
the <code>.c</code>, <code>.R</code>, and <code>.Rd</code> filenames match the <abbr><span class="acronym">GSL</span></abbr> header
filenames, except that the <code>.Rd</code> files are capitalized.  Functions
appear in all files in the same order as the <abbr><span class="acronym">GSL</span></abbr> reference manual, which
precludes the use of the tidying method given in section 3.1 of R-exts.
Error forms of <abbr><span class="acronym">GSL</span></abbr> functions (<code>_e</code> versions) are used if available.
</p>
<p>In general, documentation is limited to: (a), a pointer to the <abbr><span class="acronym">GSL</span></abbr>
reference book, which would in any case dominate any docs here; and (b),
re-productions of some tables and figures in Abramowitz and Stegun
(June 1964).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;),
  Andrew Clausen [ctb] (multimin functionality),
  Duncan Murdoch [ctb] (qrng functions)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> M. Abramowitz and I. A. Stegun 1965. <em>Handbook of
mathematical functions</em>.  New York: Dover
</p>
</li>
<li><p> M. Galassi et al. 2007. <em>GNU Scientific Library</em>.
Reference Manual edition 1.10, for <abbr><span class="acronym">GSL</span></abbr> version 1.10; 10 September 2007
</p>
</li>
<li><p> R. K. S. Hankin 2006.  <em>Introducing gsl, a wrapper for
the Gnu Scientific Library</em>.  Rnews 6(4):24-26
</p>
</li></ul>
      


<h3>Examples</h3>

<pre><code class='language-R'>airy_Ai(1:5)
</code></pre>

<hr>
<h2 id='Airy'>Airy functions</h2><span id='topic+Airy'></span><span id='topic+airy'></span><span id='topic+airy_Ai'></span><span id='topic+airy_Bi'></span><span id='topic+airy_Bi_e'></span><span id='topic+airy_Ai_scaled'></span><span id='topic+airy_Ai_scaled_e'></span><span id='topic+airy_Bi_scaled'></span><span id='topic+airy_Bi_scaled_e'></span><span id='topic+airy_Ai_deriv'></span><span id='topic+airy_Ai_deriv_e'></span><span id='topic+airy_Bi_deriv'></span><span id='topic+airy_Bi_deriv_e'></span><span id='topic+airy_Ai_deriv_scaled'></span><span id='topic+airy_Ai_deriv_scaled_e'></span><span id='topic+airy_Bi_deriv_scaled'></span><span id='topic+airy_Bi_deriv_scaled_e'></span><span id='topic+airy_zero_Ai'></span><span id='topic+airy_zero_Ai_e'></span><span id='topic+airy_zero_Bi'></span><span id='topic+airy_zero_Bi_e'></span><span id='topic+airy_zero_Ai_deriv'></span><span id='topic+airy_zero_Ai_deriv_e'></span><span id='topic+airy_zero_Bi_deriv'></span><span id='topic+airy_zero_Bi_deriv_e'></span>

<h3>Description</h3>

<p>Airy functions as per the Gnu Scientific Library, reference manual
section 7.4 and AMS-55, section 10.4.  These functions are declared
in header file <code>gsl_sf_airy.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>airy_Ai(x, mode=0, give=FALSE, strict=TRUE)
airy_Ai_scaled(x, mode=0, give=FALSE, strict=TRUE)
airy_Ai(x, mode=0, give=FALSE, strict=TRUE)
airy_Bi_scaled(x, mode=0, give=FALSE, strict=TRUE)
airy_Ai_deriv(x, mode=0, give=FALSE, strict=TRUE)
airy_Bi_deriv(x, mode=0, give=FALSE, strict=TRUE)
airy_Ai_deriv_scaled(x, mode=0, give=FALSE, strict=TRUE)
airy_Bi_deriv_scaled(x, mode=0, give=FALSE, strict=TRUE)
airy_zero_Ai(n, give=FALSE, strict=TRUE)
airy_zero_Bi(n, give=FALSE, strict=TRUE)
airy_zero_Ai_deriv(n, give=FALSE, strict=TRUE)
airy_zero_Bi_deriv(n, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Airy_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Airy_+3A_n">n</code></td>
<td>
<p>input: integer values</p>
</td></tr>
<tr><td><code id="Airy_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Airy_+3A_mode">mode</code></td>
<td>
<p>input: mode.  For <code>GSL_PREC_DOUBLE</code>,
<code>GSL_PREC_SINGLE</code>, <code>GSL_PREC_APPROX</code> use <code>0,1,2</code>
respectively</p>
</td></tr>
<tr><td><code id="Airy_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero functions return a status of <code>GSL_EDOM</code> and a value of
<code>NA</code> for <code class="reqn">n\leq 0</code>.
</p>
<p>An example is given in the package vignette.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=1,by=0.01)

f &lt;- function(x){
cbind(x=x, Ai= airy_Ai(x), Aidash= airy_Ai_deriv(x),
Bi=airy_Ai(x),Bidash=airy_Bi_deriv(x))
}

f(x)  #table 10.11, p475
f(-x) #table 10.11, p476


x &lt;- 1:10  #table 10.13, p478
cbind(x,
 airy_zero_Ai(x), airy_Ai_deriv(airy_zero_Ai(x)),
 airy_zero_Ai_deriv(x), airy_Ai(airy_zero_Ai_deriv(x)),
 airy_zero_Bi(x), airy_Bi_deriv(airy_zero_Bi(x)),

 airy_zero_Bi_deriv(x), airy_Bi(airy_zero_Bi_deriv(x))
 )


# Verify 10.4.4 and 10.4.5, p446:
3^(-2/3)/gamma(2/3)   - airy_Ai(0)
3^(-1/3) / gamma(1/3) + airy_Ai_deriv(0) 
3^(-1/6) / gamma(2/3) - airy_Bi(0)
3^(1/6) / gamma(1/3)  - airy_Bi_deriv(0)
#  All should be small


</code></pre>

<hr>
<h2 id='Bessel'>Bessel functions</h2><span id='topic+Bessel'></span><span id='topic+bessel'></span><span id='topic+bessel_J0'></span><span id='topic+bessel_J1'></span><span id='topic+bessel_Jn'></span><span id='topic+bessel_Jn_array'></span><span id='topic+bessel_Y0'></span><span id='topic+bessel_Y1'></span><span id='topic+bessel_Yn'></span><span id='topic+bessel_Yn_array'></span><span id='topic+bessel_I0'></span><span id='topic+bessel_I1'></span><span id='topic+bessel_In'></span><span id='topic+bessel_In_array'></span><span id='topic+bessel_I0_scaled'></span><span id='topic+bessel_I1_scaled'></span><span id='topic+bessel_In_scaled'></span><span id='topic+bessel_In_scaled_array'></span><span id='topic+bessel_K0'></span><span id='topic+bessel_K1'></span><span id='topic+bessel_Kn'></span><span id='topic+bessel_Kn_array'></span><span id='topic+bessel_K0_scaled'></span><span id='topic+bessel_K1_scaled'></span><span id='topic+bessel_Kn_scaled'></span><span id='topic+bessel_Kn_scaled_array'></span><span id='topic+bessel_j0'></span><span id='topic+bessel_j1'></span><span id='topic+bessel_j2'></span><span id='topic+bessel_jl'></span><span id='topic+bessel_jl_array'></span><span id='topic+bessel_jl_steed_array'></span><span id='topic+bessel_y0'></span><span id='topic+bessel_y1'></span><span id='topic+bessel_y2'></span><span id='topic+bessel_yl'></span><span id='topic+bessel_yl_array'></span><span id='topic+bessel_i0_scaled'></span><span id='topic+bessel_i1_scaled'></span><span id='topic+bessel_i2_scaled'></span><span id='topic+bessel_il_scaled'></span><span id='topic+bessel_il_scaled_array'></span><span id='topic+bessel_k0_scaled'></span><span id='topic+bessel_k1_scaled'></span><span id='topic+bessel_k2_scaled'></span><span id='topic+bessel_kl_scaled'></span><span id='topic+bessel_kl_scaled_array'></span><span id='topic+bessel_Jnu'></span><span id='topic+bessel_sequence_Jnu'></span><span id='topic+bessel_Ynu'></span><span id='topic+bessel_Inu'></span><span id='topic+bessel_Inu_scaled'></span><span id='topic+bessel_Knu'></span><span id='topic+bessel_lnKnu'></span><span id='topic+bessel_Knu_scaled'></span><span id='topic+bessel_zero_J0'></span><span id='topic+bessel_zero_J1'></span><span id='topic+bessel_zero_Jnu'></span>

<h3>Description</h3>

<p>Bessel functions as per the Gnu Scientific Library, reference manual
section 7.5 and AMS-55, chapters 9 and 10.  These functions are
declared in header file <code>gsl_sf_bessel.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bessel_J0(x, give=FALSE, strict=TRUE)
bessel_J1(x, give=FALSE, strict=TRUE)
bessel_Jn(n,x, give=FALSE, strict=TRUE)
bessel_Jn_array(nmin,nmax,x, give=FALSE, strict=TRUE)
bessel_Y0(x, give=FALSE, strict=TRUE)
bessel_Y1(x, give=FALSE, strict=TRUE)
bessel_Yn(n,x, give=FALSE, strict=TRUE)
bessel_Yn_array(nmin, nmax, x, give=FALSE, strict=TRUE)
bessel_I0(x, give=FALSE, strict=TRUE)
bessel_I1(x, give=FALSE, strict=TRUE)
bessel_In(n, x, give=FALSE, strict=TRUE)
bessel_In_array(nmin, nmax, x, give=FALSE, strict=TRUE)
bessel_I0_scaled(x, give=FALSE, strict=TRUE)
bessel_I1_scaled(x, give=FALSE, strict=TRUE)
bessel_In_scaled(n, x, give=FALSE, strict=TRUE)
bessel_In_scaled_array(nmin, nmax, x, give=FALSE, strict=TRUE)
bessel_K0(x, give=FALSE, strict=TRUE)
bessel_K1(x, give=FALSE, strict=TRUE)
bessel_Kn(n, x, give=FALSE, strict=TRUE)
bessel_Kn_array(nmin, nmax, x, give=FALSE, strict=TRUE)
bessel_K0_scaled(x, give=FALSE, strict=TRUE)
bessel_K1_scaled(x, give=FALSE, strict=TRUE)
bessel_Kn_scaled(n, x, give=FALSE, strict=TRUE)
bessel_Kn_scaled_array(nmin, nmax, x, give=FALSE, strict=TRUE)
bessel_j0(x, give=FALSE, strict=TRUE)
bessel_j1(x, give=FALSE, strict=TRUE)
bessel_j2(x, give=FALSE, strict=TRUE)
bessel_jl(l,x, give=FALSE, strict=TRUE)
bessel_jl_array(lmax,x, give=FALSE, strict=TRUE)
bessel_jl_steed_array(lmax, x, give=FALSE, strict=TRUE)
bessel_y0(x, give=FALSE, strict=TRUE)
bessel_y1(x, give=FALSE, strict=TRUE)
bessel_y2(x, give=FALSE, strict=TRUE)
bessel_yl(l, x, give=FALSE, strict=TRUE)
bessel_yl_array(lmax, x, give=FALSE, strict=TRUE)
bessel_i0_scaled(x, give=FALSE, strict=TRUE)
bessel_i1_scaled(x, give=FALSE, strict=TRUE)
bessel_i2_scaled(x, give=FALSE, strict=TRUE)
bessel_il_scaled(l, x, give=FALSE, strict=TRUE)
bessel_il_scaled_array(lmax, x, give=FALSE, strict=TRUE)
bessel_k0_scaled(x, give=FALSE, strict=TRUE)
bessel_k1_scaled(x, give=FALSE, strict=TRUE)
bessel_k2_scaled(x, give=FALSE, strict=TRUE)
bessel_kl_scaled(l,x, give=FALSE, strict=TRUE)
bessel_kl_scaled_array(lmax,x, give=FALSE, strict=TRUE)
bessel_Jnu(nu, x, give=FALSE, strict=TRUE)
bessel_sequence_Jnu(nu, v, mode=0, give=FALSE, strict=TRUE)
bessel_Ynu(nu, x, give=FALSE, strict=TRUE)
bessel_Inu(nu, x, give=FALSE, strict=TRUE)
bessel_Inu_scaled(nu, x, give=FALSE, strict=TRUE)
bessel_Knu(nu, x, give=FALSE, strict=TRUE)
bessel_lnKnu(nu, x, give=FALSE, strict=TRUE)
bessel_Knu_scaled(nu, x, give=FALSE, strict=TRUE)
bessel_zero_J0(s, give=FALSE, strict=TRUE)
bessel_zero_J1(s, give=FALSE, strict=TRUE)
bessel_zero_Jnu(nu, s, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bessel_+3A_x">x</code>, <code id="Bessel_+3A_v">v</code>, <code id="Bessel_+3A_nu">nu</code></td>
<td>
<p>input: real valued</p>
</td></tr>
<tr><td><code id="Bessel_+3A_n">n</code>, <code id="Bessel_+3A_nmin">nmin</code>, <code id="Bessel_+3A_nmax">nmax</code>, <code id="Bessel_+3A_lmax">lmax</code></td>
<td>
<p>input: integer valued</p>
</td></tr>
<tr><td><code id="Bessel_+3A_l">l</code>, <code id="Bessel_+3A_s">s</code></td>
<td>
<p>input: integer valued</p>
</td></tr>
<tr><td><code id="Bessel_+3A_mode">mode</code></td>
<td>
<p>Integer, calc mode</p>
</td></tr>
<tr><td><code id="Bessel_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Bessel_+3A_strict">strict</code></td>
<td>
<p>strict or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All as for the <abbr><span class="acronym">GSL</span></abbr> reference manual section 7.5
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compare native R routine with GSL:
besselK(0.55,4) - bessel_Knu(4,0.55)  # should be small


x &lt;- seq(from=0,to=15,len=1000)
plot(x,bessel_J0(x),xlim=c(0,16),ylim=c(-0.8,1.1),type="l",
           xaxt="n",yaxt="n",bty="n",xlab="",ylab="",
           main="Figure 9.1, p359")
jj.Y0 &lt;- bessel_Y0(x)
jj.Y0[jj.Y0&lt; -0.8] &lt;- NA
lines(x,jj.Y0)
lines(x,bessel_J1(x),lty=2)
jj.Y1 &lt;- bessel_Y1(x)
jj.Y1[jj.Y1&lt; -0.8] &lt;- NA
lines(x,jj.Y1,lty=2)
axis(1,pos=0,at=1:15,
     labels=c("","2","","4","","6","","8","","10","","12","","14","") )
axis(2,pos=0,at=seq(from=-8,to=10,by=2)/10,
labels=c("-.8","-.6","-.4","-.2","0",".2",".4",".6",".8","1.0"))
arrows(0,0,16,0,length=0.1,angle=10)
arrows(0,0,0,1.1,length=0.1,angle=10)
text(1.1, 0.83, expression(J[0]))
text(0.37, 0.3, expression(J[1]))
text(0.34,-0.3, expression(Y[0]))
text(1.7,-0.5, expression(Y[1]))
text(4.2, 0.43, expression(Y[1]))
text(7.2, 0.33, expression(J[0]))
text(8.6, 0.3, expression(J[0],paste("    ,")))
text(9.1, 0.3, expression(Y[0]))

x &lt;- seq(from=0,to=13,len=100)
y &lt;- t(bessel_jl_array(3,x))
y[y&gt;0.6] &lt;- NA
 matplot(x,y,col="black",type="l",xaxt="n",yaxt="n",bty="n",
         xlab="",ylab="",xlim=c(0,16),ylim=c(-0.3,0.75),
         main="Figure 10.1, p438")
axis(1,pos=0,at=2*(1:7))
arrows(0,0,15,0,length=0.1,angle=10)
arrows(0,0,0,0.65,length=0.1,angle=10)
axis(2,pos=0,las=1,at=seq(from=-3,to=6)/10,
         labels=c("-.3","-.2","-.1","0",".1",".2",".3",".4",".5",".6"))
text(0, 0.7, expression(J[n](x)))
text(15.5, 0, expression(x))
text(2.2,0.58,expression(n==0))
text(3.2,0.4,expression(n==1))
text(4.3,0.3,expression(n==2))
text(6.0,0.22,expression(n==3))



x &lt;- seq(from=0 ,to=5,by=0.1)
cbind(x, bessel_J0(x),bessel_J1(x),bessel_Jn(2,x))      #table 9.1, p390
cbind(x, bessel_Y0(x),bessel_Y1(x),bessel_Yn(2,x))      #table 9.2, p391
t(bessel_Jn_array(3,9,x*2))                             #table 9.2, p398



 x &lt;- seq(from=8,to=10,by=0.2)
 jj &lt;- t(bessel_Jn(n=3:9,x=t(matrix(x,11,7))))
colnames(jj) &lt;- paste("J",3:9,"(x)",sep="")
cbind(x,jj)                 #another part of table 9.2, p398


 x &lt;- seq(from=8,to=10,by=0.2)
 jj &lt;- t(bessel_Yn(n=3:9,x=t(matrix(x,11,7))))
colnames(jj) &lt;- paste("J",3:9,"(x)",sep="")
cbind(x,jj)                 #part of table 9.2, p399

cbind(                       x,                         #table 9.8, p416
        exp(-x)*bessel_I0  (x),
        exp(-x)*bessel_I1  (x),
         x^(-2)*bessel_In(2,x)
)

cbind(                      x,                          #table 9.8, p417
        exp(x)*bessel_K0  (x),
        exp(x)*bessel_K1  (x),
         x^(2)*bessel_Kn(2,x)
)

cbind(x,                                                #table 10.1 , p457
    bessel_j0(x),
    bessel_j1(x),
    bessel_j2(x),
    bessel_y0(x),
    bessel_y1(x),
    bessel_y2(x)
)

 cbind(0:9,"x=1"=bessel_yl(l=0:9,x=1), "x=2"=bessel_yl(l=0:9,x=2), "x=5"=bessel_yl(l=0:9,x=5)) 
                                                        #table 10.5, p466, top
</code></pre>

<hr>
<h2 id='Clausen'>Clausen functions</h2><span id='topic+Clausen'></span><span id='topic+clausen'></span>

<h3>Description</h3>

<p>Clausen functions as per the Gnu Scientific Library section 7.6.
These functions are declared in header file <code>gsl_sf_clausen.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clausen(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Clausen_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Clausen_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Clausen_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- (0:30)*pi/180
clausen(x)          #table 27.8, p1006

</code></pre>

<hr>
<h2 id='Coulomb'>Coulomb functions</h2><span id='topic+Coulomb'></span><span id='topic+coulomb'></span><span id='topic+hydrogenicR_1'></span><span id='topic+hydrogenicR'></span><span id='topic+coulomb_wave_FG'></span><span id='topic+coulomb_wave_F_array'></span><span id='topic+coulomb_wave_FG_array'></span><span id='topic+coulomb_wave_FGp_array'></span><span id='topic+coulomb_wave_sphF_array'></span><span id='topic+coulomb_CL'></span><span id='topic+coulomb_CL_array'></span>

<h3>Description</h3>

<p>Coulomb functions as per the Gnu Scientific Library, reference manual
section 7.7 and AMS-55, chapter 14.  These functions are declared
in header file <code>gsl_sf_coulomb.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hydrogenicR_1(Z, r, give=FALSE, strict=TRUE)
hydrogenicR(n, l, Z, r, give=FALSE, strict=TRUE)
coulomb_wave_FG(eta, x, L_F, k, give=FALSE, strict=TRUE)
coulomb_wave_F_array(L_min, kmax, eta, x, give=FALSE,strict=TRUE)
coulomb_wave_FG_array(L_min, kmax, eta, x, give=FALSE,strict=TRUE)
coulomb_wave_FGp_array(L_min, kmax, eta, x, give=FALSE,strict=TRUE)
coulomb_wave_sphF_array(L_min, kmax, eta, x, give=FALSE,strict=TRUE)
coulomb_CL(L,eta, give=FALSE,strict=TRUE)
coulomb_CL_array(L_min, kmax, eta, give=FALSE,strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coulomb_+3A_n">n</code>, <code id="Coulomb_+3A_l">l</code>, <code id="Coulomb_+3A_kmax">kmax</code></td>
<td>
<p>input: integers</p>
</td></tr>
<tr><td><code id="Coulomb_+3A_z">Z</code>, <code id="Coulomb_+3A_r">r</code>, <code id="Coulomb_+3A_eta">eta</code>, <code id="Coulomb_+3A_x">x</code>, <code id="Coulomb_+3A_l_f">L_F</code>, <code id="Coulomb_+3A_l_min">L_min</code>, <code id="Coulomb_+3A_k">k</code>, <code id="Coulomb_+3A_l">L</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Coulomb_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Coulomb_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=14,len=300)
jj &lt;- coulomb_wave_FG(1,10,x,0)
plot(x,jj$val_F,type="l",xaxt="n",yaxt="n",bty="n",xlab="",ylab="",
       main="Figure 14.1, p539")
lines(x,jj$val_G,type="l",lty=2)
axis(1,pos=0,at=1:14,
       labels=c("","2","","4","","6","","8","","10","","12","","14"))
lines(c(0,1),c(0,0))
axis(2,pos=0)
text(9.5, 0.63, expression(F[L]))
text(8.5, 1.21, expression(G[L]))





x &lt;- seq(from=0,to=24,len=400)
plot(x,coulomb_wave_FG(eta=1,x,L_F=0,k=0)$val_F,type="l",
     ylim=c(-1.3,1.7), xlim=c(0,26),
     xaxt="n",yaxt="n",bty="n",xlab="",ylab="",main="Figure 14.3, p541",lty=3)
lines(x,coulomb_wave_FG(eta= 0,x,L_F=0,k=0)$val_F,type="l",lty=1)
lines(x,coulomb_wave_FG(eta= 5,x,L_F=0,k=0)$val_F,type="l",lty=6)
lines(x,coulomb_wave_FG(eta=10,x,L_F=0,k=0)$val_F,type="l",lty=6)
lines(x,coulomb_wave_FG(eta=x/2,x,L_F=0,k=0)$val_F,type="l",lty="F3")
axis(1,pos=0,at=1:24,
       labels=c("","2","","4","","","","8","","10","","12",
                "","14","","","","18","","","","22","","24"))
lines(c(0,26),c(0,0))
axis(2,pos=0,at=0.2*(-6:9),
       labels=c("","-1.2","","-.8","","-.4","","0","",".4",
                "",".8","","1.2","","1.6"))
text(2.5, -0.8, expression(eta == 0))
text(4.5,1.1,adj=0, expression(eta == 1))
text(14,1.4,adj=0, expression(eta == 5))
text(22,1.4,adj=0, expression(eta == 10))






x &lt;- seq(from=0.5,to=10,by=0.5)
jj &lt;- coulomb_wave_FG(eta=t(matrix(x,20,5)), x=1:5,0,0)
jj.F &lt;- t(jj$val_F)
jj.G &lt;- t(jj$val_G)
colnames(jj.F) &lt;- 1:5
colnames(jj.G) &lt;- 1:5
cbind(x,jj.F)        #table 14.1, p 546, top bit.
cbind(x,jj.G)        #table 14.1, p 547, top bit.



</code></pre>

<hr>
<h2 id='Coupling'>Coupling functions</h2><span id='topic+Coupling'></span><span id='topic+coupling'></span><span id='topic+coupling_3j'></span><span id='topic+coupling_6j'></span><span id='topic+coupling_9j'></span>

<h3>Description</h3>

<p>Coupling functions as per the Gnu Scientific Library, reference manual
section 7.8.  These functions are declared in header file
<code>gsl_sf_coupling.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coupling_3j(two_ja, two_jb, two_jc, two_ma, two_mb, two_mc, give=FALSE, strict=TRUE)
coupling_6j(two_ja, two_jb, two_jc, two_jd, two_je, two_jf, give=FALSE, strict=TRUE)
coupling_9j(two_ja, two_jb, two_jc, two_jd, two_je, two_jf,
      two_jg, two_jh, two_ji, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coupling_+3A_two_ja">two_ja</code>, <code id="Coupling_+3A_two_jb">two_jb</code>, <code id="Coupling_+3A_two_jc">two_jc</code>, <code id="Coupling_+3A_two_jd">two_jd</code>, <code id="Coupling_+3A_two_je">two_je</code>, <code id="Coupling_+3A_two_jf">two_jf</code>, <code id="Coupling_+3A_two_jg">two_jg</code>, <code id="Coupling_+3A_two_jh">two_jh</code>, <code id="Coupling_+3A_two_ji">two_ji</code>, <code id="Coupling_+3A_two_ma">two_ma</code>, <code id="Coupling_+3A_two_mb">two_mb</code>, <code id="Coupling_+3A_two_mc">two_mc</code></td>
<td>
<p>Arguments as per the <abbr><span class="acronym">GSL</span></abbr> manual</p>
</td></tr>
<tr><td><code id="Coupling_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Coupling_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>coupling_3j(1,2,3,4,5,6)
coupling_6j(1,2,3,4,5,6)
coupling_9j(1,2,3,4,5,6,7,8,9)
</code></pre>

<hr>
<h2 id='Dawson'>Dawson functions</h2><span id='topic+Dawson'></span><span id='topic+dawson'></span>

<h3>Description</h3>

<p>Dawson functions as per the Gnu Scientific Library, reference manual
section 7.9.  These functions are declared in header file
<code>gsl_sf_dawson.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dawson(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dawson_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Dawson_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Dawson_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=2,by=0.01)
dawson(x)   #table 7.5 of Ab and St
</code></pre>

<hr>
<h2 id='Debye'>Debye functions</h2><span id='topic+Debye'></span><span id='topic+debye'></span><span id='topic+debye_1'></span><span id='topic+debye_2'></span><span id='topic+debye_3'></span><span id='topic+debye_4'></span>

<h3>Description</h3>

<p>Debye functions as per the Gnu Scientific Library, section 7.10 of the
reference manual.  These functions are declared in header file
<code>gsl_sf_debye.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>debye_1(x, give=FALSE, strict=TRUE)
debye_2(x, give=FALSE, strict=TRUE)
debye_3(x, give=FALSE, strict=TRUE)
debye_4(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Debye_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Debye_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Debye_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=10,by=0.1)
cbind(x,debye_1(x),debye_2(x),debye_3(x),debye_4(x))  #table 27.1
</code></pre>

<hr>
<h2 id='Dilog'>Dilog functions</h2><span id='topic+Dilog'></span><span id='topic+dilog'></span><span id='topic+polylog'></span><span id='topic+complex_dilog'></span>

<h3>Description</h3>

<p>Dilog functions as per the Gnu Scientific Library reference manual
section 7.11.  These functions are declared in header file
<code>gsl_sf_dilog.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dilog(x, give=FALSE, strict=TRUE)
complex_dilog(r, theta, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dilog_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Dilog_+3A_r">r</code>, <code id="Dilog_+3A_theta">theta</code></td>
<td>
<p>In <code>complex_dilog()</code>, input 
values.  If <code>theta</code> takes its default value of
<code>NULL</code>, interpret <code>r</code> as a complex-valued object.  If
<code>theta</code> is non-null, interpret <code>r</code> as the Modulus,
and <code>theta</code> as the argument, of the complex object passed to
<code>gsl_sf_complex_dilog_e()</code></p>
</td></tr>
<tr><td><code id="Dilog_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
return just the answers, and <code>TRUE</code> meaning to return a status
vector as well</p>
</td></tr>
<tr><td><code id="Dilog_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if nonzero status is returned by the <abbr><span class="acronym">GSL</span></abbr> function (<code>FALSE</code>
means to return the value: use with caution)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions as documented in the <abbr><span class="acronym">GSL</span></abbr> reference manual section
7.11.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0, to=0.1,by=0.01)
cbind(x,"f(x)"=dilog(1-x))   #table 27.7, p1005

</code></pre>

<hr>
<h2 id='Ellint'>Elliptic functions</h2><span id='topic+Ellint'></span><span id='topic+ellint'></span><span id='topic+ellint_Kcomp'></span><span id='topic+ellint_Ecomp'></span><span id='topic+ellint_F'></span><span id='topic+ellint_E'></span><span id='topic+ellint_P'></span><span id='topic+ellint_D'></span><span id='topic+ellint_RC'></span><span id='topic+ellint_RD'></span><span id='topic+ellint_RF'></span><span id='topic+ellint_RJ'></span>

<h3>Description</h3>

<p>Elliptic functions as per the Gnu Scientific Library, reference manual
section 7.13 and AMS-55, chapter 17.  These functions are
declared in header file <code>gsl_sf_ellint.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellint_Kcomp(k, mode=0, give=FALSE,strict=TRUE)
ellint_Ecomp(k, mode=0, give=FALSE,strict=TRUE)
ellint_F(phi,k, mode=0, give=FALSE,strict=TRUE)
ellint_E(phi,k, mode=0, give=FALSE,strict=TRUE)
ellint_P(phi,k,n, mode=0, give=FALSE,strict=TRUE)
ellint_D(phi,k, mode=0, give=FALSE,strict=TRUE)
ellint_RC(x, y, mode=0, give=FALSE,strict=TRUE)
ellint_RD(x, y, z, mode=0, give=FALSE,strict=TRUE)
ellint_RF(x, y, z, mode=0, give=FALSE,strict=TRUE)
ellint_RJ(x, y, z, p, mode=0, give=FALSE,strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ellint_+3A_phi">phi</code>, <code id="Ellint_+3A_k">k</code>, <code id="Ellint_+3A_n">n</code>, <code id="Ellint_+3A_p">p</code>, <code id="Ellint_+3A_x">x</code>, <code id="Ellint_+3A_y">y</code>, <code id="Ellint_+3A_z">z</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Ellint_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
return just the answers, and <code>TRUE</code> meaning to return a status
vector as well</p>
</td></tr>
<tr><td><code id="Ellint_+3A_strict">strict</code></td>
<td>
<p>Boolean</p>
</td></tr>
<tr><td><code id="Ellint_+3A_mode">mode</code></td>
<td>
<p>input: mode.  For <code>GSL_PREC_DOUBLE</code>,
<code>GSL_PREC_SINGLE</code>, <code>GSL_PREC_APPROX</code> use <code>0,1,2</code>
respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>ellint_Kcomp(0.3)
ellint_Ecomp(0.3)
ellint_F(0.4,0.7)
ellint_E(0.4,0.7)
ellint_P(0.4,0.7,0.3)
ellint_D(0.4,0.3)
ellint_RC(0.5,0.6)
ellint_RD(0.5,0.6,0.7)
ellint_RF(0.5,0.6,0.7)
ellint_RJ(0.5,0.6,0.7,0.1)


x &lt;- seq(from=0,to=0.5,by=0.01)
col1 &lt;- ellint_Kcomp(sqrt(x))
col2 &lt;- ellint_Kcomp(sqrt(1-x))
col3 &lt;- exp(-pi*col2/col1)
cbind(x,col1,col2,col3)         #table 17.1, p608

x &lt;- 0:45
col1 &lt;- ellint_Kcomp(sin(pi/180*x))
col2 &lt;- ellint_Kcomp(sin(pi/2-pi/180*x))
col3 &lt;- exp(-pi*col2/col1)
cbind(x,col1,col2,col3)       #table 17.2, p610

x &lt;- seq(from=0,to=90,by=2)
f &lt;- function(a){ellint_F(phi=a*pi/180,sin(x*pi/180))}
g &lt;- function(a){ellint_E(phi=a*pi/180,sin(x*pi/180))}
h &lt;- function(a,n){ellint_P(phi=a*pi/180,sin( a*15*pi/180),n)}
i &lt;- function(x){ellint_P(phi=x*pi/180, k=sin((0:6)*15*pi/180),  n= -0.6)}


cbind(x,f(5),f(10),f(15),f(20),f(25),f(30))          #table 17.5, p613
cbind(x,g(5),g(10),g(15),g(20),g(25),g(30))          #table 17.6, p616



cbind(i(15),i(30),i(45),i(60),i(75),i(90))           #table 17.9,
                                                     #(BOTTOM OF p625)


</code></pre>

<hr>
<h2 id='Elljac'>Elliptic functions</h2><span id='topic+Elljac'></span><span id='topic+elljac'></span><span id='topic+sn_cn_dn'></span><span id='topic+gsl_sn'></span><span id='topic+gsl_cn'></span><span id='topic+gsl_dn'></span><span id='topic+gsl_ns'></span><span id='topic+gsl_nc'></span><span id='topic+gsl_nd'></span><span id='topic+gsl_sc'></span><span id='topic+gsl_sd'></span><span id='topic+gsl_cs'></span><span id='topic+gsl_cd'></span><span id='topic+gsl_ds'></span><span id='topic+gsl_dc'></span>

<h3>Description</h3>

<p>Elljac functions as per the Gnu Scientific Library, reference manual
section 7.14 and AMS-55, chapter 16.  These functions are
declared in header file <code>gsl_sf_elljac.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elljac(u, m, give=FALSE, strict=TRUE)
gsl_sn(z,m)
gsl_cn(z,m)
gsl_dn(z,m)
gsl_ns(z,m)
gsl_nc(z,m)
gsl_nd(z,m)
gsl_sc(z,m)
gsl_sd(z,m)
gsl_cs(z,m)
gsl_cd(z,m)
gsl_ds(z,m)
gsl_dc(z,m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Elljac_+3A_u">u</code>, <code id="Elljac_+3A_m">m</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Elljac_+3A_z">z</code></td>
<td>
<p>input: complex values</p>
</td></tr>
<tr><td><code id="Elljac_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Elljac_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A straightforward wrapper for the <code>gsl_sf_elljac_e</code>
function of the <abbr><span class="acronym">GSL</span></abbr> library, except for <code>gsl_sn()</code>, <code>gsl_cn()</code>, and
<code>gsl_dn()</code>, which implement 16.21.1 to 16.21.4  (thus taking complex
arguments); and <code>gsl_ns()</code> et
seq which are the minor elliptic functions.
</p>
<p>Function <code>sn_cn_dn()</code> is not really intended for the end-user.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
K &lt;- ellint_F(phi=pi/2,k=sqrt(1/2))  #note the sqrt: m=k^2
u &lt;- seq(from=0,to=4*K,by=K/24)
jj &lt;- elljac(u,1/2)
plot(u,jj$sn,type="l",xaxt="n",yaxt="n",bty="n",ylab="",xlab="",main="Fig 16.1, p570")
lines(u,jj$cn,lty=2)
lines(u,jj$dn,lty=3)
axis(1,pos=0,at=c(K,2*K,3*K,4*K),labels=c("K","2K","3K","4K"))
abline(0,0)
axis(2,pos=0,at=c(-1,1))
text(1.8*K,0.6,"sn u")
text(1.6*K,-0.5,"cn u")
text(2.6*K,0.9,"dn u")



 a &lt;- seq(from=-5,to=5,len=100)
jj &lt;- outer(a,a,function(a,b){a})
z &lt;- jj+1i*t(jj)
e &lt;- Re(gsl_cd(z,m=0.2))
e[abs(e)&gt;10] &lt;- NA
contour(a,a,e,nlev=55)
</code></pre>

<hr>
<h2 id='Error'>Error functions</h2><span id='topic+error'></span><span id='topic+Error'></span><span id='topic+Error+20function'></span><span id='topic+erf'></span><span id='topic+erfc'></span><span id='topic+log_erfc'></span><span id='topic+log_erf_Z'></span><span id='topic+erf_Q'></span><span id='topic+erf_Z'></span><span id='topic+hazard'></span>

<h3>Description</h3>

<p>Error functions as per the Gnu Scientific Library, reference manual
section 7.15 and AMS-55, chapter 7.  Thes functions are declared
in header file <code>gsl_sf_error.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erf(x, mode=0, give=FALSE, strict=TRUE)
erfc(x, mode=0, give=FALSE, strict=TRUE)
log_erfc(x, mode=0, give=FALSE, strict=TRUE)
erf_Q(x, mode=0, give=FALSE, strict=TRUE)
hazard(x, mode=0, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Error_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Error_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Error_+3A_mode">mode</code></td>
<td>
<p>input: mode.  For <code>GSL_PREC_DOUBLE</code> ,
<code>GSL_PREC_SINGLE</code>, <code>GSL_PREC_APPROX</code> use <code>0,1,2</code>
respectively</p>
</td></tr>
<tr><td><code id="Error_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The zero functions return a status of <code>GSL_EDOM</code> and a value of
<code>NA</code> for <code class="reqn">n\leq 0</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>

erf(0.745) # Example 1, page 304

</code></pre>

<hr>
<h2 id='Expint'>exponential functions</h2><span id='topic+Expint'></span><span id='topic+expint'></span><span id='topic+expint_E1'></span><span id='topic+expint_E2'></span><span id='topic+expint_En'></span><span id='topic+expint_Ei'></span><span id='topic+Shi'></span><span id='topic+Chi'></span><span id='topic+expint_3'></span><span id='topic+Si'></span><span id='topic+Ci'></span><span id='topic+atanint'></span>

<h3>Description</h3>

<p>Expint functions as per the Gnu Scientific Library, reference manual
section 7.17 and AMS-55, chapter 5.  These functions are declared in
header file <code>gsl_sf_expint.h</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expint_E1(x, give=FALSE, strict=TRUE)
expint_E2(x, give=FALSE, strict=TRUE)
expint_En(n, x, give=FALSE, strict=TRUE)
expint_Ei(x, give=FALSE, strict=TRUE)
Shi(x, give=FALSE, strict=TRUE)
Chi(x, give=FALSE, strict=TRUE)
expint_3(x, give=FALSE, strict=TRUE)
Si(x, give=FALSE, strict=TRUE)
Ci(x, give=FALSE, strict=TRUE)
atanint(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Expint_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Expint_+3A_n">n</code></td>
<td>
<p>input: integer values</p>
</td></tr>
<tr><td><code id="Expint_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Expint_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Function <code>expint_En()</code> requires <abbr><span class="acronym">GSL</span></abbr> version 1.8 or later.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(from=0.5, to=1, by=0.01)
cbind(x,Si(x),Ci(x),expint_Ei(x),expint_E1(x))  #table 5.1 of AS, p239

x &lt;- seq(from=0, to=12, len=100)
plot(x,Ci(x),col="black",type="l",xaxt="n",yaxt="n",bty="n",
         xlab="",ylab="",main="Figure 5.6, p232",
         xlim=c(0,12),ylim=c(-1,2.0))
lines(x,Si(x))
axis(1,pos=0)
axis(2,pos=0)
 abline(h=pi/2,lty=2)


# Table 5.4, page 245:
 xvec &lt;- seq(from=0,by=0.01,len=20)
 nvec &lt;- c(2,3,4,10,20)
 x &lt;- kronecker(xvec,t(rep(1,5)))
 n &lt;- kronecker(t(nvec),rep(1,20))
 ans &lt;- cbind(x=xvec,expint_En(n,x))
 rownames(ans) &lt;- rep(" ",length(xvec))
 colnames(ans) &lt;- c("x",paste("n=",nvec,sep=""))
 class(ans) &lt;- "I do not understand the first column"

 ans

</code></pre>

<hr>
<h2 id='Fermi-Dirac'>Fermi-Dirac functions</h2><span id='topic+Fermi_Dirac'></span><span id='topic+Fermi'></span><span id='topic+fermi_dirac'></span><span id='topic+fermi'></span><span id='topic+fermi_dirac_m1'></span><span id='topic+fermi_dirac_0'></span><span id='topic+fermi_dirac_1'></span><span id='topic+fermi_dirac_2'></span><span id='topic+fermi_dirac_int'></span><span id='topic+fermi_dirac_mhalf'></span><span id='topic+fermi_dirac_half'></span><span id='topic+fermi_dirac_3half'></span><span id='topic+fermi_dirac_inc_0'></span>

<h3>Description</h3>

<p>Fermi-Dirac functions as per the Gnu Scientific Library, reference
manual section 7.18.  These functions are declared in header file
<code>gsl_sf_fermi_dirac.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fermi_dirac_m1(x, give=FALSE, strict=TRUE)
fermi_dirac_0(x, give=FALSE, strict=TRUE)
fermi_dirac_1(x, give=FALSE, strict=TRUE)
fermi_dirac_2(x, give=FALSE, strict=TRUE)
fermi_dirac_int(j, x, give=FALSE, strict=TRUE)
fermi_dirac_mhalf(x, give=FALSE, strict=TRUE)
fermi_dirac_half(x, give=FALSE, strict=TRUE)
fermi_dirac_3half(x, give=FALSE, strict=TRUE)
fermi_dirac_inc_0(x, b, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fermi-Dirac_+3A_x">x</code>, <code id="Fermi-Dirac_+3A_j">j</code>, <code id="Fermi-Dirac_+3A_b">b</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Fermi-Dirac_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Fermi-Dirac_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=2,by=0.01)
fermi_dirac_m1(x)   #table 7.5 of Ab and St
</code></pre>

<hr>
<h2 id='Gamma'>gamma functions</h2><span id='topic+Gamma'></span><span id='topic+gamma'></span><span id='topic+gsl_sf_gamma'></span><span id='topic+lngamma'></span><span id='topic+lngamma_sgn'></span><span id='topic+gammastar'></span><span id='topic+gammainv'></span><span id='topic+lngamma_complex'></span><span id='topic+taylorcoeff'></span><span id='topic+fact'></span><span id='topic+doublefact'></span><span id='topic+lnfact'></span><span id='topic+lndoublefact'></span><span id='topic+gsl_sf_choose'></span><span id='topic+lnchoose'></span><span id='topic+poch'></span><span id='topic+lnpoch'></span><span id='topic+lnpoch_sgn'></span><span id='topic+pochrel'></span><span id='topic+gamma_inc_Q'></span><span id='topic+gamma_inc_P'></span><span id='topic+gamma_inc'></span><span id='topic+gsl_sf_beta'></span><span id='topic+lnbeta'></span><span id='topic+beta_inc'></span>

<h3>Description</h3>

<p>Gamma functions as per the Gnu Scientific Library reference manual
section 7.19.  These functions are declared in header file
<code>gsl_sf_gamma.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsl_sf_gamma(x,give=FALSE,strict=TRUE)
lngamma(x,give=FALSE,strict=TRUE)
lngamma_sgn(x,give=FALSE,strict=TRUE)
gammastar(x,give=FALSE,strict=TRUE)
gammainv(x,give=FALSE,strict=TRUE)
lngamma_complex(zr, zi=NULL, r.and.i=TRUE, give=FALSE, strict=TRUE)
taylorcoeff(n,x,give=FALSE,strict=TRUE)
fact(n,give=FALSE,strict=TRUE)
doublefact(n,give=FALSE,strict=TRUE)
lnfact(n,give=FALSE,strict=TRUE)
lndoublefact(n,give=FALSE,strict=TRUE)
gsl_sf_choose(n,m,give=FALSE,strict=TRUE)
lnchoose(n,m,give=FALSE,strict=TRUE)
poch(a,x,give=FALSE,strict=TRUE)
lnpoch(a,x,give=FALSE,strict=TRUE)
lnpoch_sgn(a,x,give=FALSE,strict=TRUE)
pochrel(a,x,give=FALSE,strict=TRUE)
gamma_inc_Q(a,x,give=FALSE,strict=TRUE)
gamma_inc_P(a,x,give=FALSE,strict=TRUE)
gamma_inc(a,x,give=FALSE,strict=TRUE)
gsl_sf_beta(a,b,give=FALSE,strict=TRUE)
lnbeta(a,b,give=FALSE,strict=TRUE)
beta_inc(a,b,x,give=FALSE,strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gamma_+3A_x">x</code>, <code id="Gamma_+3A_a">a</code>, <code id="Gamma_+3A_b">b</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Gamma_+3A_m">m</code>, <code id="Gamma_+3A_n">n</code></td>
<td>
<p>input: integer value</p>
</td></tr>
<tr><td><code id="Gamma_+3A_zr">zr</code></td>
<td>
<p>In <code>gamma_complex()</code>, the real part of the argument</p>
</td></tr>
<tr><td><code id="Gamma_+3A_zi">zi</code></td>
<td>
<p>In <code>gamma_complex()</code>, the imaginary part of the
argument.  If missing (ie takes the default value of <code>NULL</code>),
interpret <code>zr</code> as complex, even if real</p>
</td></tr>
<tr><td><code id="Gamma_+3A_r.and.i">r.and.i</code></td>
<td>
<p>In <code>gamma_complex()</code>, Boolean variable with
default value of <code>TRUE</code> meaning to return a complex variable as
per the details section below; and <code>FALSE</code> meaning to return
the values as advertised in the <abbr><span class="acronym">GSL</span></abbr> manual</p>
</td></tr>
<tr><td><code id="Gamma_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Gamma_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions as documented in the <abbr><span class="acronym">GSL</span></abbr> reference manual section 7.19.
</p>
<p>Note that <code>gamma_inc_P()</code> gives the area of the left tail of the
gamma distribution so, for example, <code>gamma_inc_P(1.8, 5) =
  pgamma(5, 1.8)</code> to numerical accuracy.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>gsl_sf_gamma(3)

lngamma_complex(1+seq(from=0,to=5,by=0.1)*1i)  #table 6.7, p 277 (LH col)
                                               #note 2pi phase diff


jj &lt;- expand.grid(1:10,2:5)
x &lt;- taylorcoeff(jj$Var1,jj$Var2)
dim(x) &lt;- c(10,4)
x    #table 23.5, p818


jj &lt;- expand.grid(36:50,9:13)
x &lt;- gsl_sf_choose(jj$Var1,jj$Var2)
dim(x) &lt;- c(15,5)
x     #table 24.1, p829  (bottom bit)

gamma_inc(1.2,1.3)
beta(1.2, 1.3)
lnbeta(1.2,1.55)
beta_inc(1.2,1.4,1.6)

gamma_inc_P(1.8, 5) - pgamma(5, 1.8)  # should be small

</code></pre>

<hr>
<h2 id='Gegenbauer'>Gegenbauer functions</h2><span id='topic+Gegenbauer'></span><span id='topic+gegenbauer'></span><span id='topic+gegenpoly_1'></span><span id='topic+gegenpoly_2'></span><span id='topic+gegenpoly_3'></span><span id='topic+gegenpoly_n'></span><span id='topic+gegenpoly_array'></span>

<h3>Description</h3>

<p>Gegenbauer functions as per the Gnu Scientific Library reference manual
section 7.20, and AMS-55, chapter 22.  These functions are
declared in header file <code>gsl_sf_gegenbauer.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gegenpoly_1(lambda, x, give=FALSE,strict=TRUE)
gegenpoly_2(lambda, x, give=FALSE,strict=TRUE)
gegenpoly_3(lambda, x, give=FALSE,strict=TRUE)
gegenpoly_n(n,lambda, x, give=FALSE,strict=TRUE)
gegenpoly_array(nmax,lambda, x, give=FALSE,strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gegenbauer_+3A_lambda">lambda</code>, <code id="Gegenbauer_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_n">n</code>, <code id="Gegenbauer_+3A_nmax">nmax</code></td>
<td>
<p>input: integer value</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Gegenbauer_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=-1 ,to=1,len=300)
y &lt;- gegenpoly_array(6,0.5,x)
matplot(x,t(y[-(1:2),]), xlim=c(-1,1.2),ylim=c(-0.5,1.5),
       type="l",xaxt="n",yaxt="n",bty="n",xlab="",ylab="",
       main="Figure 22.5, p777",col="black")
axis(1,pos=0)
axis(2,pos=0)


plot(x, gegenpoly_n(5,lambda=0.2, x,give=FALSE,strict=TRUE),
xlim=c(-1,1),ylim=c(-1.5,1.5),main="Figure 22.5, p777",
type="n",xaxt="n",yaxt="n",bty="n",xlab="",ylab="")
lines(x, gegenpoly_n(5,lambda=0.2, x,give=FALSE,strict=TRUE))
lines(x, gegenpoly_n(5,lambda=0.4, x,give=FALSE,strict=TRUE))
lines(x, gegenpoly_n(5,lambda=0.6, x,give=FALSE,strict=TRUE))
lines(x, gegenpoly_n(5,lambda=0.8, x,give=FALSE,strict=TRUE))
lines(x, gegenpoly_n(5,lambda=1.0, x,give=FALSE,strict=TRUE))
axis(1,pos=0)
axis(2,pos=0,las=1)




</code></pre>

<hr>
<h2 id='gsl-deprecated'>gsl-deprecated</h2><span id='topic+gsl-deprecated'></span><span id='topic+legendre_Plm_array'></span><span id='topic+legendre_Plm_deriv_array'></span><span id='topic+legendre_sphPlm_array'></span><span id='topic+legendre_sphPlm_deriv_array'></span><span id='topic+legendre_array_size'></span><span id='topic+deprecated_legendre'></span>

<h3>Description</h3>

<p>Deprecated Legendre functions as per the Gnu Scientific Library reference manual
section 7.24.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendre_Plm_array(...)
legendre_Plm_deriv_array(...)
legendre_sphPlm_array(...)
legendre_sphPlm_deriv_array(...)
legendre_array_size(...)
deprecated_legendre(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsl-deprecated_+3A_...">...</code></td>
<td>
<p>(ignored)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>As of GSL-2.1, functions
</p>

<ul>
<li><p><code>gsl_sf_legendre_Plm_array</code>
</p>
</li>
<li><p><code>gsl_sf_legendre_Plm_deriv_array</code>
</p>
</li>
<li><p><code>gsl_sf_legendre_sphPlm_array</code>
</p>
</li>
<li><p><code>gsl_sf_legendre_sphPlm_deriv_array</code>
</p>
</li>
<li><p><code>gsl_sf_legendre_array_size</code>
</p>
</li></ul>

<p>are deprecated.  This functionality is now provided in GSL by the
<code>gsl_sf_legendre_array</code> suite of functions; in <span class="rlang"><b>R</b></span>, use one of:
</p>

<ul>
<li><p><code>legendre_array()</code>
</p>
</li>
<li><p><code>legendre_deriv_array()</code>
</p>
</li>
<li><p><code>legendre_deriv_alt_array()</code>
</p>
</li>
<li><p><code>legendre_deriv2_array()</code>
</p>
</li>
<li><p><code>legendre_deriv2_alt_array()</code>.
</p>
</li></ul>

<p>These are documented under <code>?Legendre</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Legendre">Legendre</a></code></p>

<hr>
<h2 id='Hyperg'>Hypergeometric functions</h2><span id='topic+Hyperg'></span><span id='topic+hyperg'></span><span id='topic+hyperg_0F1'></span><span id='topic+hyperg_1F1_int'></span><span id='topic+hyperg_1F1'></span><span id='topic+hyperg_U_int'></span><span id='topic+hyperg_U'></span><span id='topic+hyperg_2F1'></span><span id='topic+hyperg_2F1_conj'></span><span id='topic+hyperg_2F1_renorm'></span><span id='topic+hyperg_2F1_conj_renorm'></span><span id='topic+hyperg_2F0'></span>

<h3>Description</h3>

<p>Hypergeometric functions as per the Gnu Scientific Library reference manual
section 7.21 and AMS-55, chapters 13 and 15.  These functions are
declared in header file <code>gsl_sf_hyperg.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperg_0F1(c, x, give=FALSE, strict=TRUE)
hyperg_1F1_int(m, n, x, give=FALSE, strict=TRUE)
hyperg_1F1(a, b, x, give=FALSE, strict=TRUE)
hyperg_U_int(m, n, x, give=FALSE, strict=TRUE)
hyperg_U(a, b, x, give=FALSE, strict=TRUE)
hyperg_2F1(a, b, c, x, give=FALSE, strict=TRUE)
hyperg_2F1_conj(aR, aI, c, x, give=FALSE, strict=TRUE)
hyperg_2F1_renorm(a, b, c, x, give=FALSE, strict=TRUE)
hyperg_2F1_conj_renorm(aR, aI, c, x, give=FALSE, strict=TRUE)
hyperg_2F0(a, b, x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hyperg_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Hyperg_+3A_a">a</code>, <code id="Hyperg_+3A_b">b</code>, <code id="Hyperg_+3A_c">c</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Hyperg_+3A_m">m</code>, <code id="Hyperg_+3A_n">n</code></td>
<td>
<p>input: integer values</p>
</td></tr>
<tr><td><code id="Hyperg_+3A_ar">aR</code>, <code id="Hyperg_+3A_ai">aI</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Hyperg_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number.</p>
</td></tr>
<tr><td><code id="Hyperg_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&ldquo;The circle of convergence of the Gauss hypergeometric series
is the unit circle <code class="reqn">|z|=1</code>&rdquo; (AMS, page 556).
</p>
<p>There is a known issue in <code>hyperg_2F1()</code> in GSL-2.6,
<a href="https://savannah.gnu.org/bugs/?54998">https://savannah.gnu.org/bugs/?54998</a> and the package returns the
erroneous value given by GSL.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
hyperg_0F1(0.1,0.55)

hyperg_1F1_int(2,3,0.555)
hyperg_1F1(2.12312,3.12313,0.555)
hyperg_U_int(2, 3, 0.555)
hyperg_U(2.234, 3.234, 0.555)
</code></pre>

<hr>
<h2 id='Laguerre'>Laguerre functions</h2><span id='topic+Laguerre'></span><span id='topic+laguerre'></span><span id='topic+laguerre_1'></span><span id='topic+laguerre_2'></span><span id='topic+laguerre_3'></span><span id='topic+laguerre_n'></span>

<h3>Description</h3>

<p>Laguerre functions as per the Gnu Scientific Library reference manual
section 7.22.  These functions are declared in header file
<code>gsl_sf_laguerre.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laguerre_1(a, x, give=FALSE, strict=TRUE)
laguerre_2(a, x, give=FALSE, strict=TRUE)
laguerre_3(a, x, give=FALSE, strict=TRUE)
laguerre_n(n, a, x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Laguerre_+3A_a">a</code>, <code id="Laguerre_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Laguerre_+3A_n">n</code></td>
<td>
<p>input: integer values</p>
</td></tr>
<tr><td><code id="Laguerre_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Laguerre_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=6,len=100)
plot(x,laguerre_n(2,0,x),xlim=c(0,6),ylim=c(-2,3),
          type="l",xaxt="n",yaxt="n",bty="n",xlab="",ylab="",
          main="Figure 22.9, p780")

lines(x,laguerre_n(3,0,x))
lines(x,laguerre_n(4,0,x))
lines(x,laguerre_n(5,0,x))
axis(1,pos=0)
axis(2,pos=0)

  </code></pre>

<hr>
<h2 id='Lambert'>Lambert's W function</h2><span id='topic+Lambert'></span><span id='topic+lambert'></span><span id='topic+lambert_W0'></span><span id='topic+lambert_Wm1'></span><span id='topic+Lambert_W0'></span><span id='topic+Lambert_Wm1'></span>

<h3>Description</h3>

<p>Lambert's W function as per the Gnu Scientific Library reference manual
section 7.23.  These functions are declared in header file
<code>gsl_sf_lambert.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambert_W0(x, give=FALSE, strict=TRUE)
lambert_Wm1(x, give=FALSE,strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lambert_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Lambert_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Lambert_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- runif(6)
L &lt;- lambert_W0(a)
print(L*exp(L) - a)
</code></pre>

<hr>
<h2 id='Legendre'>Legendre functions</h2><span id='topic+Legendre'></span><span id='topic+legendre'></span><span id='topic+legendre_P1'></span><span id='topic+legendre_P2'></span><span id='topic+legendre_P3'></span><span id='topic+legendre_Pl'></span><span id='topic+legendre_Pl_array'></span><span id='topic+legendre_Q0'></span><span id='topic+legendre_Q1'></span><span id='topic+legendre_Ql'></span><span id='topic+legendre_array_n'></span><span id='topic+legendre_array_index'></span><span id='topic+legendre_check_args'></span><span id='topic+legendre_array'></span><span id='topic+legendre_deriv_array'></span><span id='topic+legendre_deriv_alt_array'></span><span id='topic+legendre_deriv2_array'></span><span id='topic+legendre_deriv2_alt_array'></span><span id='topic+legendre_Plm'></span><span id='topic+legendre_sphPlm'></span><span id='topic+conicalP_half'></span><span id='topic+conicalP_mhalf'></span><span id='topic+conicalP_0'></span><span id='topic+conicalP_1'></span><span id='topic+conicalP_sph_reg'></span><span id='topic+conicalP_cyl_reg'></span><span id='topic+legendre_H3d_0'></span><span id='topic+legendre_H3d_1'></span><span id='topic+legendre_H3d'></span><span id='topic+legendre_H3d_array'></span><span id='topic+conical'></span><span id='topic+Conical'></span>

<h3>Description</h3>

<p>Legendre functions as per the Gnu Scientific Library reference manual
section 7.24, and AMS-55, chapter 8.  These functions are declared in
header file <code>gsl_sf_legendre.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legendre_P1(x, give=FALSE, strict=TRUE)
legendre_P2(x, give=FALSE, strict=TRUE)
legendre_P3(x, give=FALSE, strict=TRUE)
legendre_Pl(l, x, give=FALSE, strict=TRUE)
legendre_Pl_array(lmax, x, give=FALSE, strict=TRUE)
legendre_Q0(x, give=FALSE, strict=TRUE)
legendre_Q1(x, give=FALSE, strict=TRUE)
legendre_Ql(l, x, give=FALSE, strict=TRUE)
legendre_array_n(lmax)
legendre_array_index(l,m)
legendre_check_args(x,lmax,norm,csphase)
legendre_array(x, lmax, norm=1, csphase= -1)
legendre_deriv_array(x, lmax, norm=1, csphase= -1)
legendre_deriv_alt_array(x, lmax, norm=1, csphase= -1)
legendre_deriv2_array(x, lmax, norm=1, csphase= -1)
legendre_deriv2_alt_array(x, lmax, norm=1, csphase= -1)
legendre_Plm(l, m, x, give=FALSE, strict=TRUE)
legendre_sphPlm(l, m, x, give=FALSE, strict=TRUE)
conicalP_half(lambda, x, give=FALSE, strict=TRUE)  
conicalP_mhalf(lambda, x, give=FALSE, strict=TRUE)  
conicalP_0(lambda, x, give=FALSE, strict=TRUE)  
conicalP_1(lambda, x, give=FALSE, strict=TRUE)  
conicalP_sph_reg(l, lambda, x, give=FALSE, strict=TRUE)  
conicalP_cyl_reg(m, lambda, x, give=FALSE, strict=TRUE)
legendre_H3d_0(lambda, eta, give=FALSE, strict=TRUE)
legendre_H3d_1(lambda, eta, give=FALSE, strict=TRUE)
legendre_H3d(l, lambda, eta, give=FALSE, strict=TRUE)
legendre_H3d_array(lmax, lambda, eta, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Legendre_+3A_eta">eta</code>, <code id="Legendre_+3A_lambda">lambda</code>, <code id="Legendre_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Legendre_+3A_l">l</code>, <code id="Legendre_+3A_m">m</code>, <code id="Legendre_+3A_lmax">lmax</code></td>
<td>
<p>input: integer values</p>
</td></tr>
<tr><td><code id="Legendre_+3A_csphase">csphase</code>, <code id="Legendre_+3A_norm">norm</code></td>
<td>
<p>Options for use with <code>legendre_array()</code></p>
</td></tr>
<tr><td><code id="Legendre_+3A_give">give</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
return just the answers, and <code>TRUE</code> meaning to return a status
vector as well</p>
</td></tr>
<tr><td><code id="Legendre_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if nonzero status is returned by the <abbr><span class="acronym">GSL</span></abbr> function (<code>FALSE</code>
means to return the value: use with caution)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> theta &lt;- seq(from=0,to=pi/2,len=100)
 plot(theta,legendre_P1(cos(theta)),type="l",ylim=c(-0.5,1), main="Figure 8.1, p338")
 abline(1,0)
 lines(theta,legendre_P2(cos(theta)),type="l")
 lines(theta,legendre_P3(cos(theta)),type="l")

x &lt;- seq(from=0,to=1,len=600)
plot(x, legendre_Plm(3,1,x), type="l",lty=3,main="Figure 8.2, p338: note sign error")
lines(x,legendre_Plm(2,1,x), type="l",lty=2)
lines(x,legendre_Plm(1,1,x), type="l",lty=1)
abline(0,0)


plot(x,legendre_Ql(0,x),xlim=c(0,1), ylim=c(-1,1.5), type="l",lty=1,
main="Figure 8.4, p339")
lines(x,legendre_Ql(1,x),lty=2)
lines(x,legendre_Ql(2,x),lty=3)
lines(x,legendre_Ql(3,x),lty=4)
abline(0,0)

#table 8.1 of A&amp;S:
t(legendre_Pl_array(10, seq(from=0,to=1,by=0.01))[1+c(2,3,9,10),])

#table 8.3:
f &lt;- function(n){legendre_Ql(n, seq(from=0,to=1,by=0.01))}
sapply(c(0,1,2,3,9,10),f)


# Some checks for the legendre_array() series:

# P_6^1(0.3):
legendre_array(0.3,7)[7,2]         # MMA:  LegendreP[6,1,0.3]; note off-by-one issue

# d/dx  P_8^5(x) @ x=0.2:
legendre_deriv_array(0.2,8)[9,6]   # MMA: D[LegendreP[8,5,x],x] /. {x -&gt; 0.2}


# alternative derivatives:
 legendre_deriv_alt_array(0.4,8)[9,6]  # D[LegendreP[8,5,Cos[x]],x] /. x -&gt; ArcCos[0.4] 



</code></pre>

<hr>
<h2 id='Log'>Log functions</h2><span id='topic+Log'></span><span id='topic+log'></span><span id='topic+gsl_sf_log'></span><span id='topic+log_abs'></span><span id='topic+complex_log'></span><span id='topic+log_1plusx'></span><span id='topic+log_1plusx_mx'></span>

<h3>Description</h3>

<p>Log functions as per the Gnu Scientific Library, reference manual
section 7.25 and AMS-55, chapter 4.  These functions are declared in
header file <code>gsl_sf_log.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsl_sf_log(x, give=FALSE, strict=TRUE)
log_abs(x, give=FALSE, strict=TRUE)
complex_log(zr, zi=NULL, r.and.i=TRUE, give=FALSE, strict=TRUE)
log_1plusx(x, give=FALSE, strict=TRUE)
log_1plusx_mx(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Log_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Log_+3A_zr">zr</code></td>
<td>
<p>In <code>complex_log()</code>, the real part of the argument</p>
</td></tr>
<tr><td><code id="Log_+3A_zi">zi</code></td>
<td>
<p>In <code>complex_log()</code>, the imaginary part of the
argument.  If missing (ie takes the default value of <code>NULL</code>),
interpret <code>zr</code> as complex, even if real</p>
</td></tr>
<tr><td><code id="Log_+3A_r.and.i">r.and.i</code></td>
<td>
<p>In <code>complex_log()</code>, Boolean variable with
default value of <code>TRUE</code> meaning to return a complex variable as
per the details section below; and <code>FALSE</code> meaning to return
the values as advertised in the <abbr><span class="acronym">GSL</span></abbr> manual</p>
</td></tr>
<tr><td><code id="Log_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Log_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0.1,to=2,by=0.01)
log(x)   #table 7.5 of Ab and St
</code></pre>

<hr>
<h2 id='Misc'>Argument processing and general info</h2><span id='topic+Misc'></span><span id='topic+misc'></span><span id='topic+process.args'></span><span id='topic+strictify'></span>

<h3>Description</h3>

<p>Various widely used functions in the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.args(...)
strictify(val,status)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Misc_+3A_...">...</code></td>
<td>
<p>Argument list to be coerced to the same length</p>
</td></tr>
<tr><td><code id="Misc_+3A_val">val</code></td>
<td>
<p>Value component of <code>&amp;result</code></p>
</td></tr>
<tr><td><code id="Misc_+3A_status">status</code></td>
<td>
<p>status integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>process.args()</code> is an internal function used to
massage the arguments into a form suitable for passing to <code>.C()</code>.
For example, in function <code>hyperg_0F1(c,x)</code>, one wants each of 
<code>hyperg_0F1(0.1, c(0.3,0.4))</code> and <code>hyperg_0F1(c(0.1,0.2),
  0.3)</code> and <code>hyperg_0F1(c(0.1,0.2),c(0.3,0.4))</code> to behave sensibly.
</p>
<p>Function <code>process.args()</code> is used widely in the package, taking an
arbitrary number of arguments and returning a list whose elements are
vectors of the same length.  Most of the special functions use
<code>process.args()</code> to ensure that the returned value takes the
attributes of the input argument with most elements where possible.
</p>
<p>Function <code>strictify()</code> uses the <code>status</code> value returned by
the &ldquo;error&rdquo; form of the <abbr><span class="acronym">GSL</span></abbr> special functions to make values
returned with a nonzero <code>error</code> a <code>NaN</code>.  In most of the
special functions, <code>strictify()</code> is called if argument
<code>strict</code> takes its default value of <code>TRUE</code>.  Setting it to
<code>FALSE</code> sometimes returns a numerical value as per the <abbr><span class="acronym">GSL</span></abbr>
reference manual.
</p>
<p>In most of the special functions, if argument <code>give</code> takes its
default value of <code>FALSE</code>, only a numerical value is returned.
If <code>TRUE</code>, error information and the status (see preceding
paragraph) is also returned.
</p>
<p>Following tips found on R-devel:
</p>

<ol>
<li><p> Download and extract source code of R-package <span class="pkg">gsl</span>
</p>
</li>
<li><p> Use <code>gsl-config --libs</code> to get the path to <abbr><span class="acronym">GSL</span></abbr>'s
lib directory  
(<code>-L&lt;path-to-lib&gt;</code>), use <code>gsl-config --cflags</code>  to get the
path to <code>GSL</code>'s include directory (<code>-I&lt;path-to-include&gt;</code>)
</p>
</li>
<li><p> Change <code>Makevars</code> in <code>gsl/src</code>:
</p>

<ul>
<li><p> Add <code>-L&lt;path-to-lib&gt;</code> to <code>PKG_LIBS</code>
</p>
</li>
<li><p> Add (new) line: <code>PKG_CPPFLAGS=-I&lt;path-to-include&gt;</code>
</p>
</li></ul>

</li>
<li><p> Install <code>gsl</code> via
</p>
<p><code>LDFLAGS=-L&lt;path-to-lib&gt;; export LDFLAGS</code>
</p>
<p><code>CPPFLAGS=-I&lt;path-to-include&gt;;export CPPFLAGS</code>
</p>
<p><code>R CMD INSTALL gsl</code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>

<hr>
<h2 id='multimin'>Function minimization</h2><span id='topic+Multimin'></span><span id='topic+multimin'></span><span id='topic+multimin.init'></span><span id='topic+multimin.iterate'></span><span id='topic+multimin.restart'></span><span id='topic+multimin.fminimizer.size'></span>

<h3>Description</h3>

<p><em>These functions have been removed from the package temporarily,
pending a permanent fix.</em>
</p>
<p>Function minimization using the Gnu Scientific Library, reference
manual section 35.  These functions are declared in header file
<code>gsl_multimin.h</code>
</p>
<p>Several algorithms for finding (local) minima of functions in one or
more variables are provided.  All of the algorithms operate locally,
in the sense that they maintain a best guess and require the function
to be continuous.  Apart from the Nelder-Mead algorithm, these
algorithms also use a derivative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multimin(..., prec=0.0001)
multimin.init(x, f, df=NA, fdf=NA, method=NA, step.size=NA, tol=NA)
multimin.iterate(state)
multimin.restart(state)
multimin.fminimizer.size(state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multimin_+3A_...">...</code></td>
<td>
<p>In function <code>multimin()</code>, the argument list passed to
<code>multimin.init()</code></p>
</td></tr>
<tr><td><code id="multimin_+3A_x">x</code></td>
<td>
<p>A starting point.  These algorithms are faster with better
initial guesses</p>
</td></tr>
<tr><td><code id="multimin_+3A_f">f</code></td>
<td>
<p>The function to minimize.  This function must take a single
<code>numeric</code> vector as input, and output a <code>numeric</code> scalar</p>
</td></tr>
<tr><td><code id="multimin_+3A_df">df</code></td>
<td>
<p>The derivative of <code>f</code>.  This is required for all algorithms
except Nelder-Mead</p>
</td></tr>
<tr><td><code id="multimin_+3A_fdf">fdf</code></td>
<td>
<p>A function that evaluates <code>f</code> and <code>df</code> simultaneously.
This is optional, and is only useful if simultaneous evaluation is faster</p>
</td></tr>
<tr><td><code id="multimin_+3A_method">method</code></td>
<td>
<p>The algorithm to use, which is one of
&ldquo;<code>conjugate-fr</code>&rdquo;, &ldquo;<code>conjugate-pr</code>&rdquo;,
&ldquo;<code>bfgs</code>&rdquo;, &ldquo;<code>steepest-descent</code>&rdquo; and
&ldquo;<code>nm</code>&rdquo;</p>
</td></tr>
<tr><td><code id="multimin_+3A_step.size">step.size</code></td>
<td>
<p>This step size guides the algorithm to pick a good
distance between points in its search</p>
</td></tr>
<tr><td><code id="multimin_+3A_tol">tol</code></td>
<td>
<p>This parameter is relevant for gradient-based methods.  It
controls how much the gradient should flatten out in each line
search.  More specifically, let <code class="reqn">u(t) = f(x + st)</code> be the
function restricted to the search ray.  Then a point <code class="reqn">t</code> is
tolerable if <code class="reqn">u'(t) &lt; tol u'(0)</code>.  Higher values give more lax
linesearches.  This parameter trades-off searching intensively in
the outer loop (finding search directions) versus the inner loop
(finding a good point in a particular direction)</p>
</td></tr>
<tr><td><code id="multimin_+3A_prec">prec</code></td>
<td>
<p>The stopping-rule precision parameter.  For the derivative-based
methods, a solution is good enough if the norm of the gradient is smaller
than <code>prec</code>.  For the non-derivative-based methods, a solution is good
enough if the norm of successive solutions is smaller than <code>prec</code></p>
</td></tr>
<tr><td><code id="multimin_+3A_state">state</code></td>
<td>
<p>This stores all information relating to the progress of
the optimization problem</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways to call <code>multimin</code>.  The simple way is to
merely call <code>multimin</code> directly.  A more complicated way is to
call <code>multimin.init</code> first, and then repeatedly call
<code>multimin.iterate</code> until the guess gets good enough.  In
addition, <code>multimin.restart</code> can be used with the second approach
to discard accumulated information (such as curvature information) if
that information turns out to be unhelpful.  This is roughly
equivalent to calling <code>multimin.init</code> by setting the starting
point to be the current best guess.
</p>
<p>All of the derivative-based methods consist of iterations that pick a
descent direction, and conduct a line search for a better point along
the ray in that direction from the current point.  The Fletcher-Reeves
and Polak-Ribiere conjugate gradient algorithms maintain a a vector
that summarizes the curvature at that point.  These are useful for
high-dimensional problems (eg: more than 100 dimensions) because they
don't use matrices which become expensive to keep track of.  The
Broyden-Fletcher-Goldfarb-Shanno is better for low-dimensional
problems, since it maintains an approximation of the Hessian of the
function as well, which gives better curvature information.  The
steepest-descent algorithm is a naive algorithm that does not use any
curvature information.  The Nelder-Mead algorithm which does not use
derivatives.
</p>


<h3>Value</h3>

<p>All of these functions return a state variable, which consists
of the following items:
</p>
<table>
<tr><td><code>internal.state</code></td>
<td>
<p>Bureaucratic stuff for communicating with <abbr><span class="acronym">GSL</span></abbr></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The current best guess of the optimal solution</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>The value of the function at the best guess</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The derivative of the function at the best guess</p>
</td></tr>
<tr><td><code>is.fdf</code></td>
<td>
<p>TRUE if the algorithm is using a derivative</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>The <abbr><span class="acronym">GSL</span></abbr> return code from the last iteration</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The source code for the functions documented here conditionalizes
on <code>WIN32</code>; under windows there is a slight memory leak.</p>


<h3>Author(s)</h3>

<p>Andrew Clausen <a href="mailto:clausen@econ.upenn.edu">clausen@econ.upenn.edu</a></p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>See Also</h3>

<p><code>optim</code> and <code>nlm</code> are the standard optimization functions in
R.
</p>
<p><code>deriv</code> and <code>D</code> are the standard symbolic differentation
functions in R.  <code>Ryacas</code> provides more extensive differentiation
support using Yet Another Computer Algebra System.
</p>
<p><code>numericDeriv</code> is the standard numerical differentation function
in R.  <abbr><span class="acronym">GSL</span></abbr> can also do numerical differentiation, but no-one has
written an R interface yet.
</p>
<p><code>multimin</code> requires the objective function to have a single
(vector) argument. <code>unlist</code> and <code>relist</code> are useful for
converting between more convenient forms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# COMMENTED OUT PENDING PERMANENT FIX
# The Rosenbrock function:

# x0 &lt;- c(-1.2, 1)
# f &lt;- function(x) (1 - x[1])^2 + 100 * (x[2] - x[1]^2)^2
# df &lt;- function(x) c(-2*(1 - x[1]) + 100 * 2 * (x[2] - x[1]^2) * (-2*x[1]),
#                     100 * 2 * (x[2] - x[1]^2))
# 
# # The simple way to call multimin.
# state &lt;- multimin(x0, f, df)
# print(state$x)
# 
# # The fine-control way to call multimin.
# state &lt;- multimin.init(x0, f, df, method="conjugate-fr")
# for (i in 1:200)
# 	state &lt;- multimin.iterate(state)
# print(state$x)

</code></pre>

<hr>
<h2 id='Poly'>Polynomials</h2><span id='topic+Poly'></span><span id='topic+poly'></span><span id='topic+gsl_poly'></span>

<h3>Description</h3>

<p>Polynomial functions as per the Gnu Scientific Library, reference manual
section 6.1.  These functions are defined in header
file <code>gsl_poly.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsl_poly(c_gsl,x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Poly_+3A_c_gsl">c_gsl</code></td>
<td>
<p>Coefficients of the poynomial (<code>c</code> in the function
definition and the <abbr><span class="acronym">GSL</span></abbr> ref manual) starting at the constant term and
ending in the highest power; see details section.  This argument is
called &ldquo;<code>c_gsl</code>&rdquo; (and not &ldquo;<code>c</code>&rdquo;) to avoid
confusion with <span class="rlang"><b>R</b></span> function <code>c()</code></p>
</td></tr>
<tr><td><code id="Poly_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One must be careful to avoid off-by-one errors.  In C idiom, the
function evaluates the polynomial
</p>
<p style="text-align: center;"><code class="reqn">c[0]+c[1]x+c[2]x^2+\ldots+c[\mathrm{len}-1]x^{\mathrm{len}-1}</code>
</p>

<p>where len is the second argument of <abbr><span class="acronym">GSL</span></abbr> function
<code>gsl_poly_eval()</code>.
</p>
<p>The <span class="rlang"><b>R</b></span> idiom would be
</p>
<p style="text-align: center;"><code class="reqn">c[1]+c[2]x+c[3]x^2+\ldots+c[\mathrm{len}]x^{\mathrm{len}-1}.</code>
</p>

<p>This section is work-in-progress and more will be added when I have
the time/need for the other functions here.  
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:4,2,2)
rownames(a) &lt;- letters[1:2]
(jj &lt;- gsl_poly(1:3,a))

jj-(1 + 2*a + 3*a^2)  #should be small
</code></pre>

<hr>
<h2 id='Powint'>Power functions</h2><span id='topic+pow_int'></span><span id='topic+Pow_int'></span><span id='topic+powint'></span>

<h3>Description</h3>

<p>Power functions as per the Gnu Scientific Library reference manual
section 7.27.  These functions are declared in the header file
<code>gsl_sf_pow_int.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow_int(x, n, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Powint_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Powint_+3A_n">n</code></td>
<td>
<p>input: integer  values</p>
</td></tr>
<tr><td><code id="Powint_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Powint_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>pow_int(pi/2,1:10)   
</code></pre>

<hr>
<h2 id='Psi'>Psi (digamma) functions</h2><span id='topic+Psi'></span><span id='topic+psi_int'></span><span id='topic+psi'></span><span id='topic+psi_1piy'></span><span id='topic+psi_1_int'></span><span id='topic+psi_1'></span><span id='topic+psi_n'></span>

<h3>Description</h3>

<p>Psi (digamma) functions as per the Gnu Scientific Library, reference
manual section 7.27.  These functions are declared in header file
<code>gsl_sf_psi.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_int(n, give=FALSE, strict=TRUE)
psi(x, give=FALSE, strict=TRUE)
psi_1piy(y, give=FALSE, strict=TRUE)
psi_1_int(n, give=FALSE, strict=TRUE)
psi_1(x, give=FALSE, strict=TRUE)
psi_n(m, x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Psi_+3A_m">m</code>, <code id="Psi_+3A_n">n</code></td>
<td>
<p>input: integer values</p>
</td></tr>
<tr><td><code id="Psi_+3A_x">x</code>, <code id="Psi_+3A_y">y</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Psi_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Psi_+3A_strict">strict</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=1.2,to=1.25,by=0.005)
cbind(x,psi(x),psi_1(x))
#tabe 6.1, p267, bottom bit

psi_int(1:6)
psi(pi+(1:6))
psi_1piy(pi+(1:6))
psi_1_int(1:6)
psi_n(m=5,x=c(1.123,1.6523))

</code></pre>

<hr>
<h2 id='Qrng'>Quasi-random sequences</h2><span id='topic+Qrng'></span><span id='topic+qrng'></span><span id='topic+qrng_alloc'></span><span id='topic+qrng_clone'></span><span id='topic+qrng_init'></span><span id='topic+qrng_name'></span><span id='topic+qrng_size'></span><span id='topic+qrng_get'></span>

<h3>Description</h3>

<p>Quasi-random sequences as per the Gnu Scientific Library, reference
manual section 18.  These functions are declared in header file
<code>gsl_qrng.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qrng_alloc(type = c("niederreiter_2", "sobol"), dim)
qrng_clone(q)
qrng_init(q)
qrng_name(q)
qrng_size(q)
qrng_get(q, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qrng_+3A_type">type</code></td>
<td>
<p>Type of sequence</p>
</td></tr>
<tr><td><code id="Qrng_+3A_dim">dim</code></td>
<td>
<p>Dimension of sequence</p>
</td></tr>
<tr><td><code id="Qrng_+3A_q">q</code></td>
<td>
<p>Generator from <code>qrng_alloc</code> or <code>qrng_clone</code></p>
</td></tr>
<tr><td><code id="Qrng_+3A_n">n</code></td>
<td>
<p>How many vectors to generate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are wrappers for the quasi-random sequence
functions from the <abbr><span class="acronym">GSL</span></abbr> <a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a> with
arguments corresponding to those from the library, with a few exceptions.
In particular:  I have used <code>dim</code> where the <abbr><span class="acronym">GSL</span></abbr> uses just <code>d</code>;
I have added the <code>n</code> argument to the <code>qrng_get</code> function, so that
a single call can generate <code>n</code> vectors; I have not provided <span class="rlang"><b>R</b></span>
functions corresponding to <code>qrng_free</code> (because <span class="rlang"><b>R</b></span> will automatically
free the generator when it is garbage collected) or <code>qrng_state</code> or
<code>qrng_memcpy</code> (because these don't make sense within <span class="rlang"><b>R</b></span>.)
</p>


<h3>Value</h3>

<p><code>qrng_alloc</code>, <code>qrng_clone</code> and <code>qrng_init</code> return an external pointer
to the C structure representing the generator.  The internals of this structure
are not accessible from within <span class="rlang"><b>R</b></span>.
</p>
<p><code>qrng_name</code> returns a character vector giving the name of the generator.
</p>
<p><code>qrng_size</code> returns an integer value giving the internal memory
usage of the generator.  
</p>
<p><code>qrng_get</code> returns a matrix with <code>n</code> rows and <code>dim</code> columns.
Each row is a vector in the quasi-random sequence.
</p>


<h3>Author(s)</h3>

<p> Duncan Murdoch </p>


<h3>References</h3>

 <p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>q &lt;- qrng_alloc(dim = 2)
qrng_name(q)
qrng_get(q, 10)
</code></pre>

<hr>
<h2 id='Rng'>Random numbers generation</h2><span id='topic+Rng'></span><span id='topic+rng'></span><span id='topic+rng_alloc'></span><span id='topic+rng_clone'></span><span id='topic+rng_max'></span><span id='topic+rng_min'></span><span id='topic+rng_name'></span><span id='topic+rng_set'></span><span id='topic+rng_get'></span><span id='topic+rng_uniform'></span><span id='topic+rng_uniform_int'></span><span id='topic+rng_uniform_pos'></span>

<h3>Description</h3>

<p>Random number generation with the Gnu Scientific Library,
as per the reference manual section 17</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng_alloc(type)
rng_clone(r)
rng_name(r)
rng_max(r)
rng_min(r)
rng_set(r, seed)
rng_get(r, length)
rng_uniform(r, length)
rng_uniform_int(r, N, length)
rng_uniform_pos(r, length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rng_+3A_type">type</code></td>
<td>
<p>In function <code>rng_alloc()</code>, type of random number generator.
This argument is taken to be a character string which is matched to
the names of the random number generators given in the <abbr><span class="acronym">GSL</span></abbr> manual
section 17.9, with the initial &ldquo;<code>gsl_rng_</code>&rdquo; removed
(for example, to use generator <code>gsl_rng_ranlux</code>, set
<code>type</code> to <code>ranlux</code>).  Partial matching is used; a null
string is interpreted as <code>mt19937</code>.</p>
</td></tr>
<tr><td><code id="Rng_+3A_r">r</code></td>
<td>
<p>Instance of a random number generator.  Generate this using
function <code>rng_alloc()</code>.</p>
</td></tr>
<tr><td><code id="Rng_+3A_seed">seed</code></td>
<td>
<p>Random number seed</p>
</td></tr>
<tr><td><code id="Rng_+3A_length">length</code></td>
<td>
<p>Length of vector of random numbers to create</p>
</td></tr>
<tr><td><code id="Rng_+3A_n">N</code></td>
<td>
<p>In function <code>rng_uniform_int()</code>,  upper bound of
uniform distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are wrappers for the random number generator
functions from the <abbr><span class="acronym">GSL</span></abbr> <a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a> with
arguments corresponding to those from the library.
Calling <code>rng_free</code> is not necessary as R performs garbage
collection automatically.
</p>
<p>The functions that return random numbers (<code>rng_get</code>,
<code>rng_uniform</code>, <code>rng_uniform_int</code>, <code>rng_uniform_pos</code>)
take an extra argument that specifies the length of the vector of
random numbers to be returned.
</p>


<h3>Value</h3>

<p>Function <code>rng_alloc()</code> returns an external pointer to a <abbr><span class="acronym">GSL</span></abbr> random
number generator.
</p>


<h3>Author(s)</h3>

<p>Max Bruche</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rng_alloc("cmrg")
rng_set(r, 100)
rng_uniform(r, 10)
</code></pre>

<hr>
<h2 id='Synchrotron'>Synchrotron functions</h2><span id='topic+Synchrotron'></span><span id='topic+synchrotron'></span><span id='topic+synchrotron_1'></span><span id='topic+synchrotron_2'></span>

<h3>Description</h3>

<p>Synchrotron functions as per the Gnu Scientific Library, reference
section 7.29.  These functions are declared in header file
<code>gsl_sf_synchrotron.h</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synchrotron_1(x, give=FALSE, strict=TRUE)
synchrotron_2(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Synchrotron_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Synchrotron_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Synchrotron_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=2,by=0.01)
synchrotron_1(x)
synchrotron_2(x)   
</code></pre>

<hr>
<h2 id='Transport'>Transport functions</h2><span id='topic+Transport'></span><span id='topic+transport'></span><span id='topic+transport_2'></span><span id='topic+transport_3'></span><span id='topic+transport_4'></span><span id='topic+transport_5'></span>

<h3>Description</h3>

<p>Transport functions as per the Gnu Scientific Library, reference manual 
section 7.29.  These functions are defined in header file
<code>gsl_sf_transport.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transport_2(x, give=FALSE, strict=TRUE)
transport_3(x, give=FALSE, strict=TRUE)
transport_4(x, give=FALSE, strict=TRUE)
transport_5(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Transport_+3A_x">x</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Transport_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number.</p>
</td></tr>
<tr><td><code id="Transport_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=2,by=0.01)
transport_2(x)
transport_3(x)   
</code></pre>

<hr>
<h2 id='Trig'>Trig functions</h2><span id='topic+Trig'></span><span id='topic+trig'></span><span id='topic+gsl_sf_sin'></span><span id='topic+gsl_sf_cos'></span><span id='topic+hypot'></span><span id='topic+sinc'></span><span id='topic+complex_sin'></span><span id='topic+complex_cos'></span><span id='topic+complex_logsin'></span><span id='topic+lnsinh'></span><span id='topic+lncosh'></span>

<h3>Description</h3>

<p>Trig functions as per the Gnu Scientific Library, reference manual
section 7.30.  These functions are declared in header file
<code>gsl_sf_trig.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsl_sf_sin(x, give=FALSE, strict=TRUE)
gsl_sf_cos(x, give=FALSE, strict=TRUE)
hypot(x, y, give=FALSE, strict=TRUE)
sinc(x, give=FALSE, strict=TRUE)
complex_sin(zr, zi=NULL, r.and.i=TRUE, give=FALSE, strict=TRUE)
complex_cos(zr, zi=NULL, r.and.i=TRUE, give=FALSE, strict=TRUE)
lnsinh(x, give=FALSE, strict=TRUE)
lncosh(x, give=FALSE, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trig_+3A_x">x</code>, <code id="Trig_+3A_y">y</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Trig_+3A_zr">zr</code></td>
<td>
<p>In <code>gamma_complex()</code>, the real part of the argument</p>
</td></tr>
<tr><td><code id="Trig_+3A_zi">zi</code></td>
<td>
<p>In <code>complex_sin()</code> et seq, the imaginary part of the
argument.  If missing (ie takes the default value of <code>NULL</code>),
interpret <code>zr</code> as complex, even if real</p>
</td></tr>
<tr><td><code id="Trig_+3A_r.and.i">r.and.i</code></td>
<td>
<p>In <code>complex_sin()</code> et seq, Boolean variable with
default value of <code>TRUE</code> meaning to return a complex variable as
per the details section below; and <code>FALSE</code> meaning to return
the values as advertised in the <abbr><span class="acronym">GSL</span></abbr> manual</p>
</td></tr>
<tr><td><code id="Trig_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number</p>
</td></tr>
<tr><td><code id="Trig_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(from=0,to=2,by=0.01)
gsl_sf_sin(x)   #table xx of Ab and St
gsl_sf_cos(x)   #table xx of Ab and St

f &lt;- function(x){abs(sin(x+1)-sin(x)*cos(1)-cos(x)*sin(1))}
g &lt;-
function(x){abs(gsl_sf_sin(x+1)-gsl_sf_sin(x)*gsl_sf_cos(1)-gsl_sf_cos(x)*gsl_sf_sin(1))}

f(100000:100010)
g(100000:100010)


</code></pre>

<hr>
<h2 id='Zeta'>Zeta functions</h2><span id='topic+Zeta'></span><span id='topic+zeta_int'></span><span id='topic+zeta'></span><span id='topic+zetam1_int'></span><span id='topic+zetam1'></span><span id='topic+hzeta'></span><span id='topic+eta_int'></span><span id='topic+eta'></span>

<h3>Description</h3>

<p>Zeta functions as per the Gnu Scientific Library 7.31 and AMS-55,
section 23.2.  These functions are declared in header file
<code>gsl_sf_zeta.h</code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeta_int(n, give=FALSE, strict=TRUE)
zeta(s, give=FALSE, strict=TRUE)
zetam1_int(n, give=FALSE, strict=TRUE)
zetam1(s, give=FALSE, strict=TRUE)
hzeta(s, q, give=FALSE, strict=TRUE)
eta_int(n, give=FALSE, strict=TRUE)
eta(s, give=FALSE, strict=TRUE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zeta_+3A_n">n</code></td>
<td>
<p>input: integer values</p>
</td></tr>
<tr><td><code id="Zeta_+3A_s">s</code>, <code id="Zeta_+3A_q">q</code></td>
<td>
<p>input: real values</p>
</td></tr>
<tr><td><code id="Zeta_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return a list of three
items: the value, an estimate of the error, and a status number.</p>
</td></tr>
<tr><td><code id="Zeta_+3A_strict">strict</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return <code>NaN</code>
if status is an error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p><a href="https://www.gnu.org/software/gsl/">https://www.gnu.org/software/gsl/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 1:10
cbind(n,zeta(n),eta(n))   #table 23.3, p 811


zeta_int(1:5)
zeta(c(pi,pi*2))
zetam1_int(1:5)
zetam1(c(pi,pi*2))
hzeta(1.1,1.2)
eta_int(1:5)
eta(c(pi,pi*2))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
