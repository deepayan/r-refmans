<!DOCTYPE html><html><head><title>Help for package terra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {terra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#activeCat'><p>Active category</p></a></li>
<li><a href='#add'><p>Add (in place) a SpatRaster to another SpatRaster or to a SpatRasterDataset or SpatRasterCollection</p></a></li>
<li><a href='#add_box'><p>draw a box</p></a></li>
<li><a href='#add_legend'><p>add a custom legend</p></a></li>
<li><a href='#adjacent'><p>Adjacent cells</p></a></li>
<li><a href='#aggregate'><p>Aggregate raster or vector data</p></a></li>
<li><a href='#align'><p>Align a SpatExtent</p></a></li>
<li><a href='#all.equal'><p>Compare two SpatRasters for equality</p></a></li>
<li><a href='#animate'><p>Animate a SpatRaster</p></a></li>
<li><a href='#app'><p>Apply a function to the cells of a SpatRaster</p></a></li>
<li><a href='#approximate'><p>Estimate values for cell values that are <code>NA</code> by interpolating between layers</p></a></li>
<li><a href='#Arith-methods'><p>Arithmetic</p></a></li>
<li><a href='#as.character'><p>Create a text representation of (the skeleton of) an object</p></a></li>
<li><a href='#as.data.frame'><p>SpatRaster or SpatVector to data.frame</p></a></li>
<li><a href='#as.lines'><p>Conversion to a SpatVector of lines</p></a></li>
<li><a href='#as.list'><p>Coerce a Spat* object to a list</p></a></li>
<li><a href='#as.points'><p>Conversion to a SpatVector of points</p></a></li>
<li><a href='#as.polygons'><p>Conversion to a SpatVector of polygons</p></a></li>
<li><a href='#as.raster'><p>Coerce to a &quot;raster&quot; object</p></a></li>
<li><a href='#atan2'><p>Two argument arc-tangent</p></a></li>
<li><a href='#autocorrelation'><p>Spatial autocorrelation</p></a></li>
<li><a href='#barplot'><p>Bar plot of a SpatRaster</p></a></li>
<li><a href='#boundaries'><p>Detect boundaries (edges)</p></a></li>
<li><a href='#boxplot'>
<p>Box plot of SpatRaster data</p></a></li>
<li><a href='#buffer'><p>Create a buffer around vector geometries or raster patches</p></a></li>
<li><a href='#c'><p>Combine SpatRaster or SpatVector objects</p></a></li>
<li><a href='#cartogram'><p>Cartogram</p></a></li>
<li><a href='#catalyze'><p>Factors to numeric</p></a></li>
<li><a href='#cells'><p>Get cell numbers</p></a></li>
<li><a href='#cellSize'><p>Area covered by each raster cell</p></a></li>
<li><a href='#centroids'><p>Centroids</p></a></li>
<li><a href='#clamp'><p>Clamp values</p></a></li>
<li><a href='#clamp_ts'><p>clamp time series data</p></a></li>
<li><a href='#classify'><p>Classify (or reclassify) cell values</p></a></li>
<li><a href='#click'><p>Query by clicking on a map</p></a></li>
<li><a href='#coerce'><p>Coercion to vector, matrix or array</p></a></li>
<li><a href='#colors'><p>Color table</p></a></li>
<li><a href='#combineGeoms'>
<p>Combine geometries</p></a></li>
<li><a href='#Compare-methods'><p>Compare and logical methods</p></a></li>
<li><a href='#compareGeom'><p>Compare geometries of SpatRasters</p></a></li>
<li><a href='#concats'><p>Concatenate categorical rasters</p></a></li>
<li><a href='#contour'><p>Contour plot</p></a></li>
<li><a href='#convHull'>
<p>Convex hull, minimal bounding rotated rectangle, and minimal bounding circle</p></a></li>
<li><a href='#costDist'><p>Cost distance</p></a></li>
<li><a href='#cover'><p>Replace values with values from another object</p></a></li>
<li><a href='#crds'><p>Get the coordinates of SpatVector geometries or SpatRaster cells</p></a></li>
<li><a href='#crop'><p>Cut out a geographic subset</p></a></li>
<li><a href='#crosstab'><p>Cross-tabulate</p></a></li>
<li><a href='#crs'><p> Get or set a coordinate reference system</p></a></li>
<li><a href='#datatype'><p>Data type of a SpatRaster or SpatVector</p></a></li>
<li><a href='#deepcopy'><p>Deep copy</p></a></li>
<li><a href='#densify'>
<p>Add additional nodes to lines or polygons</p></a></li>
<li><a href='#density'><p>Density plot</p></a></li>
<li><a href='#deprecated'><p>deprecated methods</p></a></li>
<li><a href='#depth'><p>depth of SpatRaster layers</p></a></li>
<li><a href='#describe'><p>describe</p></a></li>
<li><a href='#diff'><p>Lagged differences</p></a></li>
<li><a href='#dimensions'><p>Dimensions of a SpatRaster or SpatVector and related objects</p></a></li>
<li><a href='#direction'><p>Direction</p></a></li>
<li><a href='#disagg'><p>Disaggregate raster cells or vector geometries</p></a></li>
<li><a href='#distance'><p>Geographic distance</p></a></li>
<li><a href='#dots'><p>Make a dot-density map</p></a></li>
<li><a href='#draw'><p> Draw a polygon, line, extent, or points</p></a></li>
<li><a href='#elongate'><p> elongate lines</p></a></li>
<li><a href='#erase'><p> Erase parts of a SpatVector object</p></a></li>
<li><a href='#expanse'><p>Get the expanse (area) of individual polygons or for all (summed) raster cells</p></a></li>
<li><a href='#ext'><p>Create, get or set a SpatExtent</p></a></li>
<li><a href='#extend'><p>Extend</p></a></li>
<li><a href='#extract'><p>Extract values from a SpatRaster</p></a></li>
<li><a href='#extractAlong'><p>extract values along lines</p></a></li>
<li><a href='#extractRange'><p>Extract values for a range of layers from a SpatRaster</p></a></li>
<li><a href='#extremes'><p>Get or compute the minimum and maximum cell values</p></a></li>
<li><a href='#factors'><p>Categorical rasters</p></a></li>
<li><a href='#fillHoles'><p>Remove holes from polygons</p></a></li>
<li><a href='#fillTime'>
<p>Fill time gaps in a SpatRaster</p></a></li>
<li><a href='#flip'><p>Flip or reverse a raster</p></a></li>
<li><a href='#focal'><p>Focal values</p></a></li>
<li><a href='#focal3D'><p>Three-dimensional focal values</p></a></li>
<li><a href='#focalCpp'><p>Compute focal values with an iterating C++ function</p></a></li>
<li><a href='#focalMat'><p>Focal weights matrix</p></a></li>
<li><a href='#focalPairs'><p>Focal function across two layers</p></a></li>
<li><a href='#focalReg'><p>Focal regression</p></a></li>
<li><a href='#focalValues'><p>Get focal values</p></a></li>
<li><a href='#forceCCW'><p>force counter-clockwise polygons</p></a></li>
<li><a href='#freq'><p>Frequency table</p></a></li>
<li><a href='#gaps'><p>Find gaps between polygons</p></a></li>
<li><a href='#gdal'><p>GDAL version, supported file formats, and cache size</p></a></li>
<li><a href='#geom'><p>Get the geometry (coordinates) of a SpatVector</p></a></li>
<li><a href='#geomtype'><p>Geometry type of a SpatVector</p></a></li>
<li><a href='#global'><p>global statistics</p></a></li>
<li><a href='#graticule'>
<p>Create a graticule</p></a></li>
<li><a href='#gridDistance'><p>Distance on a grid</p></a></li>
<li><a href='#halo'><p>Add halo-ed text to a plot</p></a></li>
<li><a href='#headtail'><p>head and tail of a SpatRaster or SpatVector</p></a></li>
<li><a href='#hist'><p>Histogram</p></a></li>
<li><a href='#identical'><p>Compare two SpatRasters for equality</p></a></li>
<li><a href='#ifel'><p>ifelse for SpatRasters</p></a></li>
<li><a href='#image'><p>SpatRaster image method</p></a></li>
<li><a href='#impose'>
<p>Impose the geometry of a SpatRaster to those in a SpatRasterCollection.</p></a></li>
<li><a href='#initialize'><p>Initialize a SpatRaster with values</p></a></li>
<li><a href='#inplace'><p>Change values in-place</p></a></li>
<li><a href='#inset'><p>Make an inset map</p></a></li>
<li><a href='#interpIDW'><p>Interpolate points using a moving window</p></a></li>
<li><a href='#interpNear'><p>Nearest neighbor interpolation</p></a></li>
<li><a href='#interpolation'><p>Spatial interpolation</p></a></li>
<li><a href='#intersect'>
<p>Intersection</p></a></li>
<li><a href='#is.bool'><p>Raster value types</p></a></li>
<li><a href='#is.empty'><p>Check if a SpatExtent or SpatVector is empty</p></a></li>
<li><a href='#is.lonlat'><p>Check for longitude/latitude crs</p></a></li>
<li><a href='#is.rotated'><p>Check for rotation</p></a></li>
<li><a href='#is.valid'><p>Check or fix polygon or extent validity</p></a></li>
<li><a href='#k_means'><p>k_means</p></a></li>
<li><a href='#lapp'><p>Apply a function to layers of a SpatRaster, or sub-datasets of a SpatRasterDataset</p></a></li>
<li><a href='#layerCor'><p>Correlation and (weighted) covariance</p></a></li>
<li><a href='#linearUnits'><p>Linear units of the coordinate reference system</p></a></li>
<li><a href='#lines'><p>Add points, lines, or polygons to a map</p></a></li>
<li><a href='#makeTiles'><p>Make tiles or get their extents</p></a></li>
<li><a href='#makeVRT'><p>Make a VRT header file</p></a></li>
<li><a href='#map.pal'><p>map.pal arrow</p></a></li>
<li><a href='#mask'><p>Mask values in a SpatRaster or SpatVector</p></a></li>
<li><a href='#match'><p>Value matching for SpatRasters</p></a></li>
<li><a href='#Math-methods'><p>General mathematical methods</p></a></li>
<li><a href='#mem'><p>Memory available and needed</p></a></li>
<li><a href='#merge'>
<p>Merge SpatRasters, or merge a SpatVector with a data.frame</p></a></li>
<li><a href='#mergeTime'>
<p>merge SpatRasters by timelines to create a single timeseries</p></a></li>
<li><a href='#meta'><p>meta</p></a></li>
<li><a href='#metags'><p>Set or get metadata</p></a></li>
<li><a href='#modal'><p>modal value</p></a></li>
<li><a href='#mosaic'>
<p>mosaic SpatRasters</p></a></li>
<li><a href='#na.omit'><p>Find and remove geometries that are NA</p></a></li>
<li><a href='#NAflag'><p>Set the NA flag</p></a></li>
<li><a href='#names'><p>Names of Spat* objects</p></a></li>
<li><a href='#nearest'><p>nearby geometries</p></a></li>
<li><a href='#normalize.longitude'><p>normalize vector data that crosses the dateline</p></a></li>
<li><a href='#north'><p>North arrow</p></a></li>
<li><a href='#not.na'><p>is not NA</p></a></li>
<li><a href='#options'><p>Options</p></a></li>
<li><a href='#origin'><p>Origin</p></a></li>
<li><a href='#pairs'>
<p>Pairs plot (matrix of scatterplots)</p></a></li>
<li><a href='#panel'><p>Map panel</p></a></li>
<li><a href='#patches'><p>Detect patches (clumps) of cells</p></a></li>
<li><a href='#perim'><p>Perimeter or length</p></a></li>
<li><a href='#persp'><p>Perspective plot</p></a></li>
<li><a href='#plet'><p>Plot with leaflet</p></a></li>
<li><a href='#plot'><p>Make a map</p></a></li>
<li><a href='#plot_extent'><p>Plot a SpatExtent</p></a></li>
<li><a href='#plot_graticule'><p>Plot a graticule</p></a></li>
<li><a href='#plotRGB'><p>Red-Green-Blue plot of a multi-layered SpatRaster</p></a></li>
<li><a href='#prcomp'><p>SpatRaster PCA with prcomp</p></a></li>
<li><a href='#predict'><p>Spatial model predictions</p></a></li>
<li><a href='#princomp'><p>SpatRaster PCA with princomp</p></a></li>
<li><a href='#project'><p>Change the coordinate reference system</p></a></li>
<li><a href='#quantile'><p>Quantiles of spatial data</p></a></li>
<li><a href='#query'><p>Query a SpatVectorProxy object</p></a></li>
<li><a href='#rangeFill'><p>Fill layers with a range</p></a></li>
<li><a href='#rapp'><p>Range-apply</p></a></li>
<li><a href='#rast'><p>Create a SpatRaster</p></a></li>
<li><a href='#rasterize'><p>Rasterize vector data</p></a></li>
<li><a href='#rasterizeGeom'><p>Rasterize geometric properties of vector data</p></a></li>
<li><a href='#rasterizeWin'><p>Rasterize points with a moving window</p></a></li>
<li><a href='#rcl'><p>Combine row, column, and layer numbers</p></a></li>
<li><a href='#readwrite'><p>Read from, or write to, file</p></a></li>
<li><a href='#rectify'><p>Rectify a SpatRaster</p></a></li>
<li><a href='#regress'><p>Cell level regression</p></a></li>
<li><a href='#relate'>
<p>Spatial relationships between geometries</p></a></li>
<li><a href='#rep'><p>Replicate layers</p></a></li>
<li><a href='#replace_dollar'><p>Replace with $&lt;-</p></a></li>
<li><a href='#replace_layers'><p>Replace layers or variables</p></a></li>
<li><a href='#replace_values'><p>Replace values of a SpatRaster</p></a></li>
<li><a href='#resample'><p>Transfer values of a SpatRaster to another one with a different geometry</p></a></li>
<li><a href='#rescale'><p>rescale</p></a></li>
<li><a href='#RGB'><p>Layers representing colors</p></a></li>
<li><a href='#roll'><p>Rolling (moving) functions</p></a></li>
<li><a href='#rotate'><p>Rotate data along longitude</p></a></li>
<li><a href='#same.crs'><p>Compare coordinate reference systems</p></a></li>
<li><a href='#sapp'><p>Apply a terra function that takes only a single layer and returns a SpatRaster to all layers of a SpatRaster</p></a></li>
<li><a href='#sbar'><p>scale bar</p></a></li>
<li><a href='#scale'><p>Scale values</p></a></li>
<li><a href='#scatterplot'><p>Scatterplot of two SpatRaster layers</p></a></li>
<li><a href='#scoff'><p>Scale (gain) and offset</p></a></li>
<li><a href='#sds'><p>Create a SpatRasterDataset</p></a></li>
<li><a href='#segregate'><p>segregate</p></a></li>
<li><a href='#sel'>
<p>Spatial selection</p></a></li>
<li><a href='#selectHighest'><p>select cells with high or low values</p></a></li>
<li><a href='#selectRange'><p>Select the values of a range of layers, as specified by cell values in another SpatRaster</p></a></li>
<li><a href='#serialize'><p>saveRDS and serialize for SpatVector and SpatRaster*</p></a></li>
<li><a href='#setValues'><p>Set the values of raster cells or of geometry attributes</p></a></li>
<li><a href='#shade'><p>Hill shading</p></a></li>
<li><a href='#sharedPaths'>
<p>Shared paths</p></a></li>
<li><a href='#shift'><p>Shift</p></a></li>
<li><a href='#sieve'><p>Sieve filter</p></a></li>
<li><a href='#simplifyGeom'>
<p>simplifyGeom geometries</p></a></li>
<li><a href='#sort'><p>Sort a SpatRaster or SpatVector</p></a></li>
<li><a href='#sources'><p>Data sources of a SpatRaster</p></a></li>
<li><a href='#SpatExtent-class'><p>Class &quot;SpatExtent&quot;</p></a></li>
<li><a href='#SpatRaster-class'><p> SpatRaster class</p></a></li>
<li><a href='#spatSample'><p>Take a regular sample</p></a></li>
<li><a href='#SpatVector-class'><p>Class &quot;SpatVector&quot;</p></a></li>
<li><a href='#spin'><p>spin a SpatVector</p></a></li>
<li><a href='#split'><p>Split</p></a></li>
<li><a href='#sprc'><p>Create a SpatRasterCollection</p></a></li>
<li><a href='#stretch'><p>Stretch</p></a></li>
<li><a href='#subset'><p>Subset a SpatRaster or a SpatVector</p></a></li>
<li><a href='#subset_dollar'><p>Subset a SpatRaster or a SpatVector</p></a></li>
<li><a href='#subset_double'><p>Subset a SpatRaster or a SpatVector</p></a></li>
<li><a href='#subset_single'><p>Extract values from a SpatRaster, SpatVector or SpatExtent</p></a></li>
<li><a href='#subst'><p>replace cell values</p></a></li>
<li><a href='#summarize'><p>Summarize</p></a></li>
<li><a href='#summary'><p>summary</p></a></li>
<li><a href='#svc'><p>Create a SpatVectorCollection</p></a></li>
<li><a href='#symdif'>
<p>Symmetrical difference</p></a></li>
<li><a href='#tapp'><p>Apply a function to subsets of layers of a SpatRaster</p></a></li>
<li><a href='#terra-package'><p>Description of the methods in the terra package</p></a></li>
<li><a href='#terrain'><p>terrain characteristics</p></a></li>
<li><a href='#text'><p>Add labels to a map</p></a></li>
<li><a href='#tighten'><p>tighten SpatRaster or SpatRasterDataset objects</p></a></li>
<li><a href='#time'><p>time of SpatRaster layers</p></a></li>
<li><a href='#tmpFiles'><p>Temporary files</p></a></li>
<li><a href='#topology'>
<p>Vector topology methods</p></a></li>
<li><a href='#transpose'><p>Transpose</p></a></li>
<li><a href='#trim'><p>Trim a SpatRaster</p></a></li>
<li><a href='#union'>
<p>Union SpatVector or SpatExtent objects</p></a></li>
<li><a href='#unique'><p>Unique values</p></a></li>
<li><a href='#units'><p>units of SpatRaster or SpatRasterDataSet</p></a></li>
<li><a href='#update'><p>Change values in a file</p></a></li>
<li><a href='#values'><p>Cell values and geometry attributes</p></a></li>
<li><a href='#varnames'><p>variable and long variable names</p></a></li>
<li><a href='#vect'><p>Create SpatVector objects</p></a></li>
<li><a href='#vector_layers'><p>List or remove layers from a vector file</p></a></li>
<li><a href='#viewshed'><p>Compute a viewshed</p></a></li>
<li><a href='#voronoi'><p>Voronoi diagram and Delaunay triangles</p></a></li>
<li><a href='#vrt'><p>Virtual Raster Dataset</p></a></li>
<li><a href='#vrt_tiles'><p>filenames of VRT tiles</p></a></li>
<li><a href='#weighted.mean'><p>Weighted mean of layers</p></a></li>
<li><a href='#where'><p>Where are the cells with the min or max values?</p></a></li>
<li><a href='#which.lyr'><p>Which cells are TRUE?</p></a></li>
<li><a href='#width'>
<p>SpatVector geometric properties</p></a></li>
<li><a href='#window'><p>Set a window</p></a></li>
<li><a href='#wrap'><p>wrap and unwrap</p></a></li>
<li><a href='#wrapCache'><p>SpatRaster wrap with caching options</p></a></li>
<li><a href='#writeCDF'><p>Write raster data to a NetCDF file</p></a></li>
<li><a href='#writeRaster'><p>Write raster data to a file</p></a></li>
<li><a href='#writeVector'><p>Write SpatVector data to a file</p></a></li>
<li><a href='#xapp'><p>Apply a function to the cells of a two SpatRasters</p></a></li>
<li><a href='#xmin'><p>Get or set single values of an extent</p></a></li>
<li><a href='#xyRowColCell'><p>Coordinates from a row, column or cell number and vice versa</p></a></li>
<li><a href='#zonal'><p>Zonal statistics</p></a></li>
<li><a href='#zoom'><p>Zoom in on a map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7-71</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, tinytest, ncdf4, sf (&ge; 0.9-8), deldir, XML,
leaflet (&ge; 2.2.1), htmlwidgets</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rcpp (&ge; 1.0-10)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17, GDAL (&gt;= 2.2.3), GEOS (&gt;= 3.4.0), PROJ (&gt;=
4.9.3), sqlite3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert J. Hijmans &lt;r.hijmans@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for spatial data analysis with vector (points, lines, polygons) and raster (grid) data. Methods for vector data include geometric operations such as intersect and buffer. Raster methods include local, focal, global, zonal and geometric operations. The predict and interpolate methods facilitate the use of regression type (interpolation, machine learning) models for spatial prediction, including with satellite remote sensing data. Processing of very large files is supported. See the manual and tutorials on <a href="https://rspatial.org/">https://rspatial.org/</a> to get started. 'terra' replaces the 'raster' package ('terra' can do more, and it is faster and easier to use).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rspatial.org/">https://rspatial.org/</a>, <a href="https://rspatial.github.io/terra/">https://rspatial.github.io/terra/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rspatial/terra/issues/">https://github.com/rspatial/terra/issues/</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 07:01:10 UTC; rhijm</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert J. Hijmans <a href="https://orcid.org/0000-0001-5872-2872"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Roger Bivand <a href="https://orcid.org/0000-0003-2392-6140"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Michael D. Sumner [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='activeCat'>Active category</h2><span id='topic+activeCat'></span><span id='topic+activeCat+2CSpatRaster-method'></span><span id='topic+activeCat+3C-'></span><span id='topic+activeCat+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get or set the active category of a multi-categorical SpatRaster layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
activeCat(x, layer=1)
## S4 replacement method for signature 'SpatRaster'
activeCat(x, layer=1)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="activeCat_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="activeCat_+3A_layer">layer</code></td>
<td>
<p>positive integer, the layer number or name</p>
</td></tr>
<tr><td><code id="activeCat_+3A_value">value</code></td>
<td>
<p>positive integer or character, indicating which column in the categories to use. Note that when a number is used this index is zero based, and &quot;1&quot; refers to the second column. This is because the first column of the categories has the cell values, not categorical labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+levels">levels</a></code>, <code><a href="#topic+cats">cats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
r &lt;- rast(nrows=10, ncols=10)
values(r) &lt;- sample(3, ncell(r), replace=TRUE) + 10
d &lt;- data.frame(id=11:13, cover=c("forest", "water", "urban"), letters=letters[1:3], value=10:12)
levels(r) &lt;- d

activeCat(r)
activeCat(r) &lt;- 3
activeCat(r)
</code></pre>

<hr>
<h2 id='add'>Add (in place) a SpatRaster to another SpatRaster or to a SpatRasterDataset or SpatRasterCollection</h2><span id='topic+add+3C-'></span><span id='topic+add+3C-+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+add+3C-+2CSpatRasterCollection+2CSpatRaster-method'></span><span id='topic+add+3C-+2CSpatRasterDataset+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Add (in place) a SpatRaster to another SpatRaster. Comparable with <code><a href="#topic+c">c</a></code>, but without copying the object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SpatRaster,SpatRaster'
add(x)&lt;-value

## S4 replacement method for signature 'SpatRasterDataset,SpatRaster'
add(x)&lt;-value

## S4 replacement method for signature 'SpatRasterCollection,SpatRaster'
add(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatRasterDataset or SpatRasterCollection</p>
</td></tr>
<tr><td><code id="add_+3A_value">value</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c">c</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=5, ncols=9, vals=1:45)
x &lt;- c(r, r*2)
add(x) &lt;- r*3
x
</code></pre>

<hr>
<h2 id='add_box'>draw a box</h2><span id='topic+add_box'></span>

<h3>Description</h3>

 
<p>Similar to <code><a href="graphics.html#topic+box">box</a></code> allowing adding a box around a map. This function will place the legend in the locations within the mapped area as delineated by the axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_box(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_box_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+lines">lines</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- vect(system.file("ex/lux.shp", package="terra"))
plot(v)
add_box(col="red", lwd=3, xpd=TRUE)
</code></pre>

<hr>
<h2 id='add_legend'>add a custom legend</h2><span id='topic+add_legend'></span>

<h3>Description</h3>

 
<p>Wrapper around <code><a href="graphics.html#topic+legend">legend</a></code> that allows adding a custom legend to a map using a keyword such as &quot;topleft&quot; or &quot;bottomright&quot;. This function will place the legend in the locations within the mapped area as delineated by the axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_legend(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_legend_+3A_x">x</code></td>
<td>
<p>The keyword to be used to position the legend (or the x coordinate)</p>
</td></tr>
<tr><td><code id="add_legend_+3A_y">y</code></td>
<td>
<p>The y coordinate to be used to position the legend (is x is also a coordinate)</p>
</td></tr>
<tr><td><code id="add_legend_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- vect(system.file("ex/lux.shp", package="terra"))
plot(v)
points(centroids(v), col="red")
legend("topleft", legend = "centroids", pch = 20, xpd=NA, bg="white", col="red")
add_legend("topright", legend = "centroids", pch = 20, col="red")
</code></pre>

<hr>
<h2 id='adjacent'>Adjacent cells</h2><span id='topic+adjacent'></span><span id='topic+adjacent+2CSpatRaster-method'></span><span id='topic+adjacent+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Identify cells that are adjacent to a set of raster cells. Or identify adjacent polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
adjacent(x, cells, directions="rook", pairs=FALSE, include=FALSE, symmetrical=FALSE)

## S4 method for signature 'SpatVector'
adjacent(x, type="rook", pairs=TRUE, symmetrical=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacent_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="adjacent_+3A_cells">cells</code></td>
<td>
<p>vector of cell numbers for which adjacent cells should be found. Cell numbers start with 1 in the upper-left corner and increase from left to right and from top to bottom</p>
</td></tr>
<tr><td><code id="adjacent_+3A_directions">directions</code></td>
<td>
<p>character or matrix to indicated the directions in which cells are considered connected. The following character values are allowed: &quot;rook&quot; or &quot;4&quot; for the horizontal and vertical neighbors; &quot;bishop&quot; to get the diagonal neighbors; &quot;queen&quot; or &quot;8&quot; to get the vertical, horizontal and diagonal neighbors; or &quot;16&quot; for knight and one-cell queen move neighbors. If <code>directions</code> is a matrix it should have odd dimensions and have logical (or 0, 1) values</p>
</td></tr>
<tr><td><code id="adjacent_+3A_pairs">pairs</code></td>
<td>
<p>logical. If <code>TRUE</code>, a two-column matrix of pairs of adjacent cells is returned. If <code>x</code> is a <code>SpatRaster</code> and <code>pairs</code> is <code>FALSE</code>, an <code>n*m</code> matrix is returned where the number of rows <code>n</code> is <code>length(cells)</code> and the number of columns <code>m</code> is the number of neighbors requested with <code>directions</code></p>
</td></tr>
<tr><td><code id="adjacent_+3A_include">include</code></td>
<td>
<p>logical. Should the focal cells be included in the result?</p>
</td></tr>
<tr><td><code id="adjacent_+3A_type">type</code></td>
<td>
<p>character. One of &quot;rook&quot;, &quot;queen&quot;, &quot;touches&quot;, or &quot;intersects&quot;. &quot;queen&quot; and &quot;touches&quot; are synonyms. &quot;rook&quot; exclude polygons that touch at a single node only. &quot;intersects&quot; includes polygons that touch or overlap</p>
</td></tr>
<tr><td><code id="adjacent_+3A_symmetrical">symmetrical</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>pairs=TRUE</code>, an adjacent pair is only included once. For example, if polygon 1 is adjacent to polygon 3, the implied adjacency between 3 and 1 is not reported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Note</h3>

<p>When using global lon/lat rasters, adjacent cells at the other side of the date-line are included.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relate">relate</a></code>, <code><a href="#topic+nearby">nearby</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=10, ncols=10)
adjacent(r, cells=c(1, 5, 55), directions="queen") 
r &lt;- rast(nrows=10, ncols=10, crs="+proj=utm +zone=1 +datum=WGS84")
adjacent(r, cells=11, directions="rook") 

#same as 
rk &lt;- matrix(c(0,1,0,1,0,1,0,1,0), 3, 3)
adjacent(r, cells=11, directions=rk) 

## note that with global lat/lon data the E and W connect
r &lt;- rast(nrows=10, ncols=10, crs="+proj=longlat +datum=WGS84")
adjacent(r, cells=11, directions="rook") 

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
a &lt;- adjacent(v, symmetrical=TRUE)
head(a)
</code></pre>

<hr>
<h2 id='aggregate'>Aggregate raster or vector data</h2><span id='topic+aggregate'></span><span id='topic+aggregate+2CSpatRaster-method'></span><span id='topic+aggregate+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Aggregate a SpatRaster to create a new SpatRaster with a lower resolution (larger cells). Aggregation groups rectangular areas to create larger cells. The value for the resulting cells is computed with a user-specified function. 
</p>
<p>You can also aggregate (&quot;dissolve&quot;) a SpatVector. This either combines all geometries into one geometry, or it combines the geometries that have the same value for the variable(s) specified with argument <code>by</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
aggregate(x, fact=2, fun="mean", ..., cores=1, filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'SpatVector'
aggregate(x, by=NULL, dissolve=TRUE, fun="mean", count=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="aggregate_+3A_fact">fact</code></td>
<td>
<p>positive integer. Aggregation factor expressed as number of cells in each direction (horizontally and vertically). Or two integers (horizontal and vertical aggregation factor) or three integers (when also aggregating over layers)</p>
</td></tr>  
<tr><td><code id="aggregate_+3A_fun">fun</code></td>
<td>
<p>function used to aggregate values. Either an actual function, or for the following, their name: &quot;mean&quot;, &quot;max&quot;, &quot;min&quot;, &quot;median&quot;, &quot;sum&quot;, &quot;modal&quot;, &quot;any&quot;, &quot;all&quot;, &quot;prod&quot;, &quot;which.min&quot;, &quot;which.max&quot;, &quot;sd&quot; (sample standard deviation) and &quot;std&quot; (population standard deviation)</p>
</td></tr>
<tr><td><code id="aggregate_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fun</code>, such as <code>na.rm=TRUE</code></p>
</td></tr>  
<tr><td><code id="aggregate_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created. Ignored for C++ level implemented functions that are listed under <code>fun</code></p>
</td></tr>  
<tr><td><code id="aggregate_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="aggregate_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="aggregate_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="aggregate_+3A_by">by</code></td>
<td>
<p>character. The variable(s) used to group the geometries</p>
</td></tr>
<tr><td><code id="aggregate_+3A_dissolve">dissolve</code></td>
<td>
<p>logical. Should borders between aggregated geometries be dissolved?</p>
</td></tr> 
<tr><td><code id="aggregate_+3A_count">count</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>by</code> is not <code>NULL</code>, a variable &quot;agg_n&quot; is included that shows the number of input geometries for each output geometry</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aggregation starts at the upper-left end of a SpatRaster. If a division of the number of columns or rows with <code>factor</code> does not return an integer, the extent of the resulting SpatRaster will be somewhat larger then that of the original SpatRaster. For example, if an input SpatRaster has 100 columns, and <code>fact=12</code>, the output SpatRaster will have 9 columns and the maximum x coordinate of the output SpatRaster is also adjusted.
</p>
<p>The function <code>fun</code> should take multiple numbers, and return a single number. For example <code>mean</code>, <code>modal</code>, <code>min</code> or <code>max</code>.
</p>
<p>It should also accept a <code>na.rm</code> argument (or ignore it as one of the 'dots' arguments). 
</p>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+disagg">disagg</a></code> to disaggregate</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
# aggregated SpatRaster, no values
ra &lt;- aggregate(r, fact=10)

values(r) &lt;- runif(ncell(r))
# aggregated raster, max of the values
ra &lt;- aggregate(r, fact=10, fun=max)

# multiple layers
s &lt;- c(r, r*2)
x &lt;- aggregate(s, 20)


## SpatVector 
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
va &lt;- aggregate(v, "ID_1")

plot(va, "NAME_1", lwd=5, plg=list(x="topright"), mar=rep(2,4))
lines(v, lwd=3, col="light gray")
lines(va)
text(v, "ID_1", halo=TRUE)
</code></pre>

<hr>
<h2 id='align'>Align a SpatExtent</h2><span id='topic+align'></span><span id='topic+align+2CSpatExtent+2CSpatRaster-method'></span><span id='topic+align+2CSpatExtent+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Align an SpatExtent with a SpatRaster This can be useful to create a new SpatRaster with the same origin and resolution as an existing SpatRaster. Do not use this to force data to match that really does not match (use e.g. <code><a href="#topic+resample">resample</a></code> or (dis)aggregate for this).
</p>
<p>It is also possible to align a SpatExtent to a clean divisor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatExtent,SpatRaster'
align(x, y, snap="near")

## S4 method for signature 'SpatExtent,numeric'
align(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_x">x</code></td>
<td>
<p>SpatExtent</p>
</td></tr>  
<tr><td><code id="align_+3A_y">y</code></td>
<td>
<p>SpatRaster or numeric</p>
</td></tr>
<tr><td><code id="align_+3A_snap">snap</code></td>
<td>
<p>Character. One of &quot;near&quot;, &quot;in&quot;, or &quot;out&quot;, to determine in which direction the extent should be aligned. To the nearest border, inwards or outwards</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatExtent
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+ext">ext</a></code>, <code><a href="#topic+draw">draw</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
e &lt;- ext(-10.1, 9.9, -20.1, 19.9)
ea &lt;- align(e, r)
e
ext(r)
ea

align(e, 0.5)
</code></pre>

<hr>
<h2 id='all.equal'>Compare two SpatRasters for equality</h2><span id='topic+all.equal'></span><span id='topic+all.equal+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compare two SpatRasters for (near) equality. 
</p>
<p>First the attributes of the objects are compared. If these are the same, a (perhaps small) sample of the raster cells is compared as well. 
</p>
<p>The sample size used can be increased with the <code>maxcell</code> argument. You can set it to <code>Inf</code>, but for large rasters your computer may not have sufficient memory. See the examples for a safe way to compare all values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
all.equal(target, current, maxcell=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal_+3A_target">target</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="all.equal_+3A_current">current</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="all.equal_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. The size of the regular sample used to compare cell values</p>
</td></tr>
<tr><td><code id="all.equal_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+all.equal.numeric">all.equal.numeric</a></code> to compare cell values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either <code>TRUE</code> or a character vector describing the differences between target and current.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+identical">identical</a></code>, <code><a href="#topic+compareGeom">compareGeom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sqrt(1:100)
mat &lt;- matrix(x, 10, 10)
r1 &lt;- rast(nrows=10, ncols=10, xmin=0, vals = x)
r2 &lt;- rast(nrows=10, ncols=10, xmin=0, vals = mat)

all.equal(r1, r2)
all.equal(r1, r1*1)
all.equal(rast(r1), rast(r2))

# compare geometries 
compareGeom(r1, r2)

# Compare all cell values for near equality
# as floating point number imprecision can be a problem
m &lt;- minmax(r1 - r2)
all(abs(m) &lt; 1e-7)

# comparison of cell values to create new SpatRaster
e &lt;- r1 == r2
</code></pre>

<hr>
<h2 id='animate'>Animate a SpatRaster</h2><span id='topic+animate'></span><span id='topic+animate+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Animate (sequentially plot) the layers of a SpatRaster to create a movie.
</p>
<p>This does not work with R-Studio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
animate(x, pause=0.25, main, range, maxcell=50000, n=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="animate_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="animate_+3A_pause">pause</code></td>
<td>
<p>numeric. How long should be the pause be between layers?</p>
</td></tr>  
<tr><td><code id="animate_+3A_main">main</code></td>
<td>
<p>title for each layer. If not supplied the z-value is used if available. Otherwise the names are used.</p>
</td></tr>  
<tr><td><code id="animate_+3A_range">range</code></td>
<td>
<p>numeric vector of length 2. Range of values to plot</p>
</td></tr>
<tr><td><code id="animate_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot. If <code>maxcell &lt; ncell(x)</code>, <code>spatSample(type="regular")</code> is used before plotting</p>
</td></tr>
<tr><td><code id="animate_+3A_n">n</code></td>
<td>
<p>integer &gt; 0. Number of loops</p>
</td></tr>
<tr><td><code id="animate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
animate(s, n=1)
</code></pre>

<hr>
<h2 id='app'>Apply a function to the cells of a SpatRaster</h2><span id='topic+app'></span><span id='topic+app+2CSpatRaster-method'></span><span id='topic+app+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

 
<p>Apply a function to the values of each cell of a SpatRaster. Similar to <code><a href="base.html#topic+apply">apply</a></code> &ndash; think of each layer in a SpatRaster as a column (or row) in a matrix. 
</p>
<p>This is generally used to summarize the values of multiple layers into one layer; but this is not required.
</p>
<p><code>app</code> calls function <code>fun</code> with the raster data as first argument. Depending on the function supplied, the raster data is represented as either a matrix in which each layer is a column, or a vector representing a cell. The function should return a vector or matrix that is divisible by ncell(x). Thus, both &quot;sum&quot; and &quot;rowSums&quot; can be used, but &quot;colSums&quot; cannot be used.
</p>
<p>You can also apply a function <code>fun</code> across datasets by layer of a <code>SpatRasterDataset</code>. In that case, summarization is by layer across SpatRasters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
app(x, fun, ..., cores=1, filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'SpatRasterDataset'
app(x, fun, ..., cores=1, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="app_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatRasterDataset</p>
</td></tr>
<tr><td><code id="app_+3A_fun">fun</code></td>
<td>
<p>a function that operates on a vector or matrix. This can be a function that is defined in base-R or in a package, or a function you write yourself (see examples). Functions that return complex output (e.g. a list) may need to be wrapped in your own function to simplify the output to a vector or matrix. The following functions have been re-implemented in C++ for speed: &quot;sum&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;modal&quot;, &quot;which&quot;, &quot;which.min&quot;, &quot;which.max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;prod&quot;, &quot;any&quot;, &quot;all&quot;, &quot;sd&quot;, &quot;std&quot;, &quot;first&quot;. To use the base-R function for say, &quot;min&quot;, you could use something like <code>fun=function(i) min(i)</code> or the equivalent <code>fun = \(i) min(i)</code></p>
</td></tr>
<tr><td><code id="app_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code>. These are typically numerical constants. They should *never* be another SpatRaster</p>
</td></tr>  
<tr><td><code id="app_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object. Ignored for functions that are implemented by terra in C++ (see under fun)</p>
</td></tr>
<tr><td><code id="app_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="app_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="app_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To speed things up, parallelization is supported, but this is often not helpful, and it may actually be slower. There is only a speed gain if you have many cores (&gt; 8) and/or a very complex (slow) function <code>fun</code>. If you write <code>fun</code> yourself, consider supplying a <code>cppFunction</code> made with the Rcpp package instead (or go have a cup of tea while the computer works for you).
</p>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+lapp">lapp</a></code>, <code><a href="#topic+tapp">tapp</a></code>, <code><a href="#topic+Math-methods">Math-methods</a></code>, <code><a href="#topic+roll">roll</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- 1:ncell(r)
x &lt;- c(r, sqrt(r), r+50)
s &lt;- app(x, fun=sum)
s
# for a few generic functions like 
# "sum", "mean", and "max" you can also do
sum(x)

## SpatRasterDataset
sd &lt;- sds(x, x*2, x/3)
a &lt;- app(sd, max)
a
# same as 
max(x, x*2, x/3)
# and as (but slower)
b &lt;- app(sd, function(i) max(i))


## also works for a single layer
f &lt;- function(i) (i+1) * 2 * i + sqrt(i)
s &lt;- app(r, f)
# same as above, but that is not memory-safe
# and has no filename argument 
s &lt;- f(r)

## Not run: 
#### multiple cores 
test0 &lt;- app(x, sqrt) 
test1 &lt;- app(x, sqrt, cores=2)

testfun &lt;- function(i) { 2 * sqrt(i) }
test2 &lt;- app(x, fun=testfun, cores =2)

## this fails because testfun is not exported to the nodes
# test3 &lt;- app(x, fun=function(i) testfun(i), cores=2)
## to export it, add it as argument to fun
test3 &lt;- app(x, fun=function(i, ff) ff(i), cores =3, ff=testfun)

## End(Not run)
</code></pre>

<hr>
<h2 id='approximate'>Estimate values for cell values that are <code>NA</code> by interpolating between layers</h2><span id='topic+approximate'></span><span id='topic+approximate+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>approximate uses the <code>stats</code> function <code><a href="stats.html#topic+approx">approx</a></code> to estimate values for cells that are <code>NA</code> by interpolation across layers. Layers are considered equidistant, unless argument <code>z</code> is used, or <code>time(x)</code> returns values that are not <code>NA</code>, in which case these values are used to determine distance between layers.
</p>
<p>For estimation based on neighboring cells see <code><a href="#topic+focal">focal</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
approximate(x, method="linear", yleft, yright,
            rule=1, f=0, ties=mean, z=NULL, NArule=1,filename="",  ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="approximate_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="approximate_+3A_method">method</code></td>
<td>
<p>specifies the interpolation method to be used. Choices are &quot;linear&quot; or &quot;constant&quot; (step function; see the example in <code><a href="stats.html#topic+approx">approx</a></code></p>
</td></tr>
<tr><td><code id="approximate_+3A_yleft">yleft</code></td>
<td>
<p>the value to be returned before a non-<code>NA</code> value is encountered. The default is defined by the value of rule given below</p>
</td></tr>
<tr><td><code id="approximate_+3A_yright">yright</code></td>
<td>
<p>the value to be returned after the last non-<code>NA</code> value is encountered. The default is defined by the value of rule given below</p>
</td></tr>
<tr><td><code id="approximate_+3A_rule">rule</code></td>
<td>
<p>an integer (of length 1 or 2) describing how interpolation is to take place at for the first and last cells (before or after any non-<code>NA</code> values are encountered). If rule is 1 then NAs are returned for such points and if it is 2, the value at the closest data extreme is used. Use, e.g., <code>rule = 2:1</code>, if the left and right side extrapolation should differ</p>
</td></tr>
<tr><td><code id="approximate_+3A_f">f</code></td>
<td>
<p>for method = &quot;constant&quot; a number between 0 and 1 inclusive, indicating a compromise between left- and right-continuous step functions. If y0 and y1 are the values to the left and right of the point then the value is <code>y0*(1-f)+y1*f</code> so that <code>f = 0)</code> is right-continuous and <code>f = 1</code> is left-continuous</p>
</td></tr>
<tr><td><code id="approximate_+3A_ties">ties</code></td>
<td>
<p>Handling of tied 'z' values. Either a function with a single vector argument returning a single number result or the string &quot;ordered&quot;</p>
</td></tr>
<tr><td><code id="approximate_+3A_z">z</code></td>
<td>
<p>numeric vector to indicate the distance between layers (e.g., depth). The default is <code>time(x)</code> if these are not <code>NA</code> or else <code>1:nlys(x)</code>  </p>
</td></tr>  
<tr><td><code id="approximate_+3A_narule">NArule</code></td>
<td>
<p>single integer used to determine what to do when only a single layer with a non-<code>NA</code> value is encountered (and linear interpolation is not possible). The default value of 1 indicates that all layers will get this value for that cell; all other values do not change the cell values</p>
</td></tr>  
<tr><td><code id="approximate_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="approximate_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code> <a href="#topic+focal">focal</a></code>, <code><a href="#topic+fillTime">fillTime</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=5, nrows=5)
r1 &lt;- setValues(r, runif(ncell(r)))
r2 &lt;- setValues(r, runif(ncell(r)))
r3 &lt;- setValues(r, runif(ncell(r)))
r4 &lt;- setValues(r, runif(ncell(r)))
r5 &lt;- setValues(r, NA)
r6 &lt;- setValues(r, runif(ncell(r)))
r1[6:10] &lt;- NA
r2[5:15] &lt;- NA
r3[8:25] &lt;- NA
s &lt;- c(r1,r2,r3,r4,r5,r6)
s[1:5] &lt;- NA
x1 &lt;- approximate(s)
x2 &lt;- approximate(s, rule=2)
x3 &lt;- approximate(s, rule=2, z=c(1,2,3,5,14,15))

</code></pre>

<hr>
<h2 id='Arith-methods'>Arithmetic</h2><span id='topic+Arith-methods'></span><span id='topic+Arith+2CSpatExtent+2Cnumeric-method'></span><span id='topic+Arith+2Cnumeric+2CSpatExtent-method'></span><span id='topic+Arith+2CSpatExtent+2CSpatExtent-method'></span><span id='topic+Arith+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+Arith+2CSpatVector+2CSpatVector-method'></span><span id='topic+Arith+2CSpatRaster+2Cmissing-method'></span><span id='topic+Arith+2Cnumeric+2CSpatRaster-method'></span><span id='topic+Arith+2CSpatRaster+2Cnumeric-method'></span><span id='topic+Arith+2Clogical+2CSpatRaster-method'></span><span id='topic+Arith+2CSpatRaster+2Clogical-method'></span><span id='topic+Arith+2Cmissing+2CSpatRaster-method'></span><span id='topic+Arith+2CSpatRaster+2Cmatrix-method'></span><span id='topic+Arith+2Cmatrix+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Standard arithmetic operators for computations with SpatRasters. Computations are local (applied on a cell by cell basis). If multiple SpatRasters are used, these must have the same geometry (extent and resolution). These operators have been implemented:
</p>
<p><code> +, -, *, /, ^, %%, %/% </code>
</p>
<p>You can also use a SpatRaster and a vector or a matrix. If you use a SpatRaster with a vector of multiple numbers, each element in the vector is considered a layer (with a constant value). If you use a SpatRaster with a matrix, the number of columns of the matrix must match the number of layers of the SpatRaster. The rows are used to match the cells. That is, if there are two rows, these match cells 1 and 2, and they are recycled to 3 and 4, etc. 
</p>
<p>The following methods have been implemented for <code>(SpatExtent, SpatExtent)</code>: <code>+, -</code>, and the following for <code>(SpatExtent, numeric)</code>: <code>+, -, *, /, %%</code>
</p>


<h3>Value</h3>

<p>SpatRaster or SpatExtent
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ifel">ifel</a></code> to conveniently combine operations and <code><a href="#topic+Math-methods">Math-methods</a></code> or <code><a href="#topic+app">app</a></code> to use mathematical functions not implemented by the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- rast(ncols=10, nrows=10)
v &lt;- runif(ncell(r1))
v[10:20] &lt;- NA
values(r1) &lt;- v
r2 &lt;- rast(r1)
values(r2) &lt;- 1:ncell(r2) / ncell(r2)
r3 &lt;- r1 + r2
r2 &lt;- r1 / 10
r3 &lt;- r1 * (r2 - 1 / r2)

b &lt;- c(r1, r2, r3)
b2 &lt;- b * 10

### SpatExtent methods
x &lt;- ext(0.1, 2.2, 0, 3)
y &lt;- ext(-2, 1, -2,2)
# union
x + y
# intersection
x * y

e &lt;- x 
e
e * 2
e / 2
e + 1
e - 1
</code></pre>

<hr>
<h2 id='as.character'>Create a text representation of (the skeleton of) an object</h2><span id='topic+as.character+2CSpatExtent-method'></span><span id='topic+as.character+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Create a text representation of (the skeleton of) an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatExtent'
as.character(x)

## S4 method for signature 'SpatRaster'
as.character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
ext(r)
ext(c(0, 20, 0, 20))

</code></pre>

<hr>
<h2 id='as.data.frame'>SpatRaster or SpatVector to data.frame</h2><span id='topic+as.data.frame'></span><span id='topic+as.data.frame+2CSpatRaster-method'></span><span id='topic+as.data.frame+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Coerce a SpatRaster or SpatVector to a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
as.data.frame(x, row.names=NULL, optional=FALSE, geom=NULL, ...)

## S4 method for signature 'SpatRaster'
as.data.frame(x, row.names=NULL, optional=FALSE, xy=FALSE, 
	cells=FALSE, time=FALSE, na.rm=NA, wide=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_geom">geom</code></td>
<td>
<p>character or NULL. If not NULL, either &quot;WKT&quot; or &quot;HEX&quot;, to get the geometry included in Well-Known-Text or hexadecimal notation. If <code>x</code> has point geometry, it can also be &quot;XY&quot; to add the coordinates of each point</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, the coordinates of each raster cell are included</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_time">time</code></td>
<td>
<p>logical. If <code>TRUE</code>, the time data is included (if available)</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that have a <code>NA</code> value in at least one layer are removed. If the argument is set to <code>NA</code> only cells that have <code>NA</code> values in all layers are removed</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_cells">cells</code></td>
<td>
<p>logical. If <code>TRUE</code>, the cell numbers of each raster cell are included</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_wide">wide</code></td>
<td>
<p>logical. If <code>FALSE</code>, the data.frame returned has a &quot;long&quot; format</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="base.html#topic+data.frame">data.frame</a></code></p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_row.names">row.names</code></td>
<td>
<p>This argument is ignored</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_optional">optional</code></td>
<td>
<p>This argument is ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.list">as.list</a>, <a href="#topic+as.matrix">as.matrix</a></code>. See <code><a href="#topic+geom">geom</a></code> to only extract the geometry of a SpatVector</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
as.data.frame(v)
</code></pre>

<hr>
<h2 id='as.lines'>Conversion to a SpatVector of lines</h2><span id='topic+as.lines'></span><span id='topic+as.lines+2CSpatRaster-method'></span><span id='topic+as.lines+2CSpatVector-method'></span><span id='topic+as.lines+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Conversion of a SpatRaster, SpatVector or SpatExtent to a SpatVector of lines. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
as.lines(x)

## S4 method for signature 'SpatVector'
as.lines(x)

## S4 method for signature 'SpatExtent'
as.lines(x, crs="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lines_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="as.lines_+3A_crs">crs</code></td>
<td>
<p>character. The coordinate reference system (see <code><a href="#topic+crs">crs</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.points">as.points</a></code>, <code><a href="#topic+as.polygons">as.polygons</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=2, nrows=2)
values(r) &lt;- 1:ncell(r)

as.lines(r)

as.lines(ext(r), crs=crs(r))

if  (gdal() &gt;= "3.0.0") {
	p &lt;- as.polygons(r)
	as.lines(p)
}
</code></pre>

<hr>
<h2 id='as.list'>Coerce a Spat* object to a list</h2><span id='topic+as.list'></span><span id='topic+as.list+2CSpatRaster-method'></span><span id='topic+as.list+2CSpatRasterDataset-method'></span><span id='topic+as.list+2CSpatRasterCollection-method'></span><span id='topic+as.list+2CSpatVector-method'></span><span id='topic+as.list+2CSpatVectorCollection-method'></span>

<h3>Description</h3>

<p>Coerce a SpatRaster, SpatRasterCollection, SpatRasterDataset, SpatVector or SpatVectorCollection to a list. With a SpatRaster, each layer becomes a list element. With a SpatRasterCollection or SpatRasterDataset, each SpatRaster becomes a list element. With a SpatVector, each variable (attribute) becomes a list element. With a SpatVectorCollection, each SpatVector becomes a list element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
as.list(x, ...)

## S4 method for signature 'SpatRasterCollection'
as.list(x, ...)

## S4 method for signature 'SpatVector'
as.list(x, geom=NULL, ...)

## S4 method for signature 'SpatVectorCollection'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.list_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatRasterDataset, SpatRasterCollection, or SpatVector</p>
</td></tr>
<tr><td><code id="as.list_+3A_geom">geom</code></td>
<td>
<p>character or NULL. If not NULL, either &quot;WKT&quot; or &quot;HEX&quot;, to get the geometry included in Well-Known-Text or hexadecimal notation. If <code>x</code> has point geometry, it can also bey &quot;XY&quot; to add the coordinates of each point</p>
</td></tr>
<tr><td><code id="as.list_+3A_...">...</code></td>
<td>
<p>Additional arguments. These are ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>see <code><a href="methods.html#topic+coerce">coerce</a></code> for <code>as.data.frame</code> with a SpatRaster; and <code><a href="#topic+geom">geom</a></code> to only extract the geometry of a SpatVector</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
as.list(v)


s &lt;- rast(system.file("ex/logo.tif", package="terra")) + 1  
as.list(s)
</code></pre>

<hr>
<h2 id='as.points'>Conversion to a SpatVector of points</h2><span id='topic+as.points'></span><span id='topic+as.points+2CSpatRaster-method'></span><span id='topic+as.points+2CSpatVector-method'></span><span id='topic+as.points+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Conversion of a SpatRaster, SpatVector or SpatExtent to a SpatVector of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
as.points(x, values=TRUE, na.rm=TRUE, na.all=FALSE)

## S4 method for signature 'SpatVector'
as.points(x, multi=FALSE, skiplast=TRUE)

## S4 method for signature 'SpatExtent'
as.points(x, crs="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.points_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="as.points_+3A_values">values</code></td>
<td>
<p>logical; include cell values as attributes?</p>
</td></tr>
<tr><td><code id="as.points_+3A_multi">multi</code></td>
<td>
<p>logical. If <code>TRUE</code> a multi-point geometry is returned</p>
</td></tr>
<tr><td><code id="as.points_+3A_skiplast">skiplast</code></td>
<td>
<p>logical. If <code>TRUE</code> the last point of a polygon (which is the same as the first point) is not included</p>
</td></tr>
<tr><td><code id="as.points_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code> cells that are <code>NA</code> are ignored</p>
</td></tr>
<tr><td><code id="as.points_+3A_na.all">na.all</code></td>
<td>
<p>logical. If <code>TRUE</code> cells are only ignored if <code>na.rm=TRUE</code> and their value is <code>NA</code> for <b>all</b> layers instead of for <code>any</code> layer</p>
</td></tr>
<tr><td><code id="as.points_+3A_crs">crs</code></td>
<td>
<p>character. The coordinate reference system (see <code><a href="#topic+crs">crs</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lines">as.lines</a></code>, <code><a href="#topic+as.points">as.points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=2, nrows=2)
values(r) &lt;- 1:ncell(r)

as.points(r)

if  (gdal() &gt;= "3.0.0") {
	p &lt;- as.polygons(r)
	as.points(p)
}
</code></pre>

<hr>
<h2 id='as.polygons'>Conversion to a SpatVector of polygons</h2><span id='topic+as.polygons'></span><span id='topic+as.polygons+2CSpatRaster-method'></span><span id='topic+as.polygons+2CSpatVector-method'></span><span id='topic+as.polygons+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Conversion of a SpatRaster, SpatVector or SpatExtent to a SpatVector of polygons. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
as.polygons(x, round=TRUE, aggregate=TRUE, values=TRUE,
		na.rm=TRUE, na.all=FALSE, extent=FALSE, digits=0, ...)

## S4 method for signature 'SpatVector'
as.polygons(x, extent=FALSE)

## S4 method for signature 'SpatExtent'
as.polygons(x, crs="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.polygons_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_round">round</code></td>
<td>
<p>logical; If <code>TRUE</code> and <code>aggregate=TRUE</code>, values are rounded before aggregation. If this value is <code>FALSE</code> the SpatVector returned can have very many polygons and can be very large</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_aggregate">aggregate</code></td>
<td>
<p>logical; combine cells with the same values? If <code>TRUE</code> only the first layer in <code>x</code> is processed</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_values">values</code></td>
<td>
<p>logical; include cell values as attributes?</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_extent">extent</code></td>
<td>
<p>logical. if <code>TRUE</code>, a polygon for the extent of the SpatRaster or SpatVector is returned. If <code>x</code> is a SpatRaster, the polygon has vertices for each row and column, not just the four corners of the raster. This can be useful for more precise projection. If that is not required, it is more efficient to get the extent represented by only the four corners with <code>as.polygons(ext(x), crs=crs(x))</code></p>
</td></tr>
<tr><td><code id="as.polygons_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code> cells that are <code>NA</code> are ignored</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_na.all">na.all</code></td>
<td>
<p>logical. If <code>TRUE</code> cells are only ignored if <code>na.rm=TRUE</code> and their value is <code>NA</code> for <b>all</b> layers instead of for <code>any</code> layer</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_digits">digits</code></td>
<td>
<p>integer. The number of digits for rounding (if <code>round=TRUE</code>)</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_crs">crs</code></td>
<td>
<p>character. The coordinate reference system (see <code><a href="#topic+crs">crs</a></code>)</p>
</td></tr>
<tr><td><code id="as.polygons_+3A_...">...</code></td>
<td>
<p>additional arguments. For backward compatibility. Will be removed in the future</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lines">as.lines</a></code>, <code><a href="#topic+as.points">as.points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=2, nrows=2)
values(r) &lt;- 1:ncell(r)

if  (gdal() &gt;= "3.0.0") {
	p &lt;- as.polygons(r)
	p
}
</code></pre>

<hr>
<h2 id='as.raster'>Coerce to a &quot;raster&quot; object</h2><span id='topic+as.raster'></span><span id='topic+as.raster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Implementation of the generic <code><a href="grDevices.html#topic+as.raster">as.raster</a></code> function to create a &quot;raster&quot; (small r) object. Such objects can be used for plotting with the <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code> function. NOT TO BE CONFUSED with the Raster* (big R) objects defined by the 'raster' package! 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
as.raster(x, maxcell=500000, col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.raster_+3A_x">x</code></td>
<td>
<p> SpatRaster </p>
</td></tr>
<tr><td><code id="as.raster_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot</p>
</td></tr>
<tr><td><code id="as.raster_+3A_col">col</code></td>
<td>
<p>vector of colors. Default is col=rev(terrain.colors(255)))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'raster' object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=3, nrows=3)
values(r) &lt;- 1:ncell(r)
as.raster(r)
</code></pre>

<hr>
<h2 id='atan2'>Two argument arc-tangent</h2><span id='topic+atan2+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+atan2'></span><span id='topic+atan_2+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+atan_2'></span>

<h3>Description</h3>

<p>For SpatRasters x and y, atan2(y, x) returns the angle in radians for the tangent y/x, handling the case when x is zero. See <code><a href="base.html#topic+Trig">Trig</a></code>
</p>
<p>See <code><a href="#topic+Math-methods">Math-methods</a></code> for other trigonometric and mathematical functions that can be used with SpatRasters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
atan2(y, x)

## S4 method for signature 'SpatRaster,SpatRaster'
atan_2(y, x, filename, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="atan2_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="atan2_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="atan2_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="atan2_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+Math-methods">Math-methods</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- rast(nrows=10, ncols=10)
r2 &lt;- rast(nrows=10, ncols=10)
values(r1) &lt;- (runif(ncell(r1))-0.5) * 10
values(r2) &lt;- (runif(ncell(r1))-0.5) * 10
atan2(r1, r2)
</code></pre>

<hr>
<h2 id='autocorrelation'>Spatial autocorrelation</h2><span id='topic+autocor'></span><span id='topic+autocor+2Cnumeric-method'></span><span id='topic+autocor+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute spatial autocorrelation for a numeric vector or a SpatRaster. You can compute standard (global) Moran's I or Geary's C, or local indicators of spatial autocorrelation (Anselin, 1995).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'numeric'
autocor(x, w, method="moran")

## S4 method for signature 'SpatRaster'
autocor(x, w=matrix(c(1,1,1,1,0,1,1,1,1),3), method="moran", global=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocorrelation_+3A_x">x</code></td>
<td>
<p>numeric or SpatRaster</p>
</td></tr>
<tr><td><code id="autocorrelation_+3A_w">w</code></td>
<td>
<p>Spatial weights defined by or a rectangular matrix. For a SpatRaster this matrix must the sides must have an odd length (3, 5, ...)</p>
</td></tr>
<tr><td><code id="autocorrelation_+3A_global">global</code></td>
<td>
<p>logical. If <code>TRUE</code> global autocorrelation is computed instead of local autocorrelation</p>
</td></tr>
<tr><td><code id="autocorrelation_+3A_method">method</code></td>
<td>
<p>character. If <code>x</code> is numeric or SpatRaster: &quot;moran&quot; for Moran's I and &quot;geary&quot; for Geary's C. If <code>x</code> is numeric also: &quot;Gi&quot;, &quot;Gi*&quot; (the Getis-Ord statistics), locmor (local Moran's I) and &quot;mean&quot; (local mean)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default setting uses a 3x3 neighborhood to compute &quot;Queen's case&quot; indices. You can use a filter (weights matrix) to do other things, such as &quot;Rook's case&quot;, or different lags. 
</p>


<h3>Value</h3>

<p>numeric or SpatRaster
</p>


<h3>References</h3>

<p>Moran, P.A.P., 1950. Notes on continuous stochastic phenomena. Biometrika 37:17-23
</p>
<p>Geary, R.C., 1954. The contiguity ratio and statistical mapping. The Incorporated Statistician 5: 115-145
</p>
<p>Anselin, L., 1995. Local indicators of spatial association-LISA. Geographical Analysis 27:93-115
</p>
<p><a href="https://en.wikipedia.org/wiki/Indicators_of_spatial_association">https://en.wikipedia.org/wiki/Indicators_of_spatial_association</a>
</p>


<h3>See Also</h3>

<p>The <code>spdep</code> package for additional and more general approaches for computing spatial autocorrelation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### raster
r &lt;- rast(nrows=10, ncols=10, xmin=0)
values(r) &lt;- 1:ncell(r)

autocor(r)

# rook's case neighbors
f &lt;- matrix(c(0,1,0,1,0,1,0,1,0), nrow=3)
autocor(r, f)

# local 
rc &lt;- autocor(r, w=f, global=FALSE)

### numeric (for vector data)
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
w &lt;- relate(v, relation="touches")

# global
autocor(v$AREA, w)

# local
v$Gi &lt;- autocor(v$AREA, w, "Gi") 
plot(v, "Gi")
</code></pre>

<hr>
<h2 id='barplot'>Bar plot of a SpatRaster</h2><span id='topic+barplot'></span><span id='topic+barplot+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Create a barplot of the values of a the first layer of a SpatRaster. For large datasets a regular sample with a size of approximately <code>maxcells</code> is used.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
barplot(height, maxcell=1000000, digits=0, breaks=NULL, col, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barplot_+3A_height">height</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="barplot_+3A_maxcell">maxcell</code></td>
<td>
<p>integer. To regularly subsample very large datasets</p>
</td></tr>
<tr><td><code id="barplot_+3A_digits">digits</code></td>
<td>
<p>integer used to determine how to <code><a href="#topic+round">round</a></code> the values before tabulating. Set to <code>NULL</code> or to a large number if you do not want any rounding </p>
</td></tr>
<tr><td><code id="barplot_+3A_breaks">breaks</code></td>
<td>
<p>breaks used to group the data as in <code><a href="base.html#topic+cut">cut</a></code></p>
</td></tr>
<tr><td><code id="barplot_+3A_col">col</code></td>
<td>
<p>a color generating function such as <code><a href="grDevices.html#topic+rainbow">rainbow</a></code> (the default), or a vector of colors</p>
</td></tr>
<tr><td><code id="barplot_+3A_...">...</code></td>
<td>
<p>additional arguments for plotting as in <code><a href="graphics.html#topic+barplot">barplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector (or matrix, when <code>beside = TRUE</code>) of the coordinates of the bar midpoints, useful for adding to the graph. See <code><a href="graphics.html#topic+barplot">barplot</a></code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+hist">hist</a>, <a href="#topic+boxplot">boxplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
barplot(r, digits=-1, las=2, ylab="Frequency")

op &lt;- par(no.readonly = TRUE)
par(mai = c(1, 2, .5, .5))
barplot(r, breaks=10, col=c("red", "blue"), horiz=TRUE, digits=NULL, las=1)
par(op)
</code></pre>

<hr>
<h2 id='boundaries'>Detect boundaries (edges)</h2><span id='topic+boundaries'></span><span id='topic+boundaries+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Detect boundaries (edges). Boundaries are cells that have more than one class in the 4 or 8 cells surrounding it, or, if <code>classes=FALSE</code>, cells with values and cells with <code>NA</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
boundaries(x, classes=FALSE, inner=TRUE, 
         directions=8, falseval=0, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundaries_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="boundaries_+3A_inner">inner</code></td>
<td>
<p>logical. If <code>TRUE</code>, &quot;inner&quot; boundaries are returned, else &quot;outer&quot; boundaries are returned</p>
</td></tr>
<tr><td><code id="boundaries_+3A_classes">classes</code></td>
<td>
<p>character. Logical. If <code>TRUE</code> all different values are (after rounding) distinguished, as well as <code>NA</code>. If <code>FALSE</code> (the default) only edges between <code>NA</code> and non-<code>NA</code> cells are considered</p>
</td></tr>
<tr><td><code id="boundaries_+3A_directions">directions</code></td>
<td>
<p>integer. Which cells are considered adjacent? Should be 8 (Queen's case) or 4 (Rook's case)</p>
</td></tr>
<tr><td><code id="boundaries_+3A_falseval">falseval</code></td>
<td>
<p>numeric. The value to use for cells that are not a boundary and not <code>NA</code></p>
</td></tr>
<tr><td><code id="boundaries_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="boundaries_+3A_...">...</code></td>
<td>
<p>options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster. Cell values are either 1 (a border) or 0 (not a border), or <code>NA</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focal">focal</a></code>, <code><a href="#topic+patches">patches</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=18, ncols=36, xmin=0)
r[150:250] &lt;- 1
r[251:450] &lt;- 2
bi &lt;- boundaries(r)
bo &lt;- boundaries(r, inner=FALSE)
bc &lt;- boundaries(r, classes=TRUE)
#plot(bc)
</code></pre>

<hr>
<h2 id='boxplot'>
Box plot of SpatRaster data
</h2><span id='topic+boxplot'></span><span id='topic+boxplot+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Box plot of layers in a SpatRaster 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
boxplot(x, y=NULL, maxcell=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="boxplot_+3A_y">y</code></td>
<td>
<p>NULL or a SpatRaster. If <code>x</code> is a SpatRaster it used to group the values of <code>x</code> by &quot;zone&quot;</p>
</td></tr>
<tr><td><code id="boxplot_+3A_maxcell">maxcell</code></td>
<td>
<p>Integer. Number of cells to sample from datasets</p>
</td></tr>
<tr><td><code id="boxplot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>graphics::<a href="graphics.html#topic+boxplot">boxplot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>boxplot returns a list (invisibly) that can be used with <code><a href="graphics.html#topic+bxp">bxp</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pairs">pairs</a>, <a href="#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- r2 &lt;- r3 &lt;- rast(ncols=10, nrows=10)
set.seed(409)
values(r1) &lt;- rnorm(ncell(r1), 100, 40)
values(r2) &lt;- rnorm(ncell(r1), 80, 10)
values(r3) &lt;- rnorm(ncell(r1), 120, 30)
s &lt;- c(r1, r2, r3)
names(s) &lt;- c("Apple", "Pear", "Cherry")

boxplot(s, notch=TRUE, col=c("red", "blue", "orange"), main="Box plot", ylab="random", las=1)

op &lt;- par(no.readonly = TRUE)
par(mar=c(4,6,2,2))
boxplot(s, horizontal=TRUE, col="lightskyblue", axes=FALSE)
axis(1)
axis(2, at=0:3, labels=c("", names(s)), las=1, cex.axis=.9, lty=0)
par(op)

## boxplot with 2 layers
v &lt;- vect(system.file("ex/lux.shp", package="terra"))
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
y &lt;- rasterize(v, r, "NAME_2")
b &lt;- boxplot(r, y)
bxp(b)
</code></pre>

<hr>
<h2 id='buffer'>Create a buffer around vector geometries or raster patches</h2><span id='topic+buffer'></span><span id='topic+buffer+2CSpatRaster-method'></span><span id='topic+buffer+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Calculate a buffer around all cells that are not <code>NA</code> in a SpatRaster, or around the geometries of a SpatVector.
</p>
<p>SpatRaster cells inside the buffer distance get a value of 1.
</p>
<p>Note that the distance unit of the buffer <code>width</code> parameter is meters if the CRS is (<code>+proj=longlat</code>), and in map units (typically also meters) if not. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
buffer(x, width, background=0, filename="", ...)

## S4 method for signature 'SpatVector'
buffer(x, width, quadsegs=10, capstyle="round", 
		joinstyle="round", mitrelimit=NA, singlesided=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buffer_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="buffer_+3A_width">width</code></td>
<td>
<p>numeric. Unit is meter if <code>x</code> has a longitude/latitude CRS, or in the units of the coordinate reference system in other cases (typically also meter). The value should be &gt; 0 if <code>x</code> is a SpatRaster. If <code>x</code> is a SpatVector, this argument is vectorized, meaning that you can provide a different value for each geometry in <code>x</code>; and you can also use the name of a variable in <code>x</code> that has the widths</p>
</td></tr>
<tr><td><code id="buffer_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="buffer_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="buffer_+3A_background">background</code></td>
<td>
<p>numeric. value to assign to cells outside the buffer. If this value is zero or FALSE, a boolean SpatRaster is returned</p>
</td></tr>  
<tr><td><code id="buffer_+3A_quadsegs">quadsegs</code></td>
<td>
<p>positive integer. Number of line segments to use to draw a quart circle</p>
</td></tr>  
<tr><td><code id="buffer_+3A_capstyle">capstyle</code></td>
<td>
<p>character. One of &quot;round&quot;, &quot;square&quot; or &quot;flat&quot;. Ignored if <code>is.lonlat(x)</code></p>
</td></tr>
<tr><td><code id="buffer_+3A_joinstyle">joinstyle</code></td>
<td>
<p>character. One of &quot;round&quot;, &quot;mitre&quot; or &quot;bevel&quot;. Ignored if <code>is.lonlat(x)</code></p>
</td></tr>  
<tr><td><code id="buffer_+3A_mitrelimit">mitrelimit</code></td>
<td>
<p>numeric. Place an upper bound on a mitre join to avoid it from extending very far from acute angles in the input geometry. Ignored if <code>is.lonlat(x)</code></p>
</td></tr>
<tr><td><code id="buffer_+3A_singlesided">singlesided</code></td>
<td>
<p>logical. If <code>TRUE</code> a buffer is constructed on only one side of each input line.  Ignored if <code>is.lonlat(x)</code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>Same as <code>x</code> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>, <code><a href="#topic+elongate">elongate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=36, nrows=18)
r[500] &lt;- 1
b &lt;- buffer(r, width=5000000) 
plot(b)

v &lt;- vect(rbind(c(10,10), c(0,60)), crs="+proj=merc")
b &lt;- buffer(v, 20)
plot(b)
points(v)

crs(v) &lt;- "+proj=longlat" 
b &lt;- buffer(v, 1500000)
plot(b)
points(v)
</code></pre>

<hr>
<h2 id='c'>Combine SpatRaster or SpatVector objects</h2><span id='topic+c'></span><span id='topic+c+2CSpatRaster-method'></span><span id='topic+c+2CSpatRasterDataset-method'></span><span id='topic+c+2CSpatRasterCollection-method'></span><span id='topic+c+2CSpatVector-method'></span><span id='topic+c+2CSpatVectorCollection-method'></span>

<h3>Description</h3>

<p>With <code>c</code> you can:
</p>
<p>&ndash; Combine <code>SpatRaster</code> objects. They must have the same extent and resolution. However, if <code>x</code> is empty (has no cell values), its geometry is ignored with a warning. Two empty SpatRasters with the same geometry can also be combined (to get a summed number of layers). Also see <code><a href="#topic+add+3C-">add&lt;-</a></code>
</p>
<p>&ndash; Add a <code>SpatRaster</code> to a <code>SpatRasterDataset</code> or <code>SpatRasterCollection</code>
</p>
<p>&ndash; Add <code>SpatVector</code> objects to a new or existing <code>SpatVectorCollection</code>
</p>
<p>To append SpatVectors, use <code>rbind</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
c(x, ..., warn=TRUE)

## S4 method for signature 'SpatRasterDataset'
c(x, ...)

## S4 method for signature 'SpatRasterCollection'
c(x, ...)

## S4 method for signature 'SpatVector'
c(x, ...)

## S4 method for signature 'SpatVectorCollection'
c(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector, SpatRasterDataset or SpatVectorCollection</p>
</td></tr>
<tr><td><code id="c_+3A_warn">warn</code></td>
<td>
<p>logical. If <code>TRUE</code>, a warning is emitted if <code>x</code> is an empty SpatRaster</p>
</td></tr>
<tr><td><code id="c_+3A_...">...</code></td>
<td>
<p>as for <code>x</code> (you can only combine raster with raster data and vector with vector data)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same class as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add+3C-">add&lt;-</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=5, ncols=9)
values(r) &lt;- 1:ncell(r)
x &lt;- c(r, r*2, r*3)
</code></pre>

<hr>
<h2 id='cartogram'>Cartogram</h2><span id='topic+cartogram'></span><span id='topic+cartogram+2CSpatVector-method'></span>

<h3>Description</h3>

 
<p>Make a cartogram, that is, a map where the area of polygons is made proportional to another variable. This can be a good way to map raw count data (e.g. votes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
cartogram(x, var, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cartogram_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="cartogram_+3A_var">var</code></td>
<td>
<p>character. A variable name in <code>x</code></p>
</td></tr>
<tr><td><code id="cartogram_+3A_type">type</code></td>
<td>
<p>character. Cartogram type, only &quot;nc&quot; (non-contiguous) is currently supported</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+plot">plot</a></code>, <code><a href="#topic+rescale">rescale</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
v$value &lt;- 1:12
p &lt;- cartogram(v, "value", "nc")
plot(v, col="light gray", border="gray")
lines(p, col="red", lwd=2)
</code></pre>

<hr>
<h2 id='catalyze'>Factors to numeric</h2><span id='topic+as.numeric'></span><span id='topic+as.numeric+2CSpatRaster-method'></span><span id='topic+catalyze'></span><span id='topic+catalyze+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Change a categorical layer into one or more numerical layers. With <code>as.numeric</code> you can transfer the active category values to cell values in a non-categorical SpatRaster. <code>catalyze</code> creates new layers for each category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
as.numeric(x, index=NULL, filename="", ...)

## S4 method for signature 'SpatRaster'
catalyze(x, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catalyze_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="catalyze_+3A_index">index</code></td>
<td>
<p>positive integer or category indicating the category to use. If <code>NULL</code> the active category is used</p>
</td></tr>
<tr><td><code id="catalyze_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>  
<tr><td><code id="catalyze_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+activeCat">activeCat</a></code>, <code><a href="#topic+cats">cats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
r &lt;- rast(nrows=10, ncols=10)
values(r) &lt;- sample(3, ncell(r), replace=TRUE) + 10
d &lt;- data.frame(id=11:13, cover=c("forest", "water", "urban"), letters=letters[1:3], value=10:12)
levels(r) &lt;- d
catalyze(r)

activeCat(r) &lt;- 3
as.numeric(r)
</code></pre>

<hr>
<h2 id='cells'>Get cell numbers</h2><span id='topic+cells'></span><span id='topic+cells+2CSpatRaster+2Cmissing-method'></span><span id='topic+cells+2CSpatRaster+2Cnumeric-method'></span><span id='topic+cells+2CSpatRaster+2CSpatVector-method'></span><span id='topic+cells+2CSpatRaster+2CSpatExtent-method'></span>

<h3>Description</h3>

 
<p>Get the cell numbers covered by a SpatVector or SpatExtent. Or that match values in a vector; or all non <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,missing'
cells(x, y)

## S4 method for signature 'SpatRaster,numeric'
cells(x, y)

## S4 method for signature 'SpatRaster,SpatVector'
cells(x, y, method="simple", weights=FALSE, exact=FALSE, touches=is.lines(y))

## S4 method for signature 'SpatRaster,SpatExtent'
cells(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cells_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="cells_+3A_y">y</code></td>
<td>
<p>SpatVector, SpatExtent, 2-column matrix representing points, numeric representing values to match, or missing</p>
</td></tr>
<tr><td><code id="cells_+3A_method">method</code></td>
<td>
<p>character. Method for getting cell numbers for points. The default is &quot;simple&quot;, the alternative is &quot;bilinear&quot;. If it is &quot;bilinear&quot;, the four nearest cells and their weights are returned</p>
</td></tr>
<tr><td><code id="cells_+3A_weights">weights</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> has polygons, the approximate fraction of each cell that is covered is returned as well</p>
</td></tr>
<tr><td><code id="cells_+3A_exact">exact</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> has polygons, the exact fraction of each cell that is covered is returned as well</p>
</td></tr>
<tr><td><code id="cells_+3A_touches">touches</code></td>
<td>
<p>logical. If <code>TRUE</code>, values for all cells touched by lines or polygons are extracted, not just those on the line render path, or whose center point is within the polygon. Not relevant for points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector or matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- 1:ncell(r)
r[c(1:25, 31:100)] &lt;- NA
r &lt;- ifel(r &gt; 28, r + 10, r)

# all cell numbers of cells that are not NA
cells(r)

# cell numbers that match values
x &lt;- cells(r, c(28,38))
x$lyr.1

# cells for points
m &lt;- cbind(x=c(0,10,-30), y=c(40,-10,20))
cellFromXY(r, m)

v &lt;- vect(m)
cells(r, v)
cells(r, v, method="bilinear")

# cells for polygons
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
r &lt;- rast(v)
cv &lt;- cells(r, v) 
</code></pre>

<hr>
<h2 id='cellSize'>Area covered by each raster cell</h2><span id='topic+cellSize'></span><span id='topic+cellSize+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute the area covered by individual raster cells. 
</p>
<p>Computing the surface area of raster cells is especially relevant for longitude/latitude rasters. 
</p>
<p>But note that for both angular (longitude/latitude) and for planar (projected) coordinate reference systems raster cells sizes are generally not constant, unless you are using an equal-area coordinate reference system. 
</p>
<p>For planar CRSs, the area is therefore not computed based on the linear units of the coordinate reference system, but on the *actual* area by transforming cells to longitude/latitude. If you do not want that correction, you can use <code>transform=FALSE</code> or <code>init(x, prod(res(x)))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
cellSize(x, mask=FALSE, lyrs=FALSE, unit="m", transform=TRUE, rcx=100, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cellSize_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="cellSize_+3A_mask">mask</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that are <code>NA</code> in <code>x</code> are also <code>NA</code> in the output</p>
</td></tr>
<tr><td><code id="cellSize_+3A_lyrs">lyrs</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>mask=TRUE</code>, the output has the same number of layers as <code>x</code>. That is only useful if cases where the layers of <code>x</code> have different cells that are <code>NA</code></p>
</td></tr>
<tr><td><code id="cellSize_+3A_unit">unit</code></td>
<td>
<p>character. One of &quot;m&quot;, &quot;km&quot;, or &quot;ha&quot;</p>
</td></tr>
<tr><td><code id="cellSize_+3A_transform">transform</code></td>
<td>
<p>logical. If <code>TRUE</code>, planar CRS data are transformed to lon/lat for accuracy</p>
</td></tr>
<tr><td><code id="cellSize_+3A_rcx">rcx</code></td>
<td>
<p>positive integer. The maximum number of rows and columns to be used to compute area of planar data if <code>transform=TRUE</code>. If <code>x</code> has more rows and/or columns, the raster is aggregated to match this limit, and values for the original cells are estimated by bilinear interpolation (see <code>resample</code>). This can save a lot of time</p>
</td></tr>
<tr><td><code id="cellSize_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="cellSize_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expanse">expanse</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# SpatRaster 
r &lt;- rast(nrows=18, ncols=36)
v &lt;- 1:ncell(r)
v[200:400] &lt;- NA
values(r) &lt;- v

# size of each raster cell
a &lt;- cellSize(r)

# illustration of distortion
r &lt;- rast(ncols=90, nrows=45, ymin=-80, ymax=80)
m &lt;- project(r, "+proj=merc")

bad &lt;- init(m, prod(res(m)) / 1000000, names="naive")
good &lt;- cellSize(m, unit="km", names="corrected")
plot(c(good, bad), nc=1, mar=c(2,2,1,6))
</code></pre>

<hr>
<h2 id='centroids'>Centroids</h2><span id='topic+centroids'></span><span id='topic+centroids+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get the centroids of polygons or lines, or centroid-like points that are guaranteed to be inside the polygons or on the lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
centroids(x, inside=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroids_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="centroids_+3A_inside">inside</code></td>
<td>
<p>logical. If <code>TRUE</code> the points returned are guaranteed to be inside the polygons or on the lines, but they are not the true centroids. True centroids may be outside a polygon, for example when a polygon is &quot;bean shaped&quot;, and they are unlikely to be on their line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector of points</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
x &lt;- centroids(v)
y &lt;- centroids(v, TRUE)
</code></pre>

<hr>
<h2 id='clamp'>Clamp values</h2><span id='topic+clamp'></span><span id='topic+clamp+2CSpatRaster-method'></span><span id='topic+clamp+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Clamp values to a minimum and maximum value. That is, all values below a lower threshold value and above the upper threshold value become either <code>NA</code>, or, if <code>values=TRUE</code>, become the threshold value  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
clamp(x, lower=-Inf, upper=Inf, values=TRUE, filename="", ...)

## S4 method for signature 'numeric'
clamp(x, lower=-Inf, upper=Inf, values=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clamp_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="clamp_+3A_lower">lower</code></td>
<td>
<p>numeric with the lowest acceptable value (you can specify a different value for each layer). Or a SpatRaster that has a single layer or the same number of layers as <code>x</code></p>
</td></tr>
<tr><td><code id="clamp_+3A_upper">upper</code></td>
<td>
<p>numeric with the highest acceptable value (you can specify a different value for each layer). Or a SpatRaster that has a single layer or the same number of layers as <code>x</code></p>
</td></tr>
<tr><td><code id="clamp_+3A_values">values</code></td>
<td>
<p>logical. If <code>FALSE</code> values outside the clamping range become <code>NA</code>, if <code>TRUE</code>, they get the extreme values</p>
</td></tr>
<tr><td><code id="clamp_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="clamp_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classify">classify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- 1:ncell(r)
rc &lt;- clamp(r, 25, 75) 
rc
</code></pre>

<hr>
<h2 id='clamp_ts'>clamp time series data</h2><span id='topic+clamp_ts'></span><span id='topic+clamp_ts+2CSpatRaster-method'></span><span id='topic+clamp_ts+2Cnumeric-method'></span>

<h3>Description</h3>

<p>clamp time-series datat that are S shaped. The value in layers before the minimum value in a cell can be set to that minimum value, and the value in layers after the maximum value for a cell can be set to that maximum value.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
clamp_ts(x, min=FALSE, max=TRUE, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clamp_ts_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="clamp_ts_+3A_min">min</code></td>
<td>
<p>logical. If <code>TRUE</code> the time-series is clamped to the minimum value</p>
</td></tr>
<tr><td><code id="clamp_ts_+3A_max">max</code></td>
<td>
<p>logical. If <code>TRUE</code> the time-series is clamped to the maximum value</p>
</td></tr>
<tr><td><code id="clamp_ts_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="clamp_ts_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clamp">clamp</a></code>, <code><a href="base.html#topic+cummin">cummin</a></code>, <code><a href="base.html#topic+cummax">cummax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sigm &lt;- function(x) { .8 / (1 + exp(-(x-10))) + runif(length(x))/4 }
r &lt;- rast(ncols=10, nrows=10, nlyr=50)
s &lt;- seq(5.2, 15,.2)
set.seed(1)
values(r) &lt;- t(replicate(100, sigm(s)))

x &lt;- clamp_ts(r, TRUE, TRUE) 

plot(unlist(r[4]))
lines(unlist(x[4]))

</code></pre>

<hr>
<h2 id='classify'>Classify (or reclassify) cell values</h2><span id='topic+classify'></span><span id='topic+classify+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Classify values of a SpatRaster. The function (re-)classifies groups of values to other values. 
</p>
<p>The classification is done based on the argument <code>rcl</code>. You can classify ranges by specifying a three-column matrix &quot;from-to-becomes&quot; or change specific values by using a two-column matrix &quot;is-becomes&quot;. You can also supply a vector with &quot;cuts&quot; or the &quot;number of cuts&quot;.
</p>
<p>With &quot;from-to-becomes&quot; or &quot;is-becomes&quot; classification is done in the row order of the matrix. Thus, if there are overlapping ranges or values, the first time a number is within a range determines the reclassification value. 
</p>
<p>With &quot;cuts&quot; the values are sorted, so that the order in which they are provided does not matter. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
classify(x, rcl, include.lowest=FALSE, right=TRUE, 
     others=NULL, brackets=TRUE, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="classify_+3A_rcl">rcl</code></td>
<td>
<p>matrix for classification. This matrix must have 1, 2 or 3 columns. If there are three columns, the first two columns are &quot;from&quot; &quot;to&quot; of the input values, and the third column &quot;becomes&quot; has the new value for that range. 
</p>
<p>The two column matrix (&quot;is&quot;, &quot;becomes&quot;) can be useful for classifying integer values. In that case, the arguments <code>right</code> and <code>include.lowest</code> are ignored.
</p>
<p>A single column matrix (or a vector) is interpreted as a set of cuts if there is more than one value. In that case the values are classified based on their location in-between the cut-values.  
</p>
<p>If a single number is provided, that is used to make that number of cuts, at equal intervals between the lowest and highest values of the SpatRaster.
</p>
</td></tr> 
<tr><td><code id="classify_+3A_include.lowest">include.lowest</code></td>
<td>
<p>logical, indicating if a value equal to the lowest value in <code>rcl</code> (or highest value in the second column, for <code>right=FALSE</code>) should be included.</p>
</td></tr>
<tr><td><code id="classify_+3A_right">right</code></td>
<td>
<p>logical. If <code>TRUE</code>, the intervals are closed on the right (and open on the left). If <code>FALSE</code> they are open at the right and closed at the left. &quot;open&quot; means that the extreme value is *not* included in the interval. Thus, right-closed and left open is <code>(0,1] = {x | 0 &lt; x &lt;= 1}</code>. You can also close both sides with <code>right=NA</code>, that is only meaningful if you &quot;from-to-becomes&quot; classification with integers. For example to classify 1-5 -&gt; 1, 6-10 -&gt; 2, 11-15 -&gt; 3. That may be easier to read and write than the equivalent 1-5 -&gt; 1, 5-10 -&gt; 2, 10-15 -&gt; 3 with <code>right=TRUE</code> and <code>include.lowest=TRUE</code></p>
</td></tr>
<tr><td><code id="classify_+3A_others">others</code></td>
<td>
<p>numeric. If not <code>NULL</code> all values that are not matched are set to this value. Otherwise they retain their original value.</p>
</td></tr> 
<tr><td><code id="classify_+3A_brackets">brackets</code></td>
<td>
<p>logical. If <code>TRUE</code>, intervals are have parenthesis or brackets around them to indicate whether they are open or closed. Only applies if <code>rcl</code> is a vector (or single column matrix)</p>
</td></tr> 
<tr><td><code id="classify_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="classify_+3A_...">...</code></td>
<td>
<p>Additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Note</h3>

<p>classify works with the &quot;raw&quot; values of categorical rasters, ignoring the levels (labels, categories). To change the labels of categorical rasters, use <code><a href="#topic+subst">subst</a></code> instead.
</p>
<p>For model-based classification see <code><a href="#topic+predict">predict</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subst">subst</a></code> for simpler from-to replacement</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- (0:99)/99

## from-to-becomes
# classify the values into three groups 
# all values &gt;= 0 and &lt;= 0.25 become 1, etc.
m &lt;- c(0, 0.25, 1,
       0.25, 0.5, 2,
       0.5, 1, 3)
rclmat &lt;- matrix(m, ncol=3, byrow=TRUE)
rc1 &lt;- classify(r, rclmat, include.lowest=TRUE)

## cuts
# equivalent to the above, but now a categorical SpatRaster is returned 
rc2 &lt;- classify(r, c(0, 0.25, 0.5, 1), include.lowest=TRUE, brackets=TRUE)
freq(rc2)

## is-becomes 
x &lt;- round(r*3)
unique(x)
# replace 0 with NA
y &lt;- classify(x, cbind(0, NA))
unique(y)

# multiple replacements
m &lt;- rbind(c(2, 200), c(3, 300))
m

rcx1 &lt;- classify(x, m)
unique(rcx1)

rcx2 &lt;- classify(x, m, others=NA)
unique(rcx2)
</code></pre>

<hr>
<h2 id='click'>Query by clicking on a map</h2><span id='topic+click'></span><span id='topic+click+2CSpatRaster-method'></span><span id='topic+click+2CSpatVector-method'></span><span id='topic+click+2Cmissing-method'></span>

<h3>Description</h3>

<p>Click on a map (plot) to get the coordinates or the values of a SpatRaster or SpatVector at that location. For a SpatRaster you can also get the coordinates and cell number of the location. 
</p>
<p>This does to work well on the default RStudio plotting device. To work around that, you can first run <code>dev.new(noRStudioGD = TRUE)</code> which will create a separate window for plotting, then use <code>plot()</code> followed by <code>click()</code> and click on the map .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
click(x, n=10, id=FALSE, xy=FALSE, cell=FALSE, type="p", show=TRUE, ...)

## S4 method for signature 'SpatVector'
click(x,  n=10, id=FALSE, xy=FALSE, type="p", show=TRUE, ...)

## S4 method for signature 'missing'
click(x, n=10, id=FALSE, type="p", show=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="click_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector, or missing</p>
</td></tr>
<tr><td><code id="click_+3A_n">n</code></td>
<td>
<p>number of clicks on the plot (map)</p>
</td></tr>
<tr><td><code id="click_+3A_id">id</code></td>
<td>
<p>logical. If <code>TRUE</code>, a numeric ID is shown on the map that corresponds to the row number of the output</p>
</td></tr>
<tr><td><code id="click_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, xy coordinates are included in the output</p>
</td></tr>
<tr><td><code id="click_+3A_cell">cell</code></td>
<td>
<p>logical. If <code>TRUE</code>, cell numbers are included in the output</p>
</td></tr>
<tr><td><code id="click_+3A_type">type</code></td>
<td>
<p>one of &quot;n&quot;, &quot;p&quot;, &quot;l&quot; or &quot;o&quot;. If &quot;p&quot; or &quot;o&quot; the points are plotted; if &quot;l&quot; or &quot;o&quot; they are joined by lines. See ?locator</p>
</td></tr>
<tr><td><code id="click_+3A_show">show</code></td>
<td>
<p>logical. Print the values after each click?</p>
</td></tr>
<tr><td><code id="click_+3A_...">...</code></td>
<td>
<p>additional graphics parameters used if type != &quot;n&quot; for plotting the locations. See ?locator</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>The value(s) of <code>x</code> at the point(s) clicked on (or touched by the box drawn).
A <code>data.frame</code> with the value(s) of all layers of SpatRaster <code>x</code> for the cell(s) clicked on; or with the attributes of the geometries of SpatVector <code>x</code> that intersect with the box drawn).
</p>


<h3>Note</h3>

<p>The plot only provides the coordinates for a spatial query, the values are read from the SpatRaster or SpatVector that is passed as an argument. Thus you can extract values from an object that has not been plotted, as long as it spatially overlaps with with the extent of the plot.
</p>
<p>Unless the process is terminated prematurely values at at most <code>n</code> positions are determined. The identification process can be terminated, depending on how you interact with R, by hitting Esc, or by clicking the right mouse button and selecting &quot;Stop&quot; from the menu, or from the &quot;Stop&quot; menu on the graphics window. 
</p>


<h3>See Also</h3>

<p><a href="#topic+draw">draw</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
r &lt;-rast(system.file("ex/elev.tif", package="terra"))
plot(r)
click(r, n=1)
## now click on the plot (map)

## End(Not run)</code></pre>

<hr>
<h2 id='coerce'>Coercion to vector, matrix or array</h2><span id='topic+as.vector'></span><span id='topic+as.matrix'></span><span id='topic+as.array'></span><span id='topic+as.vector+2CSpatRaster-method'></span><span id='topic+as.matrix+2CSpatRaster-method'></span><span id='topic+as.array+2CSpatRaster-method'></span><span id='topic+as.vector+2CSpatExtent-method'></span><span id='topic+as.matrix+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Coercion of a SpatRaster to a vector, matrix or array. Or coerce a SpatExtent to a vector or matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
as.vector(x, mode='any')

## S4 method for signature 'SpatRaster'
as.matrix(x, wide=FALSE, ...)

## S4 method for signature 'SpatRaster'
as.array(x)

## S4 method for signature 'SpatExtent'
as.vector(x, mode='any')

## S4 method for signature 'SpatExtent'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerce_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="coerce_+3A_wide">wide</code></td>
<td>
<p>logical. If <code>FALSE</code> each layer in the SpatRaster becomes a column in the matrix and each cell in the SpatRaster becomes a row. If <code>TRUE</code> each row in the SpatRaster becomes a row in the matrix and each column in the SpatRaster becomes a column in the matrix </p>
</td></tr>
<tr><td><code id="coerce_+3A_mode">mode</code></td>
<td>
<p>this argument is ignored</p>
</td></tr>
<tr><td><code id="coerce_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, matrix, or array
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.data.frame">as.data.frame</a></code> and <code><a href="#topic+as.polygons">as.polygons</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=2, nrows=2)
values(r) &lt;- 1:ncell(r)

as.vector(r)
as.matrix(r)
as.matrix(r, wide=TRUE)
as.data.frame(r, xy=TRUE)
as.array(r)

as.vector(ext(r))
as.matrix(ext(r))
</code></pre>

<hr>
<h2 id='colors'>Color table</h2><span id='topic+has.colors'></span><span id='topic+has.colors+2CSpatRaster-method'></span><span id='topic+coltab'></span><span id='topic+coltab+2CSpatRaster-method'></span><span id='topic+coltab+3C-'></span><span id='topic+coltab+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get or set color table(s) associated with a SpatRaster. Color tables are used for associating colors with values, for use in mapping (plot).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
coltab(x)

## S4 replacement method for signature 'SpatRaster'
coltab(x, ..., layer=1)&lt;-value

## S4 method for signature 'SpatRaster'
has.colors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colors_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="colors_+3A_layer">layer</code></td>
<td>
<p>positive integer, the layer number or name</p>
</td></tr>
<tr><td><code id="colors_+3A_value">value</code></td>
<td>
<p>a two-column data.frame (first column the cell value, the second column the color); 
a vector of colors (the first one is the color for value 0 and so on); or a four (value,red,green,blue) or five (including alpha) column data.frame also from 0 to n; or NULL to remove the color table. You can also supply a list of such data.frames to set a color table to all layers</p>
</td></tr>
<tr><td><code id="colors_+3A_...">...</code></td>
<td>
<p>additional arguments (none implemented)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=3, nrows=2, vals=1:6)
coltb &lt;- data.frame(value=1:6, col=rainbow(6, end=.9))
coltb

plot(r)

has.colors(r)
coltab(r) &lt;- coltb
plot(r)
has.colors(r)

tb &lt;- coltab(r)
class(tb)
dim(tb[[1]])
</code></pre>

<hr>
<h2 id='combineGeoms'> 
Combine geometries
</h2><span id='topic+combineGeoms'></span><span id='topic+combineGeoms+2CSpatVector+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Combine the geometries of one SpatVector with those of another. Geometries can be combined based on overlap, shared boundaries and distance (in that order of operation). 
</p>
<p>The typical use-case of this method is when you are editing geometries and you have a number of small polygons in one SpatVector that should be part of the geometries of the another SpatVector; perhaps because they were small holes inbetween the borders of two SpatVectors.
</p>
<p>To append SpatVectors use 'rbind' and see methods like <code>intersect</code> and <code>union</code> for &quot;normal&quot; polygons combinations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatVector'
combineGeoms(x, y, overlap=TRUE, boundary=TRUE, distance=TRUE,
	append=TRUE, minover=0.1, maxdist=Inf, dissolve=TRUE, erase=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combineGeoms_+3A_x">x</code></td>
<td>
<p>SpatVector of polygons</p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_y">y</code></td>
<td>
<p>SpatVector of polygons geometries that are to be combined with <code>x</code></p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_overlap">overlap</code></td>
<td>
<p>logical. If <code>TRUE</code>, a geometry is combined with the geometry it has most overlap with, if the overlap is above <code>minover</code></p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_boundary">boundary</code></td>
<td>
<p>logical. If <code>TRUE</code>, a geometry is combined with the geometry it has most shared border with</p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_distance">distance</code></td>
<td>
<p>logical. If <code>TRUE</code>, a geometry is combined with the geometry it is nearest to</p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_append">append</code></td>
<td>
<p>logical. Should remaining geometries be appended to the output? Not relevant if <code>distance=TRUE</code></p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_minover">minover</code></td>
<td>
<p>numeric. The fraction of the geometry in <code>y</code> that overlaps with a geometry in <code>x</code>. Below this threshold, geometries are not considered overlapping</p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_maxdist">maxdist</code></td>
<td>
<p>numeric. Geometries further away from each other than this distance (in meters) will not be combined</p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_dissolve">dissolve</code></td>
<td>
<p>logical. Should internal boundaries be dissolved?</p>
</td></tr>
<tr><td><code id="combineGeoms_+3A_erase">erase</code></td>
<td>
<p>logical. If <code>TRUE</code> no new overlapping areas are created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+union">union</a></code>, <code><a href="#topic+erase">erase</a></code>, <code><a href="#topic+intersect">intersect</a></code>
</p>
<p><code><a href="#topic+sharedPaths">sharedPaths</a></code>, <code><a href="#topic+erase">erase</a></code>, <code><a href="#topic+intersect">intersect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- vect("POLYGON ((0 0, 8 0, 8 9, 0 9, 0 0))")
x2 &lt;- vect("POLYGON ((10 4, 12 4, 12 7, 11 7, 11 6, 10 6, 10 4))")

y1 &lt;- vect("POLYGON ((5 6, 15 6, 15 15, 5 15, 5 6))")
y2 &lt;- vect("POLYGON ((8 2, 9 2, 9 3, 8 3, 8 2))")
y3 &lt;- vect("POLYGON ((2 6, 3 6, 3 8, 2 8, 2 6))")
y4 &lt;- vect("POLYGON ((2 12, 3 12, 3 13, 2 13, 2 12))")

x &lt;- rbind(x1, x2)
values(x) &lt;- data.frame(xid=1:2)
crs(x) &lt;- "+proj=utm +zone=1"

y &lt;- rbind(y1, y2, y3, y4)
values(y) &lt;- data.frame(yid=letters[1:4])
crs(y) &lt;- "+proj=utm +zone=1"

plot(rbind(x, y), border=c(rep("red",2), rep("blue", 4)), lwd=2)
text(x, "xid")
text(y, "yid")

v &lt;- combineGeoms(x, y)
plot(v, col=c("red", "blue"))

v &lt;- combineGeoms(x, y, boundary=FALSE, maxdist=1, minover=.05)
plot(v, col=rainbow(4))
</code></pre>

<hr>
<h2 id='Compare-methods'>Compare and logical methods</h2><span id='topic+Compare-methods'></span><span id='topic+Logic-methods'></span><span id='topic+logic'></span><span id='topic+compare'></span><span id='topic+Compare+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+Compare+2Cnumeric+2CSpatRaster-method'></span><span id='topic+Compare+2CSpatRaster+2Cnumeric-method'></span><span id='topic+Compare+2CSpatRaster+2Ccharacter-method'></span><span id='topic+Compare+2CSpatRaster+2Cmatrix-method'></span><span id='topic+Compare+2Cmatrix+2CSpatRaster-method'></span><span id='topic+Logic+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+Logic+2CSpatRaster+2Cnumeric-method'></span><span id='topic+Logic+2Cnumeric+2CSpatRaster-method'></span><span id='topic+Logic+2CSpatRaster+2Clogical-method'></span><span id='topic+Logic+2Clogical+2CSpatRaster-method'></span><span id='topic+Compare+2CSpatExtent+2CSpatExtent-method'></span><span id='topic+is.na+2CSpatRaster-method'></span><span id='topic+is.nan+2CSpatRaster-method'></span><span id='topic++21+2CSpatRaster-method'></span><span id='topic+is.finite+2CSpatRaster-method'></span><span id='topic+is.infinite+2CSpatRaster-method'></span><span id='topic+logic+2CSpatRaster-method'></span><span id='topic+compare+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Standard comparison and logical operators for computations with SpatRasters. Computations are local (applied on a cell by cell basis). If multiple SpatRasters are used, these must have the same geometry (extent and resolution). These operators have been implemented:
</p>
<p><b>Logical</b>: <code>!, &amp;, |, isTRUE, isFALSE</code>
</p>
<p><b>Compare</b>: <code> ==, !=, &gt;, &lt;,  &lt;=, &gt;=, is.na, is.nan, is.finite, is.infinite</code>
</p>
<p>See <code><a href="#topic+not.na">not.na</a></code> for the inverse of <code>is.na</code>, and <code><a href="#topic+noNA">noNA</a></code> to detect cells with missing value across layers.
</p>
<p>The <code>compare</code> and <code>logic</code> methods implement these operators in a method that can return <code>NA</code> istead of <code>FALSE</code> and allows for setting an output filename.
</p>
<p>The terra package does not distinguish between <code>NA</code> (not available) and <code>NaN</code> (not a number). In most cases this state is represented by <code>NaN</code>.  
</p>
<p>If you use a SpatRaster with a vector of multiple numbers, each element in the vector is considered a layer (with a constant value). If you use a SpatRaster with a matrix, the number of columns of the matrix must match the number of layers of the SpatRaster. The rows are used to match the cells. That is, if there are two rows, these match cells 1 and 2, and they are recycled to 3 and 4, etc. 
</p>
<p>The following method has been implemented for <b>(SpatExtent, SpatExtent)</b>: <code>==</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
compare(x, y, oper, falseNA=FALSE, filename="", overwrite=FALSE, ...)

## S4 method for signature 'SpatRaster'
logic(x, oper, falseNA=FALSE, filename="", overwrite=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Compare-methods_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="Compare-methods_+3A_y">y</code></td>
<td>
<p>SpatRaster or numeric</p>
</td></tr>
<tr><td><code id="Compare-methods_+3A_oper">oper</code></td>
<td>
<p>character. Operator name. For <code>compare</code> this can be one of <code>"==", "!=", "&gt;", "&lt;", "&gt;=", "&lt;="</code> and for <code>logic</code> it can be one of <code>"!", "is.na", "allNA", "noNA", "is.infinite", "is.finite", "iSTRUE", "isFALSE"</code></p>
</td></tr>
<tr><td><code id="Compare-methods_+3A_falsena">falseNA</code></td>
<td>
<p>logical. Should the result be <code>TRUE, NA</code> instead of <code>TRUE, FALSE</code>?</p>
</td></tr>
<tr><td><code id="Compare-methods_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="Compare-methods_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="Compare-methods_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster or SpatExtent
</p>


<h3>See Also</h3>

<p><code><a href="#topic+all.equal">all.equal</a></code>, <a href="#topic+Arith-methods">Arith-methods</a>. See <code><a href="#topic+ifel">ifel</a></code> to conveniently combine operations and <code><a href="#topic+Math-methods">Math-methods</a></code> or <code><a href="#topic+app">app</a></code> to apply any R function to a SpatRaster. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- rast(ncols=10, nrows=10)
values(r1) &lt;- runif(ncell(r1))
r1[10:20] &lt;- NA
r2 &lt;- rast(r1)
values(r2) &lt;- 1:ncell(r2) / ncell(r2)

x &lt;- is.na(r1)
!x
r1 == r2 
compare(r1, r2, "==")
compare(r1, r2, "==", TRUE)
</code></pre>

<hr>
<h2 id='compareGeom'>Compare geometries of SpatRasters</h2><span id='topic+compareGeom'></span><span id='topic+compareGeom+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+compareGeom+2CSpatRaster+2CSpatRasterCollection-method'></span><span id='topic+compareGeom+2CSpatRaster+2Clist-method'></span><span id='topic+compareGeom+2CSpatRasterCollection+2Cmissing-method'></span><span id='topic+compareGeom+2CSpatVector+2CSpatVector-method'></span><span id='topic+compareGeom+2CSpatVector+2Cmissing-method'></span>

<h3>Description</h3>

<p>Evaluate whether two SpatRasters have the same extent, number of rows and columns, projection, resolution, and origin (or a subset of these comparisons). 
</p>
<p>Or evaluate whether two SpatVectors have the same geometries, or whether a SpatVector has duplicated geometries. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
compareGeom(x, y, ..., lyrs=FALSE, crs=TRUE, warncrs=FALSE, ext=TRUE,
	rowcol=TRUE, res=FALSE, stopOnError=TRUE, messages=FALSE)

## S4 method for signature 'SpatVector,SpatVector'
compareGeom(x, y, tolerance=0)

## S4 method for signature 'SpatVector,missing'
compareGeom(x, y, tolerance=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareGeom_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_y">y</code></td>
<td>
<p>Same as <code>x</code>. If <code>x</code> is a SpatRaster, <code>y</code> can also be a list of SpatRasters. If <code>x</code> is a SpatVector, <code>y</code> can be missing</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_...">...</code></td>
<td>
<p>Additional SpatRasters</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_lyrs">lyrs</code></td>
<td>
<p>logical. If <code>TRUE</code>, the number of layers is compared</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_crs">crs</code></td>
<td>
<p>logical. If <code>TRUE</code>, coordinate reference systems are compared</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_warncrs">warncrs</code></td>
<td>
<p>logical. If <code>TRUE</code>, a warning is given if the crs is different (instead of an error)</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_ext">ext</code></td>
<td>
<p>logical. If <code>TRUE</code>, bounding boxes are compared</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_rowcol">rowcol</code></td>
<td>
<p>logical. If <code>TRUE</code>, number of rows and columns of the objects are compared</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_res">res</code></td>
<td>
<p>logical. If <code>TRUE</code>, resolutions are compared (redundant when checking extent and rowcol)</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_stoponerror">stopOnError</code></td>
<td>
<p>logical. If <code>TRUE</code>, code execution stops if raster do not match</p>
</td></tr>
<tr><td><code id="compareGeom_+3A_messages">messages</code></td>
<td>
<p>logical. If <code>TRUE</code>, warning/error messages are printed even if <code>stopOnError=FALSE</code></p>
</td></tr>
<tr><td><code id="compareGeom_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical (SpatRaster) or matrix of logical (SpatVector)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- rast()
r2 &lt;- rast()
r3 &lt;- rast()
compareGeom(r1, r2, r3)
nrow(r3) &lt;- 10


## Not run: 
compareGeom(r1, r3)

## End(Not run)
</code></pre>

<hr>
<h2 id='concats'>Concatenate categorical rasters</h2><span id='topic+concats'></span><span id='topic+concats+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Combine two categorical rasters by concatenating their levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
concats(x, y, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concats_+3A_x">x</code></td>
<td>
<p>SpatRaster (with a single, categorical, layer)</p>
</td></tr>
<tr><td><code id="concats_+3A_y">y</code></td>
<td>
<p>SpatRaster (with a single, categorical, layer)</p>
</td></tr>
<tr><td><code id="concats_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>  
<tr><td><code id="concats_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cats">cats</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
r &lt;- rast(nrows=10, ncols=10)
values(r) &lt;- sample(3, ncell(r), replace=TRUE)
levels(r) &lt;- data.frame(id=1:3, cover=c("forest", "water", "urban"))

rr &lt;- rast(r)
values(rr) &lt;- sample(1:3, ncell(rr), replace=TRUE)
levels(rr) &lt;- data.frame(id=c(1:3), color=c("red", "green", "blue"))

x &lt;- concats(r, rr)
x
levels(x)[[1]]
</code></pre>

<hr>
<h2 id='contour'>Contour plot</h2><span id='topic+contour'></span><span id='topic+contour+2CSpatRaster-method'></span><span id='topic+as.contour'></span><span id='topic+as.contour+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Contour lines of a SpatRaster. Use <code>add=TRUE</code> to add the lines to the current plot.  See <code>graphics::<a href="graphics.html#topic+contour">contour</a></code> for details. 
</p>
<p>if <code>filled=TRUE</code>, a new filled contour plot is made. See <code>graphics::<a href="graphics.html#topic+filled.contour">filled.contour</a></code> for details.
</p>
<p><code>as.contour</code> returns the contour lines as a SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
contour(x, maxcells=100000, filled=FALSE, ...)

## S4 method for signature 'SpatRaster'
as.contour(x, maxcells=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contour_+3A_x">x</code></td>
<td>
<p>SpatRaster. Only the first layer is used</p>
</td></tr>
<tr><td><code id="contour_+3A_maxcells">maxcells</code></td>
<td>
<p>maximum number of pixels used to create the contours</p>
</td></tr>
<tr><td><code id="contour_+3A_filled">filled</code></td>
<td>
<p>logical. If <code>TRUE</code>, a <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> plot is made</p>
</td></tr>
<tr><td><code id="contour_+3A_...">...</code></td>
<td>
<p>any argument that can be passed to <code><a href="graphics.html#topic+contour">contour</a></code> or  <code><a href="graphics.html#topic+filled.contour">filled.contour</a></code> (graphics package)</p>
</td></tr>  
</table>


<h3>See Also</h3>

 
<p><code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/elev.tif", package="terra"))
plot(r)
contour(r, add=TRUE)

v &lt;- as.contour(r)
plot(r)
lines(v)

contour(r, filled=TRUE, nlevels=5)

## if you want a SpatVector with contour lines
template &lt;- disagg(rast(r), 10)
rr &lt;- resample(r, template)
rr &lt;- floor(rr/100) * 100
v &lt;- as.polygons(rr)
plot(v, 1, col=terrain.colors(7))

</code></pre>

<hr>
<h2 id='convHull'> 
Convex hull, minimal bounding rotated rectangle, and minimal bounding circle
</h2><span id='topic+convHull'></span><span id='topic+convHull+2CSpatVector-method'></span><span id='topic+minRect'></span><span id='topic+minRect+2CSpatVector-method'></span><span id='topic+minCircle'></span><span id='topic+minCircle+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get the convex hull, the minimal bounding rotated rectangle, or minimal bounding circle of a SpatVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
convHull(x, by="")

## S4 method for signature 'SpatVector'
minRect(x, by="")

## S4 method for signature 'SpatVector'
minCircle(x, by="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convHull_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="convHull_+3A_by">by</code></td>
<td>
<p>character (variable name), to get a new geometry for groups of input geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- vect(system.file("ex/lux.shp", package="terra"))
h &lt;- convHull(p)

hh &lt;- convHull(p, "NAME_1")
rr &lt;- minRect(p, "NAME_1")

plot(rr, lwd=5, border="gray")
plot(hh, "NAME_1", col=rainbow(10, alpha=.5), lwd=3, add=TRUE, plg=list(x="topright"))
lines(aggregate(p, "NAME_1"), col="blue", lty=2, lwd=2)

</code></pre>

<hr>
<h2 id='costDist'>Cost distance</h2><span id='topic+costDistance'></span><span id='topic+costDistance+2CSpatRaster-method'></span><span id='topic+costDist'></span><span id='topic+costDist+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Use a friction (cost) surface to compute the cost-distance from any cell to the border of one or more target cells. 
</p>
<p>Distances are computed by summing local distances between cells, which are connected with their neighbors in 8 directions, and assuming that the path has to go through the centers of one of the neighboring raster cells. 
</p>
<p>Distances are multiplied with the friction, thus to get the cost-distance, the friction surface must express the cost per unit distance (speed) of travel. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
costDist(x, target=0, scale=1, maxiter=50, filename="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="costDist_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="costDist_+3A_target">target</code></td>
<td>
<p>numeric. value of the target cells (where to compute cost-distance to)</p>
</td></tr>
<tr><td><code id="costDist_+3A_scale">scale</code></td>
<td>
<p>numeric. Scale factor. The cost distance is divided by this number</p>
</td></tr>
<tr><td><code id="costDist_+3A_maxiter">maxiter</code></td>
<td>
<p>numeric. The maximum number of iterations. Increase this number if you get the warning that <code>costDistance did not converge</code></p>
</td></tr>
<tr><td><code id="costDist_+3A_filename">filename</code></td>
<td>
<p>character. output filename (optional)</p>
</td></tr>
<tr><td><code id="costDist_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

<p><code><a href="#topic+gridDist">gridDist</a>, <a href="#topic+distance">distance</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=5, nrows=5, crs="+proj=utm +zone=1 +datum=WGS84", 
		xmin=0, xmax=5, ymin=0, ymax=5, vals=1)
r[13] &lt;- 0
d &lt;- costDist(r)
plot(d)
text(d, digits=1)

r &lt;- rast(ncols=10, nrows=10,  xmin=0, xmax=10, ymin=0, ymax=10, 
		   vals=10, crs="+proj=utm +zone=1 +datum=WGS84")
r[5, 1] &lt;- -10
r[2:3, 1] &lt;- r[1, 2:4] &lt;- r[2, 5] &lt;- 0
r[3, 6] &lt;- r[2, 7] &lt;- r[1, 8:9] &lt;- 0
r[6, 6:10] &lt;- NA
r[6:9, 6] &lt;- NA

d &lt;- costDist(r, -10)
plot(d)
text(d, digits=1, cex=.8)
</code></pre>

<hr>
<h2 id='cover'>Replace values with values from another object</h2><span id='topic+cover'></span><span id='topic+cover+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+cover+2CSpatVector+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Replace <code>NA</code> or other values in SpatRaster <code>x</code> with the values of SpatRaster <code>y</code>
</p>
<p>For polygons: areas of <code>x</code> that overlap with <code>y</code> are replaced by <code>y</code> or, if <code>identity=TRUE</code> intersected with <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
cover(x, y, values=NA, filename="", ...)

## S4 method for signature 'SpatVector,SpatVector'
cover(x, y, identity=FALSE, expand=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cover_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="cover_+3A_y">y</code></td>
<td>
<p>Same as <code>x</code></p>
</td></tr>
<tr><td><code id="cover_+3A_values">values</code></td>
<td>
<p>numeric. The cell values in <code>x</code> to be replaced by the values in <code>y</code></p>
</td></tr>
<tr><td><code id="cover_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="cover_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="cover_+3A_identity">identity</code></td>
<td>
<p>logical. If <code>TRUE</code> overlapping areas are intersected rather than replaced</p>
</td></tr>
<tr><td><code id="cover_+3A_expand">expand</code></td>
<td>
<p>logical. Should parts of <code>y</code> that are outside of <code>x</code> be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- r2 &lt;- rast(ncols=36, nrows=18)
values(r1) &lt;- 1:ncell(r1)
values(r2) &lt;- runif(ncell(r2))
r2 &lt;- classify(r2, cbind(-Inf, 0.5, NA))
r3 &lt;- cover(r2, r1)


p &lt;- vect(system.file("ex/lux.shp", package="terra"))
e &lt;- as.polygons(ext(6, 6.4, 49.75, 50))
values(e) &lt;- data.frame(y=10)

cv &lt;- cover(p, e)
plot(cv, col=rainbow(12))
ci &lt;- cover(p, e, identity=TRUE)
lines(e, lwd=3)

plot(ci, col=rainbow(12))
lines(e, lwd=3)

</code></pre>

<hr>
<h2 id='crds'>Get the coordinates of SpatVector geometries or SpatRaster cells</h2><span id='topic+crds'></span><span id='topic+crds+2CSpatVector-method'></span><span id='topic+crds+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get the coordinates of a SpatVector or SpatRaster cells. A matrix or data.frame of the x (longitude) and y (latitude) coordinates is returned. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
crds(x, df=FALSE, list=FALSE)

## S4 method for signature 'SpatRaster'
crds(x, df=FALSE, na.rm=TRUE, na.all=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crds_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="crds_+3A_df">df</code></td>
<td>
<p>logical. If <code>TRUE</code> a <code>data.frame</code> is returned instead of a matrix</p>
</td></tr>  
<tr><td><code id="crds_+3A_list">list</code></td>
<td>
<p>logical. If <code>TRUE</code> a <code>list</code> is returned instead of a matrix</p>
</td></tr>  
<tr><td><code id="crds_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code> cells that are <code>NA</code> are excluded. Ignored if the SpatRaster is a template with no associated cell values</p>
</td></tr>  
<tr><td><code id="crds_+3A_na.all">na.all</code></td>
<td>
<p>logical. If <code>TRUE</code> cells are only ignored if <code>na.rm=TRUE</code> and their value is <code>NA</code> for <b>all</b> layers instead of for <code>any</code> layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom">geom</a></code> returns the complete structure of SpatVector geometries. For SpatRaster see <code><a href="#topic+xyFromCell">xyFromCell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rbind(c(-175,-20), c(-140,55), c(10, 0), c(-140,-60))
x2 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))
x3 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
x4 &lt;- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))
z &lt;- rbind(cbind(object=1, part=1, x1), cbind(object=2, part=1, x2), 
           cbind(object=3, part=1, x3), cbind(object=3, part=2, x4))
colnames(z)[3:4] &lt;- c('x', 'y')
z &lt;- cbind(z, hole=0)
z[(z[, "object"]==3 &amp; z[,"part"]==2), "hole"] &lt;- 1

p &lt;- vect(z, "polygons")
crds(p)

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
g &lt;- crds(v)
head(g)

</code></pre>

<hr>
<h2 id='crop'>Cut out a geographic subset</h2><span id='topic+crop'></span><span id='topic+crop+2CSpatRaster-method'></span><span id='topic+crop+2CSpatRasterDataset-method'></span><span id='topic+crop+2CSpatRasterCollection-method'></span><span id='topic+crop+2CSpatVector-method'></span><span id='topic+crop+2CSpatGraticule-method'></span>

<h3>Description</h3>

<p>Cut out a part of a SpatRaster or SpatVector. 
</p>
<p>You can crop a SpatRaster with a SpatExtent, or with another object from which an extent can be obtained. Note that the SpatRaster returned may not have the exactly the same extent as the SpatExtent supplied because you can only select entire cells (rows and columns), and you cannot add new areas. See methods like <code><a href="#topic+resample">resample</a></code> and <code><a href="#topic+disagg">disagg</a></code> to force SpatRasters to align and <code><a href="#topic+extend">extend</a></code> to add rows and/or columns.
</p>
<p>You can only crop rectangular areas of a SpatRaster, but see argument <code>mask=TRUE</code> for setting cell values within SpatRaster to <code>NA</code>; or use the <code><a href="#topic+mask">mask</a></code> method after crop for additional masking options.
</p>
<p>You can crop a SpatVector with another SpatVector. If these are not polygons, the minimum convex hull is used. Unlike with <code><a href="#topic+intersect">intersect</a></code> the geometries and attributes of <code>y</code> are not transferred to the output. You can also crop a SpatVector with a rectangle (SpatRaster, SpatExtent).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
crop(x, y, snap="near", mask=FALSE, touches=TRUE, extend=FALSE, filename="", ...)

## S4 method for signature 'SpatRasterDataset'
crop(x, y, snap="near", extend=FALSE)

## S4 method for signature 'SpatRasterCollection'
crop(x, y, snap="near", extend=FALSE)

## S4 method for signature 'SpatVector'
crop(x, y, ext=FALSE)

## S4 method for signature 'SpatGraticule'
crop(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="crop_+3A_y">y</code></td>
<td>
<p>SpatRaster, SpatVector, SpatExtent, or any other object that has a SpatExtent (<code><a href="#topic+ext">ext</a></code> returns a <code>SpatExtent</code>)</p>
</td></tr>
<tr><td><code id="crop_+3A_snap">snap</code></td>
<td>
<p>character. One of &quot;near&quot;, &quot;in&quot;, or &quot;out&quot;. Used to align <code>y</code> to the geometry of <code>x</code></p>
</td></tr> 
<tr><td><code id="crop_+3A_mask">mask</code></td>
<td>
<p>logical. Should <code>y</code> be used to mask? Only used if <code>y</code> is a SpatVector, SpatRaster or sf</p>
</td></tr>  
<tr><td><code id="crop_+3A_touches">touches</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>mask=TRUE</code>, all cells touched by lines or polygons will be masked, not just those on the line render path, or whose center point is within the polygon</p>
</td></tr>
<tr><td><code id="crop_+3A_extend">extend</code></td>
<td>
<p>logical. Should rows and/or columns be added if <code>y</code> is beyond the extent of <code>x</code>? Also see <code><a href="#topic+extend">extend</a></code></p>
</td></tr>  
<tr><td><code id="crop_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="crop_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="crop_+3A_ext">ext</code></td>
<td>
<p>logical. Use the extent of <code>y</code> instead of <code>y</code>. This also changes the behavior when <code>y</code> is an extent in two ways: (1) points that are on the extent boundary are removed and (2) lon/lat extents that go beyond -180 or 180 degrees longitude are wrapped around the earth to include areas at the other end of the dateline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect">intersect</a></code>, <code><a href="#topic+extend">extend</a></code>
</p>
<p>See <code>window</code> for a virtual and sometimes more efficient way to crop a dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(xmin=0, xmax=10, ymin=0, ymax=10, nrows=25, ncols=25)
values(r) &lt;- 1:ncell(r)
e &lt;- ext(-5, 5, -5, 5)
rc &lt;- crop(r, e)

# crop and mask
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
cm &lt;- crop(r, v[9:12,], mask=TRUE)
plot(cm)
lines(v)

# crop vector
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
e &lt;- ext(6.15, 6.3, 49.7, 49.8)
x &lt;- crop(v, e)
plot(x, "NAME_1")
</code></pre>

<hr>
<h2 id='crosstab'>Cross-tabulate</h2><span id='topic+crosstab'></span><span id='topic+crosstab+2CSpatRaster+2Cmissing-method'></span>

<h3>Description</h3>

<p>Cross-tabulate the layers of a SpatRaster to create a contingency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,missing'
crosstab(x, digits=0, long=FALSE, useNA=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crosstab_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="crosstab_+3A_digits">digits</code></td>
<td>
<p>integer. The number of digits for rounding the values before cross-tabulation</p>
</td></tr>
<tr><td><code id="crosstab_+3A_long">long</code></td>
<td>
<p>logical. If <code>TRUE</code> the results are returned in 'long' format data.frame instead of a table</p>
</td></tr>
<tr><td><code id="crosstab_+3A_usena">useNA</code></td>
<td>
<p>logical, indicting if the table should includes counts of <code>NA</code> values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table or data.frame
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+freq">freq</a></code>, <code><a href="#topic+zonal">zonal</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- s &lt;- rast(nc=5, nr=5)
set.seed(1)
values(r) &lt;- runif(ncell(r)) * 2
values(s) &lt;- runif(ncell(r)) * 3
x &lt;- c(r, s)

crosstab(x)

rs &lt;- r/s
r[1:5] &lt;- NA
s[20:25] &lt;- NA
x &lt;- c(r, s, rs)
crosstab(x, useNA=TRUE, long=TRUE)
</code></pre>

<hr>
<h2 id='crs'> Get or set a coordinate reference system </h2><span id='topic+crs'></span><span id='topic+crs+3C-'></span><span id='topic+crs+2CSpatExtent-method'></span><span id='topic+crs+2CSpatRaster-method'></span><span id='topic+crs+2CSpatRasterDataset-method'></span><span id='topic+crs+3C-+2CSpatRaster-method'></span><span id='topic+crs+3C-+2CSpatRaster+2CANY-method'></span><span id='topic+crs+2CSpatVector-method'></span><span id='topic+crs+2CSpatVectorProxy-method'></span><span id='topic+crs+2CSpatVectorCollection-method'></span><span id='topic+crs+3C-+2CSpatVector-method'></span><span id='topic+crs+3C-+2CSpatVector+2CANY-method'></span><span id='topic+crs+2Csf-method'></span><span id='topic+crs+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get or set the coordinate reference system (CRS), also referred to as a &quot;projection&quot;, of a SpatRaster or SpatVector. 
</p>
<p>Setting a new CRS does not change the data itself, it just changes the label. So you should only set the CRS of a dataset (if it does not come with one) to what it *is*, not to what you would *like it to be*. See <code><a href="#topic+project">project</a></code> to *transform* an object from one CRS to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
crs(x, proj=FALSE, describe=FALSE, parse=FALSE)

## S4 method for signature 'SpatVector'
crs(x, proj=FALSE, describe=FALSE, parse=FALSE)

## S4 method for signature 'character'
crs(x, proj=FALSE, describe=FALSE, parse=FALSE)

## S4 replacement method for signature 'SpatRaster'
crs(x, warn=FALSE)&lt;-value

## S4 replacement method for signature 'SpatVector'
crs(x, warn=FALSE)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crs_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="crs_+3A_proj">proj</code></td>
<td>
<p>logical. If <code>TRUE</code> the crs is returned in PROJ-string notation</p>
</td></tr>
<tr><td><code id="crs_+3A_describe">describe</code></td>
<td>
<p>logical. If <code>TRUE</code> the name, EPSG code, and the name and extent of the area of use are returned if known</p>
</td></tr>
<tr><td><code id="crs_+3A_warn">warn</code></td>
<td>
<p>logical. If <code>TRUE</code>, a message is printed when the object already has a non-empty crs</p>
</td></tr>
<tr><td><code id="crs_+3A_value">value</code></td>
<td>
<p>character string describing a coordinate reference system. This can be in a WKT format, as a &lt;authority:number&gt; code such as &quot;EPSG:4326&quot;, or a PROJ-string format such as &quot;+proj=utm +zone=12&quot; (see Note)</p>
</td></tr>
<tr><td><code id="crs_+3A_parse">parse</code></td>
<td>
<p>logical. If <code>TRUE</code>, wkt parts are parsed into a vector (each line becomes an element)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character or modified SpatRaster/Vector
</p>


<h3>Note</h3>

<p>Projections are handled by the PROJ/GDAL libraries. Recent changes in the PROJ library to improve transformations between datums have degraded the library's usability. The PROJ developers suggest to no longer use the proj-string notation to define a CRS, but use the WKT2 or &lt;authority&gt;:&lt;code&gt; notation instead. These alternative systems work for formally described CRSs that are in databases, but they do not cover the infinite number of CRSs that exist. It is not practical to define one's own custom CRS with WKT2. Moreover, unlike the proj-notation, these newer systems are hard to read and that leads to code that cannot be easily understood and, therefore, is more error-prone.
</p>
<p>It is still possible to use the PROJ-string notation with one major caveat: the datum should be WGS84 (or the equivalent NAD83) &ndash; if you want to transform your data to a coordinate reference system with a different datum. Thus as long as you use WGS84, or an ellipsoid instead of a datum, you can safely use PROJ-strings to represent your CRS; including to define your own custom CRS.
</p>
<p>You can also set the crs to &quot;local&quot; to get an informal coordinate system on an arbitrary Euclidean (Cartesian) plane with units in meter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast()
crs(r)
crs(r, describe=TRUE, proj=TRUE)

crs(r) &lt;- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84"
crs(r)

# You can use epsg codes
crs(r)  &lt;- "epsg:25831"
crs(r, describe=TRUE)$area

crs("epsg:25831", describe=TRUE)
</code></pre>

<hr>
<h2 id='datatype'>Data type of a SpatRaster or SpatVector</h2><span id='topic+datatype'></span><span id='topic+datatype+2CSpatVector-method'></span><span id='topic+datatype+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get the data types of the fields (attributes, variables) of a SpatVector or of the file(s) associated with a SpatRaster. A (layer of a) SpatRaster has no datatype if it has no values, or if the values are in memory. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
datatype(x, bylyr=TRUE)

## S4 method for signature 'SpatVector'
datatype(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datatype_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="datatype_+3A_bylyr">bylyr</code></td>
<td>
<p>logical. If <code>TRUE</code> a value is returned for each layer. Otherwise, a value is returned for each data source (such as a file)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.bool">Raster data types</a></code> to check / set the type of SpatRaster values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
datatype(v)

f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
datatype(r)

# no data type
datatype(rast()) 
</code></pre>

<hr>
<h2 id='deepcopy'>Deep copy</h2><span id='topic+deepcopy'></span><span id='topic+deepcopy+2CSpatRaster-method'></span><span id='topic+deepcopy+2CSpatVector-method'></span>

<h3>Description</h3>

 
<p>Make a deep copy of a SpatRaster or SpatVector. This is occasionally useful when wanting to use a replacement function in a shallow copy. That is a copy that was created like this: <code>x &lt;- y</code>. If you use a replacement function to change an object, its shallow copies also change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
deepcopy(x)

## S4 method for signature 'SpatVector'
deepcopy(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deepcopy_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10, nl=3)
tm &lt;- as.Date("2001-05-03") + 1:3
time(r) &lt;- tm
time(r)
x &lt;- r
time(x) &lt;- tm + 365
time(x)
time(r)

y &lt;- deepcopy(r)
time(y) &lt;- tm - 365
time(y)
time(r)

# or make a new object like this
z &lt;- rast(r)
time(z) &lt;- tm
time(z)
time(r)
</code></pre>

<hr>
<h2 id='densify'> 
Add additional nodes to lines or polygons
</h2><span id='topic+densify'></span><span id='topic+densify+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Add additional nodes to lines or polygons. This can be useful to do prior to using <code>project</code> such that the path does not change too much.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
densify(x, interval, equalize=TRUE, flat=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densify_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="densify_+3A_interval">interval</code></td>
<td>
<p>positive number, specifying the desired minimum distance between nodes. The unit is meter for lonlat data, and in the linear unit of the crs for planar data</p>
</td></tr>
<tr><td><code id="densify_+3A_equalize">equalize</code></td>
<td>
<p>logical. If <code>TRUE</code>, new nodes are spread at equal intervals between old nodes</p>
</td></tr>
<tr><td><code id="densify_+3A_flat">flat</code></td>
<td>
<p>logical. If <code>TRUE</code>, the earth's curvature is ignored for lonlat data, and the distance unit is degrees, not meter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- vect(rbind(c(-120,-20), c(-80,5), c(-40,-60), c(-120,-20)), 
  type="polygons", crs="+proj=longlat")
vd &lt;- densify(v, 200000)

p &lt;- project(v, "+proj=robin")
pd &lt;- project(vd, "+proj=robin")

# good 
plot(pd, col="gray", border="red", lwd=10)
points(pd, col="gray")

# bad
lines(p, col="blue", lwd=3)
points(p, col="blue", cex=2)
plot(p, col="blue", alpha=.1, add=TRUE)
legend("topright", c("good", "bad"), col=c("red", "blue"), lty=1, lwd=3)

## the other way around does not work
## unless the original data was truly planar (e.g. derived from a map)
x &lt;- densify(p, 250000)
y &lt;- project(x, "+proj=longlat")
# bad
plot(y)
# good
lines(vd, col="red")
</code></pre>

<hr>
<h2 id='density'>Density plot</h2><span id='topic+density'></span><span id='topic+density+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Create density plots of the cell values of a SpatRaster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
density(x, maxcells=100000, plot=TRUE, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="density_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="density_+3A_maxcells">maxcells</code></td>
<td>
<p>the maximum number of (randomly sampled) cells to be used for creating the plot</p>
</td></tr>
<tr><td><code id="density_+3A_plot">plot</code></td>
<td>
<p>if <code>TRUE</code> produce a plot, else return a density object</p>
</td></tr>
<tr><td><code id="density_+3A_main">main</code></td>
<td>
<p>character. Caption of plot(s)</p>
</td></tr>
<tr><td><code id="density_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>density plot (and a density object, returned invisibly if <code>plot=TRUE)</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logo &lt;- rast(system.file("ex/logo.tif", package="terra"))
density(logo)
</code></pre>

<hr>
<h2 id='deprecated'>deprecated methods</h2><span id='topic+setCats'></span><span id='topic+setCats+2CSpatRaster-method'></span><span id='topic+area'></span><span id='topic+area+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>These methods are deprecated and will be removed in future versions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
setCats(x, ...)

## S4 method for signature 'SpatRaster'
area(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated_+3A_x">x</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="deprecated_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='depth'>depth of SpatRaster layers</h2><span id='topic+depth'></span><span id='topic+depth+3C-'></span><span id='topic+depth+2CSpatRaster-method'></span><span id='topic+depth+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get or set the depth of the layers of a SpatRaster. Experimental. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
depth(x)

## S4 replacement method for signature 'SpatRaster'
depth(x)&lt;-value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depth_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="depth_+3A_value">value</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+time">time</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   

depth(s) &lt;- 1:3
depth(s)
</code></pre>

<hr>
<h2 id='describe'>describe</h2><span id='topic+describe'></span><span id='topic+describe+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Describe the properties of spatial data in a file as generated with the &quot;GDALinfo&quot; tool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
describe(x, sds=FALSE, meta=FALSE, parse=FALSE, options="", print=FALSE, open_opt="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_+3A_x">x</code></td>
<td>
<p>character. The name of a file with spatial data. Or a fully specified subdataset within a file such as <code>"NETCDF:\"AVHRR.nc\":NDVI"</code></p>
</td></tr>
<tr><td><code id="describe_+3A_sds">sds</code></td>
<td>
<p>logical. If <code>TRUE</code> the description or metadata of the subdatasets is returned (if available)</p>
</td></tr>
<tr><td><code id="describe_+3A_meta">meta</code></td>
<td>
<p>logical. Get the file level metadata instead</p>
</td></tr>
<tr><td><code id="describe_+3A_parse">parse</code></td>
<td>
<p>logical. If <code>TRUE</code>, metadata for subdatasets is parsed into components (if <code>meta=TRUE</code>)</p>
</td></tr>
<tr><td><code id="describe_+3A_options">options</code></td>
<td>
<p>character. A vector of valid options (if <code>meta=FALSE</code>) including &quot;json&quot;, &quot;mm&quot;, &quot;stats&quot;, &quot;hist&quot;, &quot;nogcp&quot;, &quot;nomd&quot;, &quot;norat&quot;, &quot;noct&quot;, &quot;nofl&quot;, &quot;checksum&quot;, &quot;proj4&quot;, &quot;listmdd&quot;, &quot;mdd &lt;value&gt;&quot; where &lt;value&gt; specifies a domain or 'all', &quot;wkt_format &lt;value&gt;&quot; where value is one of 'WKT1', 'WKT2', 'WKT2_2015', or 'WKT2_2018', &quot;sd &lt;subdataset&gt;&quot; where &lt;subdataset&gt; is the name or identifier of a sub-dataset. See <a href="https://gdal.org/programs/gdalinfo.html">https://gdal.org/programs/gdalinfo.html</a>. Ignored if <code>sds=TRUE</code></p>
</td></tr>  
<tr><td><code id="describe_+3A_print">print</code></td>
<td>
<p>logical. If <code>TRUE</code>, print the results</p>
</td></tr>
<tr><td><code id="describe_+3A_open_opt">open_opt</code></td>
<td>
<p>character. Driver specific open options</p>
</td></tr>   
</table>


<h3>Value</h3>

<p>character (invisibly, if <code>print=FALSE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
describe(f)
describe(f, meta=TRUE)
#g &lt;- describe(f, options=c("json", "nomd", "proj4"))
#head(g)
</code></pre>

<hr>
<h2 id='diff'>Lagged differences</h2><span id='topic+diff'></span><span id='topic+diff+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute the difference between consecutive layers in a SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
diff(x, lag=1, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="diff_+3A_lag">lag</code></td>
<td>
<p>positive integer indicating which lag to use</p>
</td></tr>
<tr><td><code id="diff_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="diff_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
d &lt;- diff(s)
</code></pre>

<hr>
<h2 id='dimensions'>Dimensions of a SpatRaster or SpatVector and related objects</h2><span id='topic+size'></span><span id='topic+length'></span><span id='topic+ncol'></span><span id='topic+nrow'></span><span id='topic+ncell'></span><span id='topic+nlyr'></span><span id='topic+nsrc'></span><span id='topic+dim'></span><span id='topic+res'></span><span id='topic+xres'></span><span id='topic+yres'></span><span id='topic+ncol+3C-'></span><span id='topic+nrow+3C-'></span><span id='topic+nlyr+3C-'></span><span id='topic+res+3C-'></span><span id='topic+size+2CSpatRaster-method'></span><span id='topic+ncell+2CANY-method'></span><span id='topic+nrow+2CSpatRaster-method'></span><span id='topic+ncol+2CSpatRaster-method'></span><span id='topic+nrow+2CSpatRasterDataset-method'></span><span id='topic+ncol+2CSpatRasterDataset-method'></span><span id='topic+nrow+2CSpatRasterCollection-method'></span><span id='topic+ncol+2CSpatRasterCollection-method'></span><span id='topic+nrow+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+ncol+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+nlyr+2CSpatRasterDataset-method'></span><span id='topic+res+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+nlyr+2CSpatRaster-method'></span><span id='topic+nlyr+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+nsrc+2CSpatRaster-method'></span><span id='topic+ncell+2CSpatRaster-method'></span><span id='topic+ncell+2CSpatRasterDataset-method'></span><span id='topic+length+2CSpatRasterDataset-method'></span><span id='topic+length+2CSpatRasterCollection-method'></span><span id='topic+nlyr+2CSpatRasterCollection-method'></span><span id='topic+dim+2CSpatRaster-method'></span><span id='topic+dim+2CSpatRasterDataset-method'></span><span id='topic+dim+2CSpatRasterCollection-method'></span><span id='topic+dim+3C-+2CSpatRaster-method'></span><span id='topic+dim+2CSpatVector-method'></span><span id='topic+dim+2CSpatVectorProxy-method'></span><span id='topic+res+2CSpatRasterDataset-method'></span><span id='topic+res+2CSpatRaster-method'></span><span id='topic+res+3C-+2CSpatRaster-method'></span><span id='topic+xres+2CSpatRaster-method'></span><span id='topic+yres+2CSpatRaster-method'></span><span id='topic+nrow+2CSpatVector-method'></span><span id='topic+ncol+2CSpatVector-method'></span><span id='topic+length+2CSpatVector-method'></span><span id='topic+length+2CSpatVectorCollection-method'></span>

<h3>Description</h3>

<p>Get the number of rows (<code>nrow</code>), columns (<code>ncol</code>), cells (<code>ncell</code>), layers (<code>nlyr</code>), sources (<code>nsrc</code>), the size <code>size</code> (<code>nlyr(x)*ncell(x)</code>), or spatial resolution of a SpatRaster.
</p>
<p><code>length</code> returns the number of sub-datasets in a SpatRasterDataset or SpatVectorCollection.
</p>
<p>For a SpatVector <code>length(x)</code> is the same as <code>nrow(x)</code>.
</p>
<p>You can also set the number of rows or columns or layers. When setting dimensions, all cell values are dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
ncol(x)

## S4 method for signature 'SpatRaster'
nrow(x)

## S4 method for signature 'SpatRaster'
nlyr(x)

## S4 method for signature 'SpatRaster'
ncell(x)

## S4 method for signature 'SpatRaster'
nsrc(x)

## S4 replacement method for signature 'SpatRaster,numeric'
ncol(x)&lt;-value

## S4 replacement method for signature 'SpatRaster,numeric'
nrow(x)&lt;-value

## S4 replacement method for signature 'SpatRaster,numeric'
nlyr(x)&lt;-value

## S4 method for signature 'SpatRaster'
res(x)

## S4 replacement method for signature 'SpatRaster,numeric'
res(x)&lt;-value

## S4 method for signature 'SpatRaster'
xres(x)

## S4 method for signature 'SpatRaster'
yres(x)

## S4 method for signature 'SpatVector'
ncol(x)

## S4 method for signature 'SpatVector'
nrow(x)

## S4 method for signature 'SpatVector'
length(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dimensions_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector or related objects</p>
</td></tr>
<tr><td><code id="dimensions_+3A_value">value</code></td>
<td>
<p>For ncol and nrow: positive integer. For res: one or two positive numbers </p>
</td></tr>  
</table>


<h3>Value</h3>

<p>integer
</p>


<h3>See Also</h3>

 <p><a href="#topic+ext">ext</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
ncol(r)
nrow(r)
nlyr(r)
dim(r)
nsrc(r)
ncell(r)

rr  &lt;- c(r,r)
nlyr(rr)
nsrc(rr)
ncell(rr)

nrow(r) &lt;- 18
ncol(r) &lt;- 36
# equivalent to
dim(r) &lt;- c(18, 36) 

dim(r)
dim(r) &lt;- c(10, 10, 5)
dim(r)

xres(r)
yres(r)
res(r)

res(r) &lt;- 1/120
# different xres and yres
res(r) &lt;- c(1/120, 1/60)
</code></pre>

<hr>
<h2 id='direction'>Direction</h2><span id='topic+direction'></span><span id='topic+direction+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>The direction (azimuth) to or from the nearest cell that is not <code>NA</code>. The direction is expressed in radians, unless you use argument <code>degrees=TRUE</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
direction(x, from=FALSE, degrees=FALSE, filename="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direction_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="direction_+3A_filename">filename</code></td>
<td>
<p>Character. Output filename (optional)</p>
</td></tr>
<tr><td><code id="direction_+3A_degrees">degrees</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default) the unit of direction is radians.</p>
</td></tr>
<tr><td><code id="direction_+3A_from">from</code></td>
<td>
<p>Logical. Default is <code>FALSE</code>. If <code>TRUE</code>, the direction from (instead of to)  the nearest cell that is not <code>NA</code> is returned</p>
</td></tr>
<tr><td><code id="direction_+3A_...">...</code></td>
<td>
<p>Additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncol=36,nrow=18, crs="+proj=merc")
values(r) &lt;- NA
r[306] &lt;- 1
b &lt;- direction(r, degrees=TRUE) 
plot(b)

crs(r) &lt;- "+proj=longlat"
b &lt;- direction(r) 
plot(b)

</code></pre>

<hr>
<h2 id='disagg'>Disaggregate raster cells or vector geometries</h2><span id='topic+disagg'></span><span id='topic+disagg+2CSpatRaster-method'></span><span id='topic+disagg+2CSpatVector-method'></span>

<h3>Description</h3>

<p><code>SpatRaster</code>: Create a SpatRaster with a higher resolution (smaller cells). The values in the new SpatRaster are the same as in the larger original cells.
</p>
<p><code>SpatVector</code>: Separate multi-objects (points, lines, polygons) into single objects; or further into segments (for lines or polygons).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
disagg(x, fact, method="near", filename="", ...)

## S4 method for signature 'SpatVector'
disagg(x, segments=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disagg_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="disagg_+3A_fact">fact</code></td>
<td>
<p>positive integer. Aggregation factor expressed as number of cells in each direction (horizontally and vertically). Or two integers (horizontal and vertical aggregation factor) or three integers (when also aggregating over layers)</p>
</td></tr>  
<tr><td><code id="disagg_+3A_method">method</code></td>
<td>
<p>character. Either &quot;near&quot; for nearest or &quot;bilinear&quot; for bilinear interpolation</p>
</td></tr>
<tr><td><code id="disagg_+3A_segments">segments</code></td>
<td>
<p>logical. Should (poly-)lines or polygons be disaggregated into their line-segments?</p>
</td></tr>
<tr><td><code id="disagg_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="disagg_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate">aggregate</a></code>, <code><a href="#topic+resample">resample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
rd &lt;- disagg(r, fact=c(10, 2))
ncol(rd)
nrow(rd)
values(r) &lt;- 1:ncell(r)
rd &lt;- disagg(r, fact=c(4, 2))

</code></pre>

<hr>
<h2 id='distance'>Geographic distance</h2><span id='topic+distance'></span><span id='topic+distance+2CSpatRaster+2Cmissing-method'></span><span id='topic+distance+2CSpatRaster+2CSpatVector-method'></span><span id='topic+distance+2CSpatRaster+2Csf-method'></span><span id='topic+distance+2CSpatVector+2CANY-method'></span><span id='topic+distance+2CSpatVector+2CSpatVector-method'></span><span id='topic+distance+2Cmatrix+2Cmatrix-method'></span><span id='topic+distance+2Cmatrix+2Cmissing-method'></span><span id='topic+distance+2Cdata.frame+2Cdata.frame-method'></span><span id='topic+distance+2Cdata.frame+2Cmissing-method'></span>

<h3>Description</h3>

<p>If <code>x</code> is a <b>SpatRaster</b>:
</p>
<p>If <code>y</code> is <code>missing</code> this method computes the distance, for all cells that are <code>NA</code> in SpatRaster <code>x</code> to the nearest cell that is not <code>NA</code> (or other values, see arguments &quot;target&quot; and &quot;exclude&quot;). 
</p>
<p>If <code>y</code> is a numeric value, the cells with that value are ignored. That is, distance to or from these cells is not computed (only if <code>grid=FALSE</code>).
</p>
<p>If <code>y</code> is a SpatVector, the distance to that SpatVector is computed for all cells. For lines and polygons this is done after rasterization; and only the overlapping areas of the vector and raster are considered (for now).
</p>
<p>The distance is always expressed in meter if the coordinate reference system is longitude/latitude, and in map units otherwise. Map units are typically meter, but inspect <code>crs(x)</code> if in doubt.
</p>
<p>Results are more precise, sometimes much more precise, when using longitude/latitude rather than a planar coordinate reference system, as these distort distance. 
</p>
<p>If <code>x</code> is a <b>SpatVector</b>:
</p>
<p>If <code>y</code> is <code>missing</code>, a distance matrix between all objects in <code>x</code> is computed. A distance matrix object of class &quot;dist&quot; is returned. 
</p>
<p>If <code>y</code> is a SpatVector the geographic distance between all objects is computed (and a matrix is returned). If both sets have the same number of points, and <code>pairwise=TRUE</code>, the distance between each pair of objects is computed, and a vector is returned.
</p>
<p>The distance is always expressed in meter, except when the coordinate reference system is longitude/latitude AND one of the SpatVector(s) consists of lines or polygons. In that case the distance is in degrees, and thus not very useful (this will be fixed soon). Otherwise, results are more precise, sometimes much more precise, when using longitude/latitude rather than a planar coordinate reference system, as these distort distance. 
</p>
<p>If <code>x</code> is a <b>matrix</b>:
</p>
<p><code>x</code> should consist of two columns, the first with &quot;x&quot; (or longitude) and the second with &quot;y&quot; coordinates (or latitude). If <code>y</code> is a also a matrix, the distance between each points in <code>x</code> and all points in <code>y</code> is computed, unless <code>pairwise=TRUE</code>
</p>
<p>If <code>y</code> is missing, the distance between each points in <code>x</code> with all other points in <code>x</code> is computed, unless <code>sequential=TRUE</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,missing'
distance(x, y, target=NA, exclude=NULL, unit="m", haversine=TRUE, filename="", ...)

## S4 method for signature 'SpatRaster,SpatVector'
distance(x, y, unit="m", rasterize=FALSE, haversine=TRUE, filename="", ...)

## S4 method for signature 'SpatVector,ANY'
distance(x, y, sequential=FALSE, pairs=FALSE, symmetrical=TRUE, unit="m")

## S4 method for signature 'SpatVector,SpatVector'
distance(x, y, pairwise=FALSE, unit="m")

## S4 method for signature 'matrix,matrix'
distance(x, y, lonlat, pairwise=FALSE)

## S4 method for signature 'matrix,missing'
distance(x, y, lonlat, sequential=FALSE, pairs=FALSE, symmetrical=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector, or two-column matrix with coordinates (x,y) or (lon,lat)</p>
</td></tr>
<tr><td><code id="distance_+3A_y">y</code></td>
<td>
<p>missing, numeric, SpatVector, or two-column matrix</p>
</td></tr>
<tr><td><code id="distance_+3A_target">target</code></td>
<td>
<p>numeric. The value of the cells for which distances to cells that are not <code>NA</code> should be computed</p>
</td></tr>
<tr><td><code id="distance_+3A_exclude">exclude</code></td>
<td>
<p>numeric. The value of the cells that should not be considered for computing distances</p>
</td></tr>
<tr><td><code id="distance_+3A_unit">unit</code></td>
<td>
<p>character. Can be either &quot;m&quot; or &quot;km&quot;</p>
</td></tr>
<tr><td><code id="distance_+3A_haversine">haversine</code></td>
<td>
<p>logical. Use the haversine formula for lon/lat data use the haversine formula? If <code>FALSE</code>, the more precise but slower method of Karney (2003) is used</p>
</td></tr>  
<tr><td><code id="distance_+3A_rasterize">rasterize</code></td>
<td>
<p>logical. If <code>TRUE</code> distance is computed from the cells covered by the geometries after rasterization. This can be much faster in some cases</p>
</td></tr>
<tr><td><code id="distance_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="distance_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="distance_+3A_sequential">sequential</code></td>
<td>
<p>logical. If <code>TRUE</code>, the distance between sequential geometries is returned</p>
</td></tr>
<tr><td><code id="distance_+3A_pairwise">pairwise</code></td>
<td>
<p>logical. If <code>TRUE</code> and if x and y have the same size (number of rows), the pairwise distances are returned instead of the distances between all elements</p>
</td></tr> 
<tr><td><code id="distance_+3A_lonlat">lonlat</code></td>
<td>
<p>logical. If <code>TRUE</code> the coordinates are interpreted as angular (longitude/latitude). If <code>FALSE</code> they are interpreted as planar</p>
</td></tr>
<tr><td><code id="distance_+3A_pairs">pairs</code></td>
<td>
<p>logical. If <code>TRUE</code> a &quot;from&quot;, &quot;to&quot;, &quot;distance&quot; matrix is returned</p>
</td></tr> 
<tr><td><code id="distance_+3A_symmetrical">symmetrical</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>pairs=TRUE</code>, the distance between a pair is only included once. The distance between geometry 1 and 3 is included, but the (same) distance between 3 and 1 is not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster or numeric or matrix or distance matrix (object of class &quot;dist&quot;)
</p>


<h3>Note</h3>

<p>The distance unit is in meters.
</p>
<p>A distance matrix can be coerced into a matrix with <code>as.matrix</code>
</p>


<h3>References</h3>

<p>Karney, C.F.F., 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. doi:10.1007/s00190-012-0578-z.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#lonlat
r &lt;- rast(ncols=36, nrows=18, crs="+proj=longlat +datum=WGS84")
r[500] &lt;- 1
d &lt;- distance(r) 
plot(d / 100000)

#planar
rr &lt;- rast(ncols=36, nrows=18, crs="+proj=utm +zone=1 +datum=WGS84")
rr[500] &lt;- 1
d &lt;- distance(rr) 

rr[3:10, 3:10] &lt;- 99
e &lt;- distance(rr, exclude=99) 

p1 &lt;- vect(rbind(c(0,0), c(90,30), c(-90,-30)), crs="+proj=longlat +datum=WGS84")
dp &lt;- distance(r, p1) 

d &lt;- distance(p1)
d
as.matrix(d)

p2 &lt;- vect(rbind(c(30,-30), c(25,40), c(-9,-3)), crs="+proj=longlat +datum=WGS84")
dd &lt;- distance(p1, p2)
dd
pd &lt;- distance(p1, p2, pairwise=TRUE)
pd
pd == diag(dd)


# polygons, lines
crs &lt;- "+proj=utm +zone=1"
p1 &lt;- vect("POLYGON ((0 0, 8 0, 8 9, 0 9, 0 0))", crs=crs)
p2 &lt;- vect("POLYGON ((5 6, 15 6, 15 15, 5 15, 5 6))", crs=crs)
p3 &lt;- vect("POLYGON ((2 12, 3 12, 3 13, 2 13, 2 12))", crs=crs)
p &lt;- rbind(p1, p2, p3)
L1 &lt;- vect("LINESTRING(1 11, 4 6, 10 6)", crs=crs)
L2 &lt;- vect("LINESTRING(8 14, 12 10)", crs=crs)
L3 &lt;- vect("LINESTRING(1 8, 12 14)", crs=crs)
lns &lt;- rbind(L1, L2, L3)
pts &lt;- vect(cbind(c(7,10,10), c(3,5,6)), crs=crs)

distance(p1,p3)
distance(p)
distance(p,pts)
distance(p,lns)
distance(pts,lns)
</code></pre>

<hr>
<h2 id='dots'>Make a dot-density map</h2><span id='topic+dots'></span><span id='topic+dots+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Create the dots for a dot-density map and add these to the current map. Dot-density maps are made to display count data. For example of population counts, where each dot represents n persons. The dots are returned as a <code>SpatVector</code>. It there is an active graphics device, the dots are added to it with <code><a href="#topic+points">points</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
dots(x, field, size,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dots_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="dots_+3A_field">field</code></td>
<td>
<p>character of numeric indicating field name. Or numeric vector of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="dots_+3A_size">size</code></td>
<td>
<p>positive number indicating the number of cases associated with each dot</p>
</td></tr>
<tr><td><code id="dots_+3A_...">...</code></td>
<td>
<p>graphical arguments passed to <code>points</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector (invisibly)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code>, <code><a href="#topic+cartogram">cartogram</a></code>, <code><a href="#topic+points">points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
v$population &lt;- 1000*(1:12)^2
plot(v, lwd=3, col="light gray", border="white")
d &lt;- dots(v, "population", 1000, col="red", cex=.75)
lines(v)
d
</code></pre>

<hr>
<h2 id='draw'> Draw a polygon, line, extent, or points </h2><span id='topic+draw'></span><span id='topic+draw+2Ccharacter-method'></span><span id='topic+draw+2Cmissing-method'></span>

<h3>Description</h3>

<p>Draw on a plot (map) to get a SpatVector or SpatExtent object for later use. After calling the function, start clicking on the map. When you are done, press <code>ESC</code>. You can also preset the maximum number of clicks.
</p>
<p>This does to work well on the default RStudio plotting device. To work around that, you can first run <code>dev.new(noRStudioGD = TRUE)</code> which will create a separate window for plotting, then use <code>plot()</code> followed by <code>click()</code> and click on the map .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
draw(x="extent", col="red", lwd=2, id=FALSE, n=1000, xpd=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_x">x</code></td>
<td>
<p>character. The type of object to draw. One of &quot;extent&quot;, &quot;polygon&quot;, &quot;line&quot;, or &quot;points&quot;</p>
</td></tr>
<tr><td><code id="draw_+3A_col">col</code></td>
<td>
<p>the color to be used</p>
</td></tr>
<tr><td><code id="draw_+3A_lwd">lwd</code></td>
<td>
<p>the width of the lines to be drawn</p>
</td></tr>
<tr><td><code id="draw_+3A_id">id</code></td>
<td>
<p>logical. If <code>TRUE</code>, a numeric ID is shown on the map</p>
</td></tr>
<tr><td><code id="draw_+3A_n">n</code></td>
<td>
<p>the maximum number of clicks (does not apply when <code>x=="extent"</code> in which case <code>n</code> is always 2</p>
</td></tr>  
<tr><td><code id="draw_+3A_xpd">xpd</code></td>
<td>
<p>logical. If <code>TRUE</code>, you can draw outside the current plotting area</p>
</td></tr>
<tr><td><code id="draw_+3A_...">...</code></td>
<td>
<p>additional graphics arguments for drawing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector or SpatExtent 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+click">click</a></code> </p>

<hr>
<h2 id='elongate'> elongate lines </h2><span id='topic+elongate'></span><span id='topic+elongate+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Elongate SpatVector lines 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
elongate(x, length=1, flat=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elongate_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="elongate_+3A_length">length</code></td>
<td>
<p>positive number indicating how much the lines should be elongated at each end. The unit is meter is the crs is lonlat and it is the same as the linear unit of the crs on other cases (also meter in most cases)</p>
</td></tr>
<tr><td><code id="elongate_+3A_flat">flat</code></td>
<td>
<p>logical. If <code>TRUE</code>, the earth's curvature is ignored for lonlat data, and the distance unit is degrees, not meter</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buffer">buffer</a></code>, <code><a href="#topic+crop">crop</a></code> and <code><a href="#topic+erase">erase</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- vect(cbind(c(0,1,2), c(0,0,2)), "lines", crs="lonlat")
e &lt;- elongate(v, 100000)
plot(e)
points(e)
geom(e)
</code></pre>

<hr>
<h2 id='erase'> Erase parts of a SpatVector object</h2><span id='topic+erase'></span><span id='topic+erase+2CSpatVector+2CSpatVector-method'></span><span id='topic+erase+2CSpatVector+2Cmissing-method'></span><span id='topic+erase+2CSpatVector+2CSpatExtent-method'></span><span id='topic+erase+2CSpatGraticule+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Erase parts of a SpatVector with another SpatVector or with a SpatExtent. You can also erase (parts of) polygons with the other polygons of the same SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatVector'
erase(x, y)

## S4 method for signature 'SpatVector,missing'
erase(x, sequential=TRUE)

## S4 method for signature 'SpatVector,SpatExtent'
erase(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erase_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="erase_+3A_y">y</code></td>
<td>
<p>SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="erase_+3A_sequential">sequential</code></td>
<td>
<p>logical. Should areas be erased sequentially? See Details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If polygons are erased sequentially, everything that is covered by the first polygon is removed from all other polygons, then everything that is covered by (what is remaining of) the second polygon is removed, etc. 
</p>
<p>If polygons are not erased sequentially, all overlapping areas are erased and only the areas covered by a single geometry are returned.
</p>


<h3>Value</h3>

<p>SpatVector or SpatExtent
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crop">crop</a></code> and <code><a href="#topic+intersect">intersect</a></code> for the inverse. 
</p>
<p>The equivalent for SpatRaster is <code><a href="#topic+mask">mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)

# polygons with polygons or extent

e &lt;- ext(5.6, 6, 49.55, 49.7)
x &lt;- erase(v, e)

p &lt;- vect("POLYGON ((5.8 49.8, 6 49.9, 6.15 49.8, 6 49.6, 5.8 49.8))")
y &lt;- erase(v, p)

# lines with polygons
lns &lt;- as.lines(rast(v, ncol=10, nrow=10))[12:22]
eln &lt;- erase(lns, v)
plot(v)
lines(lns, col='blue', lwd=4, lty=3)
lines(eln, col='red', lwd=2)


## self-erase
h &lt;- convHull(v[-12], "NAME_1")
he &lt;- erase(h)
plot(h, lwd=2, border="red", lty=2)
lines(he, col="gray", lwd=3)
</code></pre>

<hr>
<h2 id='expanse'>Get the expanse (area) of individual polygons or for all (summed) raster cells</h2><span id='topic+expanse'></span><span id='topic+expanse+2CSpatRaster-method'></span><span id='topic+expanse+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Compute the area covered by polygons or for all raster cells that are not <code>NA</code>. 
</p>
<p>This method computes areas for longitude/latitude rasters, as the size of the cells is constant in degrees, but not in square meters. But it can also be important if the coordinate reference system is planar, but not equal-area. 
</p>
<p>For vector data, the best way to compute area is to use the longitude/latitude CRS. This is contrary to (erroneous) popular belief that suggest that you should use a planar coordinate reference system. This is done automatically, if <code>transform=TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
expanse(x, unit="m", transform=TRUE, byValue=FALSE, zones=NULL, wide=FALSE)

## S4 method for signature 'SpatVector'
expanse(x, unit="m", transform=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expanse_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="expanse_+3A_unit">unit</code></td>
<td>
<p>character. Output unit of area. One of &quot;m&quot;, &quot;km&quot;, or &quot;ha&quot;</p>
</td></tr>
<tr><td><code id="expanse_+3A_transform">transform</code></td>
<td>
<p>logical. If <code>TRUE</code>, planar CRS are transformed to lon/lat for accuracy</p>
</td></tr>
<tr><td><code id="expanse_+3A_byvalue">byValue</code></td>
<td>
<p>logical. If <code>TRUE</code>, the area for each unique cell value is returned</p>
</td></tr>
<tr><td><code id="expanse_+3A_zones">zones</code></td>
<td>
<p>NULL or SpatRaster with the same geometry identifying zones in <code>x</code></p>
</td></tr>
<tr><td><code id="expanse_+3A_wide">wide</code></td>
<td>
<p>logical. Should the results be in &quot;wide&quot; rather than &quot;long&quot; format?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><b>SpatRaster</b>: <code>data.frame</code> with at least two columns (&quot;layer&quot; and &quot;area&quot;) and possibly also &quot;value&quot; (if <code>byValue</code> is <code>TRUE</code>), and &quot;zone&quot; (if <code>zones</code> is <code>TRUE</code>). If <code>x</code> has no values, the total area of all cells is returned. Otherwise, the area of all cells that are not <code>NA</code> is returned. 
</p>
<p><b>SpatVector</b>: numeric (one value for each (multi-) polygon geometry.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cellSize">cellSize</a></code> for a the size of individual cells of a raster, that can be summed with <code><a href="#topic+global">global</a></code> or with <code><a href="#topic+zonal">zonal</a></code> to get the area for different zones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### SpatRaster 
r &lt;- rast(nrows=18, ncols=36)
v &lt;- 1:ncell(r)
v[200:400] &lt;- NA
values(r) &lt;- v

# summed area in km2
expanse(r, unit="km")

# all cells 
expanse(rast(r), unit="km")

r &lt;- rast(ncols=90, nrows=45, ymin=-80, ymax=80)
m &lt;- project(r, "+proj=merc")

expanse(m, unit="km")
expanse(m, unit="km", transform=FALSE)

m2 &lt;- c(m, m)
values(m2) &lt;- cbind(c(1,2,NA,NA), c(11:14))
expanse(m2, unit="km", byValue=TRUE, wide=TRUE)


v &lt;- vect(system.file("ex/lux.shp", package="terra"))
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
r &lt;- round((r-50)/100)
levels(r) &lt;- data.frame(id=1:5, name=c("forest", "water", "urban", "crops", "grass"))
expanse(r, byValue=TRUE)

g &lt;- rasterize(v, r, "NAME_1")
expanse(r, byValue=TRUE, zones=g, wide=TRUE)


### SpatVector
v &lt;- vect(system.file("ex/lux.shp", package="terra"))

a &lt;- expanse(v)
a
sum(a)
</code></pre>

<hr>
<h2 id='ext'>Create, get or set a SpatExtent</h2><span id='topic+ext'></span><span id='topic+ext+3C-'></span><span id='topic+ext+2CSpatExtent-method'></span><span id='topic+ext+2CSpatRaster-method'></span><span id='topic+ext+2CSpatVector-method'></span><span id='topic+ext+2CSpatVectorProxy-method'></span><span id='topic+ext+2CSpatRasterDataset-method'></span><span id='topic+ext+2CSpatRasterCollection-method'></span><span id='topic+ext+3C-+2CSpatRaster+2CSpatExtent-method'></span><span id='topic+ext+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+ext+2Cnumeric-method'></span><span id='topic+ext+2Cmatrix-method'></span><span id='topic+ext+2Cmissing-method'></span><span id='topic+ext+2CSpatial-method'></span><span id='topic+ext+2CRaster-method'></span><span id='topic+ext+2CExtent-method'></span><span id='topic+ext+2Csf-method'></span><span id='topic+ext+2Cbbox-method'></span>

<h3>Description</h3>

<p>Get a SpatExtent of a SpatRaster, SpatVector, or other spatial objects. Or create a SpatExtent from a vector (length=4; order=xmin, xmax, ymin, ymax)
</p>
<p>You can set the extent of a SpatRaster, but you cannot set the extent of a SpatVector (see <code><a href="#topic+rescale">rescale</a></code> for that). See <code><a href="#topic+set.ext">set.ext</a></code> to set the extent in place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
ext(x, cells=NULL)

## S4 method for signature 'SpatVector'
ext(x)

## S4 method for signature 'numeric'
ext(x, ..., xy=FALSE)

## S4 replacement method for signature 'SpatRaster,SpatExtent'
ext(x)&lt;-value

## S4 replacement method for signature 'SpatRaster,numeric'
ext(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ext_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="ext_+3A_cells">cells</code></td>
<td>
<p>positive integer (cell) numbers to subset the extent to area covered by these cells</p>
</td></tr>
<tr><td><code id="ext_+3A_value">value</code></td>
<td>
<p>SpatExtent, or numeric vector of length four (xmin, xmax, ymin, ymax)</p>
</td></tr>  
<tr><td><code id="ext_+3A_...">...</code></td>
<td>
<p>if <code>x</code> is a single numeric value, additional numeric values for xmax, ymin, and ymax</p>
</td></tr>  
<tr><td><code id="ext_+3A_xy">xy</code></td>
<td>
<p>logical. Set this to <code>TRUE</code> to indicate that coordinates are in (xmin, ymin, xmax, ymax) order, instead of in the terra standard order of (xmin, xmax, ymin, ymax)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatExtent">SpatExtent</a></code> object. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
e &lt;- ext(r)
as.vector(e)
as.character(e)

ext(r) &lt;- c(0, 2.5, 0, 1.5)
r
er &lt;- ext(r)

round(er)
# go "in"
floor(er)
# go "out"
ceiling(er)

ext(r) &lt;- e

</code></pre>

<hr>
<h2 id='extend'>Extend</h2><span id='topic+extend'></span><span id='topic+extend+2CSpatRaster-method'></span><span id='topic+extend+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Enlarge the spatial extent of a SpatRaster. See <code><a href="#topic+crop">crop</a></code> if you (also) want to remove rows or columns. 
</p>
<p>Note that you can only enlarge SpatRasters with entire rows and columns. Therefore, the extent of the output SpatRaster may not be exactly the same as the requested. Depending on argument <code>snap</code> it may be a bit smaller or larger. 
</p>
<p>You can also enlarge a SpatExtent with this method, or with an algebraic notation (see examples)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
extend(x, y, snap="near", fill=NA, filename="", overwrite=FALSE, ...) 

## S4 method for signature 'SpatExtent'
extend(x, y) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatExtent</p>
</td></tr>
<tr><td><code id="extend_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is a SpatRaster, <code>y</code> should be a SpatExtent, or an object from which it can be extracted (such as SpatRaster and SpatVector objects). Alternatively, you can provide one, two or four non-negative integers indicating the number of rows and columns that need to be added at each side (a single positive integer when the number of rows and columns to be added is equal; or 2 number (columns, rows), or four (left column, right column, bottom row, top row).
If <code>x</code> is a SpatExtent, <code>y</code> should likewise be a numeric vector of 1, 2, or 4 elements</p>
</td></tr>
<tr><td><code id="extend_+3A_snap">snap</code></td>
<td>
<p>character. One of &quot;near&quot;, &quot;in&quot;, or &quot;out&quot;. Used to align <code>y</code> to the geometry of <code>x</code></p>
</td></tr> 
<tr><td><code id="extend_+3A_fill">fill</code></td>
<td>
<p>numeric. The value used to for the new raster cells</p>
</td></tr>
<tr><td><code id="extend_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="extend_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="extend_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster or SpatExtent
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crop">crop</a></code>, <code><a href="#topic+merge">merge</a></code>, <code><a href="#topic+ext">ext</a></code>, <code><a href="#topic+resample">resample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(xmin=-150, xmax=-120, ymin=30, ymax=60, ncols=36, nrows=18)
values(r) &lt;- 1:ncell(r)
e &lt;- ext(-180, -100, 40, 70)
re &lt;- extend(r, e)

# extend with a number of rows and columns (at each side)
re2 &lt;- extend(r, c(2,10))

# SpatExtent
e &lt;- ext(r)
e
extend(e, 10)
extend(e, c(10, -10, 0, 20))


# add 10 columns / rows on all sides
e + 10
# double extent
e * 2
# increase extent by 25%
e * 1.25
</code></pre>

<hr>
<h2 id='extract'>Extract values from a SpatRaster</h2><span id='topic+extract'></span><span id='topic+extract+2CSpatRaster+2CSpatVector-method'></span><span id='topic+extract+2CSpatRaster+2Csf-method'></span><span id='topic+extract+2CSpatRaster+2CSpatExtent-method'></span><span id='topic+extract+2CSpatRaster+2Cmatrix-method'></span><span id='topic+extract+2CSpatRaster+2Cdata.frame-method'></span><span id='topic+extract+2CSpatRaster+2Cnumeric-method'></span><span id='topic+extract+2CSpatVector+2CSpatVector-method'></span><span id='topic+extract+2CSpatVector+2Cmatrix-method'></span><span id='topic+extract+2CSpatVector+2Cdata.frame-method'></span><span id='topic+extract+2CSpatRasterCollection+2CANY-method'></span><span id='topic+extract+2CSpatRasterDataset+2CANY-method'></span>

<h3>Description</h3>

<p>Extract values from a SpatRaster for a set of locations. The locations can be a SpatVector (points, lines, polygons), a data.frame or matrix with (x, y) or (longitude, latitude &ndash; in that order!) coordinates, or a vector with cell numbers.  
</p>
<p>When argument <code>y</code> is a <code>SpatVector</code> the first column has the ID (record number) of the <code>SpatVector</code> used (unless you set <code>ID=FALSE</code>).
</p>
<p>Alternatively, you can use <code><a href="#topic+zonal">zonal</a></code> after using <code><a href="#topic+rasterize">rasterize</a></code> with a <code>SpatVector</code> (this may be more efficient in some cases).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatVector'
extract(x, y, fun=NULL, method="simple", cells=FALSE, xy=FALSE,
    ID=TRUE, weights=FALSE, exact=FALSE, touches=is.lines(y),
	layer=NULL, bind=FALSE, raw=FALSE, ...)

## S4 method for signature 'SpatRaster,SpatExtent'
extract(x, y, cells=FALSE, xy=FALSE)

## S4 method for signature 'SpatRaster,matrix'
extract(x, y, cells=FALSE, method="simple")

## S4 method for signature 'SpatRaster,numeric'
extract(x, y, xy=FALSE, raw=FALSE)

## S4 method for signature 'SpatVector,SpatVector'
extract(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector of polygons</p>
</td></tr>
<tr><td><code id="extract_+3A_y">y</code></td>
<td>
<p>SpatVector (points, lines, or polygons). Alternatively, for points, a 2-column matrix or data.frame (x, y) or (lon, lat). Or a vector with cell numbers</p>
</td></tr>
<tr><td><code id="extract_+3A_fun">fun</code></td>
<td>
<p>function to summarize the extracted data by line or polygon geometry. You can use <code>fun=table</code> to tabulate raster values for each line or polygon geometry. If <code>weights=TRUE</code> or <code>exact=TRUE</code> only <code>mean</code>, <code>sum</code>, <code>min</code>, <code>max</code> and <code>table</code> are accepted). Ignored if <code>y</code> has point geometry</p>
</td></tr>
<tr><td><code id="extract_+3A_method">method</code></td>
<td>
<p>character. method for extracting values with points (&quot;simple&quot; or &quot;bilinear&quot;). With &quot;simple&quot; values for the cell a point falls in are returned. With &quot;bilinear&quot; the returned values are interpolated from the values of the four nearest raster cells</p>
</td></tr>
<tr><td><code id="extract_+3A_cells">cells</code></td>
<td>
<p>logical. If <code>TRUE</code> the cell numbers are also returned, unless <code>fun</code> is not <code>NULL</code>. Also see <code><a href="#topic+cells">cells</a></code></p>
</td></tr>
<tr><td><code id="extract_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code> the coordinates of the cells are also returned, unless <code>fun</code> is not <code>NULL</code>. See <code><a href="#topic+xyFromCell">xyFromCell</a></code></p>
</td></tr>
<tr><td><code id="extract_+3A_id">ID</code></td>
<td>
<p>logical. Should an ID column be added? If so, the first column returned has the IDs (record numbers) of <code>y</code></p>
</td></tr>
<tr><td><code id="extract_+3A_weights">weights</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> has polygons, the approximate fraction of each cell that is covered is returned as well, for example to compute a weighted mean</p>
</td></tr>
<tr><td><code id="extract_+3A_exact">exact</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> has polygons, the exact fraction of each cell that is covered is returned as well, for example to compute a weighted mean</p>
</td></tr>
<tr><td><code id="extract_+3A_touches">touches</code></td>
<td>
<p>logical. If <code>TRUE</code>, values for all cells touched by lines or polygons are extracted, not just those on the line render path, or whose center point is within the polygon. Not relevant for points; and always considered <code>TRUE</code> when <code>weights=TRUE</code> or <code>exact=TRUE</code></p>
</td></tr>
<tr><td><code id="extract_+3A_layer">layer</code></td>
<td>
<p>character or numeric to select the layer to extract from for each geometry. If <code>layer</code> is a character it can be a name in <code>y</code> or a vector of layer names. If it is numeric, it must be integer values between <code>1</code> and <code>nlyr(x)</code></p>
</td></tr>
<tr><td><code id="extract_+3A_bind">bind</code></td>
<td>
<p>logical. If <code>TRUE</code>, a SpatVector is returned consisting of the input SpatVector <code>y</code> and the <code>cbind</code>-ed extracted values</p>
</td></tr>
<tr><td><code id="extract_+3A_raw">raw</code></td>
<td>
<p>logical. If <code>TRUE</code>, a matrix is returned with the &quot;raw&quot; numeric cell values. If <code>FALSE</code>, a data.frame is returned and the cell values are transformed to factor, logical, or integer values, where appropriate</p>
</td></tr>
<tr><td><code id="extract_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>fun</code> if <code>y</code> is a SpatVector. For example <code>na.rm=TRUE</code>. Or arguments passed to the <code>SpatRaster,SpatVector</code> method if <code>y</code> is a matrix (such as the <code>method</code> and <code>cells</code> arguments)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame, matrix or SpatVector</p>


<h3>See Also</h3>

<p><code><a href="#topic+values">values</a>, <a href="#topic+zonal">zonal</a>, <a href="#topic+extractAlong">extractAlong</a>, <a href="#topic+extractRange">extractRange</a>, <a href="#topic+rapp">rapp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=5, nrows=5, xmin=0, xmax=5, ymin=0, ymax=5)
values(r) &lt;- 1:25
xy &lt;- rbind(c(0.5,0.5), c(2.5,2.5))
p &lt;- vect(xy, crs="+proj=longlat +datum=WGS84")

extract(r, xy)
extract(r, p)

r[1,]
r[5]
r[,5]

r[c(0:2, 99:101)]

f &lt;- system.file("ex/meuse.tif", package="terra")
r &lt;- rast(f)

xy &lt;- cbind(179000, 330000)
xy &lt;- rbind(xy-100, xy, xy+1000)
extract(r, xy)

p &lt;- vect(xy)
g &lt;- geom(p)
g

extract(r, p)

x &lt;- r + 10
extract(x, p)

i &lt;- cellFromXY(r, xy)
x[i]
r[i]

y &lt;- c(x,x*2,x*3)
y[i]

## extract with a polygon
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
v &lt;- v[1:2,]

rf &lt;- system.file("ex/elev.tif", package="terra")
x &lt;- rast(rf)
extract(x, v, mean, na.rm=TRUE)

z &lt;- rast(v, resolution=.1, names="test")
values(z) &lt;- 1:ncell(z)
e &lt;- extract(z, v, ID=TRUE)
e
tapply(e[,2], e[,1], mean, na.rm=TRUE)

x &lt;- c(z, z*2, z/3)
names(x) &lt;- letters[1:3]

e &lt;- extract(x, v, ID=TRUE)
de &lt;- data.frame(e)
aggregate(de[,2:4], de[,1,drop=FALSE], mean)
</code></pre>

<hr>
<h2 id='extractAlong'>extract values along lines</h2><span id='topic+extractAlong'></span>

<h3>Description</h3>

 
<p>Extract raster values along a line. That is, the returned values are ordered along the line. That is not the case with <code><a href="#topic+extract">extract</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractAlong(x, y, ID=TRUE, cells=FALSE, xy=FALSE, online=FALSE, bilinear=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractAlong_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="extractAlong_+3A_y">y</code></td>
<td>
<p>SpatVector with lines geometry</p>
</td></tr>
<tr><td><code id="extractAlong_+3A_id">ID</code></td>
<td>
<p>logical. Should an ID column be added? If so, the first column returned has the IDs (record numbers) of input SpatVector <code>y</code></p>
</td></tr>
<tr><td><code id="extractAlong_+3A_cells">cells</code></td>
<td>
<p>logical. If <code>TRUE</code> the cell numbers are also returned</p>
</td></tr>
<tr><td><code id="extractAlong_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code> the coordinates of the cells traversed by <code>y</code> are also returned. See <code><a href="#topic+xyFromCell">xyFromCell</a></code></p>
</td></tr>
<tr><td><code id="extractAlong_+3A_online">online</code></td>
<td>
<p>logical. If <code>TRUE</code> the returned coordinates are snapped to <code>y</code></p>
</td></tr> 
<tr><td><code id="extractAlong_+3A_bilinear">bilinear</code></td>
<td>
<p>logical. If <code>TRUE</code> the returned raster values computed with bilinear interpolation from the nearest four cells. Only relevant if <code>online=TRUE</code></p>
</td></tr> 
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract">extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=36, nrows=18, vals=1:(18*36))
cds1 &lt;- rbind(c(-50,0), c(0,60), c(40,5), c(15,-45), c(-10,-25))
cds2 &lt;- rbind(c(80,20), c(140,60), c(160,0), c(140,-55))
lines &lt;- vect(list(cds1, cds2), "lines")

extractAlong(r, lines)
</code></pre>

<hr>
<h2 id='extractRange'>Extract values for a range of layers from a SpatRaster</h2><span id='topic+extractRange'></span><span id='topic+extractRange+2CSpatRaster-method'></span><span id='topic+extractRange+2CSpatRaster+2CANY-method'></span>

<h3>Description</h3>

<p>Extract values from a SpatRaster for a set of locations and a range of layers. To extract values for a single or all layers, use <code><a href="#topic+extract">extract</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
extractRange(x, y, first, last, lyr_fun=NULL, 
		geom_fun=NULL, ID=FALSE, na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractRange_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="extractRange_+3A_y">y</code></td>
<td>
<p>SpatVector (points, lines, or polygons). Alternatively, for points, a 2-column matrix or data.frame (x, y) or (lon, lat). Or a vector with cell numbers</p>
</td></tr>
<tr><td><code id="extractRange_+3A_first">first</code></td>
<td>
<p>layer name of number, indicating the first layer in the range of layers to be considered</p>
</td></tr>
<tr><td><code id="extractRange_+3A_last">last</code></td>
<td>
<p>layer name or number, indicating the last layer in the range to be considered</p>
</td></tr>  
<tr><td><code id="extractRange_+3A_lyr_fun">lyr_fun</code></td>
<td>
<p>function to summarize the extracted data across layers</p>
</td></tr>
<tr><td><code id="extractRange_+3A_geom_fun">geom_fun</code></td>
<td>
<p>function to summarize the extracted data for each line or polygon geometry. Ignored if <code>y</code> has point geometry</p>
</td></tr>
<tr><td><code id="extractRange_+3A_id">ID</code></td>
<td>
<p>logical. Should an ID column be added? If so, the first column returned has the IDs (record numbers) of <code>y</code></p>
</td></tr>
<tr><td><code id="extractRange_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be ignored?</p>
</td></tr>
<tr><td><code id="extractRange_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>extract</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric or data.frame</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
xy &lt;- data.frame(c(50,80), c(30, 60))
extract(r, xy)
extract(r, xy, layer=c("red", "green"))
extractRange(r, xy, first=1:2, last=3:2, lyr_fun=sum)
</code></pre>

<hr>
<h2 id='extremes'>Get or compute the minimum and maximum cell values</h2><span id='topic+minmax'></span><span id='topic+hasMinMax'></span><span id='topic+setMinMax'></span><span id='topic+minmax+2CSpatRaster-method'></span><span id='topic+hasMinMax+2CSpatRaster-method'></span><span id='topic+setMinMax+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>The minimum and maximum value of a SpatRaster are returned or computed (from a file on disk if necessary) and stored in the object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
minmax(x, compute=FALSE)
## S4 method for signature 'SpatRaster'
hasMinMax(x)
## S4 method for signature 'SpatRaster'
setMinMax(x, force=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extremes_+3A_x">x</code></td>
<td>
<p> SpatRaster </p>
</td></tr>
<tr><td><code id="extremes_+3A_compute">compute</code></td>
<td>
<p>logical. If <code>TRUE</code> min and max values are computed if they are not available</p>
</td></tr>
<tr><td><code id="extremes_+3A_force">force</code></td>
<td>
<p>logical. If <code>TRUE</code> min and max values are recomputed even if already available</p>
</td></tr>
</table>


<h3>Value</h3>

<p>minmax: numeric matrix of minimum and maximum cell values by layer
</p>
<p>hasMinMax: logical indicating whether the min and max values are available.
</p>
<p>setMinMax: nothing. Used for the side-effect of computing the minimum and maximum values of a SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
minmax(r)
</code></pre>

<hr>
<h2 id='factors'>Categorical rasters</h2><span id='topic+droplevels'></span><span id='topic+droplevels+2CSpatRaster-method'></span><span id='topic+levels'></span><span id='topic+levels+2CSpatRaster-method'></span><span id='topic+levels+3C-'></span><span id='topic+levels+3C-+2CSpatRaster-method'></span><span id='topic+cats'></span><span id='topic+cats+2CSpatRaster-method'></span><span id='topic+categories'></span><span id='topic+categories+2CSpatRaster-method'></span><span id='topic+addCats'></span><span id='topic+addCats+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>A SpatRaster layer can represent a categorical variable (factor). Like <code><a href="base.html#topic+factor">factor</a></code>s, SpatRaster categories are stored as integers that have an associated label. 
</p>
<p>The categories can be inspected with <code>levels</code> and <code>cats</code>. They are represented by a <code>data.frame</code> that must have two or more columns, the first one identifying the (integer) cell values and the other column(s) providing the category labels. 
</p>
<p>If there are multiple columns with categories, you can set the &quot;active&quot; category to choose the one you want to use. 
</p>
<p><code>cats</code> returns the entire data.frame, whereas <code>levels</code> only return two columns: the index and the active category.
</p>
<p>To set categories for the first layer of a SpatRaster, you can provide <code>levels&lt;-</code> with a data.frame or a list with a data.frame. To set categories for multiple layers you can provide <code>levels&lt;-</code> with a list with one element (that either has a <code>data.frame</code> or is <code>NULL</code>) for each layer. Use <code>categories</code> to set the categories for a specific layer or specific layers.
</p>
<p><code>droplevels</code> removes categories that are not used (declared but not present as values in the raster) if <code>levels=NULL</code>.
</p>
<p><code>addCats</code> adds additional categories to a layer that already is categorical. It adds new variables, not new levels of an existing categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
levels(x)

## S4 replacement method for signature 'SpatRaster'
levels(x)&lt;-value

## S4 method for signature 'SpatRaster'
cats(x, layer)

## S4 method for signature 'SpatRaster'
categories(x, layer=1, value, active=1, ...)

## S4 method for signature 'SpatRaster'
droplevels(x, level=NULL, layer=1)

## S4 method for signature 'SpatRaster'
addCats(x, value, merge=FALSE, layer=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factors_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="factors_+3A_layer">layer</code></td>
<td>
<p>the layer name or number (positive integer); or 0 for all layers</p>
</td></tr>
<tr><td><code id="factors_+3A_value">value</code></td>
<td>
<p>a data.frame (ID, category) that define the categories. Or <code>NULL</code> to remove them</p>
</td></tr>
<tr><td><code id="factors_+3A_active">active</code></td>
<td>
<p>positive integer, indicating the column in <code>value</code> to be used as the active category (zero based to skip the first column with the cell values; that is 1 is the second column in <code>value</code>)</p>
</td></tr>
<tr><td><code id="factors_+3A_level">level</code></td>
<td>
<p>the categories to remove for the layer specified with <code>layer</code></p>
</td></tr>
<tr><td><code id="factors_+3A_merge">merge</code></td>
<td>
<p>logical. If <code>TRUE</code>, the categories are combined with <code><a href="base.html#topic+merge">merge</a></code> using the first column of <code>value</code> as ID. If <code>FALSE</code> the categories are combined with <code>cbind</code></p>
</td></tr>
<tr><td><code id="factors_+3A_...">...</code></td>
<td>
<p>additional arguments (none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data.frames (levels, cats) or logical (is.factor)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+activeCat">activeCat</a></code>, <code><a href="#topic+catalyze">catalyze</a></code>, <code><a href="#topic+set.cats">set.cats</a></code>, <code><a href="#topic+as.factor">as.factor</a></code>, <code><a href="#topic+is.factor">is.factor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
r &lt;- rast(nrows=10, ncols=10)
values(r) &lt;- sample(3, ncell(r), replace=TRUE)
is.factor(r)

cls &lt;- data.frame(id=1:3, cover=c("forest", "water", "urban"))
levels(r) &lt;- cls
is.factor(r)
r

plot(r, col=c("green", "blue", "light gray"))
text(r, digits=3, cex=.75, halo=TRUE)

# raster starts at 3
x &lt;- r + 2
is.factor(x)

# Multiple categories
d &lt;- data.frame(id=3:5, cover=cls[,2], letters=letters[1:3], value=10:12)
levels(x) &lt;- d
x

# get current index
activeCat(x)
# set index 
activeCat(x) &lt;- 3
activeCat(x)
activeCat(x) &lt;- "letters"
plot(x, col=c("green", "blue", "light gray"))
text(x, digits=3, cex=.75, halo=TRUE)

r &lt;- as.numeric(x)
r

p &lt;- as.polygons(x)
plot(p, "letters", col=c("green", "blue", "light gray"))
</code></pre>

<hr>
<h2 id='fillHoles'>Remove holes from polygons</h2><span id='topic+fillHoles'></span><span id='topic+fillHoles+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Remove the holes in SpatVector polygons. If <code>inverse=TRUE</code> the holes are returned (as polygons).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
fillHoles(x, inverse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillHoles_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="fillHoles_+3A_inverse">inverse</code></td>
<td>
<p>logical. If <code>TRUE</code> the holes are returned as polygons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
hole &lt;- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))

z &lt;- rbind(cbind(object=1, part=1, x, hole=0), 
		   cbind(object=1, part=1, hole, hole=1))
colnames(z)[3:4] &lt;- c('x', 'y')
p &lt;- vect(z, "polygons", atts=data.frame(id=1))
p

f &lt;- fillHoles(p)
g &lt;- fillHoles(p, inverse=TRUE)

plot(p, lwd=16, border="gray", col="light yellow")
polys(f, border="blue", lwd=3, density=4, col="orange")
polys(g, col="white", lwd=3)
</code></pre>

<hr>
<h2 id='fillTime'> 
Fill time gaps in a SpatRaster
</h2><span id='topic+fillTime'></span><span id='topic+fillTime+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Add empty layers in between existing layers such that the time step between each layer is the same. 
See <code><a href="#topic+approximate">approximate</a></code> to estimate values for these layer (and other missing values)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
fillTime(x, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillTime_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="fillTime_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="fillTime_+3A_...">...</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+approximate">approximate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
s &lt;- c(r, r)
time(s) &lt;- as.Date("2001-01-01") + c(0:2, 5:7)
time(s)
ss &lt;- fillTime(s)
time(ss)

a &lt;- approximate(ss)
</code></pre>

<hr>
<h2 id='flip'>Flip or reverse a raster</h2><span id='topic+flip'></span><span id='topic+flip+2CSpatRaster-method'></span><span id='topic+flip+2CSpatVector-method'></span><span id='topic+rev'></span><span id='topic+rev+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Flip the values of a SpatRaster by inverting the order of the rows (<code>vertical=TRUE</code>) or the columns (<code>vertical=FALSE</code>).
</p>
<p><code>rev</code> is the same as a horizontal *and* a vertical flip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
flip(x, direction="vertical", filename="", ...)

## S4 method for signature 'SpatVector'
flip(x, direction="vertical")

## S4 method for signature 'SpatRaster'
rev(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flip_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="flip_+3A_direction">direction</code></td>
<td>
<p>character. Should (partially) match &quot;vertical&quot; to flip by rows, or &quot;horizontal&quot; to flip by columns</p>
</td></tr>
<tr><td><code id="flip_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="flip_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+trans">trans</a></code>, <code><a href="#topic+rotate">rotate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrow=18, ncol=36)
m &lt;- matrix(1:ncell(r), nrow=18)
values(r) &lt;- as.vector(t(m))
rx &lt;- flip(r, direction="h")

values(r) &lt;- as.vector(m)
ry &lt;- flip(r, direction="v")

v &lt;- rev(r)
</code></pre>

<hr>
<h2 id='focal'>Focal values</h2><span id='topic+focal'></span><span id='topic+focal+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate focal (&quot;moving window&quot;) values for each cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
focal(x, w=3, fun="sum", ..., na.policy="all", fillvalue=NA, 
		expand=FALSE, silent=TRUE, filename="", overwrite=FALSE, wopt=list()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focal_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="focal_+3A_w">w</code></td>
<td>
<p>window. The window can be defined as one (for a square) or two numbers (row, col); or with an odd-sized weights matrix. See Details.</p>
</td></tr>
<tr><td><code id="focal_+3A_fun">fun</code></td>
<td>
<p>function that takes multiple numbers, and returns a numeric vector (one or multiple numbers). For example mean, modal, min or max</p>
</td></tr>
<tr><td><code id="focal_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fun</code> such as <code>na.rm</code></p>
</td></tr>
<tr><td><code id="focal_+3A_na.policy">na.policy</code></td>
<td>
<p>character. Can be used to determine the cells of <code>x</code> for which focal values should be computed. Must be one of &quot;all&quot; (compute for all cells), &quot;only&quot; (only for cells that are <code>NA</code>) or &quot;omit&quot; (skip cells that are <code>NA</code>). Note that the value of this argument does not affect which cells around each focal cell are included in the computations (use <code>na.rm=TRUE</code> to ignore cells that are <code>NA</code> for that)</p>
</td></tr>
<tr><td><code id="focal_+3A_fillvalue">fillvalue</code></td>
<td>
<p>numeric. The value of the cells in the virtual rows and columns outside of the raster</p>
</td></tr>
<tr><td><code id="focal_+3A_expand">expand</code></td>
<td>
<p>logical. If <code>TRUE</code> The value of the cells in the virtual rows and columns outside of the raster are set to be the same as the value on the border. Only available for &quot;build-in&quot; <code>fun</code>s such as mean, sum, min and max</p>
</td></tr>
<tr><td><code id="focal_+3A_silent">silent</code></td>
<td>
<p>logical. If <code>TRUE</code> error messages are printed that may occur when trying <code>fun</code> to determine the length of the returned value. This can be useful in debugging a <code>fun</code> that does not work</p>
</td></tr>
<tr><td><code id="focal_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="focal_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="focal_+3A_wopt">wopt</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>focal</code> 
The window used must have odd dimensions. If you need even sides, you can use a matrix and add a column or row of <code>NA</code>'s to mask out values.
</p>
<p>Window values are typically 1 or <code>NA</code> to indicate whether a value is used or ignored in computations, respectively. <code>NA</code> values in <code>w</code> can be useful for creating non-rectangular (e.g. circular) windows. 
</p>
<p>A weights matrix of numeric values can also be supplied to <code>w</code>. In the case of a weights matrix, cells with <code>NA</code> weights will be ignored, and the rest of the values in the focal window will be multiplied by the corresponding weight prior to 'fun' being applied. Note, <code>na.rm</code> does not need to be <code>TRUE</code> if <code>w</code> contains <code>NA</code> values as these cells are ignored in computations. 
</p>
<p>The &quot;mean&quot; function is a special case, where supplying weights to <code>w</code> will instead calculate a weighted mean.
</p>
<p>The &quot;sum&quot; function returns <code>NA</code> if all focal cells are <code>NA</code> and <code>na.rm=TRUE</code>. R would normally return a zero in these cases. See the difference between <code>focal(x, fun=sum, na.rm=TRUE)</code> and <code>focal(x, fun=\(i) sum(i, na.rm=TRUE))</code>
</p>
<p>Example weight matrices
</p>
<p>Laplacian filter: <code>filter=matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3)</code>
</p>
<p>Sobel filters (for edge detection):
</p>
<p><code>fx=matrix(c(-1,-2,-1,0,0,0,1,2,1), nrow=3)</code>
</p>
<p><code>fy=matrix(c(1,0,-1,2,0,-2,1,0,-1), nrow=3)</code>
</p>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>Note</h3>

<p>When using global lon/lat rasters, the focal window &quot;wraps around&quot; the date-line.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focalMat">focalMat</a></code>, <code><a href="#topic+focalValues">focalValues</a></code>, <code><a href="#topic+focal3D">focal3D</a></code>, <code><a href="#topic+focalPairs">focalPairs</a></code>, <code><a href="#topic+focalReg">focalReg</a></code>, <code><a href="#topic+focalCpp">focalCpp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10, ext(0, 10, 0, 10))
values(r) &lt;- 1:ncell(r)

f &lt;- focal(r, w=3, fun=function(x, ...) quantile(x, c(.25, .5, .75), ...), na.rm=TRUE) 

f &lt;- focal(r, w=3, fun="mean") 

# the following two statements are equivalent:
a &lt;- focal(r, w=matrix(1/9, nc=3, nr=3))
b &lt;- focal(r, w=3, fun=mean, na.rm=FALSE)

# but this is different
d &lt;- focal(r, w=3, fun=mean, na.rm=TRUE)

## illustrating the effect of different 
## combinations of na.rm and na.policy
v &lt;- vect(system.file("ex/lux.shp", package="terra"))
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
r[45:50, 45:50] &lt;- NA

# also try "mean" or "min"
f &lt;- "sum" 
# na.rm=FALSE
plot(focal(r, 5, f) , fun=lines(v))

# na.rm=TRUE
plot(focal(r, 5, f, na.rm=TRUE), fun=lines(v))

# only change cells that are NA
plot(focal(r, 5, f, na.policy="only", na.rm=TRUE), fun=lines(v))

# do not change cells that are NA
plot(focal(r, 5, f, na.policy="omit", na.rm=TRUE), fun=lines(v))

# does not do anything
# focal(r, 5, f, na.policy="only", na.rm=FALSE)
</code></pre>

<hr>
<h2 id='focal3D'>Three-dimensional focal values</h2><span id='topic+focal3D'></span><span id='topic+focal3D+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate focal (&quot;moving window&quot;) values for the three-dimensional neighborhood (window) of focal cells. See <code><a href="#topic+focal">focal</a></code> for two-dimensional focal computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
focal3D(x, w=3, fun=mean, ..., na.policy="all", fillvalue=NA, pad=FALSE, 
	padvalue=fillvalue, expand=FALSE, silent=TRUE, 
	filename="", overwrite=FALSE, wopt=list()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focal3D_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="focal3D_+3A_w">w</code></td>
<td>
<p>window. A rectangular prism (cuboid) defined by three numbers or by a three-dimensional array. The values are used as weights, and are usually zero, one, NA, or fractions. The window used must have odd dimensions. If you desire to use even sides, you can use an array, and pad the values with rows and/or columns that contain only <code>NA</code>s.
</p>
</td></tr>
<tr><td><code id="focal3D_+3A_fun">fun</code></td>
<td>
<p>function that takes multiple numbers, and returns one or multiple numbers for each focal area. For example mean, modal, min or max</p>
</td></tr>
<tr><td><code id="focal3D_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fun</code> such as <code>na.rm</code></p>
</td></tr>
<tr><td><code id="focal3D_+3A_na.policy">na.policy</code></td>
<td>
<p>character. Can be used to determine the cells of <code>x</code>, in the central layer, for which focal values should be computed. Must be one of &quot;all&quot; (compute for all cells), &quot;only&quot; (only for cells that are <code>NA</code>) or &quot;omit&quot; (skip cells that are <code>NA</code>). Note that the value of this argument does not affect which cells around each focal cell are included in the computations (use <code>na.rm=TRUE</code> to ignore cells that are <code>NA</code> in the computation of the focal value)</p>
</td></tr>
<tr><td><code id="focal3D_+3A_fillvalue">fillvalue</code></td>
<td>
<p>numeric. The value of the cells in the virtual rows and columns outside of the raster</p>
</td></tr>
<tr><td><code id="focal3D_+3A_pad">pad</code></td>
<td>
<p>logical. Add virtual layers before the first and after the last layer</p>
</td></tr>
<tr><td><code id="focal3D_+3A_padvalue">padvalue</code></td>
<td>
<p>numeric. The value of the cells in the virtual layers</p>
</td></tr>
<tr><td><code id="focal3D_+3A_expand">expand</code></td>
<td>
<p>logical. Add virtual layers before the first or after the last layer that are the same as the first or last layers. If <code>TRUE</code>, arguments <code>pad</code> and <code>padvalue</code> are ignored</p>
</td></tr>
<tr><td><code id="focal3D_+3A_silent">silent</code></td>
<td>
<p>logical. If <code>TRUE</code> error messages are printed that may occur when trying <code>fun</code> to determine the length of the returned value. This can be useful in debugging a function passed to <code>fun</code> that does not work</p>
</td></tr>
<tr><td><code id="focal3D_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="focal3D_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="focal3D_+3A_wopt">wopt</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focal">focal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
x &lt;- focal3D(r, c(5,5,3), na.rm=TRUE)

a &lt;- array(c(0,1,0,1,1,1,0,1,0, rep(1,9), 0,1,0,1,1,1,0,1,0), c(3,3,3))
a[a==0] &lt;- NA
z &lt;- focal3D(r, a, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='focalCpp'>Compute focal values with an iterating C++ function</h2><span id='topic+focalCpp'></span><span id='topic+focalCpp+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate focal values with a C++ function that iterates over cells to speed up computations by avoiding an R loop (with apply).
</p>
<p>See <code><a href="#topic+focal">focal</a></code> for an easier to use method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
focalCpp(x, w=3, fun, ..., fillvalue=NA, 
		silent=TRUE, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focalCpp_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="focalCpp_+3A_w">w</code></td>
<td>
<p>window. The window can be defined as one (for a square) or two numbers (row, col); or with an odd-sized weights matrix. See the Details section in <code><a href="#topic+focal">focal</a></code></p>
</td></tr>
<tr><td><code id="focalCpp_+3A_fun">fun</code></td>
<td>
<p><code><a href="Rcpp.html#topic+cppFunction">cppFunction</a></code> that iterates over cells. For C++ functions that operate on a single focal window, or for R functions use <code><a href="#topic+focal">focal</a></code> instead. The function must have at least three arguments. The first argument can have any name, but it must be a <code>Rcpp::NumericVector</code>, <code>Rcpp::IntegerVector</code> or a <code>std::vector&lt;double&gt;</code>. This is the container that receives the focal values. The other two arguments <code>ni</code> and <code>wi</code> must be of type <code>size_t</code>. <code>ni</code> represents the number of cells and <code>nw</code> represents the size of (number of elements in) the window</p>
</td></tr>
<tr><td><code id="focalCpp_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>fun</code></p>
</td></tr>
<tr><td><code id="focalCpp_+3A_fillvalue">fillvalue</code></td>
<td>
<p>numeric. The value of the cells in the virtual rows and columns outside of the raster</p>
</td></tr>
<tr><td><code id="focalCpp_+3A_silent">silent</code></td>
<td>
<p>logical. If <code>TRUE</code> error messages are printed that may occur when trying <code>fun</code> to determine the length of the returned value. This can be useful in debugging a <code>fun</code> that does not work</p>
</td></tr>
<tr><td><code id="focalCpp_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="focalCpp_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="focalCpp_+3A_wopt">wopt</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focal">focal</a></code>, <code><a href="#topic+focalValues">focalValues</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(Rcpp)
cppFunction( 
	'NumericVector sum_and_multiply(NumericVector x, double m, size_t ni, size_t nw) {
		NumericVector out(ni);
		// loop over cells
		size_t start = 0;
		for (size_t i=0; i&lt;ni; i++) {
			size_t end = start + nw;
			// compute something for a window
			double v = 0;
			// loop over the values of a window
			for (size_t j=start; j&lt;end; j++) {
				v += x[j];
			}
			out[i] = v * m;
			start = end;
		}
		return out;
	}'
)

nr &lt;- nc &lt;- 10
r &lt;- rast(ncols=nc, nrows=nr, ext= c(0, nc, 0, nr))
values(r) &lt;- 1:ncell(r)

raw &lt;- focalCpp(r, w=3, fun=sum_and_multiply, fillvalue=0, m=10)

# same as
f1 &lt;- focal(r, w=3, fun=sum, fillvalue=0) *10
all(values(f1) == values(raw))

# and as
ffun &lt;- function(x, m) { sum(x) * m }
f2 &lt;- focal(r, w=3, fun=ffun, fillvalue=0, m=10)


# You can also use an R function with focalCpp but this
# is not recommended 

R_sm_iter &lt;- function(x, m, ni, nw) {
	out &lt;- NULL
	for (i in 1:ni) {
		start &lt;- (i-1) * nw + 1
		out[i] &lt;- sum(x[start:(start+nw-1)]) * m
	}
	out
}

fr &lt;- focalCpp(r, w=3, fun=R_sm_iter, fillvalue=0, m=10)


## End(Not run)
</code></pre>

<hr>
<h2 id='focalMat'>Focal weights matrix</h2><span id='topic+focalMat'></span>

<h3>Description</h3>

<p>Make a focal (&quot;moving window&quot;) weight matrix for use in the <code><a href="#topic+focal">focal</a></code> function. The sum of the values adds up to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focalMat(x, d, type=c('circle', 'Gauss', 'rectangle'), fillNA=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focalMat_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="focalMat_+3A_d">d</code></td>
<td>
<p>numeric. If <code>type=circle</code>, the radius of the circle (in units of the crs). If <code>type=rectangle</code> the dimension of the rectangle (one or two numbers). If <code>type=Gauss</code> the size of sigma, and optionally another number to determine the size of the matrix returned (default is 3*sigma)</p>
</td></tr> 
<tr><td><code id="focalMat_+3A_type">type</code></td>
<td>
<p>character indicating the type of filter to be returned</p>
</td></tr>
<tr><td><code id="focalMat_+3A_fillna">fillNA</code></td>
<td>
<p>logical. If <code>TRUE</code>, zeros are set to <code>NA</code> such that they are ignored in the computations. Only applies to <code>type="circle"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix that can be used with <code><a href="#topic+focal">focal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=180, nrows=180, xmin=0)
focalMat(r, 2, "circle")

focalMat(r, c(2,3), "rect")

# Gaussian filter for square cells
gf &lt;- focalMat(r, 1, "Gauss")
</code></pre>

<hr>
<h2 id='focalPairs'>Focal function across two layers</h2><span id='topic+focalCor'></span><span id='topic+focalCor+2CSpatRaster-method'></span><span id='topic+focalPairs'></span><span id='topic+focalPairs+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate values such as a correlation coefficient for focal regions in two neighboring layers. A function is applied to the first and second layer, then to the second and third layer, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
focalPairs(x, w=3, fun, ..., fillvalue=NA, 
		filename="", overwrite=FALSE, wopt=list()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focalPairs_+3A_x">x</code></td>
<td>
<p>SpatRaster with at least two layers</p>
</td></tr>
<tr><td><code id="focalPairs_+3A_w">w</code></td>
<td>
<p>numeric or matrix to define the focal window. The window an be defined as one (for a square) or two numbers (row, col); or with an odd-sized weights matrix. See the Details section in <code><a href="#topic+focal">focal</a></code>. Note that if a matrix with numbers other than zero or one are used, the values are used as weights. For this to work, <code>fun</code> must have an argument <code>weights</code></p>
</td></tr>
<tr><td><code id="focalPairs_+3A_fun">fun</code></td>
<td>
<p>a function with at least two arguments (one for each layer). There is a built-in function &quot;pearson&quot; (for both the weighted and the unweighted Pearson correlation coefficient. This function has an additional argument <code>na.rm=FALSE</code></p>
</td></tr>
<tr><td><code id="focalPairs_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code></p>
</td></tr>
<tr><td><code id="focalPairs_+3A_fillvalue">fillvalue</code></td>
<td>
<p>numeric. The value of the cells in the virtual rows and columns outside of the raster</p>
</td></tr>
<tr><td><code id="focalPairs_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="focalPairs_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="focalPairs_+3A_wopt">wopt</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

 <p><code><a href="#topic+layerCor">layerCor</a></code>, <code><a href="#topic+focalReg">focalReg</a></code>, <code><a href="#topic+focal">focal</a></code>, <code><a href="#topic+focal3D">focal3D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))
set.seed(0)
r[[1]] &lt;- flip(r[[1]], "horizontal")
r[[2]] &lt;- flip(r[[2]], "vertical") + init(rast(r,1), runif)
r[[3]] &lt;- init(rast(r,1), runif)

x &lt;- focalPairs(r, w=5, "pearson", na.rm=TRUE)
plot(x)


# suppress warning "the standard deviation is zero"
suppressWarnings(x &lt;- focalPairs(r, w=5, "pearson", use="complete.obs"))

z &lt;- focalPairs(r, w=9, function(x, y) mean(x) + mean(y))
</code></pre>

<hr>
<h2 id='focalReg'>Focal regression</h2><span id='topic+focalReg'></span><span id='topic+focalReg+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Calculate values for a moving-window by comparing the value in one layers with the values in one to many other layers. A typical case is the computation of the coefficients for a focal linear regression model. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
focalReg(x, w=3, fun="ols", ..., fillvalue=NA, filename="", overwrite=FALSE, wopt=list()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focalReg_+3A_x">x</code></td>
<td>
<p>SpatRaster with at least two layers. The first is the &quot;Y&quot; (dependent) variable and the remainder are the &quot;X&quot; (independent) variables</p>
</td></tr>
<tr><td><code id="focalReg_+3A_w">w</code></td>
<td>
<p>numeric or matrix to define the focal window. The window an be defined as one (for a square) or two numbers (row, col); or with an odd-sized weights matrix. See the Details section in <code><a href="#topic+focal">focal</a></code>. Note that if a matrix with numbers other than zero or one are used, the values are used as weights. For this to work, <code>fun</code> must have an argument <code>weights</code></p>
</td></tr>
<tr><td><code id="focalReg_+3A_fun">fun</code></td>
<td>
<p>a function with at least two arguments (one for each layer). There is a built-in function &quot;ols&quot; for both the weighted and unweighted Ordinary Least Square regression. This function has an additional argument <code>na.rm=FALSE</code> and <code>intercept=TRUE</code></p>
</td></tr>
<tr><td><code id="focalReg_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code></p>
</td></tr>
<tr><td><code id="focalReg_+3A_fillvalue">fillvalue</code></td>
<td>
<p>numeric. The value of the cells in the virtual rows and columns outside of the raster</p>
</td></tr>
<tr><td><code id="focalReg_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="focalReg_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="focalReg_+3A_wopt">wopt</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focal">focal</a>, <a href="#topic+focal3D">focal3D</a></code>, <a href="#topic+focalValues">focalValues</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10, ext(0, 10, 0, 10))
values(r) &lt;- 1:ncell(r)
x &lt;- c(r, init(r, runif) * r)
f &lt;- focalReg(x, 3)
</code></pre>

<hr>
<h2 id='focalValues'>Get focal values</h2><span id='topic+focalValues'></span><span id='topic+focalValues+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get a matrix in which each row had the focal values of a cell. These are the values of a cell and a rectangular window around it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
focalValues(x, w=3, row=1, nrows=nrow(x), fill=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focalValues_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="focalValues_+3A_w">w</code></td>
<td>
<p>window. The window can be defined as one (for a square) or two odd numbers (row, col); or with an odd sized matrix</p>
</td></tr>
<tr><td><code id="focalValues_+3A_row">row</code></td>
<td>
<p>positive integer. Row number to start from, should be between 1 and nrow(x)</p>
</td></tr>
<tr><td><code id="focalValues_+3A_nrows">nrows</code></td>
<td>
<p>positive integer. How many rows?</p>
</td></tr>
<tr><td><code id="focalValues_+3A_fill">fill</code></td>
<td>
<p>numeric used as values for imaginary cells outside the raster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncol=4, nrow=4, crs="+proj=utm +zone=1 +datum=WGS84")
values(r) &lt;- 1:ncell(r)
focalValues(r)
</code></pre>

<hr>
<h2 id='forceCCW'>force counter-clockwise polygons</h2><span id='topic+forceCCW'></span><span id='topic+forceCCW+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Assure that the nodes of outer rings of polygons are in counter-clockwise order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
forceCCW(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forceCCW_+3A_x">x</code></td>
<td>
<p>SpatVector of polygons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- vect("POLYGON ((2 45, 2 55, 18 55, 18 45, 2 45))")
pcc &lt;- forceCCW(p)
geom(pcc, wkt=TRUE)
</code></pre>

<hr>
<h2 id='freq'>Frequency table</h2><span id='topic+freq'></span><span id='topic+freq+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Frequency table of the values of a SpatRaster. <code>NA</code>s are not counted unless <code>value=NA</code>. 
</p>
<p>You can provide a SpatVector or additional SpatRaster to define zones for which to do tabulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
freq(x, digits=0, value=NULL, bylayer=TRUE, usenames=FALSE, zones=NULL, wide=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="freq_+3A_digits">digits</code></td>
<td>
<p>integer. Used for rounding the values before tabulation. Ignored if <code>NA</code></p>
</td></tr>
<tr><td><code id="freq_+3A_value">value</code></td>
<td>
<p>numeric. An optional single value to only count the number of cells with that value. This value can be <code>NA</code></p>
</td></tr>
<tr><td><code id="freq_+3A_bylayer">bylayer</code></td>
<td>
<p>logical. If <code>TRUE</code> tabulation is done by layer</p>
</td></tr>  
<tr><td><code id="freq_+3A_usenames">usenames</code></td>
<td>
<p>logical. If <code>TRUE</code> layers are identified by their names instead of their numbers. Only relevant if <code>bylayer</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="freq_+3A_zones">zones</code></td>
<td>
<p>SpatRaster or SpatVector to define zones for which the tabulation should be done</p>
</td></tr>
<tr><td><code id="freq_+3A_wide">wide</code></td>
<td>
<p>logical. Should the results by &quot;wide&quot; instead of &quot;long&quot;?</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with 3 columns (layer, value, count) unless <code>bylayer=FALSE</code> in which case a<code>data.frame</code> with two columns is returned (value, count). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=10, ncols=10)
set.seed(2)
values(r) &lt;- sample(5, ncell(r), replace=TRUE)

freq(r)

x &lt;- c(r, r/3)
freq(x, bylayer=FALSE)
freq(x)

freq(x, digits=1)
freq(x, digits=-1)

freq(x, value=5)

</code></pre>

<hr>
<h2 id='gaps'>Find gaps between polygons</h2><span id='topic+gaps'></span><span id='topic+gaps+2CSpatVector-method'></span><span id='topic+gaps+2CSpatVector+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Get the gaps between polygons of a SpatVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
gaps(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaps_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sharedPaths">sharedPaths</a></code>, <code><a href="#topic+topology">topology</a></code>, and 
<code><a href="#topic+fillHoles">fillHoles</a></code> to get or remove polygon holes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
h &lt;- convHull(v[-12], "NAME_1")
g &lt;- gaps(h)
</code></pre>

<hr>
<h2 id='gdal'>GDAL version, supported file formats, and cache size</h2><span id='topic+gdal'></span><span id='topic+gdalCache'></span><span id='topic+getGDALconfig'></span><span id='topic+setGDALconfig'></span>

<h3>Description</h3>

<p>Set the <code>GDAL</code> warning level or get a <code>data.frame</code> with the available GDAL drivers (file formats), or, if <code>warn=NA</code> and <code>drivers=FALSE</code>, you get the version numbers of one or all of the GDAL, PROJ and GEOS libraries. 
</p>
<p><code>GDAL</code> is the software library that terra builds on to read and write spatial data and for some raster data processing. <code>PROJ</code> is used for transformation of coordinates (&quot;projection&quot;) and <code>GEOS</code> is used for geometric operations with vector data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdal(warn=NA, drivers=FALSE, lib="gdal")
gdalCache(size=NA)
setGDALconfig(option, value="")
getGDALconfig(option)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdal_+3A_warn">warn</code></td>
<td>
<p>If <code>NA</code> and <code>drivers=FALSE</code>, the version of the library specified by <code>lib</code> is returned. Otherwise, the value should be an integer between 1 and 4 representing the level of GDAL warnings and errors that are passed to R. 1 = warnings and errors; 2 = errors only (recoverable errors as a warning); 3 = irrecoverable errors only; 4 = ignore all errors and warnings. The default setting is 3</p>
</td></tr>
<tr><td><code id="gdal_+3A_drivers">drivers</code></td>
<td>
<p>logical. If <code>TRUE</code> a data.frame with the raster and vector data formats that are available.</p>
</td></tr> 
<tr><td><code id="gdal_+3A_lib">lib</code></td>
<td>
<p>character. &quot;gdal&quot;, &quot;proj&quot;, or &quot;geos&quot;, or any other value to get the versions numbers of all three</p>
</td></tr>
<tr><td><code id="gdal_+3A_size">size</code></td>
<td>
<p>numeric. The new cache size in MB</p>
</td></tr>  
<tr><td><code id="gdal_+3A_option">option</code></td>
<td>
<p>character. GDAL configuration option name, or a &quot;name=value&quot; string (in which case the value argument is ignored</p>
</td></tr>
<tr><td><code id="gdal_+3A_value">value</code></td>
<td>
<p>character. value for GDAL configuration option. Use &quot;&quot; to reset it to its default value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+describe">describe</a></code> for file-level metadata &quot;GDALinfo&quot;</p>


<h3>Examples</h3>

<pre><code class='language-R'>gdal()
gdal(2)
head(gdal(drivers=TRUE))
</code></pre>

<hr>
<h2 id='geom'>Get the geometry (coordinates) of a SpatVector</h2><span id='topic+geom'></span><span id='topic+geom+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get the geometry of a SpatVector. If <code>wkt=FALSE</code>, this is a five-column matrix or data.frame: the vector object ID, the IDs for the parts of each object (e.g. five polygons that together are one spatial object), the x (longitude) and y (latitude) coordinates, and a flag indicating whether the part is a &quot;hole&quot; (only relevant for polygons). 
</p>
<p>If <code>wkt=TRUE</code>, the &quot;well-known text&quot; representation is returned as a character vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
geom(x, wkt=FALSE, hex=FALSE, df=FALSE, list=FALSE, xnm="x", ynm="y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="geom_+3A_wkt">wkt</code></td>
<td>
<p>logical. If <code>TRUE</code> the WKT geometry is returned (unless <code>hex</code> is also <code>TRUE</code>)</p>
</td></tr>  
<tr><td><code id="geom_+3A_hex">hex</code></td>
<td>
<p>logical. If <code>TRUE</code> the hexadecimal geometry is returned</p>
</td></tr>  
<tr><td><code id="geom_+3A_df">df</code></td>
<td>
<p>logical. If <code>TRUE</code> a <code>data.frame</code> is returned instead of a matrix (only if <code>wkt=FALSE</code>, <code>hex=FALSE</code>, and <code>list=FALSE</code>)</p>
</td></tr> 
<tr><td><code id="geom_+3A_list">list</code></td>
<td>
<p>logical. If <code>TRUE</code> a nested <code>list</code> is returned with data.frames of coordinates</p>
</td></tr>
<tr><td><code id="geom_+3A_xnm">xnm</code></td>
<td>
<p>character. If <code>list=TRUE</code> the &quot;x&quot; column name for the coordinates data.frame </p>
</td></tr>  
<tr><td><code id="geom_+3A_ynm">ynm</code></td>
<td>
<p>character. If <code>list=TRUE</code> the &quot;y&quot; column name for the coordinates data.frame</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>matrix, vector, data.frame, or list
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crds">crds</a></code>, <code><a href="#topic+xyFromCell">xyFromCell</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- rbind(c(-175,-20), c(-140,55), c(10, 0), c(-140,-60))
x2 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))
x3 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
x4 &lt;- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))
z &lt;- rbind(cbind(object=1, part=1, x1), cbind(object=2, part=1, x2), 
           cbind(object=3, part=1, x3), cbind(object=3, part=2,  x4))
colnames(z)[3:4] &lt;- c('x', 'y')
z &lt;- cbind(z, hole=0)
z[(z[, "object"]==3 &amp; z[,"part"]==2), "hole"] &lt;- 1

p &lt;- vect(z, "polygons")
geom(p)

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
g &lt;- geom(v)
head(g)

w &lt;- geom(v, wkt=TRUE)
substr(w, 1, 60)
</code></pre>

<hr>
<h2 id='geomtype'>Geometry type of a SpatVector</h2><span id='topic+geomtype'></span><span id='topic+geomtype+2CSpatVector-method'></span><span id='topic+geomtype+2CSpatVectorProxy-method'></span><span id='topic+geomtype+2CSpatial-method'></span><span id='topic+is.points'></span><span id='topic+is.lines'></span><span id='topic+is.polygons'></span><span id='topic+is.points+2CSpatVector-method'></span><span id='topic+is.lines+2CSpatVector-method'></span><span id='topic+is.polygons+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get the geometry type (points, lines, or polygons) of a SpatVector. See <code><a href="#topic+datatype">datatype</a></code> for the data types of the fields (attributes, variables) of a SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
geomtype(x)

## S4 method for signature 'SpatVector'
is.points(x)

## S4 method for signature 'SpatVector'
is.lines(x)

## S4 method for signature 'SpatVector'
is.polygons(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomtype_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)

geomtype(v)
is.polygons(v)
is.lines(v)
is.points(v)

names(v)
datatype(v)
</code></pre>

<hr>
<h2 id='global'>global statistics</h2><span id='topic+global'></span><span id='topic+global+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute global statistics, that is summarized values of an entire SpatRaster. 
</p>
<p>If <code>x</code> is very large <code>global</code> can fail, except when <code>fun</code> is one of these built-in functions &quot;mean&quot;, &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;prod&quot;, &quot;range&quot; (min and max), &quot;rms&quot; (root mean square), &quot;sd&quot; (sample standard deviation), &quot;std&quot; (population standard deviation), &quot;isNA&quot; (number of cells that are NA), &quot;notNA&quot; (number of cells that are not NA).
</p>
<p>The reason that this can fail with large raster and a custom function is that all values need to be loaded into memory. To circumvent this problem you can run <code>global</code> with a sample of the cells.
</p>
<p>You can compute a weighted mean or sum by providing a SpatRaster with weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
global(x, fun="mean", weights=NULL, maxcell=Inf, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="global_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="global_+3A_fun">fun</code></td>
<td>
<p>function to be applied to summarize the values by zone. Either as one or more of these built-in character values: &quot;max&quot;, &quot;min&quot;, &quot;mean&quot;, &quot;sum&quot;, &quot;range&quot;, &quot;rms&quot; (root mean square), &quot;sd&quot;, &quot;std&quot; (population sd, using <code>n</code> rather than <code>n-1</code>), &quot;isNA&quot;, &quot;notNA&quot;; or a proper R function (but these may fail for very large SpatRasters unless you specify <code>maxcell</code>)</p>
</td></tr>
<tr><td><code id="global_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>fun</code></p>
</td></tr>  
<tr><td><code id="global_+3A_weights">weights</code></td>
<td>
<p>NULL or SpatRaster</p>
</td></tr>  
<tr><td><code id="global_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer used to take a regular sample of <code>x</code>. Ignored by the built-in functions.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with a row for each layer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zonal">zonal</a></code> for &quot;zonal&quot; statistics, and <code><a href="#topic+app">app</a></code> or <code><a href="#topic+Summary-methods">Summary-methods</a></code> for &quot;local&quot; statistics, and <code><a href="#topic+extract">extract</a></code> for summarizing values for polygons. Also see <code><a href="#topic+focal">focal</a></code> for &quot;focal&quot; or &quot;moving window&quot; operations.</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- 1:ncell(r)
global(r, "sum")
global(r, "mean", na.rm=TRUE)
x &lt;- c(r, r/10)
global(x, c("sum", "mean", "sd"), na.rm=TRUE)

global(x, function(i) min(i) / max(i))
</code></pre>

<hr>
<h2 id='graticule'> 
Create a graticule
</h2><span id='topic+graticule'></span>

<h3>Description</h3>

<p>Create a graticule. That is, a grid of lon/lat lines that can be used to on a projected map.
</p>
<p>The object returned, a SpatGraticule, can be plotted with <code>plot</code> and <code>lines</code>. There is also a <code>crop</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graticule(lon=30, lat=30, crs="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graticule_+3A_lon">lon</code></td>
<td>
<p>numeric. Either a single number (the interval between longitudes), or a vector with longitudes</p>
</td></tr>
<tr><td><code id="graticule_+3A_lat">lat</code></td>
<td>
<p>numeric. Either a single number (the interval between latitudes), or a vector with latitudes</p>
</td></tr>
<tr><td><code id="graticule_+3A_crs">crs</code></td>
<td>
<p>character. The coordinate reference system to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatGraticule
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot+2CSpatGraticule+2Cmissing-method">plot&lt;SpatGraticule&gt;</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graticule(60, 30, crs="+proj=robin")
g

graticule(90, c(-90, -60, -23.5, 0, 23.5, 60, 90), crs="+proj=robin")

</code></pre>

<hr>
<h2 id='gridDistance'>Distance on a grid</h2><span id='topic+gridDistance'></span><span id='topic+gridDistance+2CSpatRaster-method'></span><span id='topic+gridDist'></span><span id='topic+gridDist+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>The function calculates the distance to cells of a SpatRaster when the path has to go through the centers of the eight neighboring raster cells.
</p>
<p>The default distance (when <code>scale=1</code>, is meters if the coordinate reference system (CRS) of the SpatRaster is longitude/latitude (<code>+proj=longlat</code>) and in the linear units of the CRS (typically meters) in other cases. 
</p>
<p>Distances are computed by summing local distances between cells, which are connected with their neighbors in 8 directions.
</p>
<p>The shortest distance to the cells with the <code>target</code> value is computed for all cells that are not <code>NA</code>. Cells that are <code>NA</code> cannot be traversed and are ignored, unless the target itself is <code>NA</code>, in which case the distance to the nearest cell that is not <code>NA</code> is computed for all cells that are <code>NA</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
gridDist(x, target=0, scale=1, maxiter=50, filename="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridDistance_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_target">target</code></td>
<td>
<p>numeric. value of the target cells (where to compute distance to)</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_scale">scale</code></td>
<td>
<p>numeric. Scale factor. For longitude/latitude data 1 = &quot;m&quot; and 1000 = &quot;km&quot;. For planar data that is also the case of the distance unit of the crs is &quot;m&quot;</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_maxiter">maxiter</code></td>
<td>
<p>numeric. The maximum number of iterations. Increase this number if you get the warning that <code>costDistance</code> did not converge. Only relevant when target is not <code>NA</code></p>
</td></tr>
<tr><td><code id="gridDistance_+3A_filename">filename</code></td>
<td>
<p>character. output filename (optional)</p>
</td></tr>
<tr><td><code id="gridDistance_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+distance">distance</a></code> for &quot;as the crow flies&quot; distance, and <code><a href="#topic+costDist">costDist</a></code> for distance across a landscape with variable friction</p>


<h3>Examples</h3>

<pre><code class='language-R'># global lon/lat raster
r &lt;- rast(ncol=10,nrow=10, vals=1)
r[48] &lt;- 0
r[66:68] &lt;- NA
d &lt;- gridDist(r) 
plot(d)


# planar
crs(r) &lt;- "+proj=utm +zone=15 +ellps=GRS80 +datum=NAD83 +units=m +no_defs"
d &lt;- gridDist(r) 
plot(d)

# distance to cells that are not NA 
rr &lt;- classify(r, cbind(1, NA))
dd &lt;- gridDist(rr, NA) 


</code></pre>

<hr>
<h2 id='halo'>Add halo-ed text to a plot</h2><span id='topic+halo'></span>

<h3>Description</h3>

<p>Add text to a plot that has a &quot;halo&quot;. That is, a buffer around it to enhance visibility. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halo(x, y=NULL, labels, col="black", hc="white", hw=0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="halo_+3A_x">x</code>, <code id="halo_+3A_y">y</code></td>
<td>
<p>numeric. coordinates where the text labels should be written</p>
</td></tr>
<tr><td><code id="halo_+3A_labels">labels</code></td>
<td>
<p>character. The text to be written</p>
</td></tr>
<tr><td><code id="halo_+3A_col">col</code></td>
<td>
<p>character. The main color to be used</p>
</td></tr>
<tr><td><code id="halo_+3A_hc">hc</code></td>
<td>
<p>character. The halo color</p>
</td></tr>
<tr><td><code id="halo_+3A_hw">hw</code></td>
<td>
<p>numeric. The halo width</p>
</td></tr>
<tr><td><code id="halo_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="graphics.html#topic+text">text</a></code> </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+text">text</a>, <a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast(nrows=4, ncols=4)
values(r) &lt;- 1:ncell(r)
plot(r, col="blue", legend=FALSE)

text(-100, 20, "hello", cex=2)
halo(50, 20, "hello", cex=2)

halo(0, -20, "world", font=3, hc="light blue", cex=2, hw=.2)
halo(0, 90, "world", font=2, cex=2, hw=.2, xpd=TRUE, pos=2)
halo(0, 90, "world", col="white", font=2, hc="blue", cex=2, hw=.2, xpd=TRUE, pos=4)
</code></pre>

<hr>
<h2 id='headtail'>head and tail of a SpatRaster or SpatVector</h2><span id='topic+head'></span><span id='topic+head+2CSpatRaster-method'></span><span id='topic+head+2CSpatVector-method'></span><span id='topic+tail'></span><span id='topic+tail+2CSpatRaster-method'></span><span id='topic+tail+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Show the head (first values) or tail (last values) of a SpatRaster or of the attributes of a SpatVector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>head(x, ...) 
tail(x, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="headtail_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="headtail_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (SpatRaster) or data.frame (SpatVector)
</p>


<h3>See Also</h3>

<p><code><a href="methods.html#topic+show">show</a></code>, <code><a href="#topic+geom">geom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=25, ncols=25)
values(r) &lt;- 1:ncell(r)
head(r)
tail(r)
</code></pre>

<hr>
<h2 id='hist'>Histogram</h2><span id='topic+hist'></span><span id='topic+hist+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Create a histogram of the values of a SpatRaster. For large datasets a sample of <code>maxcell</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
hist(x, layer, maxcell=1000000, plot=TRUE, maxnl=16, main, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="hist_+3A_layer">layer</code></td>
<td>
<p>positive integer or character to indicate layer numbers (or names). If missing, all layers up to <code>maxnl</code> are used</p>
</td></tr> 
<tr><td><code id="hist_+3A_maxcell">maxcell</code></td>
<td>
<p>integer. To regularly sample very large objects</p>
</td></tr>
<tr><td><code id="hist_+3A_plot">plot</code></td>
<td>
<p>logical. Plot the histogram or only return the histogram values</p>
</td></tr>
<tr><td><code id="hist_+3A_maxnl">maxnl</code></td>
<td>
<p>positive integer. The maximum number of layers to use. Ignored if <code>layer</code> is not missing</p>
</td></tr>
<tr><td><code id="hist_+3A_main">main</code></td>
<td>
<p>character. Main title(s) for the plot. Default is the value of <code><a href="#topic+names">names</a></code></p>
</td></tr>
<tr><td><code id="hist_+3A_...">...</code></td>
<td>
<p>additional arguments. See <code><a href="graphics.html#topic+hist">hist</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>This function is principally used for plotting a histogram, but it also returns an object of class &quot;histogram&quot; (invisibly if <code>plot=TRUE</code>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+pairs">pairs</a>, <a href="#topic+boxplot">boxplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r1 &lt;- r2 &lt;- rast(nrows=50, ncols=50)
values(r1) &lt;- runif(ncell(r1))
values(r2) &lt;- runif(ncell(r1))
rs &lt;- r1 + r2
rp &lt;- r1 * r2

opar &lt;- par(no.readonly =TRUE)
par(mfrow=c(2,2))
plot(rs, main='sum')
plot(rp, main='product')
hist(rs)
a &lt;- hist(rp)
a
x &lt;- c(rs, rp, sqrt(rs))
hist(x)
par(opar)
</code></pre>

<hr>
<h2 id='identical'>Compare two SpatRasters for equality</h2><span id='topic+identical'></span><span id='topic+identical+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compare two SpatRasters for equality. 
</p>
<p>First the attributes of the objects are compared. If these are the same, a the raster cells are compared as well. This can be time consuming, and you may prefer to use a sample instead with <code><a href="#topic+all.equal">all.equal</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
identical(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identical_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="identical_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single logical value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+all.equal">all.equal</a></code>, <code><a href="#topic+compareGeom">compareGeom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sqrt(1:100)
mat &lt;- matrix(x, 10, 10)
r1 &lt;- rast(nrows=10, ncols=10, xmin=0, vals = x)
r2 &lt;- rast(nrows=10, ncols=10, xmin=0, vals = t(mat))

identical(r1, r2)
identical(r1, r1*1)
identical(rast(r1), rast(r2))
</code></pre>

<hr>
<h2 id='ifel'>ifelse for SpatRasters</h2><span id='topic+ifel'></span><span id='topic+ifel+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Implementation of <code><a href="base.html#topic+ifelse">ifelse</a></code> for SpatRasters. This method allows for a concise expression of what can otherwise be achieved with a combination of <code><a href="#topic+classify">classify</a></code>, <code><a href="#topic+mask">mask</a></code>, and <code><a href="#topic+cover">cover</a></code>. 
</p>
<p><code>ifel</code> is an <code>R</code> equivalent to the <code>Con</code> method in ArcGIS (arcpy). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
ifel(test, yes, no, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifel_+3A_test">test</code></td>
<td>
<p>SpatRaster with logical (TRUE/FALSE) values</p>
</td></tr>
<tr><td><code id="ifel_+3A_yes">yes</code></td>
<td>
<p>SpatRaster or numeric</p>
</td></tr>
<tr><td><code id="ifel_+3A_no">no</code></td>
<td>
<p>SpatRaster or numeric</p>
</td></tr>
<tr><td><code id="ifel_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="ifel_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=5, ncols=5, xmin=0, xmax=1, ymin=0, ymax=1)
values(r) &lt;- c(-10:0, NA, NA, NA, 0:10)

x &lt;- ifel(r &gt; 1, 1, r)
# same as 
a &lt;- classify(r, cbind(1, Inf, 1))
# or
b &lt;- app(r, fun=function(i) {i[i &gt; 1] &lt;- 1; i})
# or 
d &lt;- clamp(r, -Inf, 1)
# or (not recommended for large datasets)
e &lt;- r
e[e&gt;1] &lt;- 1

## other examples
f &lt;- ifel(is.na(r), 100, r)

z &lt;- ifel(r &gt; -2 &amp; r &lt; 2, 100, 0)

# nested expressions
y &lt;- ifel(r &gt; 1, 1, ifel(r &lt; -1, -1, r))

k &lt;- ifel(r &gt; 0, r+10, ifel(r &lt; 0, r-10, 3))
</code></pre>

<hr>
<h2 id='image'>SpatRaster image method</h2><span id='topic+image'></span><span id='topic+image+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Plot (make a map of) the values of a SpatRaster via <code><a href="graphics.html#topic+image">image</a></code>. See <code><a href="#topic+plot">plot</a></code> if you need more fancy options such as a legend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
image(x, y=1, maxcell=500000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="image_+3A_y">y</code></td>
<td>
<p>positive integer indicating the layer to be plotted, or a character indicating the name of the layer</p>
</td></tr>
<tr><td><code id="image_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot</p>
</td></tr>
<tr><td><code id="image_+3A_...">...</code></td>
<td>
<p>additional arguments as for <code>graphics::<a href="graphics.html#topic+image">image</a></code> </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
f &lt;- system.file("ex/elev.tif", package="terra") 
r &lt;- rast(f)
image(r)
image(r, col=rainbow(24))
</code></pre>

<hr>
<h2 id='impose'> 
Impose the geometry of a SpatRaster to those in a SpatRasterCollection.
</h2><span id='topic+impose'></span><span id='topic+impose+2CSpatRasterCollection-method'></span>

<h3>Description</h3>

<p>Warp the members of a SpatRasterCollection to match the geometry of a SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRasterCollection'
impose(x, y, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impose_+3A_x">x</code></td>
<td>
<p>SpatRasterCollection</p>
</td></tr>
<tr><td><code id="impose_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="impose_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="impose_+3A_...">...</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+resample">resample</a></code>
</p>

<hr>
<h2 id='initialize'>Initialize a SpatRaster with values</h2><span id='topic+init'></span><span id='topic+init+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Create a SpatRaster with values reflecting a cell property: 'x', 'y', 'col', 'row', 'cell' or 'chess'. Alternatively, a function can be used. In that case, cell values are initialized without reference to pre-existing values. E.g., initialize with a random number (<code>fun=<a href="stats.html#topic+runif">runif</a></code>). While there are more direct ways of achieving this for small objects (see examples) for which a vector with all values can be created in memory, the <code>init</code> function will also work for SpatRasters with many cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
init(x, fun, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="initialize_+3A_fun">fun</code></td>
<td>
<p>function to be applied. This must be a either single number, multiple numbers, a function, or one of a set of known character values. A function must take the number of cells as a single argument to return a vector of values with a length equal to the number of cells, such as <code>fun=runif</code>. Allowed character values are 'x', 'y', 'row', 'col', 'cell', and 'chess' to get the x or y coordinate, row, col or cell number or a chessboard pattern (alternating 0 and 1 values)</p>
</td></tr>
<tr><td><code id="initialize_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="initialize_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=5, xmin=0, xmax=10, ymin=0, ymax=5)
x &lt;- init(r, fun="cell")
y &lt;- init(r, fun=runif)

# initialize with a single value 
z &lt;- init(r, fun=8)
</code></pre>

<hr>
<h2 id='inplace'>Change values in-place</h2><span id='topic+set.ext'></span><span id='topic+set.ext+2CSpatRaster-method'></span><span id='topic+set.ext+2CSpatVector-method'></span><span id='topic+set.values'></span><span id='topic+set.values+2CSpatRaster-method'></span><span id='topic+set.RGB'></span><span id='topic+set.RGB+2CSpatRaster-method'></span><span id='topic+set.cats'></span><span id='topic+set.cats+2CSpatRaster-method'></span><span id='topic+set.names'></span><span id='topic+set.names+2CSpatRaster-method'></span><span id='topic+set.names+2CSpatRasterDataset-method'></span><span id='topic+set.names+2CSpatRasterCollection-method'></span><span id='topic+set.names+2CSpatVector-method'></span><span id='topic+set.names+2CSpatVectorCollection-method'></span><span id='topic+set.crs'></span><span id='topic+set.crs+2CSpatRaster-method'></span><span id='topic+set.crs+2CSpatVector-method'></span>

<h3>Description</h3>

<p>These &quot;in-place&quot; replacement methods assign new value to an object without making a copy. That is efficient, but if there is a copy of the object that you made by standard assignment (e.g. with <code>y &lt;- x</code>), that copy is also changed.
</p>
<p><code>set.names</code> is the in-place replacement version of <code><a href="#topic+names+3C-">names&lt;-</a></code>.
</p>
<p><code>set.ext</code> is the in-place replacement version of <code><a href="#topic+ext+3C-">ext&lt;-</a></code>
</p>
<p><code>set.values</code> is the in-place replacement version of <code><a href="#topic++5B+3C-">[&lt;-</a></code>.
</p>
<p><code>set.cats</code> is the in-place replacement version of <code><a href="#topic+categories">categories</a></code>
</p>
<p><code>set.crs</code> is the in-place replacement version of <code><a href="#topic+crs+3C-">crs&lt;-</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
set.names(x, value, index=1:nlyr(x), validate=FALSE)
## S4 method for signature 'SpatRasterDataset'
set.names(x, value, index=1:length(x), validate=FALSE)
## S4 method for signature 'SpatVector'
set.names(x, value, index=1:ncol(x), validate=FALSE)

## S4 method for signature 'SpatRaster'
set.ext(x, value)
## S4 method for signature 'SpatVector'
set.ext(x, value)

## S4 method for signature 'SpatRaster'
set.crs(x, value)
## S4 method for signature 'SpatVector'
set.crs(x, value)

## S4 method for signature 'SpatRaster'
set.values(x, cells, values, layer=0)

## S4 method for signature 'SpatRaster'
set.cats(x, layer=1, value, active=1)

## S4 method for signature 'SpatRaster'
set.RGB(x, value, type="rgb")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inplace_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="inplace_+3A_value">value</code></td>
<td>
<p>character for <code>set.names</code>. For <code>set.cats</code>: a data.frame with columns (value, category) or vector with category names. For <code>set.RGB</code> 3 or 4 numbers indicating the RGB(A) layers</p>
</td></tr>
<tr><td><code id="inplace_+3A_index">index</code></td>
<td>
<p>positive integer indicating layer(s) to assign a name to</p>
</td></tr>
<tr><td><code id="inplace_+3A_validate">validate</code></td>
<td>
<p>logical. Make names valid and/or unique?</p>
</td></tr>
<tr><td><code id="inplace_+3A_cells">cells</code></td>
<td>
<p>cell numbers or missing</p>
</td></tr>
<tr><td><code id="inplace_+3A_values">values</code></td>
<td>
<p>replacement values or missing to load all values into memory</p>
</td></tr>
<tr><td><code id="inplace_+3A_layer">layer</code></td>
<td>
<p>positive integer(s) indicating to which layer(s) to you want to assign these categories or to which you want to set these values. A number &lt; 1 indicates &quot;all layers&quot;</p>
</td></tr>
<tr><td><code id="inplace_+3A_active">active</code></td>
<td>
<p>positive integer indicating the active category (column number in <code>value</code>, but not counting the first column</p>
</td></tr>
<tr><td><code id="inplace_+3A_type">type</code></td>
<td>
<p>character. The color space. One of &quot;rgb&quot; &quot;hsv&quot;, &quot;hsi&quot; and &quot;hsl&quot;</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>logical (invisibly)</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(ncols=5, nrows=5, nlyrs=3)
x &lt;- s
names(s)
names(s) &lt;- c("a", "b", "c")
names(s)
names(x)

x &lt;- s
set.names(s, c("e", "f", "g"))
names(s)
names(x)

set.ext(x, c(0,180,0,90))

f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)

#values from file to memory
set.values(r)

# change values
set.values(r, 1:1000, 900)
</code></pre>

<hr>
<h2 id='inset'>Make an inset map</h2><span id='topic+inset'></span><span id='topic+inset+2CSpatVector-method'></span><span id='topic+inset+2CSpatRaster-method'></span><span id='topic+inext'></span><span id='topic+inext+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Make an inset map or scale the extent of a SpatVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
inset(x, e, loc="", scale=0.2, background="white", 
	perimeter=TRUE, box=NULL, pper, pbox, ...)

## S4 method for signature 'SpatRaster'
inset(x, e, loc="", scale=0.2, background="white", 
	perimeter=TRUE, box=NULL, pper, pbox, ...)

## S4 method for signature 'SpatVector'
inext(x, e, y=NULL, gap=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inset_+3A_x">x</code></td>
<td>
<p>SpatVector, SpatRaster</p>
</td></tr>
<tr><td><code id="inset_+3A_e">e</code></td>
<td>
<p>SpatExtent to set the size and location of the inset. Or missing</p>
</td></tr>
<tr><td><code id="inset_+3A_loc">loc</code></td>
<td>
<p>character. One of &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot;, &quot;center&quot;</p>
</td></tr>
<tr><td><code id="inset_+3A_scale">scale</code></td>
<td>
<p>numeric. The relative size of the inset, used when x is missing</p>
</td></tr>
<tr><td><code id="inset_+3A_background">background</code></td>
<td>
<p>color for the background of the inset. Use <code>NA</code> for no background color</p>
</td></tr>
<tr><td><code id="inset_+3A_perimeter">perimeter</code></td>
<td>
<p>logical. If <code>TRUE</code> a perimeter (border) is drawn around the inset</p>
</td></tr>
<tr><td><code id="inset_+3A_box">box</code></td>
<td>
<p>SpatExtent or missing, to draw a box on the inset, e.g. to show where the map is located in a larger area</p>
</td></tr>
<tr><td><code id="inset_+3A_pper">pper</code></td>
<td>
<p>list with graphical parameters (arguments) such as <code>col</code> and <code>lwd</code> for the perimeter line</p>
</td></tr>
<tr><td><code id="inset_+3A_pbox">pbox</code></td>
<td>
<p>list with graphical parameters (arguments) such as <code>col</code> and <code>lwd</code> for the box (line)</p>
</td></tr>
<tr><td><code id="inset_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot for the drawing of <code>x</code></p>
</td></tr>
<tr><td><code id="inset_+3A_y">y</code></td>
<td>
<p>SpatVector. If not NULL, <code>y</code> is scaled based with the parameters for <code>x</code>. This is useful, for example, when <code>x</code> represent boundaries, and <code>y</code> points within these boundaries</p>
</td></tr>
<tr><td><code id="inset_+3A_gap">gap</code></td>
<td>
<p>numeric to add space between the SpatVector and the SpatExtent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scaled and shifted SpatVector or SpatRaster (returned invisibly)</p>


<h3>See Also</h3>

<p><code><a href="#topic+sbar">sbar</a></code>, <code><a href="#topic+rescale">rescale</a></code>, <code><a href="#topic+shift">shift</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
x &lt;- v[v$NAME_2 == "Diekirch", ]

plot(x, density=10, col="blue")
inset(v)

# more elaborate
plot(x, density=10, col="blue")
inset(v, col = "brown", border="lightgrey", perimeter=TRUE, 
		pper=list(col="orange", lwd=3, lty=2), 
		box=ext(x), pbox=list(col="blue", lwd=2))

cols &lt;- rep("light grey", 12)
cols[2] &lt;- "red"
e &lt;- ext(c(6.2, 6.3, 49.9, 50))
b &lt;- ext(x)+0.02
inset(v, e=e, col=cols, box=b)

# with a SpatRaster
ff &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(ff)
r &lt;- crop(r, ext(x) + .01)
plot(r, type="int", mar=c(2,2,2,2), plg=list(x="topright"))
lines(v, lwd=1.5)
lines(x, lwd=2.5)
inset(v, col=cols, loc="topleft", scale=0.15)

# a more complex one
plot(r, plg=list(title="meter\n", shrink=.2, cex=.8))
lines(v, lwd=4, col="white")
lines(v, lwd=1.5)
lines(x, lwd=2.5)
text(x, "NAME_2", cex=1.5, halo=TRUE)
sbar(6, c(6.04, 49.785), type="bar", below="km", label=c(0,3,6), cex=.8)
s &lt;- inset(v, col=cols, box=b, scale=.2, loc="topright", background="light yellow",
	pbox=list(lwd=2, lty=5, col="blue"))

# note the returned inset SpatVector
s
lines(s, col="orange")
</code></pre>

<hr>
<h2 id='interpIDW'>Interpolate points using a moving window</h2><span id='topic+interpIDW'></span><span id='topic+interpIDW+2CSpatRaster+2CSpatVector-method'></span><span id='topic+interpIDW+2CSpatRaster+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Interpolate points within a moving window using inverse distance weighting. The maximum number of points used can be restricted, optionally by selecting the nearest points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatVector'
interpIDW(x, y, field, radius, power=2, smooth=0,
       maxPoints=Inf, minPoints=1, near=TRUE, fill=NA, filename="", ...)

## S4 method for signature 'SpatRaster,matrix'
interpIDW(x, y, radius, power=2, smooth=0, 
       maxPoints=Inf, minPoints=1, near=TRUE, fill=NA, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpIDW_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_y">y</code></td>
<td>
<p>SpatVector or matrix with three columns (x,y,z)</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_field">field</code></td>
<td>
<p>character. field name in SpatVector <code>y</code></p>
</td></tr>
<tr><td><code id="interpIDW_+3A_radius">radius</code></td>
<td>
<p>numeric. The radius of the circle (single number). If <code>near=FALSE</code>, it is also possible to use two or three numbers. Two numbers are interpreted as the radii of an ellipse (x and y-axis). A third number should indicated the desired, counter clockwise, rotation of the ellipse (in degrees)</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_power">power</code></td>
<td>
<p>numeric. Weighting power</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_smooth">smooth</code></td>
<td>
<p>numeric. Smoothing parameter</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_minpoints">minPoints</code></td>
<td>
<p>numeric. The minimum number of points to use. If fewer points are found in a search ellipse it is considered empty and the fill value is returned</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_maxpoints">maxPoints</code></td>
<td>
<p>numeric. The maximum number of points to consider in a search area. Additional points are ignored. If fewer points are found, the fill value is returned</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_near">near</code></td>
<td>
<p>logical. Should the nearest points within the neighborhood be used if <code>maxPoints</code> is reached?</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_fill">fill</code></td>
<td>
<p>numeric. value to use to fill empty cells</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="interpIDW_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasterizeWin">rasterizeWin</a>, <a href="#topic+rasterize">rasterize</a>, <a href="#topic+interpNear">interpNear</a>, <a href="#topic+interpolate">interpolate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- rast(ncol=100, nrow=100, crs="local", xmin=0, xmax=50, ymin=0, ymax=50)
set.seed(100)
x &lt;- runif(25, 5, 45)
y &lt;- runif(25, 5, 45)
z &lt;- sample(25)
xyz &lt;- cbind(x,y,z)

x &lt;- interpIDW(r, xyz, radius=5, power=1, smooth=1, maxPoints=5)

</code></pre>

<hr>
<h2 id='interpNear'>Nearest neighbor interpolation</h2><span id='topic+interpNear'></span><span id='topic+interpNear+2CSpatRaster+2CSpatVector-method'></span><span id='topic+interpNear+2CSpatRaster+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Nearest neighbor interpolation of points, using a moving window
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatVector'
interpNear(x, y, field, radius, interpolate=FALSE, fill=NA, filename="", ...)

## S4 method for signature 'SpatRaster,matrix'
interpNear(x, y, radius, interpolate=FALSE, fill=NA, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpNear_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="interpNear_+3A_y">y</code></td>
<td>
<p>SpatVector or matrix with three columns (x,y,z)</p>
</td></tr>
<tr><td><code id="interpNear_+3A_field">field</code></td>
<td>
<p>character. field name in SpatVector <code>y</code></p>
</td></tr>
<tr><td><code id="interpNear_+3A_radius">radius</code></td>
<td>
<p>numeric. The radius of the circle (single number). If <code>interpolate=FALSE</code> it is also possible to use two or three numbers. Two numbers are interpreted as the radii of an ellipse (x and y-axis). A third number should indicated the desired, counter clockwise, rotation of the ellipse (in degrees)</p>
</td></tr>  
<tr><td><code id="interpNear_+3A_interpolate">interpolate</code></td>
<td>
<p>logical. Should the nearest neighbor values be linearly interpolated between points?</p>
</td></tr>
<tr><td><code id="interpNear_+3A_fill">fill</code></td>
<td>
<p>numeric. value to use to fill empty cells</p>
</td></tr>
<tr><td><code id="interpNear_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="interpNear_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasterizeWin">rasterizeWin</a>, <a href="#topic+rasterize">rasterize</a>, <a href="#topic+interpIDW">interpIDW</a>, <a href="#topic+interpolate">interpolate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- rast(ncol=100, nrow=100, crs="local", xmin=0, xmax=50, ymin=0, ymax=50)
set.seed(100)
x &lt;- runif(25, 5, 45)
y &lt;- runif(25, 5, 45)
z &lt;- sample(25)
xyz &lt;- cbind(x,y,z)

x &lt;- interpNear(r, xyz, radius=5)

p &lt;- vect(data.frame(xyz), geom=c("x", "y")) 
v &lt;- voronoi(p)

plot(x, col=rainbow(25))
lines(v)

# plot(v, col=rainbow(25)); points(p)
</code></pre>

<hr>
<h2 id='interpolation'>Spatial interpolation</h2><span id='topic+interpolate'></span><span id='topic+interpolate+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Make a SpatRaster with interpolated values using a fitted model object of classes such as &quot;gstat&quot; (gstat package) or &quot;Krige&quot; (fields package), or any other model that has location (e.g., &quot;x&quot; and &quot;y&quot;, or &quot;longitude&quot; and &quot;latitude&quot;) as predictors (independent variables). If x and y are the only predictors, it is most efficient if you provide an empty (no associated data in memory or on file) SpatRaster for which you want predictions. If there are more spatial predictor variables provide these as a SpatRaster in the first argument of the function. If you do not have x and y locations as implicit predictors in your model you should use <code><a href="#topic+predict">predict</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
interpolate(object, model, fun=predict, ..., xyNames=c("x", "y"), 
       factors=NULL, const=NULL, index = NULL, cores=1, cpkgs=NULL, 
	   na.rm=FALSE, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolation_+3A_object">object</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="interpolation_+3A_model">model</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="interpolation_+3A_fun">fun</code></td>
<td>
<p>function. Default value is &quot;predict&quot;, but can be replaced with e.g. &quot;predict.se&quot; (depending on the class of <code>model</code>), or a custom function (see examples)</p>
</td></tr>
<tr><td><code id="interpolation_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fun</code></p>
</td></tr>
<tr><td><code id="interpolation_+3A_xynames">xyNames</code></td>
<td>
<p>character. variable names that the model uses for the spatial coordinates. E.g., <code>c("longitude", "latitude")</code></p>
</td></tr>
<tr><td><code id="interpolation_+3A_factors">factors</code></td>
<td>
<p>list with levels for factor variables. The list elements should be named with names that correspond to names in <code>object</code> such that they can be matched. This argument may be omitted for some models from which the levels can be extracted from the <code>model</code> object</p>
</td></tr>
<tr><td><code id="interpolation_+3A_const">const</code></td>
<td>
<p>data.frame. Can be used to add a constant for which there is no SpatRaster for model predictions. This is particularly useful if the constant is a character-like factor value</p>
</td></tr>
<tr><td><code id="interpolation_+3A_index">index</code></td>
<td>
<p>positive integer or NULL. Allows for selecting of the variable returned if the model returns multiple variables</p>
</td></tr>
<tr><td><code id="interpolation_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used</p>
</td></tr>
<tr><td><code id="interpolation_+3A_cpkgs">cpkgs</code></td>
<td>
<p>character. The package(s) that need to be loaded on the nodes to be able to run the model.predict function (see examples in <code><a href="#topic+predict">predict</a></code>)</p>
</td></tr>  
<tr><td><code id="interpolation_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells with <code>NA</code> values in the predictors are removed from the computation. This option prevents errors with models that cannot handle <code>NA</code> values. In most other cases this will not affect the output. An exception is when predicting with a model that returns predicted values even if some (or all!) variables are <code>NA</code> </p>
</td></tr>
<tr><td><code id="interpolation_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="interpolation_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="interpolation_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+predict">predict</a></code>, <code>link{interpIDW}</code>, <code>link{interpNear}</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
ra &lt;- aggregate(r, 10)
xy &lt;- data.frame(xyFromCell(ra, 1:ncell(ra)))
v &lt;- values(ra)
i &lt;- !is.na(v)
xy &lt;- xy[i,]
v &lt;- v[i]

## Not run: 
library(fields) 
tps &lt;- Tps(xy, v)
p &lt;- rast(r)

# use model to predict values at all locations
p &lt;- interpolate(p, tps)
p &lt;- mask(p, r)
plot(p)

### change "fun" from predict to fields::predictSE to get the TPS standard error
## need to use "rast(p)" to remove the values
se &lt;- interpolate(rast(p), tps, fun=predictSE)
se &lt;- mask(se, r)
plot(se)

### another predictor variable, "e"
e &lt;- (init(r, "x") * init(r, "y")) / 100000000
names(e) &lt;- "e"

z &lt;- as.matrix(extract(e, xy)[,-1])

## add as another independent variable
xyz &lt;- cbind(xy, z)
tps2 &lt;- Tps(xyz, v)
p2 &lt;- interpolate(e, tps2, xyOnly=FALSE)

## as a linear coveriate
tps3 &lt;- Tps(xy, v, Z=z)

## Z is a separate argument in Krig.predict, so we need a new function
## Internally (in interpolate) a matrix is formed of x, y, and elev (Z)

pfun &lt;- function(model, x, ...) {
   predict(model, x[,1:2], Z=x[,3], ...)
}
p3 &lt;- interpolate(e, tps3, fun=pfun)


#### gstat examples
library(gstat)
library(sp)
data(meuse)

### inverse distance weighted (IDW)
r &lt;- rast(system.file("ex/meuse.tif", package="terra"))
mg &lt;- gstat(id = "zinc", formula = zinc~1, locations = ~x+y, data=meuse, 
            nmax=7, set=list(idp = .5))
z &lt;- interpolate(r, mg, debug.level=0, index=1)
z &lt;- mask(z, r)

## with a model built with an `sf` object you need to provide custom function

library(sf)
sfmeuse &lt;- st_as_sf(meuse, coords = c("x", "y"), crs=crs(r))
mgsf &lt;- gstat(id = "zinc", formula = zinc~1, data=sfmeuse,  nmax=7, set=list(idp = .5))

interpolate_gstat &lt;- function(model, x, crs, ...) {
	v &lt;- st_as_sf(x, coords=c("x", "y"), crs=crs)
	p &lt;- predict(model, v, ...)
	as.data.frame(p)[,1:2]
}

zsf &lt;- interpolate(r, mgsf, debug.level=0, fun=interpolate_gstat, crs=crs(r), index=1)
zsf &lt;- mask(zsf, r)

### kriging

### ordinary kriging
v &lt;- variogram(log(zinc)~1, ~x+y, data=meuse)
mv &lt;- fit.variogram(v, vgm(1, "Sph", 300, 1))
gOK &lt;- gstat(NULL, "log.zinc", log(zinc)~1, meuse, locations=~x+y, model=mv)
OK &lt;- interpolate(r, gOK, debug.level=0)

## universal kriging
vu &lt;- variogram(log(zinc)~elev, ~x+y, data=meuse)
mu &lt;- fit.variogram(vu, vgm(1, "Sph", 300, 1))
gUK &lt;- gstat(NULL, "log.zinc", log(zinc)~elev, meuse, locations=~x+y, model=mu)
names(r) &lt;- "elev"
UK &lt;- interpolate(r, gUK, debug.level=0)

## co-kriging
gCoK &lt;- gstat(NULL, 'log.zinc', log(zinc)~1, meuse, locations=~x+y)
gCoK &lt;- gstat(gCoK, 'elev', elev~1, meuse, locations=~x+y)
gCoK &lt;- gstat(gCoK, 'cadmium', cadmium~1, meuse, locations=~x+y)
gCoK &lt;- gstat(gCoK, 'copper', copper~1, meuse, locations=~x+y)
coV &lt;- variogram(gCoK)
plot(coV, type='b', main='Co-variogram')
coV.fit &lt;- fit.lmc(coV, gCoK, vgm(model='Sph', range=1000))
coV.fit
plot(coV, coV.fit, main='Fitted Co-variogram')
coK &lt;- interpolate(r, coV.fit, debug.level=0)
plot(coK)

## End(Not run)
</code></pre>

<hr>
<h2 id='intersect'> 
Intersection
</h2><span id='topic+intersect'></span><span id='topic+intersect+2CSpatVector+2CSpatVector-method'></span><span id='topic+intersect+2CSpatVector+2CSpatExtent-method'></span><span id='topic+intersect+2CSpatExtent+2CSpatVector-method'></span><span id='topic+intersect+2CSpatExtent+2CSpatExtent-method'></span><span id='topic+intersect+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+intersect+2CSpatRaster+2CSpatExtent-method'></span><span id='topic+intersect+2CSpatExtent+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>You can intersect SpatVectors with each other or with a SpatExtent. Intersecting points with points uses the extent of <code>y</code> to get the intersection. Intersecting of points and lines is not supported because of numerical inaccuracies with that. You can use <code><a href="#topic+buffer">buffer</a></code>, to create polygons from lines and use these with intersect. 
</p>
<p>You can also intersect two SpatExtents.
</p>
<p>When intersecting two SpatRasters these need to be aligned (have the same origin and spatial resolution). The values of the returned SpatRaster are <code>TRUE</code> where both input rasters have values, <code>FALSE</code> where one has values, and <code>NA</code> in all other cells. 
</p>
<p>When intersecting a SpatExtent and a SpatRaster, the SpatExtent is first aligned to the raster cell boundaries.
</p>
<p>See <code><a href="#topic+crop">crop</a></code> for the intersection of a SpatRaster with a SpatExtent (or the extent of a SpatRaster or SpatVector) if you want a SpatRaster (not a SpatExtent) as output.
</p>
<p>See <code><a href="#topic+is.related">is.related</a>(x, y, "intersects")</code> to find out which geometries of a SpatVector intersect. You can spatially subset a SpatVector with another one with <code>x<a href="#topic++5B">[</a>y]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatVector'
intersect(x, y)

## S4 method for signature 'SpatVector,SpatExtent'
intersect(x, y)

## S4 method for signature 'SpatExtent,SpatVector'
intersect(x, y)

## S4 method for signature 'SpatExtent,SpatExtent'
intersect(x, y)

## S4 method for signature 'SpatRaster,SpatRaster'
intersect(x, y)

## S4 method for signature 'SpatRaster,SpatExtent'
intersect(x, y)

## S4 method for signature 'SpatExtent,SpatRaster'
intersect(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersect_+3A_x">x</code></td>
<td>
<p>SpatVector, SpatExtent, or SpatRaster</p>
</td></tr>
<tr><td><code id="intersect_+3A_y">y</code></td>
<td>
<p>SpatVector, SpatExtent, or SpatRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+union">union</a></code>, <code><a href="#topic+crop">crop</a></code>, <code><a href="#topic+relate">relate</a></code>, <code><a href="#topic++5B">[</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- ext(-10, 10, -20, 20)
e2 &lt;- ext(0, 20, -40, 5)
intersect(e1, e2)

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
e &lt;- ext(5.6, 6, 49.55, 49.7)
x &lt;- intersect(v, e)

p &lt;- vect(c("POLYGON ((5.8 49.8, 6 49.9, 6.15 49.8, 6 49.6, 5.8 49.8))", 
"POLYGON ((6.3 49.9, 6.2 49.7, 6.3 49.6, 6.5 49.8, 6.3 49.9))"), crs=crs(v))
values(p) &lt;- data.frame(pid=1:2, area=expanse(p))

y &lt;- intersect(v, p)

r &lt;- s &lt;- rast(ncol=5, nrow=5, xmin=1, xmax=5, ymin=1, ymax=5)
r[5:20] &lt;- 5:20
s[11:20] &lt;- 11:20
rs &lt;- intersect(r, s)

u &lt;- shift(r, .8)
us &lt;- intersect(u, s)
</code></pre>

<hr>
<h2 id='is.bool'>Raster value types</h2><span id='topic+is.bool'></span><span id='topic+is.bool+2CSpatRaster-method'></span><span id='topic+as.bool'></span><span id='topic+as.bool+2CSpatRaster-method'></span><span id='topic+isTRUE+2CSpatRaster-method'></span><span id='topic+isFALSE+2CSpatRaster-method'></span><span id='topic+as.logical+2CSpatRaster-method'></span><span id='topic+is.int'></span><span id='topic+is.int+2CSpatRaster-method'></span><span id='topic+as.int'></span><span id='topic+as.int+2CSpatRaster-method'></span><span id='topic+as.integer+2CSpatRaster-method'></span><span id='topic+is.factor'></span><span id='topic+is.factor+2CSpatRaster-method'></span><span id='topic+as.factor'></span><span id='topic+as.factor+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>The values in a SpatRaster layer are by default numeric, but they can also be set to be logical (Boolean), integer, or categorical (factor). 
</p>
<p>For a <code>SpatRaster</code>, <code>as.logical</code> and <code>isTRUE</code> is equivalent to <code>as.bool</code>. <code>isFALSE</code> is equivalent to <code>!as.bool</code>, and <code>as.integer</code> is the same as <code>as.int</code>.
</p>
<p><code>as.bool</code> and <code>as.int</code> force the values into the correct range (e.g. whole integers) but in-memory cell values are still stored as numeric. They will behave like the assigned types, though, and will be written to files with that data type (if the file type supports it). 
</p>
<p>See <code><a href="#topic+levels">levels</a></code> and <code><a href="#topic+cats">cats</a></code> to create categorical layers by setting labels. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
is.bool(x)

## S4 method for signature 'SpatRaster'
as.bool(x, filename, ...)

## S4 method for signature 'SpatRaster'
is.int(x)

## S4 method for signature 'SpatRaster'
as.int(x, filename, ...)

## S4 method for signature 'SpatRaster'
is.factor(x)

## S4 method for signature 'SpatRaster'
as.factor(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.bool_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="is.bool_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="is.bool_+3A_...">...</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>as.*</code> methods return a new <code>SpatRaster</code>, whereas the <code>is.*</code> methods return a <code>logical</code> value for each layer in <code>x</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+levels">levels</a></code> and <code><a href="#topic+cats">cats</a></code> to create categorical layers (and set labels). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=10, ncols=10, vals=1:100)
is.bool(r)
z &lt;- as.bool(r)
is.bool(z)

x &lt;- r &gt; 25
is.bool(x)

rr &lt;- r/2
is.int(rr)
is.int(round(rr))
</code></pre>

<hr>
<h2 id='is.empty'>Check if a SpatExtent or SpatVector is empty</h2><span id='topic+is.empty'></span><span id='topic+is.empty+2CSpatVector-method'></span><span id='topic+is.empty+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>An empty SpatExtent has no area
</p>
<p>An empty SpatVector has no geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatExtent'
is.empty(x)

## S4 method for signature 'SpatVector'
is.empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.empty_+3A_x">x</code></td>
<td>
<p>SpatVector or SpatExtent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- ext(0,0,0,0)
is.valid(e)
is.empty(e)

v &lt;- vect()
is.valid(v)
is.empty(v)
</code></pre>

<hr>
<h2 id='is.lonlat'>Check for longitude/latitude crs</h2><span id='topic+is.lonlat'></span><span id='topic+is.lonlat+2CSpatRaster-method'></span><span id='topic+is.lonlat+2CSpatVector-method'></span><span id='topic+is.lonlat+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Test whether a SpatRaster or SpatVector has a longitude/latitude coordinate reference system (CRS), or perhaps has one. That is, when the CRS is unknown (<code>""</code>) but the x coordinates are within -181 and 181 and the y coordinates are within -90.1 and 90.1. For a SpatRaster you can also test if it has a longitude/latitude CRS and it is &quot;global&quot; (covers all longitudes).
</p>
<p>A warning is given if the CRS is missing or if it is specified as longitude/latitude but the coordinates do not match that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
is.lonlat(x, perhaps=FALSE, warn=TRUE, global=FALSE)

## S4 method for signature 'SpatVector'
is.lonlat(x, perhaps=FALSE, warn=TRUE)

## S4 method for signature 'character'
is.lonlat(x, perhaps=FALSE, warn=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.lonlat_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="is.lonlat_+3A_perhaps">perhaps</code></td>
<td>
<p>logical. If <code>TRUE</code> and the CRS is unknown, the method returns <code>TRUE</code> if the coordinates are plausible for longitude/latitude</p>
</td></tr>
<tr><td><code id="is.lonlat_+3A_warn">warn</code></td>
<td>
<p>logical. If <code>TRUE</code>, a warning is given if the CRS is unknown but assumed to be lon/lat and  <code>perhaps=TRUE</code></p>
</td></tr>
<tr><td><code id="is.lonlat_+3A_global">global</code></td>
<td>
<p>logical. If <code>TRUE</code>, the method tests if the raster covers all longitudes (from -180 to 180 degrees) such that the extreme columns are in fact adjacent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical or NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
is.lonlat(r)
is.lonlat(r, global=TRUE)

crs(r) &lt;- ""
is.lonlat(r)
is.lonlat(r, perhaps=TRUE, warn=FALSE)

crs(r) &lt;- "+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +ellps=WGS84"
is.lonlat(r)
</code></pre>

<hr>
<h2 id='is.rotated'>Check for rotation</h2><span id='topic+is.rotated'></span><span id='topic+is.rotated+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Check if a SpatRaster is &quot;rotated&quot; and needs to be rectified before it can be used 
</p>
<p>See <code><a href="#topic+rectify">rectify</a></code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
is.rotated(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rotated_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical. One value for each raster data *source*
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rectify">rectify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=10, ncols=10, vals=1:100)
is.rotated(r)
</code></pre>

<hr>
<h2 id='is.valid'>Check or fix polygon or extent validity</h2><span id='topic+is.valid'></span><span id='topic+is.valid+2CSpatVector-method'></span><span id='topic+is.valid+2CSpatExtent-method'></span><span id='topic+makeValid'></span><span id='topic+makeValid+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Check the validity of polygons or attempt to fix it. Or check the validity of a SpatExtent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
is.valid(x, messages=FALSE, as.points=FALSE)

## S4 method for signature 'SpatVector'
makeValid(x)

## S4 method for signature 'SpatExtent'
is.valid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.valid_+3A_x">x</code></td>
<td>
<p>SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="is.valid_+3A_messages">messages</code></td>
<td>
<p>logical. If <code>TRUE</code> the error messages are returned</p>
</td></tr>
<tr><td><code id="is.valid_+3A_as.points">as.points</code></td>
<td>
<p>logical. If <code>TRUE</code>, it is attempted to return locations where polygons are invalid as a SpatVector or points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topology">topology</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- vect("POLYGON ((0 -5, 10 0, 10 -10, 0 -5))")
is.valid(w)

w &lt;- vect("POLYGON ((0 -5, 10 0, 10 -10, 4 -2, 0 -5))")
is.valid(w)
is.valid(w, TRUE)

plot(w)
points(cbind(4.54, -2.72), cex=2, col="red")


e &lt;- ext(0, 1, 0, 1)
is.valid(e)

ee &lt;- ext(0, 0, 0, 0)
is.valid(ee)

</code></pre>

<hr>
<h2 id='k_means'>k_means</h2><span id='topic+k_means'></span><span id='topic+k_means+2CANY-method'></span><span id='topic+k_means+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute k-means clusters for a SpatRaster. For large SpatRasters (with <code>ncell(x) &gt; maxcell</code>) this is done in two steps. First a sample of the cells is used to compute the cluster centers. Then each cell is assigned to a cluster by computing the distance to these centers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
k_means(x, centers=3, ..., maxcell=1000000, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k_means_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="k_means_+3A_centers">centers</code></td>
<td>
<p>either the number of clusters, or a set of initial (distinct) cluster centres. If a number, a random set of (distinct) cells in <code>x</code> is chosen as the initial centres</p>
</td></tr>   
<tr><td><code id="k_means_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+kmeans">kmeans</a></code></p>
</td></tr> 
<tr><td><code id="k_means_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. The size of the regular sample used if it is smaller than <code>ncell(x)</code></p>
</td></tr>
<tr><td><code id="k_means_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (ignored if <code>as.raster=FALSE</code>)</p>
</td></tr>
<tr><td><code id="k_means_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="k_means_+3A_wopt">wopt</code></td>
<td>
<p>list with additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+kmeans">kmeans</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/logo.tif", package = "terra")
r &lt;- rast(f)
km &lt;- k_means(r, centers=5)
km
</code></pre>

<hr>
<h2 id='lapp'>Apply a function to layers of a SpatRaster, or sub-datasets of a SpatRasterDataset</h2><span id='topic+lapp'></span><span id='topic+lapp+2CSpatRaster-method'></span><span id='topic+lapp+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

<p>Apply a function to a SpatRaster, using layers as arguments.
</p>
<p>The number of arguments in function <code>fun</code> must match the number of layers in the SpatRaster (or the number of sub-datasets in the SpatRasterDataset). For example, if you want to multiply two layers, you could use this function: <code>fun=function(x,y){return(x*y)}</code> percentage: <code>fun=function(x,y){return(100 * x / y)}</code>. If you combine three layers you could use <code>fun=function(x,y,z){return((x + y) * z)}</code>
</p>
<p>Before you use the function, test it to make sure that it is vectorized. That is, it should work for vectors longer than one, not only for single numbers. Or if the input SpatRaster(s) have multiple layers, it should work for a matrix (multiple cells) of input data (or matrices in the case of a SpatRasterDataSet). The function must return the same number of elements as its input vectors, or multiples of that. Also make sure that the function is <code>NA</code>-proof: it should returns the same number of values when some or all input values are <code>NA</code>. And the function must return a vector or a matrix, not a <code>data.frame</code>. To test it, run it with <code>do.call(fun, data)</code> (see examples). 
</p>
<p>Use <code><a href="#topic+app">app</a></code> for summarize functions such as <code>sum</code>, that take any number of arguments; and <code><a href="#topic+tapp">tapp</a></code> to do so for groups of layers. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
lapp(x, fun, ..., usenames=FALSE, cores=1, filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'SpatRasterDataset'
lapp(x, fun, ..., usenames=FALSE, recycle=FALSE, 
    filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapp_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatRasterDataset</p>
</td></tr>
<tr><td><code id="lapp_+3A_fun">fun</code></td>
<td>
<p>a function that takes a vector and can be applied to each cell of <code>x</code></p>
</td></tr>
<tr><td><code id="lapp_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>fun</code></p>
</td></tr> 
<tr><td><code id="lapp_+3A_usenames">usenames</code></td>
<td>
<p>logical. Use the layer names (or dataset names if <code>x</code> is a SpatRasterDataset) to match the function arguments? If <code>FALSE</code>, argument matching is by position</p>
</td></tr>
<tr><td><code id="lapp_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object</p>
</td></tr>
<tr><td><code id="lapp_+3A_recycle">recycle</code></td>
<td>
<p>logical. Recycle layers to match the subdataset with the largest number of layers</p>
</td></tr>
<tr><td><code id="lapp_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="lapp_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="lapp_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Note</h3>

<p>Use <code><a href="#topic+sapp">sapp</a></code> or <code>lapply</code> to apply a function that takes a SpatRaster as argument to each layer of a SpatRaster (that is rarely necessary).
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+app">app</a>, <a href="#topic+tapp">tapp</a>,  <a href="#topic+math">math</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra")) + 1  
ss &lt;- s[[2:1]]

fvi &lt;- function(x, y){ (x - y ) / (x + y) } 
# test the function
data &lt;- list(c(1:5,NA), 6:1)
do.call(fvi, data)

x &lt;- lapp(ss, fun=fvi )

# which is the same as supplying the layers to "fun"
# in some cases this will be much faster 
y &lt;- fvi(s[[2]], s[[1]])

f2 &lt;- function(x, y, z){ (z - y + 1) / (x + y + 1) } 
p1 &lt;- lapp(s, fun=f2 )

p2 &lt;- lapp(s[[1:2]], f2, z=200)

# the usenames argument

fvi2 &lt;- function(red, green){ (red - green ) / (red + green) } 
names(s)
x1 &lt;- lapp(s[[1:2]], fvi2, usenames=TRUE)
x2 &lt;- lapp(s[[2:1]], fvi2, usenames=TRUE)
# x1 and x2 are the same, despite the change in the order of the layers
# x4 is also the same, but x3 is not
x3 &lt;- lapp(s[[2:1]], fvi2, usenames=FALSE)
x4 &lt;- lapp(s, fvi2, usenames=TRUE)

# while this would fail because 
# there are too many layers in s
# x5 &lt;- lapp(s, fvi2, usenames=FALSE)

pairs(c(x1, x2, x3, x4))

## SpatRasterDataset
x &lt;- sds(s, s[[1]]+50)
fun &lt;- function(x, y) { x/y }

# test "fun"
data &lt;- list(matrix(1:9, ncol=3), matrix(9:1, ncol=3))
do.call(fun, data)

lapp(x, fun, recycle=TRUE)

# the same, more concisely
z &lt;- s / (s[[1]]+50)
</code></pre>

<hr>
<h2 id='layerCor'>Correlation and (weighted) covariance</h2><span id='topic+layerCor'></span><span id='topic+layerCor+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute correlation, (weighted) covariance, or similar summary statistics that compare the values of all pairs of the layers of a SpatRaster. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
layerCor(x, fun, w, asSample=TRUE, use="everything", maxcell=Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layerCor_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="layerCor_+3A_fun">fun</code></td>
<td>
<p>character. The statistic to compute: either &quot;cov&quot; (covariance), &quot;weighted.cov&quot; (weighted covariance), or &quot;cor&quot; (pearson correlation coefficient) or your own function that takes two vectors as argument to compute a single number</p>
</td></tr>
<tr><td><code id="layerCor_+3A_w">w</code></td>
<td>
<p>SpatRaster with the weights  to compute the weighted covariance. It should have a single layer and the same geometry as <code>x</code></p>
</td></tr>
<tr><td><code id="layerCor_+3A_assample">asSample</code></td>
<td>
<p>logical. If <code>TRUE</code>, the statistic for a sample (denominator is <code>n-1</code>) is computed, rather than for the population (denominator is <code>n</code>). Only for the standard functions</p>
</td></tr>
<tr><td><code id="layerCor_+3A_use">use</code></td>
<td>
<p>character. To decide how to handle missing values. This must be (an abbreviation of) one of &quot;everything&quot;, &quot;complete.obs&quot;, &quot;pairwise.complete.obs&quot;, &quot;masked.complete&quot;. With &quot;pairwise.complete.obs&quot;, the value for a pair of layers is computed for all cells that are not <code>NA</code> in that pair. Therefore, it may be that the (number of) cells used varies between pairs. The benefit of this approach is that all available data is used. Use &quot;complete.obs&quot;, if you want to only use the values from cells that are not <code>NA</code> in any of the layers. By using &quot;masked.complete&quot; you indicate that all layers have NA values in the same cells</p>
</td></tr>
<tr><td><code id="layerCor_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. The maximum number of cells to be used. If this is smaller than ncell(x), a regular sample of <code>x</code> is used</p>
</td></tr>
<tr><td><code id="layerCor_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code> (if it is a proper function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>fun</code> is one of the three standard statistics, you get a list with three items: the 
correlation or (weighted) covariance matrix, the (weighted) means, and the number of data cells in 
each comparison. The means are also a matrix because they may depend on the combination of layers 
if different cells have missing values and these are excluded from the computation. The rows of 
the mean matrix represent the layer whose (weighted) mean is being calculated and the columns 
represent the layer it is being paired with. Only cells with non-missing observations for both 
layers are used in the calculation of the (weighted) mean. The diagonals of the mean and n 
matrices are set to missing.
</p>
<p>If <code>fun</code> is a function, you get a single matrix.
</p>


<h3>References</h3>

<p>For the weighted covariance:
</p>

<ul>
<li> <p>Canty, M.J. and A.A. Nielsen, 2008. Automatic radiometric normalization of multitemporal satellite imagery with the iteratively re-weighted MAD transformation. Remote Sensing of Environment 112:1025-1036.
</p>
</li>
<li> <p>Nielsen, A.A., 2007. The regularized iteratively reweighted MAD method for change detection in multi- and hyperspectral data. IEEE Transactions on Image Processing 16(2):463-478. 
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+global">global</a></code>, <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>, <code><a href="#topic+weighted.mean">weighted.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- rast(system.file("ex/logo.tif", package="terra"))   
layerCor(b, "pearson")

layerCor(b, "cov")

# weigh by column number
w &lt;- init(b, fun="col")
layerCor(b, "weighted.cov", w=w)
</code></pre>

<hr>
<h2 id='linearUnits'>Linear units of the coordinate reference system</h2><span id='topic+linearUnits'></span><span id='topic+linearUnits+2CSpatRaster-method'></span><span id='topic+linearUnits+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get the linear units of the coordinate reference system (crs) of a SpatRaster or SpatVector expressed in m. The value returned is used internally to transform area and perimeter measures to meters. The value returned for longitude/latitude crs is zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
linearUnits(x)

## S4 method for signature 'SpatVector'
linearUnits(x)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearUnits_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric (meter)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs">crs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rast()
crs(x) &lt;- ""
linearUnits(x)

crs(x) &lt;- "+proj=longlat +datum=WGS84"
linearUnits(x)

crs(x) &lt;- "+proj=utm +zone=1 +units=cm"
linearUnits(x)

crs(x) &lt;- "+proj=utm +zone=1 +units=km"
linearUnits(x)

crs(x) &lt;- "+proj=utm +zone=1 +units=us-ft"
linearUnits(x)
</code></pre>

<hr>
<h2 id='lines'>Add points, lines, or polygons to a map</h2><span id='topic+points'></span><span id='topic+lines'></span><span id='topic+polys'></span><span id='topic+lines+2CSpatVector-method'></span><span id='topic+lines+2CSpatRaster-method'></span><span id='topic+lines+2CSpatGraticule-method'></span><span id='topic+lines+2CSpatExtent-method'></span><span id='topic+lines+2Csf-method'></span><span id='topic+points+2CSpatVector-method'></span><span id='topic+points+2CSpatRaster-method'></span><span id='topic+points+2CSpatExtent-method'></span><span id='topic+points+2Csf-method'></span><span id='topic+polys+2CSpatVector-method'></span><span id='topic+polys+2CSpatRaster-method'></span><span id='topic+polys+2CSpatExtent-method'></span><span id='topic+polys+2Csf-method'></span>

<h3>Description</h3>

<p>Add a vector geometries to a plot (map) with <code>points</code>, <code>lines</code>, or <code>polys</code>. 
</p>
<p>These are simpler alternatives for <code><a href="#topic+plot">plot(x, add=TRUE)</a></code>
</p>
<p>These methods also work for a small(!) SpatRaster. Only cells that are not NA in the first layer are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
points(x, col, cex=0.7, pch=16, alpha=1, ...)

## S4 method for signature 'SpatVector'
lines(x, y=NULL, col, lwd=1, lty=1, arrows=FALSE, alpha=1, ...)

## S4 method for signature 'SpatVector'
polys(x, col, border="black", lwd=1, lty=1, alpha=1, ...)

## S4 method for signature 'SpatRaster'
points(x, ...)

## S4 method for signature 'SpatRaster'
lines(x, mx=10000, ...)

## S4 method for signature 'SpatRaster'
polys(x, mx=10000, dissolve=TRUE, ...)

## S4 method for signature 'SpatExtent'
points(x, col="black", alpha=1, ...)

## S4 method for signature 'SpatExtent'
lines(x, col="black", alpha=1, ...)

## S4 method for signature 'SpatExtent'
polys(x, col, alpha=1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_+3A_x">x</code></td>
<td>
<p>SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="lines_+3A_y">y</code></td>
<td>
<p>missing or SpatVector. If both <code>x</code> and <code>y</code> have point geometry and the same number of rows, lines are drawn between pairs of points</p>
</td></tr>
<tr><td><code id="lines_+3A_col">col</code></td>
<td>
<p>character. Colors</p>
</td></tr>
<tr><td><code id="lines_+3A_border">border</code></td>
<td>
<p>character. color(s) of the polygon borders. Use <code>NULL</code> or <code>NA</code> to not draw a border</p>
</td></tr>
<tr><td><code id="lines_+3A_cex">cex</code></td>
<td>
<p>numeric. point size magnifier. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="lines_+3A_pch">pch</code></td>
<td>
<p>positive integer, point type. See <code><a href="#topic+points">points</a></code>. On some (linux) devices, the default symbol &quot;16&quot; is a not a very smooth circle. You can use &quot;20&quot; instead (it takes a bit longer to draw) or &quot;1&quot; for an open circle</p>
</td></tr>
<tr><td><code id="lines_+3A_alpha">alpha</code></td>
<td>
<p>number between 0 and 1 to set transparency</p>
</td></tr>
<tr><td><code id="lines_+3A_lwd">lwd</code></td>
<td>
<p>numeric, line-width. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="lines_+3A_lty">lty</code></td>
<td>
<p>positive integer, line type. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="lines_+3A_arrows">arrows</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> is a SpatVector, arrows are drawn intead of lines. See <code>?<a href="graphics.html#topic+arrows">arrows</a></code> for additional arguments</p>
</td></tr>
<tr><td><code id="lines_+3A_mx">mx</code></td>
<td>
<p>positive number. If the number of cells of SpatRaster <code>x</code> is higher, the method will fail with an error message</p>
</td></tr>
<tr><td><code id="lines_+3A_dissolve">dissolve</code></td>
<td>
<p>logical. Should boundaries between cells with the same value be removed?</p>
</td></tr> 
<tr><td><code id="lines_+3A_...">...</code></td>
<td>
<p>additional graphical arguments such as <code>lwd</code>, <code>cex</code> and <code>pch</code></p>
</td></tr>  
</table>


<h3>Examples</h3>

<pre><code class='language-R'> 
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)

r &lt;- rast(v)
values(r) &lt;- 1:ncell(r)
plot(r)
lines(v)
points(v)
</code></pre>

<hr>
<h2 id='makeTiles'>Make tiles or get their extents</h2><span id='topic+getTileExtents'></span><span id='topic+getTileExtents+2CSpatRaster-method'></span><span id='topic+makeTiles'></span><span id='topic+makeTiles+2CSpatRaster-method'></span>

<h3>Description</h3>

 
<p>Divide a SpatRaster into &quot;tiles&quot;. The cells of another SpatRaster (normally with a much lower resolution) or a SpatVector with polygon geometry can be used to define the tiles. You can also provide one or two numbers to indicate the number of rows and columns per tile. 
</p>
<p><code>getTileExtents</code> returns the extents of the (virtual) tiles, while <code>makeTiles</code> creates files for the tiles and returns their filenames. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
makeTiles(x, y, filename="tile_.tif", extend=FALSE,
		na.rm=FALSE, buffer=0, overwrite=FALSE, ...)

## S4 method for signature 'SpatRaster'
getTileExtents(x, y, extend=FALSE, buffer=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeTiles_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="makeTiles_+3A_y">y</code></td>
<td>
<p>SpatRaster or SpatVector defining the zones; or numeric specifying the number of rows and columns for each zone (1 or 2 numbers if the number of rows and columns is not the same)</p>
</td></tr>
<tr><td><code id="makeTiles_+3A_filename">filename</code></td>
<td>
<p>character. Output filename template. Filenames will be altered by adding the tile number for each tile</p>
</td></tr>
<tr><td><code id="makeTiles_+3A_extend">extend</code></td>
<td>
<p>logical. If <code>TRUE</code>, the extent of <code>y</code> is expanded to assure that it covers all of <code>x</code></p>
</td></tr>
<tr><td><code id="makeTiles_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, tiles with only missing values are ignored</p>
</td></tr>
<tr><td><code id="makeTiles_+3A_buffer">buffer</code></td>
<td>
<p>integer. The number of additional rows and columns added to each tile. Can be a single number, or two numbers to specify a separate number of rows and columns. This allows for creating overlapping tiles that can be used for computing spatial context dependent values with e.g. <code><a href="#topic+focal">focal</a></code>. The expansion is only inside <code>x</code>, no rows or columns outside of <code>x</code> are added</p>
</td></tr>
<tr><td><code id="makeTiles_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, existing tiles are overwritten; otherwise they are skipped (without error or warning)</p>
</td></tr>
<tr><td><code id="makeTiles_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character (filenames) or matrix (extents)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vrt">vrt</a></code> to create a virtual raster from tiles
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=100, nrows=100)
values(r) &lt;- 1:ncell(r)
x &lt;- rast(ncols=2, nrows=2)

getTileExtents(r, x)
getTileExtents(r, x, buffer=3)


filename &lt;- paste0(tempfile(), "_.tif")
ff &lt;- makeTiles(r, x, filename)
ff

vrt(ff)
</code></pre>

<hr>
<h2 id='makeVRT'>Make a VRT header file</h2><span id='topic+makeVRT'></span>

<h3>Description</h3>

 
<p>Create a VRT header file for a &quot;flat binary&quot; raster file that needs a header file to be able to read it, but does not have it. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeVRT(filename, nrow, ncol, nlyr=1, extent, xmin, ymin, xres, yres=xres, xycenter=TRUE,
   crs="+proj=longlat", lyrnms="", datatype, NAflag=NA, bandorder="BIL", byteorder="LSB",
   toptobottom=TRUE, offset=0, scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeVRT_+3A_filename">filename</code></td>
<td>
<p>character. raster filename (without the &quot;.vrt&quot; extension)</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_nrow">nrow</code></td>
<td>
<p>positive integer, the number of rows</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_ncol">ncol</code></td>
<td>
<p>positive integer, the number of columns</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_nlyr">nlyr</code></td>
<td>
<p>positive integer, the number of layers</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_extent">extent</code></td>
<td>
<p>SpatExtent or missing</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_xmin">xmin</code></td>
<td>
<p>numeric. minimum x coordinate (only used if <code>extent</code> is missing)</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_ymin">ymin</code></td>
<td>
<p>numeric. minimum y coordinate (only used if <code>extent</code> is missing)</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_xres">xres</code></td>
<td>
<p>positive number. x resolution</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_yres">yres</code></td>
<td>
<p>positive number. y resolution)</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_xycenter">xycenter</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>xmin</code> and <code>xmax</code> represent the coordinates of the center of the extreme cell, in stead of the coordinates of the outside corner. Only used of <code>extent</code> is missing</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_crs">crs</code></td>
<td>
<p>character. Coordinate reference system description</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_lyrnms">lyrnms</code></td>
<td>
<p>character. Layer names</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_datatype">datatype</code></td>
<td>
<p>character. One of &quot;INT2S&quot;, &quot;INT4S&quot;, &quot;INT1U&quot;, &quot;INT2U&quot;, &quot;INT4U&quot;, &quot;FLT4S&quot;, &quot;FLT8S&quot;. If missing, this is guessed from the file size (INT1U for 1 byte per value, INT2S for 2 bytes and FLT4S for 4 bytes per value). This may be wrong because, for example, 2 bytes per value may in fact be INT2U (with the U for unsigned) values</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_naflag">NAflag</code></td>
<td>
<p>numeric. The value used as the &quot;NA flag&quot;</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_bandorder">bandorder</code></td>
<td>
<p>character. One of &quot;BIL&quot;, &quot;BIP&quot;, or &quot;BSQ&quot;. That is Band Interleaved by Line, or by Pixel, or Band SeQuential</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_byteorder">byteorder</code></td>
<td>
<p>character. One of &quot;LSB&quot;, &quot;MSB&quot;. &quot;MSB&quot; is common for files generated on Linux systems, whereas &quot;LSB&quot; is common for files generated on windows</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_toptobottom">toptobottom</code></td>
<td>
<p>logical. If <code>FALSE</code>, the values are read bottom to top</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_offset">offset</code></td>
<td>
<p>numeric. offset to be applied</p>
</td></tr>
<tr><td><code id="makeVRT_+3A_scale">scale</code></td>
<td>
<p>numeric. scale to be applied</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character (.VRT filename)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vrt">vrt</a></code> to create a vrt for a collection of raster tiles</p>

<hr>
<h2 id='map.pal'>map.pal arrow</h2><span id='topic+map.pal'></span>

<h3>Description</h3>

<p>Get a color palette for mapping. These palettes were copied from GRASS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map.pal(name, n=50, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.pal_+3A_name">name</code></td>
<td>
<p>character (name of a palette, see Details), or missing (to get the available names)</p>
</td></tr>
<tr><td><code id="map.pal_+3A_n">n</code></td>
<td>
<p>numeric. The number of colors</p>
</td></tr>
<tr><td><code id="map.pal_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed to <code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code></p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Name </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
aspect </td><td style="text-align: left;"> aspect oriented grey colors</td>
</tr>
<tr>
 <td style="text-align: left;">
bcyr </td><td style="text-align: left;"> blue through cyan through yellow to red</td>
</tr>
<tr>
 <td style="text-align: left;">
bgyr </td><td style="text-align: left;"> blue through green through yellow to red</td>
</tr>
<tr>
 <td style="text-align: left;">
blues </td><td style="text-align: left;"> white to blue</td>
</tr>
<tr>
 <td style="text-align: left;">
byg </td><td style="text-align: left;"> blue through yellow to green</td>
</tr>
<tr>
 <td style="text-align: left;">
byr </td><td style="text-align: left;"> blue through yellow to red</td>
</tr>
<tr>
 <td style="text-align: left;">
curvature </td><td style="text-align: left;"> for terrain curvatures</td>
</tr>
<tr>
 <td style="text-align: left;">
differences </td><td style="text-align: left;"> differences oriented colors</td>
</tr>
<tr>
 <td style="text-align: left;">
elevation </td><td style="text-align: left;"> maps relative ranges of raster values to elevation color ramp</td>
</tr>
<tr>
 <td style="text-align: left;">
grass </td><td style="text-align: left;"> GRASS GIS green (perceptually uniform)</td>
</tr>
<tr>
 <td style="text-align: left;">
greens </td><td style="text-align: left;"> white to green</td>
</tr>
<tr>
 <td style="text-align: left;">
grey </td><td style="text-align: left;"> grey scale</td>
</tr>
<tr>
 <td style="text-align: left;">
grey.eq </td><td style="text-align: left;"> histogram-equalized grey scale</td>
</tr>
<tr>
 <td style="text-align: left;">
grey.log </td><td style="text-align: left;"> histogram logarithmic transformed grey scale</td>
</tr>
<tr>
 <td style="text-align: left;">
gyr </td><td style="text-align: left;"> green through yellow to red</td>
</tr>
<tr>
 <td style="text-align: left;">
haxby </td><td style="text-align: left;"> relative colors for bathymetry or topography</td>
</tr>
<tr>
 <td style="text-align: left;">
inferno </td><td style="text-align: left;"> perceptually uniform sequential color table inferno</td>
</tr>
<tr>
 <td style="text-align: left;">
magma </td><td style="text-align: left;"> perceptually uniform sequential color table magma</td>
</tr>
<tr>
 <td style="text-align: left;">
oranges </td><td style="text-align: left;"> white to orange</td>
</tr>
<tr>
 <td style="text-align: left;">
plasma </td><td style="text-align: left;"> perceptually uniform sequential color table plasma</td>
</tr>
<tr>
 <td style="text-align: left;">
rainbow </td><td style="text-align: left;"> rainbow color table</td>
</tr>
<tr>
 <td style="text-align: left;">
ramp </td><td style="text-align: left;"> color ramp</td>
</tr>
<tr>
 <td style="text-align: left;">
random </td><td style="text-align: left;"> random color table</td>
</tr>
<tr>
 <td style="text-align: left;">
reds </td><td style="text-align: left;"> white to red</td>
</tr>
<tr>
 <td style="text-align: left;">
roygbiv </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
rstcurv </td><td style="text-align: left;"> terrain curvature</td>
</tr>
<tr>
 <td style="text-align: left;">
ryb </td><td style="text-align: left;"> red through yellow to blue</td>
</tr>
<tr>
 <td style="text-align: left;">
ryg </td><td style="text-align: left;"> red through yellow to green</td>
</tr>
<tr>
 <td style="text-align: left;">
sepia </td><td style="text-align: left;"> yellowish-brown through to white</td>
</tr>
<tr>
 <td style="text-align: left;">
viridis </td><td style="text-align: left;"> perceptually uniform sequential color table viridis</td>
</tr>
<tr>
 <td style="text-align: left;">
water </td><td style="text-align: left;"> water depth</td>
</tr>
<tr>
 <td style="text-align: left;">
wave </td><td style="text-align: left;"> color wave</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>none
</p>


<h3>See Also</h3>

 <p><code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>map.pal("elevation", 10)

r &lt;- rast(system.file("ex/elev.tif", package="terra"))
plot(r, col=map.pal("elevation"))

map.pal()
</code></pre>

<hr>
<h2 id='mask'>Mask values in a SpatRaster or SpatVector</h2><span id='topic+mask'></span><span id='topic+mask+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+mask+2CSpatRaster+2CSpatVector-method'></span><span id='topic+mask+2CSpatRaster+2Csf-method'></span><span id='topic+mask+2CSpatVector+2CSpatVector-method'></span><span id='topic+mask+2CSpatVector+2Csf-method'></span>

<h3>Description</h3>

<p>If <code>x</code> is a <code>SpatRaster</code>: 
Create a new SpatRaster that has the same values as SpatRaster <code>x</code>, except for the cells that are <code>NA</code> (or other <code>maskvalue</code>) in another SpatRaster (the 'mask'), or the cells that are not covered by a SpatVector. These cells become <code>NA</code> (or another <code>updatevalue</code>).
</p>
<p>If <code>x</code> is a <code>SpatVector</code>: 
Select geometries of <code>x</code> that intersect, or not intersect, with the geometries of <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
mask(x, mask, inverse=FALSE, maskvalues=NA, 
   updatevalue=NA, filename="", ...)
   
## S4 method for signature 'SpatRaster,SpatVector'
mask(x, mask, inverse=FALSE, updatevalue=NA,
	touches=TRUE, filename="", ...)

## S4 method for signature 'SpatVector,SpatVector'
mask(x, mask, inverse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="mask_+3A_mask">mask</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="mask_+3A_inverse">inverse</code></td>
<td>
<p>logical. If <code>TRUE</code>, areas on mask that are _not_ the <code>maskvalue</code> are masked</p>
</td></tr>
<tr><td><code id="mask_+3A_maskvalues">maskvalues</code></td>
<td>
<p>numeric. The value(s) in <code>mask</code> that indicate which cells of <code>x</code> should be masked (change their value to <code>updatevalue</code> (default = <code>NA</code>))</p>
</td></tr>
<tr><td><code id="mask_+3A_updatevalue">updatevalue</code></td>
<td>
<p>numeric. The value that masked cells should become (if they are not <code>NA</code>)</p>
</td></tr>
<tr><td><code id="mask_+3A_touches">touches</code></td>
<td>
<p>logical. If <code>TRUE</code>, all cells touched by lines or polygons will be masked, not just those on the line render path, or whose center point is within the polygon</p>
</td></tr>
<tr><td><code id="mask_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="mask_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

<p><a href="#topic+crop">crop</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
msk &lt;- ifel(r &lt; 400, NA, 1)

m &lt;- mask(r, msk)

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)[1,]

mv1 &lt;- mask(r, v)
mv2 &lt;- crop(r, v, mask=TRUE)
</code></pre>

<hr>
<h2 id='match'>Value matching for SpatRasters</h2><span id='topic+match'></span><span id='topic+match+2CSpatRaster-method'></span><span id='topic++25in+25'></span><span id='topic++25in+25+2CSpatRaster-method'></span>

<h3>Description</h3>

<p><code>match</code> returns a SpatRaster with the position of the matched values. The cell values are the index of the table argument. 
</p>
<p><code>%in%</code> returns a 0/1 (FALSE/TRUE) SpatRaster indicating if the cells values were matched or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match(x, table, nomatch = NA_integer_, incomparables = NULL)

x %in% table
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="match_+3A_table">table</code></td>
<td>
<p>vector of the values to be matched against</p>
</td></tr>
<tr><td><code id="match_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is found. Note that it is coerced to integer</p>
</td></tr>
<tr><td><code id="match_+3A_incomparables">incomparables</code></td>
<td>
<p>a vector of values that cannot be matched. Any value in x matching a value in this vector is assigned the nomatch value. For historical reasons, FALSE is equivalent to NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+app">app</a>, <a href="base.html#topic+match">match</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=10, ncols=10)
values(r) &lt;- 1:100
m &lt;- match(r, c(5:10, 50:55))
n &lt;- r %in% c(5:10, 50:55)
</code></pre>

<hr>
<h2 id='Math-methods'>General mathematical methods</h2><span id='topic+Math-methods'></span><span id='topic+Math2-methods'></span><span id='topic+Math+2CSpatRaster-method'></span><span id='topic+Math2+2CSpatRaster-method'></span><span id='topic+Math+2CSpatExtent-method'></span><span id='topic+Math2+2CSpatExtent-method'></span><span id='topic+Math2+2CSpatVector-method'></span><span id='topic+cumsum'></span><span id='topic+cumsum+2CSpatRaster-method'></span><span id='topic+log'></span><span id='topic+log+2CSpatRaster-method'></span><span id='topic+round'></span><span id='topic+round+2CSpatRaster-method'></span><span id='topic+round'></span><span id='topic+round+2CSpatVector-method'></span><span id='topic+sqrt'></span><span id='topic+sqrt+2CSpatRaster-method'></span><span id='topic+math'></span><span id='topic+math+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Standard mathematical methods for computations with SpatRasters. Computations are local (applied on a cell by cell basis). If multiple SpatRasters are used, these must have the same extent and resolution. These have been implemented:
</p>
<p><code>abs, sign, sqrt, ceiling, floor, trunc,  cummax, cummin, cumprod, cumsum, log, log10, log2, log1p, acos, acosh, asin, asinh, atan, atanh, exp, expm1, cos, cosh, sin, sinh, tan, tanh, round, signif</code>
</p>
<p>Instead of directly calling these methods, you can also provide their name to the <code>math</code> method. This is useful if you want to provide an output filename.
</p>
<p>The following methods have been implemented for <code>SpatExtent</code>: <code>round, floor, ceiling</code>
</p>
<p><code>round</code> has also been implemented for <code>SpatVector</code>, to round the coordinates of the geometries. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
sqrt(x)

## S4 method for signature 'SpatRaster'
log(x, base=exp(1))

## S4 method for signature 'SpatRaster'
round(x, digits=0)

## S4 method for signature 'SpatRaster'
math(x, fun, digits=0, filename="", overwrite=FALSE, ...)

## S4 method for signature 'SpatVector'
round(x, digits=4)

## S4 method for signature 'SpatRaster'
cumsum(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Math-methods_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="Math-methods_+3A_base">base</code></td>
<td>
<p>a positive or complex number: the base with respect to which logarithms are computed</p>
</td></tr>
<tr><td><code id="Math-methods_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding</p>
</td></tr>
<tr><td><code id="Math-methods_+3A_fun">fun</code></td>
<td>
<p>character. Math function name</p>
</td></tr>
<tr><td><code id="Math-methods_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="Math-methods_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="Math-methods_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster or SpatExtent
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+app">app</a></code> to use mathematical functions not implemented by the package, and <code><a href="#topic+Arith-methods">Arith-methods</a></code> for arithmetical operations. Use <code><a href="#topic+roll">roll</a></code> for rolling functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- rast(ncols=10, nrows=10)
v &lt;- runif(ncell(r1))
v[10:20] &lt;- NA
values(r1) &lt;- v
r2 &lt;- rast(r1)
values(r2) &lt;- 1:ncell(r2) / ncell(r2)
r &lt;- c(r1, r2)

s &lt;- sqrt(r)
# same as 
math(r, "sqrt")

round(s, 1)

cumsum(r)
</code></pre>

<hr>
<h2 id='mem'>Memory available and needed</h2><span id='topic+mem_info'></span><span id='topic+free_RAM'></span>

<h3>Description</h3>

<p><code>mem_info</code> prints the amount of RAM that is required and available to process a SpatRaster. 
</p>
<p><code>free_RAM</code> returns the amount of RAM that is available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mem_info(x, n=1)

free_RAM()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mem_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="mem_+3A_n">n</code></td>
<td>
<p>positive integer. The number of copies of <code>x</code> that are needed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>free_RAM returns the amount of available RAM in kilobytes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mem_info(rast())

free_RAM()
</code></pre>

<hr>
<h2 id='merge'> 
Merge SpatRasters, or merge a SpatVector with a data.frame
</h2><span id='topic+merge'></span><span id='topic+merge+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+merge+2CSpatRasterCollection+2Cmissing-method'></span><span id='topic+merge+2CSpatVector+2CSpatVector-method'></span><span id='topic+merge+2CSpatVector+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Merge multiple SpatRasters to create a new SpatRaster with a larger spatial extent. The SpatRasters must have the same origin and spatial resolution. In areas where the SpatRasters overlap, the values of the SpatRaster that is first in the sequence of arguments (or in the SpatRasterCollection) will be retained (unless <code>first=FALSE</code>). Cells that are <code>NA</code> are ignored unless <code>na.rm=FALSE</code>
</p>
<p>There is also a method for merging SpatVector with a data.frame; that is, to join the data.frame to the attribute table of the SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
merge(x, y, ..., first=TRUE, na.rm=TRUE, filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'SpatRasterCollection,missing'
merge(x, first=TRUE, na.rm=TRUE, filename="", ...)

## S4 method for signature 'SpatVector,data.frame'
merge(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatRasterCollection, or SpatVector</p>
</td></tr>
<tr><td><code id="merge_+3A_y">y</code></td>
<td>
<p>missing if <code>x</code> is a SpatRasterCollection. SpatRaster if <code>x</code> is a SpatRaster. data.frame if <code>x</code> is a SpatVector</p>
</td></tr>
<tr><td><code id="merge_+3A_...">...</code></td>
<td>
<p>if <code>x</code> is a SpatRaster: additional objects of the same class as <code>x</code>. If <code>x</code> is a SpatRasterCollection: options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code>. If <code>x</code> is a SpatVector, the same arguments as in <code><a href="base.html#topic+merge">merge</a></code></p>
</td></tr>
<tr><td><code id="merge_+3A_first">first</code></td>
<td>
<p>logical. If <code>TRUE</code>, in areas where rasters overlap, the first value is used. Otherwise the last value is used</p>
</td></tr>
<tr><td><code id="merge_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code> values that are <code>NA</code> are ignored</p>
</td></tr>
<tr><td><code id="merge_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="merge_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="merge_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster or SpatVector
</p>


<h3>See Also</h3>

<p>Combining tiles with <code><a href="#topic+vrt">vrt</a></code> may be more efficient than using <code>merge</code>. See <code><a href="#topic+mosaic">mosaic</a></code> for averaging overlapping regions. 
</p>
<p>See <code><a href="#topic+classify">classify</a></code> to merge a <code>SpatRaster</code> and a <code>data.frame</code> and <code><a href="#topic+union">union</a></code> to combine SpatExtent objects. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rast(xmin=-110, xmax=-80, ymin=40, ymax=70, res=1, vals=1)
y &lt;- rast(xmin=-85, xmax=-55, ymax=60, ymin=30, res=1, vals=2)
z &lt;- rast(xmin=-60, xmax=-30, ymax=50, ymin=20, res=1, vals=3)

m1 &lt;- merge(x, y, z)
m2 &lt;- merge(z, y, x)
m3 &lt;- merge(y, x, z)

# if you have many SpatRasters, it may be convenient
# to make a SpatRasterCollection
rlist &lt;- list(x, y, z)
rsrc &lt;- sprc(rlist)

m &lt;- merge(rsrc)


## SpatVector with data.frame
f &lt;- system.file("ex/lux.shp", package="terra")
p &lt;- vect(f)
dfr &lt;- data.frame(District=p$NAME_1, Canton=p$NAME_2, Value=round(runif(length(p), 100, 1000)))
dfr &lt;- dfr[1:5, ]
pm &lt;- merge(p, dfr, all.x=TRUE, by.x=c('NAME_1', 'NAME_2'), by.y=c('District', 'Canton'))
pm
values(pm)
</code></pre>

<hr>
<h2 id='mergeTime'> 
merge SpatRasters by timelines to create a single timeseries
</h2><span id='topic+mergeTime'></span><span id='topic+mergeTime+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

<p>Combine SpatRasters with partly overlapping time-stamps to create a single time series. If there is no overlap between the SpatRasters there is no point in using this function (use <code><a href="#topic+c">c</a></code> instead). 
</p>
<p>Also note that time gaps are not filled. You can use <code><a href="#topic+fillTime">fillTime</a></code> to do that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRasterDataset'
mergeTime(x, fun=mean, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeTime_+3A_x">x</code></td>
<td>
<p>SpatRasterDataset</p>
</td></tr>
<tr><td><code id="mergeTime_+3A_fun">fun</code></td>
<td>
<p>A function that reduces a vector to a single number, such as <code>mean</code> or <code>min</code></p>
</td></tr>
<tr><td><code id="mergeTime_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="mergeTime_+3A_...">...</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
s1 &lt;- c(r, r)
time(s1) &lt;- as.Date("2001-01-01") + 0:5
s1 &lt;- s1/10
time(s1) &lt;- as.Date("2001-01-07") + 0:5
s2 &lt;- s1*10
time(s2) &lt;- as.Date("2001-01-05") + 0:5
x &lt;- sds(s1, s1, s2)

m &lt;- mergeTime(x, mean)
</code></pre>

<hr>
<h2 id='meta'>meta</h2><span id='topic+meta'></span><span id='topic+meta+2CSpatRaster-method'></span>

<h3>Description</h3>

 
<p>Get metadata associated with the sources or layers of a SpatRaster 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
meta(x, layers=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meta_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="meta_+3A_layers">layers</code></td>
<td>
<p>logical. Should the layer level metadata be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='metags'>Set or get metadata</h2><span id='topic+metags'></span><span id='topic+metags+2CSpatRaster-method'></span><span id='topic+metags+3C-'></span><span id='topic+metags+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>You can set arbitrary metadata to a SpatRaster using &quot;name=value&quot; tags. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SpatRaster'
metags(x, layer=NULL)&lt;-value

## S4 method for signature 'SpatRaster'
metags(x, layer=NULL, name=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metags_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="metags_+3A_layer">layer</code></td>
<td>
<p>NULL or positive integer. If the value is NULL, the tags assigned or returned are for the SpatRaster. Otherwise for the layer number(s)</p>
</td></tr>
<tr><td><code id="metags_+3A_name">name</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="metags_+3A_value">value</code></td>
<td>
<p>character of &quot;name=value&quot; or two-column matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster (<code>metags&lt;-</code>), or named character (<code>metags</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncol=5, nrow=5)
m &lt;- cbind(c("one", "two", "three"), c("ABC", "123", "hello"))
metags(r) &lt;- m
metags(r)

metags(r) &lt;- c("another_tag=another_value", "one more=this value")
metags(r)

metags(r) &lt;- c(another_tag="44", `one more`="that value")
metags(r)


metags(r, name="two")

# remove a tag
metags(r) &lt;- cbind("one", "")
metags(r) &lt;- "two="
metags(r)

# remove all metags
metags(r) &lt;- NULL
metags(r)
</code></pre>

<hr>
<h2 id='modal'>modal value</h2><span id='topic+modal'></span><span id='topic+modal+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute the mode for each cell across the layers of a SpatRaster. The mode, or modal value, is the most frequent value in a set of values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
modal(x, ..., ties="first", na.rm=FALSE, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modal_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="modal_+3A_...">...</code></td>
<td>
<p>additional argument of the same type as <code>x</code> or numeric</p>
</td></tr>
<tr><td><code id="modal_+3A_ties">ties</code></td>
<td>
<p>character. Indicates how to treat ties. Either &quot;random&quot;, &quot;lowest&quot;, &quot;highest&quot;, &quot;first&quot;, or &quot;NA&quot;</p>
</td></tr>
<tr><td><code id="modal_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values are ignored. If <code>FALSE</code>, <code>NA</code> is returned if <code>x</code> has any <code>NA</code> values</p>
</td></tr>
<tr><td><code id="modal_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="modal_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="modal_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
r &lt;- c(r/2, r, r*2)
m &lt;- modal(r)
</code></pre>

<hr>
<h2 id='mosaic'> 
mosaic SpatRasters
</h2><span id='topic+mosaic'></span><span id='topic+mosaic+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+mosaic+2CSpatRasterCollection+2Cmissing-method'></span>

<h3>Description</h3>

<p>Combine adjacent and (partly) overlapping SpatRasters to form a single new SpatRaster. Values in overlapping cells are averaged (by default) or can be computed with another function.
</p>
<p>The SpatRasters must have the same origin and spatial resolution. 
</p>
<p>This method is similar to the simpler, but much faster, <code><a href="#topic+merge">merge</a></code> method. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
mosaic(x, y, ..., fun="mean", filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'SpatRasterCollection,missing'
mosaic(x, fun="mean", filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="mosaic_+3A_y">y</code></td>
<td>
<p>object of same class as <code>x</code></p>
</td></tr>
<tr><td><code id="mosaic_+3A_...">...</code></td>
<td>
<p>additional SpatRasters</p>
</td></tr>
<tr><td><code id="mosaic_+3A_fun">fun</code></td>
<td>
<p>character. One of &quot;mean&quot;, &quot;median&quot;, &quot;min&quot;, &quot;max&quot;, &quot;modal&quot;, &quot;sum&quot;, &quot;first&quot;, &quot;last&quot;</p>
</td></tr>
<tr><td><code id="mosaic_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="mosaic_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="mosaic_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+merge">merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rast(xmin=-110, xmax=-60, ymin=40, ymax=70, res=1, vals=1)
y &lt;- rast(xmin=-95, xmax=-45, ymax=60, ymin=30, res=1, vals=2)
z &lt;- rast(xmin=-80, xmax=-30, ymax=50, ymin=20, res=1, vals=3)

m1 &lt;- mosaic(x, y, z)

m2 &lt;- mosaic(z, y, x)

# with many SpatRasters, make a SpatRasterCollection from a list
rlist &lt;- list(x, y, z)
rsrc &lt;- sprc(rlist)

m &lt;- mosaic(rsrc)
</code></pre>

<hr>
<h2 id='na.omit'>Find and remove geometries that are NA</h2><span id='topic+na.omit'></span><span id='topic+na.omit+2CSpatVector-method'></span><span id='topic+is.na+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Find geometries that are NA; or remove geometries and/or records that are <code>NA</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
is.na(x)

## S4 method for signature 'SpatVector'
na.omit(object, field=NA, geom=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="na.omit_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>  
<tr><td><code id="na.omit_+3A_object">object</code></td>
<td>
<p>SpatVector</p>
</td></tr>  
<tr><td><code id="na.omit_+3A_field">field</code></td>
<td>
<p>character or NA. If <code>NA</code>, missing values in the attributes are ignored. Other values are either one or more field (variable) names, or <code>""</code> to consider all fields</p>
</td></tr>
<tr><td><code id="na.omit_+3A_geom">geom</code></td>
<td>
<p>logical. If <code>TRUE</code> empty geometries are removed</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
v$test &lt;- c(1,2,NA)
nrow(v)
x &lt;- na.omit(v, "test")
nrow(x)
</code></pre>

<hr>
<h2 id='NAflag'>Set the NA flag</h2><span id='topic+NAflag+3C-'></span><span id='topic+NAflag'></span><span id='topic+NAflag+2CSpatRaster-method'></span><span id='topic+NAflag+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>The main purpose of this method is to allow correct reading of a SpatRaster that is based on a file that has an incorrect NA flag. The file is not changed, but flagged value is set to NA when values are read from the file (&quot;lazy evaluation&quot;). In contrast, if the values are in memory the change is made immediately. 
</p>
<p>To change values, it is generally better to use <code><a href="#topic+classify">classify</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
NAflag(x)

## S4 replacement method for signature 'SpatRaster'
NAflag(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NAflag_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="NAflag_+3A_value">value</code></td>
<td>
<p>numeric. The value to be interpreted as NA; set this before reading the values from the file. This can be a single value, or multiple values, one for each data source (file / subdataset)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none or numeric
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classify">classify</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
s &lt;- rast(system.file("ex/logo.tif", package="terra"))[[1]]   
NAflag(s) &lt;- 255
plot(s)
NAflag(s)
</code></pre>

<hr>
<h2 id='names'>Names of Spat* objects</h2><span id='topic+name'></span><span id='topic+name+3C-'></span><span id='topic+names'></span><span id='topic+names+3C-'></span><span id='topic+names+2CSpatRaster-method'></span><span id='topic+names+3C-+2CSpatRaster-method'></span><span id='topic+names+2CSpatRasterDataset-method'></span><span id='topic+names+3C-+2CSpatRasterDataset-method'></span><span id='topic+names+2CSpatRasterCollection-method'></span><span id='topic+names+3C-+2CSpatRasterCollection-method'></span><span id='topic+names+2CSpatVector-method'></span><span id='topic+names+2CSpatVectorCollection-method'></span><span id='topic+names+2CSpatVectorProxy-method'></span><span id='topic+names+3C-+2CSpatVector-method'></span><span id='topic+names+3C-+2CSpatVectorCollection-method'></span>

<h3>Description</h3>

<p>Get or set the names of the layers of a SpatRaster or the attributes of a SpatVector. 
</p>
<p>See <code><a href="#topic+set.names">set.names</a></code> for in-place setting of names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
names(x)

## S4 replacement method for signature 'SpatRaster'
names(x)&lt;-value

## S4 method for signature 'SpatRasterDataset'
names(x)

## S4 replacement method for signature 'SpatRasterDataset'
names(x)&lt;-value

## S4 method for signature 'SpatVector'
names(x)

## S4 replacement method for signature 'SpatVector'
names(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatRasterDataset, or SpatVector</p>
</td></tr>
<tr><td><code id="names_+3A_value">value</code></td>
<td>
<p>character (vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character 
</p>


<h3>Note</h3>

<p>terra enforces neither unique nor valid names. See <code><a href="base.html#topic+make.unique">make.unique</a></code> to create unique names and <code><a href="base.html#topic+make.names">make.names</a></code> to make syntactically valid names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(ncols=5, nrows=5, nlyrs=3)
nlyr(s)
names(s)
names(s) &lt;- c("a", "b", "c")
names(s)

# SpatVector names
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
names(v)
names(v) &lt;- paste0(substr(names(v), 1, 2), "_", 1:ncol(v))
names(v)
</code></pre>

<hr>
<h2 id='nearest'>nearby geometries</h2><span id='topic+nearby'></span><span id='topic+nearby+2CSpatVector-method'></span><span id='topic+nearest'></span><span id='topic+nearest+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Identify geometries that are near to each other. Either get the index of all geometries within a certain distance, or the k nearest neighbors, or (with <code>nearest</code>) get the nearest points between two geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
nearby(x, y=NULL, distance=0, k=1, centroids=TRUE, symmetrical=TRUE)

## S4 method for signature 'SpatVector'
nearest(x, y, pairs=FALSE, centroids=TRUE, lines=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="nearest_+3A_y">y</code></td>
<td>
<p>SpatVector or NULL</p>
</td></tr>
<tr><td><code id="nearest_+3A_distance">distance</code></td>
<td>
<p>numeric. maximum distance</p>
</td></tr>
<tr><td><code id="nearest_+3A_k">k</code></td>
<td>
<p>positive integer. number of neighbors. Ignored if <code>distance &gt; 0</code></p>
</td></tr>
<tr><td><code id="nearest_+3A_centroids">centroids</code></td>
<td>
<p>logical. Should the centroids of polygons be used?</p>
</td></tr>
<tr><td><code id="nearest_+3A_symmetrical">symmetrical</code></td>
<td>
<p>logical. If <code>TRUE</code>, a near pair is only included once. That is, if geometry 1 is near to geometry 3, the implied nearness between 3 and 1 is not reported. Ignored if <code>k</code> neighbors are returned</p>
</td></tr>
<tr><td><code id="nearest_+3A_pairs">pairs</code></td>
<td>
<p>logical. If <code>TRUE</code> pairwise nearest points are returned (only relevant when using at least one SpatVector of lines or polygons</p>
</td></tr>
<tr><td><code id="nearest_+3A_lines">lines</code></td>
<td>
<p>logical. If <code>TRUE</code> lines between the nearest points instead of (the nearest) points </p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relate">relate</a></code>, <code><a href="#topic+adjacent">adjacent</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
nearby(v, distance=12000)
</code></pre>

<hr>
<h2 id='normalize.longitude'>normalize vector data that crosses the dateline</h2><span id='topic+normalize.longitude'></span><span id='topic+normalize.longitude+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Normalize the longitude of geometries, move them if they are outside of the -180 to 180 degrees range. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
normalize.longitude(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize.longitude_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector</p>


<h3>See Also</h3>

<p><a href="#topic+rotate">rotate</a> for SpatRaster</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- vect("POLYGON ((120 10, 230 75, 230 -75, 120 10))")
normalize.longitude(p)
</code></pre>

<hr>
<h2 id='north'>North arrow</h2><span id='topic+north'></span>

<h3>Description</h3>

<p>Add a (North) arrow to a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>north(xy=NULL, type=1, label="N", angle=0, d, head=0.1, xpd=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="north_+3A_xy">xy</code></td>
<td>
<p>numeric. x and y coordinate to place the arrow. It can also be one of following character values: &quot;bottomleft&quot;, &quot;bottom&quot;, &quot;bottomright&quot;, topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;left&quot;, &quot;right&quot;, or NULL</p>
</td></tr>
<tr><td><code id="north_+3A_type">type</code></td>
<td>
<p>integer between 1 and 12, or a character (unicode) representation of a right pointing arrow such as <code>"\u27A9"</code></p>
</td></tr>
<tr><td><code id="north_+3A_label">label</code></td>
<td>
<p>character, to be printed near the arrow</p>
</td></tr>
<tr><td><code id="north_+3A_angle">angle</code></td>
<td>
<p>numeric. The angle of the arrow in degrees</p>
</td></tr>
<tr><td><code id="north_+3A_d">d</code></td>
<td>
<p>numeric. Distance covered by the arrow in plot coordinates. Only applies to <code>type=1</code></p>
</td></tr>
<tr><td><code id="north_+3A_head">head</code></td>
<td>
<p>numeric. The size of the arrow &quot;head&quot;, for <code>type=1</code></p>
</td></tr>
<tr><td><code id="north_+3A_xpd">xpd</code></td>
<td>
<p>logical. If <code>TRUE</code>, the scale bar or arrow can be outside the plot area</p>
</td></tr>
<tr><td><code id="north_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to other methods </p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sbar">sbar</a></code>, <code><a href="#topic+plot">plot</a></code>, <code><a href="#topic+inset">inset</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/meuse.tif", package="terra")
r &lt;- rast(f)
plot(r)
north()
north(c(178550, 332500), d=250)

## Not run: 
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
plot(r, type="interval")
sbar(15, c(6.3, 50), type="bar", below="km", label=c(0,7.5,15), cex=.8)
north(type=3, cex=.8)
north(xy=c(6.7, 49.9), type=2, angle=45, label="NE")
north(xy=c(6.6, 49.7), type=5, cex=1.25)
north(xy=c(5.5, 49.6), type=9)
north(d=.05, xy=c(5.5, 50), angle=180, label="S", lwd=2, col="blue")


## all arrows
r &lt;- rast(res=10)
values(r) &lt;- 1
plot(r, col="white", axes=FALSE, legend=FALSE, mar=c(0,0,0,0), reset=TRUE)
for (i in 1:12) {
	x = -200+i*30
	north(xy=cbind(x,30), type=i)
	text(x, -20, i, xpd=TRUE)
}


## End(Not run)

</code></pre>

<hr>
<h2 id='not.na'>is not NA</h2><span id='topic+not.na'></span><span id='topic+not.na+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Shortcut method to avoid the two-step <code>!is.na(x)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
not.na(x, falseNA, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not.na_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="not.na_+3A_falsena">falseNA</code></td>
<td>
<p>logical. Should the result be <code>TRUE, NA</code> instead of <code>TRUE, FALSE</code>?</p>
</td></tr>
<tr><td><code id="not.na_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="not.na_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Compare-methods">Compare-methods</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10, vals=1)
r[10:20] &lt;- NA
x &lt;- not.na(r)
</code></pre>

<hr>
<h2 id='options'>Options</h2><span id='topic+terraOptions'></span>

<h3>Description</h3>

<p>Get or set general options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terraOptions(..., print=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="options_+3A_...">...</code></td>
<td>
<p>option names and values (see Details). Or missing, to get or show the current options</p>
</td></tr>  
<tr><td><code id="options_+3A_print">print</code></td>
<td>
<p>logical. If <code>TRUE</code> the option names and values are printed </p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The following options are available. 
</p>
<p><b>memfrac</b> - value between 0 and 0.9 (larger values give a warning). The fraction of RAM that may be used by the program.
</p>
<p><b>memmin</b> - if memory required is below this threshold (in GB), the memory is assumed to be available. Otherwise, terra checks if it is available.
</p>
<p><b>memmax</b> - the maximum amount of RAM (in GB) that terra is allowed to use when processing a raster dataset. Should be less than what is detected (see <code><a href="#topic+mem_info">mem_info</a></code>), and higher values are ignored. Set it to a negative number or NA to not set this option. <code>terraOptions</code> only shows the value of <code>memmax</code> if it is set.
</p>
<p><b>tempdir</b> - directory where temporary files are written. The default what is returned by <code>tempdir()</code>.
</p>
<p><b>datatype</b> - default data type. See <code><a href="#topic+writeRaster">writeRaster</a></code>
</p>
<p><b>todisk</b> - logical. If <code>TRUE</code> write all raster data to disk (temp file if no file name is specified). For debugging.
</p>
<p><b>progress</b> - non-negative integer. A progress bar is shown if the number of chunks in which the data is processed is larger than this number. No progress bar is shown if the value is zero
</p>
<p><b>verbose</b> - logical. If <code>TRUE</code> debugging info is printed for some functions
</p>


<h3>Value</h3>

<p>list. Invisibly if <code>print=TRUE</code>
</p>


<h3>Note</h3>

<p>It is possible to set your own default options in &quot;etc/.Rprofile.site&quot; of your R installation like this
</p>
<p><code>options(terra_default=list(tempdir="d:/temp", memfrac=.4))</code>
</p>
<p>But that may not be a good practice. It is clearer to set your favorite options at the beginning of each script.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>terraOptions()
terraOptions(memfrac=0.5, tempdir = "c:/temp")
terraOptions(progress=10)
terraOptions()
</code></pre>

<hr>
<h2 id='origin'>Origin</h2><span id='topic+origin'></span><span id='topic+origin+2CSpatRaster-method'></span><span id='topic+origin+3C-'></span><span id='topic+origin+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get or set the coordinates of the point of origin of a SpatRaster. This is the point closest to (0, 0) that you could get if you moved towards that point in steps of the x and y resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
origin(x)

## S4 replacement method for signature 'SpatRaster'
origin(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="origin_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="origin_+3A_value">value</code></td>
<td>
<p>numeric vector of length 1 or 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of two numbers (x and y coordinates)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(xmin=-0.5, xmax = 9.5, ncols=10)
origin(r)
origin(r) &lt;- c(0,0)
r
</code></pre>

<hr>
<h2 id='pairs'>
Pairs plot (matrix of scatterplots)
</h2><span id='topic+pairs'></span><span id='topic+pairs+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Pair plots of layers in a SpatRaster. This is a wrapper around graphics function <code><a href="graphics.html#topic+pairs">pairs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
pairs(x, hist=TRUE, cor=TRUE, use="pairwise.complete.obs", maxcells=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="pairs_+3A_hist">hist</code></td>
<td>
<p>logical. If TRUE a histogram of the values is shown on the diagonal</p>
</td></tr>
<tr><td><code id="pairs_+3A_cor">cor</code></td>
<td>
<p>logical. If TRUE the correlation coefficient is shown in the upper panels</p>
</td></tr>
<tr><td><code id="pairs_+3A_use">use</code></td>
<td>
<p>argument passed to the <code><a href="stats.html#topic+cor">cor</a></code> function</p>
</td></tr>
<tr><td><code id="pairs_+3A_maxcells">maxcells</code></td>
<td>
<p>integer. Number of pixels to sample from each layer of a large SpatRaster</p>
</td></tr>
<tr><td><code id="pairs_+3A_...">...</code></td>
<td>
<p>additional arguments (graphical parameters)</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+boxplot">boxplot</a>, <a href="#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;-rast(system.file("ex/elev.tif", package="terra"))
s &lt;- c(r, 1/r, sqrt(r))
names(s) &lt;- c("elevation", "inverse", "sqrt") 
pairs(s)

# to make indvidual histograms:
hist(r)
# or scatter plots:
plot(s[[1]], s[[2]])
</code></pre>

<hr>
<h2 id='panel'>Map panel</h2><span id='topic+panel'></span><span id='topic+panel+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Show multiple maps that share a single legend. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
panel(x, main, loc.main="topleft", nc, nr, maxnl=16, 
	maxcell=500000, box=FALSE, pax=list(), plg=list(), range=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="panel_+3A_main">main</code></td>
<td>
<p>character. Main plot titles (one for each layer to be plotted). You can use arguments <code>cex.main</code>, <code>font.main</code>, <code>col.main</code> to change the appearance</p>
</td></tr>
<tr><td><code id="panel_+3A_loc.main">loc.main</code></td>
<td>
<p>numeric of character to set the location of the main title. Either two coordinates, or a character value such as &quot;topleft&quot;)</p>
</td></tr>
<tr><td><code id="panel_+3A_nc">nc</code></td>
<td>
<p>positive integer. Optional. The number of columns to divide the plotting device in (when plotting multiple layers)</p>
</td></tr>
<tr><td><code id="panel_+3A_nr">nr</code></td>
<td>
<p>positive integer. Optional. The number of rows to divide the plotting device in (when plotting multiple layers)</p>
</td></tr>
<tr><td><code id="panel_+3A_maxnl">maxnl</code></td>
<td>
<p>positive integer. Maximum number of layers to plot (for a multi-layer object)</p>
</td></tr> 
<tr><td><code id="panel_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot</p>
</td></tr>
<tr><td><code id="panel_+3A_box">box</code></td>
<td>
<p>logical. Should a box be drawn around the map?</p>
</td></tr>
<tr><td><code id="panel_+3A_plg">plg</code></td>
<td>
<p>see <code><a href="#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="panel_+3A_pax">pax</code></td>
<td>
<p>see <code><a href="#topic+plot">plot</a></code></p>
</td></tr>
<tr><td><code id="panel_+3A_range">range</code></td>
<td>
<p>numeric. minimum and maximum values to be used for the continuous legend </p>
</td></tr>  
<tr><td><code id="panel_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>plot("SpatRaster", "numeric")</code> and additional graphical arguments</p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code> and see <code>rasterVis::levelplot</code> and <code>tidyterra::autoplot</code> for more sophisticated panel plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
v &lt;- vect(system.file("ex/lux.shp", package="terra"))
x &lt;- c(r, r/2, r*2, r)
names(x) &lt;- paste0("(", LETTERS[1:4], ")")
panel(x)
panel(x, fun=\()lines(v), loc.main="topright")
</code></pre>

<hr>
<h2 id='patches'>Detect patches (clumps) of cells</h2><span id='topic+patches'></span><span id='topic+patches+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Detect patches (clumps). Patches are groups of cells that are surrounded by cells that are <code>NA</code>. Set <code>zeroAsNA</code> to <code>TRUE</code> to also identify patches separated by cells with values of zero. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
patches(x, directions=4, zeroAsNA=FALSE, allowGaps=TRUE, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patches_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="patches_+3A_directions">directions</code></td>
<td>
<p>integer indicating which cells are considered adjacent. Should be 8 (Queen's case) or 4 (Rook's case)</p>
</td></tr>
<tr><td><code id="patches_+3A_zeroasna">zeroAsNA</code></td>
<td>
<p>logical. If <code>TRUE</code> treat cells that are zero as if they were <code>NA</code></p>
</td></tr>
<tr><td><code id="patches_+3A_allowgaps">allowGaps</code></td>
<td>
<p>logical. If <code>TRUE</code> there may be gaps in the patch IDs (e.g. you may have patch IDs 1, 2, 3 and 5, but not 4). If it is FALSE, these numbers will be recoded from 1 to the number of patches (4 in this example)</p>
</td></tr>
<tr><td><code id="patches_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="patches_+3A_...">...</code></td>
<td>
<p>options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster. Cell values are patch numbers
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+focal">focal</a></code>, <code><a href="#topic+boundaries">boundaries</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=18, ncols=36, xmin=0)
r[1:2, 5:8] &lt;- 1
r[5:8, 2:6] &lt;- 1
r[7:12, 22:36] &lt;- 1
r[15:16, 18:29] &lt;- 1
p &lt;- patches(r)

# zero as background instead of NA
r &lt;- rast(nrows=10, ncols=10, xmin=0, vals=0)
r[3, 3] &lt;- 10
r[4, 4] &lt;- 10
r[5, 5:8] &lt;- 12
r[6, 6:9] &lt;- 12

# treat zeros as NA

p4 &lt;- patches(r, zeroAsNA=TRUE)
p8 &lt;- patches(r, 8, zeroAsNA=TRUE)

### patches for different values
# remove zeros manually
rr &lt;- classify(r, cbind(0, NA))

# make layers for each value
s &lt;- segregate(rr, keep=TRUE, other=NA)
p &lt;- patches(s)


### patch ID values are not guaranteed to be consecutive
r &lt;- rast(nrows=5, ncols=10, xmin=0)
set.seed(0)
values(r)&lt;- round(runif(ncell(r))*0.7)
rp &lt;- patches(r, directions=8, zeroAsNA=TRUE) 
plot(rp, type="classes"); text(rp)

## unless you set allowGaps=FALSE
rp &lt;- patches(r, directions=8, zeroAsNA=TRUE, allowGaps=FALSE) 
plot(rp, type="classes"); text(rp)

### use zonal to remove small patches 
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
x &lt;- classify(r, cbind(-Inf, 400, NA))
y &lt;- patches(x)
# remove patches smaller than 100 ha
rz &lt;- zonal(cellSize(y, unit="ha"), y, sum, as.raster=TRUE)
s &lt;- ifel(rz &lt; 250, NA, y)
</code></pre>

<hr>
<h2 id='perim'>Perimeter or length</h2><span id='topic+perim'></span><span id='topic+perim+2CSpatVector-method'></span><span id='topic+perimeter'></span><span id='topic+perimeter+2CSpatVector-method'></span>

<h3>Description</h3>

<p>This method returns the length of lines or the perimeter of polygons.
</p>
<p>When the crs is not longitude/latitude, you may get more accurate results by first unprojecting the SpatVector (you can use <code><a href="#topic+project">project</a></code> to transform the crs to longitude/latitude)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
perim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perim_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric (m)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
perim(v)
</code></pre>

<hr>
<h2 id='persp'>Perspective plot</h2><span id='topic+persp'></span><span id='topic+persp+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Perspective plot of a SpatRaster. This is an implementation of a generic function in the graphics package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
persp(x, maxcells=100000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="persp_+3A_x">x</code></td>
<td>
<p>SpatRaster. Only the first layer is used</p>
</td></tr>
<tr><td><code id="persp_+3A_maxcells">maxcells</code></td>
<td>
<p>integer &gt; 0. Maximum number of cells to use for the plot. If <code>maxpixels &lt; ncell(x)</code>, <code>spatSample(method="regular")</code> is used before plotting</p>
</td></tr>
<tr><td><code id="persp_+3A_...">...</code></td>
<td>
<p>Any argument that can be passed to <code><a href="graphics.html#topic+persp">persp</a></code> (graphics package)</p>
</td></tr>  
</table>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+persp">persp</a></code>, <code>contour</code>, <code>plot</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
persp(r)
</code></pre>

<hr>
<h2 id='plet'>Plot with leaflet</h2><span id='topic+plet'></span><span id='topic+plet+2Cmissing-method'></span><span id='topic+plet+2CSpatRaster-method'></span><span id='topic+plet+2CSpatVector-method'></span><span id='topic+plet+2CSpatVectorCollection-method'></span><span id='topic+lines+2Cleaflet-method'></span><span id='topic+points+2Cleaflet-method'></span>

<h3>Description</h3>

<p>Plot the values of a SpatRaster or SpatVector to make an interactive leaflet map that is displayed in a browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
plet(x, y=1, col, alpha=0.8, main=names(x), tiles=NULL, 
   wrap=TRUE, maxcell=500000, legend="bottomright", 
   shared=FALSE, panel=FALSE, collapse=TRUE, map=NULL) 


## S4 method for signature 'SpatVector'
plet(x, y="", col,fill=0.2, main=y, cex=1, lwd=2, 
	border="black", alpha=1, popup=TRUE, label=FALSE, split=FALSE,
	tiles=c("Streets", "Esri.WorldImagery", "OpenTopoMap"), 
	wrap=TRUE, legend="bottomright", collapse=FALSE, type=NULL, breaks=NULL,
	breakby="eqint", sort=TRUE, decreasing=FALSE, map=NULL, ...)


## S4 method for signature 'SpatVectorCollection'
plet(x, col, fill=0, cex=1, lwd=2, border="black", alpha=1, popup=TRUE, 
   label=FALSE, tiles=c("Streets", "Esri.WorldImagery", "OpenTopoMap"), wrap=TRUE,
   legend="bottomright", collapse=FALSE, map=NULL)


## S4 method for signature 'leaflet'
lines(x, y, col, lwd=2, alpha=1, ...)

## S4 method for signature 'leaflet'
points(x, y, col, cex=1, alpha=1, popup=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plet_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector, or leaflet object</p>
</td></tr>
<tr><td><code id="plet_+3A_y">y</code></td>
<td>
<p>missing, or positive integer, or character (variable or layer name) indicating the layer(s) to be plotted. If <code>x</code> is a SpatRater, you can select multiple layers</p>
</td></tr>
<tr><td><code id="plet_+3A_col">col</code></td>
<td>
<p>character. Vector of colors or color generating function</p>
</td></tr>
<tr><td><code id="plet_+3A_alpha">alpha</code></td>
<td>
<p>Number between 0 and 1 to set the transparency for lines (0 is transparent, 1 is opaque)</p>
</td></tr>
<tr><td><code id="plet_+3A_fill">fill</code></td>
<td>
<p>Number between 0 and 1 to set the transparency for polygon areas (0 is transparent, 1 is opaque)</p>
</td></tr>
<tr><td><code id="plet_+3A_tiles">tiles</code></td>
<td>
<p>character or NULL. Names of background tile providers</p>
</td></tr>
<tr><td><code id="plet_+3A_wrap">wrap</code></td>
<td>
<p>logical. if <code>TRUE</code>, tiles wrap around</p>
</td></tr>
<tr><td><code id="plet_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot</p>
</td></tr>  
<tr><td><code id="plet_+3A_legend">legend</code></td>
<td>
<p>character to indicate the legend position (&quot;bottomleft&quot;, &quot;bottomright&quot;, &quot;topleft&quot; or &quot;topright&quot;) or NULL to suppress the legend</p>
</td></tr>
<tr><td><code id="plet_+3A_main">main</code></td>
<td>
<p>character. Title for the legend. The length should be 1 if <code>x</code> is a SpatVector and length nlyr(x) if <code>x</code> is a SpatVector</p>
</td></tr>
<tr><td><code id="plet_+3A_shared">shared</code></td>
<td>
<p>logical. Should the legend be the same for all rasters (if multiple layers of SpatRaster <code>x</code> are mapped)</p>
</td></tr>  
<tr><td><code id="plet_+3A_map">map</code></td>
<td>
<p>leaflet object</p>
</td></tr>
<tr><td><code id="plet_+3A_...">...</code></td>
<td>
<p>additional arguments for drawing points, lines, or polygons passed on the the relevant leaflet function</p>
</td></tr>
<tr><td><code id="plet_+3A_border">border</code></td>
<td>
<p>character. Color for the polygon borders</p>
</td></tr>
<tr><td><code id="plet_+3A_collapse">collapse</code></td>
<td>
<p>logical. Should the layers &quot;control&quot; panel be collapsed?</p>
</td></tr>
<tr><td><code id="plet_+3A_split">split</code></td>
<td>
<p>logical. If <code>TRUE</code> a check-box is created to toggle each value in <code>y</code> (If <code>x</code> is a SpatVector)</p>
</td></tr>
<tr><td><code id="plet_+3A_cex">cex</code></td>
<td>
<p>numeric. point size magnifier. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plet_+3A_lwd">lwd</code></td>
<td>
<p>numeric, line-width. See <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plet_+3A_popup">popup</code></td>
<td>
<p>logical. Should pop-ups be created?</p>
</td></tr>
<tr><td><code id="plet_+3A_label">label</code></td>
<td>
<p>logical. Should mouse-over labels be added?</p>
</td></tr>
<tr><td><code id="plet_+3A_panel">panel</code></td>
<td>
<p>logical. Should SpatRaster layers be shown as a panel&quot;</p>
</td></tr>
<tr><td><code id="plet_+3A_type">type</code></td>
<td>
<p>character. Type of map/legend. One of &quot;classes&quot;, or &quot;interval&quot;. If not specified, the type is chosen based on the data. Use &quot;&quot; to suppress the legend</p>
</td></tr>
<tr><td><code id="plet_+3A_breaks">breaks</code></td>
<td>
<p>numeric. Either a single number to indicate the number of breaks desired, or the actual breaks. When providing this argument, the default legend becomes &quot;interval&quot;</p>
</td></tr>
<tr><td><code id="plet_+3A_breakby">breakby</code></td>
<td>
<p>character or function. Either &quot;eqint&quot; for equal interval breaks, &quot;cases&quot; for equal quantile breaks. If a function is supplied it should take a single argument (a vector of values) and create groups</p>
</td></tr>
<tr><td><code id="plet_+3A_sort">sort</code></td>
<td>
<p>logical. If <code>TRUE</code> legends with character values are sorted. You can also supply a vector of the unique values, in the order in which you want them to appear in the legend</p>
</td></tr>
<tr><td><code id="plet_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. If <code>TRUE</code>, legends are sorted in decreasing order</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run: 
if (require(leaflet) &amp;&amp; (packageVersion("leaflet") &gt; "2.1.1")) {

v &lt;- vect(system.file("ex/lux.shp", package="terra"))
p &lt;- spatSample(as.polygons(v, ext=T), 30)
values(p) = data.frame(id=11:40, name=letters[1:30])

m &lt;- plet(v, "NAME_1", tiles="", border="blue")
m &lt;- points(m, p, col="red", cex=2, popup=T)
lines(m, v, lwd=1, col="white")

plet(v, "NAME_1", split=TRUE, alpha=.2) |&gt; 
  points(p, col="gray", cex=2, popup=TRUE,
  	clusterOptions = markerClusterOptions())

s &lt;- svc(v, p)
names(s) &lt;- c("the polys", "set of points")
plet(s, col=c("red", "blue"), lwd=1)


r &lt;- rast(system.file("ex/elev.tif", package="terra"))
plet(r, main="Hi\nthere") |&gt; lines(v, lwd=1)

plet(r, tiles="Streets") |&gt; lines(v, lwd=2, col="blue")

x &lt;- c(r, 50*classify(r, 5))
names(x) &lt;- c("first", "second")

# each their own legend
plet(x, 1:2, tiles="Streets", collapse=FALSE) |&gt; lines(v, lwd=2, col="blue")

# shared legend
plet(x, 1:2, tiles="Streets", shared=TRUE, collapse=FALSE) |&gt; lines(v, lwd=2, col="blue")

}
## End(Not run)</code></pre>

<hr>
<h2 id='plot'>Make a map</h2><span id='topic+plot'></span><span id='topic+plot+2CSpatRaster+2Cmissing-method'></span><span id='topic+plot+2CSpatRaster+2Cnumeric-method'></span><span id='topic+plot+2CSpatRaster+2Ccharacter-method'></span><span id='topic+plot+2CSpatVector+2Cmissing-method'></span><span id='topic+plot+2CSpatVector+2Cnumeric-method'></span><span id='topic+plot+2CSpatVector+2Cdata.frame-method'></span><span id='topic+plot+2CSpatVector+2Ccharacter-method'></span><span id='topic+plot+2CSpatVectorProxy+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot the values of a SpatRaster or SpatVector to make a map. 
</p>
<p>See <code><a href="#topic+points">points</a></code>, <code><a href="#topic+lines">lines</a></code> or <code><a href="#topic+polys">polys</a></code> to add a SpatVector to an existing map (or use argument <code>add=TRUE</code>).
</p>
<p>There is a separate help file for plotting a <code><a href="#topic+plot+2CSpatGraticule+2Cmissing-method">SpatGraticule</a></code> or <code><a href="#topic+plot+2CSpatExtent+2Cmissing-method">SpatExtent</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,numeric'
plot(x, y=1, col, type=NULL, mar=NULL, legend=TRUE, axes=!add, plg=list(), pax=list(), 
    maxcell=500000, smooth=FALSE, range=NULL, levels=NULL, all_levels=FALSE,
	breaks=NULL, breakby="eqint", fun=NULL, colNA=NULL, alpha=NULL, sort=FALSE, 
	decreasing=FALSE, grid=FALSE, ext=NULL, reset=FALSE, add=FALSE, buffer=FALSE, 
	background=NULL, box=axes, clip=TRUE, ...)

## S4 method for signature 'SpatRaster,missing'
plot(x, y, main, mar=NULL, nc, nr, maxnl=16, maxcell=500000, add=FALSE, ...)

## S4 method for signature 'SpatRaster,character'
plot(x, y, ...)

## S4 method for signature 'SpatVector,character'
plot(x, y, col=NULL, type=NULL, mar=NULL, add=FALSE, legend=TRUE, axes=!add, 
    main="", buffer=TRUE, background=NULL, grid=FALSE, ext=NULL, sort=TRUE, 
	decreasing=FALSE, plg=list(), pax=list(), nr, nc, colNA=NA, alpha=NULL, 
	box=axes, clip=TRUE, ...)

## S4 method for signature 'SpatVector,numeric'
plot(x, y, ...)

## S4 method for signature 'SpatVector,missing'
plot(x, y, values=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>missing or positive integer or name indicating the layer(s) to be plotted</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p>character. Colors. The default is <code>rev(grDevices::terrain.colors(50))</code>. If <code>x</code> is a <code>SpatRaster</code>, it can also be a <code>data.frame</code> with two columns (value, color) to get a &quot;classes&quot; type legend or with three columns (from, to, color) to get an &quot;interval&quot; type legend</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>character. Type of map/legend. One of &quot;continuous&quot;, &quot;classes&quot;, or &quot;interval&quot;. If not specified, the type is chosen based on the data</p>
</td></tr>
<tr><td><code id="plot_+3A_mar">mar</code></td>
<td>
<p>numeric vector of length 4 to set the margins of the plot (to make space for the legend). The default is (3.1, 3.1, 2.1, 7.1) for a single plot with a legend and (3.1, 3.1, 2.1, 2.1) otherwise. The default for a RGB raster is 0. Use <code>mar=NA</code> to not set the margins</p>
</td></tr>
<tr><td><code id="plot_+3A_legend">legend</code></td>
<td>
<p>logical or character. If not <code>FALSE</code> a legend is drawn. The character value can be used to indicate where the legend is to be drawn. For example &quot;topright&quot; or &quot;bottomleft&quot;. Use <code>plg</code> for more refined placement. Not supported for continuous legends (the default for raster data)</p>
</td></tr>
<tr><td><code id="plot_+3A_axes">axes</code></td>
<td>
<p>logical. Draw axes?</p>
</td></tr>
<tr><td><code id="plot_+3A_buffer">buffer</code></td>
<td>
<p>logical. If <code>TRUE</code> the plotting area is made slightly larger than the extent of <code>x</code></p>
</td></tr>
<tr><td><code id="plot_+3A_background">background</code></td>
<td>
<p>background color. Default is no color (white)</p>
</td></tr>
<tr><td><code id="plot_+3A_box">box</code></td>
<td>
<p>logical. Should a box be drawn around the map?</p>
</td></tr>
<tr><td><code id="plot_+3A_clip">clip</code></td>
<td>
<p>logical. Should the axes be clipped to the extent of <code>x</code>?</p>
</td></tr>
<tr><td><code id="plot_+3A_plg">plg</code></td>
<td>
<p>list with parameters for drawing the legend. For the classes and interval type legend see the arguments for <code><a href="graphics.html#topic+legend">legend</a></code>. For example <code>x</code> and <code>y</code> can be used to place the legend. You can also use keywords such as &quot;topleft&quot; and &quot;bottomright&quot; to place the legend at these locations inside the map rectangle. 
</p>
<p>Some of these do not apply to a continuous legend, or they behave a little differently. For example, only the placement keywords &quot;left&quot;, &quot;right&quot;, &quot;top&quot;, and &quot;bottom&quot; are recognized; and when using these keywords, the legend is placed outside of the map rectangle. Additional parameters for continuous legends include: 
</p>

<ul>
<li> <p><code>digits</code> to set the number of digits to print after the decimal point. <code>size</code> to change the height and/or width; the defaults are <code>c(1,1)</code>, negative values for size flip the order of the legend. 
</p>
</li>
<li> <p><code>at</code> to set the location of the tic-marks
</p>
</li>
<li> <p><code>tic</code> One of these partially matched values: &quot;through&quot;, &quot;in&quot;, &quot;out&quot;, or &quot;none&quot;, to choose a tic-mark placement/length that is different from the default &quot;through and out&quot;. 
</p>
</li></ul>

</td></tr>
<tr><td><code id="plot_+3A_pax">pax</code></td>
<td>
<p>list with parameters for drawing axes. See the arguments for <code><a href="graphics.html#topic+axis">axis</a></code>. Arguments <code>side</code>, <code>tick</code> and <code>lab</code> can be used to indicate for which of the four axes to draw a line (side), tick-mark, and/or the tick-mark labels. The default is <code>c(1:4)</code> for side and <code>1:2</code> for the other two. If <code>side</code> is changed the other two default to that value. Logical argument <code>retro</code> can be used to use a sexagesimal notation for the labels (degrees/minutes/hemisphere) instead of the standard decimal notation</p>
</td></tr>  
<tr><td><code id="plot_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot</p>
</td></tr>
<tr><td><code id="plot_+3A_smooth">smooth</code></td>
<td>
<p>logical. If <code>TRUE</code> the cell values are smoothed (only if a continuous legend is used)</p>
</td></tr>
<tr><td><code id="plot_+3A_range">range</code></td>
<td>
<p>numeric. minimum and maximum values to be used for the continuous legend </p>
</td></tr>
<tr><td><code id="plot_+3A_levels">levels</code></td>
<td>
<p>character. labels for the legend when <code>type="classes"</code> </p>
</td></tr>
<tr><td><code id="plot_+3A_all_levels">all_levels</code></td>
<td>
<p>logical. If <code>TRUE</code>, the legend shows all levels of a categorical raster, even if they are not present in the data</p>
</td></tr>
<tr><td><code id="plot_+3A_breaks">breaks</code></td>
<td>
<p>numeric. Either a single number to indicate the number of breaks desired, or the actual breaks. When providing this argument, the default legend becomes &quot;interval&quot;</p>
</td></tr>
<tr><td><code id="plot_+3A_breakby">breakby</code></td>
<td>
<p>character or function. Either &quot;eqint&quot; for equal interval breaks, &quot;cases&quot; for equal quantile breaks. If a function is supplied it should take a single argument (a vector of values) and create groups</p>
</td></tr>
<tr><td><code id="plot_+3A_fun">fun</code></td>
<td>
<p>function to be called after plotting each SpatRaster layer to add something to each map (such as text, legend, lines). For example, with SpatVector <code>v</code>, you could do <code>fun=function() lines(v)</code>. The function may have one argument, representing the layer that is plotted (1 to the number of layers) </p>
</td></tr>  
<tr><td><code id="plot_+3A_colna">colNA</code></td>
<td>
<p>character. color for the NA values</p>
</td></tr>
<tr><td><code id="plot_+3A_alpha">alpha</code></td>
<td>
<p>Either a single numeric between 0 and 1 to set the transparency for all colors (0 is transparent, 1 is opaque) or a SpatRaster with values between 0 and 1 to set the transparency by cell. To set the transparency for a given color, set it to the colors directly</p>
</td></tr>
<tr><td><code id="plot_+3A_sort">sort</code></td>
<td>
<p>logical. If <code>TRUE</code> legends with categorical values are sorted. If <code>x</code> is a <code>SpatVector</code> you can also supply a vector of the unique values, in the order in which you want them to appear in the legend</p>
</td></tr>
<tr><td><code id="plot_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. If <code>TRUE</code>, legends are sorted in decreasing order</p>
</td></tr>
<tr><td><code id="plot_+3A_grid">grid</code></td>
<td>
<p>logical. If <code>TRUE</code> grid lines are drawn. Their properties such as type and color can be set with the <code>pax</code> argument</p>
</td></tr>
<tr><td><code id="plot_+3A_nc">nc</code></td>
<td>
<p>positive integer. Optional. The number of columns to divide the plotting device in (when plotting multiple layers)</p>
</td></tr>
<tr><td><code id="plot_+3A_nr">nr</code></td>
<td>
<p>positive integer. Optional. The number of rows to divide the plotting device in (when plotting multiple layers)</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>character. Main plot titles (one for each layer to be plotted). You can use arguments <code>cex.main</code>, <code>font.main</code>, <code>col.main</code> to change the appearance; and <code>loc.main</code> to change the location of the main title (either two coordinates, or a character value such as &quot;topleft&quot;)</p>
</td></tr>
<tr><td><code id="plot_+3A_maxnl">maxnl</code></td>
<td>
<p>positive integer. Maximum number of layers to plot (for a multi-layer object)</p>
</td></tr>
<tr><td><code id="plot_+3A_add">add</code></td>
<td>
<p>logical. If <code>TRUE</code> add the object to the current plot</p>
</td></tr>
<tr><td><code id="plot_+3A_ext">ext</code></td>
<td>
<p>SpatExtent. Can be use instead of xlim and ylim to set the extent of the plot</p>
</td></tr>
<tr><td><code id="plot_+3A_reset">reset</code></td>
<td>
<p>logical. If <code>TRUE</code> add the margins (see argument <code>mar</code>) are reset to what they were before calling plot; doing so may affect the display of additional objects that are added to the map (e.g. with  <code><a href="#topic+lines">lines</a></code></p>
</td></tr>
<tr><td><code id="plot_+3A_values">values</code></td>
<td>
<p>Either a vector with values to be used for plotting or a two-column data.frame, where the first column matches a variable in <code>x</code> and the second column has the values to be plotted</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>plot("SpatRaster", "numeric")</code> and additional graphical arguments</p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="#topic+points">points</a>, <a href="#topic+lines">lines</a>, <a href="#topic+polys">polys</a>, <a href="#topic+image">image</a></code>
</p>
<p>Add map elements: <code><a href="#topic+text">text</a>, <a href="#topic+sbar">sbar</a>, <a href="#topic+north">north</a>, <a href="#topic+add_legend">add_legend</a>, <a href="#topic+add_box">add_box</a></code>
</p>
<p>plot a <code><a href="#topic+plot+2CSpatGraticule+2Cmissing-method">SpatGraticule</a></code> or <code><a href="#topic+plot+2CSpatExtent+2Cmissing-method">SpatExtent</a></code>, 
</p>
<p>mulitple layers: <code><a href="#topic+plotRGB">plotRGB</a></code>, <code><a href="#topic+panel">panel</a></code>
</p>
<p>other plot types: scatter<code><a href="#topic+scatter">plot</a>, <a href="#topic+hist">hist</a>, <a href="#topic+pairs">pairs</a>, <a href="#topic+density">density</a>, <a href="#topic+persp">persp</a>, <a href="#topic+contour">contour</a>, <a href="#topic+boxplot">boxplot</a>, <a href="#topic+barplot">barplot</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## SpatRaster
f &lt;- system.file("ex/elev.tif", package="terra") 
r &lt;- rast(f)
plot(r)

plot(r, type="interval")

e &lt;- c(6.37, 6.41, 49.9, 50.1)
plot(r, plg=list(ext=e, title="Legend\nTitle", title.cex=0.9), 
		pax=list(side=1:4, retro=TRUE))
north(cbind(5.8, 50.1))	

d &lt;- classify(r, c(100,200,300,400,500,600))
plot(d, type="classes")

plot(d, type="interval", breaks=1:5) 
plot(d, type="interval", breaks=c(1,4,5), plg=list(legend=c("1-4", "4-5"))) 
plot(d, type="classes", xlim=c(5.6, 6.6), 
	plg=list(legend=c("Mr", "Xx", "As", "Zx", "Bb"), x="bottomleft"))


x &lt;- trunc(r/200)
levels(x) &lt;- data.frame(id=0:2, element=c("earth", "wind", "fire"))
plot(x, plg=list(x="topright"),mar=c(2,2,2,2))

oldpar &lt;- par(no.readonly=TRUE)

# two plots with the same legend
dev.new(width=6, height=4, noRStudioGD = TRUE)
par(mfrow=c(1,2))
plot(r, range=c(50,600), mar=c(1,1,1,4))
plot(r/2, range=c(50,600), mar=c(1,1,1,4))

# as we only need one legend:
par(mfrow=c(1,2))
plot(r, range=c(50,600), mar=c(2, 2, 2, 2), plg=list(size=0.9, cex=.8), 
	pax=list(side=1:2, cex.axis=.6), box=FALSE)
#text(182500, 335000, "Two maps, one plot", xpd=NA)
plot(r/2, range=c(50,600), mar=c(2, 2, 2, 2), legend=FALSE, 
	pax=list(side=c(1,4), cex.axis=.6), box=FALSE)

par(oldpar)

# multi-layer with RGB
s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
s
plot(s)
# remove RGB
plot(s*1)
# or use layers
plot(s, 1)
plot(s, 1:3)

# fix legend by linking values and colors

x = rast(nrows = 2, ncols = 2, vals=1)
y = rast(nrows = 2, ncols = 2, vals=c(1,2,2,1))
cols = data.frame(id=1:2, col=c("red", "blue"))
plot(c(x,y), col=cols)

r  = rast(nrows=10, ncols=10, vals=1:100)
dr = data.frame(from=c(5,33,66,150), to=c(33, 66, 95,200), col=rainbow(4))
plot(r, col=dr)

### SpatVector 

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)

plot(v)

plot(v, "NAME_2", col=rainbow(12), border=c("gray", "blue"), lwd=3)

plot(v, 2, pax=list(side=1:2), plg=list(x=6.16, y=50.17, cex=.8), xlim=c(5.7, 6.7))

plot(v, 4, pax=list(side=1:2), plg=list(x=6.2, y=50.2, ncol=2), main="", box=FALSE)
 
plot(v, 1, plg=list(x=5.8, y=49.37, horiz=TRUE, cex=1.1), main="", mar=c(5,2,0.5,0.5))

plot(v, density=1:12, angle=seq(18, 360, 20), col=rainbow(12))


plot(v, "AREA", type="interval", breaks=3, mar=c(3.1, 3.1, 2.1, 3.1),
  plg=list(x="topright"), main="")

plot(v, "AREA", type="interval", breaks=c(0,200,250,350), 
	mar=c(2,2,2,2), xlim=c(5.7, 6.75),
	plg=list(legend=c("&lt;200", "200-250", "&gt;250"), cex=1, bty="o", 
	x=6.3, y=50.15, box.lwd=2, bg="light yellow", title="My legend"))

</code></pre>

<hr>
<h2 id='plot_extent'>Plot a SpatExtent</h2><span id='topic+plot+2CSpatExtent+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a SpatExtent. Use <code><a href="#topic+lines">lines</a></code> to add a SpatExtent to an existing map.
</p>
<p>See <code><a href="#topic+plot">plot</a></code> for plotting other object types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatExtent,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_extent_+3A_x">x</code></td>
<td>
<p>SpatExtent</p>
</td></tr>
<tr><td><code id="plot_extent_+3A_y">y</code></td>
<td>
<p>missing</p>
</td></tr>
<tr><td><code id="plot_extent_+3A_...">...</code></td>
<td>
<p>additional graphical arguments for lines</p>
</td></tr>  
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast()
plot(ext(r))
</code></pre>

<hr>
<h2 id='plot_graticule'>Plot a graticule</h2><span id='topic+plot+2CSpatGraticule+2Cmissing-method'></span><span id='topic+lines+2CSpatGraticule+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plot a SpatGraticule. You can create a SpatGraticule with <code><a href="#topic+graticule">graticule</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatGraticule,missing'
plot(x, y, background=NULL, col="black", mar=NULL, labels=TRUE,
	retro=FALSE, lab.loc=c(1,1), lab.lon=NULL, lab.lat=NULL, lab.cex=0.65, 
	lab.col="black", off.lat=0.25, off.lon=0.25, box=FALSE, box.col="black",
	add=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_graticule_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_y">y</code></td>
<td>
<p>missing or positive integer or name indicating the layer(s) to be plotted</p>
</td></tr>  
<tr><td><code id="plot_graticule_+3A_background">background</code></td>
<td>
<p>background color. If NULL, no background is drawn</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_mar">mar</code></td>
<td>
<p>numeric vector of length 4 to set the margins of the plot. To make space for the legend you may use something like <code>c(3.1, 3.1, 2.1, 7.1)</code>. To fill the plotting canvas, you can use <code>c(0,0,0,0</code>. Use <code>NA</code> to not set the margins</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_col">col</code></td>
<td>
<p>character. Color for the graticule lines</p>
</td></tr> 
<tr><td><code id="plot_graticule_+3A_labels">labels</code></td>
<td>
<p>logical. If <code>TRUE</code>, show graticule labels</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_retro">retro</code></td>
<td>
<p>logical. If <code>TRUE</code>, show &quot;retro&quot; instead of decimal labels with the graticule</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_lab.loc">lab.loc</code></td>
<td>
<p>numeric. The first number indicates where the longitude graticule labels should be drawn (1=bottom, 2=top, NA=not drawn, any other number=top and bottom). The second number indicates where the latitude graticule labels should be drawn (1=left, 2=right, NA=not drawn, any other number=left and right)</p>
</td></tr>	
<tr><td><code id="plot_graticule_+3A_lab.lon">lab.lon</code></td>
<td>
<p>positive integers between 1 and the number of labels, indicating which longitude graticule labels should be included</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_lab.lat">lab.lat</code></td>
<td>
<p>positive integers between 1 and the number of labels, indicating which latitude graticule labels should be included</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_lab.cex">lab.cex</code></td>
<td>
<p>double. size of the label font</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_lab.col">lab.col</code></td>
<td>
<p>character. color of the labels</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_off.lon">off.lon</code></td>
<td>
<p>numeric. longitude labels offset</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_off.lat">off.lat</code></td>
<td>
<p>numeric. latitude labels offset</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_box">box</code></td>
<td>
<p>logical. If <code>TRUE</code>, the outer lines of the graticule are drawn on top with a sold line <code>lty=1</code></p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_box.col">box.col</code></td>
<td>
<p>character. color of the outer lines of the graticule if <code>box=TRUE</code></p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_add">add</code></td>
<td>
<p>logical. Add the graticule to the current plot?</p>
</td></tr>
<tr><td><code id="plot_graticule_+3A_...">...</code></td>
<td>
<p>additional graphical arguments passed to <code><a href="#topic+lines">lines</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+graticule">graticule</a></code>, <code><a href="#topic+plot">plot</a></code>, 
<code><a href="#topic+points">points</a></code>, <code><a href="#topic+lines">lines</a></code>, <code><a href="#topic+polys">polys</a></code>, <code><a href="#topic+image">image</a></code>, <code>scatter<a href="#topic+scatter">plot</a></code>, 
scale bar: <code><a href="#topic+sbar">sbar</a></code>, north arrow: <code><a href="#topic+north">north</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- graticule(60, 30, crs="+proj=robin")

plot(g, background="azure", col="red", lty=2, box=TRUE)
plot(g, background="azure", col="light gray", lab.loc=c(1,2), 
		lab.lon=c(2,4,6), lab.lat=3:5, lty=3, retro=TRUE)
</code></pre>

<hr>
<h2 id='plotRGB'>Red-Green-Blue plot of a multi-layered SpatRaster</h2><span id='topic+plotRGB'></span><span id='topic+plotRGB+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Make a Red-Green-Blue plot based on three layers in a SpatRaster. The layers (sometimes referred to as &quot;bands&quot; because they may represent different bandwidths in the electromagnetic spectrum) are combined such that they represent the red, green and blue channel. This function can be used to make &quot;true&quot; (or &quot;false&quot;) color images from Landsat and other multi-spectral satellite images. 
</p>
<p>Note that the margins of the plot are set to zero (no axes or titles are visible) but can be set with the <code>mar</code> argument. 
</p>
<p>An alternative way to plot RGB images is to first use <code><a href="#topic+colorize">colorize</a></code> to create a single layer SpatRaster with a color-table and then use <code><a href="#topic+plot">plot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
plotRGB(x, r=1, g=2, b=3, a=NULL, scale=NULL, mar=0, 
		stretch=NULL, smooth=TRUE, colNA="white", alpha=NULL, bgalpha=NULL, 
		zlim=NULL, zcol=FALSE, axes=FALSE ,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRGB_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_r">r</code></td>
<td>
<p>integer between 1 and <code>nlyr(x)</code>. Layer to use as the Red channel</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_g">g</code></td>
<td>
<p>integer between 1 and <code>nlyr(x)</code>. Layer to use as the Green channel</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_b">b</code></td>
<td>
<p>integer between 1 and <code>nlyr(x)</code>. Layer to use as the Blue channel</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_a">a</code></td>
<td>
<p>NULL or integer between 1 and <code>nlyr(x)</code>. Layer to use as the alpha (transparency) channel. If not NULL, argument <code>alpha</code> is ignored</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_scale">scale</code></td>
<td>
<p>integer. Maximum (possible) value in the three channels. Defaults to 255 or to the maximum value of <code>x</code> if that is known and larger than 255</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_mar">mar</code></td>
<td>
<p>numeric vector recycled to length 4 to set the margins of the plot. Use <code>mar=NULL</code> or <code>mar=NA</code> to not set the margins</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_stretch">stretch</code></td>
<td>
<p>character. Option to stretch the values to increase contrast: &quot;lin&quot; (linear) or &quot;hist&quot; (histogram). The linear stretch uses <code><a href="#topic+stretch">stretch</a></code> with arguments <code>minq=0.02</code> and <code>maxq=0.98</code></p>
</td></tr>
<tr><td><code id="plotRGB_+3A_smooth">smooth</code></td>
<td>
<p>logical. If <code>TRUE</code>, smooth the image when drawing to get the appearance of a higher spatial resolution</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_colna">colNA</code></td>
<td>
<p>color. The color used for cells that have NA values</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_alpha">alpha</code></td>
<td>
<p>transparency. Integer between 0 (transparent) and 255 (opaque)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_bgalpha">bgalpha</code></td>
<td>
<p>Background transparency. Integer between 0 (transparent) and 255 (opaque)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_zlim">zlim</code></td>
<td>
<p>numeric vector of length 2. Range of values to plot (optional). If this is set, and <code>stretch="lin"</code> is used, then the values are stretched within the range of <code>zlim</code>. This allows creating consistent coloring between SpatRasters with different cell-value ranges, even when stretching the colors for improved contrast</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_zcol">zcol</code></td>
<td>
<p>logical. If <code>TRUE</code> the values outside the range of zlim get the color of the extremes of the range. Otherwise, the values outside the zlim range get the color of <code>NA</code> values (see argument &quot;colNA&quot;)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_axes">axes</code></td>
<td>
<p>logical. If <code>TRUE</code> axes are drawn (and arguments such as <code>main="title"</code> will be honored)</p>
</td></tr>
<tr><td><code id="plotRGB_+3A_...">...</code></td>
<td>
<p>graphical parameters as in <code><a href="#topic+plot">plot</a></code>&lt;SpatRaster-method&gt;</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+plot">plot</a></code>, <code><a href="#topic+colorize">colorize</a></code>, <code><a href="#topic+RGB">RGB</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- rast(system.file("ex/logo.tif", package="terra"))   
plotRGB(b)
plotRGB(b, mar=2)
plotRGB(b, 3, 2, 1)

b[1000:2000] &lt;- NA
plotRGB(b, 3, 2, 1, stretch="hist")
</code></pre>

<hr>
<h2 id='prcomp'>SpatRaster PCA with prcomp</h2><span id='topic+prcomp'></span><span id='topic+prcomp+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute principal components for SpatRaster layers. This method may be preferred to <code><a href="#topic+princomp">princomp</a></code> for its greater numerical accuracy. However, it is slower and for very large rasters it can only be done with a sample. This may be good enough but see <code><a href="#topic+princomp">princomp</a></code> if you want to use all values. Unlike <code><a href="#topic+princomp">princomp</a></code>, in this method the sample variances are used with <code>n-1</code> as the denominator.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
prcomp(x, retx=TRUE, center=TRUE, scale.=FALSE, 
		tol=NULL, rank.=NULL, maxcell=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prcomp_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="prcomp_+3A_retx">retx</code></td>
<td>
<p>a logical value indicating whether the rotated variables should be returned</p>
</td></tr>
<tr><td><code id="prcomp_+3A_center">center</code></td>
<td>
<p>a logical value indicating whether the variables should be shifted to be zero centered. Alternately, a vector of length equal the number of columns of x can be supplied. The value is passed to <code><a href="#topic+scale">scale</a></code></p>
</td></tr>
<tr><td><code id="prcomp_+3A_scale.">scale.</code></td>
<td>
<p>a logical value indicating whether the variables should be scaled to have unit variance before the analysis takes place. The default is FALSE for consistency with S, but in general scaling is advisable. Alternatively, a vector of length equal the number of columns of x can be supplied. The value is passed to <code><a href="#topic+scale">scale</a></code></p>
</td></tr>
<tr><td><code id="prcomp_+3A_tol">tol</code></td>
<td>
<p>a value indicating the magnitude below which components should be omitted. (Components are omitted if their standard deviations are less than or equal to tol times the standard deviation of the first component.) With the default null setting, no components are omitted (unless <code>rank.</code> is specified less than <code>min(dim(x))</code>). Other settings for <code>tol</code> could be <code>tol = 0</code> or <code>tol = sqrt(.Machine$double.eps)</code>, which would omit essentially constant components</p>
</td></tr>
<tr><td><code id="prcomp_+3A_rank.">rank.</code></td>
<td>
<p>optionally, a number specifying the maximal rank, i.e., maximal number of principal components to be used. Can be set as alternative or in addition to tol, useful notably when the desired rank is considerably smaller than the dimensions of the matrix</p>
</td></tr>
<tr><td><code id="prcomp_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. The maximum number of cells to be used. If this is smaller than ncell(x), a regular sample of <code>x</code> is used</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>prcomp object
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+princomp">princomp</a></code>, <code><a href="stats.html#topic+prcomp">prcomp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/logo.tif", package = "terra")
r &lt;- rast(f)
pca &lt;- prcomp(r)
x &lt;- predict(r, pca)

# use "index" to get a subset of the components
p &lt;- predict(r, pca, index=1:2)

</code></pre>

<hr>
<h2 id='predict'>Spatial model predictions</h2><span id='topic+predict'></span><span id='topic+predict+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Make a SpatRaster with predictions from a fitted model object (for example, obtained with <code>glm</code> or <code>randomForest</code>). The first argument is a SpatRaster object with the predictor variables. The <code><a href="#topic+names">names</a></code> in the SpatRaster should exactly match those expected by the model. Any regression like model for which a predict method has been implemented (or can be implemented) can be used. 
</p>
<p>The method should work if the model's predict function returns a vector, matrix or data.frame (or a list that can be coerced to a data.frame). In other cases it may be necessary to provide a custom &quot;predict&quot; function that wraps the model's predict function to return the values in the required form. See the examples.
</p>
<p>This approach of using model predictions is commonly used in remote sensing (for the classification of satellite images) and in ecology, for species distribution modeling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
predict(object, model, fun=predict, ..., const=NULL, na.rm=FALSE,
          index=NULL, cores=1, cpkgs=NULL, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="predict_+3A_model">model</code></td>
<td>
<p>fitted model of any class that has a &quot;predict&quot; method (or for which you can supply a similar method as <code>fun</code> argument. E.g. glm, gam, or randomForest</p>
</td></tr>
<tr><td><code id="predict_+3A_fun">fun</code></td>
<td>
<p>function. The predict function that takes <code>model</code> as first argument. The default value is <code>predict</code>, but can be replaced with e.g. predict.se (depending on the type of model), or your own custom function</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code></p>
</td></tr>    
<tr><td><code id="predict_+3A_const">const</code></td>
<td>
<p>data.frame. Can be used to add a constant value as a predictor variable so that you do not need to make a SpatRaster layer for it</p>
</td></tr>
<tr><td><code id="predict_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells with <code>NA</code> values in the any of the layers of <code>x</code> are removed from the computation (even if the <code>NA</code> cell is in a layer that is not used as a variable in the model). This option prevents errors with models that cannot handle <code>NA</code> values when makeing predictions. In most other cases this will not affect the output. However, there are some models that return predicted values even if some (or all) variables are <code>NA</code> </p>
</td></tr>
<tr><td><code id="predict_+3A_index">index</code></td>
<td>
<p>integer or character. Can be used to to select a subset of the model output variables</p>
</td></tr>
<tr><td><code id="predict_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used</p>
</td></tr>
<tr><td><code id="predict_+3A_cpkgs">cpkgs</code></td>
<td>
<p>character. The package(s) that need to be loaded on the nodes to be able to run the model.predict function (see examples)</p>
</td></tr>
<tr><td><code id="predict_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="predict_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="predict_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+interpolate">interpolate</a></code> for spatial model prediction </p>


<h3>Examples</h3>

<pre><code class='language-R'>logo &lt;- rast(system.file("ex/logo.tif", package="terra"))   
names(logo) &lt;- c("red", "green", "blue")
p &lt;- matrix(c(48, 48, 48, 53, 50, 46, 54, 70, 84, 85, 74, 84, 95, 85, 
   66, 42, 26, 4, 19, 17, 7, 14, 26, 29, 39, 45, 51, 56, 46, 38, 31, 
   22, 34, 60, 70, 73, 63, 46, 43, 28), ncol=2)

a &lt;- matrix(c(22, 33, 64, 85, 92, 94, 59, 27, 30, 64, 60, 33, 31, 9,
   99, 67, 15, 5, 4, 30, 8, 37, 42, 27, 19, 69, 60, 73, 3, 5, 21,
   37, 52, 70, 74, 9, 13, 4, 17, 47), ncol=2)

xy &lt;- rbind(cbind(1, p), cbind(0, a))

# extract predictor values for points
e &lt;- extract(logo, xy[,2:3])

# combine with response (excluding the ID column)
v &lt;- data.frame(cbind(pa=xy[,1], e))

#build a model, here with glm 
model &lt;- glm(formula=pa~., data=v)

#predict to a raster
r1 &lt;- predict(logo, model)

plot(r1)
points(p, bg='blue', pch=21)
points(a, bg='red', pch=21)

# logistic regression
model &lt;- glm(formula=pa~., data=v, family="binomial")
r1log &lt;- predict(logo, model, type="response")

# to get the probability and standard error
r1se &lt;- predict(logo, model, se.fit=TRUE)

# or provide a custom predict function

predfun &lt;- function(model, data) {
  v &lt;- predict(model, data, se.fit=TRUE)
  cbind(p=as.vector(v$fit), se=as.vector(v$se.fit))
}

r2 &lt;- predict(logo, model, fun=predfun)

### principal components of a SpatRaster
pca &lt;- prcomp(logo)

# or use sampling if you have a large raster 
# and cannot process all cell values
sr &lt;- spatSample(logo, 100000, "regular")
pca &lt;- prcomp(sr)

x &lt;- predict(logo, pca)
plot(x)

## parallelization
## Not run: 
## simple case with GLM 
model &lt;- glm(formula=pa~., data=v)
p &lt;- predict(logo, model, cores=2)

## The above does not work with a model from a contributed
## package, as the package needs to be loaded in each core. 
## Below are three approaches to deal with that 

library(randomForest)
rfm &lt;- randomForest(formula=pa~., data=v)

## approach 0 (not parallel) 
rp0 &lt;- predict(logo, rfm)

## approach 1, use the "cpkgs" argument 
rp1 &lt;- predict(logo, rfm, cores=2, cpkgs="randomForest")

## approach 2, write a custom predict function that loads the package
rfun &lt;- function(mod, dat, ...) {
	library(randomForest)
	predict(mod, dat, ...)
}
rp2 &lt;- predict(logo, rfm, fun=rfun, cores=2)

## approach 3, write a parallelized custom predict function 
rfun &lt;- function(mod, dat, ...) {
	ncls &lt;- length(cls)
	nr &lt;- nrow(dat)
	s &lt;- split(dat, rep(1:ncls, each=ceiling(nr/ncls), length.out=nr))
	unlist(  parallel::clusterApply(cls, s, function(x, ...) predict(mod, x, ...))  )
}

library(parallel)
cls &lt;- parallel::makeCluster(2)
parallel::clusterExport(cls, c("rfm", "rfun", "randomForest"))
rp3 &lt;- predict(logo, rfm, fun=rfun)
parallel::stopCluster(cls)

plot(c(rp0, rp1, rp2, rp3))


### with two output variables (probabilities for each class)
v$pa &lt;- as.factor(v$pa)
rfm2 &lt;- randomForest(formula=pa~., data=v)
rfp &lt;- predict(logo, rfm2, cores=2, type="prob", cpkgs="randomForest")

## End(Not run)

</code></pre>

<hr>
<h2 id='princomp'>SpatRaster PCA with princomp</h2><span id='topic+princomp'></span><span id='topic+princomp+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute principal components for SpatRaster layers. This method can use all values to compute the principal components, even for very large rasters. This is because it computes the covariance matrix by processing the data in chunks, if necessary, using <code><a href="#topic+layerCor">layerCor</a></code>. The population covariance is used (not the sample, with <code>n-1</code> denominator, covariance). 
</p>
<p>Alternatively, you can specify <code>maxcell</code> or sample raster values to a data.frame to speed up calculations for very large rasters (see the examples below). 
</p>
<p>See <code><a href="#topic+princomp">princomp</a></code> for an alternative method that has higher numerical accuracy, but is slower, and for very large rasters can only be accomplished with a sample since all values must be read into memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
princomp(x, cor=FALSE, fix_sign=TRUE, use="pairwise.complete.obs", maxcell=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="princomp_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="princomp_+3A_cor">cor</code></td>
<td>
<p>logical. If <code>FALSE</code>, the covariance matrix is used. Otherwise the correlation matrix is used</p>
</td></tr>   
<tr><td><code id="princomp_+3A_fix_sign">fix_sign</code></td>
<td>
<p>logical.  If <code>TRUE</code>, the signs of the loadings and scores are chosen so that the first element of each loading is non-negative</p>
</td></tr>  
<tr><td><code id="princomp_+3A_use">use</code></td>
<td>
<p>character. To decide how to handle missing values. This must be (an abbreviation of) one of the strings &quot;everything&quot;, &quot;complete.obs&quot;, &quot;pairwise.complete.obs&quot;, or &quot;masked.complete&quot;. With &quot;pairwise.complete.obs&quot;, the covariance between a pair of layers is computed for all cells that are not <code>NA</code> in that pair. Therefore, it may be that the (number of) cells used varies between pairs. The benefit of this approach is that all available data is used. Use &quot;complete.obs&quot;, if you want to only use the values from cells that are not <code>NA</code> in any of the layers. By using &quot;masked.complete&quot; you indicate that all layers have NA values in the same cells</p>
</td></tr>
<tr><td><code id="princomp_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. The maximum number of cells to be used. If this is smaller than ncell(x), a regular sample of <code>x</code> is used</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>princomp object
</p>


<h3>Author(s)</h3>

<p>Alex Ilich and Robert Hijmans, based on a similar method by Benjamin Leutner</p>


<h3>See Also</h3>

 <p><code><a href="#topic+prcomp">prcomp</a></code> <code><a href="stats.html#topic+princomp">princomp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/logo.tif", package = "terra")
r &lt;- rast(f)
pca &lt;- princomp(r)
x &lt;- predict(r, pca)

# use "index" to get a subset of the components
p &lt;- predict(r, pca, index=1:2)

### use princomp directly
pca2 &lt;- princomp(values(r),  fix_sign = TRUE)
p2 &lt;- predict(r, pca2)

### may need to use sampling with a large raster 
### here with prcomp instead of princomp
sr &lt;- spatSample(r, 100000, "regular")
pca3 &lt;- prcomp(sr)
p3 &lt;- predict(r, pca3)
</code></pre>

<hr>
<h2 id='project'>Change the coordinate reference system</h2><span id='topic+project'></span><span id='topic+project+2CSpatVector-method'></span><span id='topic+project+2CSpatRaster-method'></span><span id='topic+project+2CSpatExtent-method'></span><span id='topic+project+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Change the coordinate reference system (&quot;project&quot;) of a SpatVector, SpatRaster or a matrix with coordinates. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
project(x, y, partial = FALSE)

## S4 method for signature 'SpatRaster'
project(x, y, method, mask=FALSE, align=FALSE, res=NULL, 
	origin=NULL, threads=FALSE, filename="", ..., use_gdal=TRUE, by_util = FALSE)

## S4 method for signature 'SpatExtent'
project(x, from, to)

## S4 method for signature 'matrix'
project(x, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector, SpatExtent or matrix (with x and y columns) whose coordinates to project</p>
</td></tr>
<tr><td><code id="project_+3A_y">y</code></td>
<td>
<p>if (<code>x</code> is a SpatRaster, the preferred approach is for <code>y</code> to be a SpatRaster as well, serving as a template for the geometry (extent and resolution) of the output SpatRaster. Alternatively, you can provide a coordinate reference system (CRS) description. 
</p>
<p>You can use the following formats to define coordinate reference systems: WKT,  PROJ.4 (e.g., <code>+proj=longlat +datum=WGS84</code>), or an EPSG code (e.g., <code>"epsg:4326"</code>). But note that the PROJ.4 notation has been deprecated, and you can only use it with the WGS84/NAD83 and NAD27 datums. Other datums are silently ignored. 
</p>
<p>If <code>x</code> is a SpatVector, you can provide a crs definition as discussed above, or any other object from which such a crs can be extracted with <code><a href="#topic+crs">crs</a></code></p>
</td></tr>
<tr><td><code id="project_+3A_partial">partial</code></td>
<td>
<p>logical. If <code>TRUE</code>, geometries that can only partially be represented in the output crs are included in the output</p>
</td></tr>
<tr><td><code id="project_+3A_method">method</code></td>
<td>
<p>character. Method used for estimating the new cell values of a SpatRaster. One of: 
</p>
<p><code>near</code>: nearest neighbor. This method is fast, and it can be the preferred method if the cell values represent classes. It is not a good choice for continuous values. This is used by default if the first layer of <code>x</code> is categorical.
</p>
<p><code>bilinear</code>: bilinear interpolation. This is the default if the first layer of <code>x</code> is numeric (not categorical).
</p>
<p><code>cubic</code>: cubic interpolation.
</p>
<p><code>cubicspline</code>: cubic spline interpolation.
</p>
<p><code>lanczos</code>: Lanczos windowed sinc resampling.
</p>
<p><code>sum</code>: the weighted sum of all non-NA contributing grid cells.	
</p>
<p><code>min, q1, med, q3, max, average, mode, rms</code>: the minimum, first quartile, median, third quartile, maximum, mean, mode, or root-mean-square value of all non-NA contributing grid cells.	
</p>
</td></tr>
<tr><td><code id="project_+3A_mask">mask</code></td>
<td>
<p>logical. If <code>TRUE</code>, mask out areas outside the input extent. For example to avoid data wrapping around the date-line (see example with Robinson projection). To remove cells that are <code>NA</code> in <code>y</code> (if <code>y</code> is a SpatRaster) you can use the <code><a href="#topic+mask">mask</a> method</code> after calling <code>project</code> (this function)</p>
</td></tr>
<tr><td><code id="project_+3A_align">align</code></td>
<td>
<p>logical. If <code>TRUE</code>, and <code>y</code> is a SpatRaster, the template is used for the spatial resolution and origin, but the extent is set such that all of the extent of <code>x</code> is included</p>
</td></tr>
<tr><td><code id="project_+3A_res">res</code></td>
<td>
<p>numeric. Can be used to set the resolution of the output raster if <code>y</code> is a CRS</p>
</td></tr>
<tr><td><code id="project_+3A_origin">origin</code></td>
<td>
<p>numeric. Can be used to set the origin of the output raster if <code>y</code> is a CRS</p>
</td></tr>
<tr><td><code id="project_+3A_threads">threads</code></td>
<td>
<p>logical. If <code>TRUE</code> multiple threads are used (faster for large files)</p>
</td></tr>
<tr><td><code id="project_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="project_+3A_use_gdal">use_gdal</code></td>
<td>
<p>logical. If <code>TRUE</code> the GDAL-warp algorithm is used. Otherwise a slower internal algorithm is used that may be more accurate if there is much variation in the cell sizes of the output raster. Only the <code>near</code> and <code>bilinear</code> algorithms are available for the internal algorithm</p>
</td></tr>
<tr><td><code id="project_+3A_by_util">by_util</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>gdal=TRUE</code>, the GDAL warp utility is used</p>
</td></tr>
<tr><td><code id="project_+3A_from">from</code></td>
<td>
<p>character. Coordinate reference system of <code>x</code></p>
</td></tr>
<tr><td><code id="project_+3A_to">to</code></td>
<td>
<p>character. Output coordinate reference system</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector or SpatRaster
</p>


<h3>Note</h3>

<p>The PROJ.4 notation of coordinate reference systems has been partly deprecated in the GDAL/PROJ library that is used by this function. You can still use this notation, but *only* with the WGS84 datum. Other datums are silently ignored. 
</p>
<p>Transforming (projecting) raster data is fundamentally different from transforming vector data. Vector data can be transformed and back-transformed without loss in precision and without changes in the values. This is not the case with raster data. In each transformation the values for the new cells are estimated in some fashion. Therefore, if you need to match raster and vector data for analysis, you should generally transform the vector data. 
</p>
<p>When using this method with a <code>SpatRaster</code>, the preferable approach is to provide a template <code>SpatRaster</code> as argument <code>y</code>. The template is then another raster dataset that you want your data to align with. If you do not have a template to begin with, you can do <code>project(rast(x), crs)</code> and then manipulate the output to get the template you want. For example, where possible use whole numbers for the extent and resolution so that you do not have to worry about small differences in the future. You can use commands like <code>dim(z) = c(180, 360)</code> or <code>res(z) &lt;- 100000</code>. 
</p>
<p>The output resolution should generally be similar to the input resolution, but there is no &quot;correct&quot; resolution in raster transformation. It is not obvious what this resolution is if you are using lon/lat data that spans a large North-South extent.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crs">crs</a></code>, <code><a href="#topic+resample">resample</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## SpatRaster
a &lt;- rast(ncols=40, nrows=40, xmin=-110, xmax=-90, ymin=40, ymax=60, 
          crs="+proj=longlat +datum=WGS84")
values(a) &lt;- 1:ncell(a)
newcrs="+proj=lcc +lat_1=48 +lat_2=33 +lon_0=-100 +datum=WGS84"
b &lt;- rast(ncols=94, nrows=124, xmin=-944881, xmax=935118, ymin=4664377, ymax=7144377, crs=newcrs)
w &lt;- project(a, b)


## SpatVector
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
crs(v, proj=TRUE)
cat(crs(v), "\n")

project(v, "+proj=moll")


project(v, "EPSG:2169")
</code></pre>

<hr>
<h2 id='quantile'>Quantiles of spatial data</h2><span id='topic+quantile'></span><span id='topic+quantile+2CSpatRaster-method'></span><span id='topic+quantile+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Compute quantiles for each cell across the layers of a SpatRaster. 
</p>
<p>You can use use <code><a href="#topic+global">global</a>(x, fun=quantile)</code> to instead compute quantiles across cells for each layer.
</p>
<p>You can also use this method to compute quantiles of the numeric variables of a SpatVector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
quantile(x, probs=seq(0, 1, 0.25), na.rm=FALSE, filename="", ...) 

## S4 method for signature 'SpatVector'
quantile(x, probs=seq(0, 1, 0.25), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="quantile_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1]</p>
</td></tr>  
<tr><td><code id="quantile_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code>'s are removed from <code>x</code> before the quantiles are computed</p>
</td></tr>
<tr><td><code id="quantile_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="quantile_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatRaster with layers representing quantiles
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+app">app</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
rr &lt;- c(r/2, r, r*2)
qr &lt;- quantile(rr)
qr

## Not run: 
# same but slower
qa &lt;- app(rr, quantile)

## End(Not run)

#quantile by layer instead of by cell
qg &lt;- global(r, quantile)
</code></pre>

<hr>
<h2 id='query'>Query a SpatVectorProxy object</h2><span id='topic+query'></span><span id='topic+query+2CSpatVectorProxy-method'></span>

<h3>Description</h3>

<p>Query a SpatVectorProxy to extract a subset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVectorProxy'
query(x, start=1, n=nrow(x), vars=NULL, where=NULL, 
    extent=NULL, filter=NULL, sql=NULL, what="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_+3A_x">x</code></td>
<td>
<p>SpatVectorProxy</p>
</td></tr>
<tr><td><code id="query_+3A_start">start</code></td>
<td>
<p>positive integer. The record to start reading at</p>
</td></tr>
<tr><td><code id="query_+3A_n">n</code></td>
<td>
<p>positive integer. The number of records requested</p>
</td></tr>
<tr><td><code id="query_+3A_vars">vars</code></td>
<td>
<p>character. Variable names. Must be a subset of <code>names(x)</code></p>
</td></tr>
<tr><td><code id="query_+3A_where">where</code></td>
<td>
<p>character. expression like &quot;NAME_1='California' AND ID &gt; 3&quot; , to subset records. Note that start and n are applied after executing the where statement</p>
</td></tr>
<tr><td><code id="query_+3A_extent">extent</code></td>
<td>
<p>Spat* object. The extent of the object is used as a spatial filter to select the geometries to read. Ignored if <code>filter</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="query_+3A_filter">filter</code></td>
<td>
<p>SpatVector. Used as a spatial filter to select geometries to read (the convex hull is used for lines or points)</p>
</td></tr>
<tr><td><code id="query_+3A_sql">sql</code></td>
<td>
<p>character. Arbitrary SQL statement. If used, arguments &quot;start&quot;, &quot;n&quot;, &quot;vars&quot; and &quot;where&quot; are ignored</p>
</td></tr>
<tr><td><code id="query_+3A_what">what</code></td>
<td>
<p>character indicating what to read. Either <code>""</code> for geometries and attributes, or <code>"geoms"</code> to only read the geometries, <code>"attributes"</code> to only read the attributes (that are returned as a data.frame)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector</p>


<h3>See Also</h3>

<p><code><a href="#topic+vect">vect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f, proxy=TRUE)
v

x &lt;- query(v, vars=c("ID_2", "NAME_2"), start=5, n=2)
x

query(v, vars=c("ID_2", "NAME_1", "NAME_2"), where="NAME_1='Grevenmacher' AND ID_2 &gt; 6")

## with an extent
e &lt;- ext(5.9, 6.3, 49.9, 50) 
x &lt;- query(v, extent=e)

## with polygons
p &lt;- as.polygons(e)
x &lt;- query(v, filter=p)
x
</code></pre>

<hr>
<h2 id='rangeFill'>Fill layers with a range</h2><span id='topic+rangeFill'></span><span id='topic+rangeFill+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Fill layers with cell-varying ranges defined by a start and end SpatRaster. The range must start at 1 and end at a user-defined maximum. 
</p>
<p>For example, for a cell with <code>start=3</code>, <code>end=5</code> and with <code>limit=8</code>, the output for that cell would be <code>0,0,1,1,1,0,0,0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
rangeFill(x, limit, circular=FALSE, filename="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rangeFill_+3A_x">x</code></td>
<td>
<p>SpatRaster with at two layers. The Cell values of the first layer indicate the start of the range (1 based); the cell values are indicate the end of the range</p>
</td></tr>
<tr><td><code id="rangeFill_+3A_limit">limit</code></td>
<td>
<p>numeric &gt; 1. The range size</p>
</td></tr>
<tr><td><code id="rangeFill_+3A_circular">circular</code></td>
<td>
<p>logical. If <code>TRUE</code> the values are considered circular, such as the days of the year. In that case, if first &gt; last the layers used are c(first:limit, 1:last). Otherwise, the range would be considered invalid and <code>NA</code> would be used</p>
</td></tr> 
<tr><td><code id="rangeFill_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="rangeFill_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rapp">rapp</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- y &lt;- rast(ncol=2, nrow=2)
values(x) &lt;- c(NA, 1:3)
values(y) &lt;- c(NA, 4:6)

r &lt;- rangeFill(c(x, y), 8)
</code></pre>

<hr>
<h2 id='rapp'>Range-apply</h2><span id='topic+rapp'></span><span id='topic+rapp+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Apply a function to a range of the layers of a SpatRaster that varies by cell. The range is specified for each cell with one or two SpatRasters (arguments <code>first</code> and <code>last</code>). For either <code>first</code> or <code>last</code> you can use a single number instead. 
</p>
<p>You cannot use single numbers for both <code>first</code> and <code>last</code> because in that case you could use <code><a href="#topic+app">app</a></code> or <code><a href="#topic+Summary-methods">Summary-methods</a></code>, perhaps <code><a href="#topic+subset">subset</a></code>ting the layers of a SpatRaster.
</p>
<p>See <code><a href="#topic+selectRange">selectRange</a></code> to create a new SpatRaster by extracting one or more values starting at a cell-varying layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
rapp(x, first, last, fun, ..., allyrs=FALSE, fill=NA, 
        clamp=FALSE, circular=FALSE, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rapp_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="rapp_+3A_first">first</code></td>
<td>
<p>SpatRaster or positive integer between 1 and nlyr(x), indicating the first layer in the range of layers to be considered</p>
</td></tr>
<tr><td><code id="rapp_+3A_last">last</code></td>
<td>
<p>SpatRaster or positive integer between 1 and nlyr(x), indicating the last layer in the range to be considered</p>
</td></tr>  
<tr><td><code id="rapp_+3A_fun">fun</code></td>
<td>
<p>function to be applied</p>
</td></tr>
<tr><td><code id="rapp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fun</code></p>
</td></tr> 
<tr><td><code id="rapp_+3A_allyrs">allyrs</code></td>
<td>
<p>logical. If <code>TRUE</code>, values for all layers are passed to <code>fun</code> but the values outside of the range are set to <code>fill</code></p>
</td></tr>
<tr><td><code id="rapp_+3A_fill">fill</code></td>
<td>
<p>numeric. The fill value for the values outside of the range, for when <code>allyrs=TRUE</code></p>
</td></tr> 
<tr><td><code id="rapp_+3A_clamp">clamp</code></td>
<td>
<p>logical. If <code>FALSE</code> and the specified range is outside <code>1:nlyr(x)</code> all cells are considered <code>NA</code>. Otherwise, the invalid part of the range is ignored</p>
</td></tr> 
<tr><td><code id="rapp_+3A_circular">circular</code></td>
<td>
<p>logical. If <code>TRUE</code> the values are considered circular, such as the days of the year. In that case, if first &gt; last the layers used are c(first:nlyr(x), 1:last). Otherwise, the range would be considered invalid and <code>NA</code> would be returned</p>
</td></tr> 
<tr><td><code id="rapp_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="rapp_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="rapp_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+selectRange">selectRange</a></code>, <code><a href="#topic+app">app</a></code>, <code><a href="#topic+Summary-methods">Summary-methods</a></code>, <code><a href="#topic+lapp">lapp</a></code>, <code><a href="#topic+tapp">tapp</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=9, nrows=9)
values(r) &lt;- 1:ncell(r)
s &lt;- c(r, r, r, r, r, r)
s &lt;- s * 1:6
s[1:2] &lt;- NA
start &lt;- end &lt;- rast(r)
start[] &lt;- 1:3
end[]   &lt;- 4:6
a &lt;- rapp(s, start, end, fun="mean")
b &lt;- rapp(s, start, 2, fun="mean")

# cumsum from start to nlyr(x). return all layers
r &lt;- rapp(s, start, nlyr(s), cumsum, allyrs=TRUE, fill=0)
# return only the final value
rr &lt;- rapp(s, start, nlyr(s), function(i) max(cumsum(i)))
</code></pre>

<hr>
<h2 id='rast'>Create a SpatRaster</h2><span id='topic+rast'></span><span id='topic+rast+2Cmissing-method'></span><span id='topic+rast+2Ccharacter-method'></span><span id='topic+rast+2CSpatRaster-method'></span><span id='topic+rast+2CSpatRasterDataset-method'></span><span id='topic+rast+2Cdata.frame-method'></span><span id='topic+rast+2Cmatrix-method'></span><span id='topic+rast+2Carray-method'></span><span id='topic+rast+2Clist-method'></span><span id='topic+rast+2CSpatExtent-method'></span><span id='topic+rast+2CSpatVector-method'></span><span id='topic+rast+2CANY-method'></span><span id='topic+rast+2CPackedSpatRaster-method'></span><span id='topic+rast+2Cstars-method'></span><span id='topic+rast+2Cstars_proxy-method'></span>

<h3>Description</h3>

<p>Methods to create a SpatRaster. These objects can be created from scratch, from a filename, or from another object.
</p>
<p>A SpatRaster represents a spatially referenced surface divided into three dimensional cells (rows, columns, and layers). 
</p>
<p>When a SpatRaster is created from a file, it does not load the cell (pixel) values into memory (RAM). It only reads the parameters that describe the geometry of the SpatRaster, such as the number of rows and columns and the coordinate reference system. The actual values will be read when needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
rast(x, subds=0, lyrs=NULL, drivers=NULL, opts=NULL, 
		  win=NULL, snap="near", vsi=FALSE, raw=FALSE)

## S4 method for signature 'missing'
rast(x, nrows=180, ncols=360, nlyrs=1, xmin=-180, xmax=180, 
          ymin=-90, ymax=90, crs, extent, resolution, vals, names, time, units)

## S4 method for signature 'SpatRaster'
rast(x, nlyrs=nlyr(x), names, vals, keeptime=TRUE, 
		  keepunits=FALSE, props=FALSE, tags=FALSE) 

## S4 method for signature 'matrix'
rast(x, type="", crs="", digits=6, extent=NULL)

## S4 method for signature 'data.frame'
rast(x, type="xyz", crs="", digits=6, extent=NULL)

## S4 method for signature 'array'
rast(x, crs="", extent=NULL)

## S4 method for signature 'list'
rast(x, warn=TRUE)

## S4 method for signature 'SpatRasterDataset'
rast(x)

## S4 method for signature 'SpatVector'
rast(x, ...)
									  
## S4 method for signature 'SpatExtent'
rast(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rast_+3A_x">x</code></td>
<td>
<p>filename (character), missing, SpatRaster, SpatRasterDataset, SpatExtent, SpatVector, matrix, array, list of SpatRasters. For other types it will be attempted to create a SpatRaster via ('as(x, &quot;SpatRaster&quot;)'</p>
</td></tr>
<tr><td><code id="rast_+3A_subds">subds</code></td>
<td>
<p>positive integer or character to select a sub-dataset. If zero or &quot;&quot;, all sub-datasets are returned (if possible)</p>
</td></tr>
<tr><td><code id="rast_+3A_lyrs">lyrs</code></td>
<td>
<p>positive integer or character to select a subset of layers (a.k.a. &quot;bands&quot;)</p>
</td></tr>
<tr><td><code id="rast_+3A_drivers">drivers</code></td>
<td>
<p>character. GDAL drivers to consider</p>
</td></tr>
<tr><td><code id="rast_+3A_opts">opts</code></td>
<td>
<p>character. GDAL dataset open options</p>
</td></tr>
<tr><td><code id="rast_+3A_win">win</code></td>
<td>
<p>SpatExtent to set a <code><a href="#topic+window">window</a></code> (area of interest)</p>
</td></tr>
<tr><td><code id="rast_+3A_snap">snap</code></td>
<td>
<p>character. One of &quot;near&quot;, &quot;in&quot;, or &quot;out&quot;, to indicate how the extent of <code><a href="#topic+window">window</a></code> should be &quot;snapped&quot; to <code>x</code></p>
</td></tr>
<tr><td><code id="rast_+3A_vsi">vsi</code></td>
<td>
<p>logical. If <code>TRUE</code>, &quot;\vsicurl\&quot; is prepended to filenames that start with &quot;http&quot;</p>
</td></tr>
<tr><td><code id="rast_+3A_raw">raw</code></td>
<td>
<p>logical. If <code>TRUE</code>, scale and offset values are ignored</p>
</td></tr>
<tr><td><code id="rast_+3A_nrows">nrows</code></td>
<td>
<p>positive integer. Number of rows</p>
</td></tr>
<tr><td><code id="rast_+3A_ncols">ncols</code></td>
<td>
<p>positive integer. Number of columns</p>
</td></tr>
<tr><td><code id="rast_+3A_nlyrs">nlyrs</code></td>
<td>
<p>positive integer. Number of layers</p>
</td></tr>
<tr><td><code id="rast_+3A_xmin">xmin</code></td>
<td>
<p>minimum x coordinate (left border)</p>
</td></tr>
<tr><td><code id="rast_+3A_xmax">xmax</code></td>
<td>
<p>maximum x coordinate (right border)</p>
</td></tr>
<tr><td><code id="rast_+3A_ymin">ymin</code></td>
<td>
<p>minimum y coordinate (bottom border)</p>
</td></tr>
<tr><td><code id="rast_+3A_ymax">ymax</code></td>
<td>
<p>maximum y coordinate (top border)</p>
</td></tr>
<tr><td><code id="rast_+3A_crs">crs</code></td>
<td>
<p>character. Description of the Coordinate Reference System (map projection) in <code>PROJ.4</code>, <code>WKT</code> or <code>authority:code</code> notation. See <code><a href="#topic+crs">crs</a></code>. If this argument is missing, and the x coordinates are within -360 .. 360 and the y coordinates are within -90 .. 90, longitude/latitude is assigned</p>
</td></tr>
<tr><td><code id="rast_+3A_keeptime">keeptime</code></td>
<td>
<p>logical. If <code>FALSE</code> the time stamps are discarded</p>
</td></tr>
<tr><td><code id="rast_+3A_keepunits">keepunits</code></td>
<td>
<p>logical. If <code>FALSE</code> the layer units are discarded</p>
</td></tr>
<tr><td><code id="rast_+3A_props">props</code></td>
<td>
<p>logical. If <code>TRUE</code> the properties (categories and color-table) are kept</p>
</td></tr>
<tr><td><code id="rast_+3A_tags">tags</code></td>
<td>
<p>logical. If <code>TRUE</code> the user specified metadata tags are kept (see <code><a href="#topic+metags">metags</a></code>).</p>
</td></tr>
<tr><td><code id="rast_+3A_extent">extent</code></td>
<td>
<p>object of class SpatExtent. If present, the arguments xmin, xmax, ymin and ymax are ignored</p>
</td></tr>
<tr><td><code id="rast_+3A_resolution">resolution</code></td>
<td>
<p>numeric vector of length 1 or 2 to set the spatial resolution (see <code><a href="#topic+res">res</a></code>). If this argument is used, arguments <code>ncols</code> and <code>nrows</code> are ignored </p>
</td></tr>
<tr><td><code id="rast_+3A_vals">vals</code></td>
<td>
<p>numeric. An optional vector with cell values (if fewer values are provided, these are recycled to reach the number of cells)</p>
</td></tr>
<tr><td><code id="rast_+3A_names">names</code></td>
<td>
<p>character. An optional vector with layer names (must match the number of layers)</p>
</td></tr>
<tr><td><code id="rast_+3A_time">time</code></td>
<td>
<p>time or date stamps for each layer</p>
</td></tr>
<tr><td><code id="rast_+3A_units">units</code></td>
<td>
<p>character. units for each layer</p>
</td></tr>
<tr><td><code id="rast_+3A_type">type</code></td>
<td>
<p>character. If the value is <code>"xyz"</code>, the matrix or data.frame <code>x</code> must have at least two columns, the first with <code>x</code> (or longitude) and the second with <code>y</code> (or latitude) coordinates that represent the centers of raster cells. The additional columns are the values associated with the raster cells. If the value is <code>"xylz"</code>, <code>x</code> must have four columns with the third representing the layer and the fourth the cell values. If the value is <code>""</code>, the resulting SpatRaster will have the same number of rows and columns as <code>x</code>. 
</p>
</td></tr>
<tr><td><code id="rast_+3A_digits">digits</code></td>
<td>
<p>integer to set the precision for detecting whether points are on a regular grid (a low number of digits is a low precision). Only used when <code>type="xyz"</code></p>
</td></tr>
<tr><td><code id="rast_+3A_warn">warn</code></td>
<td>
<p>logical. If <code>TRUE</code>, a warnings about empty rasters may be emitted</p>
</td></tr>
<tr><td><code id="rast_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to the <code>rast,missing-method</code></p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Files are read with the GDAL library. GDAL guesses the file format from the name, and/or tries reading it with different &quot;drivers&quot; (see <code><a href="#topic+gdal">gdal</a></code>) until it succeeds. In very few cases this may cause a file to be opened with the wrong driver, and some information may be lost. For example, when a netCDF file is opened with the HDF5 driver. You can avoid that by using argument <code>rast("filename.ncdf", drivers="NETCDF")</code>
</p>
<p>These classes hold a C++ pointer to the data &quot;reference class&quot; and that creates some limitations. They cannot be recovered from a saved R session either or directly passed to nodes on a computer cluster. Generally, you should use <code><a href="#topic+writeRaster">writeRaster</a></code> to save SpatRaster objects to disk (and pass a filename or cell values ot cluster nodes). Also see <code><a href="#topic+wrap">wrap</a></code>. 
</p>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sds">sds</a></code> to create a SpatRasterDataset (4 dimensions) and <code><a href="#topic+vect">vect</a></code> for vector (points, lines, polygons) data</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a SpatRaster from scratch
x &lt;- rast(nrows=108, ncols=21, xmin=0, xmax=10)

# Create a SpatRaster from a file
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)

s &lt;- rast(system.file("ex/logo.tif", package="terra"))   

# Create a skeleton with no associated cell values
rast(s)

# from a matrix 
m &lt;- matrix(1:25, nrow=5, ncol=5)
rm &lt;- rast(m)

# from a "xyz" data.frame
d &lt;- as.data.frame(rm, xy=TRUE)
head(d)
rast(d, type="xyz")

</code></pre>

<hr>
<h2 id='rasterize'>Rasterize vector data</h2><span id='topic+rasterize'></span><span id='topic+rasterize+2CSpatVector+2CSpatRaster-method'></span><span id='topic+rasterize+2Csf+2CSpatRaster-method'></span><span id='topic+rasterize+2Cmatrix+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Transfer values associated with the geometries of vector data to a raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatRaster'
rasterize(x, y, field="", fun, ..., background=NA, touches=FALSE, update=FALSE, 
	cover=FALSE, by=NULL, filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'matrix,SpatRaster'
rasterize(x, y, values=1, fun, ..., background=NA, update=FALSE, 
	by=NULL, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterize_+3A_x">x</code></td>
<td>
<p>SpatVector or a two-column matrix (point coordinates)</p>
</td></tr>
<tr><td><code id="rasterize_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="rasterize_+3A_field">field</code></td>
<td>
<p>character or numeric. If <code>field</code> is a character, it should a variable name in <code>x</code>. If <code>field</code> is numeric it typically is a single number or a vector of length <code>nrow(x)</code>. The values are recycled to <code>nrow(x)</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_values">values</code></td>
<td>
<p>typically a numeric vector of length <code>1</code> or <code>nrow(x)</code>. If the length is below <code>nrow(x)</code> the values will be recycled to <code>nrow(x)</code>. Only used when <code>x</code> is a matrix. Can also be a matrix or data.frame</p>
</td></tr>
<tr><td><code id="rasterize_+3A_fun">fun</code></td>
<td>
<p>summarizing function for when there are multiple geometries in one cell. For lines and polygons you can only use  <code>"min"</code>, <code>"max"</code>, <code>"mean"</code>, <code>"count"</code> and <code>"sum"</code>
For points you can use any function that returns a single number; for example <code>mean</code>, <code>length</code> (to get a count), <code>min</code> or <code>max</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fun</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_background">background</code></td>
<td>
<p>numeric. Value to put in the cells that are not covered by any of the features of <code>x</code>. Default is <code>NA</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_touches">touches</code></td>
<td>
<p>logical. If <code>TRUE</code>, all cells touched by lines or polygons are affected, not just those on the line render path, or whose center point is within the polygon. If <code>touches=TRUE</code>, <code>add</code> cannot be <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_update">update</code></td>
<td>
<p>logical. If <code>TRUE</code>, the values of the input SpatRaster are updated</p>
</td></tr>
<tr><td><code id="rasterize_+3A_cover">cover</code></td>
<td>
<p>logical. If <code>TRUE</code> and the geometry of <code>x</code> is polygons, the fraction of a cell that is covered by the polygons is returned. This is estimated by determining presence/absence of the polygon in at least 100 sub-cells (more of there are very few cells)</p>
</td></tr> 
<tr><td><code id="rasterize_+3A_by">by</code></td>
<td>
<p>character or numeric value(s) to split <code>x</code> into multiple groups. There will be a separate layer for each group returned. If <code>x</code> is a SpatVector, <code>by</code> can be a column number or name. If <code>x</code> is a matrix, <code>by</code> should be a vector that identifies group membership for each row in <code>x</code></p>
</td></tr>
<tr><td><code id="rasterize_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="rasterize_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>  
<tr><td><code id="rasterize_+3A_wopt">wopt</code></td>
<td>
<p>list with additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasterizeGeom">rasterizeGeom</a></code>, <code><a href="#topic+rasterizeWin">rasterizeWin</a></code>, <code><a href="#topic+mask">mask</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(xmin=0, ncols=18, nrows=18)

# generate points
set.seed(1)
p &lt;- spatSample(r, 1000, xy=TRUE, replace=TRUE)

# rasterize points as a matrix
x &lt;- rasterize(p, r, fun=sum)
y &lt;- rasterize(p, r, value=1:nrow(p), fun=max)

# rasterize points as a SpatVector
pv &lt;- vect(p)
xv &lt;- rasterize(pv, r, fun=sum)

# Polygons
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
r &lt;- rast(v, ncols=75, nrows=100)
z &lt;- rasterize(v, r, "NAME_2")
plot(z)
lines(v)
</code></pre>

<hr>
<h2 id='rasterizeGeom'>Rasterize geometric properties of vector data</h2><span id='topic+rasterizeGeom'></span><span id='topic+rasterizeGeom+2CSpatVector+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Rasterization of geometric properties of vector data. You can get the count of the number of geometries in each cell; the area covered by polygons; the length of the lines; or the number of lines that cross the boundary of each cell. See <code><a href="#topic+rasterize">rasterize</a></code> for standard rasterization (of attribute values associated with geometries).
</p>
<p>The area of polygons is intended for summing the area of polygons that are relatively small relative to the raster cells, and for when there may be multiple polygons per cell. See <code>rasterize(fun="sum")</code> for counting large polygons and <code>rasterize(cover=TRUE)</code> to get the fraction that is covered by larger polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatRaster'
rasterizeGeom(x, y, fun="count", unit="m", filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterizeGeom_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="rasterizeGeom_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="rasterizeGeom_+3A_fun">fun</code></td>
<td>
<p>character. &quot;count&quot;, &quot;area&quot;, &quot;length&quot;, or &quot;crosses&quot;</p>
</td></tr>
<tr><td><code id="rasterizeGeom_+3A_unit">unit</code></td>
<td>
<p>character. &quot;m&quot; or &quot;km&quot;</p>
</td></tr>
<tr><td><code id="rasterizeGeom_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="rasterizeGeom_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasterize">rasterize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
r &lt;- rast(v, res=.1)

# length of lines
lns &lt;- as.lines(v)
x &lt;- rasterizeGeom(lns, r, fun="length", "km")

# count of points
set.seed(44)
pts &lt;- spatSample(v, 100)
y &lt;- rasterizeGeom(pts, r)

# area of polygons
pols &lt;- buffer(pts, 1000)
z &lt;- rasterizeGeom(pols, r, fun="area")
</code></pre>

<hr>
<h2 id='rasterizeWin'>Rasterize points with a moving window</h2><span id='topic+rasterizeWin'></span><span id='topic+rasterizeWin+2CSpatVector+2CSpatRaster-method'></span><span id='topic+rasterizeWin+2Cdata.frame+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Rasterize points using a circle (or ellipse) as moving window. For each raster cell, the points (<code>x, y</code>) that fall within the window centered on that cell are considered. A function is used to compute a summary value (e.g. &quot;mean&quot;) for the values (<code>z</code>) associated with these points.
</p>
<p>This can result in much smoother results compared to the standard <code><a href="#topic+rasterize">rasterize</a></code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatRaster'
rasterizeWin(x, y, field, win="circle", pars, fun, ..., cvars=FALSE, 
			  minPoints=1, fill=NA, filename="", wopt=list())

## S4 method for signature 'data.frame,SpatRaster'
rasterizeWin(x, y, win="circle", pars, fun, ..., cvars=FALSE, 
		      minPoints=1, fill=NA, filename="", wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterizeWin_+3A_x">x</code></td>
<td>
<p>SpatVector or matrix with at least three columns ((x, y) coordinates and a variable to be rasterized)</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_field">field</code></td>
<td>
<p>character. field name in SpatVector <code>x</code> with the values to rasterize</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_win">win</code></td>
<td>
<p>character to choose the window type. Can be &quot;circle&quot;, &quot;ellipse&quot;, &quot;rectangle&quot;, or &quot;buffer&quot;</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_pars">pars</code></td>
<td>
<p>parameters to define the window. If <code>win="circle"</code> or <code>win="buffer"</code>, a single number to set the radius of the circle or the width of the buffer. If <code>win="ellipse"</code>, either two numbers (the x and y-axis) or three numbers the axes and a rotation (in degrees). If <code>win="rectangle"</code>, either two (width, height) or three (width, height) and the rotation in degrees. The unit of the radius/width/height/axis parameters is that of the coordinate reference system (it is not expressed as cells). That is, if you have a lon/lat crs, there is no conversion of degrees to meters or vice-versa.</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_fun">fun</code></td>
<td>
<p>function to summarize the values for each cell. If <code>cvars=FALSE</code>, functions must take a numeric vector and return (in all cases) one or more numbers. If <code>cvars=TRUE</code>, and multiple variables are used, the function must take a single argument (a data.frame with the names variables).   
For <code>win="circle"</code> and <code>win="ellipse"</code> there are two additional character values that can be used: <code>"distto"</code> (average distance to the points from the center of the cell) and <code>"distbetween"</code> (average distance between the points inside the window)</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_...">...</code></td>
<td>
<p>additional named arguments passed to <code>fun</code></p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_minpoints">minPoints</code></td>
<td>
<p>numeric. The minimum number of points to use. If fewer points are found in a search ellipse it is considered empty and the fill value is returned</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_fill">fill</code></td>
<td>
<p>numeric. value to use to fill cells with empty search areas</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_cvars">cvars</code></td>
<td>
<p>logical. When using multiple fields, should <code>fun</code> operate on all of them at once? If not, <code>fun</code> is applied to each variable separately</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="rasterizeWin_+3A_wopt">wopt</code></td>
<td>
<p>list with additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rasterize">rasterize</a></code>, <code><a href="#topic+rasterizeGeom">rasterizeGeom</a></code>, <code><a href="#topic+interpNear">interpNear</a></code>, <code><a href="#topic+interpIDW">interpIDW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- rast(ncol=100, nrow=100, crs="local", xmin=0, xmax=50, ymin=0, ymax=50)
set.seed(100)
x &lt;- runif(50, 5, 45)
y &lt;- runif(50, 5, 45)
z &lt;- sample(50)
xyz &lt;- data.frame(x,y,z)

r &lt;- rasterizeWin(xyz, r, fun="count", pars=5)

rfuns &lt;- c("count", "min", "max", "mean")
x &lt;- lapply(rfuns, function(f) rasterizeWin(xyz, r, fun=f, pars=5))
names(x) &lt;- rfuns 
x &lt;- rast(x)
#plot(x)

</code></pre>

<hr>
<h2 id='rcl'>Combine row, column, and layer numbers</h2><span id='topic+rcl'></span><span id='topic+rcl+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get a matrix with the combination of row, column, and layer numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
rcl(x, row=NULL, col=NULL, lyr=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcl_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="rcl_+3A_row">row</code></td>
<td>
<p>positive integer that are row number(s), a list thereof, or NULL for all rows</p>
</td></tr>
<tr><td><code id="rcl_+3A_col">col</code></td>
<td>
<p>as above for columns</p>
</td></tr>
<tr><td><code id="rcl_+3A_lyr">lyr</code></td>
<td>
<p>as above for layers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a list is used for at least one of <code>row</code>, <code>col</code> or <code>lyr</code>, these are evaluated in parallel. That is combinations are made for each list element, not across list elements. If, in this case another argument is not a list it has to have either length 1 (used for all cases) or have the same length as the (longest) list, in which case the value is coerced into a list with <code>as.list</code>
</p>
<p>If multiple arguments are a list but they have different lengths, theyare recycled to the longest list. 
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowColCombine">rowColCombine</a></code>, <code><a href="#topic+cellFromRowCol">cellFromRowCol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rast(ncol=5, nrow=5, nlyr=2)
values(x) &lt;- 1:size(x)

rcl(x, 1, 2:3, 1:2)

i &lt;- rcl(x, 1, list(1:2, 3:4), 1:2)
i

# get the values for these cells
x[i]
</code></pre>

<hr>
<h2 id='readwrite'>Read from, or write to, file</h2><span id='topic+readStart'></span><span id='topic+readStop'></span><span id='topic+readValues'></span><span id='topic+writeStart'></span><span id='topic+writeStop'></span><span id='topic+writeValues'></span><span id='topic+fileBlocksize'></span><span id='topic+blocks'></span><span id='topic+readStart+2CSpatRaster-method'></span><span id='topic+readStop+2CSpatRaster-method'></span><span id='topic+readStart+2CSpatRasterDataset-method'></span><span id='topic+readStop+2CSpatRasterDataset-method'></span><span id='topic+readValues+2CSpatRaster-method'></span><span id='topic+writeStart+2CSpatRaster+2Ccharacter-method'></span><span id='topic+writeStop+2CSpatRaster-method'></span><span id='topic+writeValues+2CSpatRaster+2Cvector-method'></span><span id='topic+blocks+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Methods to read from or write chunks of values to or from a file. These are low level methods for programmers. Use writeRaster if you want to save an entire SpatRaster to file in one step. It is much easier to use. 
</p>
<p>To write chunks, begin by opening a file with <code>writeStart</code>, then write values to it in chunks using the list that is returned by <code>writeStart</code>. When writing is done, close the file with <code>writeStop</code>. 
</p>
<p><code>blocks</code> only returns chunk size information. This can be useful when reading, but not writing, raster data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
readStart(x)

## S4 method for signature 'SpatRaster'
readStop(x)

## S4 method for signature 'SpatRaster'
readValues(x, row=1, nrows=nrow(x), col=1, ncols=ncol(x), mat=FALSE, dataframe=FALSE, ...)

## S4 method for signature 'SpatRaster,character'
writeStart(x, filename="", overwrite=FALSE, n=4, sources="", ...)

## S4 method for signature 'SpatRaster'
writeStop(x)

## S4 method for signature 'SpatRaster,vector'
writeValues(x, v, start, nrows)

## S4 method for signature 'SpatRaster'
blocks(x, n=4)

fileBlocksize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readwrite_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="readwrite_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="readwrite_+3A_v">v</code></td>
<td>
<p>vector with cell values to be written</p>
</td></tr>
<tr><td><code id="readwrite_+3A_start">start</code></td>
<td>
<p>integer. Row number (counting starts at 1) from where to start writing <code>v</code></p>
</td></tr>
<tr><td><code id="readwrite_+3A_row">row</code></td>
<td>
<p>positive integer. Row number to start from, should be between 1 and nrow(x)</p>
</td></tr>
<tr><td><code id="readwrite_+3A_nrows">nrows</code></td>
<td>
<p>positive integer. How many rows?</p>
</td></tr>
<tr><td><code id="readwrite_+3A_col">col</code></td>
<td>
<p>positive integer. Column number to start from, should be between 1 and ncol(x)</p>
</td></tr>
<tr><td><code id="readwrite_+3A_ncols">ncols</code></td>
<td>
<p>positive integer. How many columns? Default is the number of columns left after the start column</p>
</td></tr>
<tr><td><code id="readwrite_+3A_mat">mat</code></td>
<td>
<p>logical. If <code>TRUE</code>, values are returned as a numeric matrix instead of as a vector, except when <code>dataframe=TRUE</code>. If any of the layers of <code>x</code> is a factor, the level index is returned, not the label. Use <code>dataframe=TRUE</code> to get the labels</p>
</td></tr>
<tr><td><code id="readwrite_+3A_dataframe">dataframe</code></td>
<td>
<p>logical. If <code>TRUE</code>, values are returned as a <code>data.frame</code> instead of as a vector (also if matrix is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="readwrite_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="readwrite_+3A_n">n</code></td>
<td>
<p>positive integer indicating how many copies the data may be in memory at any point in time. This is used to determine how many blocks (large) datasets need to be read</p>
</td></tr>
<tr><td><code id="readwrite_+3A_sources">sources</code></td>
<td>
<p>character. Filenames that may not be overwritten because they are used as input to the function. Can be obtained with <code>sources(x)</code></p>
</td></tr>
<tr><td><code id="readwrite_+3A_...">...</code></td>
<td>

<p>For <code>writeStart</code>: additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code>
</p>
<p>For <code>readValues</code>: additional arguments for <code><a href="base.html#topic+data.frame">data.frame</a></code> (and thus only relevant when <code>dataframe=TRUE</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>readValues</code> returns a vector, matrix, or data.frame 
</p>
<p><code>writeStart</code> returns a list that can be used for processing the file in chunks.
</p>
<p>The other methods invisibly return a logical value indicating whether they were successful or not. Their purpose is the side-effect of opening or closing files. 
</p>

<hr>
<h2 id='rectify'>Rectify a SpatRaster</h2><span id='topic+rectify'></span><span id='topic+rectify+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Rectify a rotated SpatRaster into a non-rotated object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
rectify(x, method="bilinear", aoi=NULL, snap=TRUE,
         filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectify_+3A_x">x</code></td>
<td>
<p>SpatRaster to be rectified</p>
</td></tr>
<tr><td><code id="rectify_+3A_method">method</code></td>
<td>
<p>character. Method used to for resampling. See <code><a href="#topic+resample">resample</a></code></p>
</td></tr>
<tr><td><code id="rectify_+3A_aoi">aoi</code></td>
<td>
<p>SpatExtent or SpatRaster to crop <code>x</code> to a smaller area of interest; Using a SpatRaster allowing to set the exact output extent and output resolution</p>
</td></tr>
<tr><td><code id="rectify_+3A_snap">snap</code></td>
<td>
<p>logical. If <code>TRUE</code>, the origin and resolution of the output are the same as would the case when <code>aoi = NULL</code>. Only relevant if <code>aoi</code> is a <code>SpatExtent</code></p>
</td></tr>
<tr><td><code id="rectify_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="rectify_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.rotated">is.rotated</a></code></p>

<hr>
<h2 id='regress'>Cell level regression</h2><span id='topic+regress'></span><span id='topic+regress+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+regress+2CSpatRaster+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Run a regression model for each cell of a SpatRaster. The independent variable can either be defined by a vector, or another SpatRaster to make it spatially variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'SpatRaster,numeric'
regress(y, x, formula=y~x, na.rm=FALSE, cores=1, filename="", overwrite=FALSE, ...)

## S4 method for signature 'SpatRaster,SpatRaster'
regress(y, x, formula=y~x, na.rm=FALSE, cores=1, filename="", overwrite=FALSE, ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regress_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="regress_+3A_x">x</code></td>
<td>
<p>SpatRaster or numeric (of the same length as <code>nlyr(x)</code></p>
</td></tr>
<tr><td><code id="regress_+3A_formula">formula</code></td>
<td>
<p>regression formula in the general form of <code>y ~ x</code>. You can add additional terms such as <code>I(x^2)</code> </p>
</td></tr>
<tr><td><code id="regress_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Remove NA values?</p>
</td></tr>
<tr><td><code id="regress_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object.</p>
</td></tr>
<tr><td><code id="regress_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="regress_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="regress_+3A_...">...</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
x &lt;- regress(s, 1:nlyr(s))
</code></pre>

<hr>
<h2 id='relate'> 
Spatial relationships between geometries
</h2><span id='topic+relate'></span><span id='topic+is.related'></span><span id='topic+relate+2CSpatVector+2CSpatVector-method'></span><span id='topic+relate+2CSpatVector+2Cmissing-method'></span><span id='topic+relate+2CSpatVector+2CSpatExtent-method'></span><span id='topic+relate+2CSpatExtent+2CSpatVector-method'></span><span id='topic+relate+2CSpatExtent+2CSpatExtent-method'></span><span id='topic+relate+2CSpatVector+2CSpatRaster-method'></span><span id='topic+relate+2CSpatRaster+2CSpatVector-method'></span><span id='topic+relate+2CSpatExtent+2CSpatRaster-method'></span><span id='topic+relate+2CSpatRaster+2CSpatExtent-method'></span><span id='topic+relate+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+is.related+2CSpatVector+2CSpatVector-method'></span><span id='topic+is.related+2CSpatVector+2CSpatExtent-method'></span><span id='topic+is.related+2CSpatExtent+2CSpatVector-method'></span><span id='topic+is.related+2CSpatVector+2CSpatRaster-method'></span><span id='topic+is.related+2CSpatRaster+2CSpatVector-method'></span><span id='topic+is.related+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+is.related+2CSpatExtent+2CSpatRaster-method'></span><span id='topic+is.related+2CSpatRaster+2CSpatExtent-method'></span>

<h3>Description</h3>

<p><code>relate</code> returns a logical matrix indicating the presence or absence of a specific spatial relationships between the geometries in <code>x</code> and <code>y</code>. 
</p>
<p><code>is.related</code> returns a logical vector indicating the presence or absence of a specific spatial relationships between <code>x</code> and any of the geometries in <code>y</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatVector'
relate(x, y, relation, pairs=FALSE, na.rm=TRUE)

## S4 method for signature 'SpatVector,missing'
relate(x, y, relation, pairs=FALSE, na.rm=TRUE)

## S4 method for signature 'SpatVector,SpatVector'
is.related(x, y, relation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relate_+3A_x">x</code></td>
<td>
<p>SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="relate_+3A_y">y</code></td>
<td>
<p>missing or as for <code>x</code></p>
</td></tr>
<tr><td><code id="relate_+3A_relation">relation</code></td>
<td>
<p>character. One of &quot;intersects&quot;, &quot;touches&quot;, &quot;crosses&quot;, &quot;overlaps&quot;, &quot;within&quot;, &quot;contains&quot;, &quot;covers&quot;, &quot;coveredby&quot;, &quot;disjoint&quot;. Or a &quot;DE-9IM&quot; string such as &quot;FF*FF****&quot;. See <a href="https://en.wikipedia.org/wiki/DE-9IM">wikipedia</a> or <a href="https://docs.geotools.org/stable/userguide/library/jts/dim9.html">geotools doc</a></p>
</td></tr>
<tr><td><code id="relate_+3A_pairs">pairs</code></td>
<td>
<p>logical. If <code>TRUE</code> a two-column matrix is returned with the indices of the cases where the requested relation is <code>TRUE</code>. This is especially helpful when dealing with many geometries as the returned value is generally much smaller</p>
</td></tr> 
<tr><td><code id="relate_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code> geometries in <code>x</code> for which there is no related geometry in <code>y</code> are omitted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (relate) or vector (is.related)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjacent">adjacent</a></code>, <code><a href="#topic+nearby">nearby</a></code>, <code><a href="#topic+intersect">intersect</a></code>, <code><a href="#topic+crop">crop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# polygons
p1 &lt;- vect("POLYGON ((0 0, 8 0, 8 9, 0 9, 0 0))")
p2 &lt;- vect("POLYGON ((5 6, 15 6, 15 15, 5 15, 5 6))")
p3 &lt;- vect("POLYGON ((8 2, 9 2, 9 3, 8 3, 8 2))")
p4 &lt;- vect("POLYGON ((2 6, 3 6, 3 8, 2 8, 2 6))")
p5 &lt;- vect("POLYGON ((2 12, 3 12, 3 13, 2 13, 2 12))")
p6 &lt;- vect("POLYGON ((10 4, 12 4, 12 7, 11 7, 11 6, 10 6, 10 4))")

p &lt;- rbind(p1, p2, p3, p4, p5, p6)
plot(p, col=rainbow(6, alpha=.5))
lines(p, lwd=2)
text(p)

## relate SpatVectors
relate(p1, p2, "intersects")
relate(p1, p3, "touches")
relate(p1, p5, "disjoint")
relate(rbind(p1, p2), p4, "disjoint")

## relate geometries within SpatVectors
# which are completely separated?
relate(p, relation="disjoint")

# which touch (not overlap or within)?
relate(p, relation="touches")
# which overlap (not merely touch, and not within)?
relate(p, relation="overlaps")
# which are within (not merely overlap)?
relate(p, relation="within")

# do they touch or overlap or are within?
relate(p, relation="intersects")

all(relate(p, relation="intersects") == 
  (relate(p, relation="overlaps") | 
   relate(p, relation="touches") |
   relate(p, relation="within")))

#for polygons, "coveredby" is "within"
relate(p, relation="coveredby")

# polygons, lines, and points 

pp &lt;- rbind(p1, p2)
L1 &lt;- vect("LINESTRING(1 11, 4 6, 10 6)")
L2 &lt;- vect("LINESTRING(8 14, 12 10)")
L3 &lt;- vect("LINESTRING(1 8, 12 14)")
lns &lt;- rbind(L1, L2, L3)
pts &lt;- vect(cbind(c(7,10,10), c(3,5,6)))

plot(pp, col=rainbow(2, alpha=.5))
text(pp, paste0("POL", 1:2), halo=TRUE)
lines(pp, lwd=2)
lines(lns, col=rainbow(3), lwd=4)
text(lns, paste0("L", 1:3), halo=TRUE)
points(pts, cex=1.5)
text(pts, paste0("PT", 1:3), halo=TRUE, pos=4)


relate(lns, relation="crosses")
relate(lns, pp, relation="crosses") 
relate(lns, pp, relation="touches") 
relate(lns, pp, relation="intersects") 

relate(lns, pp, relation="within")
# polygons can contain lines or points, not the other way around
relate(lns, pp, relation="contains") 
relate(pp, lns, relation="contains") 
# points and lines can be covered by polygons
relate(lns, pp, relation="coveredby")

relate(pts, pp, "within")
relate(pts, pp, "touches")
relate(pts, lns, "touches")

</code></pre>

<hr>
<h2 id='rep'>Replicate layers</h2><span id='topic+rep'></span><span id='topic+rep+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Replicate layers in a SpatRaster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
rep(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="rep_+3A_...">...</code></td>
<td>
<p>arguments as in <code><a href="base.html#topic+rep">rep</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
x &lt;- rep(s, 2)
nlyr(x)
names(x)
x
</code></pre>

<hr>
<h2 id='replace_dollar'>Replace with $&lt;-</h2><span id='topic++24+3C-'></span><span id='topic++24+3C-+2CSpatExtent-method'></span><span id='topic++24+3C-+2CSpatVector-method'></span><span id='topic++24+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Replace a layer of a SpatRaster, or an attribute variable of a SpatVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SpatRaster'
x$name &lt;- value

## S4 replacement method for signature 'SpatVector'
x$name&lt;-value

## S4 replacement method for signature 'SpatExtent'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_dollar_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="replace_dollar_+3A_name">name</code></td>
<td>
<p>character. If <code>x</code> is a SpatRaster: layer name. If <code>x</code> is a SpatVector: variable name. If <code>x</code> is a SpatExtent: &quot;xmin&quot;, &quot;xmax&quot;. &quot;ymin&quot; or &quot;ymax&quot;</p>
</td></tr>
<tr><td><code id="replace_dollar_+3A_value">value</code></td>
<td>
<p>if <code>x</code> is a SpatRaster, a SpatRaster for which this <code>TRUE</code>: <code>nlyr(value) == length(i)</code>; if <code>x</code> is a SpatVector, a vector of new values; if <code>x</code> is a SpatExtent a single number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>x</code>
</p>


<h3>See Also</h3>

<p><code> <a href="#topic++5B+5B+3C-">[[&lt;-</a>, <a href="#topic++5B+3C-">[&lt;-</a>, <a href="#topic++24">$</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
v$ID_1 &lt;- LETTERS[1:12]
v$new &lt;- sample(12)
values(v)
</code></pre>

<hr>
<h2 id='replace_layers'>Replace layers or variables</h2><span id='topic++5B+5B+3C-'></span><span id='topic++5B+5B+3C-+2CSpatRaster+2Ccharacter-method'></span><span id='topic++5B+5B+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic++5B+5B+3C-+2CSpatVector+2Ccharacter-method'></span><span id='topic++5B+5B+3C-+2CSpatVector+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Replace the layers of SpatRaster with (layers from) another SpatRaster or replace variables of a SpatVector. You can also create new layers/variables with these methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SpatRaster,numeric'
x[[i]] &lt;- value

## S4 replacement method for signature 'SpatRaster,character'
x[[i]] &lt;- value

## S4 replacement method for signature 'SpatVector,numeric'
x[[i]] &lt;- value

## S4 replacement method for signature 'SpatVector,character'
x[[i]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_layers_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="replace_layers_+3A_i">i</code></td>
<td>
<p>if <code>x</code> is a SpatRaster: layer number(s) of name(s). If <code>x</code> is a SpatVector: variable  number(s) or name(s) (column of the attributes)</p>
</td></tr>
<tr><td><code id="replace_layers_+3A_value">value</code></td>
<td>
<p>if <code>x</code> is a SpatRaster: SpatRaster for which this <code>TRUE</code>: <code>nlyr(value) == length(i)</code>. if <code>x</code> is a SpatVector: vector or data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

<p><code><a href="#topic++24+3C-">$&lt;-</a>, <a href="#topic++5B+3C-">[&lt;-</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># raster
s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
s[["red"]] &lt;- mean(s)
s[[2]] &lt;- sqrt(s[[1]])

# vector
v &lt;- vect(system.file("ex/lux.shp", package="terra"))
v[["ID_1"]] &lt;- 12:1
</code></pre>

<hr>
<h2 id='replace_values'>Replace values of a SpatRaster</h2><span id='topic++5B+3C-'></span><span id='topic++5B+3C-+2CSpatRaster+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CSpatRaster+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CSpatExtent+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+3C-+2CSpatVector+2CANY+2CANY-method'></span><span id='topic++5B+3C-+2CSpatVector+2CANY+2Cmissing-method'></span><span id='topic++5B+3C-+2CSpatVector+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Replace values of a SpatRaster. These are convenience functions for smaller objects only. For larger rasters see <code>link{classify}</code> or <code><a href="#topic+subst">subst</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SpatRaster,ANY,ANY,ANY'
x[i, j, k] &lt;- value

## S4 replacement method for signature 'SpatVector,ANY,ANY'
x[i, j] &lt;- value

## S4 replacement method for signature 'SpatExtent,numeric,missing'
x[i, j] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_values_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="replace_values_+3A_i">i</code></td>
<td>
<p>row numbers. numeric, logical, or missing for all rows. Can also be a SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="replace_values_+3A_j">j</code></td>
<td>
<p>column numbers. numeric, logical or missing for all columns</p>
</td></tr>
<tr><td><code id="replace_values_+3A_k">k</code></td>
<td>
<p>layer number. numeric, logical or missing for all layers</p>
</td></tr>
<tr><td><code id="replace_values_+3A_value">value</code></td>
<td>
<p>numeric, matrix, or data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

<p><code><a href="#topic+classify">classify</a>, <a href="#topic+subst">subst</a>, <a href="#topic+set.values">set.values</a>, <a href="#topic+values">values</a>, <a href="#topic++5B+5B+3C-">[[&lt;-</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## SpatRaster
r &lt;- rast(ncols=5, nrows=5, xmin=0, xmax=5, ymin=0, ymax=5)
r[] &lt;- 1:25
r[1,] &lt;- 5
r[,2] &lt;- 10
r[r&gt;10] &lt;- NA

## SpatVector
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
v[2,2] &lt;- "hello"
v[1,] &lt;- v[10,]
v[,3] &lt;- v[,1]
v[2, "NAME_2"] &lt;- "terra"
head(v, 3)
</code></pre>

<hr>
<h2 id='resample'>Transfer values of a SpatRaster to another one with a different geometry</h2><span id='topic+resample'></span><span id='topic+resample+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>resample transfers values between SpatRaster objects that do not align (have a different origin and/or resolution). See <code><a href="#topic+project">project</a></code> to change the coordinate reference system (crs). 
</p>
<p>If the origin and extent of the input and output are the same, you should consider using these other functions instead: <code><a href="#topic+aggregate">aggregate</a></code>, <code><a href="#topic+disagg">disagg</a></code>, <code><a href="#topic+extend">extend</a></code> or <code><a href="#topic+crop">crop</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
resample(x, y, method, threads=FALSE, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>SpatRaster to be resampled</p>
</td></tr>
<tr><td><code id="resample_+3A_y">y</code></td>
<td>
<p>SpatRaster with the geometry that <code>x</code> should be resampled to</p>
</td></tr>
<tr><td><code id="resample_+3A_method">method</code></td>
<td>
<p>character. Method used for estimating the new cell values. One of: 
</p>
<p><code>near</code>: nearest neighbor. This method is fast, and it can be the preferred method if the cell values represent classes. It is not a good choice for continuous values. This is used by default if the first layer of <code>x</code> is categorical.
</p>
<p><code>bilinear</code>: bilinear interpolation. This is the default if the first layer of <code>x</code> is numeric (not categorical).
</p>
<p><code>cubic</code>: cubic interpolation.
</p>
<p><code>cubicspline</code>: cubic spline interpolation.
</p>
<p><code>lanczos</code>: Lanczos windowed sinc resampling.
</p>
<p><code>sum</code>: the weighted sum of all non-NA contributing grid cells.
</p>
<p><code>min, q1, med, q3, max, average, mode, rms</code>: the minimum, first quartile, median, third quartile, maximum, mean, mode, or root-mean-square value of all non-NA contributing grid cells.
</p>
</td></tr>
<tr><td><code id="resample_+3A_threads">threads</code></td>
<td>
<p>logical. If <code>TRUE</code> multiple threads are used (faster for large files)</p>
</td></tr>
<tr><td><code id="resample_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster 
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+aggregate">aggregate</a></code>, <code><a href="#topic+disagg">disagg</a></code>, <code><a href="#topic+crop">crop</a></code>, <code><a href="#topic+project">project</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r &lt;- rast(nrows=3, ncols=3, xmin=0, xmax=10, ymin=0, ymax=10)
values(r) &lt;- 1:ncell(r)
s &lt;- rast(nrows=25, ncols=30, xmin=1, xmax=11, ymin=-1, ymax=11)
x &lt;- resample(r, s, method="bilinear")

opar &lt;- par(no.readonly =TRUE)
par(mfrow=c(1,2))
plot(r)
plot(x)
par(opar)
</code></pre>

<hr>
<h2 id='rescale'>rescale</h2><span id='topic+rescale'></span><span id='topic+rescale+2CSpatRaster-method'></span><span id='topic+rescale+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Rescale a SpatVector or SpatRaster. This may be useful to make small <code><a href="#topic+inset">inset</a></code> maps or for georeferencing. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
rescale(x, fx=0.5, fy=fx, x0, y0)

## S4 method for signature 'SpatVector'
rescale(x, fx=0.5, fy=fx, x0, y0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>SpatVector or SpatRaster</p>
</td></tr>
<tr><td><code id="rescale_+3A_fx">fx</code></td>
<td>
<p>numeric &gt; 0. The horizontal scaling factor</p>
</td></tr>
<tr><td><code id="rescale_+3A_fy">fy</code></td>
<td>
<p>numeric &gt; 0. The vertical scaling factor</p>
</td></tr>
<tr><td><code id="rescale_+3A_x0">x0</code></td>
<td>
<p>numeric. x-coordinate of the center of rescaling. If missing, the center of the extent of <code>x</code> is used</p>
</td></tr>
<tr><td><code id="rescale_+3A_y0">y0</code></td>
<td>
<p>numeric. y-coordinate of the center of rescaling. If missing, the center of the extent of <code>x</code> is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+t">t</a></code>, <code><a href="#topic+shift">shift</a></code>, <code><a href="#topic+flip">flip</a></code>, <code><a href="#topic+rotate">rotate</a></code>, <code><a href="#topic+inset">inset</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
w &lt;- rescale(v, 0.2)
plot(v)
lines(w, col="red")
</code></pre>

<hr>
<h2 id='RGB'>Layers representing colors</h2><span id='topic+RGB'></span><span id='topic+RGB+2CSpatRaster-method'></span><span id='topic+RGB+3C-'></span><span id='topic+RGB+3C-+2CSpatRaster-method'></span><span id='topic+colorize'></span><span id='topic+colorize+2CSpatRaster-method'></span><span id='topic+has.RGB'></span><span id='topic+has.RGB+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>With <code>RGB</code> you can get or set the layers to be used as Red, Green and Blue when plotting a SpatRaster. Currently, a benefit of this is that <code><a href="#topic+plot">plot</a></code> will send the object to <code><a href="#topic+plotRGB">plotRGB</a></code>. You can also associated the layers with another color space (HSV, HSI or HSL)
</p>
<p>With <code>colorize</code> you can convert a three-layer RGB SpatRaster into other color spaces. You can also convert it into a single-layer SpatRaster with a color-table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
RGB(x)

## S4 replacement method for signature 'SpatRaster'
RGB(x, ..., type="rgb")&lt;-value

## S4 method for signature 'SpatRaster'
colorize(x, to="hsv", alpha=FALSE, stretch=NULL, 
	grays=FALSE, NAzero=FALSE, filename="", overwrite=FALSE, ...)

## S4 method for signature 'SpatRaster'
has.RGB(x, strict=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RGB_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="RGB_+3A_value">value</code></td>
<td>
<p>vector of three (or four) positive integers indicating the layers that are red, green and blue (and optionally a fourth transparency layer). Or <code>NULL</code> to remove the RGB settings</p>
</td></tr>
<tr><td><code id="RGB_+3A_type">type</code></td>
<td>
<p>character. The color space. One of &quot;rgb&quot; &quot;hsv&quot;, &quot;hsi&quot; and &quot;hsl&quot;</p>
</td></tr>
<tr><td><code id="RGB_+3A_to">to</code></td>
<td>
<p>character. The color space to transform the values to. If <code>x</code> has RGB set, you can transform these to &quot;hsv&quot;, &quot;hsi&quot; and &quot;hsl&quot;, or use &quot;col&quot; to create a single layer with a color table. You can also use &quot;rgb&quot; to back transform to RGB</p>
</td></tr>
<tr><td><code id="RGB_+3A_alpha">alpha</code></td>
<td>
<p>logical. Should an alpha (transparency) channel be included? Only used if <code>x</code> has a color-table and <code>to="rgb"</code></p>
</td></tr>
<tr><td><code id="RGB_+3A_stretch">stretch</code></td>
<td>
<p>character. Option to stretch the values to increase contrast: &quot;lin&quot; (linear) or &quot;hist&quot; (histogram). Only used for transforming RGB to col</p>
</td></tr>
<tr><td><code id="RGB_+3A_grays">grays</code></td>
<td>
<p>logical. If <code>TRUE</code>, a gray-scale color-table is created. Only used for transforming RGB to col</p>
</td></tr>
<tr><td><code id="RGB_+3A_nazero">NAzero</code></td>
<td>
<p>logical. If <code>TRUE</code>, NAs are treated as zeros such that a color can be returned if at least one of the three channels has a value. Only used for transforming RGB to (<code>"col"</code>)</p>
</td></tr>
<tr><td><code id="RGB_+3A_strict">strict</code></td>
<td>
<p>logical. If <code>TRUE</code>, the function returns <code>FALSE</code> if a color space such as &quot;hsv&quot;, &quot;hsi&quot; and &quot;hsl&quot; is used</p>
</td></tr>
<tr><td><code id="RGB_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="RGB_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>  
<tr><td><code id="RGB_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
plot(r)
has.RGB(r)
RGB(r) &lt;- NULL
has.RGB(r)
plot(r)
RGB(r) &lt;- c(3,1,2)
plot(r)

RGB(r) &lt;- 1:3
x &lt;- colorize(r, "col")
y &lt;- colorize(r, "hsv")
z &lt;- colorize(y, "rgb")
</code></pre>

<hr>
<h2 id='roll'>Rolling (moving) functions</h2><span id='topic+roll'></span><span id='topic+roll+2CSpatRaster-method'></span><span id='topic+roll+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Compute &quot;rolling&quot; or &quot;moving&quot; values, such as the &quot;rolling average&quot; for each cell in a SpatRaster.
</p>
<p>See <code><a href="#topic+focal">focal</a></code> for spatially moving averages and similar computations. And see <code><a href="#topic+cumsum">cumsum</a></code> and other cum* functions to compute cumulate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
roll(x, n, fun=mean, type="around", circular=FALSE,
			na.rm=FALSE, filename="", ..., wopt=list()) 

## S4 method for signature 'numeric'
roll(x, n, fun=mean, type="around", circular=FALSE, na.rm=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roll_+3A_x">x</code></td>
<td>
<p>SpatRaster or numeric</p>
</td></tr>
<tr><td><code id="roll_+3A_n">n</code></td>
<td>
<p>integer &gt; 1. The size of the &quot;window&quot;, that is, the number of sequential cells to use in <code>fun</code></p>
</td></tr>
<tr><td><code id="roll_+3A_fun">fun</code></td>
<td>
<p>a function like mean, min, max, sum</p>
</td></tr>
<tr><td><code id="roll_+3A_type">type</code></td>
<td>
<p>character. One of &quot;around&quot;, &quot;to&quot;, or &quot;from&quot;. The choice indicates which values should be used in the computation. The focal cell is always used. If type is &quot;around&quot;, <code>(n-1)/2</code> before and after the focal cell are also included. If type = &quot;from&quot;, <code>n-1</code> cells are after the focal cell are included. If type = &quot;to&quot;, <code>n-1</code> cells before the focal cell are included. For example, when using n=3 for element 5 of a vector; &quot;around&quot; used elements 4,5,6; &quot;to&quot; used elements 3,4,5, and &quot;from&quot; uses elements 5,6,7</p>
</td></tr>
<tr><td><code id="roll_+3A_circular">circular</code></td>
<td>
<p>logical. If <code>TRUE</code>, the data are considered to have a circular nature (e.g. days or months of the year), such that there are no missing values before first or after the last value.</p>
</td></tr>
<tr><td><code id="roll_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values should be ignored (by <code>fun</code>)</p>
</td></tr>
<tr><td><code id="roll_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="roll_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code></p>
</td></tr>
<tr><td><code id="roll_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cumsum">cumsum</a></code>, <code><a href="#topic+focal">focal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## numeric
roll(1:12, 3, mean)
roll(1:12, 3, mean, "to")
roll(1:12, 3, mean, circular=TRUE)

## SpatRaster
r &lt;- rast(ncol=2, nrow=2, nlyr=10, vals=1)
r[1,2] = 2
r[2,2] = 4

roll(r, n=3, "sum", "from", na.rm=FALSE) |&gt; values()
roll(r, n=3, "sum", "from", na.rm=TRUE) |&gt; values()
roll(r, n=3, "sum", "from", circular=TRUE) |&gt; values()

roll(r, n=3, "sum", "to", na.rm=TRUE) |&gt; values()

roll(r, n=3, "sum", "around", circular=TRUE) |&gt; values()
</code></pre>

<hr>
<h2 id='rotate'>Rotate data along longitude</h2><span id='topic+rotate'></span><span id='topic+rotate+2CSpatRaster-method'></span><span id='topic+rotate+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Rotate a SpatRaster that has longitude coordinates from 0 to 360, to standard coordinates between -180 and 180 degrees (or vice-versa). Longitude between 0 and 360 is frequently used in global climate models.
</p>
<p>Rotate a SpatVector as for a SpatRaster <code>split=TRUE</code>, or to correct for coordinates that are connected across the date line (and end up at the &quot;other side&quot; of the longitude scale) are reconnected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
rotate(x, left=TRUE, filename="", ...)

## S4 method for signature 'SpatVector'
rotate(x, longitude=0, split=FALSE, left=TRUE, normalize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="rotate_+3A_left">left</code></td>
<td>
<p>logical. If <code>TRUE</code>, rotate to the left, else to the right</p>
</td></tr>
<tr><td><code id="rotate_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="rotate_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="rotate_+3A_longitude">longitude</code></td>
<td>
<p>numeric. The longitude around which to rotate</p>
</td></tr>
<tr><td><code id="rotate_+3A_split">split</code></td>
<td>
<p>logical. Should geometries be split at <code>longitude</code>?</p>
</td></tr>
<tr><td><code id="rotate_+3A_normalize">normalize</code></td>
<td>
<p>logical. Should the output be normalized to longitudes between -180 and 180? See <code><a href="#topic+normalize.longitude">normalize.longitude</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shift">shift</a></code> and <code><a href="#topic+spin">spin</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rast(nrows=9, ncols=18, nl=3, xmin=0, xmax=360)
v &lt;- rep(as.vector(t(matrix(1:ncell(x), nrow=9, ncol=18))), 3)
values(x) &lt;- v
z &lt;- rotate(x)

## Not run: 
#SpatVector
p &lt;- rbind(c(3847903, 1983584 ), c(3847903, 5801864), c(8301883, 5801864), c(8301883, 1983584 ))
p &lt;- vect(p, "polygons", crs="+init=EPSG:3347")
d &lt;- densify(p, 100000)
g &lt;- project(d, "+proj=longlat")

x &lt;- rotate(g, 50)
plot(g)
lines(x, col="red")

## End(Not run)

## rotate countries to 0-360 longitude
#w &lt;- geodata::world(path=".")
#x &lt;- rotate(w, long=0, split=TRUE, left=FALSE)

</code></pre>

<hr>
<h2 id='same.crs'>Compare coordinate reference systems</h2><span id='topic+same.crs'></span>

<h3>Description</h3>

<p>The function takes two coordinate reference system descriptions and compares them for equality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>same.crs(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="same.crs_+3A_x">x</code></td>
<td>
<p>character, SpatRaster, SpatVector, CRS, or other object that returns something intelligible with<code>crs(x)</code></p>
</td></tr>
<tr><td><code id="same.crs_+3A_y">y</code></td>
<td>
<p>same types as for <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
same.crs(r, "+proj=longlat")

same.crs(r, "+proj=utm +zone=1")
</code></pre>

<hr>
<h2 id='sapp'>Apply a terra function that takes only a single layer and returns a SpatRaster to all layers of a SpatRaster</h2><span id='topic+sapp'></span><span id='topic+sapp+2CSpatRaster-method'></span><span id='topic+sapp+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

<p>Apply to all layers of a SpatRaster a function that only takes a single layer SpatRaster and returns a SpatRaster (these are rare). In most cases you can also use <code>lapply</code> or <code>sapply</code> for this. 
</p>
<p>Or apply the same method to each sub-dataset (SpatRaster) in a SpatRasterDataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
sapp(x, fun, ..., filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'SpatRasterDataset'
sapp(x, fun, ..., filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sapp_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatRasterDataset</p>
</td></tr>
<tr><td><code id="sapp_+3A_fun">fun</code></td>
<td>
<p>if <code>x</code> is a <code>SpatRaster</code>: a function that takes a SpatRaster argument and can be applied to each layer of <code>x</code> (e.g. <code><a href="#topic+terrain">terrain</a></code>. 
if <code>x</code> is a <code>SpatRasterDataset</code>: a function that is applied to all layers of the SpatRasters in <code>x</code> (e.g. <code>mean</code></p>
</td></tr>
<tr><td><code id="sapp_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>fun</code></p>
</td></tr> 
<tr><td><code id="sapp_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="sapp_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="sapp_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code> <a href="#topic+lapp">lapp</a>, <a href="#topic+app">app</a>, <a href="#topic+tapp">tapp</a>, <a href="base.html#topic+lapply">lapply</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra")) + 1  

#SpatRasterDataset
sd &lt;- sds(s*2, s/2)
y &lt;- sapp(sd, mean)
z &lt;- sapp(sd, \(i) 2 * mean(i))

</code></pre>

<hr>
<h2 id='sbar'>scale bar</h2><span id='topic+sbar'></span>

<h3>Description</h3>

<p>Add a scale bar to a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbar(d, xy=NULL, type="line", divs=2, below="", lonlat=NULL, labels,
	adj=c(0.5, -1), lwd=2, xpd=TRUE, ticks=FALSE, scaleby=1, halo=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbar_+3A_d">d</code></td>
<td>
<p>numeric. Distance covered by the scale bar. For the scale bar, it should be in the units of the coordinates of the plot (map), and in km for angular (longitude/latitude) data; see argument <code>lonlat</code>. It can also be missing</p>
</td></tr>
<tr><td><code id="sbar_+3A_xy">xy</code></td>
<td>
<p>numeric. x and y coordinate to place the scale bar. It can also be one of following character values: &quot;bottomleft&quot;, &quot;bottom&quot;, &quot;bottomright&quot;, topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;left&quot;, &quot;right&quot;, or NULL</p>
</td></tr>
<tr><td><code id="sbar_+3A_type">type</code></td>
<td>
<p>for <code>sbar</code>: &quot;line&quot; or &quot;bar&quot;</p>
</td></tr>
<tr><td><code id="sbar_+3A_divs">divs</code></td>
<td>
<p>number of divisions for a bar: 2 or 4</p>
</td></tr>
<tr><td><code id="sbar_+3A_below">below</code></td>
<td>
<p>character. Text to go below the scale bar (e.g., &quot;kilometers&quot;)</p>
</td></tr>
<tr><td><code id="sbar_+3A_lonlat">lonlat</code></td>
<td>
<p>logical or NULL. If logical, <code>TRUE</code> indicates if the plot is using longitude/latitude coordinates. If <code>NULL</code> this is guessed from the plot's coordinates</p>
</td></tr>
<tr><td><code id="sbar_+3A_labels">labels</code></td>
<td>
<p>vector of three numbers to label the scale bar (beginning, midpoint, end)</p>
</td></tr>
<tr><td><code id="sbar_+3A_adj">adj</code></td>
<td>
<p>adjustment for text placement</p>
</td></tr>
<tr><td><code id="sbar_+3A_lwd">lwd</code></td>
<td>
<p>line width for the &quot;line&quot; type of the scale bar</p>
</td></tr>
<tr><td><code id="sbar_+3A_xpd">xpd</code></td>
<td>
<p>logical. If <code>TRUE</code>, the scale bar can be outside the plotting area</p>
</td></tr>
<tr><td><code id="sbar_+3A_ticks">ticks</code></td>
<td>
<p>logical or numeric. If not <code>FALSE</code>, tick marks are added to a &quot;line&quot; scale bar. The length of the tick marks can be specified</p>
</td></tr>
<tr><td><code id="sbar_+3A_scaleby">scaleby</code></td>
<td>
<p>numeric. If <code>labels</code> is not provided. The labels are divided by this number. For example, use 1000 to go from m to km</p>
</td></tr>
<tr><td><code id="sbar_+3A_halo">halo</code></td>
<td>
<p>logical. If <code>TRUE</code> the &quot;line&quot; type scale bar gets a white background</p>
</td></tr>
<tr><td><code id="sbar_+3A_...">...</code></td>
<td>
<p>graphical arguments to be passed to other methods </p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+north">north</a></code>, <code><a href="#topic+plot">plot</a></code>, <code><a href="#topic+inset">inset</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/meuse.tif", package="terra")
r &lt;- rast(f)
plot(r)
sbar()
sbar(1000, xy=c(178500, 333500), type="bar", divs=4, cex=.8)
sbar(1000, xy="bottomright", divs=3, cex=.8, ticks=TRUE)
north(d=250, c(178550, 332500))


f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
plot(r, type="interval")
sbar(20, c(6.2, 50.1), type="bar", cex=.8, divs=4)
sbar(15, c(6.3, 50), type="bar", below="km", label=c(0,7.5,15), cex=.8)
sbar(15, c(6.65, 49.8), cex=.8, label=c(0,"km",15))
north(type=2)
sbar(15, c(6.65, 49.7), cex=.8, label="15 kilometer", lwd=5)
sbar(15, c(6.65, 49.6), divs=4, cex=.8, below="km")
</code></pre>

<hr>
<h2 id='scale'>Scale values</h2><span id='topic+scale'></span><span id='topic+scale+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Center and/or scale raster data. For details see <code><a href="#topic+scale">scale</a></code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
scale(x, center=TRUE, scale=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="scale_+3A_center">center</code></td>
<td>
<p>logical or numeric. If <code>TRUE</code>, centering is done by subtracting the layer means (omitting <code>NA</code>s), and if <code>FALSE</code>, no centering is done. If <code>center</code> is a numeric vector (recycled to <code>nlyr(x)</code>), then each layer of <code>x</code> has the corresponding value from center subtracted from it.</p>
</td></tr>
<tr><td><code id="scale_+3A_scale">scale</code></td>
<td>
<p>logical or numeric. If <code>TRUE</code>, scaling is done by dividing the (centered) layers of <code>x</code> by their standard deviations if <code>center</code> is <code>TRUE</code>, and the root mean square otherwise. If scale is <code>FALSE</code>, no scaling is done. If <code>scale</code> is a numeric vector (recycled to <code>nlyr(x)</code>), each layer of <code>x</code> is divided by the corresponding value. Scaling is done after centering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+scale">scale</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(system.file("ex/logo.tif", package="terra"))   
s &lt;- scale(r)

## the equivalent, computed in steps
m &lt;- global(r, "mean")
rr &lt;- r - m[,1]
rms &lt;- global(rr, "rms")
ss &lt;- rr / rms[,1]

</code></pre>

<hr>
<h2 id='scatterplot'>Scatterplot of two SpatRaster layers</h2><span id='topic+plot+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Scatterplot of the values of two SpatRaster layers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
plot(x, y, maxcell=100000, warn=TRUE, nc, nr, 
   maxnl=16, smooth=FALSE, gridded=FALSE, ncol=25, nrow=25, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatterplot_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_y">y</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells to use for the plot</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_nc">nc</code></td>
<td>
<p>positive integer. Optional. The number of columns to divide the plotting device in (when plotting multiple layers)</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_nr">nr</code></td>
<td>
<p>positive integer. Optional. The number of rows to divide the plotting device in (when plotting multiple layers)</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_maxnl">maxnl</code></td>
<td>
<p>positive integer. Maximum number of layers to plot (for multi-layer objects)</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_smooth">smooth</code></td>
<td>
<p>logical. If <code>TRUE</code> show a smooth scatterplot</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_gridded">gridded</code></td>
<td>
<p>logical. If <code>TRUE</code> the scatterplot is gridded (counts by cells)</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_warn">warn</code></td>
<td>
<p>boolean. Show a warning if a sample of the pixels is used (for scatterplot only)</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_ncol">ncol</code></td>
<td>
<p>positive integer. Number of columns for gridding</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_nrow">nrow</code></td>
<td>
<p>positive integer. Number of rows for gridding</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_...">...</code></td>
<td>
<p>additional graphical arguments</p>
</td></tr>  
</table>


<h3>Examples</h3>

<pre><code class='language-R'> 
s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
plot(s[[1]], s[[2]])
plot(s, sqrt(s[[3:1]]))
</code></pre>

<hr>
<h2 id='scoff'>Scale (gain) and offset</h2><span id='topic+scoff'></span><span id='topic+scoff+3C-'></span><span id='topic+scoff+2CSpatRaster-method'></span><span id='topic+scoff+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>These functions can be used to get or set the scale (gain) and offset parameters used to transform values when reading raster data from a file. The parameters are applied to the raw values using the formula below: 
</p>
<p><code>value &lt;- value * scale + offset</code>
</p>
<p>The default value for scale is 1 and for offset is 0. 'scale' is sometimes referred to as 'gain'.
</p>
<p>Note that setting the scale and/or offset are intended to be used with values that are stored in a file. When values are memory, assigning scale or offset values will lead to the immediate computation of new values; in such cases it would be clearer to use <code><a href="#topic+Arith-methods">Arith-methods</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
scoff(x)

## S4 replacement method for signature 'SpatRaster'
scoff(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scoff_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="scoff_+3A_value">value</code></td>
<td>
<p>two-column matrix with scale (first column) and offset (second column) for each layer. Or <code>NULL</code> to remove all scale and offset values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or changed SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast(system.file("ex/elev.tif", package="terra"))
minmax(r)
scoff(r)
r[4603]

scoff(r) &lt;- cbind(10, 5)
minmax(r)
scoff(r)
r[4603]
</code></pre>

<hr>
<h2 id='sds'>Create a SpatRasterDataset</h2><span id='topic+sds'></span><span id='topic+sds+2Cmissing-method'></span><span id='topic+sds+2Ccharacter-method'></span><span id='topic+sds+2Clist-method'></span><span id='topic+sds+2Carray-method'></span><span id='topic+sds+2CSpatRaster-method'></span><span id='topic+sds+2Cstars-method'></span><span id='topic+sds+2Cstars_proxy-method'></span><span id='topic++5B+3C-+2CSpatRasterDataset+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods to create a SpatRasterDataset. This is an object to hold &quot;sub-datasets&quot;, each a SpatRaster that in most cases will have multiple layers. 
</p>
<p>See <code><a href="#topic+describe">describe</a></code> for getting information about the sub-datasets present in a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
sds(x) 

## S4 method for signature 'character'
sds(x, ids=0, opts=NULL, raw=FALSE)

## S4 method for signature 'SpatRaster'
sds(x, ...) 

## S4 method for signature 'list'
sds(x) 

## S4 method for signature 'array'
sds(x, crs="", extent=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sds_+3A_x">x</code></td>
<td>
<p>character (filename), or SpatRaster, or list of SpatRasters, or missing. If multiple filenames are provided, it is attempted to make SpatRasters from these, and combine them into a SpatRasterDataset</p>
</td></tr>
<tr><td><code id="sds_+3A_ids">ids</code></td>
<td>
<p>optional. vector of integer subdataset ids. Ignored if the first value is not a positive integer</p>
</td></tr>
<tr><td><code id="sds_+3A_opts">opts</code></td>
<td>
<p>character. GDAL dataset open options</p>
</td></tr>
<tr><td><code id="sds_+3A_raw">raw</code></td>
<td>
<p>logical. If <code>TRUE</code>, scale and offset values are ignored</p>
</td></tr>
<tr><td><code id="sds_+3A_crs">crs</code></td>
<td>
<p>character. Description of the Coordinate Reference System (map projection) in <code>PROJ.4</code>, <code>WKT</code> or <code>authority:code</code> notation. If this argument is missing, and the x coordinates are within -360 .. 360 and the y coordinates are within -90 .. 90, longitude/latitude is assigned</p>
</td></tr>
<tr><td><code id="sds_+3A_extent">extent</code></td>
<td>
<p><code><a href="#topic+SpatExtent">SpatExtent</a></code></p>
</td></tr>
<tr><td><code id="sds_+3A_...">...</code></td>
<td>
<p>additional <code>SpatRaster</code> objects</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>SpatRasterDataset
</p>


<h3>See Also</h3>

<p><code><a href="#topic+describe">describe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
x &lt;- sds(s, s/2)
names(x) &lt;- c("first", "second")
x
length(x)

# extract the second SpatRaster
x[2]

a &lt;- array(1:9, c(3,3,3,3))
sds(a)
</code></pre>

<hr>
<h2 id='segregate'>segregate</h2><span id='topic+segregate'></span><span id='topic+segregate+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Create a SpatRaster with a layer for each class (value, or subset of the values) in the input SpatRaster. For example, if the input has vegetation types, this function will create a layer (presence/absence; dummy variable) for each of these classes.
</p>
<p>This is called &quot;one-hot encoding&quot; or &quot;dummy encoding&quot; (for a dummy encoding scheme you can remove (any) one of the output layers as it is redundant).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
segregate(x, classes=NULL, keep=FALSE, other=0, round=FALSE, digits=0, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segregate_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="segregate_+3A_classes">classes</code></td>
<td>
<p>numeric. The values (classes) for which layers should be made. If <code>NULL</code> all classes are used</p>
</td></tr>
<tr><td><code id="segregate_+3A_keep">keep</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that are of the class represented by a layer get that value, rather than a value of 1</p>
</td></tr>
<tr><td><code id="segregate_+3A_other">other</code></td>
<td>
<p>numeric. Value to assign to cells that are not of the class represented by a layer</p>
</td></tr>
<tr><td><code id="segregate_+3A_round">round</code></td>
<td>
<p>logical. Should the values be rounded first?</p>
</td></tr>
<tr><td><code id="segregate_+3A_digits">digits</code></td>
<td>
<p>integer. Number of digits to round the values to</p>
</td></tr>
<tr><td><code id="segregate_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="segregate_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=5, ncols=5)
values(r) &lt;- rep(c(1:4, NA), each=5)
b &lt;- segregate(r)
bb &lt;- segregate(r, keep=TRUE, other=NA)
</code></pre>

<hr>
<h2 id='sel'>
Spatial selection
</h2><span id='topic+sel'></span><span id='topic+sel+2CSpatRaster-method'></span><span id='topic+sel+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Geometrically subset SpatRaster or SpatVector (to be done) by drawing on a plot (map).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
sel(x, ...)

## S4 method for signature 'SpatVector'
sel(x, use="rec", show=TRUE, col="cyan", draw=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sel_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="sel_+3A_use">use</code></td>
<td>
<p>character indicating what to draw. One of &quot;rec&quot; (rectangle) or &quot;pol&quot; (polygon)</p>
</td></tr>
<tr><td><code id="sel_+3A_show">show</code></td>
<td>
<p>logical. If <code>TRUE</code> the selected geometries are shown on the map</p>
</td></tr>
<tr><td><code id="sel_+3A_col">col</code></td>
<td>
<p>color to be used for drawing if <code>draw=TRUE</code></p>
</td></tr>
<tr><td><code id="sel_+3A_draw">draw</code></td>
<td>
<p>logical. If <code>TRUE</code> the area drawn to select geometries is shown on the map</p>
</td></tr>
<tr><td><code id="sel_+3A_...">...</code></td>
<td>
<p>additional graphics arguments for drawing the selected geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster or SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crop">crop</a></code> and <code><a href="#topic+intersect">intersect</a></code> to make an intersection and <code><a href="#topic+click">click</a></code> and <code><a href="#topic+text">text</a></code> to see cell values or geometry attributes.
</p>
<p>Use <code><a href="#topic+draw">draw</a></code> to draw a SpatExtent of SpatVector that you want to keep.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# select a subset of a SpatRaster
r &lt;- rast(nrows=10, ncols=10)
values(r) &lt;- 1:ncell(r)
plot(r)
s &lt;- sel(r) # now click on the map twice

# plot the selection on a new canvas:
x11()
plot(s)

# vector
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
plot(v)
x &lt;- sel(v) # now click on the map twice
x

## End(Not run)
</code></pre>

<hr>
<h2 id='selectHighest'>select cells with high or low values</h2><span id='topic+selectHighest'></span><span id='topic+selectHighest+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Identify n cells that have the highest of lowest values in the first layer of a SpatRaster. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
selectHighest(x, n, low=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectHighest_+3A_x">x</code></td>
<td>
<p>SpatRaster. Only the first layer is processed</p>
</td></tr>
<tr><td><code id="selectHighest_+3A_n">n</code></td>
<td>
<p>The number of cells to select</p>
</td></tr>
<tr><td><code id="selectHighest_+3A_low">low</code></td>
<td>
<p>logical. If <code>TRUE</code>, the lowest values are selected instead of the highest values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
x &lt;- selectHighest(r, 1000)
y &lt;- selectHighest(r, 1000, TRUE)

m &lt;- merge(y-1, x)
levels(m) &lt;- data.frame(id=0:1, elevation=c("low", "high"))
plot(m)
</code></pre>

<hr>
<h2 id='selectRange'>Select the values of a range of layers, as specified by cell values in another SpatRaster</h2><span id='topic+selectRange'></span><span id='topic+selectRange+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Use a single layer SpatRaster to select cell values from different layers in a multi-layer SpatRaster. The values of the SpatRaster to select layers (<code>y</code>) should be whole numbers between <code>1</code> and <code>nlyr(x)</code> (values outside this range are ignored). 
</p>
<p>See <code><a href="#topic+rapp">rapp</a></code> for applying a function to a range of variable size.
</p>
<p>See <code><a href="#topic+extract">extract</a></code> for extraction of values by cell, point, or otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
selectRange(x, y, z=1, repint=0, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectRange_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="selectRange_+3A_y">y</code></td>
<td>
<p>SpatRaster. Cell values must be positive integers. They indicate the first layer to select for each cell</p>
</td></tr>
<tr><td><code id="selectRange_+3A_z">z</code></td>
<td>
<p>positive integer. The number of layers to select</p>
</td></tr>
<tr><td><code id="selectRange_+3A_repint">repint</code></td>
<td>
<p>integer &gt; 1 and &lt; nlyr(x) allowing for repeated selection at a fixed interval. For example, if <code>x</code> has 36 layers, and the value of a cell in <code>y</code>=2 and <code>repint</code> = 12, the values for layers 2, 14 and 26 are returned</p>
</td></tr>
<tr><td><code id="selectRange_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="selectRange_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rapp">rapp</a></code>, <code><a href="#topic+tapp">tapp</a></code>, <code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- 1
s &lt;- c(r, r+2, r+5)
s &lt;- c(s, s)
set.seed(1)
values(r) &lt;- sample(3, ncell(r), replace=TRUE)
x &lt;- selectRange(s, r)

x &lt;- selectRange(s, r, 3)
</code></pre>

<hr>
<h2 id='serialize'>saveRDS and serialize for SpatVector and SpatRaster*</h2><span id='topic+serialize'></span><span id='topic+saveRDS'></span><span id='topic+unserialize'></span><span id='topic+readRDS'></span><span id='topic+serialize+2CSpatVector-method'></span><span id='topic+serialize+2CSpatRaster-method'></span><span id='topic+serialize+2CSpatRasterDataset-method'></span><span id='topic+serialize+2CSpatRasterCollection-method'></span><span id='topic+unserialize+2CANY-method'></span><span id='topic+saveRDS+2CSpatVector-method'></span><span id='topic+saveRDS+2CSpatRaster-method'></span><span id='topic+saveRDS+2CSpatRasterCollection-method'></span><span id='topic+saveRDS+2CSpatRasterDataset-method'></span><span id='topic+readRDS+2Ccharacter-method'></span>

<h3>Description</h3>

<p>serialize and saveRDS for SpatVector, SpatRaster, SpatRasterDataset and SpatRasterCollection. Note that these objects will first be &quot;packed&quot; with <code><a href="#topic+wrap">wrap</a></code>, and after unserialize/readRDS they need to be unpacked with <code>rast</code> or <code>vect</code>.
</p>
<p>Extensive use of these functions is not recommended. Especially for SpatRaster it is generally much more efficient to use <code><a href="#topic+writeRaster">writeRaster</a></code> and write, e.g., a GTiff file. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
saveRDS(object, file="", ascii = FALSE, version = NULL, compress=TRUE, refhook = NULL)

## S4 method for signature 'SpatRasterDataset'
saveRDS(object, file="", ascii = FALSE, version = NULL, compress=TRUE, refhook = NULL)

## S4 method for signature 'SpatRasterCollection'
saveRDS(object, file="", ascii = FALSE, version = NULL, compress=TRUE, refhook = NULL)

## S4 method for signature 'SpatVector'
saveRDS(object, file="", ascii = FALSE, version = NULL, compress=TRUE, refhook = NULL)

## S4 method for signature 'SpatRaster'
serialize(object, connection, ascii = FALSE, xdr = TRUE, version = NULL, refhook = NULL)

## S4 method for signature 'SpatVector'
serialize(object, connection, ascii = FALSE, xdr = TRUE, version = NULL, refhook = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialize_+3A_object">object</code></td>
<td>
<p>SpatVector, SpatRaster, SpatRasterDataset or SpatRasterCollection</p>
</td></tr>
<tr><td><code id="serialize_+3A_file">file</code></td>
<td>
<p>file name to save object to</p>
</td></tr>
<tr><td><code id="serialize_+3A_connection">connection</code></td>
<td>
<p>see <code><a href="#topic+serialize">serialize</a></code></p>
</td></tr>
<tr><td><code id="serialize_+3A_ascii">ascii</code></td>
<td>
<p>see <code><a href="#topic+serialize">serialize</a></code> or <code><a href="#topic+saveRDS">saveRDS</a></code></p>
</td></tr>
<tr><td><code id="serialize_+3A_version">version</code></td>
<td>
<p>see <code><a href="#topic+serialize">serialize</a></code> or <code><a href="#topic+saveRDS">saveRDS</a></code></p>
</td></tr>
<tr><td><code id="serialize_+3A_compress">compress</code></td>
<td>
<p>see <code><a href="#topic+serialize">serialize</a></code> or <code><a href="#topic+saveRDS">saveRDS</a></code></p>
</td></tr>
<tr><td><code id="serialize_+3A_refhook">refhook</code></td>
<td>
<p>see <code><a href="#topic+serialize">serialize</a></code> or <code><a href="#topic+saveRDS">saveRDS</a></code></p>
</td></tr>
<tr><td><code id="serialize_+3A_xdr">xdr</code></td>
<td>
<p>see <code><a href="#topic+serialize">serialize</a></code> or <code><a href="#topic+saveRDS">saveRDS</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Packed* object 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
p &lt;- serialize(v, NULL)
head(p)
x &lt;- unserialize(p)
x
</code></pre>

<hr>
<h2 id='setValues'>Set the values of raster cells or of geometry attributes</h2><span id='topic+values+3C-'></span><span id='topic+values+3C-+2CSpatRaster+2CANY-method'></span><span id='topic+setValues'></span><span id='topic+setValues+2CSpatRaster-method'></span><span id='topic+setValues+2CSpatRaster+2CANY-method'></span><span id='topic+values+3C-+2CSpatVector+2Cdata.frame-method'></span><span id='topic+values+3C-+2CSpatVector+2Cmatrix-method'></span><span id='topic+values+3C-+2CSpatVector+2CANY-method'></span><span id='topic+values+3C-+2CSpatVector+2CNULL-method'></span><span id='topic+setValues+2CSpatVector-method'></span><span id='topic+setValues+2CSpatVector+2CANY-method'></span>

<h3>Description</h3>

<p>Set cell values of a SpatRaster or the attributes of a SpatVector. For large SpatRasters use <code><a href="#topic+init">init</a></code> instead to set values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SpatRaster,ANY'
values(x)&lt;-value

## S4 method for signature 'SpatRaster,ANY'
setValues(x, values, keeptime=TRUE, keepunits=TRUE, keepnames=FALSE, props=FALSE)

## S4 replacement method for signature 'SpatVector,ANY'
values(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setValues_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="setValues_+3A_value">value</code></td>
<td>
<p>For SpatRaster: numeric, matrix or data.frame. The length of the numeric values must match the total number of cells (ncell(x) * nlyr(x)), or be a single value. The number of columns of the matrix or data.frame must match the number of layers of <code>x</code>, and the number of rows must match the number of cells of <code>x</code>. It is also possible to use a matrix with the same number of rows as <code>x</code> and the number of columns that matches <code>ncol(x) * nlyr(x)</code>. 
</p>
<p>For SpatVector: data.frame, matrix, vector, or NULL</p>
</td></tr>
<tr><td><code id="setValues_+3A_values">values</code></td>
<td>
<p>Same as for <code>value</code></p>
</td></tr>
<tr><td><code id="setValues_+3A_keeptime">keeptime</code></td>
<td>
<p>logical. If <code>TRUE</code> the time stamps are kept</p>
</td></tr>
<tr><td><code id="setValues_+3A_keepunits">keepunits</code></td>
<td>
<p>logical. If <code>FALSE</code> the units are discarded</p>
</td></tr>
<tr><td><code id="setValues_+3A_keepnames">keepnames</code></td>
<td>
<p>logical. If <code>FALSE</code> the layer names are replaced by the column names in <code>y</code> (if present)</p>
</td></tr>
<tr><td><code id="setValues_+3A_props">props</code></td>
<td>
<p>logical. If <code>TRUE</code> the properties (categories and color-table) are kept</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object type as <code>x</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+values">values</a></code>, <code><a href="#topic+init">init</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
x &lt;- setValues(r, 1:ncell(r))
x
values(x) &lt;- runif(ncell(x))
x
head(x)

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
values(v) &lt;- data.frame(ID=1:12, name=letters[1:12])
head(v)
</code></pre>

<hr>
<h2 id='shade'>Hill shading</h2><span id='topic+shade'></span>

<h3>Description</h3>

<p>Compute hill shade from slope and aspect layers (both in radians). Slope and aspect can be computed with function <code><a href="#topic+terrain">terrain</a></code>. 
</p>
<p>A hill shade layer is often used as a backdrop on top of which another, semi-transparent, layer is drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shade(slope, aspect, angle=45, direction=0, normalize=FALSE,
   filename="", overwrite=FALSE, ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shade_+3A_slope">slope</code></td>
<td>
<p>SpatRasterwith slope values (in radians) </p>
</td></tr>
<tr><td><code id="shade_+3A_aspect">aspect</code></td>
<td>
<p>SpatRaster with aspect values (in radians) </p>
</td></tr>
<tr><td><code id="shade_+3A_angle">angle</code></td>
<td>
<p> The elevation angle(s) of the light source (sun), in degrees</p>
</td></tr>
<tr><td><code id="shade_+3A_direction">direction</code></td>
<td>
<p> The direction (azimuth) angle(s) of the light source (sun), in degrees</p>
</td></tr>
<tr><td><code id="shade_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>TRUE</code>, values below zero are set to zero and the results are multiplied with 255</p>
</td></tr>
<tr><td><code id="shade_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="shade_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>  
<tr><td><code id="shade_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>  
</table>


<h3>References</h3>

<p>Horn, B.K.P., 1981. Hill shading and the reflectance map. Proceedings of the IEEE 69(1):14-47
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+terrain">terrain</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
alt &lt;- disagg(r, 10, method="bilinear")
slope &lt;- terrain(alt, "slope", unit="radians")
aspect &lt;- terrain(alt, "aspect", unit="radians")
hill &lt;- shade(slope, aspect, 40, 270)
plot(hill, col=grey(0:100/100), legend=FALSE, mar=c(2,2,1,4))
plot(alt, col=rainbow(25, alpha=0.35), add=TRUE)

# A better hill shade may be achieved by combining 
# different angles and directions. For example

h &lt;- shade(slope, aspect, angle = c(45, 45, 45, 80), direction = c(225, 270, 315, 135))
h &lt;- Reduce(mean, h)				
</code></pre>

<hr>
<h2 id='sharedPaths'> 
Shared paths
</h2><span id='topic+sharedPaths'></span><span id='topic+sharedPaths+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get shared paths of line or polygon geometries. This can for geometries in a single SpatVector, or between two SpatVectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
sharedPaths(x, y=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sharedPaths_+3A_x">x</code></td>
<td>
<p>SpatVector of lines or polygons</p>
</td></tr>
<tr><td><code id="sharedPaths_+3A_y">y</code></td>
<td>
<p>missing or SpatVector of lines or polygons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaps">gaps</a></code>, <code><a href="#topic+topology">topology</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
plot(v, col="light gray")
text(v, halo=TRUE)

x &lt;- sharedPaths(v)
lines(x, col="red", lwd=2)
text(x, col="blue", halo=TRUE, cex=0.8)
head(x)

z &lt;- sharedPaths(v[3,], v[12,])

</code></pre>

<hr>
<h2 id='shift'>Shift</h2><span id='topic+shift'></span><span id='topic+shift+2CSpatRaster-method'></span><span id='topic+shift+2CSpatExtent-method'></span><span id='topic+shift+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Shift a SpatRaster, SpatVector or SpatExtent to another location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
shift(x, dx=0, dy=0, filename="", ...)

## S4 method for signature 'SpatVector'
shift(x, dx=0, dy=0)

## S4 method for signature 'SpatExtent'
shift(x, dx=0, dy=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="shift_+3A_dx">dx</code></td>
<td>
<p>numeric. The shift in horizontal direction</p>
</td></tr>
<tr><td><code id="shift_+3A_dy">dy</code></td>
<td>
<p>numeric. The shift in vertical direction</p>
</td></tr>
<tr><td><code id="shift_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="shift_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <code>x</code>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+flip">flip</a></code>, <code><a href="#topic+rotate">rotate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(xmin=0, xmax=1, ymin=0, ymax=1)
r &lt;- shift(r, dx=1, dy=-1)

e &lt;- ext(r)
shift(e, 5, 5)
</code></pre>

<hr>
<h2 id='sieve'>Sieve filter</h2><span id='topic+sieve'></span><span id='topic+sieve+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Apply a sieve filter. That is, remove &quot;noise&quot;, by changing small clumps of cells with a value that is different from the surrounding cells, to the value of the largest neighboring clump.
</p>
<p>Note that the input raster data is rounded to integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
sieve(x, threshold, directions=8, filename="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sieve_+3A_x">x</code></td>
<td>
<p>SpatRaster, single layer with elevation values. Values should have the same unit as the map units</p>
</td></tr>
<tr><td><code id="sieve_+3A_threshold">threshold</code></td>
<td>
<p>positive integer. Only clumps smaller than this threshold will be removed</p>
</td></tr>
<tr><td><code id="sieve_+3A_directions">directions</code></td>
<td>
<p>numeric to indicate which cells are connected. Either <code>4</code> to only consider the horizontal and vertical neighbors (&quot;rook&quot;), or <code>8</code> to consider the vertical, horizontal and diagonal neighbors</p>
</td></tr>
<tr><td><code id="sieve_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="sieve_+3A_...">...</code></td>
<td>
<p>Options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+focal">focal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=18, ncols=18, xmin=0, vals=0, crs="local")
r[2, 5] &lt;- 1
r[5:8, 2:3] &lt;- 2
r[7:12, 10:15] &lt;- 3
r[15:16, 15:18] &lt;- 4
freq(r, bylayer=FALSE)

x &lt;- sieve(r, 8)
y &lt;- sieve(r, 9)
</code></pre>

<hr>
<h2 id='simplifyGeom'> 
simplifyGeom geometries
</h2><span id='topic+simplifyGeom'></span><span id='topic+simplifyGeom+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Reduce the number of nodes used to represent geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
simplifyGeom(x, tolerance=0.1, preserveTopology=TRUE, makeValid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplifyGeom_+3A_x">x</code></td>
<td>
<p>SpatVector of lines or polygons</p>
</td></tr>
<tr><td><code id="simplifyGeom_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric. The minimum distance between nodes in units of the crs (i.e. degrees for long/lat)</p>
</td></tr>
<tr><td><code id="simplifyGeom_+3A_preservetopology">preserveTopology</code></td>
<td>
<p>logical. If <code>TRUE</code> the topology of output geometries is preserved</p>
</td></tr>
<tr><td><code id="simplifyGeom_+3A_makevalid">makeValid</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code><a href="#topic+makeValid">makeValid</a></code> is run after simplification to assure that the output polygons are valid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sharedPaths">sharedPaths</a></code>, <code><a href="#topic+gaps">gaps</a></code>, <code><a href="#topic+is.valid">is.valid</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
w &lt;- simplifyGeom(v, .02, makeValid=FALSE)
e &lt;- erase(w)
g &lt;- gaps(e)
plot(e, lwd=5, border="light gray")
polys(g, col="red", border="red")
</code></pre>

<hr>
<h2 id='sort'>Sort a SpatRaster or SpatVector</h2><span id='topic+sort'></span><span id='topic+sort+2CSpatRaster-method'></span><span id='topic+sort+2CSpatVector-method'></span><span id='topic+sort+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>Sort the cell values of a SpatRaster across layers. You can also compute the sorting order. 
</p>
<p>Or sort the records of SpatVector (or data.frame) by specifying the column number(s) or names(s) to sort on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
sort(x, decreasing=FALSE, order=FALSE, filename="", ...)

## S4 method for signature 'SpatVector'
sort(x, v, decreasing=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="sort_+3A_decreasing">decreasing</code></td>
<td>
<p>logical. If <code>TRUE</code>, sorting is in decreasing order</p>
</td></tr>
<tr><td><code id="sort_+3A_order">order</code></td>
<td>
<p>logical. If <code>TRUE</code> the sorting order is returned instead of the sorted values</p>
</td></tr>
<tr><td><code id="sort_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="sort_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="sort_+3A_v">v</code></td>
<td>
<p>character or numeric indicating the column(s) to sort on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
r &lt;- c(r, r/2, r*2)
sort(r)

ord &lt;- sort(r, order=TRUE)
# these two are the same 
ord[[1]]
which.min(r)
</code></pre>

<hr>
<h2 id='sources'>Data sources of a SpatRaster</h2><span id='topic+sources'></span><span id='topic+sources+2CSpatRaster-method'></span><span id='topic+sources+2CSpatRasterCollection-method'></span><span id='topic+sources+2CSpatRasterDataset-method'></span><span id='topic+sources+2CSpatVector-method'></span><span id='topic+sources+2CSpatVectorProxy-method'></span><span id='topic+hasValues'></span><span id='topic+hasValues+2CSpatRaster-method'></span><span id='topic+inMemory'></span><span id='topic+inMemory+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Get the data sources of a SpatRaster or SpatVector or related object. Sources are either files (or similar resources) or &quot;&quot;, meaning that they are in memory. You can use <code>hasValues</code> to check if in-memory layers actually have cell values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
sources(x, nlyr=FALSE, bands=FALSE)

## S4 method for signature 'SpatVector'
sources(x)

## S4 method for signature 'SpatRaster'
hasValues(x)

## S4 method for signature 'SpatRaster'
inMemory(x, bylayer=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sources_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatRasterCollection, SpatVector or SpatVectorProxy</p>
</td></tr>
<tr><td><code id="sources_+3A_nlyr">nlyr</code></td>
<td>
<p>logical. If <code>TRUE</code> for each source, the number of layers is returned</p>
</td></tr>
<tr><td><code id="sources_+3A_bands">bands</code></td>
<td>
<p>logical. If <code>TRUE</code> for each source, the &quot;bands&quot; used, that is, the layer number in the source file, are returned</p>
</td></tr>
<tr><td><code id="sources_+3A_bylayer">bylayer</code></td>
<td>
<p>logical. If <code>TRUE</code> a value is returned for each layer instead of for each source</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of filenames, or <code>""</code> when there is no filename, if <code>nlyr</code> and <code>bands</code> are both <code>FALSE</code>. Otherwise a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
s &lt;- rast(r)
values(s) &lt;- 1:ncell(s)
rs &lt;- c(r,r,s,r)
sources(rs)
hasValues(r)
x &lt;- rast()
hasValues(x)
</code></pre>

<hr>
<h2 id='SpatExtent-class'>Class &quot;SpatExtent&quot; </h2><span id='topic+SpatExtent'></span><span id='topic+SpatExtent-class'></span><span id='topic+Rcpp_SpatExtent-class'></span><span id='topic+show+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Objects of class SpatExtent are used to define the spatial extent (extremes) of objects of the SpatRaster class. 
</p>


<h3>Objects from the Class</h3>

<p>You can use the <code><a href="#topic+ext">ext</a></code> function to create SpatExtent objects, or to extract them from a SpatRaster, SpatVector or related objects.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p>display values of a SpatExtent object </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- ext(-180, 180, -90, 90)
e
</code></pre>

<hr>
<h2 id='SpatRaster-class'> SpatRaster class</h2><span id='topic+SpatRaster'></span><span id='topic+SpatRaster-class'></span><span id='topic+Rcpp_SpatRaster-class'></span><span id='topic+PackedSpatRaster-class'></span><span id='topic+SpatRasterCollection'></span><span id='topic+SpatRasterDataset'></span><span id='topic+SpatRasterCollection-class'></span><span id='topic+SpatRasterDataset-class'></span><span id='topic+RasterSource'></span><span id='topic+RasterSource-class'></span><span id='topic+Rcpp_RasterSource-class'></span><span id='topic+SpatCategories'></span><span id='topic+SpatCategories-class'></span><span id='topic+Rcpp_SpatCategories-class'></span><span id='topic+show+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>A <code>SpatRaster</code> represents a rectangular part of the world that is sub-divided into rectangular cells of equal area (in terms of the units of the coordinate reference system). For each cell can have multiple values (&quot;layers&quot;). 
</p>
<p>An object of the <code>SpatRaster</code> class can point to one or more files on disk that hold the cell values, and/or it can hold these values in memory. These objects can be created with the <code><a href="#topic+rast">rast</a></code> method. 
</p>
<p>A <code>SpatRasterDataset</code> is a collection of sub-datasets, where each is a <code>SpatRaster</code> for the same area (extent) and coordinate reference system, but possibly with a different resolution. Sub-datasets are often used to capture variables (e.g. temperature and precipitation), or a fourth dimension (e.g. height, depth or time) if the sub-datasets already have three dimensions (multiple layers).
</p>
<p>A <code>SpatRasterCollection</code> is a collection of SpatRasters with no restriction in the extent or other geometric parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rast()
</code></pre>

<hr>
<h2 id='spatSample'>Take a regular sample</h2><span id='topic+spatSample'></span><span id='topic+spatSample+2CSpatRaster-method'></span><span id='topic+spatSample+2CSpatExtent-method'></span><span id='topic+spatSample+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Take a spatial sample from a SpatRaster, SpatVector or SpatExtent. Sampling a SpatVector or SpatExtent always returns a SpatVector of points. 
</p>
<p>With a SpatRaster, you can get cell values, cell numbers (<code>cells=TRUE</code>), coordinates (<code>xy=TRUE</code>) or (when <code>type="regular"</code> and <code>as.raster=TRUE</code>) get a new SpatRaster with the same extent, but fewer cells. 
</p>
<p>In order to assure regularity when requesting a regular sample, the number of cells or points returned may not be exactly the same as the <code>size</code> requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
spatSample(x, size, method="random", replace=FALSE, na.rm=FALSE, 
    as.raster=FALSE, as.df=TRUE, as.points=FALSE, values=TRUE, cells=FALSE, 
    xy=FALSE, ext=NULL, warn=TRUE, weights=NULL, exp=5, exhaustive=FALSE)

## S4 method for signature 'SpatVector'
spatSample(x, size, method="random", strata=NULL, chess="")

## S4 method for signature 'SpatExtent'
spatSample(x, size, method="random", lonlat, as.points=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatSample_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="spatSample_+3A_size">size</code></td>
<td>
<p>numeric. The sample size. If <code>x</code> is a SpatVector, you can also provide a vector of the same length as <code>x</code> in which case sampling is done separately for each geometry. If <code>x</code> is a SpatRaster, and you are using <code>method="regular"</code> you can specify the size as two numbers (number of rows and columns)</p>
</td></tr>
<tr><td><code id="spatSample_+3A_method">method</code></td>
<td>
<p>character. Should be &quot;regular&quot; or &quot;random&quot;, If <code>x</code> is a <code>SpatRaster</code>, it can also be &quot;stratified&quot; (each value in <code>x</code> is a stratum) or &quot;weights&quot; (each value in <code>x</code> is a probability weight)</p>
</td></tr>
<tr><td><code id="spatSample_+3A_replace">replace</code></td>
<td>
<p>logical. If <code>TRUE</code>, sampling is with replacement (if <code>method="random"</code>)</p>
</td></tr>
<tr><td><code id="spatSample_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NAs</code> are removed. Only used with random sampling of cell values. That is with <code>method="random", as.raster=FALSE, cells=FALSE</code></p>
</td></tr>
<tr><td><code id="spatSample_+3A_as.raster">as.raster</code></td>
<td>
<p>logical. If <code>TRUE</code>, a SpatRaster is returned</p>
</td></tr>
<tr><td><code id="spatSample_+3A_as.df">as.df</code></td>
<td>
<p>logical. If <code>TRUE</code>, a data.frame is returned instead of a matrix</p>
</td></tr>
<tr><td><code id="spatSample_+3A_as.points">as.points</code></td>
<td>
<p>logical. If <code>TRUE</code>, a SpatVector of points is returned</p>
</td></tr>
<tr><td><code id="spatSample_+3A_values">values</code></td>
<td>
<p>logical. If <code>TRUE</code> raster cell values are returned</p>
</td></tr>
<tr><td><code id="spatSample_+3A_cells">cells</code></td>
<td>
<p>logical. If <code>TRUE</code>, cell numbers are returned. If <code>method="stratified"</code> this is always set to <code>TRUE</code> if <code>xy=FALSE</code></p>
</td></tr>
<tr><td><code id="spatSample_+3A_xy">xy</code></td>
<td>
<p>logical. If <code>TRUE</code>, cell coordinates are returned</p>
</td></tr>
<tr><td><code id="spatSample_+3A_ext">ext</code></td>
<td>
<p>SpatExtent or NULL to restrict sampling to a subset of the area of <code>x</code></p>
</td></tr>
<tr><td><code id="spatSample_+3A_warn">warn</code></td>
<td>
<p>logical. Give a warning if the sample size returned is smaller than requested</p>
</td></tr>
<tr><td><code id="spatSample_+3A_weights">weights</code></td>
<td>
<p>SpatRaster. Used to provide weights when <code>method="stratified"</code></p>
</td></tr>
<tr><td><code id="spatSample_+3A_strata">strata</code></td>
<td>
<p>if not NULL, stratified random sampling is done, taking <code>size</code> samples from each stratum. If <code>x</code> has polygon geometry, <code>strata</code> must be a field name (or index) in <code>x</code>. If <code>x</code> has point geometry, <code>strata</code> can be a SpatVector of polygons or a SpatRaster</p>
</td></tr>
<tr><td><code id="spatSample_+3A_chess">chess</code></td>
<td>
<p>character. One of &quot;&quot;, &quot;white&quot;, or &quot;black&quot;. For stratified sampling if <code>strata</code> is a SpatRaster. If not &quot;&quot;, samples are only taken from alternate cells, organized like the &quot;white&quot; or &quot;black&quot; fields on a chessboard</p>
</td></tr>
<tr><td><code id="spatSample_+3A_lonlat">lonlat</code></td>
<td>
<p>logical. If <code>TRUE</code>, sampling of a SpatExtent is weighted by <code>cos(latitude)</code>. For SpatRaster and SpatVector this done based on the <code><a href="#topic+crs">crs</a></code>, but it is ignored if <code>as.raster=TRUE</code></p>
</td></tr>
<tr><td><code id="spatSample_+3A_exp">exp</code></td>
<td>
<p>numeric &gt;= 1. &quot;Expansion factor&quot; that is multiplied with <code>size</code> to get an initial sample used for stratified samples and random samples with <code>na.rm=TRUE</code> to try to get at least <code>size</code> samples</p>
</td></tr>
<tr><td><code id="spatSample_+3A_exhaustive">exhaustive</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>na.rm=TRUE</code> first all cells that are not <code>NA</code> are determined and a sample is taked from these cells. This is useful when you are dealing with a very large raster that is sparse (most cells are NA). Otherwise, the default approach may not find enough samples. This should not be used in other cases, especially not with large rasters that mostly have values</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>numeric matrix, data.frame, SpatRaster or SpatVector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
s &lt;- spatSample(r, 10, as.raster=TRUE)
spatSample(r, 5)
spatSample(r, 5, na.rm=TRUE)
spatSample(r, 5, "regular")

## if you require cell numbers and/or coordinates
size &lt;- 6
spatSample(r, 6, "random", cells=TRUE, xy=TRUE, values=FALSE)

# regular, with values 
spatSample(r, 6, "regular", cells=TRUE, xy=TRUE)

# stratified
rr &lt;- rast(ncol=10, nrow=10, names="stratum")
set.seed(1)
values(rr) &lt;- round(runif(ncell(rr), 1, 3))
spatSample(rr, 2, "stratified", xy=TRUE)

s &lt;- spatSample(rr, 5, "stratified", as.points=TRUE)
plot(rr, plg=list(title="raster"))
plot(s, 1, add=TRUE, plg=list(x=185, y=1, title="points"))
 
## SpatExtent 
e &lt;- ext(r)
spatSample(e, 10, "random", lonlat=TRUE)

## SpatVector
f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)

# sample the geometries 
i &lt;- sample(v, 3)

# sample points in geometries
p &lt;- spatSample(v, 3)

</code></pre>

<hr>
<h2 id='SpatVector-class'>Class &quot;SpatVector&quot; </h2><span id='topic+SpatVector'></span><span id='topic+SpatVector-class'></span><span id='topic+SpatVectorCollection'></span><span id='topic+SpatVectorCollection-class'></span><span id='topic+SpatVectorProxy'></span><span id='topic+SpatVectorProxy-class'></span><span id='topic+Rcpp_SpatVector-class'></span><span id='topic+PackedSpatVector-class'></span><span id='topic+show+2CSpatVector-method'></span>

<h3>Description</h3>

<p><code>SpatVector</code> can represent points, lines or polygons.
</p>
<p><code>SpatVectorCollection</code> can hold a collection of SpatVectors
</p>
<p><code>SpatVectorProxy</code> is a SpatVector for which the data are on-disk in-stead of in memory. 
</p>

<hr>
<h2 id='spin'>spin a SpatVector</h2><span id='topic+spin'></span><span id='topic+spin+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Spin (rotate) the geometry of a SpatVector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
spin(x, angle, x0, y0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spin_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="spin_+3A_angle">angle</code></td>
<td>
<p>numeric. Angle of rotation in degrees</p>
</td></tr>
<tr><td><code id="spin_+3A_x0">x0</code></td>
<td>
<p>numeric. x-coordinate of the center of rotation. If missing, the center of the extent of <code>x</code> is used</p>
</td></tr>
<tr><td><code id="spin_+3A_y0">y0</code></td>
<td>
<p>numeric. y-coordinate of the center of rotation. If missing, the center of the extent of <code>x</code> is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rescale">rescale</a></code>, <code><a href="#topic+t">t</a></code>, <code><a href="#topic+shift">shift</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
w &lt;- spin(v, 180)
plot(v)
lines(w, col="red")

# lower-right corner as center
e &lt;- as.vector(ext(v))
x &lt;- spin(v, 45, e[1], e[3])
</code></pre>

<hr>
<h2 id='split'>Split</h2><span id='topic+split'></span><span id='topic+split+2CSpatRaster+2CANY-method'></span><span id='topic+split+2CSpatVector+2CANY-method'></span><span id='topic+split+2CSpatVector+2CSpatVector-method'></span>

<h3>Description</h3>

 
<p>Split a SpatRaster by layer, or a SpatVector by attributes. You can also split the geometry of a polygon SpatVector with another SpatVector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,ANY'
split(x, f)

## S4 method for signature 'SpatVector,ANY'
split(x, f)

## S4 method for signature 'SpatVector,SpatVector'
split(x, f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="split_+3A_f">f</code></td>
<td>
<p>If <code>x</code> is a SpatRaster: a vector of the length <code>nlyr(x)</code>. If <code>x</code> is a SpatVector: a field (variable) name or a vector of the same length as <code>x</code>; or, if <code>x</code> is a SpatVector of polygons, a SpatVector of lines or polygons to split the polygon geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list or SpatVector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## split layers
s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
y &lt;- split(s, c(1,2,1))
sds(y)

## split attributes
v &lt;- vect(system.file("ex/lux.shp", package="terra"))
x &lt;- split(v, "NAME_1")

## split geometries
v &lt;- v[1:5,]
line &lt;- vect(matrix(c(5.79, 6.22, 5.75, 6.1, 5.8, 
	50.14, 50.05, 49.88, 49.85, 49.71), ncol=2), "line")
s &lt;- split(v, line)
</code></pre>

<hr>
<h2 id='sprc'>Create a SpatRasterCollection</h2><span id='topic+sprc'></span><span id='topic+sprc+2Cmissing-method'></span><span id='topic+sprc+2Clist-method'></span><span id='topic+sprc+2CSpatRaster-method'></span><span id='topic+sprc+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Methods to create a SpatRasterCollection. This is an object to hold a collection (list) of SpatRasters. There are no restrictions on the similarity of the SpatRaster geometry. 
</p>
<p>They can be used to combine several SpatRasters to be used with <code><a href="#topic+merge">merge</a></code> or <code><a href="#topic+mosaic">mosaic</a></code>
</p>
<p>You can create a SpatRasterCollection from a file with subdatasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
sprc(x, ids=0, opts=NULL, raw=FALSE) 

## S4 method for signature 'SpatRaster'
sprc(x, ...) 

## S4 method for signature 'list'
sprc(x) 

## S4 method for signature 'missing'
sprc(x) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sprc_+3A_x">x</code></td>
<td>
<p>SpatRaster, list with SpatRasters, missing, or filename</p>
</td></tr>
<tr><td><code id="sprc_+3A_ids">ids</code></td>
<td>
<p>optional. vector of integer subdataset ids. Ignored if the first value is not a positive integer</p>
</td></tr>
<tr><td><code id="sprc_+3A_opts">opts</code></td>
<td>
<p>character. GDAL dataset open options</p>
</td></tr>
<tr><td><code id="sprc_+3A_raw">raw</code></td>
<td>
<p>logical. If <code>TRUE</code>, scale and offset values are ignored</p>
</td></tr>
<tr><td><code id="sprc_+3A_...">...</code></td>
<td>
<p>additional SpatRasters</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>SpatRasterCollection
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sds">sds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rast(xmin=-110, xmax=-50, ymin=40, ymax=70, ncols=60, nrows=30)
y &lt;- rast(xmin=-80, xmax=-20, ymax=60, ymin=30)
res(y) &lt;- res(x)
values(x) &lt;- 1:ncell(x)
values(y) &lt;- 1:ncell(y)

z &lt;- sprc(x, y)
z
</code></pre>

<hr>
<h2 id='stretch'>Stretch</h2><span id='topic+stretch'></span><span id='topic+stretch+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Linear or histogram equalization stretch of values in a SpatRaster. 
</p>
<p>For linear stretch, provide the desired output range (<code>minv</code> and <code>maxv</code>) and the lower and upper bounds in the original data, either as quantiles (<code>minq</code> and <code>maxq</code>, or as cell values (<code>smin</code> and <code>smax</code>). If <code>smin</code> and <code>smax</code> are both not <code>NA</code>, <code>minq</code> and <code>maxq</code> are ignored.
</p>
<p>For histogram equalization, these arguments are ignored, but you can provide the desired scale of the output and the maximum number of cells that is used to compute the histogram (empirical cumulative distribution function). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
stretch(x, minv=0, maxv=255, minq=0, maxq=1, smin=NA, smax=NA,
		histeq=FALSE, scale=1, maxcell=500000, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stretch_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr> 
<tr><td><code id="stretch_+3A_minv">minv</code></td>
<td>
<p>numeric &gt;= 0 and smaller than maxv. lower bound of stretched value</p>
</td></tr>
<tr><td><code id="stretch_+3A_maxv">maxv</code></td>
<td>
<p>numeric &lt;= 255 and larger than maxv. upper bound of stretched value</p>
</td></tr>
<tr><td><code id="stretch_+3A_minq">minq</code></td>
<td>
<p>numeric &gt;= 0 and smaller than maxq. lower quantile bound of original value. Ignored if smin is supplied</p>
</td></tr>
<tr><td><code id="stretch_+3A_maxq">maxq</code></td>
<td>
<p>numeric &lt;= 1 and larger than minq. upper quantile bound of original value. Ignored if smax is supplied</p>
</td></tr>
<tr><td><code id="stretch_+3A_smin">smin</code></td>
<td>
<p>numeric &lt; smax. user supplied lower value for the layers, to be used instead of a quantile computed by the function itself</p>
</td></tr>
<tr><td><code id="stretch_+3A_smax">smax</code></td>
<td>
<p>numeric &gt; smin. user supplied upper value for the layers, to be used instead of a quantile computed by the function itself</p>
</td></tr>
<tr><td><code id="stretch_+3A_histeq">histeq</code></td>
<td>
<p>logical. If <code>TRUE</code> histogram equalization is used instead of linear stretch</p>
</td></tr>
<tr><td><code id="stretch_+3A_scale">scale</code></td>
<td>
<p>numeric. The scale (maximum value) of the output if <code>histeq=TRUE</code></p>
</td></tr>
<tr><td><code id="stretch_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. The size of the regular sample used to compute the histogram</p>
</td></tr>
<tr><td><code id="stretch_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="stretch_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nc=10, nr=10)
values(r) &lt;- rep(1:25, 4)
rs &lt;- stretch(r)
s &lt;- c(r, r*2)
sr &lt;- stretch(s)
</code></pre>

<hr>
<h2 id='subset'>Subset a SpatRaster or a SpatVector</h2><span id='topic+subset'></span><span id='topic+subset+2CSpatRaster-method'></span><span id='topic+subset+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Select a subset of layers from a SpatRaster or select a subset of records (row) and/or variables (columns) from a SpatVector.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
subset(x, subset, negate=FALSE, NSE=FALSE, filename="", overwrite=FALSE, ...)

## S4 method for signature 'SpatVector'
subset(x, subset, select, drop=FALSE, NSE=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="subset_+3A_subset">subset</code></td>
<td>

<p>if <code>x</code> is a <code>SpatRaster</code>: integer or character to select layers
</p>
<p>if <code>x</code> is a <code>SpatVector</code>: logical expression indicating the rows to keep (missing values are taken as FALSE)
</p>
</td></tr>
<tr><td><code id="subset_+3A_select">select</code></td>
<td>
<p>expression, indicating columns to select</p>
</td></tr> 
<tr><td><code id="subset_+3A_negate">negate</code></td>
<td>
<p>logical. If <code>TRUE</code> all layers that are <b>not</b> in the subset are selected</p>
</td></tr>
<tr><td><code id="subset_+3A_nse">NSE</code></td>
<td>
<p>logical. If <code>TRUE</code>, non-standard evaluation (the use of unquoted variable names) is allowed. Set this to <code>FALSE</code> when calling <code>subset</code> from a function</p>
</td></tr> 
<tr><td><code id="subset_+3A_drop">drop</code></td>
<td>
<p>logical. If <code>TRUE</code>, the geometries will be dropped, and a data.frame is returned</p>
</td></tr>  
<tr><td><code id="subset_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="subset_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="subset_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>x</code> is a <code>SpatRaster</code>: SpatRaster
</p>
<p>if <code>x</code> is a <code>SpatVector</code>: SpatVector or, if <code>drop=TRUE</code>, a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### SpatRaster
s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
subset(s, 2:3)
subset(s, c(3,2,3,1))

#equivalent to 
s[[ c(3,2,3,1) ]]

s[[c("red", "green")]]
s$red

# expression based (partial) matching of names with single brackets
s["re"]
s["^re"]

# not with double brackets
# s[["re"]]


### SpatVector

v &lt;- vect(system.file("ex/lux.shp", package="terra"))

subset(v, v$NAME_1 == "Diekirch", c("NAME_1", "NAME_2"))

subset(v, NAME_1 == "Diekirch", c(NAME_1, NAME_2), NSE=TRUE)

# or like this
v[2:3,]
v[1:2, 2:3]
v[1:2, c("NAME_1", "NAME_2")]
</code></pre>

<hr>
<h2 id='subset_dollar'>Subset a SpatRaster or a SpatVector</h2><span id='topic++24'></span><span id='topic++24+2CSpatRaster-method'></span><span id='topic++24+2CSpatRasterDataset-method'></span><span id='topic++24+2CSpatVector-method'></span><span id='topic++24+2CSpatExtent-method'></span>

<h3>Description</h3>

<p>Select a subset of layers from a SpatRaster or select a subset of records (row) and/or variables (columns) from a SpatVector.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatExtent'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_dollar_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="subset_dollar_+3A_name">name</code></td>
<td>
<p>character. If <code>x</code> is a SpatRaster: layer name. If <code>x</code> is a SpatVector: variable name. If <code>x</code> is a SpatExtent: xmin, xmax, ymin or ymax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>x</code> is a <code>SpatRaster</code>: SpatRaster
</p>
<p>if <code>x</code> is a <code>SpatVector</code>: SpatVector or, if <code>drop=TRUE</code>, a <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset">subset</a></code>, <code><a href="#topic++5B">[</a></code>, <code><a href="#topic++5B+5B">[[</a></code>, <code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### SpatRaster
s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
subset(s, 2:3)
subset(s, c(3,2,3,1))
#equivalent to 
s[[ c(3,2,3,1) ]]

s[[c("red", "green")]]
s$red

# expression based (partial) matching of names with single brackets
s["re"]
s["^re"]

# not with double brackets
# s[["re"]]


### SpatVector

v &lt;- vect(system.file("ex/lux.shp", package="terra"))
v[2:3,]
v[1:2, 2:3]

subset(v, v$NAME_1 == "Diekirch", c("NAME_1", "NAME_2"))

subset(v, NAME_1 == "Diekirch", c(NAME_1, NAME_2), NSE=TRUE)
</code></pre>

<hr>
<h2 id='subset_double'>Subset a SpatRaster or a SpatVector</h2><span id='topic++5B+5B'></span><span id='topic++5B+5B+2CSpatRaster+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+2CSpatRaster+2Clogical+2Cmissing-method'></span><span id='topic++5B+5B+2CSpatRaster+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+5B+2CSpatRaster+2CANY+2Cmissing-method'></span><span id='topic++5B+5B+2CSpatRasterDataset+2CANY+2CANY-method'></span><span id='topic++5B+5B+2CSpatVector+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+2CSpatVector+2Clogical+2Cmissing-method'></span><span id='topic++5B+5B+2CSpatVector+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Select a subset of layers from a SpatRaster or select a subset of records (row) and/or variables (columns) from a SpatVector.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,numeric,missing'
x[[i, j]]

## S4 method for signature 'SpatRasterDataset,ANY,ANY'
x[[i, j, drop=TRUE]]

## S4 method for signature 'SpatVector,numeric,missing'
x[[i, j, drop=FALSE]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_double_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="subset_double_+3A_i">i</code></td>
<td>

<p>if <code>x</code> is a <code>SpatRaster</code>: integer, logical, or character to select layers
</p>
<p>if <code>x</code> is a <code>SpatVector</code>: integer, logical, or character to select variables
</p>
</td></tr>
<tr><td><code id="subset_double_+3A_j">j</code></td>
<td>
<p>missing, or, for SpatRasterDataset only, numeric</p>
</td></tr>
<tr><td><code id="subset_double_+3A_drop">drop</code></td>
<td>
<p>logical. If <code>TRUE</code>, the geometries will be dropped, and a data.frame is returned</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>if <code>x</code> is a <code>SpatRaster</code> or <code>SpatRasterDataset</code>: SpatRaster
</p>
<p>if <code>x</code> is a <code>SpatVector</code>: a <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset">subset</a></code>, <code><a href="#topic++24">$</a></code>, <code><a href="#topic++5B">[</a></code>, <code><a href="#topic+extract">extract</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### SpatRaster
s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
s[[ 1:2 ]]

s[[c("red", "green")]]

# expression based (partial) matching of names with single brackets
s["re"]
s["^re"]

# does not with double brackets
# s[["re"]]


### SpatVector

v &lt;- vect(system.file("ex/lux.shp", package="terra"))
v[[2:3]]

# to keep the geometry use
v[,2:3]
</code></pre>

<hr>
<h2 id='subset_single'>Extract values from a SpatRaster, SpatVector or SpatExtent</h2><span id='topic++5B'></span><span id='topic++5B+2CSpatExtent+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CSpatExtent+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2CSpatRaster+2CANY+2CANY-method'></span><span id='topic++5B+2CSpatRasterDataset+2Clogical+2Cmissing-method'></span><span id='topic++5B+2CSpatRasterDataset+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2CSpatRasterDataset+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CSpatRasterDataset+2Cnumeric+2Cnumeric-method'></span><span id='topic++5B+2CSpatRasterDataset+2Cnumeric+2Clogical-method'></span><span id='topic++5B+2CSpatRasterDataset+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+2CSpatRasterDataset+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CSpatRasterCollection+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+2CSpatVector+2Cmissing+2Ccharacter-method'></span><span id='topic++5B+2CSpatVector+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CSpatVector+2Ccharacter+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2Cnumeric+2Cnumeric-method'></span><span id='topic++5B+2CSpatVector+2Cnumeric+2Ccharacter-method'></span><span id='topic++5B+2CSpatVector+2Cnumeric+2Clogical-method'></span><span id='topic++5B+2CSpatVector+2Clogical+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2Clogical+2Ccharacter-method'></span><span id='topic++5B+2CSpatVector+2Clogical+2Cnumeric-method'></span><span id='topic++5B+2CSpatVector+2Clogical+2Clogical-method'></span><span id='topic++5B+2CSpatVector+2Cdata.frame+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2Cdata.frame+2CANY-method'></span><span id='topic++5B+2CSpatVector+2Cmatrix+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2CSpatVector+2Cmissing-method'></span><span id='topic++5B+2CSpatVector+2CSpatExtent+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2CSpatVector+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2Cmissing+2Cnumeric-method'></span><span id='topic++5B+2CSpatRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic++5B+2CSpatRaster+2Cdata.frame+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2Cmatrix+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2CSpatRaster+2Cmissing-method'></span><span id='topic++5B+2CSpatRaster+2CSpatExtent+2Cmissing-method'></span>

<h3>Description</h3>

<p>Extract values from a SpatRaster; a subset of records (row) and/or variables (columns) from a SpatVector; or a number from a SpatExtent.  
</p>
<p>You can use indices (row, column, layer or cell numbers) to extract. You can also use other Spat* objects. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,ANY,ANY,ANY'
x[i, j, k]

## S4 method for signature 'SpatVector,numeric,numeric'
x[i, j, drop=FALSE]

## S4 method for signature 'SpatVector,SpatVector,missing'
x[i, j]

## S4 method for signature 'SpatExtent,numeric,missing'
x[i, j]

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_single_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="subset_single_+3A_i">i</code></td>
<td>

<p>if <code>x</code> is a <code>SpatRaster</code>: numeric, logical or missing to select rows or, if <code>j</code> is missing, to select cells numbers.
</p>
<p>if <code>x</code> is a <code>SpatVector</code>: numeric or missing to select rows. 
if <code>i</code> is another SpatVector: get a new SpatVector with the geometries that intersect.
</p>
<p>if <code>x</code> is a <code>SpatExtent</code>: integer between 1 and 4.
</p>
</td></tr>
<tr><td><code id="subset_single_+3A_j">j</code></td>
<td>
<p>numeric, logical, or missing to select columns</p>
</td></tr>
<tr><td><code id="subset_single_+3A_k">k</code></td>
<td>
<p>numeric, character, or missing to select layers</p>
</td></tr>
<tr><td><code id="subset_single_+3A_drop">drop</code></td>
<td>
<p>logical. If <code>FALSE</code> an object of the same class as <code>x</code> is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric if <code>x</code> is a SpatExtent. 
Same as <code>x</code> if <code>drop=FALSE</code>. Otherwise a data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract">extract</a></code>, <code><a href="#topic+subset">subset</a></code>, <code><a href="#topic++24">$</a></code>, <code><a href="#topic++5B+5B">[[</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### SpatRaster
f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
r[3638]
rowColFromCell(r, 2638)
r[39, 28]
x &lt;- r[39:40, 28:29, drop=FALSE] 
as.matrix(x, wide=TRUE)

### SpatVector

v &lt;- vect(system.file("ex/lux.shp", package="terra"))
v[2:3,]
v[1:2, 2:3]
v[1:2, 2:3, drop=TRUE]
</code></pre>

<hr>
<h2 id='subst'>replace cell values</h2><span id='topic+subst'></span><span id='topic+subst+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Substitute(replace) cell values of a SpatRaster with a new value. See <code><a href="#topic+classify">classify</a></code> for more complex/flexible replacement. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
subst(x, from, to, others=NULL, raw=FALSE, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subst_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="subst_+3A_from">from</code></td>
<td>
<p>numeric value(s). Normally a vector of the same length as 'to'. If <code>x</code> has multiple layers, it can also be a matrix of numeric value(s) where <code>nrow(x) == length(to)</code>. In that case the output has a single layer, with values based on the combination of the values of the input layers</p>
</td></tr>
<tr><td><code id="subst_+3A_to">to</code></td>
<td>
<p>numeric value(s). Normally a vector of the same length as 'from'. If <code>x</code> has a single layer, it can also be a matrix of numeric value(s) where <code>nrow(x) == length(from)</code>. In that case the output has multiple layers, one for each column in <code>to</code></p>
</td></tr> 
<tr><td><code id="subst_+3A_others">others</code></td>
<td>
<p>numeric. If not <code>NULL</code> all values that are not matched are set to this value. Otherwise they retain their original value.</p>
</td></tr> 
<tr><td><code id="subst_+3A_raw">raw</code></td>
<td>
<p>logical. If <code>TRUE</code>, the values in from and to are the raw cell values, not the categorical labels. Only relevant if <code>is.factor(x)</code></p>
</td></tr>
<tr><td><code id="subst_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="subst_+3A_...">...</code></td>
<td>
<p>Additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+classify">classify</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=5, nrows=5, xmin=0, xmax=1, ymin=0, ymax=1, crs="")
r &lt;- init(r, 1:6)
x &lt;- subst(r, 3, 7)
x &lt;- subst(r, 2:3, NA)
x &lt;- subst(x, NA, 10)

# multiple output layers
z &lt;- subst(r, 2:3, cbind(20,30))

# multiple input layers
rr &lt;- c(r, r+1, r+2)
m &lt;- rbind(c(1:3), c(3:5))
zz &lt;- subst(rr, m, c(100, 200))
</code></pre>

<hr>
<h2 id='summarize'>Summarize</h2><span id='topic+Summary-methods'></span><span id='topic+median'></span><span id='topic+mean'></span><span id='topic+min'></span><span id='topic+max'></span><span id='topic+which.min'></span><span id='topic+which.max'></span><span id='topic+any'></span><span id='topic+all'></span><span id='topic+prod'></span><span id='topic+range'></span><span id='topic+sum'></span><span id='topic+anyNA'></span><span id='topic+allNA'></span><span id='topic+noNA'></span><span id='topic+countNA'></span><span id='topic+mean+2CSpatRaster-method'></span><span id='topic+mean+2CSpatVector-method'></span><span id='topic+mean+2CSpatExtent-method'></span><span id='topic+median+2CSpatRaster-method'></span><span id='topic+median+2CSpatVector-method'></span><span id='topic+min+2CSpatRaster-method'></span><span id='topic+max+2CSpatRaster-method'></span><span id='topic+range+2CSpatRaster-method'></span><span id='topic+which.min+2CSpatRaster-method'></span><span id='topic+which.max+2CSpatRaster-method'></span><span id='topic+any+2CSpatRaster-method'></span><span id='topic+all+2CSpatRaster-method'></span><span id='topic+prod+2CSpatRaster-method'></span><span id='topic+range+2CSpatRaster-method'></span><span id='topic+sum+2CSpatRaster-method'></span><span id='topic+anyNA+2CSpatRaster-method'></span><span id='topic+allNA+2CSpatRaster-method'></span><span id='topic+noNA+2CSpatRaster-method'></span><span id='topic+countNA+2CSpatRaster-method'></span><span id='topic+stdev'></span><span id='topic+stdev+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute summary statistics for cells, either across layers or between layers (parallel summary). 
</p>
<p>The following summary methods are available for SpatRaster: <code>any, anyNA, all, allNA, max, min, mean, median, prod, range, stdev, sum, which.min, which.max</code>. See <code><a href="#topic+modal">modal</a></code> to compute the mode and <code><a href="#topic+app">app</a></code> to compute summary statistics that are not included here.
</p>
<p>Because generic functions are used, the method applied is chosen based on the first argument: &quot;<code>x</code>&quot;. This means that if <code>r</code> is a SpatRaster, <code>mean(r, 5)</code> will work, but <code>mean(5, r)</code> will not work.
</p>
<p>The <code>mean</code> method has an argument &quot;trim&quot; that is ignored.
</p>
<p>If <code>pop=TRUE</code> <code>stdev</code> computes the population standard deviation, computed as:
</p>
<p><code>f &lt;- function(x) sqrt(sum((x-mean(x))^2) / length(x))</code>
</p>
<p>This is different than the sample standard deviation returned by <code>sd</code> (which uses <code>n-1</code> as denominator). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
min(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
max(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
range(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
prod(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
sum(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
any(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
all(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
range(x, ..., na.rm=FALSE)

## S4 method for signature 'SpatRaster'
which.min(x)

## S4 method for signature 'SpatRaster'
which.max(x)

## S4 method for signature 'SpatRaster'
stdev(x, ..., pop=TRUE, na.rm=FALSE)

## S4 method for signature 'SpatRaster'
mean(x, ..., trim=NA, na.rm=FALSE)

## S4 method for signature 'SpatRaster'
median(x, na.rm=FALSE, ...)

## S4 method for signature 'SpatRaster'
anyNA(x)

## S4 method for signature 'SpatRaster'
countNA(x, n=0)

## S4 method for signature 'SpatRaster'
noNA(x, falseNA=FALSE)

## S4 method for signature 'SpatRaster'
allNA(x, falseNA=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>additional SpatRasters or numeric values; and arguments <code>par</code> for parallel summarization (see Details), and <code>filename</code>, <code>overwrite</code> and <code>wopt</code> as for <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="summarize_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code> values are ignored. If <code>FALSE</code>, <code>NA</code> is returned if <code>x</code> has any <code>NA</code> values</p>
</td></tr>
<tr><td><code id="summarize_+3A_trim">trim</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="summarize_+3A_pop">pop</code></td>
<td>
<p>logical. If <code>TRUE</code>, the population standard deviation is computed. Otherwise the sample standard deviation is computed</p>
</td></tr>
<tr><td><code id="summarize_+3A_falsena">falseNA</code></td>
<td>
<p>logical. If <code>TRUE</code>, cells that would otherwise be <code>FALSE</code> are set to <code>NA</code></p>
</td></tr>
<tr><td><code id="summarize_+3A_n">n</code></td>
<td>
<p>integer. If <code>n &gt; 0</code>, cell values are <code>TRUE</code> if at least <code>n</code> of its layers are <code>NA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additional argument <code>par</code> can be used for &quot;parallel&quot; summarizing a SpatRaster and a numeric or logical value. If a SpatRaster <code>x</code> has three layers, <code>max(x, 5)</code> will return a single layer (the number five is treated as a layer in which all cells have value five). In contrast <code>max(x, 5, par=TRUE)</code> returns three layers (the number five is treated as another SpatRaster with a single layer with all cells having the value five.
</p>


<h3>Value</h3>

<p>SpatRaster</p>


<h3>See Also</h3>

<p><code><a href="#topic+app">app</a></code>, <code><a href="#topic+Math-methods">Math-methods</a></code>, <code><a href="#topic+modal">modal</a></code>, <code><a href="#topic+which.lyr">which.lyr</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
r &lt;- rast(nrows=10, ncols=10, nlyrs=3)
values(r) &lt;- runif(ncell(r) * nlyr(r))

x &lt;- mean(r)
# note how this returns one layer
x &lt;- sum(c(r, r[[2]]), 5)

# and this returns three layers
y &lt;- sum(r, r[[2]], 5)

max(r)

## when adding a number, do you want 1 layer or all layers?
# 1 layer
max(r, 0.5)

# all layers
max(r, 0.5, par=TRUE)

y &lt;- stdev(r)
# not the same as 
yy &lt;- app(r, sd)

z &lt;- stdev(r, r*2)

x &lt;- mean(r, filename=paste0(tempfile(), ".tif"))


v &lt;- values(r)
set.seed(3)
v[sample(length(v), 50)] &lt;- NA
values(r) &lt;- v
is.na(r)
anyNA(r)
allNA(r)
countNA(r)
countNA(r, 2)
</code></pre>

<hr>
<h2 id='summary'>summary</h2><span id='topic+summary'></span><span id='topic+summary+2CSpatRaster-method'></span><span id='topic+summary+2CSpatVector-method'></span><span id='topic+Summary+2CSpatExtent-method'></span><span id='topic+Summary+2CSpatRaster-method'></span><span id='topic+Summary+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Compute summary statistics (min, max, mean, and quartiles) for SpatRaster using base <code><a href="base.html#topic+summary">summary</a></code> method. A sample is used for very large files. 
</p>
<p>For single or other statistics see <code><a href="#topic+Summary-methods">Summary-methods</a></code>, <code><a href="#topic+global">global</a></code>, and <code><a href="#topic+quantile">quantile</a></code> 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
summary(object, size=100000, warn=TRUE, ...)

## S4 method for signature 'SpatVector'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="summary_+3A_size">size</code></td>
<td>
<p>positive integer. Size of a regular sample used for large datasets (see <code><a href="#topic+spatSample">spatSample</a></code>)</p>
</td></tr>
<tr><td><code id="summary_+3A_warn">warn</code></td>
<td>
<p>logical. If <code>TRUE</code> a warning is given if a sample is used</p>
</td></tr>  
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to the base <code><a href="base.html#topic+summary">summary</a> method</code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>matrix with (an estimate of) the median, minimum and maximum values, the first and third quartiles, and the number of cells with <code>NA</code> values</p>


<h3>See Also</h3>

 <p><code><a href="#topic+Summary-methods">Summary-methods</a></code>, <code><a href="#topic+global">global</a></code>, <code><a href="#topic+quantile">quantile</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
r &lt;- rast(nrows=10, ncols=10, nlyrs=3)
values(r) &lt;- runif(nlyr(r)*ncell(r))
summary(r)
</code></pre>

<hr>
<h2 id='svc'>Create a SpatVectorCollection</h2><span id='topic+svc'></span><span id='topic+svc+2Cmissing-method'></span><span id='topic+svc+2Ccharacter-method'></span><span id='topic+svc+2Clist-method'></span><span id='topic+svc+2Csf-method'></span><span id='topic+svc+2CSpatVector-method'></span><span id='topic++5B+3C-+2CSpatVectorCollection+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2CSpatVectorCollection+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+2CSpatVectorCollection+2Cnumeric+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods to create a SpatVectorCollection. This is an object to hold &quot;sub-datasets&quot;, each a SpatVector, perhaps of different geometry type. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
svc(x) 

## S4 method for signature 'SpatVector'
svc(x, ...) 

## S4 method for signature 'list'
svc(x) 

## S4 method for signature 'character'
svc(x, layer="", query="", extent=NULL, filter=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svc_+3A_x">x</code></td>
<td>
<p>SpatVector, character (filename), list with SpatVectors, or missing</p>
</td></tr>
<tr><td><code id="svc_+3A_...">...</code></td>
<td>
<p>Additional <code>SpatVector</code>s</p>
</td></tr> 
<tr><td><code id="svc_+3A_layer">layer</code></td>
<td>
<p>character. layer name to select a layer from a file (database) with multiple layers</p>
</td></tr>
<tr><td><code id="svc_+3A_query">query</code></td>
<td>
<p>character. An query to subset the dataset in the <a href="https://gdal.org/user/ogr_sql_dialect.html">OGR-SQL dialect</a></p>
</td></tr>
<tr><td><code id="svc_+3A_extent">extent</code></td>
<td>
<p>Spat* object. The extent of the object is used as a spatial filter to select the geometries to read. Ignored if <code>filter</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="svc_+3A_filter">filter</code></td>
<td>
<p>SpatVector. Used as a spatial filter to select geometries to read (the convex hull is used for lines or points). It is guaranteed that all features that overlap with the extent of filter will be returned. It can happen that additional geometries are returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVectorCollection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
x &lt;- svc()
x &lt;- svc(v, v[1:3,], as.lines(v[3:5,]), as.points(v))
length(x)
x

# extract
x[3]

# replace
x[2] &lt;- as.lines(v[1,])


</code></pre>

<hr>
<h2 id='symdif'> 
Symmetrical difference
</h2><span id='topic+symdif'></span><span id='topic+symdif+2CSpatVector+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Symmetrical difference of polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatVector'
symdif(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symdif_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="symdif_+3A_y">y</code></td>
<td>
<p>SpatVector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+erase">erase</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- vect(system.file("ex/lux.shp", package="terra"))
b &lt;- as.polygons(ext(6, 6.4, 49.75, 50))
#sd &lt;- symdif(p, b)
#plot(sd, col=rainbow(12))
</code></pre>

<hr>
<h2 id='tapp'>Apply a function to subsets of layers of a SpatRaster</h2><span id='topic+tapp'></span><span id='topic+tapp+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Apply a function to subsets of layers of a SpatRaster (similar to <code><a href="base.html#topic+tapply">tapply</a></code> and <code><a href="stats.html#topic+aggregate">aggregate</a></code>). The layers are combined based on the <code>index</code>.
</p>
<p>The number of layers in the output SpatRaster equals the number of unique values in <code>index</code> times the number of values that the supplied function returns for a single vector of numbers.
</p>
<p>For example, if you have a SpatRaster with 6 layers, you can use <code>index=c(1,1,1,2,2,2)</code> and <code>fun=sum</code>. This will return a SpatRaster with two layers. The first layer is the sum of the first three layers in the input SpatRaster, and the second layer is the sum of the last three layers in the input SpatRaster. Indices are recycled such that <code>index=c(1,2)</code> would also return a SpatRaster with two layers (one based on the odd layers (1,3,5), the other based on the even layers (2,4,6)). 
</p>
<p>The index can also be one of the following values to group by time period (if <code>x</code> has the appropriate <code><a href="#topic+time">time</a></code> values): &quot;years&quot;, &quot;months&quot;, &quot;yearmonths&quot;, &quot;week&quot; (the ISO 8601 week number, see Details), &quot;yearweeks&quot;, &quot;days&quot;, &quot;doy&quot; (day of the year), &quot;7days&quot; (seven-day periods starting at Jan 1 of each year), &quot;10days&quot;, or &quot;15days&quot;. It can also be a function that makes groups from time values.
</p>
<p>See <code><a href="#topic+app">app</a></code> or <code><a href="#topic+Summary-methods">Summary-methods</a></code> if you want to use a more efficient function that returns multiple layers based on <b>all</b> layers in the SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
tapp(x, index, fun, ..., cores=1, filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tapp_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="tapp_+3A_index">index</code></td>
<td>
<p>factor or numeric (integer). Vector of length <code>nlyr(x)</code> (shorter vectors are recycled) grouping the input layers. It can also be one of the following values: &quot;years&quot;, &quot;months&quot;, &quot;yearmonths&quot;, &quot;days&quot;, &quot;week&quot; (ISO 8601 week number), or &quot;doy&quot; (day of the year)</p>
</td></tr>
<tr><td><code id="tapp_+3A_fun">fun</code></td>
<td>
<p>function to be applied. The following functions have been re-implemented in C++ for speed: &quot;sum&quot;, &quot;mean&quot;, &quot;median&quot;, &quot;modal&quot;, &quot;which&quot;, &quot;which.min&quot;, &quot;which.max&quot;, &quot;min&quot;, &quot;max&quot;, &quot;prod&quot;, &quot;any&quot;, &quot;all&quot;, &quot;sd&quot;, &quot;std&quot;, &quot;first&quot;. To use the base-R function for say, &quot;min&quot;, you could use something like <code>fun = \(i) min(i)</code></p>
</td></tr>
<tr><td><code id="tapp_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>fun</code></p>
</td></tr>
<tr><td><code id="tapp_+3A_cores">cores</code></td>
<td>
<p>positive integer. If <code>cores &gt; 1</code>, a 'parallel' package cluster with that many cores is created and used. You can also supply a cluster object. Ignored for functions that are implemented by terra in C++ (see under fun)</p>
</td></tr>  
<tr><td><code id="tapp_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="tapp_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="tapp_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;week&quot; follows the ISO 8601 definition. Weeks start on Monday. If the week containing 1 January has four or more days in the new year, then it is considered week &quot;01&quot;. Otherwise, it is the last week of the previous year (week &quot;52&quot; or &quot;53&quot;, and the next week is week 1.
</p>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+app">app</a></code>, <code><a href="#topic+Summary-methods">Summary-methods</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- 1:ncell(r)
s &lt;- c(r, r, r, r, r, r)
s &lt;- s * 1:6
b1 &lt;- tapp(s, index=c(1,1,1,2,2,2), fun=sum)
b1
b2 &lt;- tapp(s, c(1,2,3,1,2,3), fun=sum)
b2
</code></pre>

<hr>
<h2 id='terra-package'>Description of the methods in the terra package</h2><span id='topic+terra-package'></span><span id='topic+terra'></span>

<h3>Description</h3>

<p><code>terra</code> provides methods to manipulate geographic (spatial) data in &quot;raster&quot; and &quot;vector&quot; form. Raster data divide space into rectangular grid cells and they are commonly used to represent spatially continuous phenomena, such as elevation or the weather. Satellite images also have this data structure, and in that context grid cells are often referred to as pixels. In contrast, &quot;vector&quot; spatial data (points, lines, polygons) are typically used to represent discrete spatial entities, such as a road, country, or bus stop. 
</p>
<p>The package implements two main classes (data types): <code>SpatRaster</code> and <code>SpatVector</code>. <code>SpatRaster</code> supports handling large raster files that cannot be loaded into memory; local, focal, zonal, and global raster operations; polygon, line and point to raster conversion; integration with modeling methods to make spatial predictions; and more. <code>SpatVector</code> supports all types of geometric operations such as intersections.
</p>
<p>Additional classes include <code>SpatExtent</code>, which is used to define a spatial extent (bounding box); <code>SpatRasterDataset</code>, which represents a collection of sub-datasets for the same area. Each sub-dataset is a SpatRaster with possibly many layers, and may, for example, represent different weather variables; and <code>SpatRasterCollection</code> and <code>SpatVectorCollection</code> that are equivalent to lists of <code>SpatRaster</code> or <code>SpatVector</code> objects. There is also a <code>SpatGraticule</code> class to assist in adding a longitude/latitude lines and labels to a map with another coordinate reference system.
</p>
<p>These classes hold a C++ pointer to the data &quot;reference class&quot; and that creates some limitations. They cannot be recovered from a saved R session either or directly passed to nodes on a computer cluster. Generally, you should use <code><a href="#topic+writeRaster">writeRaster</a></code> to save <code>SpatRaster</code> objects to disk (and pass a filename or cell values to cluster nodes). Also see <code><a href="#topic+wrap">wrap</a></code>. Also, package developers should not directly access this pointer, as its user-interface is not stable.
</p>
<p>The <code>terra</code> package is conceived as a replacement of the <code>raster</code> package. <code>terra</code> has a very similar, but simpler, interface, and it is faster than <code>raster</code>. At the bottom of this page there is a table that shows differences in the methods between the two packages. 
</p>
<p>Below is a list of some of the most important methods grouped by theme. 
</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
</p>


<h3><b>SpatRaster</b></h3>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>


<h3>I. Creating, combining and sub-setting</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rast">rast</a></code></td><td style="text-align: left;"> Create a SpatRaster from scratch, file, or another object</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+c">c</a></code> </td><td style="text-align: left;"> Combine SpatRasters (multiple layers)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+add+3C-">add&lt;-</a></code> </td><td style="text-align: left;"> Add a SpatRaster to another one</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+subset">subset</a></code> or <code>[[</code>, or <code>$</code> </td><td style="text-align: left;"> Select layers of a SpatRaster</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+selectRange">selectRange</a></code> </td><td style="text-align: left;"> Select cell values from different layers using an index layer</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>II. Changing the spatial extent or resolution</h3>

<p>Also see the methods in section VIII
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+merge">merge</a></code> </td><td style="text-align: left;"> Combine SpatRasters with different extents (but same origin and resolution) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mosaic">mosaic</a></code> </td><td style="text-align: left;"> Combine SpatRasters with different extents using a function for overlapping cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crop">crop</a></code> </td><td style="text-align: left;"> Select a geographic subset of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extend">extend</a></code> </td><td style="text-align: left;"> Add rows and/or columns to a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+trim">trim</a></code> </td><td style="text-align: left;"> Trim a SpatRaster by removing exterior rows and/or columns that only have NAs</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+aggregate">aggregate</a></code> </td><td style="text-align: left;"> Combine cells of a SpatRaster to create larger cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+disagg">disagg</a></code> </td><td style="text-align: left;"> Subdivide cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+resample">resample</a></code> </td><td style="text-align: left;"> Resample (warp) values to a SpatRaster with a different origin and/or resolution </td>
</tr>
<tr>
 <td style="text-align: left;"> 
	<code><a href="#topic+project">project</a></code> </td><td style="text-align: left;"> Project (warp) values to a SpatRaster with a different coordinate reference system </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+shift">shift</a></code> </td><td style="text-align: left;"> Adjust the location of SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+flip">flip</a></code> </td><td style="text-align: left;">  Flip values horizontally or vertically </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rotate">rotate</a></code> </td><td style="text-align: left;"> Rotate values around the date-line (for lon/lat data) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+t">t</a></code> </td><td style="text-align: left;"> Transpose a SpatRaster</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>III. Local (cell based) methods</h3>



<h4>Apply-like methods</h4>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+app">app</a></code> </td><td style="text-align: left;"> Apply a function to all cells, across layers, typically to summarize (as in <code>base::apply</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+tapp">tapp</a></code> </td><td style="text-align: left;"> Apply a function to groups of layers (as in <code>base::tapply</code> and <code>stats::aggregate</code>)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+lapp">lapp</a></code> </td><td style="text-align: left;"> Apply a function to using the layers of a SpatRaster as variables</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sapp">sapp</a></code> </td><td style="text-align: left;"> Apply a function to each layer</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rapp">rapp</a></code> </td><td style="text-align: left;"> Apply a function to a spatially variable range of layers</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>




<h4>Arithmetic, logical, and standard math methods</h4>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Arith-methods">Arith-methods</a></code> </td><td style="text-align: left;"> Standard arithmetic methods (<code>+, -, *, ^, %%, %/%, /</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Compare-methods">Compare-methods</a></code> </td><td style="text-align: left;"> Comparison methods for SpatRaster (<code>==, !=, &gt;, &lt;, &lt;=, &gt;=m is.na, is.finite</code>) </td>
</tr>
<tr>
 <td style="text-align: left;"> 	
    <code><a href="#topic+not.na">not.na</a></code> </td><td style="text-align: left;"> a one-step equivalent to <code>!is.na</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Summary-methods">Summary-methods</a></code> </td><td style="text-align: left;"> <code>mean, max, min, median, sum, range, prod,</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <code>any, all, stdev, which.min, which.max, anyNA, noNA, allNA</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Logic-methods">Logic-methods</a></code> </td><td style="text-align: left;"> Boolean methods (<code>!, &amp;, |</code>) </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+Math-methods">Math-methods</a></code> </td><td style="text-align: left;"> <code>abs, sign, sqrt, ceiling, floor, trunc, cummax, cummin, cumprod,</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td><td style="text-align: left;"> <code>cumsum, log, log10, log2, log1p, acos, acosh, asin, asinh, atan, atanh,</code> </td>
</tr>
<tr>
 <td style="text-align: left;">	 
	</td><td style="text-align: left;"> <code>exp, expm1, cos, cosh, sin, sinh, tan, tanh, round, signif</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.bool">as.bool</a></code></td><td style="text-align: left;"> create a Boolean (logical) SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.int">as.int</a></code></td><td style="text-align: left;"> create an integer (whole numbers) SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>




<h4>Other methods</h4>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+approximate">approximate</a></code> </td><td style="text-align: left;"> Compute missing values for cells by interpolation across layers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+roll">roll</a></code> </td><td style="text-align: left;"> Rolling functions such as the rolling mean </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellSize">cellSize</a></code> </td><td style="text-align: left;"> Compute the area of cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+classify">classify</a></code> </td><td style="text-align: left;"> (Re-)classify values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+subst">subst</a></code> </td><td style="text-align: left;"> Substitute (replace) cell values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cover">cover</a></code> </td><td style="text-align: left;"> First layer covers second layer except where the first layer is <code>NA</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+init">init</a></code> </td><td style="text-align: left;"> Initialize cells with new values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mask">mask</a></code> </td><td style="text-align: left;"> Replace values in a SpatRaster based on values in another SpatRaster</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+which.lyr">which.lyr</a></code> </td><td style="text-align: left;"> which is the first layer that is <code>TRUE</code>?</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+segregate">segregate</a></code> </td><td style="text-align: left;"> Make a 0/1 layer for each unique value </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rangeFill">rangeFill</a></code> </td><td style="text-align: left;"> Make a 0/1 SpatRaster for a time series </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+regress">regress</a></code> </td><td style="text-align: left;"> Cell-based regression models </td>
</tr>
<tr>
 <td style="text-align: left;">
	
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>




<h3>IV. Zonal and global methods</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+expanse">expanse</a></code> </td><td style="text-align: left;"> Compute the summed area of cells </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crosstab">crosstab</a></code> </td><td style="text-align: left;"> Cross-tabulate two SpatRasters</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+freq">freq</a></code> </td><td style="text-align: left;"> Frequency table of SpatRaster cell values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+global">global</a></code> </td><td style="text-align: left;"> Summarize SpatRaster cell values with a function </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+quantile">quantile</a></code> </td><td style="text-align: left;"> Quantiles </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+layerCor">layerCor</a></code> </td><td style="text-align: left;"> Correlation between layers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+stretch">stretch</a></code> </td><td style="text-align: left;"> Stretch values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+scale">scale</a></code> </td><td style="text-align: left;"> Scale values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+summary">summary</a></code> </td><td style="text-align: left;"> Summary of the values of a SpatRaster (quartiles and mean) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+unique">unique</a></code> </td><td style="text-align: left;"> Get the unique values in a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+zonal">zonal</a></code> </td><td style="text-align: left;"> Summarize a SpatRaster by zones in another SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>V. Situation (spatial context) based methods</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+adjacent">adjacent</a></code> </td><td style="text-align: left;"> Identify cells that are adjacent to a set of cells of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+boundaries">boundaries</a></code> </td><td style="text-align: left;"> Detection of boundaries (edges)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+distance">distance</a></code> </td><td style="text-align: left;"> Shortest distance to a cell that is not <code>NA</code> or to or from a vector object</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+gridDist">gridDist</a></code> </td><td style="text-align: left;"> Shortest distance through adjacent grid cells</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+costDist">costDist</a></code> </td><td style="text-align: left;"> Shortest distance considering cell-varying friction </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+direction">direction</a></code> </td><td style="text-align: left;"> Direction (azimuth) to or from cells that are not <code>NA</code></td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+focal">focal</a></code> </td><td style="text-align: left;"> Focal (neighborhood; moving window) functions </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+focal3D">focal3D</a></code> </td><td style="text-align: left;"> Three dimensional (row, col, lyr) focal functions </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+focalCpp">focalCpp</a></code> </td><td style="text-align: left;"> Faster focal by using custom C++ functions </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+focalReg">focalReg</a></code> </td><td style="text-align: left;"> Regression between layers for focal areas </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+focalPairs">focalPairs</a></code> </td><td style="text-align: left;"> Apply a function (e.g. a correlation coefficient) to focal values for pairs of layers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+patches">patches</a></code> </td><td style="text-align: left;"> Find patches (clumps) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sieve">sieve</a></code> </td><td style="text-align: left;"> Sieve filter to remove small patches</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+terrain">terrain</a></code> </td><td style="text-align: left;"> Compute slope, aspect and other terrain characteristics from elevation data </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+viewshed">viewshed</a></code> </td><td style="text-align: left;"> Compute viewshed (showing areas that are visible from a particular location </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+shade">shade</a></code> </td><td style="text-align: left;"> Compute hill shade from slope and aspect layers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+autocor">autocor</a></code> </td><td style="text-align: left;"> Compute global or local spatial autocorrelation  </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>VI. Model predictions</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+predict">predict</a></code> </td><td style="text-align: left;"> Predict a non-spatial (regression or classification) model to a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+interpolate">interpolate</a></code> </td><td style="text-align: left;"> Predict a spatial model to a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+interpIDW">interpIDW</a></code> </td><td style="text-align: left;"> Inverse-distance-weighted interpolation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+interpNear">interpNear</a></code> </td><td style="text-align: left;"> Nearest neighbor interpolation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+k_means">k_means</a></code> </td><td style="text-align: left;"> k-means clustering of SpatRaster data </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+princomp">princomp</a> and <a href="#topic+prcomp">prcomp</a></code> </td><td style="text-align: left;"> Principal Component Analysis (PCA) with raster data</td>
</tr>
<tr>
 <td style="text-align: left;">
	
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>VII. Accessing cell values</h3>

<p>Apart from the function listed below, you can also use indexing with <code>[</code> with cell numbers, and row and/or column numbers <br />
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+values">values</a></code> </td><td style="text-align: left;"> cell values (fails with very large rasters)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+values+3C-">values&lt;-</a></code> </td><td style="text-align: left;"> Set new values to the cells of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+setValues">setValues</a></code> </td><td style="text-align: left;"> Set new values to the cells of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.matrix">as.matrix</a></code> </td><td style="text-align: left;"> Get cell values as a matrix </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.array">as.array</a></code> </td><td style="text-align: left;"> Get cell values as an array </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extract">extract</a></code> </td><td style="text-align: left;"> Extract cell values from a SpatRaster (with cell numbers, coordinates, points, lines, or polygons)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extractAlong">extractAlong</a></code> </td><td style="text-align: left;"> Extract cell values along a line such that the values are in the right order</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+spatSample">spatSample</a></code> </td><td style="text-align: left;"> Regular or random sample </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+minmax">minmax</a></code> </td><td style="text-align: left;"> Get the minimum and maximum value of the cells of a SpatRaster (if known) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+setMinMax">setMinMax</a></code> </td><td style="text-align: left;"> Compute the minimum and maximum value of a SpatRaster if these are not known </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+extract">extract</a></code> </td><td style="text-align: left;"> spatial queries of a SpatRaster with a SpatVector</td>
</tr>
<tr>
 <td style="text-align: left;">

  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>VIII. Getting and setting dimensions </h3>

<p>Get or set basic parameters of SpatRasters. If there are values associated with a SpatRaster (either in memory or via a link to a file) these are lost when you change the number of columns or rows or the resolution. This is not the case when the extent is changed (as the number of columns and rows will not be affected). Similarly, with <b>crs</b> you can set the coordinate reference system, but this does not transform the data (see <a href="#topic+project">project</a> for that).   
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ncol">ncol</a></code></td><td style="text-align: left;"> The number of columns </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nrow">nrow</a></code> </td><td style="text-align: left;"> The number of rows </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ncell">ncell</a></code> </td><td style="text-align: left;"> The number of cells (can not be set directly, only via ncol or nrow) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+res">res</a></code> </td><td style="text-align: left;"> The resolution (x and y) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+nlyr">nlyr</a></code> </td><td style="text-align: left;"> Get or set the number of layers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+names">names</a></code> </td><td style="text-align: left;"> Get or set the layer names </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xres">xres</a></code> </td><td style="text-align: left;"> The x resolution (can be set with res) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+yres">yres</a></code> </td><td style="text-align: left;"> The y resolution (can be set with res)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xmin">xmin</a></code> </td><td style="text-align: left;"> The minimum x coordinate (or longitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xmax">xmax</a></code> </td><td style="text-align: left;"> The maximum x coordinate (or longitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ymin">ymin</a></code> </td><td style="text-align: left;"> The minimum y coordinate (or latitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ymax">ymax</a></code> </td><td style="text-align: left;"> The maximum y coordinate (or latitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+ext">ext</a></code> </td><td style="text-align: left;"> Get or set the extent (minimum and maximum x and y coordinates ("bounding box") </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+origin">origin</a></code> </td><td style="text-align: left;"> The origin of a SpatRaster</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crs">crs</a></code> </td><td style="text-align: left;"> The coordinate reference system (map projection) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+is.lonlat">is.lonlat</a></code> </td><td style="text-align: left;"> Test if an object has (or may have) a longitude/latitude coordinate reference system</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sources">sources</a></code> </td><td style="text-align: left;"> Get the filename(s) to which a SpatRaster is linked </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+inMemory">inMemory</a></code> </td><td style="text-align: left;"> Are the data sources in memory (or on disk)? </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+compareGeom">compareGeom</a></code> </td><td style="text-align: left;"> Compare the geometry of SpatRasters </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+NAflag">NAflag</a></code> </td><td style="text-align: left;"> Set the <code>NA</code> value (for reading from a file with insufficient metadata) </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>IX. Computing row, column, cell numbers and coordinates</h3>

<p>Cell numbers start at 1 in the upper-left corner. They increase within rows, from left to right, and then row by row from top to bottom. Likewise, row numbers start at 1 at the top of the raster, and column numbers start at 1 at the left side of the raster. 
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xFromCol">xFromCol</a></code> </td><td style="text-align: left;"> x-coordinates from column numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+yFromRow">yFromRow</a></code> </td><td style="text-align: left;"> y-coordinates from row numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xFromCell">xFromCell</a></code> </td><td style="text-align: left;"> x-coordinates from row numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+yFromCell">yFromCell</a></code> </td><td style="text-align: left;"> y-coordinates from cell numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+xyFromCell">xyFromCell</a></code> </td><td style="text-align: left;"> x and y coordinates from cell numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+colFromX">colFromX</a></code> </td><td style="text-align: left;"> Column numbers from x-coordinates (or longitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rowFromY">rowFromY</a></code> </td><td style="text-align: left;"> Row numbers from y-coordinates (or latitude) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rowColFromCell">rowColFromCell</a></code> </td><td style="text-align: left;"> Row and column numbers from cell numbers</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellFromXY">cellFromXY</a></code> </td><td style="text-align: left;"> Cell numbers from x and y coordinates </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellFromRowCol">cellFromRowCol</a></code> </td><td style="text-align: left;"> Cell numbers from row and column numbers </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cellFromRowColCombine">cellFromRowColCombine</a></code> </td><td style="text-align: left;"> Cell numbers from all combinations of row and column numbers </td>
</tr>
<tr>
 <td style="text-align: left;">    
	<code><a href="#topic+cells">cells</a></code></td><td style="text-align: left;"> Cell numbers from an SpatVector or SpatExtent</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>X. Time related methods</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+time">time</a></code> </td><td style="text-align: left;"> Get or set time</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+fillTime">fillTime</a></code> </td><td style="text-align: left;"> can add empty layers in between existing layers to assure that the time step between layers is constant </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mergeTime">mergeTime</a></code> </td><td style="text-align: left;"> combine multiple rasters, perhaps partly overlapping in time, into a single time series</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>XI. Methods for categorical rasters</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+is.factor">is.factor</a></code> </td><td style="text-align: left;"> Are there categorical layers?</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+levels">levels</a></code> </td><td style="text-align: left;"> Get active categories, or set categories</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+activeCat">activeCat</a></code> </td><td style="text-align: left;"> Get or set the active category</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cats">cats</a></code> </td><td style="text-align: left;"> Get categories (active and inactive)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+set.cats">set.cats</a></code> </td><td style="text-align: left;"> Set categories in place </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+concats">concats</a></code> </td><td style="text-align: left;"> Combine SpatRasters with different categories</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+catalyze">catalyze</a></code> </td><td style="text-align: left;"> Create a layer for each category </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.numeric">as.numeric</a></code> </td><td style="text-align: left;"> use the active category to create a non-categorical SpatRaster</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.factor">as.factor</a></code> </td><td style="text-align: left;"> Make the layers of a SpatRaster categorical</td>
</tr>
<tr>
 <td style="text-align: left;">


  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>XII. Writing SpatRaster files</h3>



<h4>Basic</h4>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+writeRaster">writeRaster</a></code> </td><td style="text-align: left;"> Write all values of SpatRaster to disk. You can set the filetype, datatype, compression. </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+writeCDF">writeCDF</a></code> </td><td style="text-align: left;"> Write SpatRaster data to a netCDF file</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
 	</td>
</tr>

</table>




<h4>Advanced</h4>


<table>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+readStart">readStart</a></code> </td><td style="text-align: left;"> Open file connections for efficient multi-chunk reading </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+readStop">readStop</a></code> </td><td style="text-align: left;"> Close file connections </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+writeStart">writeStart</a></code> </td><td style="text-align: left;"> Open a file for writing </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+writeValues">writeValues</a></code> </td><td style="text-align: left;"> Write some values  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+writeStop">writeStop</a></code> </td><td style="text-align: left;"> Close the file after writing </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code><a href="#topic+blocks">blocks</a></code> </td><td style="text-align: left;"> Get blocksize for reading files (when not writing) </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h3>XIII. Miscellaneous SpatRaster methods</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+terraOptions">terraOptions</a></code> </td><td style="text-align: left;"> Show, set, or get session options, mostly to control memory use and to set write options</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sources">sources</a></code> </td><td style="text-align: left;"> Show the data sources of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+tmpFiles">tmpFiles</a></code> </td><td style="text-align: left;"> Show or remove temporary files </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+mem_info">mem_info</a></code> </td><td style="text-align: left;"> memory needs and availability </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+inMemory">inMemory</a></code> </td><td style="text-align: left;"> Are the cell values in memory? </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>XIV. SpatRasterDataset</h3>

<p>A SpatRasterDataset contains SpatRasters that represent sub-datasets for the same area. They all have the same extent and resolution.
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+sds">sds</a></code> </td><td style="text-align: left;"> Create a SpatRasterDataset from a file with subdatasets (ncdf or hdf) or from SpatRasters </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>[</code> or <code>$</code> </td><td style="text-align: left;"> Extract a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+names">names</a></code> </td><td style="text-align: left;"> Get the names of the sub-datasets </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>XV. SpatRasterCollections</h3>

<p>A SpatRasterCollection is a vector of SpatRaster objects. Unlike for a SpatRasterDataset, there the extent and resolution of the SpatRasters do not need to match each other. 
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+sprc">sprc</a></code> </td><td style="text-align: left;"> create a SpatRasterCollection from (a list of) SpatRasters</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+length">length</a></code> </td><td style="text-align: left;"> how many SpatRasters does the SpatRasterCollection have?</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+crop">crop</a></code> </td><td style="text-align: left;"> crop a SpatRasterCollection</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+impose">impose</a></code> </td><td style="text-align: left;"> force the members of SpatRasterCollection to the same geometry</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+merge">merge</a></code> </td><td style="text-align: left;"> merge the members of a SpatRasterCollection</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+mosaic">mosaic</a></code> </td><td style="text-align: left;"> mosaic (merge with a function for overlapping areas) the members of a SpatRasterCollection</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic++5B">[</a></code> </td><td style="text-align: left;"> extract a SpatRaster</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3><b>SpatVector</b></h3>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>


<h3>XVI. Create SpatVector objects</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+vect">vect</a></code> </td><td style="text-align: left;"> Create a SpatVector from a file (for example a "shapefile") or from another object</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+vector_layers">vector_layers</a></code> </td><td style="text-align: left;"> list or delete layers in a vector database such as GPGK</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>rbind</code> </td><td style="text-align: left;"> append SpatVectors of the same geometry type</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+unique">unique</a></code> </td><td style="text-align: left;"> remove duplicates </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+na.omit">na.omit</a></code> </td><td style="text-align: left;"> remove empty geometries and/or fields that are <code>NA</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+project">project</a></code> </td><td style="text-align: left;"> Project a SpatVector to a different coordinate reference system </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+writeVector">writeVector</a></code> </td><td style="text-align: left;"> Write SpatVector data to disk </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+centroids">centroids</a></code> </td><td style="text-align: left;"> Get the centroids of a SpatVector</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+voronoi">voronoi</a></code> </td><td style="text-align: left;"> Voronoi diagram </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+delaunay">delaunay</a></code> </td><td style="text-align: left;"> Delaunay triangles</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+convHull">convHull</a></code> </td><td style="text-align: left;"> Compute the convex hull of a SpatVector </td>
</tr>
<tr>
 <td style="text-align: left;">  
  <code><a href="#topic+minRect">minRect</a></code> </td><td style="text-align: left;"> Compute the minimum minimal bounding rotated rectangle of a SpatVector </td>
</tr>
<tr>
 <td style="text-align: left;">  
  <code><a href="#topic+minCircle">minCircle</a></code> </td><td style="text-align: left;"> Compute the minimal bounding circle of a SpatVector </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fillHoles">fillHoles</a></code></td><td style="text-align: left;"> Remove or extract holes from polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>


<h3>XVII. Properties of SpatVector objects</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+geom">geom</a></code> </td><td style="text-align: left;"> returns the geometries as matrix or WKT</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+crds">crds</a></code> </td><td style="text-align: left;"> returns the coordinates as a matrix</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+linearUnits">linearUnits</a></code> </td><td style="text-align: left;"> returns the linear units of the crs (in meter)</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+ncol">ncol</a></code></td><td style="text-align: left;"> The number of columns (of the attributes)</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+nrow">nrow</a></code> </td><td style="text-align: left;"> The number of rows (of the geometries and attributes)</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+names">names</a></code> </td><td style="text-align: left;"> Get or set the layer names </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+ext">ext</a></code> </td><td style="text-align: left;"> Get the extent (minimum and maximum x and y coordinates ("bounding box") </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+crs">crs</a></code> </td><td style="text-align: left;"> The coordinate reference system (map projection) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+is.lonlat">is.lonlat</a></code> </td><td style="text-align: left;"> Test if an object has (or may have) a longitude/latitude coordinate reference system</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>


<h3>XVIII. Geometric queries</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+adjacent">adjacent</a></code> </td><td style="text-align: left;"> find adjacent polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+expanse">expanse</a></code> </td><td style="text-align: left;"> computes the area covered by polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+nearby">nearby</a></code> </td><td style="text-align: left;"> find nearby geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+nearest">nearest</a></code> </td><td style="text-align: left;"> find the nearest geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+relate">relate</a></code> </td><td style="text-align: left;"> geometric relationships such as "intersects", "overlaps", and "touches"</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+perim">perim</a></code> </td><td style="text-align: left;"> computes the length of the perimeter of polygons, and the length of lines</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>


<h3>XIX. Geometric operations</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+erase">erase</a></code> or "-" </td><td style="text-align: left;"> erase (parts of) geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+intersect">intersect</a></code> or "*"  </td><td style="text-align: left;"> intersect geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+union">union</a></code> or "+" </td><td style="text-align: left;"> Merge geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+cover">cover</a></code> </td><td style="text-align: left;"> update polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+symdif">symdif</a></code> </td><td style="text-align: left;"> symmetrical difference of two polygons </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  <code><a href="#topic+aggregate">aggregate</a></code> </td><td style="text-align: left;"> dissolve smaller polygons into larger ones </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+buffer">buffer</a></code> </td><td style="text-align: left;"> buffer geometries </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+disagg">disagg</a></code> </td><td style="text-align: left;"> split multi-geometries into separate geometries </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+crop">crop</a></code> </td><td style="text-align: left;"> clip geometries using a rectangle (SpatExtent) or SpatVector </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>


<h3>XX. SpatVector attributes</h3>

<p>We use the term &quot;attributes&quot; for the tabular data (data.frame) associated with vector geometries.
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+extract">extract</a></code> </td><td style="text-align: left;"> spatial queries between SpatVector and SpatVector (e.g. point in polygons) </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+sel">sel</a></code> </td><td style="text-align: left;"> select - interactively select geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+click">click</a></code> </td><td style="text-align: left;"> identify attributes by clicking on a map</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+merge">merge</a></code> </td><td style="text-align: left;"> Join a table with a SpatVector </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+as.data.frame">as.data.frame</a></code> </td><td style="text-align: left;"> get attributes as a data.frame</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+as.list">as.list</a></code> </td><td style="text-align: left;"> get attributes as a list</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+values">values</a></code> </td><td style="text-align: left;"> Get the attributes of a SpatVector </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+values+3C-">values&lt;-</a></code> </td><td style="text-align: left;"> Set new attributes to the geometries of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">  
  <code><a href="#topic+sort">sort</a></code> </td><td style="text-align: left;"> sort SpatVector by the values in a field </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>


<h3>XXI. Change geometries (for display, experimentation)</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+shift">shift</a></code> </td><td style="text-align: left;"> change the position geometries by shifting their coordinates in horizontal and/or vertical direction</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+spin">spin</a></code></td><td style="text-align: left;"> rotate geometries around an origin</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+rescale">rescale</a></code> </td><td style="text-align: left;"> shrink (or expand) geometries, for example to make an inset map </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+flip">flip</a></code> </td><td style="text-align: left;"> flip geometries vertically or horizontally</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+t">t</a></code> </td><td style="text-align: left;"> transpose geometries (switch x and y)</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">  
</td>
</tr>

</table>


<h3>XXII. Geometry properties and topology</h3>


<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+width">width</a></code> </td><td style="text-align: left;"> the minimum diameter of the geometries </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+clearance">clearance</a></code> </td><td style="text-align: left;"> the minimum clearance of the geometries </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+sharedPaths">sharedPaths</a></code> </td><td style="text-align: left;"> shared paths (arcs) between line or polygon geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+simplifyGeom">simplifyGeom</a></code> </td><td style="text-align: left;"> simplify geometries</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+gaps">gaps</a></code> </td><td style="text-align: left;"> find gaps between polygon geometries </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+fillHoles">fillHoles</a></code> </td><td style="text-align: left;"> get or remove the polygon holes</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+makeNodes">makeNodes</a></code> </td><td style="text-align: left;"> create nodes on lines </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+mergeLines">mergeLines</a></code> </td><td style="text-align: left;"> connect lines to form polygons  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+removeDupNodes">removeDupNodes</a></code> </td><td style="text-align: left;"> remove duplicate nodes in geometries and optionally rounds the coordinates  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+is.valid">is.valid</a></code> </td><td style="text-align: left;"> check if geometries are valid </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+makeValid">makeValid</a></code> </td><td style="text-align: left;"> attempt to repair invalid geometries </td>
</tr>
<tr>
 <td style="text-align: left;">  
  <code><a href="#topic+snap">snap</a></code> </td><td style="text-align: left;"> make boundaries of geometries identical if they are very close to each other  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+erase">erase</a> (single argument)</code> </td><td style="text-align: left;"> remove parts of geometries that overlap </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+union">union</a> (single argument)</code> </td><td style="text-align: left;"> create new polygons such that there are no overlapping polygons </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+rotate">rotate</a></code> </td><td style="text-align: left;"> rotate to (dis-) connect them across the date-line </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+normalize.longitude">normalize.longitude</a></code> </td><td style="text-align: left;"> move geometries that are outside of the -180 to 180 degrees range.  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+elongate">elongate</a></code> </td><td style="text-align: left;"> make lines longer by extending both sides </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+combineGeoms">combineGeoms</a></code> </td><td style="text-align: left;"> combine geometries that overlap, share a border, or are within a minimum distance of each other </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+forceCCW">forceCCW</a></code> </td><td style="text-align: left;"> force counter-clockwise polygon winding </td>
</tr>
<tr>
 <td style="text-align: left;"> 
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>XXIII. SpatVectorCollections</h3>

<p>A SpatVectorCollection is a vector of SpatVector objects. 
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+svc">svc</a></code> </td><td style="text-align: left;"> create a SpatVectorCollection from (a list of) SpatVector objects</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+length">length</a></code> </td><td style="text-align: left;"> how many SpatRasters does the SpatRasterCollection have?</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic++5B">[</a></code> </td><td style="text-align: left;"> extract a SpatVector</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3><b>Other classes</b></h3>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>


<h3>XXIV. SpatExtent</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+ext">ext</a></code> </td><td style="text-align: left;"> Create a SpatExtent object. For example to <code><a href="#topic+crop">crop</a></code> a Spatial dataset</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+intersect">intersect</a></code> </td><td style="text-align: left;"> Intersect two SpatExtent objects, same as <code>-</code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+union">union</a></code> </td><td style="text-align: left;"> Combine two SpatExtent objects, same as <code>+</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+Math-methods">Math-methods</a></code> </td><td style="text-align: left;"> round/floor/ceiling of a SpatExtent </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+align">align</a></code> </td><td style="text-align: left;"> Align a SpatExtent with a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+draw">draw</a></code> </td><td style="text-align: left;"> Create a SpatExtent by drawing it on top of a map (plot) </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>XXV. SpatGraticule</h3>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+graticule">graticule</a></code> </td><td style="text-align: left;"> Create a graticule</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+crop">crop</a></code> </td><td style="text-align: left;"> crop a graticule</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+plot+2CSpatGraticule+2Cmissing-method">plot&lt;SpatGraticule&gt;</a></code> </td><td style="text-align: left;"> plot a graticule </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3><b>General methods</b></h3>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>


<h3>XXVI. Conversion between spatial data objects from different packages</h3>

<p>You can coerce SpatRasters to Raster* objects, after loading the <code>raster</code> package, with <code>as(object, "Raster")</code>, or <code>raster(object)</code> or <code>brick(object)</code> or <code>stack(object)</code>
</p>

<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rast">rast</a></code> </td><td style="text-align: left;"> SpatRaster from matrix and other objects</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+vect">vect</a></code> </td><td style="text-align: left;"> SpatVector from <code>sf</code> or <code>Spatial*</code> vector data</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code>sf::st_as_sf</code> </td><td style="text-align: left;"> sf object from SpatVector</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterize">rasterize</a></code> </td><td style="text-align: left;"> Rasterizing points, lines or polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterizeWin">rasterizeWin</a></code> </td><td style="text-align: left;"> Rasterize points with a moving window</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+rasterizeGeom">rasterizeGeom</a></code> </td><td style="text-align: left;"> Rasterize attributes of geometries such as "count", "area", or "length"</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.points">as.points</a></code> </td><td style="text-align: left;"> Create points from a SpatRaster or SpatVector </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.lines">as.lines</a></code> </td><td style="text-align: left;"> Create points from a SpatRaster or SpatVector</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.polygons">as.polygons</a></code> </td><td style="text-align: left;"> Create polygons from a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+as.contour">as.contour</a></code>  </td><td style="text-align: left;"> Contour lines from a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>XXVII. Plotting</h3>



<h4>Maps</h4>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot">plot</a></code> </td><td style="text-align: left;"> Plot a SpatRaster or SpatVector. The main method to create a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+panel">panel</a></code> </td><td style="text-align: left;"> Combine multiple plots </td>
</tr>
<tr>
 <td style="text-align: left;">	
	<code><a href="#topic+points">points</a></code> </td><td style="text-align: left;"> Add points to a map</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+lines">lines</a></code> </td><td style="text-align: left;"> Add lines to a map</td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+polys">polys</a></code> </td><td style="text-align: left;"> Add polygons to a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+text">text</a></code> </td><td style="text-align: left;"> Add text (such as the values of a SpatRaster or SpatVector) to a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+halo">halo</a></code> </td><td style="text-align: left;"> Add text with a halo to a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+image">image</a></code> </td><td style="text-align: left;"> Alternative to plot to make a map with a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plotRGB">plotRGB</a></code> </td><td style="text-align: left;"> Combine three layers (red, green, blue channels) into a single "real color" plot </td>
</tr>
<tr>
 <td style="text-align: left;">
	<code><a href="#topic+plot+2CSpatGraticule+2Cmissing-method">plot&lt;SpatGraticule&gt;</a></code> </td><td style="text-align: left;"> plot a graticule </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sbar">sbar</a></code> </td><td style="text-align: left;"> Add a scale bar to a map</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+north">north</a></code> </td><td style="text-align: left;"> Add a north arrow to a map</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+inset">inset</a></code> </td><td style="text-align: left;"> Add a small inset (overview) map</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+dots">dots</a></code> </td><td style="text-align: left;"> Make a dot-density map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+cartogram">cartogram</a></code> </td><td style="text-align: left;"> Make a cartogram </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+persp">persp</a></code> </td><td style="text-align: left;"> Perspective plot of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+contour">contour</a></code> </td><td style="text-align: left;"> Contour plot or filled-contour plot of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+colorize">colorize</a></code> </td><td style="text-align: left;"> Combine three layers (red, green, blue channels) into a single layer with a color-table </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>




<h4>Interacting with a map</h4>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+zoom">zoom</a></code> </td><td style="text-align: left;"> Zoom in to a part of a map by drawing a bounding box on it </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+click">click</a></code> </td><td style="text-align: left;"> Query values of SpatRaster or SpatVector by clicking on a map </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+sel">sel</a></code> </td><td style="text-align: left;"> Select a spatial subset of a SpatRaster or SpatVector by drawing on a map</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+draw">draw</a></code> </td><td style="text-align: left;"> Create a SpatExtent or SpatVector by drawing on a map </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>




<h4>Other plots</h4>


<table>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+plot">plot</a></code> </td><td style="text-align: left;"> x-y scatter plot of the values of (a sample of) the layers of two SpatRaster objects</td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+hist">hist</a></code> </td><td style="text-align: left;"> Histogram of SpatRaster values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+barplot">barplot</a></code> </td><td style="text-align: left;"> Bar plot of a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+density">density</a></code> </td><td style="text-align: left;"> Density plot of SpatRaster values </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+pairs">pairs</a></code> </td><td style="text-align: left;"> Pairs plot for layers in a SpatRaster </td>
</tr>
<tr>
 <td style="text-align: left;">
    <code><a href="#topic+boxplot">boxplot</a></code> </td><td style="text-align: left;"> Box plot of the values of a SpatRaster</td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
	</td>
</tr>

</table>




<h3><b>Comparison with the raster package</b></h3>

<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;</p>


<h3>XXVIII. New method names</h3>

<p><code>terra</code> has a single class <code>SpatRaster</code> for which <code>raster</code> has three (<code>RasterLayer, RasterStack, RasterBrick</code>). Likewise there is a single class for vector data <code>SpatVector</code> that replaces six <code>Spatial*</code> classes. Most method names are the same, but note the following important differences in methods names with the <code>raster</code> package
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>raster package</b> </td><td style="text-align: left;"> <b>terra package</b></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>raster, brick, stack</code></td><td style="text-align: left;"><code><a href="#topic+rast">rast</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rasterFromXYZ</code></td><td style="text-align: left;"><code><a href="#topic+rast">rast</a>( , type="xyz")</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>stack, addLayer</code></td><td style="text-align: left;"><code><a href="#topic+c">c</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>addLayer</code> </td><td style="text-align: left;"><code><a href="#topic+add+3C-">add&lt;-</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>area</code> </td><td style="text-align: left;"><code><a href="#topic+cellSize">cellSize</a></code> or <code><a href="#topic+expanse">expanse</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>approxNA</code> </td><td style="text-align: left;"><code><a href="#topic+approximate">approximate</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>calc</code></td><td style="text-align: left;"><code><a href="#topic+app">app</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cellFromLine, cellFromPolygon,</code></td><td style="text-align: left;"> <code><a href="#topic+cells">cells</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cellsFromExtent</code></td><td style="text-align: left;"><code><a href="#topic+cells">cells</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cellStats</code></td><td style="text-align: left;"><code><a href="#topic+global">global</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>clump</code></td><td style="text-align: left;"><code><a href="#topic+patches">patches</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>compareRaster</code></td><td style="text-align: left;"><code><a href="#topic+compareGeom">compareGeom</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>corLocal</code></td><td style="text-align: left;"><code><a href="#topic+focalPairs">focalPairs</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>coordinates</code></td><td style="text-align: left;"><code><a href="#topic+crds">crds</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>couldBeLonLat</code></td><td style="text-align: left;"><code><a href="#topic+is.lonlat">is.lonlat</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>disaggregate</code> </td><td style="text-align: left;"><code><a href="#topic+disagg">disagg</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>distanceFromPoints</code> </td><td style="text-align: left;"> <code><a href="#topic+distance">distance</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>drawExtent, drawPoly, drawLine</code> </td><td style="text-align: left;"> <code><a href="#topic+draw">draw</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>dropLayer</code></td><td style="text-align: left;"><code><a href="#topic+subset">subset</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>extent</code></td><td style="text-align: left;"><code><a href="#topic+ext">ext</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>getValues</code></td><td style="text-align: left;"><code><a href="#topic+values">values</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>isLonLat, isGlobalLonLat</code></td><td style="text-align: left;"><code><a href="#topic+is.lonlat">is.lonlat</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>layerize</code></td><td style="text-align: left;"><code><a href="#topic+segregate">segregate</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>layerStats</code></td><td style="text-align: left;"><code><a href="#topic+layerCor">layerCor</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>movingFun</code></td><td style="text-align: left;"><code><a href="#topic+roll">roll</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>NAvalue</code></td><td style="text-align: left;"><code><a href="#topic+NAflag">NAflag</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>nlayers</code></td><td style="text-align: left;"><code><a href="#topic+nlyr">nlyr</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>overlay</code></td><td style="text-align: left;"><code><a href="#topic+lapp">lapp</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>unstack</code></td><td style="text-align: left;"><code><a href="#topic+as.list">as.list</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>projectRaster</code></td><td style="text-align: left;"><code><a href="#topic+project">project</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rasterToPoints</code></td><td style="text-align: left;"><code><a href="#topic+as.points">as.points</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rasterToPolygons</code></td><td style="text-align: left;"><code><a href="#topic+as.polygons">as.polygons</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>reclassify, subs, cut</code></td><td style="text-align: left;"><code><a href="#topic+classify">classify</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>sampleRandom, sampleRegular</code></td><td style="text-align: left;"><code><a href="#topic+spatSample">spatSample</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>shapefile</code></td><td style="text-align: left;"><code><a href="#topic+vect">vect</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>stackApply</code></td><td style="text-align: left;"><code><a href="#topic+tapp">tapp</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>stackSelect</code></td><td style="text-align: left;"><code><a href="#topic+selectRange">selectRange</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>XXIX. Changed behavior</h3>

<p>Also note that even if function names are the same in <code>terra</code> and <code>raster</code>, their output can be different. In most cases this was done to get more consistency in the returned values (and thus fewer errors in the downstream code that uses them). In other cases it simply seemed better. Here are some examples:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+as.polygons">as.polygons</a></code></td><td style="text-align: left;"> By default, <code>terra</code> returns dissolved polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+quantile">quantile</a></code></td><td style="text-align: left;"> computes by cell, across layers instead of the other way around</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+extract">extract</a></code></td><td style="text-align: left;"> By default, <code>terra</code> returns a matrix, with the first column the sequential ID of the vectors. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>raster</code> returns a list (for lines or polygons) or a matrix (for points, but without the ID</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> column. You can use <code>list=TRUE</code> to get the results as a list</td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+values">values</a></code></td><td style="text-align: left;"> <code>terra</code> always returns a matrix. <code>raster</code> returns a vector for a <code>RasterLayer</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+Summary-methods">Summary-methods</a></code></td><td style="text-align: left;"> With <code>raster</code>, <code>mean(x, y)</code> and <code>mean(stack(x, y)</code> return the same result, a single</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> layer with the mean of all cell values. This is also what <code>terra</code> returns with </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>mean(c(x, y))</code>, but with <code>mean(x, y)</code> the parallel mean is returned -- that is, the</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> computation is done layer-wise, and the number of layers in the output is the same as</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;">  that of <code>x</code> and <code>y</code> (or the larger of the two if they are not the same). This affects </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> all summary functions (<code>sum</code>, <code>mean</code>, <code>median</code>, <code>which.min</code>, <code>which.max</code>, <code>min</code>, <code>max</code>,</td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> <code>prod</code>, <code>any</code>, <code>all</code>, <code>stdev</code>), except <code>range</code>, which is not implemented for this case </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> (you can use <code>min</code> and <code>max</code> instead) </td>
</tr>
<tr>
 <td style="text-align: left;">
  --------------------------- </td><td style="text-align: left;"> ------------------------------------------------------------------------------------------ </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Authors</h3>

<p>Except where indicated otherwise, the methods and functions in this package were written by Robert Hijmans. The configuration scripts were written by Roger Bivand. Some of code using the GEOS library was adapted from code by Edzer Pebesma for <code>sf</code>. Michael Sumner contributed various bits and pieces.
</p>


<h3>Acknowledgments</h3>

<p>This package is an attempt to climb on the shoulders of giants (GDAL, PROJ, GEOS, NCDF, GeographicLib, Rcpp, R). Many people have contributed by asking questions or <a href="https://github.com/rspatial/terra">raising issues</a>. Feedback and suggestions by Mrcia Barbosa, Kendon Bell, Andrew Gene Brown, Jean-Luc Dupouey, Krzysztof Dyba, Sarah Endicott, Derek Friend, Alex Ilich, Gerald Nelson, Jakub Nowosad, and Monika Tomaszewska have been especially helpful.
</p>

<hr>
<h2 id='terrain'>terrain characteristics</h2><span id='topic+terrain'></span><span id='topic+terrain+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute terrain characteristics from elevation data. The elevation values should be in the same units as the map units (typically meter) for projected (planar) raster data. They should be in meter when the coordinate reference system is longitude/latitude. 
</p>
<p>For accuracy, always compute these values on the original data (do not first change the projection). Distances (needed for slope and aspect) for longitude/latitude data are computed on the WGS84 ellipsoid with Karney's algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
terrain(x, v="slope", neighbors=8, unit="degrees", filename="", ...)  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terrain_+3A_x">x</code></td>
<td>
<p>SpatRaster, single layer with elevation values. Values should have the same unit as the map units, or in meters when the crs is longitude/latitude</p>
</td></tr>
<tr><td><code id="terrain_+3A_v">v</code></td>
<td>
<p>character. One or more of these options: slope, aspect, TPI, TRI, TRIriley, TRIrmsd, roughness, flowdir (see Details)</p>
</td></tr>
<tr><td><code id="terrain_+3A_unit">unit</code></td>
<td>
<p>character. &quot;degrees&quot; or &quot;radians&quot; for the output of &quot;slope&quot; and &quot;aspect&quot;</p>
</td></tr>
<tr><td><code id="terrain_+3A_neighbors">neighbors</code></td>
<td>
<p>integer. Indicating how many neighboring cells to use to compute slope or aspect with. Either 8 (queen case) or 4 (rook case)</p>
</td></tr>
<tr><td><code id="terrain_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="terrain_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>neighbors=4</code>, slope and aspect are computed according to Fleming and Hoffer (1979) and Ritter (1987). When <code>neighbors=8</code>, slope and aspect are computed according to Horn (1981). The Horn algorithm may be best for rough surfaces, and the Fleming and Hoffer algorithm may be better for smoother surfaces (Jones, 1997; Burrough and McDonnell, 1998).
</p>
<p>If slope = 0, aspect is set to 0.5*pi radians (or 90 degrees if unit=&quot;degrees&quot;). When computing slope or aspect, the coordinate reference system of <code>x</code> must be known for the algorithm to differentiate between planar and longitude/latitude data.
</p>
<p><code>terrain</code> is not vectorized over &quot;neighbors&quot; or &quot;unit&quot; &ndash; only the first value is used.
</p>
<p>flowdir returns the &quot;flow direction&quot; (of water), that is the direction of the greatest drop in elevation (or the smallest rise if all neighbors are higher). They are encoded as powers of 2 (0 to 7). The cell to the right of the focal cell is 1, the one below that is 2, and so on:
</p>

<table>
<tr>
 <td style="text-align: right;">
32 </td><td style="text-align: right;">64 </td><td style="text-align: right;"> 128</td>
</tr>
<tr>
 <td style="text-align: right;"> 
16 </td><td style="text-align: right;"> x </td><td style="text-align: right;"> 1 </td>
</tr>
<tr>
 <td style="text-align: right;"> 
 8 </td><td style="text-align: right;"> 4 </td><td style="text-align: right;"> 2 </td>
</tr>
<tr>
 <td style="text-align: right;"> </td>
</tr>

</table>

<p>Cells without lower neighboring cells are encoded as zero. 
</p>
<p>If two cells have the same drop in elevation, a random cell is picked. That is not ideal as it may prevent the creation of connected flow networks. ArcGIS implements the approach of Greenlee (1987) and I might adopt that in the future. 
</p>
<p>Most terrain indices are according to Wilson et al. (2007), as in <a href="https://gdal.org/programs/gdaldem.html">gdaldem</a>. TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells. TPI (Topographic Position Index) is the difference between the value of a cell and the mean value of its 8 surrounding cells. Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells. 
</p>
<p>TRIriley (TRI according to Riley et al. (2007)) returns the square root of summed squared differences between the value of a cell and its 8 surrounding cells. TRIrmsd computes the square root of the mean of the squared differences between these cells. The benefit of  TRIrmsd
</p>
<p>Such measures can also be computed with the <code><a href="#topic+focal">focal</a></code> function:
</p>
<p>TRI &lt;- focal(x, w=3, fun=\(x) sum(abs(x[-5]-x[5]))/8)
</p>
<p>TPI &lt;- focal(x, w=3, fun=\(x) x[5] - mean(x[-5]))
</p>
<p>rough &lt;- focal(x, w=3, fun=\(x) max(x) - min(x))
</p>


<h3>References</h3>

<p>Burrough, P., and R.A. McDonnell, 1998. Principles of Geographical Information Systems. Oxford University Press.
</p>
<p>Fleming, M.D. and Hoffer, R.M., 1979. Machine processing of Landsat MSS data and DMA topographic data for forest cover type mapping. LARS Technical Report 062879. Laboratory for Applications of Remote Sensing, Purdue University, West Lafayette, Indiana.
</p>
<p>Horn, B.K.P., 1981. Hill shading and the reflectance map. Proceedings of the IEEE 69:14-47
</p>
<p>Jones, K.H., 1998. A comparison of algorithms used to compute hill slope as a property of the DEM. Computers &amp; Geosciences 24: 315-323 
</p>
<p>Karney, C.F.F., 2013. Algorithms for geodesics, J. Geodesy 87: 43-55. doi:10.1007/s00190-012-0578-z.
</p>
<p>Riley, S.J., De Gloria, S.D., Elliot, R. (1999): A Terrain Ruggedness that Quantifies Topographic Heterogeneity. Intermountain Journal of Science 5: 23-27.
</p>
<p>Ritter, P., 1987. A vector-based terrain and aspect generation algorithm. Photogrammetric Engineering and Remote Sensing 53: 1109-1111
</p>
<p>Wilson et al 2007, Multiscale Terrain Analysis of Multibeam Bathymetry Data for Habitat Mapping on the Continental Slope. Marine Geodesy 30:3-35
</p>


<h3>See Also</h3>

<p><code><a href="#topic+viewshed">viewshed</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
x &lt;- terrain(r, "slope")
</code></pre>

<hr>
<h2 id='text'>Add labels to a map</h2><span id='topic+text'></span><span id='topic+text+2CSpatRaster-method'></span><span id='topic+text+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Plots labels, that is a textual (rather than color) representation of values, on top an existing plot (map). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
text(x, labels, digits=0, halo=FALSE, ...)

## S4 method for signature 'SpatVector'
text(x, labels, halo=FALSE, inside=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="text_+3A_labels">labels</code></td>
<td>
<p>character. Optional. Vector of labels with <code>length(x)</code> or a variable name from <code>names(x)</code></p>
</td></tr>
<tr><td><code id="text_+3A_digits">digits</code></td>
<td>
<p>integer. How many digits should be used?</p>
</td></tr>
<tr><td><code id="text_+3A_halo">halo</code></td>
<td>
<p>logical. If <code>TRUE</code> a &quot;halo&quot; is printed around the text. If <code>TRUE</code>, additional arguments <code>hc="white"</code> and <code>hw=0.1</code> can be modified to set the color and width of the halo</p>
</td></tr>
<tr><td><code id="text_+3A_inside">inside</code></td>
<td>
<p>logical. Should the text always be placed inside one the sub-geometries?</p>
</td></tr>
<tr><td><code id="text_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to graphics function <code><a href="graphics.html#topic+text">text</a></code> </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+text">text</a>, <a href="#topic+plot">plot</a>, <a href="#topic+halo">halo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
r &lt;- rast(nrows=4, ncols=4)
values(r) &lt;- 1:ncell(r)
plot(r)
text(r)

plot(r)
text(r, halo=TRUE, hc="blue", col="white", hw=0.2)

plot(r, col=rainbow(16))
text(r, col=c("black", "white"), vfont=c("sans serif", "bold"), cex=2)
</code></pre>

<hr>
<h2 id='tighten'>tighten SpatRaster or SpatRasterDataset objects</h2><span id='topic+tighten'></span><span id='topic+tighten+2CSpatRaster-method'></span><span id='topic+tighten+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

<p>Combines data sources within a SpatRaster (that are in memory, or from the same file) to allow for faster processing. 
</p>
<p>Or combine sub-datasets into a SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'SpatRaster'
tighten(x)

## S4 method for signature 'SpatRasterDataset'
tighten(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tighten_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatRasterDataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrow=5, ncol=9, vals=1:45)
x &lt;- c(r, r*2, r*3)
x
tighten(x)
</code></pre>

<hr>
<h2 id='time'>time of SpatRaster layers</h2><span id='topic+time'></span><span id='topic+time+2CSpatRaster-method'></span><span id='topic+time+2CSpatRasterDataset-method'></span><span id='topic+has.time'></span><span id='topic+has.time+2CSpatRaster-method'></span><span id='topic+has.time+2CSpatRasterDataset-method'></span><span id='topic+time+3C-'></span><span id='topic+time+3C-+2CSpatRaster-method'></span><span id='topic+time+3C-+2CSpatRasterDataset-method'></span><span id='topic+timeInfo'></span><span id='topic+timeInfo+2CSpatRaster-method'></span><span id='topic+timeInfo+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

<p>Get or set the time of the layers of a SpatRaster. Time can be stored as <code><a href="base.html#topic+POSIXlt">POSIXlt</a></code> (date and time, with  a resolution of seconds, and a time zone), <code><a href="base.html#topic+Date">Date</a></code>, &quot;months&quot;, &quot;years&quot;, or &quot;yearmonths&quot;. 
</p>
<p><code>timeInfo</code> and <code>has.time</code> are helper functions to understand what a time data a SpatRaster has.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
has.time(x)

## S4 method for signature 'SpatRaster'
time(x, format="")

## S4 replacement method for signature 'SpatRaster'
time(x, tstep="")&lt;-value

## S4 method for signature 'SpatRaster'
timeInfo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatRasterDataset</p>
</td></tr>
<tr><td><code id="time_+3A_format">format</code></td>
<td>
<p>One of &quot;&quot;, &quot;seconds&quot; (POSIXlt), &quot;days&quot; (Date), &quot;yearmonths&quot; (decimal years), &quot;years&quot;, &quot;months&quot;. If &quot;&quot;, the returned format is (based on) the format that was used to set the time</p>
</td></tr>
<tr><td><code id="time_+3A_value">value</code></td>
<td>
<p><code>Date</code>, <code>POSIXt</code>, <code>yearmon</code> (defined in package zoo), or numeric</p>
</td></tr>
<tr><td><code id="time_+3A_tstep">tstep</code></td>
<td>
<p>One of &quot;years&quot;, &quot;months&quot;, &quot;yearmonths&quot;. Used when <code>value</code> is numeric. Ignored when <code>value</code> is of type <code>Date</code>, <code>POSIXt</code>, or <code>yearmon</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>time</code>: POSIXlt, Date, or numeric
<code>timeInfo</code>: data.frame with time step and time zone information (if available)
<code>has.time</code>: logical
</p>


<h3>See Also</h3>

<p><code><a href="#topic+depth">depth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   

# Date"
d &lt;- as.Date("2001-05-04") + 0:2
time(s) &lt;- d
time(s)

# POSIX (date/time with a resolution of seconds)
time(s) &lt;- as.POSIXlt(d)
time(s)

# with time zone
time(s) &lt;- as.POSIXlt(Sys.time(), "America/New_York") + 0:2
time(s)
timeInfo(s)

# years
time(s, tstep="years") &lt;- 2000 + 0:2
s

time(s, tstep="months") &lt;- 1:3
s 
</code></pre>

<hr>
<h2 id='tmpFiles'>Temporary files</h2><span id='topic+tmpFiles'></span>

<h3>Description</h3>

<p>List and optionally remove temporary files created by the terra package. These files are created when an output SpatRaster may be too large to store in memory (RAM). This can happen when no filename is provided to a function and when using functions where you cannot provide a filename.
</p>
<p>Temporary files are automatically removed at the end of each R session that ends normally. You can use <code>tmpFiles</code> to see the files in the current sessions, including those that are orphaned (not connect to a SpatRaster object any more) and from other (perhaps old) sessions, and remove all the temporary files. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmpFiles(current=TRUE, orphan=FALSE, old=FALSE, remove=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmpFiles_+3A_current">current</code></td>
<td>
<p>logical. If <code>TRUE</code>, temporary files from the current R session are included</p>
</td></tr>
<tr><td><code id="tmpFiles_+3A_orphan">orphan</code></td>
<td>
<p>logical. If <code>TRUE</code>, temporary files from the current R session that are no longer associated with a SpatRaster (if <code>current</code> is <code>TRUE</code> these are also included)</p>
</td></tr>
<tr><td><code id="tmpFiles_+3A_old">old</code></td>
<td>
<p>logical. If <code>TRUE</code>, temporary files from other &quot;R&quot; sessions. Unless you are running multiple instances of R at the same time, these are from old (possibly crashed) R  sessions and should be removed</p>
</td></tr>
<tr><td><code id="tmpFiles_+3A_remove">remove</code></td>
<td>
<p>logical. If <code>TRUE</code>, temporary files are removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+terraOptions">terraOptions</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpFiles()
</code></pre>

<hr>
<h2 id='topology'> 
Vector topology methods
</h2><span id='topic+topology'></span><span id='topic+makeNodes'></span><span id='topic+mergeLines'></span><span id='topic+removeDupNodes'></span><span id='topic+emptyGeoms'></span><span id='topic+snap'></span><span id='topic+makeNodes+2CSpatVector-method'></span><span id='topic+mergeLines+2CSpatVector-method'></span><span id='topic+snap+2CSpatVector-method'></span><span id='topic+removeDupNodes+2CSpatVector-method'></span><span id='topic+emptyGeoms+2CSpatVector-method'></span>

<h3>Description</h3>

<p><code>makeNodes</code> create nodes on lines
</p>
<p><code>mergeLines</code> connect lines to form polygons
</p>
<p><code>removeDupNodes</code> removes duplicate nodes in geometries and optionally rounds the coordinates
</p>
<p><code>emptyGeoms</code> returns the indices of empty (null) geometries. <code><a href="Matrix.html#topic+is.na">is.na</a></code> also checks if any of the coordinates is <code>NA</code>.
</p>
<p><code>snap</code> makes boundaries of geometries identical if they are very close to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
mergeLines(x)
## S4 method for signature 'SpatVector'
snap(x, y=NULL, tolerance)
## S4 method for signature 'SpatVector'
removeDupNodes(x, digits = -1)
## S4 method for signature 'SpatVector'
makeNodes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topology_+3A_x">x</code></td>
<td>
<p>SpatVector of lines or polygons</p>
</td></tr>
<tr><td><code id="topology_+3A_y">y</code></td>
<td>
<p>SpatVector of lines or polygons to snap to. If <code>NULL</code> snapping is to the other geometries in <code>x</code></p>
</td></tr>
<tr><td><code id="topology_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric. Snapping tolerance (distance between geometries)</p>
</td></tr>
<tr><td><code id="topology_+3A_digits">digits</code></td>
<td>
<p>numeric. Number of digits used in rounding. Ignored if &lt; 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sharedPaths">sharedPaths</a></code>, <code><a href="#topic+gaps">gaps</a></code>, <code><a href="#topic+simplifyGeom">simplifyGeom</a></code>, <code><a href="#topic+forceCCW">forceCCW</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>p1 &lt;- as.polygons(ext(0,1,0,1))
p2 &lt;- as.polygons(ext(1.1,2,0,1))

p &lt;- rbind(p1, p2)

y &lt;- snap(p, tol=.15)
plot(p, lwd=3, col="light gray")
lines(y, col="red", lwd=2)
</code></pre>

<hr>
<h2 id='transpose'>Transpose</h2><span id='topic+t'></span><span id='topic+t+2CSpatRaster-method'></span><span id='topic+t+2CSpatVector-method'></span><span id='topic+trans'></span><span id='topic+trans+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Transpose a SpatRaster or SpatVector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
t(x)

## S4 method for signature 'SpatVector'
t(x)

## S4 method for signature 'SpatRaster'
trans(x, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transpose_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="transpose_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="transpose_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+flip">flip</a>, <a href="#topic+rotate">rotate</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=18, ncols=36)
values(r) &lt;- 1:ncell(r)
tr1 &lt;- t(r)
tr2 &lt;- trans(r)
ttr &lt;- trans(tr2)
</code></pre>

<hr>
<h2 id='trim'>Trim a SpatRaster</h2><span id='topic+trim'></span><span id='topic+trim+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Trim (shrink) a SpatRaster by removing outer rows and columns that are <code>NA</code> or another value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
trim(x, padding=0, value=NA, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="trim_+3A_padding">padding</code></td>
<td>
<p>integer. Number of outer rows/columns to keep</p>
</td></tr>
<tr><td><code id="trim_+3A_value">value</code></td>
<td>
<p>numeric. The value of outer rows or columns that are to be removed</p>
</td></tr>
<tr><td><code id="trim_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>
<p>additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10, xmin=0,xmax=10,ymin=0,ymax=10)
v &lt;- rep(NA, ncell(r))
v[c(12,34,69)] &lt;- 1:3
values(r) &lt;- v
s &lt;- trim(r) 
</code></pre>

<hr>
<h2 id='union'> 
Union SpatVector or SpatExtent objects
</h2><span id='topic+union'></span><span id='topic+union+2CSpatExtent+2CSpatExtent-method'></span><span id='topic+union+2CSpatVector+2CSpatVector-method'></span><span id='topic+union+2CSpatVector+2CSpatExtent-method'></span><span id='topic+union+2CSpatVector+2Cmissing-method'></span>

<h3>Description</h3>

<p>Overlapping polygons (between, not within, objects) are intersected. Union for lines and points simply combines the two data sets; without any geometric intersections. This is equivalent to <code><a href="#topic+c">c</a></code>. Attributes are joined. See <code><a href="#topic+c">c</a></code> if you want to combine polygons without intersection. 
</p>
<p>If <code>x</code> and <code>y</code> have a different geometry type, a SpatVectorCollection is returned.
</p>
<p>If a single SpatVector is supplied, overlapping polygons are intersected. Original attributes are lost. New attributes allow for determining how many, and which, polygons overlapped. 
</p>
<p>SpatExtent: Objects are combined into their union; this is equivalent to <code>+</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,SpatVector'
union(x, y)

## S4 method for signature 'SpatVector,missing'
union(x, y)

## S4 method for signature 'SpatExtent,SpatExtent'
union(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="union_+3A_x">x</code></td>
<td>
<p>SpatVector or SpatExtent</p>
</td></tr>
<tr><td><code id="union_+3A_y">y</code></td>
<td>
<p>Same as <code>x</code> or missing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector or SpatExtent
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intersect">intersect</a></code>
</p>
<p><code><a href="#topic+merge">merge</a></code> and <code><a href="#topic+mosaic">mosaic</a></code> to union SpatRasters.
</p>
<p><code><a href="#topic+crop">crop</a></code> and <code><a href="#topic+extend">extend</a></code> for the union of SpatRaster and SpatExtent.
</p>
<p><code><a href="#topic+merge">merge</a></code> for merging a data.frame with attributes of a SpatVector.
</p>
<p><code><a href="#topic+aggregate">aggregate</a></code> to dissolve SpatVector objects. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e1 &lt;- ext(-10, 10, -20, 20)
e2 &lt;- ext(0, 20, -40, 5)
union(e1, e2)

#SpatVector
v &lt;- vect(system.file("ex/lux.shp", package="terra"))
v &lt;- v[,3:4]
p &lt;- vect(c("POLYGON ((5.8 49.8, 6 49.9, 6.15 49.8, 6 49.65, 5.8 49.8))", 
"POLYGON ((6.3 49.9, 6.2 49.7, 6.3 49.6, 6.5 49.8, 6.3 49.9))"), crs=crs(v))
values(p) &lt;- data.frame(pid=1:2, value=expanse(p))
u &lt;- union(v, p)
plot(u, "pid")

b &lt;- buffer(v, 1000)

u &lt;- union(b)
u$sum &lt;- rowSums(as.data.frame(u))
plot(u, "sum")
</code></pre>

<hr>
<h2 id='unique'>Unique values</h2><span id='topic+unique'></span><span id='topic+unique+2CSpatRaster-method'></span><span id='topic+unique+2CSpatRaster+2CANY-method'></span><span id='topic+unique+2CSpatVector-method'></span><span id='topic+unique+2CSpatVector+2CANY-method'></span>

<h3>Description</h3>

<p>This method returns the unique values in a SpatRaster, or removes duplicates records (geometry and attributes) in a SpatVector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
unique(x, incomparables=FALSE, digits=NA, na.rm=TRUE, as.raster=FALSE) 

## S4 method for signature 'SpatVector'
unique(x, incomparables=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="unique_+3A_incomparables">incomparables</code></td>
<td>
<p>logical. If <code>FALSE</code> and <code>x</code> is a SpatRaster: the unique values are determined for all layers together, and the result is a matrix. If <code>TRUE</code>, each layer is evaluated separately, and a list is returned. If <code>x</code> is a SpatVector this argument is as for a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="unique_+3A_digits">digits</code></td>
<td>
<p>integer. The number of digits for rounding the values before finding the unique values. Use <code>NA</code> means to not do any rounding</p>
</td></tr>
<tr><td><code id="unique_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NaN</code> is included if there are any missing values</p>
</td></tr>  
<tr><td><code id="unique_+3A_as.raster">as.raster</code></td>
<td>
<p>logical. If <code>TRUE</code>, a single-layer categorical SpatRaster with the unique values is returned</p>
</td></tr>  
<tr><td><code id="unique_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="base.html#topic+unique">unique</a></code></p>
</td></tr>  
</table>


<h3>Value</h3>

<p>If <code>x</code> is a SpatRaster: data.frame or list (if <code>incomparables=FALSE</code>)
</p>
<p>If <code>x</code> is a SpatVector: SpatVector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=5, nrows=5)
values(r) &lt;- rep(1:5, each=5)
unique(r)
s &lt;- c(r, round(r/3))
unique(s)
unique(s,TRUE)

unique(s, as.raster=TRUE)


v &lt;- vect(cbind(x=c(1:5,1:5), y=c(5:1,5:1)), 
		crs="+proj=utm +zone=1 +datum=WGS84")
nrow(v)
u &lt;- unique(v)
nrow(u)

values(v) &lt;- c(1:5, 1:3, 5:4)
unique(v)
</code></pre>

<hr>
<h2 id='units'>units of SpatRaster or SpatRasterDataSet</h2><span id='topic+units'></span><span id='topic+units+3C-'></span><span id='topic+units+2CSpatRaster-method'></span><span id='topic+units+3C-+2CSpatRaster-method'></span><span id='topic+units+2CSpatRasterDataset-method'></span><span id='topic+units+3C-+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

<p>Get or set the units of the layers of a SpatRaster or the datasets in a SpatRasterDataSet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
units(x)

## S4 replacement method for signature 'SpatRaster'
units(x)&lt;-value

## S4 method for signature 'SpatRasterDataset'
units(x)

## S4 replacement method for signature 'SpatRasterDataset'
units(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="units_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="units_+3A_value">value</code></td>
<td>
<p>character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+time">time</a>, <a href="#topic+names">names</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   

units(s) &lt;- c("m/s", "kg", "ha")
units(s)
s

units(s) &lt;- "kg"
units(s)
</code></pre>

<hr>
<h2 id='update'>Change values in a file</h2><span id='topic+update'></span><span id='topic+update+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Change the contents of a file that is the data source of a SpatRaster. BE CAREFUL as you are overwriting values in an existing file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
update(object, names=FALSE, crs=FALSE, extent=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_+3A_object">object</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="update_+3A_names">names</code></td>
<td>
<p>logical. Should the names be updated?</p>
</td></tr>
<tr><td><code id="update_+3A_crs">crs</code></td>
<td>
<p>logical. Should the coordinate reference system be updated?</p>
</td></tr>
<tr><td><code id="update_+3A_extent">extent</code></td>
<td>
<p>logical. Should the extent be updated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster (invisibly)</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
fname &lt;- paste0(tempfile(), ".tif")
x &lt;- writeRaster(s, fname)
names(x) &lt;- c("A", "B", "C")
ext(x) &lt;- ext(x) + 1
crs(x) &lt;- "+proj=utm +zone=1"

update(x, names=TRUE, crs=TRUE, extent=TRUE)

rast(fname)
</code></pre>

<hr>
<h2 id='values'>Cell values and geometry attributes</h2><span id='topic+values'></span><span id='topic+values+2CSpatRaster-method'></span><span id='topic+values+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get the cell values of a SpatRaster or the attributes of a SpatVector.
</p>
<p>By default all values returned are numeric. This is because a vector or matrix can only store one data type, and a SpatRaster may consist of multiple data types. However, if all layers have integer or logical values, the returned values also have that datatype.  
</p>
<p>Note that with <code>values(x, dataframe=TRUE)</code> and <code><a href="#topic+as.data.frame">as.data.frame</a>(x)</code> the values returned match the type of each layer, and can be a mix of numeric, logical, integer, and factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
values(x, mat=TRUE, dataframe=FALSE, row=1, 
    nrows=nrow(x), col=1, ncols=ncol(x), na.rm=FALSE, ...)

## S4 method for signature 'SpatVector'
values(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="values_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="values_+3A_mat">mat</code></td>
<td>
<p>logical. If <code>TRUE</code>, values are returned as a matrix instead of as a vector, except when dataframe is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="values_+3A_dataframe">dataframe</code></td>
<td>
<p>logical. If <code>TRUE</code>, values are returned as a <code>data.frame</code> instead of as a vector (also if matrix is <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="values_+3A_row">row</code></td>
<td>
<p>positive integer. Row number to start from, should be between 1 and nrow(x)</p>
</td></tr>
<tr><td><code id="values_+3A_nrows">nrows</code></td>
<td>
<p>positive integer. How many rows?</p>
</td></tr>
<tr><td><code id="values_+3A_col">col</code></td>
<td>
<p>positive integer. Column number to start from, should be between 1 and ncol(x)</p>
</td></tr>
<tr><td><code id="values_+3A_ncols">ncols</code></td>
<td>
<p>positive integer. How many columns? Default is the number of columns left after the start column</p>
</td></tr>
<tr><td><code id="values_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Remove <code>NA</code>s?</p>
</td></tr>
<tr><td><code id="values_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+data.frame">data.frame</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a <code>SpatRaster</code>, and <code>mat=FALSE</code>, the values are returned as a vector. In cell-order by layer. If <code>mat=TRUE</code>, a matrix is returned in which the values of each layer are represented by a column (with <code>ncell(x)</code> rows). The values per layer are in cell-order, that is, from top-left, to top-right and then down by row. Use <code><a href="#topic+as.matrix">as.matrix</a>(x, wide=TRUE)</code> for an alternative matrix representation where the number of rows and columns matches that of <code>x</code>.  
</p>


<h3>Value</h3>

<p>matrix or data.frame
</p>


<h3>Note</h3>

<p>raster values that are <code>NA</code> (missing) are represented by <code>NaN</code> (not-a-number) unless argument <code>dataframe</code> is <code>TRUE</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+values+3C-">values&lt;-</a></code>, <code><a href="#topic+focalValues">focalValues</a></code>, <code><a href="#topic+as.data.frame">as.data.frame</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
r
x &lt;- values(r)
x[3650:3655, ]
r[3650:3655]


ff &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(ff)
y &lt;- values(v)
head(y)
</code></pre>

<hr>
<h2 id='varnames'>variable and long variable names</h2><span id='topic+varnames'></span><span id='topic+varnames+3C-'></span><span id='topic+longnames'></span><span id='topic+longnames+3C-'></span><span id='topic+varnames+2CSpatRaster-method'></span><span id='topic+varnames+3C-+2CSpatRaster-method'></span><span id='topic+longnames+2CSpatRaster-method'></span><span id='topic+longnames+3C-+2CSpatRaster-method'></span><span id='topic+varnames+2CSpatRasterDataset-method'></span><span id='topic+varnames+3C-+2CSpatRasterDataset-method'></span><span id='topic+longnames+2CSpatRasterDataset-method'></span><span id='topic+longnames+3C-+2CSpatRasterDataset-method'></span>

<h3>Description</h3>

<p>Set or get names for each dataset (variable) in a SpatRasterDataset. 
</p>
<p>Each SpatRaster _data source_ can also have a variable name and a long variable name. They are set when reading a file with possibly multiple sub-datasets (e.g. netcdf or hdf5 format) into a single SpatRaster. Each sub-datset is a seperate &quot;data-source&quot; in the SpatRaster. Note that newly created or derived SpatRasters always have a single variable (data source), and therefore the variable names are lost when processing a multi-variable SpatRaster. Thus the variable names are mostly useful to understand a SpatRaster created from some files and for managing SpatRasterDatasets.
</p>
<p>See <code>link{names}</code> for the more commonly used _layer_ names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
varnames(x)

## S4 replacement method for signature 'SpatRaster'
varnames(x)&lt;-value

## S4 method for signature 'SpatRaster'
longnames(x)

## S4 replacement method for signature 'SpatRaster'
longnames(x)&lt;-value

## S4 method for signature 'SpatRasterDataset'
varnames(x)

## S4 replacement method for signature 'SpatRasterDataset'
varnames(x)&lt;-value

## S4 method for signature 'SpatRasterDataset'
longnames(x)

## S4 replacement method for signature 'SpatRasterDataset'
longnames(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varnames_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatRasterDataset</p>
</td></tr>
<tr><td><code id="varnames_+3A_value">value</code></td>
<td>
<p>character (vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character 
</p>


<h3>Note</h3>

<p>terra enforces neither unique nor valid names. See <code><a href="base.html#topic+make.unique">make.unique</a></code> to create unique names and <code>{make.names}</code> to make syntactically valid names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(ncols=5, nrows=5, nlyrs=3)
names(s) &lt;- c("a", "b", "c")
x &lt;- sds(s, s)
varnames(x) &lt;- c("one", "two")
x
</code></pre>

<hr>
<h2 id='vect'>Create SpatVector objects</h2><span id='topic+vect'></span><span id='topic+vect+2Ccharacter-method'></span><span id='topic+vect+2Clist-method'></span><span id='topic+vect+2CSpatVector-method'></span><span id='topic+vect+2CSpatVectorCollection-method'></span><span id='topic+vect+2CSpatExtent-method'></span><span id='topic+vect+2Cdata.frame-method'></span><span id='topic+vect+2Cmatrix-method'></span><span id='topic+vect+2Cmissing-method'></span><span id='topic+vect+2CSpatial-method'></span><span id='topic+vect+2Csf-method'></span><span id='topic+vect+2Csfc-method'></span><span id='topic+vect+2CXY-method'></span><span id='topic+vect+2CPackedSpatVector-method'></span>

<h3>Description</h3>

<p>Methods to create a SpatVector from a filename or other R object. 
</p>
<p>A filename can be for a shapefile or any spatial file format. 
</p>
<p>You can use a data.frame to make a SpatVector of points; or a &quot;geom&quot; matrix to make a SpatVector of any supported geometry (see examples and <code><a href="#topic+geom">geom</a></code>). 
</p>
<p>You can supply a list of SpatVectors to append them into a single SpatVector. 
</p>
<p>SpatVectors can also be created from &quot;Well Known Text&quot;, and from spatial vector data objects defined in the <code>sf</code> or <code>sp</code> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
vect(x, layer="", query="", extent=NULL, filter=NULL, 
		crs="", proxy=FALSE, what="", opts=NULL)

## S4 method for signature 'matrix'
vect(x, type="points", atts=NULL, crs="")

## S4 method for signature 'data.frame'
vect(x, geom=c("lon", "lat"), crs="", keepgeom=FALSE)

## S4 method for signature 'list'
vect(x, type="points", crs="")

## S4 method for signature 'SpatExtent'
vect(x, crs="")

## S4 method for signature 'SpatVectorCollection'
vect(x)

## S4 method for signature 'sf'
vect(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vect_+3A_x">x</code></td>
<td>
<p>character. A filename; or a &quot;Well Known Text&quot; string; SpatExtent, data.frame (to make a SpatVector of points); a &quot;geom&quot; matrix to make a SpatVector of any supported geometry (see examples and <code><a href="#topic+geom">geom</a></code>); a spatial vector data object defined in the <code>sf</code> or <code>sp</code> packages; or a list with matrices with coordinates</p>
</td></tr>
<tr><td><code id="vect_+3A_layer">layer</code></td>
<td>
<p>character. layer name to select a layer from a file (database) with multiple layers</p>
</td></tr>
<tr><td><code id="vect_+3A_query">query</code></td>
<td>
<p>character. An query to subset the dataset in the <a href="https://gdal.org/user/ogr_sql_dialect.html">OGR-SQL dialect</a></p>
</td></tr>
<tr><td><code id="vect_+3A_extent">extent</code></td>
<td>
<p>Spat* object. The extent of the object is used as a spatial filter to select the geometries to read. Ignored if <code>filter</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="vect_+3A_filter">filter</code></td>
<td>
<p>SpatVector. Used as a spatial filter to select geometries to read (the convex hull is used for lines or points). It is guaranteed that all features that overlap with the extent of filter will be returned. It can happen that additional geometries are returned</p>
</td></tr>
<tr><td><code id="vect_+3A_type">type</code></td>
<td>
<p>character. Geometry type. Must be &quot;points&quot;, &quot;lines&quot;, or &quot;polygons&quot;</p>
</td></tr>
<tr><td><code id="vect_+3A_atts">atts</code></td>
<td>
<p>data.frame with the attributes. The number of rows must match the number of geometrical elements</p>
</td></tr>
<tr><td><code id="vect_+3A_crs">crs</code></td>
<td>
<p>character. The coordinate reference system in one of the following formats: WKT/WKT2, &lt;authority&gt;:&lt;code&gt;, or PROJ-string notation (see <code><a href="#topic+crs">crs</a></code>). See <code><a href="#topic+crs">crs</a></code></p>
</td></tr>
<tr><td><code id="vect_+3A_proxy">proxy</code></td>
<td>
<p>logical. If <code>TRUE</code> a SpatVectorProxy is returned</p>
</td></tr>
<tr><td><code id="vect_+3A_what">what</code></td>
<td>
<p>character indicating what to read. Either <code>""</code> for geometries and attributes, or <code>"geoms"</code> to only read the geometries, <code>"attributes"</code> to only read the attributes (that are returned as a data.frame)</p>
</td></tr>
<tr><td><code id="vect_+3A_opts">opts</code></td>
<td>
<p>character. GDAL dataset open options</p>
</td></tr>
<tr><td><code id="vect_+3A_geom">geom</code></td>
<td>
<p>character. The field name(s) with the geometry data. Either two names for x and y coordinates of points, or a single name for a single column with WKT geometries)</p>
</td></tr>
<tr><td><code id="vect_+3A_keepgeom">keepgeom</code></td>
<td>
<p>logical. If <code>TRUE</code> the geom variable(s) is (are) also included in the attributes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom">geom</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>### SpatVector from file
f &lt;- system.file("ex/lux.shp", package="terra")
f
v &lt;- vect(f)
v

## subsetting (large) files
## with attribute query 
v &lt;- vect(f, query="SELECT NAME_1, NAME_2, ID_2 FROM lux WHERE ID_2 &lt; 4")

## with an extent
e &lt;- ext(5.9, 6.3, 49.9, 50) 
v &lt;- vect(f, extent=e)

## with polygons
p &lt;- as.polygons(e)
v &lt;- vect(f, filter=p)


### SpatVector from a geom matrix
x1 &lt;- rbind(c(-180,-20), c(-140,55), c(10, 0), c(-140,-60))
x2 &lt;- rbind(c(-10,0), c(140,60), c(160,0), c(140,-55))
x3 &lt;- rbind(c(-125,0), c(0,60), c(40,5), c(15,-45))
hole &lt;- rbind(c(80,0), c(105,13), c(120,2), c(105,-13))
z &lt;- rbind(cbind(object=1, part=1, x1, hole=0), cbind(object=2, part=1, x3, hole=0),
			cbind(object=3, part=1, x2, hole=0), cbind(object=3, part=1, hole, hole=1))
colnames(z)[3:4] &lt;- c('x', 'y')

p &lt;- vect(z, "polygons")
p

z[z[, "hole"]==1, "object"] &lt;- 4
lns &lt;- vect(z[,1:4], "lines")
plot(p)
lines(lns, col="red", lwd=2)

### from wkt
v &lt;- vect("POLYGON ((0 -5, 10 0, 10 -10, 0 -5))")

wkt &lt;- c("MULTIPOLYGON ( ((40 40, 20 45, 45 30, 40 40)), 
((20 35, 10 30, 10 10, 30 5, 45 20, 20 35),(30 20, 20 15, 20 25, 30 20)))", 
"POLYGON ((0 -5, 10 0, 10 -10, 0 -5))")
w &lt;- vect(wkt)

# combine two SpatVectors 
vw &lt;- rbind(w, v)

# add a data.frame
d &lt;- data.frame(id=1:2, name=c("a", "b"))
values(w) &lt;- d

# add data.frame on creation, here from a geom matrix
g &lt;- geom(w)
d &lt;- data.frame(id=1:2, name=c("a", "b"))
m &lt;- vect(g, "polygons", atts=d, crs="+proj=longlat +datum=WGS84")

### SpatVector from a data.frame
d$wkt &lt;- wkt
x &lt;- vect(d, geom="wkt")

d$wkt &lt;- NULL
d$lon &lt;- c(0,10)
d$lat &lt;- c(0,10)
x &lt;- vect(d, geom=c("lon", "lat"))

# SpatVector to sf
#sf::st_as_sf(x)
</code></pre>

<hr>
<h2 id='vector_layers'>List or remove layers from a vector file</h2><span id='topic+vector_layers'></span>

<h3>Description</h3>

<p>List or remove layers from a vector file that supports layers such as GPGK
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_layers(filename, delete="", return_error=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector_layers_+3A_filename">filename</code></td>
<td>
<p>character. filename</p>
</td></tr>
<tr><td><code id="vector_layers_+3A_delete">delete</code></td>
<td>
<p>character. layers to be deleted (ignored if the value is <code>""</code></p>
</td></tr>
<tr><td><code id="vector_layers_+3A_return_error">return_error</code></td>
<td>
<p>logical. If <code>TRUE</code>, an error occurs if some layers cannot be deleted. Otherwise a warning is given</p>
</td></tr>
</table>

<hr>
<h2 id='viewshed'>Compute a viewshed</h2><span id='topic+viewshed'></span><span id='topic+viewshed+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Use elevation data to compute the locations that can be seen, or how much higher they would have to be to be seen, from a certain position. The raster data coordinate reference system must planar (not lon/lat), with the elevation values in the same unit as the distance unit of the coordinate reference system. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
viewshed(x, loc, observer=1.80, target=0, curvcoef=6/7, output="yes/no", filename="", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewshed_+3A_x">x</code></td>
<td>
<p>SpatRaster, single layer with elevation values. Values should have the same unit as the map units</p>
</td></tr>
<tr><td><code id="viewshed_+3A_loc">loc</code></td>
<td>
<p>location (x and y coordinates) or a cell number</p>
</td></tr>
<tr><td><code id="viewshed_+3A_observer">observer</code></td>
<td>
<p>numeric. The height above the elevation data of the observer</p>
</td></tr>
<tr><td><code id="viewshed_+3A_target">target</code></td>
<td>
<p>numeric. The height above the elevation data of the targets</p>
</td></tr>
<tr><td><code id="viewshed_+3A_curvcoef">curvcoef</code></td>
<td>
<p>numeric. Coefficient to consider the effect of the curvature of the earth and refraction of the atmosphere. The elevation values are corrected with: <code>elevation = elevation - curvcoeff * (distance)^2 / (earth_diameter)</code>. This means that with the default value of 0.85714, you lose sight of about 1 meter of elevation for each 385 m of planar distance</p>
</td></tr>
<tr><td><code id="viewshed_+3A_output">output</code></td>
<td>
<p>character. Can be &quot;yes/no&quot; to get a binary (logical) output showing what areas are visible; &quot;land&quot; to get the height above the current elevation that would be visible; or &quot;sea&quot; the elevation above sea level that would be visible</p>
</td></tr>
<tr><td><code id="viewshed_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="viewshed_+3A_...">...</code></td>
<td>
<p>Options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>References</h3>

<p>The algorithm used is by Wang et al.: https://www.asprs.org/wp-content/uploads/pers/2000journal/january/2000_jan_87-90.pdf.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+terrain">terrain</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (gdal() &gt;= 3.1) {
	f &lt;- system.file("ex/elev.tif", package="terra")
	r &lt;- rast(f)
	x &lt;- project(r, "EPSG:2169")
	p &lt;- cbind(70300, 96982)
	v &lt;- viewshed(x, p, 0, 0, 0.85714)
}

</code></pre>

<hr>
<h2 id='voronoi'>Voronoi diagram and Delaunay triangles</h2><span id='topic+delaunay'></span><span id='topic+voronoi'></span><span id='topic+voronoi+2CSpatVector-method'></span><span id='topic+delaunay+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Get a Voronoi diagram or Delaunay triangles for points, or the nodes of lines or polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
voronoi(x, bnd=NULL, tolerance=0, as.lines=FALSE, deldir=FALSE) 

## S4 method for signature 'SpatVector'
delaunay(x, tolerance=0, as.lines=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="voronoi_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="voronoi_+3A_bnd">bnd</code></td>
<td>
<p>SpatVector to set the outer boundary of the voronoi diagram</p>
</td></tr>
<tr><td><code id="voronoi_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt;= 0, snapping tolerance (0 is no snapping)</p>
</td></tr>
<tr><td><code id="voronoi_+3A_as.lines">as.lines</code></td>
<td>
<p>logical. If <code>TRUE</code>, lines are returned without the outer boundary</p>
</td></tr>
<tr><td><code id="voronoi_+3A_deldir">deldir</code></td>
<td>
<p>logical. If <code>TRUE</code>, the <code><a href="deldir.html#topic+deldir">deldir</a></code> is used instead of the GEOS C++ library method. It has been reported that <code>deldir</code> does not choke on very large data sets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatVector</p>


<h3>Examples</h3>

<pre><code class='language-R'>wkt &lt;- c("MULTIPOLYGON ( ((40 40, 20 45, 45 30, 40 40)), 
  ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35),(30 20, 20 15, 20 25, 30 20)))", 
  "POLYGON ((0 -5, 10 0, 10 -10, 0 -5))")
x &lt;- vect(wkt)
v &lt;- voronoi(x)
v

d &lt;- delaunay(x)
d

plot(v, lwd=2, col=rainbow(15))
lines(x, col="gray", lwd=2)
points(x)
</code></pre>

<hr>
<h2 id='vrt'>Virtual Raster Dataset</h2><span id='topic+vrt'></span><span id='topic+vrt+2Ccharacter-method'></span>

<h3>Description</h3>

 
<p>Create a Virtual Raster Dataset (VRT) from a collection of file-based raster datasets (tiles). See 
<a href="https://gdal.org/programs/gdalbuildvrt.html">gdalbuildvrt</a> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
vrt(x, filename="", options=NULL, overwrite=FALSE, set_names=FALSE, return_filename=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vrt_+3A_x">x</code></td>
<td>
<p>character. Filenames of raster &quot;tiles&quot;. That is, files that have data for, typically non-overlapping, sub-regions of an raster. See <code><a href="#topic+makeTiles">makeTiles</a></code></p>
</td></tr>
<tr><td><code id="vrt_+3A_filename">filename</code></td>
<td>
<p>character. output VRT filename</p>
</td></tr>  
<tr><td><code id="vrt_+3A_options">options</code></td>
<td>
<p>character. All arguments as separate vector elements. Options as for <a href="https://gdal.org/programs/gdalbuildvrt.html">gdalbuildvrt</a></p>
</td></tr>
<tr><td><code id="vrt_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. Should <code>filename</code> be overwritten if it exists?</p>
</td></tr>
<tr><td><code id="vrt_+3A_set_names">set_names</code></td>
<td>
<p>logical. Add the layer names of the first tile to the vrt?</p>
</td></tr>
<tr><td><code id="vrt_+3A_return_filename">return_filename</code></td>
<td>
<p>logical. If <code>TRUE</code> the filename is returned, otherwise a SpatRaster is returned</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>Note</h3>

<p>A VRT can reference very many datasets. These are not all opened at the same time. The default is to open not more than 100 files. To increase performance, this maximum limit can be increased by setting the GDAL_MAX_DATASET_POOL_SIZE configuration option to a bigger value with <code><a href="#topic+setGDALconfig">setGDALconfig</a></code>. Note that a typical user process on Linux is limited to 1024 simultaneously opened files.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makeTiles">makeTiles</a></code> to create tiles; <code><a href="#topic+makeVRT">makeVRT</a></code> to create a .vrt file for a binary raster file that does not have a header file. <code><a href="#topic+vrt_tiles">vrt_tiles</a></code> to get the filenames of the tiles in a VRT. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=100, nrows=100)
values(r) &lt;- 1:ncell(r)
x &lt;- rast(ncols=2, nrows=2)
filename &lt;- paste0(tempfile(), "_.tif")
ff &lt;- makeTiles(r, x, filename)
ff

#vrtfile &lt;- paste0(tempfile(), ".vrt")
#v &lt;- vrt(ff, vrtfile)


## output in lower resolution
#vrtfile &lt;- paste0(tempfile(), ".vrt")
#v &lt;- vrt(ff, vrtfile, options = c("-tr", 5, 5))
#head(readLines(vrtfile))
#v
</code></pre>

<hr>
<h2 id='vrt_tiles'>filenames of VRT tiles</h2><span id='topic+vrt_tiles'></span>

<h3>Description</h3>

 
<p>Get the filenames of the tiles in a Virtual Raster Dataset (VRT) 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vrt_tiles(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vrt_tiles_+3A_x">x</code></td>
<td>
<p>character (filename) or SpatRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vrt">vrt</a></code>
</p>

<hr>
<h2 id='weighted.mean'>Weighted mean of layers</h2><span id='topic+weighted.mean'></span><span id='topic+weighted.mean+2CSpatRaster+2Cnumeric-method'></span><span id='topic+weighted.mean+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Compute the weighted mean for each cell of the layers of a SpatRaster. The weights can be spatially variable or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,numeric'
weighted.mean(x, w, na.rm=FALSE, filename="", ...)

## S4 method for signature 'SpatRaster,SpatRaster'
weighted.mean(x, w, na.rm=FALSE, filename="", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.mean_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_w">w</code></td>
<td>
<p>A vector of weights (one number for each layer), or for spatially variable weights, a SpatRaster with weights (should have the same extent, resolution and number of layers as x)</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="weighted.mean_+3A_...">...</code></td>
<td>
<p>options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Summary-methods">Summary-methods</a></code>, <code><a href="stats.html#topic+weighted.mean">weighted.mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- rast(system.file("ex/logo.tif", package="terra"))   

# give least weight to first layer, most to last layer
wm1 &lt;- weighted.mean(b, w=1:3)

# spatially varying weights
# weigh by column number
w1 &lt;- init(b, "col")

# weigh by row number
w2 &lt;- init(b, "row")
w &lt;- c(w1, w2, w2)

wm2 &lt;- weighted.mean(b, w=w)
</code></pre>

<hr>
<h2 id='where'>Where are the cells with the min or max values?</h2><span id='topic+where.min'></span><span id='topic+where.min+2CSpatRaster-method'></span><span id='topic+where.max'></span><span id='topic+where.max+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>This method returns the cell numbers for the cells with the min or max values of each layer in a SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
where.min(x, values=TRUE, list=FALSE)

## S4 method for signature 'SpatRaster'
where.max(x, values=TRUE, list=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="where_+3A_values">values</code></td>
<td>
<p>logical. If <code>TRUE</code> the min or max values are also returned</p>
</td></tr>
<tr><td><code id="where_+3A_list">list</code></td>
<td>
<p>logical. If <code>TRUE</code> a list is returned instead of a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or list
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+which">which</a></code> and <code><a href="#topic+Summary-methods">Summary-methods</a></code> for <code>which.min</code> and <code>which.max</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
where.min(r)
</code></pre>

<hr>
<h2 id='which.lyr'>Which cells are TRUE?</h2><span id='topic+which.lyr'></span><span id='topic+which.lyr+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>This method returns a single layer SpatRaster with cell values indicating the first layer in the input that is <code>TRUE</code>. All numbers that are not zero (or <code>FALSE</code>), are considered to be <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
which.lyr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which.lyr_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+isTRUE">isTRUE</a></code>, <code><a href="base.html#topic+which">which</a></code>, See <code><a href="#topic+Summary-methods">Summary-methods</a></code> for <code>which.min</code> and <code>which.max</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>s &lt;- rast(system.file("ex/logo.tif", package="terra"))   
x &lt;- which.lyr(s &gt; 100)
</code></pre>

<hr>
<h2 id='width'> 
SpatVector geometric properties
</h2><span id='topic+width'></span><span id='topic+clearance'></span><span id='topic+width+2CSpatVector-method'></span><span id='topic+clearance+2CSpatVector-method'></span>

<h3>Description</h3>

<p><code>width</code> returns the minimum diameter of the geometry, defined as the smallest band that contains the geometry, where a band is a strip of the plane defined by two parallel lines. This can be thought of as the smallest hole that the geometry can be moved through, with a single rotation.
</p>
<p><code>clearance</code> returns the minimum clearance of a geometry. The minimum clearance is the smallest amount by which a vertex could be moved to produce an invalid polygon, a non-simple linestring, or a multipoint with repeated points. If a geometry has a minimum clearance of 'mc', it can be said that:
</p>
<p>No two distinct vertices in the geometry are separated by less than 'mc'
No vertex is closer than 'mc' to a line segment of which it is not an endpoint.
If the minimum clearance cannot be defined for a geometry (such as with a single point, or a multipoint whose points are identical, NA is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector'
width(x, as.lines=FALSE)
## S4 method for signature 'SpatVector'
clearance(x, as.lines=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="width_+3A_x">x</code></td>
<td>
<p>SpatVector of lines or polygons</p>
</td></tr>
<tr><td><code id="width_+3A_as.lines">as.lines</code></td>
<td>
<p>logical. If <code>TRUE</code> lines are returned that define the width or clearance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric or SpatVector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+minRect">minRect</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
width(v)
clearance(v)
</code></pre>

<hr>
<h2 id='window'>Set a window</h2><span id='topic+window'></span><span id='topic+window+3C-'></span><span id='topic+window+2CSpatRaster-method'></span><span id='topic+window+3C-+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Assign a window (area of interest) to a SpatRaster with a <code>SpatExtent</code>, or set it to <code>NULL</code> to remove the window. This is similar to <code><a href="#topic+crop">crop</a></code> without actually creating a new dataset. 
</p>
<p>The window is intersect with the extent of the SpatRaster. It is envisioned that in a future version, the window may also go outside these boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 replacement method for signature 'SpatRaster'
window(x)&lt;-value

## S4 method for signature 'SpatRaster'
window(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="window_+3A_value">value</code></td>
<td>
<p>SpatExtent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none for <code>window&lt;-</code> and logical for <code>window</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crop">crop</a></code>, <code><a href="#topic+extend">extend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
f &lt;- system.file("ex/elev.tif", package="terra") 
r &lt;- rast(f)
global(r, "mean", na.rm=TRUE)
e &lt;- ext(c(5.9, 6,49.95, 50))

window(r) &lt;- e
global(r, "mean", na.rm=TRUE)
r

x &lt;- rast(f)
xe &lt;- crop(x, e)
global(xe, "mean", na.rm=TRUE)

b &lt;- c(xe, r)
window(b)
b

window(r) &lt;- NULL
r
</code></pre>

<hr>
<h2 id='wrap'>wrap and unwrap</h2><span id='topic+wrap'></span><span id='topic+unwrap'></span><span id='topic+wrap+2CSpatVector-method'></span><span id='topic+wrap+2CSpatRaster-method'></span><span id='topic+wrap+2CSpatRasterDataset-method'></span><span id='topic+wrap+2CSpatRasterCollection-method'></span><span id='topic+unwrap+2CANY-method'></span><span id='topic+unwrap+2CPackedSpatRaster-method'></span><span id='topic+unwrap+2CPackedSpatRasterDC-method'></span><span id='topic+unwrap+2CPackedSpatVector-method'></span>

<h3>Description</h3>

<p>Use <code>wrap</code> to pack a SpatVector or SpatRaster* to create a Packed* object. Packed objects can be passed over a connection that serializes (e.g. to nodes on a computer cluster). At the receiving end they need to be unpacked with <code>unwrap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
wrap(x, proxy=FALSE)

## S4 method for signature 'SpatRasterDataset'
wrap(x, proxy=FALSE)

## S4 method for signature 'SpatRasterCollection'
wrap(x, proxy=FALSE)

## S4 method for signature 'SpatVector'
wrap(x)

## S4 method for signature 'ANY'
unwrap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_+3A_x">x</code></td>
<td>
<p>SpatVector, SpatRaster, SpatRasterDataset or SpatRasterCollection</p>
</td></tr>
<tr><td><code id="wrap_+3A_proxy">proxy</code></td>
<td>
<p>logical. If <code>FALSE</code> raster cell values are forced to memory if possible. If <code>TRUE</code>, a reference to source filenames is stored for data sources that are not in memory</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wrap</code>: Packed* object
</p>
<p><code>unwrap</code>: SpatVector, SpatRaster, SpatRasterCollection, SpatRasterDataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
p &lt;- wrap(v)
p
vv &lt;- vect(p)
vv
</code></pre>

<hr>
<h2 id='wrapCache'>SpatRaster wrap with caching options</h2><span id='topic+wrapCache'></span><span id='topic+wrapCache+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Use <code>wrap</code> to pack a SpatRaster with caching options. See <code><a href="#topic+wrap">wrap</a></code> for the general approach that is easier and better to use in most cases. 
</p>
<p>This method allows for specifying a folder, or filenames, to cache all sources of a SpatRaster in a specific location (on disk).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
wrapCache(x, filename=NULL, path=NULL, overwrite=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapCache_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="wrapCache_+3A_filename">filename</code></td>
<td>
<p>character. A single filename, or one filename per SpatRaster data source. If not <code>NULL</code>, the raster sources are saved in these files</p>
</td></tr>
<tr><td><code id="wrapCache_+3A_path">path</code></td>
<td>
<p>character. If not <code>NULL</code>, the path where raster sources will be saved. Ignored if filenames is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="wrapCache_+3A_overwrite">overwrite</code></td>
<td>
<p>Should existing files be overwritten when <code>files</code> or <code>path</code> is not <code>NULL</code>? If this value is not <code>TRUE</code> or <code>FALSE</code>, only files that do not exist are created</p>
</td></tr>
<tr><td><code id="wrapCache_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>writeRaster</code>. Only used for raster sources that are in memory, as other sources are cached by copying the files</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>PackedSpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrap">wrap</a></code>, <code><a href="#topic+unwrap">unwrap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)

x &lt;- wrapCache(r, path=tempdir())
x

</code></pre>

<hr>
<h2 id='writeCDF'>Write raster data to a NetCDF file</h2><span id='topic+writeCDF'></span><span id='topic+writeCDF+2CSpatRasterDataset-method'></span><span id='topic+writeCDF+2CSpatRaster-method'></span>

<h3>Description</h3>

<p>Write a SpatRaster or SpatRasterDataset to a NetCDF file. 
</p>
<p>When using a SpatRasterDataset, the varname, longname, and unit should be set in the object (see examples).
</p>
<p>Always use the <code>".nc"</code> or <code>".cdf"</code> file extension to assure that the file can be properly read again by GDAL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
writeCDF(x, filename, varname, longname="", unit="", split=FALSE, ...)

## S4 method for signature 'SpatRasterDataset'
writeCDF(x, filename, overwrite=FALSE, zname="time", atts="", 
    gridmap="", prec="float", compression=NA, missval, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeCDF_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatRasterDataset</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_varname">varname</code></td>
<td>
<p>character. Name of the dataset</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_longname">longname</code></td>
<td>
<p>character. Long name of the dataset</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_unit">unit</code></td>
<td>
<p>character. Unit of the data</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_split">split</code></td>
<td>
<p>logical. If <code>TRUE</code> each layer of <code>x</code> is treated as a sub-dataset</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_atts">atts</code></td>
<td>
<p>character. A vector of additional global attributes to write. The must be formatted like c(&quot;x=a value&quot;, &quot;y=abc&quot;)</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_gridmap">gridmap</code></td>
<td>
<p>character. The crs is always writting to the file in standard formats. With this argument you can also write the format commonly used in netcdf files. Something like <code>c("grid_mapping_name=lambert_azimuthal_equal_area", "longitude_of_projection_origin=10", "latitude_of_projection_origin=52", "false_easting=4321000", "false_northing=3210000")</code></p>
</td></tr>
<tr><td><code id="writeCDF_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_zname">zname</code></td>
<td>
<p>character. The name of the &quot;time&quot; dimension</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_prec">prec</code></td>
<td>
<p>character. One of &quot;double&quot;, &quot;float&quot;, &quot;integer&quot;, &quot;short&quot;, &quot;byte&quot; or &quot;char&quot;</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_compression">compression</code></td>
<td>
<p>Can be set to an integer between 1 (least compression) and 9 (most compression)</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_missval">missval</code></td>
<td>
<p>numeric, the number used to indicate missing values</p>
</td></tr>
<tr><td><code id="writeCDF_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to the SpatRasterDataset method, and from there possibly to <code><a href="ncdf4.html#topic+ncvar_def">ncvar_def</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster or SpatDataSet
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+writeRaster">writeRaster</a></code> for writing other file formats
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("ex/elev.tif", package="terra")
r &lt;- rast(f)
fname &lt;- paste0(tempfile(), ".nc")
rr &lt;- writeCDF(r, fname, overwrite=TRUE, varname="alt", 
      longname="elevation in m above sea level", unit="m")

a &lt;- rast(ncols=5, nrows=5, nl=50)
values(a) &lt;- 1:prod(dim(a))
time(a) &lt;- as.Date("2020-12-31") + 1:nlyr(a)
aa &lt;- writeCDF(a, fname, overwrite=TRUE, varname="power", 
      longname="my nice data", unit="U/Pa")

b &lt;- sqrt(a)
s &lt;- sds(a, b)
names(s) &lt;- c("temp", "prec")
longnames(s) &lt;- c("temperature (C)", "precipitation (mm)")
units(s) &lt;- c("C", "mm")
ss &lt;- writeCDF(s, fname, overwrite=TRUE)

# for CRAN
file.remove(fname)
</code></pre>

<hr>
<h2 id='writeRaster'>Write raster data to a file</h2><span id='topic+writeRaster+2CSpatRaster+2Ccharacter-method'></span><span id='topic+writeRaster'></span>

<h3>Description</h3>

<p>Write a SpatRaster to a file. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,character'
writeRaster(x, filename, overwrite=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeRaster_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="writeRaster_+3A_filename">filename</code></td>
<td>
<p>character. Output filename. Can be a single filename, or as many filenames as <code>nlyr(x)</code> to write a file for each layer</p>
</td></tr>
<tr><td><code id="writeRaster_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="writeRaster_+3A_...">...</code></td>
<td>
<p>additional arguments for for writing files. See Details </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In writeRaster, and in other methods that generate SpatRasters, options for writing raster files to disk can be provided as additional arguments or, in a few cases, as the <code>wopt</code> argument (a named list) if the additional arguments are already used for a different purpose. See <code><a href="#topic+terraOptions">terraOptions</a></code> to get or set default values. The following options are available: 
</p>

<table>
<tr>
 <td style="text-align: left;">
<b>name</b> </td><td style="text-align: left;"> <b>description</b></td>
</tr>
<tr>
 <td style="text-align: left;">

<code>datatype</code></td><td style="text-align: left;"> values accepted are "INT1U", "INT2U", "INT2S", "INT4U", "INT4S", "FLT4S", "FLT8S". With GDAL &gt;= 3.5 you can also use "INT8U" and "INT8S". And with GDAL &gt;= 3.7 you can use also use "INT1S". See <code><a href="#topic+gdal">gdal</a></code> to discover the GDAL version you are using.
The first three letters indicate whether the datatype is an integer (whole numbers) of a real number ("float", decimal numbers), the fourth character indicates the number of bytes used for each number. Higher values allow for storing larger numbers and/or more precision; but create larger files. The  "S" or "U" indicate whether the values are signed (both negative and positive) or unsigned (zero and positive values only).</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>filetype</code></td><td style="text-align: left;"> file format expresses as <a href="https://gdal.org/drivers/raster/index.html">GDAL driver names</a>. If this argument is not supplied, the driver is derived from the filename. You can use <code>gdal(drivers=TRUE)</code> to see what drivers are available in your installation</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>gdal</code></td><td style="text-align: left;"> GDAL driver specific datasource creation options. See the GDAL documentation. For example, with the <a href="https://gdal.org/drivers/raster/gtiff.html">GeoTiff file format</a> you can use <code>gdal=c("COMPRESS=DEFLATE", "TFW=YES")</code>.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>tempdir</code></td><td style="text-align: left;"> the path where temporary files are to be written to.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>progress</code></td><td style="text-align: left;"> positive integer. If the number of chunks is larger, a progress bar is shown.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>memfrac</code></td><td style="text-align: left;"> numeric between 0 and 0.9 (higher values give a warning). The fraction of available RAM that terra is allowed to use.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>memmax</code></td><td style="text-align: left;"> memmax - the maximum amount of RAM (in GB) that terra can use when processing a raster dataset. Should be less than what is detected (see <code><a href="#topic+mem_info">mem_info</a></code>, and higher values are ignored. Set it to a negative number or NA to ignore this value). </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>names</code></td><td style="text-align: left;"> output layer names.</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>NAflag</code></td><td style="text-align: left;"> numeric. value to represent missing (<code>NA</code> or <code>NaN</code>) values. See note</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>scale</code></td><td style="text-align: left;"> numeric. Cell values written to disk are divided by this value (default is 1). See <code><a href="#topic+scoff">scoff</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">

<code>offset</code></td><td style="text-align: left;"> numeric. Value that is subtracted from the cell values written to disk (default is 0). See 
<code><a href="#topic+scoff">scoff</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">

<code>verbose</code></td><td style="text-align: left;"> logical. If <code>TRUE</code> debugging information is printed</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>steps</code></td><td style="text-align: left;"> positive integers. In how many steps (chunks) do you want to process the data (for debugging)</td>
</tr>
<tr>
 <td style="text-align: left;">

<code>todisk</code></td><td style="text-align: left;"> logical. If <code>TRUE</code> processing operates as if the dataset is very large and needs to be written to a temporary file (for debugging).</td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>Value</h3>

<p>SpatRaster. This function is used for the side-effect of writing values to a file.
</p>


<h3>Note</h3>

<p>GeoTiff files are, by default, written with LZW compression. If you do not want compression, use <code>gdal="COMPRESS=NONE"</code>.
</p>
<p>When writing integer values the lowest available value (given the datatype) is used to represent <code>NA</code> for signed types, and the highest value is used for unsigned values. This can be a problem with byte data (between 0 and 255) as the value 255 is reserved for <code>NA</code>. To keep the value 255, you need to set another value as <code>NAflag</code>, or do not set a <code>NAflag</code> (with <code>NAflag=NA</code>)
</p>


<h3>See Also</h3>

<p>see <code><a href="#topic+writeCDF">writeCDF</a></code> for writing NetCDF files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(nrows=5, ncols=5, vals=1:25)

# create a temporary filename for the example
f &lt;- file.path(tempdir(), "test.tif")

writeRaster(r, f, overwrite=TRUE)

writeRaster(r, f, overwrite=TRUE, gdal=c("COMPRESS=NONE", "TFW=YES"), datatype='INT1U')

## Or with a wopt argument:

writeRaster(r, f, overwrite=TRUE, wopt= list(gdal=c("COMPRESS=NONE"), datatype='INT1U'))

## remove the file
unlink(f)
</code></pre>

<hr>
<h2 id='writeVector'>Write SpatVector data to a file</h2><span id='topic+writeVector+2CSpatVector+2Ccharacter-method'></span><span id='topic+writeVector'></span>

<h3>Description</h3>

<p>Write a SpatVector to a file. You can choose one of many file formats.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatVector,character'
writeVector(x, filename, filetype=NULL, layer=NULL, insert=FALSE,
    overwrite=FALSE, options="ENCODING=UTF-8")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeVector_+3A_x">x</code></td>
<td>
<p>SpatVector</p>
</td></tr>
<tr><td><code id="writeVector_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="writeVector_+3A_filetype">filetype</code></td>
<td>
<p>character. A file format associated with a GDAL &quot;driver&quot; such as &quot;ESRI Shapefile&quot;. See <code>gdal(drivers=TRUE)</code> or the <a href="https://gdal.org/drivers/vector/index.html">GDAL docs</a>. If <code>NULL</code> it is attempted to guess the filetype from the filename extension</p>
</td></tr>
<tr><td><code id="writeVector_+3A_layer">layer</code></td>
<td>
<p>character. Output layer name. If <code>NULL</code> the filename is used</p>
</td></tr>
<tr><td><code id="writeVector_+3A_insert">insert</code></td>
<td>
<p>logical. If <code>TRUE</code>, a new layer is inserted into the file, if the format allows it (e.g. GPKG allows that). See <code><a href="#topic+vector_layers">vector_layers</a></code> to remove a layer</p>
</td></tr>
<tr><td><code id="writeVector_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="writeVector_+3A_options">options</code></td>
<td>
<p>character. Format specific GDAL options such as &quot;ENCODING=UTF-8&quot;. Use NULL or &quot;&quot; to not use any options</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v &lt;- vect(cbind(1:5,1:5))
crs(v) &lt;- "+proj=longlat +datum=WGS84"
v$id &lt;- 1:length(v)
v$name &lt;- letters[1:length(v)]
tmpf1 &lt;- paste0(tempfile(), ".gpkg")
writeVector(v, tmpf1, overwrite=TRUE)
x &lt;- vect(tmpf1)

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)
tmpf2 &lt;- paste0(tempfile(), ".gpkg")
writeVector(v, tmpf2, overwrite=TRUE)
y &lt;- vect(tmpf2)
</code></pre>

<hr>
<h2 id='xapp'>Apply a function to the cells of a two SpatRasters</h2><span id='topic+xapp'></span><span id='topic+xapp+2CSpatRaster+2CSpatRaster-method'></span>

<h3>Description</h3>

 
<p>Apply a function to the values of each cell of two (multilayer) SpatRasters. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
xapp(x, y, fun, ..., filename="", overwrite=FALSE, wopt=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xapp_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="xapp_+3A_y">y</code></td>
<td>
<p>SpatRaster with the same geometry as <code>x</code></p>
</td></tr>
<tr><td><code id="xapp_+3A_fun">fun</code></td>
<td>
<p>a function that operates on two vectors</p>
</td></tr>
<tr><td><code id="xapp_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>fun</code>. These are typically numerical constants. They should *never* be another SpatRaster</p>
</td></tr>  
<tr><td><code id="xapp_+3A_filename">filename</code></td>
<td>
<p>character. Output filename</p>
</td></tr>
<tr><td><code id="xapp_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="xapp_+3A_wopt">wopt</code></td>
<td>
<p>list with named options for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatRaster
</p>


<h3>See Also</h3>

<p><code><a href="#topic+app">app</a></code>, <code><a href="#topic+lapp">lapp</a></code>, <code><a href="#topic+tapp">tapp</a></code>, <code><a href="#topic+Math-methods">Math-methods</a></code>, <code><a href="#topic+roll">roll</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast(ncols=10, nrows=10, nlyr=5)
set.seed(1)
r &lt;- init(r, runif)
s &lt;- init(r, runif)
x &lt;- xapp(r, s, fun=cor)
</code></pre>

<hr>
<h2 id='xmin'>Get or set single values of an extent</h2><span id='topic+xmin'></span><span id='topic+xmax'></span><span id='topic+ymin'></span><span id='topic+ymax'></span><span id='topic+xmin+3C-'></span><span id='topic+xmax+3C-'></span><span id='topic+ymin+3C-'></span><span id='topic+ymax+3C-'></span><span id='topic+xmin+2CSpatExtent-method'></span><span id='topic+xmin+2CSpatRaster-method'></span><span id='topic+xmin+2CSpatVector-method'></span><span id='topic+xmax+2CSpatExtent-method'></span><span id='topic+xmax+2CSpatRaster-method'></span><span id='topic+xmax+2CSpatVector-method'></span><span id='topic+ymin+2CSpatExtent-method'></span><span id='topic+ymin+2CSpatRaster-method'></span><span id='topic+ymin+2CSpatVector-method'></span><span id='topic+ymax+2CSpatExtent-method'></span><span id='topic+ymax+2CSpatRaster-method'></span><span id='topic+ymax+2CSpatVector-method'></span><span id='topic+xmin+3C-+2CSpatExtent+2Cnumeric-method'></span><span id='topic+xmin+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+xmax+3C-+2CSpatExtent+2Cnumeric-method'></span><span id='topic+xmax+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+ymin+3C-+2CSpatExtent+2Cnumeric-method'></span><span id='topic+ymin+3C-+2CSpatRaster+2Cnumeric-method'></span><span id='topic+ymax+3C-+2CSpatExtent+2Cnumeric-method'></span><span id='topic+ymax+3C-+2CSpatRaster+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Get or set single values of an extent. Values can be set for a SpatExtent or SpatRaster, but not for a SpatVector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatExtent'
xmin(x)

## S4 method for signature 'SpatExtent'
xmax(x)

## S4 method for signature 'SpatExtent'
ymin(x)

## S4 method for signature 'SpatExtent'
ymax(x)

## S4 method for signature 'SpatRaster'
xmin(x)

## S4 method for signature 'SpatRaster'
xmax(x)

## S4 method for signature 'SpatRaster'
ymin(x)

## S4 method for signature 'SpatRaster'
ymax(x)

## S4 method for signature 'SpatVector'
xmin(x)

## S4 method for signature 'SpatVector'
xmax(x)

## S4 method for signature 'SpatVector'
ymin(x)

## S4 method for signature 'SpatVector'
ymax(x)

## S4 replacement method for signature 'SpatRaster,numeric'
xmin(x)&lt;-value

## S4 replacement method for signature 'SpatRaster,numeric'
xmax(x)&lt;-value

## S4 replacement method for signature 'SpatRaster,numeric'
ymin(x)&lt;-value

## S4 replacement method for signature 'SpatRaster,numeric'
ymax(x)&lt;-value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmin_+3A_x">x</code></td>
<td>
<p>SpatRaster, SpatExtent, or SpatVector</p>
</td></tr>
<tr><td><code id="xmin_+3A_value">value</code></td>
<td>
<p>numeric</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>SpatExtent or numeric coordinate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()
ext(r)
ext(c(0, 20, 0, 20))

xmin(r)
xmin(r) &lt;- 0
xmin(r)
</code></pre>

<hr>
<h2 id='xyRowColCell'>Coordinates from a row, column or cell number and vice versa</h2><span id='topic+xFromCol'></span><span id='topic+xFromCol+2CSpatRaster+2Cnumeric-method'></span><span id='topic+xFromCol+2CSpatRaster+2Cmissing-method'></span><span id='topic+yFromRow'></span><span id='topic+yFromRow+2CSpatRaster+2Cnumeric-method'></span><span id='topic+yFromRow+2CSpatRaster+2Cmissing-method'></span><span id='topic+xyFromCell'></span><span id='topic+xyFromCell+2CSpatRaster+2Cnumeric-method'></span><span id='topic+xFromCell'></span><span id='topic+xFromCell+2CSpatRaster+2Cnumeric-method'></span><span id='topic+yFromCell'></span><span id='topic+yFromCell+2CSpatRaster+2Cnumeric-method'></span><span id='topic+cellFromRowCol'></span><span id='topic+cellFromRowCol+2CSpatRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic+cellFromRowColCombine'></span><span id='topic+cellFromRowColCombine+2CSpatRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic+rowColCombine'></span><span id='topic+rowColCombine+2CSpatRaster+2Cnumeric+2Cnumeric-method'></span><span id='topic+colFromX'></span><span id='topic+colFromX+2CSpatRaster+2Cnumeric-method'></span><span id='topic+rowFromY'></span><span id='topic+rowFromY+2CSpatRaster+2Cnumeric-method'></span><span id='topic+cellFromXY'></span><span id='topic+cellFromXY+2CSpatRaster+2Cmatrix-method'></span><span id='topic+cellFromXY+2CSpatRaster+2Cdata.frame-method'></span><span id='topic+rowFromCell'></span><span id='topic+rowFromCell+2CSpatRaster+2Cnumeric-method'></span><span id='topic+colFromCell'></span><span id='topic+colFromCell+2CSpatRaster+2Cnumeric-method'></span><span id='topic+rowColFromCell'></span><span id='topic+rowColFromCell+2CSpatRaster+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Get coordinates of the center of raster cells for a row, column, or cell number of a SpatRaster.
Or get row, column, or cell numbers from coordinates or from each other.
</p>
<p>Cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom.
The last cell number equals the number of cells of the SpatRaster.
row numbers start at 1 at the top, column numbers start at 1 at the left.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,numeric'
xFromCol(object, col)

## S4 method for signature 'SpatRaster,numeric'
yFromRow(object, row)

## S4 method for signature 'SpatRaster,numeric'
xyFromCell(object, cell)

## S4 method for signature 'SpatRaster,numeric'
xFromCell(object, cell)

## S4 method for signature 'SpatRaster,numeric'
yFromCell(object, cell)

## S4 method for signature 'SpatRaster,numeric'
colFromX(object, x)

## S4 method for signature 'SpatRaster,numeric'
rowFromY(object, y)

## S4 method for signature 'SpatRaster,numeric,numeric'
cellFromRowCol(object, row, col)

## S4 method for signature 'SpatRaster,numeric,numeric'
cellFromRowColCombine(object, row, col)

## S4 method for signature 'SpatRaster,numeric,numeric'
rowColCombine(object, row, col)

## S4 method for signature 'SpatRaster,numeric'
rowFromCell(object, cell)

## S4 method for signature 'SpatRaster,numeric'
colFromCell(object, cell)

## S4 method for signature 'SpatRaster,numeric'
rowColFromCell(object, cell)

## S4 method for signature 'SpatRaster,matrix'
cellFromXY(object, xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyRowColCell_+3A_object">object</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="xyRowColCell_+3A_cell">cell</code></td>
<td>
<p>integer. cell number(s)</p>
</td></tr>
<tr><td><code id="xyRowColCell_+3A_col">col</code></td>
<td>
<p>integer. column number(s) or missing (equivalent to all columns)</p>
</td></tr>
<tr><td><code id="xyRowColCell_+3A_row">row</code></td>
<td>
<p>integer. row number(s) or missing (equivalent to all rows)</p>
</td></tr>
<tr><td><code id="xyRowColCell_+3A_x">x</code></td>
<td>
<p>x coordinate(s)</p>
</td></tr>
<tr><td><code id="xyRowColCell_+3A_y">y</code></td>
<td>
<p>y coordinate(s)</p>
</td></tr>
<tr><td><code id="xyRowColCell_+3A_xy">xy</code></td>
<td>
<p>matrix of x and y coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cell numbers start at 1 in the upper left corner, and increase from left to right, and then from top to bottom.
The last cell number equals the number of cells of the SpatRaster (see <code><a href="#topic+ncell">ncell</a></code>).
</p>


<h3>Value</h3>

<p>xFromCol, yFromCol, xFromCell, yFromCell: vector of x or y coordinates
</p>
<p>xyFromCell: matrix(x,y) with coordinate pairs
</p>
<p>colFromX, rowFromY, cellFromXY, cellFromRowCol, rowFromCell, colFromCell: vector of row, column, or cell numbers
</p>
<p>rowColFromCell, rowColCombine: matrix of row and column numbers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+crds">crds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rast()

xFromCol(r, c(1, 120, 180))
yFromRow(r, 90)
xyFromCell(r, 10000)
xyFromCell(r, c(0, 1, 32581, ncell(r), ncell(r)+1))

cellFromRowCol(r, 5, 5)
cellFromRowCol(r, 1:2, 1:2)
cellFromRowCol(r, 1, 1:3)

# all combinations
cellFromRowColCombine(r, 1:2, 1:2)

colFromX(r, 10)
rowFromY(r, 10)
xy &lt;- cbind(lon=c(10,5), lat=c(15, 88))
cellFromXY(r, xy)

# if no row/col specified all are returned
range(xFromCol(r))
length(yFromRow(r))
</code></pre>

<hr>
<h2 id='zonal'>Zonal statistics</h2><span id='topic+zonal'></span><span id='topic+zonal+2CSpatRaster+2CSpatRaster-method'></span><span id='topic+zonal+2CSpatRaster+2CSpatVector-method'></span><span id='topic+zonal+2CSpatVector+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Compute zonal statistics, that is summarize values of a SpatRaster for each &quot;zone&quot; defined by another SpatRaster, or by a SpatVector with polygon geometry. 
</p>
<p>If <code>fun</code> is a true R <code>function</code>, the &lt;SpatRaster,SpatRaster&gt; method may fail when using very large SpatRasters, except for the functions (&quot;mean&quot;, &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;isNA&quot;, and &quot;notNA&quot;). 
</p>
<p>You can also summarize values of a SpatVector for each polygon (zone) defined by another SpatVector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster,SpatRaster'
zonal(x, z, fun="mean", ..., w=NULL, wide=TRUE,
		as.raster=FALSE, filename="", overwrite=FALSE, wopt=list())

## S4 method for signature 'SpatRaster,SpatVector'
zonal(x, z, fun="mean", na.rm=FALSE, w=NULL, weights=FALSE,
		exact=FALSE, touches=FALSE, as.raster=FALSE, as.polygons=FALSE, wide=TRUE, 
		filename="", wopt=list())

## S4 method for signature 'SpatVector,SpatVector'
zonal(x, z, fun=mean, ..., weighted=FALSE, as.polygons=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zonal_+3A_x">x</code></td>
<td>
<p>SpatRaster or SpatVector</p>
</td></tr>
<tr><td><code id="zonal_+3A_z">z</code></td>
<td>
<p>SpatRaster with cell-values representing zones or a SpatVector with each polygon geometry representing a zone. <code>z</code> can have multiple layers to define intersecting zones</p>
</td></tr>
<tr><td><code id="zonal_+3A_fun">fun</code></td>
<td>
<p>function to be applied to summarize the values by zone. Either as character: &quot;mean&quot;, &quot;min&quot;, &quot;max&quot;, &quot;sum&quot;, &quot;isNA&quot;, and &quot;notNA&quot; and, for relatively small SpatRasters, a proper function</p>
</td></tr>
<tr><td><code id="zonal_+3A_...">...</code></td>
<td>
<p>additional arguments passed to fun, such as <code>na.rm=TRUE</code></p>
</td></tr>  
<tr><td><code id="zonal_+3A_w">w</code></td>
<td>
<p>SpatRaster with weights. Should have a single-layer with non-negative values</p>
</td></tr>
<tr><td><code id="zonal_+3A_wide">wide</code></td>
<td>
<p>logical. Should the values returned in a wide format? For the <code>SpatRaster, SpatRaster</code> method this only affects the results when <code>nlyr(z) == 2</code>. For the <code>SpatRaster, SpatVector</code> method this only affects the results when <code>fun=table</code></p>
</td></tr>
<tr><td><code id="zonal_+3A_as.raster">as.raster</code></td>
<td>
<p>logical. If <code>TRUE</code>, a SpatRaster is returned with the zonal statistic for each zone</p>
</td></tr>  
<tr><td><code id="zonal_+3A_filename">filename</code></td>
<td>
<p>character. Output filename (ignored if <code>as.raster=FALSE</code></p>
</td></tr>
<tr><td><code id="zonal_+3A_overwrite">overwrite</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>filename</code> is overwritten</p>
</td></tr>
<tr><td><code id="zonal_+3A_wopt">wopt</code></td>
<td>
<p>list with additional arguments for writing files as in <code><a href="#topic+writeRaster">writeRaster</a></code></p>
</td></tr>
<tr><td><code id="zonal_+3A_weights">weights</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> has polygons, the approximate fraction of each cell that is covered is returned as well, for example to compute a weighted mean</p>
</td></tr>
<tr><td><code id="zonal_+3A_exact">exact</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>y</code> has polygons, the exact fraction of each cell that is covered is returned as well, for example to compute a weighted mean</p>
</td></tr>
<tr><td><code id="zonal_+3A_touches">touches</code></td>
<td>
<p>logical. If <code>TRUE</code>, values for all cells touched by lines or polygons are extracted, not just those on the line render path, or whose center point is within the polygon. Not relevant for points; and always considered <code>TRUE</code> when <code>weights=TRUE</code> or <code>exact=TRUE</code></p>
</td></tr>
<tr><td><code id="zonal_+3A_weighted">weighted</code></td>
<td>
<p>logical. If <code>TRUE</code>, a weighted.mean is computed and <code>fun</code> is ignored. Weights are based on the length of the lines or the area of the polygons in <code>x</code> that intersect with <code>z</code>. This argument is ignored of <code>x</code> is a SpatVector or points</p>
</td></tr>  
<tr><td><code id="zonal_+3A_as.polygons">as.polygons</code></td>
<td>
<p>logical. Should the zonal statistics be combined with the geometry of <code>z</code>?</p>
</td></tr>
<tr><td><code id="zonal_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>NA</code>s are removed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with a value for each zone, or a SpatRaster, or SpatVector of polygons.
</p>


<h3>See Also</h3>

<p> See <code><a href="#topic+global">global</a></code> for &quot;global&quot; statistics (i.e., all of <code>x</code> is considered a single zone), <code><a href="#topic+app">app</a></code> for local statistics, and <code><a href="#topic+extract">extract</a></code> for an alternative way to summarize values of a SpatRaster with a SpatVector. With <code><a href="#topic+aggregate">aggregate</a></code> you can compute statistics for cell blocks defined by a number of rows and columns. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### SpatRaster, SpatRaster
r &lt;- rast(ncols=10, nrows=10)
values(r) &lt;- 1:ncell(r)
z &lt;- rast(r)
values(z) &lt;- rep(c(1:2, NA, 3:4), each=20)
names(z) &lt;- "zone"
zonal(r, z, "sum", na.rm=TRUE)

# with weights 
w &lt;- init(r, "col")
zonal(r, z, w=w, "mean", na.rm=TRUE)

# multiple layers
r &lt;- rast(system.file("ex/logo.tif", package = "terra")) 
# zonal layer 
z &lt;- rast(r, 1)
names(z) &lt;- "zone"
values(z) &lt;- rep(c(1:2, NA, c(3:4)), each=ncell(r)/5, length.out=ncell(r))

zonal(r, z, "mean", na.rm = TRUE)

# raster of zonal values
zr &lt;- zonal(r, z, "mean", na.rm = TRUE, as.raster=TRUE)


### SpatRaster, SpatVector
x &lt;- rast(ncol=2,nrow=2, vals=1:4, xmin=0, xmax=1, ymin=0, ymax=1, crs="+proj=utm +zone=1")
p &lt;- as.polygons(x)
pp &lt;- shift(p, .2)
r &lt;- disagg(x, 4)

zonal(r, p)
zonal(r, p, sum)
zonal(x, pp, exact=TRUE)
zonal(c(x, x*10), pp, w=x)


### SpatVector, SpatVector

f &lt;- system.file("ex/lux.shp", package="terra")
v &lt;- vect(f)[,c(2,4)]

p &lt;- spatSample(v, 100)
values(p) &lt;- data.frame(b2=1:100, ssep1=100:1)

zonal(p, v, mean)
</code></pre>

<hr>
<h2 id='zoom'>Zoom in on a map</h2><span id='topic+zoom'></span><span id='topic+zoom+2CSpatRaster-method'></span><span id='topic+zoom+2CSpatVector-method'></span>

<h3>Description</h3>

<p>Zoom in on a map (plot) by providing a new extent, by default this is done by clicking twice on the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatRaster'
zoom(x, e=draw(), maxcell=100000, layer=1, new=FALSE, ...)

## S4 method for signature 'SpatVector'
zoom(x, e=draw(), new=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zoom_+3A_x">x</code></td>
<td>
<p>SpatRaster</p>
</td></tr>
<tr><td><code id="zoom_+3A_e">e</code></td>
<td>
<p>SpatExtent</p>
</td></tr>
<tr><td><code id="zoom_+3A_maxcell">maxcell</code></td>
<td>
<p>positive integer. Maximum number of cells used for the map</p>
</td></tr>
<tr><td><code id="zoom_+3A_layer">layer</code></td>
<td>
<p>positive integer to select the layer to be used</p>
</td></tr>
<tr><td><code id="zoom_+3A_new">new</code></td>
<td>
<p>logical. If <code>TRUE</code>, the zoomed in map will appear on a new device (window)</p>
</td></tr>
<tr><td><code id="zoom_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatExtent (invisibly)
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+draw">draw</a></code>, <code><a href="#topic+plot">plot</a></code></p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
