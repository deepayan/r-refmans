<!DOCTYPE html><html><head><title>Help for package nnls</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nnls}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nnls-package'><p>The Lawson-Hanson NNLS implementation of non-negative least squares</p></a></li>
<li><a href='#nnls'><p>The Lawson-Hanson NNLS implemention of non-negative least squares</p></a></li>
<li><a href='#nnnpls'><p>An implementation of least squares with non-negative and non-positive</p>
constraints</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Lawson-Hanson Algorithm for Non-Negative Least Squares
(NNLS)</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Katharine M. Mullen and Ivo H. M. van Stokkum</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Katharine Mullen &lt;mullenkate@gmail.com&gt;</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bvls, quadprog</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface to the Lawson-Hanson implementation of an
        algorithm for non-negative least squares (NNLS).  Also allows
        the combination of non-negative and non-positive constraints.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 04:13:04 UTC; kmm-windog</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-11 07:20:07 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
</table>
<hr>
<h2 id='nnls-package'>The Lawson-Hanson NNLS implementation of non-negative least squares</h2><span id='topic+nnls-package'></span>

<h3>Description</h3>

<p>An R interface to the Lawson-Hanson
NNLS implementation of an algorithm
for non-negative linear least squares 
that solves the least squares problem
<code class="reqn">\min{\parallel A x = b \parallel_2}</code>
with the constraint <code class="reqn">x \ge 0</code> where
<code class="reqn">x \in R^n, b \in R^m</code>  and <code class="reqn">A</code> is an
<code class="reqn">m \times n</code> matrix. 
Also allows the combination of non-negative and non-positive
constraints on <code class="reqn">x</code>. 
</p>


<h3>References</h3>

<p>Lawson CL, Hanson RJ (1974). Solving Least Squares Problems. Prentice
Hall, Englewood Cliffs, NJ.
</p>
<p>Lawson CL, Hanson RJ (1995). Solving Least Squares Problems. Classics
in Applied Mathematics. SIAM, Philadelphia.
</p>


<h3>See Also</h3>

 <p><a href="#topic+nnls">nnls</a>, <a href="#topic+nnnpls">nnnpls</a>,
the method <code>"L-BFGS-B"</code> for <a href="stats.html#topic+optim">optim</a>,
<a href="quadprog.html#topic+solve.QP">solve.QP</a>, <a href="bvls.html#topic+bvls">bvls</a>
</p>

<hr>
<h2 id='nnls'>The Lawson-Hanson NNLS implemention of non-negative least squares</h2><span id='topic+nnls'></span>

<h3>Description</h3>

<p>An R interface to the Lawson-Hanson
NNLS implementation of an algorithm
for non-negative linear least squares 
that solves 
<code class="reqn">\min{\parallel A x - b \parallel_2}</code> with the
constraint <code class="reqn">x \ge 0</code>,  where
<code class="reqn">x \in R^n, b \in R^m</code>  and <code class="reqn">A</code> is an <code class="reqn">m \times n</code> matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnls(A, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnls_+3A_a">A</code></td>
<td>
<p>numeric matrix with <code>m</code> rows and <code>n</code> columns</p>
</td></tr>
<tr><td><code id="nnls_+3A_b">b</code></td>
<td>
<p>numeric vector of length <code>m</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nnls</code> returns
an object of class <code>"nnls"</code>.
</p>
<p>The generic accessor functions <code>coefficients</code>,
<code>fitted.values</code>, <code>deviance</code> and <code>residuals</code> extract
various useful features of the value returned by <code>nnls</code>.
</p>
<p>An object of class <code>"nnls"</code> is a list containing the
following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the parameter estimates.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the residual sum-of-squares.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>a character vector containing a message regarding why
termination occured.</p>
</td></tr>
<tr><td><code>passive</code></td>
<td>
<p>vector of the indices of <code>x</code> that are not bound
at zero. </p>
</td></tr>
<tr><td><code>bound</code></td>
<td>
<p>vector of the indices of <code>x</code> that are bound
at zero.</p>
</td></tr>
<tr><td><code>nsetp</code></td>
<td>
<p>the number of elements of <code>x</code> that are not bound
at zero. </p>
</td></tr>
</table>


<h3>Source</h3>

<p>This is an R interface to the Fortran77 code distributed
with the book referenced below by Lawson CL, Hanson RJ (1995),
obtained from Netlib (file &lsquo;<span class="file">lawson-hanson/all</span>&rsquo;), 
with a trivial modification to return the variable
NSETP.
</p>


<h3>References</h3>

<p>Lawson CL, Hanson RJ (1974). Solving Least Squares Problems. Prentice
Hall, Englewood Cliffs, NJ.
</p>
<p>Lawson CL, Hanson RJ (1995). Solving Least Squares Problems. Classics
in Applied Mathematics. SIAM, Philadelphia.
</p>


<h3>See Also</h3>

<p><a href="#topic+nnnpls">nnnpls</a>, the method <code>"L-BFGS-B"</code> for <a href="stats.html#topic+optim">optim</a>,
<a href="quadprog.html#topic+solve.QP">solve.QP</a>, <a href="bvls.html#topic+bvls">bvls</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a matrix A
## with 3 columns, each containing an exponential decay 
t &lt;- seq(0, 2, by = .04)
k &lt;- c(.5, .6, 1)
A &lt;- matrix(nrow = 51, ncol = 3)
Acolfunc &lt;- function(k, t) exp(-k*t)
for(i in 1:3) A[,i] &lt;- Acolfunc(k[i],t)

## simulate a matrix X
## with 3 columns, each containing a Gaussian shape 
## the Gaussian shapes are non-negative
X &lt;- matrix(nrow = 51, ncol = 3)
wavenum &lt;- seq(18000,28000, by=200)
location &lt;- c(25000, 22000, 20000) 
delta &lt;- c(3000,3000,3000)
Xcolfunc &lt;- function(wavenum, location, delta)
  exp( - log(2) * (2 * (wavenum - location)/delta)^2)
for(i in 1:3) X[,i] &lt;- Xcolfunc(wavenum, location[i], delta[i])

## set seed for reproducibility
set.seed(3300)

## simulated data is the product of A and X with some
## spherical Gaussian noise added 
matdat &lt;- A %*% t(X) + .005 * rnorm(nrow(A) * nrow(X))

## estimate the rows of X using NNLS criteria 
nnls_sol &lt;- function(matdat, A) {
  X &lt;- matrix(0, nrow = 51, ncol = 3)
  for(i in 1:ncol(matdat)) 
     X[i,] &lt;- coef(nnls(A,matdat[,i]))
  X
}
X_nnls &lt;- nnls_sol(matdat,A) 

matplot(X_nnls,type="b",pch=20)
abline(0,0, col=grey(.6))

## Not run: 
## can solve the same problem with L-BFGS-B algorithm
## but need starting values for x 
bfgs_sol &lt;- function(matdat, A) {
  startval &lt;- rep(0, ncol(A))
  fn1 &lt;- function(par1, b, A) sum( ( b - A %*% par1)^2)
  X &lt;- matrix(0, nrow = 51, ncol = 3)
  for(i in 1:ncol(matdat))  
    X[i,] &lt;-  optim(startval, fn = fn1, b=matdat[,i], A=A,
                   lower = rep(0,3), method="L-BFGS-B")$par
    X
}
X_bfgs &lt;- bfgs_sol(matdat,A) 

## the RMS deviation under NNLS is less than under L-BFGS-B 
sqrt(sum((X - X_nnls)^2)) &lt; sqrt(sum((X - X_bfgs)^2))

## and L-BFGS-B is much slower 
system.time(nnls_sol(matdat,A))
system.time(bfgs_sol(matdat,A))

## can also solve the same problem by reformulating it as a
## quadratic program (this requires the quadprog package; if you
## have quadprog installed, uncomment lines below starting with
## only 1 "#" )

# library(quadprog)

# quadprog_sol &lt;- function(matdat, A) {
#  X &lt;- matrix(0, nrow = 51, ncol = 3)
#  bvec &lt;- rep(0, ncol(A))
#  Dmat &lt;- crossprod(A,A)
#  Amat &lt;- diag(ncol(A))
#  for(i in 1:ncol(matdat)) { 
#    dvec &lt;- crossprod(A,matdat[,i]) 
#    X[i,] &lt;- solve.QP(dvec = dvec, bvec = bvec, Dmat=Dmat,
#                      Amat=Amat)$solution
#  }
#  X
# }
# X_quadprog &lt;- quadprog_sol(matdat,A) 

## the RMS deviation under NNLS is about the same as under quadprog 
# sqrt(sum((X - X_nnls)^2))
# sqrt(sum((X - X_quadprog)^2))

## and quadprog requires about the same amount of time 
# system.time(nnls_sol(matdat,A))
# system.time(quadprog_sol(matdat,A))


## End(Not run)

</code></pre>

<hr>
<h2 id='nnnpls'>An implementation of least squares with non-negative and non-positive
constraints</h2><span id='topic+nnnpls'></span>

<h3>Description</h3>

<p>An implementation of an algorithm for linear least squares problems
with non-negative and non-positive
constraints based on the Lawson-Hanson
NNLS algorithm.   Solves <code class="reqn">\min{\parallel A x - b \parallel_2}</code>
with the constraint <code class="reqn">x_i \ge 0</code>
if <code class="reqn">con_i \ge 0</code> and <code class="reqn">x_i \le 0</code> otherwise,  where
<code class="reqn">x, con \in R^n, b \in R^m</code>, and <code class="reqn">A</code> is an <code class="reqn">m \times n</code> matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nnnpls(A, b, con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nnnpls_+3A_a">A</code></td>
<td>
<p>numeric matrix with <code>m</code> rows and <code>n</code> columns</p>
</td></tr>
<tr><td><code id="nnnpls_+3A_b">b</code></td>
<td>
<p>numeric vector of length <code>m</code> </p>
</td></tr>
<tr><td><code id="nnnpls_+3A_con">con</code></td>
<td>
<p>numeric vector of length <code>m</code> where element <code>i</code>
is negative if and only if element <code>i</code> of the solution vector
<code>x</code> should be constrained to non-positive, as opposed to
non-negative, values. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nnnpls</code> returns
an object of class <code>"nnnpls"</code>.
</p>
<p>The generic accessor functions <code>coefficients</code>,
<code>fitted.values</code>, <code>deviance</code> and <code>residuals</code> extract
various useful features of the value returned by <code>nnnpls</code>.
</p>
<p>An object of class <code>"nnnpls"</code> is a list containing the
following components:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the parameter estimates.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the residual sum-of-squares.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>mode</code></td>
<td>
<p>a character vector containing a message regarding why
termination occured.</p>
</td></tr>
<tr><td><code>passive</code></td>
<td>
<p>vector of the indices of <code>x</code> that are not bound
at zero. </p>
</td></tr>
<tr><td><code>bound</code></td>
<td>
<p>vector of the indices of <code>x</code> that are bound
at zero.</p>
</td></tr>
<tr><td><code>nsetp</code></td>
<td>
<p>the number of elements of <code>x</code> that are not bound
at zero. </p>
</td></tr>
</table>


<h3>Source</h3>

<p>This is an R interface to Fortran77 code distributed
with the book referenced below by Lawson CL, Hanson RJ (1995),
obtained from Netlib (file &lsquo;<span class="file">lawson-hanson/all</span>&rsquo;), with some
trivial modifications to allow for the combination of constraints to
non-negative and non-positive values, and to return the variable
NSETP.
</p>


<h3>References</h3>

<p>Lawson CL, Hanson RJ (1974). Solving Least Squares Problems. Prentice
Hall, Englewood Cliffs, NJ.
</p>
<p>Lawson CL, Hanson RJ (1995). Solving Least Squares Problems. Classics
in Applied Mathematics. SIAM, Philadelphia.
</p>


<h3>See Also</h3>

<p><a href="#topic+nnls">nnls</a>, the method <code>"L-BFGS-B"</code> for <a href="stats.html#topic+optim">optim</a>,
<a href="quadprog.html#topic+solve.QP">solve.QP</a>, <a href="bvls.html#topic+bvls">bvls</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate a matrix A
## with 3 columns, each containing an exponential decay 
t &lt;- seq(0, 2, by = .04)
k &lt;- c(.5, .6, 1)
A &lt;- matrix(nrow = 51, ncol = 3)
Acolfunc &lt;- function(k, t) exp(-k*t)
for(i in 1:3) A[,i] &lt;- Acolfunc(k[i],t)

## simulate a matrix X
## with 3 columns, each containing a Gaussian shape 
## 2 of the Gaussian shapes are non-negative and 1 is non-positive 
X &lt;- matrix(nrow = 51, ncol = 3)
wavenum &lt;- seq(18000,28000, by=200)
location &lt;- c(25000, 22000, 20000) 
delta &lt;- c(3000,3000,3000)
Xcolfunc &lt;- function(wavenum, location, delta)
  exp( - log(2) * (2 * (wavenum - location)/delta)^2)
for(i in 1:3) X[,i] &lt;- Xcolfunc(wavenum, location[i], delta[i])
X[,2] &lt;- -X[,2]

## set seed for reproducibility
set.seed(3300)

## simulated data is the product of A and X with some
## spherical Gaussian noise added 
matdat &lt;- A %*% t(X) + .005 * rnorm(nrow(A) * nrow(X))

## estimate the rows of X using NNNPLS criteria 
nnnpls_sol &lt;- function(matdat, A) {
  X &lt;- matrix(0, nrow = 51, ncol = 3)
  for(i in 1:ncol(matdat)) 
     X[i,] &lt;- coef(nnnpls(A,matdat[,i],con=c(1,-1,1)))
  X
}
X_nnnpls &lt;- nnnpls_sol(matdat,A) 

## Not run:  
## can solve the same problem with L-BFGS-B algorithm
## but need starting values for x and 
## impose a very low/high bound where none is desired
bfgs_sol &lt;- function(matdat, A) {
  startval &lt;- rep(0, ncol(A))
  fn1 &lt;- function(par1, b, A) sum( ( b - A %*% par1)^2)
  X &lt;- matrix(0, nrow = 51, ncol = 3)
  for(i in 1:ncol(matdat))  
    X[i,] &lt;-  optim(startval, fn = fn1, b=matdat[,i], A=A,
              lower=rep(0, -1000, 0), upper=c(1000,0,1000),
              method="L-BFGS-B")$par
    X
}
X_bfgs &lt;- bfgs_sol(matdat,A) 

## the RMS deviation under NNNPLS is less than under L-BFGS-B 
sqrt(sum((X - X_nnnpls)^2)) &lt; sqrt(sum((X - X_bfgs)^2))

## and L-BFGS-B is much slower 
system.time(nnnpls_sol(matdat,A))
system.time(bfgs_sol(matdat,A))

## can also solve the same problem by reformulating it as a
## quadratic program (this requires the quadprog package; if you
## have quadprog installed, uncomment lines below starting with
## only 1 "#" )

# library(quadprog)

# quadprog_sol &lt;- function(matdat, A) {
#  X &lt;- matrix(0, nrow = 51, ncol = 3)
#  bvec &lt;- rep(0, ncol(A))
#  Dmat &lt;- crossprod(A,A)
#  Amat &lt;- diag(c(1,-1,1))
#  for(i in 1:ncol(matdat)) { 
#    dvec &lt;- crossprod(A,matdat[,i]) 
#    X[i,] &lt;- solve.QP(dvec = dvec, bvec = bvec, Dmat=Dmat,
#                      Amat=Amat)$solution
#  }
#  X
# }
# X_quadprog &lt;- quadprog_sol(matdat,A) 

## the RMS deviation under NNNPLS is about the same as under quadprog 
# sqrt(sum((X - X_nnnpls)^2))
# sqrt(sum((X - X_quadprog)^2))

## and quadprog requires about the same amount of time 
# system.time(nnnpls_sol(matdat,A))
# system.time(quadprog_sol(matdat,A))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
