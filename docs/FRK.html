<!DOCTYPE html><html><head><title>Help for package FRK</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FRK}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIRS_05_2003'><p>AIRS data for May 2003</p></a></li>
<li><a href='#Am_data'><p>Americium soil data</p></a></li>
<li><a href='#auto_basis'><p>Automatic basis-function placement</p></a></li>
<li><a href='#auto_BAUs'><p>Automatic BAU generation</p></a></li>
<li><a href='#Basis'><p>Generic basis-function constructor</p></a></li>
<li><a href='#Basis_obj-class'><p>Basis functions</p></a></li>
<li><a href='#BAUs_from_points'><p>Creates pixels around points</p></a></li>
<li><a href='#coef_uncertainty'><p>Uncertainty quantification of the fixed effects</p></a></li>
<li><a href='#combine_basis'><p>Combine basis functions</p></a></li>
<li><a href='#data.frame&lt;-'><p>Basis-function data frame object</p></a></li>
<li><a href='#df_to_SpatialPolygons'><p>Convert data frame to SpatialPolygons</p></a></li>
<li><a href='#dist-matrix'><p>Distance Matrix Computation from Two Matrices</p></a></li>
<li><a href='#distance'><p>Compute distance</p></a></li>
<li><a href='#distances'><p>Pre-configured distances</p></a></li>
<li><a href='#draw_world'><p>Draw a map of the world with country boundaries.</p></a></li>
<li><a href='#eval_basis'><p>Evaluate basis functions</p></a></li>
<li><a href='#FRK'><p>Construct SRE object, fit and predict</p></a></li>
<li><a href='#info_fit'><p>Retrieve fit information for SRE model</p></a></li>
<li><a href='#initialize,manifold-method'><p>manifold</p></a></li>
<li><a href='#isea3h'><p>ISEA Aperture 3 Hexagon (ISEA3H) Discrete Global Grid</p></a></li>
<li><a href='#local_basis'><p>Construct a set of local basis functions</p></a></li>
<li><a href='#loglik'><p>(Deprecated) Retrieve log-likelihood</p></a></li>
<li><a href='#manifold'><p>Retrieve manifold</p></a></li>
<li><a href='#manifold-class'><p>manifold</p></a></li>
<li><a href='#measure-class'><p>measure</p></a></li>
<li><a href='#MODIS_cloud_df'><p>MODIS cloud data</p></a></li>
<li><a href='#nbasis'><p>Number of basis functions</p></a></li>
<li><a href='#NOAA_df_1990'><p>NOAA maximum temperature data for 1990&ndash;1993</p></a></li>
<li><a href='#nres'><p>Return  the number of resolutions</p></a></li>
<li><a href='#observed_BAUs'><p>Observed (or unobserved) BAUs</p></a></li>
<li><a href='#opts_FRK'><p>FRK options</p></a></li>
<li><a href='#plane'><p>plane</p></a></li>
<li><a href='#plot'><p>Plot predictions from FRK analysis</p></a></li>
<li><a href='#plot_spatial_or_ST'><p>Plot a Spatial*DataFrame or STFDF object</p></a></li>
<li><a href='#plotting-themes'><p>Plotting themes</p></a></li>
<li><a href='#real_line'><p>real line</p></a></li>
<li><a href='#remove_basis'><p>Removes basis functions</p></a></li>
<li><a href='#show_basis'><p>Show basis functions</p></a></li>
<li><a href='#SpatialPolygonsDataFrame_to_df'><p>SpatialPolygonsDataFrame to df</p></a></li>
<li><a href='#sphere'><p>sphere</p></a></li>
<li><a href='#SRE-class'><p>Spatial Random Effects class</p></a></li>
<li><a href='#SRE.predict'><p>Deprecated: Please use <code>predict</code></p></a></li>
<li><a href='#STplane'><p>plane in space-time</p></a></li>
<li><a href='#STsphere'><p>Space-time sphere</p></a></li>
<li><a href='#TensorP'><p>Tensor product of basis functions</p></a></li>
<li><a href='#type'><p>Type of manifold</p></a></li>
<li><a href='#worldmap'><p>World map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fixed Rank Kriging</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-03</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Zammit-Mangion &lt;andrewzm@gmail.com&gt;</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Description:</td>
<td>A tool for spatial/spatio-temporal modelling and prediction with large datasets. The approach models the field, and hence the covariance function, using a set of basis functions. This fixed-rank basis-function representation facilitates the modelling of big data, and the method naturally allows for non-stationary, anisotropic covariance functions. Discretisation of the spatial domain into so-called basic areal units (BAUs) facilitates the use of observations with varying support (i.e., both point-referenced and areal supports, potentially simultaneously), and prediction over arbitrary user-specified regions. 'FRK' also supports inference over various manifolds, including the 2D plane and 3D sphere, and it provides helper functions to model, fit, predict, and plot with relative ease. Version 2.0.0 and above also supports the modelling of non-Gaussian data (e.g., Poisson, binomial, negative-binomial, gamma, and inverse-Gaussian) by employing a generalised linear mixed model (GLMM) framework. Zammit-Mangion and Cressie &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i04">doi:10.18637/jss.v098.i04</a>&gt; describe 'FRK' in a Gaussian setting, and detail its use of basis functions and BAUs, while Sainsbury-Dale, Zammit-Mangion, and Cressie &lt;<a href="https://doi.org/10.18637%2Fjss.v108.i10">doi:10.18637/jss.v108.i10</a>&gt; describe 'FRK' in a non-Gaussian setting; two vignettes are available that summarise these papers and provide additional examples.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://andrewzm.github.io/FRK/">https://andrewzm.github.io/FRK/</a>, <a href="https://github.com/andrewzm/FRK/">https://github.com/andrewzm/FRK/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/andrewzm/FRK/issues/">https://github.com/andrewzm/FRK/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dggrids, gstat, INLA, knitr, lme4, mapproj, parallel,
sf, spdep, splancs, testthat, verification</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, dplyr, ggplot2, grDevices, Hmisc (&ge; 4.1), Matrix,
methods, plyr, Rcpp (&ge; 0.12.12), sp, spacetime, sparseinv,
statmod, stats, TMB, utils, ggpubr, reshape2, scales</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://andrewzm.github.io/dggrids-repo/">https://andrewzm.github.io/dggrids-repo/</a>,
<a href="https://inla.r-inla-download.org/R/stable/">https://inla.r-inla-download.org/R/stable/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, TMB, RcppEigen</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-02 17:03:11 UTC; andrewzm</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Zammit-Mangion [aut, cre],
  Matthew Sainsbury-Dale [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-03 00:14:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIRS_05_2003'>AIRS data for May 2003</h2><span id='topic+AIRS_05_2003'></span>

<h3>Description</h3>

<p>Mid-tropospheric CO2 measurements from the Atmospheric InfraRed Sounder (AIRS).
The data are measurements between 60 degrees S and 90 degrees N at roughly 1:30 pm local
time on 1 May through to 15 May 2003. (AIRS does not release data below 60 degrees S.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AIRS_05_2003
</code></pre>


<h3>Format</h3>

<p>A data frame with 209631 rows and 7 variables:
</p>

<dl>
<dt>year</dt><dd><p>year of retrieval</p>
</dd>
<dt>month</dt><dd><p>month of retrieval</p>
</dd>
<dt>day</dt><dd><p>day of retrieval</p>
</dd>
<dt>lon</dt><dd><p>longitude coordinate of retrieval</p>
</dd>
<dt>lat</dt><dd><p>latitude coordinate of retrieval</p>
</dd>
<dt>co2avgret</dt><dd><p>CO2 mole fraction retrieval in ppm</p>
</dd>
<dt>co2std</dt><dd><p>standard error of CO2 retrieval in ppm</p>
</dd>
</dl>



<h3>References</h3>

<p>Chahine, M. et al. (2006). AIRS: Improving weather forecasting and
providing new data on greenhouse gases. Bulletin of the American Meteorological
Society 87, 911&ndash;26.
</p>

<hr>
<h2 id='Am_data'>Americium soil data</h2><span id='topic+Am_data'></span>

<h3>Description</h3>

<p>Americium (Am) concentrations in a spatial domain immediately surrounding the location at which nuclear devices were detonated at Area 13 of the Nevada Test Site, between 1954 and 1963.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Am_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 212 rows and 3 variables:
</p>

<dl>
<dt>Easting</dt><dd><p>Easting in metres</p>
</dd>
<dt>Northing</dt><dd><p>Northing in metres</p>
</dd>
<dt>Am</dt><dd><p>Americium concentration in 1000 counts per minute</p>
</dd>
</dl>



<h3>References</h3>

<p>Paul R, Cressie N (2011). “Lognormal block kriging for contaminated soil.” European Journal of Soil Science, 62, 337–345.
</p>

<hr>
<h2 id='auto_basis'>Automatic basis-function placement</h2><span id='topic+auto_basis'></span>

<h3>Description</h3>

<p>Automatically generate a set of local basis functions in the domain, and automatically prune in regions of sparse data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_basis(
  manifold = plane(),
  data,
  regular = 1,
  nres = 3,
  prune = 0,
  max_basis = NULL,
  subsamp = 10000,
  type = c("bisquare", "Gaussian", "exp", "Matern32"),
  isea3h_lo = 2,
  bndary = NULL,
  scale_aperture = ifelse(is(manifold, "sphere"), 1, 1.25),
  verbose = 0L,
  buffer = 0,
  tunit = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_basis_+3A_manifold">manifold</code></td>
<td>
<p>object of class <code>manifold</code>, for example, <code>sphere</code> or <code>plane</code></p>
</td></tr>
<tr><td><code id="auto_basis_+3A_data">data</code></td>
<td>
<p>object of class <code>SpatialPointsDataFrame</code> or <code>SpatialPolygonsDataFrame</code> containing the data on which basis-function placement is based, or a list of these; see details</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_regular">regular</code></td>
<td>
<p>an integer indicating the number of regularly-placed basis functions at the first resolution. In two dimensions, this dictates the smallest number of basis functions in a row or column at the coarsest resolution. If <code>regular=0</code>, an irregular grid is used, one that is based on the triangulation of the domain with increased mesh density in areas of high data density; see details</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_nres">nres</code></td>
<td>
<p>the number of basis-function resolutions to use</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_prune">prune</code></td>
<td>
<p>a threshold parameter that dictates when a basis function is considered irrelevent or unidentifiable, and thus removed; see details [deprecated]</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_max_basis">max_basis</code></td>
<td>
<p>maximum number of basis functions. This overrides the parameter <code>nres</code></p>
</td></tr>
<tr><td><code id="auto_basis_+3A_subsamp">subsamp</code></td>
<td>
<p>the maximum amount of data points to consider when carrying out basis-function placement: these data objects are randomly sampled from the full dataset. Keep this number fairly high (on the order of 10^5), otherwise fine-resolution basis functions may be spuriously removed</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_type">type</code></td>
<td>
<p>the type of basis functions to use; see details</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_isea3h_lo">isea3h_lo</code></td>
<td>
<p>if <code>manifold = sphere()</code>, this argument dictates which ISEA3H resolution is the coarsest one that should be used for the first resolution</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_bndary">bndary</code></td>
<td>
<p>a <code>matrix</code> containing points containing the boundary. If <code>regular == 0</code> this can be used to define a boundary in which irregularly-spaced basis functions are placed</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_scale_aperture">scale_aperture</code></td>
<td>
<p>the aperture (in the case of the bisquare, but similar interpretation for other basis) width of the basis function is the minimum distance between all the basis function centroids multiplied by <code>scale_aperture</code>. Typically this ranges between 1 and 1.5 and is defaulted to 1 on the sphere and 1.25 on the other manifolds.</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_verbose">verbose</code></td>
<td>
<p>a logical variable indicating whether to output a summary of the basis functions created or not</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_buffer">buffer</code></td>
<td>
<p>a numeric between 0 and 0.5 indicating the size of the buffer of basis functions along the boundary. The buffer is added by computing the number of basis functions in each dimension, and increasing this number by a factor of <code>buffer</code>. A buffer may be needed when the prior distribution of the basis-function coefficients is formulated in terms of a precision matrix</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_tunit">tunit</code></td>
<td>
<p>temporal unit, required when constructing a spatio-temporal basis. Should be the same as used for the BAUs. Can be &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, &quot;days&quot;, &quot;years&quot;, etc.</p>
</td></tr>
<tr><td><code id="auto_basis_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically places basis functions within the domain of interest. If the domain is a plane or the real line, then the object <code>data</code> is used to establish the domain boundary.
</p>
<p>Let <code class="reqn">\phi(u)</code> denote the value of a basis function evaluated at <code class="reqn">u = s - c</code>, 
where <code class="reqn">s</code> is a spatial coordinate and <code class="reqn">c</code> is the basis-function centroid. 
The argument <code>type</code> can be either &ldquo;Gaussian&rdquo;, in which case  
</p>
<div style="text-align:center"> <i> &phi;(u) = exp(-|u|&sup2;/2&sigma;&sup2;), </i></div>
<p>&ldquo;bisquare&rdquo;, in which case
</p>
<div style="text-align:center"> <i> &phi;(u) = (1 -(|u|/R)&sup2;)&sup2;, </i></div>
<p>&ldquo;exp&rdquo;, in which case
</p>
<div style="text-align:center"> <i> &phi;(u) = exp(-|u|/&tau;), </i></div>
<p>or &ldquo;Matern32&rdquo;, in which case
</p>
<div style="text-align:center"> <i> &phi;(u) = (1 + &radic;3|u|/&kappa;)exp(-&radic;3|u|/&kappa;), </i></div>
<p>where the parameters <code class="reqn">\sigma, R, \tau</code> and <code class="reqn">\kappa</code> are <code>scale</code> arguments.
</p>
<p>If the manifold is the real line, the basis functions are placed regularly inside the domain, and the number of basis functions at the coarsest resolution is dictated by the integer parameter <code>regular</code> which has to be greater than zero. On the real line, each subsequent resolution has twice as many basis functions. The scale of the basis function is set based on the minimum distance between the centre locations following placement. The scale is equal to the minimum distance if the type of basis function is Gaussian, exponential, or Matern32, and is equal to 1.5 times this value if the function is bisquare.
</p>
<p>If the manifold is a plane, and <code>regular &gt; 0</code>, then basis functions are placed regularly within the bounding box of <code>data</code>, with the smallest number of basis functions in each row or column equal to the value of <code>regular</code> in the coarsest resolution (note, this is just the smallest number of basis functions). Subsequent resolutions have twice the number of basis functions in each row or column. If <code>regular = 0</code>, then the function <code>INLA::inla.nonconvex.hull</code> is used to construct a (non-convex) hull around the data. The buffer and smoothness of the hull is determined by the parameter <code>convex</code>. Once the domain boundary is found,  <code>INLA::inla.mesh.2d</code> is used to construct a triangular mesh such that the node vertices coincide with data locations, subject to some minimum and maximum triangular-side-length constraints. The result is a mesh that is dense in regions of high data density and not dense in regions of sparse data. Even basis functions are irregularly placed, the scale is taken to be a function of the minimum distance between basis function centres, as detailed above. This may be changed in a future revision of the package.
</p>
<p>If the manifold is the surface of a sphere, then basis functions are placed on the centroids of the discrete global grid (DGG), with the first basis resolution corresponding to the third resolution of the DGG (ISEA3H resolution 2, which yields 92 basis functions globally).  It is not recommended to go above <code>nres == 3</code> (ISEA3H resolutions 2&ndash;4) for the whole sphere; <code>nres=3</code> yields a total of 1176 basis functions. Up to ISEA3H resolution 6 is available with <code>FRK</code>; for finer resolutions; please install <code>dggrids</code> from <code>https://github.com/andrewzm/dggrids</code> using <code>devtools</code>.
</p>
<p>Basis functions that are not influenced by data points may hinder convergence of the EM algorithm when <code>K_type = "unstructured"</code>, since the associated hidden states are, by and large, unidentifiable. We hence provide a means to automatically remove such basis functions through the parameter <code>prune</code>. The final set only contains basis functions for which the column sums in the associated matrix <code class="reqn">S</code> (which, recall, is the value/average of the basis functions at/over the data points/polygons) is greater than <code>prune</code>. If <code>prune == 0</code>, no basis functions are removed from the original design.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+remove_basis">remove_basis</a></code> for removing basis functions and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sp)
library(ggplot2)

## Create a synthetic dataset
set.seed(1)
d &lt;- data.frame(lon = runif(n=1000,min = -179, max = 179),
                lat = runif(n=1000,min = -90, max = 90),
                z = rnorm(5000))
coordinates(d) &lt;- ~lon + lat
slot(d, "proj4string") = CRS("+proj=longlat +ellps=sphere")

## Now create basis functions over sphere
G &lt;- auto_basis(manifold = sphere(),data=d,
                nres = 2,prune=15,
                type = "bisquare",
                subsamp = 20000)

## Plot
show_basis(G,draw_world())

## End(Not run)
</code></pre>

<hr>
<h2 id='auto_BAUs'>Automatic BAU generation</h2><span id='topic+auto_BAUs'></span>

<h3>Description</h3>

<p>This function calls the generic function <code>auto_BAU</code> (not exported) after a series of checks and is the easiest way to generate a set of Basic Areal Units (BAUs) on the manifold being used; see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_BAUs(
  manifold,
  type = NULL,
  cellsize = NULL,
  isea3h_res = NULL,
  data = NULL,
  nonconvex_hull = TRUE,
  convex = -0.05,
  tunit = NULL,
  xlims = NULL,
  ylims = NULL,
  spatial_BAUs = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_BAUs_+3A_manifold">manifold</code></td>
<td>
<p>object of class <code>manifold</code></p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_type">type</code></td>
<td>
<p>either &ldquo;grid&rdquo; or &ldquo;hex&rdquo;, indicating whether gridded or hexagonal BAUs should be used. If <code>type</code> is unspecified, &ldquo;hex&rdquo; will be used if we are on the sphere, and &ldquo;grid&rdquo; will used otherwise</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_cellsize">cellsize</code></td>
<td>
<p>denotes size of gridcell when <code>type</code> = &ldquo;grid&rdquo;. Needs to be of length 1 (square-grid case) or a vector of length <code>dimensions(manifold)</code> (rectangular-grid case)</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_isea3h_res">isea3h_res</code></td>
<td>
<p>resolution number of the isea3h DGGRID cells for when type is &ldquo;hex&rdquo; and manifold is the surface of a <code>sphere</code></p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_data">data</code></td>
<td>
<p>object of class <code>SpatialPointsDataFrame</code>, <code>SpatialPolygonsDataFrame</code>,  <code>STIDF</code>, or <code>STFDF</code>. Provision of <code>data</code> implies that the domain is bounded, and is thus necessary when the manifold is a <code>real_line, plane</code>, or <code>STplane</code>, but is not necessary when the manifold is the surface of a <code>sphere</code></p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_nonconvex_hull">nonconvex_hull</code></td>
<td>
<p>flag indicating whether to use <code>INLA</code> to generate a non-convex hull. Otherwise a convex hull is used</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_convex">convex</code></td>
<td>
<p>convex parameter used for smoothing an extended boundary when working on a bounded domain (that is, when the object <code>data</code> is supplied); see details</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_tunit">tunit</code></td>
<td>
<p>temporal unit when requiring space-time BAUs. Can be &quot;secs&quot;, &quot;mins&quot;, &quot;hours&quot;, etc.</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_xlims">xlims</code></td>
<td>
<p>limits of the horizontal axis (overrides automatic selection)</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_ylims">ylims</code></td>
<td>
<p>limits of the vertical axis (overrides automatic selection)</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_spatial_baus">spatial_BAUs</code></td>
<td>
<p>object of class <code>SpatialPolygonsDataFrame</code> or <code>SpatialPixelsDataFrame</code> representing the spatial BAUs to be used in a spatio-temporal setting (if left <code>NULL</code>, the spatial BAUs are constructed automatically using the data)</p>
</td></tr>
<tr><td><code id="auto_BAUs_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>auto_BAUs</code> constructs a set of Basic Areal Units (BAUs) used both for data pre-processing and for prediction. As such, the BAUs need to be of sufficienly fine resolution so that inferences are not affected due to binning.
</p>
<p>Two types of BAUs are supported by <code>FRK</code>: &ldquo;hex&rdquo; (hexagonal) and &ldquo;grid&rdquo; (rectangular). In order to have a &ldquo;grid&rdquo; set of BAUs, the user should specify a cellsize of length one, or of length equal to the dimensions of the manifold, that is, of length 1 for <code>real_line</code> and of length 2 for the surface of a <code>sphere</code> and <code>plane</code>. When a &ldquo;hex&rdquo; set of BAUs is desired, the first element of <code>cellsize</code> is used to determine the side length by dividing this value by approximately 2. The argument <code>type</code> is ignored with <code>real_line</code> and &ldquo;hex&rdquo; is not available for this manifold.
</p>
<p>If the object <code>data</code> is provided, then automatic domain selection may be carried out by employing the <code>INLA</code> function <code>inla.nonconvex.hull</code>, which finds a (non-convex) hull surrounding the data points (or centroids of the data polygons). This domain is extended and smoothed using the parameter <code>convex</code>. The parameter <code>convex</code> should be negative, and a larger absolute value for <code>convex</code> results in a larger domain with smoother boundaries (note that <code>INLA</code> was not available on CRAN at the time of writing).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First a 1D example
library(sp)
set.seed(1)
data &lt;- data.frame(x = runif(10)*10, y = 0, z= runif(10)*10)
coordinates(data) &lt;- ~x+y
Grid1D_df &lt;- auto_BAUs(manifold = real_line(),
                       cellsize = 1,
                       data=data)
## Not run: spplot(Grid1D_df)

## Now a 2D example
data(meuse)
coordinates(meuse) = ~x+y # change into an sp object

## Grid BAUs
GridPols_df &lt;- auto_BAUs(manifold = plane(),
                         cellsize = 200,
                         type = "grid",
                         data = meuse,
                         nonconvex_hull = 0)
## Not run: plot(GridPols_df)

## Hex BAUs
HexPols_df &lt;- auto_BAUs(manifold = plane(),
                        cellsize = 200,
                        type = "hex",
                        data = meuse,
                        nonconvex_hull = 0)
## Not run: plot(HexPols_df)
</code></pre>

<hr>
<h2 id='Basis'>Generic basis-function constructor</h2><span id='topic+Basis'></span>

<h3>Description</h3>

<p>This function is meant to be used for manual construction of arbitrary basis functions. For
&lsquo;local&rsquo; basis functions, please use the function <code><a href="#topic+local_basis">local_basis</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Basis(manifold, n, fn, pars, df, regular = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Basis_+3A_manifold">manifold</code></td>
<td>
<p>object of class <code>manifold</code>, for example, <code>sphere</code></p>
</td></tr>
<tr><td><code id="Basis_+3A_n">n</code></td>
<td>
<p>number of basis functions (should be an integer)</p>
</td></tr>
<tr><td><code id="Basis_+3A_fn">fn</code></td>
<td>
<p>a list of functions, one for each basis function. Each function should be encapsulated within an environment
in which the manifold and any other parameters required to evaluate the function are defined. The
function itself takes a single input <code>s</code> which can be of class <code>numeric</code>, <code>matrix</code>, or <code>Matrix</code>,
and returns a vector which contains the basis function evaluations at <code>s</code>.</p>
</td></tr>
<tr><td><code id="Basis_+3A_pars">pars</code></td>
<td>
<p>A list containing a list of parameters for each function. For local basis functions these would correspond
to location and scale parameters.</p>
</td></tr>
<tr><td><code id="Basis_+3A_df">df</code></td>
<td>
<p>A data frame containing one row per basis function, typically for providing informative summaries.</p>
</td></tr>
<tr><td><code id="Basis_+3A_regular">regular</code></td>
<td>
<p>logical indicating if the basis functions (of each resolution) are in a regular grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This constructor checks that all parameters are valid before constructing the basis functions. 
The requirement that every function is encapsulated is tedious, but necessary for
FRK to work with a large range of basis functions in the future. Please see the example below which exemplifies
the process of constructing linear basis functions from scratch using this function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for constructing basis functions automatically, <code><a href="#topic+local_basis">local_basis</a></code> for
constructing &lsquo;local&rsquo; basis functions, and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct two linear basis functions on [0, 1]
manifold &lt;- real_line()
n &lt;- 2
lin_basis_fn &lt;- function(manifold, grad, intercept) {
   function(s) grad*s + intercept
}
pars &lt;- list(list(grad = 1, intercept = 0),
             list(grad = -1, intercept = 1))
fn &lt;- list(lin_basis_fn(manifold, 1, 0),
           lin_basis_fn(manifold, -1, 1))
df &lt;- data.frame(n = 1:2, grad = c(1, -1), m = c(1, -1))
G &lt;- Basis(manifold = manifold, n = n, fn = fn, pars = pars, df = df)
## Not run: 
eval_basis(G, s = matrix(seq(0,1, by = 0.1), 11, 1))
## End(Not run)
</code></pre>

<hr>
<h2 id='Basis_obj-class'>Basis functions</h2><span id='topic+Basis_obj-class'></span><span id='topic+Basis-class'></span><span id='topic+TensorP_Basis-class'></span>

<h3>Description</h3>

<p>An object of class <code>Basis</code> contains the basis functions used to construct the matrix <code class="reqn">S</code> in FRK.
</p>


<h3>Details</h3>

<p>Basis functions are a central component of <code>FRK</code>, and the package is designed to work with user-defined specifications of these. For convenience, however, several functions are available to aid the user to construct a basis set for a given set of data points. Please see <code><a href="#topic+auto_basis">auto_basis</a></code> for more details. The function <code><a href="#topic+local_basis">local_basis</a></code> helps the user construct a set of local basis functions (e.g., bisquare functions) from a collection of location and scale parameters.
</p>


<h3>Slots</h3>


<dl>
<dt><code>manifold</code></dt><dd><p>an object of class <code>manifold</code> that contains information on the manifold and the distance measure used on the manifold. See <code><a href="#topic+manifold-class">manifold-class</a></code> for more details</p>
</dd>
<dt><code>n</code></dt><dd><p>the number of basis functions in this set</p>
</dd>
<dt><code>fn</code></dt><dd><p>a list of length <code>n</code>, with each item the function of a specific basis function</p>
</dd>
<dt><code>pars</code></dt><dd><p>a list of parameters where the <code class="reqn">i</code>-th item in the list contains the parameters of the <code class="reqn">i</code>-th basis function, <code>fn[[i]]</code></p>
</dd>
<dt><code>df</code></dt><dd><p>a data frame containing other attributes specific to each basis function (for example the geometric centre of the local basis function)</p>
</dd>
<dt><code>regular</code></dt><dd><p>logical indicating if the basis functions (of each resolution) are in a regular grid</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions.
</p>

<hr>
<h2 id='BAUs_from_points'>Creates pixels around points</h2><span id='topic+BAUs_from_points'></span><span id='topic+BAUs_from_points+2CSpatialPoints-method'></span><span id='topic+BAUs_from_points+2CST-method'></span>

<h3>Description</h3>

<p>Takes a SpatialPointsDataFrame and converts it into SpatialPolygonsDataFrame by constructing a tiny (within machine tolerance) BAU around each SpatialPoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BAUs_from_points(obj, offset = 1e-10)

## S4 method for signature 'SpatialPoints'
BAUs_from_points(obj, offset = 1e-10)

## S4 method for signature 'ST'
BAUs_from_points(obj, offset = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BAUs_from_points_+3A_obj">obj</code></td>
<td>
<p>object of class <code>SpatialPointsDataFrame</code></p>
</td></tr>
<tr><td><code id="BAUs_from_points_+3A_offset">offset</code></td>
<td>
<p>edge size of the mini-BAU (default 1e-10)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows users to mimic standard geospatial analysis where BAUs are not used. Since <code>FRK</code> is built on the concept of a BAU, this function constructs tiny BAUs around the observation and prediction locations that can be subsequently passed on to the functions <code>SRE</code> and <code>FRK</code>. With <code>BAUs_from_points</code>, the user supplies both the data and prediction locations accompanied with covariates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auto_BAUs">auto_BAUs</a></code> for automatically constructing generic BAUs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
opts_FRK$set("parallel",0L)
df &lt;- data.frame(x = rnorm(10),
                 y = rnorm(10))
coordinates(df) &lt;- ~x+y
BAUs &lt;- BAUs_from_points(df)
</code></pre>

<hr>
<h2 id='coef_uncertainty'>Uncertainty quantification of the fixed effects</h2><span id='topic+coef_uncertainty'></span>

<h3>Description</h3>

<p>Compute confidence intervals for the fixed effects (upper  
and lower bound specifed by percentiles; default 90% confidence central interval)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_uncertainty(
  object,
  percentiles = c(5, 95),
  nsim = 400,
  random_effects = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_uncertainty_+3A_object">object</code></td>
<td>
<p>object of class <code>SRE</code> returned from the constructor <code>SRE()</code> containing all the parameters and information on the SRE model</p>
</td></tr>
<tr><td><code id="coef_uncertainty_+3A_percentiles">percentiles</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;TMB&quot;) a vector of scalars in (0, 100) specifying the desired percentiles of the posterior predictive distribution; if <code>NULL</code>, no percentiles are computed</p>
</td></tr>
<tr><td><code id="coef_uncertainty_+3A_nsim">nsim</code></td>
<td>
<p>number of Monte Carlo samples used to compute the confidence intervals</p>
</td></tr>
<tr><td><code id="coef_uncertainty_+3A_random_effects">random_effects</code></td>
<td>
<p>logical; if set to true, confidence intervals will also be provided for the random effects random effects <i> <b>&gamma;</b></i> (see '?SRE' for details on these random effects)</p>
</td></tr>
</table>

<hr>
<h2 id='combine_basis'>Combine basis functions</h2><span id='topic+combine_basis'></span><span id='topic+combine_basis+2Clist-method'></span><span id='topic+combine_basis+2CBasis-method'></span>

<h3>Description</h3>

<p>Takes a list of objects of class <code>Basis</code> and returns a 
single object of class <code>Basis</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_basis(Basis_list)

## S4 method for signature 'list'
combine_basis(Basis_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_basis_+3A_basis_list">Basis_list</code></td>
<td>
<p>a list of objects of class <code>Basis</code>. Each element of the list is assumed to 
represent a single resolution of basis functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Construct two resolutions of basis functions using local_basis() 
Basis1 &lt;- local_basis(manifold = real_line(), 
                     loc = matrix(seq(0, 1, length.out = 3), ncol = 1), 
                     scale = rep(0.4, 3))

Basis2 &lt;- local_basis(manifold = real_line(), 
                     loc = matrix(seq(0, 1, length.out = 6), ncol = 1), 
                     scale = rep(0.2, 6))

## Combine basis-function resolutions into a single Basis object
combine_basis(list(Basis1, Basis2)) 
</code></pre>

<hr>
<h2 id='data.frame+26lt+3B-'>Basis-function data frame object</h2><span id='topic+data.frame+3C-'></span><span id='topic++24+2CBasis-method'></span><span id='topic++24+3C-+2CBasis-method'></span><span id='topic+data.frame+3C-+2CBasis-method'></span><span id='topic+data.frame_Basis+2CBasis-method'></span><span id='topic+data.frame+3C-+2CTensorP_Basis-method'></span><span id='topic+as.data.frame.Basis'></span><span id='topic+as.data.frame.TensorP_Basis'></span>

<h3>Description</h3>

<p>Tools for retrieving and manipulating the data frame within Basis objects. Use the assignment <code>data.frame()&lt;-</code> with care; no checks are made to ensure the data frame conforms with the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.frame(x) &lt;- value

## S4 method for signature 'Basis'
x$name

## S4 replacement method for signature 'Basis'
x$name &lt;- value

## S4 replacement method for signature 'Basis'
data.frame(x) &lt;- value

## S4 replacement method for signature 'TensorP_Basis'
data.frame(x) &lt;- value

## S3 method for class 'Basis'
as.data.frame(x, ...)

## S3 method for class 'TensorP_Basis'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.frame+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>the obect of class <code>Basis</code> we are assigning the new data to or retrieving data from</p>
</td></tr>
<tr><td><code id="data.frame+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the new data being assigned to the Basis object</p>
</td></tr>
<tr><td><code id="data.frame+2B26lt+2B3B-_+3A_name">name</code></td>
<td>
<p>the field name to which values will be retrieved or assigned inside the Basis object's data frame</p>
</td></tr>
<tr><td><code id="data.frame+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;- local_basis()
df &lt;- data.frame(G)
print(df$res)
df$res &lt;- 2
data.frame(G) &lt;- df
</code></pre>

<hr>
<h2 id='df_to_SpatialPolygons'>Convert data frame to SpatialPolygons</h2><span id='topic+df_to_SpatialPolygons'></span>

<h3>Description</h3>

<p>Convert data frame to SpatialPolygons object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_SpatialPolygons(df, keys, coords, proj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_to_SpatialPolygons_+3A_df">df</code></td>
<td>
<p>data frame containing polygon information, see details</p>
</td></tr>
<tr><td><code id="df_to_SpatialPolygons_+3A_keys">keys</code></td>
<td>
<p>vector of variable names used to group rows belonging to the same polygon</p>
</td></tr>
<tr><td><code id="df_to_SpatialPolygons_+3A_coords">coords</code></td>
<td>
<p>vector of variable names identifying the coordinate columns</p>
</td></tr>
<tr><td><code id="df_to_SpatialPolygons_+3A_proj">proj</code></td>
<td>
<p>the projection of the <code>SpatialPolygons</code> object. Needs to be of class <code>CRS</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row in the data frame <code>df</code> contains both coordinates and labels (or keys) that identify to which polygon the coordinates belong. This function groups the data frame according to <code>keys</code> and forms a <code>SpatialPolygons</code> object from the coordinates in each group. It is important that all rings are closed, that is, that the last row of each group is identical to the first row. Since <code>keys</code> can be of length greater than one, we identify each polygon with a new key by forming an MD5 hash made out of the respective <code>keys</code> variables that in themselves are unique (and therefore the hashed key is also unique). For lon-lat coordinates use <code>proj = CRS("+proj=longlat +ellps=sphere")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
df &lt;- data.frame(id = c(rep(1,4),rep(2,4)),
                 x = c(0,1,0,0,2,3,2,2),
                 y=c(0,0,1,0,0,1,1,0))
pols &lt;- df_to_SpatialPolygons(df,"id",c("x","y"),CRS())
## Not run: plot(pols)
</code></pre>

<hr>
<h2 id='dist-matrix'>Distance Matrix Computation from Two Matrices</h2><span id='topic+dist-matrix'></span><span id='topic+distR'></span>

<h3>Description</h3>

<p>This function extends <code>dist</code> to accept two arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distR(x1, x2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist-matrix_+3A_x1">x1</code></td>
<td>
<p>matrix of size N1 x n</p>
</td></tr>
<tr><td><code id="dist-matrix_+3A_x2">x2</code></td>
<td>
<p>matrix of size N2 x n</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the distances between the coordinates in <code>x1</code> and the coordinates in <code>x2</code>. The matrices <code>x1</code> and <code>x2</code> do not need to have the same number of rows, but need to have the same number of columns (e.g., manifold dimensions).
</p>


<h3>Value</h3>

<p>Matrix of size N1 x N2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(50),5,10)
D &lt;- distR(A,A[-3,])
</code></pre>

<hr>
<h2 id='distance'>Compute distance</h2><span id='topic+distance'></span><span id='topic+distance+2Cmeasure-method'></span><span id='topic+distance+2Cmanifold-method'></span>

<h3>Description</h3>

<p>Compute distance using object of class <code>measure</code> or <code>manifold</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(d, x1, x2 = NULL)

## S4 method for signature 'measure'
distance(d, x1, x2 = NULL)

## S4 method for signature 'manifold'
distance(d, x1, x2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_d">d</code></td>
<td>
<p>object of class <code>measure</code> or <code>manifold</code></p>
</td></tr>
<tr><td><code id="distance_+3A_x1">x1</code></td>
<td>
<p>first coordinate</p>
</td></tr>
<tr><td><code id="distance_+3A_x2">x2</code></td>
<td>
<p>second coordinate</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+real_line">real_line</a></code>, <code><a href="#topic+plane">plane</a></code>, <code><a href="#topic+sphere">sphere</a></code>, <code><a href="#topic+STplane">STplane</a></code> and <code><a href="#topic+STsphere">STsphere</a></code> for constructing manifolds, and <code><a href="#topic+distances">distances</a></code> for the type of distances available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>distance(sphere(),matrix(0,1,2),matrix(10,1,2))
distance(plane(),matrix(0,1,2),matrix(10,1,2))
</code></pre>

<hr>
<h2 id='distances'>Pre-configured distances</h2><span id='topic+distances'></span><span id='topic+measure'></span><span id='topic+Euclid_dist'></span><span id='topic+gc_dist'></span><span id='topic+gc_dist_time'></span>

<h3>Description</h3>

<p>Useful objects of class <code>distance</code> included in package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measure(dist, dim)

Euclid_dist(dim = 2L)

gc_dist(R = NULL)

gc_dist_time(R = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distances_+3A_dist">dist</code></td>
<td>
<p>a function taking two arguments <code>x1,x2</code></p>
</td></tr>
<tr><td><code id="distances_+3A_dim">dim</code></td>
<td>
<p>the dimension of the manifold (e.g., 2 for a plane)</p>
</td></tr>
<tr><td><code id="distances_+3A_r">R</code></td>
<td>
<p>great-circle radius</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initialises an object of class <code>measure</code> which contains a function <code>dist</code> used for computing the distance between two points.  Currently the Euclidean distance and the great-circle distance are included with <code>FRK</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- measure(distR,2)
D &lt;- distance(M1,matrix(rnorm(10),5,2))
</code></pre>

<hr>
<h2 id='draw_world'>Draw a map of the world with country boundaries.</h2><span id='topic+draw_world'></span>

<h3>Description</h3>

<p>Layers a <code>ggplot2</code> map of the world over the current <code>ggplot2</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_world(g = ggplot() + theme_bw() + xlab("") + ylab(""), inc_border = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_world_+3A_g">g</code></td>
<td>
<p>initial ggplot object</p>
</td></tr>
<tr><td><code id="draw_world_+3A_inc_border">inc_border</code></td>
<td>
<p>flag indicating whether a map border should be drawn or not; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>ggplot2::map_data()</code> in order to create a world map. Since, by default, this creates lines crossing the world at the (-180,180) longitude boundary, the function <code>.homogenise_maps()</code> is used to split the polygons at this boundary into two. If <code>inc_border</code> is TRUE, then a border is drawn around the lon-lat space; this option is most useful for projections that do not yield rectangular plots (e.g., the sinusoidal global projection).
</p>


<h3>See Also</h3>

<p>the help file for the dataset <code><a href="#topic+worldmap">worldmap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(ggplot2)
draw_world(g = ggplot())
## End(Not run)
</code></pre>

<hr>
<h2 id='eval_basis'>Evaluate basis functions</h2><span id='topic+eval_basis'></span><span id='topic+eval_basis+2CBasis+2Cmatrix-method'></span><span id='topic+eval_basis+2CBasis-matrix-method'></span><span id='topic+eval_basis+2CBasis+2CSpatialPointsDataFrame-method'></span><span id='topic+eval_basis+2CBasis-SpatialPointsDataFrame-method'></span><span id='topic+eval_basis+2CBasis+2CSpatialPolygonsDataFrame-method'></span><span id='topic+eval_basis+2CBasis-SpatialPolygonsDataFrame-method'></span><span id='topic+eval_basis+2CBasis+2CSTIDF-method'></span><span id='topic+eval_basis+2CBasis-STIDF-method'></span><span id='topic+eval_basis+2CTensorP_Basis+2Cmatrix-method'></span><span id='topic+eval_basis+2CTensorP_Basis-matrix-method'></span><span id='topic+eval_basis+2CTensorP_Basis+2CSTIDF-method'></span><span id='topic+eval_basis+2CTensorP_Basis-STIDF-method'></span><span id='topic+eval_basis+2CTensorP_Basis+2CSTFDF-method'></span><span id='topic+eval_basis+2CTensorP_Basis-STFDF-method'></span>

<h3>Description</h3>

<p>Evaluate basis functions at points or average functions over polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_basis(basis, s)

## S4 method for signature 'Basis,matrix'
eval_basis(basis, s)

## S4 method for signature 'Basis,SpatialPointsDataFrame'
eval_basis(basis, s)

## S4 method for signature 'Basis,SpatialPolygonsDataFrame'
eval_basis(basis, s)

## S4 method for signature 'Basis,STIDF'
eval_basis(basis, s)

## S4 method for signature 'TensorP_Basis,matrix'
eval_basis(basis, s)

## S4 method for signature 'TensorP_Basis,STIDF'
eval_basis(basis, s)

## S4 method for signature 'TensorP_Basis,STFDF'
eval_basis(basis, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_basis_+3A_basis">basis</code></td>
<td>
<p>object of class <code>Basis</code></p>
</td></tr>
<tr><td><code id="eval_basis_+3A_s">s</code></td>
<td>
<p>object of class <code>matrix</code>, <code>SpatialPointsDataFrame</code> or <code>SpatialPolygonsDataFrame</code> containing the spatial locations/footprints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates the basis functions at isolated points, or averages
the basis functions over polygons, for computing the matrix <code class="reqn">S</code>. The latter
operation is carried out using Monte Carlo integration with 1000 samples per polygon. When
using space-time basis functions, the object must contain a field <code>t</code> containing a numeric
representation of the time, for example, containing the number of seconds, hours, or days since the first
data point.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)

### Create a synthetic dataset
set.seed(1)
d &lt;- data.frame(lon = runif(n=500,min = -179, max = 179),
                lat = runif(n=500,min = -90, max = 90),
                z = rnorm(500))
coordinates(d) &lt;- ~lon + lat
slot(d, "proj4string") = CRS("+proj=longlat")

### Now create basis functions on sphere
G &lt;- auto_basis(manifold = sphere(),data=d,
                nres = 2,prune=15,
                type = "bisquare",
                subsamp = 20000)

### Now evaluate basis functions at origin
S &lt;- eval_basis(G,matrix(c(0,0),1,2))
</code></pre>

<hr>
<h2 id='FRK'>Construct SRE object, fit and predict</h2><span id='topic+FRK'></span><span id='topic+SRE'></span><span id='topic+SRE.fit'></span><span id='topic+predict+2CSRE-method'></span><span id='topic+logLik+2CSRE-method'></span><span id='topic+nobs+2CSRE-method'></span><span id='topic+coef+2CSRE-method'></span><span id='topic+coef_uncertainty+2CSRE-method'></span><span id='topic+simulate'></span><span id='topic+fitted+2CSRE-method'></span><span id='topic+residuals+2CSRE-method'></span><span id='topic+AIC+2CSRE-method'></span><span id='topic+BIC+2CSRE-method'></span>

<h3>Description</h3>

<p>The Spatial Random Effects (SRE) model is the central object in <span class="pkg">FRK</span>. The function <code>FRK()</code> provides a wrapper for the construction and estimation of the SRE object from data, using the functions <code>SRE()</code> (the object constructor) and <code>SRE.fit()</code> (for fitting it to the data). Please see <code><a href="#topic+SRE-class">SRE-class</a></code> for more details on the SRE object's properties and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FRK(
  f,
  data,
  basis = NULL,
  BAUs = NULL,
  est_error = TRUE,
  average_in_BAU = TRUE,
  sum_variables = NULL,
  normalise_wts = TRUE,
  fs_model = "ind",
  vgm_model = NULL,
  K_type = c("block-exponential", "precision", "unstructured"),
  n_EM = 100,
  tol = 0.01,
  method = c("EM", "TMB"),
  lambda = 0,
  print_lik = FALSE,
  response = c("gaussian", "poisson", "gamma", "inverse-gaussian", "negative-binomial",
    "binomial"),
  link = c("identity", "log", "sqrt", "logit", "probit", "cloglog", "inverse",
    "inverse-squared"),
  optimiser = nlminb,
  fs_by_spatial_BAU = FALSE,
  known_sigma2fs = NULL,
  taper = NULL,
  simple_kriging_fixed = FALSE,
  ...
)

SRE(
  f,
  data,
  basis,
  BAUs,
  est_error = TRUE,
  average_in_BAU = TRUE,
  sum_variables = NULL,
  normalise_wts = TRUE,
  fs_model = "ind",
  vgm_model = NULL,
  K_type = c("block-exponential", "precision", "unstructured"),
  normalise_basis = TRUE,
  response = c("gaussian", "poisson", "gamma", "inverse-gaussian", "negative-binomial",
    "binomial"),
  link = c("identity", "log", "sqrt", "logit", "probit", "cloglog", "inverse",
    "inverse-squared"),
  include_fs = TRUE,
  fs_by_spatial_BAU = FALSE,
  ...
)

SRE.fit(
  object,
  n_EM = 100L,
  tol = 0.01,
  method = c("EM", "TMB"),
  lambda = 0,
  print_lik = FALSE,
  optimiser = nlminb,
  known_sigma2fs = NULL,
  taper = NULL,
  simple_kriging_fixed = FALSE,
  ...
)

## S4 method for signature 'SRE'
predict(
  object,
  newdata = NULL,
  obs_fs = FALSE,
  pred_time = NULL,
  covariances = FALSE,
  nsim = 400,
  type = "mean",
  k = NULL,
  percentiles = c(5, 95),
  kriging = "simple"
)

## S4 method for signature 'SRE'
logLik(object)

## S4 method for signature 'SRE'
nobs(object, ...)

## S4 method for signature 'SRE'
coef(object, ...)

## S4 method for signature 'SRE'
coef_uncertainty(
  object,
  percentiles = c(5, 95),
  nsim = 400,
  random_effects = FALSE
)

simulate(object, newdata = NULL, nsim = 400, conditional_fs = FALSE, ...)

## S4 method for signature 'SRE'
fitted(object, ...)

## S4 method for signature 'SRE'
residuals(object, type = "pearson")

## S4 method for signature 'SRE'
AIC(object, k = 2)

## S4 method for signature 'SRE'
BIC(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FRK_+3A_f">f</code></td>
<td>
<p><code>R</code> formula relating the dependent variable (or transformations thereof) to covariates</p>
</td></tr>
<tr><td><code id="FRK_+3A_data">data</code></td>
<td>
<p>list of objects of class <code>SpatialPointsDataFrame</code>, <code>SpatialPolygonsDataFrame</code>, <code>STIDF</code>, or  <code>STFDF</code>. If using space-time objects, the data frame must have another field, <code>t</code>, containing the time index of the data point</p>
</td></tr>
<tr><td><code id="FRK_+3A_basis">basis</code></td>
<td>
<p>object of class <code>Basis</code> (or <code>TensorP_Basis</code>)</p>
</td></tr>
<tr><td><code id="FRK_+3A_baus">BAUs</code></td>
<td>
<p>object of class <code>SpatialPolygonsDataFrame</code>, <code>SpatialPixelsDataFrame</code>, <code>STIDF</code>, or <code>STFDF</code>. The object's data frame must contain covariate information as well as a field <code>fs</code> describing the fine-scale variation up to a constant of proportionality. If the function <code>FRK()</code> is used directly, then BAUs are created automatically, but only coordinates can then be used as covariates</p>
</td></tr>
<tr><td><code id="FRK_+3A_est_error">est_error</code></td>
<td>
<p>(applicable only if <code>response</code> = &quot;gaussian&quot;) flag indicating whether the measurement-error variance should be estimated from variogram techniques. If this is set to 0, then <code>data</code> must contain a field <code>std</code>. Measurement-error estimation is currently not implemented for spatio-temporal datasets</p>
</td></tr>
<tr><td><code id="FRK_+3A_average_in_bau">average_in_BAU</code></td>
<td>
<p>if <code>TRUE</code>, then multiple data points falling in the same BAU are averaged; the measurement error of the averaged data point is taken as the average of the individual measurement errors</p>
</td></tr>
<tr><td><code id="FRK_+3A_sum_variables">sum_variables</code></td>
<td>
<p>if <code>average_in_BAU == TRUE</code>, the string <code>sum_variables</code> indicates which data variables (can be observations or covariates) are to be summed rather than averaged</p>
</td></tr>
<tr><td><code id="FRK_+3A_normalise_wts">normalise_wts</code></td>
<td>
<p>if <code>TRUE</code>, the rows of the incidence matrices <i><b>C</b><sub>Z</sub></i> and <i><b>C</b><sub>P</sub></i> are normalised to sum to 1, so that the mapping represents a weighted average; if false, no normalisation of the weights occurs (i.e., the mapping corresponds to a weighted sum)</p>
</td></tr>
<tr><td><code id="FRK_+3A_fs_model">fs_model</code></td>
<td>
<p>if &quot;ind&quot; then the fine-scale variation is independent at the BAU level. Only the independent model is allowed for now, future implementation will include CAR/ICAR (in development)</p>
</td></tr>
<tr><td><code id="FRK_+3A_vgm_model">vgm_model</code></td>
<td>
<p>(applicable only if <code>response</code> = &quot;gaussian&quot;) an object of class <code>variogramModel</code> from the package <code>gstat</code> constructed using the function <code>vgm</code>. This object contains the variogram model that will be fit to the data. The nugget is taken as the measurement error when <code>est_error = TRUE</code>. If unspecified, the variogram used is <code>gstat::vgm(1, "Lin", d, 1)</code>, where <code>d</code> is approximately one third of the maximum distance between any two data points</p>
</td></tr>
<tr><td><code id="FRK_+3A_k_type">K_type</code></td>
<td>
<p>the parameterisation used for the basis-function covariance matrix, <code>K</code>. If <code>method</code> = &quot;EM&quot;, <code>K_type</code> can be &quot;unstructured&quot; or &quot;block-exponential&quot;. If <code>method</code> = &quot;TMB&quot;, <code>K_type</code> can be &quot;precision&quot; or &quot;block-exponential&quot;. The default is &quot;block-exponential&quot;, however if <code>FRK()</code> is used and <code>method</code> = &quot;TMB&quot;, for computational reasons <code>K_type</code> is set to &quot;precision&quot;</p>
</td></tr>
<tr><td><code id="FRK_+3A_n_em">n_EM</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;EM&quot;) maximum number of iterations for the EM algorithm</p>
</td></tr>
<tr><td><code id="FRK_+3A_tol">tol</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;EM&quot;) convergence tolerance for the EM algorithm</p>
</td></tr>
<tr><td><code id="FRK_+3A_method">method</code></td>
<td>
<p>parameter estimation method to employ. Currently &quot;EM&quot; and &quot;TMB&quot; are supported</p>
</td></tr>
<tr><td><code id="FRK_+3A_lambda">lambda</code></td>
<td>
<p>(applicable only if <code>K_type</code> = &quot;unstructured&quot;) ridge-regression regularisation parameter (0 by default). Can be a single number, or a vector (one parameter for each resolution)</p>
</td></tr>
<tr><td><code id="FRK_+3A_print_lik">print_lik</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;EM&quot;) flag indicating whether to plot log-likelihood vs. iteration after convergence of the EM estimation algorithm</p>
</td></tr>
<tr><td><code id="FRK_+3A_response">response</code></td>
<td>
<p>string indicating the assumed distribution of the response variable. It can be &quot;gaussian&quot;, &quot;poisson&quot;, &quot;negative-binomial&quot;, &quot;binomial&quot;, &quot;gamma&quot;, or &quot;inverse-gaussian&quot;. If <code>method</code> = &quot;EM&quot;, only &quot;gaussian&quot; can be used. Two distributions considered in this framework, namely the binomial distribution and the negative-binomial distribution, have an assumed-known ‘size’ parameter and a ‘probability of success’ parameter; see the details below for the exact parameterisations used, and how to provide these ‘size’ parameters</p>
</td></tr>
<tr><td><code id="FRK_+3A_link">link</code></td>
<td>
<p>string indicating the desired link function. Can be &quot;log&quot;, &quot;identity&quot;, &quot;logit&quot;, &quot;probit&quot;, &quot;cloglog&quot;, &quot;reciprocal&quot;, or &quot;reciprocal-squared&quot;. Note that only sensible link-function and response-distribution combinations are permitted. If <code>method</code> = &quot;EM&quot;, only &quot;identity&quot; can be used</p>
</td></tr>
<tr><td><code id="FRK_+3A_optimiser">optimiser</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;TMB&quot;) the optimising function used for model fitting when <code>method</code> = &quot;TMB&quot; (default is <code>nlminb</code>). Users may pass in a function object or a string corresponding to a named function. Optional parameters may be passed to <code>optimiser</code> via <code>...</code>. The only requirement of <code>optimiser</code> is that the first three arguments correspond to the initial parameters, the objective function, and the gradient, respectively (this may be achieved by simply constructing a wrapper function)</p>
</td></tr>
<tr><td><code id="FRK_+3A_fs_by_spatial_bau">fs_by_spatial_BAU</code></td>
<td>
<p>(applicable only in a spatio-temporal setting and if <code>method</code> = &quot;TMB&quot;) if <code>TRUE</code>, then each spatial BAU is associated with its own fine-scale variance parameter; otherwise, a single fine-scale variance parameter is used</p>
</td></tr>
<tr><td><code id="FRK_+3A_known_sigma2fs">known_sigma2fs</code></td>
<td>
<p>known value of the fine-scale variance parameter. If <code>NULL</code> (the default), the fine-scale variance parameter is estimated as usual. If <code>known_sigma2fs</code> is not <code>NULL</code>, the fine-scale variance is fixed to the supplied value; this may be a scalar, or vector of length equal to the number of spatial BAUs (if <code>fs_by_spatial_BAU = TRUE</code>)</p>
</td></tr>
<tr><td><code id="FRK_+3A_taper">taper</code></td>
<td>
<p>positive numeric indicating the strength of the covariance/partial-correlation tapering. Only applicable if <code>K_type</code> = &quot;block-exponential&quot;, or if <code>K_type</code> = &quot;precision&quot; and the the basis-functions are irregular or the manifold is not the plane. If <code>taper</code> is <code>NULL</code> (default) and <code>method</code> = &quot;EM&quot;, no tapering is applied; if <code>method</code> = &quot;TMB&quot;, tapering must be applied (for computational reasons), and we set it to 3 if it is unspecified</p>
</td></tr>
<tr><td><code id="FRK_+3A_simple_kriging_fixed">simple_kriging_fixed</code></td>
<td>
<p>commit to simple kriging at the fitting stage? If <code>TRUE</code>, model fitting is faster, but the option to conduct universal kriging at the prediction stage is removed</p>
</td></tr>
<tr><td><code id="FRK_+3A_...">...</code></td>
<td>
<p>other parameters passed on to <code>auto_basis()</code> and <code>auto_BAUs()</code> when calling <code>FRK()</code>, or the user specified function <code>optimiser()</code> when calling <code>FRK()</code> or <code>SRE.fit()</code></p>
</td></tr>
<tr><td><code id="FRK_+3A_normalise_basis">normalise_basis</code></td>
<td>
<p>flag indicating whether to normalise the basis functions so that they reproduce a stochastic process with approximately constant variance spatially</p>
</td></tr>
<tr><td><code id="FRK_+3A_include_fs">include_fs</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;TMB&quot;) flag indicating whether the fine-scale variation should be included in the model</p>
</td></tr>
<tr><td><code id="FRK_+3A_object">object</code></td>
<td>
<p>object of class <code>SRE</code> returned from the constructor <code>SRE()</code> containing all the parameters and information on the SRE model</p>
</td></tr>
<tr><td><code id="FRK_+3A_newdata">newdata</code></td>
<td>
<p>object of class <code>SpatialPoylgons</code>, <code>SpatialPoints</code>, or <code>STI</code>, indicating the regions or points over which prediction will be carried out. The BAUs are used if this option is not specified.</p>
</td></tr>
<tr><td><code id="FRK_+3A_obs_fs">obs_fs</code></td>
<td>
<p>flag indicating whether the fine-scale variation sits in the observation model (systematic error; indicated by <code>obs_fs = TRUE</code>) or in the process model (process fine-scale variation; indicated by <code>obs_fs = FALSE</code>, default). For non-Gaussian data models, and/or non-identity link functions, if <code>obs_fs = TRUE</code>, then the fine-scale variation is removed from the latent process <code class="reqn">Y</code>; however, they are re-introduced for prediction of the conditonal mean <i> <b> &mu; </b></i> and simulated data <i> <b>Z</b><sup>*</sup> </i></p>
</td></tr>
<tr><td><code id="FRK_+3A_pred_time">pred_time</code></td>
<td>
<p>vector of time indices at which prediction will be carried out. All time points are used if this option is not specified</p>
</td></tr>
<tr><td><code id="FRK_+3A_covariances">covariances</code></td>
<td>
<p>(applicable only for <code>method</code> = &quot;EM&quot;) logical variable indicating whether prediction covariances should be returned or not. If set to <code>TRUE</code>, a maximum of 4000 prediction locations or polygons are allowed</p>
</td></tr>
<tr><td><code id="FRK_+3A_nsim">nsim</code></td>
<td>
<p>number of i) MC samples at each location when using <code>predict</code> or ii) response vectors when using <code>simulate</code></p>
</td></tr>
<tr><td><code id="FRK_+3A_type">type</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;TMB&quot;) vector of strings indicating the quantities for which inference is desired. If &quot;link&quot; is in <code>type</code>, inference on the latent Gaussian process <code class="reqn">Y(\cdot)</code> is included; if &quot;mean&quot; is in <code>type</code>, inference on the mean process <code class="reqn">\mu(\cdot)</code> is included (and the probability process, <code class="reqn">\pi(\cdot)</code>,  if applicable); if &quot;response&quot; is in <code>type</code>, inference on the noisy data <i> <b>Z</b><sup>*</sup> </i> is included</p>
</td></tr>
<tr><td><code id="FRK_+3A_k">k</code></td>
<td>
<p>(applicable only if <code>response</code> is &quot;binomial&quot; or &quot;negative-binomial&quot;) vector of size parameters at each BAU</p>
</td></tr>
<tr><td><code id="FRK_+3A_percentiles">percentiles</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;TMB&quot;) a vector of scalars in (0, 100) specifying the desired percentiles of the posterior predictive distribution; if <code>NULL</code>, no percentiles are computed</p>
</td></tr>
<tr><td><code id="FRK_+3A_kriging">kriging</code></td>
<td>
<p>(applicable only if <code>method</code> = &quot;TMB&quot;) string indicating the kind of kriging: &quot;simple&quot; ignores uncertainty due to estimation of the fixed effects, while &quot;universal&quot; accounts for this source of uncertainty</p>
</td></tr>
<tr><td><code id="FRK_+3A_random_effects">random_effects</code></td>
<td>
<p>logical; if set to true, confidence intervals will also be provided for the random effects random effects <i> <b>&gamma;</b></i> (see '?SRE' for details on these random effects)</p>
</td></tr>
<tr><td><code id="FRK_+3A_conditional_fs">conditional_fs</code></td>
<td>
<p>condition on the fitted fine-scale random effects?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following details provide a summary of the model and basic workflow
used in <span class="pkg">FRK</span>. See Zammit-Mangion and Cressie
(2021) and Sainsbury-Dale, Zammit-Mangion and Cressie (2023) for further details.
</p>
<p><strong>Model description</strong>
</p>
<p>The hierarchical model implemented in <span class="pkg">FRK</span> is a spatial generalised
linear mixed model (GLMM), which may be summarised as
</p>
<div style="text-align:center"> <i> Z<sub>j</sub> | <b>&mu;</b><sub>Z</sub>, &psi; ~ EF(&mu;<sub>Z<sub>j</sub></sub> , &psi;); &nbsp; &nbsp; &nbsp; j = 1, ..., m, </i></div>
<div style="text-align:center"> <i> <b>&mu;</b><sub>Z</sub> = <b>C</b><sub>Z</sub> <b>&mu;</b>, </i></div>
<div style="text-align:center"> <i> g(<b>&mu;</b>) = <b>Y</b>, </i></div>
<div style="text-align:center"> <i> <b>Y</b> = <b>T&alpha;</b> + <b>G&gamma;</b>  + <b>S&eta;</b> + <b>&xi;</b>, </i></div>
<div style="text-align:center"> <i> <b>&eta;</b> ~ N(<b>0</b>, <b>K</b>),</i></div>
<div style="text-align:center"> <i> <b>&xi;</b> ~ N(<b>0</b>, <b>&Sigma;</b><sub>&xi;</sub> ),</i></div>
<div style="text-align:center"> <i> <b>&gamma;</b> ~ N(<b>0</b>, <b>&Sigma;</b><sub>&gamma;</sub> ),</i></div><br>
<p>where <i>Z<sub>j</sub></i> denotes a datum, <code class="reqn">EF</code>  corresponds to a probability
distribution in the exponential family with dispersion parameter <code class="reqn">\psi</code>,
<i> <b>&mu;</b><sub>Z</sub></i> is the vector containing the conditional expectations of each datum,
<i> <b>C</b><sub>Z</sub></i> is a matrix which aggregates the BAU-level mean process over the observation supports,
<i> <b>&mu;</b></i> is the mean process evaluated over the BAUs, <code class="reqn">g</code> is a link function,
<i> <b>Y</b></i> is a latent Gaussian process evaluated over the BAUs,
the matrix <i> <b>T</b></i> contains regression covariates at the BAU level associated with the fixed effects <i> <b>&alpha;</b></i>,
the matrix <i> <b>G</b></i> is a design matrix at the BAU level associated with random effects <i> <b>&gamma;</b></i>,
the matrix <i> <b>S</b></i> contains basis-function evaluations over the BAUs associated with basis-function random effects <i> <b>&eta;</b></i>, and <i> <b>&xi;</b></i> is a vector containing fine-scale variation at the BAU level.
</p>
<p>The prior distribution of the random effects, <i> <b>&gamma;</b></i>, is a mean-zero multivariate Gaussian with diagonal covariance matrix, with each group of random effects associated with its own variance parameter. These variance parameters are estimated during model fitting. 
</p>
<p>The prior distribution of the basis-function coefficients, <i><b>&eta;</b></i>, is formulated
using either a covariance matrix <i> <b>K</b></i> or precision matrix <i> <b>Q</b></i>, depending on the argument
<code>K_type</code>. The parameters of these matrices are estimated during model fitting.
</p>
<p>The prior distribution of the fine-scale random effects, <i> <b>&xi;</b></i>, is a mean-zero multivariate Gaussian with diagonal covariance matrix,
<i> <b>&Sigma;</b><sub>&xi;</sub></i>.
By default, <i> <b>&Sigma;</b><sub>&xi;</sub> = &sigma;<sup>2</sup><sub>&xi;</sub><b>V</b></i>, where <i> <b>V</b></i> is a
known, positive-definite diagonal matrix whose elements are provided in the
field <code>fs</code> in the BAUs. In the absence of problem
specific fine-scale information, <code>fs</code> can simply be set to 1, so that
<i> <b>V</b> = <b>I</b></i>.
In a spatio-temporal setting, another model for <i> <b>&Sigma;</b><sub>&xi;</sub></i>
can be used by setting <code>fs_by_spatial_BAU = TRUE</code>, in which case each
spatial BAU is associated with its own fine-scale variance parameter 
(see Sainsbury-Dale et al., 2023, Sec. 2.6).
In either case, the fine-scale variance parameter(s) are either estimated during model fitting, or provided by
the user via the argument <code>known_sigma2fs</code>.
</p>
<p><em>Gaussian data model with an identity link function</em>
</p>
<p>When the data is Gaussian, and an identity link function is used, the preceding
model simplifies considerably: Specifically,
</p>

<div style="text-align:center"><i> <b>Z</b> = <b>C</b><sub>Z</sub><b>Y</b> + <b>C</b><sub>Z</sub><b>&delta;</b> + <b>e</b>,<br> </i></div>

<p>where
<i><b>Z</b></i> is the data vector,
<i><b>&delta;</b></i> is systematic error at the BAU level, and
<i><b>e</b></i> represents independent measurement error.
</p>
<p><em>Distributions with size parameters</em>
</p>
<p>Two distributions considered in this framework, namely the binomial
distribution and the negative-binomial distribution, have an assumed-known
‘size’ parameter and a ‘probability of success’ parameter.
Given the vector of size parameters associated with the data,
<i> <b>k</b><sub>Z</sub></i>, the parameterisation used in <span class="pkg">FRK</span> assumes that
<i>Z<sub>j</sub></i> represents either the number of &lsquo;successes&rsquo; from
<i>k<sub>Z<sub>j</sub></sub></i> trials (binomial data model) or that it represents the number of failures before
<i>k<sub>Z<sub>j</sub></sub></i> successes (negative-binomial data model).
</p>
<p>When model fitting, the BAU-level size parameters
<i> <b> k </b></i> are needed.
The user must supply these size parameters either through the data or though
the BAUs. How this is done depends on whether the data are areal or
point-referenced, and whether they overlap common BAUs or not.
The simplest case is when each observation is associated with a single BAU
only and each BAU is associated with at most one observation support; then,
it is straightforward to assign elements from
<i> <b>k</b><sub>Z</sub></i> to elements of
<i> <b> k </b></i> and vice-versa, and so the user may provide either
<i> <b> k </b></i> or
<i> <b>k</b><sub>Z</sub></i>.
If each observation is associated with
exactly one BAU, but some BAUs are associated with multiple observations,
the user must provide <i> <b>k</b><sub>Z</sub></i>, which is used to infer
<i> <b> k </b></i>; in
particular,
<i>k<sub>i</sub> = &Sigma;<sub>j&isin;a<sub>i</sub></sub> k<sub>Z<sub>j</sub></sub></i> ,
<code class="reqn">i = 1, \dots, N</code>, where
<i>a<sub>i</sub></i>
denotes the indices of the observations associated with BAU
<i>A<sub>i</sub></i>.
If one or more observations encompass multiple BAUs,
<i> <b> k </b></i>
must be provided with the BAUs, as we cannot meaningfully
distribute
<i>k<sub>Z<sub>j</sub></sub></i>
over multiple BAUs associated with datum
<i>Z<sub>j</sub></i>.
In this case, we infer
<i> <b>k</b><sub>Z</sub></i> using
<i>k<sub>Z<sub>j</sub></sub> = &Sigma;<sub>i&isin;c<sub>j</sub></sub> k<sub>i</sub></i> ,
<code class="reqn">j = 1, \dots, m</code>, where
<i>c<sub>j</sub></i>
denotes the indices of the BAUs associated with observation
<i>Z<sub>j</sub></i>.
</p>
<p><strong>Set-up</strong>
</p>
<p><code>SRE()</code> constructs a spatial random effects model from the user-defined formula, data object (a list
of spatially-referenced data), basis functions and a set of Basic Areal Units (BAUs).
It first takes each object in the list <code>data</code> and maps it to the BAUs &ndash; this
entails binning point-referenced data into the BAUs (and averaging within the
BAU if <code>average_in_BAU = TRUE</code>), and finding which BAUs are associated
with observations. Following this, the incidence matrix, <i> <b>C</b><sub>Z</sub></i>, is
constructed.
All required matrices (<i><b>S</b></i>, <i> <b>T</b></i>, <i> <b>C</b><sub>Z</sub></i>, etc.)
are constructed within <code>SRE()</code> and returned as part of the <code>SRE</code> object.
<code>SRE()</code> also intitialises the parameters and random effects using
sensible defaults. Please see
<code><a href="#topic+SRE-class">SRE-class</a></code> for more details.
The functions <code>observed_BAUs()</code> and <code>unobserved_BAUs()</code> return the
indices of the observed and unobserved BAUs, respectively.
</p>
<p>To include random effects in <span class="pkg">FRK</span> please follow the notation as used in <span class="pkg">lme4</span>. 
For example, to add a random effect according to a variable <code>fct</code>, simply add 
'<code>(1 | fct)</code>' to the formula used when calling <code>FRK()</code> or <code>SRE()</code>. 
Note that <span class="pkg">FRK</span> only supports simple, uncorrelated random effects and 
that a formula term such as '<code>(1 + x | fct)</code>' will throw an error 
(since in <span class="pkg">lme4</span> parlance this implies that the random effect corresponding to 
the intercept and the slope are correlated). If one wishes to model a an intercept and linear trend 
for each level in <code>fct</code>, 
then one can force the intercept and slope terms to be uncorrelated  by using 
the notation &quot;<code>(x || fct)</code>&quot;, which is shorthand for 
&quot;<code>(1 | fct) + (x - 1 | x2)</code>&quot;.
</p>
<p><strong>Model fitting</strong>
</p>
<p><code>SRE.fit()</code> takes an object of class <code>SRE</code> and estimates all unknown
parameters, namely the covariance matrix <i><b>K</b></i>, the fine scale variance
(<i>&sigma;<sup>2</sup><sub>&xi;</sub></i> or <i>&sigma;<sup>2</sup><sub>&delta;</sub></i>, depending on whether Case 1
or Case 2 is chosen; see the vignette &quot;FRK_intro&quot;) and the regression parameters <i> <b>&alpha;</b></i>.
There are two methods of model fitting currently implemented, both of which
implement maximum likelihood estimation (MLE).
</p>

<dl>
<dt>MLE via the expectation maximisation
(EM) algorithm. </dt><dd><p>This method is implemented only
for Gaussian data and an identity link function.
The log-likelihood (given in Section 2.2 of the vignette) is evaluated at each
iteration at the current parameter estimate. Optimation continues until
convergence is reached (when the log-likelihood stops changing by more than
<code>tol</code>), or when the number of EM iterations reaches <code>n_EM</code>.
The actual computations for the E-step and M-step are relatively straightforward.
The E-step contains an inverse of an <code class="reqn">r \times r</code> matrix, where <code class="reqn">r</code>
is the number of basis functions which should not exceed 2000. The M-step
first updates the matrix <i><b>K</b></i>, which only depends on the sufficient
statistics of the basis-function coefficients <i> <b>&eta;</b></i>. Then, the regression
parameters <i> <b>&alpha;</b></i> are updated and a simple optimisation routine
(a line search) is used to update the fine-scale variance
<i>&sigma;<sup>2</sup><sub>&delta;</sub></i> or <i>&sigma;<sup>2</sup><sub>&xi;</sub></i>. If the fine-scale errors and
measurement random errors are homoscedastic, then a closed-form solution is
available for the update of <i>&sigma;<sup>2</sup><sub>&xi;</sub></i> or <i>&sigma;<sup>2</sup><sub>&delta;</sub></i>.
Irrespectively, since the updates of <i> <b>&alpha;</b></i>, and <i>&sigma;<sup>2</sup><sub>&delta;</sub></i>
or <i>&sigma;<sup>2</sup><sub>&xi;</sub></i>, are dependent, these two updates are iterated until
the change in <i>&sigma;<sup>2</sup><sub>.</sub></i> is no more than 0.1%.</p>
</dd>
<dt>MLE via <code>TMB</code>. </dt><dd><p>This method is implemented for
all available data models and link functions offered by <span class="pkg">FRK</span>. Furthermore,
this method facilitates the inclusion of many more basis function than possible
with the EM algorithm (in excess of 10,000). <code>TMB</code> applies
the Laplace approximation to integrate out the latent random effects from the
complete-data likelihood. The resulting approximation of the marginal
log-likelihood, and its derivatives with respect to the parameters, are then
called from within <code>R</code> using the optimising function <code>optimiser</code>
(default <code>nlminb()</code>).</p>
</dd>
</dl>

<p><em>Wrapper for set-up and model fitting</em>
</p>
<p>The function <code>FRK()</code> acts as a wrapper for the functions <code>SRE()</code> and
<code>SRE.fit()</code>. An added advantage of using <code>FRK()</code> directly is that it
automatically generates BAUs and basis functions based on the data. Hence
<code>FRK()</code> can be called using only a list of data objects and an <code>R</code>
formula, although the <code>R</code> formula can only contain space or time as
covariates when BAUs are not explicitly supplied with the covariate data.
</p>
<p><strong>Prediction</strong>
</p>
<p>Once the parameters are estimated, the <code>SRE</code> object is passed onto the
function <code>predict()</code> in order to carry out optimal predictions over the
same BAUs used to construct the SRE model with <code>SRE()</code>. The first part
of the prediction process is to construct the matrix <i> <b>S</b></i> over the
prediction polygons. This is made computationally efficient by treating the
prediction over polygons as that of the prediction over a combination of BAUs.
This will yield valid results only if the BAUs are relatively small. Once the
matrix <i> <b>S</b></i> is found, a standard Gaussian inversion (through conditioning)
using the estimated parameters is used for prediction.
</p>
<p><code>predict()</code> returns the BAUs (or an object specified in <code>newdata</code>),
which are of class <code>SpatialPixelsDataFrame</code>, <code>SpatialPolygonsDataFrame</code>,
or <code>STFDF</code>, with predictions and
uncertainty quantification added.
If <code>method</code> = &quot;TMB&quot;, the returned object is a list, containing the
previously described predictions, and a list of Monte Carlo samples.
The predictions and uncertainties can be easily plotted using <code><a href="#topic+plot">plot</a></code>
or <code>spplot</code> from the package <code>sp</code>.
</p>


<h3>References</h3>

<p>Zammit-Mangion, A. and Cressie, N. (2021). FRK: An R package for spatial and spatio-temporal prediction with large datasets. Journal of Statistical Software, 98(4), 1-48. doi:10.18637/jss.v098.i04.
</p>
<p>Sainsbury-Dale, M. and Zammit-Mangion, A. and Cressie, N. (2024) Modelling Big, Heterogeneous, Non-Gaussian Spatial and Spatio-Temporal Data using FRK. Journal of Statistical Software, 108(10), 1&ndash;39. doi:10.18637/jss.v108.i10.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SRE-class">SRE-class</a></code> for details on the SRE object internals,
<code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions, and
<code><a href="#topic+auto_BAUs">auto_BAUs</a></code> for automatically constructing BAUs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("FRK")
library("sp")
## Generate process and data
m &lt;- 250                                                   # Sample size
zdf &lt;- data.frame(x = runif(m), y= runif(m))               # Generate random locs
zdf$Y &lt;- 3 + sin(7 * zdf$x) + cos(9 * zdf$y)               # Latent process
zdf$z &lt;- rnorm(m, mean = zdf$Y)                            # Simulate data
coordinates(zdf) = ~x+y                                    # Turn into sp object

## Construct BAUs and basis functions
BAUs &lt;- auto_BAUs(manifold = plane(), data = zdf,
                  nonconvex_hull = FALSE, cellsize = c(0.03, 0.03), type="grid")
BAUs$fs &lt;- 1 # scalar fine-scale covariance matrix
basis &lt;- auto_basis(manifold =  plane(), data = zdf, nres = 2)

## Construct the SRE model
S &lt;- SRE(f = z ~ 1, list(zdf), basis = basis, BAUs = BAUs)

## Fit with 2 EM iterations so to take as little time as possible
S &lt;- SRE.fit(S, n_EM = 2, tol = 0.01, print_lik = TRUE)

## Check fit info, final log-likelihood, and estimated regression coefficients
info_fit(S)
logLik(S)
coef(S)

## Predict over BAUs
pred &lt;- predict(S)

## Plot
## Not run: 
plotlist &lt;- plot(S, pred)
ggpubr::ggarrange(plotlist = plotlist, nrow = 1, align = "hv", legend = "top")
## End(Not run)
</code></pre>

<hr>
<h2 id='info_fit'>Retrieve fit information for SRE model</h2><span id='topic+info_fit'></span><span id='topic+info_fit+2CSRE-method'></span>

<h3>Description</h3>

<p>Takes an object of class <code>SRE</code> and returns a list containing all the relevant information on parameter estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>info_fit(object)

## S4 method for signature 'SRE'
info_fit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="info_fit_+3A_object">object</code></td>
<td>
<p>object of class <code>SRE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+FRK">FRK</a></code> for more information on the SRE model and available fitting methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example in the help file for FRK
</code></pre>

<hr>
<h2 id='initialize+2Cmanifold-method'>manifold</h2><span id='topic+initialize+2Cmanifold-method'></span>

<h3>Description</h3>

<p>Manifold initialisation. This function should not be called directly as <code>manifold</code> is a virtual class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'manifold'
initialize(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize+2B2Cmanifold-method_+3A_.object">.Object</code></td>
<td>
<p><code>manifold</code> object passed up from lower-level constructor</p>
</td></tr>
</table>

<hr>
<h2 id='isea3h'>ISEA Aperture 3 Hexagon (ISEA3H) Discrete Global Grid</h2><span id='topic+isea3h'></span>

<h3>Description</h3>

<p>The data used here were obtained from
https://webpages.sou.edu/~sahrk/dgg/isea.old/gen/isea3h.html and represent ISEA
discrete global grids (DGGRIDs) generated using the <code>DGGRID</code> software.
The original .gen files were converted to a data frame using the function <code>dggrid_gen_to_df</code>,
available with the <code>dggrids</code> package. Only resolutions 0&ndash;6 are supplied with <code>FRK</code>
and note that resolution 0 of ISEA3H is equal to resolution 1 in <code>FRK</code>. For higher
resolutions <code>dggrids</code> can be installed from <code>https://github.com/andrewzm/dggrids/</code>
using <code>devtools</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isea3h
</code></pre>


<h3>Format</h3>

<p>A data frame with 284,208 rows and 5 variables:
</p>

<dl>
<dt>id</dt><dd><p>grid identification number within the given resolution</p>
</dd>
<dt>lon</dt><dd><p>longitude coordinate</p>
</dd>
<dt>lat</dt><dd><p>latitude coordinate</p>
</dd>
<dt>res</dt><dd><p>DGGRID resolution (0 &ndash; 6)</p>
</dd>
<dt>centroid</dt><dd><p>A 0-1 variable, indicating whether the point describes the centroid of the polygon,
or whether it is a boundary point of the polygon</p>
</dd>
</dl>



<h3>References</h3>

<p>Sahr, K. (2008). Location coding on icosahedral aperture 3 hexagon discrete global grids. Computers, Environment and Urban Systems, 32, 174&ndash;187.
</p>

<hr>
<h2 id='local_basis'>Construct a set of local basis functions</h2><span id='topic+local_basis'></span><span id='topic+radial_basis'></span>

<h3>Description</h3>

<p>Construct a set of local basis functions based on pre-specified location and scale parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_basis(
  manifold = sphere(),
  loc = matrix(c(1, 0), nrow = 1),
  scale = 1,
  type = c("bisquare", "Gaussian", "exp", "Matern32"),
  res = 1,
  regular = FALSE
)

radial_basis(
  manifold = sphere(),
  loc = matrix(c(1, 0), nrow = 1),
  scale = 1,
  type = c("bisquare", "Gaussian", "exp", "Matern32")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_basis_+3A_manifold">manifold</code></td>
<td>
<p>object of class <code>manifold</code>, for example, <code>sphere</code></p>
</td></tr>
<tr><td><code id="local_basis_+3A_loc">loc</code></td>
<td>
<p>a matrix of size <code>n</code> by <code>dimensions(manifold)</code> indicating centres of basis functions</p>
</td></tr>
<tr><td><code id="local_basis_+3A_scale">scale</code></td>
<td>
<p>vector of length <code>n</code> containing the scale parameters of the basis functions; see details</p>
</td></tr>
<tr><td><code id="local_basis_+3A_type">type</code></td>
<td>
<p>either <code>"bisquare"</code>, <code>"Gaussian"</code>, <code>"exp"</code>, or <code>"Matern32"</code></p>
</td></tr>
<tr><td><code id="local_basis_+3A_res">res</code></td>
<td>
<p>vector of length <code>n</code> containing the resolutions of the basis functions</p>
</td></tr>
<tr><td><code id="local_basis_+3A_regular">regular</code></td>
<td>
<p>logical indicating if the basis functions (of each resolution) are in a regular grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions lays out local basis functions in a domain of interest based on pre-specified location and scale parameters. If <code>type</code> is &ldquo;bisquare&rdquo;, then
</p>
<p style="text-align: center;"><code class="reqn">\phi(u) = \left(1- \left(\frac{\| u \|}{R}\right)^2\right)^2 I(\|u\| &lt; R),</code>
</p>

<p>and <code>scale</code> is given by <code class="reqn">R</code>, the range of support of the bisquare function. If <code>type</code> is &ldquo;Gaussian&rdquo;, then
</p>
<p style="text-align: center;"><code class="reqn">\phi(u) = \exp\left(-\frac{\|u \|^2}{2\sigma^2}\right),</code>
</p>

<p>and <code>scale</code> is given by <code class="reqn">\sigma</code>, the standard deviation. If <code>type</code> is &ldquo;exp&rdquo;, then
</p>
<p style="text-align: center;"><code class="reqn">\phi(u) = \exp\left(-\frac{\|u\|}{ \tau}\right),</code>
</p>

<p>and <code>scale</code> is given by <code class="reqn">\tau</code>, the e-folding length. If <code>type</code> is &ldquo;Matern32&rdquo;, then
</p>
<p style="text-align: center;"><code class="reqn">\phi(u) = \left(1 + \frac{\sqrt{3}\|u\|}{\kappa}\right)\exp\left(-\frac{\sqrt{3}\| u \|}{\kappa}\right),</code>
</p>

<p>and <code>scale</code> is given by <code class="reqn">\kappa</code>, the function's scale.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for constructing basis functions automatically, and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
G &lt;-  local_basis(manifold = real_line(),
                   loc=matrix(1:10,10,1),
                   scale=rep(2,10),
                   type="bisquare")
## Not run: show_basis(G)
</code></pre>

<hr>
<h2 id='loglik'>(Deprecated) Retrieve log-likelihood</h2><span id='topic+loglik'></span><span id='topic+loglik+2CSRE-method'></span>

<h3>Description</h3>

<p>This function is deprecated; please use <code>logLik</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik(object)

## S4 method for signature 'SRE'
loglik(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik_+3A_object">object</code></td>
<td>
<p>object of class <code>SRE</code></p>
</td></tr>
</table>

<hr>
<h2 id='manifold'>Retrieve manifold</h2><span id='topic+manifold'></span><span id='topic+manifold+2CBasis-method'></span><span id='topic+manifold+2CTensorP_Basis-method'></span>

<h3>Description</h3>

<p>Retrieve manifold from <code>FRK</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manifold(.Object)

## S4 method for signature 'Basis'
manifold(.Object)

## S4 method for signature 'TensorP_Basis'
manifold(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manifold_+3A_.object">.Object</code></td>
<td>
<p><code>FRK</code> object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+real_line">real_line</a></code>, <code><a href="#topic+plane">plane</a></code>, <code><a href="#topic+sphere">sphere</a></code>, <code><a href="#topic+STplane">STplane</a></code> and <code><a href="#topic+STsphere">STsphere</a></code> for constructing manifolds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>G &lt;-  local_basis(manifold = plane(),
                   loc=matrix(0,1,2),
                   scale=0.2,
                   type="bisquare")
manifold(G)
</code></pre>

<hr>
<h2 id='manifold-class'>manifold</h2><span id='topic+manifold-class'></span><span id='topic+STmanifold-class'></span><span id='topic+real_line-class'></span><span id='topic+plane-class'></span><span id='topic+STplane-class'></span><span id='topic+sphere-class'></span><span id='topic+STsphere-class'></span>

<h3>Description</h3>

<p>The class <code>manifold</code> is virtual; other manifold classes inherit from this class.
</p>


<h3>Details</h3>

<p>A <code>manifold</code> object is characterised by a character variable <code>type</code>, which contains a description of the manifold, and a variable <code>measure</code> of type <code>measure</code>. A typical measure is the Euclidean distance.
</p>
<p><code>FRK</code> supports five manifolds; the real line (in one dimension), instantiated by using <code>real_line()</code>; the 2D plane, instantiated by using <code>plane()</code>; the 2D-sphere surface S2, instantiated by using <code>sphere()</code>; the R2 space-time manifold, instantiated by using <code>STplane()</code>, and the S2 space-time manifold, instantiated by using <code>STsphere()</code>. User-specific manifolds can also be specified, however helper functions that are manifold specific, such as <code>auto_BAUs</code> and <code>auto_basis</code>, only work with the pre-configured manifolds. Importantly, one can change the distance function used on the manifold to synthesise anisotropy or heterogeneity. See the vignette for one such example.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+real_line">real_line</a></code>, <code><a href="#topic+plane">plane</a></code>, <code><a href="#topic+sphere">sphere</a></code>, <code><a href="#topic+STplane">STplane</a></code> and <code><a href="#topic+STsphere">STsphere</a></code> for constructing manifolds.
</p>

<hr>
<h2 id='measure-class'>measure</h2><span id='topic+measure-class'></span>

<h3>Description</h3>

<p>Measure class used for defining measures used to compute distances between points in objects constructed with the <code>FRK</code> package.
</p>


<h3>Details</h3>

<p>An object of class <code>measure</code> contains a distance function and a variable <code>dim</code> with the dimensions of the Riemannian manifold over which the distance is computed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distance">distance</a></code> for computing a distance and <code><a href="#topic+distances">distances</a></code> for a list of implemented distance functions.
</p>

<hr>
<h2 id='MODIS_cloud_df'>MODIS cloud data</h2><span id='topic+MODIS_cloud_df'></span>

<h3>Description</h3>

<p>An image of a cloud taken by the Moderate Resolution
Imaging Spectroradiometer (MODIS) instrument aboard the Aqua satellite (MODIS
Characterization Support Team, 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MODIS_cloud_df
</code></pre>


<h3>Format</h3>

<p>A data frame with 33,750 rows and 3 variables:
</p>

<dl>
<dt>x</dt><dd><p>x-coordinate</p>
</dd>
<dt>y</dt><dd><p>y-coordinate</p>
</dd>
<dt>z</dt><dd><p>binary dependent variable: 1 if cloud is present, 0 if no cloud. This
variable has been thresholded from the original continuous measurement of
radiance supplied by the MODIS instrument</p>
</dd>
<dt>z_unthresholded</dt><dd><p>The original continuous measurement of
radiance supplied by the MODIS instrument</p>
</dd>
</dl>



<h3>References</h3>

<p>MODIS Characterization Support Team (2015). MODIS 500m Calibrated Radiance Product.NASA MODIS Adaptive Processing System, Goddard Space Flight Center, USA.
</p>

<hr>
<h2 id='nbasis'>Number of basis functions</h2><span id='topic+nbasis'></span><span id='topic+nbasis+2CBasis_obj-method'></span><span id='topic+nbasis+2CSRE-method'></span>

<h3>Description</h3>

<p>Retrieve the number of basis functions from <code>Basis</code> or <code>SRE</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbasis(.Object)

## S4 method for signature 'Basis_obj'
nbasis(.Object)

## S4 method for signature 'SRE'
nbasis(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbasis_+3A_.object">.Object</code></td>
<td>
<p>object of class <code>Basis</code> or <code>SRE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y # change into an sp object
G &lt;- auto_basis(manifold = plane(),
                data=meuse,
                nres = 2,
                regular=1,
                type = "Gaussian")
print(nbasis(G))
</code></pre>

<hr>
<h2 id='NOAA_df_1990'>NOAA maximum temperature data for 1990&ndash;1993</h2><span id='topic+NOAA_df_1990'></span>

<h3>Description</h3>

<p>Maximum temperature data obtained from the National Oceanic and Atmospheric
Administration (NOAA) for a part of the USA between 1990 and 1993 (inclusive).
See https://iridl.ldeo.columbia.edu/ SOURCES/.NOAA/.NCDC/.DAILY/.FSOD/.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOAA_df_1990
</code></pre>


<h3>Format</h3>

<p>A data frame with 196,253 rows and 8 variables:
</p>

<dl>
<dt>year</dt><dd><p>year of retrieval</p>
</dd>
<dt>month</dt><dd><p>month of retrieval</p>
</dd>
<dt>day</dt><dd><p>day of retrieval</p>
</dd>
<dt>z</dt><dd><p>dependent variable</p>
</dd>
<dt>proc</dt><dd><p>variable name (Tmax)</p>
</dd>
<dt>id</dt><dd><p>station id</p>
</dd>
<dt>lon</dt><dd><p>longitude coordinate of measurement station</p>
</dd>
<dt>lat</dt><dd><p>latitude coordinate of measurement station</p>
</dd>
</dl>



<h3>References</h3>

<p>National Climatic Data Center, March 1993: Local Climatological Data.
Environmental Information summary (C-2), NOAA-NCDC, Asheville, NC.
</p>

<hr>
<h2 id='nres'>Return  the number of resolutions</h2><span id='topic+nres'></span><span id='topic+nres+2CBasis-method'></span><span id='topic+nres_basis+2CBasis-method'></span><span id='topic+nres+2CTensorP_Basis-method'></span><span id='topic+nres+2CSRE-method'></span><span id='topic+nres_SRE+2CSRE-method'></span>

<h3>Description</h3>

<p>Return the number of resolutions from a basis function object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nres(b)

## S4 method for signature 'Basis'
nres(b)

## S4 method for signature 'TensorP_Basis'
nres(b)

## S4 method for signature 'SRE'
nres(b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nres_+3A_b">b</code></td>
<td>
<p>object of class <code>Basis</code> or <code>SRE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
set.seed(1)
d &lt;- data.frame(lon = runif(n=500,min = -179, max = 179),
                lat = runif(n=500,min = -90, max = 90),
                z = rnorm(500))
coordinates(d) &lt;- ~lon + lat
slot(d, "proj4string") = CRS("+proj=longlat")

### Now create basis functions on sphere
G &lt;- auto_basis(manifold = sphere(),data=d,
                nres = 2,prune=15,
                type = "bisquare",
                subsamp = 20000)
nres(G)
</code></pre>

<hr>
<h2 id='observed_BAUs'>Observed (or unobserved) BAUs</h2><span id='topic+observed_BAUs'></span><span id='topic+unobserved_BAUs'></span><span id='topic+observed_BAUs+2CSRE-method'></span><span id='topic+unobserved_BAUs+2CSRE-method'></span>

<h3>Description</h3>

<p>Computes the indices (a numeric vector) of the observed (or unobserved) BAUs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observed_BAUs(object)

unobserved_BAUs(object)

## S4 method for signature 'SRE'
observed_BAUs(object)

## S4 method for signature 'SRE'
unobserved_BAUs(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="observed_BAUs_+3A_object">object</code></td>
<td>
<p>object of class <code>SRE</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+FRK">FRK</a></code> for more information on the SRE model and available fitting methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See example in the help file for FRK
</code></pre>

<hr>
<h2 id='opts_FRK'>FRK options</h2><span id='topic+opts_FRK'></span>

<h3>Description</h3>

<p>The main options list for the FRK package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts_FRK
</code></pre>


<h3>Format</h3>

<p>List of 2
</p>

<dl>
<dt><code>$</code>  </dt><dd><p><code>set:function(opt,value)</code></p>
</dd>
<dt><code>$</code>  </dt><dd><p><code>get:function(opt)</code></p>
</dd>
</dl>



<h3>Details</h3>

<p><code>opts_FRK</code> is a list containing two functions, <code>set</code> and <code>get</code>, which can be used to set options and retrieve options, respectively. Currently <code>FRK</code> uses three options:
</p>

<dl>
<dt>&quot;progress&quot;:</dt><dd><p> a flag indicating whether progress bars should be displayed or not</p>
</dd>
<dt>&quot;verbose&quot;:</dt><dd><p> a flag indicating whether certain progress messages should be shown or not. Currently this is the only option applicable to <code>method</code> = &quot;TMB&quot;</p>
</dd>
<dt>&quot;parallel&quot;:</dt><dd><p> an integer indicating the number of cores to use. A number 0 or 1 indicates no parallelism</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>opts_FRK$set("progress",1L)
opts_FRK$get("parallel")
</code></pre>

<hr>
<h2 id='plane'>plane</h2><span id='topic+plane'></span>

<h3>Description</h3>

<p>Initialisation of a 2D plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plane(measure = Euclid_dist(dim = 2L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plane_+3A_measure">measure</code></td>
<td>
<p>an object of class <code>measure</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 2D plane is initialised using a <code>measure</code> object. By default, the measure object (<code>measure</code>) is the Euclidean distance in 2 dimensions, <a href="#topic+Euclid_dist">Euclid_dist</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- plane()
print(type(P))
print(sp::dimensions(P))
</code></pre>

<hr>
<h2 id='plot'>Plot predictions from FRK analysis</h2><span id='topic+plot'></span><span id='topic+plot+2CSRE+2Clist-method'></span><span id='topic+plot+2CSRE+2CSTFDF-method'></span><span id='topic+plot+2CSRE+2CSpatialPointsDataFrame-method'></span><span id='topic+plot+2CSRE+2CSpatialPixelsDataFrame-method'></span><span id='topic+plot+2CSRE+2CSpatialPolygonsDataFrame-method'></span>

<h3>Description</h3>

<p>This function acts as a wrapper around 
<code><a href="#topic+plot_spatial_or_ST">plot_spatial_or_ST</a></code>. It plots the fields of the 
<code>Spatial*DataFrame</code> or <code>STFDF</code> object corresponding to 
prediction and prediction uncertainty quantification. It also uses the 
<code>@data</code> slot of <code>SRE</code> object to plot the training data set(s), 
and generates informative, latex-style legend labels for each of the plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)

## S4 method for signature 'SRE,list'
plot(x, y, ...)

## S4 method for signature 'SRE,STFDF'
plot(x, y, ...)

## S4 method for signature 'SRE,SpatialPointsDataFrame'
plot(x, y, ...)

## S4 method for signature 'SRE,SpatialPixelsDataFrame'
plot(x, y, ...)

## S4 method for signature 'SRE,SpatialPolygonsDataFrame'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>object of class <code>SRE</code></p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>the <code>Spatial*DataFrame</code> or <code>STFDF</code> object resulting from the call <code>predict(x)</code>. 
Keep in mind that <code>predict()</code> returns a <code>list</code> when <code>method</code> = &quot;TMB&quot;; the element <code>$newdata</code> contains the required <code>Spatial</code>/<code>ST</code> object. 
If the list itself is passed, you will receive the error: &quot;x&quot; and &quot;y&quot; lengths differ.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>optional arguments passed on to <code><a href="#topic+plot_spatial_or_ST">plot_spatial_or_ST</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>ggplot</code> objects consisting of the observed data, predictions, and standard errors. This list can then be supplied to, for example, <code>ggpubr::ggarrange()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example in the help file for SRE
</code></pre>

<hr>
<h2 id='plot_spatial_or_ST'>Plot a Spatial*DataFrame or STFDF object</h2><span id='topic+plot_spatial_or_ST'></span><span id='topic+plot_spatial_or_ST+2CSTFDF-method'></span><span id='topic+plot_spatial_or_ST+2CSpatialPointsDataFrame-method'></span><span id='topic+plot_spatial_or_ST+2CSpatialPixelsDataFrame-method'></span><span id='topic+plot_spatial_or_ST+2CSpatialPolygonsDataFrame-method'></span>

<h3>Description</h3>

<p>Takes an object of class <code>Spatial*DataFrame</code> or <code>STFDF</code>, and plots requested data columns using <code>ggplot2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spatial_or_ST(
  newdata,
  column_names,
  map_layer = NULL,
  subset_time = NULL,
  palette = "Spectral",
  plot_over_world = FALSE,
  labels_from_coordnames = TRUE,
  ...
)

## S4 method for signature 'STFDF'
plot_spatial_or_ST(
  newdata,
  column_names,
  map_layer = NULL,
  subset_time = NULL,
  palette = "Spectral",
  plot_over_world = FALSE,
  labels_from_coordnames = TRUE,
  ...
)

## S4 method for signature 'SpatialPointsDataFrame'
plot_spatial_or_ST(
  newdata,
  column_names,
  map_layer = NULL,
  subset_time = NULL,
  palette = "Spectral",
  plot_over_world = FALSE,
  labels_from_coordnames = TRUE,
  ...
)

## S4 method for signature 'SpatialPixelsDataFrame'
plot_spatial_or_ST(
  newdata,
  column_names,
  map_layer = NULL,
  subset_time = NULL,
  palette = "Spectral",
  plot_over_world = FALSE,
  labels_from_coordnames = TRUE,
  ...
)

## S4 method for signature 'SpatialPolygonsDataFrame'
plot_spatial_or_ST(
  newdata,
  column_names,
  map_layer = NULL,
  subset_time = NULL,
  palette = "Spectral",
  plot_over_world = FALSE,
  labels_from_coordnames = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_spatial_or_ST_+3A_newdata">newdata</code></td>
<td>
<p>an object of class <code>Spatial*DataFrame</code> or <code>STFDF</code></p>
</td></tr>
<tr><td><code id="plot_spatial_or_ST_+3A_column_names">column_names</code></td>
<td>
<p>a vector of strings indicating the columns of the data to plot</p>
</td></tr>
<tr><td><code id="plot_spatial_or_ST_+3A_map_layer">map_layer</code></td>
<td>
<p>(optional) a <code>ggplot</code> layer or object to add below the plotted layer, often a map</p>
</td></tr>
<tr><td><code id="plot_spatial_or_ST_+3A_subset_time">subset_time</code></td>
<td>
<p>(optional) a vector of times to be included; applicable only for <code>STFDF</code> objects</p>
</td></tr>
<tr><td><code id="plot_spatial_or_ST_+3A_palette">palette</code></td>
<td>
<p>the palette supplied to the argument <code>palette</code> of <code>scale_*_distiller()</code>. Alternatively, if <code>palette</code> = &quot;nasa&quot;, a vibrant colour palette is created using <code>scale_*_gradientn()</code></p>
</td></tr>
<tr><td><code id="plot_spatial_or_ST_+3A_plot_over_world">plot_over_world</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>coord_map("mollweide")</code> and <code><a href="#topic+draw_world">draw_world</a></code> are used to plot over the world</p>
</td></tr>
<tr><td><code id="plot_spatial_or_ST_+3A_labels_from_coordnames">labels_from_coordnames</code></td>
<td>
<p>logical; if <code>TRUE</code>, the coordinate names of <code>newdata</code> (i.e., <code>coordnames(newdata)</code>) are used as the horizontal- and vertical-axis labels. Otherwise, generic names, s_1 and s_2, are used</p>
</td></tr>
<tr><td><code id="plot_spatial_or_ST_+3A_...">...</code></td>
<td>
<p>optional arguments passed on to whatever geom is appropriate for the <code>Spatial*DataFrame</code> or <code>STFDF</code> object (<code>geom_point</code>, <code>geom_tile</code>, <code>geom_raster</code>, or <code>geom_polygon</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>ggplot</code> objects corresponding to the provided <code>column_names</code>. This list can then be supplied to, for example, <code>ggpubr::ggarrange()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See example in the help file for FRK
</code></pre>

<hr>
<h2 id='plotting-themes'>Plotting themes</h2><span id='topic+plotting-themes'></span><span id='topic+LinePlotTheme'></span><span id='topic+EmptyTheme'></span>

<h3>Description</h3>

<p>Formats a ggplot object for neat plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LinePlotTheme()

EmptyTheme()
</code></pre>


<h3>Details</h3>

<p><code>LinePlotTheme()</code> creates <code>ggplot</code> object with a white background, a relatively large font, and grid lines. <code>EmptyTheme()</code> on the other hand creates a <code>ggplot</code> object with no axes or legends.
</p>


<h3>Value</h3>

<p>Object of class <code>ggplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
X &lt;- data.frame(x=runif(100),y = runif(100), z = runif(100))
LinePlotTheme() + geom_point(data=X,aes(x,y,colour=z))
EmptyTheme() + geom_point(data=X,aes(x,y,colour=z))
## End(Not run)
</code></pre>

<hr>
<h2 id='real_line'>real line</h2><span id='topic+real_line'></span>

<h3>Description</h3>

<p>Initialisation of the real-line (1D) manifold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>real_line(measure = Euclid_dist(dim = 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="real_line_+3A_measure">measure</code></td>
<td>
<p>an object of class <code>measure</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A real line is initialised using a <code>measure</code> object. By default, the measure object (<code>measure</code>) describes the distance between two points as the absolute difference between the two coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- real_line()
print(type(R))
print(sp::dimensions(R))
</code></pre>

<hr>
<h2 id='remove_basis'>Removes basis functions</h2><span id='topic+remove_basis'></span><span id='topic+remove_basis+2CBasis+2CANY-method'></span><span id='topic+remove_basis+2CBasis-method'></span><span id='topic+remove_basis+2CBasis+2CSpatialPolygons-method'></span>

<h3>Description</h3>

<p>Takes an object of class <code>Basis</code> and returns an object of class <code>Basis</code> with selected basis functions removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_basis(Basis, rmidx)

## S4 method for signature 'Basis,ANY'
remove_basis(Basis, rmidx)

## S4 method for signature 'Basis,SpatialPolygons'
remove_basis(Basis, rmidx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_basis_+3A_basis">Basis</code></td>
<td>
<p>object of class <code>Basis</code></p>
</td></tr>
<tr><td><code id="remove_basis_+3A_rmidx">rmidx</code></td>
<td>
<p>indices of basis functions to remove. Or a <code>SpatialPolygons</code> object; basis functions overlapping this <code>SpatialPolygons</code> object will be <em>retained</em></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
df &lt;- data.frame(x = rnorm(10),
                 y = rnorm(10))
coordinates(df) &lt;- ~x+y
G &lt;- auto_basis(plane(),df,nres=1)
data.frame(G) # Print info on basis

## Removing basis functions by index
G_subset &lt;- remove_basis(G, 1:(nbasis(G)-1))
data.frame(G_subset)

## Removing basis functions using SpatialPolygons
x &lt;- 1
poly &lt;- Polygon(rbind(c(-x, -x), c(-x, x), c(x, x), c(x, -x), c(-x, -x)))
polys &lt;- Polygons(list(poly), "1")
spatpolys &lt;- SpatialPolygons(list(polys))
G_subset &lt;- remove_basis(G, spatpolys)
data.frame(G_subset)
</code></pre>

<hr>
<h2 id='show_basis'>Show basis functions</h2><span id='topic+show_basis'></span><span id='topic+show_basis+2CBasis-method'></span><span id='topic+show_basis+2CTensorP_Basis-method'></span>

<h3>Description</h3>

<p>Generic plotting function for visualising the basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_basis(basis, ...)

## S4 method for signature 'Basis'
show_basis(basis, g = ggplot() + theme_bw() + xlab("") + ylab(""))

## S4 method for signature 'TensorP_Basis'
show_basis(basis, g = ggplot())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_basis_+3A_basis">basis</code></td>
<td>
<p>object of class <code>Basis</code></p>
</td></tr>
<tr><td><code id="show_basis_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
<tr><td><code id="show_basis_+3A_g">g</code></td>
<td>
<p>object of class <code>gg</code> (a <code>ggplot</code> object) over which to overlay the basis functions (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>show_basis</code> adapts its behaviour to the manifold being used. With <code>real_line</code>, the 1D basis functions are plotted with colour distinguishing between the different resolutions. With <code>plane</code>, only local basis functions are supported (at present). Each basis function is shown as a circle with diameter equal to the <code>scale</code> parameter of the function. Linetype distinguishes the resolution. With <code>sphere</code>, the centres of the basis functions are shown as circles, with larger sizes corresponding to coarser resolutions. Space-time basis functions of subclass <code>TensorP_Basis</code> are visualised by showing the spatial basis functions and the temporal basis functions in two separate plots.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(sp)
data(meuse)
coordinates(meuse) = ~x+y # change into an sp object
G &lt;- auto_basis(manifold = plane(),data=meuse,nres = 2,regular=2,prune=0.1,type = "bisquare")
## Not run: show_basis(G,ggplot()) + geom_point(data=data.frame(meuse),aes(x,y))
</code></pre>

<hr>
<h2 id='SpatialPolygonsDataFrame_to_df'>SpatialPolygonsDataFrame to df</h2><span id='topic+SpatialPolygonsDataFrame_to_df'></span>

<h3>Description</h3>

<p>Convert <code>SpatialPolygonsDataFrame</code> or <code>SpatialPixelsDataFrame</code> object to data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialPolygonsDataFrame_to_df(sp_polys, vars = names(sp_polys))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SpatialPolygonsDataFrame_to_df_+3A_sp_polys">sp_polys</code></td>
<td>
<p>object of class <code>SpatialPolygonsDataFrame</code> or <code>SpatialPixelsDataFrame</code></p>
</td></tr>
<tr><td><code id="SpatialPolygonsDataFrame_to_df_+3A_vars">vars</code></td>
<td>
<p>variables to put into data frame (by default all of them)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly used for plotting <code>SpatialPolygonsDataFrame</code> objects with <code>ggplot</code> rather than <code>spplot</code>. The coordinates of each polygon are extracted and concatenated into one long data frame. The attributes of each polygon are then attached to this data frame as variables that vary by polygon <code>id</code> (the rownames of the object).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(ggplot2)
opts_FRK$set("parallel",0L)
df &lt;- data.frame(id = c(rep(1,4),rep(2,4)),
                 x = c(0,1,0,0,2,3,2,2),
                 y=c(0,0,1,0,0,1,1,0))
pols &lt;- df_to_SpatialPolygons(df,"id",c("x","y"),CRS())
polsdf &lt;- SpatialPolygonsDataFrame(pols,data.frame(p = c(1,2),row.names=row.names(pols)))
df2 &lt;- SpatialPolygonsDataFrame_to_df(polsdf)
## Not run: ggplot(df2,aes(x=x,y=y,group=id)) + geom_polygon()
</code></pre>

<hr>
<h2 id='sphere'>sphere</h2><span id='topic+sphere'></span>

<h3>Description</h3>

<p>Initialisation of the 2-sphere, S2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sphere(radius = 6371)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sphere_+3A_radius">radius</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 2D surface of a sphere is initialised using a <code>radius</code> parameter. The default value of the radius <code>R</code> is <code>R</code>=6371 km, Earth's radius, while the measure used to compute distances on the sphere is the great-circle distance on a sphere of radius <code>R</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- sphere()
print(sp::dimensions(S))
</code></pre>

<hr>
<h2 id='SRE-class'>Spatial Random Effects class</h2><span id='topic+SRE-class'></span>

<h3>Description</h3>

<p>This is the central class definition of the <code>FRK</code> package, containing the model and all other information required for estimation and prediction.
</p>


<h3>Details</h3>

<p>The spatial random effects (SRE) model is the model employed in Fixed Rank Kriging, and the <code>SRE</code> object contains all information required for estimation and prediction from spatial data. Object slots contain both other objects (for example, an object of class <code>Basis</code>) and matrices derived from these objects (for example, the matrix <code class="reqn">S</code>) in order to facilitate computations.
</p>


<h3>Slots</h3>


<dl>
<dt><code>f</code></dt><dd><p>formula used to define the SRE object. All covariates employed need to be specified in the object <code>BAUs</code></p>
</dd>
<dt><code>data</code></dt><dd><p>the original data from which the model's parameters are estimated</p>
</dd>
<dt><code>basis</code></dt><dd><p>object of class <code>Basis</code> used to construct the matrix <code class="reqn">S</code></p>
</dd>
<dt><code>BAUs</code></dt><dd><p>object of class <code>SpatialPolygonsDataFrame</code>, <code>SpatialPixelsDataFrame</code> of <code>STFDF</code> that contains the Basic Areal Units (BAUs) that are used to both (i) project the data onto a common discretisation if they are point-referenced and (ii) provide a BAU-to-data relationship if the data has a spatial footprint</p>
</dd>
<dt><code>S</code></dt><dd><p>matrix constructed by evaluating the basis functions at all the data locations (of class <code>Matrix</code>)</p>
</dd>
<dt><code>S0</code></dt><dd><p>matrix constructed by evaluating the basis functions at all BAUs (of class <code>Matrix</code>)</p>
</dd>
<dt><code>D_basis</code></dt><dd><p>list of distance-matrices of class <code>Matrix</code>, one for each basis-function resolution</p>
</dd>
<dt><code>Ve</code></dt><dd><p>measurement-error variance-covariance matrix (typically diagonal and of class <code>Matrix</code>)</p>
</dd>
<dt><code>Vfs</code></dt><dd><p>fine-scale variance-covariance matrix at the data locations (typically diagonal and of class <code>Matrix</code>) up to a constant of proportionality estimated using the EM algorithm</p>
</dd>
<dt><code>Vfs_BAUs</code></dt><dd><p>fine-scale variance-covariance matrix at the BAU centroids (typically diagonal and of class <code>Matrix</code>) up to a constant of proportionality estimated using the EM algorithm</p>
</dd>
<dt><code>Qfs_BAUs</code></dt><dd><p>fine-scale precision matrix at the BAU centroids (typically diagonal and of class <code>Matrix</code>) up to a constant of proportionality estimated using the EM algorithm</p>
</dd>
<dt><code>Z</code></dt><dd><p>vector of observations (of class <code>Matrix</code>)</p>
</dd>
<dt><code>Cmat</code></dt><dd><p>incidence matrix mapping the observations to the BAUs</p>
</dd>
<dt><code>X</code></dt><dd><p>design matrix of covariates at all the data locations</p>
</dd>
<dt><code>G</code></dt><dd><p>list of objects of class Matrix containing the design matrices for random effects at all the data locations</p>
</dd>
<dt><code>G0</code></dt><dd><p>list of objects of class Matrix containing the design matrices for random effects at all BAUs</p>
</dd>
<dt><code>K_type</code></dt><dd><p>type of prior covariance matrix of random effects. Can be &quot;block-exponential&quot; (correlation between effects decays as a function of distance between the basis-function centroids), &quot;unstructured&quot; (all elements in <code>K</code> are unknown and need to be estimated), or &quot;neighbour&quot; (a sparse precision matrix is used, whereby only neighbouring basis functions have non-zero precision matrix elements).</p>
</dd>
<dt><code>mu_eta</code></dt><dd><p>updated expectation of the basis-function random effects (estimated)</p>
</dd>
<dt><code>mu_gamma</code></dt><dd><p>updated expectation of the random effects (estimated)</p>
</dd>
<dt><code>S_eta</code></dt><dd><p>updated covariance matrix of random effects (estimated)</p>
</dd>
<dt><code>Q_eta</code></dt><dd><p>updated precision matrix of random effects (estimated)</p>
</dd>
<dt><code>Khat</code></dt><dd><p>prior covariance matrix of random effects (estimated)</p>
</dd>
<dt><code>Khat_inv</code></dt><dd><p>prior precision matrix of random effects (estimated)</p>
</dd>
<dt><code>alphahat</code></dt><dd><p>fixed-effect regression coefficients (estimated)</p>
</dd>
<dt><code>sigma2fshat</code></dt><dd><p>fine-scale variation scaling (estimated)</p>
</dd>
<dt><code>sigma2gamma</code></dt><dd><p>random-effect variance parameters (estimated)</p>
</dd>
<dt><code>fs_model</code></dt><dd><p>type of fine-scale variation (independent or CAR-based). Currently only &quot;ind&quot; is permitted</p>
</dd>
<dt><code>info_fit</code></dt><dd><p>information on fitting (convergence etc.)</p>
</dd>
<dt><code>response</code></dt><dd><p>A character string indicating the assumed distribution of the response variable</p>
</dd>
<dt><code>link</code></dt><dd><p>A character string indicating the desired link function. Can be &quot;log&quot;, &quot;identity&quot;, &quot;logit&quot;, &quot;probit&quot;, &quot;cloglog&quot;, &quot;reciprocal&quot;, or &quot;reciprocal-squared&quot;. Note that only sensible link-function and response-distribution combinations are permitted.</p>
</dd>
<dt><code>mu_xi</code></dt><dd><p>updated expectation of the fine-scale random effects at all BAUs (estimated)</p>
</dd>
<dt><code>Q_posterior</code></dt><dd><p>updated joint precision matrix of the basis function random effects and observed fine-scale random effects (estimated)</p>
</dd>
<dt><code>log_likelihood</code></dt><dd><p>the log likelihood of the fitted model</p>
</dd>
<dt><code>method</code></dt><dd><p>the fitting procedure used to fit the SRE model</p>
</dd>
<dt><code>phi</code></dt><dd><p>the estimated dispersion parameter (assumed constant throughout the spatial domain)</p>
</dd>
<dt><code>k_Z</code></dt><dd><p>vector of known size parameters at the observation support level (only applicable to binomial and negative-binomial response distributions)</p>
</dd>
<dt><code>k_BAU</code></dt><dd><p>vector of known size parameters at the observed BAUs (only applicable to binomial and negative-binomial response distributions)</p>
</dd>
<dt><code>include_fs</code></dt><dd><p>flag indicating whether the fine-scale variation should be included in the model</p>
</dd>
<dt><code>include_gamma</code></dt><dd><p>flag indicating whether there are gamma random effects in the model</p>
</dd>
<dt><code>normalise_wts</code></dt><dd><p>if <code>TRUE</code>, the rows of the incidence matrices <code class="reqn">C_Z</code> and <code class="reqn">C_P</code> are normalised to sum to 1, so that the mapping represents a weighted average; if false, no normalisation of the weights occurs (i.e., the mapping corresponds to a weighted sum)</p>
</dd>
<dt><code>fs_by_spatial_BAU</code></dt><dd><p>if <code>TRUE</code>, then each BAU is associated with its own fine-scale variance parameter</p>
</dd>
<dt><code>obsidx</code></dt><dd><p>indices of observed BAUs</p>
</dd>
<dt><code>simple_kriging_fixed</code></dt><dd><p>logical indicating whether one wishes to commit to simple kriging at the fitting stage: If <code>TRUE</code>, model fitting is faster, but the option to conduct universal kriging at the prediction stage is removed</p>
</dd>
</dl>


<h3>References</h3>

<p>Zammit-Mangion, A. and Cressie, N. (2017). FRK: An R package for spatial and spatio-temporal prediction with large datasets. Journal of Statistical Software, 98(4), 1-48. doi:10.18637/jss.v098.i04.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SRE">SRE</a></code> for details on how to construct and fit SRE models.
</p>

<hr>
<h2 id='SRE.predict'>Deprecated: Please use <code><a href="stats.html#topic+predict">predict</a></code></h2><span id='topic+SRE.predict'></span>

<h3>Description</h3>

<p>Deprecated: Please use <code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SRE.predict(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SRE.predict_+3A_...">...</code></td>
<td>
<p>(Deprecated)</p>
</td></tr>
</table>

<hr>
<h2 id='STplane'>plane in space-time</h2><span id='topic+STplane'></span>

<h3>Description</h3>

<p>Initialisation of a 2D plane with a temporal dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STplane(measure = Euclid_dist(dim = 3L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STplane_+3A_measure">measure</code></td>
<td>
<p>an object of class <code>measure</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 2D plane with a time component added is initialised using a <code>measure</code> object. By default, the measure object (<code>measure</code>) is the Euclidean distance in 3 dimensions, <a href="#topic+Euclid_dist">Euclid_dist</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- STplane()
print(type(P))
print(sp::dimensions(P))
</code></pre>

<hr>
<h2 id='STsphere'>Space-time sphere</h2><span id='topic+STsphere'></span>

<h3>Description</h3>

<p>Initialisation of a 2-sphere (S2) with a temporal dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STsphere(radius = 6371)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STsphere_+3A_radius">radius</code></td>
<td>
<p>radius of sphere</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As with the spatial-only sphere, the sphere surface is initialised using a <code>radius</code> parameter. The default value of the radius <code>R</code> is <code>R</code>=6371, which is the Earth's radius in km, while the measure used to compute distances on the sphere is the great-circle distance on a sphere of radius <code>R</code>. By default Euclidean geometry is used to factor in the time component, so that dist((s1,t1),(s2,t2)) = sqrt(gc_dist(s1,s2)^2 + (t1 - t2)^2). Frequently this distance can be used since separate correlation length scales for space and time  are estimated in the EM algorithm (that effectively scale space and time separately).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- STsphere()
print(sp::dimensions(S))
</code></pre>

<hr>
<h2 id='TensorP'>Tensor product of basis functions</h2><span id='topic+TensorP'></span><span id='topic+TensorP+2CBasis+2CBasis-method'></span><span id='topic+TensorP+2CBasis-Basis-method'></span>

<h3>Description</h3>

<p>Constructs a new set of basis functions by finding the tensor product of two sets of basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TensorP(Basis1, Basis2)

## S4 method for signature 'Basis,Basis'
TensorP(Basis1, Basis2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TensorP_+3A_basis1">Basis1</code></td>
<td>
<p>first set of basis functions</p>
</td></tr>
<tr><td><code id="TensorP_+3A_basis2">Basis2</code></td>
<td>
<p>second set of basis functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+auto_basis">auto_basis</a></code> for automatically constructing basis functions and <code><a href="#topic+show_basis">show_basis</a></code> for visualising basis functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(spacetime)
library(sp)
library(dplyr)
sim_data &lt;- data.frame(lon = runif(20,-180,180),
                       lat = runif(20,-90,90),
                       t = 1:20,
                       z = rnorm(20),
                       std = 0.1)
time &lt;- as.POSIXct("2003-05-01",tz="") + 3600*24*(sim_data$t-1)
space &lt;- sim_data[,c("lon","lat")]
coordinates(space) = ~lon+lat # change into an sp object
slot(space, "proj4string") = CRS("+proj=longlat +ellps=sphere")
STobj &lt;- STIDF(space,time,data=sim_data)
G_spatial &lt;- auto_basis(manifold = sphere(),
                        data=as(STobj,"Spatial"),
                        nres = 1,
                        type = "bisquare",
                        subsamp = 20000)
G_temporal &lt;- local_basis(manifold=real_line(),loc = matrix(c(1,3)),scale = rep(1,2))
G &lt;- TensorP(G_spatial,G_temporal)
# show_basis(G_spatial)
# show_basis(G_temporal)
</code></pre>

<hr>
<h2 id='type'>Type of manifold</h2><span id='topic+type'></span><span id='topic+type+2Cmanifold-method'></span>

<h3>Description</h3>

<p>Retrieve slot <code>type</code> from object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type(.Object)

## S4 method for signature 'manifold'
type(.Object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="type_+3A_.object">.Object</code></td>
<td>
<p>object of class <code>Basis</code> or <code>manifold</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+real_line">real_line</a></code>, <code><a href="#topic+plane">plane</a></code>, <code><a href="#topic+sphere">sphere</a></code>, <code><a href="#topic+STplane">STplane</a></code> and <code><a href="#topic+STsphere">STsphere</a></code> for constructing manifolds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- sphere()
print(type(S))
</code></pre>

<hr>
<h2 id='worldmap'>World map</h2><span id='topic+worldmap'></span>

<h3>Description</h3>

<p>This world map was extracted from the package <code>maps</code> v.3.0.1 by
running <code>ggplot2::map_data("world")</code>. To reduce the data size, only every third point of
this data frame is contained in <code>worldmap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worldmap
</code></pre>


<h3>Format</h3>

<p>A data frame with 33971 rows and 6 variables:
</p>

<dl>
<dt>long</dt><dd><p>longitude coordinate</p>
</dd>
<dt>lat</dt><dd><p>latitude coordinate</p>
</dd>
<dt>group</dt><dd><p>polygon (region) number</p>
</dd>
<dt>order</dt><dd><p>order of point in polygon boundary</p>
</dd>
<dt>region</dt><dd><p>region name</p>
</dd>
<dt>subregion</dt><dd><p>subregion name</p>
</dd>
</dl>



<h3>References</h3>

<p>Original S code by Becker, R.A. and Wilks, R.A. This R version is by
Brownrigg, R. Enhancements have been made by Minka, T.P. and Deckmyn, A. (2015)
maps: Draw Geographical Maps, R package version 3.0.1.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
