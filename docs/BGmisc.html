<!DOCTYPE html><html lang="en-US"><head><title>Help for package BGmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BGmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BGmisc-package'><p>BGmisc: An R Package for Extended Behavior Genetics Analysis</p></a></li>
<li><a href='#adjustKidsPerCouple'><p>Generate or Adjust Number of Kids per Couple Based on Mating Rate</p></a></li>
<li><a href='#allGens'><p>allGens</p>
A function to calculate the number of individuals in each generation. This is a supporting function for <code>simulatePedigree</code>.</a></li>
<li><a href='#assignCoupleIds'><p>Assign Couple IDs</p></a></li>
<li><a href='#assignParentIDs'><p>Assign momID and dadID based on family mapping</p></a></li>
<li><a href='#buildBetweenGenerations'><p>Process Generation Connections</p></a></li>
<li><a href='#buildWithinGenerations'><p>Process Generations for Pedigree Simulation</p></a></li>
<li><a href='#calculateH'><p>Falconer's Formula</p></a></li>
<li><a href='#calculateRelatedness'><p>Calculate Relatedness Coefficient</p></a></li>
<li><a href='#calculateSummaryDT'><p>This function calculates summary statistics for all numeric variables in a data.table. It is supposed to be used internally by the <code>summarize_pedigree</code> function.</p></a></li>
<li><a href='#checkIDs'><p>Validates and Optionally Repairs Unique IDs in a Pedigree Dataframe</p></a></li>
<li><a href='#checkSex'><p>Validates and Optionally Repairs Sex Coding in a Pedigree Dataframe</p></a></li>
<li><a href='#combine_columns'><p>Combine Columns</p></a></li>
<li><a href='#comp2vech'><p>comp2vech</p>
Turn a variance component relatedness matrix into its half-vectorization</a></li>
<li><a href='#compute_transpose'><p>Compute the transpose multiplication for the relatedness matrix</p></a></li>
<li><a href='#countPatternRows'><p>Check for Pattern Rows</p></a></li>
<li><a href='#createFamilyToParentsMapping'><p>Create a mapping of family IDs to parent IDs</p></a></li>
<li><a href='#createGenDataFrame'><p>Create Data Frame for Generation</p></a></li>
<li><a href='#determineSex'><p>Determine Sex of Offspring</p></a></li>
<li><a href='#dropLink'><p>dropLink</p>
A function to drop a person from his/her parents in the simulated pedigree <code>data.frame</code>.
The person can be dropped by specifying his/her ID or by specifying the generation which the randomly to-be-dropped person is in.
The function can separate one pedigree into two pedigrees. Separating into small pieces should be done by running the function multiple times.
This is a supplementary function for <code>simulatePedigree</code>.</a></li>
<li><a href='#efunc'><p>Error Function</p></a></li>
<li><a href='#evenInsert'><p>evenInsert</p>
A function to insert m elements evenly into a length n vector.</a></li>
<li><a href='#extract_info'><p>Extract Information from Line</p></a></li>
<li><a href='#famSizeCal'><p>famSizeCal</p>
A function to calculate the total number of individuals in a pedigree given parameters. This is a supporting function for function <code>simulatePedigree</code></a></li>
<li><a href='#findFounder'><p>This function finds the originating member for each line in a pedigree. It is supposed to be used internally by the <code>summarize_pedigree</code> function.</p></a></li>
<li><a href='#fitComponentModel'><p>fitComponentModel</p>
Fit the estimated variance components of a model to covariance data</a></li>
<li><a href='#hazard'><p>Simulated pedigree with two extended families and an age-related hazard</p></a></li>
<li><a href='#identifyComponentModel'><p>identifyComponentModel</p>
Determine if a variance components model is identified</a></li>
<li><a href='#inbreeding'><p>Artificial pedigree data on eight families with inbreeding</p></a></li>
<li><a href='#inferRelatedness'><p>Infer Relatedness Coefficient</p></a></li>
<li><a href='#makeInbreeding'><p>makeInbreeding</p>
A function to create inbred mates in the simulated pedigree <code>data.frame</code>.
Inbred mates can be created by specifying their IDs or the generation the inbred mate should be created.
When specifying the generation, inbreeding between siblings or 1st cousin needs to be specified.
This is a supplementary function for <code>simulatePedigree</code>.</a></li>
<li><a href='#makeTwins'><p>makeTwins</p>
A function to impute twins in the simulated pedigree <code>data.frame</code>.
Twins can be imputed by specifying their IDs or by specifying the generation the twin should be imputed.
This is a supplementary function for <code>simulatePedigree</code>.</a></li>
<li><a href='#markPotentialChildren'><p>Mark and Assign children</p></a></li>
<li><a href='#Null'><p>Compute the null space of a matrix</p></a></li>
<li><a href='#nullToNA'><p>nullToNA</p></a></li>
<li><a href='#ped2add'><p>Take a pedigree and turn it into an additive genetics relatedness matrix</p></a></li>
<li><a href='#ped2ce'><p>Take a pedigree and turn it into an extended environmental relatedness matrix</p></a></li>
<li><a href='#ped2cn'><p>Take a pedigree and turn it into a common nuclear environmental relatedness matrix</p></a></li>
<li><a href='#ped2com'><p>Take a pedigree and turn it into a relatedness matrix</p></a></li>
<li><a href='#ped2fam'><p>Segment Pedigree into Extended Families</p></a></li>
<li><a href='#ped2graph'><p>Turn a pedigree into a graph</p></a></li>
<li><a href='#ped2maternal'><p>Add a maternal line ID variable to a pedigree</p></a></li>
<li><a href='#ped2mit'><p>Take a pedigree and turn it into a mitochondrial relatedness matrix</p></a></li>
<li><a href='#ped2paternal'><p>Add a paternal line ID variable to a pedigree</p></a></li>
<li><a href='#plotPedigree'><p>plotPedigree</p>
A wrapped function to plot simulated pedigree from function <code>simulatePedigree</code>. This function require the installation of package <code>kinship2</code>.</a></li>
<li><a href='#potter'><p>Fictional pedigree data on a wizarding family</p></a></li>
<li><a href='#processParents'><p>Process parents information</p></a></li>
<li><a href='#readGedcom'><p>Read a GEDCOM File</p></a></li>
<li><a href='#recodeSex'><p>Recodes Sex Variable in a Pedigree Dataframe</p></a></li>
<li><a href='#related_coef'><p>related_coef (Deprecated)</p></a></li>
<li><a href='#relatedness'><p>relatedness (Deprecated)</p></a></li>
<li><a href='#repairIDs'><p>Repair Missing IDs</p></a></li>
<li><a href='#repairSex'><p>Repairs Sex Coding in a Pedigree Dataframe</p></a></li>
<li><a href='#resample'><p>Resample Elements of a Vector</p></a></li>
<li><a href='#rmvn'><p>rmvn</p></a></li>
<li><a href='#SimPed'><p>SimPed (Deprecated)</p></a></li>
<li><a href='#simulatePedigree'><p>Simulate Pedigrees</p>
This function simulates &quot;balanced&quot; pedigrees based on a group of parameters:
1) k - Kids per couple;
2) G - Number of generations;
3) p - Proportion of males in offspring;
4) r - Mating rate.</a></li>
<li><a href='#sizeAllGens'><p>sizeAllGens</p>
An internal supporting function for <code>simulatePedigree</code>.</a></li>
<li><a href='#standardizeColnames'><p>Standardize Column Names in a Dataframe (Internal)</p></a></li>
<li><a href='#summarizeFamilies'><p>Summarize the families in a pedigree</p></a></li>
<li><a href='#summarizeMatrilines'><p>Summarize the maternal lines in a pedigree</p></a></li>
<li><a href='#summarizePatrilines'><p>Summarize the paternal lines in a pedigree</p></a></li>
<li><a href='#summarizePedigrees'><p>Summarize Pedigree Data</p></a></li>
<li><a href='#try_na'><p>modified tryCatch function</p></a></li>
<li><a href='#vech'><p>vech</p>
Create the half-vectorization of a matrix</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>An R Package for Extended Behavior Genetics Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for behavior genetics analysis, 
    including variance component model identification [Hunter et al. (2021) &lt;<a href="https://doi.org/10.1007%2Fs10519-021-10055-x">doi:10.1007/s10519-021-10055-x</a>&gt;],     
    calculation of relatedness coefficients using path-tracing methods 
    [Wright (1922) &lt;<a href="https://doi.org/10.1086%2F279872">doi:10.1086/279872</a>&gt;; McArdle &amp; McDonald (1984) &lt;<a href="https://doi.org/10.1111%2Fj.2044-8317.1984.tb00802.x">doi:10.1111/j.2044-8317.1984.tb00802.x</a>&gt;], 
    inference of relatedness, pedigree conversion, and simulation of multi-generational family data 
    [Lyu et al. (2024) &lt;<a href="https://doi.org/10.1101%2F2024.12.19.629449">doi:10.1101/2024.12.19.629449</a>&gt;]. For a full overview, 
    see Garrison et al. (2025) &lt;<a href="https://doi.org/10.21105%2Fjoss.06203">doi:10.21105/joss.06203</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/R-Computing-Lab/BGmisc/">https://github.com/R-Computing-Lab/BGmisc/</a>,
<a href="https://r-computing-lab.github.io/BGmisc/">https://r-computing-lab.github.io/BGmisc/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/R-Computing-Lab/BGmisc/issues">https://github.com/R-Computing-Lab/BGmisc/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, igraph, kinship2, Matrix, stats, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, EasyMx, knitr, OpenMx, rmarkdown, testthat (&ge; 3.0.0),
tidyverse</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-19 01:19:03 UTC; smaso</td>
</tr>
<tr>
<td>Author:</td>
<td>S. Mason Garrison <a href="https://orcid.org/0000-0002-4804-6003"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Michael D. Hunter <a href="https://orcid.org/0000-0002-3651-6709"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Xuanyu Lyu <a href="https://orcid.org/0000-0002-2841-5529"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Rachel N. Good [ctb],
  Jonathan D. Trattner
    <a href="https://orcid.org/0000-0002-1097-7603"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut] (url:
    https://www.jdtrat.com/),
  S. Alexandra Burt <a href="https://orcid.org/0000-0001-5538-7431"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>S. Mason Garrison &lt;garrissm@wfu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-19 08:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='BGmisc-package'>BGmisc: An R Package for Extended Behavior Genetics Analysis</h2><span id='topic+BGmisc'></span><span id='topic+BGmisc-package'></span>

<h3>Description</h3>

<p>Provides functions for behavior genetics analysis, including variance component model identification [Hunter et al. (2021) <a href="https://doi.org/10.1007/s10519-021-10055-x">doi:10.1007/s10519-021-10055-x</a>], calculation of relatedness coefficients using path-tracing methods [Wright (1922) <a href="https://doi.org/10.1086/279872">doi:10.1086/279872</a>; McArdle &amp; McDonald (1984) <a href="https://doi.org/10.1111/j.2044-8317.1984.tb00802.x">doi:10.1111/j.2044-8317.1984.tb00802.x</a>], inference of relatedness, pedigree conversion, and simulation of multi-generational family data [Lyu et al. (2024) <a href="https://doi.org/10.1101/2024.12.19.629449">doi:10.1101/2024.12.19.629449</a>]. For a full overview, see Garrison et al. (2025) <a href="https://doi.org/10.21105/joss.06203">doi:10.21105/joss.06203</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: S. Mason Garrison <a href="mailto:garrissm@wfu.edu">garrissm@wfu.edu</a> (<a href="https://orcid.org/0000-0002-4804-6003">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Michael D. Hunter (<a href="https://orcid.org/0000-0002-3651-6709">ORCID</a>)
</p>
</li>
<li><p> Xuanyu Lyu (<a href="https://orcid.org/0000-0002-2841-5529">ORCID</a>)
</p>
</li>
<li><p> Jonathan D. Trattner <a href="mailto:code@jdtrat.com">code@jdtrat.com</a> (<a href="https://orcid.org/0000-0002-1097-7603">ORCID</a>) (https://www.jdtrat.com/)
</p>
</li>
<li><p> S. Alexandra Burt (<a href="https://orcid.org/0000-0001-5538-7431">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Rachel N. Good [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/R-Computing-Lab/BGmisc/">https://github.com/R-Computing-Lab/BGmisc/</a>
</p>
</li>
<li> <p><a href="https://r-computing-lab.github.io/BGmisc/">https://r-computing-lab.github.io/BGmisc/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/R-Computing-Lab/BGmisc/issues">https://github.com/R-Computing-Lab/BGmisc/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adjustKidsPerCouple'>Generate or Adjust Number of Kids per Couple Based on Mating Rate</h2><span id='topic+adjustKidsPerCouple'></span>

<h3>Description</h3>

<p>This function generates or adjusts the number of kids per couple in a generation
based on the specified average and whether the count should be randomly determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustKidsPerCouple(nMates, kpc, rd_kpc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjustKidsPerCouple_+3A_nmates">nMates</code></td>
<td>
<p>Integer, the number of mated pairs in the generation.</p>
</td></tr>
<tr><td><code id="adjustKidsPerCouple_+3A_kpc">kpc</code></td>
<td>
<p>Number of kids per couple. An integer &gt;= 2 that determines how many kids each fertilized mated couple will have in the pedigree. Default value is 3. Returns an error when kpc equals 1.</p>
</td></tr>
<tr><td><code id="adjustKidsPerCouple_+3A_rd_kpc">rd_kpc</code></td>
<td>
<p>logical. If TRUE, the number of kids per mate will be randomly generated from a poisson distribution with mean kpc. If FALSE, the number of kids per mate will be fixed at kpc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the generated or adjusted number of kids per couple.
</p>

<hr>
<h2 id='allGens'>allGens
A function to calculate the number of individuals in each generation. This is a supporting function for <code>simulatePedigree</code>.</h2><span id='topic+allGens'></span>

<h3>Description</h3>

<p>allGens
A function to calculate the number of individuals in each generation. This is a supporting function for <code>simulatePedigree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allGens(kpc, Ngen, marR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allGens_+3A_kpc">kpc</code></td>
<td>
<p>Number of kids per couple (integer &gt;= 2).</p>
</td></tr>
<tr><td><code id="allGens_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations (integer &gt;= 1).</p>
</td></tr>
<tr><td><code id="allGens_+3A_marr">marR</code></td>
<td>
<p>Mating rate (numeric value ranging from 0 to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector containing the number of individuals in every generation.
</p>

<hr>
<h2 id='assignCoupleIds'>Assign Couple IDs</h2><span id='topic+assignCoupleIds'></span>

<h3>Description</h3>

<p>This subfunction assigns a unique couple ID to each mated pair in the generation.
Unmated individuals are assigned NA for their couple ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignCoupleIds(df_Ngen)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignCoupleIds_+3A_df_ngen">df_Ngen</code></td>
<td>
<p>The dataframe for the current generation, including columns for individual IDs and spouse IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataframe augmented with a 'coupleId' column, where each mated pair has a unique identifier.
</p>

<hr>
<h2 id='assignParentIDs'>Assign momID and dadID based on family mapping</h2><span id='topic+assignParentIDs'></span>

<h3>Description</h3>

<p>This function assigns mother and father IDs to individuals in the data frame
based on the mapping of family IDs to parent IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignParentIDs(df_temp, family_to_parents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignParentIDs_+3A_df_temp">df_temp</code></td>
<td>
<p>A data frame containing individual information.</p>
</td></tr>
<tr><td><code id="assignParentIDs_+3A_family_to_parents">family_to_parents</code></td>
<td>
<p>A list mapping family IDs to parent IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with added momID and dad_ID columns.
</p>

<hr>
<h2 id='buildBetweenGenerations'>Process Generation Connections</h2><span id='topic+buildBetweenGenerations'></span>

<h3>Description</h3>

<p>This function processes connections between each two generations in a pedigree simulation.
It marks individuals as parents, sons, or daughters based on their generational position and relationships.
The function also handles the assignment of couple IDs, manages single and coupled individuals,
and establishes parent-offspring links across generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildBetweenGenerations(
  df_Fam,
  Ngen,
  sizeGens,
  verbose,
  marR,
  sexR,
  kpc,
  rd_kpc
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildBetweenGenerations_+3A_df_fam">df_Fam</code></td>
<td>
<p>A data frame containing the simulated pedigree information up to the current generation.
Must include columns for family ID, individual ID, generation number, spouse ID (spID),
and sex. This data frame is updated in place to include flags for parental status (ifparent),
son status (ifson), and daughter status (ifdau), as well as couple IDs.</p>
</td></tr>
<tr><td><code id="buildBetweenGenerations_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations. An integer &gt;= 2 that determines how many generations the simulated pedigree will have. The first generation is always a fertilized couple. The last generation has no mated individuals.</p>
</td></tr>
<tr><td><code id="buildBetweenGenerations_+3A_sizegens">sizeGens</code></td>
<td>
<p>A numeric vector containing the sizes of each generation within the pedigree.</p>
</td></tr>
<tr><td><code id="buildBetweenGenerations_+3A_verbose">verbose</code></td>
<td>
<p>logical  If TRUE, print progress through stages of algorithm</p>
</td></tr>
<tr><td><code id="buildBetweenGenerations_+3A_marr">marR</code></td>
<td>
<p>Mating rate. A numeric value ranging from 0 to 1 which determines the proportion of mated (fertilized) couples in the pedigree within each generation. For instance, marR = 0.5 suggests 50 percent of the offspring in a specific generation will be mated and have their offspring.</p>
</td></tr>
<tr><td><code id="buildBetweenGenerations_+3A_sexr">sexR</code></td>
<td>
<p>Sex ratio of offspring. A numeric value ranging from 0 to 1 that determines the proportion of males in all offspring in this pedigree. For instance, 0.4 means 40 percent of the offspring will be male.</p>
</td></tr>
<tr><td><code id="buildBetweenGenerations_+3A_kpc">kpc</code></td>
<td>
<p>Number of kids per couple. An integer &gt;= 2 that determines how many kids each fertilized mated couple will have in the pedigree. Default value is 3. Returns an error when kpc equals 1.</p>
</td></tr>
<tr><td><code id="buildBetweenGenerations_+3A_rd_kpc">rd_kpc</code></td>
<td>
<p>logical. If TRUE, the number of kids per mate will be randomly generated from a poisson distribution with mean kpc. If FALSE, the number of kids per mate will be fixed at kpc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function iterates through each generation, starting from the second, to establish connections based on mating and parentage.
For the first generation, it sets the parental status directly. For subsequent generations, it calculates the number of couples,
the expected number of offspring, and assigns offspring to parents. It handles gender-based assignments for sons and daughters,
and deals with the nuances of single individuals and couple formation. The function relies on external functions 'assignCoupleIds'
and 'adjustKidsPerCouple' to handle specific tasks related to couple ID assignment and offspring number adjustments, respectively.
</p>


<h3>Value</h3>

<p>The function updates the 'df_Fam' data frame in place, adding or modifying columns related to parental and offspring status,
as well as assigning unique couple IDs. It does not return a value explicitly.
</p>

<hr>
<h2 id='buildWithinGenerations'>Process Generations for Pedigree Simulation</h2><span id='topic+buildWithinGenerations'></span>

<h3>Description</h3>

<p>This function iterates through generations in a pedigree simulation, assigning IDs,
creating data frames, determining sexes, and managing pairing within each generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildWithinGenerations(sizeGens, marR, sexR, Ngen)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildWithinGenerations_+3A_sizegens">sizeGens</code></td>
<td>
<p>A numeric vector containing the sizes of each generation within the pedigree.</p>
</td></tr>
<tr><td><code id="buildWithinGenerations_+3A_marr">marR</code></td>
<td>
<p>Mating rate. A numeric value ranging from 0 to 1 which determines the proportion of mated (fertilized) couples in the pedigree within each generation. For instance, marR = 0.5 suggests 50 percent of the offspring in a specific generation will be mated and have their offspring.</p>
</td></tr>
<tr><td><code id="buildWithinGenerations_+3A_sexr">sexR</code></td>
<td>
<p>Sex ratio of offspring. A numeric value ranging from 0 to 1 that determines the proportion of males in all offspring in this pedigree. For instance, 0.4 means 40 percent of the offspring will be male.</p>
</td></tr>
<tr><td><code id="buildWithinGenerations_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations. An integer &gt;= 2 that determines how many generations the simulated pedigree will have. The first generation is always a fertilized couple. The last generation has no mated individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame representing the simulated pedigree, including columns for family ID ('fam'),
</p>

<hr>
<h2 id='calculateH'>Falconer's Formula</h2><span id='topic+calculateH'></span>

<h3>Description</h3>

<p>Use Falconer's formula to solve for H using the observed correlations for two groups of any two levels of relatednesses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateH(r1, r2, obsR1, obsR2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateH_+3A_r1">r1</code></td>
<td>
<p>Relatedness coefficient of the first group.</p>
</td></tr>
<tr><td><code id="calculateH_+3A_r2">r2</code></td>
<td>
<p>Relatedness coefficient of the second group.</p>
</td></tr>
<tr><td><code id="calculateH_+3A_obsr1">obsR1</code></td>
<td>
<p>Observed correlation between members of the first group.</p>
</td></tr>
<tr><td><code id="calculateH_+3A_obsr2">obsR2</code></td>
<td>
<p>Observed correlation between members of the second group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This generalization of Falconer's formula provides a method to calculate heritability by using the observed correlations for two groups of any two relatednesses.
This function solves for H using the formula:
</p>
<p style="text-align: center;"><code class="reqn">H^2 = \frac{obsR1 - obsR2}{r1 - r2}</code>
</p>

<p>where r1 and r2 are the relatedness coefficients for the first and second group, respectively, and obsR1 and obsR2 are the observed correlations.
</p>


<h3>Value</h3>

<p>Heritability estimates ('heritability_estimates').
</p>

<hr>
<h2 id='calculateRelatedness'>Calculate Relatedness Coefficient</h2><span id='topic+calculateRelatedness'></span>

<h3>Description</h3>

<p>This function calculates the relatedness coefficient between two individuals based on their shared ancestry, as described by Wright (1922).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateRelatedness(
  generations = 2,
  path = NULL,
  full = TRUE,
  maternal = FALSE,
  empirical = FALSE,
  segregating = TRUE,
  total_a = 6800 * 1e+06,
  total_m = 16500,
  weight_a = 1,
  weight_m = 1,
  denom_m = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateRelatedness_+3A_generations">generations</code></td>
<td>
<p>Number of generations back of common ancestors the pair share.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_path">path</code></td>
<td>
<p>Traditional method to count common ancestry, which is twice the number of generations removed from common ancestors. If not provided, it is calculated as 2*generations.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_full">full</code></td>
<td>
<p>Logical. Indicates if the kin share both parents at the common ancestor's generation. Default is TRUE.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_maternal">maternal</code></td>
<td>
<p>Logical. Indicates if the maternal lineage should be considered in the calculation.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_empirical">empirical</code></td>
<td>
<p>Logical. Adjusts the coefficient based on empirical data, using the total number of nucleotides and other parameters.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_segregating">segregating</code></td>
<td>
<p>Logical. Adjusts for segregating genes.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_total_a">total_a</code></td>
<td>
<p>Numeric. Represents the total size of the autosomal genome in terms of nucleotides, used in empirical adjustment. Default is 6800*1000000.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_total_m">total_m</code></td>
<td>
<p>Numeric. Represents the total size of the mitochondrial genome in terms of nucleotides, used in empirical adjustment. Default is 16500.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_weight_a">weight_a</code></td>
<td>
<p>Numeric. Represents the weight of phenotypic influence from additive genetic variance, used in empirical adjustment.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_weight_m">weight_m</code></td>
<td>
<p>Numeric. Represents the weight of phenotypic influence from mitochondrial effects, used in empirical adjustment.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_denom_m">denom_m</code></td>
<td>
<p>Logical. Indicates if 'total_m' and 'weight_m' should be included in the denominator of the empirical adjustment calculation.</p>
</td></tr>
<tr><td><code id="calculateRelatedness_+3A_...">...</code></td>
<td>
<p>Further named arguments that may be passed to another function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relatedness coefficient between two people (b &amp; c) is defined in relation to their common ancestors:
<code class="reqn">r_{bc} = \sum \left(\frac{1}{2}\right)^{n+n'+1} (1+f_a)</code>
</p>


<h3>Value</h3>

<p>Relatedness Coefficient ('coef'): A measure of the genetic relationship between two individuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# For full siblings, the relatedness coefficient is expected to be 0.5:
calculateRelatedness(generations = 1, full = TRUE)
# For half siblings, the relatedness coefficient is expected to be 0.25:
calculateRelatedness(generations = 1, full = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='calculateSummaryDT'>This function calculates summary statistics for all numeric variables in a data.table. It is supposed to be used internally by the <code>summarize_pedigree</code> function.</h2><span id='topic+calculateSummaryDT'></span>

<h3>Description</h3>

<p>This function calculates summary statistics for all numeric variables in a data.table. It is supposed to be used internally by the <code>summarize_pedigree</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateSummaryDT(data, group_var, skip_var, five_num_summary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateSummaryDT_+3A_data">data</code></td>
<td>
<p>A data.table containing the pedigree data.</p>
</td></tr>
<tr><td><code id="calculateSummaryDT_+3A_group_var">group_var</code></td>
<td>
<p>A character string specifying the column name of the grouping variable.</p>
</td></tr>
<tr><td><code id="calculateSummaryDT_+3A_skip_var">skip_var</code></td>
<td>
<p>Character vector. Variables to exclude from summary calculations.</p>
</td></tr>
<tr><td><code id="calculateSummaryDT_+3A_five_num_summary">five_num_summary</code></td>
<td>
<p>Logical. If 'TRUE', includes the first quartile (Q1) and third quartile (Q3) in addition to
the minimum, median, and maximum values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the summary statistics for all numeric variables.
</p>

<hr>
<h2 id='checkIDs'>Validates and Optionally Repairs Unique IDs in a Pedigree Dataframe</h2><span id='topic+checkIDs'></span>

<h3>Description</h3>

<p>This function takes a pedigree object and performs two main tasks:
1. Checks for the uniqueness of individual IDs.
2. Optionally repairs non-unique IDs based on a specified logic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIDs(ped, verbose = FALSE, repair = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkIDs_+3A_ped">ped</code></td>
<td>
<p>A dataframe representing the pedigree data with columns 'ID', 'dadID', and 'momID'.</p>
</td></tr>
<tr><td><code id="checkIDs_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag indicating whether to print progress and validation messages to the console.</p>
</td></tr>
<tr><td><code id="checkIDs_+3A_repair">repair</code></td>
<td>
<p>A logical flag indicating whether to attempt repairs on non-unique IDs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on 'repair' value, either returns a list containing validation results or a repaired dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ped &lt;- data.frame(ID = c(1, 2, 2, 3), dadID = c(NA, 1, 1, 2), momID = c(NA, NA, 2, 2))
checkIDs(ped, verbose = TRUE, repair = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='checkSex'>Validates and Optionally Repairs Sex Coding in a Pedigree Dataframe</h2><span id='topic+checkSex'></span>

<h3>Description</h3>

<p>This function checks and optionally modifies the coding of the biological 'sex' variable in a pedigree dataset.
It serves two primary purposes:
1. Recodes the 'sex' variable based on specified codes for males and females, if provided.
2. Identifies and optionally repairs inconsistencies in sex coding that could break the algorithm for constructing genetic pedigrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkSex(
  ped,
  code_male = NULL,
  code_female = NULL,
  verbose = FALSE,
  repair = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkSex_+3A_ped">ped</code></td>
<td>
<p>A dataframe representing the pedigree data with a 'sex' column.</p>
</td></tr>
<tr><td><code id="checkSex_+3A_code_male">code_male</code></td>
<td>
<p>The current code used to represent males in the 'sex' column.</p>
</td></tr>
<tr><td><code id="checkSex_+3A_code_female">code_female</code></td>
<td>
<p>The current code used to represent females in the 'sex' column. If both are NULL, no recoding is performed.</p>
</td></tr>
<tr><td><code id="checkSex_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag indicating whether to print progress and validation messages to the console.</p>
</td></tr>
<tr><td><code id="checkSex_+3A_repair">repair</code></td>
<td>
<p>A logical flag indicating whether to attempt repairs on the sex coding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The validation process identifies:
- The unique sex codes present in the dataset.
- Whether individuals listed as fathers or mothers have inconsistent sex codes.
- Instances where an individual's recorded sex does not align with their parental role.
</p>
<p>If 'repair = TRUE', the function standardizes sex coding by:
- Assigning individuals listed as fathers the most common male code in the dataset.
- Assigning individuals listed as mothers the most common female code.
</p>
<p>This function uses the terms 'male' and 'female' in a biological context, referring to chromosomal and other biologically-based characteristics necessary for constructing genetic pedigrees. The biological aspect of sex used in genetic analysis (genotype) is distinct from the broader, richer concept of gender identity (phenotype).
</p>
<p>We recognize the importance of using language and methodologies that affirm and respect the full spectrum of gender identities.  The developers of this
package express unequivocal support for folx in the transgender
and LGBTQ+ communities.
</p>


<h3>Value</h3>

<p>Depending on the value of 'repair', either a list containing validation results or a repaired dataframe is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ped &lt;- data.frame(ID = c(1, 2, 3), sex = c("M", "F", "M"))
checkSex(ped, code_male = "M", verbose = TRUE, repair = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='combine_columns'>Combine Columns</h2><span id='topic+combine_columns'></span>

<h3>Description</h3>

<p>This function combines two columns, handling conflicts and merging non-conflicting data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_columns(col1, col2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_columns_+3A_col1">col1</code></td>
<td>
<p>The first column to combine.</p>
</td></tr>
<tr><td><code id="combine_columns_+3A_col2">col2</code></td>
<td>
<p>The second column to combine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the combined column and a flag indicating if the second column should be retained.
</p>

<hr>
<h2 id='comp2vech'>comp2vech
Turn a variance component relatedness matrix into its half-vectorization</h2><span id='topic+comp2vech'></span>

<h3>Description</h3>

<p>comp2vech
Turn a variance component relatedness matrix into its half-vectorization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp2vech(x, include.zeros = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comp2vech_+3A_x">x</code></td>
<td>
<p>Relatedness component matrix (can be a matrix, list, or object that inherits from 'Matrix').</p>
</td></tr>
<tr><td><code id="comp2vech_+3A_include.zeros">include.zeros</code></td>
<td>
<p>logical. Whether to include all-zero rows. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the <code>vech</code> function, extending it to allow for blockwise matrices and specific classes.
It facilitates the conversion of a variance component relatedness matrix into a half-vectorized form.
</p>


<h3>Value</h3>

<p>The half-vectorization of the relatedness component matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp2vech(list(matrix(c(1, .5, .5, 1), 2, 2), matrix(1, 2, 2)))

</code></pre>

<hr>
<h2 id='compute_transpose'>Compute the transpose multiplication for the relatedness matrix</h2><span id='topic+compute_transpose'></span>

<h3>Description</h3>

<p>Compute the transpose multiplication for the relatedness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_transpose(r2, transpose_method = "tcrossprod", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_transpose_+3A_r2">r2</code></td>
<td>
<p>a relatedness matrix</p>
</td></tr>
<tr><td><code id="compute_transpose_+3A_transpose_method">transpose_method</code></td>
<td>
<p>character. The method to use for computing the transpose.  Options are &quot;tcrossprod&quot;, &quot;crossprod&quot;, or &quot;star&quot;</p>
</td></tr>
<tr><td><code id="compute_transpose_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, print progress through stages of algorithm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms and methodologies used in this function are further discussed and exemplified in the vignette titled &quot;examplePedigreeFunctions&quot;. For more advanced scenarios and detailed explanations, consult this vignette.
</p>

<hr>
<h2 id='countPatternRows'>Check for Pattern Rows</h2><span id='topic+countPatternRows'></span>

<h3>Description</h3>

<p>This function counts the number of rows containing specific patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countPatternRows(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="countPatternRows_+3A_file">file</code></td>
<td>
<p>A data frame containing the GEDCOM file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the number of rows containing each pattern.
</p>

<hr>
<h2 id='createFamilyToParentsMapping'>Create a mapping of family IDs to parent IDs</h2><span id='topic+createFamilyToParentsMapping'></span>

<h3>Description</h3>

<p>This function creates a mapping from family IDs to the IDs of the parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createFamilyToParentsMapping(df_temp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createFamilyToParentsMapping_+3A_df_temp">df_temp</code></td>
<td>
<p>A data frame containing information about individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list mapping family IDs to parent IDs.
</p>

<hr>
<h2 id='createGenDataFrame'>Create Data Frame for Generation</h2><span id='topic+createGenDataFrame'></span>

<h3>Description</h3>

<p>This function creates a data frame for a specific generation within the simulated pedigree.
It initializes the data frame with default values for family ID, individual ID, generation number,
paternal ID, maternal ID, spouse ID, and sex. All individuals are initially set with NA for paternal,
maternal, spouse IDs, and sex, awaiting further assignment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGenDataFrame(sizeGens, genIndex, idGen)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createGenDataFrame_+3A_sizegens">sizeGens</code></td>
<td>
<p>A numeric vector containing the sizes of each generation within the pedigree.</p>
</td></tr>
<tr><td><code id="createGenDataFrame_+3A_genindex">genIndex</code></td>
<td>
<p>An integer representing the current generation index for which the data frame is being created.</p>
</td></tr>
<tr><td><code id="createGenDataFrame_+3A_idgen">idGen</code></td>
<td>
<p>A numeric vector containing the ID numbers to be assigned to individuals in the current generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame representing the initial structure for the individuals in the specified generation
before any relationships (parental, spousal) are defined. The columns include family ID ('fam'),
individual ID (&lsquo;id'), generation number ('gen'), father&rsquo;s ID (&lsquo;pat'), mother&rsquo;s ID ('mat'),
spouse's ID ('spID'), and sex ('sex'), with NA values for paternal, maternal, and spouse IDs, and sex.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sizeGens &lt;- c(3, 5, 4) # Example sizes for 3 generations
genIndex &lt;- 2 # Creating data frame for the 2nd generation
idGen &lt;- 101:105 # Example IDs for the 2nd generation
df_Ngen &lt;- createGenDataFrame(sizeGens, genIndex, idGen)
print(df_Ngen)
</code></pre>

<hr>
<h2 id='determineSex'>Determine Sex of Offspring</h2><span id='topic+determineSex'></span>

<h3>Description</h3>

<p>This internal function assigns sexes to the offspring in a generation based on the specified sex ratio.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determineSex(idGen, sexR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="determineSex_+3A_idgen">idGen</code></td>
<td>
<p>Vector of IDs for the generation.</p>
</td></tr>
<tr><td><code id="determineSex_+3A_sexr">sexR</code></td>
<td>
<p>Numeric value indicating the sex ratio (proportion of males).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of sexes (&quot;M&quot; for male, &quot;F&quot; for female) for the offspring.
</p>

<hr>
<h2 id='dropLink'>dropLink
A function to drop a person from his/her parents in the simulated pedigree <code>data.frame</code>.
The person can be dropped by specifying his/her ID or by specifying the generation which the randomly to-be-dropped person is in.
The function can separate one pedigree into two pedigrees. Separating into small pieces should be done by running the function multiple times.
This is a supplementary function for <code>simulatePedigree</code>.</h2><span id='topic+dropLink'></span>

<h3>Description</h3>

<p>dropLink
A function to drop a person from his/her parents in the simulated pedigree <code>data.frame</code>.
The person can be dropped by specifying his/her ID or by specifying the generation which the randomly to-be-dropped person is in.
The function can separate one pedigree into two pedigrees. Separating into small pieces should be done by running the function multiple times.
This is a supplementary function for <code>simulatePedigree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropLink(
  ped,
  ID_drop = NA_integer_,
  gen_drop = 2,
  sex_drop = NA_character_,
  n_drop = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropLink_+3A_ped">ped</code></td>
<td>
<p>a pedigree simulated from simulatePedigree function or the same format</p>
</td></tr>
<tr><td><code id="dropLink_+3A_id_drop">ID_drop</code></td>
<td>
<p>the ID of the person to be dropped from his/her parents.</p>
</td></tr>
<tr><td><code id="dropLink_+3A_gen_drop">gen_drop</code></td>
<td>
<p>the generation in which the randomly dropped person is. Will work if 'ID_drop' is not specified.</p>
</td></tr>
<tr><td><code id="dropLink_+3A_sex_drop">sex_drop</code></td>
<td>
<p>the biological sex of the randomly dropped person.</p>
</td></tr>
<tr><td><code id="dropLink_+3A_n_drop">n_drop</code></td>
<td>
<p>the number of times the mutation happens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pedigree with the dropped person's 'dadID' and 'momID' set to NA.
</p>

<hr>
<h2 id='efunc'>Error Function</h2><span id='topic+efunc'></span>

<h3>Description</h3>

<p>Error Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efunc(error)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="efunc_+3A_error">error</code></td>
<td>
<p>error output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Replaces error message (<code>error</code>) with NA
</p>

<hr>
<h2 id='evenInsert'>evenInsert
A function to insert m elements evenly into a length n vector.</h2><span id='topic+evenInsert'></span>

<h3>Description</h3>

<p>evenInsert
A function to insert m elements evenly into a length n vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evenInsert(m, n, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evenInsert_+3A_m">m</code></td>
<td>
<p>A numeric vector of length less than or equal to n. The elements to be inserted.</p>
</td></tr>
<tr><td><code id="evenInsert_+3A_n">n</code></td>
<td>
<p>A numeric vector. The vector into which the elements of m will be inserted.</p>
</td></tr>
<tr><td><code id="evenInsert_+3A_verbose">verbose</code></td>
<td>
<p>logical  If TRUE, prints additional information. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes two vectors, m and n, and inserts the elements of m evenly into n.
If the length of m is greater than the length of n, the vectors are swapped, and the insertion proceeds.
The resulting vector is a combination of m and n, with the elements of m evenly distributed within n.
</p>


<h3>Value</h3>

<p>Returns a numeric vector with the elements of m evenly inserted into n.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SimPed">SimPed</a></code> for the main function that uses this supporting function.
</p>

<hr>
<h2 id='extract_info'>Extract Information from Line</h2><span id='topic+extract_info'></span>

<h3>Description</h3>

<p>This function extracts information from a line based on a specified type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_info(line, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_info_+3A_line">line</code></td>
<td>
<p>A character string representing a line from a GEDCOM file.</p>
</td></tr>
<tr><td><code id="extract_info_+3A_type">type</code></td>
<td>
<p>A character string representing the type of information to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with the extracted information.
</p>

<hr>
<h2 id='famSizeCal'>famSizeCal
A function to calculate the total number of individuals in a pedigree given parameters. This is a supporting function for function <code>simulatePedigree</code></h2><span id='topic+famSizeCal'></span>

<h3>Description</h3>

<p>famSizeCal
A function to calculate the total number of individuals in a pedigree given parameters. This is a supporting function for function <code>simulatePedigree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>famSizeCal(kpc, Ngen, marR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="famSizeCal_+3A_kpc">kpc</code></td>
<td>
<p>Number of kids per couple (integer &gt;= 2).</p>
</td></tr>
<tr><td><code id="famSizeCal_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations (integer &gt;= 1).</p>
</td></tr>
<tr><td><code id="famSizeCal_+3A_marr">marR</code></td>
<td>
<p>Mating rate (numeric value ranging from 0 to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric value indicating the total pedigree size.
</p>

<hr>
<h2 id='findFounder'>This function finds the originating member for each line in a pedigree. It is supposed to be used internally by the <code>summarize_pedigree</code> function.</h2><span id='topic+findFounder'></span>

<h3>Description</h3>

<p>This function finds the originating member for each line in a pedigree. It is supposed to be used internally by the <code>summarize_pedigree</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findFounder(data, group_var, sort_var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findFounder_+3A_data">data</code></td>
<td>
<p>A data.table containing the pedigree data.</p>
</td></tr>
<tr><td><code id="findFounder_+3A_sort_var">sort_var</code></td>
<td>
<p>A character string specifying the column name to sort by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table containing the originating member for each line.
</p>

<hr>
<h2 id='fitComponentModel'>fitComponentModel
Fit the estimated variance components of a model to covariance data</h2><span id='topic+fitComponentModel'></span>

<h3>Description</h3>

<p>fitComponentModel
Fit the estimated variance components of a model to covariance data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitComponentModel(covmat, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitComponentModel_+3A_covmat">covmat</code></td>
<td>
<p>The covariance matrix of the raw data, which may be blockwise.</p>
</td></tr>
<tr><td><code id="fitComponentModel_+3A_...">...</code></td>
<td>
<p>Comma-separated relatedness component matrices representing the variance components of the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits the estimated variance components of a model to given covariance data.
The rank of the component matrices is checked to ensure that the variance components are all identified.
Warnings are issued if there are inconsistencies.
</p>


<h3>Value</h3>

<p>A regression (linear model fitted with <code>lm</code>). The coefficients of the regression represent the estimated variance components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# install.packages("OpenMX")
data(twinData, package = "OpenMx")
sellVars &lt;- c("ht1", "ht2")
mzData &lt;- subset(twinData, zyg %in% c(1), c(selVars, "zyg"))
dzData &lt;- subset(twinData, zyg %in% c(3), c(selVars, "zyg"))

fitComponentModel(
  covmat = list(cov(mzData[, selVars], use = "pair"), cov(dzData[, selVars], use = "pair")),
  A = list(matrix(1, nrow = 2, ncol = 2), matrix(c(1, 0.5, 0.5, 1), nrow = 2, ncol = 2)),
  C = list(matrix(1, nrow = 2, ncol = 2), matrix(1, nrow = 2, ncol = 2)),
  E = list(diag(1, nrow = 2), diag(1, nrow = 2))
)

## End(Not run)

</code></pre>

<hr>
<h2 id='hazard'>Simulated pedigree with two extended families and an age-related hazard</h2><span id='topic+hazard'></span>

<h3>Description</h3>

<p>A dataset simulated to have an age-related hazard.
There are two extended families that are sampled from the same population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hazard)
</code></pre>


<h3>Format</h3>

<p>A data frame with 43 rows and 14 variables
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li> <p><code>FamID</code>:  ID of the extended family
</p>
</li>
<li> <p><code>ID</code>:  Person identification variable
</p>
</li>
<li> <p><code>sex</code>:  Sex of the ID: 1 is female; 0 is male
</p>
</li>
<li> <p><code>dadID</code>:  ID of the father
</p>
</li>
<li> <p><code>momID</code>:  ID of the mother
</p>
</li>
<li> <p><code>affected</code>:  logical.  Whether the person is affected or not
</p>
</li>
<li> <p><code>DA1</code>:  Binary variable signifying the meaninglessness of life
</p>
</li>
<li> <p><code>DA2</code>:  Binary variable signifying the fundamental unknowability of existence
</p>
</li>
<li> <p><code>birthYr</code>:  Birth year for person
</p>
</li>
<li> <p><code>onsetYr</code>:  Year of onset for person
</p>
</li>
<li> <p><code>deathYr</code>:  Death year for person
</p>
</li>
<li> <p><code>available</code>:  logical.  Whether
</p>
</li>
<li> <p><code>Gen</code>:  Generation of the person
</p>
</li>
<li> <p><code>proband</code>:  logical.  Whether the person is a proband or not
</p>
</li></ul>


<hr>
<h2 id='identifyComponentModel'>identifyComponentModel
Determine if a variance components model is identified</h2><span id='topic+identifyComponentModel'></span>

<h3>Description</h3>

<p>identifyComponentModel
Determine if a variance components model is identified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identifyComponentModel(..., verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identifyComponentModel_+3A_...">...</code></td>
<td>
<p>Comma-separated relatedness component matrices representing the variance components of the model.</p>
</td></tr>
<tr><td><code id="identifyComponentModel_+3A_verbose">verbose</code></td>
<td>
<p>logical. If FALSE, suppresses messages about identification; TRUE by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the identification status of a given variance components model
by examining the rank of the concatenated matrices of the components.
If any components are not identified, their names are returned in the output.
</p>


<h3>Value</h3>

<p>A list of length 2 containing:
</p>

<ul>
<li> <p><code>identified</code>: TRUE if the model is identified, FALSE otherwise.
</p>
</li>
<li> <p><code>nidp</code>: A vector of non-identified parameters, specifying the names of components that are not simultaneously identified.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
identifyComponentModel(A = list(matrix(1, 2, 2)), C = list(matrix(1, 2, 2)), E = diag(1, 2))

</code></pre>

<hr>
<h2 id='inbreeding'>Artificial pedigree data on eight families with inbreeding</h2><span id='topic+inbreeding'></span>

<h3>Description</h3>

<p>A dataset created purely from imagination that includes several types of inbreeding.
Different kinds of inbreeding occur in each extended family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(inbreeding)
</code></pre>


<h3>Format</h3>

<p>A data frame (and ped object) with 134 rows and 7 variables
</p>


<h3>Details</h3>

<p>The types of inbreeding are as follows:
</p>

<ul>
<li><p> Extended Family 1: Sister wives - Children with the same father and different mothers who are sisters.
</p>
</li>
<li><p> Extended Family 2: Full siblings have children.
</p>
</li>
<li><p> Extended Family 3: Half siblings have children.
</p>
</li>
<li><p> Extended Family 4: First cousins have children.
</p>
</li>
<li><p> Extended Family 5: Father has child with his daughter.
</p>
</li>
<li><p> Extended Family 6: Half sister wives - Children with the same father and different mothers who are half sisters.
</p>
</li>
<li><p> Extended Family 7: Uncle-niece and Aunt-nephew have children.
</p>
</li>
<li><p> Extended Family 8: A father-son pairs has children with a corresponding mother-daughter pair.
</p>
</li></ul>

<p>Although not all of the above structures are technically inbreeding, they aim to test pedigree diagramming and path tracing algorithms.
</p>
<p>The variables are as follows:
</p>

<ul>
<li> <p><code>ID</code>:  Person identification variable
</p>
</li>
<li> <p><code>sex</code>:  Sex of the ID: 1 is female; 0 is male
</p>
</li>
<li> <p><code>dadID</code>:  ID of the father
</p>
</li>
<li> <p><code>momID</code>:  ID of the mother
</p>
</li>
<li> <p><code>FamID</code>:  ID of the extended family
</p>
</li>
<li> <p><code>Gen</code>:  Generation of the person
</p>
</li>
<li> <p><code>proband</code>:  Always FALSE
</p>
</li></ul>


<hr>
<h2 id='inferRelatedness'>Infer Relatedness Coefficient</h2><span id='topic+inferRelatedness'></span>

<h3>Description</h3>

<p>This function infers the relatedness coefficient between two groups based on
the observed correlation between their additive genetic variance and shared environmental variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferRelatedness(obsR, aceA = 0.9, aceC = 0, sharedC = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inferRelatedness_+3A_obsr">obsR</code></td>
<td>
<p>Numeric. Observed correlation between the two groups. Must be between -1 and 1.</p>
</td></tr>
<tr><td><code id="inferRelatedness_+3A_acea">aceA</code></td>
<td>
<p>Numeric. Proportion of variance attributable to additive genetic variance. Must be between 0 and 1. Default is 0.9.</p>
</td></tr>
<tr><td><code id="inferRelatedness_+3A_acec">aceC</code></td>
<td>
<p>Numeric. Proportion of variance attributable to shared environmental variance. Must be between 0 and 1. Default is 0.</p>
</td></tr>
<tr><td><code id="inferRelatedness_+3A_sharedc">sharedC</code></td>
<td>
<p>Numeric. Proportion of shared environment shared between the two individuals. Must be between 0 and 1. Default is 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the ACE (Additive genetic, Common environmental, and Unique environmental) model to infer the relatedness between two individuals or groups.
By considering the observed correlation ('obsR'), the proportion of variance attributable to additive genetic variance ('aceA'), and the proportion of shared environmental variance ('aceC'), it calculates the relatedness coefficient.
</p>


<h3>Value</h3>

<p>Numeric. The calculated relatedness coefficient ('est_r').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Infer the relatedness coefficient:
inferRelatedness(obsR = 0.5, aceA = 0.9, aceC = 0, sharedC = 0)

## End(Not run)
</code></pre>

<hr>
<h2 id='makeInbreeding'>makeInbreeding
A function to create inbred mates in the simulated pedigree <code>data.frame</code>.
Inbred mates can be created by specifying their IDs or the generation the inbred mate should be created.
When specifying the generation, inbreeding between siblings or 1st cousin needs to be specified.
This is a supplementary function for <code>simulatePedigree</code>.</h2><span id='topic+makeInbreeding'></span>

<h3>Description</h3>

<p>makeInbreeding
A function to create inbred mates in the simulated pedigree <code>data.frame</code>.
Inbred mates can be created by specifying their IDs or the generation the inbred mate should be created.
When specifying the generation, inbreeding between siblings or 1st cousin needs to be specified.
This is a supplementary function for <code>simulatePedigree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeInbreeding(
  ped,
  ID_mate1 = NA_integer_,
  ID_mate2 = NA_integer_,
  verbose = FALSE,
  gen_inbred = 2,
  type_inbred = "sib"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeInbreeding_+3A_ped">ped</code></td>
<td>
<p>A <code>data.frame</code> in the same format as the output of <code>simulatePedigree</code>.</p>
</td></tr>
<tr><td><code id="makeInbreeding_+3A_id_mate1">ID_mate1</code></td>
<td>
<p>A vector of <code>ID</code> of the first mate. If not provided, the function will randomly select two individuals from the second generation.</p>
</td></tr>
<tr><td><code id="makeInbreeding_+3A_id_mate2">ID_mate2</code></td>
<td>
<p>A vector of <code>ID</code> of the second mate.</p>
</td></tr>
<tr><td><code id="makeInbreeding_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, print progress through stages of algorithm</p>
</td></tr>
<tr><td><code id="makeInbreeding_+3A_gen_inbred">gen_inbred</code></td>
<td>
<p>A vector of <code>generation</code> of the twin to be imputed.</p>
</td></tr>
<tr><td><code id="makeInbreeding_+3A_type_inbred">type_inbred</code></td>
<td>
<p>A character vector indicating the type of inbreeding. &quot;sib&quot; for sibling inbreeding and &quot;cousin&quot; for cousin inbreeding.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates inbred mates in the simulated pedigree <code>data.frame</code>. This function's purpose is to evaluate the effect of inbreeding on model fitting and parameter estimation. In case it needs to be said, we do not condone inbreeding in real life. But we recognize that it is a common practice in some fields to create inbred strains for research purposes.
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with some inbred mates.
</p>

<hr>
<h2 id='makeTwins'>makeTwins
A function to impute twins in the simulated pedigree <code>data.frame</code>.
Twins can be imputed by specifying their IDs or by specifying the generation the twin should be imputed.
This is a supplementary function for <code>simulatePedigree</code>.</h2><span id='topic+makeTwins'></span>

<h3>Description</h3>

<p>makeTwins
A function to impute twins in the simulated pedigree <code>data.frame</code>.
Twins can be imputed by specifying their IDs or by specifying the generation the twin should be imputed.
This is a supplementary function for <code>simulatePedigree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeTwins(
  ped,
  ID_twin1 = NA_integer_,
  ID_twin2 = NA_integer_,
  gen_twin = 2,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeTwins_+3A_ped">ped</code></td>
<td>
<p>A <code>data.frame</code> in the same format as the output of <code>simulatePedigree</code>.</p>
</td></tr>
<tr><td><code id="makeTwins_+3A_id_twin1">ID_twin1</code></td>
<td>
<p>A vector of <code>ID</code> of the first twin.</p>
</td></tr>
<tr><td><code id="makeTwins_+3A_id_twin2">ID_twin2</code></td>
<td>
<p>A vector of <code>ID</code> of the second twin.</p>
</td></tr>
<tr><td><code id="makeTwins_+3A_gen_twin">gen_twin</code></td>
<td>
<p>A vector of <code>generation</code> of the twin to be imputed.</p>
</td></tr>
<tr><td><code id="makeTwins_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, print progress through stages of algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with MZ twins information added as a new column.
</p>

<hr>
<h2 id='markPotentialChildren'>Mark and Assign children</h2><span id='topic+markPotentialChildren'></span>

<h3>Description</h3>

<p>This subfunction marks individuals in a generation as potential sons, daughters,
or parents based on their relationships and assigns unique couple IDs. It processes
the assignment of roles and relationships within and between generations in a pedigree simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markPotentialChildren(df_Ngen, i, Ngen, sizeGens, CoupleF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="markPotentialChildren_+3A_df_ngen">df_Ngen</code></td>
<td>
<p>A data frame for the current generation being processed.
It must include columns for individual IDs ('id'), spouse IDs ('spID'), sex ('sex'),
and any previously assigned roles ('ifparent', 'ifson', 'ifdau').</p>
</td></tr>
<tr><td><code id="markPotentialChildren_+3A_i">i</code></td>
<td>
<p>Integer, the index of the current generation being processed.</p>
</td></tr>
<tr><td><code id="markPotentialChildren_+3A_ngen">Ngen</code></td>
<td>
<p>Integer, the total number of generations in the simulation.</p>
</td></tr>
<tr><td><code id="markPotentialChildren_+3A_sizegens">sizeGens</code></td>
<td>
<p>Numeric vector, containing the size (number of individuals) of each generation.</p>
</td></tr>
<tr><td><code id="markPotentialChildren_+3A_couplef">CoupleF</code></td>
<td>
<p>Integer, IT MIGHT BE the number of couples in the current generation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modifies 'df_Ngen' in place by updating or adding columns related to individual roles
('ifparent', 'ifson', 'ifdau') and couple IDs ('coupleId'). The updated data frame is
also returned for integration into the larger pedigree data frame ('df_Fam').
</p>

<hr>
<h2 id='Null'>Compute the null space of a matrix</h2><span id='topic+Null'></span>

<h3>Description</h3>

<p>Compute the null space of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Null(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Null_+3A_m">M</code></td>
<td>
<p>a matrix of which the null space is desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method uses the QR factorization to determine a basis for the null
space of a matrix.  This is sometimes also called the orthogonal
complement of a matrix.  As implemented, this function is identical
to the function of the same name in the MASS package.
</p>

<hr>
<h2 id='nullToNA'>nullToNA</h2><span id='topic+nullToNA'></span>

<h3>Description</h3>

<p>nullToNA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nullToNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nullToNA_+3A_x">x</code></td>
<td>
<p>vector of any length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>replaces null values in a vector to NA
</p>

<hr>
<h2 id='ped2add'>Take a pedigree and turn it into an additive genetics relatedness matrix</h2><span id='topic+ped2add'></span>

<h3>Description</h3>

<p>Take a pedigree and turn it into an additive genetics relatedness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2add(
  ped,
  max.gen = 25,
  sparse = FALSE,
  verbose = FALSE,
  gc = FALSE,
  flatten.diag = FALSE,
  standardize.colnames = TRUE,
  transpose_method = "tcrossprod",
  saveable = FALSE,
  resume = FALSE,
  save_rate = 5,
  save_rate_gen = save_rate,
  save_rate_parlist = 1000 * save_rate,
  save_path = "checkpoint/",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2add_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2add_+3A_max.gen">max.gen</code></td>
<td>
<p>the maximum number of generations to compute
(e.g., only up to 4th degree relatives).  The default is 25. However it can be set to infinity.
'Inf' uses as many generations as there are in the data.</p>
</td></tr>
<tr><td><code id="ped2add_+3A_sparse">sparse</code></td>
<td>
<p>logical.  If TRUE, use and return sparse matrices from Matrix package</p>
</td></tr>
<tr><td><code id="ped2add_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, print progress through stages of algorithm</p>
</td></tr>
<tr><td><code id="ped2add_+3A_gc">gc</code></td>
<td>
<p>logical. If TRUE, do frequent garbage collection via <code><a href="base.html#topic+gc">gc</a></code> to save memory</p>
</td></tr>
<tr><td><code id="ped2add_+3A_flatten.diag">flatten.diag</code></td>
<td>
<p>logical. If TRUE, overwrite the diagonal of the final relatedness matrix with ones</p>
</td></tr>
<tr><td><code id="ped2add_+3A_standardize.colnames">standardize.colnames</code></td>
<td>
<p>logical. If TRUE, standardize the column names of the pedigree dataset</p>
</td></tr>
<tr><td><code id="ped2add_+3A_transpose_method">transpose_method</code></td>
<td>
<p>character. The method to use for computing the transpose.  Options are &quot;tcrossprod&quot;, &quot;crossprod&quot;, or &quot;star&quot;</p>
</td></tr>
<tr><td><code id="ped2add_+3A_saveable">saveable</code></td>
<td>
<p>logical. If TRUE, save the intermediate results to disk</p>
</td></tr>
<tr><td><code id="ped2add_+3A_resume">resume</code></td>
<td>
<p>logical. If TRUE, resume from a checkpoint</p>
</td></tr>
<tr><td><code id="ped2add_+3A_save_rate">save_rate</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results</p>
</td></tr>
<tr><td><code id="ped2add_+3A_save_rate_gen">save_rate_gen</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by generation. If NULL, defaults to save_rate</p>
</td></tr>
<tr><td><code id="ped2add_+3A_save_rate_parlist">save_rate_parlist</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by parent list. If NULL, defaults to save_rate*1000</p>
</td></tr>
<tr><td><code id="ped2add_+3A_save_path">save_path</code></td>
<td>
<p>character. The path to save the checkpoint files</p>
</td></tr>
<tr><td><code id="ped2add_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms and methodologies used in this function are further discussed and exemplified in the vignette titled &quot;examplePedigreeFunctions&quot;. For more advanced scenarios and detailed explanations, consult this vignette.
</p>

<hr>
<h2 id='ped2ce'>Take a pedigree and turn it into an extended environmental relatedness matrix</h2><span id='topic+ped2ce'></span>

<h3>Description</h3>

<p>Take a pedigree and turn it into an extended environmental relatedness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2ce(ped, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2ce_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2ce_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms and methodologies used in this function are further discussed and exemplified in the vignette titled &quot;examplePedigreeFunctions&quot;. For more advanced scenarios and detailed explanations, consult this vignette.
</p>

<hr>
<h2 id='ped2cn'>Take a pedigree and turn it into a common nuclear environmental relatedness matrix</h2><span id='topic+ped2cn'></span>

<h3>Description</h3>

<p>Take a pedigree and turn it into a common nuclear environmental relatedness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2cn(
  ped,
  max.gen = 25,
  sparse = FALSE,
  verbose = FALSE,
  gc = FALSE,
  flatten.diag = FALSE,
  standardize.colnames = TRUE,
  transpose_method = "tcrossprod",
  saveable = FALSE,
  resume = FALSE,
  save_rate = 5,
  save_rate_gen = save_rate,
  save_rate_parlist = 1000 * save_rate,
  save_path = "checkpoint/",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2cn_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_max.gen">max.gen</code></td>
<td>
<p>the maximum number of generations to compute
(e.g., only up to 4th degree relatives).  The default is 25. However it can be set to infinity.
'Inf' uses as many generations as there are in the data.</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_sparse">sparse</code></td>
<td>
<p>logical.  If TRUE, use and return sparse matrices from Matrix package</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, print progress through stages of algorithm</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_gc">gc</code></td>
<td>
<p>logical. If TRUE, do frequent garbage collection via <code><a href="base.html#topic+gc">gc</a></code> to save memory</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_flatten.diag">flatten.diag</code></td>
<td>
<p>logical. If TRUE, overwrite the diagonal of the final relatedness matrix with ones</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_standardize.colnames">standardize.colnames</code></td>
<td>
<p>logical. If TRUE, standardize the column names of the pedigree dataset</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_transpose_method">transpose_method</code></td>
<td>
<p>character. The method to use for computing the transpose.  Options are &quot;tcrossprod&quot;, &quot;crossprod&quot;, or &quot;star&quot;</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_saveable">saveable</code></td>
<td>
<p>logical. If TRUE, save the intermediate results to disk</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_resume">resume</code></td>
<td>
<p>logical. If TRUE, resume from a checkpoint</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_save_rate">save_rate</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_save_rate_gen">save_rate_gen</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by generation. If NULL, defaults to save_rate</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_save_rate_parlist">save_rate_parlist</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by parent list. If NULL, defaults to save_rate*1000</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_save_path">save_path</code></td>
<td>
<p>character. The path to save the checkpoint files</p>
</td></tr>
<tr><td><code id="ped2cn_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms and methodologies used in this function are further discussed and exemplified in the vignette titled &quot;examplePedigreeFunctions&quot;. For more advanced scenarios and detailed explanations, consult this vignette.
</p>

<hr>
<h2 id='ped2com'>Take a pedigree and turn it into a relatedness matrix</h2><span id='topic+ped2com'></span>

<h3>Description</h3>

<p>Take a pedigree and turn it into a relatedness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2com(
  ped,
  component,
  max.gen = 25,
  sparse = FALSE,
  verbose = FALSE,
  gc = FALSE,
  flatten.diag = FALSE,
  standardize.colnames = TRUE,
  transpose_method = "tcrossprod",
  saveable = FALSE,
  resume = FALSE,
  save_rate = 5,
  save_rate_gen = save_rate,
  save_rate_parlist = 1000 * save_rate,
  update_rate = 100,
  save_path = "checkpoint/",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2com_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2com_+3A_component">component</code></td>
<td>
<p>character.  Which component of the pedigree to return.  See Details.</p>
</td></tr>
<tr><td><code id="ped2com_+3A_max.gen">max.gen</code></td>
<td>
<p>the maximum number of generations to compute
(e.g., only up to 4th degree relatives).  The default is 25. However it can be set to infinity.
'Inf' uses as many generations as there are in the data.</p>
</td></tr>
<tr><td><code id="ped2com_+3A_sparse">sparse</code></td>
<td>
<p>logical.  If TRUE, use and return sparse matrices from Matrix package</p>
</td></tr>
<tr><td><code id="ped2com_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, print progress through stages of algorithm</p>
</td></tr>
<tr><td><code id="ped2com_+3A_gc">gc</code></td>
<td>
<p>logical. If TRUE, do frequent garbage collection via <code><a href="base.html#topic+gc">gc</a></code> to save memory</p>
</td></tr>
<tr><td><code id="ped2com_+3A_flatten.diag">flatten.diag</code></td>
<td>
<p>logical. If TRUE, overwrite the diagonal of the final relatedness matrix with ones</p>
</td></tr>
<tr><td><code id="ped2com_+3A_standardize.colnames">standardize.colnames</code></td>
<td>
<p>logical. If TRUE, standardize the column names of the pedigree dataset</p>
</td></tr>
<tr><td><code id="ped2com_+3A_transpose_method">transpose_method</code></td>
<td>
<p>character. The method to use for computing the transpose.  Options are &quot;tcrossprod&quot;, &quot;crossprod&quot;, or &quot;star&quot;</p>
</td></tr>
<tr><td><code id="ped2com_+3A_saveable">saveable</code></td>
<td>
<p>logical. If TRUE, save the intermediate results to disk</p>
</td></tr>
<tr><td><code id="ped2com_+3A_resume">resume</code></td>
<td>
<p>logical. If TRUE, resume from a checkpoint</p>
</td></tr>
<tr><td><code id="ped2com_+3A_save_rate">save_rate</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results</p>
</td></tr>
<tr><td><code id="ped2com_+3A_save_rate_gen">save_rate_gen</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by generation. If NULL, defaults to save_rate</p>
</td></tr>
<tr><td><code id="ped2com_+3A_save_rate_parlist">save_rate_parlist</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by parent list. If NULL, defaults to save_rate*1000</p>
</td></tr>
<tr><td><code id="ped2com_+3A_update_rate">update_rate</code></td>
<td>
<p>numeric. The rate at which to print progress</p>
</td></tr>
<tr><td><code id="ped2com_+3A_save_path">save_path</code></td>
<td>
<p>character. The path to save the checkpoint files</p>
</td></tr>
<tr><td><code id="ped2com_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms and methodologies used in this function are further discussed and exemplified in the vignette titled &quot;examplePedigreeFunctions&quot;. For more advanced scenarios and detailed explanations, consult this vignette.
</p>

<hr>
<h2 id='ped2fam'>Segment Pedigree into Extended Families</h2><span id='topic+ped2fam'></span>

<h3>Description</h3>

<p>This function adds an extended family ID variable to a pedigree by segmenting that dataset into independent extended families
using the weakly connected components algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2fam(
  ped,
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  famID = "famID",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2fam_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2fam_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="ped2fam_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="ped2fam_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="ped2fam_+3A_famid">famID</code></td>
<td>
<p>character.  Name of the column to be created in ped for the family ID variable</p>
</td></tr>
<tr><td><code id="ped2fam_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general idea of this function is to use person ID, mother ID, and father ID to
create an extended family ID such that everyone with the same family ID is in the
same (perhaps very extended) pedigree.  That is, a pair of people with the same family ID
have at least one traceable relation of any length to one another.
</p>
<p>This function works by turning the pedigree into a mathematical graph using the igraph
package.  Once in graph form, the function uses weakly connected components to search
for all possible relationship paths that could connect anyone in the data to anyone
else in the data.
</p>


<h3>Value</h3>

<p>A pedigree dataset with one additional column for the newly created extended family ID
</p>

<hr>
<h2 id='ped2graph'>Turn a pedigree into a graph</h2><span id='topic+ped2graph'></span>

<h3>Description</h3>

<p>Turn a pedigree into a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2graph(
  ped,
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  directed = TRUE,
  adjacent = c("parents", "mothers", "fathers"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2graph_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2graph_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="ped2graph_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="ped2graph_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="ped2graph_+3A_directed">directed</code></td>
<td>
<p>Logical scalar. Default is TRUE. Indicates whether or not to create a directed graph.</p>
</td></tr>
<tr><td><code id="ped2graph_+3A_adjacent">adjacent</code></td>
<td>
<p>Character.  Relationship that defines adjacency in the graph: parents, mothers, or fathers</p>
</td></tr>
<tr><td><code id="ped2graph_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general idea of this function is to represent a pedigree as a graph using the igraph package.
</p>
<p>Once in graph form, several common pedigree tasks become much simpler.
</p>
<p>The <code>adjacent</code> argument allows for different kinds of graph structures.
When using <code>parents</code> for adjacency, the graph shows all parent-child relationships.
When using <code>mother</code> for adjacency, the graph only shows mother-child relationships.
Similarly when using <code>father</code> for adjacency, only father-child relationships appear in the graph.
Construct extended families from the parent graph, maternal lines from the mothers graph,
and paternal lines from the fathers graph.
</p>


<h3>Value</h3>

<p>A graph
</p>

<hr>
<h2 id='ped2maternal'>Add a maternal line ID variable to a pedigree</h2><span id='topic+ped2maternal'></span>

<h3>Description</h3>

<p>Add a maternal line ID variable to a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2maternal(
  ped,
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  matID = "matID",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2maternal_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2maternal_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="ped2maternal_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="ped2maternal_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="ped2maternal_+3A_matid">matID</code></td>
<td>
<p>Character.  Maternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="ped2maternal_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under various scenarios it is useful to know which people in a pedigree
belong to the same maternal lines.  This function first turns a pedigree
into a graph where adjacency is defined by mother-child relationships.
Subsequently, the weakly connected components algorithm finds all the
separate maternal lines and gives them an ID variable.
</p>


<h3>See Also</h3>

<p>[ped2fam()] for creating extended family IDs, and [ped2paternal()]
for creating paternal line IDs
</p>

<hr>
<h2 id='ped2mit'>Take a pedigree and turn it into a mitochondrial relatedness matrix</h2><span id='topic+ped2mit'></span><span id='topic+ped2mt'></span>

<h3>Description</h3>

<p>Take a pedigree and turn it into a mitochondrial relatedness matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2mit(
  ped,
  max.gen = 25,
  sparse = FALSE,
  verbose = FALSE,
  gc = FALSE,
  flatten.diag = FALSE,
  standardize.colnames = TRUE,
  transpose_method = "tcrossprod",
  saveable = FALSE,
  resume = FALSE,
  save_rate = 5,
  save_rate_gen = save_rate_gen,
  save_rate_parlist = 1000 * save_rate,
  save_path = "checkpoint/",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2mit_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_max.gen">max.gen</code></td>
<td>
<p>the maximum number of generations to compute
(e.g., only up to 4th degree relatives).  The default is 25. However it can be set to infinity.
'Inf' uses as many generations as there are in the data.</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_sparse">sparse</code></td>
<td>
<p>logical.  If TRUE, use and return sparse matrices from Matrix package</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, print progress through stages of algorithm</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_gc">gc</code></td>
<td>
<p>logical. If TRUE, do frequent garbage collection via <code><a href="base.html#topic+gc">gc</a></code> to save memory</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_flatten.diag">flatten.diag</code></td>
<td>
<p>logical. If TRUE, overwrite the diagonal of the final relatedness matrix with ones</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_standardize.colnames">standardize.colnames</code></td>
<td>
<p>logical. If TRUE, standardize the column names of the pedigree dataset</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_transpose_method">transpose_method</code></td>
<td>
<p>character. The method to use for computing the transpose.  Options are &quot;tcrossprod&quot;, &quot;crossprod&quot;, or &quot;star&quot;</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_saveable">saveable</code></td>
<td>
<p>logical. If TRUE, save the intermediate results to disk</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_resume">resume</code></td>
<td>
<p>logical. If TRUE, resume from a checkpoint</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_save_rate">save_rate</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_save_rate_gen">save_rate_gen</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by generation. If NULL, defaults to save_rate</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_save_rate_parlist">save_rate_parlist</code></td>
<td>
<p>numeric. The rate at which to save the intermediate results by parent list. If NULL, defaults to save_rate*1000</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_save_path">save_path</code></td>
<td>
<p>character. The path to save the checkpoint files</p>
</td></tr>
<tr><td><code id="ped2mit_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms and methodologies used in this function are further discussed and exemplified in the vignette titled &quot;examplePedigreeFunctions&quot;. For more advanced scenarios and detailed explanations, consult this vignette.
</p>

<hr>
<h2 id='ped2paternal'>Add a paternal line ID variable to a pedigree</h2><span id='topic+ped2paternal'></span>

<h3>Description</h3>

<p>Add a paternal line ID variable to a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ped2paternal(
  ped,
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  patID = "patID",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ped2paternal_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="ped2paternal_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="ped2paternal_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="ped2paternal_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="ped2paternal_+3A_patid">patID</code></td>
<td>
<p>Character.  Paternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="ped2paternal_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+ped2com">ped2com</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under various scenarios it is useful to know which people in a pedigree
belong to the same paternal lines.  This function first turns a pedigree
into a graph where adjacency is defined by father-child relationships.
Subsequently, the weakly connected components algorithm finds all the
separate paternal lines and gives them an ID variable.
</p>


<h3>See Also</h3>

<p>[ped2fam()] for creating extended family IDs, and [ped2maternal()]
for creating maternal line IDs
</p>

<hr>
<h2 id='plotPedigree'>plotPedigree
A wrapped function to plot simulated pedigree from function <code>simulatePedigree</code>. This function require the installation of package <code>kinship2</code>.</h2><span id='topic+plotPedigree'></span>

<h3>Description</h3>

<p>plotPedigree
A wrapped function to plot simulated pedigree from function <code>simulatePedigree</code>. This function require the installation of package <code>kinship2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPedigree(
  ped,
  code_male = NULL,
  verbose = FALSE,
  affected = NULL,
  cex = 0.5,
  col = 1,
  symbolsize = 1,
  branch = 0.6,
  packed = TRUE,
  align = c(1.5, 2),
  width = 8,
  density = c(-1, 35, 65, 20),
  mar = c(2.1, 1, 2.1, 1),
  angle = c(90, 65, 40, 0),
  keep.par = FALSE,
  pconnect = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPedigree_+3A_ped">ped</code></td>
<td>
<p>The simulated pedigree data.frame from function <code>simulatePedigree</code>. Or a pedigree dataframe with the same colnames as the dataframe simulated from function <code>simulatePedigree</code>.</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_code_male">code_male</code></td>
<td>
<p>This optional input allows you to indicate what value in the sex variable codes for male. Will be recoded as &quot;M&quot; (Male). If <code>NULL</code>, no recoding is performed.</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_verbose">verbose</code></td>
<td>
<p>logical  If TRUE, prints additional information. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_affected">affected</code></td>
<td>
<p>This optional parameter can either be a string specifying the column name that indicates affected status or a numeric/logical vector of the same length as the number of rows in 'ped'. If <code>NULL</code>, no affected status is assigned.</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_cex">cex</code></td>
<td>
<p>The font size of the IDs for each individual in the plot.</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_col">col</code></td>
<td>

<p>color for each id.  Default assigns the same color to everyone.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_symbolsize">symbolsize</code></td>
<td>

<p>controls symbolsize. Default=1.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_branch">branch</code></td>
<td>

<p>defines how much angle is used to connect various levels of nuclear families.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_packed">packed</code></td>
<td>

<p>default=T.  If T, uniform distance between all individuals at a given level.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_align">align</code></td>
<td>
<p> these parameters control the extra effort spent trying to
align children underneath parents, but without making the pedigree too
wide.  Set to F to speed up plotting.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_width">width</code></td>
<td>

<p>default=8.  For a packed pedigree, the minimum width allowed in the
realignment of pedigrees.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_density">density</code></td>
<td>

<p>defines density used in the symbols.  Takes up to 4 different values.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_mar">mar</code></td>
<td>
<p>margin parmeters, as in the <code>par</code> function</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_angle">angle</code></td>
<td>

<p>defines angle used in the symbols.  Takes up to 4 different values.
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_keep.par">keep.par</code></td>
<td>

<p>Default = F, allows user to keep the parameter settings the same as they
were for plotting (useful for adding extras to the plot)
</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_pconnect">pconnect</code></td>
<td>
<p>when connecting parent to children the program will try
to make the connecting line as close to vertical as possible, subject
to it lying inside the endpoints of the line that connects the
children by at least <code>pconnect</code> people.  Setting this option
to a large number will force the line to connect at the midpoint of
the children.</p>
</td></tr>
<tr><td><code id="plotPedigree_+3A_...">...</code></td>
<td>

<p>Extra options that feed into the plot function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the provided pedigree
</p>

<hr>
<h2 id='potter'>Fictional pedigree data on a wizarding family</h2><span id='topic+potter'></span>

<h3>Description</h3>

<p>A dataset created purely from imagination that includes a subset of the Potter extended family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(potter)
</code></pre>


<h3>Format</h3>

<p>A data frame (and ped object) with 36 rows and 8 variables
</p>


<h3>Details</h3>

<p>The variables are as follows:
</p>

<ul>
<li> <p><code>personID</code>:  Person identification variable
</p>
</li>
<li> <p><code>famID</code>: Family identification variable
</p>
</li>
<li> <p><code>name</code>:  Name of the person
</p>
</li>
<li> <p><code>gen</code>: Generation of the person
</p>
</li>
<li> <p><code>momID</code>:  ID of the mother
</p>
</li>
<li> <p><code>dadID</code>:  ID of the father
</p>
</li>
<li> <p><code>spouseID</code>: ID of the spouse
</p>
</li>
<li> <p><code>sex</code>:  Sex of the ID: 1 is male; 0 is female
</p>
</li></ul>

<p>IDs in the 100s <code>momID</code>s and <code>dadID</code>s are for people not in the dataset.
</p>

<hr>
<h2 id='processParents'>Process parents information</h2><span id='topic+processParents'></span>

<h3>Description</h3>

<p>This function processes the dataframe to add momID and dadID columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processParents(df_temp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="processParents_+3A_df_temp">df_temp</code></td>
<td>
<p>A data frame containing information about individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with added momID and dadID columns.
</p>

<hr>
<h2 id='readGedcom'>Read a GEDCOM File</h2><span id='topic+readGedcom'></span>

<h3>Description</h3>

<p>This function reads a GEDCOM file and parses it into a structured data frame of individuals.
Inspired by https://raw.githubusercontent.com/jjfitz/readgedcom/master/R/read_gedcom.R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readGedcom(
  file_path,
  verbose = FALSE,
  add_parents = TRUE,
  remove_empty_cols = TRUE,
  combine_cols = TRUE,
  skinny = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readGedcom_+3A_file_path">file_path</code></td>
<td>
<p>The path to the GEDCOM file.</p>
</td></tr>
<tr><td><code id="readGedcom_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating whether to print messages.</p>
</td></tr>
<tr><td><code id="readGedcom_+3A_add_parents">add_parents</code></td>
<td>
<p>A logical value indicating whether to add parents to the data frame.</p>
</td></tr>
<tr><td><code id="readGedcom_+3A_remove_empty_cols">remove_empty_cols</code></td>
<td>
<p>A logical value indicating whether to remove columns with all missing values.</p>
</td></tr>
<tr><td><code id="readGedcom_+3A_combine_cols">combine_cols</code></td>
<td>
<p>A logical value indicating whether to combine columns with duplicate values.</p>
</td></tr>
<tr><td><code id="readGedcom_+3A_skinny">skinny</code></td>
<td>
<p>A logical value indicating whether to return a skinny data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing information about individuals, with the following potential columns:
- 'id': ID of the individual
- &lsquo;momID': ID of the individual&rsquo;s mother
- &lsquo;dadID': ID of the individual&rsquo;s father
- 'sex': Sex of the individual
- 'name': Full name of the individual
- 'name_given': First name of the individual
- 'name_surn': Last name of the individual
- 'name_marriedsurn': Married name of the individual
- 'name_nick': Nickname of the individual
- 'name_npfx': Name prefix
- 'name_nsfx': Name suffix
- 'birth_date': Birth date of the individual
- 'birth_lat': Latitude of the birthplace
- 'birth_long': Longitude of the birthplace
- 'birth_place': Birthplace of the individual
- 'death_caus': Cause of death
- 'death_date': Death date of the individual
- 'death_lat': Latitude of the place of death
- 'death_long': Longitude of the place of death
- 'death_place': Place of death of the individual
- 'attribute_caste': Caste of the individual
- 'attribute_children': Number of children of the individual
- 'attribute_description': Description of the individual
- 'attribute_education': Education of the individual
- 'attribute_idnumber': Identification number of the individual
- 'attribute_marriages': Number of marriages of the individual
- 'attribute_nationality': Nationality of the individual
- 'attribute_occupation': Occupation of the individual
- 'attribute_property': Property owned by the individual
- 'attribute_religion': Religion of the individual
- 'attribute_residence': Residence of the individual
- 'attribute_ssn': Social security number of the individual
- 'attribute_title': Title of the individual
- 'FAMC': ID(s) of the family where the individual is a child
- 'FAMS': ID(s) of the family where the individual is a spouse
</p>

<hr>
<h2 id='recodeSex'>Recodes Sex Variable in a Pedigree Dataframe</h2><span id='topic+recodeSex'></span>

<h3>Description</h3>

<p>This function serves as is primarily used internally, by plotting functions etc.
It sets the 'repair' flag to TRUE automatically and forwards any additional parameters to 'checkSex'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recodeSex(
  ped,
  verbose = FALSE,
  code_male = NULL,
  code_na = NULL,
  code_female = NULL,
  recode_male = "M",
  recode_female = "F",
  recode_na = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recodeSex_+3A_ped">ped</code></td>
<td>
<p>A dataframe representing the pedigree data with a 'sex' column.</p>
</td></tr>
<tr><td><code id="recodeSex_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag indicating whether to print progress and validation messages to the console.</p>
</td></tr>
<tr><td><code id="recodeSex_+3A_code_male">code_male</code></td>
<td>
<p>The current code used to represent males in the 'sex' column.</p>
</td></tr>
<tr><td><code id="recodeSex_+3A_code_na">code_na</code></td>
<td>
<p>The current value used for missing values.</p>
</td></tr>
<tr><td><code id="recodeSex_+3A_code_female">code_female</code></td>
<td>
<p>The current code used to represent females in the 'sex' column. If both are NULL, no recoding is performed.</p>
</td></tr>
<tr><td><code id="recodeSex_+3A_recode_male">recode_male</code></td>
<td>
<p>The value to use for males. Default is &quot;M&quot;</p>
</td></tr>
<tr><td><code id="recodeSex_+3A_recode_female">recode_female</code></td>
<td>
<p>The value to use for females. Default is &quot;F&quot;</p>
</td></tr>
<tr><td><code id="recodeSex_+3A_recode_na">recode_na</code></td>
<td>
<p>The value to use for missing values. Default is NA_character_</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The validation process identifies:
- The unique sex codes present in the dataset.
- Whether individuals listed as fathers or mothers have inconsistent sex codes.
- Instances where an individual's recorded sex does not align with their parental role.
</p>
<p>If 'repair = TRUE', the function standardizes sex coding by:
- Assigning individuals listed as fathers the most common male code in the dataset.
- Assigning individuals listed as mothers the most common female code.
</p>
<p>This function uses the terms 'male' and 'female' in a biological context, referring to chromosomal and other biologically-based characteristics necessary for constructing genetic pedigrees. The biological aspect of sex used in genetic analysis (genotype) is distinct from the broader, richer concept of gender identity (phenotype).
</p>
<p>We recognize the importance of using language and methodologies that affirm and respect the full spectrum of gender identities.  The developers of this
package express unequivocal support for folx in the transgender
and LGBTQ+ communities.
</p>


<h3>Value</h3>

<p>A modified version of the input data.frame <code>ped</code>, containing an additional or modified 'sex_recode' column where the 'sex' values are recoded according to <code>code_male</code>. NA values in the 'sex' column are preserved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPedigree">plotPedigree</a></code>
</p>

<hr>
<h2 id='related_coef'>related_coef (Deprecated)</h2><span id='topic+related_coef'></span>

<h3>Description</h3>

<p>When calling this function, a warning will be issued about its deprecation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>related_coef(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="related_coef_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'calculateRelatedness'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the new 'calculateRelatedness' function.
&lsquo;related_coef' has been deprecated, and it&rsquo;s advised to use 'calculateRelatedness' directly.
</p>


<h3>Value</h3>

<p>The same result as calling 'calculateRelatedness'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateRelatedness">calculateRelatedness</a></code> for the updated function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is an example of the deprecated function:
related_coef(...)
# It is recommended to use:
calculateRelatedness(...)

## End(Not run)
</code></pre>

<hr>
<h2 id='relatedness'>relatedness (Deprecated)</h2><span id='topic+relatedness'></span>

<h3>Description</h3>

<p>When calling this function, a warning will be issued about its deprecation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relatedness_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'inferRelatedness'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the new 'inferRelatedness' function.
&lsquo;relatedness' has been deprecated, and it&rsquo;s advised to use 'inferRelatedness' directly.
</p>


<h3>Value</h3>

<p>The same result as calling 'inferRelatedness'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inferRelatedness">inferRelatedness</a></code> for the updated function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is an example of the deprecated function:
relatedness(...)
# It is recommended to use:
inferRelatedness(...)

## End(Not run)
</code></pre>

<hr>
<h2 id='repairIDs'>Repair Missing IDs</h2><span id='topic+repairIDs'></span>

<h3>Description</h3>

<p>This function repairs missing IDs in a pedigree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairIDs(ped, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repairIDs_+3A_ped">ped</code></td>
<td>
<p>A pedigree object</p>
</td></tr>
<tr><td><code id="repairIDs_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A corrected pedigree
</p>

<hr>
<h2 id='repairSex'>Repairs Sex Coding in a Pedigree Dataframe</h2><span id='topic+repairSex'></span>

<h3>Description</h3>

<p>This function serves as a wrapper around 'checkSex' to specifically handle
the repair of the sex coding in a pedigree dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairSex(ped, verbose = FALSE, code_male = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repairSex_+3A_ped">ped</code></td>
<td>
<p>A dataframe representing the pedigree data with a 'sex' column.</p>
</td></tr>
<tr><td><code id="repairSex_+3A_verbose">verbose</code></td>
<td>
<p>A logical flag indicating whether to print progress and validation messages to the console.</p>
</td></tr>
<tr><td><code id="repairSex_+3A_code_male">code_male</code></td>
<td>
<p>The current code used to represent males in the 'sex' column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The validation process identifies:
- The unique sex codes present in the dataset.
- Whether individuals listed as fathers or mothers have inconsistent sex codes.
- Instances where an individual's recorded sex does not align with their parental role.
</p>
<p>If 'repair = TRUE', the function standardizes sex coding by:
- Assigning individuals listed as fathers the most common male code in the dataset.
- Assigning individuals listed as mothers the most common female code.
</p>
<p>This function uses the terms 'male' and 'female' in a biological context, referring to chromosomal and other biologically-based characteristics necessary for constructing genetic pedigrees. The biological aspect of sex used in genetic analysis (genotype) is distinct from the broader, richer concept of gender identity (phenotype).
</p>
<p>We recognize the importance of using language and methodologies that affirm and respect the full spectrum of gender identities.  The developers of this
package express unequivocal support for folx in the transgender
and LGBTQ+ communities.
</p>


<h3>Value</h3>

<p>A modified version of the input data.frame <code>ped</code>, containing an additional or modified 'sex_recode' column where the 'sex' values are recoded according to <code>code_male</code>. NA values in the 'sex' column are preserved.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkSex">checkSex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ped &lt;- data.frame(ID = c(1, 2, 3), sex = c("M", "F", "M"))
repairSex(ped, code_male = "M", verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='resample'>Resample Elements of a Vector</h2><span id='topic+resample'></span>

<h3>Description</h3>

<p>This function performs resampling of the elements in a vector 'x'. It randomly
shuffles the elements of 'x' and returns a vector of the resampled elements. If 'x'
is empty, it returns 'NA_integer_'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>A vector containing the elements to be resampled. If 'x' is empty, the
function will return 'NA_integer_'.</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'sample.int', such as 'size' for the
number of items to sample and 'replace' indicating whether sampling should be with
replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of resampled elements from 'x'. If 'x' is empty, returns
'NA_integer_'. The length and type of the returned vector depend on the input
vector 'x' and the additional arguments provided via '...'.
</p>

<hr>
<h2 id='rmvn'>rmvn</h2><span id='topic+rmvn'></span>

<h3>Description</h3>

<p>rmvn
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvn(n, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmvn_+3A_n">n</code></td>
<td>
<p>Sample Size</p>
</td></tr>
<tr><td><code id="rmvn_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates multivariate normal data from a covariance matrix (<code>sigma</code>) of length <code>n</code>
</p>

<hr>
<h2 id='SimPed'>SimPed (Deprecated)</h2><span id='topic+SimPed'></span>

<h3>Description</h3>

<p>When calling this function, a warning will be issued about its deprecation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimPed(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SimPed_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to 'simulatePedigree'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper around the new 'simulatePedigree' function.
&lsquo;SimPed' has been deprecated, and it&rsquo;s advised to use 'simulatePedigree' directly.
</p>


<h3>Value</h3>

<p>The same result as calling 'simulatePedigree'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulatePedigree">simulatePedigree</a></code> for the updated function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# This is an example of the deprecated function:
SimPed(...)
# It is recommended to use:
simulatePedigree(...)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulatePedigree'>Simulate Pedigrees
This function simulates &quot;balanced&quot; pedigrees based on a group of parameters:
1) k - Kids per couple;
2) G - Number of generations;
3) p - Proportion of males in offspring;
4) r - Mating rate.</h2><span id='topic+simulatePedigree'></span>

<h3>Description</h3>

<p>Simulate Pedigrees
This function simulates &quot;balanced&quot; pedigrees based on a group of parameters:
1) k - Kids per couple;
2) G - Number of generations;
3) p - Proportion of males in offspring;
4) r - Mating rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulatePedigree(
  kpc = 3,
  Ngen = 4,
  sexR = 0.5,
  marR = 2/3,
  rd_kpc = FALSE,
  balancedSex = TRUE,
  balancedMar = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulatePedigree_+3A_kpc">kpc</code></td>
<td>
<p>Number of kids per couple. An integer &gt;= 2 that determines how many kids each fertilized mated couple will have in the pedigree. Default value is 3. Returns an error when kpc equals 1.</p>
</td></tr>
<tr><td><code id="simulatePedigree_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations. An integer &gt;= 2 that determines how many generations the simulated pedigree will have. The first generation is always a fertilized couple. The last generation has no mated individuals.</p>
</td></tr>
<tr><td><code id="simulatePedigree_+3A_sexr">sexR</code></td>
<td>
<p>Sex ratio of offspring. A numeric value ranging from 0 to 1 that determines the proportion of males in all offspring in this pedigree. For instance, 0.4 means 40 percent of the offspring will be male.</p>
</td></tr>
<tr><td><code id="simulatePedigree_+3A_marr">marR</code></td>
<td>
<p>Mating rate. A numeric value ranging from 0 to 1 which determines the proportion of mated (fertilized) couples in the pedigree within each generation. For instance, marR = 0.5 suggests 50 percent of the offspring in a specific generation will be mated and have their offspring.</p>
</td></tr>
<tr><td><code id="simulatePedigree_+3A_rd_kpc">rd_kpc</code></td>
<td>
<p>logical. If TRUE, the number of kids per mate will be randomly generated from a poisson distribution with mean kpc. If FALSE, the number of kids per mate will be fixed at kpc.</p>
</td></tr>
<tr><td><code id="simulatePedigree_+3A_balancedsex">balancedSex</code></td>
<td>
<p>Not fully developed yet. Always <code>TRUE</code> in the current version.</p>
</td></tr>
<tr><td><code id="simulatePedigree_+3A_balancedmar">balancedMar</code></td>
<td>
<p>Not fully developed yet. Always <code>TRUE</code> in the current version.</p>
</td></tr>
<tr><td><code id="simulatePedigree_+3A_verbose">verbose</code></td>
<td>
<p>logical  If TRUE, print progress through stages of algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with each row representing a simulated individual. The columns are as follows:
</p>

<ul>
<li><p>fam: The family id of each simulated individual. It is 'fam1' in a single simulated pedigree.
</p>
</li>
<li><p>ID: The unique personal ID of each simulated individual. The first digit is the fam id; the fourth digit is the generation the individual is in; the following digits represent the order of the individual within his/her pedigree. For example, 100411 suggests this individual has a family id of 1, is in the 4th generation, and is the 11th individual in the 4th generation.
</p>
</li>
<li><p>gen: The generation the simulated individual is in.
</p>
</li>
<li><p>dadID: Personal ID of the individual's father.
</p>
</li>
<li><p>momID: Personal ID of the individual's mother.
</p>
</li>
<li><p>spID: Personal ID of the individual's mate.
</p>
</li>
<li><p>sex: Biological sex of the individual. F - female; M - male.
</p>
</li></ul>


<hr>
<h2 id='sizeAllGens'>sizeAllGens
An internal supporting function for <code>simulatePedigree</code>.</h2><span id='topic+sizeAllGens'></span>

<h3>Description</h3>

<p>sizeAllGens
An internal supporting function for <code>simulatePedigree</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeAllGens(kpc, Ngen, marR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sizeAllGens_+3A_kpc">kpc</code></td>
<td>
<p>Number of kids per couple (integer &gt;= 2).</p>
</td></tr>
<tr><td><code id="sizeAllGens_+3A_ngen">Ngen</code></td>
<td>
<p>Number of generations (integer &gt;= 1).</p>
</td></tr>
<tr><td><code id="sizeAllGens_+3A_marr">marR</code></td>
<td>
<p>Mating rate (numeric value ranging from 0 to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector including the number of individuals in every generation.
</p>

<hr>
<h2 id='standardizeColnames'>Standardize Column Names in a Dataframe (Internal)</h2><span id='topic+standardizeColnames'></span>

<h3>Description</h3>

<p>This internal function standardizes the column names of a given dataframe.
It utilizes regular expressions and the 'tolower()' function to match column names
against a list of predefined standard names. The approach is case-insensitive and
allows for flexible matching of column names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizeColnames(df, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizeColnames_+3A_df">df</code></td>
<td>
<p>A dataframe whose column names need to be standardized.</p>
</td></tr>
<tr><td><code id="standardizeColnames_+3A_verbose">verbose</code></td>
<td>
<p>A logical indicating whether to print progress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with standardized column names.
</p>

<hr>
<h2 id='summarizeFamilies'>Summarize the families in a pedigree</h2><span id='topic+summarizeFamilies'></span>

<h3>Description</h3>

<p>Summarize the families in a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeFamilies(
  ped,
  famID = "famID",
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  matID = "matID",
  patID = "patID",
  byr = NULL,
  founder_sort_var = NULL,
  include_founder = FALSE,
  nbiggest = 5,
  noldest = 5,
  skip_var = NULL,
  five_num_summary = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizeFamilies_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_famid">famID</code></td>
<td>
<p>character.  Name of the column to be created in ped for the family ID variable</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_matid">matID</code></td>
<td>
<p>Character.  Maternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_patid">patID</code></td>
<td>
<p>Character.  Paternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_byr">byr</code></td>
<td>
<p>Character. Optional column name for birth year. Used to determine the oldest lineages.</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_founder_sort_var">founder_sort_var</code></td>
<td>
<p>Character. Column used to determine the founder of each lineage.
Defaults to 'byr' (if available) or 'personID' otherwise.</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_include_founder">include_founder</code></td>
<td>
<p>Logical. If 'TRUE', includes the founder (originating member) of each lineage in the output.</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_nbiggest">nbiggest</code></td>
<td>
<p>Integer. Number of largest lineages to return (sorted by count).</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_noldest">noldest</code></td>
<td>
<p>Integer. Number of oldest lineages to return (sorted by birth year).</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_skip_var">skip_var</code></td>
<td>
<p>Character vector. Variables to exclude from summary calculations.</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_five_num_summary">five_num_summary</code></td>
<td>
<p>Logical. If 'TRUE', includes the first quartile (Q1) and third quartile (Q3) in addition to
the minimum, median, and maximum values.</p>
</td></tr>
<tr><td><code id="summarizeFamilies_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if TRUE, print progress messages.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>[summarizePedigrees ()]
</p>

<hr>
<h2 id='summarizeMatrilines'>Summarize the maternal lines in a pedigree</h2><span id='topic+summarizeMatrilines'></span>

<h3>Description</h3>

<p>Summarize the maternal lines in a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeMatrilines(
  ped,
  famID = "famID",
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  matID = "matID",
  patID = "patID",
  byr = NULL,
  include_founder = FALSE,
  founder_sort_var = NULL,
  nbiggest = 5,
  noldest = 5,
  skip_var = NULL,
  five_num_summary = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizeMatrilines_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_famid">famID</code></td>
<td>
<p>character.  Name of the column to be created in ped for the family ID variable</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_matid">matID</code></td>
<td>
<p>Character.  Maternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_patid">patID</code></td>
<td>
<p>Character.  Paternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_byr">byr</code></td>
<td>
<p>Character. Optional column name for birth year. Used to determine the oldest lineages.</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_include_founder">include_founder</code></td>
<td>
<p>Logical. If 'TRUE', includes the founder (originating member) of each lineage in the output.</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_founder_sort_var">founder_sort_var</code></td>
<td>
<p>Character. Column used to determine the founder of each lineage.
Defaults to 'byr' (if available) or 'personID' otherwise.</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_nbiggest">nbiggest</code></td>
<td>
<p>Integer. Number of largest lineages to return (sorted by count).</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_noldest">noldest</code></td>
<td>
<p>Integer. Number of oldest lineages to return (sorted by birth year).</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_skip_var">skip_var</code></td>
<td>
<p>Character vector. Variables to exclude from summary calculations.</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_five_num_summary">five_num_summary</code></td>
<td>
<p>Logical. If 'TRUE', includes the first quartile (Q1) and third quartile (Q3) in addition to
the minimum, median, and maximum values.</p>
</td></tr>
<tr><td><code id="summarizeMatrilines_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if TRUE, print progress messages.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>[summarizePedigrees ()]
</p>

<hr>
<h2 id='summarizePatrilines'>Summarize the paternal lines in a pedigree</h2><span id='topic+summarizePatrilines'></span>

<h3>Description</h3>

<p>Summarize the paternal lines in a pedigree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizePatrilines(
  ped,
  famID = "famID",
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  matID = "matID",
  patID = "patID",
  byr = NULL,
  founder_sort_var = NULL,
  include_founder = FALSE,
  nbiggest = 5,
  noldest = 5,
  skip_var = NULL,
  five_num_summary = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizePatrilines_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_famid">famID</code></td>
<td>
<p>character.  Name of the column to be created in ped for the family ID variable</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_matid">matID</code></td>
<td>
<p>Character.  Maternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_patid">patID</code></td>
<td>
<p>Character.  Paternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_byr">byr</code></td>
<td>
<p>Character. Optional column name for birth year. Used to determine the oldest lineages.</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_founder_sort_var">founder_sort_var</code></td>
<td>
<p>Character. Column used to determine the founder of each lineage.
Defaults to 'byr' (if available) or 'personID' otherwise.</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_include_founder">include_founder</code></td>
<td>
<p>Logical. If 'TRUE', includes the founder (originating member) of each lineage in the output.</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_nbiggest">nbiggest</code></td>
<td>
<p>Integer. Number of largest lineages to return (sorted by count).</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_noldest">noldest</code></td>
<td>
<p>Integer. Number of oldest lineages to return (sorted by birth year).</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_skip_var">skip_var</code></td>
<td>
<p>Character vector. Variables to exclude from summary calculations.</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_five_num_summary">five_num_summary</code></td>
<td>
<p>Logical. If 'TRUE', includes the first quartile (Q1) and third quartile (Q3) in addition to
the minimum, median, and maximum values.</p>
</td></tr>
<tr><td><code id="summarizePatrilines_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if TRUE, print progress messages.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>[summarizePedigrees ()]
</p>

<hr>
<h2 id='summarizePedigrees'>Summarize Pedigree Data</h2><span id='topic+summarizePedigrees'></span>

<h3>Description</h3>

<p>This function summarizes pedigree data, by
computing key summary statistics for all numeric variables and identifying the
originating member (founder) for each family, maternal, and paternal lineage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizePedigrees(
  ped,
  famID = "famID",
  personID = "ID",
  momID = "momID",
  dadID = "dadID",
  matID = "matID",
  patID = "patID",
  type = c("fathers", "mothers", "families"),
  byr = NULL,
  include_founder = FALSE,
  founder_sort_var = NULL,
  nbiggest = 5,
  noldest = 5,
  skip_var = NULL,
  five_num_summary = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizePedigrees_+3A_ped">ped</code></td>
<td>
<p>a pedigree dataset.  Needs ID, momID, and dadID columns</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_famid">famID</code></td>
<td>
<p>character.  Name of the column to be created in ped for the family ID variable</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_personid">personID</code></td>
<td>
<p>character.  Name of the column in ped for the person ID variable</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_momid">momID</code></td>
<td>
<p>character.  Name of the column in ped for the mother ID variable</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_dadid">dadID</code></td>
<td>
<p>character.  Name of the column in ped for the father ID variable</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_matid">matID</code></td>
<td>
<p>Character.  Maternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_patid">patID</code></td>
<td>
<p>Character.  Paternal line ID variable to be created and added to the pedigree</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_type">type</code></td>
<td>
<p>Character vector. Specifies which summaries to compute.
Options: '&quot;fathers&quot;', '&quot;mothers&quot;', '&quot;families&quot;'. Default includes all three.</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_byr">byr</code></td>
<td>
<p>Character. Optional column name for birth year. Used to determine the oldest lineages.</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_include_founder">include_founder</code></td>
<td>
<p>Logical. If 'TRUE', includes the founder (originating member) of each lineage in the output.</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_founder_sort_var">founder_sort_var</code></td>
<td>
<p>Character. Column used to determine the founder of each lineage.
Defaults to 'byr' (if available) or 'personID' otherwise.</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_nbiggest">nbiggest</code></td>
<td>
<p>Integer. Number of largest lineages to return (sorted by count).</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_noldest">noldest</code></td>
<td>
<p>Integer. Number of oldest lineages to return (sorted by birth year).</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_skip_var">skip_var</code></td>
<td>
<p>Character vector. Variables to exclude from summary calculations.</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_five_num_summary">five_num_summary</code></td>
<td>
<p>Logical. If 'TRUE', includes the first quartile (Q1) and third quartile (Q3) in addition to
the minimum, median, and maximum values.</p>
</td></tr>
<tr><td><code id="summarizePedigrees_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if TRUE, print progress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates standard descriptive statistics, including the count of individuals in
each lineage, means, medians, minimum and maximum values, and standard deviations.
Additionally, if 'five_num_summary = TRUE', the function includes the first and third quartiles (Q1, Q3)
to provide a more detailed distributional summary. Users can also specify variables to exclude from
the analysis via 'skip_var'.
</p>
<p>Beyond summary statistics, the function identifies the founding member of each lineage
based on the specified sorting variable ('founder_sort_var'), defaulting to birth year ('byr')
when available or 'personID' otherwise. Users can retrieve the largest and oldest
lineages by setting 'nbiggest' and 'noldest', respectively.
</p>


<h3>Value</h3>

<p>A data.frame (or list) containing summary statistics for family, maternal, and paternal lines, as well as the 5 oldest and biggest lines.
</p>

<hr>
<h2 id='try_na'>modified tryCatch function</h2><span id='topic+try_na'></span>

<h3>Description</h3>

<p>modified tryCatch function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_na(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_na_+3A_x">x</code></td>
<td>
<p>vector of any length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Fuses the nullToNA function with efunc
</p>

<hr>
<h2 id='vech'>vech
Create the half-vectorization of a matrix</h2><span id='topic+vech'></span>

<h3>Description</h3>

<p>vech
Create the half-vectorization of a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vech_+3A_x">x</code></td>
<td>
<p>a matrix, the half-vectorization of which is desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the vectorized form of the lower triangle of a matrix, including the diagonal.
The upper triangle is ignored with no checking that the provided matrix is symmetric.
</p>


<h3>Value</h3>

<p>A vector containing the lower triangle of the matrix, including the diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vech(matrix(c(1, 0.5, 0.5, 1), nrow = 2, ncol = 2))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
