<!DOCTYPE html><html><head><title>Help for package prabclus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prabclus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abundtest'><p>Parametric bootstrap test for clustering in abundance matrices</p></a></li>
<li><a href='#allele2zeroone'><p>Converts alleleobject into binary matrix</p></a></li>
<li><a href='#alleleconvert'><p>Format conversion for codominant marker data</p></a></li>
<li><a href='#alleledist'><p>Shared allele distance for diploid loci</p></a></li>
<li><a href='#alleleinit'><p>Diploid loci matrix initialization</p></a></li>
<li><a href='#allelepaircomp'><p>Internal: compares two pairs of alleles</p></a></li>
<li><a href='#autoconst'><p>Spatial autocorrelation parameter estimation</p></a></li>
<li><a href='#build.charmatrix'><p>Internal: create character matrix out of allele list</p></a></li>
<li><a href='#build.ext.nblist'><p>Internal: generates neighborhood list for diploid loci</p></a></li>
<li><a href='#build.nblist'><p>Generate spatial weights from prabclus neighborhood list</p></a></li>
<li><a href='#cluspop.nb'><p>Simulation of presence-absence matrices (clustered)</p></a></li>
<li><a href='#communities'><p>Construct communities from individuals</p></a></li>
<li><a href='#communitydist'><p>Distances between communities</p></a></li>
<li><a href='#comp.test'><p>Compare species clustering and species groups</p></a></li>
<li><a href='#con.comp'><p>Connectivity components of an undirected graph</p></a></li>
<li><a href='#con.regmat'><p>Connected regions per species</p></a></li>
<li><a href='#coord2dist'><p>Geographical coordinates to distances</p></a></li>
<li><a href='#crmatrix'><p>Region-wise cluster membership</p></a></li>
<li><a href='#dicedist'><p>Dice distance matrix</p></a></li>
<li><a href='#distratio'><p>Distance ratio test statistics for distance based clustering</p></a></li>
<li><a href='#geco'><p>geco distance matrix</p></a></li>
<li><a href='#geo2neighbor'><p>Neighborhood list from geographical distance</p></a></li>
<li><a href='#homogen.test'><p>Classical distance-based test for homogeneity against clustering</p></a></li>
<li><a href='#hprabclust'><p>Clustering of species ranges from presence-absence matrices</p>
(hierarchical methods)</a></li>
<li><a href='#incmatrix'><p>Nestedness matrix</p></a></li>
<li><a href='#jaccard'><p>Jaccard distance matrix</p></a></li>
<li><a href='#kulczynski'><p>Kulczynski distance matrix</p></a></li>
<li><a href='#kykladspecreg'><p>Snail presence-absence data from Aegean sea</p></a></li>
<li><a href='#lcomponent'><p>Largest connectivity component</p></a></li>
<li><a href='#lociplots'><p>Visualises clusters of markers vs. species</p></a></li>
<li><a href='#nastats'><p>Missing values statistics for matrix</p></a></li>
<li><a href='#nb'><p>Neighborhood list for Aegean islands</p></a></li>
<li><a href='#nbtest'><p>Test of neighborhood list</p></a></li>
<li><a href='#nn'><p>Mean distance to kth nearest neighbor</p></a></li>
<li><a href='#NNclean'><p>Nearest neighbor based clutter/noise detection</p></a></li>
<li><a href='#phipt'><p>Distances between communities, auxiliary functions</p></a></li>
<li><a href='#piecewiselin'><p>Piecewise linear transformation for distance matrices</p></a></li>
<li><a href='#plotdistreg'><p>Plots for within-groups and between-groups distance regression</p></a></li>
<li><a href='#pop.sim'><p>p-value simulation for presence-absence matrices clustering test</p></a></li>
<li><a href='#prab.sarestimate'><p>Estimates SAR model from log-abundance matrix of prab-object.</p></a></li>
<li><a href='#prabclus-package'><p>prabclus package overview</p></a></li>
<li><a href='#prabclust'><p>Clustering for biotic elements or for species delimitation</p>
(mixture method)</a></li>
<li><a href='#prabinit'><p>Presence-absence/abundance matrix initialization</p></a></li>
<li><a href='#prabtest'><p>Parametric bootstrap test for clustering in presence-absence matrices</p></a></li>
<li><a href='#qkulczynski'><p>Quantitative Kulczynski distance matrix</p></a></li>
<li><a href='#randpop.nb'><p>Simulation of presence-absence matrices (non-clustered)</p></a></li>
<li><a href='#regdist'><p>Regression between subsets of dissimilarity matrices</p></a></li>
<li><a href='#regdistbetween'><p>Testing equality of within-groups and between-groups distances regression</p></a></li>
<li><a href='#regdistbetweenone'><p>Testing equality of one within-group and between-two groups</p>
distances regression</a></li>
<li><a href='#regdistdiff'><p>Regression difference between within-group dissimilarities</p></a></li>
<li><a href='#regdistdiffone'><p>Regression difference within reference group and between-group dissimilarities</p></a></li>
<li><a href='#regeqdist'><p>Testing equality of two distance-regressions</p></a></li>
<li><a href='#regpop.sar'><p>Simulation of abundance matrices (non-clustered)</p></a></li>
<li><a href='#siskiyou'><p>Herbs of the Siskiyou Mountains</p></a></li>
<li><a href='#specgroups'><p>Average within-group distances for given groups</p></a></li>
<li><a href='#stressvals'><p>Stress values for different dimensions of Kruskal's MDS</p></a></li>
<li><a href='#tetragonula'><p>Microsatellite genetic data of Tetragonula bees</p></a></li>
<li><a href='#toprab'><p>Convert abundance matrix into presence/absence matrix</p></a></li>
<li><a href='#unbuild.charmatrix'><p>Internal: create allele list out of character matrix</p></a></li>
<li><a href='#veronica'><p>Genetic AFLP data of Veronica plants</p></a></li>
<li><a href='#waterdist'><p>Overwater distances between islands in the Aegean sea</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Functions for Clustering and Testing of Presence-Absence,
Abundance and Multilocus Genetic Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Hennig &lt;christian.hennig@unibo.it&gt;, 
        Bernhard Hausdorf &lt;Hausdorf@zoologie.uni-hamburg.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), MASS, mclust</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spdep, spatialreg, bootstrap, foreign, mvtnorm</td>
</tr>
<tr>
<td>Description:</td>
<td>Distance-based parametric bootstrap tests for clustering with 
  spatial neighborhood information. Some distance measures, 
  Clustering of presence-absence, abundance and multilocus genetic data 
  for species delimitation, nearest neighbor 
  based noise detection. Genetic distances between communities.
  Tests whether various distance-based regressions
  are equal. Try package?prabclus for on overview. </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Hennig &lt;christian.hennig@unibo.it&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-23 23:33:09 UTC; chrish</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-24 00:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abundtest'>Parametric bootstrap test for clustering in abundance matrices</h2><span id='topic+abundtest'></span>

<h3>Description</h3>

<p>Parametric bootstrap test of a null model of i.i.d., but spatially
autocorrelated species against clustering of the species' population
patterns. Note that most relevant functionality of <code>prabtest</code>
(except of the use of the geco distance) is
also included in <code>abundtest</code>, so that <code>abundtest</code> can also
be used on binary presence-absence data.
In spite of the lots of
parameters, a standard execution (for the default test statistics, see
parameter <code>teststat</code> below) will be <br />
<code>prabmatrix &lt;- prabinit(file="path/abundmatrixfile",
    neighborhood="path/neighborhoodfile")</code><br />
<code>test &lt;- abundtest(prabmatrix)</code><br />
<code>summary(test)</code><br />
<b>Note:</b> Data formats are described
on the <code>prabinit</code> help page. You may also consider the example datasets
<code>kykladspecreg.dat</code> and <code>nb.dat</code>. Take care of the
parameter <code>rows.are.species</code> of <code>prabinit</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>abundtest(prabobj, teststat = "distratio", tuning = 0.25,
                       times = 1000, p.nb = NULL, 
                       prange = c(0, 1), nperp = 4, step = 0.1, step2 = 0.01, 
                       twostep = TRUE, species.fixed=TRUE, prab01=NULL,
                       groupvector=NULL,
                       sarestimate=prab.sarestimate(prabobj),
                       dist = prabobj$distance,
                       n.species = prabobj$n.species)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abundtest_+3A_prabobj">prabobj</code></td>
<td>
<p>an object of class <code>prab</code> (presence-absence data), as
generated by <code>prabinit</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_teststat">teststat</code></td>
<td>
<p>string, indicating the test statistics. <code>"isovertice"</code>:
number of isolated vertices in the graph of <code>tuning</code>
smallest distances
between species. <code>"lcomponent"</code>: size of largest connectivity
component in this graph. <code>"distratio"</code>: ratio between <code>tuning</code>
smallest and largest distances. <code>"nn"</code>: average distance of species to
<code>tuning</code>th nearest neighbor. 
<code>"inclusions"</code>: number of inclusions between areas of different
species (tests for nestedness structure, not for clustering, and
treats abundance matrices as presence-absence-data). <code>"mean"</code>:
mean of the distances between species (this is a rough measure of
species co-occurrence).
<code>"groups"</code>: this requires a specification of a vector defining
different groups of species via parameter <code>groupvector</code>. The
test statistic is then the mean of the distances between species of
the same group. This is computed over all species, but also for
every single group of species. It also includes the
<code>"mean"</code>-test, so that the number of tests carried out is
number of species groups with more than one element plus two.</p>
</td></tr> 
<tr><td><code id="abundtest_+3A_tuning">tuning</code></td>
<td>
<p>integer or (if <code>teststat="distratio"</code>) numerical
between 0 and 1. Tuning constant for test statistics, see
<code>teststat</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_times">times</code></td>
<td>
<p>integer. Number of simulation runs.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_p.nb">p.nb</code></td>
<td>
<p>numerical between 0 and 1. The probability that a new
region is drawn from the non-neighborhood of the previous regions
belonging to a species under generation. If <code>NULL</code> (the
default), and <code>prabobj$spatial</code>, 
<code>prabtest</code> estimates this by function
<code>autoconst</code>. Otherwise the next five parameters have no effect.
If <code>NULL</code>, and <code>!prabobj$spatial</code>,
spatial structure is ignored.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_prange">prange</code></td>
<td>
<p>numerical range vector, lower value not smaller than 0, larger
value not larger than 1. Range where <code>pd</code> is to be found. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_nperp">nperp</code></td>
<td>
<p>integer. Number of simulations per <code>pd</code>-value. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_step">step</code></td>
<td>
<p>numerical between 0 and 1. Interval length between
subsequent choices of <code>pd</code> for the first simulation. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_step2">step2</code></td>
<td>
<p>numerical between 0 and 1. Interval length between
subsequent choices of <code>pd</code> for the second simulation (see
parameter <code>twostep</code>). Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_twostep">twostep</code></td>
<td>
<p>logical. If <code>TRUE</code>, a first estimation step for
<code>pd</code> is
carried out in the whole <code>prange</code>, and then the final
estimation is determined between the preliminary estimator
<code>-5*step2</code> and <code>+5*step2</code>. Else, the first simulation
determines the final estimator. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_species.fixed">species.fixed</code></td>
<td>
<p>logical. Indicates if the range sizes of the species
are held fixed
in the test simulation (<code>TRUE</code>) or generated from their empirical
distribution in <code>x</code> (<code>FALSE</code>) for presence-absence data.
See function <code>randpop.nb</code>. Use always <code>TRUE</code> for abundance
data (not necessary if <code>teststat="inclusions"</code>).</p>
</td></tr>
<tr><td><code id="abundtest_+3A_prab01">prab01</code></td>
<td>
<p><code>prabinit</code>-object based on
presence-absence matrix of same dimensions than the
abundance matrix of <code>prabobj</code>. This specifies the presences and
absences on which the presence/absence step of abundance-based tests
is based (see details). If <code>NULL</code> (which is usually the only
reasonable choice), <code>prab01</code> is computed in order to indicate
the nonzeroes of <code>prabobj$prab</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_groupvector">groupvector</code></td>
<td>
<p>integer vector. For every species, a number
indicating the species' group membership. Needed only if
<code>teststat="groups"</code>.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_sarestimate">sarestimate</code></td>
<td>
<p>Estimator of the parameters of a simultaneous
autoregression model corresponding to the null model for abundance
data from Hausdorf and Hennig (2007) as generated by
<code>prab.sarestimate</code>. This requires package <code>spdep</code>.
Note that by explicitly specifying <code>sarestimate=NULL</code> simulation
of 0-1 matrices can be enforced.</p>
</td></tr>
<tr><td><code id="abundtest_+3A_dist">dist</code></td>
<td>
<p>One of <code>"jaccard"</code>, <code>"kulczynski"</code>,
<code>"qkulczynski"</code> or <code>"logkulczynski"</code> specifying the distance
measure on which the test is based. By default, this is taken from
<code>prabobj</code>.</p>
</td></tr>  
<tr><td><code id="abundtest_+3A_n.species">n.species</code></td>
<td>
<p>number of species. By default this is taken from
<code>prabobj</code>. This should normally not be changed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For presence-absence data, the routine is described in
<code><a href="#topic+prabtest">prabtest</a></code>. For abundance data, the first step under the
null model is to
simulated presence-absence patterns as in <code>prabtest</code>. The second
step is to fit a simultaneous autoregression (SAR) model (Ripley 1981,
section 5.2) to the log-abundances, see
<code><a href="#topic+prab.sarestimate">prab.sarestimate</a></code>. The simulation from the null model is
implemented in <code>regpop.sar</code>.
For more details see Hennig
and Hausdorf (2004) for presence-absence data and Hausdorf and Hennig
(2007) for abundance data and the test statistics <code>"mean"</code> and
<code>"groups"</code>, which can also be applied to binary data.
</p>
<p>If <code>p.nb=NA</code> was
specified, a diagnostic plot
for the estimation of <code>pd</code> is plotted by <code>autoconst</code>.
For details see Hennig
and Hausdorf (2004) and the help pages of the cited functions. 
</p>


<h3>Value</h3>

<p>An object of class <code>prabtest</code>, which is a list with components
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>vector of test statistic values for all simulated
populations. For <code>teststat="groups"</code> a list with components
<code>overall</code> (means of within group-distances), <code>mean</code> (means
of all distances), <code>gr</code> (matrix with a row for every group,
giving the groupwise within-group distance means).</p>
</td></tr>
<tr><td><code>p.above</code></td>
<td>
<p>p-value against an alternative that generates large
values of the test statistic (usually reasonable for
<code>teststat="inclusions"</code>, <code>"groups"</code>, <code>"mean"</code>).</p>
</td></tr>
<tr><td><code>p.below</code></td>
<td>
<p>p-value against an alternative that generates small
values of the test statistic (usually reasonable for
<code>"lcomponent"</code>, <code>"nn"</code>, <code>"distratio"</code>; for
<code>"isovertice"</code>, the two-sided p may make sense which is twice
the smaller one of <code>p.above</code> and <code>p.below</code>). </p>
</td></tr>
<tr><td><code>datac</code></td>
<td>
<p>test statistic value for the original
data. (<code>specgroups</code>-output for <code>teststat="groups"</code>).</p>
</td></tr>
<tr><td><code>tuning</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p><code>dist</code> above.</p>
</td></tr>
<tr><td><code>teststat</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>
<p><code>p.nb</code> above.</p>
</td></tr>
<tr><td><code>abund</code></td>
<td>
<p><code>TRUE</code> if simultaneous autoregression has been used
(i.e., a <code>sarestimate</code> has been supplied or computed).</p>
</td></tr>
<tr><td><code>sarlambda</code></td>
<td>
<p>Estimator of the autocorrelation
parameter <code>lambda</code> (see <code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code>)
defined so that the average weight of neighbors (see
<code><a href="spdep.html#topic+nb2listw">nb2listw</a></code>) is standardized to 1.</p>
</td></tr>
<tr><td><code>sarestimate</code></td>
<td>
<p>the output object of <code>prab.sarestimate</code>.</p>
</td></tr>
<tr><td><code>groupinfo</code></td>
<td>
<p>list containing information from
<code>"groups"</code> tests, with components <code>lg</code> (levels of
<code>groupvector</code>), <code>ng</code> (number of groups), <code>nsg</code>
(vector of group sizes), <code>testm</code> (value of <code>"means"</code> test
statistic for input <code>prabobj</code>), <code>pa</code> (group-wise
<code>p.above</code>), <code>pb</code> (group-wise
<code>p.below</code>), <code>pma</code> (<code>p.above</code> of <code>"means"</code> test),
<code>pmb</code> (<code>p.below</code> of <code>"means"</code> test).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2007) Null model tests of clustering of
species, negative co-occurrence patterns and nestedness in meta-communities.
<em>Oikos</em> 116, 818-828. 
</p>
<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
<a href="http://stat.ethz.ch/Research-Reports/110.html">http://stat.ethz.ch/Research-Reports/110.html</a>.
</p>
<p>Ripley, B. D. (1981) <em>Spatial Statistics</em>. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabinit">prabinit</a></code> generates objects of class <code>prab</code>.
</p>
<p><code><a href="#topic+autoconst">autoconst</a></code> estimates <code>pd</code> from such objects.
</p>
<p><code><a href="#topic+prabtest">prabtest</a></code> (analogous function for presence-absence data).
</p>
<p><code><a href="#topic+regpop.sar">regpop.sar</a></code> generates populations from the null model.
</p>
<p><code><a href="#topic+prab.sarestimate">prab.sarestimate</a></code> (parameter estimators for simultaneous
autoregression model). This calls
</p>
<p><code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code> (original estimation function from
package <code>spdep</code>).
</p>
<p>Some more information on the test statistics is given in
<code><a href="#topic+homogen.test">homogen.test</a></code>, <code><a href="#topic+lcomponent">lcomponent</a></code>,
<code><a href="#topic+distratio">distratio</a></code>, <code><a href="#topic+nn">nn</a></code>,
<code><a href="#topic+incmatrix">incmatrix</a></code>.
</p>
<p>Summary and print methods: <code><a href="#topic+summary.prabtest">summary.prabtest</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note: NOT RUN.
# This needs package spdep and a bunch of packages that are
# called by spdep!
# data(siskiyou)
# set.seed(1234)
# x &lt;- prabinit(prabmatrix=siskiyou, neighborhood=siskiyou.nb,
#              distance="logkulczynski")
# a1 &lt;- abundtest(x, times=5, p.nb=0.0465)
# a2 &lt;- abundtest(x, times=5, p.nb=0.0465, teststat="groups",
#                 groupvector=siskiyou.groups)
# These settings are chosen to make the example execution
# faster; usually you will use abundtest(x).
# summary(a1)
# summary(a2)
</code></pre>

<hr>
<h2 id='allele2zeroone'>Converts alleleobject into binary matrix</h2><span id='topic+allele2zeroone'></span>

<h3>Description</h3>

<p>Converts <code><a href="#topic+alleleobject">alleleobject</a></code> with codominant markers into
binary matrix with a column for each marker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  allele2zeroone(alleleobject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allele2zeroone_+3A_alleleobject">alleleobject</code></td>
<td>
<p>object of class <code><a href="#topic+alleleobject">alleleobject</a></code> as
generated by <code><a href="#topic+alleleinit">alleleinit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 0-1-matrix with individuals as rows and markers (alleles) as columns. 
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(tetragonula)
  ta &lt;- alleleconvert(strmatrix=tetragonula[21:50,])
  tai &lt;- alleleinit(allelematrix=ta)
  allele2zeroone(tai)
</code></pre>

<hr>
<h2 id='alleleconvert'>Format conversion for codominant marker data</h2><span id='topic+alleleconvert'></span>

<h3>Description</h3>

<p>Codominant marker data (which here means: data with several diploid
loci; two alleles per locus) can be represented in various ways. This
function converts the formats <code>"genepop"</code> and <code>"structure"</code> into
<code>"structurama"</code> and <code>"prabclus"</code>. <code>"genepop"</code>
is a version of the format
used by the package GENEPOP (Rousset, 2008), <code>"structure"</code> is a version
of what is used by STRUCTURE (Pritchard et al., 2000), another one is
<code>"structureb"</code>. <code>"structurama"</code>
is a version of what is used by STRUCTURAMA (Huelsenbeck and
Andolfatto, 2007) and <code>"prabclus"</code> is required by the function
<code><a href="#topic+alleleinit">alleleinit</a></code> in the present package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  alleleconvert(file=NULL,strmatrix=NULL, format.in="genepop",
                          format.out="prabclus",
                          alength=3,orig.nachar="000",new.nachar="-",
                          rows.are.individuals=TRUE, firstcolname=FALSE,
                          aletters=intToUtf8(c(65:90,97:122),multiple=TRUE),
                          outfile=NULL,skip=0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alleleconvert_+3A_file">file</code></td>
<td>
<p>string. Filename of input file, see details. One of
<code>file</code> and <code>strmatrix</code> needs to be specified.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_strmatrix">strmatrix</code></td>
<td>
<p>matrix or data frame of strings, see details. One of
<code>file</code> and <code>strmatrix</code> needs to be specified.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_format.in">format.in</code></td>
<td>
<p>string. One of <code>"genepop"</code>,
<code>"structure"</code>, or <code>"structureb"</code>, see details.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_format.out">format.out</code></td>
<td>
<p>string. One of <code>"structurama"</code> or
<code>"prabclus"</code>, see details.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_alength">alength</code></td>
<td>
<p>integer. If <code>format.in="genepop"</code>, length of code
for a single allele.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_orig.nachar">orig.nachar</code></td>
<td>
<p>string. Code for missing values in input data.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_new.nachar">new.nachar</code></td>
<td>
<p>string. Code for missing values in output data.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_rows.are.individuals">rows.are.individuals</code></td>
<td>
<p>logical. If <code>TRUE</code>, rows are
interpreted as individuals and columns (variables if
<code>strmatrix</code> is a data frame) as loci.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_firstcolname">firstcolname</code></td>
<td>
<p>logical. If <code>TRUE</code>, it is assumed that the
first column contains row names.</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_aletters">aletters</code></td>
<td>
<p>character vector. String of default characters for
alleles if <code>format.out=="prabclus"</code> (the default is fine unless
there is a locus that can have more than 62 different alleles in the
dataset).</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_outfile">outfile</code></td>
<td>
<p>string. If specified, the output matrix (omitting
quotes) is written to a file of this name (including row names if
<code>fistcolname==TRUE</code>).</p>
</td></tr>
<tr><td><code id="alleleconvert_+3A_skip">skip</code></td>
<td>
<p>number of rows to be skipped when reading data from a
file (<code>skip</code>-argument of <code><a href="utils.html#topic+read.table">read.table</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formats are as follows (described is the format within R, i.e.,
for the input, the format of <code>strmatrix</code>; if <code>file</code> is
specified, the file is read with
<code>read.table(file,colClasses="character")</code> and should give the
format explained below - note that <code>colClasses="character"</code>
implies that quotes are not needed in the input file):
</p>

<dl>
<dt>genepop</dt><dd><p>Alleles are coded by strings of length <code>alength</code>
and there is no space between the two alleles in a locus, so a
value of <code>"258260"</code> means that in the corresponding locus the two
alleles have codes 258 and 260.</p>
</dd>
<dt>structure</dt><dd><p>Alleles are coded by strings of arbitrary length.
Two rows correspond to each inidividual, the first row containing
the first alleles in all loci and the second row containing the
second ones.</p>
</dd>
<dt>structureb</dt><dd><p>Alleles are coded by strings of arbitrary length.
One row corresponds to each inidividual, containing first and
second alleles in all loci (first and second allele of first locus, first
and second allele of second locus etc.). This starts in the third
row (first two have locus names and other information).</p>
</dd>
<dt>structurama</dt><dd><p>Alleles are coded by strings of arbitrary
length. the two alleles in each locus are written with brackets
around them and a comma in between, so <code>"258260"</code> in
<code>"genepop"</code>
corresponds to <code>"(258,260)"</code> in <code>"structurama"</code>.</p>
</dd>
<dt>prabclus</dt><dd><p>Alleles are coded by a single character and there is
no space between the two alleles in a locus (e.g.,
<code>"AC"</code>).</p>
</dd>
</dl>



<h3>Value</h3>

<p>A matrix of strings in the format specified as <code>format.out</code> with
an attribute <code>"alevels"</code>, a vector of all used allele codes if
<code>format.out=="prabclus"</code>, otherwise vector of allele codes of
last locus.  
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Huelsenbeck, J. P., and P. Andolfatto (2007) Inference of population
structure under a Dirichlet process model. <em>Genetics</em> 175,
1787-1802.
</p>
<p>Pritchard, J. K., M. Stephens, and P. Donnelly (2000) Inference of
population structure using multi-locus genotype data. <em>Genetics</em>
155, 945-959.
</p>
<p>Rousset, F. (2008) genepop'007: a complete re-implementation of the
genepop software for Windows and Linux. <em>Molecular Ecology
Resources</em> 8, 103-106.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleinit">alleleinit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(tetragonula)
# This uses example data file Heterotrigona_indoFO.dat
  str(alleleconvert(strmatrix=tetragonula))
  strucmatrix &lt;-
    cbind(c("I1","I1","I2","I2","I3","I3"),
    c("122","144","122","122","144","144"),c("0","0","21","33","35","44"))
  alleleconvert(strmatrix=strucmatrix,format.in="structure",
    format.out="prabclus",orig.nachar="0",firstcolname=TRUE)
  alleleconvert(strmatrix=strucmatrix,format.in="structure",
    format.out="structurama",orig.nachar="0",new.nachar="-9",firstcolname=TRUE)
</code></pre>

<hr>
<h2 id='alleledist'>Shared allele distance for diploid loci</h2><span id='topic+alleledist'></span>

<h3>Description</h3>

<p>Shared allele distance for codominant markers (Bowcock et al., 1994).
One minus proportion of alleles shared by two individuals averaged
over loci (loci with missing values for at least one individual are
ignored).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  alleledist(allelelist,ni,np,count=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alleledist_+3A_allelelist">allelelist</code></td>
<td>
<p>a list of lists. In the &quot;outer&quot; list, there are
<code>np</code> lists, one for each locus. In the &quot;inner&quot; list, for every
individual there is a vector of two codes (typically characters, see
<code><a href="#topic+alleleinit">alleleinit</a></code>) for the two alleles in that locus. Such a
list can be constructed by <code><a href="#topic+unbuild.charmatrix">unbuild.charmatrix</a></code> out of
the <code>charmatrix</code> component of an output object of
<code><a href="#topic+alleleinit">alleleinit</a></code>.</p>
</td></tr>
<tr><td><code id="alleledist_+3A_ni">ni</code></td>
<td>
<p>integer. Number of individuals.</p>
</td></tr>
<tr><td><code id="alleledist_+3A_np">np</code></td>
<td>
<p>integer. Number of loci.</p>
</td></tr>
<tr><td><code id="alleledist_+3A_count">count</code></td>
<td>
<p>logical. If <code>TRUE</code>, the number of the individual to
be processed is printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetrical matrix of shared allele distances between individuals.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Bowcock, A. M., Ruiz-Linares, A., Tomfohrde, J., Minch, E., Kidd, J. R.,
Cavalli-Sforza, L. L. (1994) High resolution of human evolutionary
trees with polymorphic microsatellites. <em>Nature</em> 368, 455-457.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+alleleinit">alleleinit</a></code>, <code><a href="#topic+unbuild.charmatrix">unbuild.charmatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(tetragonula)
  tnb &lt;-
  coord2dist(coordmatrix=tetragonula.coord[1:50,],cut=50,file.format="decimal2",neighbors=TRUE)
  ta &lt;- alleleconvert(strmatrix=tetragonula[1:50,])
  tai &lt;- alleleinit(allelematrix=ta,neighborhood=tnb$nblist,distance="none")
  str(alleledist((unbuild.charmatrix(tai$charmatrix,50,13)),50,13)) 
</code></pre>

<hr>
<h2 id='alleleinit'>Diploid loci matrix initialization</h2><span id='topic+alleleinit'></span><span id='topic+alleleobject'></span><span id='topic+print.alleleobject'></span>

<h3>Description</h3>

<p><code>alleleinit</code> converts genetic data with diploid loci as generated
by <code><a href="#topic+alleleconvert">alleleconvert</a></code> into an object of class
<code>alleleobject</code>. <code>print.alleleobject</code> is a print method for such
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alleleinit(file = NULL, allelematrix=NULL,
                        rows.are.individuals = TRUE, 
    neighborhood = "none", distance = "alleledist", namode="variables",
                       nachar="-", distcount=FALSE) 


## S3 method for class 'alleleobject'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alleleinit_+3A_file">file</code></td>
<td>
<p>string. File name. File must be in <code>"prabclus"</code>
format, see details. Either <code>file</code>
or <code>allelematrix</code> needs to be specified.</p>
</td></tr>
<tr><td><code id="alleleinit_+3A_allelematrix">allelematrix</code></td>
<td>
<p>matrix in <code>"prabclus"</code>-format as generated by
<code><a href="#topic+alleleconvert">alleleconvert</a></code>, see details. Either <code>file</code>
or <code>allelematrix</code> needs to be specified. </p>
</td></tr>
<tr><td><code id="alleleinit_+3A_rows.are.individuals">rows.are.individuals</code></td>
<td>
<p>logical. If <code>TRUE</code>, rows are interpreted
as individuals and columns are interpreted as loci.</p>
</td></tr>
<tr><td><code id="alleleinit_+3A_neighborhood">neighborhood</code></td>
<td>
<p>A string or a list with a component for
every individual. The
components are vectors of integers indicating
neighboring individuals. An individual without neighbors 
should be assigned a vector <code>numeric(0)</code>. If <code>neighborhood</code>
is a filename, it is attempted to read such a list from a file,
where every row should correspond to one region (such as example
dataset <code>nb.dat</code>). If
<code>neighborhood="none"</code>, all neighborhoods are set to
<code>numeric(0)</code>. The neighborhood can be tested by
<code><a href="#topic+nbtest">nbtest</a></code> for consistency.</p>
</td></tr>
<tr><td><code id="alleleinit_+3A_distance">distance</code></td>
<td>
<p><code>"alleledist"</code>

or <code>"none"</code>. The distance measure
between individuals to compute by <code>alleleinit</code>.</p>
</td></tr>
<tr><td><code id="alleleinit_+3A_namode">namode</code></td>
<td>
<p>one of <code>"single"</code>, <code>"individuals"</code>,
<code>"variables"</code> , or <code>"none"</code>. Determines whether a
single probability for the entry to be missing is computed for a
single locus of an individual (<code>"single"</code>), a vector of
individual-wise probabilities for loci to be missing
(<code>"individuals"</code>), a vector of loci-wise probabilities for
individuals to be missing (<code>"variables"</code>) or no missingness
probability at all.</p>
</td></tr>
<tr><td><code id="alleleinit_+3A_nachar">nachar</code></td>
<td>
<p>character denoting missing values.</p>
</td></tr>
<tr><td><code id="alleleinit_+3A_distcount">distcount</code></td>
<td>
<p>logical. If <code>TRUE</code>, during distance computation
individuals are counted on the screen.</p>
</td></tr> 
<tr><td><code id="alleleinit_+3A_x">x</code></td>
<td>
<p>object of class <code>alleleobject</code>.</p>
</td></tr>
<tr><td><code id="alleleinit_+3A_...">...</code></td>
<td>
<p>necessary for print method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The required input format is the output format <code>"prabclus"</code> of
<code><a href="#topic+alleleconvert">alleleconvert</a></code>. Alleles are coded by a single character,
so diploid loci need to be pairs of characters without space between
the two alleles (e.g., &quot;AC&quot;). The input needs to be an
individuals*loci matrix or data frame (or a file that produces such
a data frame by <code>read.table(file,stringsAsFactors=FALSE)</code>) 
</p>


<h3>Value</h3>

<p><code>alleleinit</code> produces 
an object of class <code>alleleobject</code> (note that this is similar to
class <code><a href="#topic+prab">prab</a></code>; for example both can be used with
<code><a href="#topic+prabclust">prabclust</a></code>), which is a list with components
</p>
<table>
<tr><td><code>distmat</code></td>
<td>
<p>distance matrix between individuals.</p>
</td></tr>
<tr><td><code>amatrix</code></td>
<td>
<p>data frame of input data with string variables in the
input format, see details.  Note that in the
output for an individual the whole locus is declared missing if at
least one of its alleles is missing in the input.</p>
</td></tr>
<tr><td><code>charmatrix</code></td>
<td>
<p>matrix of characters in which there are two rows for
every individual corresponding to the two alleles in every locus
(column). Entries are allele codes but missing values are coded as
<code>NA</code>.</p>
</td></tr>  
<tr><td><code>nb</code></td>
<td>
<p>neighborhood list, see above.</p>
</td></tr>
<tr><td><code>ext.nblist</code></td>
<td>
<p>a neighborhood list in which for every row in
<code>charmatrix</code> the second row number corresponding to the
neighboring individuals is listed.</p>
</td></tr> 
<tr><td><code>n.variables</code></td>
<td>
<p>number of loci.</p>
</td></tr>
<tr><td><code>n.individuals</code></td>
<td>
<p>number of individuals.</p>
</td></tr>
<tr><td><code>n.levels</code></td>
<td>
<p>maximum number of different alleles in a locus.</p>
</td></tr>
<tr><td><code>n.species</code></td>
<td>
<p>identical to <code>n.individuals</code> used for
compatibility with <code>prabclust</code>.</p>
</td></tr>
<tr><td><code>alevels</code></td>
<td>
<p>character vector with all used allele codes not
including missing values.</p>
</td></tr>
<tr><td><code>leveldist</code></td>
<td>
<p>matrix in which rows are loci, columns are alleles
and entries are frequencies of alleles per locus.</p>
</td></tr>
<tr><td><code>prab</code></td>
<td>
<p>useless matrix of number of factor levels corresponding to
<code>amatrix</code> added for compatibility with objects of class
<code>prab</code>.</p>
</td></tr>
<tr><td><code>regperspec</code></td>
<td>
<p>vector of row-wise sums of <code>prab</code> added for
compatibility with objects of class <code>prab</code>.</p>
</td></tr>
<tr><td><code>specperreg</code></td>
<td>
<p>vector of column-wise sums of <code>prab</code> added for
compatibility with objects of class <code>prab</code>.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>string denoting the chosen distance measure, see above.</p>
</td></tr>
<tr><td><code>namode</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>naprob</code></td>
<td>
<p>probability of missing values, numeric or vector, see
documentation of argument <code>namode</code>.</p>
</td></tr>
<tr><td><code>nasum</code></td>
<td>
<p>number of missing entries (individual/loci) in
<code>amatrix</code>.</p>
</td></tr>
<tr><td><code>nachar</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>spatial</code></td>
<td>
<p>logical. <code>TRUE</code> if a neighborhood was submitted.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleconvert">alleleconvert</a></code>, <code><a href="#topic+alleledist">alleledist</a></code>,
<code><a href="#topic+prabinit">prabinit</a></code>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'># Only 50 observations are used in order to have a fast example.
  data(tetragonula)
  tnb &lt;-
  coord2dist(coordmatrix=tetragonula.coord[1:50,],cut=50,file.format="decimal2",neighbors=TRUE)
  ta &lt;- alleleconvert(strmatrix=tetragonula[1:50,])
  tai &lt;- alleleinit(allelematrix=ta,neighborhood=tnb$nblist)
  print(tai)
</code></pre>

<hr>
<h2 id='allelepaircomp'>Internal: compares two pairs of alleles</h2><span id='topic+allelepaircomp'></span>

<h3>Description</h3>

<p>Used for computation of the genetic distances <code><a href="#topic+alleledist">alleledist</a></code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>  allelepaircomp(allelepair1,allelepair2,method="sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allelepaircomp_+3A_allelepair1">allelepair1</code></td>
<td>
<p>vector of two allele codes (usually characters), or
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="allelepaircomp_+3A_allelepair2">allelepair2</code></td>
<td>
<p>vector of two allele codes (usually characters), or
<code>NA</code>.</p>
</td></tr>
<tr><td><code id="allelepaircomp_+3A_method">method</code></td>
<td>
<p>one of <code>"sum"</code> or <code>"geometrical"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>method=="sum"</code>, number of shared alleles (0, 1 or 2), or
<code>NA</code>. If <code>method=="geometrical"</code>, 0, 0.5, <code>sqrt(0.5)</code>
(in case that one of the allelepairs is double such as in
<code>c("A","B"),c("A","A")</code>) or 1, or
<code>NA</code>. 
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+alleledist">alleledist</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>  allelepaircomp(c("A","B"),c("A","C"))
</code></pre>

<hr>
<h2 id='autoconst'>Spatial autocorrelation parameter estimation</h2><span id='topic+autoconst'></span><span id='topic+autoreg'></span>

<h3>Description</h3>

<p>Monte Carlo estimation of the disjunction/spatial autocorrelation
parameter <code>pd</code> for the simulation model used in
<code>randpop.nb</code>, used for tests for clustering of presence-absence data.
</p>
<p><code>autoconst</code> is the main function; <code>autoreg</code> performs the
simulation and is executed within <code>autoconst</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoconst(x, prange = c(0, 1), twostep = TRUE, step1 = 0.1,
step2 = 0.01, plot = TRUE, nperp = 4, ejprob = NULL,
species.fixed = TRUE, pdfnb=FALSE, ignore.richness=FALSE)

autoreg(x, probs, ejprob, plot = TRUE, nperp = 4, species.fixed = TRUE,
pdfnb=FALSE, ignore.richness=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoconst_+3A_x">x</code></td>
<td>
<p>object of class <code>prab</code> as generated by <code>prabinit</code>.
Presence-absence data to be analyzed.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_prange">prange</code></td>
<td>
<p>numerical range vector, lower value not smaller than 0, larger
value not larger than 1. Range where the parameter is to be found.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_twostep">twostep</code></td>
<td>
<p>logical. If <code>TRUE</code>, a first estimation step is
carried out in the whole <code>prange</code>, and then the final
estimation is determined between the preliminary estimator
<code>-5*step2</code> and <code>+5*step2</code>. Else, the first simulation
determines the final estimator.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_step1">step1</code></td>
<td>
<p>numerical between 0 and 1. Interval length between
subsequent choices of <code>pd</code> for the first simulation.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_step2">step2</code></td>
<td>
<p>numerical between 0 and 1. Interval length between
subsequent choices of <code>pd</code> for the second simulation in case of
<code>twostep=TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, a scatterplot of <code>pd</code>-values
against resulting <code>ejprob</code> values (see below), with regression
line and data value of <code>ejprob</code> is shown.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_nperp">nperp</code></td>
<td>
<p>integer. Number of simulations per <code>pd</code>-value.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_ejprob">ejprob</code></td>
<td>
<p>numerical between 0 and 1. Observed disjunction
probability for data <code>x</code>; if not specified in advance,
it will be computed by <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_species.fixed">species.fixed</code></td>
<td>
<p>logical. If <code>TRUE</code>, sizes of generated
species match the species sizes in <code>x</code>, else they are generated
from the empirical distribution of species sizes in <code>x</code>.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_probs">probs</code></td>
<td>
<p>vector of numericals between 0 and 1. <code>pd</code> values
for the simulation.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_pdfnb">pdfnb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the probabilities of the regions
are modified according to the number of neighboring regions in
<code>randpop.nb</code>, see Hennig and Hausdorf (2002), p. 5.</p>
</td></tr>
<tr><td><code id="autoconst_+3A_ignore.richness">ignore.richness</code></td>
<td>
<p>logical. If <code>TRUE</code>, there is no assumption
of species richnesses to differ between regions in the null model.
Regionwise probabilities don't differ in the generation of null
data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial autocorrelation parameter <code>pd</code>
of the model for the generation of
presence-absence data sets used by <code>randpop.nb</code> can be estimated
by use of the observed disjuction probability <code>ejprob</code> which is
the sum of
all species' connectivity components minus the number of species
divided by the number of &quot;presence&quot; entries minus the number of
species. This is done by a simulation of artificial data sets with
characteristics of <code>x</code> and different <code>pd</code>-values, governed
by <code>prange, step1, step2</code> and <code>nperp</code>. <code>ejprob</code> is then
calculated for all simulated populations. A linear regression of
<code>ejprob</code> on <code>pd</code> is performed and the estimator of <code>pd</code>
is determined by computing the inverse of the regression function for
the <code>ejprob</code>-value of <code>x</code>. 
</p>


<h3>Value</h3>

<p><code>autoconst</code> produces the same list as <code>autoreg</code> with
additional component <code>ejprob</code>. The components are 
</p>
<table>
<tr><td><code>pd</code></td>
<td>
<p>(eventually) estimated parameter <code>pd</code>.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>(eventually) estimated regression coefficients.</p>
</td></tr>
<tr><td><code>ejprob</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2003)  Biotic Element Analysis in
Biogeography. To appear in  <em>Systematic Biology</em>.
</p>
<p>Hausdorf, B. and Hennig, C. (2003) Nestedness of north-west European
land snail ranges as a consequence of differential immigration from
Pleistocene glacial refuges. <em>Oecologia</em> 135, 102-109.
</p>
<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randpop.nb">randpop.nb</a></code>, <code><a href="#topic+prabinit">prabinit</a></code>, <code><a href="#topic+con.comp">con.comp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
data(nb)
set.seed(1234)
x &lt;- prabinit(prabmatrix=kykladspecreg, neighborhood=nb)
ax &lt;- autoconst(x,nperp=2,step1=0.3,twostep=FALSE)
</code></pre>

<hr>
<h2 id='build.charmatrix'>Internal: create character matrix out of allele list</h2><span id='topic+build.charmatrix'></span>

<h3>Description</h3>

<p>For use in <code><a href="#topic+alleleinit">alleleinit</a></code>.
Creates a matrix of characters in which there are two rows for
every individual corresponding to the two alleles in every locus
(column) out of a list of lists, such as required by
<code><a href="#topic+alleledist">alleledist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   build.charmatrix(allelelist,n.individuals,n.variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.charmatrix_+3A_allelelist">allelelist</code></td>
<td>
<p>A list of lists. In the &quot;outer&quot; list, there are
<code>n.variables</code> lists, one for each locus. In the &quot;inner&quot; list, for every
individual there is a vector of two codes (typically characters, see
<code><a href="#topic+alleleinit">alleleinit</a></code>) for the two alleles in that locus.</p>
</td></tr>  
<tr><td><code id="build.charmatrix_+3A_n.individuals">n.individuals</code></td>
<td>
<p>integer. Number of individuals.</p>
</td></tr>
<tr><td><code id="build.charmatrix_+3A_n.variables">n.variables</code></td>
<td>
<p>integer. Number of loci.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of characters in which there are two rows for
every individual corresponding to the two alleles in every locus
(column). 
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleinit">alleleinit</a></code>, <code><a href="#topic+unbuild.charmatrix">unbuild.charmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  alist &lt;- list()
  alist[[1]] &lt;- list(c("A","A"),c("B","A"),c(NA,NA))
  alist[[2]] &lt;- list(c("A","C"),c("B","B"),c("A","D"))
  build.charmatrix(alist,3,2)
</code></pre>

<hr>
<h2 id='build.ext.nblist'>Internal: generates neighborhood list for diploid loci</h2><span id='topic+build.ext.nblist'></span>

<h3>Description</h3>

<p>This is for use in <code><a href="#topic+alleleinit">alleleinit</a></code>.
Given a neighborhood list of individuals, a new neighborhood list is
generated in which there are two entries for each individual (entry 1
and 2 refer to individual one, 3 and 4 to individual 2 and so
on). Neighborhoods are preserved and additionally the two entries
belonging to the same individual are marked as neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  build.ext.nblist(neighbors,n.individuals=length(neighbors))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.ext.nblist_+3A_neighbors">neighbors</code></td>
<td>
<p>list of integer vectors, where each vector contains
the neighbors of an individual.</p>
</td></tr>
<tr><td><code id="build.ext.nblist_+3A_n.individuals">n.individuals</code></td>
<td>
<p>integer. Number of individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with <code>2*n.inidividuals</code> vectors of integers as described
above.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleinit">alleleinit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(veronica)
  vnb &lt;- coord2dist(coordmatrix=veronica.coord[1:20,], cut=20,
    file.format="decimal2",neighbors=TRUE)
  build.ext.nblist(vnb$nblist)
</code></pre>

<hr>
<h2 id='build.nblist'>Generate spatial weights from prabclus neighborhood list</h2><span id='topic+build.nblist'></span>

<h3>Description</h3>

<p>This generates a <code>listw</code>-object as needed for estimation of a
simultaneous autoregression model in package <code>spdep</code> from a
neighborhood list of the type generated in <code>prabinit</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.nblist(prabobj,prab01=NULL,style="C")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.nblist_+3A_prabobj">prabobj</code></td>
<td>
<p>object of class <code>prab</code>.</p>
</td></tr>
<tr><td><code id="build.nblist_+3A_prab01">prab01</code></td>
<td>
<p>presence-absence matrix of same dimensions than the
abundance matrix of <code>prabobj</code>. This specifies the presences and
absences on which the presence/absence step of abundance-based tests
is based (see details). If <code>NULL</code> (which is usually the only
reasonable choice), <code>prab01</code> is computed in order to indicate
the nonzeroes of <code>prabobj$prab</code>.</p>
</td></tr>
<tr><td><code id="build.nblist_+3A_style">style</code></td>
<td>
<p>can take values &quot;W&quot;, &quot;B&quot;, &quot;C&quot;, &quot;U&quot;, and &quot;S&quot; though tests
suggest that &quot;C&quot; should be chosen. See <code><a href="spdep.html#topic+nb2listw">nb2listw</a></code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A 'listw' object with the following members: 
</p>
<table>
<tr><td><code>style</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>neighbours</code></td>
<td>
<p>the neighbours list in <code>spdep</code>-format.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights for the neighbours and chosen style, with
attributes set to report the type of relationships (binary or
general, if general the form of the glist argument), and
style as above.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="spdep.html#topic+nb2listw">nb2listw</a></code> (which is called)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run; requires package spdep
# data(siskiyou)
# x &lt;- prabinit(prabmatrix=siskiyou, neighborhood=siskiyou.nb,
#             distance="logkulczynski")
# build.nblist(x)
</code></pre>

<hr>
<h2 id='cluspop.nb'>Simulation of presence-absence matrices (clustered)</h2><span id='topic+cluspop.nb'></span>

<h3>Description</h3>

<p>Generates a simulated matrix where the rows are interpreted as regions
and the columns as species, 1 means that a species is present in the
region and 0 means that the species is absent. Species are generated
in order to produce 2 clusters of species with similar ranges.
Spatial autocorrelation of a species' presences is governed by
the parameter <code>p.nb</code> and a list of neighbors for each region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluspop.nb(neighbors, p.nb = 0.5, n.species, clus.specs, reg.group,
grouppf = 10, n.regions = length(neighbors),
vector.species = rep(1, n.species), pdf.regions = rep(1/n.regions,
n.regions), count = TRUE, pdfnb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluspop.nb_+3A_neighbors">neighbors</code></td>
<td>
<p>A list with a component for every region. The
components are vectors of integers indicating
neighboring regions. A region without neighbors (e.g., an island)
should be assigned a list <code>numeric(0)</code>.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_p.nb">p.nb</code></td>
<td>
<p>numerical between 0 and 1. The probability that a new
region is drawn from the non-neighborhood of the previous regions
belonging to a species under generation. Note that for a given
presence-absence matrix, this parameter can be estimated by
<code>autoconst</code> (called <code>pd</code> there).</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_n.species">n.species</code></td>
<td>
<p>integer. Number of species.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_clus.specs">clus.specs</code></td>
<td>
<p>integer not larger than <code>n.species</code>. Number of
species restricted to one of the two groups of regions defined by
<code>reg.group</code> (called &quot;clustered species&quot; because this leads to
more similar species ranges).</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_reg.group">reg.group</code></td>
<td>
<p>vector of pairwise distinct integers not larger than
<code>n. regions</code>. Defines a group of regions to which a part of the
<code>clus.specs</code> clustered species is restricted (more or less, see
<code>grouppf</code>). The other clustered species are restricted to the
complementary regions.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_grouppf">grouppf</code></td>
<td>
<p>numerical. The probability of the region of
a clustered species to belong to the corresponding group of regions
is up-weighted by factor <code>grouppf</code> compared to the generation
of &quot;non-clustered&quot; species.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_n.regions">n.regions</code></td>
<td>
<p>integer. Number of regions.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_vector.species">vector.species</code></td>
<td>
<p>vector of integers. The sizes
(i.e., numbers of regions)
of the species are generated randomly from
the empirical distribution of <code>vector.species</code>.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_pdf.regions">pdf.regions</code></td>
<td>
<p>numerical vector of length <code>n.species</code>. The
entries must sum up to 1 and give probabilities for the regions to
be drawn during the generation of a species. These probabilities are
used conditional on the new region being a neighbor or a
non-neighbor of the previous regions of the species, see
<code>p.nb</code>, modified by <code>grouppf</code> for the clustered species.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_count">count</code></td>
<td>
<p>logical. If <code>TRUE</code>, the number of the currently
generated species is printed.</p>
</td></tr>
<tr><td><code id="cluspop.nb_+3A_pdfnb">pdfnb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the probabilities of the regions
are modified according to the number of neighboring regions by
dividing them relative to the others by min(1,number of neighbors).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The non-clustered species are generated as explained on the help page
for <code>randpop.nb</code>. The general principle for the clustered species
is the same, but with modified probabilities for the regions. For each
clustered species, one of the two groups of regions is drawn,
distributed according to the sum of its regions' probability given by
<code>pdf.regions</code>. The first region of such a species is only drawn
from the regions of this group.
</p>


<h3>Value</h3>

<p>A 0-1-matrix, rows are regions, columns are species.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+randpop.nb">randpop.nb</a></code>,
</p>
<p><code><a href="#topic+autoconst">autoconst</a></code> estimates <code>p.nb</code> from matrices of class
<code>prab</code>. These are generated by <code><a href="#topic+prabinit">prabinit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nb)
set.seed(888)
cluspop.nb(nb, p.nb=0.1, n.species=10, clus.specs=9, reg.group=1:17,
vector.species=c(10))
</code></pre>

<hr>
<h2 id='communities'>Construct communities from individuals</h2><span id='topic+communities'></span>

<h3>Description</h3>

<p>Construct communities from individuals using geographical distance and
hierarchical clustering. Communities are clusters of geographically
close individuals, formed by <code><a href="stats.html#topic+hclust">hclust</a></code> with specified
distance cutoff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communities(geodist,grouping=NULL,
                        cutoff=1e-5,method="single")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communities_+3A_geodist">geodist</code></td>
<td>
<p><code>dist</code>-object or matrix of geographical distances
between individuals.</p>
</td></tr>
<tr><td><code id="communities_+3A_grouping">grouping</code></td>
<td>
<p>something that can be coerced into a factor. Different
groups indicated by <code>grouping</code> cannot be together in the same
community. (If <code>NULL</code>, there is no constraint.)</p>
</td></tr>
<tr><td><code id="communities_+3A_cutoff">cutoff</code></td>
<td>
<p>numeric; clustering distance cutoff value, passed on as
parameter <code>h</code> to <code>cutree</code>. Note that if this is smaller
than the smallest nonzero geographical distance, communities will be
all sets of individuals that have zero geographical distance to each
other.</p>
</td></tr>
<tr><td><code id="communities_+3A_method">method</code></td>
<td>
<p><code>method</code>-parameter for <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of community memberships for the individuals (integer numbers
from 1 to the number of communities without interruption.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+communitydist">communitydist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[1:90,],file.format="decimal2")
  species &lt;-c(rep(1,64),rep(2,17),rep(3,9))
  communities(ver.geo,species)
  
</code></pre>

<hr>
<h2 id='communitydist'>Distances between communities</h2><span id='topic+communitydist'></span>

<h3>Description</h3>

<p>Constructs distances between communities: chord- (Cavalli-Sforza and
Edwards, 1967), phiPT/phiST (Peakall and Smouse, 2012, Meirmans,
2006),
three versions of the shared allele distance between communities,
and geographical distance between communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communitydist(alleleobj,comvector="auto",distance="chord",
                          compute.geodist=TRUE,out.dist=FALSE,
                          grouping=NULL,geodist=NA,diploid=TRUE,
                          phiptna=NA,...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communitydist_+3A_alleleobj">alleleobj</code></td>
<td>
<p>if <code>diploid=TRUE</code>, an object of class
<code>alleleobject</code> as produced by
function  <code><a href="#topic+alleleinit">alleleinit</a></code>. This has the required
information on the individuals that are grouped into communities. In
case <code>diploid=FALSE</code>, a list that needs to have components
<code>n.variables</code> (number of loci), <code>alevels</code> (vector of
allele names, see <code><a href="#topic+alleleinit">alleleinit</a></code>) and
<code>charmatrix</code> (matrix of characters with one row for every
individual and one column for every locus giving the alleles; see
examples below for how this can be constructed for a
<code>prabobject</code> with presence-absence data).</p>
</td></tr>
<tr><td><code id="communitydist_+3A_comvector">comvector</code></td>
<td>
<p>either a vector of integers indicating to which
community an individual belongs (these need to be numbered from 1 to
a maximum number without interruption), or <code>"auto"</code>, which
indicates that communities are automatically generated by the
<code><a href="#topic+communities">communities</a></code>-function.</p>
</td></tr>
<tr><td><code id="communitydist_+3A_distance">distance</code></td>
<td>
<p>one of <code>"chord"</code>, <code>"phipt"</code>,
<code>"shared.average"</code>, <code>"shared.chakraborty"</code>,
<code>"shared.problist"</code>. See Details.</p>
</td></tr> 
<tr><td><code id="communitydist_+3A_compute.geodist">compute.geodist</code></td>
<td>
<p>logical, indicating whether geographical
distances between communities should be generated.</p>
</td></tr>
<tr><td><code id="communitydist_+3A_out.dist">out.dist</code></td>
<td>
<p>logical, indicating whether <code>dist</code>-objects are
given out or rather distance matrices.</p>
</td></tr>
<tr><td><code id="communitydist_+3A_grouping">grouping</code></td>
<td>
<p>something that can be coerced into a factor, for
passing on to <code><a href="#topic+communities">communities</a></code> in case that
<code>comvector=="auto"</code>. This implies that individuals in different
groups indicated by <code>grouping</code> cannot be together in the same
community. Furthermore (also if <code>comvector</code> is something
else), a vector of groups of communities will be computed, see
output component <code>comgroup</code>. In any case individuals in
different groups are not allowed to be in the same community.</p>
</td></tr>
<tr><td><code id="communitydist_+3A_geodist">geodist</code></td>
<td>
<p>matrix or <code>dist</code>-object providing geographical
distances between individuals. Required if
<code>compute.geodist==TRUE</code> or <code>comvector=="auto"</code>.</p>
</td></tr>
<tr><td><code id="communitydist_+3A_diploid">diploid</code></td>
<td>
<p>logical, indicating whether loci are diploid, see
<code>alleleobj</code>.</p>
</td></tr>
<tr><td><code id="communitydist_+3A_phiptna">phiptna</code></td>
<td>
<p>if <code>distance="phipt"</code>, value to be given out as
phiPT-distance in case that
the original definition amounts to 0/0 (particularly if communities
have just one member).</p>
</td></tr>
<tr><td><code id="communitydist_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to <code><a href="#topic+communities">communities</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All genetic distances between communities are based on the information
given in <code>alleleobj</code>; either on the alleles directly or on a genetic
distance (<code>distmat</code>-component, see <code><a href="#topic+alleleinit">alleleinit</a></code>). 
The possible genetic distance measures between communities are as follows:
</p>

<ul>
<li> <p><code>"chord"</code>: chord-distance (Cavalli-Sforza and Edwards,
1967)
</p>
</li>
<li> <p><code>"phipt"</code>: phiPT-distance implemented according to
Peakall and Smouse, 2012. This also appears in the literature under
the name phiST (Meirmans, 2006, although the definition there is
incomplete and we are not sure whether this is identical).
</p>
</li>
<li> <p><code>"shared.average"</code>: average of between-community genetic
distances.
</p>
</li>
<li> <p><code>"shared.chakraborty"</code>: between-community shared allele
distance according to Chakraborty and Jin (1993).
</p>
</li>
<li> <p><code>"shared.problist"</code>: this implements the shared allele
distance (Bowcock et al., 1994) for individuals directly for
communities (one minus proportion of alleles shared by two
communities averaged over loci).
</p>
</li></ul>



<h3>Value</h3>

<p>list with components
</p>
<table>
<tr><td><code>comvector</code></td>
<td>
<p>integer vector of length of the number of
individuals, indicating their community membership.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>genetic distances between communities. Parameter <code>out.dist</code>
determines whether this is a <code>dist</code>-object or a matrix.</p>
</td></tr>
<tr><td><code>cgeodist</code></td>
<td>
<p>if <code>compute.geodist</code>, geographical distance
between communities defined as average distance of all pairs of
individuals belonging to different ones of the two communities between
which the distance is computed. Parameter <code>out.dist</code>
determines whether this is a <code>dist</code>-object or a matrix.</p>
</td></tr>
<tr><td><code>comgroup</code></td>
<td>
<p>vector of length of the number of communities. If
<code>grouping</code> was provided, this is a vector giving the group
memberships of all communities, otherwise it is a vector of 1s.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Bowcock, A. M., Ruiz-Linares, A., Tomfohrde, J., Minch, E., Kidd, J. R.,
Cavalli-Sforza, L. L. (1994) High resolution of human evolutionary
trees with polymorphic microsatellites. <em>Nature</em> 368, 455-457.
</p>
<p>Cavalli-Sforza, L. L. and Edwards, A. W. F. (1967) Phylogenetic
Analysis - Models and Estimation Procedures. <em>The American Journal of
Human Genetics</em> 19, 233-257.
</p>
<p>Chakraborty, R. and Jin, L. (1993) Determination of relatedness between
individuals using DNA fingerprinting. <em>Human Biology</em> 65, 875-895.
</p>
<p>Meirmans, P. G. (2006) Using the AMOVA framework to estimate a
standardized genetic differentiation measure. <em>Evolution</em> 60, 2399-2402.
</p>
<p>Peakall, R. and Smouse P.E. (2012) GenAlEx Tutorial 2.
<a href="https://biology-assets.anu.edu.au/GenAlEx/Tutorials.html">https://biology-assets.anu.edu.au/GenAlEx/Tutorials.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+communities">communities</a></code>; refer to <code><a href="#topic+phipt">phipt</a></code> for
computation of distances between specific pairs of communities.
<code><a href="#topic+diploidcomlist">diploidcomlist</a></code> produces relative frequencies for all
alles of all loci in all communities (on which the chord- and the
<code>"shared.problist"</code>-distances are based). 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(tetragonula)
  tnb &lt;-
  coord2dist(coordmatrix=tetragonula.coord[83:120,],cut=50,
    file.format="decimal2",neighbors=TRUE)
  ta &lt;- alleleconvert(strmatrix=tetragonula[83:120,])
  tai &lt;- alleleinit(allelematrix=ta,neighborhood=tnb$nblist)
  tetraspec &lt;- c(rep(1,11),rep(2,13),rep(3,14))
  tetracoms &lt;-
  c(rep(1:3,each=3),4,5,rep(6:11,each=2),12,rep(13:19,each=2))
  c1 &lt;- communitydist(tai,comvector=tetracoms,distance="chord",
    geodist=tnb$distmatrix,grouping=tetraspec)
  c2 &lt;- communitydist(tai,comvector=tetracoms,distance="phipt",
    geodist=tnb$distmatrix,grouping=tetraspec,compute.geodist=FALSE)
  c3 &lt;- communitydist(tai,comvector=tetracoms,distance="shared.average",
    geodist=tnb$distmatrix,grouping=tetraspec,compute.geodist=FALSE)
  c4 &lt;- communitydist(tai,comvector=tetracoms,distance="shared.chakraborty",
    geodist=tnb$distmatrix,grouping=tetraspec,compute.geodist=FALSE)
  c5 &lt;- communitydist(tai,comvector=tetracoms,distance="shared.problist",
    geodist=tnb$distmatrix,grouping=tetraspec,compute.geodist=FALSE)
  round(c1$cgeodist,digits=1)
  c1$comvector
  c2$comvector
  c3$comvector
  c4$comvector
  c5$comvector
  round(c1$dist,digits=2)
  round(c2$dist,digits=2)
  round(c3$dist,digits=2)
  round(c4$dist,digits=2)
  round(c5$dist,digits=2)  
</code></pre>

<hr>
<h2 id='comp.test'>Compare species clustering and species groups</h2><span id='topic+comp.test'></span>

<h3>Description</h3>

<p>Tests for independence between a clustering and another grouping of species.
This is simply an interface to <code>chisq.test</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp.test(cl,spg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp.test_+3A_cl">cl</code></td>
<td>
<p>a vector of integers. Clustering of species (may be taken
from <code>prabclust</code>).</p>
</td></tr>
<tr><td><code id="comp.test_+3A_spg">spg</code></td>
<td>
<p>a vector of integers of the same length, groups of species.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chisq.test</code> with simulated p-value is used.
</p>


<h3>Value</h3>

<p>Output of <code>chisq.test</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2003)  Biotic Element Analysis in
Biogeography. <em>Systematic Biology</em> 52, 717-723.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test</a></code>, <code><a href="#topic+prabclust">prabclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
g1 &lt;- c(rep(1,34),rep(2,12),rep(3,15))
g2 &lt;- sample(3,61,replace=TRUE)
comp.test(g1,g2)
</code></pre>

<hr>
<h2 id='con.comp'>Connectivity components of an undirected graph</h2><span id='topic+con.comp'></span>

<h3>Description</h3>

<p>Computes the connectivity components of an undirected graph from a
matrix giving the edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>con.comp(comat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="con.comp_+3A_comat">comat</code></td>
<td>
<p>a symmetric logical or 0-1 matrix, where <code>comat[i,j]=TRUE</code>
means that there is an edge between vertices <code>i</code> and
<code>j</code>. The diagonal is ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;depth-first search&quot; algorithm of Cormen, Leiserson and Rivest
(1990, p. 477) is used.
</p>


<h3>Value</h3>

<p>An integer vector, giving the number of the connectivity component for
each vertice.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Cormen, T. H., Leiserson, C. E. and Rivest, R. L. (1990), <em>Introduction
to Algorithms</em>, Cambridge: MIT Press.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code> for cutted single linkage
trees (often equivalent).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1000)
  x &lt;- rnorm(20)
  m &lt;- matrix(0,nrow=20,ncol=20)
  for(i in 1:20)
    for(j in 1:20)
      m[i,j] &lt;- abs(x[i]-x[j])
  d &lt;- m&lt;0.2
  cc &lt;- con.comp(d)
  max(cc) # number of connectivity components
  plot(x,cc)
  # The same should be produced by
  # cutree(hclust(as.dist(m),method="single"),h=0.2).
</code></pre>

<hr>
<h2 id='con.regmat'>Connected regions per species</h2><span id='topic+con.regmat'></span>

<h3>Description</h3>

<p>Returns a vector of the numbers of connected regions per species for a
presence-absence matrix.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>con.regmat(regmat, neighbors, count = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="con.regmat_+3A_regmat">regmat</code></td>
<td>
<p>0-1-matrix. Columns are species, rows are regions.</p>
</td></tr>
<tr><td><code id="con.regmat_+3A_neighbors">neighbors</code></td>
<td>
<p>A list with a component for every region. The
components are vectors of integers indicating
neighboring regions. A region without neighbors (e.g., an island)
should be assigned a list <code>numeric(0)</code>.</p>
</td></tr>
<tr><td><code id="con.regmat_+3A_count">count</code></td>
<td>
<p>logical. If <code>TRUE</code>, the number of the currently
processed species is printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>con.comp</code>.
</p>


<h3>Value</h3>

<p>Vector of numbers of connected regions per species.
</p>


<h3>Note</h3>

<p>Designed for use in <code>prabtest</code>.</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+con.comp">con.comp</a></code>, <code><a href="#topic+prabtest">prabtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nb)
set.seed(888) 
cp &lt;- cluspop.nb(nb, p.nb=0.1, n.species=10, clus.specs=9,
                 reg.group=1:17,vector.species=c(10))
con.regmat(cp,nb)
</code></pre>

<hr>
<h2 id='coord2dist'>Geographical coordinates to distances</h2><span id='topic+coord2dist'></span>

<h3>Description</h3>

<p>Computes geographical distances from geographical coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coord2dist(file=NULL, coordmatrix=NULL, cut=NULL,
                       file.format="degminsec",
                       output.dist=FALSE, radius=6378.137,
              fp=1/298.257223563, neighbors=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord2dist_+3A_file">file</code></td>
<td>
<p>string. A filename for the coordinate file. The file
should have 2, 4 or 6 numeric columns and one row for each location.
See <code>file.format</code>. One of <code>file</code> and <code>coordmatrix</code>
needs to be specified (if <code>coordmatrix</code> is not specified,
coordinates are read from <code>file</code>).</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_coordmatrix">coordmatrix</code></td>
<td>
<p>something that can be coerced into a matrix with
2, 4 or 6 columns. Matrix of coordinates, one row for each
location. See <code>file.format</code>. One of <code>file</code> and
<code>coordmatrix</code> needs to be specified.</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_cut">cut</code></td>
<td>
<p>numeric. Only active if <code>neighbors==TRUE</code>; see
<code>neighbors</code>.</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_file.format">file.format</code></td>
<td>
<p>one of <code>"degminsec"</code>, <code>"decimal2"</code> or
<code>"decimal4"</code>. The format of the required file or
<code>coordmatrix</code> consists of the following columns:
</p>

<dl>
<dt>&quot;degminsec&quot;</dt><dd><p>6 columns; the first three give degrees,
minutes and seconds for latitude, columns 4-6 the same for
longitude.  Values in column 1 and 4 can be positive or negative
(negative means &quot;South&quot;, &quot;West&quot;, respectively). Values in the
other columns should be non-negative.</p>
</dd>
<dt>&quot;decimal2&quot;</dt><dd><p>2 columns; the first one gives latitude, the
second one longitude in proper decimal notation. Values can be
positive or negative (negative means &quot;South&quot;, &quot;West&quot;,
respectively).</p>
</dd>
<dt>&quot;decimal4&quot;</dt><dd><p>4 columns; the first two give latitude, no. 3
and 4 give longitude. Values in column 1 and 3 can be positive
or negative (negative means &quot;South&quot;, &quot;West&quot;,
respectively). The give integer degrees. Values in the other
columns should be non-negative. They give percentages
(<code>&lt;=100</code>).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="coord2dist_+3A_output.dist">output.dist</code></td>
<td>
<p>logical. If <code>TRUE</code>, the resulting distance
matrix is given out as a <code><a href="stats.html#topic+dist">dist</a></code> object.</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_radius">radius</code></td>
<td>
<p>numeric. Radius of the earth in km used in computation
(the default is the equatorial radius but this is not the uniquely
possible choice).</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_fp">fp</code></td>
<td>
<p>flattening of the earth; the default is from WGS-84.</p>
</td></tr>
<tr><td><code id="coord2dist_+3A_neighbors">neighbors</code></td>
<td>
<p>logical. If <code>TRUE</code>, a neighborhood list is also
computed, listing for every location all locations with distance
<code>&lt;=cut</code> as neighbors.</p>
</td></tr>      
</table>


<h3>Value</h3>

<p>If <code>neighbors==TRUE</code>, a
list with components
</p>
<table>
<tr><td><code>distmatrix</code></td>
<td>
<p>distance matrix between locations. See
<code>output.dist</code> above. This is in km by default; the measurement
unit is determined by the value used for <code>radius</code>.</p>
</td></tr>
<tr><td><code>nblist</code></td>
<td>
<p>list with a vector for every location containing the
numbers of its neighbors, see <code>neighbors</code>.</p>
</td></tr>
</table>
<p>If <code>neighbors==FALSE</code>, only the distance matrix.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>German Wikipedia from 29 August 2010:
<a href="https://de.wikipedia.org/wiki/Orthodrome">https://de.wikipedia.org/wiki/Orthodrome</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geo2neighbor">geo2neighbor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  coord2dist(coordmatrix=veronica.coord[1:20,], cut=20, file.format="decimal2",neighbors=TRUE)
</code></pre>

<hr>
<h2 id='crmatrix'>Region-wise cluster membership</h2><span id='topic+crmatrix'></span>

<h3>Description</h3>

<p>Produces a matrix with clusters as rows and regions as columns,
indicating how many species present in a region belong to the clusters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crmatrix(x,xc,percentages=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crmatrix_+3A_x">x</code></td>
<td>
<p>object of class <code>prab</code> as
generated by <code>prabinit</code>. Presence-absence data to be analyzed.</p>
</td></tr>
<tr><td><code id="crmatrix_+3A_xc">xc</code></td>
<td>
<p>object of class <code>prabclust</code> or <code>comprabclust</code>
as generated by <code>prabclust</code> or <code>hprabclust</code>. The
clustering.</p>
</td></tr>
<tr><td><code id="crmatrix_+3A_percentages">percentages</code></td>
<td>
<p>logical. If <code>TRUE</code>, the output matrix will
give the proportion of species from a certain region in the cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A clusters time regions matrix as explained above.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  options(digits=3)
  data(kykladspecreg)
  data(nb)
  set.seed(1234)
  x &lt;- prabinit(prabmatrix=kykladspecreg, neighborhood=nb)
  xc &lt;- prabclust(x)

  crmatrix(x,xc)
  crmatrix(x,xc, percentages=TRUE)

</code></pre>

<hr>
<h2 id='dicedist'>Dice distance matrix</h2><span id='topic+dicedist'></span>

<h3>Description</h3>

<p>Computes a distance derived from Dice's coincidence index
between the columns of a 0-1-matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dicedist(regmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicedist_+3A_regmat">regmat</code></td>
<td>
<p>0-1-matrix. Columns are species, rows are regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Dice distance between two species is 1 minus the Coincidence
Index, which is (2*number of regions where
both species are present)/(2*number of regions where
both species are present plus number of regions where at least one
species is present). This is S23 in Shi (1993).
</p>


<h3>Value</h3>

<p>A symmetrical matrix of Dice distances.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Shi, G. R. (1993) Multivariate data analysis in palaeoecology and
palaeobiogeography - a review. <em>Palaeogeography, 
Palaeoclimatology, Palaeoecology</em> 105, 199-234.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kulczynski">kulczynski</a></code>,<code><a href="#topic+jaccard">jaccard</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
dicedist(t(kykladspecreg))
</code></pre>

<hr>
<h2 id='distratio'>Distance ratio test statistics for distance based clustering</h2><span id='topic+distratio'></span>

<h3>Description</h3>

<p>Calculates the ratio between the <code>prop</code> smallest and largest
distances of a distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distratio(distmat, prop = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distratio_+3A_distmat">distmat</code></td>
<td>
<p>symmetric distance matrix.</p>
</td></tr>
<tr><td><code id="distratio_+3A_prop">prop</code></td>
<td>
<p>numerical. Proportion between 0 and 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rounding is by <code>floor</code> for small and <code>ceiling</code> for large
distances.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>dr</code></td>
<td>
<p>ratio of <code>prop</code> smallest to <code>prop</code> largest distances.</p>
</td></tr>
<tr><td><code>lowmean</code></td>
<td>
<p>mean of <code>prop</code> smallest distances.</p>
</td></tr>
<tr><td><code>himean</code></td>
<td>
<p>mean of <code>prop</code> smallest distances.</p>
</td></tr>
<tr><td><code>prop</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges.
<em>Computational Statistics and Data Analysis</em> 45, 875-896.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabtest">prabtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
j &lt;- jaccard(t(kykladspecreg))
distratio(j)
</code></pre>

<hr>
<h2 id='geco'>geco distance matrix</h2><span id='topic+geco'></span>

<h3>Description</h3>

<p>Computes geco distances between the columns of a 0-1-matrix, based on
a distance matrix between regions (usually, but not necessarily, this is
a geographical distance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geco(regmat,geodist=as.dist(matrix(as.integer(!diag(nrow(regmat))))),
                   transform="piece",
                   tf=0.1,
                   countmode=ncol(regmat)+1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geco_+3A_regmat">regmat</code></td>
<td>
<p>0-1-matrix. Columns are species, rows are regions.</p>
</td></tr>
<tr><td><code id="geco_+3A_geodist">geodist</code></td>
<td>
<p><code>dist</code>-object or symmetric non-negative matrix.
Geographical distances between regions.</p>
</td></tr>
<tr><td><code id="geco_+3A_transform">transform</code></td>
<td>
<p>transformation applied to the distances before
computation of geco coefficient, see details. &quot;piece&quot; means
piecewise linear, namely distance/(<code>tf</code>*maximum distance)
if distance&lt;<code>tf</code>*maximum distance, and 1 otherwise, &quot;log&quot; means
<code>log((tf*distance)+1)</code>, &quot;sqrt&quot; means <code>sqrt(tf*distance)</code>,
&quot;none&quot; means no transformation.</p>
</td></tr>
<tr><td><code id="geco_+3A_tf">tf</code></td>
<td>
<p>tuning constant for transformation. See <code>transform</code>.</p>
</td></tr>
<tr><td><code id="geco_+3A_countmode">countmode</code></td>
<td>
<p>optional positive integer. Every 'countmode' algorithm runs
'geco' shows a message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geco distance between two species is 0.5*(mean distance
between region where species 1 is present and closest region where
species 2 is present plus mean distance
between region where species 2 is present and closest region where
species 1 is present). 'closest' to a region could be the regions
itself. 
It is recommended (Hennig and Hausdorf, 2006) to transform the
distances first, because the differences between large distances are
usually not meaningful or at least much less meaningful than
differences between small distances for dissimilarity measurement
between species ranges. See parameter <code>transform</code>.
</p>
<p>If the between-regions distance is 1 for all pairs of
non-equal regions, the geco distance degenerates
to the Kulczynski distance, see <code>kulczynski</code>.
</p>


<h3>Value</h3>

<p>A symmetrical matrix of geco distances.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2006)  A robust distance coefficient
between distribution areas incorporating geographic distances.
<em>Systematic Biology</em> 55, 170-175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kulczynski">kulczynski</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
data(waterdist)
geco(t(kykladspecreg),waterdist)
</code></pre>

<hr>
<h2 id='geo2neighbor'>Neighborhood list from geographical distance</h2><span id='topic+geo2neighbor'></span>

<h3>Description</h3>

<p>Generates a neighborhood list as required by <code>prabinit</code> from a
matrix of geographical distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geo2neighbor(geodist,cut=0.1*max(geodist))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geo2neighbor_+3A_geodist">geodist</code></td>
<td>
<p><code>dist</code>-object or symmetric non-negative matrix.
Geographical distances between regions.</p>
</td></tr>
<tr><td><code id="geo2neighbor_+3A_cut">cut</code></td>
<td>
<p>non-negative numerical. All pairs of regions with
<code>distance&lt;=cut</code> are treated as neighbors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of integer vectors, giving the set of neighbors for every region.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterdist)
geo2neighbor(waterdist)
</code></pre>

<hr>
<h2 id='homogen.test'>Classical distance-based test for homogeneity against clustering</h2><span id='topic+homogen.test'></span>

<h3>Description</h3>

<p>Classical distance-based test for homogeneity against clustering. Test
statistics is number of isolated vertices in the graph of smallest
distances. The homogeneity model is a random graph model where <code>ne</code>
edges are drawn from all possible edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogen.test(distmat, ne = ncol(distmat), testdist = "erdos")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homogen.test_+3A_distmat">distmat</code></td>
<td>
<p>numeric symmetric distance matrix.</p>
</td></tr>
<tr><td><code id="homogen.test_+3A_ne">ne</code></td>
<td>
<p>integer. Number of edges in the data graph, corresponding to
smallest distances.</p>
</td></tr>
<tr><td><code id="homogen.test_+3A_testdist">testdist</code></td>
<td>
<p>string. If <code>testdist="erdos"</code>, the test
distribution is a Poisson asymptotic distibution as given by Erdos
and Renyi (1960). If <code>testdist="ling"</code>, the test distribution
is exact as given by Ling (1973), which needs much more computing time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;ling&quot;-test is one-sided (rejection if the number of isolated vertices
is too large), the &quot;erdos&quot;-test computes a one-sided as well as a
two-sided p-value.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>p</code></td>
<td>
<p>p-value for one-sided test.</p>
</td></tr>
<tr><td><code>p.twoside</code></td>
<td>
<p>p-value for two-sided test, only if <code>testdist="erdos"</code>.</p>
</td></tr>
<tr><td><code>iv</code></td>
<td>
<p>number of isolated vertices in the data.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>parameter of the Poisson test distribution, only if
<code>testdist="erdos"</code>.</p>
</td></tr>
<tr><td><code>distcut</code></td>
<td>
<p>largest distance value for which an edge has been
drawn.</p>
</td></tr>
<tr><td><code>ne</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Erdos, P. and Renyi, A. (1960) On the evolution of random
graphs. <em>Publications of the Mathematical Institute of the
Hungarian Academy of Sciences</em> 5, 17-61.
</p>
<p>Godehardt, E. and Horsch, A. (1995) Graph-Theoretic Models for Testing
the Homogeneity of Data. In Gaul, W. and Pfeifer, D. (Eds.) <em>From
Data to Knowledge</em>, Springer, Berlin, 167-176.
</p>
<p>Ling, R. F. (1973) A probability theory of cluster
analysis. <em>Journal of the American Statistical Association</em> 68,
159-164.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabtest">prabtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
j &lt;- jaccard(t(kykladspecreg))
homogen.test(j, testdist="erdos")
homogen.test(j, testdist="ling")
</code></pre>

<hr>
<h2 id='hprabclust'>Clustering of species ranges from presence-absence matrices
(hierarchical methods)</h2><span id='topic+hprabclust'></span><span id='topic+print.comprabclust'></span>

<h3>Description</h3>

<p>Clusters a presence-absence matrix object by taking the
'h-cut'-partition of a hierarchical clustering and
declaring all members of too small clusters as 'noise' (this gives a
distance-based clustering method, which estimates the number of
clusters and allows for noise/non-clustered points). Note that this
is experimental. Often, the <code>prabclust</code>-solutions
is more convincing due to higher flexibility of that method. However,
<code>hprabclust</code> may be more stable sometimes.
</p>
<p><b>Note:</b> Data formats are described
on the <code>prabinit</code> help page. You may also consider the example datasets
<code>kykladspecreg.dat</code> and <code>nb.dat</code>. Take care of the
parameter <code>rows.are.species</code> of <code>prabinit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hprabclust(prabobj, cutdist=0.4, cutout=1,
method="average", nnout=2, mdsplot=TRUE, mdsmethod="classical")

## S3 method for class 'comprabclust'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hprabclust_+3A_prabobj">prabobj</code></td>
<td>
<p>object of class <code>prab</code> as
generated by <code>prabinit</code>. Presence-absence data to be analyzed.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_cutdist">cutdist</code></td>
<td>
<p>non-negative integer. Cutoff distance to determine the
partition, see <code>cutree</code>.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_cutout">cutout</code></td>
<td>
<p>non-negative integer. Points that have at most
<code>nnout</code> distances smaller or equal than <code>cutout</code> are
treated as noise.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_method">method</code></td>
<td>
<p>string. Clustering method, see <code>hclust</code>.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_nnout">nnout</code></td>
<td>
<p>non-negative integer. Members of clusters with less or
equal than <code>nnout</code> points or that have less or equal than
<code>nnout</code> neighbors closer than <code>cutout</code> are treated as noise.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_mdsplot">mdsplot</code></td>
<td>
<p>logical. If <code>TRUE</code>, the cluster solution is
plotted on the first two MDS dimensions, see <code>mdsmethod</code>.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_mdsmethod">mdsmethod</code></td>
<td>
<p><code>"classical"</code>, <code>"kruskal"</code>, or
<code>"sammon"</code>. The MDS method
to transform the distances to data points. <code>"classical"</code> indicates
metric MDS by function <code>cmdscale</code>, <code>"kruskal"</code> is
non-metric MDS. Note that if <code>mdsmethod!="classical"</code> zero
distances between different objects are replaced by the minimum of
the nonzero distances divided by 10 (otherwise the MDS method would
produce an error). Note that <code>mdsmethod</code> is ignored if
<code>mdsplot=FALSE</code>.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_x">x</code></td>
<td>
<p><code>comprabclust</code>-object as generated by <code>hprabclus</code>.</p>
</td></tr>
<tr><td><code id="hprabclust_+3A_...">...</code></td>
<td>
<p>necessary for print method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hprabclust</code> generates an object of class <code>comprabclust</code>. This is a
list with components
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>vector of integers indicating the cluster memberships of
the species (<code>cutout</code>-outliers are noise, but small clusters
are allowed). Noise is coded as 0.</p>
</td></tr>
<tr><td><code>rclustering</code></td>
<td>
<p>vector of integers indicating the cluster memberships of
the species, noise as described under <code>nnout</code>.
Noise is coded as 0.</p>
</td></tr>
<tr><td><code>cutdist</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>cutout</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>nnout</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>noisen</code></td>
<td>
<p>number of points minus <code>cutout</code>-outliers.</p>
</td></tr>
<tr><td><code>symbols</code></td>
<td>
<p>vector of characters corresponding to <code>rclustering</code>, but
estimated noise by <code>"N"</code>.</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>numerical matrix. MDS configuration (if <code>mdsplot=TRUE</code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>,
<code><a href="#topic+prabclust">prabclust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kykladspecreg)
data(nb)
data(waterdist)
x &lt;- prabinit(prabmatrix=kykladspecreg, neighborhood=nb,
              geodist=waterdist, distance="geco")
hprabclust(x,mdsplot=FALSE)
</code></pre>

<hr>
<h2 id='incmatrix'>Nestedness matrix</h2><span id='topic+incmatrix'></span>

<h3>Description</h3>

<p>Computes species*species nestedness matrix and number of nestings
(inclusions) from regions*species presence-absence matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incmatrix(regmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incmatrix_+3A_regmat">regmat</code></td>
<td>
<p>0-1-matrix. Columns are species, rows are regions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>m</code></td>
<td>
<p>0-1-matrix. <code>m[i,j]=1</code> means that the occupied region of
species j is a subset (not equal) of the region of species i.</p>
</td></tr>
<tr><td><code>ninc</code></td>
<td>
<p>integer. Number of strict inclusions.</p>
</td></tr>
<tr><td><code>neq</code></td>
<td>
<p>integer. Number of region equalities between species (not
including equality between species i and i).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2003) Nestedness of nerth-west European
land snail ranges as a consequence of differential immigration from
Pleistocene glacial refuges. <em>Oecologia</em> 135, 102-109.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabtest">prabtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kykladspecreg)
incmatrix(t(kykladspecreg))$ninc
</code></pre>

<hr>
<h2 id='jaccard'>Jaccard distance matrix</h2><span id='topic+jaccard'></span>

<h3>Description</h3>

<p>Computes Jaccard distances between the columns of a 0-1-matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard(regmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_+3A_regmat">regmat</code></td>
<td>
<p>0-1-matrix. Columns are species, rows are regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jaccard distance between two species is 1-(number of regions where
both species are present)/(number of regions where at least one
species is present). As a similarity coefficient, this is S22 in
Shi (1993).
</p>
<p>Thank you to Laurent Buffat for improving this function!
</p>


<h3>Value</h3>

<p>A symmetrical matrix of Jaccard distances.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Shi, G. R. (1993) Multivariate data analysis in palaeoecology and
palaeobiogeography - a review. <em>Palaeogeography, 
Palaeoclimatology, Palaeoecology</em> 105, 199-234.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kulczynski">kulczynski</a></code>, <code><a href="#topic+dicedist">dicedist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
jaccard(t(kykladspecreg))
</code></pre>

<hr>
<h2 id='kulczynski'>Kulczynski distance matrix</h2><span id='topic+kulczynski'></span>

<h3>Description</h3>

<p>Computes Kulczynski distances between the columns of a 0-1-matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kulczynski(regmat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kulczynski_+3A_regmat">regmat</code></td>
<td>
<p>0-1-matrix. Columns are species, rows are regions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kulczynski distance between two species is 1-(mean of (number of
regions where
both species are present)/(number of regions where species 1 is
present) and (number of
regions where
both species are present)/(number of regions where species 2 is
present)). The similarity version of this is S28 in Shi (1993).
</p>


<h3>Value</h3>

<p>A symmetrical matrix of Kulczynski distances.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Shi, G. R. (1993) Multivariate data analysis in palaeoecology and
palaeobiogeography - a review. <em>Palaeogeography, 
Palaeoclimatology, Palaeoecology</em> 105, 199-234.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jaccard">jaccard</a></code>, <code><a href="#topic+geco">geco</a></code>,<code><a href="#topic+qkulczynski">qkulczynski</a></code> ,
<code><a href="#topic+dicedist">dicedist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
kulczynski(t(kykladspecreg))
</code></pre>

<hr>
<h2 id='kykladspecreg'>Snail presence-absence data from Aegean sea</h2><span id='topic+kykladspecreg'></span>

<h3>Description</h3>

<p>0-1-matrix where rows are snail species and columns are islands in the
Aegean sea. An entry of 1 means that the species is present in the
region.     
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kykladspecreg)</code></pre>


<h3>Format</h3>

<p>A 0-1 matrix with 80 rows and 34 columns.</p>


<h3>Details</h3>

<p>Reads from example data file <code>kykladspecreg.dat</code>.
</p>


<h3>Source</h3>

<p>B. Hausdorf and C. Hennig (2005) The influence of recent geography,
palaeography and climate on the composition of the faune of the
central Aegean Islands. <em>Biological Journal of the Linnean
Society</em> 84, 785-795.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nb">nb</a></code> provides neighborhood information about the 34
islands. <code><a href="#topic+waterdist">waterdist</a></code> provides a geographical distance
matrix between the islands. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kykladspecreg)
</code></pre>

<hr>
<h2 id='lcomponent'>Largest connectivity component</h2><span id='topic+lcomponent'></span>

<h3>Description</h3>

<p>Computes the size of the largest connectivity component of the graph
of <code>ncol(distmat)</code> vertices with edges defined by the smallest
<code>ne</code> distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcomponent(distmat, ne = floor(3*ncol(distmat)/4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcomponent_+3A_distmat">distmat</code></td>
<td>
<p>symmetric distance matrix.</p>
</td></tr>
<tr><td><code id="lcomponent_+3A_ne">ne</code></td>
<td>
<p>integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components
</p>
<table>
<tr><td><code>lc</code></td>
<td>
<p>size of the largest connectivity component.</p>
</td></tr>
<tr><td><code>ne</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabtest">prabtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kykladspecreg)
j &lt;- jaccard(t(kykladspecreg))
lcomponent(j)
</code></pre>

<hr>
<h2 id='lociplots'>Visualises clusters of markers vs. species</h2><span id='topic+lociplots'></span>

<h3>Description</h3>

<p>Given a clustering of individuals from <code><a href="#topic+prabclust">prabclust</a></code> (as
generated in species delimitation) and a clustering of markers (for
example dominant markers of genetic loci), <code>lociplots</code> visualises 
the presence of markers against the clustering of individuals and
computes some statistics.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lociplots(indclust,locclust,locprab,lcluster,
                      symbols=NULL,brightest.grey=0.8,darkest.grey=0,
                      mdsdim=1:2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lociplots_+3A_indclust">indclust</code></td>
<td>
<p><code><a href="#topic+prabclust">prabclust</a></code>-object. Clustering of individuals.</p>
</td></tr>
<tr><td><code id="lociplots_+3A_locclust">locclust</code></td>
<td>
<p>vector of integers. Clustering of markers/loci.</p>
</td></tr>
<tr><td><code id="lociplots_+3A_locprab">locprab</code></td>
<td>
<p><code><a href="#topic+prab">prab</a></code>-object in which the markers are what
the help page of <code><a href="#topic+prabinit">prabinit</a></code> refers to as &quot;species&quot;
(i.e., reverse of what is used for species delimitation clustering;
for data sets with codominant markers, such an object can be
constructed by use of <code><a href="#topic+allele2zeroone">allele2zeroone</a></code> before
<code><a href="#topic+prabinit">prabinit</a></code>.)</p>
</td></tr>
<tr><td><code id="lociplots_+3A_lcluster">lcluster</code></td>
<td>
<p>integer. Number of cluster in <code>locclust</code> for
which plot and statistics are produced.</p>
</td></tr>
<tr><td><code id="lociplots_+3A_symbols">symbols</code></td>
<td>
<p>vector of plot symbols. If <code>NULL</code>,
<code>indclust$symbols</code> is used.</p>
</td></tr>
<tr><td><code id="lociplots_+3A_brightest.grey">brightest.grey</code></td>
<td>
<p>numeric between 0 and 1. Brightest grey value
used in plot for individuals with smallest marker percentage, see
details.</p>
</td></tr>
<tr><td><code id="lociplots_+3A_darkest.grey">darkest.grey</code></td>
<td>
<p>numeric between 0 and 1. Darkest grey value
used in plot for individuals with highest marker percentage, see
details.</p>
</td></tr>
<tr><td><code id="lociplots_+3A_mdsdim">mdsdim</code></td>
<td>
<p>vector of two integers. The two MDS variables taken from
<code>indclust</code> used for visualisation.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Plot and statistics are based on the individual marker percentage,
which is the percentage of markers present in an individual of the
markers belonging to cluster no. <code>lcluster</code>. In the plot, the
grey value visualises the marker percentage.
</p>


<h3>Value</h3>

<p>list with components
</p>
<table>
<tr><td><code>locfreq</code></td>
<td>
<p>vector of individual marker percentages.</p>
</td></tr>
<tr><td><code>locfreqmin</code></td>
<td>
<p>vector of minimum individual marker precentages for
each cluster in <code>indclust</code>-clustering (the first value refers
to the &quot;noise component&quot;, if present).</p>
</td></tr>
<tr><td><code>locfreqmax</code></td>
<td>
<p>vector of maximum individual marker precentages for
each cluster in <code>indclust</code>-clustering (the first value refers
to the &quot;noise component&quot;, if present).</p>
</td></tr>
<tr><td><code>locfreqmean</code></td>
<td>
<p>vector of average individual marker precentages for
each cluster in <code>indclust</code>-clustering (the first value refers
to the &quot;noise component&quot;, if present).</p>
</td></tr>  
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+prabclust">prabclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
  options(digits=4)
  data(veronica)
  vei &lt;- prabinit(prabmatrix=veronica[1:50,],distance="jaccard")
  ppv &lt;- prabclust(vei)
  veloci &lt;- prabinit(prabmatrix=veronica[1:50,],rows.are.species=FALSE)
  velociclust &lt;- prabclust(veloci,nnk=0)
  lociplots(ppv,velociclust$clustering,veloci,lcluster=3)

</code></pre>

<hr>
<h2 id='nastats'>Missing values statistics for matrix</h2><span id='topic+nastats'></span>

<h3>Description</h3>

<p>Computes column-wise and row-wise numbers of missing values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nastats(amatrix, nastr="--")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nastats_+3A_amatrix">amatrix</code></td>
<td>
<p>(any) matrix.</p>
</td></tr>
<tr><td><code id="nastats_+3A_nastr">nastr</code></td>
<td>
<p>missing value indicator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>narow</code></td>
<td>
<p>vector of row-wise numbers of mixxing values.</p>
</td></tr>
<tr><td><code>nacol</code></td>
<td>
<p>vector of column-wise numbers of mixxing values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  xx &lt;- cbind(c(1,2,3),c(0,0,1),c(5,3,1))
  nastats(xx,nastr=0)
</code></pre>

<hr>
<h2 id='nb'>Neighborhood list for Aegean islands</h2><span id='topic+nb'></span>

<h3>Description</h3>

<p>List of neighboring islands for 34 Aegean islands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nb)</code></pre>


<h3>Format</h3>

<p>List with 34 components, all being vetors of integers (or
<code>numeric(0)</code> in case of no neighbors) indicating the neighboring
islands.
</p>


<h3>Details</h3>

<p>Reads from example data file <code>nb.dat</code>.
</p>


<h3>Source</h3>

<p>B. Hausdorf and C. Hennig (2005) The influence of recent geography,
palaeography and climate on the composition of the faune of the
central Aegean Islands. <em>Biological Journal of the Linnean
Society</em> 84, 785-795. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nb)
# nb &lt;- list()
# for (i in 1:34)
#   nb &lt;- c(nb,list(scan(file="(path/)nb.dat",
#                   skip=i-1,nlines=1)))
</code></pre>

<hr>
<h2 id='nbtest'>Test of neighborhood list</h2><span id='topic+nbtest'></span>

<h3>Description</h3>

<p>Tests a list of neighboring regions for proper format. Neighborhood is
tested for being symmetrical. Causes an error if tests fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nbtest(nblist, n.regions=length(nblist))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nbtest_+3A_nblist">nblist</code></td>
<td>
<p>A list with a component for
every region. The
components are vectors of integers indicating
neighboring regions. A region without neighbors (e.g., an island)
should be assigned a vector <code>numeric(0)</code>.</p>
</td></tr>
<tr><td><code id="nbtest_+3A_n.regions">n.regions</code></td>
<td>
<p>Number of regions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>invisible{TRUE}</code>.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+prabinit">prabinit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nb)
nbtest(nb)
nb[[1]][1] &lt;- 1
try(nbtest(nb))
</code></pre>

<hr>
<h2 id='nn'>Mean distance to kth nearest neighbor</h2><span id='topic+nn'></span>

<h3>Description</h3>

<p>Computes the mean of the distances from each point to its <code>ne</code>th
nearest neighbor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn(distmat, ne = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nn_+3A_distmat">distmat</code></td>
<td>
<p>symmetric distance matrix (not a <code>dist</code>-object).</p>
</td></tr>
<tr><td><code id="nn_+3A_ne">ne</code></td>
<td>
<p>integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabtest">prabtest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kykladspecreg)
j &lt;- jaccard(t(kykladspecreg))
nn(j,4)
</code></pre>

<hr>
<h2 id='NNclean'>Nearest neighbor based clutter/noise detection</h2><span id='topic+NNclean'></span><span id='topic+print.nnclean'></span>

<h3>Description</h3>

<p>Detects if data points are noise or part of a cluster,
based on a Poisson process model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NNclean(data, k, distances = NULL, edge.correct = FALSE, wrap = 0.1,
convergence = 0.001, plot=FALSE, quiet=TRUE)

## S3 method for class 'nnclean'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NNclean_+3A_data">data</code></td>
<td>
<p>numerical matrix or data frame.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_k">k</code></td>
<td>
<p>integer. Number of considered nearest neighbors per point.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_distances">distances</code></td>
<td>
<p>distance matrix object of class <code>dist</code>. If
specified, it is used instead of computing distances from the data.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_edge.correct">edge.correct</code></td>
<td>
<p>logical. If <code>TRUE</code> and the data is
two-dimensional, neighbors for points at the edges of the parent
region of the noise Poisson process are determined after wrapping
the region onto a toroid.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_wrap">wrap</code></td>
<td>
<p>numerical. If <code>edge.correct=TRUE</code>, points in a
strip of size <code>wrap*range</code> along the edge for each variable
are candidates for
being neighbors of points from the opposite.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_convergence">convergence</code></td>
<td>
<p>numerical. Convergence criterion for EM-algorithm.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>, a histogram of the distance to
kth nearest neighbor and fit is plotted.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_quiet">quiet</code></td>
<td>
<p>logical. If <code>FALSE</code>, the likelihood is printed
during the iterations.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_x">x</code></td>
<td>
<p>object of class <code>nnclean</code>.</p>
</td></tr>
<tr><td><code id="NNclean_+3A_...">...</code></td>
<td>
<p>necessary for print methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assumption is that the noise is distributed as a homogeneous
Poisson process  on a certain region and the clusters are distributed
as a homogeneous Poisson process with larger intensity on a
subregion (disconnected in case of more than one cluster).
The distances are then distributed according to a mixture of two
transformed Gamma distributions, and this mixture is estimated via the
EM-algorithm. The points are assigned to noise or cluster component
by use of the estimated a posteriori probabilities. 
</p>


<h3>Value</h3>

<p><code>NNclean</code> returns a list of class <code>nnclean</code> with components
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>0-1-vector of length of the number of data points. 1 means
cluster, 0 means noise.</p>
</td></tr>
<tr><td><code>probs</code></td>
<td>
<p>vector of estimated a priori probabilities for each point
to belong to the cluster component.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>lambda1</code></td>
<td>
<p>intensity parameter of cluster component.</p>
</td></tr>
<tr><td><code>lambda2</code></td>
<td>
<p>intensity parameter of noise component.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>estimated probability of cluster component.</p>
</td></tr>
<tr><td><code>kthNND</code></td>
<td>
<p>distance to kth nearest neighbor.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The software can be freely used for non-commercial purposes, and can
be freely distributed for non-commercial purposes only.</p>


<h3>Author(s)</h3>

<p>R-port by Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a>,<br />
original Splus package by S. Byers and A. E. Raftery.
</p>


<h3>References</h3>

<p>Byers, S. and Raftery, A. E. (1998) Nearest-Neighbor Clutter
Removal for Estimating Features in Spatial Point Processes,
<em>Journal of the American Statistical Association</em>, 93, 577-584.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mclust)
data(chevron)
nnc &lt;-  NNclean(chevron[,2:3],15,plot=TRUE)
plot(chevron[,2:3],col=1+nnc$z)
</code></pre>

<hr>
<h2 id='phipt'>Distances between communities, auxiliary functions</h2><span id='topic+phipt'></span><span id='topic+cfchord'></span><span id='topic+shared.problist'></span><span id='topic+diploidcomlist'></span>

<h3>Description</h3>

<p>Auxiliary functions for <code><a href="#topic+communitydist">communitydist</a></code>. <code>phipt</code>
computes phiPT/phiST (Peakall and Smouse, 2012, Meirmans,
2006) between two communities. <code>cfchord</code> computes the
chord-distance (Cavalli-Sforza and Edwards, 1967) between two lists or
locus-wise relative allele frequencies. <code>shared.problist</code>
computes a straightforward generalisation of the shared allele
distance (Bowcock et al., 1994) between
individuals for communities, namely the &lsquo;overlap&rsquo;, i.e., sum of the
minima of the
allele relative frequencies. <code>diploidcomlist</code> constructs the
input lists for <code>cfchord</code> and <code>shared.problist</code> from an
<code>alleleobject</code>. It provides relative frequencies for all
alles of all loci in all communities. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
phipt(alleleobj,comvector,i,j)
cfchord(p1,p2)
shared.problist(p1,p2)
diploidcomlist(alleleobj,comvector,diploid=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phipt_+3A_alleleobj">alleleobj</code></td>
<td>
<p>if <code>diploid=TRUE</code>, an object of class
<code>alleleobject</code> as produced by
function  <code><a href="#topic+alleleinit">alleleinit</a></code>. This has the required
information on the individuals that are grouped into communities. In
case <code>diploid=FALSE</code>, a list that needs to have components
<code>n.variables</code> (number of loci), <code>alevels</code> (vector of
allele names, see <code><a href="#topic+alleleinit">alleleinit</a></code>) and
<code>charmatrix</code> (matrix of characters with one row for every
individual and one column for every locus giving the alleles; see
examples below for how this can be constructed for a
<code>prabobject</code> with presence-absence data).</p>
</td></tr>
<tr><td><code id="phipt_+3A_comvector">comvector</code></td>
<td>
<p>vector of integers indicating to which
community an individual belongs.</p>
</td></tr>
<tr><td><code id="phipt_+3A_i">i</code></td>
<td>
<p>integer. Number of community.</p>
</td></tr>
<tr><td><code id="phipt_+3A_j">j</code></td>
<td>
<p>integer. Number of community. The phiPT-distance is computed
between the communities numbered <code>i</code> and <code>j</code></p>
</td></tr>
<tr><td><code id="phipt_+3A_p1">p1</code></td>
<td>
<p>list. Every list entry refers to a locus and is a vector of
relative frequencies of the alleles present in that locus in a
community.</p>
</td></tr> 
<tr><td><code id="phipt_+3A_p2">p2</code></td>
<td>
<p>list. Every list entry refers to a locus and is a vector of
relative frequencies of the alleles present in that locus in a
community. The chord or shared allele distance is computed between
the communities encoded by <code>p1</code> and <code>p2</code>.</p>
</td></tr> 
<tr><td><code id="phipt_+3A_diploid">diploid</code></td>
<td>
<p>logical, indicating whether loci are diploid, see
<code>alleleobj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>cfchord</code> gives out the value of the chord
distance. <code>shared.problist</code> gives out the distance
value. <code>diploidcomlist</code> gives out a two-dimensional list. The
list has one entry for each community, which is itself a list. This
community list has one entry for each locus, which is a vector that
gives the relative frequencies of the different alleles in    
<code>phipt</code> gives out a list with components <code>phipt, vap, n0,
  sst, ssg, msa, msw</code>. These refer to the notation on p.2.12 and 2.15 of
Peakall and Smouse (2012).
</p>
<table>
<tr><td><code>phipt</code></td>
<td>
<p>value of phiPT.</p>
</td></tr>
<tr><td><code>vap</code></td>
<td>
<p>variance among (between) populations (communities).</p>
</td></tr>
<tr><td><code>n0</code></td>
<td>
<p>standardisation factor N0, see  p.2.12 of Peakall and Smouse (2012).</p>
</td></tr>
<tr><td><code>sst</code></td>
<td>
<p>total distances sum of squares.</p>
</td></tr>
<tr><td><code>ssg</code></td>
<td>
<p>vector with two non-<code>NA</code> entriesm, within community
sums of squares for communities <code>i</code> and <code>j</code>.</p>
</td></tr>
<tr><td><code>msa</code></td>
<td>
<p>mean square between communities.</p>
</td></tr>
<tr><td><code>msw</code></td>
<td>
<p>mean square within communities.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Bowcock, A. M., Ruiz-Linares, A., Tomfohrde, J., Minch, E., Kidd, J. R.,
Cavalli-Sforza, L. L. (1994) High resolution of human evolutionary
trees with polymorphic microsatellites. <em>Nature</em> 368, 455-457.
</p>
<p>Cavalli-Sforza, L. L. and Edwards, A. W. F. (1967) Phylogenetic
Analysis - Models and Estimation Procedures. <em>The American Journal of
Human Genetics</em> 19, 233-257.
</p>
<p>Meirmans, P. G. (2006) Using the AMOVA framework to estimate a
standardized genetic differentiation measure. <em>Evolution</em> 60, 2399-2402.
</p>
<p>Peakall, R. and Smouse P.E. (2012) GenAlEx Tutorial 2.
<a href="https://biology-assets.anu.edu.au/GenAlEx/Tutorials.html">https://biology-assets.anu.edu.au/GenAlEx/Tutorials.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+communitydist">communitydist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(tetragonula)
  tnb &lt;-
  coord2dist(coordmatrix=tetragonula.coord[83:120,],cut=50,file.format="decimal2",neighbors=TRUE)
  ta &lt;- alleleconvert(strmatrix=tetragonula[83:120,])
  tai &lt;- alleleinit(allelematrix=ta,neighborhood=tnb$nblist)
  tetracoms &lt;-
  c(rep(1:3,each=3),4,5,rep(6:11,each=2),12,rep(13:19,each=2))
  phipt(tai,tetracoms,4,6)
  tdip &lt;- diploidcomlist(tai,tetracoms,diploid=TRUE)
  cfchord(tdip[[4]],tdip[[6]])
  shared.problist(tdip[[4]],tdip[[6]])
  
</code></pre>

<hr>
<h2 id='piecewiselin'>Piecewise linear transformation for distance matrices</h2><span id='topic+piecewiselin'></span>

<h3>Description</h3>

<p>Piecewise linear transformation for distance matrices, utility
function for <code>geco</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewiselin(distmatrix, maxdist=0.1*max(distmatrix))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewiselin_+3A_distmatrix">distmatrix</code></td>
<td>
<p>symmetric (non-negative) distance matrix.</p>
</td></tr>
<tr><td><code id="piecewiselin_+3A_maxdist">maxdist</code></td>
<td>
<p>non-negative numeric. Larger distances are transformed
to constant 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transforms large distances to 1, 0 to 0 and continuously linear between 0 and
<code>maxdist</code>.
</p>


<h3>Value</h3>

<p>A symmetrical matrix.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+geco">geco</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(waterdist)
piecewiselin(waterdist)
</code></pre>

<hr>
<h2 id='plotdistreg'>Plots for within-groups and between-groups distance regression</h2><span id='topic+plotdistreg'></span>

<h3>Description</h3>

<p>Visualisation of various regressions on distance (or dissimilarity)
data where objects are from two groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotdistreg(dmx,dmy,grouping,groups=levels(as.factor(grouping))[1:2],
                        cols=c(1,2,3,4),
                        pchs=rep(1,3),
                        ltys=c(1,2,1,2),
                        individual=TRUE,jointwithin=TRUE,jointall=TRUE,
                        oneplusjoint=TRUE,jittering=TRUE,bcenterline=TRUE,
                        xlim=NULL,ylim=NULL,xlab="geographical distance",
                        ylab="genetic distance",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotdistreg_+3A_dmx">dmx</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Explanatory dissimilarities (often these will be proper
distances, but more general dissimilarities that do not
necessarily fulfill the triangle inequality can be used, same for <code>dmy</code>).</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_dmy">dmy</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Response dissimilarities.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_grouping">grouping</code></td>
<td>
<p>something that can be coerced into a factor,
defining the grouping of
objects represented by the dissimilarities <code>dmx</code> and <code>dmy</code>
(i.e., if <code>grouping</code> has length n, <code>dmx</code> and <code>dmy</code>
must be dissimilarities between <code>n</code> objects).</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_groups">groups</code></td>
<td>
<p>Vector of two levels. The two groups defining the
regressions to be compared in the test. These can be
factor levels, integer numbers, or strings, depending on the entries
of <code>grouping</code>.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_cols">cols</code></td>
<td>
<p>vector of four colors (or color numbers) to be used for
plotting distances 
and regression lines within the first group, within the second group,
distances between groups, and a line marking the center of the
between-groups explanatory distances, see <code>col</code>-argument of
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_pchs">pchs</code></td>
<td>
<p>vector of three plot symbols (or numbers) to be used for
plotting distances within the first group, within the second group,
and distances between groups, see <code>pch</code>-argument of
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_ltys">ltys</code></td>
<td>
<p>vector of line type numbers to be used for single group
within-group regression, both groups combined within-group
regression, regression with all distances, and regression combining
within-groups distances of one group with between-groups distances,
see <code>lty</code>-argument of
<code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_individual">individual</code></td>
<td>
<p>if <code>TRUE</code>, within-groups distances regression
lines are shown for both groups.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_jointwithin">jointwithin</code></td>
<td>
<p>if <code>TRUE</code>, the within-groups distances regression
line for both groups combined is shown.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_jointall">jointall</code></td>
<td>
<p>if <code>TRUE</code>, the regression
line based on all distances is shown.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_oneplusjoint">oneplusjoint</code></td>
<td>
<p>if <code>TRUE</code>, the regression lines combining
within-groups distances of one group with between-groups distances
are shown (the colors of these are the colors of the individual
groups, the first two components of the <code>cols</code>-argument).</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_jittering">jittering</code></td>
<td>
<p>if <code>TRUE</code>, points are jittered to avoid
overplotting.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_bcenterline">bcenterline</code></td>
<td>
<p>if <code>TRUE</code>, a line is plotted to mark the
center of the between-groups distances on the explanatory variable.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_xlim">xlim</code></td>
<td>
<p>to be passed on to <code><a href="graphics.html#topic+plot">plot</a></code>; the default is
determined from the involved distances.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_ylim">ylim</code></td>
<td>
<p>to be passed on to <code><a href="graphics.html#topic+plot">plot</a></code>; the default is
determined from the involved distances.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_xlab">xlab</code></td>
<td>
<p>to be passed on to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotdistreg_+3A_ylab">ylab</code></td>
<td>
<p>to be passed on to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>  
<tr><td><code id="plotdistreg_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed on to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regeqdist">regeqdist</a></code>, <code><a href="#topic+regdistbetween">regdistbetween</a></code>,
<code><a href="#topic+regdistbetweenone">regdistbetweenone</a></code>, <code><a href="#topic+regdistdiffone">regdistdiffone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[173:207,],file.format="decimal2")
  vei &lt;- prabinit(prabmatrix=veronica[173:207,],distance="jaccard")

  species &lt;-c(rep(1,13),rep(2,22))
  loggeo &lt;- log(ver.geo+quantile(as.vector(as.dist(ver.geo)),0.25))
  plotdistreg(dmx=loggeo,dmy=vei$distmat,grouping=species,
  jointwithin=FALSE,jointall=FALSE,groups=c(1,2))
  legend(5,0.75,c("within species 1",
  "within species 2","species 1 and between","species 2 and between"),lty=c(1,1,2,2),col=c(1,2,1,2))
  plotdistreg(dmx=loggeo,dmy=vei$distmat,grouping=species,
  jointwithin=TRUE,jointall=TRUE,oneplusjoint=FALSE,groups=c(1,2))
  legend(5,0.75,c("within species 1",
  "within species 2","all distances","all within species"),lty=c(1,1,1,2),col=c(1,2,3,3))
  

</code></pre>

<hr>
<h2 id='pop.sim'>p-value simulation for presence-absence matrices clustering test</h2><span id='topic+pop.sim'></span>

<h3>Description</h3>

<p>Parametric bootstrap simulation of the p-value of a test of a
homogeneity hypothesis against clustering (or significant nestedness).
Designed for use within
<code><a href="#topic+prabtest">prabtest</a></code>. The null model is defined by
<code><a href="#topic+randpop.nb">randpop.nb</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop.sim(regmat, neighbors, h0c = 1, times = 200, dist = "kulczynski",
teststat = "isovertice", testc = NULL, geodist=NULL, gtf=0.1,
n.species = ncol(regmat),
specperreg = NULL, regperspec = NULL, species.fixed=FALSE, pdfnb=FALSE,
ignore.richness=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop.sim_+3A_regmat">regmat</code></td>
<td>
<p>0-1-matrix. Columns are species, rows are regions.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_neighbors">neighbors</code></td>
<td>
<p>A list with a component for every region. The
components are vectors of integers indicating
neighboring regions. A region without neighbors (e.g., an island)
should be assigned a list <code>numeric(0)</code>.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_h0c">h0c</code></td>
<td>
<p>numerical. Parameter <code>p.nb</code> for use in <code>randpop.nb</code>.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_times">times</code></td>
<td>
<p>integer. Number of simulation runs.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_dist">dist</code></td>
<td>
<p>&quot;kulczynski&quot;, &quot;jaccard&quot; or &quot;geco&quot;, see <code>kulczynski</code>,
<code>geco</code> and <code>jaccard</code>.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_teststat">teststat</code></td>
<td>
<p>&quot;isovertice&quot;, &quot;lcomponent&quot;, &quot;distratio&quot;, &quot;nn&quot; or
&quot;inclusions&quot;. See
the corresponding functions, <code>homogen.test</code> for &quot;isovertice&quot;,
<code>incmatrix</code> for &quot;inclusions&quot;).</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_testc">testc</code></td>
<td>
<p>numerical. Tuning constant for the test statistics.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_geodist">geodist</code></td>
<td>
<p>matrix of non-negative reals. Geographical distances
between regions. Only used if <code>dist="geco"</code>.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_gtf">gtf</code></td>
<td>
<p>tuning constant for geco-distance if <code>dist="geco"</code>,
see <code>"geco"</code>.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_n.species">n.species</code></td>
<td>
<p>integer. Number of species.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_specperreg">specperreg</code></td>
<td>
<p>vector of integers. Numbers of species per region
(is calculated from the data by default).</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_regperspec">regperspec</code></td>
<td>
<p>vector of integers. Number of regions per species
(is calculated from the data by default).</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_species.fixed">species.fixed</code></td>
<td>
<p>logical. If <code>TRUE</code>, the sizes of the species
are taken directly from <code>regmat</code>. Otherwise, they are drawn by
random from the empirical distribution of the values from
<code>regmat</code>.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_pdfnb">pdfnb</code></td>
<td>
<p>logical. Probability correction in <code>randpop.nb</code>.</p>
</td></tr>
<tr><td><code id="pop.sim_+3A_ignore.richness">ignore.richness</code></td>
<td>
<p>logical. If <code>TRUE</code>, there is no assumption
of species richnesses to differ between regions in the null model.
Regionwise probabilities don't differ in the generation of null
data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with components
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>vector of teststatistic values for the simulated matrices.</p>
</td></tr>
<tr><td><code>p.above</code></td>
<td>
<p>p-value if large test statistic leads to rejection.</p>
</td></tr>
<tr><td><code>p.below</code></td>
<td>
<p>p-value if small test statistic leads to rejection.</p>
</td></tr>
<tr><td><code>datac</code></td>
<td>
<p>test statistic value for the original data.</p>
</td></tr>
<tr><td><code>testc</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
<a href="http://stat.ethz.ch/Research-Reports/110.html">http://stat.ethz.ch/Research-Reports/110.html</a>.
</p>
<p>Hausdorf, B. and Hennig, C. (2003)  Biotic Element Analysis in
Biogeography. <em>Systematic Biology</em> 52, 717-723.
</p>
<p>Hausdorf, B. and Hennig, C. (2003) Nestedness of north-west European
land snail ranges as a consequence of differential immigration from
Pleistocene glacial refuges. <em>Oecologia</em> 135, 102-109.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabtest">prabtest</a></code>, <code><a href="#topic+randpop.nb">randpop.nb</a></code>,
<code><a href="#topic+jaccard">jaccard</a></code>, <code><a href="#topic+kulczynski">kulczynski</a></code>,
<code><a href="#topic+homogen.test">homogen.test</a></code>, <code><a href="#topic+lcomponent">lcomponent</a></code>,
<code><a href="#topic+distratio">distratio</a></code>, <code><a href="#topic+nn">nn</a></code>,
<code><a href="#topic+incmatrix">incmatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
data(nb)
set.seed(1234)
pop.sim(t(kykladspecreg), nb, times=5, h0c=0.35, teststat="nn", testc=3)
</code></pre>

<hr>
<h2 id='prab.sarestimate'>Estimates SAR model from log-abundance matrix of prab-object.</h2><span id='topic+prab.sarestimate'></span>

<h3>Description</h3>

 
<p>This is either an interface for the function <code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code>
for abundance data stored in an object of class <code><a href="#topic+prab">prab</a></code>
implemented for use in <code><a href="#topic+abundtest">abundtest</a></code>, or, in case that spatial
information should be ignored, it estimates a two-way additive
unreplicated linear
model for log-abundances on factors species and region. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prab.sarestimate(abmat, prab01=NULL,sarmethod="eigen",
                             weightstyle="C",
                             quiet=TRUE, sar=TRUE,
                             add.lmobject=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prab.sarestimate_+3A_abmat">abmat</code></td>
<td>
<p>object of class <code>prab</code>.</p>
</td></tr>
<tr><td><code id="prab.sarestimate_+3A_prab01">prab01</code></td>
<td>
<p>presence-absence matrix of same dimensions than the
abundance matrix of <code>prabobj</code>. This specifies the presences and
absences on which the presence/absence step of abundance-based tests
is based (see details). If <code>NULL</code> (which is usually the only
reasonable choice), <code>prab01</code> is computed in order to indicate
the nonzeroes of <code>prabobj$prab</code>.</p>
</td></tr>
<tr><td><code id="prab.sarestimate_+3A_sarmethod">sarmethod</code></td>
<td>
<p>this is passed on as parameter <code>method</code> to
<code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code> and documented there. We don't have
experience with any other choice than <code>"eigen"</code>.</p>
</td></tr> 
<tr><td><code id="prab.sarestimate_+3A_weightstyle">weightstyle</code></td>
<td>
<p>can take values &quot;W&quot;, &quot;B&quot;, &quot;C&quot;, &quot;U&quot;, and &quot;S&quot; though tests
suggest that &quot;C&quot; should be chosen. See <code><a href="spdep.html#topic+nb2listw">nb2listw</a></code>.</p>
</td></tr> 
<tr><td><code id="prab.sarestimate_+3A_quiet">quiet</code></td>
<td>
<p>this is passed on as parameter <code>quiet</code> to
<code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code> and documented there.</p>
</td></tr> 
<tr><td><code id="prab.sarestimate_+3A_sar">sar</code></td>
<td>
<p>logical. If <code>TRUE</code>, a simultaneous autoregression
model is fitted by calling <code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code>. If
<code>FALSE</code>, a two-way additive
unreplicated linear
model for log-abundances on factors species and region is computed
by <code><a href="stats.html#topic+lm">lm</a></code>,
ignoring the spatial arrangement of the regions.</p>
</td></tr> 
<tr><td><code id="prab.sarestimate_+3A_add.lmobject">add.lmobject</code></td>
<td>
<p>logical. If <code>TRUE</code>, the whole output object
of <code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code> (or <code>lm</code>) is given out.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>sar</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>numeric. Estimator of the intercept.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>numeric. Estimator of error standard deviation.</p>
</td></tr>
<tr><td><code>regeffects</code></td>
<td>
<p>numeric vector. Estimator for region effects.</p>
</td></tr>
<tr><td><code>speceffects</code></td>
<td>
<p>numeric vector. Estimator for species effects.</p>
</td></tr>
<tr><td><code>lamda</code></td>
<td>
<p>numeric. Governs the degree of spatial
autocorrelation. See <code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code>.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>integer. Length of neighborhood list generated by
<code><a href="spdep.html#topic+nb2listw">nb2listw</a></code> used by
<code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code>.</p>
</td></tr>
<tr><td><code>nbweight</code></td>
<td>
<p>numeric. Average weight of neighbors.</p>
</td></tr>
<tr><td><code>lmobject</code></td>
<td>
<p>if <code>add.lmobject=TRUE</code>, output object of either
<code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code>,
<code><a href="#topic+abundtest">abundtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(siskiyou)
  x &lt;- prabinit(prabmatrix=siskiyou, neighborhood=siskiyou.nb,
             distance="none")
#  Not run; this needs package spdep 
#  prab.sarestimate(x)
  prab.sarestimate(x, sar=FALSE)
</code></pre>

<hr>
<h2 id='prabclus-package'>prabclus package overview</h2><span id='topic+prabclus-package'></span>

<h3>Description</h3>

<p>Here is a list of the main functions in package prabclus. Most other
functions are auxiliary functions for these.
</p>


<h3>Initialisation</h3>


<dl>
<dt>prabinit</dt><dd><p>Initialises presence/absence-, abundance- and
multilocus data with dominant markers for use with most other key
prabclus-functions.</p>
</dd>
<dt>alleleinit</dt><dd><p>Initialises multilocus data with codominant
markers for use with key prabclus-functions.</p>
</dd>
<dt>alleleconvert</dt><dd><p>Generates the input format required by
<code><a href="#topic+alleleinit">alleleinit</a></code>.</p>
</dd>
</dl>


<h3>Tests for clustering and nestedness</h3>


<dl>
<dt>prabtest</dt><dd>
<p>Computes the tests introduced in Hausdorf and Hennig (2003) and
Hennig and Hausdorf (2004; these tests occur in some further 
publications of ours but this one is the most detailed statistical
reference) for presence/absence data. Allows use of the
geco-dissimilarity (Hennig and Hausdorf, 2006).</p>
</dd>
<dt>abundtest</dt><dd>
<p>Computes the test introduced in Hausdorf and Hennig (2007) for
abundance data.</p>
</dd>
<dt>homogen.test</dt><dd><p>A classical distance-based test for homogeneity
going back to Erdos and Renyi (1960) and Ling (1973).</p>
</dd>
</dl>


<h3>Clustering</h3>


<dl>
<dt>prabclust</dt><dd><p>Species clustering for biotic element analysis
(Hausdorf and Hennig, 2007, Hennig and Hausdorf, 2004 and others),
clustering of individuals for species delimitation (Hausdorf and
Hennig, 2010) based on Gaussian mixture model clustering with
noise as implemented in R-package <code>mclust</code>, Fraley and
Raftery (1998),  on output of
multidimensional scaling from distances as computed by
<code><a href="#topic+prabinit">prabinit</a></code> or <code><a href="#topic+alleleinit">alleleinit</a></code>. See also
<code><a href="#topic+stressvals">stressvals</a></code> for help with choosing the number of
MDS-dimensions.</p>
</dd> 
<dt>hprabclust</dt><dd><p>An unpublished alternative to
<code><a href="#topic+prabclust">prabclust</a></code> using hierarchical clustering methods.</p>
</dd>
<dt>lociplots</dt><dd><p>Visualisation of clusters of genetic markers vs.
clusters of species.</p>
</dd>
<dt>NNclean</dt><dd><p>Nearest neighbor based classification of observations
as noise/outliers according to Byers and Raftery (1998).</p>
</dd>
</dl>


<h3>Dissimilarity matrices</h3>


<dl>
<dt>alleledist</dt><dd><p>Shared allele distance (see the corresponding help
pages for references).</p>
</dd>
<dt>dicedist</dt><dd><p>Dice distance.</p>
</dd>
<dt>geco</dt><dd><p>geco coefficient, taking geographical distance into account.</p>
</dd>
<dt>jaccard</dt><dd><p>Jaccard distance.</p>
</dd>
<dt>kulczynski</dt><dd><p>Kulczynski dissimilarity.</p>
</dd>
<dt>qkulczynski</dt><dd><p>Quantitative Kulczynski dissimilarity for
abundance data.</p>
</dd>
</dl>


<h3>Communities</h3>


<dl>
<dt>communities</dt><dd><p>Constructs communities from geographical
distances between individuals.</p>
</dd>
<dt>communitydist</dt><dd><p>chord-, phiPT- and various versions of the
shared allele distance between communities.</p>
</dd>
</dl>


<h3>Tests for equality of dissimilarity-based regression</h3>


<dl>
<dt>regeqdist</dt><dd><p>Jackknife-based test for equality of
two independent regressions between distances (Hausdorf and Hennig
2019).</p>
</dd>
<dt>regdistbetween</dt><dd><p>Jackknife-based test for equality of
regression involving all distances and regression involving
within-group distances only (Hausdorf and Hennig
2019).</p>
</dd>
<dt>regdistbetweenone</dt><dd><p>Jackknife-based test for equality of
regression involving within-group distances of a reference group
only and regression involving between-group distances (Hausdorf
and Hennig 2019).</p>
</dd>
</dl>


<h3>Small conversion functions</h3>


<dl>
<dt>coord2dist</dt><dd><p>Computes geographical distances from geographical
coordinates.</p>
</dd>
<dt>geo2neighbor</dt><dd><p>Computes a neighborhood list from geographical
distances.</p>
</dd>
<dt>alleleconvert</dt><dd><p>A somewhat restricted function for conversion
of different file formats used for genetic data with codominant markers.</p>
</dd>
</dl>


<h3>Data sets</h3>

<p><code><a href="#topic+kykladspecreg">kykladspecreg</a></code>, <code><a href="#topic+siskiyou">siskiyou</a></code>,
<code><a href="#topic+veronica">veronica</a></code>, <code><a href="#topic+tetragonula">tetragonula</a></code>.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en/">https://www.unibo.it/sitoweb/christian.hennig/en/</a>
</p>


<h3>References</h3>

<p>Byers, S. and Raftery, A. E. (1998) Nearest-Neighbor Clutter
Removal for Estimating Features in Spatial Point Processes,
<em>Journal of the American Statistical Association</em>, 93, 577-584.
</p>
<p>Erdos, P. and Renyi, A. (1960) On the evolution of random
graphs. <em>Publications of the Mathematical Institute of the
Hungarian Academy of Sciences</em> 5, 17-61.
</p>
<p>Fraley, C.  and Raftery, A. E. (1998) How many clusters? Which
clusterin method? - Answers via Model-Based Cluster Analysis.
<em>Computer Journal</em> 41, 578-588.
</p>
<p>Hausdorf, B. and Hennig, C. (2003) Nestedness of north-west European
land snail ranges as a consequence of differential immigration from
Pleistocene glacial refuges. <em>Oecologia</em> 135, 102-109.
</p>
<p>Hausdorf, B. and Hennig, C. (2007) Null model tests of clustering of
species, negative co-occurrence patterns and nestedness in meta-communities.
<em>Oikos</em> 116, 818-828. 
</p>
<p>Hausdorf, B. and Hennig, C. (2010) Species Delimitation Using Dominant
and Codominant Multilocus Markers. <em>Systematic Biology</em>, 59, 491-503.
</p>
<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>
<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
</p>
<p>Hennig, C. and Hausdorf, B. (2006)  A robust distance coefficient
between distribution areas incorporating geographic distances.
<em>Systematic Biology</em> 55, 170-175.
</p>
<p>Ling, R. F. (1973) A probability theory of cluster
analysis. <em>Journal of the American Statistical Association</em> 68,
159-164.
</p>

<hr>
<h2 id='prabclust'>Clustering for biotic elements or for species delimitation
(mixture method)</h2><span id='topic+prabclust'></span><span id='topic+print.prabclust'></span>

<h3>Description</h3>

<p>Clusters a presence-absence matrix object (for clustering
ranges/finding biotic elements, Hennig and Hausdorf, 2004) or
an object of genetic information (for species delimitation, Hausdorf
and Hennig, 2010)
by calculating an MDS from
the distances, and applying maximum likelihood Gaussian mixtures clustering
with &quot;noise&quot; (package <code>mclust</code>) to the MDS points. The solution
is plotted. A standard execution (using the default distance of
<code>prabinit</code>) will be <br />
<code>prabmatrix &lt;- prabinit(file="path/prabmatrixfile",
    neighborhood="path/neighborhoodfile")</code><br />
<code>clust &lt;- prabclust(prabmatrix)</code><br />
<code>print(clust)</code> <br />
Examples for species delimitation are given below in the examples section. 
<b>Note:</b> Data formats are described
on the <code><a href="#topic+prabinit">prabinit</a></code> and <code><a href="#topic+alleleinit">alleleinit</a></code>
help pages. You may also consider the example datasets
<code>kykladspecreg.dat</code>, <code>nb.dat</code>,
<code>Heterotrigona_indoFO.txt</code> or <code>MartinezOrtega04AFLP.dat</code>.
<br />
<b>Note:</b> <code>prabclust</code> calls the function
<code><a href="mclust.html#topic+mclustBIC">mclustBIC</a></code> in package mclust. An alternative is the use of <code><a href="#topic+hprabclust">hprabclust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prabclust(prabobj, mdsmethod = "classical", mdsdim = 4, nnk =
ceiling(prabobj$n.species/40), nclus = 0:9, modelid = "all", permutations=0)

## S3 method for class 'prabclust'
print(x, bic=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prabclust_+3A_prabobj">prabobj</code></td>
<td>
<p>object of class <code>prab</code> as
generated by <code>prabinit</code>. Presence-absence data to be analyzed.
(This can be geographical information for range clustering  
Can also be an object of class <code>alleleobject</code> as generated by
<code>alleleinit</code>. 
</p>
</td></tr>
<tr><td><code id="prabclust_+3A_mdsmethod">mdsmethod</code></td>
<td>
<p><code>"classical"</code>, <code>"kruskal"</code>, or
<code>"sammon"</code>. The MDS method
to transform the distances to data points. <code>"classical"</code> indicates
metric MDS by function <code>cmdscale</code>, <code>"kruskal"</code> is
non-metric MDS.</p>
</td></tr>
<tr><td><code id="prabclust_+3A_mdsdim">mdsdim</code></td>
<td>
<p>integer. Dimension of the MDS points. For
<code>mdsmethod=="kruskal"</code>, <code><a href="#topic+stressvals">stressvals</a></code> can be used to
see how the stress depends on <code>mdsdim</code> in order to choose
<code>mdsdim</code> to get a small stress (smaller than 5%, say).</p>
</td></tr>
<tr><td><code id="prabclust_+3A_nnk">nnk</code></td>
<td>
<p>integer. Number of nearest neighbors to determine the
initial noise estimation by <code>NNclean</code>. <code>nnk=0</code> fits the
model without a noise component.</p>
</td></tr>
<tr><td><code id="prabclust_+3A_nclus">nclus</code></td>
<td>
<p>vector of integers. Numbers of clusters to perform the
mixture estimation.</p>
</td></tr>
<tr><td><code id="prabclust_+3A_modelid">modelid</code></td>
<td>
<p>string. Model name for <code>mclustBIC</code> (see the
corresponding help page; all models or combinations of models
mentioned there are possible). <code>modelid="all"</code> compares all possible
models. Additionally, <code>"noVVV"</code> is possible, which
fits all methods except <code>"VVV"</code>.</p>
</td></tr>
<tr><td><code id="prabclust_+3A_permutations">permutations</code></td>
<td>
<p>integer. It has been found occasionally that
depending on the order of observations the algorithms <code>isoMDS</code>
and <code>mclustBIC</code> converge to different solutions. This is
because these methods require an ordering of the distances, which,
if equal distance values are involved, may depend on the order.
<code>prabclust</code> uses a standard ordering which should give a
reproducible solution in these cases as well. However, if
<code>permutations&gt;0</code>, which gives a number of random permutations
of the observations, the algorithm is carried out for every
permutation and the best solution (in terms of the BIC, based on the
lowest stress MDS configuration) is given out (for many datasets
this won't change anything except increasing the computing time).</p>
</td></tr>     
<tr><td><code id="prabclust_+3A_x">x</code></td>
<td>
<p>object of class <code>prabclust</code>. Output of
<code>prabclust</code>.</p>
</td></tr>
<tr><td><code id="prabclust_+3A_bic">bic</code></td>
<td>
<p>logical. If <code>TRUE</code>, information about the BIC
criterion to choose the model is displayed.</p>
</td></tr>
<tr><td><code id="prabclust_+3A_...">...</code></td>
<td>
<p>necessary for summary method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if <code>mdsmethod!="classical"</code>, zero distances between
non-identical objects are replaced by the smallest nonzero distance
divided by 10 to prevent the MDS methods from producing an error.
</p>


<h3>Value</h3>

<p><code>print.prabclust</code> does not produce output. 
<code>prabclust</code> generates an object of class <code>prabclust</code>. This is a
list with components
</p>
<table>
<tr><td><code>clustering</code></td>
<td>
<p>vector of integers indicating the cluster memberships of
the species. Noise can be recognized by output component <code>symbols</code>.</p>
</td></tr>
<tr><td><code>clustsummary</code></td>
<td>
<p>output object of <code>summary.mclustBIC</code>. A list
giving the optimal (according to BIC) parameters, 
conditional probabilities &lsquo;z&rsquo;, and loglikelihood, together with
the associated classification and its uncertainty. Note that the
numbering of clusters may differ from <code>clustering</code>, see
<code>csreorder</code>.</p>
</td></tr>
<tr><td><code>bicsummary</code></td>
<td>
<p>output object of <code>mclustBIC</code>. Bayesian Information
Criterion for the specified mixture models and numbers of clusters. </p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>numerical matrix. MDS configuration.</p>
</td></tr>
<tr><td><code>nnk</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>mdsdim</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>mdsmethod</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>symbols</code></td>
<td>
<p>vector of characters, similar to <code>clustering</code>, but
indicating estimated noise and points belonging to
one-point-components (which should be interpreted as some kind of
noise as well) by <code>"N"</code>. </p>
</td></tr>
<tr><td><code>permchange</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>permutations&gt;0</code> has
been used and the best solution is different from the one obtained
by the standard ordering. (This is just for information and has no
further operational consequences.)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that we used <code>mdsmethod="kruskal"</code> in our publications, but
<code>mdsmethod="classical"</code> is now the default, because of
occasional numerical instabilities of the <code>isoMDS</code>-implementation
for Jaccard, Kulczynski or geco distance matrices. 
</p>
<p>Sometimes, <code>prabclust</code> produces an error because <code>mclustBIC</code>
cannot handle all models properly. In this case we recommend to change
the <code>modelid</code> parameter. <code>"noVVV"</code> and <code>"VVV"</code> are
reasonable alternative choices (one of these is expected to reproduce
the error, but the other one might work).
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Fraley, C.  and Raftery, A. E. (1998) How many clusters? Which
clustering method? - Answers via Model-Based Cluster Analysis.
<em>Computer Journal</em> 41, 578-588.
</p>
<p>Hausdorf, B. and Hennig, C. (2010) Species Delimitation Using Dominant
and Codominant Multilocus Markers. <em>Systematic Biology</em>, 59, 491-503.
</p>
<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
<a href="http://stat.ethz.ch/Research-Reports/110.html">http://stat.ethz.ch/Research-Reports/110.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+mclustBIC">mclustBIC</a></code>, <code><a href="mclust.html#topic+summary.mclustBIC">summary.mclustBIC</a></code>,
<code><a href="#topic+NNclean">NNclean</a></code>, <code><a href="stats.html#topic+cmdscale">cmdscale</a></code>,
<code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>, <code><a href="MASS.html#topic+sammon">sammon</a></code>,
<code><a href="#topic+prabinit">prabinit</a></code>, <code><a href="#topic+hprabclust">hprabclust</a></code>,
<code><a href="#topic+alleleinit">alleleinit</a></code>, <code><a href="#topic+stressvals">stressvals</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Biotic element/range clustering:
data(kykladspecreg)
data(nb)
set.seed(1234)
x &lt;- prabinit(prabmatrix=kykladspecreg, neighborhood=nb)
# If you want to use your own ASCII data files, use
# x &lt;- prabinit(file="path/prabmatrixfile",
# neighborhood="path/neighborhoodfile")
print(prabclust(x))

# Here is an example for species delimitation with codominant markers;
# only 50 individuals were used in order to have a fast example. 
data(tetragonula)
ta &lt;- alleleconvert(strmatrix=tetragonula[1:50,])
tai &lt;- alleleinit(allelematrix=ta)
print(prabclust(tai))

# Here is an example for species delimitation with dominant markers;
# only 50 individuals were used in order to have a fast example.
# You may want to use stressvals to choose mdsdim.
data(veronica)
vei &lt;- prabinit(prabmatrix=veronica[1:50,],distance="jaccard")
print(prabclust(vei,mdsmethod="kruskal",mdsdim=3))

</code></pre>

<hr>
<h2 id='prabinit'>Presence-absence/abundance matrix initialization</h2><span id='topic+prabinit'></span><span id='topic+print.prab'></span><span id='topic+prab'></span>

<h3>Description</h3>

<p><code>prabinit</code> converts a matrix into an object
of class <code>prab</code> (presence-absence). The matrix may be read from a
file or an R-object. It may be a 0-1 matrix or a matrix with
non-negative entries (usually abundances).
<code>print.prab</code> is a print method for such
objects.
</p>
<p>Documentation here is in terms of biotic elements analysis (species
are to be clustered). For species delimitation with dominant markers,
see Hausdorf and Hennig (2010), individuals take the role of species
and loci take the role of regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prabinit(file = NULL, prabmatrix = NULL, rows.are.species = TRUE,
neighborhood = "none", nbbetweenregions=TRUE, geodist=NULL, gtf=0.1,
distance = "kulczynski", toprab = FALSE, toprabp
= 0.05, outc = 5.2)

## S3 method for class 'prab'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prabinit_+3A_file">file</code></td>
<td>
<p>string. non-negative matrix ASCII file (such as example dataset
<code>kykladspecreg.dat</code>) from which the
matrix is read by <code>read.table</code>. The usual interpretation is
that it is a species-by-regions matrix of species presences/absences
(0-1 matrix) or abundances.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_prabmatrix">prabmatrix</code></td>
<td>
<p>matrix with non-negative entries. Either <code>file</code>
or <code>prabmatrix</code> should be <code>NA</code>.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_rows.are.species">rows.are.species</code></td>
<td>
<p>logical. If <code>TRUE</code>, rows are interpreted
as species and columns are interpreted as regions. In this case,
rows and columns are interchanged by <code>prabinit</code>.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_neighborhood">neighborhood</code></td>
<td>
<p>A string or a list with a component for
every region. The
components are vectors of integers indicating
neighboring regions. A region without neighbors (e.g., an island)
should be assigned a vector <code>numeric(0)</code>. If <code>neighborhood</code>
is a filename, it is attempted to read such a list from a file,
where every row should correspond to one region (such as example
dataset <code>nb.dat</code>). If
<code>neighborhood="none"</code>, all neighborhoods are set to
<code>numeric(0)</code>. The neighborhood can be tested by
<code><a href="#topic+nbtest">nbtest</a></code> for consistency.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_nbbetweenregions">nbbetweenregions</code></td>
<td>
<p>logical. If <code>TRUE</code>, the neighborhood is
defined between regions as explained above. Otherwise it is defined
between species (or individuals, if this is used for species
delimitation).</p>
</td></tr>
<tr><td><code id="prabinit_+3A_geodist">geodist</code></td>
<td>
<p>matrix of non-negative reals. Geographical distances
between regions. Only used if <code>distance="geco"</code>.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_gtf">gtf</code></td>
<td>
<p>tuning constant for geco-distance if <code>distance="geco"</code>,
see <code>geco</code>.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_distance">distance</code></td>
<td>
<p><code>"kulczynski"</code>, <code>"jaccard"</code>, <code>"geco"</code>,
<code>"qkulczynski"</code>, <code>"logkulczynski"</code> (this calls function
<code>qkulczynski</code> with <code>log.distance=TRUE</code>), <code>"dice"</code>, or
<code>"none"</code>. The distance measure
between species to compute by <code>prabinit</code>.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_toprab">toprab</code></td>
<td>
<p>logical. If <code>TRUE</code>, a presence-absence matrix is
computed from the non-negative input matrix. &quot;Absence&quot;, i.e., the
entry 0, is chosen if the original entry is 0, or the original entry
is smaller than or equal to <code>toprabp</code> times the
sum of entries in the
corresponding region, and log(original entry) is considered to be a
lower outlier compared with the other entries of the corresponding
species (see <code>outc</code>). &quot;Presence&quot;, i.e., the entry 1, thus
means that the original
entry is non-negligible w.r.t. the species or w.r.t. the region.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_toprabp">toprabp</code></td>
<td>
<p>numerical between 0 and 1, see <code>toprab</code>.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_outc">outc</code></td>
<td>
<p>numerical. Tuning constant for the outlier identification
associated with <code>toprab=TRUE</code>. An entry smaller than or equal to
<code>outc*mad</code> times the median is considered as a lower outlier.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_x">x</code></td>
<td>
<p>object of class <code>prab</code>.</p>
</td></tr>
<tr><td><code id="prabinit_+3A_...">...</code></td>
<td>
<p>necessary for print method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Species that are absent in all regions are omitted.</p>


<h3>Value</h3>

<p><code>prabinit</code> produces
an object of class <code>prab</code>, which is a list with components
</p>
<table>
<tr><td><code>distmat</code></td>
<td>
<p>distance matrix between species.</p>
</td></tr>
<tr><td><code>prab</code></td>
<td>
<p>abundance or presence/absence matrix (if presence/absence,
the entries are logical). Rows are regions, columns are
species.</p>
</td></tr>
<tr><td><code>nb</code></td>
<td>
<p>neighborhood list, see above.</p>
</td></tr>
<tr><td><code>regperspec</code></td>
<td>
<p>vector of the number of regions occupied by a
species.</p>
</td></tr>
<tr><td><code>specperreg</code></td>
<td>
<p>vector of the number of species present in a region.</p>
</td></tr>
<tr><td><code>n.species</code></td>
<td>
<p>number of species (in the <code>prab</code>-object, see 
<code>nonzero</code>).</p>
</td></tr>
<tr><td><code>n.regions</code></td>
<td>
<p>number of regions.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>string denoting the chosen distance measure.</p>
</td></tr>
<tr><td><code>geodist</code></td>
<td>
<p>non-negative matrix. see above.</p>
</td></tr>
<tr><td><code>gtf</code></td>
<td>
<p>numeric. see above.</p>
</td></tr>
<tr><td><code>spatial</code></td>
<td>
<p><code>TRUE</code>, if there is a specified neighborhood
structure.</p>
</td></tr> 
<tr><td><code>nonempty.species</code></td>
<td>
<p>logical vector. The length is the number of species
in the original file/matrix. If <code>FALSE</code>, the corresponding species 
had only zero entries and was therefore absent. Note that these species
are not included in any other component of a <code>prab</code> object, i.e.,
<code>n.species</code> is the number of <code>TRUE</code>-entries in
<code>nonzero</code>.</p>
</td></tr>
<tr><td><code>nbbetweenregions</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2010) Species Delimitation Using Dominant
and Codominant Multilocus Markers. <em>Systematic Biology</em>, 59, 491-503.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+jaccard">jaccard</a></code>,
<code><a href="#topic+kulczynski">kulczynski</a></code>, <code><a href="#topic+geco">geco</a></code>,
<code><a href="#topic+qkulczynski">qkulczynski</a></code>, <code><a href="#topic+nbtest">nbtest</a></code>,
<code><a href="#topic+alleleinit">alleleinit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># If you want to use your own ASCII data files, use
# x &lt;- prabinit(file="path/prabmatrixfile",
# neighborhood="path/neighborhoodfile")
data(kykladspecreg)
data(nb)
prabinit(prabmatrix=kykladspecreg, neighborhood=nb)
</code></pre>

<hr>
<h2 id='prabtest'>Parametric bootstrap test for clustering in presence-absence matrices</h2><span id='topic+prabtest'></span><span id='topic+summary.prabtest'></span><span id='topic+print.summary.prabtest'></span>

<h3>Description</h3>

<p>Parametric bootstrap test of a null model of i.i.d., but spatially
autocorrelated species against clustering of the species' occupied
areas (or alternatively nestedness). In spite of the lots of
parameters, a standard execution (for the default test statistics, see
parameter <code>teststat</code> below) will be <br />
<code>prabmatrix &lt;- prabinit(file="path/prabmatrixfile",
    neighborhood="path/neighborhoodfile")</code><br />
<code>test &lt;- prabtest(prabmatrix)</code><br />
<code>summary(test)</code><br />
<b>Note:</b> Data formats are described
on the <code>prabinit</code> help page. You may also consider the example datasets
<code>kykladspecreg.dat</code> and <code>nb.dat</code>. Take care of the
parameter <code>rows.are.species</code> of <code>prabinit</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>prabtest(prabobject, teststat = "distratio", tuning = switch(teststat, 
    distratio = 0.25, lcomponent = floor(3 * ncol(prabobject$distmat)/4), 
    isovertice = ncol(prabobject$distmat), nn = 4, NA), times = 1000, 
    pd = NULL, prange = c(0, 1), nperp = 4, step = 0.1, step2=0.01,
                      twostep = TRUE, 
    sf.sim = FALSE, sf.const = sf.sim, pdfnb = FALSE, ignore.richness=FALSE) 


## S3 method for class 'prabtest'
summary(object, above.p=object$teststat %in%
         c("groups","inclusions","mean"),
         group.outmean=FALSE,...)

## S3 method for class 'summary.prabtest'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prabtest_+3A_prabobject">prabobject</code></td>
<td>
<p>an object of class <code>prab</code> (presence-absence data), as
generated by <code>prabinit</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_teststat">teststat</code></td>
<td>
<p>string, indicating the test statistics. <code>"isovertice"</code>:
number of isolated vertices in the graph of <code>tuning</code>
smallest distances
between species. <code>"lcomponent"</code>: size of largest connectivity
component in this graph. <code>"distratio"</code>: ratio between <code>tuning</code>
smallest and largest distances. <code>"nn"</code>: average distance of species to
<code>tuning</code>th nearest neighbor. 
<code>"inclusions"</code>: number of inclusions between areas of different
species (tests for nestedness structure, not for clustering).</p>
</td></tr>
<tr><td><code id="prabtest_+3A_tuning">tuning</code></td>
<td>
<p>integer or (if <code>teststat="distratio"</code>) numerical
between 0 and 1. Tuning constant for test statistics, see
<code>teststat</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_times">times</code></td>
<td>
<p>integer. Number of simulation runs.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_pd">pd</code></td>
<td>
<p>numerical between 0 and 1. The probability that a new
region is drawn from the non-neighborhood of the previous regions
belonging to a species under generation. If <code>NA</code> (the default),
<code>prabtest</code> estimates this by function
<code>autoconst</code>. Otherwise the next five parameters have no effect.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_prange">prange</code></td>
<td>
<p>numerical range vector, lower value not smaller than 0, larger
value not larger than 1. Range where <code>pd</code> is to be found. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_nperp">nperp</code></td>
<td>
<p>integer. Number of simulations per <code>pd</code>-value. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_step">step</code></td>
<td>
<p>numerical between 0 and 1. Interval length between
subsequent choices of <code>pd</code> for the first simulation. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_step2">step2</code></td>
<td>
<p>numerical between 0 and 1. Interval length between
subsequent choices of <code>pd</code> for the second simulation (see
parameter <code>twostep</code>). Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_twostep">twostep</code></td>
<td>
<p>logical. If <code>TRUE</code>, a first estimation step for
<code>pd</code> is
carried out in the whole <code>prange</code>, and then the final
estimation is determined between the preliminary estimator
<code>-5*step2</code> and <code>+5*step2</code>. Else, the first simulation
determines the final estimator. Used
by function <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_sf.sim">sf.sim</code></td>
<td>
<p>logical. Indicates if the range sizes of the species
are held fixed
in the test simulation (<code>TRUE</code>) or generated from their empirical
distribution in <code>x</code> (<code>FALSE</code>). See function <code>randpop.nb</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_sf.const">sf.const</code></td>
<td>
<p>logical. Same as <code>sf.sim</code>, but for estimation of
<code>pd</code> by <code>autoconst</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_pdfnb">pdfnb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the probabilities of the regions
are modified according to the number of neighboring regions in
<code>randpop.nb</code>, see Hennig and Hausdorf (2002), p. 5. This is
usually no improvement.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_ignore.richness">ignore.richness</code></td>
<td>
<p>logical. If <code>TRUE</code>, there is no assumption
of species richnesses to differ between regions in the null model.
Regionwise probabilities don't differ in the generation of null
data.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_object">object</code></td>
<td>
<p>object of class <code>prabtest</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_above.p">above.p</code></td>
<td>
<p>logical. <code>TRUE</code> means that for output from
<code>abundtest</code> the p-value is
<code>p.above</code>, otherwise <code>p.below</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_group.outmean">group.outmean</code></td>
<td>
<p>logical. If <code>TRUE</code> and
<code>object$teststat="groups"</code>, statistics concerning the mean of
all dissimilarities are given out by <code>print.summary.prabtest</code>.</p>
</td></tr>    
<tr><td><code id="prabtest_+3A_x">x</code></td>
<td>
<p>object of class <code>summary.prabtest</code>.</p>
</td></tr>
<tr><td><code id="prabtest_+3A_...">...</code></td>
<td>
<p>no meaning, necessary for print and summary methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From the original data, the distribution of the
range sizes of the species, the autocorrelation parameter <code>pd</code>
(estimated by <code>autoconst</code>) and the distribution on the regions
induced by the relative species numbers are taken. With these
parameters, <code>times</code> populations according to the null model
implemented in <code>randpop.nb</code> are generated and the test statistic
is evaluated. The resulting p-value is number of simulated statistic
values more extreme than than the value of the original data<code>+1</code>
divided by <code>times+1</code>. &quot;More extreme&quot; means smaller for
<code>"lcomponent"</code>, <code>"distratio"</code>, <code>"nn"</code>, larger for
<code>"inclusions"</code>, and
twice the smaller number between the original statistic value and the
&quot;border&quot;, i.e., a two-sided test for <code>"isovertice"</code>.
If <code>pd=NA</code> was
specified, a diagnostic plot
for the estimation of <code>pd</code> is plotted by <code>autoconst</code>.
For details see Hennig
and Hausdorf (2004) and the help pages of the cited functions. 
</p>


<h3>Value</h3>

<p><code>prabtest</code> prodices
an object of class <code>prabtest</code>, which is a list with components
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>vector of test statistic values for all simulated
populations.</p>
</td></tr>
<tr><td><code>datac</code></td>
<td>
<p>test statistic value for the original data.'</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value.</p>
</td></tr>
<tr><td><code>tuning</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>reg</code></td>
<td>
<p>regression coefficients from <code>autoconst</code>.</p>
</td></tr>
<tr><td><code>teststat</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>the distance measure chosen, see <code>prabinit</code>.</p>
</td></tr>
<tr><td><code>gtf</code></td>
<td>
<p>the geco-distance tuning parameter (only informative if
<code>distance="geco"</code>), see <code>prabinit</code>.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>pdfnb</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>ignore.richness</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>
<p><code>summary.prabtest</code> produces an object of class
<code>summary.prabtest</code>, which is a list with components
</p>
<table>
<tr><td><code>rrange</code></td>
<td>
<p>range of the simulation results (test statistic values)
of <code>object</code>.</p>
</td></tr>
<tr><td><code>rmean</code></td>
<td>
<p>mean of the simulation results (test statistic values)
of <code>object</code>.</p>
</td></tr>
<tr><td><code>datac</code>, <code>p.value</code>, <code>pd</code>, <code>tuning</code>, <code>teststat</code>, <code>distance</code>, <code>times</code>, <code>pdfnb</code>, <code>abund</code>, <code>sarlambda</code></td>
<td>
<p>directly
taken from <code>object</code>, see <code>prabtest</code> and <code>abundtest</code>.</p>
</td></tr>
<tr><td><code>groupinfo</code></td>
<td>
<p>if <code>object$teststat="groups"</code>, components
<code>rrangeg</code> (matrix of group-wise ranges of test statistic
value), <code>rmeang</code> (vector of group-wise means of test statistic
value), <code>rrangem</code> (range over simulations of overall mean of
within-group dissimilarities), <code>rmeanm</code> (mean over simulations
of overall mean of within-group dissimilarities) are added to the
list <code>object$groupinfo</code>, and this is given out.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
<a href="http://stat.ethz.ch/Research-Reports/110.html">http://stat.ethz.ch/Research-Reports/110.html</a>.
</p>
<p>Hausdorf, B. and Hennig, C. (2003)  Biotic Element Analysis in
Biogeography. <em>Systematic Biology</em> 52, 717-723.
</p>
<p>Hausdorf, B. and Hennig, C. (2003) Nestedness of north-west European
land snail ranges as a consequence of differential immigration from
Pleistocene glacial refuges. <em>Oecologia</em> 135, 102-109.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prabinit">prabinit</a></code> generates objects of class <code>prab</code>.
</p>
<p><code><a href="#topic+autoconst">autoconst</a></code> estimates <code>pd</code> from such objects.
</p>
<p><code><a href="#topic+randpop.nb">randpop.nb</a></code> generates populations from the null model.
An alternative model is given by <code><a href="#topic+cluspop.nb">cluspop.nb</a></code>.
</p>
<p>Some more information on the test statistics is given in
<code><a href="#topic+homogen.test">homogen.test</a></code>, <code><a href="#topic+lcomponent">lcomponent</a></code>,
<code><a href="#topic+distratio">distratio</a></code>, <code><a href="#topic+nn">nn</a></code>,
<code><a href="#topic+incmatrix">incmatrix</a></code>.
</p>
<p>The simulations are computed by <code><a href="#topic+pop.sim">pop.sim</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
data(nb)
set.seed(1234)
x &lt;- prabinit(prabmatrix=kykladspecreg, neighborhood=nb)
# If you want to use your own ASCII data files, use
# x &lt;- prabinit(file="path/prabmatrixfile",
# neighborhood="path/neighborhoodfile")
kpt &lt;- prabtest(x, times=5, pd=0.35)
# These settings are chosen to make the example execution
# a bit faster; usually you will use prabtest(kprab).
summary(kpt)
</code></pre>

<hr>
<h2 id='qkulczynski'>Quantitative Kulczynski distance matrix</h2><span id='topic+qkulczynski'></span>

<h3>Description</h3>

<p>Computes quantitative Kulczynski distances between the columns of an
abundance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qkulczynski(regmat, log.distance=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qkulczynski_+3A_regmat">regmat</code></td>
<td>
<p>(non-negative) abundance matrix. Columns are species,
rows are regions.</p>
</td></tr>
<tr><td><code id="qkulczynski_+3A_log.distance">log.distance</code></td>
<td>
<p>logical. If <code>TRUE</code>, 1 is added to the
abundance matrix and then the logs of the values are taken in order
to compute the distance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The quantitative Kulczynski distance between two species
is 1-(mean of (mean of over regions minimum abundance of both
species)/(sum of abundances of species 1) and (mean of over regions
minimum abundance of both species)/(sum of abundances of species 2)).
If the abundance matrix is a 0-1-matrix, this gives the standard
Kulczynski distance.
</p>


<h3>Value</h3>

<p>A symmetrical matrix of quantitative Kulczynski distances.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>D. P. Faith, P. R. Minchin and L. Belbin (1987) Compositional
dissimilarity as a robust measure of ecological distance.
<em>Vegetation</em> 69, 57-68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kulczynski">kulczynski</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(kykladspecreg)
qkulczynski(t(kykladspecreg))
</code></pre>

<hr>
<h2 id='randpop.nb'>Simulation of presence-absence matrices (non-clustered)</h2><span id='topic+randpop.nb'></span>

<h3>Description</h3>

<p>Generates a simulated matrix where the rows are interpreted as regions
and the columns as species, 1 means that a species is present in the
region and 0 means that the species is absent. Species are generated
i.i.d.. Spatial autocorrelation of a species' presences is governed by
the parameter <code>p.nb</code> and a list of neighbors for each region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randpop.nb(neighbors, p.nb = 0.5, n.species, n.regions =
length(neighbors), vector.species = rep(1, n.species),
species.fixed = FALSE, pdf.regions = rep(1/n.regions, n.regions),
count = TRUE, pdfnb = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randpop.nb_+3A_neighbors">neighbors</code></td>
<td>
<p>A list with a component for every region. The
components are vectors of integers indicating
neighboring regions. A region without neighbors (e.g., an island)
should be assigned a list <code>numeric(0)</code>.</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_p.nb">p.nb</code></td>
<td>
<p>numerical between 0 and 1. The probability that a new
region is drawn from the non-neighborhood of the previous regions
belonging to a species under generation. Note that for a given
presence-absence matrix, this parameter can be estimated by
<code>autoconst</code> (called <code>pd</code> there).</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_n.species">n.species</code></td>
<td>
<p>integer. Number of species.</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_n.regions">n.regions</code></td>
<td>
<p>integer. Number of regions.</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_vector.species">vector.species</code></td>
<td>
<p>vector of integers. If
<code>species.fixed=TRUE</code>, <code>vector.species</code> must have length
<code>n.species</code> and gives the sizes (i.e., numbers of regions) of
the species to generate. Else, the sizes are generated randomly from
the empirical distribution of <code>vector.species</code>.</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_species.fixed">species.fixed</code></td>
<td>
<p>logical. See <code>vector.species</code>.</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_pdf.regions">pdf.regions</code></td>
<td>
<p>numerical vector of length <code>n.species</code>. The
entries must sum up to 1 and give probabilities for the regions to
be drawn during the generation of a species. These probabilities are
used conditional on the new region being a neighbor or a
non-neighbor of the previous regions of the species, see
<code>p.nb</code>.</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_count">count</code></td>
<td>
<p>logical. If <code>TRUE</code>, the number of the currently
generated species is printed.</p>
</td></tr>
<tr><td><code id="randpop.nb_+3A_pdfnb">pdfnb</code></td>
<td>
<p>logical. If <code>TRUE</code>, the probabilities of the regions
are modified according to the number of neighboring regions by
dividing them relative to the others by min(1,number of neighbors).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The principle is that a single species with given size is generated
one-by-one region. The first region is drawn according to
<code>pdf.regions</code>. For all following regions, a neighbor or
non-neighbor of the previous configuration is added (if possible),
as explained in <code>pdf.regions</code>, <code>p.nb</code>.  
</p>


<h3>Value</h3>

<p>A 0-1-matrix, rows are regions, columns are species.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hennig, C. and Hausdorf, B. (2004) Distance-based parametric bootstrap
tests for clustering of species ranges. <em>Computational Statistics
and
Data Analysis</em> 45, 875-896.
<a href="http://stat.ethz.ch/Research-Reports/110.html">http://stat.ethz.ch/Research-Reports/110.html</a>.
</p>
<p>Hausdorf, B. and Hennig, C. (2003)  Biotic Element Analysis in
Biogeography. <em>Systematic Biology</em> 52, 717-723.
</p>
<p>Hausdorf, B. and Hennig, C. (2003) Nestedness of nerth-west European
land snail ranges as a consequence of differential immigration from
Pleistocene glacial refuges. <em>Oecologia</em> 135, 102-109.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoconst">autoconst</a></code> estimates <code>p.nb</code> from matrices of class
<code>prab</code>. These are generated by <code><a href="#topic+prabinit">prabinit</a></code>.
</p>
<p><code><a href="#topic+prabtest">prabtest</a></code> uses <code>randpop.nb</code> as a null model for
tests of clustering. An alternative model is given by
<code><a href="#topic+cluspop.nb">cluspop.nb</a></code>.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nb)
set.seed(2346)
randpop.nb(nb, p.nb=0.1, n.species=5, vector.species=c(1,10,20,30,34))
</code></pre>

<hr>
<h2 id='regdist'>Regression between subsets of dissimilarity matrices</h2><span id='topic+regdist'></span>

<h3>Description</h3>

<p>Given two dissimilarity matrices <code>dmx</code> and <code>dmy</code> and an indicator
vector <code>x</code>, this computes a standard least squares regression
between the dissimilarity between objects indicated in <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
regdist(x,dmx,dmy,xcenter=0,param)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regdist_+3A_x">x</code></td>
<td>
<p>vector of logicals of length of the number of objects on which
dissimilarities <code>dmx</code> and <code>dmy</code> are based.</p>
</td></tr> 
<tr><td><code id="regdist_+3A_dmx">dmx</code></td>
<td>
<p>dissimilarity matrix or object of class
<code><a href="stats.html#topic+dist">dist</a></code>. Explanatory  dissimilarities.</p>
</td></tr>
<tr><td><code id="regdist_+3A_dmy">dmy</code></td>
<td>
<p>dissimilarity matrix or object of class
<code><a href="stats.html#topic+dist">dist</a></code>. Response dissimilarities.</p>
</td></tr>
<tr><td><code id="regdist_+3A_xcenter">xcenter</code></td>
<td>
<p>numeric. Dissimilarities <code>dmx</code> are centered by
this, i.e., this value is subtracted from the dissimilarities before
regression.</p>
</td></tr>
<tr><td><code id="regdist_+3A_param">param</code></td>
<td>
<p>1 or 2 or <code>NULL</code>. If 1 or 2, only the first or
second parameter (intercept or slope) of the regression is given
out.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>param=NULL</code>, the output object of <code><a href="stats.html#topic+lm">lm</a></code>. If
<code>param=1</code> the intercept. If
<code>param=2</code> the slope. 
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[1:20,],file.format="decimal2")
  vei &lt;- prabinit(prabmatrix=veronica[1:20,],distance="jaccard")
  regdist(c(rep(TRUE,10),rep(FALSE,10)),ver.geo,vei$distmat,param=1)
</code></pre>

<hr>
<h2 id='regdistbetween'>Testing equality of within-groups and between-groups distances regression</h2><span id='topic+regdistbetween'></span><span id='topic+print.regdistbetween'></span>

<h3>Description</h3>

<p>Jackknife-based test for equality of two regressions between
distances. Given two groups of objects, this tests whether the
regression involving all distances is compatible with the regression
involving within-group distances only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regdistbetween(dmx,dmy,grouping,groups=levels(as.factor(grouping))[1:2])

## S3 method for class 'regdistbetween'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regdistbetween_+3A_dmx">dmx</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Explanatory dissimilarities (often these will be proper
distances, but more general dissimilarities that do not
necessarily fulfill the triangle inequality can be used, same for <code>dmy</code>).</p>
</td></tr>
<tr><td><code id="regdistbetween_+3A_dmy">dmy</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Response dissimilarities.</p>
</td></tr>
<tr><td><code id="regdistbetween_+3A_grouping">grouping</code></td>
<td>
<p>something that can be coerced into a factor,
defining the grouping of
objects represented by the dissimilarities <code>dmx</code> and <code>dmy</code>
(i.e., if <code>grouping</code> has length n, <code>dmx</code> and <code>dmy</code>
must be dissimilarities between <code>n</code> objects).</p>
</td></tr>
<tr><td><code id="regdistbetween_+3A_groups">groups</code></td>
<td>
<p>Vector of two levels. The two groups defining the
regressions to be compared in the test. These can be
factor levels, integer numbers, or strings, depending on the entries
of <code>grouping</code>.</p>
</td></tr>
<tr><td><code id="regdistbetween_+3A_x">x</code></td>
<td>
<p>object of class <code>"regdistbetween"</code>.</p>
</td></tr>
<tr><td><code id="regdistbetween_+3A_...">...</code></td>
<td>
<p>optional arguments for print method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis that the regressions based on all distances and
based on within-group distances only are
equal is tested using jackknife pseudovalues. This assumes that a
single regression is appropriate at least for the within-group
distances alone. The test statistic is the difference between fitted
values with x (explanatory variable) fixed at the center of the
between-group distances. The test is run one-sided, i.e., the null
hypothesis is only rejected if the between-group distances are larger
than expected under the null hypothesis, see below.   
</p>
<p>The test cannot be run in case that
within-group regressions or jackknifed within-group regressions are
ill-conditioned.
</p>
<p>This was implemented having in mind an application in which the
explanatory distances represent geographical distances, the response
distances are genetic distances, and groups represent species or
species-candidates. In this application, for testing whether the
regression patterns are compatble with the two groups behaving like a
single species, one would first use <code>regeqdist</code> to test whether a
joint regression for the within-group distances of both groups makes
sense. If this is not rejected, <code>regdistbetween</code> is run to see
whether the between-group distances are compatible with the
within-group distances. This is only rejected if the between-group
distances are larger than expected under equality of regressions,
because if they are smaller, this is not an indication against the
groups belonging together genetically.
</p>
<p>If a joint regression on
within-group distances is rejected by <code>regeqdist</code>,
<code>regdistbetweenone</code> can be
used to test whether the between-group distances are at least
compatible with the within-group distances of one of the groups, which
can still be the case within a single species, see Hausdorf and Hennig (2019).
</p>


<h3>Value</h3>

<p>list of class <code>"regdistbetween"</code> with components
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>p-value.</p>
</td></tr> 
<tr><td><code>coeffdiff</code></td>
<td>
<p>difference between regression fits (all distances
minus within-group distances only) at <code>xcenterbetween</code>, see below.</p>
</td></tr>  
<tr><td><code>condition</code></td>
<td>
<p>condition numbers of regressions, see <code><a href="base.html#topic+kappa">kappa</a></code>.</p>
</td></tr>
<tr><td><code>lmfit</code></td>
<td>
<p>list. Output objects of <code><a href="stats.html#topic+lm">lm</a></code> within the two groups.</p>
</td></tr>
<tr><td><code>jr</code></td>
<td>
<p>output object of <code><a href="bootstrap.html#topic+jackknife">jackknife</a></code> for difference
between regression fitted values at <code>xcenterbetween</code>.</p>
</td></tr>
<tr><td><code>xcenter</code></td>
<td>
<p>mean of within-groups distances of explanatory
variable, used for centering.</p>
</td></tr>
<tr><td><code>xcenterbetween</code></td>
<td>
<p>mean of between-groups distances of explanatory
variable (after centering by <code>xcenter</code>); at this point
regression fitted values are computed.</p>
</td></tr>
<tr><td><code>tstat</code></td>
<td>
<p>t-statistic.</p>
</td></tr>
<tr><td><code>tdf</code></td>
<td>
<p>degrees of freedom of t-statistic.</p>
</td></tr>
<tr><td><code>jackest</code></td>
<td>
<p>jackknife-estimator of difference between regression
fitted values at <code>xcenterbetween</code>.</p>
</td></tr> 
<tr><td><code>jackse</code></td>
<td>
<p>jackknife-standard error for
<code>jackest</code>.</p>
</td></tr>
<tr><td><code>jackpseudo</code></td>
<td>
<p>vector of jacknife pseudovalues on which the test is
based.</p>
</td></tr>
<tr><td><code>testname</code></td>
<td>
<p>title to be printed out when using
<code>print.regdistbetween</code>.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regeqdist">regeqdist</a></code>, <code><a href="#topic+regdistbetweenone">regdistbetweenone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[173:207,],file.format="decimal2")
  vei &lt;- prabinit(prabmatrix=veronica[173:207,],distance="jaccard")
  loggeo &lt;- log(ver.geo+quantile(as.vector(as.dist(ver.geo)),0.25))

  species &lt;-c(rep(1,13),rep(2,22))
 
  rtest2 &lt;-
  regdistbetween(dmx=loggeo,dmy=vei$distmat,grouping=species,groups=c(1,2))
  print(rtest2)
</code></pre>

<hr>
<h2 id='regdistbetweenone'>Testing equality of one within-group and between-two groups
distances regression</h2><span id='topic+regdistbetweenone'></span>

<h3>Description</h3>

<p>Jackknife-based test for equality of two regressions between
distances. Given two groups of objects, this tests whether the
regression involving the distances within one of the groups is compatible
with the regression involving the same within-group distances together
with the between group distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regdistbetweenone(dmx,dmy,grouping,groups=levels(as.factor(grouping))[1:2],rgroup)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regdistbetweenone_+3A_dmx">dmx</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Explanatory dissimilarities (often these will be proper
distances, but more general dissimilarities that do not
necessarily fulfill the triangle inequality can be used, same for <code>dmy</code>).</p>
</td></tr>
<tr><td><code id="regdistbetweenone_+3A_dmy">dmy</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Response dissimilarities.</p>
</td></tr>
<tr><td><code id="regdistbetweenone_+3A_grouping">grouping</code></td>
<td>
<p>something that can be coerced into a factor,
defining the grouping of
objects represented by the dissimilarities <code>dmx</code> and <code>dmy</code>
(i.e., if <code>grouping</code> has length n, <code>dmx</code> and <code>dmy</code>
must be dissimilarities between <code>n</code> objects).</p>
</td></tr>
<tr><td><code id="regdistbetweenone_+3A_groups">groups</code></td>
<td>
<p>vector of two levels. The two groups defining the
regressions to be compared in the test. These can be
factor levels, integer numbers, or strings, depending on the entries
of <code>grouping</code>.</p>
</td></tr>
<tr><td><code id="regdistbetweenone_+3A_rgroup">rgroup</code></td>
<td>
<p>one of the levels in <code>groups</code>, denoting the group
of which within-group dissimilarities are considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis that the regressions based on the distances
within group <code>species</code> and based on these distances together with
the between-groups distances are
equal is tested using jackknife pseudovalues. The test statistic is
the difference between fitted
values with x (explanatory variable) fixed at the center of the
between-group distances. The test is run one-sided, i.e., the null
hypothesis is only rejected if the between-group distances are larger
than expected under the null hypothesis, see below. For the jackknife,
observations from both groups are left out one at a time. However, the
roles of the two groups are different (observations from group
<code>species</code> are used in both regressions whereas observations from
the other group are only used in one of them), and therefore the
corresponding jackknife pseudovalues can have different variances. To
take this into account, variances are pooled, and the degrees of
freedom of the t-test are computed by the Welch-Sattertwaithe
approximation for aggregation of different variances.
</p>
<p>The test cannot be run and many components will be <code>NA</code> in case that
within-group regressions or jackknifed within-group regressions are
ill-conditioned.
</p>
<p>This was implemented having in mind an application in which the
explanatory distances represent geographical distances, the response
distances are genetic distances, and groups represent species or
species-candidates. In this application, for testing whether the
regression patterns are compatble with the two groups behaving like a
single species, one would first use <code>regeqdist</code> to test whether a
joint regression for the within-group distances of both groups makes
sense. If this is not rejected, <code>regdistbetween</code> is run to see
whether the between-group distances are compatible with the
within-group distances. 
If a joint regression on
within-group distances is rejected by <code>regeqdist</code>,
<code>regdistbetweenone</code> can be
used to test whether the between-group distances are at least
compatible with the within-group distances of one of the groups, which
can still be the case within a single species, see Hausdorf and Hennig
(2019). This
is only rejected if the between-group
distances are larger than expected under equality of regressions,
because if they are smaller, this is not an indication against the
groups belonging together genetically. To this end,
<code>regdistbetweenone</code> needs to be run twice using both groups as
<code>species</code>. This will produce two p-values. The null hypothesis
that the regressions are compatible for at least one group can be
rejected if the maximum of the two p-values is smaller than the chosen
significance level.
</p>


<h3>Value</h3>

<p>list of class <code>"regdistbetween"</code> with components
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>p-value.</p>
</td></tr> 
<tr><td><code>coeffdiff</code></td>
<td>
<p>difference between regression fits (within-group
together with between-groups distances
minus within-group distances only) at <code>xcenterbetween</code>, see
below.</p>
</td></tr>
<tr><td><code>condition</code></td>
<td>
<p>condition numbers of regressions, see <code><a href="base.html#topic+kappa">kappa</a></code>.</p>
</td></tr>
<tr><td><code>lmfit</code></td>
<td>
<p>list. Output objects of <code><a href="stats.html#topic+lm">lm</a></code> within the two groups.</p>
</td></tr>
<tr><td><code>jr</code></td>
<td>
<p>output object of <code><a href="bootstrap.html#topic+jackknife">jackknife</a></code> for difference
between regression fitted values at <code>xcenterbetween</code>.</p>
</td></tr>
<tr><td><code>xcenter</code></td>
<td>
<p>mean of within-group distances for group <code>species</code>
of explanatory variable, used for centering.</p>
</td></tr>
<tr><td><code>xcenterbetween</code></td>
<td>
<p>mean of between-groups distances of explanatory
variable (after centering by <code>xcenter</code>); at this point
regression fitted values are computed.</p>
</td></tr>
<tr><td><code>tstat</code></td>
<td>
<p>t-statistic.</p>
</td></tr>
<tr><td><code>tdf</code></td>
<td>
<p>degrees of freedom of t-statistic according to
Welch-Sattertwaithe approximation.</p>
</td></tr>
<tr><td><code>jackest</code></td>
<td>
<p>jackknife-estimator of difference between regression
fitted values at <code>xcenterbetween</code>.</p>
</td></tr> 
<tr><td><code>jackse</code></td>
<td>
<p>jackknife-standard error for
<code>jackest</code>.</p>
</td></tr>
<tr><td><code>jackpseudo</code></td>
<td>
<p>vector of jacknife pseudovalues on which the test is
based.</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>species</code></td>
<td>
<p>see above.</p>
</td></tr>
<tr><td><code>testname</code></td>
<td>
<p>title to be printed out when using
<code>print.regdistbetween</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regeqdist">regeqdist</a></code>, <code><a href="#topic+regdistbetweenone">regdistbetweenone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[173:207,],file.format="decimal2")
  vei &lt;- prabinit(prabmatrix=veronica[173:207,],distance="jaccard")

  species &lt;-c(rep(1,13),rep(2,22))
  loggeo &lt;- log(ver.geo+quantile(as.vector(as.dist(ver.geo)),0.25))
  rtest3 &lt;-
  regdistbetweenone(dmx=loggeo,dmy=vei$distmat,grouping=species,groups=c(1,2),rgroup=1)
  print(rtest3)
</code></pre>

<hr>
<h2 id='regdistdiff'>Regression difference between within-group dissimilarities</h2><span id='topic+regdistdiff'></span>

<h3>Description</h3>

<p>Given two dissimilarity matrices <code>dmx</code> and <code>dmy</code>, an indicator
vector <code>x</code> and a grouping, this computes the difference between
standard least squares regression predictions at point
<code>xcenterbetween</code>. The regressions are based on the dissimilarities
in <code>dmx</code> vs. <code>dmy</code> for objects indicated in
<code>x</code>. <code>grouping</code> indicates the two groups, and the difference
is computed between regressions based on the within-group distances of
the two groups. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
regdistdiff(x,dmx,dmy,grouping,xcenter=0,xcenterbetween=0)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regdistdiff_+3A_x">x</code></td>
<td>
<p>vector of logicals of length of the number of objects on which
dissimilarities <code>dmx</code> and <code>dmy</code> are based.</p>
</td></tr> 
<tr><td><code id="regdistdiff_+3A_dmx">dmx</code></td>
<td>
<p>dissimilarity matrix or object of class
<code><a href="stats.html#topic+dist">dist</a></code>. Explanatory  dissimilarities.</p>
</td></tr>
<tr><td><code id="regdistdiff_+3A_dmy">dmy</code></td>
<td>
<p>dissimilarity matrix or object of class
<code><a href="stats.html#topic+dist">dist</a></code>. Response dissimilarities.</p>
</td></tr>
<tr><td><code id="regdistdiff_+3A_grouping">grouping</code></td>
<td>
<p>vector of length of the number of objects on which
dissimilarities <code>dmx</code> and <code>dmy</code> are based. Grouping
vector. Regressions will be based on the first two values that
appear in <code>unique(grouping[x])</code> (note that objects that are not
assigned to one of these groups will be ignored); normally
<code>grouping</code> should indicate only
two groups on the objects with <code>x=TRUE</code>, and then these are used.</p>
</td></tr>
<tr><td><code id="regdistdiff_+3A_xcenter">xcenter</code></td>
<td>
<p>numeric. Dissimilarities <code>dmx</code> are centered by
this, i.e., this value is subtracted from the dissimilarities before
regression.</p>
</td></tr>
<tr><td><code id="regdistdiff_+3A_xcenterbetween">xcenterbetween</code></td>
<td>
<p>numeric. This specifies the x- (dissimilarity)
value at which predictions from the two regressions are
compared. Note that this is interpreted as after centering by
<code>xcenter</code>.</p>
</td></tr>    
</table>


<h3>Value</h3>

<p>Difference between
standard least squares regression predictions for the two groups at point
<code>xcenterbetween</code>.  
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regdistbetween">regdistbetween</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[173:207,],file.format="decimal2")
  vei &lt;- prabinit(prabmatrix=veronica[173:207,],distance="jaccard")

  species &lt;-c(rep(1,13),rep(2,22))
  regdistdiff(rep(TRUE,35),ver.geo,vei$distmat,grouping=species,xcenter=0,xcenterbetween=100)

</code></pre>

<hr>
<h2 id='regdistdiffone'>Regression difference within reference group and between-group dissimilarities</h2><span id='topic+regdistdiffone'></span>

<h3>Description</h3>

<p>Given two dissimilarity matrices <code>dmx</code> and <code>dmy</code>, an indicator
vector <code>x</code> and a grouping, this computes the difference between
standard least squares regression predictions at point
<code>xcenterbetween</code>. The regressions are based on the dissimilarities
in <code>dmx</code> vs. <code>dmy</code> for objects indicated in
<code>x</code>. <code>grouping</code> indicates the two groups, and the difference
is computed between regressions based on (a) the within-group
distances of the reference group <code>rgroup</code> and (b) these together
with the between-group distances. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
regdistdiffone(x,dmx,dmy,grouping,xcenter=0,xcenterbetween=0,rgroup)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regdistdiffone_+3A_x">x</code></td>
<td>
<p>vector of logicals of length of the number of objects on which
dissimilarities <code>dmx</code> and <code>dmy</code> are based.</p>
</td></tr> 
<tr><td><code id="regdistdiffone_+3A_dmx">dmx</code></td>
<td>
<p>dissimilarity matrix or object of class
<code><a href="stats.html#topic+dist">dist</a></code>. Explanatory  dissimilarities.</p>
</td></tr>
<tr><td><code id="regdistdiffone_+3A_dmy">dmy</code></td>
<td>
<p>dissimilarity matrix or object of class
<code><a href="stats.html#topic+dist">dist</a></code>. Response dissimilarities.</p>
</td></tr>
<tr><td><code id="regdistdiffone_+3A_grouping">grouping</code></td>
<td>
<p>vector of length of the number of objects on which
dissimilarities <code>dmx</code> and <code>dmy</code> are based. Grouping
vector. Regressions will be based on the first two values that
appear in <code>unique(grouping[x])</code> (note that objects that are not
assigned to one of these groups will be ignored); normally
<code>grouping</code> should indicate only
two groups on the objects with <code>x=TRUE</code>, and then these are used.</p>
</td></tr>
<tr><td><code id="regdistdiffone_+3A_xcenter">xcenter</code></td>
<td>
<p>numeric. Dissimilarities <code>dmx</code> are centered by
this, i.e., this value is subtracted from the dissimilarities before
regression.</p>
</td></tr>
<tr><td><code id="regdistdiffone_+3A_xcenterbetween">xcenterbetween</code></td>
<td>
<p>numeric. This specifies the x- (dissimilarity)
value at which predictions from the two regressions are
compared. Note that this is interpreted as after centering by
<code>xcenter</code>.</p>
</td></tr>
<tr><td><code id="regdistdiffone_+3A_rgroup">rgroup</code></td>
<td>
<p>one of the values of <code>grouping</code>, specifying the
reference group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Difference between
standard least squares regression predictions for the two regressions at point
<code>xcenterbetween</code>.  
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regdistbetweenone">regdistbetweenone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[173:207,],
    file.format="decimal2")
  vei &lt;- prabinit(prabmatrix=veronica[173:207,],distance="jaccard")

  species &lt;-c(rep(1,13),rep(2,22))
  regdistdiffone(rep(TRUE,35),ver.geo,vei$distmat,grouping=species,
    xcenter=0,xcenterbetween=100,rgroup=2)

</code></pre>

<hr>
<h2 id='regeqdist'>Testing equality of two distance-regressions</h2><span id='topic+regeqdist'></span><span id='topic+print.regeqdist'></span>

<h3>Description</h3>

<p>Jackknife-based test for equality of two regressions between
distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regeqdist(dmx,dmy,grouping,groups=levels(as.factor(grouping))[1:2])

## S3 method for class 'regeqdist'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regeqdist_+3A_dmx">dmx</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Explanatory dissimilarities (often these will be proper
distances, but more general dissimilarities that do not
necessarily fulfill the triangle inequality can be used, same for
<code>dmy</code>).</p>
</td></tr>
<tr><td><code id="regeqdist_+3A_dmy">dmy</code></td>
<td>
<p>dissimilarity matrix or object of class
<code>dist</code>. Response dissimilarities.</p>
</td></tr>
<tr><td><code id="regeqdist_+3A_grouping">grouping</code></td>
<td>
<p>something that can be coerced into a factor,
defining the grouping of
objects represented by the dissimilarities <code>dmx</code> and <code>dmy</code>
(i.e., if <code>grouping</code> has length n, <code>dmx</code> and <code>dmy</code>
must be dissimilarities between <code>n</code> objects).</p>
</td></tr>
<tr><td><code id="regeqdist_+3A_groups">groups</code></td>
<td>
<p>Vector of two, indicating the two groups defining the
regressions to be compared in the test. These can be
factor levels, integer numbers, or strings, depending on the entries
of <code>grouping</code>.</p>
</td></tr>
<tr><td><code id="regeqdist_+3A_x">x</code></td>
<td>
<p>object of class <code>"regeqdist"</code>.</p>
</td></tr>
<tr><td><code id="regeqdist_+3A_...">...</code></td>
<td>
<p>optional arguments for print method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis that the regressions within the two groups are
equal is tested using jackknife pseudovalues independently in both
groups allowing for potentially different variances of the
pseudovalues, and aggregating as in Welch's t-test. Tests are run
separately for intercept and slope and aggregated by Bonferroni's
rule.
</p>
<p>The test cannot be run and many components will be <code>NA</code> in case that
within-group regressions or jackknifed within-group regressions are
ill-conditioned.
</p>
<p>This was implemented having in mind an application in which the
explanatory distances represent geographical distances, the response
distances are genetic distances, and groups represent species or
species-candidates. In this application, for testing whether the
regression patterns are compatble with the two groups behaving like a
single species, one would first use <code>regeqdist</code> to test whether a
joint regression for the within-group distances of both groups makes
sense. If this is not rejected, <code>regdistbetween</code> is run to see
whether the between-group distances are compatible with the
within-group distances. On the other hand, if a joint regression on
within-group distances is rejected, <code>regdistbetweenone</code> can be
used to test whether the between-group distances are at least
compatible with the within-group distances of one of the groups, which
can still be the case within a single species, see Hausdorf and Hennig (2019).
</p>


<h3>Value</h3>

<p>list of class <code>"regeqdist"</code> with components
</p>
<table>
<tr><td><code>pval</code></td>
<td>
<p>p-values for intercept and slope.</p>
</td></tr> 
<tr><td><code>coeffdiff</code></td>
<td>
<p>vector of differences between groups (first minus
second) for intercept and slope.</p>
</td></tr>  
<tr><td><code>condition</code></td>
<td>
<p>condition numbers of regressions, see <code><a href="base.html#topic+kappa">kappa</a></code>.</p>
</td></tr>
<tr><td><code>lmfit</code></td>
<td>
<p>list. Output objects of <code><a href="stats.html#topic+lm">lm</a></code> within the two groups.</p>
</td></tr>
<tr><td><code>jr</code></td>
<td>
<p>list of two lists of two; output object of
<code><a href="bootstrap.html#topic+jackknife">jackknife</a></code> within the two groups for intercept and
slope.</p>
</td></tr>
<tr><td><code>xcenter</code></td>
<td>
<p>mean of <code>dmx</code> within the two groups used for centering.</p>
</td></tr>
<tr><td><code>tstat</code></td>
<td>
<p>t-statistic.</p>
</td></tr>
<tr><td><code>tdf</code></td>
<td>
<p>vector of degrees of freedom of t-statistic according to
Welch-Sattertwaithe approximation for intercept and slope.</p>
</td></tr>
<tr><td><code>jackest</code></td>
<td>
<p>jackknife-estimator of difference between regressions; 
vector with intercept and slope difference.</p>
</td></tr>
<tr><td><code>jackse</code></td>
<td>
<p>vector with jackknife-standard errors for
<code>jackest</code>, intercept and slope.</p>
</td></tr>
<tr><td><code>jackpseudo</code></td>
<td>
<p>list of two lists of vectors; jacknife pseudovalues
within both groups for intercept and slope estimators.</p>
</td></tr> 
<tr><td><code>groups</code></td>
<td>
<p>see above.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2019) Species delimitation and
geography. Submitted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regdistbetween">regdistbetween</a></code>, <code><a href="#topic+regdistbetweenone">regdistbetweenone</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(veronica)
  ver.geo &lt;- coord2dist(coordmatrix=veronica.coord[173:207,],file.format="decimal2")
  vei &lt;- prabinit(prabmatrix=veronica[173:207,],distance="jaccard")
  loggeo &lt;- log(ver.geo+quantile(as.vector(as.dist(ver.geo)),0.25))

  species &lt;-c(rep(1,13),rep(2,22))
  rtest &lt;- regeqdist(dmx=loggeo,dmy=vei$distmat,grouping=species,groups=c(1,2))
  print(rtest)
</code></pre>

<hr>
<h2 id='regpop.sar'>Simulation of abundance matrices (non-clustered)</h2><span id='topic+regpop.sar'></span>

<h3>Description</h3>

<p>Generates a simulated matrix where the rows are interpreted as regions
and the columns as species, and the entries are abundances.
Species are generated i.i.d. in two steps. In the first step, a
presence-absence matrix is generated as in <code>randpop.nb</code>. In the
second step, conditionally on presence in the first step, abundance
values are generated according to a simultaneous autoregression (SAR)
model for the log-abundances (see <code><a href="spdep.html#topic+errorsarlm">errorsarlm</a></code> for
the model; estimates are provided by the parameter
<code>sarestimate</code>). Spatial autocorrelation of a species' presences
is governed by the parameter <code>p.nb</code>, <code>sarestimate</code> and a
list of neighbors for each region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regpop.sar(abmat, prab01=NULL, sarestimate=prab.sarestimate(abmat),
                    p.nb=NULL,
                    vector.species=prab01$regperspec,
                    pdf.regions=prab01$specperreg/(sum(prab01$specperreg)),
                   count=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regpop.sar_+3A_abmat">abmat</code></td>
<td>
<p>object of class <code>prab</code>, containing the abundance or
presence/absence data.</p>
</td></tr>
<tr><td><code id="regpop.sar_+3A_prab01">prab01</code></td>
<td>
<p>presence-absence matrix of same dimensions than the
abundance matrix of <code>prabobj</code>. This specifies the presences and
absences on which the presence/absence step of abundance-based tests
is based (see details). If <code>NULL</code> (which is usually the only
reasonable choice), <code>prab01</code> is computed in order to indicate
the nonzeroes of <code>prabobj$prab</code>.</p>
</td></tr>
<tr><td><code id="regpop.sar_+3A_sarestimate">sarestimate</code></td>
<td>
<p>Estimator of the parameters of a simultaneous
autoregression model corresponding to the null model for abundance
data from Hausdorf and Hennig (2007) as generated by
<code>prab.sarestimate</code>. This requires package <code>spdep</code>. If
<code>sarestimate$sar=FALSE</code>, spatial structure is ignored for
generating the abundance values.</p>
</td></tr>
<tr><td><code id="regpop.sar_+3A_p.nb">p.nb</code></td>
<td>
<p>numeric between 0 and 1. The probability that a new
region is drawn from the non-neighborhood of the previous regions
belonging to a species under generation. If <code>NULL</code>, the spatial
structure of the regions is ignored. Note that for a given
presence-absence matrix, this parameter can be estimated by
<code>autoconst</code> (called <code>pd</code> there).</p>
</td></tr>
<tr><td><code id="regpop.sar_+3A_vector.species">vector.species</code></td>
<td>
<p>vector of integers. <code>vector.species</code> gives
the sizes (i.e., numbers of regions) of
the species to generate..</p>
</td></tr>
<tr><td><code id="regpop.sar_+3A_pdf.regions">pdf.regions</code></td>
<td>
<p>numerical vector of length <code>n.species</code>. The
entries must sum up to 1 and give probabilities for the regions to
be drawn during the generation of a species. These probabilities are
used conditional on the new region being a neighbor or a
non-neighbor of the previous regions of the species, see
<code>p.nb</code>.</p>
</td></tr>
<tr><td><code id="regpop.sar_+3A_count">count</code></td>
<td>
<p>logical. If <code>TRUE</code>, the number of the currently
generated species is printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of abundance values, rows are regions, columns are species.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>References</h3>

<p>Hausdorf, B. and Hennig, C. (2007) Null model tests of clustering of
species, negative co-occurrence patterns and nestedness in meta-communities.
<em>Oikos</em> 116, 818-828. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoconst">autoconst</a></code> estimates <code>p.nb</code> from matrices of class
<code>prab</code>. These are generated by <code><a href="#topic+prabinit">prabinit</a></code>.
</p>
<p><code><a href="#topic+abundtest">abundtest</a></code> uses <code>regpop.sar</code> as a null model for
tests of clustering.
</p>
<p><code><a href="#topic+randpop.nb">randpop.nb</a></code> (analogous function for simulating
presence-absence data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(digits=4)
data(siskiyou)
set.seed(1234)
x &lt;- prabinit(prabmatrix=siskiyou, neighborhood=siskiyou.nb,
             distance="none")
# Not run; this needs package spdep.
# regpop.sar(x, p.nb=0.046)
regpop.sar(x, p.nb=0.046, sarestimate=prab.sarestimate(x,sar=FALSE))
</code></pre>

<hr>
<h2 id='siskiyou'>Herbs of the Siskiyou Mountains</h2><span id='topic+siskiyou'></span><span id='topic+siskiyou.nb'></span><span id='topic+siskiyou.groups'></span>

<h3>Description</h3>

<p>Distributions of species of herbs in relation to elevation on quartz
diorite in the central Siskiyou Mountains. All values are per mille
frequencies
in transects (The number of 1 m2 quadrats, among 1000 such quadrats,
in which a species was observed, based on 1250 1m2 quadrats in the
first 5  transects, and 400 1m2 quadrats in 6. transect). Observed
presences in the transect, outside the sampling plots, were coded as
0.2. Rows correspond to species, columns correspond to regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(siskiyou)</code></pre>


<h3>Format</h3>

<p>Three objects are generated:
</p>

<dl>
<dt>siskiyou</dt><dd><p>numeric matrix giving the 144*6 abundance values.</p>
</dd>
<dt>siskiyou.nb</dt><dd><p>neighborhood list for the 6 regions.</p>
</dd>
<dt>siskiyou.groups</dt><dd><p>integer vector of length 144, giving group
memberships for the 144 species.</p>
</dd></dl>



<h3>Details</h3>

<p>Reads from example data files <code>LeiMik1.dat, LeiMik1NB.dat,
    LeiMik1G.dat</code>.
</p>


<h3>Source</h3>

<p>Whittaker, R. H. 1960. Vegetation of the Siskiyou Mountains, Oregon and
California. <em>Ecol. Monogr</em>. 30: 279-338 (table 14).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(siskiyou)
</code></pre>

<hr>
<h2 id='specgroups'>Average within-group distances for given groups</h2><span id='topic+specgroups'></span>

<h3>Description</h3>

<p>Generates average within-group distances (overall and group-wise) from
a dissimilarity matrix and a given grouping.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  specgroups(distmat,groupvector, groupinfo) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specgroups_+3A_distmat">distmat</code></td>
<td>
<p>dissimilarity matrix or <code>dist</code>-object.</p>
</td></tr>
<tr><td><code id="specgroups_+3A_groupvector">groupvector</code></td>
<td>
<p>integer vector. For every row of <code>distmat</code>,
a number indicating the group membership.</p>
</td></tr>
<tr><td><code id="specgroups_+3A_groupinfo">groupinfo</code></td>
<td>
<p>list with components <code>lg</code> (levels of
<code>groupvector</code>), <code>ng</code> (number of groups), <code>nsg</code>
(vector of group sizes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with parameters 
</p>
<table>
<tr><td><code>overall</code></td>
<td>
<p>overall average within-groups dissimilarity.</p>
</td></tr>
<tr><td><code>gr</code></td>
<td>
<p>vector of group-wise average within-group dissimilarities
(this will be <code>NaN</code> if the group size is only 1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(siskiyou)
  x &lt;- prabinit(prabmatrix=siskiyou, neighborhood=siskiyou.nb,
              distance="logkulczynski")  
  groupvector &lt;- as.factor(siskiyou.groups)
  ng &lt;- length(levels(groupvector))
  lg &lt;- levels(groupvector)
  nsg &lt;- numeric(0)
    for (i in 1:ng) nsg[i] &lt;- sum(groupvector==lg[i])
  groupinfo &lt;- list(lg=lg,ng=ng,nsg=nsg)
  specgroups(x$distmat,groupvector,groupinfo)
</code></pre>

<hr>
<h2 id='stressvals'>Stress values for different dimensions of Kruskal's MDS</h2><span id='topic+stressvals'></span>

<h3>Description</h3>

<p>Computes Kruskal's nonmetric multidimensional scaling
<code><a href="MASS.html#topic+isoMDS">isoMDS</a></code> on <code><a href="#topic+alleleobject">alleleobject</a></code> or
<code><a href="#topic+prab">prab</a></code>-objects for
different output dimensions in order to compare stress values.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stressvals(x,mdsdim=1:12,trace=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stressvals_+3A_x">x</code></td>
<td>
<p>object of class <code><a href="#topic+alleleobject">alleleobject</a></code> or <code>link{prab}</code>.
generated by <code><a href="#topic+alleleinit">alleleinit</a></code> or <code><a href="#topic+prabinit">prabinit</a></code>.</p>
</td></tr>
<tr><td><code id="stressvals_+3A_mdsdim">mdsdim</code></td>
<td>
<p>integer vector of MDS numbers of dimensions to be
tried.</p>
</td></tr>
<tr><td><code id="stressvals_+3A_trace">trace</code></td>
<td>
<p>logical. <code>trace</code>-argument for <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>
(should trace information be printed during execution?).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that zero distances between
non-identical objects are replaced by the smallest nonzero distance
divided by 10 to prevent <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code> from producing an error.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>MDSstress</code></td>
<td>
<p>vector of stress values.</p>
</td></tr>
<tr><td><code>mdsout</code></td>
<td>
<p>list of full outputs of <code><a href="MASS.html#topic+isoMDS">isoMDS</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  options(digits=4)
  data(tetragonula)
  set.seed(112233)
  taiselect &lt;- sample(236,40)
# Use data subset to make execution faster.
  tnb &lt;-
  coord2dist(coordmatrix=tetragonula.coord[taiselect,],
    cut=50,file.format="decimal2",neighbors=TRUE)
  ta &lt;- alleleconvert(strmatrix=tetragonula[taiselect,])
  tai &lt;- alleleinit(allelematrix=ta,neighborhood=tnb$nblist)
  stressvals(tai,mdsdim=1:3)$MDSstress
</code></pre>

<hr>
<h2 id='tetragonula'>Microsatellite genetic data of Tetragonula bees</h2><span id='topic+tetragonula'></span><span id='topic+tetragonula.coord'></span>

<h3>Description</h3>

<p>Genetic data for 236 Tetragonula (Apidae) bees from Australia
and Southeast Asia, see  Franck et al. (2004). The data give pairs of
alleles (codominant markers) for 13 microsatellite loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tetragonula)</code></pre>


<h3>Format</h3>

<p>Two objects are generated:
</p>

<dl>
<dt>tetragonula</dt><dd><p>A data frame with 236 observations and 13 string
variables. Strings consist of six digits each. The
format is derived from the data format used by the software GENEPOP
(Rousset 2008). Alleles have a three digit code, so a value of
<code>"258260"</code> on variable V10 means that on locus 10 the two alleles have
codes 258 and 260. <code>"000"</code> refers to missing values.</p>
</dd>
<dt>tetragonula.coord</dt><dd><p>a 236*2 matrix. Coordinates of locations of
individuals in decimal format, i.e. the first number is latitude
(negative values are South), with minutes and seconds
converted to fractions. The second number is longitude (negative
values are West).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Reads from example data file <code>Heterotrigona_indoFO.dat</code>. 
</p>


<h3>Source</h3>

<p>Franck, P., E. Cameron, G. Good, J.-Y. Rasplus, and B. P. Oldroyd
(2004) Nest architecture and genetic differentiation in a species
complex of Australian stingless bees. <em>Mol. Ecol.</em> 13, 2317-2331.
</p>
<p>Rousset, F. (2008) genepop'007: a complete re-implementation of the
genepop software for Windows and Linux. <em>Molecular Ecology
Resources</em> 8, 103-106.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tetragonula)
</code></pre>

<hr>
<h2 id='toprab'>Convert abundance matrix into presence/absence matrix</h2><span id='topic+toprab'></span>

<h3>Description</h3>

<p>Converts abundance matrix into binary (logical) presence/absence
matrix (<code>TRUE</code> if
abundance&gt;0). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toprab(prabobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toprab_+3A_prabobj">prabobj</code></td>
<td>
<p>object of class <code>prab</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical matrix with same dimensions as <code>prabobj$prab</code> as described above.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(siskiyou)
  x &lt;- prabinit(prabmatrix=siskiyou, neighborhood=siskiyou.nb,
             distance="none")
  toprab(x)
</code></pre>

<hr>
<h2 id='unbuild.charmatrix'>Internal: create allele list out of character matrix</h2><span id='topic+unbuild.charmatrix'></span>

<h3>Description</h3>

<p>Creates a list of lists, such as required by <code><a href="#topic+alleledist">alleledist</a></code>,
from the <code>charmatrix</code> component of an
<code><a href="#topic+alleleobject">alleleobject</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   unbuild.charmatrix(charmatrix,n.individuals,n.variables)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unbuild.charmatrix_+3A_charmatrix">charmatrix</code></td>
<td>
<p>matrix of characters in which there are two rows for
every individual corresponding to the two alleles in every locus
(column). Entries are allele codes but missing values are coded as
<code>NA</code>.</p>
</td></tr>  
<tr><td><code id="unbuild.charmatrix_+3A_n.individuals">n.individuals</code></td>
<td>
<p>integer. Number of individuals.</p>
</td></tr>
<tr><td><code id="unbuild.charmatrix_+3A_n.variables">n.variables</code></td>
<td>
<p>integer. Number of loci.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists. In the &quot;outer&quot; list, there are
<code>n.variables</code> lists, one for each locus. In the &quot;inner&quot; list, for every
individual there is a vector of two codes (typically characters, see
<code><a href="#topic+alleleinit">alleleinit</a></code>) for the two alleles in that locus.
</p>


<h3>Author(s)</h3>

<p>Christian Hennig
<a href="mailto:christian.hennig@unibo.it">christian.hennig@unibo.it</a>
<a href="https://www.unibo.it/sitoweb/christian.hennig/en">https://www.unibo.it/sitoweb/christian.hennig/en</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+alleleinit">alleleinit</a></code>, <code><a href="#topic+build.charmatrix">build.charmatrix</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(tetragonula)
  tnb &lt;-
  coord2dist(coordmatrix=tetragonula.coord[1:50,],cut=50,file.format="decimal2",neighbors=TRUE)
  ta &lt;- alleleconvert(strmatrix=tetragonula[1:50,])
  tai &lt;- alleleinit(allelematrix=ta,neighborhood=tnb$nblist,distance="none")
  str(unbuild.charmatrix(tai$charmatrix,50,13)) 
</code></pre>

<hr>
<h2 id='veronica'>Genetic AFLP data of Veronica plants</h2><span id='topic+veronica'></span><span id='topic+veronica.coord'></span>

<h3>Description</h3>

<p>0-1 data indicating whether dominant markers are present for 583
different AFLP bands ranging from 61 to 454 bp of 207 plant
individuals of Veronica (Pentasepalae) from the Iberian Peninsula and
Morocco (Martinez-Ortega et al., 2004). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(veronica)</code></pre>


<h3>Format</h3>

<p>Two objects are generated:
</p>

<dl>
<dt>veronica</dt><dd><p>0-1 matrix with 207 individuals (rows) and 583 AFLP
bands (columns).</p>
</dd>
<dt>veronica.coord</dt><dd><p>a 207*2 matrix. Coordinates of locations of
individuals in decimal format, i.e. the first number is latitude
(negative values are South), with minutes and seconds
converted to fractions. The second number is longitude (negative
values are West).</p>
</dd>
</dl>



<h3>Details</h3>

<p>Reads from example data files <code>MartinezOrtega04AFLP.dat,
    MartinezKoord.dat</code>. 
</p>


<h3>Source</h3>

<p>Martinez-Ortega, M. M., L. Delgado, D. C. Albach,
J. A. Elena-Rossello, and E. Rico (2004). Species boundaries
and phylogeographic patterns in cryptic taxa inferred from AFLP
markers: Veronica subgen. Pentasepalae (Scrophulariaceae) in the
Western Mediterranean.<em>Syst. Bot.</em> 29, 965-986.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(veronica)
</code></pre>

<hr>
<h2 id='waterdist'>Overwater distances between islands in the Aegean sea</h2><span id='topic+waterdist'></span>

<h3>Description</h3>

<p>Distance matrix of overwater distances in km between 34 islands in the
Aegean sea.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(waterdist)</code></pre>


<h3>Format</h3>

<p>A symmetric 34*34 distance matrix.</p>


<h3>Details</h3>

<p>Reads from example data file <code>Waterdist.dat</code>, in which there is a
35th column and line with distances to Turkey mainland.
</p>


<h3>Source</h3>

<p>B. Hausdorf and C. Hennig (2005) The influence of recent geography,
palaeography and climate on the composition of the faune of the
central Aegean Islands.   <em>Biological Journal of the Linnean
Society</em> 84, 785-795.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(waterdist)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
