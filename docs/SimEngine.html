<!DOCTYPE html><html><head><title>Help for package SimEngine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimEngine}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#batch'><p>Run a block of code as part of a batch</p></a></li>
<li><a href='#get_complex'><p>Access internal simulation variables</p></a></li>
<li><a href='#js_support'><p>Display information about currently-supported job schedulers</p></a></li>
<li><a href='#new_sim'><p>Create a new simulation object</p></a></li>
<li><a href='#run'><p>Run the simulation</p></a></li>
<li><a href='#run_on_cluster'><p>Framework for running simulations on a cluster computing system</p></a></li>
<li><a href='#set_config'><p>Modify the simulation configuration</p></a></li>
<li><a href='#set_levels'><p>Set simulation levels</p></a></li>
<li><a href='#set_script'><p>Set the &quot;simulation script&quot;</p></a></li>
<li><a href='#SimEngine-package'><p>SimEngine: A Modular Framework for Statistical Simulations in R</p></a></li>
<li><a href='#summarize'><p>Summarize simulation results</p></a></li>
<li><a href='#update_sim'><p>Update a simulation</p></a></li>
<li><a href='#update_sim_on_cluster'><p>Framework for updating simulations on a cluster computing system</p></a></li>
<li><a href='#use_method'><p>Use a method</p></a></li>
<li><a href='#vars'><p>Access internal simulation variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Modular Framework for Statistical Simulations in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An open-source R package for structuring, maintaining, running, and debugging statistical simulations on both local and cluster-based computing environments.See full documentation at <a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>magrittr (&ge; 2.0.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.10), parallel (&ge; 4.2.2), pbapply (&ge; 1.6.0),
data.table (&ge; 1.14.6), rlang (&ge; 1.0.6), methods (&ge; 4.2.2),
stats (&ge; 4.0.0), utils (&ge; 4.2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.6.1), knitr (&ge; 1.41), rmarkdown (&ge; 2.19),
testthat (&ge; 3.1.6), tidyr (&ge; 1.2.1), ggplot2 (&ge; 3.4.0),
sandwich (&ge; 3.0.2)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-26 17:29:51 UTC; avike</td>
</tr>
<tr>
<td>Author:</td>
<td>Avi Kenny [aut, cre],
  Charles Wolock [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Avi Kenny &lt;avi.kenny@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-26 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='batch'>Run a block of code as part of a batch</h2><span id='topic+batch'></span>

<h3>Description</h3>

<p>This function is designed to be used within a simulation script
to leverage &quot;replicate batches&quot;. This is useful if you want to share data
or objects between simulation replicates. Essentially, it allows you to
take your simulation replicates and divide them into &quot;batches&quot;; all
replicates in a given batch will then share a single set of objects. The
most common use case for this is if you have a simulation that involves
generating one dataset, analyzing it using multiple methods, and then
repeating this a number of times. See
<a href="https://avi-kenny.github.io/SimEngine/advanced-usage/#using-the-batch-function">https://avi-kenny.github.io/SimEngine/advanced-usage/#using-the-batch-function</a>
for a thorough overview of how this function is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batch_+3A_code">code</code></td>
<td>
<p>A block of code enclosed by curly braces ; see examples.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n, mu) { rnorm(n=n, mean=mu) }
est_mean &lt;- function(dat, type) {
  if (type=="est_mean") { return(mean(dat)) }
  if (type=="est_median") { return(median(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100), mu=c(3,5), est=c("est_mean","est_median"))
sim %&lt;&gt;% set_config(
  num_sim = 2,
  batch_levels = c("n","mu"),
  return_batch_id = TRUE
)
sim %&lt;&gt;% set_script(function() {
  batch({
    dat &lt;- create_data(n=L$n, mu=L$mu)
  })
  mu_hat &lt;- est_mean(dat=dat, type=L$est)
  return(list(
    "mu_hat" = round(mu_hat,2),
    "dat_1" = round(dat[1],2)
  ))
})
sim %&lt;&gt;% run()
sim$results[order(sim$results$batch_id),]
</code></pre>

<hr>
<h2 id='get_complex'>Access internal simulation variables</h2><span id='topic+get_complex'></span>

<h3>Description</h3>

<p>Extract complex simulation data from a simulation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_complex(sim, sim_uid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_complex_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="get_complex_+3A_sim_uid">sim_uid</code></td>
<td>
<p>The unique identifier of a single simulation replicate. This
corresponds to the <code>sim_uid</code> column in <code>sim$results</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the complex simulation result data corresponding to the
supplied <code>sim_uid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n) {
  x &lt;- runif(n)
  y &lt;- 3 + 2*x + rnorm(n)
  return(data.frame("x"=x, "y"=y))
}
sim %&lt;&gt;% set_levels("n"=c(10, 100, 1000))
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  model &lt;- lm(y~x, data=dat)
  return (list(
    "beta1_hat" = model$coefficients[[2]],
    ".complex" = model
  ))
})
sim %&lt;&gt;% run()
sim$results %&gt;% print()
get_complex(sim, 1) %&gt;% print()
</code></pre>

<hr>
<h2 id='js_support'>Display information about currently-supported job schedulers</h2><span id='topic+js_support'></span>

<h3>Description</h3>

<p>Run this function to display information about job schedulers
that are currently supported for running <span class="pkg">SimEngine</span> simulations on a
cluster computing system (CCS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>js_support()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>js_support()
</code></pre>

<hr>
<h2 id='new_sim'>Create a new simulation object</h2><span id='topic+new_sim'></span>

<h3>Description</h3>

<p>Create a new simulation object. This is typically the first
function to be called when running a simulation using <span class="pkg">SimEngine</span>. Most
other <span class="pkg">SimEngine</span> functions take a simulation object as their first
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sim()
</code></pre>


<h3>Value</h3>

<p>A simulation object, of class <code>sim_obj</code>
</p>


<h3>See Also</h3>

<p>Visit <a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a> for more information on how to
use the <span class="pkg">SimEngine</span> simulation framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
sim
</code></pre>

<hr>
<h2 id='run'>Run the simulation</h2><span id='topic+run'></span>

<h3>Description</h3>

<p>This is the workhorse function of <span class="pkg">SimEngine</span> that actually
runs the simulation. This should be called after all functions that set
up the simulation (<code>set_config</code>, <code>set_script</code>, etc.) have been
called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(sim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original simulation object but with the results attached (along
with any errors and warnings). Results are stored in <code>sim$results</code>,
errors are stored in <code>sim$errors</code>, and warnings are stored in
<code>sim$warnings</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example of a simulation, illustrating the use of
# the run function.
sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim$results %&gt;% print()
</code></pre>

<hr>
<h2 id='run_on_cluster'>Framework for running simulations on a cluster computing system</h2><span id='topic+run_on_cluster'></span>

<h3>Description</h3>

<p>This function allows for simulations to be run in parallel on a
cluster computing system (CCS). It acts as a wrapper for the code in your
simulation script, organizing the code into three sections, labeled
&quot;first&quot; (code that is run once at the start of the simulation, e.g.
setting simulation levels), &quot;main&quot; (running the simulation script via
<code><a href="#topic+run">run</a></code>)), and &quot;last&quot; (usually code to process or summarize
simulation results). This function interacts with cluster job scheduler
software (e.g. Slurm or Oracle Grid Engine) to divide parallel tasks over
cluster nodes. See
<a href="https://avi-kenny.github.io/SimEngine/parallelization/">https://avi-kenny.github.io/SimEngine/parallelization/</a> for a
detailed overview of how CCS parallelization works in <span class="pkg">SimEngine</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_on_cluster(first, main, last, cluster_config)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_on_cluster_+3A_first">first</code></td>
<td>
<p>Code to run at the start of a simulation. This should be a block
of code enclosed by curly braces  that creates a simulation object. Put
everything you need in the simulation object, since global variables
declared in this block will not be available when the 'main' and 'last'
code blocks run.</p>
</td></tr>
<tr><td><code id="run_on_cluster_+3A_main">main</code></td>
<td>
<p>Code that will run for every simulation replicate. This should be
a block of code enclosed by curly braces , and will almost always
contain only a single call to the <code><a href="#topic+run">run</a></code>) function. This code
block will have access to the simulation object you created in the
'first' code block, but any changes made here to the simulation object
will not be saved.</p>
</td></tr>
<tr><td><code id="run_on_cluster_+3A_last">last</code></td>
<td>
<p>Code that will run after all simulation replicates have been run.
This should be a block of code enclosed by curly braces  that takes
your simulation object (which at this point will contain your results)
and do something with it, such as display your results on a graph.</p>
</td></tr>
<tr><td><code id="run_on_cluster_+3A_cluster_config">cluster_config</code></td>
<td>
<p>A list of configuration options. You must specify
either <code>js</code> (the job scheduler you are using) or <code>tid_var</code> (the
name of the environment variable that your task ID is stored in). Run
<code>js_support()</code> to see a list of job schedulers that are currently
supported. You can optionally also specify <code>dir</code>, which is a
character string representing a path to a directory; this directory will
serve as your working directory and hold your simulation object,
temporary <span class="pkg">SimEngine</span> objects, and simulation results (this defaults
to the working directory of the R script that contains your simulation
code).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The following is a toy simulation that could be run on a cluster computing
# environment. It runs 10 replicates of 2 simulation levels as 20 separate
# cluster jobs, and then summarizes the results. This function is designed to
# be used in conjunction with cluster job scheduler software (e.g. Slurm or
# Oracle Grid Engine). We include both the R code as well as sample BASH code
# for running the simulation using Oracle Grid Engine.

# This code is saved in a file called my_simulation.R
library(SimEngine)
run_on_cluster(

  first = {
    sim &lt;- new_sim()
    create_data &lt;- function(n) { rnorm(n) }
    sim %&lt;&gt;% set_script(function() {
      data &lt;- create_data(L$n)
      return(list("x"=mean(data)))
    })
    sim %&lt;&gt;% set_levels(n=c(100,1000))
    sim %&lt;&gt;% set_config(num_sim=10)
  },

  main = {
    sim %&lt;&gt;% run()
  },

  last = {
    sim %&gt;% summarize()
  },

  cluster_config = list(js="ge")

)

# This code is saved in a file called run_sim.sh
# #!/bin/bash
# Rscript my_simulation.R

# The following lines of code are run on the cluster head node.
# qsub -v sim_run='first' run_sim.sh
# qsub -v sim_run='main' -t 1-20 -hold_jid 101 run_sim.sh
# qsub -v sim_run='last' -hold_jid 102 run_sim.sh

## End(Not run)
</code></pre>

<hr>
<h2 id='set_config'>Modify the simulation configuration</h2><span id='topic+set_config'></span>

<h3>Description</h3>

<p>This function sets configuration options for the simulation. If
the 'packages' argument is specified, all packages will be loaded and
attached via <code>library</code> when <code>set_config</code> is called. Multiple
calls to <code>set_config</code> will only overwrite configuration options that
are specified in the subsequent calls, leaving others in place. You can
see the current configuration via <code>print(sim)</code>, where <code>sim</code> is
your simulation object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_config(
  sim,
  num_sim = 1000,
  parallel = FALSE,
  n_cores = NA,
  packages = NULL,
  stop_at_error = FALSE,
  progress_bar = TRUE,
  seed = as.integer(1e+09 * runif(1)),
  batch_levels = NA,
  return_batch_id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_config_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="set_config_+3A_num_sim">num_sim</code></td>
<td>
<p>An integer; the number of simulations to conduct for each
level combination</p>
</td></tr>
<tr><td><code id="set_config_+3A_parallel">parallel</code></td>
<td>
<p>Boolean; if set to TRUE, <span class="pkg">SimEngine</span> will run one
simulation per core. if set to FALSE, code will not be parallelized. See
<a href="https://avi-kenny.github.io/SimEngine/parallelization/">https://avi-kenny.github.io/SimEngine/parallelization/</a> for an
overview of how parallelization works in <span class="pkg">SimEngine</span>. This option
will be automatically set to TRUE if the simulation is being run on a
cluster computing system.</p>
</td></tr>
<tr><td><code id="set_config_+3A_n_cores">n_cores</code></td>
<td>
<p>An integer; determines the number of cores on which the
simulation will run if using parallelization. Defaults to one fewer than
the number of available cores.</p>
</td></tr>
<tr><td><code id="set_config_+3A_packages">packages</code></td>
<td>
<p>A character vector of packages to load and attach</p>
</td></tr>
<tr><td><code id="set_config_+3A_stop_at_error">stop_at_error</code></td>
<td>
<p>Boolean; if set to TRUE, the simulation will stop if it
encounters an error in any single replicate Useful for debugging.</p>
</td></tr>
<tr><td><code id="set_config_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Boolean; if set to FALSE, the progress bar that is
normally displayed while the simulation is running is suppressed.</p>
</td></tr>
<tr><td><code id="set_config_+3A_seed">seed</code></td>
<td>
<p>An integer; seeds allow for reproducible simulation results. If a
seed is specified, then consecutive runs of the same simulation with the
same seed will lead to identical results (under normal circumstances). If
a seed was not set in advance by the user, <span class="pkg">SimEngine</span> will set a
random seed, which can later be retrieved using the <code><a href="#topic+vars">vars</a></code>
function. See details for further info.</p>
</td></tr>
<tr><td><code id="set_config_+3A_batch_levels">batch_levels</code></td>
<td>
<p>Either NULL or a character vector. If the
<code><a href="#topic+batch">batch</a></code> function is being used within the simulation script,
this should contain the names of the simulation levels that are used
within the <code><a href="#topic+batch">batch</a></code> function code block. If no simulation
levels are used within the <code><a href="#topic+batch">batch</a></code> function code block,
specify NULL. See the documentation for the <code><a href="#topic+batch">batch</a></code> function.</p>
</td></tr>
<tr><td><code id="set_config_+3A_return_batch_id">return_batch_id</code></td>
<td>
<p>Boolean. If set to TRUE, the batch_id will be included
as part of the simulation results</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>If a user specifies, for example, <code>set_config(seed=4)</code>, this
seed is used twice by <span class="pkg">SimEngine</span>. First, <span class="pkg">SimEngine</span> executes
<code>set.seed(4)</code> at the end of the <code>set_config</code> call. Second, this
seed is used to generate a new set of seeds, one for each simulation
replicate. Each of these seeds is set in turn (or in parallel) when
<code><a href="#topic+run">run</a></code> is called.
</p>
</li>
<li><p>Even if seeds are used, not all code will be reproducible. For
example, a simulation that involves getting the current date/time with
<code>Sys.time</code> or dynamically retrieving external data may produce
different results on different runs.
</p>
</li></ul>



<h3>Value</h3>

<p>The original simulation object with a modified configuration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
sim %&lt;&gt;% set_config(
  num_sim = 10,
  seed = 2112
)
sim
</code></pre>

<hr>
<h2 id='set_levels'>Set simulation levels</h2><span id='topic+set_levels'></span>

<h3>Description</h3>

<p>Set one or more simulation levels, which are things that vary
between simulation replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_levels(sim, ..., .keep = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_levels_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="set_levels_+3A_...">...</code></td>
<td>
<p>One or more key-value pairs representing simulation levels. Each
value can either be a vector (for simple levels) or a list of lists (for
more complex levels). See examples.</p>
</td></tr>
<tr><td><code id="set_levels_+3A_.keep">.keep</code></td>
<td>
<p>An integer vector specifying which level combinations to keep;
see examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original simulation object with the old set of levels replaced
with the new set
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic usage is as follows:
sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(
  "n" = c(10, 100, 1000),
  "theta" = c(2, 3)
)
sim$levels

# More complex levels can be set using lists:
sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(
  "n" = c(10, 100, 1000),
  "theta" = c(2, 3),
  "method" = list(
    "spline1" = list(knots=c(2,4), slopes=c(0.1,0.4)),
    "spline2" = list(knots=c(1,5), slopes=c(0.2,0.3))
  )
)
sim$levels

# If you don't want to run simulations for all level combinations, use the
# .keep option. First, set the levels normally. Second, view the
# sim$levels_grid dataframe to examine the level combinations and the
# associated level_id values. Third, call set_levels again with the .keep
# option to specify which levels to keep (via a vector of level_id values).
sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(alpha=c(1,2,3), beta=c(5,6))
sim$levels_grid
#&gt;   level_id alpha beta
#&gt; 1        1     1    5
#&gt; 2        2     2    5
#&gt; 3        3     3    5
#&gt; 4        4     1    6
#&gt; 5        5     2    6
#&gt; 6        6     3    6
sim %&lt;&gt;% set_levels(.keep=c(1,2,6))
sim$levels_grid
#&gt;   level_id alpha beta
#&gt; 1        1     1    5
#&gt; 2        2     2    5
#&gt; 6        6     3    6
</code></pre>

<hr>
<h2 id='set_script'>Set the &quot;simulation script&quot;</h2><span id='topic+set_script'></span>

<h3>Description</h3>

<p>Specify a function to be used as the &quot;simulation script&quot;. The
simulation script is a function that runs a single simulation replicate
and returns the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_script(sim, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_script_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="set_script_+3A_fn">fn</code></td>
<td>
<p>A function that runs a single simulation replicate and returns the
results. The results must be a list of key-value pairs. Values are
categorized as simple (a number, a character string, etc.) or complex
(vectors, dataframes, lists, etc.). Complex data must go inside a key
called &quot;.complex&quot; and the associated value must be a list (see examples).
The function body can contain references to the special object <code>L</code>
that stores the current set of simulation levels (see examples).
The keys must be valid R names (see ?make.names). Any functions used
within the script must be declared before <code>set_script</code> is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original simulation object with the new &quot;simulation script&quot;
function added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example of a simulation, illustrating the use of
# the set_script function.
sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim$results

# If you need to return complex result data (vectors, dataframes, lists,
# etc.), use the construct ".complex"=list().
sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(n=c(4,9))
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- rnorm(L$n)
  mtx &lt;- matrix(dat, nrow=sqrt(length(dat)))
  return (list(
    "mean" = mean(dat),
    "det" = det(mtx),
    ".complex" = list(dat=dat, mtx=mtx)
  ))
})
sim %&lt;&gt;% run()

</code></pre>

<hr>
<h2 id='SimEngine-package'>SimEngine: A Modular Framework for Statistical Simulations in R</h2><span id='topic+SimEngine'></span><span id='topic+SimEngine-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>An open-source R package for structuring, maintaining, running, and debugging statistical simulations on both local and cluster-based computing environments.See full documentation at <a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Avi Kenny <a href="mailto:avi.kenny@gmail.com">avi.kenny@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Charles Wolock <a href="mailto:cwolock@uw.edu">cwolock@uw.edu</a>
</p>
</li></ul>


<hr>
<h2 id='summarize'>Summarize simulation results</h2><span id='topic+summarize'></span>

<h3>Description</h3>

<p>This function calculates summary statistics for simulation results,
including descriptive statistics (e.g. measures of
center or spread) and inferential statistics (e.g. bias or confidence interval
coverage). All summary statistics are calculated over simulation replicates
within a single simulation level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize(sim, ..., mc_se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>One or more lists, separated by commas, specifying desired summaries of the <code>sim</code>
simulation object. See examples. Each list must have a <code>stat</code> item, which specifies the type of summary statistic to
be calculated. The <code>na.rm</code> item indicates whether to exclude <code>NA</code> values when performing the calculation (with
default being <code>FALSE</code>). For <code>stat</code> options where the <code>name</code> item is optional,
if it is not provided, a name will be formed from the type of summary and the column on which the summary
is performed. Additional required items are detailed below for each <code>stat</code> type.
</p>

<ul>
<li><p><code>list(stat="mean", x="col_1", name="mean_col")</code> computes the
mean of column <code>sim$results$col_1</code> for each level combination and
creates a summary column named <code>"mean_col"</code>. Other single-column
summary statistics (see the next few items) work analogously. <code>name</code>
is optional.
</p>
</li>
<li><p><code>list(stat="median", ...)</code> computes the median.
</p>
</li>
<li><p><code>list(stat="var", ...)</code> computes the variance.
</p>
</li>
<li><p><code>list(stat="sd", ...)</code> computes the standard deviation.
</p>
</li>
<li><p><code>list(stat="mad", ...)</code> computes the mean absolute deviation.
</p>
</li>
<li><p><code>list(stat="iqr", ...)</code> computes the interquartile range.
</p>
</li>
<li><p><code>list(stat="min", ...)</code> computes the minimum.
</p>
</li>
<li><p><code>list(stat="max", ...)</code> computes the maximum.
</p>
</li>
<li><p><code>list(stat="is_na", ...)</code> computes the number of NA values.
</p>
</li>
<li><p><code>list(stat="correlation", x="col_1", y="col_2",
    name="cor_12")</code> computes the (Pearson's) correlation coefficient between
<code>sim$results$col_1</code> and <code>sim$results$col_2</code> for each level
combination and creates a summary column named <code>"cor_12"</code>.
</p>
</li>
<li><p><code>list(stat="covariance", x="col_1", y="col_2",
    name="cov_12")</code> computes the covariance between <code>sim$results$col_1</code>
and <code>sim$results$col_2</code> for each level combination and creates a
summary column named <code>"cov_12"</code>.
</p>
</li>
<li><p><code>list(stat="quantile", x="col_1", prob=0.8, name="q_col_1")</code>
computes the 0.8 quantile of column <code>sim$results$col_1</code> and creates
a summary column named <code>"q_col_1"</code>. <code>prob</code> can be any number in
[0,1].
</p>
</li>
<li><p><code>list(stat="bias", estimate="est", truth=5,
    name="bias_est")</code> computes the absolute bias of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"bias_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="bias_pct", estimate="est", truth=5,
    name="bias_est")</code> computes the percent bias of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"bias_pct_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="mse", estimate="est", truth=5,
    name="mse_est")</code> computes the mean squared error of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"mse_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="mae", estimate="est", truth=5,
    name="mae_est")</code> computes the mean absolute error of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"mae_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="coverage", estimate="est", se="se_est",
    truth=5, name="cov_est")</code> or
<code>list(stat="coverage", lower="est_l", upper="est_u",
    truth=5, name="cov_est")</code> computes confidence interval coverage. With the
first form, <code>estimate</code> gives the name of the variable in
<code>sim$results</code> corresponding to the estimator of interest and
<code>se</code> gives the name of the variable containing the standard error of
the estimator of interest. With the second form, <code>lower</code> gives the
name of the variable containing the confidence interval lower bound and
<code>upper</code> gives the name of the confidence interval upper bound. In
both cases, <code>truth</code> is the true value (see <em>Details</em>), and a
summary column named <code>"cov_est"</code> is created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarize_+3A_mc_se">mc_se</code></td>
<td>
<p>A logical argument indicating whether to compute Monte Carlo standard error and associated confidence interval
for inferential summary statistics.  This applies only to the <code>bias</code>, <code>bias_pct</code>, <code>mse</code>, <code>mae</code>,
and <code>coverage</code> summary statistics.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>For all inferential summaries there are three ways to specify <code>truth</code>: (1) a single number,
meaning the estimand is the same across all simulation replicates and levels, (2) a numeric vector of the
same length as the number of rows in <code>sim$results</code>, or (3) the name of a variable in <code>sim$results</code>
containing the estimand of interest.
</p>
</li>
<li><p>There are two ways to specify the confidence interval bounds for <code>coverage</code>. The first is to provide
an <code>estimate</code> and its associated <code>se</code> (standard error). These should both be variables in
<code>sim$results</code>. The function constructs a 95% Wald-type confidence interval of the form
<code>(estimate-1.96*se, estimate+1.96*se)</code>. The alternative is to provide
<code>lower</code> and <code>upper</code> bounds, which should also be variables in <code>sim$results</code>. In this case,
the confidence interval is (<code>lower</code>, <code>upper</code>). The coverage is the proportion of simulation
replicates for a given level combination in which <code>truth</code> lies within the interval.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame containing the result of each specified summary function as a column, for each of
the simulation levels. The column <code>n_reps</code> returns the number of successful simulation replicates
within each level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example of a simulation, illustrating the use of
# the summarize function.
sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=5)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim %&gt;% summarize(
  list(stat = "mean", name="mean_lambda_hat", x="lambda_hat"),
  list(stat = "mse", name="lambda_mse", estimate="lambda_hat", truth=5)
)
</code></pre>

<hr>
<h2 id='update_sim'>Update a simulation</h2><span id='topic+update_sim'></span>

<h3>Description</h3>

<p>This function updates a previously run simulation. After a
simulation has been <code><a href="#topic+run">run</a></code>, you can alter the levels of the
resulting object of class <code>sim_obj</code> using <code><a href="#topic+set_levels">set_levels</a></code>,
or change the configuration (including the number of simulation
replicates) using <code><a href="#topic+set_config">set_config</a></code>. Executing <code>update_sim</code> on
this simulation object will only run the added levels/replicates, without
repeating anything that has already been run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_sim(sim, keep_errors = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_sim_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code>, that has already been run by the <code><a href="#topic+run">run</a></code>
function</p>
</td></tr>
<tr><td><code id="update_sim_+3A_keep_errors">keep_errors</code></td>
<td>
<p>logical (<code>TRUE</code> by default); if <code>TRUE</code>, do not
try to re-run simulation reps that results in errors previously; if
<code>FALSE</code>, attempt to run those reps again</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>It is not possible to add new level variables, only new levels of the
existing variables. Because of this, it is best practice to include all
potential level variables before initially running a simulation, even if
some of them only contain a single level. This way, additional levels can
be added later.
</p>
</li></ul>



<h3>Value</h3>

<p>The original simulation object with additional simulation replicates
in <code>results</code> or <code>errors</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100), est="M")
sim %&lt;&gt;% set_config(num_sim=10)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=5)
sim %&lt;&gt;% update_sim()
</code></pre>

<hr>
<h2 id='update_sim_on_cluster'>Framework for updating simulations on a cluster computing system</h2><span id='topic+update_sim_on_cluster'></span>

<h3>Description</h3>

<p>This function serves a scaffold for updating a previously-run in
parallel on a cluster computing system. Like
<code><a href="#topic+run_on_cluster">run_on_cluster</a></code>, it acts as a wrapper for the code in your
simulation script, organizing the code into three sections, labeled
&quot;first&quot; (code that is run once at the start of the simulation, e.g.
setting simulation levels), &quot;main&quot; (the simulation script, which is run
repeatedly), and &quot;last&quot; (code to combine and summarize simulation
results). This function interacts with cluster job scheduler software
(e.g. Slurm or Oracle Grid Engine) to divide parallel tasks over cluster
nodes. See <a href="https://avi-kenny.github.io/SimEngine/parallelization/">https://avi-kenny.github.io/SimEngine/parallelization/</a>
for an overview of how cluster parallelization works in <span class="pkg">SimEngine</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_sim_on_cluster(first, main, last, cluster_config, keep_errors = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_sim_on_cluster_+3A_first">first</code></td>
<td>
<p>Code to run before executing additional simulation replicates. For example,
this could include altering the simulation levels or changing <code>nsim</code>. This block of code,
enclosed by curly braces , must first read in an existing simulation object
and then make alterations to it. Global variables declared in this block will not be available when the 'main'
and 'last' code blocks run.</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_main">main</code></td>
<td>
<p>Code that will run for every simulation replicate. This should be
a block of code enclosed by curly braces  that includes a call to
<code><a href="#topic+update_sim">update_sim</a></code>. This code block will have access to the
simulation object you read in the 'first' code block, but any changes
made here to the simulation object will not be saved.</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_last">last</code></td>
<td>
<p>Code that will run after all additional simulation replicates have been run.
This should be a block of code enclosed by curly braces  that takes
your simulation object (which at this point will contain both your old and new results)
and do something with it, such as display your results on a graph.</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_cluster_config">cluster_config</code></td>
<td>
<p>A list of configuration options. You must specify
either <code>js</code> (the job scheduler you are using) or <code>tid_var</code> (the
name of the environment variable that your task ID is stored in). Run
<code>js_support()</code> to see a list of job schedulers that are currently
supported. You can optionally also specify <code>dir</code>, which is a
character string representing a path to a directory; this directory will
serve as your working directory and hold your simulation object,
temporary <span class="pkg">SimEngine</span> objects, and simulation results (this defaults
to the working directory of the R script that contains your simulation
code).</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_keep_errors">keep_errors</code></td>
<td>
<p>logical (<code>TRUE</code> by default); if <code>TRUE</code>, do not
try to re-run simulation reps that results in errors previously; if
<code>FALSE</code>, attempt to run those reps again</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The following code creates, runs, and subsequently updates a toy simulation
# on a cluster computing environment. We include both the R code as well as
# sample BASH code for running the simulation using Oracle Grid Engine.

# This code is saved in a file called my_simulation.R
library(SimEngine)
run_on_cluster(

  first = {
    sim &lt;- new_sim()
    create_data &lt;- function(n) { rnorm(n) }
    sim %&lt;&gt;% set_script(function() {
      data &lt;- create_data(L$n)
      return(list("x"=mean(data)))
    })
    sim %&lt;&gt;% set_levels(n=c(100,1000))
    sim %&lt;&gt;% set_config(num_sim=10)
  },

  main = {
    sim %&lt;&gt;% run()
  },

  last = {
    sim %&gt;% summarize()
  },

  cluster_config = list(js="ge")

)

# This code is saved in a file called run_sim.sh
# #!/bin/bash
# Rscript my_simulation.R

# The following lines of code are run on the cluster head node.
# qsub -v sim_run='first' run_sim.sh
# qsub -v sim_run='main' -t 1-20 -hold_jid 101 run_sim.sh
# qsub -v sim_run='last' -hold_jid 102 run_sim.sh

# This code is saved in a file called update_my_simulation.R. Note that it
# reads in the simulation object created above, which is saved in a file
# called "sim.rds".
library(SimEngine)
update_sim_on_cluster(

  first = {
    sim &lt;- readRDS("sim.rds")
    sim %&lt;&gt;% set_levels(n = c(100,500,1000))
  },

  main = {
    sim %&lt;&gt;% update_sim()
  },

  last = {
    sim %&gt;% summarize()
  },

  cluster_config = list(js="ge")

)

# This code is saved in a file called update_sim.sh
# #!/bin/bash
# Rscript update_my_simulation.R

# The following lines of code are run on the cluster head node. Note that
# only 10 new replicates are run, since 20 of 30 simulation replicates were
# run in the original call to run_on_cluster.
# qsub -v sim_run='first' update_sim.sh
# qsub -v sim_run='main' -t 1-10 -hold_jid 104 update_sim.sh
# qsub -v sim_run='last' -hold_jid 105 update_sim.sh

## End(Not run)
</code></pre>

<hr>
<h2 id='use_method'>Use a method</h2><span id='topic+use_method'></span>

<h3>Description</h3>

<p>This function calls the specified method, passing along any
arguments that have been specified in <code>args</code>. It will typically be
used in conjunction with the special object L to dynamically run methods
that have been included as simulation levels. This function is a wrapper
around do.call and is used in a similar manner. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_method(method, args = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_method_+3A_method">method</code></td>
<td>
<p>A character string naming a function that has been declared or
loaded via <code>source</code>.</p>
</td></tr>
<tr><td><code id="use_method_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed onto <code>method</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the call to <code>method</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example of a simulation, illustrating the use of
# the use_method function.
sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean_1 &lt;- function(dat) { mean(dat) }
est_mean_2 &lt;- function(dat) { var(dat) }
sim %&lt;&gt;% set_levels(
  "n" = c(10, 100, 1000),
  "estimator" = c("est_mean_1", "est_mean_2")
)
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- use_method(L$estimator, list(dat))
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim$results
</code></pre>

<hr>
<h2 id='vars'>Access internal simulation variables</h2><span id='topic+vars'></span>

<h3>Description</h3>

<p>This is a &quot;getter function&quot; that returns the value of an
internal simulation variable. Do not change any of these variables
manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(sim, var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="vars_+3A_var">var</code></td>
<td>
<p>If this argument is omitted, <code>vars</code> will return a list
containing all available internal variables. If this argument is
provided, it should equal one of the following character strings:
</p>

<ul>
<li><p><code>seed</code>: the simulation seed; see <code><a href="#topic+set_config">set_config</a></code> for
more info on seeds.
</p>
</li>
<li><p><code>env</code>: a reference to the environment in which individual
simulation replicates are run (advanced)
</p>
</li>
<li><p><code>num_sim_total</code>: The total number of simulation replicates
for the simulation. This is particularly useful when a simulation is
being run in parallel on a cluster computing system as a job array and
the user needs to know the range of task IDs.
</p>
</li>
<li><p><code>run_state</code>: A character string describing the &quot;run state&quot; of
the simulation. This will equal one of the following: &quot;pre run&quot; (the
simulation has not yet been run), &quot;run, no errors&quot; (the simulation ran
and had no errors), &quot;run, some errors&quot; (the simulation ran and had some
errors), &quot;run, all errors&quot; (the simulation ran and all replicates had
errors).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>You can also access simulation variables through sim$vars, where
<code>sim</code> is your simulation object (see examples).
</p>
</li></ul>



<h3>Value</h3>

<p>The value of the internal variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(
  "n" = c(10, 100, 1000)
)
sim %&lt;&gt;% set_config(num_sim=10)
vars(sim, "num_sim_total") %&gt;% print()
sim$vars$num_sim_total %&gt;% print()
vars(sim) %&gt;% print()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
