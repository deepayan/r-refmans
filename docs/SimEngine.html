<!DOCTYPE html><html lang="en"><head><title>Help for package SimEngine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SimEngine}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SimEngine-package'><p>SimEngine: A Modular Framework for Statistical Simulations in R</p></a></li>
<li><a href='#batch'><p>Run a block of code as part of a batch</p></a></li>
<li><a href='#get_complex'><p>Access internal simulation variables</p></a></li>
<li><a href='#js_support'><p>Display information about currently-supported job schedulers</p></a></li>
<li><a href='#new_sim'><p>Create a new simulation object</p></a></li>
<li><a href='#run'><p>Run the simulation</p></a></li>
<li><a href='#run_on_cluster'><p>Framework for running simulations on a cluster computing system</p></a></li>
<li><a href='#set_config'><p>Modify the simulation configuration</p></a></li>
<li><a href='#set_levels'><p>Set simulation levels</p></a></li>
<li><a href='#set_script'><p>Set the &quot;simulation script&quot;</p></a></li>
<li><a href='#summarize'><p>Summarize simulation results</p></a></li>
<li><a href='#update_sim'><p>Update a simulation</p></a></li>
<li><a href='#update_sim_on_cluster'><p>Framework for updating simulations on a cluster computing system</p></a></li>
<li><a href='#use_method'><p>Use a method</p></a></li>
<li><a href='#vars'><p>Access internal simulation variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Modular Framework for Statistical Simulations in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An open-source R package for structuring, maintaining, running, and debugging statistical simulations on both local and cluster-based computing environments.See full documentation at <a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>magrittr (&ge; 2.0.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.0.10), parallel (&ge; 4.2.2), pbapply (&ge; 1.6.0),
data.table (&ge; 1.14.6), rlang (&ge; 1.0.6), methods (&ge; 4.2.2),
stats (&ge; 4.0.0), utils (&ge; 4.2.2), MASS (&ge; 7.3.50)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr (&ge; 3.6.1), knitr (&ge; 1.41), rmarkdown (&ge; 2.19),
testthat (&ge; 3.1.6), tidyr (&ge; 1.2.1), ggplot2 (&ge; 3.4.0),
sandwich (&ge; 3.0.2)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Avi-Kenny/SimEngine/issues">https://github.com/Avi-Kenny/SimEngine/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 02:55:44 UTC; ak811</td>
</tr>
<tr>
<td>Author:</td>
<td>Avi Kenny [aut, cre],
  Charles Wolock [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Avi Kenny &lt;avi.kenny@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-04 03:22:58 UTC</td>
</tr>
</table>
<hr>
<h2 id='SimEngine-package'>SimEngine: A Modular Framework for Statistical Simulations in R</h2><span id='topic+SimEngine'></span><span id='topic+SimEngine-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>An open-source R package for structuring, maintaining, running, and debugging statistical simulations on both local and cluster-based computing environments.See full documentation at <a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Avi Kenny <a href="mailto:avi.kenny@gmail.com">avi.kenny@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Charles Wolock <a href="mailto:cwolock@uw.edu">cwolock@uw.edu</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Avi-Kenny/SimEngine/issues">https://github.com/Avi-Kenny/SimEngine/issues</a>
</p>
</li></ul>


<hr>
<h2 id='batch'>Run a block of code as part of a batch</h2><span id='topic+batch'></span>

<h3>Description</h3>

<p>This function is useful for sharing data or objects between
simulation replicates. Essentially, it allows simulation replicates to be
divided into “batches”; all replicates in a given batch will then share a
certain set of objects. A common use case for this is a simulation that
involves using multiple methods to analyze a shared dataset, and
repeating this process over a number of dataset replicates. See the <a href="https://avi-kenny.github.io/SimEngine/articles/advanced-functionality.html#using-the-batch-function">Advanced Functionality</a>
vignette for a detailed overview of how this function is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batch(code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="batch_+3A_code">code</code></td>
<td>
<p>A block of code enclosed by curly braces {}; see examples.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n, mu) { rnorm(n=n, mean=mu) }
est_mean &lt;- function(dat, type) {
  if (type=="est_mean") { return(mean(dat)) }
  if (type=="est_median") { return(median(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100), mu=c(3,5), est=c("est_mean","est_median"))
sim %&lt;&gt;% set_config(
  num_sim = 2,
  batch_levels = c("n","mu"),
  return_batch_id = TRUE
)
sim %&lt;&gt;% set_script(function() {
  batch({
    dat &lt;- create_data(n=L$n, mu=L$mu)
  })
  mu_hat &lt;- est_mean(dat=dat, type=L$est)
  return(list(
    "mu_hat" = round(mu_hat,2),
    "dat_1" = round(dat[1],2)
  ))
})
sim %&lt;&gt;% run()
sim$results[order(sim$results$batch_id),]
</code></pre>

<hr>
<h2 id='get_complex'>Access internal simulation variables</h2><span id='topic+get_complex'></span>

<h3>Description</h3>

<p>Extract complex simulation data from a simulation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_complex(sim, sim_uid)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_complex_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="get_complex_+3A_sim_uid">sim_uid</code></td>
<td>
<p>The unique identifier of a single simulation replicate. This
corresponds to the <code>sim_uid</code> column in <code>sim$results</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the complex simulation result data corresponding to the
supplied <code>sim_uid</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(n=c(10, 100, 1000))
create_data &lt;- function(n) {
  x &lt;- runif(n)
  y &lt;- 3 + 2*x + rnorm(n)
  return(data.frame("x"=x, "y"=y))
}
sim %&lt;&gt;% set_config(num_sim=2)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  model &lt;- lm(y~x, data=dat)
  return(list(
    "beta0_hat" = model$coefficients[[1]],
    "beta1_hat" = model$coefficients[[2]],
    ".complex" = list(
      "model" = model,
      "cov_mtx" = vcov(model)
    )
  ))
})
sim %&lt;&gt;% run()
c5 &lt;- get_complex(sim, sim_uid=5)
print(summary(c5$model))
print(c5$cov_mtx)
</code></pre>

<hr>
<h2 id='js_support'>Display information about currently-supported job schedulers</h2><span id='topic+js_support'></span>

<h3>Description</h3>

<p>Run this function to display information about job schedulers
that are currently supported for running <span class="pkg">SimEngine</span> simulations on a
cluster computing system (CCS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>js_support()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>js_support()
</code></pre>

<hr>
<h2 id='new_sim'>Create a new simulation object</h2><span id='topic+new_sim'></span>

<h3>Description</h3>

<p>Create a new simulation object. This is typically the first
function to be called when running a simulation using <span class="pkg">SimEngine</span>.
Most other <span class="pkg">SimEngine</span> functions take a simulation object as their
first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_sim()
</code></pre>


<h3>Value</h3>

<p>A simulation object, of class <code>sim_obj</code>
</p>


<h3>See Also</h3>

<p>Visit <a href="https://avi-kenny.github.io/SimEngine/">https://avi-kenny.github.io/SimEngine/</a> for more information on how to
use the <span class="pkg">SimEngine</span> simulation framework.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
print(sim)
</code></pre>

<hr>
<h2 id='run'>Run the simulation</h2><span id='topic+run'></span>

<h3>Description</h3>

<p>This is the workhorse function of <span class="pkg">SimEngine</span> that actually
runs the simulation. This should be called after all functions that set
up the simulation (<code>set_config</code>, <code>set_script</code>, etc.) have been
called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run(sim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original simulation object but with the results attached (along
with any errors and warnings). Results are stored in <code>sim$results</code>,
errors are stored in <code>sim$errors</code>, and warnings are stored in
<code>sim$warnings</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim$results %&gt;% print()
</code></pre>

<hr>
<h2 id='run_on_cluster'>Framework for running simulations on a cluster computing system</h2><span id='topic+run_on_cluster'></span>

<h3>Description</h3>

<p>This function allows for simulations to be run in parallel on a
cluster computing system (CCS). See the <a href="https://avi-kenny.github.io/SimEngine/articles/parallelization.html">Parallelization</a>
vignette for a detailed overview of how CCS parallelization works in
<span class="pkg">SimEngine</span>. <code>run_on_cluster</code> acts as a wrapper for the code in
your simulation, organizing the code into three sections, labeled &quot;first&quot;
(code that is run once at the start of the simulation), &quot;main&quot;
(running the simulation script repeatedly), and &quot;last&quot; (code to process
or summarize simulation results). This function is to be used in
conjunction with job scheduler software (e.g., Slurm or Oracle Grid
Engine) to divide the simulation into tasks that are run in parallel on
the CCS. See the Parallelization documentation for a detailed overview of
how CCS parallelization works in <span class="pkg">SimEngine</span>.
<code><a href="#topic+run">run</a></code>)), and &quot;last&quot; (usually code to process or summarize
simulation results). This function interacts with cluster job scheduler
software (e.g. Slurm or Oracle Grid Engine) to divide parallel tasks over
cluster nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_on_cluster(first, main, last, cluster_config)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_on_cluster_+3A_first">first</code></td>
<td>
<p>Code to run at the start of a simulation. This should be a block
of code enclosed by curly braces  that creates and sets up a simulation
object.</p>
</td></tr>
<tr><td><code id="run_on_cluster_+3A_main">main</code></td>
<td>
<p>Code that will run for every simulation replicate. This should be
a block of code enclosed by curly braces , and will typically be a
single line of code calling the <code><a href="#topic+run">run</a></code>) function. This code
block will have access to the simulation object you created in the
'first' code block, but any changes made here to the simulation object
will not be saved.</p>
</td></tr>
<tr><td><code id="run_on_cluster_+3A_last">last</code></td>
<td>
<p>Code that will run after all simulation replicates have been run.
This should be a block of code enclosed by curly braces  that processes
your simulation object (which at this point will contain your results),
which may involve calls to <code><a href="#topic+summarize">summarize</a></code>, creation of plots,
and so on.</p>
</td></tr>
<tr><td><code id="run_on_cluster_+3A_cluster_config">cluster_config</code></td>
<td>
<p>A list of configuration options. You must specify
either <code>js</code> (the job scheduler you are using) or <code>tid_var</code> (the
name of the environment variable that your task ID is stored in); see
examples. Run <code>js_support()</code> to see a list of job schedulers that
are currently supported. You can optionally also specify <code>dir</code>,
which is a character string representing a path to a directory on the
CCS; this directory will serve as your working directory and hold your
simulation object and all temporary objects created by <span class="pkg">SimEngine</span>.
If unspecified, this defaults to the working directory of the R script
that contains your simulation code).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The following code is saved in a file called my_simulation.R:
library(SimEngine)
run_on_cluster(
  first = {
    sim &lt;- new_sim()
    create_data &lt;- function(n) { return(rpois(n=n, lambda=20)) }
    est_lambda &lt;- function(dat, type) {
      if (type=="M") { return(mean(dat)) }
      if (type=="V") { return(var(dat)) }
    }
    sim %&lt;&gt;% set_levels(estimator = c("M","V"), n = c(10,100,1000))
    sim %&lt;&gt;% set_script(function() {
      dat &lt;- create_data(L$n)
      lambda_hat &lt;- est_lambda(dat=dat, type=L$estimator)
      return(list("lambda_hat"=lambda_hat))
    })
    sim %&lt;&gt;% set_config(num_sim=100, n_cores=20)
  },
  main = {
    sim %&lt;&gt;% run()
  },
  last = {
    sim %&gt;% summarize()
  },
  cluster_config = list(js="slurm")
)

# The following code is saved in a file called run_sim.sh:
# #!/bin/bash
# Rscript my_simulation.R

# The following lines of code are run on the CCS head node:
# sbatch --export=sim_run='first' run_sim.sh
# sbatch --export=sim_run='main' --array=1-20 --depend=afterok:101 run_sim.sh
# sbatch --export=sim_run='last' --depend=afterok:102 run_sim.sh

## End(Not run)
</code></pre>

<hr>
<h2 id='set_config'>Modify the simulation configuration</h2><span id='topic+set_config'></span>

<h3>Description</h3>

<p>This function sets configuration options for the simulation. If
the 'packages' argument is specified, all packages will be loaded and
attached via <code>library</code> when <code>set_config</code> is called. Multiple
calls to <code>set_config</code> will only overwrite configuration options that
are specified in the subsequent calls, leaving others in place. You can
see the current configuration via <code>print(sim)</code>, where <code>sim</code> is
your simulation object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_config(
  sim,
  num_sim = 1000,
  parallel = FALSE,
  n_cores = NA,
  packages = NULL,
  stop_at_error = FALSE,
  progress_bar = TRUE,
  seed = as.integer(1e+09 * runif(1)),
  batch_levels = NA,
  return_batch_id = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_config_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="set_config_+3A_num_sim">num_sim</code></td>
<td>
<p>An integer; the number of simulations to conduct for each
level combination</p>
</td></tr>
<tr><td><code id="set_config_+3A_parallel">parallel</code></td>
<td>
<p>Boolean; if set to TRUE, <span class="pkg">SimEngine</span> will run one
simulation per core. if set to FALSE, code will not be parallelized. See
the <a href="https://avi-kenny.github.io/SimEngine/articles/parallelization.html">Parallelization</a>
vignette for an overview of how parallelization works in <span class="pkg">SimEngine</span>.</p>
</td></tr>
<tr><td><code id="set_config_+3A_n_cores">n_cores</code></td>
<td>
<p>An integer; determines the number of cores on which the
simulation will run if using parallelization. Defaults to one fewer than
the number of available cores.</p>
</td></tr>
<tr><td><code id="set_config_+3A_packages">packages</code></td>
<td>
<p>A character vector of packages to load and attach</p>
</td></tr>
<tr><td><code id="set_config_+3A_stop_at_error">stop_at_error</code></td>
<td>
<p>Boolean; if set to TRUE, the simulation will stop if it
encounters an error in any single replicate Useful for debugging.</p>
</td></tr>
<tr><td><code id="set_config_+3A_progress_bar">progress_bar</code></td>
<td>
<p>Boolean; if set to FALSE, the progress bar that is
normally displayed while the simulation is running is suppressed.</p>
</td></tr>
<tr><td><code id="set_config_+3A_seed">seed</code></td>
<td>
<p>An integer; seeds allow for reproducible simulation results. If a
seed is specified, then consecutive runs of the same simulation with the
same seed will lead to identical results (under normal circumstances). If
a seed was not set in advance by the user, <span class="pkg">SimEngine</span> will set a
random seed, which can later be retrieved using the <code><a href="#topic+vars">vars</a></code>
function. See details for further info.</p>
</td></tr>
<tr><td><code id="set_config_+3A_batch_levels">batch_levels</code></td>
<td>
<p>Either NULL or a character vector. If the
<code><a href="#topic+batch">batch</a></code> function is being used within the simulation script,
this should contain the names of the simulation levels that are used
within the <code><a href="#topic+batch">batch</a></code> function code block. If no simulation
levels are used within the <code><a href="#topic+batch">batch</a></code> function code block,
specify NULL. See the documentation for the <code><a href="#topic+batch">batch</a></code> function.</p>
</td></tr>
<tr><td><code id="set_config_+3A_return_batch_id">return_batch_id</code></td>
<td>
<p>Boolean. If set to TRUE, the batch_id will be included
as part of the simulation results</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>If a user specifies, for example, <code>set_config(seed=4)</code>, this
seed is used twice by <span class="pkg">SimEngine</span>. First, <span class="pkg">SimEngine</span> executes
<code>set.seed(4)</code> at the end of the <code>set_config</code> call. Second, this
seed is used to generate a new set of seeds, one for each simulation
replicate. Each of these seeds is set in turn (or in parallel) when
<code><a href="#topic+run">run</a></code> is called.
</p>
</li>
<li><p>Even if seeds are used, not all code will be reproducible. For
example, a simulation that involves getting the current date/time with
<code>Sys.time</code> or dynamically retrieving external data may produce
different results on different runs.
</p>
</li></ul>



<h3>Value</h3>

<p>The original simulation object with a modified configuration
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
sim %&lt;&gt;% set_config(
  num_sim = 10,
  seed = 2112
)
print(sim)
</code></pre>

<hr>
<h2 id='set_levels'>Set simulation levels</h2><span id='topic+set_levels'></span>

<h3>Description</h3>

<p>Set one or more simulation levels, which are things that vary
between simulation replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_levels(sim, ..., .keep = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_levels_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="set_levels_+3A_...">...</code></td>
<td>
<p>One or more key-value pairs representing simulation levels. Each
value can either be a vector (for simple levels) or a list of lists (for
more complex levels). See examples.</p>
</td></tr>
<tr><td><code id="set_levels_+3A_.keep">.keep</code></td>
<td>
<p>An integer vector of level_id values specifying which level
combinations to keep; see the Advanced Functionality documentation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original simulation object with the old set of levels replaced
with the new set
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic simulation levels are numeric or character vectors
sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(
  n = c(10, 100, 1000),
  est = c("M", "V")
)

# Complex simulation levels can be set using named lists of lists
sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(
  n = c(10, 100, 1000),
  distribution = list(
    "Beta 1" = list(type="Beta", params=c(0.3, 0.7)),
    "Beta 2" = list(type="Beta", params=c(1.5, 0.4)),
    "Normal" = list(type="Normal", params=c(3.0, 0.2))
  )
)
</code></pre>

<hr>
<h2 id='set_script'>Set the &quot;simulation script&quot;</h2><span id='topic+set_script'></span>

<h3>Description</h3>

<p>Specify a function to be used as the &quot;simulation script&quot;. The
simulation script is a function that runs a single simulation replicate
and returns the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_script(sim, fn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_script_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="set_script_+3A_fn">fn</code></td>
<td>
<p>A function that runs a single simulation replicate and returns the
results. The results must be a list of key-value pairs. Values are
categorized as simple (a number, a character string, etc.) or complex
(vectors, dataframes, lists, etc.). Complex data must go inside a key
called &quot;.complex&quot; and the associated value must be a list (see Advanced
Functionality documentation and examples). The function body can contain
references to the special object <code>L</code> that stores the current set of
simulation levels (see examples). The keys must be valid R names (see
?make.names). Any functions used within the script must be declared
before <code>set_script</code> is called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original simulation object with the new &quot;simulation script&quot;
function added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim$results %&gt;% print()

# To return complex result data, use the special key ".complex".
sim &lt;- new_sim()
create_data &lt;- function(n) {
  x &lt;- runif(n)
  y &lt;- 3 + 2*x + rnorm(n)
  return(data.frame("x"=x, "y"=y))
}
sim %&lt;&gt;% set_levels("n"=c(10, 100, 1000))
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  model &lt;- lm(y~x, data=dat)
  return (list(
    "beta1_hat" = model$coefficients[[2]],
    ".complex" = model
  ))
})
sim %&lt;&gt;% run()
sim$results %&gt;% print()
get_complex(sim, 1) %&gt;% print()
</code></pre>

<hr>
<h2 id='summarize'>Summarize simulation results</h2><span id='topic+summarize'></span>

<h3>Description</h3>

<p>This function calculates summary statistics for simulation
results, including descriptive statistics (e.g. measures of center or
spread) and inferential statistics (e.g. bias or confidence interval
coverage). All summary statistics are calculated over simulation
replicates within a single simulation level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize(sim, ..., mc_se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarize_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>One or more lists, separated by commas, specifying desired
summaries of the <code>sim</code> simulation object. See examples. Each list
must have a <code>stat</code> item, which specifies the type of summary
statistic to be calculated. The <code>na.rm</code> item indicates whether to
exclude <code>NA</code> values when performing the calculation (with default
being <code>FALSE</code>). For <code>stat</code> options where the <code>name</code> item
is optional, if it is not provided, a name will be formed from the type
of summary and the column on which the summary is performed. Additional
required items are detailed below for each <code>stat</code> type.
</p>

<ul>
<li><p><code>list(stat="mean", x="col_1", name="mean_col", na.rm=F)</code>
computes the mean of column <code>sim$results$col_1</code> for each level
combination and creates a summary column named <code>"mean_col"</code>. Other
single-column summary statistics (see the next few items) work
analogously. <code>name</code> is optional.
</p>
</li>
<li><p><code>list(stat="median", ...)</code> computes the median.
</p>
</li>
<li><p><code>list(stat="var", ...)</code> computes the variance.
</p>
</li>
<li><p><code>list(stat="sd", ...)</code> computes the standard deviation.
</p>
</li>
<li><p><code>list(stat="mad", ...)</code> computes the mean absolute deviation.
</p>
</li>
<li><p><code>list(stat="iqr", ...)</code> computes the interquartile range.
</p>
</li>
<li><p><code>list(stat="min", ...)</code> computes the minimum.
</p>
</li>
<li><p><code>list(stat="max", ...)</code> computes the maximum.
</p>
</li>
<li><p><code>list(stat="is_na", ...)</code> computes the number of NA values.
</p>
</li>
<li><p><code>list(stat="correlation", x="col_1", y="col_2",
    name="cor_12")</code> computes the (Pearson's) correlation coefficient between
<code>sim$results$col_1</code> and <code>sim$results$col_2</code> for each level
combination and creates a summary column named <code>"cor_12"</code>.
</p>
</li>
<li><p><code>list(stat="covariance", x="col_1", y="col_2",
    name="cov_12")</code> computes the covariance between <code>sim$results$col_1</code>
and <code>sim$results$col_2</code> for each level combination and creates a
summary column named <code>"cov_12"</code>.
</p>
</li>
<li><p><code>list(stat="quantile", x="col_1", prob=0.8, name="q_col_1")</code>
computes the 0.8 quantile of column <code>sim$results$col_1</code> and creates
a summary column named <code>"q_col_1"</code>. <code>prob</code> can be any number in
[0,1].
</p>
</li>
<li><p><code>list(stat="bias", estimate="est", truth=5,
    name="bias_est")</code> computes the absolute bias of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"bias_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="bias_pct", estimate="est", truth=5,
    name="bias_est")</code> computes the percent bias of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"bias_pct_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="mse", estimate="est", truth=5,
    name="mse_est")</code> computes the mean squared error of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"mse_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="mae", estimate="est", truth=5,
    name="mae_est")</code> computes the mean absolute error of the estimator
corresponding to column <code>"sim$results$est"</code>, relative to the true
value given in <code>truth</code>, and creates a summary column named
<code>"mae_est"</code>. <code>name</code> is optional. See <em>Details</em>.
</p>
</li>
<li><p><code>list(stat="coverage", estimate="est", se="se_est",
    truth=5, name="cov_est")</code> or
<code>list(stat="coverage", lower="est_l", upper="est_u",
    truth=5, name="cov_est")</code> computes confidence interval coverage. With the
first form, <code>estimate</code> gives the name of the variable in
<code>sim$results</code> corresponding to the estimator of interest and
<code>se</code> gives the name of the variable containing the standard error of
the estimator of interest. With the second form, <code>lower</code> gives the
name of the variable containing the confidence interval lower bound and
<code>upper</code> gives the name of the confidence interval upper bound. In
both cases, <code>truth</code> is the true value (see <em>Details</em>), and a
summary column named <code>"cov_est"</code> is created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarize_+3A_mc_se">mc_se</code></td>
<td>
<p>A logical argument indicating whether to compute Monte Carlo
standard error and associated confidence interval for inferential summary
statistics.  This applies only to the <code>bias</code>, <code>bias_pct</code>,
<code>mse</code>, <code>mae</code>, and <code>coverage</code> summary statistics.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>For all inferential summaries there are three ways to specify
<code>truth</code>: (1) a single number, meaning the estimand is the same
across all simulation replicates and levels, (2) a numeric vector of the
same length as the number of rows in <code>sim$results</code>, or (3) the name
of a variable in <code>sim$results</code> containing the estimand of interest.
</p>
</li>
<li><p>There are two ways to specify the confidence interval bounds for
<code>coverage</code>. The first is to provide an <code>estimate</code> and its
associated <code>se</code> (standard error). These should both be variables in
<code>sim$results</code>. The function constructs a 95% Wald-type confidence
interval of the form <code>(estimate-1.96*se, estimate+1.96*se)</code>. The
alternative is to provide <code>lower</code> and <code>upper</code> bounds, which
should also be variables in <code>sim$results</code>. In this case, the
confidence interval is (<code>lower</code>, <code>upper</code>). The coverage is the
proportion of simulation replicates for a given level combination in
which <code>truth</code> lies within the interval.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame containing the result of each specified summary function
as a column, for each of the simulation levels. The column <code>n_reps</code>
returns the number of successful simulation replicates within each level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=5)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim %&gt;% summarize(
  list(stat = "mean", name="mean_lambda_hat", x="lambda_hat"),
  list(stat = "mse", name="lambda_mse", estimate="lambda_hat", truth=5)
)
</code></pre>

<hr>
<h2 id='update_sim'>Update a simulation</h2><span id='topic+update_sim'></span>

<h3>Description</h3>

<p>This function updates a previously run simulation. After a
simulation has been <code><a href="#topic+run">run</a></code>, you can alter the levels of the
resulting object of class <code>sim_obj</code> using <code><a href="#topic+set_levels">set_levels</a></code>,
or change the configuration (including the number of simulation
replicates) using <code><a href="#topic+set_config">set_config</a></code>. Executing <code>update_sim</code> on
this simulation object will only run the added levels/replicates, without
repeating anything that has already been run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_sim(sim, keep_errors = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_sim_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code>, that has already been run by the <code><a href="#topic+run">run</a></code>
function</p>
</td></tr>
<tr><td><code id="update_sim_+3A_keep_errors">keep_errors</code></td>
<td>
<p>logical (<code>TRUE</code> by default); if <code>TRUE</code>, do not
try to re-run simulation reps that results in errors previously; if
<code>FALSE</code>, attempt to run those reps again</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p>It is not possible to add new level variables, only new levels of the
existing variables. Because of this, it is best practice to include all
potential level variables before initially running a simulation, even if
some of them only contain a single level. This way, additional levels can
be added later.
</p>
</li></ul>



<h3>Value</h3>

<p>The original simulation object with additional simulation replicates
in <code>results</code> or <code>errors</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean &lt;- function(dat, type) {
  if (type=="M") { return(mean(dat)) }
  if (type=="V") { return(var(dat)) }
}
sim %&lt;&gt;% set_levels(n=c(10,100), est="M")
sim %&lt;&gt;% set_config(num_sim=10)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- est_mean(dat=dat, type=L$est)
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim %&gt;% summarize(list(stat="mean", x="lambda_hat"))
sim %&lt;&gt;% set_levels(n=c(10,100,1000), est=c("M","V"))
sim %&lt;&gt;% set_config(num_sim=5)
sim %&lt;&gt;% update_sim()
sim %&gt;% summarize(list(stat="mean", x="lambda_hat"))
</code></pre>

<hr>
<h2 id='update_sim_on_cluster'>Framework for updating simulations on a cluster computing system</h2><span id='topic+update_sim_on_cluster'></span>

<h3>Description</h3>

<p>This function allows for simulations to be updated in parallel
on a cluster computing system (CCS). See the <a href="https://avi-kenny.github.io/SimEngine/articles/parallelization.html">Parallelization</a>
vignette for a detailed overview of how CCS parallelization works in
<span class="pkg">SimEngine</span>. Like <code><a href="#topic+run_on_cluster">run_on_cluster</a></code>, the
<code>update_sim_on_cluster</code> function acts as a wrapper for the code in
your simulation, organizing the code into three sections, labeled &quot;first&quot;
(code that is run once at the start of the simulation), &quot;main&quot; (running
the simulation script repeatedly), and &quot;last&quot; (code to process or
summarize simulation results). This function is to be used in conjunction
with job scheduler software (e.g., Slurm or Oracle Grid Engine) to divide
the simulation into tasks that are run in parallel on the CCS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_sim_on_cluster(first, main, last, cluster_config, keep_errors = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_sim_on_cluster_+3A_first">first</code></td>
<td>
<p>Code to run at the start of a simulation. This should be a block
of code enclosed by curly braces  that reads in a previously-run
simulation object via <code>readRDS</code> and makes changes to it via
<code><a href="#topic+set_levels">set_levels</a></code> or <code><a href="#topic+set_config">set_config</a></code>.</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_main">main</code></td>
<td>
<p>Code that will run for every simulation replicate. This should be
a block of code enclosed by curly braces , and will typically be a
single line of code calling the <code><a href="#topic+update_sim">update_sim</a></code>) function. This
code block will have access to the simulation object you created in the
'first' code block, but any changes made here to the simulation object
will not be saved.</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_last">last</code></td>
<td>
<p>Code that will run after all simulation replicates have been run.
This should be a block of code enclosed by curly braces  that processes
your simulation object (which at this point will contain your updated
results), which may involve calls to <code><a href="#topic+summarize">summarize</a></code>, creation of
plots, and so on.</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_cluster_config">cluster_config</code></td>
<td>
<p>A list of configuration options. You must specify
either <code>js</code> (the job scheduler you are using) or <code>tid_var</code> (the
name of the environment variable that your task ID is stored in); see
examples. Run <code>js_support()</code> to see a list of job schedulers that
are currently supported. You can optionally also specify <code>dir</code>,
which is a character string representing a path to a directory on the
CCS; this directory will serve as your working directory and hold your
simulation object and all temporary objects created by <span class="pkg">SimEngine</span>.
If unspecified, this defaults to the working directory of the R script
that contains your simulation code).</p>
</td></tr>
<tr><td><code id="update_sim_on_cluster_+3A_keep_errors">keep_errors</code></td>
<td>
<p>logical (<code>TRUE</code> by default); if <code>TRUE</code>, do not
try to re-run simulation reps that results in errors previously; if
<code>FALSE</code>, attempt to run those reps again</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The following code is saved in a file called my_simulation.R:
library(SimEngine)
update_sim_on_cluster(
  first = {
    sim &lt;- readRDS("sim.rds")
    sim %&lt;&gt;% set_levels(n=c(100,500,1000))
  },
  main = {
    sim %&lt;&gt;% update_sim()
  },
  last = {
    sim %&gt;% summarize()
  },
  cluster_config = list(js="slurm")
)

# The following code is saved in a file called run_sim.sh:
# #!/bin/bash
# Rscript my_simulation.R

# The following lines of code are run on the CCS head node:
# sbatch --export=sim_run='first' run_sim.sh
# sbatch --export=sim_run='main' --array=1-20 --depend=afterok:101 run_sim.sh
# sbatch --export=sim_run='last' --depend=afterok:102 run_sim.sh

## End(Not run)
</code></pre>

<hr>
<h2 id='use_method'>Use a method</h2><span id='topic+use_method'></span>

<h3>Description</h3>

<p>This function calls the specified method, passing along any
arguments that have been specified in <code>args</code>. It will typically be
used in conjunction with the special object L to dynamically run methods
that have been included as simulation levels. This function is a wrapper
around do.call and is used in a similar manner. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_method(method, args = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="use_method_+3A_method">method</code></td>
<td>
<p>A character string naming a function that has been declared or
loaded via <code>source</code>.</p>
</td></tr>
<tr><td><code id="use_method_+3A_args">args</code></td>
<td>
<p>A list of arguments to be passed onto <code>method</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the call to <code>method</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following is a toy example of a simulation, illustrating the use of
# the use_method function.
sim &lt;- new_sim()
create_data &lt;- function(n) { rpois(n, lambda=5) }
est_mean_1 &lt;- function(dat) { mean(dat) }
est_mean_2 &lt;- function(dat) { var(dat) }
sim %&lt;&gt;% set_levels(
  "n" = c(10, 100, 1000),
  "estimator" = c("est_mean_1", "est_mean_2")
)
sim %&lt;&gt;% set_config(num_sim=1)
sim %&lt;&gt;% set_script(function() {
  dat &lt;- create_data(L$n)
  lambda_hat &lt;- use_method(L$estimator, list(dat))
  return (list("lambda_hat"=lambda_hat))
})
sim %&lt;&gt;% run()
sim$results
</code></pre>

<hr>
<h2 id='vars'>Access internal simulation variables</h2><span id='topic+vars'></span>

<h3>Description</h3>

<p>This is a &quot;getter function&quot; that returns the value of an
internal simulation variable. Do not change any of these variables
manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(sim, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vars_+3A_sim">sim</code></td>
<td>
<p>A simulation object of class <code>sim_obj</code>, usually created by
<code><a href="#topic+new_sim">new_sim</a></code></p>
</td></tr>
<tr><td><code id="vars_+3A_var">var</code></td>
<td>
<p>If this argument is omitted, <code>vars</code> will return a list
containing all available internal variables. If this argument is
provided, it should equal one of the following character strings:
</p>

<ul>
<li><p><code>seed</code>: the simulation seed; see <code><a href="#topic+set_config">set_config</a></code> for
more info on seeds.
</p>
</li>
<li><p><code>env</code>: a reference to the environment in which individual
simulation replicates are run (advanced)
</p>
</li>
<li><p><code>num_sim_total</code>: The total number of simulation replicates
for the simulation. This is particularly useful when a simulation is
being run in parallel on a cluster computing system as a job array and
the user needs to know the range of task IDs.
</p>
</li>
<li><p><code>run_state</code>: A character string describing the &quot;run state&quot; of
the simulation. This will equal one of the following: &quot;pre run&quot; (the
simulation has not yet been run), &quot;run, no errors&quot; (the simulation ran
and had no errors), &quot;run, some errors&quot; (the simulation ran and had some
errors), &quot;run, all errors&quot; (the simulation ran and all replicates had
errors).
</p>
</li>
<li><p><code>session_info</code>: The results of a call to utils::sessionInfo()
that occures when <a href="#topic+new_sim">new_sim</a> is called.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the internal variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim &lt;- new_sim()
sim %&lt;&gt;% set_levels(n = c(10, 100, 1000))
sim %&lt;&gt;% set_config(num_sim=10)
print(vars(sim, "seed"))
print(vars(sim, "env"))
print(vars(sim, "num_sim_total"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
