<!DOCTYPE html><html lang="en"><head><title>Help for package mvdalab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvdalab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvdalab-package'>
<p>Multivariate Data Analysis Laboratory (mvdalab)</p></a></li>
<li><a href='#acfplot'><p>Plot of Auto-correlation Funcion</p></a></li>
<li><a href='#ap.plot'><p>Actual versus Predicted Plot and Residuals versus Predicted</p></a></li>
<li><a href='#bca.cis'><p>Bias-corrected and Accelerated Confidence Intervals</p></a></li>
<li><a href='#bidiagpls.fit'><p>Bidiag2 PLS</p></a></li>
<li><a href='#BiPlot'><p>Generates a biplot from the output of an 'mvdareg' and 'mvdapca' object</p></a></li>
<li><a href='#boot.plots'><p>Plots of the Output of a Bootstrap Simulation for an <code>mvdareg</code> Object</p></a></li>
<li><a href='#coef.mvdareg'><p>Extract Information From a plsFit Model</p></a></li>
<li><a href='#coefficients.boots'><p>BCa Summaries for the coefficient of an mvdareg object</p></a></li>
<li><a href='#coefficients.mvdareg'><p>Extract Summary Information Pertaining to the Coefficients resulting from a PLS model</p></a></li>
<li><a href='#coefficientsplot2D'><p>2-Dimensionsl Graphical Summary Information Pertaining to the Coefficients of a PLS</p></a></li>
<li><a href='#coefsplot'><p>Graphical Summary Information Pertaining to the Regression Coefficients</p></a></li>
<li><a href='#College'>
<p>Data for College Level Examination Program and the College Qualification Test</p></a></li>
<li><a href='#contr.niets'><p>Cell Means Contrast Matrix</p></a></li>
<li><a href='#ellipse.mvdalab'><p>Ellipses, Data Ellipses, and Confidence Ellipses</p></a></li>
<li><a href='#imputeBasic'><p>Naive imputation of missing values.</p></a></li>
<li><a href='#imputeEM'><p>Expectation Maximization (EM) for imputation of missing values.</p></a></li>
<li><a href='#imputeQs'><p>Quartile Naive Imputation of Missing Values</p></a></li>
<li><a href='#imputeRough'><p>Naive Imputation of Missing Values for Dummy Variable Model Matrix</p></a></li>
<li><a href='#introNAs'><p>Introduce NA's into a Dataframe</p></a></li>
<li><a href='#jk.after.boot'><p>Jackknife After Bootstrap</p></a></li>
<li><a href='#loadings'><p>Summary Information Pertaining to the Bootstrapped Loadings</p></a></li>
<li><a href='#loadings.boots'><p>BCa Summaries for the loadings of an mvdareg object</p></a></li>
<li><a href='#loadingsplot'><p>Graphical Summary Information Pertaining to the Loadings</p></a></li>
<li><a href='#loadingsplot2D'><p>2-Dimensionsl Graphical Summary Information Pertaining to the Loadings of a PLS or PCA Analysis</p></a></li>
<li><a href='#mewma'><p>Generates a Hotelling's T2 Graph of the Multivariate Exponentially Weighted Average</p></a></li>
<li><a href='#model.matrix'><p><code>model.matrix</code> creates a design (or model) matrix.</p></a></li>
<li><a href='#MultCapability'>
<p>Principal Component Based Multivariate Process Capability Indices</p></a></li>
<li><a href='#MVcis'>
<p>Calculate Hotelling's T2 Confidence Intervals</p></a></li>
<li><a href='#MVComp'>
<p>Traditional Multivariate Mean Vector Comparison</p></a></li>
<li><a href='#mvdaboot'><p>Bootstrapping routine for <code>mvdareg</code> objects</p></a></li>
<li><a href='#mvdaloo'><p>Leave-one-out routine for <code>mvdareg</code> objects</p></a></li>
<li><a href='#mvrnorm.svd'><p>Simulate from a Multivariate Normal, Poisson, Exponential, or Skewed Distribution</p></a></li>
<li><a href='#my.dummy.df'><p>Create a Design Matrix with the Desired Constrasts</p></a></li>
<li><a href='#no.intercept'><p>Delete Intercept from Model Matrix</p></a></li>
<li><a href='#pca.nipals'><p>PCA with the NIPALS algorithm</p></a></li>
<li><a href='#pcaFit'><p>Principal Component Analysis</p></a></li>
<li><a href='#PE'><p>Percent Explained Variation of X</p></a></li>
<li><a href='#Penta'>
<p>Penta data set</p></a></li>
<li><a href='#perc.cis'><p>Percentile Bootstrap Confidence Intervals</p></a></li>
<li><a href='#plot.cp'><p>Plotting Function for Score Contributions.</p></a></li>
<li><a href='#plot.mvcomp'>
<p>Plot of Multivariate Mean Vector Comparison</p></a></li>
<li><a href='#plot.mvdareg'><p>General plotting function for <code>mvdareg</code> and <code>mvdapaca</code> objects.</p></a></li>
<li><a href='#plot.plusminus'><p>2D Graph of the PCA scores associated with a plusminusFit</p></a></li>
<li><a href='#plot.R2s'><p>Plot of R2</p></a></li>
<li><a href='#plot.smc'><p>Plotting function for Significant Multivariate Correlation</p></a></li>
<li><a href='#plot.sr'><p>Plotting function for Selectivity Ratio.</p></a></li>
<li><a href='#plot.wrtpls'><p>Plots of the Output of a Permutation Distribution for an <code>mvdareg</code> Object with <code>method = "bidiagpls"</code></p></a></li>
<li><a href='#plsFit'><p>Partial Least Squares Regression</p></a></li>
<li><a href='#plusminus.fit'><p>PlusMinus (Mas-o-Menos)</p></a></li>
<li><a href='#plusminus.loo'><p>Leave-one-out routine for <code>plusminus</code> objects</p></a></li>
<li><a href='#plusMinusDat'>
<p>plusMinusDat data set</p></a></li>
<li><a href='#plusminusFit'><p>Plus-Minus (Mas-o-Menos) Classifier</p></a></li>
<li><a href='#predict.mvdareg'><p>Model Predictions From a plsFit Model</p></a></li>
<li><a href='#print.mvdalab'><p>Print Methods for mvdalab Objects</p></a></li>
<li><a href='#print.plusminus'><p>Print Methods for plusminus Objects</p></a></li>
<li><a href='#proCrustes'><p>Comparison of n-point Configurations vis Procrustes Analysis</p></a></li>
<li><a href='#R2s'><p>Cross-validated R2, R2 for X, and R2 for Y for PLS models</p></a></li>
<li><a href='#ScoreContrib'><p>Generates a score contribution plot</p></a></li>
<li><a href='#scoresplot'><p>2D Graph of the scores</p></a></li>
<li><a href='#SeqimputeEM'><p>Sequential Expectation Maximization (EM) for imputation of missing values.</p></a></li>
<li><a href='#smc'><p>Significant Multivariate Correlation</p></a></li>
<li><a href='#smc.acfTest'><p>Test of the Residual Significant Multivariate Correlation Matrix for the presence of Autocorrelation</p></a></li>
<li><a href='#sr'><p>Selectivity Ratio</p></a></li>
<li><a href='#T2'><p>Generates a Hotelling's T2 Graph</p></a></li>
<li><a href='#Wang_Chen'>
<p>Bivariate process data.</p></a></li>
<li><a href='#Wang_Chen_Sim'>
<p>Simulated process data from a plastics manufacturer.</p></a></li>
<li><a href='#weight.boots'><p>BCa Summaries for the weights of an mvdareg object</p></a></li>
<li><a href='#weights'><p>Extract Summary Information Pertaining to the Bootstrapped weights</p></a></li>
<li><a href='#weightsplot'><p>Extract Graphical Summary Information Pertaining to the Weights</p></a></li>
<li><a href='#weightsplot2D'><p>Extract a 2-Dimensional Graphical Summary Information Pertaining to the weights of a PLS Analysis</p></a></li>
<li><a href='#wrtpls.fit'><p>Weight Randomization Test PLS</p></a></li>
<li><a href='#Xresids'><p>Generates a Graph of the X-residuals</p></a></li>
<li><a href='#XresidualContrib'><p>Generates the squared prediction error contributions and contribution plot</p></a></li>
<li><a href='#y.loadings'><p>Extract Summary Information Pertaining to the y-loadings</p></a></li>
<li><a href='#y.loadings.boots'><p>Extract Summary Information Pertaining to the y-loadings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multivariate Data Analysis Laboratory</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-05</td>
</tr>
<tr>
<td>Author:</td>
<td>Nelson Lee Afanador, Thanh Tran, Lionel Blanchet, and Richard Baumgartner</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nelson Lee Afanador &lt;nelson.afanador@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An open-source implementation of latent variable methods and multivariate modeling tools. The focus is on exploratory analyses using dimensionality reduction methods including low dimensional embedding, classical multivariate statistical tools, and tools for enhanced interpretation of machine learning methods (i.e. intelligible models to provide important information for end-users).   Target domains include extension to dedicated applications e.g. for manufacturing process modeling, spectroscopic analyses, and data mining.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>car, ggplot2, MASS, moments, parallel, penalized, plyr,
reshape2, sn</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-05 17:16:49 UTC; Nelson</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-05 23:00:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvdalab-package'>
Multivariate Data Analysis Laboratory (mvdalab)
</h2><span id='topic+mvdalab-package'></span><span id='topic+mvdalab'></span>

<h3>Description</h3>

<p>Implementation of latent variables methods. The focus is on explorative anlaysis
using dimensionality reduction methods, such as Principal Component Analysis (PCA),
and on multivariate regression based on Partial Least Squares regression (PLS).
PLS analyses are supported by embedded bootstrapping and variable selection procedures.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mvdalab</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-08-10</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@gmail.com">nelson.afanador@gmail.com</a>), Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>), Lionel Blanchet (<a href="mailto:lionel.blanchet@mvdalab.com">lionel.blanchet@mvdalab.com</a>), Richard Baumgartner (<a href="mailto:richard_baumgartner@merck.com">richard_baumgartner@merck.com</a>)
</p>
<p>Maintainer: Nelson Lee Afanador (<a href="mailto:nelson.afanador@gmail.com">nelson.afanador@gmail.com</a>)
</p>

<hr>
<h2 id='acfplot'>Plot of Auto-correlation Funcion</h2><span id='topic+acfplot'></span>

<h3>Description</h3>

<p>This function computes the autocorrelation function estimates for a selected parameter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfplot(object, parm = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfplot_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code>, i.e., <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="acfplot_+3A_parm">parm</code></td>
<td>
<p> a chosen predictor variable; if <code>NULL</code> a random predictor variable is chosen</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the autocorrelation function estimates for a selected parameter, via <code>acf</code>, and generates a graph that allows the analyst to assess the need for an autocorrelation adjustment in the <code><a href="#topic+smc">smc</a></code>.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>This function is built using the <code>acf</code> function in the <span class="pkg">stats</span> R package.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) Modern Applied Statistics with S. Fourth Edition. Springer-Verlag.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smc">smc</a></code>, <code><a href="#topic+smc.acfTest">smc.acfTest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
acfplot(mod1, parm = NULL)
</code></pre>

<hr>
<h2 id='ap.plot'>Actual versus Predicted Plot and Residuals versus Predicted</h2><span id='topic+ap.plot'></span>

<h3>Description</h3>

<p>This function provides the actual versus predicted and actual versus residuals plot as part of a model assessment</p>


<h3>Usage</h3>

<pre><code class='language-R'>ap.plot(object, ncomp = object$ncomp, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ap.plot_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code>, i.e., <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="ap.plot_+3A_ncomp">ncomp</code></td>
<td>
<p> number of components used in the model assessment </p>
</td></tr>
<tr><td><code id="ap.plot_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides the actual versus predicted and residuals versus predicted plot as part of model a assessment across the desired number of latent variables.  A smooth fit (dashed line) is added in order to detect curvature in the fit.
</p>


<h3>Value</h3>

<p>The output of <code>ap.plot</code> is a two facet graph for actual versus predicted and residuals versus predicted plots.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsFit">plsFit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
ap.plot(mod1, ncomp = 2)
</code></pre>

<hr>
<h2 id='bca.cis'>Bias-corrected and Accelerated Confidence Intervals</h2><span id='topic+bca.cis'></span>

<h3>Description</h3>

<p>Computes bootstrap BCa confidence intervals for chosen parameters for PLS models fitted with <code>validation = "oob"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bca.cis(object, conf = .95, type = c("coefficients",
        "loadings", "weights"))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bca.cis_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mvdareg"</code>, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="bca.cis_+3A_conf">conf</code></td>
<td>
<p> desired confidence level </p>
</td></tr>
<tr><td><code id="bca.cis_+3A_type">type</code></td>
<td>
<p> input parameter vector  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the bootstrap BCa confidence intervals for any fitted <code>mvdareg</code> model.
Should be used in instances in which there is reason to suspectd the percentile intervals.  Results provided across all latent variables (LVs).  As such, it may be slow for models with a large number of LVs.
</p>


<h3>Value</h3>

<p>A bca.cis object contains component results for the following:
</p>
<table role = "presentation">
<tr><td><code>ncomp</code></td>
<td>
<p> number of components in the model </p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p> variable names </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap </p>
</td></tr>
<tr><td><code>BCa percentiles</code></td>
<td>
<p> confidence intervals </p>
</td></tr>
<tr><td><code>proportional bias</code></td>
<td>
<p> calculated bias </p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> skewness of the bootstrap distribution </p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p> acceleration contstant </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>There are many references explaining the bootstrap and its implementation for confidence interval estimation. Among them are:
</p>
<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. and Tibshirani, R. (1993) An Introduction to the Bootstrap. Chapman &amp; Hall.
</p>
<p>Hinkley, D.V. (1988) Bootstrap methods (with Discussion). Journal of the Royal Statistical Society, B, 50, 312:337, 355:370.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsFit">plsFit</a></code>, <code><a href="#topic+mvdaboot">mvdaboot</a></code>, <code><a href="#topic+boot.plots">boot.plots</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 250 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 250)
bca.cis(mod1, conf = .95, type = "coefficients")
## Not run: 
bca.cis(mod1, conf = .95, type = "loadings")
bca.cis(mod1, conf = .95, type = "weights")

## End(Not run)
</code></pre>

<hr>
<h2 id='bidiagpls.fit'>Bidiag2 PLS</h2><span id='topic+bidiagpls.fit'></span>

<h3>Description</h3>

<p>Bidiagonalization algorithm for PLS1</p>


<h3>Usage</h3>

<pre><code class='language-R'>bidiagpls.fit(X, Y, ncomp, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bidiagpls.fit_+3A_x">X</code></td>
<td>
<p> a matrix of observations. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="bidiagpls.fit_+3A_y">Y</code></td>
<td>
<p> a vector. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="bidiagpls.fit_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="bidiagpls.fit_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly, but through <code>plsFit</code> with the argument <code>method="bidiagpls"</code>. It implements the Bidiag2 scores algorithm.  
</p>


<h3>Value</h3>

<p>An object of class <code>mvdareg</code> is returned. The object contains all components returned by the underlying fit function. In addition, it contains the following:
</p>
<table role = "presentation">
<tr><td><code>loadings</code></td>
<td>
<p> X loadings </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> weights </p>
</td></tr>
<tr><td><code>D2</code></td>
<td>
<p> bidiag2 matrix </p>
</td></tr>
<tr><td><code>iD2</code></td>
<td>
<p> inverse of bidiag2 matrix </p>
</td></tr>
<tr><td><code>Ymean</code></td>
<td>
<p> mean of reponse variable </p>
</td></tr>
<tr><td><code>Xmeans</code></td>
<td>
<p> mean of predictor variables </p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> regression coefficients </p>
</td></tr>
<tr><td><code>y.loadings</code></td>
<td>
<p> y-loadings </p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p> X scores </p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p> orthogonal weights </p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p> scaled response values </p>
</td></tr>
<tr><td><code>Yactual</code></td>
<td>
<p> actual response values </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> fitted values </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> residuals </p>
</td></tr>
<tr><td><code>Xdata</code></td>
<td>
<p> X matrix </p>
</td></tr>
<tr><td><code>iPreds</code></td>
<td>
<p> predicted values </p>
</td></tr>
<tr><td><code>y.loadings2</code></td>
<td>
<p> scaled y-loadings </p>
</td></tr>
<tr><td><code>fit.time</code></td>
<td>
<p> model fitting time </p>
</td></tr>
<tr><td><code>val.method</code></td>
<td>
<p> validation method </p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p> number of latent variables </p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p> contrast matrix used </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> PLS algorithm used </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p> scaling used </p>
</td></tr>
<tr><td><code>validation</code></td>
<td>
<p> validation method </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> model call </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> model terms </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> fitted model </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>), Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Indahl, Ulf G., (2014) The geometry of PLS1 explained properly: 10 key notes on mathematical properties of and some alternative algorithmic approaches to PLS1 modeling. Journal of Chemometrics, 28, 168:180.
</p>
<p>Manne R., Analysis of two partial-least-squares algorithms for multi-variate calibration. Chemom. Intell. Lab. Syst. 1987; 2: 187:197.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsFit">plsFit</a></code></p>

<hr>
<h2 id='BiPlot'>Generates a biplot from the output of an 'mvdareg' and 'mvdapca' object</h2><span id='topic+BiPlot'></span>

<h3>Description</h3>

<p>Generates a 2D Graph of both the scores and loadings for both <code>"mvdareg"</code> and <code>"mvdapca"</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiPlot(object, diag.adj = c(0, 0), axis.scaling = 2,
                          cov.scale = FALSE, comps = c(1, 2), 
                          col = "red", verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BiPlot_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mvdareg"</code> or <code>"mvdapca"</code>. </p>
</td></tr>
<tr><td><code id="BiPlot_+3A_diag.adj">diag.adj</code></td>
<td>
<p> adjustment to singular values.  see details. </p>
</td></tr>
<tr><td><code id="BiPlot_+3A_axis.scaling">axis.scaling</code></td>
<td>
<p> a graphing parameter for extenting the axis. </p>
</td></tr>
<tr><td><code id="BiPlot_+3A_cov.scale">cov.scale</code></td>
<td>
<p>implement covariance scaling</p>
</td></tr>
<tr><td><code id="BiPlot_+3A_comps">comps</code></td>
<td>
<p>the components to illustrate on the graph</p>
</td></tr>
<tr><td><code id="BiPlot_+3A_col">col</code></td>
<td>
<p>the color applied to the scores</p>
</td></tr>
<tr><td><code id="BiPlot_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"BiPlot"</code> is used to extract a 2D graphical summary of the scores and loadings of PLS and PCA models.
</p>
<p>The singular values are scaled so that the approximation becomes X = GH':
</p>
<p>X = ULV' = (UL^alpha1)(L^alpha2V') = GH', and where alpha2 is = to (1 = alpha)
</p>
<p>The rows of the G matrix are plotted as points, corresponding to observations. The rows of the H matrix are plotted as vectors, corresponding to variables.  The choice of alpha determines the following:
</p>
<p>c(0, 0):  variables are scaled to unit length and treats observations and variables symmetrically.
</p>
<p>c(0, 1):  This biplot attempts to preserve relationships between variables wherein the distance betweein any two rows of G is proportional to the Mahalanobis distance between the same observations in the data set.
</p>
<p>c(1, 0):  This biplot attempts to preserve the distance between observations where in the positions of the points in the biplot are identical to the score plot of first two principal components, but the distance between any two rows of G is equal to the Euclidean distance between the corresponding observations in the data set.
</p>
<p><code>cov.scale = FALSE</code> sets diag.adj to c(0, 0) and multiples G by sqrt(n - 1) and divides H by sqrt(n - 1).  In this biplot the rows of H approximate the variance of the corresponding variable, and the distance between any two points of G approximates the Mahalanobis distance between any two rows.
</p>
<p>Additional scalings may be implemented.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>SAS Stat Studio 3.11 (2009), User's Guide.
</p>
<p>Additional information pertaining to biplots can be obtained from the following:
</p>
<p>Friendly, M. (1991), SAS System for Statistical Graphics , SAS Series in Statistical Applications, Cary, NC: SAS Institute
</p>
<p>Gabriel, K. R. (1971), &quot;The Biplot Graphical Display of Matrices with Applications to Principal Component Analysis,&quot; Biometrika , 58(3), 453&ndash;467.
</p>
<p>Golub, G. H. and Van Loan, C. F. (1989), Matrix Computations , Second Edition, Baltimore: Johns Hopkins University Press.
</p>
<p>Gower, J. C. and Hand, D. J. (1996), Biplots , London: Chapman &amp; Hall.
</p>
<p>Jackson, J. E. (1991), A User's Guide to Principal Components , New York: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
BiPlot(mod1, diag.adj = c(0, 0), axis.scaling = 2, cov.scale = FALSE)

## Not run: 
data(Penta)
mod2 &lt;- pcaFit(Penta[, -1], ncomp = 4)
BiPlot(mod2, diag.adj = c(0, 0), axis.scaling = 2.25, cov.scale = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='boot.plots'>Plots of the Output of a Bootstrap Simulation for an <code>mvdareg</code> Object</h2><span id='topic+boot.plots'></span>

<h3>Description</h3>

<p>This takes an <code>mvdareg</code> object fitted with <code>validation = "oob"</code> and produces a graph of the bootstrap distribution and its corresponding normal quantile plot for a  variable of interest.</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.plots(object, comp = object$ncomp, parm = NULL,
           type = c("coefs", "weights", "loadings"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.plots_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mvdareg"</code>, i.e., a <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="boot.plots_+3A_comp">comp</code></td>
<td>
<p> latent variable from which to generate the bootstrap distribution for a specific parameter </p>
</td></tr>
<tr><td><code id="boot.plots_+3A_parm">parm</code></td>
<td>
<p> a parameter for which to generate the bootstrap distribution </p>
</td></tr>
<tr><td><code id="boot.plots_+3A_type">type</code></td>
<td>
<p> input parameter vector  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the bootstrap distribution and normal quantile plot for a bootstrapped <code>mvdareg</code> model given <code>validation = "oob"</code> for <code>type = c("coefs", "weights", "loadings")</code>.  If <code>parm = NULL</code> a paramater is chosen at random.
</p>


<h3>Value</h3>

<p>The output of <code>boot.plots</code> is a histogram of the bootstrap distribution and the corresponding normal quantile plot.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+bca.cis">bca.cis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
boot.plots(mod1, type = "coefs", parm = NULL)
</code></pre>

<hr>
<h2 id='coef.mvdareg'>Extract Information From a plsFit Model</h2><span id='topic+coef.mvdareg'></span>

<h3>Description</h3>

<p>Functions to extract information from <code>mvdalab</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
coef(object, ncomp = object$ncomp, type = c("coefficients",
    "loadings", "weights", "y.loadings"), conf = .95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.mvdareg_+3A_object">object</code></td>
<td>
<p> an mvdareg object, i.e. a <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="coef.mvdareg_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="coef.mvdareg_+3A_type">type</code></td>
<td>
<p> specify model parameters to return. </p>
</td></tr>
<tr><td><code id="coef.mvdareg_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
<tr><td><code id="coef.mvdareg_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are usually called through their generic functions <code>coef</code> and <code>residuals</code>, respectively.
<code>coef.mvdareg</code> is used to extract the regression coefficients, loadings, or weights of a PLS model.
</p>
<p>If <code>comps</code> is missing (or is <code>NULL</code>), all parameter estimates are returned.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector, or matrix, of coefficients. </p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p> a named vector, or matrix, of loadings. </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> a named vector, or matrix, of weights. </p>
</td></tr>
<tr><td><code>y.loadings</code></td>
<td>
<p> a named vector, or matrix, of y.loadings. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+coefficients.boots">coefficients.boots</a></code>, <code><a href="stats.html#topic+coefficients">coefficients</a></code>,
<code><a href="stats.html#topic+loadings">loadings</a></code>, <code><a href="#topic+loadings.boots">loadings.boots</a></code>, <code><a href="stats.html#topic+weights">weights</a></code>,
<code><a href="#topic+weight.boots">weight.boots</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
coef(mod1, type = "coefficients")
</code></pre>

<hr>
<h2 id='coefficients.boots'>BCa Summaries for the coefficient of an mvdareg object</h2><span id='topic+coefficients.boots'></span>

<h3>Description</h3>

<p>Computes bootstrap BCa confidence intervals for regression coefficients, along with expanded bootstrap summaries.</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefficients.boots(object, ncomp = object$ncomp, conf = 0.95)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefficients.boots_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code>, i.e., a <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="coefficients.boots_+3A_ncomp">ncomp</code></td>
<td>
<p> number of components in the model  </p>
</td></tr>
<tr><td><code id="coefficients.boots_+3A_conf">conf</code></td>
<td>
<p> desired confidence level </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the bootstrap BCa confidence intervals for fitted <code>mvdareg</code> models where <code>valiation = "oob"</code>.
Should be used in instances in which there is reason to suspectd the percentile intervals.  Results provided across all latent variables or for specific latent variables via <code>ncomp</code>.
</p>


<h3>Value</h3>

<p>A coefficients.boots object contains component results for the following:
</p>
<table role = "presentation">
<tr><td><code>variable</code></td>
<td>
<p> variable names </p>
</td></tr>
<tr><td><code>actual</code></td>
<td>
<p> Actual loading estimate using all the data </p>
</td></tr>
<tr><td><code>BCa percentiles</code></td>
<td>
<p> confidence intervals </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap </p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> skewness of the bootstrap distribution </p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p> estimate of bias w.r.t. the loading estimate </p>
</td></tr>
<tr><td><code>Bootstrap Error</code></td>
<td>
<p> estimate of bootstrap standard error </p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p> approximate 't-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
<tr><td><code>bias t value</code></td>
<td>
<p> approximate 'bias t-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>There are many references explaining the bootstrap. Among them are:
</p>
<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. and Tibshirani, R. (1993) An Introduction to the Bootstrap. Chapman &amp; Hall.
</p>
<p>Hinkley, D.V. (1988) Bootstrap methods (with Discussion). Journal of the Royal Statistical Society, B, 50, 312:337, 355:370.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+coefficients">coefficients</a></code>,
<code><a href="#topic+coefsplot">coefsplot</a></code>, <code><a href="stats.html#topic+coefficients">coefficients</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
coefficients.boots(mod1, ncomp = 2, conf = .95)
</code></pre>

<hr>
<h2 id='coefficients.mvdareg'>Extract Summary Information Pertaining to the Coefficients resulting from a PLS model</h2><span id='topic+coefficients.mvdareg'></span>

<h3>Description</h3>

<p>Functions to extract regression coefficient bootstrap information from mvdalab objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
coefficients(object, ncomp = object$ncomp, conf = .95, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefficients.mvdareg_+3A_object">object</code></td>
<td>
<p> an mvdareg object.  A fitted model. </p>
</td></tr>
<tr><td><code id="coefficients.mvdareg_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="coefficients.mvdareg_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
<tr><td><code id="coefficients.mvdareg_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coefficients</code> is used to extract a bootstrap summary of the regression of a PLS model.
</p>
<p>If <code>comps</code> is missing (or is NULL), summaries for all regression estimates are returned.  Otherwise, if comps is given parameters for a model with only the requested component comps is returned.
</p>
<p>Boostrap summaries provided are for actual regression coefficients, bootstrap percentiles, bootstrap mean, skewness, and bias.  These summaries can also be extracted using <code>coefficients.boots</code>
</p>


<h3>Value</h3>

<p>A coefficients object contains a data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>variable</code></td>
<td>
<p> variable names </p>
</td></tr>
<tr><td><code>Actual</code></td>
<td>
<p> Actual loading estimate using all the data </p>
</td></tr>
<tr><td><code>BCa percentiles</code></td>
<td>
<p> confidence intervals </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap </p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> skewness of the bootstrap distribution </p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p> estimate of bias w.r.t. the loading estimate </p>
</td></tr>
<tr><td><code>Bootstrap Error</code></td>
<td>
<p> estimate of bootstrap standard error </p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p> approximate 't-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
<tr><td><code>bias t value</code></td>
<td>
<p> approximate 'bias t-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+coefficients.boots">coefficients.boots</a></code>, <code><a href="stats.html#topic+coefficients">coefficients</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
coefficients(mod1)
</code></pre>

<hr>
<h2 id='coefficientsplot2D'>2-Dimensionsl Graphical Summary Information Pertaining to the Coefficients of a PLS</h2><span id='topic+coefficientsplot2D'></span>

<h3>Description</h3>

<p>Functions to extract 2D graphical coefficients information from <code>mvdalab</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefficientsplot2D(object, comps = c(1, 2), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefficientsplot2D_+3A_object">object</code></td>
<td>
<p> an <code>mvdareg</code> object. </p>
</td></tr>
<tr><td><code id="coefficientsplot2D_+3A_comps">comps</code></td>
<td>
<p> a vector of length 2 corresponding to the number of components to include.</p>
</td></tr>
<tr><td><code id="coefficientsplot2D_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coefficientsplot2D</code> is used to extract a graphical summary of the coefficients of a PLS model.
If <code>comp</code> is <code>missing</code> (or is <code>NULL</code>), a graphical summary for the 1st and 2nd components is returned.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadingsplot2D">loadingsplot2D</a></code>, <code><a href="#topic+weightsplot2D">weightsplot2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
coefficientsplot2D(mod1, comp = c(1, 2))
</code></pre>

<hr>
<h2 id='coefsplot'>Graphical Summary Information Pertaining to the Regression Coefficients</h2><span id='topic+coefsplot'></span>

<h3>Description</h3>

<p>Functions to extract regression coefficient bootstrap information from mvdalab objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>coefsplot(object, ncomp = object$ncomp, conf = 0.95, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefsplot_+3A_object">object</code></td>
<td>
<p> an mvdareg object.  A fitted model. </p>
</td></tr>
<tr><td><code id="coefsplot_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include. </p>
</td></tr>
<tr><td><code id="coefsplot_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
<tr><td><code id="coefsplot_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coefficients</code> is used to extract a graphical summary of the regression coefficients of a PLS model.
</p>
<p>If <code>comps</code> is <code>missing</code> (or is <code>NULL</code>), a graphical summary for the nth component regression estimates are returned.  Otherwise, if <code>comps</code> is given parameters for a model with only the requested component <code>comps</code> is returned.
</p>
<p>Bootstrap graphcal summaries provided are when <code>method = oob</code>.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
coefsplot(mod1, ncomp = 1:2)
</code></pre>

<hr>
<h2 id='College'>
Data for College Level Examination Program and the College Qualification Test
</h2><span id='topic+College'></span>

<h3>Description</h3>

<p>Scores obtained from 87 college students on the College Level Examination Program and the College Qualification Test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>College</code></pre>


<h3>Format</h3>

<p>A data frame with 87 observations and the following 3 variables.
</p>

<dl>
<dt><code>Science</code></dt><dd><p>Science (CQT) - numerical vector</p>
</dd>
<dt><code>Social</code></dt><dd><p>Social science and history (CLEP) - numerical vector</p>
</dd>
<dt><code>Verbal</code></dt><dd><p>Verbal (CQT) - numerical vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Johnson, R.A., Wichern, D.W. (2002) Applied Multivariate Statistical Analysis. Prentice Hall.
</p>

<hr>
<h2 id='contr.niets'>Cell Means Contrast Matrix </h2><span id='topic+contr.niets'></span>

<h3>Description</h3>

<p>This function generates a cell means contrast matrix to support PLS models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.niets(n, contrasts)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contr.niets_+3A_n">n</code></td>
<td>
<p> A vector of levels for a factor, or the number of levels. </p>
</td></tr>
<tr><td><code id="contr.niets_+3A_contrasts">contrasts</code></td>
<td>
<p> a logical indicating whether contrasts should be computed; set to <code>FALSE</code> 
in order to generate required contrast matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses <code>contr.treatment</code> to generate a cell means contrast matrix in support of PLS models. 
</p>


<h3>Value</h3>

<p>For datasets with categorical variables it produces the needed design matrix.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador</p>


<h3>Examples</h3>

<pre><code class='language-R'># Three levels
levels &lt;- LETTERS[1:3]
contr.niets(levels)

# Two levels
levels &lt;- LETTERS[1:2]
contr.niets(levels)
</code></pre>

<hr>
<h2 id='ellipse.mvdalab'>Ellipses, Data Ellipses, and Confidence Ellipses</h2><span id='topic+ellipse.mvdalab'></span>

<h3>Description</h3>

<p>This function draws econfidence ellipses for covariance and correlation matrices derived from from either a matrix or dataframe.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipse.mvdalab(data, center = c(0, 0), radius = "chi", scale = TRUE,
  segments = 51, level = c(0.95, 0.99), plot.points = FALSE, pch = 1, size = 1,
  alpha = 0.5, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipse.mvdalab_+3A_data">data</code></td>
<td>
<p> A dataframe </p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_center">center</code></td>
<td>
<p> 2-element vector with coordinates of center of ellipse. </p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_radius">radius</code></td>
<td>
<p> Use of the Chi or F Distributions for setting the radius of the confidence ellipse</p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_scale">scale</code></td>
<td>
<p>use correlation or covariance matrix</p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_segments">segments</code></td>
<td>
<p> number of line-segments used to draw ellipse. </p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_level">level</code></td>
<td>
<p> draw elliptical contours at these (normal) probability or confidence levels. </p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_pch">pch</code></td>
<td>
<p>symbols to use for scores</p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_size">size</code></td>
<td>
<p>size to use for scores</p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_alpha">alpha</code></td>
<td>
<p>transparency of scores</p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_plot.points">plot.points</code></td>
<td>
<p>Should the points be added to the graph. </p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_verbose">verbose</code></td>
<td>
<p>output results as a data frame</p>
</td></tr>
<tr><td><code id="ellipse.mvdalab_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ellipse</code> uses the singular value decomposition in order to generate the desired confidence regions. The default confidence ellipse is based on the chisquare statistic.
</p>


<h3>Value</h3>

<p>Returns a graph with the ellipses at the stated as levels, as well as the ellipse coordinates.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Fox, J. (2008) Applied Regression Analysis and Generalized Linear Models, Second Edition. Sage.
</p>
<p>Fox, J. and Weisberg, S. (2011) An R Companion to Applied Regression, Second Edition, Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
ellipse.mvdalab(iris[, 1:2], plot.points = FALSE)
ellipse.mvdalab(iris[, 1:2], center = colMeans(iris[, 1:2]), plot.points = TRUE)
</code></pre>

<hr>
<h2 id='imputeBasic'>Naive imputation of missing values.</h2><span id='topic+imputeBasic'></span>

<h3>Description</h3>

<p>Imputes the mean or median for continous variables; highest frequency for categorical variables.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeBasic(data, Init = "mean")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeBasic_+3A_data">data</code></td>
<td>
<p> a dataset with missing values </p>
</td></tr>
<tr><td><code id="imputeBasic_+3A_init">Init</code></td>
<td>
<p> For continous variables impute either the mean or median </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A completed data frame is returned. For numeric variables, <code>NAs</code> are replaced with column means or medians. For categorical variables, <code>NAs</code> are replaced with the most frequent levels. If object contains no <code>NAs</code>, it is returned unaltered.
</p>


<h3>Value</h3>

<p><code>imputeBasic</code> returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>Imputed.DataFrame</code></td>
<td>
<p> Final imputed data frame </p>
</td></tr>
<tr><td><code>Imputed.Missing.Continous</code></td>
<td>
<p> Imputed continous values </p>
</td></tr>
<tr><td><code>Imputed.Missing.Factors</code></td>
<td>
<p> Imputed categorical values </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- introNAs(iris, percent = 25)
imputeBasic(dat)
</code></pre>

<hr>
<h2 id='imputeEM'>Expectation Maximization (EM) for imputation of missing values.</h2><span id='topic+imputeEM'></span><span id='topic+print.empca'></span>

<h3>Description</h3>

<p>Missing values are iterarively updated via an EM algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeEM(data, impute.ncomps = 2, pca.ncomps = 2, CV = TRUE, Init = "mean",
         scale = TRUE, iters = 25, tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeEM_+3A_data">data</code></td>
<td>
<p> a dataset with missing values. </p>
</td></tr>
<tr><td><code id="imputeEM_+3A_impute.ncomps">impute.ncomps</code></td>
<td>
<p> integer corresponding to the minimum number of components to test. </p>
</td></tr>
<tr><td><code id="imputeEM_+3A_pca.ncomps">pca.ncomps</code></td>
<td>
<p>minimum number of components to use in the imputation.</p>
</td></tr>
<tr><td><code id="imputeEM_+3A_cv">CV</code></td>
<td>
<p> Use cross-validation in determining the optimal number of components to retain for the final imputation. </p>
</td></tr>
<tr><td><code id="imputeEM_+3A_init">Init</code></td>
<td>
<p> For continous variables impute either the mean or median. </p>
</td></tr>
<tr><td><code id="imputeEM_+3A_scale">scale</code></td>
<td>
<p> Scale variables to unit variance. </p>
</td></tr>
<tr><td><code id="imputeEM_+3A_iters">iters</code></td>
<td>
<p> For continous variables impute either the mean or median. </p>
</td></tr>
<tr><td><code id="imputeEM_+3A_tol">tol</code></td>
<td>
<p> the threshold for assessing convergence. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A completed data frame is returned that mirrors a <code>model.matrix</code>. <code>NAs</code> are replaced with convergence values as obtained via EM. If object contains no <code>NAs</code>, it is returned unaltered.  
</p>


<h3>Value</h3>

<p><code>imputeEM</code> returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>Imputed.DataFrames</code></td>
<td>
<p> A list of imputed data frames across <code>impute.comps</code> </p>
</td></tr>
<tr><td><code>Imputed.Continous</code></td>
<td>
<p> A list of imputed values, at each EM iteration, across <code>impute.comps</code> </p>
</td></tr>
<tr><td><code>CV.Results</code></td>
<td>
<p> Cross-validation results across <code>impute.comps</code> </p>
</td></tr>
<tr><td><code>ncomps</code></td>
<td>
 <p><code>impute.comps</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>), Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>)</p>


<h3>References</h3>

<p>B. Walczak, D.L. Massart. Dealing with missing data, Part I. Chemom. Intell. Lab. Syst. 58 (2001); 15:27
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- introNAs(iris, percent = 25)
imputeEM(dat)
</code></pre>

<hr>
<h2 id='imputeQs'>Quartile Naive Imputation of Missing Values </h2><span id='topic+imputeQs'></span>

<h3>Description</h3>

<p>Missing value imputed as 'Missing'.</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeQs(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeQs_+3A_data">data</code></td>
<td>
<p> a dataset with missing values </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A completed data frame is returned.  For continous variables with missing values, missing values are replaced with 'Missing', while the non-missing values are replaced with their corresponding quartile assignment.  For categorical variable with missing values, missing values are replaced with 'Missing'.  This procedure can greatly increases the dimensionality of the data.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- introNAs(iris, percent = 25)
imputeQs(dat)
</code></pre>

<hr>
<h2 id='imputeRough'>Naive Imputation of Missing Values for Dummy Variable Model Matrix</h2><span id='topic+imputeRough'></span><span id='topic+print.roughImputation'></span>

<h3>Description</h3>

<p>After generating a cell means model matrix, impute expected values (mean or median for continous; hightest frequency for categorical).</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeRough(data, Init = "mean")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imputeRough_+3A_data">data</code></td>
<td>
<p> a dataset with missing values </p>
</td></tr>
<tr><td><code id="imputeRough_+3A_init">Init</code></td>
<td>
<p> For continous variables impute either the mean or median </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A completed data frame is returned that mirrors a <code>model.matrix</code>. <code>NAs</code> are replaced with column means or medians. If object contains no <code>NAs</code>, it is returned unaltered.  This is the starting point for imputeEM.
</p>


<h3>Value</h3>

<p><code>imputeRough</code> returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>Initials</code></td>
<td>
<p> Imputed values </p>
</td></tr>
<tr><td><code>Pre.Imputed</code></td>
<td>
<p> Pre-imputed data frame </p>
</td></tr>
<tr><td><code>Imputed.Dataframe</code></td>
<td>
<p> Imputed data frame </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- introNAs(iris, percent = 25)
imputeRough(dat)
</code></pre>

<hr>
<h2 id='introNAs'>Introduce NA's into a Dataframe</h2><span id='topic+introNAs'></span>

<h3>Description</h3>

<p>Function for testing missing value imputation algorithms</p>


<h3>Usage</h3>

<pre><code class='language-R'>introNAs(data, percent = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="introNAs_+3A_data">data</code></td>
<td>
<p> a dataset without missing values. </p>
</td></tr>
<tr><td><code id="introNAs_+3A_percent">percent</code></td>
<td>
<p> the percent data that should be randomly assigned as missing </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A completed data frame is returned with the desired percentage of missing data.  <code>NAs</code> are assigned at random.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- introNAs(iris)
dat
</code></pre>

<hr>
<h2 id='jk.after.boot'>Jackknife After Bootstrap</h2><span id='topic+jk.after.boot'></span>

<h3>Description</h3>

<p>This function calculates the jackknife influence values from a bootstrap output <code>mvdareg</code> object and plots the corresponding jackknife-after-bootstrap plot.</p>


<h3>Usage</h3>

<pre><code class='language-R'>jk.after.boot(object, ncomp = object$ncomp,
              type = c("coefficients", "loadings", "weights"),
              parm = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jk.after.boot_+3A_object">object</code></td>
<td>
<p> an mvdareg object.  A fitted model.  </p>
</td></tr>
<tr><td><code id="jk.after.boot_+3A_ncomp">ncomp</code></td>
<td>
<p> the component number to include in the jackknife-after-bootstrap plot assessment. </p>
</td></tr>
<tr><td><code id="jk.after.boot_+3A_type">type</code></td>
<td>
<p> input parameter vector.  </p>
</td></tr>
<tr><td><code id="jk.after.boot_+3A_parm">parm</code></td>
<td>
<p> predictor variable for which to perform the assessment.  if <code>NULL</code> one will be chosen at random.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The centred jackknife quantiles for each observation are estimated from those bootstrap samples in which a particular observation did not appear. These are then plotted against the influence values.
</p>
<p>The resulting plots are useful diagnostic tools for looking at the way individual observations affect the bootstrap output.
</p>
<p>The plot will consist of a number of horizontal dotted lines which correspond to the quantiles of the centred bootstrap distribution. For each data point the quantiles of the bootstrap distribution calculated by omitting that point are plotted against the jackknife values. The observation number is printed below the plots. To make it easier to see the effect of omitting points on quantiles, the plotted quantiles are joined by line segments. These plots provide a useful diagnostic tool in establishing the effect of individual observations on the bootstrap distribution. See the references below for some guidelines on the interpretation of the plots.
</p>


<h3>Value</h3>

<p>There is no returned value but a graph is generated on the current graphics display.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. (1992) Jackknife-after-bootstrap standard errors and influence functions (with Discussion). Journal of the Royal Statistical Society, B, 54, 83:127.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
jk.after.boot(mod1, type = "coefficients")
## Not run: 
jk.after.boot(mod1, type = "loadings")
jk.after.boot(mod1, type = "weights")

## End(Not run)
</code></pre>

<hr>
<h2 id='loadings'>Summary Information Pertaining to the Bootstrapped Loadings</h2><span id='topic+loadings.mvdareg'></span>

<h3>Description</h3>

<p>Functions to extract loadings bootstrap information from mvdalab objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
loadings(object, ncomp = object$ncomp, conf = .95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadings_+3A_object">object</code></td>
<td>
<p> an mvdareg or mvdapaca object.  A fitted model. </p>
</td></tr>
<tr><td><code id="loadings_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="loadings_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
<tr><td><code id="loadings_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>loadings</code> is used to extract a summary of the loadings of a PLS or PCA model.
If <code>ncomps</code> is missing (or is NULL), summaries for all loadings estimates are returned.  Otherwise, if comps is given parameters for a model with only the requested component comps is returned.
</p>
<p>Boostrap summaries are provided for <code>mvdareg</code> objects where <code>validation = "oob"</code>.  These summaries can also be extracted using <code>loadings.boots</code>
</p>


<h3>Value</h3>

<p>A loadings object contains a data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>variable</code></td>
<td>
<p> variable names </p>
</td></tr>
<tr><td><code>Actual</code></td>
<td>
<p> Actual loading estimate using all the data </p>
</td></tr>
<tr><td><code>BCa percentiles</code></td>
<td>
<p> confidence intervals </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap </p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> skewness of the bootstrap distribution </p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p> estimate of bias w.r.t. the loading estimate </p>
</td></tr>
<tr><td><code>Bootstrap Error</code></td>
<td>
<p> estimate of bootstrap standard error </p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p> approximate 't-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
<tr><td><code>bias t value</code></td>
<td>
<p> approximate 'bias t-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>There are many references explaining the bootstrap. Among them are:
</p>
<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. (1992) Jackknife-after-bootstrap standard errors and influence functions (with Discussion). Journal of the Royal Statistical Society, B, 54, 83:127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadingsplot">loadingsplot</a></code>, <code><a href="#topic+loadings.boots">loadings.boots</a></code>, <code><a href="#topic+loadingsplot2D">loadingsplot2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
loadings(mod1, ncomp = 2, conf = .95)

data(iris)
pc1 &lt;- pcaFit(iris)
loadings(pc1)
</code></pre>

<hr>
<h2 id='loadings.boots'>BCa Summaries for the loadings of an mvdareg object</h2><span id='topic+loadings.boots'></span>

<h3>Description</h3>

<p>Computes bootstrap BCa confidence intervals for the loadings, along with expanded bootstrap summaries.</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadings.boots(object, ncomp = object$ncomp, conf = .95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadings.boots_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mvdareg"</code>, i.e., a <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="loadings.boots_+3A_ncomp">ncomp</code></td>
<td>
<p> number of components in the model.  </p>
</td></tr>
<tr><td><code id="loadings.boots_+3A_conf">conf</code></td>
<td>
<p> desired confidence level. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the bootstrap BCa confidence intervals for fitted <code>mvdareg</code> models where <code>valiation = "oob"</code>.
Should be used in instances in which there is reason to suspectd the percentile intervals.  Results provided across all latent variables or for specific latent variables via <code>ncomp</code>.
</p>


<h3>Value</h3>

<p>A loadings.boots object contains component results for the following:
</p>
<table role = "presentation">
<tr><td><code>variable</code></td>
<td>
<p> variable names </p>
</td></tr>
<tr><td><code>actual</code></td>
<td>
<p> Actual loading estimate using all the data </p>
</td></tr>
<tr><td><code>BCa percentiles</code></td>
<td>
<p> confidence intervals </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap </p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> skewness of the bootstrap distribution </p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p> estimate of bias w.r.t. the loading estimate </p>
</td></tr>
<tr><td><code>Bootstrap Error</code></td>
<td>
<p> estimate of bootstrap standard error </p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p> approximate 't-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
<tr><td><code>bias t value</code></td>
<td>
<p> approximate 'bias t-value' based on the <code>Bootstrap Error</code> </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>There are many references explaining the bootstrap. Among them are:
</p>
<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. (1992) Jackknife-after-bootstrap standard errors and influence functions (with Discussion). Journal of the Royal Statistical Society, B, 54, 83:127.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
loadings.boots(mod1, ncomp = 2, conf = .95)
</code></pre>

<hr>
<h2 id='loadingsplot'>Graphical Summary Information Pertaining to the Loadings</h2><span id='topic+loadingsplot'></span>

<h3>Description</h3>

<p>Functions to extract graphical loadings information from <code>mvdareg</code> and <code>mvdapca</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadingsplot(object, ncomp = object$ncomp, conf = 0.95, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadingsplot_+3A_object">object</code></td>
<td>
<p> an <code>mvdareg</code> or <code>mvdapca</code> object.</p>
</td></tr>
<tr><td><code id="loadingsplot_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include. </p>
</td></tr>
<tr><td><code id="loadingsplot_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
<tr><td><code id="loadingsplot_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"loadingsplot"</code> is used to extract a graphical summary of the loadings of a PLS model.
If <code>"comps"</code> is missing (or is NULL), a graphical summary for the nth component estimates are returned.  Otherwise, if comps is given parameters for a model with only the requested component comps is returned.
</p>
<p>Bootstrap graphcal summaries provided are when <code>"method = oob"</code>
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+loadings">loadings</a></code>, <code><a href="#topic+loadings.boots">loadings.boots</a></code>, <code><a href="#topic+loadingsplot2D">loadingsplot2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
loadingsplot(mod1, ncomp = 1:2)
</code></pre>

<hr>
<h2 id='loadingsplot2D'>2-Dimensionsl Graphical Summary Information Pertaining to the Loadings of a PLS or PCA Analysis</h2><span id='topic+loadingsplot2D'></span>

<h3>Description</h3>

<p>Functions to extract 2D graphical loadings information from mvdalab objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadingsplot2D(object, comps = c(1, 2), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadingsplot2D_+3A_object">object</code></td>
<td>
<p> an <code>mvdareg</code> or <code>mvdapca</code> object. </p>
</td></tr>
<tr><td><code id="loadingsplot2D_+3A_comps">comps</code></td>
<td>
<p> a vector or length 2 corresponding to the number of components to include.</p>
</td></tr> <tr><td><code id="loadingsplot2D_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>loadingsplot2D</code> is used to extract a graphical summary of the loadings of a PLS model.
If <code>comp</code> is missing (or is NULL), a graphical summary for the 1st and 2nd componentsare returned.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+coefficientsplot2D">coefficientsplot2D</a></code>, <code><a href="#topic+weightsplot2D">weightsplot2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
loadingsplot2D(mod1, comp = c(1, 2))

## Not run: 
data(Penta)
mod2 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
loadingsplot2D(mod2, comp = c(1, 2))

## End(Not run)

data(iris)
pc1 &lt;- pcaFit(iris)
loadingsplot2D(pc1, comp = c(1, 2))
</code></pre>

<hr>
<h2 id='mewma'>Generates a Hotelling's T2 Graph of the Multivariate Exponentially Weighted Average</h2><span id='topic+mewma'></span>

<h3>Description</h3>

<p>Generates a Hotelling's T2 Graph for <code>mewma</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mewma(X, phase = 1, lambda = 0.2, conf = c(0.95, 0.99), 
                      asymptotic.form = FALSE) </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mewma_+3A_x">X</code></td>
<td>
<p> a dataframe. </p>
</td></tr>
<tr><td><code id="mewma_+3A_phase">phase</code></td>
<td>
<p> designates whether the confidence limits should reflect the current data frame, <code>phase = 1</code> or future observations, <code>phase = 2</code>. </p>
</td></tr>
<tr><td><code id="mewma_+3A_lambda">lambda</code></td>
<td>
<p>EWMA smoothing parameter</p>
</td></tr>
<tr><td><code id="mewma_+3A_conf">conf</code></td>
<td>
<p> the confidence level(s) to use for upper control limit. </p>
</td></tr>
<tr><td><code id="mewma_+3A_asymptotic.form">asymptotic.form</code></td>
<td>
<p> use asymptotic convergence parameter for scaling the covariance matrix. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mewma</code> is used to generates a Hotelling's T2 graph for the multivariate EWMA.
</p>


<h3>Value</h3>

<p>The output of <code>mewma</code> is a graph of Hotelling's T2 for the Multivariate EWMS, and a list containing a data frame of univariate EWMAs and the multivariate EWMA T2 values.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Lowry, Cynthia A., et al. &quot;A multivariate exponentially weighted moving average control chart.&quot; Technometrics 34.1 (1992): 46:53.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mewma(iris[, -5], phase = 1, lambda = 0.2, conf = c(0.95, 0.99), 
                      asymptotic.form = FALSE)
</code></pre>

<hr>
<h2 id='model.matrix'><code>model.matrix</code> creates a design (or model) matrix.</h2><span id='topic+model.matrix.mvdareg'></span>

<h3>Description</h3>

<p>This function returns the <code>model.matrix</code> of an <code>mvdareg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix_+3A_object">object</code></td>
<td>
<p> an <code>mvdareg</code> object </p>
</td></tr>
<tr><td><code id="model.matrix_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"model.matrix.mvdareg"</code> is used to returns the <code>model.matrix</code> of an <code>mvdareg</code> object.
</p>


<h3>Value</h3>

<p>The design matrix for a <code>PLS</code> model with the specified formula and data.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "loo")
model.matrix(mod1)

</code></pre>

<hr>
<h2 id='MultCapability'>
Principal Component Based Multivariate Process Capability Indices
</h2><span id='topic+MultCapability'></span>

<h3>Description</h3>

<p>Provides three multivariate capability indices for correlated multivariate processes based on Principal Component Analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultCapability(data, lsls, usls, targets, ncomps = NULL, Target = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MultCapability_+3A_data">data</code></td>
<td>
<p> a multivariable dataset </p>
</td></tr>
<tr><td><code id="MultCapability_+3A_lsls">lsls</code></td>
<td>
<p> is the vector of the lower specification limits </p>
</td></tr>  
<tr><td><code id="MultCapability_+3A_usls">usls</code></td>
<td>
<p> is the vector of the upper specification limits </p>
</td></tr>
<tr><td><code id="MultCapability_+3A_targets">targets</code></td>
<td>
<p> is the vector of the target of the process </p>
</td></tr>
<tr><td><code id="MultCapability_+3A_ncomps">ncomps</code></td>
<td>
<p> is the number of principal component to use </p>
</td></tr>
<tr><td><code id="MultCapability_+3A_target">Target</code></td>
<td>
<p> Use <code>targets</code> for calculation of univariate PpKs; otherwise the average is used </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ncomps</code> has to be set prior to running the analysis.  The user is strongly encouraged to use <code>pcaFit</code> in order to determine the optimal number of principal components using cross-validation.
</p>
<p>When the parameter targets is not specified, then is estimated of centered way as targets = lsls + (usls - lsls)/2. 
</p>
<p>Ppk values are provided to allow the user to compare the multivariate results to the univariate results.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p>For <code>mpca_wang</code>, the following is returned:
</p>
<table role = "presentation">
<tr><td><code>ncomps</code></td>
<td>
<p> number of components used </p>
</td></tr>
<tr><td><code>mcp_wang</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpk_wang</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpm_wang</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpmk_wang</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
</table>
<p>For <code>mcp_xe</code>, the following is returned:
</p>
<table role = "presentation">
<tr><td><code>ncomps</code></td>
<td>
<p> number of components used </p>
</td></tr>
<tr><td><code>mcp_wang_2</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpk_wang_2</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpm_wang_2</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpmk_wang_2</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
</table>
<p>For <code>mpca_wang_2</code>, the following is returned:
</p>
<table role = "presentation">
<tr><td><code>ncomps</code></td>
<td>
<p> number of components used </p>
</td></tr>
<tr><td><code>mcp_xe</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpk_xe</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpm_xe</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
<tr><td><code>mcpmk_xe</code></td>
<td>
<p> index greater than 1, the process is capable </p>
</td></tr>
</table>
<p>For Ppk, the following is returned:
</p>
<table role = "presentation">
<tr><td><code>Individual.Ppks</code></td>
<td>
<p> univariate Ppks; index greater than 1, the process is capable </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Wang F, Chen J (1998). Capability index using principal components analysis. Quality Engineering, 11, 21-27.
</p>
<p>Xekalaki E, Perakis M (2002). The Use of principal component analysis in the assessment of process capability indices.
Proceedings of the Joint Statistical Meetings of the American Statistical Association, The Institute of Mathematical Statistics, The Canadian Statistical Society. New York.
</p>
<p>Wang, C (2005). Constructing multivariate process capability indices for short-run production. The International Journal of Advanced Manufacturing Technology, 26, 1306-1311.
</p>
<p>Scagliarini, M (2011). Multivariate process capability using principal component analysis in the presence of measurement errors. AStA Adv Stat Anal, 95, 113-128.
</p>
<p>Santos-Fernandez E, Scagliarini M (2012). &quot;MPCI: An R Package for Computing Multivariate Process Capability Indices&quot;. Journal of Statistical Software, 47(7), 1-15, URL http://www.jstatsoft.org/v47/i07/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Wang_Chen_Sim)
lsls1 &lt;- c(2.1, 304.5, 304.5)
usLs1 &lt;- c(2.3, 305.1, 305.1)
targets1 &lt;- c(2.2, 304.8, 304.8)

MultCapability(Wang_Chen_Sim, lsls = lsls1, usls = usLs1, targets = targets1, ncomps = 2)

data(Wang_Chen)
targets2 &lt;- c(177, 53)
lsls2 &lt;- c(112.7, 32.7)
usLs2 &lt;- c(241.3, 73.3)

MultCapability(Wang_Chen, lsls = lsls2, usls = usLs2, targets = targets2, ncomps = 1)

</code></pre>

<hr>
<h2 id='MVcis'>
Calculate Hotelling's T2 Confidence Intervals
</h2><span id='topic+MVcis'></span>

<h3>Description</h3>

<p>Calculate joint confidence intervals (Hotelling's T2 Intervals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVcis(data, segments = 51, level = .95, Vars2Plot = c(1, 2), include.zero = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MVcis_+3A_data">data</code></td>
<td>
<p> a multivariable dataset to compare to means</p>
</td></tr>
<tr><td><code id="MVcis_+3A_segments">segments</code></td>
<td>
<p> number of line-segments used to draw ellipse. </p>
</td></tr>
<tr><td><code id="MVcis_+3A_level">level</code></td>
<td>
<p> draw elliptical contours at these (normal) probability or confidence levels. </p>
</td></tr>
<tr><td><code id="MVcis_+3A_vars2plot">Vars2Plot</code></td>
<td>
<p> variables to plot </p>
</td></tr>
<tr><td><code id="MVcis_+3A_include.zero">include.zero</code></td>
<td>
<p> add the zero axis to the graph output </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the Hotelling's T2 Intervals for a mean vector.
</p>
<p>Assumption:
</p>
<p>Population is a random sample from a multivariate population.
</p>
<p>If the confidence ellipse does not cover c(0, 0), we reject the NULL that the joint confidence region is equal to zero (at the stated alpha level).
</p>


<h3>Value</h3>

<p>This function returns the Hotelling's T2 confidence intervals for the p-variates and its corresponding confidence ellipse at the stated confidence level.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Johnson, R.A., Wichern, D.W. (2002) Applied Multivariate Statistical Analysis. Prentice Hall.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MVComp">MVComp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(College)
MVcis(College, Vars2Plot = c(1, 2), include.zero = TRUE)
</code></pre>

<hr>
<h2 id='MVComp'>
Traditional Multivariate Mean Vector Comparison
</h2><span id='topic+MVComp'></span><span id='topic+print.mvcomp'></span>

<h3>Description</h3>

<p>Performs a traditional multivariate comparison of mean vectors drawn from two populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MVComp(data1, data2, level = .95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MVComp_+3A_data1">data1</code></td>
<td>
<p> a multivariable dataset to compare to. </p>
</td></tr>
<tr><td><code id="MVComp_+3A_data2">data2</code></td>
<td>
<p> a multivariable dataset to compare. </p>
</td></tr>
<tr><td><code id="MVComp_+3A_level">level</code></td>
<td>
<p> draw elliptical contours at these (normal) probability or confidence levels. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a T2-statistic for testing the equality of two mean vectors.  This test is appropriate for testing two populations, assuming independence.  
</p>
<p>Assumptions:
</p>
<p>The sample for both populations is a random sample from a multivariate population.
</p>
<p>-Both populations are independent
</p>
<p>-Both populations are multivariate normal
</p>
<p>-Covariance matrices are approximately equal
</p>


<h3>Value</h3>

<p>This function returns the simultaneous confidence intervals for the p-variates and its corresponding confidence ellipse at the stated confidence level.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Johnson, R.A., Wichern, D.W. (2002) Applied Multivariate Statistical Analysis. Prentice Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(College)
dat1 &lt;- College
#Generate a 'fake' difference of 15 units
dat2 &lt;- College + matrix(rnorm(nrow(dat1) * ncol(dat1), mean = 15), 
        nrow = nrow(dat1), ncol = ncol(dat1))

Comparison &lt;- MVComp(dat1, dat2, level = .95)
Comparison
plot(Comparison, Diff2Plot = c(1, 2), include.zero = FALSE)
plot(Comparison, Diff2Plot = c(1, 2), include.zero = TRUE)

plot(Comparison, Diff2Plot = c(2, 3), include.zero = FALSE)
plot(Comparison, Diff2Plot = c(2, 3), include.zero = TRUE)


data(iris)
dat1b &lt;- iris[, -5]
#Generate a 'fake' difference of .5 units
dat2b &lt;- dat1b + matrix(rnorm(nrow(dat1b) * ncol(dat1b), mean = .5), 
          nrow = nrow(dat1b), ncol = ncol(dat1b))

Comparison2 &lt;- MVComp(dat1b, dat2b, level = .90)
plot(Comparison2, Diff2Plot = c(1, 2), include.zero = FALSE)
plot(Comparison2, Diff2Plot = c(1, 2), include.zero = TRUE)

plot(Comparison2, Diff2Plot = c(3, 4), include.zero = FALSE)
plot(Comparison2, Diff2Plot = c(3, 4), include.zero = TRUE)
</code></pre>

<hr>
<h2 id='mvdaboot'>Bootstrapping routine for <code>mvdareg</code> objects</h2><span id='topic+mvdaboot'></span>

<h3>Description</h3>

<p>When <code>validation = 'oob'</code> this routine effects the bootstrap procedure for <code>mvdareg</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvdaboot(X, Y, ncomp, method = "bidiagpls", scale = FALSE, n_cores, parallel,
          boots, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvdaboot_+3A_x">X</code></td>
<td>
<p> a matrix of observations. NAs and Infs are not allowed. </p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_y">Y</code></td>
<td>
<p> a vector. NAs and Infs are not allowed. </p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_method">method</code></td>
<td>
<p> PLS algorithm used. </p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_scale">scale</code></td>
<td>
<p> scaling used. </p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_n_cores">n_cores</code></td>
<td>
<p> No. of cores to run for parallel processing.  Currently set to 2 (4 max). </p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_parallel">parallel</code></td>
<td>
<p> should parallelization be used. </p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_boots">boots</code></td>
<td>
<p>No. of bootstrap samples when <code>validation = 'oob'</code></p>
</td></tr>
<tr><td><code id="mvdaboot_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly, but through the generic function plsFit with the argument <code>validation = 'oob'</code>. 
</p>


<h3>Value</h3>

<p>Provides the following bootstrapped results as a list for <code>mvdareg</code> objects:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> fitted values </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> weights </p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>
<p> loadings </p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p> number of latent variables </p>
</td></tr>
<tr><td><code>bootstraps</code></td>
<td>
<p> No. of bootstraps </p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p> scores </p>
</td></tr>
<tr><td><code>cvR2</code></td>
<td>
<p> bootstrap estimate of cvR2 </p>
</td></tr>
<tr><td><code>PRESS</code></td>
<td>
<p> bootstrap estimate of prediction error sums of squares </p>
</td></tr>
<tr><td><code>MSPRESS</code></td>
<td>
<p> bootstrap estimate of mean squared error prediction sums of squares </p>
</td></tr>
<tr><td><code>boot.means</code></td>
<td>
<p> bootstrap mean of bootstrapped parameters </p>
</td></tr>
<tr><td><code>RMSPRESS</code></td>
<td>
<p> bootstrap estimate of mean squared error prediction sums of squares </p>
</td></tr>
<tr><td><code>D2</code></td>
<td>
<p> bidiag2 matrix </p>
</td></tr>
<tr><td><code>iD2</code></td>
<td>
<p> Inverse of bidiag2 matrix </p>
</td></tr>
<tr><td><code>y.loadings</code></td>
<td>
<p> normalized y-loadings </p>
</td></tr>
<tr><td><code>y.loadings2</code></td>
<td>
<p> non-normalized y-loadings </p>
</td></tr>
<tr><td><code>MSPRESS.632</code></td>
<td>
<p> .632 corrected estimate of MSPRESS </p>
</td></tr>
<tr><td><code>oob.fitted</code></td>
<td>
<p> out-of-bag PLS fitted values </p>
</td></tr>
<tr><td><code>RMSPRESS.632</code></td>
<td>
<p> .632 corrected estimate of RMSPRESS </p>
</td></tr>
<tr><td><code>in.bag</code></td>
<td>
<p> bootstrap samples used for model building at each bootstrap </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>), Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>)</p>


<h3>References</h3>

<p>There are many references explaining the bootstrap and its implementation for confidence interval estimation. Among them are:
</p>
<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. and Tibshirani, R. (1993) An Introduction to the Bootstrap. Chapman &amp; Hall.
</p>
<p>Hinkley, D.V. (1988) Bootstrap methods (with Discussion). Journal of the Royal Statistical Society, B, 50, 312:337, 355:370.
</p>
<p>NOTE: This function is adapted from <code>mvr</code> in package <span class="pkg">pls</span> with extensive modifications by Nelson Lee Afanador and Thanh Tran.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsFit">plsFit</a></code>, <code><a href="#topic+mvdaloo">mvdaloo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "oob", boots = 300)

## Run line below to see bootstrap results
## mod1$validation
</code></pre>

<hr>
<h2 id='mvdaloo'>Leave-one-out routine for <code>mvdareg</code> objects</h2><span id='topic+mvdaloo'></span>

<h3>Description</h3>

<p>When <code>validation = 'loo'</code> this routine effects the leave-one-out cross-validation procedure for <code>mvdareg</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvdaloo(X, Y, ncomp, weights = NULL, method = "bidiagpls", 
        scale = FALSE, boots = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvdaloo_+3A_x">X</code></td>
<td>
<p> a matrix of observations. <code>NAs</code> and Infs are not allowed. </p>
</td></tr>
<tr><td><code id="mvdaloo_+3A_y">Y</code></td>
<td>
<p> a vector. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="mvdaloo_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="mvdaloo_+3A_weights">weights</code></td>
<td>
<p>currently not in use</p>
</td></tr>
<tr><td><code id="mvdaloo_+3A_method">method</code></td>
<td>
<p> PLS algorithm used </p>
</td></tr>
<tr><td><code id="mvdaloo_+3A_scale">scale</code></td>
<td>
<p> scaling used </p>
</td></tr>
<tr><td><code id="mvdaloo_+3A_boots">boots</code></td>
<td>
<p>not applicable for <code>validation = 'loo'</code></p>
</td></tr>
<tr><td><code id="mvdaloo_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly, but through the generic function <code>plsFit</code> with the argument <code>validation = 'loo'</code>. 
</p>


<h3>Value</h3>

<p>Provides the following bootstrapped results as a list for <code>mvdareg</code> objects:
</p>
<table role = "presentation">
<tr><td><code>cvR2</code></td>
<td>
<p> leave-one-out estimate of cvR2. </p>
</td></tr>
<tr><td><code>PRESS</code></td>
<td>
<p> leave-one-out estimate of prediction error sums of squares. </p>
</td></tr>
<tr><td><code>MSPRESS</code></td>
<td>
<p> leave-one-out estimate of mean squared error prediction sums of squares. </p>
</td></tr>
<tr><td><code>RMSPRESS</code></td>
<td>
<p> leave-one-out estimate of mean squared error prediction sums of squares. </p>
</td></tr>
<tr><td><code>in.bag</code></td>
<td>
<p> leave-one-out samples used for model building. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>), Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>)</p>


<h3>References</h3>

<p>NOTE: This function is adapted from <code>mvr</code> in package <span class="pkg">pls</span> with extensive modifications by Nelson Lee Afanador and Thanh Tran.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsFit">plsFit</a></code>, <code><a href="#topic+mvdaboot">mvdaboot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
        ncomp = 2, method = "bidiagpls", validation = "loo")

mod1$validation$cvR2
mod1$validation$PRESS
mod1$validation$MSPRESS
mod1$validation$RMSPRESS
mod1$validation$in.bag  
</code></pre>

<hr>
<h2 id='mvrnorm.svd'>Simulate from a Multivariate Normal, Poisson, Exponential, or Skewed Distribution</h2><span id='topic+mvrnorm.svd'></span><span id='topic+mvrnormBase.svd'></span>

<h3>Description</h3>

<p>Produces one or more samples from the specified multivariate  distribution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvrnorm.svd(n = 1, mu = NULL, Sigma = NULL, tol = 1e-06, empirical = FALSE, 
            Dist = "normal", skew = 5, skew.mean = 0, skew.sd = 1, 
            poisson.mean = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvrnorm.svd_+3A_n">n</code></td>
<td>
<p> the number of samples required. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_mu">mu</code></td>
<td>
<p> a vector giving the means of the variables. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_sigma">Sigma</code></td>
<td>
<p> a positive-definite symmetric matrix specifying the covariance matrix of the variables. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_tol">tol</code></td>
<td>
<p> tolerance (relative to largest variance) for numerical lack of positive-definiteness in Sigma. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_empirical">empirical</code></td>
<td>
<p> logical. If true, <code>mu</code> and <code>Sigma</code> specify the empirical not population mean and covariance matrix. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_dist">Dist</code></td>
<td>
<p> desired distribution. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_skew">skew</code></td>
<td>
<p> amount of skew for skewed distributions. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_skew.mean">skew.mean</code></td>
<td>
<p> mean for skewed distribution. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_skew.sd">skew.sd</code></td>
<td>
<p> standard deviation for skewed distribution. </p>
</td></tr>
<tr><td><code id="mvrnorm.svd_+3A_poisson.mean">poisson.mean</code></td>
<td>
<p> mean for poisson distribution. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"mvrnorm.svd"</code> The matrix decomposition is done via <code>svd</code>
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>Sigma &lt;- matrix(c(1, .5, .5, .5, 1, .5, .5, .5, 1), 3, 3)
Means &lt;- rep(0, 3)

Sim.dat.norm &lt;- mvrnorm.svd(n = 1000, Means, Sigma, Dist = "normal")
plot(as.data.frame(Sim.dat.norm))

Sim.dat.pois &lt;- mvrnorm.svd(n = 1000, Means, Sigma, Dist = "poisson")
plot(as.data.frame(Sim.dat.pois))

Sim.dat.exp &lt;- mvrnorm.svd(n = 1000, Means, Sigma, Dist = "exp")
plot(as.data.frame(Sim.dat.exp))

Sim.dat.skew &lt;- mvrnorm.svd(n = 1000, Means, Sigma, Dist = "skewnorm")
plot(as.data.frame(Sim.dat.skew))

</code></pre>

<hr>
<h2 id='my.dummy.df'>Create a Design Matrix with the Desired Constrasts</h2><span id='topic+my.dummy.df'></span>

<h3>Description</h3>

<p>This function generates a dummy variable data frame in support various functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>my.dummy.df(data, contr = "contr.niets")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="my.dummy.df_+3A_data">data</code></td>
<td>
<p> a data frame </p>
</td></tr>
<tr><td><code id="my.dummy.df_+3A_contr">contr</code></td>
<td>
<p> an optional list. See the contrasts.arg of model.matrix.default. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>my.dummy.df takes a <code>data.frame</code> with categorical variables, and returns a <code>data.frame</code> in which all the categorical variables columns are expanded as dummy variables. 
</p>
<p>The argument <code>contr</code> is passed to the default <code>contr.niets</code>; <code>contr.helmert</code>, <code>contr.poly</code>, <code>contr.sum</code>, <code>contr.treatment</code> are also supported.
</p>


<h3>Value</h3>

<p>For datasets with categorical variables it produces the specified design matrix.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
my.dummy.df(iris)
</code></pre>

<hr>
<h2 id='no.intercept'>Delete Intercept from Model Matrix</h2><span id='topic+no.intercept'></span>

<h3>Description</h3>

<p>Deletes the intercept from a model matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>no.intercept(mm)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="no.intercept_+3A_mm">mm</code></td>
<td>
<p> Model Matrix </p>
</td></tr></table>


<h3>Value</h3>

<p>A model matrix without intercept column.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador</p>

<hr>
<h2 id='pca.nipals'>PCA with the NIPALS algorithm</h2><span id='topic+pca.nipals'></span><span id='topic+print.npca'></span>

<h3>Description</h3>

<p>Implements the Nonlinear Iterative Partial Least Squares (NIPALS) algorithm for computing PCA scores and loadings and intermediate steps to convergence.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca.nipals(data, ncomps = 1, Iters = 500, start.vec = NULL, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pca.nipals_+3A_data">data</code></td>
<td>
<p> A dataframe </p>
</td></tr>
<tr><td><code id="pca.nipals_+3A_ncomps">ncomps</code></td>
<td>
<p> the number of components to include in the analysis. </p>
</td></tr>
<tr><td><code id="pca.nipals_+3A_iters">Iters</code></td>
<td>
<p> Number of iterations </p>
</td></tr>
<tr><td><code id="pca.nipals_+3A_start.vec">start.vec</code></td>
<td>
<p>option for choosing your own starting vector</p>
</td></tr>
<tr><td><code id="pca.nipals_+3A_tol">tol</code></td>
<td>
<p>tolernace for convergence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NIPALS algorithm is a popular algorithm in multivariate data analysi for computing PCA scores and loadings. This function is specifically designed to help explore the subspace prior to convergence.  Currently only mean-centering is employed.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Loadings</code></td>
<td>
<p> Loadings obtained via NIPALS </p>
</td></tr>
<tr><td><code>Scores</code></td>
<td>
<p> Scores obtained via NIPALS </p>
</td></tr>
<tr><td><code>Loading.Space</code></td>
<td>
<p> A list containing the intermediate step to convergence for the loadings </p>
</td></tr>
<tr><td><code>Score.Space</code></td>
<td>
<p> A list containing the intermediate step to convergence for the scores </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>There are many good references for the NIPALS algorithm:
</p>
<p>Risvik, Henning. &quot;Principal component analysis (PCA) &amp; NIPALS algorithm.&quot; (2007).
</p>
<p>Wold, Svante, Kim Esbensen, and Paul Geladi. &quot;Principal component analysis.&quot; Chemometrics and intelligent laboratory systems 2.1-3 (1987): 37:52.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.nipals &lt;- pca.nipals(iris[, 1:4], ncomps = 4, tol = 1e-08)
names(my.nipals)

#Check results
my.nipals$Loadings
svd(scale(iris[, 1:4], scale = FALSE))$v

nipals.scores &lt;- data.frame(my.nipals$Scores)
names(nipals.scores) &lt;- paste("np", 1:4)
svd.scores &lt;- data.frame(svd(scale(iris[, 1:4], scale = FALSE))$u)
names(svd.scores) &lt;- paste("svd", 1:4)
Scores. &lt;- cbind(nipals.scores, svd.scores)
plot(Scores.)

my.nipals$Loading.Space
my.nipals$Score.Space
</code></pre>

<hr>
<h2 id='pcaFit'>Principal Component Analysis</h2><span id='topic+pcaFit'></span><span id='topic+print.mvdapca'></span><span id='topic+plot.mvdapca'></span>

<h3>Description</h3>

<p>Function to perform principal component analysis.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcaFit(data, scale = TRUE, ncomp = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcaFit_+3A_data">data</code></td>
<td>
<p> an data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="pcaFit_+3A_scale">scale</code></td>
<td>
<p> should scaling to unit variance be used. </p>
</td></tr>
<tr><td><code id="pcaFit_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation is done via singular value decomposition of the data matrix.  Dummy variables are automatically created for categorical variables.
</p>


<h3>Value</h3>

<p><code>pcaFit</code> returns a list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>loadings</code></td>
<td>
<p> X loadings </p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p> X scores </p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p> eigenvalues </p>
</td></tr>
<tr><td><code>Xdata</code></td>
<td>
<p> X matrix </p>
</td></tr>
<tr><td><code>Percent.Explained</code></td>
<td>
<p> Explained variation in X </p>
</td></tr>
<tr><td><code>PRESS</code></td>
<td>
<p> Prediction Error Sum-of-Squares </p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p> number of latent variables </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> PLS algorithm used </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Everitt, Brian S. (2005). An R and S-Plus Companion to Multivariate Analysis. Springer-Verlag.
</p>
<p>Edoardo Saccentia, Jos? Camacho, (2015) On the use of the observation-wise k-fold operation in PCA cross-validation, J. Chemometrics 2015; 29: 467-478.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadingsplot2D">loadingsplot2D</a></code>, <code><a href="#topic+T2">T2</a></code>, <code><a href="#topic+Xresids">Xresids</a></code>, <code><a href="#topic+ScoreContrib">ScoreContrib</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
pc1 &lt;- pcaFit(iris, scale = TRUE, ncomp = NULL)
pc1

print(pc1) #Model summary
plot(pc1) #MSEP
PE(pc1) #X-explained variance

T2(pc1, ncomp = 2) #T2 plot

Xresids(pc1, ncomp = 2) #X-residuals plot

scoresplot(pc1) #scoresplot variable importance

(SC &lt;- ScoreContrib(pc1, obs1 = 1:9, obs2 = 10:11))  #score contribution
plot(SC)  #score contribution plot

loadingsplot(pc1, ncomp = 1) #loadings plot
loadingsplot(pc1, ncomp = 1:2) #loadings plot
loadingsplot(pc1, ncomp = 1:3) #loadings plot
loadingsplot(pc1, ncomp = 1:7) #loadings plot
loadingsplot2D(pc1, comps = c(1, 2)) #2-D loadings plot
loadingsplot2D(pc1, comps = c(2, 3)) #2-D loadings plot
</code></pre>

<hr>
<h2 id='PE'>Percent Explained Variation of X</h2><span id='topic+PE'></span>

<h3>Description</h3>

<p>This function provides both the cumulative and individual percent explained for the X-block for an <code>mvdareg</code> and <code>mvdapca</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PE(object, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PE_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code> or <code>mvdapca</code> objects. </p>
</td></tr>
<tr><td><code id="PE_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides both the cumulative and individual percent explained for the X-block for an <code>mvdareg</code> or <code>mvdapca</code> objects.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "none")
PE(mod1)

## Not run: 
data(Penta)
mod2 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
PE(mod2)

## End(Not run)

</code></pre>

<hr>
<h2 id='Penta'>
Penta data set
</h2><span id='topic+Penta'></span>

<h3>Description</h3>

<p>This data is obtained from drug discovery and includes measurements pertaining to size, lipophilicity, and polarity at various sites on a molecule. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Penta</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations and the following 17 variables.
</p>

<dl>
<dt><code>Obs.Name</code></dt><dd><p>Categorical ID Variable</p>
</dd>
<dt><code>S1</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>L1</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>P1</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>S2</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>L2</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>P2</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>S3</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>L3</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>P3</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>S4</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>L4</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>P4</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>S5</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>L5</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>P5</code></dt><dd><p>numeric predictor vector</p>
</dd>
<dt><code>log.RAI</code></dt><dd><p>numeric response vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Umetrics, Inc. (1995), Multivariate Analysis (3-day course), Winchester, MA.
</p>
<p>SAS/STAT(R) 9.22 User's Guide, &quot;The PLS Procedure&quot;.
</p>

<hr>
<h2 id='perc.cis'>Percentile Bootstrap Confidence Intervals</h2><span id='topic+perc.cis'></span>

<h3>Description</h3>

<p>Computes percentile bootstrap confidence intervals for chosen parameters for <code>plsFit</code> models fitted with <code>validation = "oob"</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>perc.cis(object, ncomp = object$ncomp, conf = 0.95, 
        type = c("coefficients", "loadings", "weights"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="perc.cis_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mvdareg"</code>, i.e., <code>plsFit</code> </p>
</td></tr>
<tr><td><code id="perc.cis_+3A_ncomp">ncomp</code></td>
<td>
<p> number of components to extract percentile intervals. </p>
</td></tr>
<tr><td><code id="perc.cis_+3A_conf">conf</code></td>
<td>
<p> confidence level. </p>
</td></tr>
<tr><td><code id="perc.cis_+3A_type">type</code></td>
<td>
<p> input parameter vector. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits computes the bootstrap percentile confidence intervals for any fitted <code>mvdareg</code> model. 
</p>


<h3>Value</h3>

<p>A perc.cis object contains component results for the following:
</p>
<table role = "presentation">
<tr><td><code>ncomp</code></td>
<td>
<p> number of components in the model </p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p> variable names </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap </p>
</td></tr>
<tr><td><code>percentiles</code></td>
<td>
<p> confidence intervals </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>There are many references explaining the bootstrap and its implementation for confidence interval estimation. Among them are:
</p>
<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. and Tibshirani, R. (1993) An Introduction to the Bootstrap. Chapman &amp; Hall.
</p>
<p>Hinkley, D.V. (1988) Bootstrap methods (with Discussion). Journal of the Royal Statistical Society, B, 50, 312:337, 355:370.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 250 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "oob", boots = 250)
perc.cis(mod1, ncomp = 1:2, conf = .95, type = "coefficients")
</code></pre>

<hr>
<h2 id='plot.cp'>Plotting Function for Score Contributions.</h2><span id='topic+plot.cp'></span>

<h3>Description</h3>

<p>This function generates a plot an object of class <code>score.contribution</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cp'
plot(x, ncomp = "Overall", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cp_+3A_x">x</code></td>
<td>
 <p><code>score.contribution</code> object </p>
</td></tr>
<tr><td><code id="plot.cp_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include the graph output. </p>
</td></tr>
<tr><td><code id="plot.cp_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A graph of the score contributions for <code>ScoreContrib</code> objects.
</p>


<h3>Value</h3>

<p>The output of <code>plot</code> is a graph of score contributions for the specified observation(s).
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, method = "bidiagpls", validation = "loo")
Score.Contributions1 &lt;- ScoreContrib(mod1, obs1 = 1, obs2 = 3)
plot(Score.Contributions1, ncomp = 1)

## Not run: 
data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod2 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
Score.Contributions2 &lt;- ScoreContrib(mod2, obs1 = 1, obs2 = 3)
plot(Score.Contributions2, ncomp = 1)

## End(Not run)

#PCA Model
pc1 &lt;- pcaFit(Penta[, -1], ncomp = 3)
Score.Contributions1 &lt;- ScoreContrib(mod1, obs1 = 1, obs2 = 3)
plot(Score.Contributions1, ncomp = 1)
</code></pre>

<hr>
<h2 id='plot.mvcomp'>
Plot of Multivariate Mean Vector Comparison
</h2><span id='topic+plot.mvcomp'></span>

<h3>Description</h3>

<p>Plot a comparison of mean vectors drawn from two populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvcomp'
plot(x, Diff2Plot = c(3, 4), segments = 51, include.zero = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvcomp_+3A_x">x</code></td>
<td>
<p> an plot.mvcomp object. </p>
</td></tr>
<tr><td><code id="plot.mvcomp_+3A_segments">segments</code></td>
<td>
<p> number of line-segments used to draw ellipse. </p>
</td></tr>
<tr><td><code id="plot.mvcomp_+3A_diff2plot">Diff2Plot</code></td>
<td>
<p> variable differences to plot. </p>
</td></tr>
<tr><td><code id="plot.mvcomp_+3A_include.zero">include.zero</code></td>
<td>
<p> add the zero axis to the graph output. </p>
</td></tr>
<tr><td><code id="plot.mvcomp_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a plot of the T2-statistic for testing the equality of two mean vectors.  This test is appropriate for testing two populations, assuming independence.  
</p>
<p>Assumptions:
</p>
<p>The sample for both populations is a random sample from a multivariate population.
</p>
<p>-Both populations are independent
</p>
<p>-Both populations are multivariate normal
</p>
<p>-Covariance matrices are approximately equal
</p>
<p>If the confidence ellipse does not cover c(0, 0), we reject the NULL that the differnece between mean vectors is equal to zero (at the stated alpha level).
</p>


<h3>Value</h3>

<p>This function returns a plot of the simultaneous confidence intervals for the p-variates and its corresponding confidence ellipse at the stated confidence level.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Johnson, R.A., Wichern, D.W. (2002) Applied Multivariate Statistical Analysis. Prentice Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(College)
dat1 &lt;- College
#Generate a 'fake' difference of 15 units
dat2 &lt;- College + matrix(rnorm(nrow(dat1) * ncol(dat1), mean = 15), 
        nrow = nrow(dat1), ncol = ncol(dat1))

Comparison &lt;- MVComp(dat1, dat2, level = .95)
Comparison
plot(Comparison, Diff2Plot = c(1, 2), include.zero = FALSE)
plot(Comparison, Diff2Plot = c(1, 2), include.zero = TRUE)

plot(Comparison, Diff2Plot = c(2, 3), include.zero = FALSE)
plot(Comparison, Diff2Plot = c(2, 3), include.zero = TRUE)


data(iris)
dat1b &lt;- iris[, -5]
#Generate a 'fake' difference of .5 units
dat2b &lt;- dat1b + matrix(rnorm(nrow(dat1b) * ncol(dat1b), mean = .5), 
          nrow = nrow(dat1b), ncol = ncol(dat1b))

Comparison2 &lt;- MVComp(dat1b, dat2b, level = .90)
plot(Comparison2, Diff2Plot = c(1, 2), include.zero = FALSE)
plot(Comparison2, Diff2Plot = c(1, 2), include.zero = TRUE)

plot(Comparison2, Diff2Plot = c(3, 4), include.zero = FALSE)
plot(Comparison2, Diff2Plot = c(3, 4), include.zero = TRUE)
</code></pre>

<hr>
<h2 id='plot.mvdareg'>General plotting function for <code>mvdareg</code> and <code>mvdapaca</code> objects.</h2><span id='topic+plot.mvdareg'></span>

<h3>Description</h3>

<p>A general plotting function for a <code>mvdareg</code> and <code>mvdapca</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
plot(x, plottype = c("PE", "scoresplot", "loadingsplot",
                    "loadingsplot2D", "T2", "Xresids", "coefsplot", "ap.plot",
                    "weightsplot", "weightsplot2D", "acfplot"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvdareg_+3A_x">x</code></td>
<td>
<p> an object of class <code>"mvdareg"</code>, i.e., a fitted model. </p>
</td></tr>
<tr><td><code id="plot.mvdareg_+3A_plottype">plottype</code></td>
<td>
<p> the desired plot from an object of class <code>"mvdareg"</code> </p>
</td></tr>
<tr><td><code id="plot.mvdareg_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following plotting functions are supported:
</p>
<p><code>PE</code>, <code>scoreplot</code>, <code>loadingsplot</code>, <code>loadingsplot2D</code>, <code>T2</code>, <code>Xresids</code>, <code>coefsplot</code>, <code>ap.plot</code>, <code>weightsplot</code>, <code>weightsplot2D</code>, <code>acfplot</code>
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
plot(mod1, plottype = "scoresplot")
## Not run: 
plot(mod1, plottype = "loadingsplot2D")
plot(mod1, plottype = "T2", ncomp = 2, phase = 1, conf = c(.95, .99))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.plusminus'>2D Graph of the PCA scores associated with a plusminusFit</h2><span id='topic+plot.plusminus'></span>

<h3>Description</h3>

<p>Generates a 2-dimensional graph of the scores for both <code>plusminus</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plusminus'
plot(x, ncomp = 2, comps = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.plusminus_+3A_x">x</code></td>
<td>
<p> an object of class <code>plusminus</code>, i.e. <code>plusminusFit</code>. </p>
</td></tr>
<tr><td><code id="plot.plusminus_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="plot.plusminus_+3A_comps">comps</code></td>
<td>
<p> a vector or length 2 corresponding to the number of components to include. </p>
</td></tr>
<tr><td><code id="plot.plusminus_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.plusminus</code> is used to extract a 2D graphical summary of the PCA scores associated with a <code>plusminus</code> object.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>###  PLUS-Minus CLASSIFIER WITH validation = 'none', i.e. no CV ###
data(plusMinusDat)
mod1 &lt;- plusminusFit(Y ~., data = plusMinusDat, validation = "none", n_cores = 2)
plot(mod1, ncomp = 2, comps = c(1, 2))

###  Plus-Minus CLASSIFIER WITH validation = 'loo', i.e. leave-one-out CV ###
## Not run: 
data(plusMinusDat)
mod2 &lt;- plusminusFit(Y ~., data = plusMinusDat, validation = "loo", n_cores = 2)
plot(mod2, ncomp = 2, comps = c(1, 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.R2s'>Plot of R2</h2><span id='topic+plot.R2s'></span>

<h3>Description</h3>

<p>Plots for the cross-validated R2 (CVR2), explained variance in the predictor variables (R2X), and the reponse (R2Y).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'R2s'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.R2s_+3A_x">x</code></td>
<td>
<p>An <code>R2s</code> object </p>
</td></tr>
<tr><td><code id="plot.R2s_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.R2s</code> is used to generates the graph of the cross-validated R2 (CVR2), explained variance in the predictor variables (R2X), and the reponse (R2Y) for PLS models.
</p>


<h3>Value</h3>

<p>The output of <code>plot.R2s</code> is a graph of the stated explained variance summary.
</p>


<h3>Author(s)</h3>

<p>Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
plot(R2s(mod1))
</code></pre>

<hr>
<h2 id='plot.smc'>Plotting function for Significant Multivariate Correlation</h2><span id='topic+plot.smc'></span>

<h3>Description</h3>

<p>This function generates a plot an object of class <code>smc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smc'
plot(x, variables = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.smc_+3A_x">x</code></td>
<td>
<p><code>smc</code> object. </p>
</td></tr>
<tr><td><code id="plot.smc_+3A_variables">variables</code></td>
<td>
<p> the number of variables to include the graph output. </p>
</td></tr>
<tr><td><code id="plot.smc_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.smc</code> is used to generates the graph of the significant multivariate correlation from <code>smc</code> objects.
</p>


<h3>Value</h3>

<p>The output of <code>plot.smc</code> is a graph of the significant multivariate correlation for the specified observation(s).
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "loo")
smc(mod1)
plot(smc(mod1))
</code></pre>

<hr>
<h2 id='plot.sr'>Plotting function for Selectivity Ratio.</h2><span id='topic+plot.sr'></span>

<h3>Description</h3>

<p>This function provides the ability to plot an object of class <code>sr</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sr'
plot(x, variables = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sr_+3A_x">x</code></td>
<td>
<p><code>sr</code> object </p>
</td></tr>
<tr><td><code id="plot.sr_+3A_variables">variables</code></td>
<td>
<p> the number of variables to include the graph output. </p>
</td></tr>
<tr><td><code id="plot.sr_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.sr</code> is used to generates the graph of the selectivity ratio from <code>sr</code> objects.
</p>


<h3>Value</h3>

<p>The output of <code>plot.sr</code> is a graph of the selectivity ratio for the specified observation(s).
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "loo")
sr(mod1)
plot(sr(mod1))
</code></pre>

<hr>
<h2 id='plot.wrtpls'>Plots of the Output of a Permutation Distribution for an <code>mvdareg</code> Object with <code>method = "bidiagpls"</code></h2><span id='topic+plot.wrtpls'></span>

<h3>Description</h3>

<p>This takes an <code>mvdareg</code> object fitted with <code>method = "bidiagpls"</code> and produces a graph of the bootstrap distribution and its corresponding normal quantile plot for a  variable of interest.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wrtpls'
plot(x, comp = 1:object$ncomp, distribution = "log", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.wrtpls_+3A_x">x</code></td>
<td>
<p> an object of class <code>"mvdareg"</code>, i.e., a <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="plot.wrtpls_+3A_comp">comp</code></td>
<td>
<p> number of latent variables to generate the permutation distribution </p>
</td></tr>
<tr><td><code id="plot.wrtpls_+3A_distribution">distribution</code></td>
<td>
<p> plot the <code>"log"</code>, or <code>"actual"</code>, of the permutation distribution </p>
</td></tr>
<tr><td><code id="plot.wrtpls_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function generates the permutation distribution and normal quantile plot for a <code>mvdareg</code> model when <code>method = "bidiagpls"</code> is specified.
</p>


<h3>Value</h3>

<p>The output of <code>plot.wrtpls</code> is a histogram of the permutation distribution with the following vertical line indicators.
</p>
<p>Solid line = Actual Value;
Dashed Line = Critical Value from t-distribution at the model specifed alpha;
Dotted line = Quantile at the model specifed alpha
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>See Also</h3>

<p><code><a href="#topic+bca.cis">bca.cis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               method = "wrtpls", validation = "none")
## Not run
## plot.wrtpls(mod1, distribution = "log")
</code></pre>

<hr>
<h2 id='plsFit'>Partial Least Squares Regression</h2><span id='topic+plsFit'></span><span id='topic+mvdareg'></span><span id='topic+summary.mvdareg'></span><span id='topic+summary.mvdareg.default'></span>

<h3>Description</h3>

<p>Functions to perform partial least squares regression with a formula interface. Bootstraping can be used. Prediction, residuals, model extraction, plot, print and summary methods are also implemented.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsFit(formula, data, subset, ncomp = NULL, na.action, 
method = c("bidiagpls", "wrtpls"), scale = TRUE, n_cores = 2, 
alpha = 0.05, perms = 2000, validation = c("none", "oob", "loo"), 
boots = 1000, model = TRUE, parallel = FALSE,
x = FALSE, y = FALSE, ...) 
## S3 method for class 'mvdareg'
summary(object, ncomp = object$ncomp, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plsFit_+3A_formula">formula</code></td>
<td>
<p> a model formula (see below). </p>
</td></tr>
<tr><td><code id="plsFit_+3A_data">data</code></td>
<td>
<p> an optional data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be used in the fitting process. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="plsFit_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data contain <code>NAs</code>. The default is set by the <code>na.action</code> setting of options, and is <code>na.fail</code> if that is unset. The default is <code>na.omit</code>. Another possible value is <code>NULL</code>, no action. Value <code>na.exclude</code> can be useful. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_method">method</code></td>
<td>
<p> the multivariate regression algorithm to be used. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_scale">scale</code></td>
<td>
<p> should scaling to unit variance be used. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_n_cores">n_cores</code></td>
<td>
<p> Number of cores to run for parallel processing.  Currently set to 2 with the max being 4. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_alpha">alpha</code></td>
<td>
<p> the significance level for <code>wrtpls</code> </p>
</td></tr>
<tr><td><code id="plsFit_+3A_perms">perms</code></td>
<td>
<p> the number of permutations to run for <code>wrtpls</code> </p>
</td></tr>
<tr><td><code id="plsFit_+3A_validation">validation</code></td>
<td>
<p> character. What kind of (internal) validation to use. See below. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_boots">boots</code></td>
<td>
<p>Number of bootstrap samples when <code>validation = 'oob'</code></p>
</td></tr>
<tr><td><code id="plsFit_+3A_model">model</code></td>
<td>
<p> an optional data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_parallel">parallel</code></td>
<td>
<p> should parallelization be used. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_x">x</code></td>
<td>
<p> a logical. If TRUE, the model matrix is returned. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_y">y</code></td>
<td>
<p> a logical. If TRUE, the response is returned. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_object">object</code></td>
<td>
<p> an object of class <code>"mvdareg"</code>, i.e., a fitted model. </p>
</td></tr>
<tr><td><code id="plsFit_+3A_digits">digits</code></td>
<td>
<p>the number of decimal place to output with <code>summary.mvdareg</code></p>
</td></tr>
<tr><td><code id="plsFit_+3A_...">...</code></td>
<td>
<p> additional arguments, passed to the underlying fit functions, and <code>mvdareg</code>. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a partial least squares (PLS) model with 1, ..., <code>ncomp</code> number of latent variables. Multi-response models are not supported.
</p>
<p>The type of model to fit is specified with the method argument. Currently two PLS algorithms are available: the bigiag2 algorithm (&quot;bigiagpls&quot; and &quot;wrtpls&quot;).
</p>
<p>The formula argument should be a symbolic formula of the form response ~ terms, where response is the name of the response vector and terms is the name of one or more predictor matrices, usually separated by +, e.g., y ~ X + Z. See <code><a href="stats.html#topic+lm">lm</a></code> for a detailed description. The named variables should exist in the supplied data data frame or in the global environment. The chapter Statistical models in R of the manual An Introduction to R distributed with R is a good reference on formulas in R.
</p>
<p>The number of components to fit is specified with the argument <code>ncomp</code>. It this is not supplied, the maximal number of components is used.
</p>
<p>Note that if the number of samples is &lt;= 15, oob validation may fail.  It is recommended that you PLS with <code>validation = "loo"</code>.
</p>
<p>If <code>method = "bidiagpls"</code> and <code>validation = "oob"</code>, bootstrap cross-validation is performed. Bootstrap confidence intervals are provided for <code><a href="stats.html#topic+coefficients">coefficients</a></code>, <code>weights</code>, <code>loadings</code>, and <code>y.loadings</code>.  The number of bootstrap samples is specified with the argument <code>boots</code>. See <code>mvdaboot</code> for details.
</p>
<p>If <code>method = "bidiagpls"</code> and <code>validation = "loo"</code>, leave-one-out cross-validation is performed.
</p>
<p>If <code>method = "bidiagpls"</code> and <code>validation = "none"</code>, no cross-validation is performed.  Note that the number of components, <code>ncomp</code>, is set to <code>min(nobj - 1, npred)</code>
</p>
<p>If <code>method = "wrtpls"</code> and <code>validation = "none"</code>, The Weight Randomization Test for the selection of the number of components is performed.  Note that the number of components, <code>ncomp</code>, is set to <code>min(nobj - 1, npred)</code>
</p>


<h3>Value</h3>

<p>An object of class <code>mvdareg</code> is returned. The object contains all components returned by the underlying fit function. In addition, it contains the following:
</p>
<table role = "presentation">
<tr><td><code>loadings</code></td>
<td>
<p> X loadings </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> weights </p>
</td></tr>
<tr><td><code>D2.values</code></td>
<td>
<p> bidiag2 matrix </p>
</td></tr>
<tr><td><code>iD2</code></td>
<td>
<p> inverse of bidiag2 matrix </p>
</td></tr>
<tr><td><code>Ymean</code></td>
<td>
<p> mean of reponse variable </p>
</td></tr>
<tr><td><code>Xmeans</code></td>
<td>
<p> mean of predictor variables </p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> PLS regression coefficients </p>
</td></tr>
<tr><td><code>y.loadings</code></td>
<td>
<p> y-loadings </p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p> X scores </p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p> orthogonal weights </p>
</td></tr>
<tr><td><code>Y.values</code></td>
<td>
<p> scaled response values </p>
</td></tr>
<tr><td><code>Yactual</code></td>
<td>
<p> actual response values </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> fitted values </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> residuals </p>
</td></tr>
<tr><td><code>Xdata</code></td>
<td>
<p> X matrix </p>
</td></tr>
<tr><td><code>iPreds</code></td>
<td>
<p> predicted values </p>
</td></tr>
<tr><td><code>y.loadings2</code></td>
<td>
<p> scaled y-loadings </p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p> number of latent variables </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> PLS algorithm used </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p> scaling used </p>
</td></tr>
<tr><td><code>validation</code></td>
<td>
<p> validation method </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> model call </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> model terms </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> fitted model </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>), Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>)</p>


<h3>References</h3>

<p>NOTE: This function is adapted from <code>mvr</code> in package <span class="pkg">pls</span> with extensive modifications by Nelson Lee Afanador and Thanh Tran.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bidiagpls.fit">bidiagpls.fit</a></code>, <code><a href="#topic+mvdaboot">mvdaboot</a></code>, <code><a href="#topic+boot.plots">boot.plots</a></code>,
<code><a href="#topic+R2s">R2s</a></code>, <code><a href="#topic+PE">PE</a></code>, <code><a href="#topic+ap.plot">ap.plot</a></code>,
<code><a href="#topic+T2">T2</a></code>, <code><a href="#topic+Xresids">Xresids</a></code>, <code><a href="#topic+smc">smc</a></code>,
<code><a href="#topic+scoresplot">scoresplot</a></code>, <code><a href="#topic+ScoreContrib">ScoreContrib</a></code>, <code><a href="#topic+sr">sr</a></code>,
<code><a href="#topic+loadingsplot">loadingsplot</a></code>, <code><a href="#topic+weightsplot">weightsplot</a></code>, <code><a href="#topic+coefsplot">coefsplot</a></code>,
<code><a href="#topic+coefficientsplot2D">coefficientsplot2D</a></code>, <code><a href="#topic+loadingsplot2D">loadingsplot2D</a></code>,
<code><a href="#topic+weightsplot2D">weightsplot2D</a></code>, 
<code><a href="#topic+bca.cis">bca.cis</a></code>, <code><a href="#topic+coefficients.boots">coefficients.boots</a></code>, <code><a href="#topic+loadings.boots">loadings.boots</a></code>,
<code><a href="#topic+weight.boots">weight.boots</a></code>, <code><a href="stats.html#topic+coefficients">coefficients</a></code>, <code><a href="stats.html#topic+loadings">loadings</a></code>,
<code><a href="stats.html#topic+weights">weights</a></code>, <code><a href="#topic+BiPlot">BiPlot</a></code>, <code><a href="#topic+jk.after.boot">jk.after.boot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>###  PLS MODEL FIT WITH method = 'bidiagpls' and validation = 'oob', i.e. bootstrapping ###
data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], method = "bidiagpls",
               ncomp = 2, validation = "oob", boots = 300)
summary(mod1) #Model summary

###  PLS MODEL FIT WITH method = 'bidiagpls' and validation = 'loo', i.e. leave-one-out CV ###
## Not run: 
mod2 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], method = "bidiagpls",
               ncomp = 2, validation = "loo")
summary(mod2) #Model summary

## End(Not run)

###  PLS MODEL FIT WITH method = 'bidiagpls' and validation = 'none', i.e. no CV is performed ###
## Not run: 
mod3 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], method = "bidiagpls",
               ncomp = 2, validation = "none")
summary(mod3) #Model summary

## End(Not run)
###  PLS MODEL FIT WITH method = 'wrtpls' and validation = 'none', i.e. WRT-PLS is performed ###
## Not run: 
mod4 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               method = "wrtpls", validation = "none")
summary(mod4) #Model summary
plot.wrtpls(mod4)

## End(Not run)
</code></pre>

<hr>
<h2 id='plusminus.fit'>PlusMinus (Mas-o-Menos)</h2><span id='topic+plusminus.fit'></span>

<h3>Description</h3>

<p>Plus-Minus classifier</p>


<h3>Usage</h3>

<pre><code class='language-R'>plusminus.fit(XX, YY, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plusminus.fit_+3A_xx">XX</code></td>
<td>
<p> a matrix of observations. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="plusminus.fit_+3A_yy">YY</code></td>
<td>
<p> a vector. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="plusminus.fit_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly, but through <code>plusminusFit</code> with the argument <code>method="plusminus"</code>. It implements the Plus-Minus algorithm.  
</p>


<h3>Value</h3>

<p>An object of class <code>plusminus</code> is returned. The object contains all components returned by the underlying fit function. In addition, it contains the following:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p> regression coefficients </p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p> response values </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p> scaled predictors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard Baumgartner (<a href="mailto:richard_baumgartner@merck.com">richard_baumgartner@merck.com</a>), Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Zhao et al. (2014) Mas-o-menos: a simple sign averaging method for discriminationin genomic data analysis. Bioinformatics, 30(21):3062-3069.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plusminusFit">plusminusFit</a></code></p>

<hr>
<h2 id='plusminus.loo'>Leave-one-out routine for <code>plusminus</code> objects</h2><span id='topic+plusminus.loo'></span>

<h3>Description</h3>

<p>When <code>validation = 'loo'</code> this routine effects the leave-one-out cross-validation procedure for <code>plusminus</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plusminus.loo(X, Y, method = "plusminus", n_cores, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plusminus.loo_+3A_x">X</code></td>
<td>
<p> a matrix of observations. <code>NAs</code> and Infs are not allowed. </p>
</td></tr>
<tr><td><code id="plusminus.loo_+3A_y">Y</code></td>
<td>
<p> a vector. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="plusminus.loo_+3A_method">method</code></td>
<td>
<p> PlusMinus algorithm used </p>
</td></tr>
<tr><td><code id="plusminus.loo_+3A_n_cores">n_cores</code></td>
<td>
<p> number of cores </p>
</td></tr>
<tr><td><code id="plusminus.loo_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly, but through the generic function <code>plusminusFit</code> with the argument <code>validation = 'loo'</code>.
</p>


<h3>Value</h3>

<p>Provides the following crossvalideted results as a list for <code>plusminus</code> objects:
</p>
<table role = "presentation">
<tr><td><code>cvError</code></td>
<td>
<p> leave-one-out estimate of cv error. </p>
</td></tr>
<tr><td><code>in.bag</code></td>
<td>
<p> leave-one-out samples used for model building. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard Baumgartner (<a href="mailto:richard_baumgartner@merck.com">richard_baumgartner@merck.com</a>), Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>NOTE: This function is adapted from <code>mvr</code> in package <span class="pkg">pls</span> with extensive modifications by Nelson Lee Afanador and Thanh Tran.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plusminusFit">plusminusFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(plusMinusDat)
mod1 &lt;- plusminusFit(Y ~., data = plusMinusDat, validation = "loo", n_cores = 2)
## Not run: 
summary(mod1)
mod1$validation$cvError
mod1$validation$in.bag

## End(Not run)
</code></pre>

<hr>
<h2 id='plusMinusDat'>
plusMinusDat data set
</h2><span id='topic+plusMinusDat'></span>

<h3>Description</h3>

<p>A simulated dataset for demonstrating the performance of a <code>plusminusFit</code> analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plusMinusDat</code></pre>


<h3>Format</h3>

<p>A data frame with 201 observations, 200 input variables (X) and one response variable (Y).
</p>


<h3>Source</h3>

<p>Richard Baumgartner (<a href="mailto:richard_baumgartner@merck.com">richard_baumgartner@merck.com</a>)
</p>

<hr>
<h2 id='plusminusFit'>Plus-Minus (Mas-o-Menos) Classifier</h2><span id='topic+plusminusFit'></span><span id='topic+summary.plusminus'></span><span id='topic+summary.plusminus.default'></span>

<h3>Description</h3>

<p>Functions to perform plus-minus classifier with a formula interface. Leave one out crossvalidation also implemented. Model extraction, plot, print and summary methods are also implemented.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plusminusFit(formula, data, subset, na.action, method = "plusminus", n_cores = 2,
                         validation = c("loo", "none"), model = TRUE,
                         x = FALSE, y = FALSE, ...)

## S3 method for class 'plusminus'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plusminusFit_+3A_formula">formula</code></td>
<td>
<p> a model formula (see below). </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_data">data</code></td>
<td>
<p> an optional data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be used in the fitting process. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data contain <code>NAs</code>. The default is set by the <code>na.action</code> setting of options, and is <code>na.fail</code> if that is unset. The default is <code>na.omit</code>. Another possible value is <code>NULL</code>, no action. Value <code>na.exclude</code> can be useful. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_method">method</code></td>
<td>
<p> the classification algorithm to be used. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_n_cores">n_cores</code></td>
<td>
<p> Number of cores to run for parallel processing.  Currently set to 2 with the max being 4. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_validation">validation</code></td>
<td>
<p> character. What kind of (internal) validation to use. See below. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_model">model</code></td>
<td>
<p> an optional data frame containing the variables in the model. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_x">x</code></td>
<td>
<p> a logical. If TRUE, the model matrix is returned. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_y">y</code></td>
<td>
<p> a logical. If TRUE, the response is returned. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_object">object</code></td>
<td>
<p> an object of class <code>"plusminus"</code>, i.e., a fitted model. </p>
</td></tr>
<tr><td><code id="plusminusFit_+3A_...">...</code></td>
<td>
<p> additional arguments, passed to the underlying fit functions, and <code>plusminus</code>. Currently not in use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits a Plus-Minus classifier.
</p>
<p>The formula argument should be a symbolic formula of the form response ~ terms, where response is the name of the response vector and terms is the name of one or more predictor matrices, usually separated by +, e.g., y ~ X + Z. See <code><a href="stats.html#topic+lm">lm</a></code> for a detailed description. The named variables should exist in the supplied data data frame or in the global environment. The chapter Statistical models in R of the manual An Introduction to R distributed with R is a good reference on formulas in R.
</p>
<p>If <code>validation = "loo"</code>, leave-one-out cross-validation is performed. If <code>validation = "none"</code>, no cross-validation is performed.
</p>


<h3>Value</h3>

<p>An object of class <code>plusminus</code> is returned. The object contains all components returned by the underlying fit function. In addition, it contains the following:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>Plus-Minus regression coefficients </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p> X matrix </p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p> actual response values (class labels)</p>
</td></tr>
<tr><td><code>val.method</code></td>
<td>
<p> validation method </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> model call </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> model terms </p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p>model matrix</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> fitted model </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard Baumgartner (<a href="mailto:richard_baumgartner@merck.com">richard_baumgartner@merck.com</a>), Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Zhao et al.: Mas-o-menos: a simple sign averaging method for discriminationin genomic data analysis. Bioinformatics, 30(21):3062-3069,2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plusminus.fit">plusminus.fit</a></code>, <code><a href="#topic+plusminus.loo">plusminus.loo</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>###  PLUS-Minus CLASSIFIER WITH validation = 'none', i.e. no CV ###
data(plusMinusDat)
mod1 &lt;- plusminusFit(Y ~., data = plusMinusDat, validation = "none", n_cores = 2)
summary(mod1)

###  Plus-Minus CLASSIFIER WITH validation = 'loo', i.e. leave-one-out CV ###
## Not run: 
data(plusMinusDat)
mod2 &lt;- plusminusFit(Y ~., data = plusMinusDat, validation = "loo", n_cores = 2)
summary(mod2)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.mvdareg'>Model Predictions From a plsFit Model</h2><span id='topic+predict.mvdareg'></span>

<h3>Description</h3>

<p><code>predict</code> provides predictions from the results of a pls model.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
predict(object, newdata, ncomp = object$ncomp,
            na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mvdareg_+3A_object">object</code></td>
<td>
<p> A <code>plsFit</code> model. </p>
</td></tr>
<tr><td><code id="predict.mvdareg_+3A_newdata">newdata</code></td>
<td>
<p> An optional data frame in which to look for variables with which to predict. If omitted, the fitted values are used. </p>
</td></tr>
<tr><td><code id="predict.mvdareg_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="predict.mvdareg_+3A_na.action">na.action</code></td>
<td>
<p> function determining what should be done with missing values in newdata. The default is to predict <code>NA</code>. </p>
</td></tr>
<tr><td><code id="predict.mvdareg_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.mvdareg</code> produces predicted values, obtained by evaluating the regression function in the frame newdata (which defaults to model.frame(object).  If <code>newdata</code> is omitted the predictions are based on the data used for the fit.
</p>
<p>If <code>comps</code> is missing (or is NULL), predictions of the number of latent variables is provided.   Otherwise, if <code>comps</code> is given parameters for a model with only the requested components is returned. The generic function <code>residuals</code> return the model residuals for all the components specified for the model. If the model was fitted with na.action = na.exclude (or after setting the default na.action to <code>na.exclude</code> with options), the residuals corresponding to excluded observations are returned as NA; otherwise, they are omitted.
</p>


<h3>Value</h3>

<p><code>predict.mvdareg</code> produces a vector of predictions or a matrix of predictions
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>NOTE: This function is adapted from <code>mvr</code> in package <span class="pkg">pls</span> with extensive modifications by Nelson Lee Afanador.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="#topic+coefficients.boots">coefficients.boots</a></code>, <code><a href="stats.html#topic+coefficients">coefficients</a></code>,
<code><a href="stats.html#topic+loadings">loadings</a></code>, <code><a href="#topic+loadings.boots">loadings.boots</a></code>, <code><a href="stats.html#topic+weights">weights</a></code>,
<code><a href="#topic+weight.boots">weight.boots</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
predict.mvdareg(mod1)
## Not run: 
residuals(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.mvdalab'>Print Methods for mvdalab Objects</h2><span id='topic+print.mvdareg'></span>

<h3>Description</h3>

<p>Summary and print methods for mvdalab objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mvdalab_+3A_x">x</code></td>
<td>
<p> an mvdalab object </p>
</td></tr>
<tr><td><code id="print.mvdalab_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.mvdalab</code> Is a generic function used to print mvdalab objects, such as <code>print.empca</code> for <code>imputeEM</code>, <code>print.mvdapca</code> for <code>mvdapca</code> objects, and <code>summary.mvdareg</code> for <code>mvdareg</code> objects.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "loo")
print(mod1, ncomp = 2)
summary(mod1, ncomp = 2)
</code></pre>

<hr>
<h2 id='print.plusminus'>Print Methods for plusminus Objects</h2><span id='topic+print.plusminus'></span>

<h3>Description</h3>

<p>Summary and print methods for plusminus objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'plusminus'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.plusminus_+3A_x">x</code></td>
<td>
<p> an plusminus object </p>
</td></tr>
<tr><td><code id="print.plusminus_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.plusminus</code> Is a generic function used to print plusminus objects, such as <code>print.plusminus</code> for <code>plusminus</code> objects.
</p>


<h3>Author(s)</h3>

<p>Richard Baumgartner (<a href="mailto:richard_baumgartner@merck.com">richard_baumgartner@merck.com</a>), Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(plusMinusDat)
mod1 &lt;- plusminusFit(Y ~., data = plusMinusDat, validation = "loo", n_cores = 2)
print(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='proCrustes'>Comparison of n-point Configurations vis Procrustes Analysis</h2><span id='topic+proCrustes'></span><span id='topic+print.proC'></span>

<h3>Description</h3>

<p>Implementation of Procrustes Analysis in the spirit of multidimensional scaling.</p>


<h3>Usage</h3>

<pre><code class='language-R'>proCrustes(X, Y, scaling = TRUE, standardize = FALSE, scale.unit = F, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="proCrustes_+3A_x">X</code></td>
<td>
<p> Target configuration </p>
</td></tr>
<tr><td><code id="proCrustes_+3A_y">Y</code></td>
<td>
<p> Matching configuration </p>
</td></tr>
<tr><td><code id="proCrustes_+3A_scaling">scaling</code></td>
<td>
<p> Scale Y-axis </p>
</td></tr>
<tr><td><code id="proCrustes_+3A_standardize">standardize</code></td>
<td>
<p>Standardize configurations</p>
</td></tr>
<tr><td><code id="proCrustes_+3A_scale.unit">scale.unit</code></td>
<td>
<p>Scale to unit variance</p>
</td></tr>
<tr><td><code id="proCrustes_+3A_...">...</code></td>
<td>
<p>additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements Procrustes Analysis as described in the reference below.  That is to say:
</p>
<p>Translation:  Fixed displacement of points through a constant distance in a common direction
</p>
<p>Rotation:  Fixed displacement of all points through a constant angle
</p>
<p>Dilation:  Stretching or shrinking by a contant amount
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Rotation.Matrix</code></td>
<td>
<p> The matrix, Q, that rotates Y towards X; obtained via <code>svd</code> of X'Y </p>
</td></tr>
<tr><td><code>Residuals</code></td>
<td>
<p> residuals after fitting </p>
</td></tr>
<tr><td><code>M2_min</code></td>
<td>
<p> Residual Sums of Squares </p>
</td></tr>
<tr><td><code>Xmeans</code></td>
<td>
<p> Column Means of X </p>
</td></tr>
<tr><td><code>Ymeans</code></td>
<td>
<p> Column Means of Y </p>
</td></tr>
<tr><td><code>PRMSE</code></td>
<td>
<p> Procrustes Root Mean Square Error </p>
</td></tr>
<tr><td><code>Yproj</code></td>
<td>
<p> Projected Y-values </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p> logical.  Should Y be scaled. </p>
</td></tr>
<tr><td><code>Translation</code></td>
<td>
<p> Scaling through a common distance based on rotation of Y and scaling parameter, c </p>
</td></tr>
<tr><td><code>residuals.</code></td>
<td>
<p> residual sum-of-squares </p>
</td></tr>
<tr><td><code>Anova.MSS</code></td>
<td>
<p> Explained Variance w.r.t. Y </p>
</td></tr>
<tr><td><code>Anova.ESS</code></td>
<td>
<p> Unexplained Variance w.r.t. Y </p>
</td></tr>
<tr><td><code>Anova.TSS</code></td>
<td>
<p> Total Sums of Squares w.r.t. X </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Krzanowski, Wojtek. Principles of multivariate analysis. OUP Oxford, 2000.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[, 1:2]
Y &lt;- iris[, 3:4]

proc &lt;- proCrustes(X, Y)
proc
names(proc)
</code></pre>

<hr>
<h2 id='R2s'>Cross-validated R2, R2 for X, and R2 for Y for PLS models</h2><span id='topic+R2s'></span><span id='topic+print.R2s'></span>

<h3>Description</h3>

<p>Functions to report the cross-validated R2 (CVR2), explained variance in the predictor variables (R2X), and the reponse (R2Y) for PLS models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2s(object)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="R2s_+3A_object">object</code></td>
<td>
<p> an mvdareg object, i.e., <code>plsFit</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>R2s</code> is used to extract a summary of the cross-validated R2 (CVR2), explained variance in the predictor variables (R2X), and the reponse (R2Y) for PLS models.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
R2s(mod1)
## Not run: 
plot(R2s(mod1))

## End(Not run)
</code></pre>

<hr>
<h2 id='ScoreContrib'>Generates a score contribution plot</h2><span id='topic+ScoreContrib'></span>

<h3>Description</h3>

<p>Generates a the Score Contribution Graph both <code>mvdareg</code> and <code>mvdapca</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ScoreContrib(object, ncomp = 1:object$ncomp, obs1 = 1, obs2 = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScoreContrib_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code> or <code>mvdapca</code>. </p>
</td></tr>
<tr><td><code id="ScoreContrib_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="ScoreContrib_+3A_obs1">obs1</code></td>
<td>
<p> the first observaion(s) in the score(s) comparison. </p>
</td></tr>
<tr><td><code id="ScoreContrib_+3A_obs2">obs2</code></td>
<td>
<p> the second observaion(s) in the score(s) comparison. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ScoreContrib</code> is used to generates the score contributions for both PLS and PCA models.  Up to two groups of score(s) can be selected.  If only one group is selected, the contribution is measured to the model average.  For PLS models the PCA loadings are replaced with the PLS weights.
</p>


<h3>Value</h3>

<p>The output of <code>ScoreContrib</code> is a matrix of score contributions for the specified observation(s).
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>MacGregor, Process Monitoring and Diagnosis by Multiblock PLS Methods, May 1994 Vol. 40, No. 5 AIChE Journal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "none")
Score.Contributions1 &lt;- ScoreContrib(mod1, ncomp = 1:2, obs1 = 1, obs2 = 3)
plot(Score.Contributions1, ncomp = 2)

## Not run: 
data(Penta)
mod2 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "none")
Score.Contributions2 &lt;- ScoreContrib(mod2, obs1 = 1, obs2 = 3)
plot(Score.Contributions2)
Score.Contributions3 &lt;- ScoreContrib(mod1, obs1 = c(1, 3), obs2 = c(5:10))
plot(Score.Contributions3)

## End(Not run)

###  PLS MODEL FIT WITH method = 'wrtpls' and validation = 'none', i.e. WRT-PLS is performed ###
## Not run: 
mod3 &lt;- plsFit(Sepal.Length ~., scale = TRUE, data = iris,
               method = "wrtpls", validation = "none") #ncomp is ignored
Score.Contributions4 &lt;- ScoreContrib(mod3, ncomp = 1:5, obs1 = 1, obs2 = 3)
plot(Score.Contributions4, ncomp = 5)

## End(Not run)

#PCA Model
pc1 &lt;- pcaFit(Penta[, -1], ncomp = 2)
Score.Contributions1 &lt;- ScoreContrib(pc1, obs1 = 1, obs2 = 3)
plot(Score.Contributions1)
</code></pre>

<hr>
<h2 id='scoresplot'>2D Graph of the scores</h2><span id='topic+scoresplot'></span>

<h3>Description</h3>

<p>Generates a 2-dimensional graph of the scores for both <code>mvdareg</code> and <code>mvdapca</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoresplot(object, comps = c(1, 2), alphas = c(.95, .99),
           segments = 51, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoresplot_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code>, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="scoresplot_+3A_comps">comps</code></td>
<td>
<p> a vector or length 2 corresponding to the number of components to include. </p>
</td></tr>
<tr><td><code id="scoresplot_+3A_alphas">alphas</code></td>
<td>
<p> draw elliptical contours at these confidence levels. </p>
</td></tr>
<tr><td><code id="scoresplot_+3A_segments">segments</code></td>
<td>
<p> number of line-segments used to draw ellipse. </p>
</td></tr>
<tr><td><code id="scoresplot_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scoresplot</code> is used to extract a 2D graphical summary of the scores of PLS and PCA models.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
scoresplot(mod1, comp = c(1, 2))
</code></pre>

<hr>
<h2 id='SeqimputeEM'>Sequential Expectation Maximization (EM) for imputation of missing values.</h2><span id='topic+SeqimputeEM'></span><span id='topic+print.seqem'></span>

<h3>Description</h3>

<p>Missing values are sequentially updated via an EM algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>SeqimputeEM(data, max.ncomps = 5, max.ssq = 0.99, Init = "mean", 
            adjmean = FALSE, max.iters = 200, 
            tol = .Machine$double.eps^0.25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SeqimputeEM_+3A_data">data</code></td>
<td>
<p> a dataset with missing values. </p>
</td></tr>
<tr><td><code id="SeqimputeEM_+3A_max.ncomps">max.ncomps</code></td>
<td>
<p> integer corresponding to the maximum number of components to test </p>
</td></tr>
<tr><td><code id="SeqimputeEM_+3A_max.ssq">max.ssq</code></td>
<td>
<p> maximal SSQ for final number of components. This will be improved by automation.  </p>
</td></tr>
<tr><td><code id="SeqimputeEM_+3A_init">Init</code></td>
<td>
<p> For continous variables impute either the mean or median. </p>
</td></tr>
<tr><td><code id="SeqimputeEM_+3A_adjmean">adjmean</code></td>
<td>
<p> Adjust (recalculate) mean after each iteration. </p>
</td></tr>
<tr><td><code id="SeqimputeEM_+3A_max.iters">max.iters</code></td>
<td>
<p> maximum number of iterations for the algorithm. </p>
</td></tr>
<tr><td><code id="SeqimputeEM_+3A_tol">tol</code></td>
<td>
<p> the threshold for assessing convergence. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A completed data frame is returned that mirrors the model matrix. <code>NAs</code> are replaced with convergence values as obtained via Seqential EM algorithm. If object contains no <code>NAs</code>, it is returned unaltered.  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Imputed.DataFrames</code></td>
<td>
<p> A list of imputed data frames across <code>impute.comps</code> </p>
</td></tr>
<tr><td><code>ncomps</code></td>
<td>
<p> number of components to test </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>), Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>NOTE: Publication Pending
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- introNAs(iris, percent = 25)
SeqimputeEM(dat)
</code></pre>

<hr>
<h2 id='smc'>Significant Multivariate Correlation</h2><span id='topic+smc'></span><span id='topic+print.smc'></span><span id='topic+smc.error'></span><span id='topic+smc.modeled'></span>

<h3>Description</h3>

<p>This function calculates the significant multivariate correlation (<code>smc</code>) metric for an <code>mvdareg</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>smc(object, ncomps = object$ncomp, corrected = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smc_+3A_object">object</code></td>
<td>
<p> an mvdareg or mvdapaca object, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="smc_+3A_ncomps">ncomps</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="smc_+3A_corrected">corrected</code></td>
<td>
<p> whether there should be a correction of 1st order auto-correlation in the residuals. </p>
</td></tr>
</table>
<p>Note that hidden objects include the smc modeled matrix and error matrices
</p>


<h3>Details</h3>

<p><code>smc</code> is used to extract a summary of the significant multivariae correlation of a PLS model.
</p>
<p>If <code>comps</code> is missing (or is <code>NULL</code>), summaries for all <code>smc</code> estimates are returned. Otherwise, if comps are given parameters for a model with only the requested component comps is returned.
</p>


<h3>Value</h3>

<p>The output of <code>smc</code> is an <code>smc summary</code> detailing the following:
</p>
<table role = "presentation">
<tr><td><code>smc</code></td>
<td>
<p> significant multivariate correlation statistic (<code>smc</code>).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> p-value of the smc statistic. </p>
</td></tr>
<tr><td><code>f.value</code></td>
<td>
<p> f-value of the smc statistic. </p>
</td></tr>
<tr><td><code>Significant</code></td>
<td>
<p> Assessment of statistical significance. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Thanh N. Tran, Nelson Lee Afanador, Lutgarde M.C. Buydens, Lionel Blanchet, Interpretation of variable importance in Partial Least Squares with Significance Multivariate Correlation (sMC). Chemom. Intell. Lab. Syst. 2014; 138: 153:160.
</p>
<p>Nelson Lee Afanador, Thanh N. Tran, Lionel Blanchet, Lutgarde M.C. Buydens, Variable importance in PLS in the presence of autocorrelated data - Case studies in manufacturing processes. Chemom. Intell. Lab. Syst. 2014; 139: 139:145.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smc.acfTest">smc.acfTest</a></code>, <code><a href="#topic+sr">sr</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
smc(mod1)
plot(smc(mod1))

###  PLS MODEL FIT WITH method = 'wrtpls' and validation = 'none', i.e. WRT-PLS is performed ###
## Not run: 
mod2 &lt;- plsFit(Sepal.Length ~., scale = TRUE, data = iris,
               method = "wrtpls", validation = "none") #ncomp is ignored
plot(smc(mod2, ncomps = 2))

## End(Not run)

</code></pre>

<hr>
<h2 id='smc.acfTest'>Test of the Residual Significant Multivariate Correlation Matrix for the presence of Autocorrelation</h2><span id='topic+smc.acfTest'></span>

<h3>Description</h3>

<p>This function peforms a 1st order test of the Residual Significant Multivariate Correlation Matrix in order to help determine if the <code>smc</code> should be performed correcting for 1st order autocorrelation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>smc.acfTest(object, ncomp = object$ncomp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smc.acfTest_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code>, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="smc.acfTest_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the acf assessment </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a test for 1st order auto correlation in the <code>smc</code> residual matrix.
</p>


<h3>Value</h3>

<p>The output of <code>smc.acfTest</code> is a list detailing the following:
</p>
<table role = "presentation">
<tr><td><code>variable</code></td>
<td>
<p> variable for whom the test is being performed </p>
</td></tr>
<tr><td><code>ACF</code></td>
<td>
<p> value of the 1st lag of the ACF </p>
</td></tr>
<tr><td><code>Significant</code></td>
<td>
<p> Assessment of the statistical significance of the 1st order lag </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Thanh N. Tran, Nelson Lee Afanador, Lutgarde M.C. Buydens, Lionel Blanchet, Interpretation of variable importance in Partial Least Squares with Significance Multivariate Correlation (sMC). Chemom. Intell. Lab. Syst. 2014; 138: 153:160.
</p>
<p>Nelson Lee Afanador, Thanh N. Tran, Lionel Blanchet, Lutgarde M.C. Buydens, Variable importance in PLS in the presence of autocorrelated data - Case studies in manufacturing processes. Chemom. Intell. Lab. Syst. 2014; 139: 139:145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "loo")
smc.acfTest(mod1, ncomp = 2)
</code></pre>

<hr>
<h2 id='sr'>Selectivity Ratio</h2><span id='topic+sr'></span><span id='topic+print.sr'></span><span id='topic+sr.error'></span><span id='topic+sr.modeled'></span>

<h3>Description</h3>

<p>This function calculates the Selectivity Ratio (<code>sr</code>) metric for an <code>mvdareg</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>sr(object, ncomps = object$ncomp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sr_+3A_object">object</code></td>
<td>
<p> an mvdareg or mvdapaca object, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="sr_+3A_ncomps">ncomps</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sr</code> is used to extract a summary of the significant multivariae correlation of a PLS model.
</p>
<p>If <code>comps</code> is missing (or is <code>NULL</code>), summaries for all <code>sr</code> estimates are returned. Otherwise, if comps are given parameters for a model with only the requested component comps is returned.
</p>


<h3>Value</h3>

<p>The output of <code>sr</code> is an <code>sr summary</code> detailing the following:
</p>
<table role = "presentation">
<tr><td><code>sr</code></td>
<td>
<p> selectivity ratio statistic (<code>sr</code>).</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> p-value of the sr statistic. </p>
</td></tr>
<tr><td><code>f.value</code></td>
<td>
<p> f-value of the sr statistic. </p>
</td></tr>
<tr><td><code>Significant</code></td>
<td>
<p> Assessment of statistical significance. </p>
</td></tr>
</table>
<p>Note that hidden objects include the SR modeled matrix and error matrices.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>O.M. Kvalheim, T.V. Karstang, Interpretation of latent-variable regression models. Chemom. Intell. Lab. Syst., 7 (1989), pp. 39:51
</p>
<p>O.M. Kvalheim, Interpretation of partial least squares regression models by means of target projection and selectivity ratio plots. J. Chemom., 24 (2010), pp. 496:504
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smc">smc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
sr(mod1)
plot(sr(mod1))

## Not run: 
mod2 &lt;- plsFit(Sepal.Length ~., scale = TRUE, data = iris,
               method = "wrtpls", validation = "none") #ncomp is ignored
plot(sr(mod2, ncomps = 2))

## End(Not run)
</code></pre>

<hr>
<h2 id='T2'>Generates a Hotelling's T2 Graph</h2><span id='topic+T2'></span>

<h3>Description</h3>

<p>Generates a Hotelling's T2 Graph both <code>mvdareg</code> and <code>mvdapca</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>T2(object, ncomp = object$ncomp, phase = 1, conf = c(.95, .99), verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="T2_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code> or <code>mvdapca</code>. </p>
</td></tr>
<tr><td><code id="T2_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the calculation of Hotelling's T2. </p>
</td></tr>
<tr><td><code id="T2_+3A_phase">phase</code></td>
<td>
<p> designates whether the confidence limits should reflect the current data frame, <code>phase = 1</code> or future observations, <code>phase = 2</code>. </p>
</td></tr>
<tr><td><code id="T2_+3A_conf">conf</code></td>
<td>
<p> the confidence level(s) to use for upper control limit. </p>
</td></tr>
<tr><td><code id="T2_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>T2</code> is used to generates a Hotelling's T2 graph both PLS and PCA models.
</p>


<h3>Value</h3>

<p>The output of <code>T2</code> is a graph of Hotelling's T2 and a data frame listing the T2 values.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Hotelling, H. (1931). &quot;The generalization of Student's ratio&quot;. Annals of Mathematical Statistics 2 (3): 360:378.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
T2(mod1, ncomp = 2)
</code></pre>

<hr>
<h2 id='Wang_Chen'>
Bivariate process data.
</h2><span id='topic+Wang_Chen'></span>

<h3>Description</h3>

<p>Twenty-five observations where 'H' represents brinell hardness and 'S' represents tensile strength.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wang_Chen</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations and the following 2 variables.
</p>

<dl>
<dt><code>H</code></dt><dd><p>brinell hardness</p>
</dd>
<dt><code>S</code></dt><dd><p>tensile strength</p>
</dd>
</dl>



<h3>Source</h3>

<p>Wang F, Chen J (1998). &quot;Capability index using principal components analysis.&quot; Quality Engineering, 11, 21-27.
</p>

<hr>
<h2 id='Wang_Chen_Sim'>
Simulated process data from a plastics manufacturer.
</h2><span id='topic+Wang_Chen_Sim'></span>

<h3>Description</h3>

<p>Fifty observations where 'D' represents depth, 'L' represents length, and 'W' represents width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wang_Chen_Sim</code></pre>


<h3>Format</h3>

<p>A simulated data frame with 50 observations and the following 3 variables.
</p>

<dl>
<dt><code>D</code></dt><dd><p>depth</p>
</dd>
<dt><code>L</code></dt><dd><p>length</p>
</dd>
<dt><code>W</code></dt><dd><p>width</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data simulated by Nelson Lee Afanador from average and covariance estimates provided in Wang F, Chen J (1998). &quot;Capability index using principal components analysis.&quot; Quality Engineering, 11, 21-27.
</p>

<hr>
<h2 id='weight.boots'>BCa Summaries for the weights of an mvdareg object</h2><span id='topic+weight.boots'></span>

<h3>Description</h3>

<p>Computes weights bootstrap BCa confidence intervals, along with expanded bootstrap summaries.</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight.boots(object, ncomp = object$ncomp, conf = .95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weight.boots_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code>, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="weight.boots_+3A_ncomp">ncomp</code></td>
<td>
<p> number of components in the model.</p>
</td></tr>
<tr><td><code id="weight.boots_+3A_conf">conf</code></td>
<td>
<p> desired confidence level. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function fits computes the bootstrap BCa confidence intervals for fitted <code>mvdareg</code> models where <code>valiation = "oob"</code>.
Should be used in instances in which there is reason to suspectd the percentile intervals.  Results provided across all latent variables or for specific latent variables via <code>ncomp</code>.
</p>


<h3>Value</h3>

<p>A weight.boots object contains component results for the following:
</p>
<table role = "presentation">
<tr><td><code>variable</code></td>
<td>
<p> variable names. </p>
</td></tr>
<tr><td><code>actual</code></td>
<td>
<p> Actual loading estimate using all the data. </p>
</td></tr>
<tr><td><code>BCa percentiles</code></td>
<td>
<p> confidence intervals. </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap. </p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> skewness of the bootstrap distribution. </p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p> estimate of bias w.r.t. the loading estimate. </p>
</td></tr>
<tr><td><code>Bootstrap Error</code></td>
<td>
<p> estimate of bootstrap standard error. </p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p> approximate 't-value' based on the <code>Bootstrap Error</code>. </p>
</td></tr>
<tr><td><code>bias t value</code></td>
<td>
<p> approximate 'bias t-value' based on the <code>Bootstrap Error</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. (1992) Jackknife-after-bootstrap standard errors and influence functions (with Discussion). Journal of the Royal Statistical Society, B, 54, 83:127.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
weight.boots(mod1, ncomp = 2, conf = .95)
</code></pre>

<hr>
<h2 id='weights'>Extract Summary Information Pertaining to the Bootstrapped weights</h2><span id='topic+weights.mvdareg'></span>

<h3>Description</h3>

<p>Functions to extract <code>weights</code> bootstrap information from <code>mvdalab</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvdareg'
weights(object, ncomp = object$ncomp, conf = .95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weights_+3A_object">object</code></td>
<td>
<p> an mvdareg or mvdapaca object, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="weights_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="weights_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
<tr><td><code id="weights_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weights</code> is used to extract a summary of the weights of a PLS.
If <code>ncomps</code> is missing (or is <code>NULL</code>), summaries for all regression estimates are returned.  Otherwise, if comps is given parameters for a model with only the requested component comps is returned.
</p>
<p>For mvdareg objects only, boostrap summaries provided are for actual regression weights, bootstrap percentiles, bootstrap mean, skewness, and bias.  These summaries can also be extracted using <code>weight.boots</code>
</p>


<h3>Value</h3>

<p>A weights object contains a data frame with columns:
</p>
<table role = "presentation">
<tr><td><code>variable</code></td>
<td>
<p> variable names. </p>
</td></tr>
<tr><td><code>Actual</code></td>
<td>
<p> Actual loading estimate using all the data. </p>
</td></tr>
<tr><td><code>BCa percentiles</code></td>
<td>
<p> confidence intervals. </p>
</td></tr>
<tr><td><code>boot.mean</code></td>
<td>
<p> mean of the bootstrap. </p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> skewness of the bootstrap distribution. </p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p> estimate of bias w.r.t. the loading estimate. </p>
</td></tr>
<tr><td><code>Bootstrap Error</code></td>
<td>
<p> estimate of bootstrap standard error. </p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p> approximate 't-value' based on the <code>Bootstrap Error</code>. </p>
</td></tr>
<tr><td><code>bias t value</code></td>
<td>
<p> approximate 'bias t-value' based on the <code>Bootstrap Error</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Davison, A.C. and Hinkley, D.V. (1997) Bootstrap Methods and Their Application. Cambridge University Press.
</p>
<p>Efron, B. (1992) Jackknife-after-bootstrap standard errors and influence functions (with Discussion). Journal of the Royal Statistical Society, B, 54, 83:127.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+weightsplot">weightsplot</a></code>, <code><a href="#topic+weight.boots">weight.boots</a></code>, <code><a href="#topic+weightsplot2D">weightsplot2D</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
weights(mod1, ncomp = 2, conf = .95)
</code></pre>

<hr>
<h2 id='weightsplot'>Extract Graphical Summary Information Pertaining to the Weights</h2><span id='topic+weightsplot'></span>

<h3>Description</h3>

<p>Functions to extract regression coefficient bootstrap information from <code>mvdalab</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsplot(object, ncomp = object$ncomp, conf = .95, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightsplot_+3A_object">object</code></td>
<td>
<p> an mvdareg object, i.e. <code>plsFit</code> </p>
</td></tr>
<tr><td><code id="weightsplot_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include. </p>
</td></tr>
<tr><td><code id="weightsplot_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
<tr><td><code id="weightsplot_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weightsplot</code> is used to extract a graphical summary of the weights of a PLS model.
</p>
<p>If <code>comps</code> is missing (or is <code>NULL</code>), a graphical summary for the nth component regression estimates are returned.  Otherwise, if comps is given parameters for a model with only the requested component <code>comps</code> is returned.
</p>
<p>Boostrap graphcal summaries provided are when <code>method = oob</code>.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "oob", boots = 300)
weightsplot(mod1, ncomp = 1:2)
</code></pre>

<hr>
<h2 id='weightsplot2D'>Extract a 2-Dimensional Graphical Summary Information Pertaining to the weights of a PLS Analysis</h2><span id='topic+weightsplot2D'></span>

<h3>Description</h3>

<p>Functions to extract 2D graphical weights information from <code>mvdalab</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>weightsplot2D(object, comps = c(1, 2), verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weightsplot2D_+3A_object">object</code></td>
<td>
<p> an mvdareg object, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="weightsplot2D_+3A_comps">comps</code></td>
<td>
<p> a vector or length 2 corresponding to the number of components to include.</p>
</td></tr> <tr><td><code id="weightsplot2D_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>weightsplot2D</code> is used to extract a graphical summary of the weights of a PLS model.
</p>
<p>If <code>comp</code> is missing (or is <code>NULL</code>), a graphical summary for the 1st and 2nd componentsare returned.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
weightsplot2D(mod1, comp = c(1, 2))
</code></pre>

<hr>
<h2 id='wrtpls.fit'>Weight Randomization Test PLS</h2><span id='topic+wrtpls.fit'></span>

<h3>Description</h3>

<p>Weight Randomization Test algorithm for PLS1</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrtpls.fit(X, Y, ncomp, perms, alpha, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrtpls.fit_+3A_x">X</code></td>
<td>
<p> a matrix of observations. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="wrtpls.fit_+3A_y">Y</code></td>
<td>
<p> a vector. <code>NAs</code> and <code>Infs</code> are not allowed. </p>
</td></tr>
<tr><td><code id="wrtpls.fit_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="wrtpls.fit_+3A_alpha">alpha</code></td>
<td>
<p> the significance level for <code>wrtpls</code> </p>
</td></tr>
<tr><td><code id="wrtpls.fit_+3A_perms">perms</code></td>
<td>
<p> the number of permutations to run for <code>wrtpls</code> </p>
</td></tr>
<tr><td><code id="wrtpls.fit_+3A_...">...</code></td>
<td>
<p> additional arguments.  Currently ignored. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should not be called directly, but through <code>plsFit</code> with the argument <code>method="wrtpls"</code>. It implements the Bidiag2 scores algorithm with a permutation test for selecting the statistically significant components.
</p>


<h3>Value</h3>

<p>An object of class <code>mvdareg</code> is returned. The object contains all components returned by the underlying fit function. In addition, it contains the following:
</p>
<table role = "presentation">
<tr><td><code>loadings</code></td>
<td>
<p> X loadings </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> weights </p>
</td></tr>
<tr><td><code>D2</code></td>
<td>
<p> bidiag2 matrix </p>
</td></tr>
<tr><td><code>iD2</code></td>
<td>
<p> inverse of bidiag2 matrix </p>
</td></tr>
<tr><td><code>Ymean</code></td>
<td>
<p> mean of reponse variable </p>
</td></tr>
<tr><td><code>Xmeans</code></td>
<td>
<p> mean of predictor variables </p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> regression coefficients </p>
</td></tr>
<tr><td><code>y.loadings</code></td>
<td>
<p> y-loadings </p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p> X scores </p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p> orthogonal weights </p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p> scaled response values </p>
</td></tr>
<tr><td><code>Yactual</code></td>
<td>
<p> actual response values </p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p> fitted values </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> residuals </p>
</td></tr>
<tr><td><code>Xdata</code></td>
<td>
<p> X matrix </p>
</td></tr>
<tr><td><code>iPreds</code></td>
<td>
<p> predicted values </p>
</td></tr>
<tr><td><code>y.loadings2</code></td>
<td>
<p> scaled y-loadings </p>
</td></tr>
<tr><td><code>wrtpls</code></td>
<td>
<p> permutations effected </p>
</td></tr>
<tr><td><code>wrtpls.out.Sig</code></td>
<td>
<p> Significant LVs </p>
</td></tr>
<tr><td><code>wrtpls.crit</code></td>
<td>
<p> weight critical values </p>
</td></tr>
<tr><td><code>actual.normwobs</code></td>
<td>
<p> normed weights </p>
</td></tr>
<tr><td><code>fit.time</code></td>
<td>
<p> model fitting time </p>
</td></tr>
<tr><td><code>val.method</code></td>
<td>
<p> validation method </p>
</td></tr>
<tr><td><code>ncomp</code></td>
<td>
<p> number of latent variables </p>
</td></tr>
<tr><td><code>perms</code></td>
<td>
<p> number of permutations performed </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p> permutation alpha value </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> PLS algorithm </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p> scaling used </p>
</td></tr>
<tr><td><code>scaled</code></td>
<td>
<p> was scaling performed </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> model call </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> model terms </p>
</td></tr>
<tr><td><code>mm</code></td>
<td>
<p> model matrix </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> fitted model </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>), Thanh Tran (<a href="mailto:thanh.tran@mvdalab.com">thanh.tran@mvdalab.com</a>)</p>


<h3>References</h3>

<p>Indahl, Ulf G., (2014) The geometry of PLS1 explained properly: 10 key notes on mathematical properties of and some alternative algorithmic approaches to PLS1 modeling. Journal of Chemometrics, 28, 168:180.
</p>
<p>Manne R., Analysis of two partial-least-squares algorithms for multi-variate calibration. Chemom. Intell. Lab. Syst. 1987; 2: 187:197.
</p>
<p>Thanh Tran, Ewa Szymanska, Jan Gerretzen, Lutgarde Buydens, Nelson Lee Afanador, Lionel Blanchet, Weight Randomization Test for the Selection of the Number of Components in PLS Models. Chemom. Intell. Lab. Syst., accepted for publication - Jan 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plsFit">plsFit</a></code></p>

<hr>
<h2 id='Xresids'>Generates a Graph of the X-residuals</h2><span id='topic+Xresids'></span>

<h3>Description</h3>

<p>Generates a graph of the X-residuals for both <code>mvdareg</code> and <code>mvdapca</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xresids(object, ncomp = object$ncomp, conf = c(.95, .99),
        normalized = TRUE, verbose = FALSE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Xresids_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code> or <code>mvdapca</code>. </p>
</td></tr>
<tr><td><code id="Xresids_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the calculation of the X-residuals. </p>
</td></tr>
<tr><td><code id="Xresids_+3A_conf">conf</code></td>
<td>
<p> the confidence level(s) to use for upper control limit. </p>
</td></tr>
<tr><td><code id="Xresids_+3A_normalized">normalized</code></td>
<td>
<p> should residuals be normalized </p>
</td></tr>
<tr><td><code id="Xresids_+3A_verbose">verbose</code></td>
<td>
<p> output results as a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Xresids</code> is used to generates a graph of the X-residuals for both PLS and PCA models.
</p>


<h3>Value</h3>

<p>The output of <code>Xresids</code> is a graph of X-residuals and a data frame listing the X-residuals values.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>MacGregor, Process Monitoring and Diagnosis by Multiblock PLS Methods, May 1994 Vol. 40, No. 5 AIChE Journal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
Xresids(mod1, ncomp = 2)
</code></pre>

<hr>
<h2 id='XresidualContrib'>Generates the squared prediction error contributions and contribution plot</h2><span id='topic+XresidualContrib'></span>

<h3>Description</h3>

<p>Generates the squared prediction error (SPE) contributions and graph both <code>mvdareg</code> and <code>mvdapca</code> objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>XresidualContrib(object, ncomp = object$ncomp, obs1 = 1)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="XresidualContrib_+3A_object">object</code></td>
<td>
<p> an object of class <code>mvdareg</code> or <code>mvdapca</code>. </p>
</td></tr>
<tr><td><code id="XresidualContrib_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the SPE calculation. </p>
</td></tr>
<tr><td><code id="XresidualContrib_+3A_obs1">obs1</code></td>
<td>
<p> the observaion in SPE assessment. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>XresidualContrib</code> is used to generates the squared prediction error (SPE) contributions and graph for both PLS and PCA models.  Only one observation at a time is supported.
</p>


<h3>Value</h3>

<p>The output of <code>XresidualContrib</code> is a matrix of score contributions for a specified observation and the corresponding graph.
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>References</h3>

<p>MacGregor, Process Monitoring and Diagnosis by Multiblock PLS Methods, May 1994 Vol. 40, No. 5 AIChE Journal
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1],
               ncomp = 2, validation = "loo")
XresidualContrib(mod1, ncomp = 2, obs1 = 3)

## Not run: 
#PCA Model
pc1 &lt;- pcaFit(Penta[, -1], ncomp = 4)
XresidualContrib(pc1, ncomp = 3, obs1 = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='y.loadings'>Extract Summary Information Pertaining to the y-loadings</h2><span id='topic+y.loadings'></span>

<h3>Description</h3>

<p>Functions to extract the y-loadings from mvdareg and mvdapca objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>y.loadings(object, conf = .95)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="y.loadings_+3A_object">object</code></td>
<td>
<p> an <code>mvdareg</code> or <code>mvdapaca</code> object, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="y.loadings_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y.loadings</code> is used to extract a summary of the y-loadings from a PLS or PCA model.
</p>
<p>If <code>comps</code> is missing (or is <code>NULL</code>), summaries for all regression estimates are returned.  Otherwise, if <code>comps</code> is provided the requested component comps are returned. 
</p>
<p>For <code>mvdareg</code> objects only, boostrap summaries provided are for actual regression <code>y.loadings</code>, bootstrap percentiles, bootstrap mean, skewness, and bias.  These summaries can also be extracted using <code>y.loadings.boots</code>
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "loo")
y.loadings(mod1)
</code></pre>

<hr>
<h2 id='y.loadings.boots'>Extract Summary Information Pertaining to the y-loadings</h2><span id='topic+y.loadings.boots'></span>

<h3>Description</h3>

<p>Functions to extract the y-loadings from mvdareg and mvdapca objects.</p>


<h3>Usage</h3>

<pre><code class='language-R'>y.loadings.boots(object, ncomp = object$ncomp, conf = 0.95)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="y.loadings.boots_+3A_object">object</code></td>
<td>
<p> an <code>mvdareg</code> or <code>mvdapaca</code> object, i.e. <code>plsFit</code>. </p>
</td></tr>
<tr><td><code id="y.loadings.boots_+3A_ncomp">ncomp</code></td>
<td>
<p> the number of components to include in the model (see below). </p>
</td></tr>
<tr><td><code id="y.loadings.boots_+3A_conf">conf</code></td>
<td>
<p> for a bootstrapped model, the confidence level to use. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y.loadings.boots</code> is used to extract a summary of the y-loadings from a PLS or PCA model.
</p>
<p>If <code>comps</code> is missing (or is <code>NULL</code>), summaries for all regression estimates are returned.  Otherwise, if <code>comps</code> is provided the requested component comps are returned. 
</p>
<p>For <code>mvdareg</code> objects only, boostrap summaries provided are for actual regression <code>y.loadings</code>, bootstrap percentiles, bootstrap mean, skewness, and bias.  These summaries can also be extracted using <code>y.loadings.boots</code>
</p>


<h3>Author(s)</h3>

<p>Nelson Lee Afanador (<a href="mailto:nelson.afanador@mvdalab.com">nelson.afanador@mvdalab.com</a>)</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Penta)
## Number of bootstraps set to 300 to demonstrate flexibility
## Use a minimum of 1000 (default) for results that support bootstraping
mod1 &lt;- plsFit(log.RAI ~., scale = TRUE, data = Penta[, -1], 
               ncomp = 2, validation = "oob", boots = 300)
y.loadings(mod1)
y.loadings.boots(mod1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
