<!DOCTYPE html><html><head><title>Help for package serp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {serp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AIC.serp'><p>AIC for a fitted serp object</p></a></li>
<li><a href='#anova.serp'><p>ANOVA method for a fitted serp object</p></a></li>
<li><a href='#BIC.serp'><p>BIC for a fitted serp object</p></a></li>
<li><a href='#coef.serp'><p>Coefficients for a fitted serp object</p></a></li>
<li><a href='#confint.serp'><p>Confidence interval for a fitted serp object</p></a></li>
<li><a href='#logLik.serp'><p>Log-likelihood for a fitted serp object</p></a></li>
<li><a href='#predict.serp'><p>Prediction from fitted serp model</p></a></li>
<li><a href='#print.serp'><p>Print method for a fitted serp object</p></a></li>
<li><a href='#print.summary.serp'><p>Print method for an object of class summary.serp</p></a></li>
<li><a href='#serp'><p>Smooth Effects on Response Penalty for CLM</p></a></li>
<li><a href='#serp.control'><p>Control parameters for a fitted serp object</p></a></li>
<li><a href='#summary.serp'><p>Summary method for a fitted serp object.</p></a></li>
<li><a href='#vcov.serp'><p>Variance covariance matrix for a fitted serp object</p></a></li>
<li><a href='#wine'><p>Bitterness of wine dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Smooth Effects on Response Penalty for CLM</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A regularization method for the cumulative link
    models.  The smooth-effect-on-response penalty (SERP) provides
    flexible modelling of the ordinal model by enabling the smooth
    transition from the general cumulative link model to a coarser form of
    the same model. In other words, as the tuning parameter goes from zero
    to infinity, the subject-specific effects associated with each
    variable in the model tend to a unique global effect. The parameter
    estimates of the general cumulative model are mostly unidentifiable or
    at least only identifiable within a range of the entire parameter
    space. Thus, by maximizing a penalized rather than the usual
    non-penalized log-likelihood, this and other numerical problems common
    with the general model are to a large extent eliminated. Fitting is
    via a modified Newton's method. Several standard model performance and
    descriptive methods are also available. For more details on the penalty
    implemented here, see, Ugba (2021) &lt;<a href="https://doi.org/10.21105%2Fjoss.03705">doi:10.21105/joss.03705</a>&gt; and 
    Ugba et al. (2021) &lt;<a href="https://doi.org/10.3390%2Fstats4030037">doi:10.3390/stats4030037</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ejikeugba/serp">https://github.com/ejikeugba/serp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ejikeugba/serp/issues">https://github.com/ejikeugba/serp/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ordinal (&ge; 2016-12-12), crayon, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat, VGAM (&ge; 1.1-4)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-15 22:07:56 UTC; EJIKE</td>
</tr>
<tr>
<td>Author:</td>
<td>Ejike R. Ugba <a href="https://orcid.org/0000-0003-2572-0023"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ejike R. Ugba &lt;ejike.ugba@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-16 07:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='AIC.serp'>AIC for a fitted serp object</h2><span id='topic+AIC.serp'></span>

<h3>Description</h3>

<p>Returns the akaike information criterion of a fitted object of class
<code>serp</code>. For the penalized slope, the effective degrees of freedom (edf)
is obtained from the trace of the generalized hat matrix which depends on
the tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
AIC(object, ..., k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AIC.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="AIC.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="AIC.serp_+3A_k">k</code></td>
<td>
<p>fixed value equal to 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value of the model AIC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+BIC.serp">BIC.serp</a></code>, <code><a href="#topic+coef.serp">coef.serp</a></code>,
<code><a href="#topic+logLik.serp">logLik.serp</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "parallel", link = "probit",
          data = wine)
AIC(m)
</code></pre>

<hr>
<h2 id='anova.serp'>ANOVA method for a fitted serp object</h2><span id='topic+anova.serp'></span>

<h3>Description</h3>

<p>Provides a likelihood ratio test for comparing two or more <code>serp</code> objects. This
does not currently support model(s) with penalized slope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
anova(object, ..., test = c("Chisq", "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="anova.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="anova.serp_+3A_test">test</code></td>
<td>
<p>type of test to be conducted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ANOVA table with the following components on display:
</p>


<h3>Value</h3>

<table>
<tr><td><code>model</code></td>
<td>
<p>the respective model aliases.</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>type of slope fitted, which may be any of, unparallel, parallel,
or partial slope.</p>
</td></tr>
<tr><td><code>no.par</code></td>
<td>
<p>the no of parameters in the model.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the akaike information criterion.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the realized log-likelihood.</p>
</td></tr>
<tr><td><code>Test</code></td>
<td>
<p>the different pair(s) of test(s) conducted.</p>
</td></tr>
<tr><td><code>LR.stat</code></td>
<td>
<p>the computed Likelihood ratio statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degree of freedom.</p>
</td></tr>
<tr><td><code>Pr(chi)</code></td>
<td>
<p>the p-value of test statitic.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+confint.serp">confint.serp</a></code>, <code><a href="#topic+vcov.serp">vcov.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m1 &lt;- serp(rating ~ temp + contact, slope = "parallel", link = "logit",
           data = wine)
m2 &lt;- update(m1, ~ contact)
anova(m1, m2)

</code></pre>

<hr>
<h2 id='BIC.serp'>BIC for a fitted serp object</h2><span id='topic+BIC.serp'></span>

<h3>Description</h3>

<p>Returns the bayesian information criterion of a fitted object of class
<code>serp</code>. For the penalized slopes, the effective degrees of freedom (edf)
is obtained from the trace of the generalized hat matrix which depends on
the tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
BIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BIC.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="BIC.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value of the model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+AIC.serp">AIC.serp</a></code>, <code><a href="#topic+coef.serp">coef.serp</a></code>,
<code><a href="#topic+logLik.serp">logLik.serp</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "parallel", link = "loglog",
          data = wine)
BIC(m)
</code></pre>

<hr>
<h2 id='coef.serp'>Coefficients for a fitted serp object</h2><span id='topic+coef.serp'></span><span id='topic+coefficients.serp'></span>

<h3>Description</h3>

<p>Returns the coefficients of a fitted object of class <code>serp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
coef(object, ...)

## S3 method for class 'serp'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="coef.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of model coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+AIC.serp">AIC.serp</a></code>, <code><a href="#topic+BIC.serp">BIC.serp</a></code>,
<code><a href="#topic+logLik.serp">logLik.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "parallel", link = "loglog",
          data = wine)
coef(m)

</code></pre>

<hr>
<h2 id='confint.serp'>Confidence interval for a fitted serp object</h2><span id='topic+confint.serp'></span>

<h3>Description</h3>

<p>Provides the confidence interval of estimates for an object of class <code>serp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
confint(object, ..., parm, level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="confint.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="confint.serp_+3A_parm">parm</code></td>
<td>
<p>unused argument.</p>
</td></tr>
<tr><td><code id="confint.serp_+3A_level">level</code></td>
<td>
<p>significance level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the the confidence intervals of fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+anova.serp">anova.serp</a></code>, <code><a href="#topic+vcov.serp">vcov.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "parallel", link = "logit",
           data = wine)
confint(m)

</code></pre>

<hr>
<h2 id='logLik.serp'>Log-likelihood for a fitted serp object</h2><span id='topic+logLik.serp'></span>

<h3>Description</h3>

<p>Returns the Log-likelihood for a fitted object of class <code>serp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="logLik.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single numeric value of model log-likelihood
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+AIC.serp">AIC.serp</a></code>, <code><a href="#topic+BIC.serp">BIC.serp</a></code>,
<code><a href="#topic+coef.serp">coef.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "parallel", link = "loglog",
          data = wine)
logLik(m)
</code></pre>

<hr>
<h2 id='predict.serp'>Prediction from fitted serp model</h2><span id='topic+predict.serp'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>serp</code> object produced by serp() and
produces predicted values. Type of predictions returned include response,
link and class. Prediction is also possible with new set of values having
the same column names as in the original values used for the model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
predict(object, type = c("link", "response", "class"), newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="predict.serp_+3A_type">type</code></td>
<td>
<p>could be any of these: response, link or terms.</p>
</td></tr>
<tr><td><code id="predict.serp_+3A_newdata">newdata</code></td>
<td>
<p>fresh dataset with all relevant variables.</p>
</td></tr>
<tr><td><code id="predict.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of predicted classes with <code>type</code> equal to 'class'
or a dataframe of predicted values for <code>type</code> equal to 'response'
and 'link'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.serp">anova.serp</a></code>, <code><a href="#topic+summary.serp">summary.serp</a></code>,
<code><a href="#topic+confint.serp">confint.serp</a></code>, <code><a href="#topic+vcov.serp">vcov.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "penalize",
           reverse = TRUE, link = "logit", tuneMethod = "user",
           lambda = 1, data = wine)

head(predict(m, type = "link"))
head(predict(m, type = "response"))
predict(m, type = "class")

n.wine &lt;- wine[1:20,]
predict(m, newdata = n.wine, type = "class")

</code></pre>

<hr>
<h2 id='print.serp'>Print method for a fitted serp object</h2><span id='topic+print.serp'></span>

<h3>Description</h3>

<p>Prints out a vector of coefficients of the fitted model with some
additional goodness-of-fit measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.serp_+3A_x">x</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="print.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+print.summary.serp">print.summary.serp</a></code>
</p>

<hr>
<h2 id='print.summary.serp'>Print method for an object of class summary.serp</h2><span id='topic+print.summary.serp'></span>

<h3>Description</h3>

<p>Prints out the information supplied via <code>summary.serp</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.serp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.serp_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.serp</code>.</p>
</td></tr>
<tr><td><code id="print.summary.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+print.serp">print.serp</a></code>
</p>

<hr>
<h2 id='serp'>Smooth Effects on Response Penalty for CLM</h2><span id='topic+serp'></span>

<h3>Description</h3>

<p>Fits cumulative link models (CLMs) with the
smooth-effect-on-response penalty (SERP) via a modified Newton-Raphson
algorithm. SERP enables the regularization of the parameter space between
the general and the restricted cumulative models, with a resultant shrinkage
of all subject-specific effects to global effects. The Akaike information
critrion (<code>aic</code>), K-fold cross validation (<code>cv</code>), among other tuning
aproaches, provide the means of arriving at an optimal tuning parameter in a
in a situation where a user-supplied tuning value is not available.
The <code>slope</code> argument allows for the selection of a penalized, unparallel,
parallel, or partial slope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serp(
     formula,
     link = c("logit", "probit","loglog", "cloglog", "cauchit"),
     slope = c("penalize", "parallel", "unparallel", "partial"),
     tuneMethod = c("aic", "cv", "finite", "user"),
     reverse = FALSE,
     lambdaGrid = NULL,
     cvMetric = c("brier", "logloss", "misclass"),
     gridType = c("discrete", "fine"),
     globalEff = NULL,
     data,
     subset,
     weights = NULL,
     weight.type = c("analytic", "frequency"),
     na.action = NULL,
     lambda = NULL,
     contrasts = NULL,
     control = list(),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serp_+3A_formula">formula</code></td>
<td>
<p>regression formula of the form: response ~ predictors. The
response should be a factor (ordered).</p>
</td></tr>
<tr><td><code id="serp_+3A_link">link</code></td>
<td>
<p>sets the link function for the cumulative link model including:
logit, probit, complementary log-log, cloglog, cauchit.</p>
</td></tr>
<tr><td><code id="serp_+3A_slope">slope</code></td>
<td>
<p>selects the form of coefficients used in the model, with
<code>penalize</code> denoting the penalized coefficients, <code>unparallel</code>,
<code>parallel</code> and <code>partial</code> denoting the unpenalized non-parallel,
parallel and semi-parallel coefficients respectively.</p>
</td></tr>
<tr><td><code id="serp_+3A_tunemethod">tuneMethod</code></td>
<td>
<p>sets the method of choosing an optimal shrinkage
parameter, including: <code>aic</code>, <code>cv</code>, <code>finite</code> and
<code>user</code>. i.e., the lambda value along parameter shrinkage path at
which the fit's AIC or the k-fold cross-validated test error is
minimal. The finite tuning is used to obtain the model along parameter
shrinkage for which the log-Likelihood exist (is finite). The 'user'
tuning supports a user-supplied lambda value.</p>
</td></tr>
<tr><td><code id="serp_+3A_reverse">reverse</code></td>
<td>
<p>false by default, when true the sign of the linear predictor
is reversed.</p>
</td></tr>
<tr><td><code id="serp_+3A_lambdagrid">lambdaGrid</code></td>
<td>
<p>optional user-supplied lambda grid for the <code>aic</code>,
and <code>cv</code> tuning methods, when the discrete <code>gridType</code>
is chosen. Negative range of values are not allowed. A short lambda grid
could increase computation time assuming large number of predictors and
cases in the model.</p>
</td></tr>
<tr><td><code id="serp_+3A_cvmetric">cvMetric</code></td>
<td>
<p>sets the performance metric for the cv tuning, with the
brier score used by default.</p>
</td></tr>
<tr><td><code id="serp_+3A_gridtype">gridType</code></td>
<td>
<p>chooses if a discrete or a continuous lambda grid should be
used to select the optimal tuning parameter. The former is used by default
and could be adjusted as desired in <code>serp.control</code>. The latter
is on the range (0, <code>maxPen</code>). A user-supplied grid is also possible,
which automatically overrides the internal grid.</p>
</td></tr>
<tr><td><code id="serp_+3A_globaleff">globalEff</code></td>
<td>
<p>specifies variable(s) to be assigned global effects during
penalization or when <code>slope</code> is set to <code>partial</code>. Variables are
specified as a formula with an empty left hand side, for instance,
globalEff = ~predictors.</p>
</td></tr>
<tr><td><code id="serp_+3A_data">data</code></td>
<td>
<p>optional dataframe explaining the variables used in the formula.</p>
</td></tr>
<tr><td><code id="serp_+3A_subset">subset</code></td>
<td>
<p>specifies which subset of the rows of the data should be used
for fit. All observations are used by default.</p>
</td></tr>
<tr><td><code id="serp_+3A_weights">weights</code></td>
<td>
<p>optional case weights in fitting. Negative weights are not
allowed. Defaults to 1.</p>
</td></tr>
<tr><td><code id="serp_+3A_weight.type">weight.type</code></td>
<td>
<p>chooses between analytic and frequency weights with the
former used by default. The latter should be used when weights are mere
case counts used to compress the data set.</p>
</td></tr>
<tr><td><code id="serp_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data.</p>
</td></tr>
<tr><td><code id="serp_+3A_lambda">lambda</code></td>
<td>
<p>a user-supplied single numeric value for the tuning parameter
when using the <code>user</code> tuning method. Negative values are not
allowed.</p>
</td></tr>
<tr><td><code id="serp_+3A_contrasts">contrasts</code></td>
<td>
<p>a list of contrasts to be used for some or all of the
factors appearing as variables in the model formula.</p>
</td></tr>
<tr><td><code id="serp_+3A_control">control</code></td>
<td>
<p>A list of fit control parameters to replace default values
returned by <code>serp.control</code>. Values not set assume default values.</p>
</td></tr>
<tr><td><code id="serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>serp</code> function fits the cumulative link model (CLM)
with smooth-effect-on-response penalty (SERP). The cumulative
model developed by McCullagh (1980) is probably most frequently
used ordinal model. When motivated by an underlying latent
variable, a simple form of the model is expressed as follows:
</p>
<p style="text-align: center;"><code class="reqn">P(Y\leq r|x) = F(\delta_{0r} + x^T\delta)</code>
</p>

<p>where <code class="reqn">x</code> is a vector of covariates, <code class="reqn">\delta</code> a vector
of regression parameters and <code class="reqn">F</code> a continuous distribution
function. This model assumes that the effect of <code class="reqn">x</code> does not
depend on the  category. However, with this assumption relaxed,
one obtains the following general cumulative model:
</p>
<p style="text-align: center;"><code class="reqn">P(Y\leq r|x) = F(\delta_{0r} + x^T\delta_{r}),</code>
</p>

<p>where r=1,...,k-1. This model, however, has the stochastic ordering
property, which implies that <code class="reqn">P(Y\leq r-1|x) &lt; P(Y\leq r|x)</code>
holds for all <code class="reqn">x</code> and all categories <code class="reqn">r</code>. Such assumption
is often problematic, resulting in unstable likelihoods with
ill-conditioned parameter space during the iterative procedure.
</p>
<p>SERP offers a means of arriving at stable estimates of the general model.
It provides a form of regularization that is based on minimizing the
penalized log-likelihood:
</p>
<p style="text-align: center;"><code class="reqn">l_{p}(\delta)=l(\delta)-J_{\lambda}(\delta)</code>
</p>

<p>where <code class="reqn">l(\delta)</code>, is the log-likelihood of the general cumulative
model and <code class="reqn">J_{\lambda}(\delta)=\lambda J(\delta)</code> the penalty
function weighted by the turning parameter <code class="reqn">\lambda</code>. Assuming an
ordered categorical outcome <code class="reqn">Y \in \{1,\dots,k\}</code>, and considering
that the corresponding parameters <code class="reqn">\delta_{1j},\dots \delta_{k-1,j}</code>
vary smoothly over the categories, the following penalty
(Tutz and Gertheiss, 2016),
</p>
<p style="text-align: center;"><code class="reqn">J_{\lambda}(\delta)= \sum_{j=1}^{p} \sum_{r=1}^{k-2}
(\delta_{r+1,j}-\delta_{rj})^{2}</code>
</p>

<p>enables the smoothing of response categories such that all
category-specific effects associated with the response turn towards a
common global effect. SERP could also be applied to a semi-parallel model
with only the category-specific part of the model penalized. See,
Ugba (2021), Ugba et al. (2021) for further details and application in
empirical studies.
</p>
<p>An object of class <code>serp</code> with the components listed below,
depending on the type of slope modeled. Other summary methods include:
<code>summary</code>, <code>coef</code>, <code>predict</code>, <code>vcov</code>,
<code>anova</code>, etc.
</p>


<h3>Value</h3>

<table>
<tr><td><code>aic</code></td>
<td>
<p>the akaike information criterion, with effective degrees of
freedom obtained from the trace of the generalized hat matrix
depending on the tuning parameter.</p>
</td></tr>
<tr><td><code>bic</code></td>
<td>
<p>the bayesian information criterion, with effective degrees of
freedom obtained from the trace of the generalized hat matrix
depending on the tuning parameter.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>a vector of coefficients of the fitted model.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>a character vector of fit convergence status.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(where relevant) the contrasts used in the model.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>list of control parameters from <code>serp.control</code>.</p>
</td></tr>
<tr><td><code>cvMetric</code></td>
<td>
<p>the performance metric used for cv tuning.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the residual deviance.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>the (effective) number of degrees of freedom used by the model</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted probabilities.</p>
</td></tr>
<tr><td><code>globalEff</code></td>
<td>
<p>variable(s) in model treated as global effect(s)</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>a column vector of gradients for the coefficients at the
model convergence.</p>
</td></tr>
<tr><td><code>Hessian</code></td>
<td>
<p>the hessian matrix for the coefficients at the model
convergence.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of interactions before convergence or non-convergence.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>a user-supplied single numeric value for the <code>user</code>
tuning tuning method.</p>
</td></tr>
<tr><td><code>lambdaGrid</code></td>
<td>
<p>a numeric vector of lambda values used to determine the
optimum tuning parameter.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the realized log-likelihood at the model convergence.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>character vector indicating the link function of the fit.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p>character vector stating the type of convergence obtained</p>
</td></tr>
<tr><td><code>misc</code></td>
<td>
<p>a list to hold miscellaneous fit information.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>model.frame having variables from formula.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information on the treatment of NAs.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>nrFold</code></td>
<td>
<p>the number of k-fold cross validation for the cv tuning
method. Default to k = 5.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>the residual degrees of freedom</p>
</td></tr>
<tr><td><code>reverse</code></td>
<td>
<p>a logical vector indicating the the direction of the
cumulative probabilities. Default to P(Y&lt;=r).</p>
</td></tr>
<tr><td><code>slope</code></td>
<td>
<p>a character vector indicating the type of slope parameters
fitted. Default to <code>penalize</code>.</p>
</td></tr>
<tr><td><code>Terms</code></td>
<td>
<p>the terms structure describing the model.</p>
</td></tr>
<tr><td><code>testError</code></td>
<td>
<p>numeric value of the cross-validated test error at which
the optimal tuning parameter emerged.</p>
</td></tr>
<tr><td><code>tuneMethod</code></td>
<td>
<p>a character vector specifying the method for choosing an
optimal shrinkage parameter.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>numeric value of AIC or logLik obtained at the optimal tuning
parameter when using <code>aic</code> or <code>finite</code> tuning methods respectively.</p>
</td></tr>
<tr><td><code>ylev</code></td>
<td>
<p>the number of the response levels.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ugba, E. R. (2021). serp: An R package for smoothing in ordinal regression
<em>Journal of Open Source Software</em>, 6(66), 3705.
https://doi.org/10.21105/joss.03705
</p>
<p>Ugba, E. R., Mörlein, D. and Gertheiss, J. (2021). Smoothing in Ordinal
Regression: An Application to Sensory Data. <em>Stats</em>, 4, 616–633.
https://doi.org/10.3390/stats4030037
</p>
<p>Tutz, G. and Gertheiss, J. (2016). Regularized Regression
for Categorical Data (With Discussion and Rejoinder).
<em>Statistical Modelling</em>, 16, pp. 161-260.
https://doi.org/10.1177/1471082X16642560
</p>
<p>McCullagh, P. (1980). Regression Models for Ordinal Data.
<em>Journal of the Royal Statistical Society. Series B
(Methodological)</em>, 42, pp. 109-142.
https://doi.org/10.1111/j.2517-6161.1980.tb01109.x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova.serp">anova.serp</a></code>, <code><a href="#topic+summary.serp">summary.serp</a></code>,
<code><a href="#topic+predict.serp">predict.serp</a></code>, <code><a href="#topic+confint.serp">confint.serp</a></code>,
<code><a href="#topic+vcov.serp">vcov.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(serp)

## The unpenalized non-proportional odds model returns unbounded estimates, hence,
## not fully identifiable.
f1 &lt;- serp(rating ~ temp + contact, slope = "unparallel",
           reverse = TRUE, link = "logit", data = wine)
coef(f1)

## The penalized non-proportional odds model with a user-supplied lambda gives
## a fully identified model with bounded estimates. A suitable tuning criterion
## could as well be used to select lambda (e.g., aic, cv)
f2 &lt;- serp(rating ~ temp + contact, slope = "penalize",
           link = "logit", reverse = TRUE, tuneMethod = "user",
           lambda = 1e1, data = wine)
coef(f2)

## A penalized partial proportional odds model with some variables set to
## global effect is also possible.
f3 &lt;- serp(rating ~ temp + contact, slope = "penalize",
           reverse = TRUE, link = "logit", tuneMethod = "user",
           lambda = 2e1, globalEff = ~ temp, data = wine)
coef(f3)


## The unpenalized proportional odds model having constrained estimates can
## as well be fit. Under extreme shrinkage, estimates in f2 equal those in
## this model.
f4 &lt;-  serp(rating ~ temp + contact, slope = "parallel",
            reverse = FALSE, link = "logit", data = wine)
summary(f4)

</code></pre>

<hr>
<h2 id='serp.control'>Control parameters for a fitted serp object</h2><span id='topic+serp.control'></span>

<h3>Description</h3>

<p>Default control parameters for 'serp' fit. User-supplied control parameters
could be specified in the main function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serp.control(
             maxits = 5e01,
             eps = 1e-07,
             maxpen = 1e07,
             trace = 0L,
             maxAdjIter = 5e0,
             max.half.iter = 1e01,
             relTol = 1e-03,
             nrFold = 5e0,
             cv.seed = 1e01,
             grid.length = 5e01,
             misclass.thresh = 5e-01,
             minP = .Machine$double.eps,
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serp.control_+3A_maxits">maxits</code></td>
<td>
<p>the maximum number of Newton's iterations. Default to 100.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_eps">eps</code></td>
<td>
<p>threshold value during optimization at which the iteration
routine terminates. In other words, when the reported change in the
log-likelihood goes below this threshold, convergence is achieved.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_maxpen">maxpen</code></td>
<td>
<p>the upper end point of the interval from zero to be searched
for a tuning parameter.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_trace">trace</code></td>
<td>
<p>prints the Newton's fitting process at each iteration step.If
0 (default) no information is printed, if 1, 2 or 3 different shades of
information are printed.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_maxadjiter">maxAdjIter</code></td>
<td>
<p>the maximum allowable number of Newton step adjustment to
forestall an early optimization failure. Defaults to 5.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_max.half.iter">max.half.iter</code></td>
<td>
<p>the maximum number of iteration step-halfings. Defaults
to 10.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_reltol">relTol</code></td>
<td>
<p>relative convergence tolerance, defaults to 1e-03. checks
relative changes in the parameter estimates between Newton iterations.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_nrfold">nrFold</code></td>
<td>
<p>the number of k-fold cross validation for the CV tuning
method. Default to k = 5.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_cv.seed">cv.seed</code></td>
<td>
<p>single numeric value to change the random seed in CV
tuning.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_grid.length">grid.length</code></td>
<td>
<p>the length of the discrete lambda grid for the penalty
method.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_misclass.thresh">misclass.thresh</code></td>
<td>
<p>to reset the classification threshold in
<code>errorMetrics</code> when <code>type</code> is 'misclass'.</p>
</td></tr>
<tr><td><code id="serp.control_+3A_minp">minP</code></td>
<td>
<p>A near zero minimum value the fitted probabilities are allowed
to get during iteration to prevent numerical instability .</p>
</td></tr>
<tr><td><code id="serp.control_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of control parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
serp(rating ~ contact, slope = "parallel", link = "logit",
     control = list(maxits = 2e01, eps=1e-05, trace = 2),
     data = wine)

</code></pre>

<hr>
<h2 id='summary.serp'>Summary method for a fitted serp object.</h2><span id='topic+summary.serp'></span>

<h3>Description</h3>

<p>This function summarizes the result of a fitted serp object in a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="summary.serp_+3A_...">...</code></td>
<td>
<p>Not used. Additional summary arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>an object of class <code>summary.serp</code>. A list (depending on the type of
<code>slope</code> used) of all model components defined in the <code><a href="#topic+serp">serp</a></code>,
function with additional components listed below.
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors,
z-values and p-values.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the deviance for the intercept only model.</p>
</td></tr>
<tr><td><code>null.logLik</code></td>
<td>
<p>the log-likelihood for the intercept only model.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>list of penalization information obtained with
<code>slope</code> set to &quot;penalize&quot;.</p>
</td></tr>
<tr><td><code>expcoefs</code></td>
<td>
<p>the exponentiated coefficients.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+anova.serp">anova.serp</a></code>, <code><a href="#topic+predict.serp">predict.serp</a></code>,
<code><a href="#topic+confint.serp">confint.serp</a></code>, <code><a href="#topic+vcov.serp">vcov.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "penalize",
           reverse = TRUE, link = "logit", tuneMethod = "user",
           lambda = 0, data = wine)
summary(m)
</code></pre>

<hr>
<h2 id='vcov.serp'>Variance covariance matrix for a fitted serp object</h2><span id='topic+vcov.serp'></span>

<h3>Description</h3>

<p>Provides the Variance covariance matrix of an object of class <code>serp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'serp'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.serp_+3A_object">object</code></td>
<td>
<p>An object of class <code>serp</code>.</p>
</td></tr>
<tr><td><code id="vcov.serp_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance covariance matrix of a fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+serp">serp</a></code>
</p>
<p><code><a href="#topic+serp">serp</a></code>, <code><a href="#topic+anova.serp">anova.serp</a></code>, <code><a href="#topic+confint.serp">confint.serp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(serp)
m &lt;- serp(rating ~ temp + contact, slope = "parallel", link = "logit",
           data = serp::wine)
vcov(m)

</code></pre>

<hr>
<h2 id='wine'>Bitterness of wine dataset</h2><span id='topic+wine'></span>

<h3>Description</h3>

<p>The <code>wine</code> dataset adopted from Randall(1989),
represents the outcome of a factorial experiment on factors
determining the bitterness of wine. Two treatment factors
(temperature and contact) with two levels each are provided,
with the rating of wine taken on a continuous scale in the interval
from 0 (none) to 100 (intense). These were subsequently grouped
into five ordered categories ranging from 1 = 'least bitter'
to 5 = 'most bitter'. Altogether, nine different judges assessed
wine from two bottles and out of the four treatment conditions,
making a total of 72 observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wine
</code></pre>


<h3>Format</h3>

<p>A data frame with 72 rows and 6 variables:
</p>


<h3>Value</h3>

<table>
<tr><td><code>response</code></td>
<td>

<p>scorings of wine bitterness on a 0&mdash;100 continuous scale.
</p>
</td></tr>
<tr><td><code>rating</code></td>
<td>

<p>ordered factor with 5 levels; a grouped version of <code>response</code>.
</p>
</td></tr>
<tr><td><code>contact</code></td>
<td>

<p>factor with two levels (<code>"no"</code> and <code>"yes"</code>).
</p>
</td></tr>
<tr><td><code>temp</code></td>
<td>

<p>temperature: factor with two levels.
</p>
</td></tr>
<tr><td><code>judge</code></td>
<td>

<p>factor with nine levels.
</p>
</td></tr>
<tr><td><code>bottle</code></td>
<td>

<p>factor with eight levels.
</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Taken from Randall (1989).
</p>


<h3>References</h3>

<p>Randall, J (1989). The analysis of sensory data by generalized linear
model. <em>Biometrical Journal</em>, 31, 781&ndash;793.
https://doi.org/10.1002/bimj.4710310703
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
str(wine)
head(wine)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
