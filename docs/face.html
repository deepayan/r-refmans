<!DOCTYPE html><html lang="en"><head><title>Help for package face</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {face}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#face-package'><p>face</p></a></li>
<li><a href='#cor.face'>
<p>Extraction of correlation and mean from a <code>face.sparse</code> object</p></a></li>
<li><a href='#face-internal'><p>Internal functions for face package</p></a></li>
<li><a href='#face.sparse'>
<p>Fast covariance estimation for sparse functional data</p></a></li>
<li><a href='#predict.face.sparse'>
<p>Subject-specific curve prediction from a face.sparse fit</p></a></li>
<li><a href='#predict.pspline.face'>
<p>Mean prediction from a P-spline smoothing fit</p></a></li>
<li><a href='#pspline'>
<p>Univariate P-spline smoothing</p></a></li>
<li><a href='#select.knots'>
<p>Knots selection for P-spline smoothing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fast Covariance Estimation for Sparse Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-7</td>
</tr>
<tr>
<td>Author:</td>
<td>Luo Xiao [aut], Cai Li [aut,cre], William Checkley [aut], Ciprian Crainiceanu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cai Li &lt;cai.li.stats@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We implement the Fast Covariance Estimation for 
             Sparse Functional Data paper published in Statistics and Computing &lt;<a href="https://doi.org/10.1007%2Fs11222-017-9744-8">doi:10.1007/s11222-017-9744-8</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, splines, Matrix, matrixcalc, mgcv</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-18 10:07:52 UTC; cli9</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-18 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='face-package'>face</h2><span id='topic+face-package'></span><span id='topic+face'></span>

<h3>Description</h3>

<p>Fast Covariance Estimation for Sparse Functional Data
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> face</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-07-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: GPL-3
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Luo Xiao, Cai Li, William Checkley and Ciprian Crainiceanu
</p>
<p>Maintainer: Cai Li &lt;cai.li.stats@gmail.com&gt;
</p>


<h3>References</h3>

<p>Luo Xiao, Cai Li, William Checkley and Ciprian Crainiceanu, Fast covariance estimation
for sparse functional data, Stat. Comput., doi: <a href="https://doi.org/10.1007/s11222-017-9744-8">10.1007/s11222-017-9744-8</a>.
</p>

<hr>
<h2 id='cor.face'>
Extraction of correlation and mean from a <code>face.sparse</code> object
</h2><span id='topic+cor.face'></span>

<h3>Description</h3>

<p>Extraction of correlation and mean from a <code>face.sparse</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.face(object,argvals.new,option="raw")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor.face_+3A_object">object</code></td>
<td>
<p> A <code>face.sparse</code> object.
</p>
</td></tr>
<tr><td><code id="cor.face_+3A_argvals.new">argvals.new</code></td>
<td>
<p>Where to evalulate correlation and mean.
</p>
</td></tr>
<tr><td><code id="cor.face_+3A_option">option</code></td>
<td>
<p>Defaults to &quot;raw&quot;; if &quot;smooth&quot;, then extract correlation from smoothed covariance function.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>argvals.new</code></td>
<td>
<p>Where to evaluate correlation and mean.</p>
</td></tr>
<tr><td><code>option</code></td>
<td>
<p>Defaults to &quot;raw&quot;; if &quot;smooth&quot;, then extract correlation from smoothed covariance function.</p>
</td></tr>
<tr><td><code>Cor</code></td>
<td>
<p>estimated correlation matrix at <code>argvals.new</code></p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>estimated group/population mean at <code>argvals.new</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luo Xiao &lt;lxiao5@ncsu.edu&gt;
</p>


<h3>References</h3>

<p>Luo Xiao, Cai Li, William Checkley and Ciprian Crainiceanu, Fast covariance estimation
for sparse functional data, Stat. Comput., doi: <a href="https://doi.org/10.1007/s11222-017-9744-8">10.1007/s11222-017-9744-8</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples for "face.sparse".
</code></pre>

<hr>
<h2 id='face-internal'>Internal functions for face package</h2><span id='topic+kr'></span><span id='topic+pspline.setting'></span><span id='topic+raw.construct'></span><span id='topic+construct.knots'></span><span id='topic+check.data'></span><span id='topic+matrix.multiply'></span><span id='topic+weight.construct'></span><span id='topic+covZ'></span><span id='topic+face.sparse.inner'></span>

<h3>Description</h3>

<p>Internal function.
</p>

<hr>
<h2 id='face.sparse'>
Fast covariance estimation for sparse functional data
</h2><span id='topic+face.sparse'></span>

<h3>Description</h3>

<p>The function is to estimate the mean and covariance function
from a cluster of functions/longitudinal observations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>face.sparse(data, newdata = NULL,
             center = TRUE, argvals.new = NULL,
             knots = 7, 
             p = 3, m = 2, lambda = NULL, lambda_mean = NULL,
             search.length = 14, 
             lower = -3, upper = 10, lower2 = -3, upper2 = 5,
             calculate.scores = FALSE,pve=0.99,two_step=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="face.sparse_+3A_data">data</code></td>
<td>

<p>a data frame with three arguments:
(1) <code>argvals</code>: observation times;
(2) <code>subj</code>: subject indices;
(3) <code>y</code>: values of observations.
Missing values not allowed.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_newdata">newdata</code></td>
<td>

<p>of the same strucutre as <code>data</code>; defaults to NULL, then no prediction. 
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_center">center</code></td>
<td>

<p>logical. If TRUE, then Pspline smoothing of the population mean will be conducted and
subtracted from the data before covariance smoothing; if FALSE, then
the population mean will be just 0s.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_argvals.new">argvals.new</code></td>
<td>

<p>a vector of observation time points to evaluate mean function, covariance function, error variance
and etc. If NULL,
then 100 equidistant points in the range of <code>data$argvals</code>.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_knots">knots</code></td>
<td>

<p>the number of knots for B-spline basis functions to be used; defaults to 7.
The resulting number of basis functions is the number of interior knots plus the degree of B-splines.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_p">p</code></td>
<td>

<p>the degrees of B-splines; defaults to 3.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_m">m</code></td>
<td>

<p>the order of differencing penalty; defaults to 2.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_lambda">lambda</code></td>
<td>

<p>the value of the smoothing parameter for covariance smoothing; defaults to NULL.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_lambda_mean">lambda_mean</code></td>
<td>

<p>the value of the smoothing parameter for mean smoothing; defaults to NULL.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_search.length">search.length</code></td>
<td>

<p>the number of equidistant (log scale) smoothing parameters to search; defaults to 14.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_lower">lower</code>, <code id="face.sparse_+3A_upper">upper</code></td>
<td>

<p>bounds for log smoothing parameter for first step of estimation; defaults are -3 and 10, respectively.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_lower2">lower2</code>, <code id="face.sparse_+3A_upper2">upper2</code></td>
<td>

<p>bounds for log smoothing parameter for second step of estimation; defaults are <code>lower</code> and 5, respectively.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_calculate.scores">calculate.scores</code></td>
<td>

<p>if TRUE, scores will be calculated.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_pve">pve</code></td>
<td>

<p>Defaults 0.99. To select the number of eigenvalues by percentage of variance.
</p>
</td></tr>
<tr><td><code id="face.sparse_+3A_two_step">two_step</code></td>
<td>

<p>if TRUE, a two-step estimation procedure will be applied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generalized version of bivariate P-splines (Eilers and Marx, 2003) for
covariance smoothing of sparse functional or longitudinal data.
It uses tensor product B-spline basis functions and
employes a differencing penalty on the assosciated parameter matrix.
The only smoothing parameter in the method is selected
by leave-one-subject-out cross validation and is implemented with a fast algorithm.
</p>
<p>There are two steps for estimation. During the first step, the objective function to minimize
is the penalized least squares on empirical estimates of covariance function. During the second step,
the covariance between the empirical estimates (depending on the estimates of 
covariance function) are accounted and thus a generalized penalized
least squares are minimized.
</p>
<p>If <code>center</code> is TRUE, then a population mean will be calculated and is smoothed by
univariate P-spline smoothing:<code>pspline</code> (Eilers and Marx, 1996). This univariate
smoothing uses leave-one-subject-out cross validation to select the smoothing parameter.
</p>
<p>The knots are &quot;equally-spaced&quot;, the differencing penalty in Eilers and Marx (2003)
is used.
</p>
<p>If the functional data are observed at the same grid for each function/curve
and can be organized into
a data matrix, then <code>fpca.face</code> in the package <code>refund</code>
should instead be used. <code>fpca.face</code> allows a small percentage (less than
30 percent) of 
missing data in the data matrix.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>newdata</code></td>
<td>
<p>Input</p>
</td></tr>
<tr><td><code>y.pred</code>, <code>mu.pred</code>, <code>Chat.diag.pred</code>, <code>var.error.pred</code></td>
<td>
<p>Predicted/estimated objects at
<code>newdata$argvals</code></p>
</td></tr>
<tr><td><code>Theta</code></td>
<td>
<p>Estimated parameter matrix</p>
</td></tr>
<tr><td><code>argvals.new</code></td>
<td>
<p>Vector of time points to evaluate population parameters</p>
</td></tr>
<tr><td><code>mu.new</code>, <code>Chat.new</code>, <code>Cor.new</code>, <code>Cor.raw.new</code>, <code>Chat.raw.diag.new</code>, <code>var.error.new</code></td>
<td>
<p>Estimated objects at
<code>argvals.new</code></p>
</td></tr>
<tr><td><code>eigenfunctions</code>, <code>eigenvalues</code></td>
<td>
<p>Estimated eigenfunctions (scaled eigenvector) and eigenvalues at <code>argvals.new</code></p>
</td></tr>
<tr><td><code>mu.hat</code>, <code>var.error.hat</code></td>
<td>
<p>Estimated objects at  <code>data$argvals</code></p>
</td></tr>
<tr><td><code>calculate.scores</code>, <code>rand_eff</code></td>
<td>
<p>if <code>calculate.scores</code> is TRUE (default to FALSE), then predicted scores <code>rand_eff$scores</code> will be calculated.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luo Xiao &lt;lxiao5@ncsu.edu&gt; and Cai Li &lt;cli9@ncsu.edu&gt;
</p>


<h3>References</h3>

<p>Luo Xiao, Cai Li, William Checkley and Ciprian Crainiceanu, Fast covariance estimation
for sparse functional data, Stat. Comput., doi: <a href="https://doi.org/10.1007/s11222-017-9744-8">10.1007/s11222-017-9744-8</a>.
</p>
<p>Paul Eilers and Brian  Marx, Multivariate calibration with temperature
interaction using two-dimensional penalized signal regression,
Chemometrics and Intelligent Laboratory Systems 66 (2003), 159-174.
</p>
<p>Paul Eilers and Brian Marx, Flexible smoothing with B-splines and penalties,
Statist. Sci., 11, 89-121, 1996.
</p>
<p>Simon N. Wood, P-splines with derivative based penalties and tensor product 
smoothing of unevenly distributed data, Stat. Comput., doi: <a href="https://doi.org/10.1007/s11222-016-9666-x">10.1007/s11222-016-9666-x</a>.
</p>


<h3>See Also</h3>

<p><code>fpca.face</code> and <code>fpca.sc</code> in <code>refund</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
##########################
#### CD4 data example
##########################

require(refund)
data(cd4)
n &lt;- nrow(cd4)
Tt &lt;- ncol(cd4)

id &lt;- rep(1:n,each=Tt)
t &lt;- rep(-18:42,times=n)
y &lt;- as.vector(t(cd4))
sel &lt;- which(is.na(y))


## organize data and apply FACEs
data &lt;- data.frame(y=log(y[-sel]),
argvals = t[-sel],
subj = id[-sel])
data &lt;- data[data$y&gt;4.5,]
fit_face &lt;- face.sparse(data,argvals.new=(-20:40))

## set calculate.scores to TRUE if want to get scores
fit_face &lt;- face.sparse(data,argvals.new=(-20:40),calculate.scores=TRUE)
scores &lt;- fit_face$rand_eff$scores

data.h &lt;- data
tnew &lt;- fit_face$argvals.new

## scatter plots
Xlab &lt;- "Months since seroconversion"
Ylab &lt;- "log (CD4 count)"
par(mfrow=c(1,1),mar = c(4.5,4.5,3,2))
id &lt;- data.h$subj
uid &lt;- unique(id)
plot(data.h$argvals,data.h$y,
type = "n", ylim = c(4.5,8),
xlab = Xlab, ylab = Ylab,
cex.lab = 1.25,cex.axis=1.25,cex.main = 1.25)

for(i in 1:10){
seq &lt;- which(id==uid[i])
lines(data.h$argvals[seq],data.h$y[seq],lty=1,col="gray",lwd=1,type="l")
#points(data.h$argvals[seq],data.h$y[seq],col=1,lty=1,pch=1)
}

Sample &lt;- seq(10,50,by=10)
for(i in Sample){
seq &lt;- which(id==uid[i])
lines(data.h$argvals[seq],data.h$y[seq],lty=1,col="black",lwd=1,type="l")
}
lines(tnew,fit_face$mu.new,lwd=2,lty=2,col="red")

## plots of variance/correlation functions

Cov &lt;- fit_face$Chat.new
Cov_diag &lt;- diag(Cov)
Cor &lt;- fit_face$Cor.new

par(mfrow=c(1,2),mar=c(4.5,4.1,3,4.5))


plot(tnew,Cov_diag,type="l",
xlab = Xlab, ylab="",main= "CD4: variance function",
#ylim = c(0.8,1.5),
cex.axis=1.25,cex.lab=1.25,cex.main=1.25,lwd=2)

require(fields)
image.plot(tnew,tnew,Cor,
xlab=Xlab, ylab = Xlab,
main = "CD4: correlation function",
cex.axis=1.25,cex.lab=1.25,cex.main=1.25,
axis.args = list(at = c(0,0.2,0.4,0.6,0.8,1.0)),
legend.shrink=0.75,legend.line=-1.5)


## prediction of several subjects

par(mfrow=c(2,2),mar=c(4.5,4.5,3,2))
Sample &lt;- c(30,40,50,60)
for(i in 1:4){
sel &lt;- which(id==uid[Sample[i]])
dati &lt;- data.h[sel,]

seq &lt;- -20:40
k &lt;- length(seq)
dati_pred &lt;- data.frame(y = rep(NA,nrow(dati) + k ),
argvals = c(rep(NA,nrow(dati)),seq),
subj=rep(dati$subj[1],nrow(dati) + k )
)

dati_pred[1:nrow(dati),] &lt;- dati
yhat2 &lt;- predict(fit_face,dati_pred)

data3 &lt;- dati
Ylim &lt;- range(c(data3$y,yhat2$y.pred))

plot(data3$argvals,data3$y,xlab=Xlab,ylab=Ylab, main = paste("Male ",i,sep=""),
ylim = c(4,8.5),
cex.lab=1.25,cex.axis = 1.25,cex.main = 1.25,pch=1,xlim=c(-20,40))

Ord &lt;- nrow(dati) + 1:k
lines(dati_pred$argvals[Ord],yhat2$y.pred[Ord],col="red",lwd=2)
lines(dati_pred$argvals[Ord],
yhat2$y.pred[Ord] - 1.96*yhat2$se.pred[Ord], col="red",lwd=1,lty=2)
lines(dati_pred$argvals[Ord],
yhat2$y.pred[Ord] + 1.96*yhat2$se.pred[Ord], col="red",lwd=1,lty=2)

lines(tnew,fit_face$mu.new,lty=3,col="black",lwd=2)
legend("bottomleft",c("mean","prediction"),lty=c(3,1),col=1:2,lwd=2,bty="n")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.face.sparse'>
Subject-specific curve prediction from a face.sparse fit
</h2><span id='topic+predict.face.sparse'></span>

<h3>Description</h3>

<p>Predict subject-specific curves based on a fit from &quot;face.sparse&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'face.sparse'
predict(object, newdata,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.face.sparse_+3A_object">object</code></td>
<td>

<p>a fitted object from the R function  &quot;face.sparse&quot;.
</p>
</td></tr>
<tr><td><code id="predict.face.sparse_+3A_newdata">newdata</code></td>
<td>

<p>a data frame with three arguments: 
(1) <code>argvals</code>: observation times;
(2) <code>subj</code>: subject indices;
(3) <code>y</code>: values of observations.
NA values are allowed in &quot;y&quot; but not in the other two.
</p>
</td></tr>
<tr><td><code id="predict.face.sparse_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes prediction based on observed data for each subject. So for each subject,
it requires at least one observed data. For the time points prediction is desired but
no observation is available, just make the corresponding <code>data$y</code> as NA.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>object</code></td>
<td>
<p>A &quot;face.sparse&quot; fit</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>Input</p>
</td></tr>
<tr><td><code>y.pred</code>, <code>mu.pred</code>, <code>Chat.pred</code>, <code>Chat.diag.pred</code>, <code>var.error.pred</code></td>
<td>
<p>Predicted/estimated objects at
the observation time points in <code>newdata</code></p>
</td></tr>
<tr><td><code>rand_eff</code></td>
<td>
<p>if <code>calculate.scores</code> in <code>object</code> is TRUE (typically FALSE),
then predicted scores <code>rand_eff$scores</code> will be calculated.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luo Xiao &lt;lxiao5@ncsu.edu&gt;
</p>


<h3>References</h3>

<p>Luo Xiao, Cai Li, William Checkley and Ciprian Crainiceanu, Fast covariance estimation
for sparse functional data, Stat. Comput., doi: <a href="https://doi.org/10.1007/s11222-017-9744-8">10.1007/s11222-017-9744-8</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#See the examples for "face.sparse".
</code></pre>

<hr>
<h2 id='predict.pspline.face'>
Mean prediction from a P-spline smoothing fit
</h2><span id='topic+predict.pspline.face'></span>

<h3>Description</h3>

<p>Predict mean values based on a fit from &quot;pspline&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pspline.face'
predict(object, argvals.new,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.pspline.face_+3A_object">object</code></td>
<td>

<p>a fitted object from the R function  &quot;pspline&quot;.
</p>
</td></tr>
<tr><td><code id="predict.pspline.face_+3A_argvals.new">argvals.new</code></td>
<td>

<p>a vector of new time points.
</p>
</td></tr>
<tr><td><code id="predict.pspline.face_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predicted means at <code>argvals.new</code>.
</p>


<h3>Author(s)</h3>

<p>Luo Xiao &lt;lxiao5@ncsu.edu&gt;
</p>


<h3>References</h3>

<p>Luo Xiao, Cai Li, William Checkley and Ciprian Crainiceanu, Fast covariance estimation
for sparse functional data, Stat. Comput., doi: <a href="https://doi.org/10.1007/s11222-017-9744-8">10.1007/s11222-017-9744-8</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the examples for "pspline".
</code></pre>

<hr>
<h2 id='pspline'>
Univariate P-spline smoothing
</h2><span id='topic+pspline'></span>

<h3>Description</h3>

<p>Univariate P-spline smoothing with the smoothing parameter selected by leave-one-subject-out cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pspline(data, argvals.new = NULL, knots = 35,
            p = 3, m = 2, lambda = NULL,
            search.length = 100,
            lower = -20, upper = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pspline_+3A_data">data</code></td>
<td>

<p>a data frame with three arguments: 
(1) <code>argvals</code>: observation times;
(2) <code>subj</code>: subject indices;
(3) <code>y</code>: values of observations.
Missing values not allowed.
</p>
</td></tr>
<tr><td><code id="pspline_+3A_argvals.new">argvals.new</code></td>
<td>

<p>a vector of observations times for prediction; if NULL, then the same as <code>data$argvals</code>.
</p>
</td></tr>
<tr><td><code id="pspline_+3A_knots">knots</code></td>
<td>

<p>a vector of interior knots or the number of knots for B-spline basis functions to be used; defaults to 35.
</p>
</td></tr>
<tr><td><code id="pspline_+3A_p">p</code></td>
<td>

<p>the degrees of B-splines; defaults to 3.
</p>
</td></tr>
<tr><td><code id="pspline_+3A_m">m</code></td>
<td>

<p>the order of differencing penalty; defaults to 2.
</p>
</td></tr>
<tr><td><code id="pspline_+3A_lambda">lambda</code></td>
<td>

<p>the value of the smoothing parameter; defaults to NULL.
</p>
</td></tr>
<tr><td><code id="pspline_+3A_search.length">search.length</code></td>
<td>

<p>the number of equidistant (log scale) smoothing parameters to search; defaults to 100.
</p>
</td></tr>
<tr><td><code id="pspline_+3A_lower">lower</code>, <code id="pspline_+3A_upper">upper</code></td>
<td>

<p>bounds for log smoothing parameter; defaults are -20 and 20.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is an implementation of the P-spline smoothing in Eilers and Marx (1996). P-splines uses B-splines as basis functions and employs a differencing penalty on the coefficients. Leave-one-subject-out cross validation is used for selecting the smoothing parameter and a fast algorithm is implemented.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted mean values</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>B-spline design matrix</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Estimated coefficients</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Eigenvalues</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>Knots</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>The degrees of B-splines</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>The order of differencing penalty</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The value of the smoothing parameter</p>
</td></tr>
<tr><td><code>argvals.new</code></td>
<td>
<p>A vector of observations times</p>
</td></tr>
<tr><td><code>mu.new</code></td>
<td>
<p>Fitted mean values at <code>argvals.new</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luo Xiao &lt;lxiao5@ncsu.edu&gt;
</p>


<h3>References</h3>

<p>Paul Eilers and Brian Marx, Flexible smoothing with B-splines and penalties,
Statist. Sci., 11, 89-121, 1996.
</p>
<p>Luo Xiao, Cai Li, William Checkley and Ciprian Crainiceanu, Fast covariance estimation
for sparse functional data, Stat. Comput., doi: <a href="https://doi.org/10.1007/s11222-017-9744-8">10.1007/s11222-017-9744-8</a>.
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+gam">gam</a></code> in <code><a href="mgcv.html#topic+mgcv">mgcv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## cd4 data
require(refund)
data(cd4)
n &lt;- nrow(cd4)
T &lt;- ncol(cd4)

id &lt;- rep(1:n,each=T)
t &lt;- rep(-18:42,times=n)
y &lt;- as.vector(t(cd4))
sel &lt;- which(is.na(y))

## organize data
data &lt;- data.frame(y=log(y[-sel]),
argvals = t[-sel],
subj = id[-sel])
data &lt;- data[data$y&gt;4.5,]

## smooth
fit &lt;- pspline(data)

## plot
plot(data$argvals,fit$mu.new,type="p")

## prediction
pred &lt;- predict(fit,quantile(data$argvals,c(0.2,0.6)))
pred

## End(Not run)
</code></pre>

<hr>
<h2 id='select.knots'>
Knots selection for P-spline smoothing
</h2><span id='topic+select.knots'></span>

<h3>Description</h3>

<p>Construct knots from either quantiles of observed time points or
equally-spaced time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select.knots(t,knots=10,p=3,option="equally-spaced")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select.knots_+3A_t">t</code></td>
<td>
<p> Observed time points.
</p>
</td></tr>
<tr><td><code id="select.knots_+3A_knots">knots</code></td>
<td>
<p> Number of interior knots.
</p>
</td></tr>
<tr><td><code id="select.knots_+3A_p">p</code></td>
<td>
<p>Degrees of B-splines to be used.</p>
</td></tr>
<tr><td><code id="select.knots_+3A_option">option</code></td>
<td>
<p>Default &quot;equally-spaced&quot;: equally-spaced time points in the range of <code>t</code>; if &quot;quantile&quot;, 
then quantiles of <code>t</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of knots in the output will be <code>knot</code> plus  2 times <code>p</code>; and
the B-spline basis matrix constructed from this vector of knots with degrees <code>p</code>
will be <code>knots</code> plus <code>p</code>.
</p>


<h3>Value</h3>

<p>A vector of knots
</p>


<h3>Author(s)</h3>

<p>Luo Xiao &lt;lxiao5@ncsu.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- rnorm(100)
knots &lt;- select.knots(t)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
