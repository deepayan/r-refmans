<!DOCTYPE html><html lang="en"><head><title>Help for package talkr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {talkr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_lines'><p>Add information for line-by-line visualization</p></a></li>
<li><a href='#calculate_timing'><p>Calculate conversation properties</p></a></li>
<li><a href='#check_columns'><p>Check the presence of necessary columns in a dataset</p></a></li>
<li><a href='#check_talkr'><p>Check the presence of talkr-workflow columns in the dataset.</p></a></li>
<li><a href='#check_time'><p>Verify that timing columns are numeric and likely indicate milliseconds.</p></a></li>
<li><a href='#geom_token'><p>Plot individual tokens</p></a></li>
<li><a href='#geom_turn'><p>Show turn-taking in visualized conversations</p></a></li>
<li><a href='#GeomToken'><p>GeomToken</p></a></li>
<li><a href='#get_ifadv'><p>Get IFADV data</p></a></li>
<li><a href='#init'><p>Initialize a 'talkr' dataset</p></a></li>
<li><a href='#plot_density'><p>Make a density plot of a specific column</p></a></li>
<li><a href='#plot_quality'><p>Check source quality by plotting timing data</p></a></li>
<li><a href='#plot_scatter'><p>Make a scatter plot of two columns</p></a></li>
<li><a href='#report_stats'><p>Report corpus-level and conversation-level statistics</p></a></li>
<li><a href='#theme_turnPlot'><p>T  heme for the turn plot</p></a></li>
<li><a href='#tokenize'><p>Generate a token-specific dataframe</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plotting Conversation Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Visualisation, analysis and quality control of conversational data.
             Rapid and visual insights into the nature, timing and quality of
             time-aligned annotations in conversational corpora.
             For more details, see 
             Dingemanse et al., (2022) &lt;<a href="https://doi.org/10.18653%2Fv1%2F2022.acl-long.385">doi:10.18653/v1/2022.acl-long.385</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cowplot, dplyr, ggplot2, ggthemes, knitr, stats, stringr,
tidyr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, testthat (&ge; 3.0.0), pkgdown, ggrepel, utils</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-15 13:53:36 UTC; pablo</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Dingemanse [aut, cre],
  Barbara Vreede [aut],
  Eva Viviani [aut],
  Pablo Rodríguez-Sánchez [aut],
  Andreas Liesenfeld [ctb],
  Netherlands eScience Center [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Dingemanse &lt;mark.dingemanse@ru.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-19 11:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_lines'>Add information for line-by-line visualization</h2><span id='topic+add_lines'></span>

<h3>Description</h3>

<p>This function adds columns to the dataset that adds a line ID, and changes columns
with timestamps relative to the beginning of the line, so data can
be visualized line-by-line.
The participant column is also adjusted to create a Y-coordinate for each speaker.
The line duration is set to 60 seconds by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_lines(data, time_columns = c("begin", "end"), line_duration = 60000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_lines_+3A_data">data</code></td>
<td>
<p>dataset to divide into lines</p>
</td></tr>
<tr><td><code id="add_lines_+3A_time_columns">time_columns</code></td>
<td>
<p>columns with timestamps that need to be adjusted to line-relative time</p>
</td></tr>
<tr><td><code id="add_lines_+3A_line_duration">line_duration</code></td>
<td>
<p>length of line (in ms)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This transformation can be done for multiple columns with time-stamped data.
Use the 'time_columns' argument to supply the names of one or more columns
that should be transformed.
</p>


<h3>Value</h3>

<p>data set with added columns: 'line_id', 'line_participant', and
'line_column' for every column in 'time_columns'
</p>

<hr>
<h2 id='calculate_timing'>Calculate conversation properties</h2><span id='topic+calculate_timing'></span>

<h3>Description</h3>

<p>A dataframe is generated with conversation properties related to timing.
This data is made for quality control purposes only, and does not contain
sophisticated transition calculation methods. For this, we refer to the
python package 'scikit-talk'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_timing(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_timing_+3A_data">data</code></td>
<td>
<p>talkr data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing the UIDs and calculated columns turn_duration, transition_time
</p>

<hr>
<h2 id='check_columns'>Check the presence of necessary columns in a dataset</h2><span id='topic+check_columns'></span>

<h3>Description</h3>

<p>Check the presence of necessary columns in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_columns(data, columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_columns_+3A_data">data</code></td>
<td>
<p>dataset to check</p>
</td></tr>
<tr><td><code id="check_columns_+3A_columns">columns</code></td>
<td>
<p>a vector of column names that must be present</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, but throws an error if a column is missing
</p>

<hr>
<h2 id='check_talkr'>Check the presence of talkr-workflow columns in the dataset.</h2><span id='topic+check_talkr'></span>

<h3>Description</h3>

<p>Uses check_columns() to check for:
- begin
- end
- participant
- utterance
- source
- uid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_talkr(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_talkr_+3A_data">data</code></td>
<td>
<p>dataset to check</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Verifies that begin and end columns are numeric, and likely indicate milliseconds.
</p>

<hr>
<h2 id='check_time'>Verify that timing columns are numeric and likely indicate milliseconds.</h2><span id='topic+check_time'></span>

<h3>Description</h3>

<p>Verify that timing columns are numeric and likely indicate milliseconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_time(column, name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_time_+3A_column">column</code></td>
<td>
<p>vector with timing information</p>
</td></tr>
<tr><td><code id="check_time_+3A_name">name</code></td>
<td>
<p>name of the column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, but throws an error if the column is not numeric and warns if the column may not indicate milliseconds
</p>

<hr>
<h2 id='geom_token'>Plot individual tokens</h2><span id='topic+geom_token'></span>

<h3>Description</h3>

<p>From a separate data frame containing tokenized data, plot individual tokens
at their estimated time. Data must be provided separately, and should
contain a column with the participant (y) and a column with the time (x).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_token(
  data,
  mapping = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_token_+3A_data">data</code></td>
<td>
<p>A tokenized data frame (see 'tokenize()').</p>
</td></tr>
<tr><td><code id="geom_token_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="geom_token_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_token_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_token_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_token_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_token_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_token_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer corresponding to a token
</p>

<hr>
<h2 id='geom_turn'>Show turn-taking in visualized conversations</h2><span id='topic+geom_turn'></span>

<h3>Description</h3>

<p>Show turn-taking in visualized conversations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_turn(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  height = 0.5,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_turn_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by 'ggplot2::aes()'.
Requires specification of 'begin' and 'end' of turns. Inherits from the default mapping at the
top level of the plot, if 'inherit.aes' is set to 'TRUE' (the default).</p>
</td></tr>
<tr><td><code id="geom_turn_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_turn_+3A_stat">stat</code></td>
<td>
<p>The statistical transformation to use on the data for this layer.
When using a <code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function to construct a layer, the <code>stat</code>
argument can be used the override the default coupling between geoms and
stats. The <code>stat</code> argument accepts the following:
</p>

<ul>
<li><p> A <code>Stat</code> ggproto subclass, for example <code>StatCount</code>.
</p>
</li>
<li><p> A string naming the stat. To give the stat as a string, strip the
function name of the <code>stat_</code> prefix. For example, to use <code>stat_count()</code>,
give the stat as <code>"count"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the stat, see the
<a href="ggplot2.html#topic+layer_stats">layer stat</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_turn_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_turn_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_turn_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_turn_+3A_height">height</code></td>
<td>
<p>The height of the turn-taking rectangles</p>
</td></tr>
<tr><td><code id="geom_turn_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_turn_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer corresponding to a turn-taking rectangle
</p>

<hr>
<h2 id='GeomToken'>GeomToken</h2><span id='topic+GeomToken'></span><span id='topic+GeomTurn'></span>

<h3>Description</h3>

<p>GeomToken
</p>
<p>GeomTurn
</p>

<hr>
<h2 id='get_ifadv'>Get IFADV data</h2><span id='topic+get_ifadv'></span>

<h3>Description</h3>

<p>IFA Dialog Video corpus data
Available in the public repository:
https://github.com/elpaco-escience/ifadv
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ifadv(
  source = "https://raw.githubusercontent.com/elpaco-escience/ifadv/csv/data/ifadv.csv"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ifadv_+3A_source">source</code></td>
<td>
<p>(default = &quot;https://raw.githubusercontent.com/elpaco-escience/ifadv/csv/data/ifadv.csv&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires an internet connection.
</p>


<h3>Value</h3>

<p>A data frame containing the IFADV dataset
</p>

<hr>
<h2 id='init'>Initialize a 'talkr' dataset</h2><span id='topic+init'></span>

<h3>Description</h3>

<p>From a dataframe object, generate a talkr dataset.
This dataset contains columns that are used throughout the talkr
infrastructure to visualize conversations and language corpora.
Initializing a talkr dataset is the first step in the talkr workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init(
  data,
  source = "source",
  begin = "begin",
  end = "end",
  participant = "participant",
  utterance = "utterance",
  format_timestamps = "ms"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_+3A_data">data</code></td>
<td>
<p>A dataframe object</p>
</td></tr>
<tr><td><code id="init_+3A_source">source</code></td>
<td>
<p>The column name identifying the conversation source
(e.g. a filename; is used as unique conversation ID). If there are no different
sources in the data, set this parameter to 'NULL'.</p>
</td></tr>
<tr><td><code id="init_+3A_begin">begin</code></td>
<td>
<p>The column name with the begin time of the utterance (in milliseconds)</p>
</td></tr>
<tr><td><code id="init_+3A_end">end</code></td>
<td>
<p>The column name with the end time of the utterance (in milliseconds)</p>
</td></tr>
<tr><td><code id="init_+3A_participant">participant</code></td>
<td>
<p>The column name with the participant who produced the utterance</p>
</td></tr>
<tr><td><code id="init_+3A_utterance">utterance</code></td>
<td>
<p>The column name with the utterance itself</p>
</td></tr>
<tr><td><code id="init_+3A_format_timestamps">format_timestamps</code></td>
<td>
<p>The format of the timestamps in the begin and end columns. Default is &quot;ms&quot;, which expects milliseconds. '%H:%M:%OS' will format eg. 00:00:00.010 to milliseconds (10). See '?strptime' for more format examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe object with columns needed for the talkr workflow
</p>

<hr>
<h2 id='plot_density'>Make a density plot of a specific column</h2><span id='topic+plot_density'></span>

<h3>Description</h3>

<p>Make a density plot of a specific column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_density(
  data,
  colname,
  title = "Density",
  xlab = "value",
  ylab = "density"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_density_+3A_data">data</code></td>
<td>
<p>data frame containing the column</p>
</td></tr>
<tr><td><code id="plot_density_+3A_colname">colname</code></td>
<td>
<p>column name for which the density should be plotted</p>
</td></tr>
<tr><td><code id="plot_density_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot_density_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plot_density_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recorded plot
</p>

<hr>
<h2 id='plot_quality'>Check source quality by plotting timing data</h2><span id='topic+plot_quality'></span>

<h3>Description</h3>

<p>Check source quality by plotting timing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_quality(data, source = "all", saveplot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_quality_+3A_data">data</code></td>
<td>
<p>talkr data frame</p>
</td></tr>
<tr><td><code id="plot_quality_+3A_source">source</code></td>
<td>
<p>source to be checked (default is &quot;all&quot;, no source is selected)</p>
</td></tr>
<tr><td><code id="plot_quality_+3A_saveplot">saveplot</code></td>
<td>
<p>save plot to file (default is FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of recorded plots
</p>

<hr>
<h2 id='plot_scatter'>Make a scatter plot of two columns</h2><span id='topic+plot_scatter'></span>

<h3>Description</h3>

<p>Make a scatter plot of two columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_scatter(
  data,
  colname_x,
  colname_y,
  title = "Scatter",
  xlab = "x",
  ylab = "y"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_scatter_+3A_data">data</code></td>
<td>
<p>data frame containing the columns</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_colname_x">colname_x</code></td>
<td>
<p>name of column plotted on x-axis</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_colname_y">colname_y</code></td>
<td>
<p>name of column plotted on y-axis</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_title">title</code></td>
<td>
<p>plot title</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plot_scatter_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recorded plot
</p>

<hr>
<h2 id='report_stats'>Report corpus-level and conversation-level statistics</h2><span id='topic+report_stats'></span>

<h3>Description</h3>

<p>Basic conversation statistics are reported to the console:
- Corpus-level statistics, reporting on the dataset as a whole;
- Conversation-level statistics, reporting per source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report_stats(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="report_stats_+3A_data">data</code></td>
<td>
<p>talkr dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input for this function must be a 'talkr' dataset, containing
the columns 'source', 'participant', 'begin', and 'end'. Time stamps in the
columns 'begin' and 'end' must be in milliseconds.
To easily transform a dataset to a 'talkr' dataset, consult 'talkr::init()'.
</p>


<h3>Value</h3>

<p>No return, just prints a summary to the console
</p>

<hr>
<h2 id='theme_turnPlot'>T  heme for the turn plot</h2><span id='topic+theme_turnPlot'></span>

<h3>Description</h3>

<p>T  heme for the turn plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_turnPlot(base_size = 11, base_family = "serif", ticks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="theme_turnPlot_+3A_base_size">base_size</code></td>
<td>
<p>int</p>
</td></tr>
<tr><td><code id="theme_turnPlot_+3A_base_family">base_family</code></td>
<td>
<p>chr</p>
</td></tr>
<tr><td><code id="theme_turnPlot_+3A_ticks">ticks</code></td>
<td>
<p>bool</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 custom theme for turn plots
</p>

<hr>
<h2 id='tokenize'>Generate a token-specific dataframe</h2><span id='topic+tokenize'></span>

<h3>Description</h3>

<p>From a dataframe with utterances, generate a dataframe that separates tokens
in utterances, and assesses their relative timing.
The returned data contains information about the original utterance ('uid'),
as well as the number of tokens in the utterance ('nwords'), and the relative
time of the token in the utterance ('relative_time').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tokenize(data, utterancecol = "utterance")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tokenize_+3A_data">data</code></td>
<td>
<p>a talkr dataset</p>
</td></tr>
<tr><td><code id="tokenize_+3A_utterancecol">utterancecol</code></td>
<td>
<p>the name of the column containing the clean utterance (defaults to &quot;utterance&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative time is calculated with each token in an utterance having an equal
duration (the duration of the utterance divided by the number of words), and
the first token in the utterance beginning at the beginning of the utterance.
</p>
<p>The input column provided with the argument 'utterancecol' is used to generate
the tokens. It is advised to provide a version of the utterance that has been
cleaned and stripped of special characters. Cleaning is not performed in this
function. Spaces are used to separate tokens.
</p>


<h3>Value</h3>

<p>a dataframe with details about each token in the utterance
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
