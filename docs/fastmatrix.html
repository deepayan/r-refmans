<!DOCTYPE html><html><head><title>Help for package fastmatrix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastmatrix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#array.mult'><p>Array multiplication</p></a></li>
<li><a href='#asSymmetric'><p>Force a matrix to be symmetric</p></a></li>
<li><a href='#bezier'><p>Computation of Bezier curve</p></a></li>
<li><a href='#bracket.prod'><p>Bracket product</p></a></li>
<li><a href='#cg'><p>Solve linear systems using the conjugate gradients method</p></a></li>
<li><a href='#cholupdate'><p>Rank 1 update to Cholesky factorization</p></a></li>
<li><a href='#circulant'><p>Form a symmetric circulant matrix</p></a></li>
<li><a href='#comm.info'><p>Compact information to construct the commutation matrix</p></a></li>
<li><a href='#comm.prod'><p>Matrix multiplication envolving the commutation matrix</p></a></li>
<li><a href='#commutation'><p>Commutation matrix</p></a></li>
<li><a href='#corAR1'><p>AR(1) correlation structure</p></a></li>
<li><a href='#corCS'><p>Compound symmetry correlation structure</p></a></li>
<li><a href='#cov.MSSD'><p>Mean Square Successive Difference (MSSD) estimator of the covariance matrix</p></a></li>
<li><a href='#cov.weighted'><p>Weighted covariance matrices</p></a></li>
<li><a href='#dupl.cross'><p>Matrix crossproduct envolving the duplication matrix</p></a></li>
<li><a href='#dupl.info'><p>Compact information to construct the duplication matrix</p></a></li>
<li><a href='#dupl.prod'><p>Matrix multiplication envolving the duplication matrix</p></a></li>
<li><a href='#duplication'><p>Duplication matrix</p></a></li>
<li><a href='#equilibrate'><p>Equilibration of a rectangular or symmetric matrix</p></a></li>
<li><a href='#frank'><p>Frank matrix</p></a></li>
<li><a href='#geomean'><p>Geometric mean</p></a></li>
<li><a href='#hadamard'><p>Hadamard product of two matrices</p></a></li>
<li><a href='#harris.test'><p>Test for variance homogeneity of correlated variables</p></a></li>
<li><a href='#helmert'><p>Helmert matrix</p></a></li>
<li><a href='#is.lower.tri'><p>Check if a matrix is lower or upper triangular</p></a></li>
<li><a href='#jacobi'><p>Solve linear systems using the Jacobi method</p></a></li>
<li><a href='#JarqueBera.test'><p>Jarque-Bera test for univariate normality</p></a></li>
<li><a href='#kronecker.prod'><p>Kronecker product on matrices</p></a></li>
<li><a href='#krylov'><p>Computes a Krylov matrix</p></a></li>
<li><a href='#kurtosis'><p>Mardia's multivariate skewness and kurtosis coefficients</p></a></li>
<li><a href='#ldl'><p>The LDL decomposition</p></a></li>
<li><a href='#lu'><p>The LU factorization of a square matrix</p></a></li>
<li><a href='#lu-methods'><p>Reconstruct the L, U, or X matrices from an LU object</p></a></li>
<li><a href='#lu2inv'><p>Inverse from LU factorization</p></a></li>
<li><a href='#Mahalanobis'><p>Mahalanobis distance</p></a></li>
<li><a href='#matrix.inner'><p>Compute the inner product between two rectangular matrices</p></a></li>
<li><a href='#matrix.norm'><p>Compute the norm of a rectangular matrix</p></a></li>
<li><a href='#mchol'><p>The modified Cholesky factorization</p></a></li>
<li><a href='#mediancenter'><p>Mediancenter</p></a></li>
<li><a href='#minkowski'><p>Computes the p-norm of a vector</p></a></li>
<li><a href='#moments'><p>Central moments</p></a></li>
<li><a href='#ols'><p>Fit linear regression model</p></a></li>
<li><a href='#ols.fit'><p>Fitter functions for linear models</p></a></li>
<li><a href='#ols.fit-methods'><p>Fit a linear model</p></a></li>
<li><a href='#power.method'><p>Power method to approximate dominant eigenvalue and eigenvector</p></a></li>
<li><a href='#rball'><p>Generation of deviates uniformly distributed in a unitary ball</p></a></li>
<li><a href='#ridge'><p>Ridge regression</p></a></li>
<li><a href='#rmnorm'><p>Multivariate normal random deviates</p></a></li>
<li><a href='#rsphere'><p>Generation of deviates uniformly located on a spherical surface</p></a></li>
<li><a href='#scaled.condition'><p>Scaled condition number</p></a></li>
<li><a href='#seidel'><p>Solve linear systems using the Gauss-Seidel method</p></a></li>
<li><a href='#sherman.morrison'><p>Sherman-Morrison formula</p></a></li>
<li><a href='#sweep.operator'><p>Gauss-Jordan sweep operator for symmetric matrices</p></a></li>
<li><a href='#symm.info'><p>Compact information to construct the symmetrizer matrix</p></a></li>
<li><a href='#symm.prod'><p>Matrix multiplication envolving the symmetrizer matrix</p></a></li>
<li><a href='#symmetrizer'><p>Symmetrizer matrix</p></a></li>
<li><a href='#vec'><p>Vectorization of a matrix</p></a></li>
<li><a href='#vech'><p>Vectorization the lower triangular part of a square matrix</p></a></li>
<li><a href='#WH.normal'><p>Wilson-Hilferty transformation for chi-squared variates</p></a></li>
<li><a href='#whitening'><p>Whitening transformation</p></a></li>
<li><a href='#wilson.hilferty'><p>Wilson-Hilferty transformation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Computation of some Matrices Useful in Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5-772</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felipe Osorio &lt;felipe.osorios@usm.cl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Small set of functions to fast computation of some matrices and operations
  useful in statistics and econometrics. Currently, there are functions for efficient
  computation of duplication, commutation and symmetrizer matrices with minimal storage
  requirements. Some commonly used matrix decompositions (LU and LDL), basic matrix
  operations (for instance, Hadamard, Kronecker products and the Sherman-Morrison formula)
  and iterative solvers for linear systems are also available. In addition, the package
  includes a number of common statistical procedures such as the sweep operator, weighted
  mean and covariance matrix using an online algorithm, linear regression (using Cholesky,
  QR, SVD, sweep operator and conjugate gradients methods), ridge regression (with optimal
  selection of the ridge parameter considering several procedures), omnibus tests for 
  univariate normality, functions to compute the multivariate skewness, kurtosis, the 
  Mahalanobis distance (checking the positive defineteness), and the Wilson-Hilferty 
  transformation of gamma variables. Furthermore, the package provides interfaces 
  to C code callable by another C code from other R packages.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://faosorios.github.io/fastmatrix/">https://faosorios.github.io/fastmatrix/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 19:12:32 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Felipe Osorio <a href="https://orcid.org/0000-0002-4675-5201"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alonso Ogueda [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-17 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='array.mult'>Array multiplication</h2><span id='topic+array.mult'></span>

<h3>Description</h3>

<p>Multiplication of 3-dimensional arrays was first introduced by Bates and Watts (1980).
More extensions and technical details can be found in Wei (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array.mult(a, b, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array.mult_+3A_a">a</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
<tr><td><code id="array.mult_+3A_b">b</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
<tr><td><code id="array.mult_+3A_x">x</code></td>
<td>
<p> a three-dimensional array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\bold{X} = (x_{tij})</code> be a 3-dimensional <code class="reqn">n\times p\times q</code> where
indices <code class="reqn">t, i</code> and <code class="reqn">j</code> indicate face, row and column, respectively. The
product <code class="reqn">\bold{Y} = \bold{AXB}</code> is an <code class="reqn">n\times r\times s</code> array, with
<code class="reqn">\bold{A}</code> and <code class="reqn">\bold{B}</code> are <code class="reqn">r\times p</code> and <code class="reqn">q\times s</code> matrices
respectively. The elements of <code class="reqn">\bold{Y}</code> are defined as:
</p>
<p style="text-align: center;"><code class="reqn">y_{tkl} = \sum\limits_{i=1}^p\sum\limits_{j=1}^q a_{ki}x_{tij}b_{jl}</code>
</p>



<h3>Value</h3>

<p><code>array.mult</code> returns a 3-dimensional array of dimension <code class="reqn">n\times r\times s</code>.
</p>


<h3>References</h3>

<p>Bates, D.M., Watts, D.G. (1980).
Relative curvature measures of nonlinearity.
<em>Journal of the Royal Statistical Society, Series B</em> <b>42</b>, 1-25.
</p>
<p>Wei, B.C. (1998).
<em>Exponential Family Nonlinear Models</em>.
Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+array">array</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="#topic+bracket.prod">bracket.prod</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(0, dim = c(2,3,3)) # 2 x 3 x 3 array
x[,,1] &lt;- c(1,2,2,4,3,6)
x[,,2] &lt;- c(2,4,4,8,6,12)
x[,,3] &lt;- c(3,6,6,12,9,18)

a &lt;- matrix(1, nrow = 2, ncol = 3)
b &lt;- matrix(1, nrow = 3, ncol = 2)

y &lt;- array.mult(a, b, x) # a 2 x 2 x 2 array
y
</code></pre>

<hr>
<h2 id='asSymmetric'>Force a matrix to be symmetric</h2><span id='topic+asSymmetric'></span>

<h3>Description</h3>

<p>Force a square matrix <code>x</code> to be symmetric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asSymmetric(x, lower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asSymmetric_+3A_x">x</code></td>
<td>
<p> a square matrix to be forced to be symmetric.</p>
</td></tr>
<tr><td><code id="asSymmetric_+3A_lower">lower</code></td>
<td>
<p> logical, should the upper (lower) triangle be replaced with the
lower (upper) triangle?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square symmetric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(1:16, ncol = 4)
isSymmetric(a) # FALSE
a &lt;- asSymmetric(a) # copy lower triangle into upper triangle
</code></pre>

<hr>
<h2 id='bezier'>Computation of Bezier curve</h2><span id='topic+bezier'></span>

<h3>Description</h3>

<p>Computes the Bezier curve based on <code class="reqn">n+1</code> control points using the De Casteljau's method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bezier(x, y, ngrid = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bezier_+3A_x">x</code>, <code id="bezier_+3A_y">y</code></td>
<td>
<p> vector giving the coordinates of the control points. Missing values are deleted.</p>
</td></tr>
<tr><td><code id="bezier_+3A_ngrid">ngrid</code></td>
<td>
<p> number of elements in the grid used to compute the smoother.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">\bold{p}_0,\bold{p}_1,\dots,\bold{p}_n</code> control points the Bezier curve is given by
<code class="reqn">B(t)</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">B(t) = \left({\begin{array}{c}
    x(t) \\
    y(t)
  \end{array}}\right) = \sum\limits_{k=0}^n {n \choose k} t^k (1 - t)^k\bold{p}_k</code>
</p>

<p>where <code class="reqn">t\in[0,1]</code>. To evaluate the Bezier curve the De Casteljau's method is used.
</p>


<h3>Value</h3>

<p>A list containing <code>xgrid</code> and <code>ygrid</code> elements used to plot the Bezier curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a tiny example
x &lt;- c(1.0, 0.25, 1.25, 2.5, 4.00, 5.0)
y &lt;- c(0.5, 2.00, 3.75, 4.0, 3.25, 1.0)
plot(x, y, type = "o")
z &lt;- bezier(x, y, ngrid = 50)
lines(z$xgrid, z$ygrid, lwd = 2, lty = 2, col = "red")

# other simple example
x &lt;- c(4,6,4,5,6,7)
y &lt;- 1:6
plot(x, y, type = "o")
z &lt;- bezier(x, y, ngrid = 50)
lines(z$xgrid, z$ygrid, lwd = 2, lty = 2, col = "red")
</code></pre>

<hr>
<h2 id='bracket.prod'>Bracket product</h2><span id='topic+bracket.prod'></span>

<h3>Description</h3>

<p>Bracket product of a matrix and a 3-dimensional array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bracket.prod(a, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bracket.prod_+3A_a">a</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
<tr><td><code id="bracket.prod_+3A_x">x</code></td>
<td>
<p> a three-dimensional array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\bold{X} = (x_{tij})</code> be a 3-dimensional <code class="reqn">n\times p\times q</code> array and
<code class="reqn">\bold{A}</code> an <code class="reqn">m\times n</code> matrix, then <code class="reqn">\bold{Y} = [\bold{A}][\bold{X}]</code>
is called the bracket product of <code class="reqn">\bold{A}</code> and <code class="reqn">\bold{X}</code>, that is an <code class="reqn">m
  \times p\times q</code> with elements
</p>
<p style="text-align: center;"><code class="reqn">y_{tij} = \sum\limits_{k=1}^n a_{tk}x_{kij}</code>
</p>



<h3>Value</h3>

<p><code>bracket.prod</code> returns a 3-dimensional array of dimension <code class="reqn">m\times p\times q</code>.
</p>


<h3>References</h3>

<p>Wei, B.C. (1998).
<em>Exponential Family Nonlinear Models</em>.
Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+array">array</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>, <code><a href="#topic+array.mult">array.mult</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(0, dim = c(2,3,3)) # 2 x 3 x 3 array
x[,,1] &lt;- c(1,2,2,4,3,6)
x[,,2] &lt;- c(2,4,4,8,6,12)
x[,,3] &lt;- c(3,6,6,12,9,18)

a &lt;- matrix(1, nrow = 3, ncol = 2)

y &lt;- bracket.prod(a, x) # a 3 x 3 x 3 array
y
</code></pre>

<hr>
<h2 id='cg'>Solve linear systems using the conjugate gradients method</h2><span id='topic+cg'></span>

<h3>Description</h3>

<p>Conjugate gradients (CG) method is an iterative algorithm for solving linear systems
with positive definite coefficient matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cg(a, b, maxiter = 200, tol = 1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cg_+3A_a">a</code></td>
<td>
<p> a symmetric positive definite matrix containing the coefficients of
the linear system.</p>
</td></tr>
<tr><td><code id="cg_+3A_b">b</code></td>
<td>
<p> a vector of right-hand sides of the linear system.</p>
</td></tr>
<tr><td><code id="cg_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. Defaults to <code>200</code></p>
</td></tr>
<tr><td><code id="cg_+3A_tol">tol</code></td>
<td>
<p> tolerance level for stopping iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the approximate solution, the iterations performed are returned
as the attribute 'iterations'.
</p>


<h3>Warning</h3>

<p>The underlying <code>C</code> code does not check for symmetry nor positive definitiveness.
</p>


<h3>References</h3>

<p>Golub, G.H., Van Loan, C.F. (1996).
<em>Matrix Computations</em>, 3rd Edition.
John Hopkins University Press.
</p>
<p>Hestenes, M.R., Stiefel, E. (1952).
Methods of conjugate gradients for solving linear equations.
<em>Journal of Research of the National Bureau of Standards</em> <b>49</b>, 409-436.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jacobi">jacobi</a></code>, <code><a href="#topic+seidel">seidel</a></code>, <code><a href="base.html#topic+solve">solve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(4,3,0,3,4,-1,0,-1,4), ncol = 3)
b &lt;- c(24,30,-24)
z &lt;- cg(a, b)
z # converged in 3 iterations
</code></pre>

<hr>
<h2 id='cholupdate'>Rank 1 update to Cholesky factorization</h2><span id='topic+cholupdate'></span>

<h3>Description</h3>

<p>function <code>cholupdate</code>, where <code>R = chol(A)</code> is the original Cholesky
factorization of <code class="reqn">\bold{A}</code>, returns the upper triangular Cholesky factor of
<code class="reqn">\bold{A} + \bold{xx}^T</code>, with <code class="reqn">\bold{x}</code> a column vector of appropriate dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholupdate(r, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cholupdate_+3A_r">r</code></td>
<td>
<p> a upper triangular matrix, the Cholesky factor of matrix a.</p>
</td></tr>
<tr><td><code id="cholupdate_+3A_x">x</code></td>
<td>
<p> vector defining the rank one update.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Golub, G.H., Van Loan, C.F. (2013).
<em>Matrix Computations</em>, 4th Edition.
John Hopkins University Press.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(1,1,1,1,2,3,1,3,6), ncol = 3)
r &lt;- chol(a)
x &lt;- c(0,0,1)
b &lt;- a + outer(x,x)
r1 &lt;- cholupdate(r, x)
r1
all(r1 == chol(b)) # TRUE
</code></pre>

<hr>
<h2 id='circulant'>Form a symmetric circulant matrix</h2><span id='topic+circulant'></span>

<h3>Description</h3>

<p>Forms a symmetric circulant matrix using a backwards shift of its first column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circulant(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circulant_+3A_x">x</code></td>
<td>
<p>the first column to form the circulant matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric circulant matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2,3,5,7,11,13)
circulant(x)
</code></pre>

<hr>
<h2 id='comm.info'>Compact information to construct the commutation matrix</h2><span id='topic+comm.info'></span>

<h3>Description</h3>

<p>This function provides the minimum information required to create the commutation matrix.
</p>
<p>The commutation matrix is a square matrix of order <code class="reqn">mn</code> that, for an <code class="reqn">m\times n</code>
matrix <code class="reqn">\bold{A}</code>, transform <code>vec</code><code class="reqn">(\bold{A}</code>) to <code>vec</code><code class="reqn">(\bold{A}^T)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.info(m = 1, n = m, condensed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.info_+3A_m">m</code></td>
<td>
<p> a positive integer row dimension.</p>
</td></tr>
<tr><td><code id="comm.info_+3A_n">n</code></td>
<td>
<p> a positive integer column dimension.</p>
</td></tr>
<tr><td><code id="comm.info_+3A_condensed">condensed</code></td>
<td>
<p> logical. Information should be returned in compact form?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list containing two vectors that represent an element of
the commutation matrix and is accesed by the indexes in vectors <code>row</code> and <code>col</code>.
This information is used by function <code><a href="#topic+comm.prod">comm.prod</a></code> to do some operations
involving the commutation matrix without forming it. This information also can be
obtained using function <code><a href="#topic+commutation">commutation</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p> vector of indexes, each entry represents the row index of the commutation
matrix.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p> vector of indexes, each entry represents the column index of the commutation
matrix. Only present if <code>condensed = FALSE</code>.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p> positive integer, row dimension.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p> positive integer, column dimension.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Magnus, J.R., Neudecker, H. (1979).
The commutation matrix: some properties and applications.
<em>The Annals of Statistics</em> <b>7</b>, 381-394.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+commutation">commutation</a></code>, <code><a href="#topic+comm.prod">comm.prod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- comm.info(m = 3, n = 2, condensed = FALSE)
z # where are the ones in commutation matrix of order '3,2'?

K32 &lt;- commutation(m = 3, n = 2, matrix = TRUE)
K32 # only recommended if m and n are very small
</code></pre>

<hr>
<h2 id='comm.prod'>Matrix multiplication envolving the commutation matrix</h2><span id='topic+comm.prod'></span>

<h3>Description</h3>

<p>Given the row and column dimensions of a commutation matrix <code class="reqn">\bold{K}</code> of order
<code class="reqn">mn</code> and a conformable matrix <code class="reqn">\bold{x}</code>, performs one of the matrix-matrix
operations:
</p>

<ul>
<li> <p><code class="reqn">\bold{Y} = \bold{KX}</code>, if <code>side = "left"</code> and <code>transposed = FALSE</code>, or
</p>
</li>
<li> <p><code class="reqn">\bold{Y} = \bold{K}^T\bold{X}</code>, if <code>side = "left"</code> and <code>transposed = TRUE</code>, or
</p>
</li>
<li> <p><code class="reqn">\bold{Y} = \bold{XK}</code>, if <code>side = "right"</code> and <code>transposed = FALSE</code>, or
</p>
</li>
<li> <p><code class="reqn">\bold{Y} = \bold{XK}^T</code>, if <code>side = "right"</code> and <code>transposed = TRUE</code>.
</p>
</li></ul>

<p>The main aim of <code>comm.prod</code> is to do this matrix multiplication <b>without forming</b>
the commutation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm.prod(m = 1, n = m, x = NULL, transposed = FALSE, side = "left")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comm.prod_+3A_m">m</code></td>
<td>
<p> a positive integer row dimension.</p>
</td></tr>
<tr><td><code id="comm.prod_+3A_n">n</code></td>
<td>
<p> a positive integer column dimension.</p>
</td></tr>
<tr><td><code id="comm.prod_+3A_x">x</code></td>
<td>
<p> numeric matrix (or vector).</p>
</td></tr>
<tr><td><code id="comm.prod_+3A_transposed">transposed</code></td>
<td>
<p> logical. Commutation matrix should be transposed?</p>
</td></tr>
<tr><td><code id="comm.prod_+3A_side">side</code></td>
<td>
<p> a string selecting if commutation matrix is pre-multiplying <code>x</code>, that is
<code>side = "left"</code> or post-multiplying <code>x</code>, by using <code>side = "right"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Underlying <code>Fortran</code> code only uses information provided by <code><a href="#topic+comm.info">comm.info</a></code>
to performs the matrix multiplication. The commutation matrix is <b>never</b> created.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+commutation">commutation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>K42 &lt;- commutation(m = 4, n = 2, matrix = TRUE)
x &lt;- matrix(1:24, ncol = 3)
y &lt;- K42 %*% x

z &lt;- comm.prod(m = 4, n = 2, x) # K42 is not stored
all(z == y) # matrices y and z are equal!
</code></pre>

<hr>
<h2 id='commutation'>Commutation matrix</h2><span id='topic+commutation'></span>

<h3>Description</h3>

<p>This function returns the commutation matrix of order <code class="reqn">mn</code> which transforms,
for an <code class="reqn">m\times n</code>  matrix <code class="reqn">\bold{A}</code>, <code>vec</code><code class="reqn">(\bold{A})</code> to
<code>vec</code><code class="reqn">(\bold{A}^T)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commutation(m = 1, n = m, matrix = FALSE, condensed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commutation_+3A_m">m</code></td>
<td>
<p> a positive integer row dimension.</p>
</td></tr>
<tr><td><code id="commutation_+3A_n">n</code></td>
<td>
<p> a positive integer column dimension.</p>
</td></tr>
<tr><td><code id="commutation_+3A_matrix">matrix</code></td>
<td>
<p> a logical indicating whether the commutation matrix will be returned.</p>
</td></tr>
<tr><td><code id="commutation_+3A_condensed">condensed</code></td>
<td>
<p> logical. Information should be returned in compact form?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function for the function <code>comm.info</code>. This function
provides the minimum information required to create the commutation matrix. If option
<code>matrix = FALSE</code> the commutation matrix is stored in two vectors containing the
coordinate list of indexes for rows and columns. Option <code>condensed = TRUE</code> only
returns vector of indexes for the rows of commutation matrix.
</p>
<p><b>Warning:</b> <code>matrix = TRUE</code> is <b>not</b> recommended, unless the order <code>m</code>
<b>and</b> <code>n</code> be small. This matrix can require a huge amount of storage.
</p>


<h3>Value</h3>

<p>Returns an <code class="reqn">mn</code> by <code class="reqn">mn</code> matrix (if requested).
</p>


<h3>References</h3>

<p>Magnus, J.R., Neudecker, H. (1979).
The commutation matrix: some properties and applications.
<em>The Annals of Statistics</em> <b>7</b>, 381-394.
</p>
<p>Magnus, J.R., Neudecker, H. (2007).
<em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>, 3rd Edition.
Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+comm.info">comm.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- commutation(m = 100, condensed = TRUE)
object.size(z) # 40.6 Kb of storage

z &lt;- commutation(m = 100, condensed = FALSE)
object.size(z) # 80.7 Kb of storage

K100 &lt;- commutation(m = 100, matrix = TRUE) # time: &lt; 2 secs
object.size(K100) # 400 Mb of storage, do not request this matrix!

# a small example
K32 &lt;- commutation(m = 3, n = 2, matrix = TRUE)
a &lt;- matrix(1:6, ncol = 2)
v &lt;- K32 %*% vec(a)
all(vec(t(a)) == as.vector(v)) # vectors are equal!
</code></pre>

<hr>
<h2 id='corAR1'>AR(1) correlation structure</h2><span id='topic+corAR1'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corAR1</code> correlation matrix representing
an autocorrelation structure of order 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corAR1(rho, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corAR1_+3A_rho">rho</code></td>
<td>
<p> the value of the lag 1 autocorrelation, which must be between -1 and 1.</p>
</td></tr>
<tr><td><code id="corAR1_+3A_p">p</code></td>
<td>
<p> dimension of the requested correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">p</code> by <code class="reqn">p</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- corAR1(rho = 0.8, p = 5)
</code></pre>

<hr>
<h2 id='corCS'>Compound symmetry correlation structure</h2><span id='topic+corCS'></span>

<h3>Description</h3>

<p>This function is a constructor for the <code>corCS</code> correlation matrix representing
a compound symmetry structure corresponding to uniform correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corCS(rho, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corCS_+3A_rho">rho</code></td>
<td>
<p> the value of the correlation between any two correlated observations,
which must be between -1 and 1.</p>
</td></tr>
<tr><td><code id="corCS_+3A_p">p</code></td>
<td>
<p> dimension of the requested correlation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">p</code> by <code class="reqn">p</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- corCS(rho = 0.8, p = 5)
</code></pre>

<hr>
<h2 id='cov.MSSD'>Mean Square Successive Difference (MSSD) estimator of the covariance matrix</h2><span id='topic+cov.MSSD'></span>

<h3>Description</h3>

<p>Returns a list containing the mean and covariance matrix of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.MSSD(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.MSSD_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. As usual, rows are observations and columns are
variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This procedure uses the Holmes-Mergen method using the difference between each
successive pairs of observations also known as Mean Square Successive Method (MSSD)
to estimate the covariance matrix.
</p>


<h3>Value</h3>

<p>A list containing the following named components:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>an estimate for the center (mean) of the data.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the estimated covariance matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Holmes, D.S., Mergen, A.E. (1993).
Improving the performance of the <code class="reqn">T^2</code> control chart.
<em>Quality Engineering</em> <b>5</b>, 619-625.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov">cov</a></code> and <code><a href="stats.html#topic+var">var</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(1:10, c(1:3, 8:5, 8:10))
z0 &lt;- cov(x)
z0
z1 &lt;- cov.MSSD(x)
z1
</code></pre>

<hr>
<h2 id='cov.weighted'>Weighted covariance matrices</h2><span id='topic+cov.weighted'></span>

<h3>Description</h3>

<p>Returns a list containing estimates of the weighted mean and covariance matrix
of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov.weighted(x, weights = rep(1, nrow(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov.weighted_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. As usual, rows are observations and columns are
variables.</p>
</td></tr>
<tr><td><code id="cov.weighted_+3A_weights">weights</code></td>
<td>
<p>a non-negative and non-zero vector of weights for each
observation. Its length must equal the number of rows of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix is divided by the number of observations, which arise for
instance, when we use the class of elliptical contoured distributions. This differs
from the behaviour of function <code><a href="stats.html#topic+cov.wt">cov.wt</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following named components:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>an estimate for the center (mean) of the data.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the estimated (weighted) covariance matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Clarke, M.R.B. (1971).
Algorithm AS 41: Updating the sample mean and dispersion matrix.
<em>Applied Statistics</em> <b>20</b>, 206-209.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov.wt">cov.wt</a></code>, <code><a href="stats.html#topic+cov">cov</a></code> and <code><a href="stats.html#topic+var">var</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(1:10, c(1:3, 8:5, 8:10))
z0 &lt;- cov.weighted(x) # all weights are 1
D2 &lt;- Mahalanobis(x, center = z0$mean, cov = z0$cov)
p &lt;- ncol(x)
wts &lt;- (p + 1) / (1 + D2) # nice weights!
z1 &lt;- cov.weighted(x, weights = wts)
z1
</code></pre>

<hr>
<h2 id='dupl.cross'>Matrix crossproduct envolving the duplication matrix</h2><span id='topic+dupl.cross'></span>

<h3>Description</h3>

<p>Given the order of two duplication matrices and a conformable matrix <code class="reqn">\bold{X}</code>,
this function performs the operation: <code class="reqn">\bold{Y} = \bold{D}_n^T\bold{X}\bold{D}_k</code>,
where <code class="reqn">\bold{D}_n</code> and <code class="reqn">\bold{D}_k</code> are duplication matrices of order <code class="reqn">n</code>
and <code class="reqn">k</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dupl.cross(n = 1, k = n, x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dupl.cross_+3A_n">n</code></td>
<td>
<p> order of the duplication matrix used pre-multiplying <code>x</code>.</p>
</td></tr>
<tr><td><code id="dupl.cross_+3A_k">k</code></td>
<td>
<p> order of the duplication matrix used post-multiplying <code>x</code>. By default
<code>k = n</code> is used.</p>
</td></tr>
<tr><td><code id="dupl.cross_+3A_x">x</code></td>
<td>
<p> numeric matrix, this argument is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls <code><a href="#topic+dupl.prod">dupl.prod</a></code> to performs the matrix multiplications required
but <b>without forming</b> any duplication matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dupl.prod">dupl.prod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D2 &lt;- duplication(n = 2, matrix = TRUE)
D3 &lt;- duplication(n = 3, matrix = TRUE)
x &lt;- matrix(1, nrow = 9, ncol = 4)
y &lt;- t(D3) %*% x %*% D2

z &lt;- dupl.cross(n = 3, k = 2, x) # D2 and D3 are not stored
all(z == y) # matrices y and z are equal!

x &lt;- matrix(1, nrow = 9, ncol = 9)
z &lt;- dupl.cross(n = 3, x = x) # same matrix is used to pre- and post-multiplying x
z # print result
</code></pre>

<hr>
<h2 id='dupl.info'>Compact information to construct the duplication matrix</h2><span id='topic+dupl.info'></span>

<h3>Description</h3>

<p>This function provides the minimum information required to create the duplication matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dupl.info(n = 1, condensed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dupl.info_+3A_n">n</code></td>
<td>
<p> order of the duplication matrix.</p>
</td></tr>
<tr><td><code id="dupl.info_+3A_condensed">condensed</code></td>
<td>
<p> logical. Information should be returned in compact form?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list containing two vectors that represent an element of
the duplication matrix and is accesed by the indexes in vectors <code>row</code> and <code>col</code>.
This information is used by function <code><a href="#topic+dupl.prod">dupl.prod</a></code> to do some operations
involving the duplication matrix without forming it. This information also can be
obtained using function <code><a href="#topic+duplication">duplication</a></code>
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p> vector of indexes, each entry represents the row index of the duplication
matrix. Only present if <code>condensed = FALSE</code>.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p> vector of indexes, each entry represents the column index of the duplication
matrix.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p> order of the duplication matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+duplication">duplication</a></code>, <code><a href="#topic+dupl.prod">dupl.prod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- dupl.info(n = 3, condensed = FALSE)
z # where are the ones in duplication of order 3?

D3 &lt;- duplication(n = 3, matrix = TRUE)
D3 # only recommended if n is very small
</code></pre>

<hr>
<h2 id='dupl.prod'>Matrix multiplication envolving the duplication matrix</h2><span id='topic+dupl.prod'></span>

<h3>Description</h3>

<p>Given the order of a duplication and a conformable matrix <code class="reqn">\bold{X}</code>, performs
one of the matrix-matrix operations:
</p>

<ul>
<li> <p><code class="reqn">\bold{Y} = \bold{DX}</code>, if <code>side = "left"</code> and <code>transposed = FALSE</code>, or
</p>
</li>
<li> <p><code class="reqn">\bold{Y} = \bold{D}^T\bold{X}</code>, if <code>side = "left"</code> and <code>transposed = TRUE</code>, or
</p>
</li>
<li> <p><code class="reqn">\bold{Y} = \bold{XD}</code>, if <code>side = "right"</code> and <code>transposed = FALSE</code>, or
</p>
</li>
<li> <p><code class="reqn">\bold{Y} = \bold{XD}^T</code>, if <code>side = "right"</code> and <code>transposed = TRUE</code>,
</p>
</li></ul>

<p>where <code class="reqn">\bold{D}</code> is the duplication matrix of order <code class="reqn">n</code>. The main aim of
<code>dupl.prod</code> is to do this matrix multiplication <b>without forming</b> the
duplication matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dupl.prod(n = 1, x, transposed = FALSE, side = "left")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dupl.prod_+3A_n">n</code></td>
<td>
<p> order of the duplication matrix.</p>
</td></tr>
<tr><td><code id="dupl.prod_+3A_x">x</code></td>
<td>
<p> numeric matrix (or vector).</p>
</td></tr>
<tr><td><code id="dupl.prod_+3A_transposed">transposed</code></td>
<td>
<p> logical. Duplication matrix should be transposed?</p>
</td></tr>
<tr><td><code id="dupl.prod_+3A_side">side</code></td>
<td>
<p> a string selecting if duplication matrix is pre-multiplying <code>x</code>, that is
<code>side = "left"</code> or post-multiplying <code>x</code>, by using <code>side = "right"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Underlying <code>C</code> code only uses information provided by <code><a href="#topic+dupl.info">dupl.info</a></code> to
performs the matrix multiplication. The duplication matrix is <b>never</b> created.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+duplication">duplication</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>D4 &lt;- duplication(n = 4, matrix = TRUE)
x &lt;- matrix(1, nrow = 16, ncol = 2)
y &lt;- crossprod(D4, x)

z &lt;- dupl.prod(n = 4, x, transposed = TRUE) # D4 is not stored
all(z == y) # matrices y and z are equal!
</code></pre>

<hr>
<h2 id='duplication'>Duplication matrix</h2><span id='topic+duplication'></span>

<h3>Description</h3>

<p>This function returns the duplication matrix of order <code class="reqn">n</code> which transforms,
for a symmetric matrix <code class="reqn">\bold{A}</code>, <code>vech</code><code class="reqn">(\bold{A})</code> into <code>vec</code><code class="reqn">(\bold{A})</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duplication(n = 1, matrix = FALSE, condensed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplication_+3A_n">n</code></td>
<td>
<p> order of the duplication matrix.</p>
</td></tr>
<tr><td><code id="duplication_+3A_matrix">matrix</code></td>
<td>
<p> a logical indicating whether the duplication matrix will be returned.</p>
</td></tr>
<tr><td><code id="duplication_+3A_condensed">condensed</code></td>
<td>
<p> logical. Information should be returned in compact form?.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function for the function <code>dupl.info</code>. This function
provides the minimum information required to create the duplication matrix. If option
<code>matrix = FALSE</code> the duplication matrix is stored in two vectors containing the
coordinate list of indexes for rows and columns. Option <code>condensed = TRUE</code> only
returns vector of indexes for the columns of duplication matrix.
</p>
<p><b>Warning:</b> <code>matrix = TRUE</code> is <b>not</b> recommended, unless the order <code>n</code>
be small. This matrix can require a huge amount of storage.
</p>


<h3>Value</h3>

<p>Returns an <code class="reqn">n^2</code> by <code class="reqn">n(n + 1)/2</code> matrix (if requested).
</p>


<h3>References</h3>

<p>Magnus, J.R., Neudecker, H. (1980).
The elimination matrix, some lemmas and applications.
<em>SIAM Journal on Algebraic Discrete Methods</em> <b>1</b>, 422-449.
</p>
<p>Magnus, J.R., Neudecker, H. (2007).
<em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>, 3rd Edition.
Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dupl.info">dupl.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- duplication(n = 100, condensed = TRUE)
object.size(z) # 40.5 Kb of storage

z &lt;- duplication(n = 100, condensed = FALSE)
object.size(z) # 80.6 Kb of storage

D100 &lt;- duplication(n = 100, matrix = TRUE)
object.size(D100) # 202 Mb of storage, do not request this matrix!

# a small example
D3 &lt;- duplication(n = 3, matrix = TRUE)
a &lt;- matrix(c( 1, 2, 3,
               2, 3, 4,
               3, 4, 5), nrow = 3)
upper &lt;- vech(a)
v &lt;- D3 %*% upper
all(vec(a) == as.vector(v)) # vectors are equal!
</code></pre>

<hr>
<h2 id='equilibrate'>Equilibration of a rectangular or symmetric matrix</h2><span id='topic+equilibrate'></span>

<h3>Description</h3>

<p>Equilibrate a rectangular or symmetric matrix using 2-norm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equilibrate(x, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equilibrate_+3A_x">x</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
<tr><td><code id="equilibrate_+3A_scale">scale</code></td>
<td>
<p> a logical value, <code>x</code> must be scaled to norm unity?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>scale = TRUE</code>, the equilibrated matrix. The scalings and an approximation
of the condition number, are returned as attributes <code>"scales"</code> and <code>"condition"</code>.
If <code>x</code> is a rectangular matrix, only the columns are equilibrated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 1, 1,
              1, 2, 1,
              1, 3, 1,
              1, 1,-1,
              1, 2,-1,
              1, 3,-1), ncol = 3, byrow = TRUE)
z &lt;- equilibrate(x)
apply(z, 2, function(x) sum(x^2)) # all 1

xx &lt;- crossprod(x)
equilibrate(xx)
</code></pre>

<hr>
<h2 id='frank'>Frank matrix</h2><span id='topic+frank'></span>

<h3>Description</h3>

<p>This function returns the Frank matrix of order <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frank(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frank_+3A_n">n</code></td>
<td>
<p> order of the Frank matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Frank matrix of order <code class="reqn">n</code> is a square matrix <code class="reqn">\bold{F}_n = (f_{ij})</code> defined as
</p>
<p style="text-align: center;"><code class="reqn">f_{ij} = \left\{ {\begin{array}{ll}
    n - j + 1, &amp; i \le j, \\
    n - j, &amp; i = j + 1, \\
    0, &amp; i \ge j + 2
  \end{array}} \right.</code>
</p>



<h3>Value</h3>

<p>Returns an <code class="reqn">n</code> by <code class="reqn">n</code> matrix.
</p>


<h3>References</h3>

<p>Frank, W.L. (1958).
Computing eigenvalues of complex matrices by determinant evaluation and by methods of Danilewski and Wielandt.
<em>Journal of the Society for Industrial and Applied Mathematics</em> <b>6</b>, 378-392.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>F5 &lt;- frank(n = 5)
det(F5) # equals 1
</code></pre>

<hr>
<h2 id='geomean'>Geometric mean</h2><span id='topic+geomean'></span>

<h3>Description</h3>

<p>It calculates the geometric mean using a Fused-Multiply-and-Add (FMA) compensated scheme
for accurate computation of floating-point product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geomean(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geomean_+3A_x">x</code></td>
<td>
<p>a numeric vector containing the sample observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> contains any non-positive values, <code>geomean</code> returns <code>NA</code> and
a warning message is displayed.
</p>
<p>The geometric mean is a measure of central tendency, which is defined as
</p>
<p style="text-align: center;"><code class="reqn">G = \sqrt[n]{x_1 x_2 \ldots x_n} = \Big(\prod_{i=1}^n x_i\Big)^{1/n}.</code>
</p>

<p>This procedure calculates the product required in the geometric mean safely using
a compensated scheme as proposed by Graillat (2009).
</p>


<h3>Value</h3>

<p>The geometric mean of the sample, a non-negative number.
</p>


<h3>References</h3>

<p>Graillat, S. (2009).
Accurate floating-point product and exponentiation.
<em>IEEE Transactions on Computers</em> <b>58</b>, 994-1000.
</p>
<p>Oguita, T., Rump, S.M., Oishi, S. (2005).
Accurate sum and dot product.
<em>SIAM Journal on Scientific Computing</em> <b>26</b>, 1955-1988.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+median">median</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(149)
x &lt;- rlnorm(1000)
mean(x)    # 1.68169
median(x)  # 0.99663
geomean(x) # 1.01688
</code></pre>

<hr>
<h2 id='hadamard'>Hadamard product of two matrices</h2><span id='topic+hadamard'></span>

<h3>Description</h3>

<p>This function returns the Hadamard or element-wise product of two matrices <code>x</code>
and <code>y</code>, that have the same dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hadamard(x, y = x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hadamard_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector.</p>
</td></tr>
<tr><td><code id="hadamard_+3A_y">y</code></td>
<td>
<p> a numeric matrix or vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the same dimension of <code>x</code> (and <code>y</code>) which corresponds to the
element-by-element product of the two matrices.
</p>


<h3>References</h3>

<p>Styan, G.P.H. (1973).
Hadamard products and multivariate statistical analysis,
<em>Linear Algebra and Its Applications</em> <b>6</b>, 217-240.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rep(1:10, times = 5), ncol = 5)
y &lt;- matrix(rep(1:5, each = 10), ncol = 5)
z &lt;- hadamard(x, y)
z
</code></pre>

<hr>
<h2 id='harris.test'>Test for variance homogeneity of correlated variables</h2><span id='topic+harris.test'></span>

<h3>Description</h3>

<p>Performs large-sample methods for testing equality of <code class="reqn">p \ge 2</code> correlated variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harris.test(x, test = "Wald")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harris.test_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. As usual, rows are observations and columns are variables.</p>
</td></tr>
<tr><td><code id="harris.test_+3A_test">test</code></td>
<td>
<p> test statistic to be used. One of &quot;Wald&quot; (default), &quot;log&quot;, &quot;robust&quot; or &quot;log-robust&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'harris.test' with the following elements:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the statistic, i.e. the value of either Wald test, using the log-transformation,
or distribution-robust versions of the test (robust and log-robust).</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p> the degrees of freedom for the test statistic, which is chi-square distributed.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> the p-value for the test.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p> the estimated covariance matrix.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> a character string indicating what type of test was performed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Harris, P. (1985).
Testing the variance homogeneity of correlated variables.
<em>Biometrika</em> <b>72</b>, 103-107.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iris[,1:4]
z &lt;- harris.test(x, test = "robust")
z
</code></pre>

<hr>
<h2 id='helmert'>Helmert matrix</h2><span id='topic+helmert'></span>

<h3>Description</h3>

<p>This function returns the Helmert matrix of order <code class="reqn">n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helmert(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helmert_+3A_n">n</code></td>
<td>
<p> order of the Helmert matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Helmert matrix of order <code class="reqn">n</code> is a square matrix defined as
</p>
<p style="text-align: center;"><code class="reqn">\bold{H}_n = \left[ {\begin{array}{ccccc}
    1/\sqrt{n} &amp; 1/\sqrt{n} &amp; 1/\sqrt{n} &amp; \dots &amp; 1/\sqrt{n} \\
    1/\sqrt{2} &amp; -1/\sqrt{2} &amp; 0 &amp; \dots &amp; 0 \\
    1/\sqrt{6} &amp; 1/\sqrt{6} &amp; -2/\sqrt{6} &amp; \dots &amp; 0 \\
    \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    \frac{1}{\sqrt{n(n-1)}} &amp; \frac{1}{\sqrt{n(n-1)}} &amp; \frac{1}{\sqrt{n(n-1)}} &amp; \dots &amp; -\frac{(n-1)}{\sqrt{n(n-1)}}
  \end{array}} \right].</code>
</p>

<p>Helmert matrix is orthogonal and is frequently used in the analysis of variance (ANOVA).
</p>


<h3>Value</h3>

<p>Returns an <code class="reqn">n</code> by <code class="reqn">n</code> matrix.
</p>


<h3>References</h3>

<p>Lancaster, H.O. (1965).
The Helmert matrices.
<em>The American Mathematical Monthly</em> <b>72</b>, 4-12.
</p>
<p>Gentle, J.E. (2007).
<em>Matrix Algebra: Theory, Computations, and Applications in Statistics</em>.
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
set.seed(149)
x &lt;- rnorm(n)

H &lt;- helmert(n)
object.size(H) # 7.63 Mb of storage
K &lt;- H[2:n,]
z &lt;- c(K %*% x)
sum(z^2) # 933.1736

# same that
(n - 1) * var(x)
</code></pre>

<hr>
<h2 id='is.lower.tri'>Check if a matrix is lower or upper triangular</h2><span id='topic+is.lower.tri'></span><span id='topic+is.upper.tri'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if the given matrix is lower or upper triangular matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.lower.tri(x, diag = FALSE)
is.upper.tri(x, diag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.lower.tri_+3A_x">x</code></td>
<td>
<p>a matrix of other <span class="rlang"><b>R</b></span> object with <code>length(dim(x)) = 2</code>.</p>
</td></tr>
<tr><td><code id="is.lower.tri_+3A_diag">diag</code></td>
<td>
<p>logical. Should the diagonal be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Check if a matrix is lower or upper triangular. You can also include diagonal to the check.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lower.tri">lower.tri</a></code>, <code><a href="base.html#topic+upper.tri">upper.tri</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- matrix(rnorm(10 * 3), ncol = 3)
  R &lt;- chol(crossprod(x))

  is.lower.tri(R)
  is.upper.tri(R)
</code></pre>

<hr>
<h2 id='jacobi'>Solve linear systems using the Jacobi method</h2><span id='topic+jacobi'></span>

<h3>Description</h3>

<p>Jacobi method is an iterative algorithm for solving a system of linear equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jacobi(a, b, start, maxiter = 200, tol = 1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jacobi_+3A_a">a</code></td>
<td>
<p> a square numeric matrix containing the coefficients of the linear system.</p>
</td></tr>
<tr><td><code id="jacobi_+3A_b">b</code></td>
<td>
<p> a vector of right-hand sides of the linear system.</p>
</td></tr>
<tr><td><code id="jacobi_+3A_start">start</code></td>
<td>
<p> a vector for initial starting point.</p>
</td></tr>
<tr><td><code id="jacobi_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. Defaults to <code>200</code></p>
</td></tr>
<tr><td><code id="jacobi_+3A_tol">tol</code></td>
<td>
<p> tolerance level for stopping iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\bold{D}</code>, <code class="reqn">\bold{L}</code>, and <code class="reqn">\bold{U}</code> denote the diagonal, lower
triangular and upper triangular parts of a matrix <code class="reqn">\bold{A}</code>. Jacobi's method
solve the equation <code class="reqn">\bold{Ax} = \bold{b}</code>, iteratively by rewriting <code class="reqn">\bold{Dx}
  + (\bold{L} + \bold{U})\bold{x} = \bold{b}</code>. Assuming that <code class="reqn">\bold{D}</code> is nonsingular
leads to the iteration formula
</p>
<p style="text-align: center;"><code class="reqn">\bold{x}^{(k+1)} = -\bold{D}^{-1}(\bold{L} + \bold{U})\bold{x}^{(k)} + \bold{D}^{-1}\bold{b}</code>
</p>



<h3>Value</h3>

<p>a vector with the approximate solution, the iterations performed are returned
as the attribute 'iterations'.
</p>


<h3>References</h3>

<p>Golub, G.H., Van Loan, C.F. (1996).
<em>Matrix Computations</em>, 3rd Edition.
John Hopkins University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seidel">seidel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(5,-3,2,-2,9,-1,3,1,-7), ncol = 3)
b &lt;- c(-1,2,3)
start &lt;- c(1,1,1)
z &lt;- jacobi(a, b, start)
z # converged in 15 iterations
</code></pre>

<hr>
<h2 id='JarqueBera.test'>Jarque-Bera test for univariate normality</h2><span id='topic+JarqueBera.test'></span>

<h3>Description</h3>

<p>Performs an omnibus test for univariate normality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JarqueBera.test(x, test = "DH")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JarqueBera.test_+3A_x">x</code></td>
<td>
<p> a numeric vector containing the sample observations.</p>
</td></tr>
<tr><td><code id="JarqueBera.test_+3A_test">test</code></td>
<td>
<p> test statistic to be used. One of &quot;DH&quot; (Doornik-Hansen, the default), &quot;JB&quot; (Jarque-Bera), 
&quot;robust&quot; (robust modification by Gel and Gastwirth), &quot;ALM&quot; (Adjusted Lagrange multiplier).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class 'JarqueBera.test' with the following elements:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p> value of the statistic, i.e. the value of either Doornik-Hansen, Jarque-Bera, or 
Adjusted Lagrange multiplier test.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p> the degrees of freedom for the test statistic, which is chi-square distributed.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p> the p-value for the test.</p>
</td></tr>
<tr><td><code>skewness</code></td>
<td>
<p> the estimated skewness coefficient.</p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p> the estimated kurtosis coefficient.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> a character string indicating what type of test was performed.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Doornik, J.A., Hansen, H. (2008).
An omnibus test for univariate and multivariate normality.
<em>Oxford Bulletin of Economics and Statistics</em> <b>70</b>, 927-939.
</p>
<p>Gel, Y.R., Gastwirth, J.L. (2008).
A robust modification of the Jarque-Bera test of normality.
<em>Economics Letters</em> <b>99</b>, 30-32.
</p>
<p>Jarque, C.M., Bera, A.K. (1980).
Efficient tests for normality, homoscedasticity and serial independence of regression residuals.
<em>Economics Letters</em> <b>6</b>, 255-259.
</p>
<p>Urzua, C.M. (1996).
On the correct use of omnibus tests for normality.
<em>Economics Letters</em> <b>53</b>, 247-251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(149)
x &lt;- rnorm(100)
z &lt;- JarqueBera.test(x, test = "DH")
z

set.seed(173)
x &lt;- runif(100)
z &lt;- JarqueBera.test(x, test = "DH")
z
</code></pre>

<hr>
<h2 id='kronecker.prod'>Kronecker product on matrices</h2><span id='topic+kronecker.prod'></span>

<h3>Description</h3>

<p>Computes the kronecker product of two matrices, <code>x</code> and <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kronecker.prod(x, y = x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kronecker.prod_+3A_x">x</code></td>
<td>
<p> a numeric matrix or vector.</p>
</td></tr>
<tr><td><code id="kronecker.prod_+3A_y">y</code></td>
<td>
<p> a numeric matrix or vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\bold{X}</code> be an <code class="reqn">m\times n</code> and <code class="reqn">\bold{Y}</code> a <code class="reqn">p\times q</code> matrix.
The <code class="reqn">mp\times nq</code> matrix defined by
</p>
<p style="text-align: center;"><code class="reqn">\left[{\begin{array}{ccc}
    x_{11}\bold{Y} &amp; \dots &amp; x_{1n}\bold{Y} \\
    \vdots &amp; &amp; \vdots \\
    x_{m1}\bold{Y} &amp; \dots &amp; x_{mn}\bold{Y}
  \end{array}}\right],</code>
</p>

<p>is called the <em>Kronecker product</em> of <code class="reqn">\bold{X}</code> and <code class="reqn">\bold{Y}</code>.
</p>


<h3>Value</h3>

<p>An array with dimensions <code>dim(x) * dim(y)</code>.
</p>


<h3>References</h3>

<p>Magnus, J.R., Neudecker, H. (2007).
<em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>, 3rd Edition.
Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+kronecker">kronecker</a></code> function from <code>base</code> package is based on <code><a href="base.html#topic+outer">outer</a></code>.
Our <code>C</code> version is slightly faster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># block diagonal matrix:
a &lt;- diag(1:3)
b &lt;- matrix(1:4, ncol = 2)
kronecker.prod(a, b)

# examples with vectors
ones &lt;- rep(1, 4)
y &lt;- 1:3
kronecker.prod(ones, y) # 12-dimensional vector
kronecker.prod(ones, t(y)) # 3 x 3 matrix
</code></pre>

<hr>
<h2 id='krylov'>Computes a Krylov matrix</h2><span id='topic+krylov'></span>

<h3>Description</h3>

<p>Given <code class="reqn">\bold{A}</code> an <code class="reqn">n</code> by <code class="reqn">n</code> real matrix and an <code class="reqn">n</code>-vector <code class="reqn">\bold{b}</code>,
this function constructs the Krylov matrix <code class="reqn">\bold{K}</code>, where
</p>
<p style="text-align: center;"><code class="reqn">\bold{K} = [\bold{b},\bold{Ab},\dots,\bold{A}^{m-1}\bold{b}].</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>krylov(a, b, m = ncol(a))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krylov_+3A_a">a</code></td>
<td>
<p> a numeric square matrix of order <code class="reqn">n</code> by <code class="reqn">n</code> for which the Krylov
matrix is to be computed.</p>
</td></tr>
<tr><td><code id="krylov_+3A_b">b</code></td>
<td>
<p> a numeric vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="krylov_+3A_m">m</code></td>
<td>
<p> length of the Krylov sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an <code class="reqn">n</code> by <code class="reqn">m</code> matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(1, 3, 2, -5, 1, 7, 1, 5, -4), ncol = 3, byrow = TRUE)
b &lt;- c(1, 1, 1)
k &lt;- krylov(a, b, m = 4)
k
</code></pre>

<hr>
<h2 id='kurtosis'>Mardia's multivariate skewness and kurtosis coefficients</h2><span id='topic+kurtosis'></span><span id='topic+skewness'></span>

<h3>Description</h3>

<p>Functions to compute measures of multivariate skewness <code class="reqn">(b_{1p})</code> and kurtosis
<code class="reqn">(b_{2p})</code> proposed by Mardia (1970),
</p>
<p style="text-align: center;"><code class="reqn">b_{1p} = \frac{1}{n^2}\sum\limits_{i=1}^n\sum\limits_{j=1}^n ((\bold{x}_i -
  \overline{\bold{x}})^T\bold{S}^{-1}(\bold{x}_j - \overline{\bold{x}}))^3,</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">b_{2p} = \frac{1}{n}\sum\limits_{i=1}^n ((\bold{x}_i - \overline{\bold{x}})^T
  \bold{S}^{-1}(\bold{x}_j - \overline{\bold{x}}))^2.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>kurtosis(x)

skewness(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kurtosis_+3A_x">x</code></td>
<td>
<p> matrix of data with, say, <code class="reqn">p</code> columns.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mardia, K.V. (1970).
Measures of multivariate skewness and kurtosis with applications.
<em>Biometrika</em> <b>57</b>, 519-530.
</p>
<p>Mardia, K.V., Zemroch, P.J. (1975).
Algorithm AS 84: Measures of multivariate skewness and kurtosis.
<em>Applied Statistics</em> <b>24</b>, 262-265.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setosa &lt;- iris[1:50,1:4]
kurtosis(setosa)
skewness(setosa)
</code></pre>

<hr>
<h2 id='ldl'>The LDL decomposition</h2><span id='topic+ldl'></span>

<h3>Description</h3>

<p>Compute the LDL decomposition of a real symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ldl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ldl_+3A_x">x</code></td>
<td>
<p> a symmetric numeric matrix whose LDL decomposition is to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The factorization has the form <code class="reqn">\bold{X} = \bold{LDL}^T</code>, where <code class="reqn">\bold{D}</code>
is a diagonal matrix and <code class="reqn">\bold{L}</code> is unitary lower triangular.
</p>
<p>The LDL decomposition of <code class="reqn">\bold{x}</code> is returned as a list with components:
</p>
<table>
<tr><td><code>lower</code></td>
<td>
<p> the unitary lower triangular factor <code class="reqn">\bold{L}</code>.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p> a vector containing the diagonal elements of <code class="reqn">\bold{D}</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Golub, G.H., Van Loan, C.F. (1996).
<em>Matrix Computations</em>, 3rd Edition.
John Hopkins University Press.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(2,-1,0,-1,2,-1,0,-1,1), ncol = 3)
z &lt;- ldl(a)
z # information of LDL factorization

# computing det(a)
prod(z$d) # product of diagonal elements of D

# a non-positive-definite matrix
m &lt;- matrix(c(5,-5,-5,3), ncol = 2)
try(chol(m)) # fails
ldl(m)
</code></pre>

<hr>
<h2 id='lu'>The LU factorization of a square matrix</h2><span id='topic+lu'></span><span id='topic+lu.default'></span><span id='topic+solve.lu'></span><span id='topic+is.lu'></span>

<h3>Description</h3>

<p><code>lu</code> computes the LU factorization of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lu(x)
## Default S3 method:
lu(x)

## S3 method for class 'lu'
solve(a, b, ...)

is.lu(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lu_+3A_x">x</code></td>
<td>
<p>a square numeric matrix whose LU factorization is to be computed.</p>
</td></tr>
<tr><td><code id="lu_+3A_a">a</code></td>
<td>
<p>an LU factorization of a square matrix.</p>
</td></tr>
<tr><td><code id="lu_+3A_b">b</code></td>
<td>
<p>a vector or matrix of right-hand sides of equations.</p>
</td></tr>
<tr><td><code id="lu_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LU factorization plays an important role in many numerical procedures. In
particular it is the basic method to solve the equation <code class="reqn">\bold{Ax} = \bold{b}</code>
for given matrix <code class="reqn">\bold{A}</code>, and vector <code class="reqn">\bold{b}</code>.
</p>
<p><code>solve.lu</code> is the method for <code><a href="base.html#topic+solve">solve</a></code> for <code>lu</code> objects.
</p>
<p><code>is.lu</code> returns <code>TRUE</code> if <code>x</code> is a <code><a href="base.html#topic+list">list</a></code>
and <code><a href="base.html#topic+inherits">inherits</a></code> from <code>"lu"</code>.
</p>
<p>Unsuccessful results from the underlying LAPACK code will result in an
error giving a positive error code: these can only be interpreted by
detailed study of the <code>Fortran</code> code.
</p>


<h3>Value</h3>

<p>The LU factorization of the matrix as computed by LAPACK. The components in
the returned value correspond directly to the values returned by <code>DGETRF</code>.
</p>
<table>
<tr><td><code>lu</code></td>
<td>
<p>a matrix with the same dimensions as <code>x</code>.
The upper triangle contains the <code class="reqn">\bold{U}</code> of the decomposition
and the strict lower triangle contains information on the <code class="reqn">\bold{L}</code> of
the factorization.</p>
</td></tr>
<tr><td><code>pivot</code></td>
<td>
<p>information on the pivoting strategy used during
the factorization.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To compute the determinant of a matrix (do you <em>really</em> need it?),
the LU factorization is much more efficient than using eigenvalues
(<code><a href="base.html#topic+eigen">eigen</a></code>).  See <code><a href="base.html#topic+det">det</a></code>.
</p>
<p>LAPACK uses column pivoting and does not attempt to detect rank-deficient matrices.
</p>


<h3>References</h3>

<p>Anderson. E., Bai, Z., Bischof, C., Blackford, S., Demmel, J., Dongarra, J.,
Du Croz, J., Greenbaum, A., Hammarling, S., McKenney, A. Sorensen, D. (1999).
<em>LAPACK Users' Guide</em>, 3rd Edition. SIAM.
</p>
<p>Golub, G.H., Van Loan, C.F. (1996).
<em>Matrix Computations</em>, 3rd Edition.
John Hopkins University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extractL">extractL</a></code>,  <code><a href="#topic+extractU">extractU</a></code>,  <code><a href="#topic+constructX">constructX</a></code> for
reconstruction of the matrices,
<code><a href="#topic+lu2inv">lu2inv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(3,2,6,17,4,18,10,-2,-12), ncol = 3)
z &lt;- lu(a)
z # information of LU factorization

# computing det(a)
prod(diag(z$lu)) # product of diagonal elements of U

# solve linear equations
b &lt;- matrix(1:6, ncol = 2)
solve(z, b)
</code></pre>

<hr>
<h2 id='lu-methods'>Reconstruct the L, U, or X matrices from an LU object</h2><span id='topic+constructX'></span><span id='topic+extractL'></span><span id='topic+extractU'></span>

<h3>Description</h3>

<p>Returns the original matrix from which the object was constructed or
the components of the factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructX(x)
extractL(x)
extractU(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lu-methods_+3A_x">x</code></td>
<td>
<p>object representing an LU factorization. This will typically have
come from a previous call to <code><a href="#topic+lu">lu</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>constructX</code> returns <code class="reqn">\bold{X}</code>, the original matrix from which the <code>lu</code>
object was constructed (because of the pivoting the <code class="reqn">\bold{X}</code> matrix is not exactly
the product between <code class="reqn">\bold{L}</code> and <code class="reqn">\bold{U}</code>).
</p>
<p><code>extractL</code> returns <code class="reqn">\bold{L}</code>. This may be pivoted.
</p>
<p><code>extractU</code> returns <code class="reqn">\bold{U}</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lu">lu</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(10,-3,5,-7,2,-1,0,6,5), ncol = 3)
z &lt;- lu(a)
L &lt;- extractL(z)
L
U &lt;- extractU(z)
U
X &lt;- constructX(z)
all(a == X)
</code></pre>

<hr>
<h2 id='lu2inv'>Inverse from LU factorization</h2><span id='topic+lu2inv'></span>

<h3>Description</h3>

<p>Invert a square matrix from its LU factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lu2inv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lu2inv_+3A_x">x</code></td>
<td>
<p>object representing an LU factorization. This will typically have
come from a previous call to <code><a href="#topic+lu">lu</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse of the matrix whose LU factorization was given.
</p>
<p>Unsuccessful results from the underlying LAPACK code will result in an
error giving a positive error code: these can only be interpreted by
detailed study of the <code>Fortran</code> code.
</p>


<h3>Source</h3>

<p>This is an interface to the LAPACK routine <code>DGETRI</code>. LAPACK is from
<a href="https://netlib.org/lapack/">https://netlib.org/lapack/</a> and its guide is listed in the references.
</p>


<h3>References</h3>

<p>Anderson. E., Bai, Z., Bischof, C., Blackford, S., Demmel, J., Dongarra, J.,
Du Croz, J., Greenbaum, A., Hammarling, S., McKenney, A. Sorensen, D. (1999).
<em>LAPACK Users' Guide</em>, 3rd Edition. SIAM.
</p>
<p>Golub, G.H., Van Loan, C.F. (1996).
<em>Matrix Computations</em>, 3rd Edition.
John Hopkins University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lu">lu</a></code>, <code><a href="base.html#topic+solve">solve</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(3,2,6,17,4,18,10,-2,-12), ncol = 3)
z &lt;- lu(a)
a %*% lu2inv(z)
</code></pre>

<hr>
<h2 id='Mahalanobis'>Mahalanobis distance</h2><span id='topic+Mahalanobis'></span>

<h3>Description</h3>

<p>Returns the squared Mahalanobis distance of all rows in <code class="reqn">\bold{x}</code> and the
vector <code class="reqn">\bold{\mu}</code> = <code>center</code> with respect to <code class="reqn">\bold{\Sigma}</code> = <code>cov</code>.
This is (for vector <code class="reqn">\bold{x}</code>) defined as
</p>
<p style="text-align: center;"><code class="reqn">D^2 = (\bold{x} - \bold{\mu})^T \bold{\Sigma}^{-1} (\bold{x} - \bold{\mu})</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>Mahalanobis(x, center, cov, inverted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mahalanobis_+3A_x">x</code></td>
<td>
<p>vector or matrix of data. As usual, rows are observations and columns are
variables.</p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_center">center</code></td>
<td>
<p>mean vector of the distribution.</p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_cov">cov</code></td>
<td>
<p>covariance matrix (<code class="reqn">p \times p</code>) of the distribution, must
be positive definite.</p>
</td></tr>
<tr><td><code id="Mahalanobis_+3A_inverted">inverted</code></td>
<td>
<p>logical. If <code>TRUE</code>, <code>cov</code> is supposed to contain the
<em>inverse</em> of the covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike function <code>mahalanobis</code>, the covariance matrix is factorized using the
Cholesky decomposition, which allows to assess if <code>cov</code> is positive definite.
Unsuccessful results from the underlying LAPACK code will result in an error message.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov">cov</a></code>, <code><a href="stats.html#topic+mahalanobis">mahalanobis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(1:6, 1:3)
xbar &lt;- colMeans(x)
S &lt;- matrix(c(1,4,4,1), ncol = 2) # is negative definite
D2 &lt;- mahalanobis(x, center = xbar, S)
all(D2 &gt;= 0) # several distances are negative

## next command produces the following error:
## Covariance matrix is possibly not positive-definite
## Not run: D2 &lt;- Mahalanobis(x, center = xbar, S)
</code></pre>

<hr>
<h2 id='matrix.inner'>Compute the inner product between two rectangular matrices</h2><span id='topic+matrix.inner'></span>

<h3>Description</h3>

<p>Computes the inner product between two rectangular matrices calling BLAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.inner(x, y = x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.inner_+3A_x">x</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
<tr><td><code id="matrix.inner_+3A_y">y</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a real value, indicating the inner product between two matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 1, 1,
              1, 2, 1,
              1, 3, 1,
              1, 1,-1,
              1, 2,-1,
              1, 3,-1), ncol = 3, byrow = TRUE)
y &lt;- matrix(1, nrow = 6, ncol = 3)
matrix.inner(x, y)

# must be equal
matrix.norm(x, type = "Frobenius")^2
matrix.inner(x)
</code></pre>

<hr>
<h2 id='matrix.norm'>Compute the norm of a rectangular matrix</h2><span id='topic+matrix.norm'></span>

<h3>Description</h3>

<p>Computes a matrix norm of <code>x</code> using LAPACK. The norm can be the one (<code>"1"</code>)
norm, the infinity (<code>"inf"</code>) norm, the Frobenius norm, the maximum modulus
(<code>"maximum"</code>) among elements of a matrix, as determined by the value of <code>type</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.norm(x, type = "Frobenius")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.norm_+3A_x">x</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
<tr><td><code id="matrix.norm_+3A_type">type</code></td>
<td>
<p> character string, specifying the <em>type</em> of matrix norm to be computed.
A character indicating the type of norm desired.
</p>

<dl>
<dt><code>"1"</code></dt><dd><p> specifies the <b>one</b> norm,	(maximum absolute column sum);</p>
</dd>
<dt><code>"Inf"</code></dt><dd><p> specifies the <b>inf</b>inity norm (maximum absolute row sum);</p>
</dd>
<dt><code>"Frobenius"</code></dt><dd><p> specifies the <b>Frobenius</b> norm (the	Euclidean norm of
<code>x</code> treated as if it were a vector);</p>
</dd>
<dt><code>"maximum"</code></dt><dd><p> specifies the <b>maximum</b> modulus of all the elements in
<code>x</code>.</p>
</dd>
</dl>

</td></tr></table>


<h3>Details</h3>

<p>As function <code>norm</code> in package <span class="pkg">base</span>, method of <code>matrix.norm</code> calls
the LAPACK function <code>DLANGE</code>.
</p>
<p>Note that the 1-, <code>Inf</code>- and maximum norm is faster to calculate than the Frobenius one.
</p>


<h3>Value</h3>

<p>The matrix norm, a non-negative number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a tiny example
x &lt;- matrix(c(1, 1, 1,
              1, 2, 1,
              1, 3, 1,
              1, 1,-1,
              1, 2,-1,
              1, 3,-1), ncol = 3, byrow = TRUE)
matrix.norm(x, type = "Frobenius")
matrix.norm(x, type = "1")
matrix.norm(x, type = "Inf")

# an example not that small
n &lt;- 1000
x &lt;- .5 * diag(n) + 0.5 * matrix(1, nrow = n, ncol = n)
matrix.norm(x, type = "Frobenius")
matrix.norm(x, type = "1")
matrix.norm(x, type = "Inf")
matrix.norm(x, type = "maximum") # equal to 1
</code></pre>

<hr>
<h2 id='mchol'>The modified Cholesky factorization</h2><span id='topic+mchol'></span>

<h3>Description</h3>

<p>Compute the Cholesky factorization of a real symmetric but not necessarily positive 
definite matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mchol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mchol_+3A_x">x</code></td>
<td>
<p> a symmetric but not necessarily positive definite matrix to be factored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lower triangular factor of modified Cholesky decomposition, i.e., the matrix 
<code class="reqn">\bold{L}</code> such that <code class="reqn">\bold{X} + \bold{E} = \bold{LL}^T</code>, where <code class="reqn">\bold{E}</code> 
is a nonnegative diagonal matrix that is zero if <code class="reqn">\bold{X}</code> es sufficiently positive 
definite.
</p>


<h3>References</h3>

<p>Gill, P.E., Murray, W., Wright, M.H. (1981).
<em>Practical Optimization</em>.
Academic Press, London.
</p>
<p>Nocedal, J., Wright, S.J. (1999).
<em>Numerical Optimization</em>.
Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code>, <code><a href="#topic+ldl">ldl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a non-positive-definite matrix
a &lt;- matrix(c(4,2,1,2,6,3,1,3,-.004), ncol = 3)
try(chol(a)) # fails
z &lt;- mchol(a)
z # triangular factor

# modified 'a' matrix
tcrossprod(z)
</code></pre>

<hr>
<h2 id='mediancenter'>Mediancenter</h2><span id='topic+mediancenter'></span>

<h3>Description</h3>

<p>It calculates the mediancenter (or geometric median) of multivariate data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mediancenter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mediancenter_+3A_x">x</code></td>
<td>
<p>a matrix or data frame. As usual, rows are observations and columns are
variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mediancenter for a sample of multivariate observations is computed using a
steepest descend method combined with bisection. The mediancenter invariant to
rotations of axes and is useful as a multivariate generalization of the median
of univariate sample.
</p>


<h3>Value</h3>

<p>A list containing the following named components:
</p>
<table>
<tr><td><code>median</code></td>
<td>
<p>an estimate for the mediancenter of the data.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations performed, it is negative if a degenerate
solution is found.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gower, J.C. (1974).
Algorithm AS 78: The mediancentre.
<em>Applied Statistics</em> <b>23</b>, 466-470.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov.wt">cov.wt</a></code>, <code><a href="stats.html#topic+median">median</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(1:10, c(1:3, 8:5, 8:10))
z &lt;- mediancenter(x)$median # degenerate solution
xbar &lt;- colMeans(x)
plot(x, xlab = "", ylab = "")
points(x = xbar[1], y = xbar[2], pch = 16, col = "red")
points(x = z[1], y = z[2], pch = 3, col = "blue", lwd = 2)
</code></pre>

<hr>
<h2 id='minkowski'>Computes the p-norm of a vector</h2><span id='topic+minkowski'></span>

<h3>Description</h3>

<p>Computes a <code class="reqn">p</code>-norm of vector <code class="reqn">\bold{x}</code>. The norm can be the one (<code class="reqn">p = 1</code>)
norm, Euclidean (<code class="reqn">p = 2</code>) norm, the infinity (<code class="reqn">p</code> = <code>Inf</code>) norm. The underlying
<code>C</code> or <code>Fortran</code> code is inspired on ideas of BLAS Level 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minkowski(x, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minkowski_+3A_x">x</code></td>
<td>
<p> a numeric vector.</p>
</td></tr>
<tr><td><code id="minkowski_+3A_p">p</code></td>
<td>
<p> a number, specifying the <em>type</em> of norm desired. Possible values include
real number greater or equal to 1, or Inf, Default value is <code class="reqn">p = 2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method of <code>minkowski</code> for <code class="reqn">p</code> = <code>Inf</code> calls <code>idamax</code> BLAS function.
For other values, <code>C</code> or <code>Fortran</code> subroutines using unrolled cycles are
called.
</p>


<h3>Value</h3>

<p>The vector <code class="reqn">p</code>-norm, a non-negative number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a tiny example
x &lt;- rnorm(1000)
minkowski(x, p = 1)
minkowski(x, p = 1.5)
minkowski(x, p = 2)
minkowski(x, p = Inf)

x &lt;- x / minkowski(x)
minkowski(x, p = 2) # equal to 1
</code></pre>

<hr>
<h2 id='moments'>Central moments</h2><span id='topic+moments'></span>

<h3>Description</h3>

<p>It calculates up to fourth central moments (or moments about the mean), and the
skewness and kurtosis coefficients using an online algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moments(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moments_+3A_x">x</code></td>
<td>
<p>a numeric vector containing the sample observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code class="reqn">k</code>-th central moment is defined as
</p>
<p style="text-align: center;"><code class="reqn">m_k = \frac{1}{n}\sum_{i=1}^n (x_i - \overline{x})^k.</code>
</p>

<p>In particular, the second central moment is the variance of the sample. The sample
skewness and kurtosis are defined, respectively, as
</p>
<p style="text-align: center;"><code class="reqn">b_1 = \frac{m_3}{m_2^{3/2}}, \qquad b_2 = \frac{m_4}{m_2^2}.</code>
</p>



<h3>Value</h3>

<p>A list containing <code>second</code>, <code>third</code> and <code>fourth</code> central moments,
and <code>skewness</code> and <code>kurtosis</code> coefficients.
</p>


<h3>References</h3>

<p>Spicer, C.C. (1972).
Algorithm AS 52: Calculation of power sums of deviations about the mean.
<em>Applied Statistics</em> <b>21</b>, 226-227.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+var">var</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(149)
x &lt;- rnorm(1000)
z &lt;- moments(x)
z
</code></pre>

<hr>
<h2 id='ols'>Fit linear regression model</h2><span id='topic+ols'></span>

<h3>Description</h3>

<p>Returns an object of class <code>"ols"</code> that represents a linear model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ols(formula, data, subset, na.action, method = "qr", tol = 1e-7, maxiter = 100,
  x = FALSE, y = FALSE, contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ols_+3A_formula">formula</code></td>
<td>
<p> an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the model to
be fitted.</p>
</td></tr>
<tr><td><code id="ols_+3A_data">data</code></td>
<td>
<p> an optional data frame, list or environment (or object coercible
by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in
the model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>ols</code>
is called.</p>
</td></tr>
<tr><td><code id="ols_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="ols_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of
<code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.</p>
</td></tr>
<tr><td><code id="ols_+3A_method">method</code></td>
<td>
<p>the least squares fitting method to be used; the options are <code>"cg"</code>
(conjugate gradients), <code>"chol"</code>, <code>"qr"</code> (the default), <code>"svd"</code> and
<code>"sweep"</code>.</p>
</td></tr>
<tr><td><code id="ols_+3A_tol">tol</code></td>
<td>
<p> tolerance for the conjugate gradients (<code>gc</code>) method. Default is
<code>tol = 1e-7</code>.</p>
</td></tr>
<tr><td><code id="ols_+3A_maxiter">maxiter</code></td>
<td>
<p> The maximum number of iterations for the conjugate gradients (<code>gc</code>)
method. Defaults to 100.</p>
</td></tr>
<tr><td><code id="ols_+3A_x">x</code>, <code id="ols_+3A_y">y</code></td>
<td>
<p> logicals.  If <code>TRUE</code> the corresponding components of
the fit (the model matrix, the response) are returned.</p>
</td></tr>
<tr><td><code id="ols_+3A_contrasts">contrasts</code></td>
<td>
<p> an optional list. See the <code>contrasts.arg</code> of
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="ols_+3A_...">...</code></td>
<td>
<p> additional arguments (currently disregarded).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ols</code> returns an object of <code><a href="base.html#topic+class">class</a></code> <code>"ols"</code>.
</p>
<p>The function <code>summary</code> is used to obtain and print a summary of the
results.  The generic accessor functions <code>coefficients</code>, <code>fitted.values</code>
and <code>residuals</code> extract various useful features of the value returned by <code>ols</code>.
</p>
<p>An object of class <code>"ols"</code> is a list containing at least the
following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>the residual sum of squares.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>a <code class="reqn">p \times p</code> matrix of (unscaled)
covariances of the <code class="reqn">\hat\beta_j</code>, <code class="reqn">j=1, \dots, p</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>(only where relevant) the contrasts used.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>if requested, the model matrix used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested (the default), the model frame used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ols.fit">ols.fit</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="stats.html#topic+lsfit">lsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tiny example of regression
y &lt;- c(1, 3, 3, 2, 2, 1)
x &lt;- matrix(c(1, 1,
              2, 1,
              3, 1,
              1,-1,
              2,-1,
              3,-1), ncol = 2, byrow = TRUE)
f0 &lt;- ols(y ~ x) # intercept is included by default
f0 # printing results (QR method was used)

f1 &lt;- ols(y ~ x, method = "svd") # using SVD method instead
f1
</code></pre>

<hr>
<h2 id='ols.fit'>Fitter functions for linear models</h2><span id='topic+ols.fit'></span>

<h3>Description</h3>

<p>This function is a <em>switcher</em> among various numerical fitting functions
(<code><a href="#topic+ols.fit.cg">ols.fit.cg</a></code>, <code><a href="#topic+ols.fit.chol">ols.fit.chol</a></code>, <code><a href="#topic+ols.fit.qr">ols.fit.qr</a></code>,
<code><a href="#topic+ols.fit.svd">ols.fit.svd</a></code> and <code><a href="#topic+ols.fit.sweep">ols.fit.sweep</a></code>). The argument <code>method</code>
does the switching: <code>"qr"</code> for <code><a href="#topic+ols.fit.qr">ols.fit.qr</a></code>, etc. This should usually
<em>not</em> be used directly unless by experienced users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ols.fit(x, y, method = "qr", tol = 1e-7, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ols.fit_+3A_x">x</code></td>
<td>
<p> design matrix of dimension <code class="reqn">n\times q</code>.</p>
</td></tr>
<tr><td><code id="ols.fit_+3A_y">y</code></td>
<td>
<p> vector of observations of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="ols.fit_+3A_method">method</code></td>
<td>
<p> currently, methods <code>"cg"</code>, <code>"chol"</code>, <code>"qr"</code> (default),
<code>"svd"</code> and <code>"sweep"</code> are supported.</p>
</td></tr>
<tr><td><code id="ols.fit_+3A_tol">tol</code></td>
<td>
<p> tolerance for the conjugate gradients (<code>gc</code>) method. Default is
<code>tol = 1e-7</code>.</p>
</td></tr>
<tr><td><code id="ols.fit_+3A_maxiter">maxiter</code></td>
<td>
<p> The maximum number of iterations for the conjugate gradients (<code>gc</code>)
method. Defaults to 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of coefficients</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> the fitted mean values.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p> the residual sum of squares.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p> a <code class="reqn">p \times p</code> matrix of (unscaled)
covariances of the <code class="reqn">\hat\beta_j</code>, <code class="reqn">j=1, \dots, p</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ols.fit.cg">ols.fit.cg</a></code>, <code><a href="#topic+ols.fit.chol">ols.fit.chol</a></code>, <code><a href="#topic+ols.fit.qr">ols.fit.qr</a></code>,
<code><a href="#topic+ols.fit.svd">ols.fit.svd</a></code>, <code><a href="#topic+ols.fit.sweep">ols.fit.sweep</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(151)
n &lt;- 100
p &lt;- 2
x &lt;- matrix(rnorm(n * p), n, p) # no intercept!
y &lt;- rnorm(n)
fm &lt;- ols.fit(x = x, y = y, method = "chol")
fm
</code></pre>

<hr>
<h2 id='ols.fit-methods'>Fit a linear model</h2><span id='topic+ols.fit.cg'></span><span id='topic+ols.fit.chol'></span><span id='topic+ols.fit.qr'></span><span id='topic+ols.fit.svd'></span><span id='topic+ols.fit.sweep'></span>

<h3>Description</h3>

<p>Fits a linear model, returning the bare minimum computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ols.fit.cg(x, y, tol = 1e-7, maxiter = 100)
ols.fit.chol(x, y)
ols.fit.qr(x, y)
ols.fit.svd(x, y)
ols.fit.sweep(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ols.fit-methods_+3A_x">x</code>, <code id="ols.fit-methods_+3A_y">y</code></td>
<td>
<p> numeric vectors or matrices for the predictors and the response in
a linear model. Typically, but not necessarily, <code>x</code> will be constructed by
one of the fitting functions.</p>
</td></tr>
<tr><td><code id="ols.fit-methods_+3A_tol">tol</code></td>
<td>
<p> tolerance for the conjugate gradients (<code>gc</code>) method. Default is
<code>tol = 1e-7</code>.</p>
</td></tr>
<tr><td><code id="ols.fit-methods_+3A_maxiter">maxiter</code></td>
<td>
<p> The maximum number of iterations for the conjugate gradients (<code>gc</code>)
method. Defaults to 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bare bones of an <code>ols</code> object: the coefficients, residuals, fitted values,
and some information used by <code>summary.ols</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ols">ols</a></code>, <code><a href="#topic+ols.fit">ols.fit</a></code>, <code><a href="stats.html#topic+lm">lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(151)
n &lt;- 100
p &lt;- 2
x &lt;- matrix(rnorm(n * p), n, p) # no intercept!
y &lt;- rnorm(n)
z &lt;- ols.fit.chol(x, y)
z
</code></pre>

<hr>
<h2 id='power.method'>Power method to approximate dominant eigenvalue and eigenvector</h2><span id='topic+power.method'></span>

<h3>Description</h3>

<p>The power method seeks to determine the eigenvalue of maximum modulus, and a corresponding
eigenvector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.method(x, only.value = FALSE, maxiter = 100, tol = 1e-8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power.method_+3A_x">x</code></td>
<td>
<p> a symmetric matrix.</p>
</td></tr>
<tr><td><code id="power.method_+3A_only.value">only.value</code></td>
<td>
<p> if <code>TRUE</code>, only the dominant eigenvalue is returned, otherwise
both dominant eigenvalue and eigenvector are returned.</p>
</td></tr>
<tr><td><code id="power.method_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. Defaults to <code>100</code></p>
</td></tr>
<tr><td><code id="power.method_+3A_tol">tol</code></td>
<td>
<p> a numeric tolerance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>only.value</code> is not true, as by default, the result is a list with components
<code>"value"</code> and <code>"vector"</code>. Otherwise only the dominan eigenvalue is returned.
The performed number of iterations to reach convergence is returned as attribute <code>"iterations"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code> for eigenvalues and eigenvectors computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
x &lt;- .5 * diag(n) + 0.5 * matrix(1, nrow = n, ncol = n)

# dominant eigenvalue must be (n + 1) / 2
z &lt;- power.method(x, only.value = TRUE)
</code></pre>

<hr>
<h2 id='rball'>Generation of deviates uniformly distributed in a unitary ball</h2><span id='topic+rball'></span>

<h3>Description</h3>

<p>Random vector generation uniformly in the unitary ball.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rball(n = 1, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rball_+3A_n">n</code></td>
<td>
<p> the number of samples requested</p>
</td></tr>
<tr><td><code id="rball_+3A_p">p</code></td>
<td>
<p> dimension of the unitary sphere</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rball</code> is an interface to C routines, which make calls to
subroutines from BLAS. 
</p>


<h3>Value</h3>

<p>If <code>n = 1</code> a <code>p</code>-dimensional vector, otherwise a matrix of <code>n</code>
rows of random vectors.
</p>


<h3>References</h3>

<p>Hormann, W., Leydold, J., Derflinger, G. (2004).
<em>Automatic Nonuniform Random Variate Generation</em>.
Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+runif">runif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate the sample
z &lt;- rball(n = 500)

# scatterplot of a random sample of 500 points uniformly distributed
# in the unitary ball
par(pty = "s")
plot(z, xlab = "x", ylab = "y")
title("500 points in the ball", font.main = 1)
</code></pre>

<hr>
<h2 id='ridge'>Ridge regression</h2><span id='topic+ridge'></span>

<h3>Description</h3>

<p>Fit a linear model by ridge regression, returning an object of class <code>"ridge"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ridge(formula, data, subset, lambda = 1.0, method = "GCV", ngrid = 200, tol = 1e-07,
  maxiter = 50, na.action, x = FALSE, y = FALSE, contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ridge_+3A_formula">formula</code></td>
<td>
<p> an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the model to
be fitted.</p>
</td></tr>
<tr><td><code id="ridge_+3A_data">data</code></td>
<td>
<p> an optional data frame, list or environment (or object coercible
by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing the variables in
the model. If not found in <code>data</code>, the variables are taken from
<code>environment(formula)</code>, typically the environment from which <code>ridge</code>
is called.</p>
</td></tr>
<tr><td><code id="ridge_+3A_subset">subset</code></td>
<td>
<p> an optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="ridge_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain <code>NA</code>s. The default is set by the <code>na.action</code> setting of
<code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.</p>
</td></tr>
<tr><td><code id="ridge_+3A_lambda">lambda</code></td>
<td>
<p> a scalar or vector of ridge constants. A value of 0 corresponds
to ordinary least squares.</p>
</td></tr>
<tr><td><code id="ridge_+3A_method">method</code></td>
<td>
<p> the method for choosing the ridge parameter lambda. If <code>method = "none"</code>,
then lambda is 'fixed'. If <code>method = "GCV"</code> (the default) then the ridge
parameter is chosen automatically using the generalized cross validation (GCV) criterion.
For <code>method = "grid"</code>, optimal value of lambda is selected computing the GCV
criterion over a grid. If <code>method = "MSE"</code> the optimal ridge parameter is selected
minimizing the mean squared estimation error criterion, this is the <code>ORPS1</code>
subroutine by Lee (1987).</p>
</td></tr>
<tr><td><code id="ridge_+3A_ngrid">ngrid</code></td>
<td>
<p>number of elements in the grid used to compute the GCV criterion.
Only required if <code>method = "grid"</code> and <code>lambda</code> is a scalar.</p>
</td></tr>
<tr><td><code id="ridge_+3A_tol">tol</code></td>
<td>
<p> tolerance for the optimization of the GCV criterion. Default is <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="ridge_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations. The default is 50.</p>
</td></tr>
<tr><td><code id="ridge_+3A_x">x</code>, <code id="ridge_+3A_y">y</code></td>
<td>
<p> logicals.  If <code>TRUE</code> the corresponding components of
the fit (the model matrix, the response) are returned.</p>
</td></tr>
<tr><td><code id="ridge_+3A_contrasts">contrasts</code></td>
<td>
<p> an optional list. See the <code>contrasts.arg</code> of
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="ridge_+3A_...">...</code></td>
<td>
<p> additional arguments to be passed to the low level regression
fitting functions (not implemented).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ridge</code> function fits in linear ridge regression <b>without</b> scaling or centering
the regressors and the response. In addition, If an intercept is present in the model, its
coefficient is penalized.)
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>dims</code></td>
<td>
<p> dimensions of model matrix.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> a named vector of coefficients.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p> a named vector of coefficients.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> the fitted mean values.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p> the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p> the residual sum of squares.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p> the effective number of parameters.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p> vector (if <code>method = "grid"</code>) of GCV values.</p>
</td></tr>
<tr><td><code>HKB</code></td>
<td>
<p> HKB estimate of the ridge constant.</p>
</td></tr>
<tr><td><code>LW</code></td>
<td>
<p> LW estimate of the ridge constant.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p> vector (if <code>method = "grid"</code>) of lambda values; otherwise, for
methods <code>method = "none"</code>, <code>"GCV"</code> or <code>"MSE"</code>, the value of ridge
parameter used by the algorithm.</p>
</td></tr>
<tr><td><code>optimal</code></td>
<td>
<p> value of lambda with the minimum GCV (only relevant if <code>method = "grid"</code>).</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p> number of iterations performed by the algorithm (only relevant if <code>method = "MSE"</code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p> the matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p> the <code><a href="stats.html#topic+terms">terms</a></code> object used.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p> (only where relevant) the contrasts used.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> if requested, the response used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p> if requested, the model matrix used.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> if requested, the model frame used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Golub, G.H., Heath, M., Wahba, G. (1979).
Generalized cross-validation as a method for choosing a good ridge parameter.
<em>Technometrics</em> <b>21</b>, 215-223.
</p>
<p>Hoerl, A.E., Kennard, R.W., Baldwin, K.F. (1975).
Ridge regression: Some simulations.
<em>Communication in Statistics</em> <b>4</b>, 105-123.
</p>
<p>Hoerl, A.E., Kennard, R.W. (1970).
Ridge regression: Biased estimation of nonorthogonal problems.
<em>Technometrics</em> <b>12</b>, 55-67.
</p>
<p>Lawless, J.F., Wang, P. (1976).
A simulation study of ridge and other regression estimators.
<em>Communications in Statistics</em> <b>5</b>, 307-323.
</p>
<p>Lee, T.S (1987).
Algorithm AS 223: Optimum ridge parameter selection.
<em>Applied Statistics</em> <b>36</b>, 112-118.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a></code>, <code><a href="#topic+ols">ols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- ridge(GNP.deflator ~ ., data = longley, lambda = 4, method = "grid")
z # ridge regression on a grid over seq(0, 4, length = 200)

z &lt;- ridge(GNP.deflator ~ ., data = longley)
z # ridge parameter selected using GCV (default)
</code></pre>

<hr>
<h2 id='rmnorm'>Multivariate normal random deviates</h2><span id='topic+rmnorm'></span>

<h3>Description</h3>

<p>Random number generation from the multivariate normal (Gaussian) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmnorm(n = 1, mean = rep(0, nrow(Sigma)), Sigma = diag(length(mean)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmnorm_+3A_n">n</code></td>
<td>
<p> the number of samples requested</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_mean">mean</code></td>
<td>
<p> a vector giving the means of each variable</p>
</td></tr>
<tr><td><code id="rmnorm_+3A_sigma">Sigma</code></td>
<td>
<p> a positive-definite covariance matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rmnorm</code> is an interface to <code>C</code> routines, which make calls
to subroutines from LAPACK. The matrix decomposition is internally done using the
Cholesky decomposition. If <code>Sigma</code> is not non-negative definite then there
will be a warning message.
</p>


<h3>Value</h3>

<p>If <code class="reqn">n = 1</code> a vector of the same length as <code>mean</code>, otherwise a
matrix of <code class="reqn">n</code> rows of random vectors.
</p>


<h3>References</h3>

<p>Devroye, L. (1986).
<em>Non-Uniform Random Variate Generation</em>.
Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+rnorm">rnorm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># covariance parameters
Sigma &lt;- matrix(c(10,3,3,2), ncol = 2)
Sigma

# generate the sample
y &lt;- rmnorm(n = 1000, Sigma = Sigma)
var(y)

# scatterplot of a random bivariate normal sample with mean
# vector zero and covariance matrix 'Sigma'
par(pty = "s")
plot(y, xlab = "", ylab = "")
title("bivariate normal sample", font.main = 1)

# QQ-plot of transformed distances
z &lt;- WH.normal(y)
par(pty = "s")
qqnorm(z, main = "Transformed distances QQ-plot")
abline(c(0,1), col = "red", lwd = 2, lty = 2)
</code></pre>

<hr>
<h2 id='rsphere'>Generation of deviates uniformly located on a spherical surface</h2><span id='topic+rsphere'></span>

<h3>Description</h3>

<p>Random vector generation uniformly on the sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsphere(n = 1, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsphere_+3A_n">n</code></td>
<td>
<p> the number of samples requested</p>
</td></tr>
<tr><td><code id="rsphere_+3A_p">p</code></td>
<td>
<p> dimension of the unitary sphere</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rsphere</code> is an interface to C routines, which make calls to
subroutines from BLAS. 
</p>


<h3>Value</h3>

<p>If <code>n = 1</code> a <code>p</code>-dimensional vector, otherwise a matrix of <code>n</code>
rows of random vectors.
</p>


<h3>References</h3>

<p>Devroye, L. (1986).
<em>Non-Uniform Random Variate Generation</em>.
Springer-Verlag, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+runif">runif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate the sample
z &lt;- rsphere(n = 200)

# scatterplot of a random sample of 200 points uniformly distributed
# on the unit circle
par(pty = "s")
plot(z, xlab = "x", ylab = "y")
title("200 points on the circle", font.main = 1)
</code></pre>

<hr>
<h2 id='scaled.condition'>Scaled condition number</h2><span id='topic+scaled.condition'></span>

<h3>Description</h3>

<p>Compute the scaled condition number of a rectangular matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaled.condition(x, scales = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaled.condition_+3A_x">x</code></td>
<td>
<p> a numeric rectangular matrix.</p>
</td></tr>
<tr><td><code id="scaled.condition_+3A_scales">scales</code></td>
<td>
<p> a logical value indicating whether the scaling factors that allow balancing 
the columns of <code>x</code> should be returned by the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The columns of a rectangular matrix <code>x</code> are equilibrated (but not centered), 
then the scaled condition number is computed following the guidelines of Belsley (1990).
If requested, the column scalings are returned as the attribute <code>'scales'</code>.
</p>


<h3>References</h3>

<p>Belsley, D.A. (1990).
<em>Conditioning Diagnostics: Collinearity and Weak Data in Regression</em>.
Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c(1, 1, 1,
              1, 2, 1,
              1, 3, 1,
              1, 1,-1,
              1, 2,-1,
              1, 3,-1), ncol = 3, byrow = TRUE)
scaled.condition(x)
</code></pre>

<hr>
<h2 id='seidel'>Solve linear systems using the Gauss-Seidel method</h2><span id='topic+seidel'></span>

<h3>Description</h3>

<p>Gauss-Seidel method is an iterative algorithm for solving a system of linear equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seidel(a, b, start, maxiter = 200, tol = 1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seidel_+3A_a">a</code></td>
<td>
<p> a square numeric matrix containing the coefficients of the linear system.</p>
</td></tr>
<tr><td><code id="seidel_+3A_b">b</code></td>
<td>
<p> a vector of right-hand sides of the linear system.</p>
</td></tr>
<tr><td><code id="seidel_+3A_start">start</code></td>
<td>
<p> a vector for initial starting point.</p>
</td></tr>
<tr><td><code id="seidel_+3A_maxiter">maxiter</code></td>
<td>
<p> the maximum number of iterations. Defaults to <code>200</code></p>
</td></tr>
<tr><td><code id="seidel_+3A_tol">tol</code></td>
<td>
<p> tolerance level for stopping iterations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\bold{D}</code>, <code class="reqn">\bold{L}</code>, and <code class="reqn">\bold{U}</code> denote the diagonal, lower
triangular and upper triangular parts of a matrix <code class="reqn">\bold{A}</code>. Gauss-Seidel method
solve the equation <code class="reqn">\bold{Ax} = \bold{b}</code>, iteratively by rewriting <code class="reqn">(\bold{L}
  + \bold{D})\bold{x} + \bold{Ux} = \bold{b}</code>. Assuming that <code class="reqn">\bold{L} + \bold{D}</code> is
nonsingular leads to the iteration formula
</p>
<p style="text-align: center;"><code class="reqn">\bold{x}^{(k+1)} = -(\bold{L} + \bold{D})^{-1}\bold{U}\bold{x}^{(k)} + (\bold{L}
  + \bold{D})^{-1}\bold{b}</code>
</p>



<h3>Value</h3>

<p>a vector with the approximate solution, the iterations performed are returned
as the attribute 'iterations'.
</p>


<h3>References</h3>

<p>Golub, G.H., Van Loan, C.F. (1996).
<em>Matrix Computations</em>, 3rd Edition.
John Hopkins University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jacobi">jacobi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- matrix(c(5,-3,2,-2,9,-1,3,1,-7), ncol = 3)
b &lt;- c(-1,2,3)
start &lt;- c(1,1,1)
z &lt;- seidel(a, b, start)
z # converged in 10 iterations
</code></pre>

<hr>
<h2 id='sherman.morrison'>Sherman-Morrison formula</h2><span id='topic+sherman.morrison'></span>

<h3>Description</h3>

<p>The Sherman-Morrison formula gives a convenient expression for the inverse of the
rank 1 update <code class="reqn">(\bold{A} + \bold{bd}^T)</code> where <code class="reqn">\bold{A}</code> is a <code class="reqn">n\times n</code>
matrix and <code class="reqn">\bold{b}</code>, <code class="reqn">\bold{d}</code> are <code class="reqn">n</code>-dimensional vectors. Thus
</p>
<p style="text-align: center;"><code class="reqn">(\bold{A} + \bold{bd}^T)^{-1} = \bold{A}^{-1} - \frac{\bold{A}^{-1}\bold{bd}^T
  \bold{A}^{-1}}{1 + \bold{d}^T\bold{A}^{-1}\bold{b}}.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>sherman.morrison(a, b, d = b, inverted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sherman.morrison_+3A_a">a</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
<tr><td><code id="sherman.morrison_+3A_b">b</code></td>
<td>
<p> a numeric vector.</p>
</td></tr>
<tr><td><code id="sherman.morrison_+3A_d">d</code></td>
<td>
<p> a numeric vector.</p>
</td></tr>
<tr><td><code id="sherman.morrison_+3A_inverted">inverted</code></td>
<td>
<p> logical. If <code>TRUE</code>, <code>a</code> is supposed to contain its <em>inverse</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method of <code>sherman.morrison</code> calls BLAS level 2 subroutines <code>DGEMV</code> and
<code>DGER</code> for computational efficiency.
</p>


<h3>Value</h3>

<p>a square matrix of the same order as <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 10
ones &lt;- rep(1, n)
a &lt;- 0.5 * diag(n)
z &lt;- sherman.morrison(a, ones, 0.5 * ones)
z
</code></pre>

<hr>
<h2 id='sweep.operator'>Gauss-Jordan sweep operator for symmetric matrices</h2><span id='topic+sweep.operator'></span>

<h3>Description</h3>

<p>Perform the sweep operation (or reverse sweep) on the diagonal elements of a
symmetric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sweep.operator(x, k = 1, reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sweep.operator_+3A_x">x</code></td>
<td>
<p> a symmetric matrix.</p>
</td></tr>
<tr><td><code id="sweep.operator_+3A_k">k</code></td>
<td>
<p> elements (if <code>k</code> is vector) of the diagonal which will be sweeped.</p>
</td></tr>
<tr><td><code id="sweep.operator_+3A_reverse">reverse</code></td>
<td>
<p> logical. If <code>reverse = TRUE</code> the reverse sweep is performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symmetric sweep operator is a powerful tool in computational statistics with
uses in stepwise regression, conditional multivariate normal distributions, MANOVA,
and more.
</p>


<h3>Value</h3>

<p>a square matrix of the same order as <code>x</code>.
</p>


<h3>References</h3>

<p>Goodnight, J.H. (1979).
A tutorial on the SWEEP operator.
<em>The American Statistician</em> <b>33</b>, 149-158.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># tiny example of regression, last column contains 'y'
xy &lt;- matrix(c(1, 1, 1, 1,
               1, 2, 1, 3,
               1, 3, 1, 3,
               1, 1,-1, 2,
               1, 2,-1, 2,
               1, 3,-1, 1), ncol = 4, byrow = TRUE)
z &lt;- crossprod(xy)
z &lt;- sweep.operator(z, k = 1:3)
cf &lt;- z[1:3,4] # regression coefficients
RSS &lt;- z[4,4]  # residual sum of squares

# an example not that small
x &lt;- matrix(rnorm(1000 * 100), ncol = 100)
xx &lt;- crossprod(x)
z &lt;- sweep.operator(xx, k = 1)
</code></pre>

<hr>
<h2 id='symm.info'>Compact information to construct the symmetrizer matrix</h2><span id='topic+symm.info'></span>

<h3>Description</h3>

<p>This function provides the information required to create the symmetrizer matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm.info(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symm.info_+3A_n">n</code></td>
<td>
<p> order of the symmetrizer matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list containing vectors that represent an element of the
symmetrizer matrix and is accesed by the indexes in vectors <code>row</code>, <code>col</code>
and values contained in <code>val</code>. This information is used by function <code><a href="#topic+symm.prod">symm.prod</a></code>
to do some operations involving the symmetrizer matrix without forming it. This
information also can be obtained using function <code><a href="#topic+symmetrizer">symmetrizer</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>row</code></td>
<td>
<p> vector of indexes, each entry represents the row index of the symmetrizer
matrix.</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p> vector of indexes, each entry represents the column index of the symmetrizer
matrix.</p>
</td></tr>
<tr><td><code>val</code></td>
<td>
<p> vector of values, each entry represents the value of the symmetrizer matrix
at element given by <code>row</code> and <code>col</code> indexes.</p>
</td></tr>
<tr><td><code>order</code></td>
<td>
<p> order of the symmetrizer matrix.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+symmetrizer">symmetrizer</a></code>, <code><a href="#topic+symm.prod">symm.prod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- symm.info(n = 3)
z # elements in symmetrizer matrix of order 3

N3 &lt;- symmetrizer(n = 3, matrix = TRUE)
N3 # only recommended if n is very small
</code></pre>

<hr>
<h2 id='symm.prod'>Matrix multiplication envolving the symmetrizer matrix</h2><span id='topic+symm.prod'></span>

<h3>Description</h3>

<p>Given the order of a symmetrizer matrix <code class="reqn">\bold{N}</code> of order <code class="reqn">n</code> and a
conformable matrix <code class="reqn">\bold{X}</code>, performs one of the matrix-matrix operations:
</p>

<ul>
<li> <p><code class="reqn">\bold{Y} = \bold{NX}</code>, if <code>side = "left"</code>, or
</p>
</li>
<li> <p><code class="reqn">\bold{Y} = \bold{XN}</code>, if <code>side = "right"</code>,
</p>
</li></ul>

<p>The main aim of <code>symm.prod</code> is to do this matrix multiplication <b>without forming</b>
the symmetrizer matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm.prod(n = 1, x = NULL, side = "left")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symm.prod_+3A_n">n</code></td>
<td>
<p> order of the symmetrizer matrix.</p>
</td></tr>
<tr><td><code id="symm.prod_+3A_x">x</code></td>
<td>
<p> numeric matrix (or vector).</p>
</td></tr>
<tr><td><code id="symm.prod_+3A_side">side</code></td>
<td>
<p> a string selecting if symmetrizer matrix is pre-multiplying <code class="reqn">\bold{X}</code>,
that is <code>side = "left"</code> or post-multiplying <code class="reqn">\bold{X}</code>, by using <code>side = "right"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Underlying <code>C</code> code only uses information provided by <code><a href="#topic+symm.info">symm.info</a></code> to
performs the matrix multiplication. The symmetrizer matrix is <b>never</b> created.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symmetrizer">symmetrizer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N4 &lt;- symmetrizer(n = 4, matrix = TRUE)
x &lt;- matrix(1:32, ncol = 2)
y &lt;- N4 %*% x

z &lt;- symm.prod(n = 4, x) # N4 is not stored
all(z == y) # matrices y and z are equal!
</code></pre>

<hr>
<h2 id='symmetrizer'>Symmetrizer matrix</h2><span id='topic+symmetrizer'></span>

<h3>Description</h3>

<p>This function returns the symmetrizer matrix of order <code class="reqn">n</code> which transforms,
for every <code class="reqn">n\times n</code> matrix <code class="reqn">\bold{A}</code>, <code>vec</code><code class="reqn">(\bold{A})</code> into
<code>vec</code><code class="reqn">((\bold{A} + \bold{A}^T)/2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symmetrizer(n = 1, matrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symmetrizer_+3A_n">n</code></td>
<td>
<p> order of the symmetrizer matrix.</p>
</td></tr>
<tr><td><code id="symmetrizer_+3A_matrix">matrix</code></td>
<td>
<p> a logical indicating whether the symmetrizer matrix will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper function for the function <code>symm.info</code>. This function
provides the information required to create the symmetrizer matrix. If option <code>matrix = FALSE</code>
the symmetrizer matrix is stored in three vectors containing the coordinate list of
indexes for rows, columns and the values.
</p>
<p><b>Warning:</b> <code>matrix = TRUE</code> is <b>not</b> recommended, unless the order <code>n</code>
be small. This matrix can require a huge amount of storage.
</p>


<h3>Value</h3>

<p>Returns an <code class="reqn">n^2</code> by <code class="reqn">n^2</code> matrix (if requested).
</p>


<h3>References</h3>

<p>Abadir, K.M., Magnus, J.R. (2005).
<em>Matrix Algebra</em>.
Cambridge University Press.
</p>
<p>Magnus, J.R., Neudecker, H. (2007).
<em>Matrix Differential Calculus with Applications in Statistics and Econometrics</em>, 3rd Edition.
Wiley, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+symm.info">symm.info</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- symmetrizer(n = 100)
object.size(z) # 319 Kb of storage

N100 &lt;- symmetrizer(n = 100, matrix = TRUE) # time: &lt; 2 secs
object.size(N100) # 800 Mb of storage, do not request this matrix!

# a small example
N3 &lt;- symmetrizer(n = 3, matrix = TRUE)
a &lt;- matrix(rep(c(2,4,6), each = 3), ncol = 3)
a
b &lt;- 0.5 * (a + t(a))
b
v &lt;- N3 %*% vec(a)
all(vec(b) == as.vector(v)) # vectors are equal!
</code></pre>

<hr>
<h2 id='vec'>Vectorization of a matrix</h2><span id='topic+vec'></span>

<h3>Description</h3>

<p>This function returns a vector obtained by stacking the columns of <code class="reqn">\bold{X}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_+3A_x">x</code></td>
<td>
<p> a numeric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Let <code class="reqn">\bold{X}</code> be a <code class="reqn">n</code> by <code class="reqn">m</code> matrix, then <code>vec</code>(<code class="reqn">\bold{X}</code>)
is a <code class="reqn">nm</code>-dimensional vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rep(1:10, each = 10), ncol = 10)
x
y &lt;- vec(x)
y
</code></pre>

<hr>
<h2 id='vech'>Vectorization the lower triangular part of a square matrix</h2><span id='topic+vech'></span>

<h3>Description</h3>

<p>This function returns a vector obtained by stacking the lower triangular part of a
square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vech(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vech_+3A_x">x</code></td>
<td>
<p> a square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Let <code class="reqn">\bold{X}</code> be a <code class="reqn">n</code> by <code class="reqn">n</code> matrix, then <code>vech</code>(<code class="reqn">\bold{X}</code>)
is a <code class="reqn">n(n+1)/2</code>-dimensional vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(rep(1:10, each = 10), ncol = 10)
x
y &lt;- vech(x)
y
</code></pre>

<hr>
<h2 id='WH.normal'>Wilson-Hilferty transformation for chi-squared variates</h2><span id='topic+WH.normal'></span>

<h3>Description</h3>

<p>Returns the Wilson-Hilferty transformation of random variables with chi-squared distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  WH.normal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WH.normal_+3A_x">x</code></td>
<td>
<p> vector or matrix of data with, say, <code class="reqn">p</code> columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">T = D^2/p</code> be a random variable, where <code class="reqn">D^2</code> denotes the squared Mahalanobis
distance defined as
</p>
<p style="text-align: center;"><code class="reqn">D^2 = (\bold{x} - \bold{\mu})^T \bold{\Sigma}^{-1} (\bold{x} - \bold{\mu})</code>
</p>

<p>Thus the Wilson-Hilferty transformation is given by
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{T^{1/3} - (1 - \frac{2}{9p})}{(\frac{2}{9p})^{1/2}}</code>
</p>

<p>and <code class="reqn">z</code> is approximately distributed as a standard normal distribution. This
is useful, for instance, in the construction of QQ-plots.
</p>


<h3>References</h3>

<p>Wilson, E.B., and Hilferty, M.M. (1931).
The distribution of chi-square.
<em>Proceedings of the National Academy of Sciences of the United States of America</em> <b>17</b>, 684-688.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mahalanobis">Mahalanobis</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iris[,1:4]
z &lt;- WH.normal(x)
par(pty = "s")
qqnorm(z, main = "Transformed distances QQ-plot")
abline(c(0,1), col = "red", lwd = 2, lty = 2)
</code></pre>

<hr>
<h2 id='whitening'>Whitening transformation</h2><span id='topic+whitening'></span>

<h3>Description</h3>

<p>Applies the whitening transformation to a data matrix based on the Cholesky decomposition
of the empirical covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whitening(x, Scatter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whitening_+3A_x">x</code></td>
<td>
<p> vector or matrix of data with, say, <code class="reqn">p</code> columns.</p>
</td></tr>
<tr><td><code id="whitening_+3A_scatter">Scatter</code></td>
<td>
<p> covariance (or scatter) matrix (<code class="reqn">p \times p</code>) of the
distribution, must be positive definite. If <code>NULL</code>, the covariance matrix
is estimated from the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the whitened data matrix <code class="reqn">\bold{Z} = \bold{X W}^T</code>, where
</p>
<p style="text-align: center;"><code class="reqn">\bold{W}^T\bold{W} = \bold{S}^{-1},</code>
</p>

<p>with <code class="reqn">\bold{S}</code> the empirical covariance matrix.
</p>


<h3>References</h3>

<p>Kessy, A., Lewin, A., Strimmer, K. (2018).
Optimal whitening and decorrelation.
<em>The American Statistician</em> <b>72</b>, 309-314.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- iris[,1:4]
species &lt;- iris[,5]
pairs(x, col = species) # plot of Iris

# whitened data
z &lt;- whitening(x)
pairs(z, col = species) # plot of
</code></pre>

<hr>
<h2 id='wilson.hilferty'>Wilson-Hilferty transformation</h2><span id='topic+wilson.hilferty'></span>

<h3>Description</h3>

<p>Returns the Wilson-Hilferty transformation of random variables with Gamma distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  wilson.hilferty(x, shape, rate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilson.hilferty_+3A_x">x</code></td>
<td>
<p> a numeric vector containing Gamma distributed deviates.</p>
</td></tr>
<tr><td><code id="wilson.hilferty_+3A_shape">shape</code>, <code id="wilson.hilferty_+3A_rate">rate</code></td>
<td>
<p>shape and rate parameters. Must be positive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> be a random variable following a Gamma distribution with parameters <code class="reqn">a</code> = <code>shape</code> 
and <code class="reqn">b</code> = <code>rate</code> with density
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{b^a}{\Gamma(a)} x^{a-1}\exp(-bx),</code>
</p>

<p>where <code class="reqn">x \ge 0</code>, <code class="reqn">a &gt; 0</code>, <code class="reqn">b &gt; 0</code> and consider the random variable 
<code class="reqn">T = X/(a/b)</code>. Thus, the Wilson-Hilferty transformation
</p>
<p style="text-align: center;"><code class="reqn">z = \frac{T^{1/3} - (1 - \frac{1}{9a})}{(\frac{1}{9a})^{1/2}}</code>
</p>

<p>is approximately distributed as a standard normal distribution. This is useful, for instance, 
in the construction of QQ-plots.
</p>


<h3>References</h3>

<p>Terrell, G.R. (2003).
The Wilson-Hilferty transformation is locally saddlepoint.
<em>Biometrika</em> <b>90</b>, 445-453.
</p>
<p>Wilson, E.B., and Hilferty, M.M. (1931).
The distribution of chi-square.
<em>Proceedings of the National Academy of Sciences of the United States of America</em> <b>17</b>, 684-688.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WH.normal">WH.normal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(n = 300, shape = 2, rate = 1)
z &lt;- wilson.hilferty(x, shape = 2, rate = 1)
par(pty = "s")
qqnorm(z, main = "Transformed Gamma QQ-plot")
abline(c(0,1), col = "red", lwd = 2, lty = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
