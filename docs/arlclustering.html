<!DOCTYPE html><html lang="en"><head><title>Help for package arlclustering</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {arlclustering}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#arlc_calculate_mode'><p>Calculate the Mode of a Vector</p></a></li>
<li><a href='#arlc_clean_final_rules'><p>Clean Final Rules</p></a></li>
<li><a href='#arlc_clusters_plot'><p>Plot Graph with Custom Layout and Communities</p></a></li>
<li><a href='#arlc_convert_date_format'><p>Convert a Date to a Different Format</p></a></li>
<li><a href='#arlc_count_na'><p>Count NA Values in a Data Frame</p></a></li>
<li><a href='#arlc_df_summary'><p>Create a Summary of a Data Frame</p></a></li>
<li><a href='#arlc_fct_clean_transactions'><p>Clean Transactions by Removing Overlapping Sets</p></a></li>
<li><a href='#arlc_fct_get_best_apriori_thresholds'><p>Get Best Apriori Thresholds</p></a></li>
<li><a href='#arlc_file_exists_readable'><p>Check if a File Exists and is Readable</p></a></li>
<li><a href='#arlc_gen_gross_rules'><p>Get Gross Rules</p></a></li>
<li><a href='#arlc_gen_transactions'><p>Get Transactional Dataset</p></a></li>
<li><a href='#arlc_generate_clusters'><p>Generate Clusters</p></a></li>
<li><a href='#arlc_generate_date_sequence'><p>Generate a Sequence of Dates</p></a></li>
<li><a href='#arlc_generate_uid'><p>Generate a Unique Identifier</p></a></li>
<li><a href='#arlc_get_apriori_thresholds'><p>Get Apriori Thresholds</p></a></li>
<li><a href='#arlc_get_network_dataset'><p>Get Network Dataset</p></a></li>
<li><a href='#arlc_get_NonR_rules'><p>Get Non-Redundant Rules</p></a></li>
<li><a href='#arlc_get_significant_rules'><p>Get Significant Rules</p></a></li>
<li><a href='#arlc_is_numeric_vector'><p>Check if a Vector is Numeric</p></a></li>
<li><a href='#arlc_list_to_df'><p>Convert List of Vectors to Data Frame</p></a></li>
<li><a href='#arlc_measure_time'><p>Measure Execution Time of a Function</p></a></li>
<li><a href='#arlc_normalize_vector'><p>Normalize a Numeric Vector</p></a></li>
<li><a href='#arlc_replace_na'><p>Replace NA with a Specified Value</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exploring Social Network Structures Through Friendship-Driven
Community Detection with Association Rules Mining</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mohamed El-Moussaoui &lt;med.elmoussaoui.ced@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an innovative approach to community detection in social networks using Association Rules Learning. The package provides tools for processing graph and rules objects, generating association rules, and detecting communities based on node interactions. Designed to facilitate advanced research in Social Network Analysis, this package leverages association rules learning for enhanced community detection. This approach is described in El-Moussaoui et al. (2021) &lt;<a href="https://doi.org/10.1007%2F978-3-030-66840-2_3">doi:10.1007/978-3-030-66840-2_3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/assuom44/arlclustering">https://github.com/assuom44/arlclustering</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/assuom44/arlclustering/issues">https://github.com/assuom44/arlclustering/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>false</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, tidyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, igraph, arules, grDevices, graphics, stats</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-08 23:12:38 UTC; wadii</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohamed El-Moussaoui [aut, cre],
  Mohamed Hanine [aut],
  Ali Kartit [ths],
  Tarik Agouti [rev]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-11 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='arlc_calculate_mode'>Calculate the Mode of a Vector</h2><span id='topic+arlc_calculate_mode'></span>

<h3>Description</h3>

<p>This function calculates the mode of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_calculate_mode(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_calculate_mode_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mode of the vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_calculate_mode(c(1, 2, 2, 3, 4))
</code></pre>

<hr>
<h2 id='arlc_clean_final_rules'>Clean Final Rules</h2><span id='topic+arlc_clean_final_rules'></span>

<h3>Description</h3>

<p>This function cleans the final set of association rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_clean_final_rules(final_rules)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_clean_final_rules_+3A_final_rules">final_rules</code></td>
<td>
<p>A set of final rules to be cleaned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cleaned set of rules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
grossRules &lt;- arlc_gen_gross_rules(trans, params$minSupp, params$minConf, 1, params$lenRules)
nonRR_rules &lt;- arlc_get_NonR_rules(grossRules$GrossRules)
NonRRSig_rules &lt;- arlc_get_significant_rules(trans, nonRR_rules$FiltredRules)
cleaned_rules &lt;- arlc_clean_final_rules(NonRRSig_rules$FiltredRules)
message(cleaned_rules)

</code></pre>

<hr>
<h2 id='arlc_clusters_plot'>Plot Graph with Custom Layout and Communities</h2><span id='topic+arlc_clusters_plot'></span>

<h3>Description</h3>

<p>This function plots a graph with specified aesthetics and highlights communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_clusters_plot(g, graphLabel, clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_clusters_plot_+3A_g">g</code></td>
<td>
<p>An igraph object representing the graph.</p>
</td></tr>
<tr><td><code id="arlc_clusters_plot_+3A_graphlabel">graphLabel</code></td>
<td>
<p>A character string for the graph label to be displayed in the title.</p>
</td></tr>
<tr><td><code id="arlc_clusters_plot_+3A_clusters">clusters</code></td>
<td>
<p>A list of clusters to highlight in the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function produces a plot as a side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
grossRules &lt;- arlc_gen_gross_rules(trans, params$minSupp, params$minConf, 1, params$lenRules)
nonRR_rules &lt;- arlc_get_NonR_rules(grossRules$GrossRules)
NonRRSig_rules &lt;- arlc_get_significant_rules(trans, nonRR_rules$FiltredRules)
cleaned_rules &lt;- arlc_clean_final_rules(NonRRSig_rules$FiltredRules)
clusters &lt;- arlc_generate_clusters(cleaned_rules)
arlc_clusters_plot(g$graph, "Karate Club", clusters$Clusters)

</code></pre>

<hr>
<h2 id='arlc_convert_date_format'>Convert a Date to a Different Format</h2><span id='topic+arlc_convert_date_format'></span>

<h3>Description</h3>

<p>This function converts a date from one format to another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_convert_date_format(date_str, from_format, to_format)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_convert_date_format_+3A_date_str">date_str</code></td>
<td>
<p>A date string.</p>
</td></tr>
<tr><td><code id="arlc_convert_date_format_+3A_from_format">from_format</code></td>
<td>
<p>The current format of the date string.</p>
</td></tr>
<tr><td><code id="arlc_convert_date_format_+3A_to_format">to_format</code></td>
<td>
<p>The desired format of the date string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The date string in the new format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_convert_date_format("2023-01-01", "%Y-%m-%d", "%d-%m-%Y")
</code></pre>

<hr>
<h2 id='arlc_count_na'>Count NA Values in a Data Frame</h2><span id='topic+arlc_count_na'></span>

<h3>Description</h3>

<p>This function counts the number of NA values in each column of a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_count_na(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_count_na_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the count of NA values in each column.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_count_na(data.frame(a = c(1, NA, 3), b = c(NA, NA, 3)))
</code></pre>

<hr>
<h2 id='arlc_df_summary'>Create a Summary of a Data Frame</h2><span id='topic+arlc_df_summary'></span>

<h3>Description</h3>

<p>This function creates a summary of a data frame including count, mean, median, and standard deviation for numeric columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_df_summary(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_df_summary_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame summarizing the statistics of the input data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_df_summary(data.frame(a = c(1, 2, 3, 4, 5), b = c(5, 4, 3, 2, 1)))
</code></pre>

<hr>
<h2 id='arlc_fct_clean_transactions'>Clean Transactions by Removing Overlapping Sets</h2><span id='topic+arlc_fct_clean_transactions'></span>

<h3>Description</h3>

<p>This function processes a list of sets and removes those that are fully overlapped by other sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_fct_clean_transactions(all_sets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_fct_clean_transactions_+3A_all_sets">all_sets</code></td>
<td>
<p>A list of sets where each set is a vector of elements.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function iterates through each set and checks if it is fully overlapped by any other set. If a set is fully overlapped, it is excluded from the final list of sets. The result is a list of sets with no fully overlapped sets.
</p>


<h3>Value</h3>

<p>A list of sets with fully overlapped sets removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
grossRules &lt;- arlc_gen_gross_rules(trans, params$minSupp, params$minConf, 1, params$lenRules)
nonRR_rules &lt;- arlc_get_NonR_rules(grossRules$GrossRules)
NonRRSig_rules &lt;- arlc_get_significant_rules(trans, nonRR_rules$FiltredRules)
cleaned_rules &lt;- arlc_clean_final_rules(NonRRSig_rules$FiltredRules)

vec &lt;- lapply(cleaned_rules, function(v) unique(unlist(v)))
vec2 &lt;- split(vec, sapply(vec, `[`, 1))
sorted_result &lt;- lapply(vec2, function(v) sort(unique(unlist(v))))

clusters &lt;- arlc_fct_clean_transactions(sorted_result)

message (clusters)


</code></pre>

<hr>
<h2 id='arlc_fct_get_best_apriori_thresholds'>Get Best Apriori Thresholds</h2><span id='topic+arlc_fct_get_best_apriori_thresholds'></span>

<h3>Description</h3>

<p>This function finds the best support and confidence thresholds for the Apriori algorithm
to maximize the lift of the generated association rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_fct_get_best_apriori_thresholds(transactions, support_range, conf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_fct_get_best_apriori_thresholds_+3A_transactions">transactions</code></td>
<td>
<p>A transaction dataset of class <code>transactions</code> from the <code>arules</code> package.</p>
</td></tr>
<tr><td><code id="arlc_fct_get_best_apriori_thresholds_+3A_support_range">support_range</code></td>
<td>
<p>A numeric vector specifying the range of support values to be tested.</p>
</td></tr>
<tr><td><code id="arlc_fct_get_best_apriori_thresholds_+3A_conf">conf</code></td>
<td>
<p>A numeric value (0.5 or 1.0) specifying the confidence value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function iterates through the given ranges of support and confidence values,
applies the Apriori algorithm to find association rules for each pair of values, and selects
the pair that produces rules with the highest lift.
</p>


<h3>Value</h3>

<p>A numeric vector containing the best support, best confidence, highest lift, and the number of rules found.
The return value is a named vector with elements <code>best_support</code>, <code>best_confidence</code>, <code>best_lift</code>, and <code>len_rules</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
best_thresholds &lt;- arlc_fct_get_best_apriori_thresholds(trans, supportRange, Conf)


</code></pre>

<hr>
<h2 id='arlc_file_exists_readable'>Check if a File Exists and is Readable</h2><span id='topic+arlc_file_exists_readable'></span>

<h3>Description</h3>

<p>This function checks if a file exists and is readable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_file_exists_readable(filepath)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_file_exists_readable_+3A_filepath">filepath</code></td>
<td>
<p>The path to the file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the file exists and is readable, FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_file_exists_readable("example.txt")
</code></pre>

<hr>
<h2 id='arlc_gen_gross_rules'>Get Gross Rules</h2><span id='topic+arlc_gen_gross_rules'></span>

<h3>Description</h3>

<p>This function generates gross association rules from transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_gen_gross_rules(transactions, minSupp, minConf, minLenRules, maxLenRules)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_gen_gross_rules_+3A_transactions">transactions</code></td>
<td>
<p>A transactions object.</p>
</td></tr>
<tr><td><code id="arlc_gen_gross_rules_+3A_minsupp">minSupp</code></td>
<td>
<p>Minimum support threshold.</p>
</td></tr>
<tr><td><code id="arlc_gen_gross_rules_+3A_minconf">minConf</code></td>
<td>
<p>Minimum confidence threshold.</p>
</td></tr>
<tr><td><code id="arlc_gen_gross_rules_+3A_minlenrules">minLenRules</code></td>
<td>
<p>Minimum length of rules.</p>
</td></tr>
<tr><td><code id="arlc_gen_gross_rules_+3A_maxlenrules">maxLenRules</code></td>
<td>
<p>Maximum length of rules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of gross association rules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
grossRules &lt;- arlc_gen_gross_rules(trans, params$minSupp, params$minConf, 1, params$lenRules)

</code></pre>

<hr>
<h2 id='arlc_gen_transactions'>Get Transactional Dataset</h2><span id='topic+arlc_gen_transactions'></span>

<h3>Description</h3>

<p>This function generates a transactional dataset from a graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_gen_transactions(graph)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_gen_transactions_+3A_graph">graph</code></td>
<td>
<p>A graph object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transactional dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)

</code></pre>

<hr>
<h2 id='arlc_generate_clusters'>Generate Clusters</h2><span id='topic+arlc_generate_clusters'></span>

<h3>Description</h3>

<p>This function takes a vector of preprocessed rules, combines elements
starting with the same value, groups segments by the starting value, sorts elements
within each segment, and returns potential clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_generate_clusters(vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_generate_clusters_+3A_vec">vec</code></td>
<td>
<p>A vector of preprocessed rules.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates potential clusters based on preprocessed rules.
</p>


<h3>Value</h3>

<p>A list of unique and potential clusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
grossRules &lt;- arlc_gen_gross_rules(trans, params$minSupp, params$minConf, 1, params$lenRules)
nonRR_rules &lt;- arlc_get_NonR_rules(grossRules$GrossRules)
NonRRSig_rules &lt;- arlc_get_significant_rules(trans, nonRR_rules$FiltredRules)
cleaned_rules &lt;- arlc_clean_final_rules(NonRRSig_rules$FiltredRules)
clusters &lt;- arlc_generate_clusters(cleaned_rules)

</code></pre>

<hr>
<h2 id='arlc_generate_date_sequence'>Generate a Sequence of Dates</h2><span id='topic+arlc_generate_date_sequence'></span>

<h3>Description</h3>

<p>This function generates a sequence of dates between two given dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_generate_date_sequence(start_date, end_date, by = "day")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_generate_date_sequence_+3A_start_date">start_date</code></td>
<td>
<p>The start date.</p>
</td></tr>
<tr><td><code id="arlc_generate_date_sequence_+3A_end_date">end_date</code></td>
<td>
<p>The end date.</p>
</td></tr>
<tr><td><code id="arlc_generate_date_sequence_+3A_by">by</code></td>
<td>
<p>The step size for the sequence (e.g., &quot;day&quot;, &quot;week&quot;, &quot;month&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of dates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_generate_date_sequence("2023-01-01", "2023-01-10", "day")
</code></pre>

<hr>
<h2 id='arlc_generate_uid'>Generate a Unique Identifier</h2><span id='topic+arlc_generate_uid'></span>

<h3>Description</h3>

<p>This function generates a unique identifier string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_generate_uid(length = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_generate_uid_+3A_length">length</code></td>
<td>
<p>The length of the unique identifier. Default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A unique identifier string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_generate_uid()
arlc_generate_uid(15)
</code></pre>

<hr>
<h2 id='arlc_get_apriori_thresholds'>Get Apriori Thresholds</h2><span id='topic+arlc_get_apriori_thresholds'></span>

<h3>Description</h3>

<p>This function takes a transaction dataset and ranges for support and confidence,
computes the best thresholds, and returns the best minimum support, minimum confidence,
best lift, total number of gross rules, and ratio of generated rules to total number of transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_get_apriori_thresholds(trx, supportRange, Conf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_get_apriori_thresholds_+3A_trx">trx</code></td>
<td>
<p>A transaction dataset of class <code>transactions</code> from the <code>arules</code> package.</p>
</td></tr>
<tr><td><code id="arlc_get_apriori_thresholds_+3A_supportrange">supportRange</code></td>
<td>
<p>A sequence of values representing the range for minimum support.</p>
</td></tr>
<tr><td><code id="arlc_get_apriori_thresholds_+3A_conf">Conf</code></td>
<td>
<p>A sequence of values representing the range for minimum confidence.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates gross rules based on the best obtained thresholds.
</p>
<p>This function iterates through the given ranges of support and confidence values,
applies the Apriori algorithm to find association rules for each pair of values, and selects
the pair that produces rules with the highest lift. The function then returns the best thresholds
along with the lift, number of rules, and their ratio to the total transactions.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>minSupp</code></td>
<td>
<p>The best minimum support value.</p>
</td></tr>
<tr><td><code>minConf</code></td>
<td>
<p>The best minimum confidence value.</p>
</td></tr>
<tr><td><code>bestLift</code></td>
<td>
<p>The highest lift value obtained.</p>
</td></tr>
<tr><td><code>lenRules</code></td>
<td>
<p>The total number of gross rules generated.</p>
</td></tr>
<tr><td><code>ratio</code></td>
<td>
<p>The ratio of generated rules to the total number of transactions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
message(params$minSupp)
message(params$minConf)
message(params$bestLift)
message(params$lenRules)
message(params$ratio)


</code></pre>

<hr>
<h2 id='arlc_get_network_dataset'>Get Network Dataset</h2><span id='topic+arlc_get_network_dataset'></span>

<h3>Description</h3>

<p>This function reads a network dataset from a GML file, assigns node names, and calculates
various properties of the graph such as total edges, total nodes, and average degree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_get_network_dataset(file_path, label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_get_network_dataset_+3A_file_path">file_path</code></td>
<td>
<p>The file path to the GML file to be loaded.</p>
</td></tr>
<tr><td><code id="arlc_get_network_dataset_+3A_label">label</code></td>
<td>
<p>A label for the graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function loads a network dataset from a specified GML file and computes basic graph properties.
</p>


<h3>Value</h3>

<p>A list containing the graph object and its properties: total edges, total nodes, and average degree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
loaded_karate &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
message(loaded_karate$graph)
message(loaded_karate$graphLabel)
message(loaded_karate$totalEdges)
message(loaded_karate$graphEdges)
message(loaded_karate$totalNodes)
message(loaded_karate$graphNodes)
message(loaded_karate$averageDegree)

</code></pre>

<hr>
<h2 id='arlc_get_NonR_rules'>Get Non-Redundant Rules</h2><span id='topic+arlc_get_NonR_rules'></span>

<h3>Description</h3>

<p>This function takes a set of gross rules, removes redundant rules,
and returns the total number of non-redundant rules along with the non-redundant rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_get_NonR_rules(gross_rules)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_get_NonR_rules_+3A_gross_rules">gross_rules</code></td>
<td>
<p>A vector or dataframe of gross rules.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function cleans the gross rules and provides non-redundant rules.
</p>


<h3>Value</h3>

<p>A list containing the total number of non-redundant rules and the non-redundant rules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
grossRules &lt;- arlc_gen_gross_rules(trans, params$minSupp, params$minConf, 1, params$lenRules)
nonRR_rules &lt;- arlc_get_NonR_rules(grossRules$GrossRules)

</code></pre>

<hr>
<h2 id='arlc_get_significant_rules'>Get Significant Rules</h2><span id='topic+arlc_get_significant_rules'></span>

<h3>Description</h3>

<p>This function takes all transactions and a set of non-redundant rules as input,
and returns significant rules based on a specified method and adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_get_significant_rules(all_trans, nonRR_rules)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_get_significant_rules_+3A_all_trans">all_trans</code></td>
<td>
<p>A dataframe containing all transactions.</p>
</td></tr>
<tr><td><code id="arlc_get_significant_rules_+3A_nonrr_rules">nonRR_rules</code></td>
<td>
<p>A list of non-redundant rules.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function filters significant rules from a set of non-redundant rules.
</p>


<h3>Value</h3>

<p>A list containing the total number of significant non-redundant rules and the significant rules themselves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(arlclustering)
# Create a sample transactions dataset
sample_gml_file &lt;- system.file("extdata", "karate.gml", package = "arlclustering")
g &lt;- arlc_get_network_dataset(sample_gml_file, "Karate Club")
trans &lt;- arlc_gen_transactions(g$graph)
supportRange &lt;- seq(0.1, 0.2, by = 0.1)
Conf &lt;- 0.5
params &lt;- arlc_get_apriori_thresholds(trans, supportRange, Conf)
grossRules &lt;- arlc_gen_gross_rules(trans, params$minSupp, params$minConf, 1, params$lenRules)
nonRR_rules &lt;- arlc_get_NonR_rules(grossRules$GrossRules)
NonRRSig_rules &lt;- arlc_get_significant_rules(trans, nonRR_rules$FiltredRules)

</code></pre>

<hr>
<h2 id='arlc_is_numeric_vector'>Check if a Vector is Numeric</h2><span id='topic+arlc_is_numeric_vector'></span>

<h3>Description</h3>

<p>This function checks if all elements of a vector are numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_is_numeric_vector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_is_numeric_vector_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all elements are numeric, FALSE otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_is_numeric_vector(c(1, 2, 3))
arlc_is_numeric_vector(c(1, "a", 3))
</code></pre>

<hr>
<h2 id='arlc_list_to_df'>Convert List of Vectors to Data Frame</h2><span id='topic+arlc_list_to_df'></span>

<h3>Description</h3>

<p>This function converts a list of named vectors to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_list_to_df(lst)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_list_to_df_+3A_lst">lst</code></td>
<td>
<p>A list of named vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each element of the list as a row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lst &lt;- list(a = c(x = 1, y = 2), b = c(x = 3, y = 4))
arlc_list_to_df(lst)
</code></pre>

<hr>
<h2 id='arlc_measure_time'>Measure Execution Time of a Function</h2><span id='topic+arlc_measure_time'></span>

<h3>Description</h3>

<p>This function measures the execution time of a given function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_measure_time(func, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_measure_time_+3A_func">func</code></td>
<td>
<p>The function to measure.</p>
</td></tr>
<tr><td><code id="arlc_measure_time_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of the function execution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_measure_time(Sys.sleep, 1)
</code></pre>

<hr>
<h2 id='arlc_normalize_vector'>Normalize a Numeric Vector</h2><span id='topic+arlc_normalize_vector'></span>

<h3>Description</h3>

<p>This function normalizes a numeric vector to have values between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_normalize_vector(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_normalize_vector_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A normalized numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_normalize_vector(c(1, 2, 3, 4, 5))
</code></pre>

<hr>
<h2 id='arlc_replace_na'>Replace NA with a Specified Value</h2><span id='topic+arlc_replace_na'></span>

<h3>Description</h3>

<p>This function replaces NA values in a vector or data frame with a specified value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arlc_replace_na(x, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arlc_replace_na_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="arlc_replace_na_+3A_value">value</code></td>
<td>
<p>The value to replace NA with.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector or data frame with NA values replaced.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arlc_replace_na(c(1, NA, 3), 0)
arlc_replace_na(data.frame(a = c(1, NA, 3), b = c(NA, NA, 3)), 0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
