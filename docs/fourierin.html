<!DOCTYPE html><html><head><title>Help for package fourierin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fourierin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fourierin'><p>Compute Fourier integrals</p></a></li>
<li><a href='#fourierin_1d'><p>Univariate Fourier integrals</p></a></li>
<li><a href='#fourierin_2d'><p>Bivariate Fourier integrals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computes Numeric Fourier Integrals</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillermo Basulto-Elias</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillermo Basulto-Elias &lt;guillermobasulto@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes Fourier integrals of functions of one and two variables using the Fast Fourier transform. The Fourier transforms must be evaluated on a regular grid for fast evaluation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, knitr, rmarkdown, dplyr, tidyr, purrr, ggplot2,
lattice, rbenchmark, testthat (&ge; 3.1.0), covr, spelling</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gbasulto/fourierin">https://github.com/gbasulto/fourierin</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gbasulto/fourierin/issues">https://github.com/gbasulto/fourierin/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 19:18:14 UTC; basulto</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fourierin'>Compute Fourier integrals</h2><span id='topic+fourierin'></span>

<h3>Description</h3>

<p>It computes Fourier integrals for functions of one and two
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourierin(
  f,
  lower_int,
  upper_int,
  lower_eval = NULL,
  upper_eval = NULL,
  const_adj,
  freq_adj,
  resolution = NULL,
  eval_grid = NULL,
  use_fft = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourierin_+3A_f">f</code></td>
<td>
<p>function or a vector of size m. If a function is
provided, it must be able to be evaluated at vectors. If a
vector of values is provided, such evaluations must have been
obtained on a regular grid and the Fourier integral is faster
is m is a power of 2.</p>
</td></tr>
<tr><td><code id="fourierin_+3A_lower_int">lower_int</code></td>
<td>
<p>Lower integration limit(s).</p>
</td></tr>
<tr><td><code id="fourierin_+3A_upper_int">upper_int</code></td>
<td>
<p>Upper integration limit(s).</p>
</td></tr>
<tr><td><code id="fourierin_+3A_lower_eval">lower_eval</code></td>
<td>
<p>Lower evaluation limit(s). It can be NULL if an
evaluation grid is provided.</p>
</td></tr>
<tr><td><code id="fourierin_+3A_upper_eval">upper_eval</code></td>
<td>
<p>Upper evaluation limit(s). It can be NULL if an
evaluation grid is provided.</p>
</td></tr>
<tr><td><code id="fourierin_+3A_const_adj">const_adj</code></td>
<td>
<p>Factor related to adjust definition of Fourier
transform. It is usually equal to 0, -1 or 1.</p>
</td></tr>
<tr><td><code id="fourierin_+3A_freq_adj">freq_adj</code></td>
<td>
<p>Constant to adjust the exponent on the definition
of the Fourier transform. It is usually equal to 1, -1, 2pi or
-2pi.</p>
</td></tr>
<tr><td><code id="fourierin_+3A_resolution">resolution</code></td>
<td>
<p>A vector of integers (faster if powers of two)
determining the resolution of the evaluation grid. Not
required if f is a vector.</p>
</td></tr>
<tr><td><code id="fourierin_+3A_eval_grid">eval_grid</code></td>
<td>
<p>Optional matrix with d columns with the points
where the Fourier integral will be evaluated. If it is
provided, the FFT will not be used.</p>
</td></tr>
<tr><td><code id="fourierin_+3A_use_fft">use_fft</code></td>
<td>
<p>Logical value specifying whether the FFT will be
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See plenty of detailed examples in the vignette.
</p>


<h3>Value</h3>

<p>A list with the elements n-dimensional array and n vectors
with their corresponding resolution. Specifically,
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>A n-dimensional (resol_1 x resol_2 x ... x
resol_n) complex array with the values.</p>
</td></tr>  <tr><td><code>w1</code></td>
<td>
<p>A vector of
size resol_1</p>
</td></tr> <tr><td><code>...</code></td>
<td>
 </td></tr> <tr><td><code>wn</code></td>
<td>
<p>A vector of size resol_n</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##--- Example 1 ---------------------------------------------------
##--- Recovering std. normal from its characteristic function -----
library(fourierin)

## Function to be used in the integrand
myfnc &lt;- function(t) exp(-t^2/2)

## Compute integral
out &lt;- fourierin(f = myfnc, lower_int = -5, upper_int = 5,
                 lower_eval= -3, upper_eval = 3, const_adj = -1,
                 freq_adj = -1, resolution = 64)

## Extract grid and values
grid &lt;- out$w
values &lt;- Re(out$values)

## Compare with true values of Fourier transform
plot(grid, values, type = "l", col = 3)
lines(grid, dnorm(grid), col = 4)


##--- Example 2 ---------------------------------------------------
##--- Computing characteristic function of a gamma r. v. ----------

library(fourierin)

## Function to be used in integrand
myfnc &lt;- function(t) dgamma(t, shape, rate)

## Compute integral
shape &lt;- 5
rate &lt;- 3
out &lt;- fourierin(f = myfnc, lower_int = 0, upper_int = 6,
                 lower_eval = -4, upper_eval = 4,
                 const_adj = 1, freq_adj = 1, resolution = 64)

## Extract values
grid &lt;- out$w                           # Extract grid
re_values &lt;- Re(out$values)             # Real values
im_values &lt;- Im(out$values)             # Imag values

## Now compute the real and imaginary true values of the
## characteric function.
true_cf &lt;- function(t, shape, rate) (1 - 1i*t/rate)^-shape
true_re &lt;- Re(true_cf(grid, shape, rate))
true_im &lt;- Im(true_cf(grid, shape, rate))

## Compare them. We can see a slight discrepancy on the tails,
## but that is fixed when resulution is increased.
plot(grid, re_values, type = "l", col = 3)
lines(grid, true_re, col = 4)

                                        # Same here
plot(grid, im_values, type = "l", col = 3)
lines(grid, true_im, col = 4)

##--- Example 3 -------------------------------------------------
##--- Recovering std. normal from its characteristic function ---
library(fourierin)

##-Parameters of bivariate normal distribution
mu &lt;- c(-1, 1)
sig &lt;- matrix(c(3, -1, -1, 2), 2, 2)

##-Multivariate normal density
##-x is n x d
f &lt;- function(x) {
    ##-Auxiliar values
    d &lt;- ncol(x)
    z &lt;- sweep(x, 2, mu, "-")
    ##-Get numerator and denominator of normal density
    num &lt;- exp(-0.5*rowSums(z * (z %*% solve(sig))))
    denom &lt;- sqrt((2*pi)^d*det(sig))
    return(num/denom)
}

## Characteristic function
## s is n x d
phi &lt;- function(s) {
    complex(modulus = exp(- 0.5*rowSums(s*(s %*% sig))),
            argument = s %*% mu)
}

##-Approximate cf using Fourier integrals
eval &lt;- fourierin(f, lower_int = c(-8, -6), upper_int = c(6, 8),
                  lower_eval = c(-4, -4), upper_eval = c(4, 4),
                  const_adj = 1, freq_adj =  1,
                  resolution = c(128, 128))

## Extract values
t1 &lt;- eval$w1
t2 &lt;- eval$w2
t &lt;- as.matrix(expand.grid(t1 = t1, t2 = t2))
approx &lt;- eval$values
true &lt;- matrix(phi(t), 128, 128)        # Compute true values


## This is a section of the characteristic function
i &lt;- 65
plot(t2, Re(approx[i, ]), type = "l", col = 2,
     ylab = "",
     xlab = expression(t[2]),
     main = expression(paste("Real part section at ",
                             t[1], "= 0")))
lines(t2, Re(true[i, ]), col = 3)
legend("topleft", legend = c("true", "approximation"),
       col = 3:2, lwd = 1)

##-Another section, now of the imaginary part
plot(t1, Im(approx[, i]), type = "l", col = 2,
     ylab = "",
     xlab = expression(t[1]),
     main = expression(paste("Imaginary part section at ",
                             t[2], "= 0")))
lines(t1, Im(true[, i]), col = 3)
legend("topleft", legend = c("true", "approximation"),
       col = 3:2, lwd = 1)
</code></pre>

<hr>
<h2 id='fourierin_1d'>Univariate Fourier integrals</h2><span id='topic+fourierin_1d'></span>

<h3>Description</h3>

<p>It computes Fourier integrals of functions of one and two
variables on a regular grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourierin_1d(
  f,
  lower_int,
  upper_int,
  lower_eval = NULL,
  upper_eval = NULL,
  const_adj,
  freq_adj,
  resolution = NULL,
  eval_grid = NULL,
  use_fft = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourierin_1d_+3A_f">f</code></td>
<td>
<p>function or a vector of size m. If a function is
provided, it must be able to be evaluated at vectors. If a
vector of values is provided, such evaluations must have been
obtained on a regular grid and the Fourier integral is faster
is m is a power of 2.</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_lower_int">lower_int</code></td>
<td>
<p>Lower integration limit(s).</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_upper_int">upper_int</code></td>
<td>
<p>Upper integration limit(s).</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_lower_eval">lower_eval</code></td>
<td>
<p>Lower evaluation limit(s). It can be NULL if an
evaluation grid is provided.</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_upper_eval">upper_eval</code></td>
<td>
<p>Upper evaluation limit(s). It can be NULL if an
evaluation grid is provided.</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_const_adj">const_adj</code></td>
<td>
<p>Factor related to adjust definition of Fourier
transform. It is usually equal to 0, -1 or 1.</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_freq_adj">freq_adj</code></td>
<td>
<p>Constant to adjust the exponent on the definition
of the Fourier transform. It is usually equal to 1, -1, 2pi or
-2pi.</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_resolution">resolution</code></td>
<td>
<p>A vector of integers (faster if powers of two)
determining the resolution of the evaluation grid. Not
required if f is a vector.</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_eval_grid">eval_grid</code></td>
<td>
<p>Optional matrix with d columns with the points
where the Fourier integral will be evaluated. If it is
provided, the FFT will not be used.</p>
</td></tr>
<tr><td><code id="fourierin_1d_+3A_use_fft">use_fft</code></td>
<td>
<p>Logical value specifying whether the FFT will be
used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See vignette for more detailed examples.
</p>


<h3>Value</h3>

<p>If w is given, only the values of the Fourier integral are
returned, otherwise, a list with the elements </p>
<table>
<tr><td><code>w</code></td>
<td>
<p>A vector
of size m where the integral was computed.</p>
</td></tr>  <tr><td><code>values</code></td>
<td>
<p>A
complex vector of size m with the values of the integral</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##--- Example 1 ---------------------------------------------------
##--- Recovering std. normal from its characteristic function -----
library(fourierin)

#' Function to to be used in integrand
myfun &lt;- function(t) exp(-t^2/2)

                                        # Compute Foueien integral
out &lt;- fourierin_1d(f = myfun,
                    lower_int = -5, upper_int = 5,
                    lower_eval = -3, upper_eval = 3,
                    const_adj = -1, freq_adj = -1,
                    resolution = 64)

## Extract grid and values
grid &lt;- out$w
values &lt;- Re(out$values)

plot(grid, values, type = "l", col = 3)
lines(grid, dnorm(grid), col = 4)

##--- Example 2 -----------------------------------------------
##--- Computing characteristic function of a gamma r. v. ------

library(fourierin)

## Function to to be used in integrand
myfun &lt;- function(t) dgamma(t, shape, rate)

## Compute integral
shape &lt;- 5
rate &lt;- 3
out &lt;- fourierin_1d(f = myfun, lower_int = 0, upper_int = 6,
                    lower_eval = -4, upper_eval = 4,
                    const_adj = 1, freq_adj = 1, resolution = 64)

grid &lt;- out$w                           # Extract grid
re_values &lt;- Re(out$values)             # Real values
im_values &lt;- Im(out$values)             # Imag values

                                     # Now compute the real and
                                     # imaginary true values of the
                                        # characteric function.
true_cf &lt;- function(t, shape, rate) (1 - 1i*t/rate)^-shape
true_re &lt;- Re(true_cf(grid, shape, rate))
true_im &lt;- Im(true_cf(grid, shape, rate))

                                     # Compare them. We can see a
                                     # slight discrepancy on the
                                     # tails, but that is fixed
                                     # when resulution is
                                     # increased.
plot(grid, re_values, type = "l", col = 3)
lines(grid, true_re, col = 4)

                                        # Same here
plot(grid, im_values, type = "l", col = 3)
lines(grid, true_im, col = 4)
</code></pre>

<hr>
<h2 id='fourierin_2d'>Bivariate Fourier integrals</h2><span id='topic+fourierin_2d'></span>

<h3>Description</h3>

<p>It computes Fourier integrals for functions of one and two
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourierin_2d(
  f,
  lower_int,
  upper_int,
  lower_eval = NULL,
  upper_eval = NULL,
  const_adj,
  freq_adj,
  resolution = NULL,
  eval_grid = NULL,
  use_fft = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourierin_2d_+3A_f">f</code></td>
<td>
<p>function or a vector of size m. If a function is
provided, it must be able to be evaluated at vectors. If a
vector of values is provided, such evaluations must have been
obtained on a regular grid and the Fourier integral is faster
is m is a power of 2.</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_lower_int">lower_int</code></td>
<td>
<p>Lower integration limit(s).</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_upper_int">upper_int</code></td>
<td>
<p>Upper integration limit(s).</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_lower_eval">lower_eval</code></td>
<td>
<p>Lower evaluation limit(s). It can be NULL if an
evaluation grid is provided.</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_upper_eval">upper_eval</code></td>
<td>
<p>Upper evaluation limit(s). It can be NULL if an
evaluation grid is provided.</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_const_adj">const_adj</code></td>
<td>
<p>Factor related to adjust definition of Fourier
transform. It is usually equal to 0, -1 or 1.</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_freq_adj">freq_adj</code></td>
<td>
<p>Constant to adjust the exponent on the definition
of the Fourier transform. It is usually equal to 1, -1, 2pi or
-2pi.</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_resolution">resolution</code></td>
<td>
<p>A vector of integers (faster if powers of two)
determining the resolution of the evaluation grid. Not
required if f is a vector.</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_eval_grid">eval_grid</code></td>
<td>
<p>Optional matrix with d columns with the points
where the Fourier integral will be evaluated. If it is
provided, the FFT will not be used.</p>
</td></tr>
<tr><td><code id="fourierin_2d_+3A_use_fft">use_fft</code></td>
<td>
<p>Logical value specifying whether the FFT will be
used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If w is given, only the values of the Fourier integral are
returned, otherwise, a list with three elements
</p>
<table>
<tr><td><code>w1</code></td>
<td>
<p>Evaluation grid for first entry</p>
</td></tr> <tr><td><code>w2</code></td>
<td>
<p>Evaluation
grid for second entry</p>
</td></tr> <tr><td><code>values</code></td>
<td>
<p>m1 x m2 matrix of complex
numbers, corresponding to the evaluations of the integral</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>##--- Recovering std. normal from its characteristic function -----
library(fourierin)

##-Parameters of bivariate normal distribution
mu &lt;- c(-1, 1)
sig &lt;- matrix(c(3, -1, -1, 2), 2, 2)

##-Multivariate normal density
##-x is n x d
f &lt;- function(x) {
    ##-Auxiliar values
    d &lt;- ncol(x)
    z &lt;- sweep(x, 2, mu, "-")

    ##-Get numerator and denominator of normal density
    num &lt;- exp(-0.5*rowSums(z * (z %*% solve(sig))))
    denom &lt;- sqrt((2*pi)^d*det(sig))

    return(num/denom)
}

##-Characteristic function
##-s is n x d
phi &lt;- function(s) {
    complex(modulus = exp(- 0.5*rowSums(s*(s %*% sig))),
            argument = s %*% mu)
}

##-Approximate cf using Fourier integrals
eval &lt;- fourierin_2d(f, lower_int = c(-8, -6), upper_int = c(6, 8),
                     lower_eval = c(-4, -4), upper_eval = c(4, 4),
                     const_adj = 1, freq_adj =  1,
                     resolution = c(128, 128))

## Extract values
t1 &lt;- eval$w1
t2 &lt;- eval$w2
t &lt;- as.matrix(expand.grid(t1 = t1, t2 = t2))
approx &lt;- eval$values
true &lt;- matrix(phi(t), 128, 128)        # Compute true values

##-This is a section of the characteristic functions
i &lt;- 65
plot(t2, Re(approx[i, ]), type = "l", col = 2,
     ylab = "",
     xlab = expression(t[2]),
     main = expression(paste("Real part section at ",
                             t[1], "= 0")))
lines(t2, Re(true[i, ]), col = 3)
legend("topleft", legend = c("true", "approximation"),
       col = 3:2, lwd = 1)

##-Another section, now of the imaginary part
plot(t1, Im(approx[, i]), type = "l", col = 2,
     ylab = "",
     xlab = expression(t[1]),
     main = expression(paste("Imaginary part section at ",
                             t[2], "= 0")))
lines(t1, Im(true[, i]), col = 3)
legend("topleft", legend = c("true", "approximation"),
       col = 3:2, lwd = 1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
