<!DOCTYPE html><html><head><title>Help for package qfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ar2qspec'><p>Quantile Spectrum from AR Model of Quantile Series</p></a></li>
<li><a href='#qacf'><p>Quantile Autocovariance Function (QACF)</p></a></li>
<li><a href='#qdft'><p>Quantile Discrete Fourier Transform (QDFT)</p></a></li>
<li><a href='#qdft2qacf'><p>Quantile Autocovariance Function (QACF)</p></a></li>
<li><a href='#qdft2qper'><p>Quantile Periodogram and Cross-Periodogram (QPER)</p></a></li>
<li><a href='#qdft2qser'><p>Quantile Series (QSER)</p></a></li>
<li><a href='#qfa.plot'><p>Quantile-Frequency Plot</p></a></li>
<li><a href='#qkl.divergence'><p>Kullback-Leibler Divergence of Quantile Spectral Estimate</p></a></li>
<li><a href='#qper'><p>Quantile Periodogram and Cross-Periodogram (QPER)</p></a></li>
<li><a href='#qper2'><p>Quantile Periodogram Type II (QPER2)</p></a></li>
<li><a href='#qser'><p>Quantile Series (QSER)</p></a></li>
<li><a href='#qser2ar'><p>Autoregression (AR) Model of Quantile Series</p></a></li>
<li><a href='#qser2sar'><p>Spline Autoregression (SAR) Model of Quantile Series</p></a></li>
<li><a href='#qsmooth.qdft'><p>Quantile Smoothing of Quantile Discrete Fourier Transform</p></a></li>
<li><a href='#qsmooth.qper'><p>Quantile Smoothing of Quantile Periodogram or Spectral Estimate</p></a></li>
<li><a href='#qspec.ar'><p>Autoregression (AR) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec.lw'><p>Lag-Window (LW) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec.lwqs'><p>Lag-Window-Quantile-Smoothing (LWQS) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec.qslw'><p>Quantile-Smoothing-Lag-Window (QSLW) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec.sar'><p>Spline Autoregression (SAR) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec.sqrlw'><p>Spline-Quantile-Regression-Lag-Window (SQRLW) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec2qcoh'><p>Quantile Coherence Spectrum</p></a></li>
<li><a href='#sar.eq.bootstrap'><p>Bootstrap Simulation of SAR Coefficients for Testing Equality of Granger-Causality in Two Samples</p></a></li>
<li><a href='#sar.eq.test'><p>Wald Test and Confidence Band for Equality of SAR-Based Granger-Causality in Two Samples</p></a></li>
<li><a href='#sar.gc.bootstrap'><p>Bootstrap Simulation of SAR Coefficients for Granger-Causality Analysis</p></a></li>
<li><a href='#sar.gc.coef'><p>Extraction of SAR Coefficients for Granger-Causality Analysis</p></a></li>
<li><a href='#sar.gc.test'><p>Wald Test and Confidence Band for SAR-Based Granger-Causality Analysis</p></a></li>
<li><a href='#sqdft'><p>Spline Quantile Discrete Fourier Transform (SQDFT)</p></a></li>
<li><a href='#sqr.fit'><p>Spline Quantile Regression (SQR)</p></a></li>
<li><a href='#tqr.fit'><p>Trigonometric Quantile Regression (TQR)</p></a></li>
<li><a href='#tsqr.fit'><p>Trigonometric Spline Quantile Regression (TSQR)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantile-Frequency Analysis (QFA) of Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ta-Hsin Li &lt;thl@us.ibm.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantile-frequency analysis (QFA) of univariate or multivariate time series based on trigonometric quantile regression. See Li, T.-H. (2012) "Quantile periodograms", Journal of the American Statistical Association, 107, 765â€“776, &lt;<a href="https://doi.org/10.1080%2F01621459.2012.682815">doi:10.1080/01621459.2012.682815</a>&gt;; Li, T.-H. (2014) Time Series with Mixed Spectra, CRC Press, &lt;<a href="https://doi.org/10.1201%2Fb15154">doi:10.1201/b15154</a>&gt;; Li, T.-H. (2022) "Quantile Fourier transform, quantile series, and nonparametric estimation of quantile spectra", &lt;<a href="https://doi.org/10.48550%2FarXiv.2211.05844">doi:10.48550/arXiv.2211.05844</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RhpcBLASctl, doParallel, fields, foreach, mgcv, nlme,
parallel, quantreg, splines, stats, graphics, colorRamps, MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="https://github.com/IBM/qfa">https://github.com/IBM/qfa</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 17:34:42 UTC; 991216897</td>
</tr>
<tr>
<td>Author:</td>
<td>Ta-Hsin Li [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ar2qspec'>Quantile Spectrum from AR Model of Quantile Series</h2><span id='topic+ar2qspec'></span>

<h3>Description</h3>

<p>This function computes quantile spectrum/cross-spectrum (QSPEC) from an AR model of quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ar2qspec(fit, freq = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ar2qspec_+3A_fit">fit</code></td>
<td>
<p>object of AR model from <code>qser2sar()</code> or <code>qser2ar()</code></p>
</td></tr>
<tr><td><code id="ar2qspec_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in [0,1) (default = <code>NULL</code>: all Fourier frequencies)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of quantile spectrum/cross-spectrum</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>sequence of frequencies</p>
</td></tr>
</table>

<hr>
<h2 id='qacf'>Quantile Autocovariance Function (QACF)</h2><span id='topic+qacf'></span>

<h3>Description</h3>

<p>This function computes quantile autocovariance function (QACF) from time series 
or quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qacf(y, tau, y.qdft = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qacf_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qacf_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qacf_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of pre-calculated QDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qacf_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qdft = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qacf_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile autocovariance function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
# compute from time series
y.qacf &lt;- qacf(y,tau)
# compute from QDFT 
y.qdft &lt;- qdft(y,tau) 
y.qacf &lt;- qacf(y.qdft=y.qdft)
</code></pre>

<hr>
<h2 id='qdft'>Quantile Discrete Fourier Transform (QDFT)</h2><span id='topic+qdft'></span>

<h3>Description</h3>

<p>This function computes quantile discrete Fourier transform (QDFT) for univariate or multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft(y, tau, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdft_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qdft_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qdft_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qdft_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile discrete Fourier transform of <code>y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y,tau)
# Make a cluster for repeated use
n.cores &lt;- 2
cl &lt;- parallel::makeCluster(n.cores)
parallel::clusterExport(cl, c("tqr.fit"))
doParallel::registerDoParallel(cl)
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y.qdft &lt;- qdft(y1,tau,n.cores=n.cores,cl=cl)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y.qdft &lt;- qdft(y2,tau,n.cores=n.cores,cl=cl)
parallel::stopCluster(cl)
</code></pre>

<hr>
<h2 id='qdft2qacf'>Quantile Autocovariance Function (QACF)</h2><span id='topic+qdft2qacf'></span>

<h3>Description</h3>

<p>This function computes quantile autocovariance function (QACF) from QDFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft2qacf(y.qdft, return.qser = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdft2qacf_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of QDFT from <code>qdft()</code> or SQDFT from <code>sqdft()</code></p>
</td></tr>
<tr><td><code id="qdft2qacf_+3A_return.qser">return.qser</code></td>
<td>
<p>if <code>TRUE</code>, return quantile series (QSER) along with QACF</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile autocovariance function if <code>return.sqer = FALSE</code> (default), else a list with the following elements:
</p>
<table>
<tr><td><code>qacf</code></td>
<td>
<p>matirx or array of quantile autocovariance function</p>
</td></tr>
<tr><td><code>qser</code></td>
<td>
<p>matrix or array of quantile series</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># single time series
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y1,tau)
y.qacf &lt;- qdft2qacf(y.qdft)
plot(c(0:9),y.qacf[c(1:10),1],type='h',xlab="LAG",ylab="QACF")
y.qser &lt;- qdft2qacf(y.qdft,return.qser=TRUE)$qser
plot(y.qser[,1],type='l',xlab="TIME",ylab="QSER")
# multiple time series
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qacf &lt;- qdft2qacf(y.qdft)
plot(c(0:9),y.qacf[1,2,c(1:10),1],type='h',xlab="LAG",ylab="QACF")
</code></pre>

<hr>
<h2 id='qdft2qper'>Quantile Periodogram and Cross-Periodogram (QPER)</h2><span id='topic+qdft2qper'></span>

<h3>Description</h3>

<p>This function computes quantile periodogram/cross-periodogram (QPER) from QDFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft2qper(y.qdft)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdft2qper_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of QDFT from <code>qdft()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile periodogram/cross-periodogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single time series
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y1,tau)
y.qper &lt;- qdft2qper(y.qdft)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
qfa.plot(ff[sel.f],tau,Re(y.qper[sel.f,]))
# multiple time series
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qper &lt;- qdft2qper(y.qdft)
qfa.plot(ff[sel.f],tau,Re(y.qper[1,1,sel.f,]))
qfa.plot(ff[sel.f],tau,Re(y.qper[1,2,sel.f,]))
</code></pre>

<hr>
<h2 id='qdft2qser'>Quantile Series (QSER)</h2><span id='topic+qdft2qser'></span>

<h3>Description</h3>

<p>This function computes quantile series (QSER) from QDFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft2qser(y.qdft)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdft2qser_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of QDFT from <code>qdft()</code> or SQDFT from <code>sqdft()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile series
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single time series
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y1,tau)
y.qser &lt;- qdft2qser(y.qdft)
plot(y.qser[,1],type='l',xlab="TIME",ylab="QSER")
# multiple time series
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qser &lt;- qdft2qser(y.qdft)
plot(y.qser[1,,1],type='l',xlab="TIME",ylab="QSER")
</code></pre>

<hr>
<h2 id='qfa.plot'>Quantile-Frequency Plot</h2><span id='topic+qfa.plot'></span>

<h3>Description</h3>

<p>This function creates an image plot of quantile spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfa.plot(
  freq,
  tau,
  rqper,
  rg.qper = range(rqper),
  rg.tau = range(tau),
  rg.freq = c(0, 0.5),
  color = colorRamps::matlab.like2(1024),
  ylab = "QUANTILE LEVEL",
  xlab = "FREQUENCY",
  tlab = NULL,
  set.par = TRUE,
  legend.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfa.plot_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in (0,0.5) at which quantile spectrum is evaluated</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1) at which quantile spectrum is evaluated</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rqper">rqper</code></td>
<td>
<p>real-valued matrix of quantile spectrum evaluated on the <code>freq</code> x <code>tau</code> grid</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rg.qper">rg.qper</code></td>
<td>
<p><code>zlim</code> for <code>qper</code> (default = <code>range(qper)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rg.tau">rg.tau</code></td>
<td>
<p><code>ylim</code> for <code>tau</code> (default = <code>range(tau)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rg.freq">rg.freq</code></td>
<td>
<p><code>xlim</code> for <code>freq</code> (default = <code>c(0,0.5)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_color">color</code></td>
<td>
<p>colors (default = <code>colorRamps::matlab.like2(1024)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_ylab">ylab</code></td>
<td>
<p>label of y-axis (default = <code>"QUANTILE LEVEL"</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_xlab">xlab</code></td>
<td>
<p>label of x-axis (default = <code>"FREQUENCY"</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_tlab">tlab</code></td>
<td>
<p>title of plot (default = <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_set.par">set.par</code></td>
<td>
<p>if <code>TRUE</code>, <code>par()</code> is set internally (single image)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_legend.plot">legend.plot</code></td>
<td>
<p>if <code>TRUE</code>, legend plot is added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>

<hr>
<h2 id='qkl.divergence'>Kullback-Leibler Divergence of Quantile Spectral Estimate</h2><span id='topic+qkl.divergence'></span>

<h3>Description</h3>

<p>This function computes Kullback-Leibler divergence (KLD) of quantile spectral estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qkl.divergence(y.qper, qspec, sel.f = NULL, sel.tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qkl.divergence_+3A_y.qper">y.qper</code></td>
<td>
<p>matrix or array of quantile spectral estimate from, e.g., <code>qspec.lw()</code></p>
</td></tr>
<tr><td><code id="qkl.divergence_+3A_qspec">qspec</code></td>
<td>
<p>matrix of array of true quantile spectrum/cross-spectrum (same dimension as <code>y.qper</code>)</p>
</td></tr>
<tr><td><code id="qkl.divergence_+3A_sel.f">sel.f</code></td>
<td>
<p>index of selected frequencies for computation (default = <code>NULL</code>: all frequencies)</p>
</td></tr>
<tr><td><code id="qkl.divergence_+3A_sel.tau">sel.tau</code></td>
<td>
<p>index of selected quantile levels for computation (default = <code>NULL</code>: all quantile levels)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>real number of Kullback-Leibler divergence
</p>

<hr>
<h2 id='qper'>Quantile Periodogram and Cross-Periodogram (QPER)</h2><span id='topic+qper'></span>

<h3>Description</h3>

<p>This function computes quantile periodogram/cross-periodogram (QPER) from time series 
or quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qper(y, tau, y.qdft = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qper_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qper_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qper_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of pre-calculated QDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qper_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qdft = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qper_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile periodogram/cross-periodogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
# compute from time series
y.qper &lt;- qper(y,tau)  
# compute from QDFT 
y.qdft &lt;- qdft(y,tau) 
y.qper &lt;- qper(y.qdft=y.qdft)  
</code></pre>

<hr>
<h2 id='qper2'>Quantile Periodogram Type II (QPER2)</h2><span id='topic+qper2'></span>

<h3>Description</h3>

<p>This function computes type-II quantile periodogram for univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qper2(y, freq, tau, weights = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qper2_+3A_y">y</code></td>
<td>
<p>univariate time series</p>
</td></tr>
<tr><td><code id="qper2_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in [0,1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_weights">weights</code></td>
<td>
<p>sequence of weights in quantile regression (default = <code>NULL</code>: weights equal to 1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of quantile periodogram evaluated on <code>freq * tau</code> grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qper2 &lt;- qper2(y,ff,tau)
qfa.plot(ff[sel.f],tau,Re(y.qper2[sel.f,]))
</code></pre>

<hr>
<h2 id='qser'>Quantile Series (QSER)</h2><span id='topic+qser'></span>

<h3>Description</h3>

<p>This function computes quantile series (QSER) from time series or quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qser(y, tau, y.qdft = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qser_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qser_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qser_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of pre-calculated QDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qser_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qdft = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qser_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
# compute from time series
y.qser &lt;- qser(y,tau)  
# compute from QDFT
y.qdft &lt;- qdft(y,tau)  
y.qser &lt;- qser(y.qdft=y.qdft) 
</code></pre>

<hr>
<h2 id='qser2ar'>Autoregression (AR) Model of Quantile Series</h2><span id='topic+qser2ar'></span>

<h3>Description</h3>

<p>This function fits an autoregression (AR) model to quantile series (QSER) separately for each quantile level using <code>stats::ar()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qser2ar(y.qser, p = NULL, order.max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qser2ar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER, e.g., using <code>qser()</code></p>
</td></tr>
<tr><td><code id="qser2ar_+3A_p">p</code></td>
<td>
<p>order of AR model (default = <code>NULL</code>: selected by AIC)</p>
</td></tr>
<tr><td><code id="qser2ar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>matrix or array of AR coefficients</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>vector or matrix of residual covariance</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>order of AR model</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>matrix or array of residuals</p>
</td></tr>
</table>

<hr>
<h2 id='qser2sar'>Spline Autoregression (SAR) Model of Quantile Series</h2><span id='topic+qser2sar'></span>

<h3>Description</h3>

<p>This function fits spline autoregression (SAR) model to quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qser2sar(
  y.qser,
  tau,
  d = 1,
  p = NULL,
  order.max = NULL,
  spar = NULL,
  method = c("AIC", "BIC", "GCV"),
  weighted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qser2sar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER, e.g., using <code>qser()</code></p>
</td></tr>
<tr><td><code id="qser2sar_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels where <code>y.qser</code> is calculated</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_p">p</code></td>
<td>
<p>order of SAR model (default = <code>NULL</code>: automatically selected by AIC)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_spar">spar</code></td>
<td>
<p>penalty parameter alla <code>smooth.spline</code> (default = <code>NULL</code>: automatically selected)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_method">method</code></td>
<td>
<p>criterion for penalty parameter selection:  <code>"AIC"</code> (default), <code>"BIC"</code>, or <code>"GCV"</code></p>
</td></tr>
<tr><td><code id="qser2sar_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>matrix or array of SAR coefficients</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>vector or matrix of SAR residual covariance</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>order of SAR model</p>
</td></tr>
<tr><td><code>spar</code></td>
<td>
<p>penalty parameter</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>sequence of quantile levels</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>subsampling rate of quantile levels</p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>option for weighted penalty function</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object containing details of SAR fit</p>
</td></tr>
</table>

<hr>
<h2 id='qsmooth.qdft'>Quantile Smoothing of Quantile Discrete Fourier Transform</h2><span id='topic+qsmooth.qdft'></span>

<h3>Description</h3>

<p>This function computes quantile-smoothed version of quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsmooth.qdft(
  y.qdft,
  method = c("gamm", "sp"),
  spar = "GCV",
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsmooth.qdft_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of QDFT from <code>qdft()</code></p>
</td></tr>
<tr><td><code id="qsmooth.qdft_+3A_method">method</code></td>
<td>
<p>smoothing method: <code>"gamm"</code> for <code>mgcv::gamm()</code> (default), 
<code>"sp"</code> for <code>stats::smooth.spline()</code></p>
</td></tr>
<tr><td><code id="qsmooth.qdft_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter in <code>smooth.spline()</code> if <code>method = "sp"</code> (default = <code>"GCV"</code>)</p>
</td></tr>
<tr><td><code id="qsmooth.qdft_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qsmooth.qdft_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile-smoothed QDFT
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qdft &lt;- qsmooth.qdft(y.qdft,method="sp",spar=0.9)
y.qacf &lt;- qdft2qacf(y.qdft)
y.qper.qslw &lt;- qspec.lw(y.qacf,M=5)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.qslw[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qsmooth.qper'>Quantile Smoothing of Quantile Periodogram or Spectral Estimate</h2><span id='topic+qsmooth.qper'></span>

<h3>Description</h3>

<p>This function computes quantile-smoothed version of quantile periodogram/cross-periodogram (QPER) or other quantile spectral estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qsmooth.qper(
  y.qper,
  method = c("gamm", "sp"),
  spar = "GCV",
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qsmooth.qper_+3A_y.qper">y.qper</code></td>
<td>
<p>matrix or array of quantile periodogram/cross-periodogram or spectral estimate</p>
</td></tr>
<tr><td><code id="qsmooth.qper_+3A_method">method</code></td>
<td>
<p>smoothing method: <code>"gamm"</code> for <code>mgcv::gamm()</code> (default), 
<code>"sp"</code> for <code>stats::smooth.spline()</code></p>
</td></tr>
<tr><td><code id="qsmooth.qper_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter in <code>smooth.spline()</code> if <code>method = "sp"</code> (default = <code>"GCV"</code>)</p>
</td></tr>
<tr><td><code id="qsmooth.qper_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qsmooth.qper_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile-smoothed quantile spectral estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qacf &lt;- qdft2qacf(y.qdft)
y.qper.lw &lt;- qspec.lw(y.qacf,M=5)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.lw[1,1,sel.f,]))
y.qper.lwqs &lt;- qsmooth.qper(y.qper.lw,method="sp",spar=0.9)
qfa.plot(ff[sel.f],tau,Re(y.qper.lwqs[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.ar'>Autoregression (AR) Estimator of Quantile Spectrum</h2><span id='topic+qspec.ar'></span>

<h3>Description</h3>

<p>This function computes autoregression (AR) estimate of quantile spectrum/cross-spectrum from time series or quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.ar(
  y,
  tau,
  y.qser = NULL,
  p = NULL,
  order.max = NULL,
  freq = NULL,
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspec.ar_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qser</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_p">p</code></td>
<td>
<p>order of AR model (default = <code>NULL</code>: automatically selected by AIC)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in [0,1) (default = <code>NULL</code>: all Fourier frequencies)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qser = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of AR quantile spectrum/cross-spectrum</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>sequence of frequencies</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object of AR model</p>
</td></tr>
<tr><td><code>qser</code></td>
<td>
<p>matrix or array of quantile series if <code>y.qser = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.ar &lt;- qspec.ar(cbind(y1,y2),tau,p=1)
qfa.plot(ff[sel.f],tau,Re(y.ar$spec[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.lw'>Lag-Window (LW) Estimator of Quantile Spectrum</h2><span id='topic+qspec.lw'></span>

<h3>Description</h3>

<p>This function computes lag-window (LW) estimate of quantile spectrum/cross-spectrum from QACF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.lw(y.qacf, M = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspec.lw_+3A_y.qacf">y.qacf</code></td>
<td>
<p>matrix or array of pre-calculated QACF from <code>qdft2qacf()</code></p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_m">M</code></td>
<td>
<p>bandwidth parameter of lag window (default = <code>NULL</code>: quantile periodogram)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of quantile spectrum/cross-spectrum</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>lag-window sequence</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># single time series
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y1,tau)
y.qacf &lt;- qdft2qacf(y.qdft)
y.qper.lw &lt;- qspec.lw(y.qacf,M=5)$spec
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
qfa.plot(ff[sel.f],tau,Re(y.qper.lw[sel.f,]))
# multiple time series
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qacf &lt;- qdft2qacf(y.qdft)
y.qper.lw &lt;- qspec.lw(y.qacf,M=5)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.lw[1,2,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.lwqs'>Lag-Window-Quantile-Smoothing (LWQS) Estimator of Quantile Spectrum</h2><span id='topic+qspec.lwqs'></span>

<h3>Description</h3>

<p>This function computes lag-window-quantile-smoothing (LWQS) estimate of quantile spectrum/cross-spectrum 
from time series or quantile autocovariance function (QACF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.lwqs(
  y,
  tau,
  y.qacf = NULL,
  M = NULL,
  method = c("gamm", "sp"),
  spar = "GCV",
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspec.lwqs_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.lwqs_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.lwqs_+3A_y.qacf">y.qacf</code></td>
<td>
<p>matrix or array of pre-calculated QACF (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qacf</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.lwqs_+3A_m">M</code></td>
<td>
<p>bandwidth parameter of lag window (default = <code>NULL</code>: quantile periodogram)</p>
</td></tr>
<tr><td><code id="qspec.lwqs_+3A_method">method</code></td>
<td>
<p>smoothing method: <code>"gamm"</code> for <code>mgcv::gamm()</code> (default), 
<code>"sp"</code> for <code>stats::smooth.spline()</code></p>
</td></tr>
<tr><td><code id="qspec.lwqs_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter in <code>smooth.spline()</code> if <code>method = "sp"</code> (default = <code>"GCV"</code>)</p>
</td></tr>
<tr><td><code id="qspec.lwqs_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.lwqs_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of quantile spectrum/cross-spectrum</p>
</td></tr>
<tr><td><code>spec.lw</code></td>
<td>
<p>matrix or array of quantile spectrum/cross-spectrum without quantile smoothing</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>lag-window sequence</p>
</td></tr>
<tr><td><code>qacf</code></td>
<td>
<p>matrix or array of quantile autocovariance function if <code>y.qacf = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qper.lwqs &lt;- qspec.lwqs(cbind(y1,y2),tau,M=5,method="sp",spar=0.9)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.lwqs[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.qslw'>Quantile-Smoothing-Lag-Window (QSLW) Estimator of Quantile Spectrum</h2><span id='topic+qspec.qslw'></span>

<h3>Description</h3>

<p>This function computes quantie-smoothing-lag-window (QSLW estimate of quantile spectrum/cross-spectrum 
from time series or quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.qslw(
  y,
  tau,
  y.qdft = NULL,
  M = NULL,
  method = c("gamm", "sp"),
  spar = "GCV",
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspec.qslw_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.qslw_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.qslw_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of pre-calculated QDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.qslw_+3A_m">M</code></td>
<td>
<p>bandwidth parameter of lag window (default = <code>NULL</code>: quantile periodogram)</p>
</td></tr>
<tr><td><code id="qspec.qslw_+3A_method">method</code></td>
<td>
<p>smoothing method: <code>"gamm"</code> for <code>mgcv::gamm()</code> (default), 
<code>"sp"</code> for <code>stats::smooth.spline()</code></p>
</td></tr>
<tr><td><code id="qspec.qslw_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter in <code>smooth.spline()</code> if <code>method = 'sp'</code> (default = <code>"GCV"</code>)</p>
</td></tr>
<tr><td><code id="qspec.qslw_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.qslw_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of quantile spectrum/cross-spectrum</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>lag-window sequence</p>
</td></tr>
<tr><td><code>qdft</code></td>
<td>
<p>matrix or array of quantile discrete Fourier transform if <code>y.qdft = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qper.qslw &lt;- qspec.qslw(cbind(y1,y2),tau,M=5,method="sp",spar=0.9)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.qslw[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.sar'>Spline Autoregression (SAR) Estimator of Quantile Spectrum</h2><span id='topic+qspec.sar'></span>

<h3>Description</h3>

<p>This function computes spline autoregression (SAR) estimate of quantile spectrum/cross-spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.sar(
  y,
  y.qser = NULL,
  tau,
  d = 1,
  p = NULL,
  order.max = NULL,
  spar = NULL,
  method = c("AIC", "BIC", "GCV"),
  weighted = FALSE,
  freq = NULL,
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspec.sar_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qser</code> is supplied, <code>y</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_p">p</code></td>
<td>
<p>order of SAR model (default = <code>NULL</code>: automatically selected by AIC)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_spar">spar</code></td>
<td>
<p>penalty parameter alla <code>smooth.spline</code> (default = <code>NULL</code>: automatically selected)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_method">method</code></td>
<td>
<p>criterion for penalty parameter selection:  <code>"AIC"</code> (default), <code>"BIC"</code>, or <code>"GCV"</code></p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in [0,1) (default = <code>NULL</code>: all Fourier frequencies)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qser = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of SAR quantile spectrum</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>sequence of frequencies</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object of SAR model</p>
</td></tr>
<tr><td><code>qser</code></td>
<td>
<p>matrix or array of quantile series if <code>y.qser = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
# compute from time series
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
qfa.plot(ff[sel.f],tau,Re(y.sar$spec[1,1,sel.f,]))
# compute from quantile series
y.qser &lt;- qser(cbind(y1,y2),tau)
y.sar &lt;- qspec.sar(y.qser=y.qser,tau=tau,p=1)
qfa.plot(ff[sel.f],tau,Re(y.sar$spec[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.sqrlw'>Spline-Quantile-Regression-Lag-Window (SQRLW) Estimator of Quantile Spectrum</h2><span id='topic+qspec.sqrlw'></span>

<h3>Description</h3>

<p>This function computes spline-quantile-regression-lag-window (SQRLW) estimate of quantile spectrum/cross-spectrum 
from time series or spline quantile discrete Fourier transform (SQDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.sqrlw(
  y,
  tau,
  y.sqdft = NULL,
  M = NULL,
  c0 = 0.02,
  d = 4,
  weighted = FALSE,
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspec.sqrlw_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_y.sqdft">y.sqdft</code></td>
<td>
<p>matrix or array of pre-calculated SQDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.sqdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_m">M</code></td>
<td>
<p>bandwidth parameter of lag window (default = <code>NULL</code>: quantile periodogram)</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_c0">c0</code></td>
<td>
<p>penalty parameter for SQDFT</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels for SQDFT (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, SQR penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of SQDFT (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.sqrlw_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of SQDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of quantile spectrum/cross-spectrum</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>lag-window sequence</p>
</td></tr>
<tr><td><code>sqdft</code></td>
<td>
<p>matrix or array of spline quantile discrete Fourier transform if <code>y.sqdft = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qper.sqrlw &lt;- qspec.sqrlw(cbind(y1,y2),tau,M=5,c0=0.02,d=4)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.sqrlw[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec2qcoh'>Quantile Coherence Spectrum</h2><span id='topic+qspec2qcoh'></span>

<h3>Description</h3>

<p>This function computes quantile coherence spectrum (QCOH) from quantile spectrum and cross-spectrum of multiple time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec2qcoh(qspec, k = 1, kk = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qspec2qcoh_+3A_qspec">qspec</code></td>
<td>
<p>array of quantile spectrum/cross-spectrum</p>
</td></tr>
<tr><td><code id="qspec2qcoh_+3A_k">k</code></td>
<td>
<p>index of first series (default = 1)</p>
</td></tr>
<tr><td><code id="qspec2qcoh_+3A_kk">kk</code></td>
<td>
<p>index of second series (default = 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of quantile coherence evaluated at Fourier frequencies in (0,0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qacf &lt;- qacf(cbind(y1,y2),tau)
y.qper.lw &lt;- qspec.lw(y.qacf,M=5)$spec
y.qcoh &lt;- qspec2qcoh(y.qper.lw,k=1,kk=2)
qfa.plot(ff[sel.f],tau,y.qcoh)
</code></pre>

<hr>
<h2 id='sar.eq.bootstrap'>Bootstrap Simulation of SAR Coefficients for Testing Equality of Granger-Causality in Two Samples</h2><span id='topic+sar.eq.bootstrap'></span>

<h3>Description</h3>

<p>This function simulates bootstrap samples of selected spline autoregression (SAR) coefficients 
for testing equality of Granger-causality in two samples based on their SAR models
under H0: effect in each sample equals the average effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.eq.bootstrap(
  y.qser,
  fit,
  fit2,
  index = c(1, 2),
  nsim = 1000,
  method = c("ar", "sar"),
  n.cores = 1,
  mthreads = FALSE,
  seed = 1234567
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar.eq.bootstrap_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of QSER from <code>qser()</code> or <code>qspec.sar()$qser</code></p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_fit">fit</code></td>
<td>
<p>object of SAR model from <code>qser2sar()</code> or <code>qspec.sar()$fit</code></p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_fit2">fit2</code></td>
<td>
<p>object of SAR model for the other sample</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_index">index</code></td>
<td>
<p>a pair of component indices for multiple time series 
or a sequence of lags for single time series (default = <code>c(1,2)</code>)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_nsim">nsim</code></td>
<td>
<p>number of bootstrap samples (default = 1000)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_method">method</code></td>
<td>
<p>method of residual calculation: <code>"ar"</code> (default) or <code>"sar"</code></p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>TRUE</code>, multithread BLAS is enabled when available (default = <code>FALSE</code>, required for parallel computing)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_seed">seed</code></td>
<td>
<p>seed for random sampling (default = <code>1234567</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of simulated bootstrap samples of selected SAR coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y11 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y21 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y12 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y22 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y1.sar &lt;- qspec.sar(cbind(y11,y21),tau=tau,p=1)
y2.sar &lt;- qspec.sar(cbind(y12,y22),tau=tau,p=1)
A1.sim &lt;- sar.eq.bootstrap(y1.sar$qser,y1.sar$fit,y2.sar$fit,index=c(1,2),nsim=5)
A2.sim &lt;- sar.eq.bootstrap(y2.sar$qser,y2.sar$fit,y1.sar$fit,index=c(1,2),nsim=5)
</code></pre>

<hr>
<h2 id='sar.eq.test'>Wald Test and Confidence Band for Equality of SAR-Based Granger-Causality in Two Samples</h2><span id='topic+sar.eq.test'></span>

<h3>Description</h3>

<p>This function computes Wald test and confidence band for equality of Granger-causality in two samples
using bootstrap samples generated by <code>sar.eq.bootstrap()</code> based on the spline autoregression (SAR) models
of quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.eq.test(A1, A1.sim, A2, A2.sim, sel.lag = NULL, sel.tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar.eq.test_+3A_a1">A1</code></td>
<td>
<p>matrix of selected SAR coefficients for sample 1</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_a1.sim">A1.sim</code></td>
<td>
<p>simulated bootstrap samples from <code>sar.eq.bootstrap()</code> for sample 1</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_a2">A2</code></td>
<td>
<p>matrix of selected SAR coefficients for sample 2</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_a2.sim">A2.sim</code></td>
<td>
<p>simulated bootstrap samples from <code>sar.eq.bootstrap()</code> for sample 2</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_sel.lag">sel.lag</code></td>
<td>
<p>indices of time lags for Wald test (default = <code>NULL</code>: all lags)</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_sel.tau">sel.tau</code></td>
<td>
<p>indices of quantile levels for Wald test (default = <code>NULL</code>: all quantiles)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>test</code></td>
<td>
<p>list of Wald test result containing <code>wald</code> and <code>p.value</code></p>
</td></tr>
<tr><td><code>D.u</code></td>
<td>
<p>matrix of upper limits of 95% confidence band for <code>A1 - A2</code></p>
</td></tr>
<tr><td><code>D.l</code></td>
<td>
<p>matrix of lower limits of 95% confidence band for <code>A1 - A2</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y11 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y21 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y12 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y22 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y1.sar &lt;- qspec.sar(cbind(y11,y21),tau=tau,p=1)
y2.sar &lt;- qspec.sar(cbind(y12,y22),tau=tau,p=1)
A1.sim &lt;- sar.eq.bootstrap(y1.sar$qser,y1.sar$fit,y2.sar$fit,index=c(1,2),nsim=5)
A2.sim &lt;- sar.eq.bootstrap(y2.sar$qser,y2.sar$fit,y1.sar$fit,index=c(1,2),nsim=5)
A1 &lt;- sar.gc.coef(y1.sar$fit,index=c(1,2))
A2 &lt;- sar.gc.coef(y2.sar$fit,index=c(1,2))
test &lt;- sar.eq.test(A1,A1.sim,A2,A2.sim,sel.lag=NULL,sel.tau=NULL)
</code></pre>

<hr>
<h2 id='sar.gc.bootstrap'>Bootstrap Simulation of SAR Coefficients for Granger-Causality Analysis</h2><span id='topic+sar.gc.bootstrap'></span>

<h3>Description</h3>

<p>This function simulates bootstrap samples of selected spline autoregression (SAR) coefficients 
for Granger-causality analysis based on the SAR model of quantile series (QSER) under H0: 
(a) for multiple time series, the second series specified in <code>index</code> is not causal 
for the first series specified in <code>index</code>;
(b) for single time series, the series is not causal at the lags specified in <code>index</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.gc.bootstrap(
  y.qser,
  fit,
  index = c(1, 2),
  nsim = 1000,
  method = c("ar", "sar"),
  n.cores = 1,
  mthreads = FALSE,
  seed = 1234567
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar.gc.bootstrap_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of QSER from <code>qser()</code> or <code>qspec.sar()$qser</code></p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_fit">fit</code></td>
<td>
<p>object of SAR model from <code>qser2sar()</code> or <code>qspec.sar()$fit</code></p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_index">index</code></td>
<td>
<p>a pair of component indices for multiple time series 
or a sequence of lags for single time series (default = <code>c(1,2)</code>)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_nsim">nsim</code></td>
<td>
<p>number of bootstrap samples (default = 1000)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_method">method</code></td>
<td>
<p>method of residual calculation: <code>"ar"</code> (default) or <code>"sar"</code></p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>TRUE</code>, multithread BLAS is enabled when available (default = <code>FALSE</code>, required for parallel computing)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_seed">seed</code></td>
<td>
<p>seed for random sampling (default = <code>1234567</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of simulated bootstrap samples of selected SAR coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
A.sim &lt;- sar.gc.bootstrap(y.sar$qser,y.sar$fit,index=c(1,2),nsim=5)
</code></pre>

<hr>
<h2 id='sar.gc.coef'>Extraction of SAR Coefficients for Granger-Causality Analysis</h2><span id='topic+sar.gc.coef'></span>

<h3>Description</h3>

<p>This function extracts the spline autoregression (SAR) coefficients from an SAR model for Granger-causality analysis.
See <code>sar.gc.bootstrap</code> for more details regarding the use of <code>index</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.gc.coef(fit, index = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar.gc.coef_+3A_fit">fit</code></td>
<td>
<p>object of SAR model from <code>qser2sar()</code> or <code>qspec.sar()$fit</code></p>
</td></tr>
<tr><td><code id="sar.gc.coef_+3A_index">index</code></td>
<td>
<p>a pair of component indices for multiple time series 
or a sequence of lags for single time series (default = <code>c(1,2)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of selected SAR coefficients (number of lags by number of quantiles)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
A &lt;- sar.gc.coef(y.sar$fit,index=c(1,2))
</code></pre>

<hr>
<h2 id='sar.gc.test'>Wald Test and Confidence Band for SAR-Based Granger-Causality Analysis</h2><span id='topic+sar.gc.test'></span>

<h3>Description</h3>

<p>This function computes Wald test and confidence band for Granger-causality 
using bootstrap samples generated by <code>sar.gc.bootstrap()</code> 
based the spline autoregression (SAR) model of quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.gc.test(A, A.sim, sel.lag = NULL, sel.tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sar.gc.test_+3A_a">A</code></td>
<td>
<p>matrix of selected SAR coefficients</p>
</td></tr>
<tr><td><code id="sar.gc.test_+3A_a.sim">A.sim</code></td>
<td>
<p>simulated bootstrap samples from <code>sar.gc.bootstrap()</code></p>
</td></tr>
<tr><td><code id="sar.gc.test_+3A_sel.lag">sel.lag</code></td>
<td>
<p>indices of time lags for Wald test (default = <code>NULL</code>: all lags)</p>
</td></tr>
<tr><td><code id="sar.gc.test_+3A_sel.tau">sel.tau</code></td>
<td>
<p>indices of quantile levels for Wald test (default = <code>NULL</code>: all quantiles)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table>
<tr><td><code>test</code></td>
<td>
<p>list of Wald test result containing <code>wald</code> and <code>p.value</code></p>
</td></tr>
<tr><td><code>A.u</code></td>
<td>
<p>matrix of upper limits of 95% confidence band of <code>A</code></p>
</td></tr>
<tr><td><code>A.l</code></td>
<td>
<p>matrix of lower limits of 95% confidence band of <code>A</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
A &lt;- sar.gc.coef(y.sar$fit,index=c(1,2))
A.sim &lt;- sar.gc.bootstrap(y.sar$qser,y.sar$fit,index=c(1,2),nsim=5)
y.gc &lt;- sar.gc.test(A,A.sim)
</code></pre>

<hr>
<h2 id='sqdft'>Spline Quantile Discrete Fourier Transform (SQDFT)</h2><span id='topic+sqdft'></span>

<h3>Description</h3>

<p>This function computes spline quantile discrete Fourier transform (SQDFT) for univariate or multivariate time series
through trigonometric spline quantile regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqdft(y, tau, c0 = 0.02, d = 4, weighted = FALSE, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqdft_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_c0">c0</code></td>
<td>
<p>penalty parameter</p>
</td></tr>
<tr><td><code id="sqdft_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of the spline quantile discrete Fourier transform of <code>y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sqdft &lt;- sqdft(y,tau,c0=0.02,d=4)
n &lt;- length(y)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qacf &lt;- qdft2qacf(y.sqdft)
y.qper.sqrlw &lt;- qspec.lw(y.qacf,M=5)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.sqrlw[sel.f,]))
</code></pre>

<hr>
<h2 id='sqr.fit'>Spline Quantile Regression (SQR)</h2><span id='topic+sqr.fit'></span>

<h3>Description</h3>

<p>This function computes spline quantile regression (SQR) solution from response vector and design matrix.
It uses the FORTRAN code <code>rqfnb.f</code> in the &quot;quantreg&quot; package with the kind permission of Dr. R. Koenker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqr.fit(y, X, tau, c0, d = 1, weighted = FALSE, mthreads = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqr.fit_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_x">X</code></td>
<td>
<p>design matrix (<code>nrow(X) = length(y)</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_c0">c0</code></td>
<td>
<p>penalty parameter</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>TRUE</code>, multithread BLAS is enabled when available (default = <code>FALSE</code>, required for parallel computing)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>matrix of regression coefficients</p>
</td></tr>
<tr><td><code>nit</code></td>
<td>
<p>number of iterations</p>
</td></tr>
</table>

<hr>
<h2 id='tqr.fit'>Trigonometric Quantile Regression (TQR)</h2><span id='topic+tqr.fit'></span>

<h3>Description</h3>

<p>This function computes trigonometric quantile regression (TQR) for univariate time series at a single frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tqr.fit(y, f0, tau, prepared = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tqr.fit_+3A_y">y</code></td>
<td>
<p>vector of time series</p>
</td></tr>
<tr><td><code id="tqr.fit_+3A_f0">f0</code></td>
<td>
<p>frequency in [0,1)</p>
</td></tr>
<tr><td><code id="tqr.fit_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="tqr.fit_+3A_prepared">prepared</code></td>
<td>
<p>if <code>TRUE</code>, intercept is removed and coef of cosine is doubled when <code>f0 = 0.5</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of <code>rq()</code> (coefficients in <code>$coef</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
fit &lt;- tqr.fit(y,f0=0.1,tau=tau)
plot(tau,fit$coef[1,],type='o',pch=0.75,xlab='QUANTILE LEVEL',ylab='TQR COEF')
</code></pre>

<hr>
<h2 id='tsqr.fit'>Trigonometric Spline Quantile Regression (TSQR)</h2><span id='topic+tsqr.fit'></span>

<h3>Description</h3>

<p>This function computes trigonometric spline quantile regression (TSQR) for univariate time series at a single frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsqr.fit(y, f0, tau, c0, d = 1, weighted = FALSE, prepared = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsqr.fit_+3A_y">y</code></td>
<td>
<p>vector of time series</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_f0">f0</code></td>
<td>
<p>frequency in [0,1)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_c0">c0</code></td>
<td>
<p>penalty parameter</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_prepared">prepared</code></td>
<td>
<p>if <code>TRUE</code>, intercept is removed and coef of cosine is doubled when <code>f0 = 0.5</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of <code>sqr.fit()</code> (coefficients in <code>$coef</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
fit &lt;- tqr.fit(y,f0=0.1,tau=tau)
fit.sqr &lt;- tsqr.fit(y,f0=0.1,tau=tau,c0=0.02,d=4)
plot(tau,fit$coef[1,],type='p',xlab='QUANTILE LEVEL',ylab='TQR COEF')
lines(tau,fit.sqr$coef[1,],type='l')
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
