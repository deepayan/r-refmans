<!DOCTYPE html><html lang="en"><head><title>Help for package qfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#birthweight'><p>Birthweight data</p></a></li>
<li><a href='#engel'><p>Engel food expenditure data</p></a></li>
<li><a href='#per'><p>Periodogram (PER)</p></a></li>
<li><a href='#qacf'><p>Quantile Autocovariance Function (QACF)</p></a></li>
<li><a href='#qcser'><p>Quantile-Crossing Series (QCSER)</p></a></li>
<li><a href='#qdft'><p>Quantile Discrete Fourier Transform (QDFT)</p></a></li>
<li><a href='#qdft2qacf'><p>Quantile Autocovariance Function (QACF)</p></a></li>
<li><a href='#qdft2qper'><p>Quantile Periodogram (QPER)</p></a></li>
<li><a href='#qdft2qser'><p>Quantile Series (QSER)</p></a></li>
<li><a href='#qfa.plot'><p>Quantile-Frequency Plot</p></a></li>
<li><a href='#qkl.divergence'><p>Kullback-Leibler Divergence of Quantile Spectral Estimate</p></a></li>
<li><a href='#qper'><p>Quantile Periodogram (QPER)</p></a></li>
<li><a href='#qper2'><p>Quantile Periodogram Type II (QPER2)</p></a></li>
<li><a href='#qser'><p>Quantile Series (QSER)</p></a></li>
<li><a href='#qser2ar'><p>Autoregression (AR) Model of Quantile Series</p></a></li>
<li><a href='#qser2qacf'><p>ACF of Quantile Series (QSER) or Quantile-Crossing Series (QCACF)</p></a></li>
<li><a href='#qser2sar'><p>Spline Autoregression (SAR) Model of Quantile Series</p></a></li>
<li><a href='#qspec.ar'><p>Autoregression (AR) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec.lw'><p>Lag-Window (LW) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec.sar'><p>Spline Autoregression (SAR) Estimator of Quantile Spectrum</p></a></li>
<li><a href='#qspec2qcoh'><p>Quantile Coherence Spectrum</p></a></li>
<li><a href='#sar.eq.bootstrap'><p>Bootstrap Simulation of SAR Coefficients for Testing Equality of Granger-Causality in Two Samples</p></a></li>
<li><a href='#sar.eq.test'><p>Wald Test and Confidence Band for Equality of Granger-Causality in Two Samples</p></a></li>
<li><a href='#sar.gc.bootstrap'><p>Bootstrap Simulation of SAR Coefficients for Granger-Causality Analysis</p></a></li>
<li><a href='#sar.gc.coef'><p>Extraction of SAR Coefficients for Granger-Causality Analysis</p></a></li>
<li><a href='#sar.gc.test'><p>Wald Test and Confidence Band for Granger-Causality Analysis</p></a></li>
<li><a href='#sqdft'><p>Spline Quantile Discrete Fourier Transform (SQDFT) of Time Series</p></a></li>
<li><a href='#sqdft.fit'><p>Spline Quantile Discrete Fourier Transform (SQDFT) of Time Series Given Smoothing Parameter</p></a></li>
<li><a href='#sqr'><p>Spline Quantile Regression (SQR) by formula</p></a></li>
<li><a href='#sqr.fit'><p>Spline Quantile Regression (SQR)</p></a></li>
<li><a href='#sqr.fit.optim'><p>Spline Quantile Regression (SQR) by Gradient Algorithms</p></a></li>
<li><a href='#tqr.fit'><p>Trigonometric Quantile Regression (TQR)</p></a></li>
<li><a href='#tsqr.fit'><p>Trigonometric Spline Quantile Regression (TSQR) of Time Series</p></a></li>
<li><a href='#yearssn'><p>Yearly sunspot numbers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantile-Frequency Analysis (QFA) of Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ta-Hsin Li &lt;thl024@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantile-frequency analysis (QFA) of time series based on trigonometric quantile regression. 
 Spline quantile regression (SQR) for regression coefficient estimation.
 References:
    [1] Li, T.-H. (2012) "Quantile periodograms", Journal of the American Statistical
        Association, 107, 765â€“776, &lt;<a href="https://doi.org/10.1080%2F01621459.2012.682815">doi:10.1080/01621459.2012.682815</a>&gt;.
    [2] Li, T.-H. (2014) Time Series with Mixed Spectra, CRC Press, &lt;<a href="https://doi.org/10.1201%2Fb15154">doi:10.1201/b15154</a>&gt;
    [3] Li, T.-H. (2022) "Quantile Fourier transform, quantile series, and nonparametric
        estimation of quantile spectra", &lt;<a href="https://doi.org/10.48550%2FarXiv.2211.05844">doi:10.48550/arXiv.2211.05844</a>&gt;.
    [4] Li, T.-H. (2024) "Quantile crossing spectrum and spline autoregression
         estimation," &lt;<a href="https://doi.org/10.48550%2FarXiv.2412.02513">doi:10.48550/arXiv.2412.02513</a>&gt;.
    [5] Li, T.-H. (2024) "Spline autoregression method for estimation of quantile spectrum",
        &lt;<a href="https://doi.org/10.48550%2FarXiv.2412.17163">doi:10.48550/arXiv.2412.17163</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RhpcBLASctl, doParallel, fields, foreach, mgcv, nlme,
parallel, quantreg, splines, stats, graphics, colorRamps, MASS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/IBM/qfa">https://github.com/IBM/qfa</a>, <a href="https://github.com/thl2019/QFA">https://github.com/thl2019/QFA</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-07 15:22:34 UTC; thl</td>
</tr>
<tr>
<td>Author:</td>
<td>Ta-Hsin Li [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-08 08:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='birthweight'>Birthweight data</h2><span id='topic+birthweight'></span>

<h3>Description</h3>

<p>Infant birth weight data. <code>Precare</code> and <code>Education</code> should be treated as factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(birthweight)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 50000 rows and 12 columns.
</p>


<h3>Source</h3>

<p>natality2022us.csv, &lt;https://www.nber.org/research/data/vital-statistics-natality-birth-data&gt;
</p>


<h3>References</h3>

<p>Koenker, R. (2005). Quantile Regression. Cambridge University Press.
</p>

<hr>
<h2 id='engel'>Engel food expenditure data</h2><span id='topic+engel'></span>

<h3>Description</h3>

<p>The Engel food expenditure data from the R package <code>quantreg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(engel)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 235 rows and 2 columns.
</p>


<h3>References</h3>

<p>Koenker, R. (2005). Quantile Regression. Cambridge University Press.
</p>

<hr>
<h2 id='per'>Periodogram (PER)</h2><span id='topic+per'></span>

<h3>Description</h3>

<p>This function computes the periodogram or periodogram matrix for univariate or multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>per(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="per_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series s (if matrix, nrow(y) = length of time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or array of periodogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y.per &lt;- per(y)
plot(y.per)
</code></pre>

<hr>
<h2 id='qacf'>Quantile Autocovariance Function (QACF)</h2><span id='topic+qacf'></span>

<h3>Description</h3>

<p>This function computes quantile autocovariance function (QACF) from time series 
or quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qacf(y, tau, y.qdft = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qacf_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qacf_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qacf_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of pre-calculated QDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qacf_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qdft = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qacf_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile autocovariance function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
# compute from time series
y.qacf &lt;- qacf(y,tau)
# compute from QDFT 
y.qdft &lt;- qdft(y,tau) 
y.qacf &lt;- qacf(y.qdft=y.qdft)
</code></pre>

<hr>
<h2 id='qcser'>Quantile-Crossing Series (QCSER)</h2><span id='topic+qcser'></span>

<h3>Description</h3>

<p>This function creates the quantile-crossing series (QCSER) for univariate or multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qcser(y, tau, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qcser_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series</p>
</td></tr>
<tr><td><code id="qcser_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qcser_+3A_normalize">normalize</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default): normalize QCSER to have unit variance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or array of quantile-crossing series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qser &lt;- qcser(y,tau)
dim(y.qser)
</code></pre>

<hr>
<h2 id='qdft'>Quantile Discrete Fourier Transform (QDFT)</h2><span id='topic+qdft'></span>

<h3>Description</h3>

<p>This function computes quantile discrete Fourier transform (QDFT) for univariate or multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft(y, tau, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdft_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qdft_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qdft_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qdft_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile discrete Fourier transform of <code>y</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y,tau)
# Make a cluster for repeated use
n.cores &lt;- 2
cl &lt;- parallel::makeCluster(n.cores)
parallel::clusterExport(cl, c("tqr.fit"))
doParallel::registerDoParallel(cl)
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y.qdft &lt;- qdft(y1,tau,n.cores=n.cores,cl=cl)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y.qdft &lt;- qdft(y2,tau,n.cores=n.cores,cl=cl)
parallel::stopCluster(cl)
</code></pre>

<hr>
<h2 id='qdft2qacf'>Quantile Autocovariance Function (QACF)</h2><span id='topic+qdft2qacf'></span>

<h3>Description</h3>

<p>This function computes quantile autocovariance function (QACF) from QDFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft2qacf(y.qdft, return.qser = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdft2qacf_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of QDFT from <code>qdft()</code></p>
</td></tr>
<tr><td><code id="qdft2qacf_+3A_return.qser">return.qser</code></td>
<td>
<p>if <code>TRUE</code>, return quantile series (QSER) along with QACF</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile autocovariance function if <code>return.sqer = FALSE</code> (default), else a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>qacf</code></td>
<td>
<p>matirx or array of quantile autocovariance function</p>
</td></tr>
<tr><td><code>qser</code></td>
<td>
<p>matrix or array of quantile series</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># single time series
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y1,tau)
y.qacf &lt;- qdft2qacf(y.qdft)
plot(c(0:9),y.qacf[c(1:10),1],type='h',xlab="LAG",ylab="QACF")
y.qser &lt;- qdft2qacf(y.qdft,return.qser=TRUE)$qser
plot(y.qser[,1],type='l',xlab="TIME",ylab="QSER")
# multiple time series
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qacf &lt;- qdft2qacf(y.qdft)
plot(c(0:9),y.qacf[1,2,c(1:10),1],type='h',xlab="LAG",ylab="QACF")
</code></pre>

<hr>
<h2 id='qdft2qper'>Quantile Periodogram (QPER)</h2><span id='topic+qdft2qper'></span>

<h3>Description</h3>

<p>This function computes quantile periodogram (QPER) from QDFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft2qper(y.qdft)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdft2qper_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of QDFT from <code>qdft()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile periodogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single time series
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y1,tau)
y.qper &lt;- qdft2qper(y.qdft)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
qfa.plot(ff[sel.f],tau,Re(y.qper[sel.f,]))
# multiple time series
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qper &lt;- qdft2qper(y.qdft)
qfa.plot(ff[sel.f],tau,Re(y.qper[1,1,sel.f,]))
qfa.plot(ff[sel.f],tau,Re(y.qper[1,2,sel.f,]))
</code></pre>

<hr>
<h2 id='qdft2qser'>Quantile Series (QSER)</h2><span id='topic+qdft2qser'></span>

<h3>Description</h3>

<p>This function computes quantile series (QSER) from QDFT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdft2qser(y.qdft)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdft2qser_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of QDFT from <code>qdft()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile series
</p>


<h3>Examples</h3>

<pre><code class='language-R'># single time series
y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qdft &lt;- qdft(y1,tau)
y.qser &lt;- qdft2qser(y.qdft)
plot(y.qser[,1],type='l',xlab="TIME",ylab="QSER")
# multiple time series
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y.qdft &lt;- qdft(cbind(y1,y2),tau)
y.qser &lt;- qdft2qser(y.qdft)
plot(y.qser[1,,1],type='l',xlab="TIME",ylab="QSER")
</code></pre>

<hr>
<h2 id='qfa.plot'>Quantile-Frequency Plot</h2><span id='topic+qfa.plot'></span>

<h3>Description</h3>

<p>This function creates an image plot of quantile spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfa.plot(
  freq,
  tau,
  rqper,
  rg.qper = range(rqper),
  rg.tau = range(tau),
  rg.freq = c(0, 0.5),
  color = colorRamps::matlab.like2(1024),
  ylab = "QUANTILE LEVEL",
  xlab = "FREQUENCY",
  tlab = NULL,
  set.par = TRUE,
  legend.plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qfa.plot_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in (0,0.5) at which quantile spectrum is evaluated</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1) at which quantile spectrum is evaluated</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rqper">rqper</code></td>
<td>
<p>real-valued matrix of quantile spectrum evaluated on the <code>freq</code> x <code>tau</code> grid</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rg.qper">rg.qper</code></td>
<td>
<p><code>zlim</code> for <code>qper</code> (default = <code>range(qper)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rg.tau">rg.tau</code></td>
<td>
<p><code>ylim</code> for <code>tau</code> (default = <code>range(tau)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_rg.freq">rg.freq</code></td>
<td>
<p><code>xlim</code> for <code>freq</code> (default = <code>c(0,0.5)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_color">color</code></td>
<td>
<p>colors (default = <code>colorRamps::matlab.like2(1024)</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_ylab">ylab</code></td>
<td>
<p>label of y-axis (default = <code>"QUANTILE LEVEL"</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_xlab">xlab</code></td>
<td>
<p>label of x-axis (default = <code>"FREQUENCY"</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_tlab">tlab</code></td>
<td>
<p>title of plot (default = <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_set.par">set.par</code></td>
<td>
<p>if <code>TRUE</code>, <code>par()</code> is set internally (single image)</p>
</td></tr>
<tr><td><code id="qfa.plot_+3A_legend.plot">legend.plot</code></td>
<td>
<p>if <code>TRUE</code>, legend plot is added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>no return value
</p>

<hr>
<h2 id='qkl.divergence'>Kullback-Leibler Divergence of Quantile Spectral Estimate</h2><span id='topic+qkl.divergence'></span>

<h3>Description</h3>

<p>This function computes Kullback-Leibler divergence (KLD) of quantile spectral estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qkl.divergence(y.qper, qspec, sel.f = NULL, sel.tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qkl.divergence_+3A_y.qper">y.qper</code></td>
<td>
<p>matrix or array of quantile spectral estimate from, e.g., <code>qspec.lw()</code></p>
</td></tr>
<tr><td><code id="qkl.divergence_+3A_qspec">qspec</code></td>
<td>
<p>matrix of array of true quantile spectrum (same dimension as <code>y.qper</code>)</p>
</td></tr>
<tr><td><code id="qkl.divergence_+3A_sel.f">sel.f</code></td>
<td>
<p>index of selected frequencies for computation (default = <code>NULL</code>: all frequencies)</p>
</td></tr>
<tr><td><code id="qkl.divergence_+3A_sel.tau">sel.tau</code></td>
<td>
<p>index of selected quantile levels for computation (default = <code>NULL</code>: all quantile levels)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>real number of Kullback-Leibler divergence
</p>

<hr>
<h2 id='qper'>Quantile Periodogram (QPER)</h2><span id='topic+qper'></span>

<h3>Description</h3>

<p>This function computes quantile periodogram (QPER) from time series 
or quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qper(y, tau, y.qdft = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qper_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qper_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qper_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of pre-calculated QDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qper_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qdft = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qper_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile periodogram
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
# compute from time series
y.qper &lt;- qper(y,tau)  
# compute from QDFT 
y.qdft &lt;- qdft(y,tau) 
y.qper &lt;- qper(y.qdft=y.qdft)  
</code></pre>

<hr>
<h2 id='qper2'>Quantile Periodogram Type II (QPER2)</h2><span id='topic+qper2'></span>

<h3>Description</h3>

<p>This function computes type-II quantile periodogram for univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qper2(y, freq, tau, weights = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qper2_+3A_y">y</code></td>
<td>
<p>univariate time series</p>
</td></tr>
<tr><td><code id="qper2_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in [0,1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_weights">weights</code></td>
<td>
<p>sequence of weights in quantile regression (default = <code>NULL</code>: weights equal to 1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qper2_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of quantile periodogram evaluated on <code>freq * tau</code> grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qper2 &lt;- qper2(y,ff,tau)
qfa.plot(ff[sel.f],tau,Re(y.qper2[sel.f,]))
</code></pre>

<hr>
<h2 id='qser'>Quantile Series (QSER)</h2><span id='topic+qser'></span>

<h3>Description</h3>

<p>This function computes quantile series (QSER) from time series or quantile discrete Fourier transform (QDFT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qser(y, tau, y.qdft = NULL, n.cores = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qser_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qser_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qser_+3A_y.qdft">y.qdft</code></td>
<td>
<p>matrix or array of pre-calculated QDFT (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qdft</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qser_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qdft = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qser_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix or array of quantile series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
# compute from time series
y.qser &lt;- qser(y,tau)  
# compute from QDFT
y.qdft &lt;- qdft(y,tau)  
y.qser &lt;- qser(y.qdft=y.qdft) 
</code></pre>

<hr>
<h2 id='qser2ar'>Autoregression (AR) Model of Quantile Series</h2><span id='topic+qser2ar'></span>

<h3>Description</h3>

<p>This function fits an autoregression (AR) model to quantile series (QSER) separately for each quantile level using <code>stats::ar()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qser2ar(y.qser, p = NULL, order.max = NULL, method = c("none", "gamm", "sp"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qser2ar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER, e.g., using <code>qser()</code></p>
</td></tr>
<tr><td><code id="qser2ar_+3A_p">p</code></td>
<td>
<p>order of AR model (default = <code>NULL</code>: selected by AIC)</p>
</td></tr>
<tr><td><code id="qser2ar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
<tr><td><code id="qser2ar_+3A_method">method</code></td>
<td>
<p>quantile smoothing method: <code>"gamm"</code>, <code>"sp"</code>, or <code>"NA"</code> (default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>matrix or array of AR coefficients</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>vector or matrix of residual covariance</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>order of AR model</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>matrix or array of residuals</p>
</td></tr>
</table>

<hr>
<h2 id='qser2qacf'>ACF of Quantile Series (QSER) or Quantile-Crossing Series (QCACF)</h2><span id='topic+qser2qacf'></span>

<h3>Description</h3>

<p>This function creates the ACF of quantile series or quantile-crossing series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qser2qacf(y.qser)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qser2qacf_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of quantile-crossing series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or array of ACF
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.qser &lt;- qcser(y,tau)
y.qacf &lt;- qser2qacf(y.qser)
dim(y.qacf)
</code></pre>

<hr>
<h2 id='qser2sar'>Spline Autoregression (SAR) Model of Quantile Series</h2><span id='topic+qser2sar'></span>

<h3>Description</h3>

<p>This function fits spline autoregression (SAR) model to quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qser2sar(
  y.qser,
  tau,
  d = 1,
  p = NULL,
  order.max = NULL,
  spar = NULL,
  method = c("GCV", "AIC", "BIC"),
  weighted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qser2sar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER, e.g., using <code>qser()</code></p>
</td></tr>
<tr><td><code id="qser2sar_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels where <code>y.qser</code> is calculated</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_p">p</code></td>
<td>
<p>order of SAR model (default = <code>NULL</code>: automatically selected by AIC)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_spar">spar</code></td>
<td>
<p>penalty parameter alla <code>smooth.spline</code> (default = <code>NULL</code>: automatically selected)</p>
</td></tr>
<tr><td><code id="qser2sar_+3A_method">method</code></td>
<td>
<p>criterion for penalty parameter selection:  <code>"AIC"</code> (default), <code>"BIC"</code>, or <code>"GCV"</code></p>
</td></tr>
<tr><td><code id="qser2sar_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>matrix or array of SAR coefficients</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>vector or matrix of SAR residual covariance</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>order of SAR model</p>
</td></tr>
<tr><td><code>spar</code></td>
<td>
<p>penalty parameter</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>sequence of quantile levels</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>length of time series</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>subsampling rate of quantile levels</p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>option for weighted penalty function</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object containing details of SAR fit</p>
</td></tr>
</table>

<hr>
<h2 id='qspec.ar'>Autoregression (AR) Estimator of Quantile Spectrum</h2><span id='topic+qspec.ar'></span>

<h3>Description</h3>

<p>This function computes autoregression (AR) estimate of quantile spectrum from time series or quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.ar(
  y,
  tau,
  y.qser = NULL,
  p = NULL,
  order.max = NULL,
  freq = NULL,
  method = c("none", "gamm", "sp"),
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qspec.ar_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_p">p</code></td>
<td>
<p>order of AR model (default = <code>NULL</code>: automatically selected by AIC)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in [0,1) (default = <code>NULL</code>: all Fourier frequencies)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_method">method</code></td>
<td>
<p>quantile smoothing method: <code>"gamm"</code> for <code>mgcv::gamm()</code>, 
<code>"sp"</code> for <code>stats::smooth.spline()</code>, or <code>"none"</code> (default)
if <code>y.qser</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qser = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.ar_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of AR quantile spectrum</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>sequence of frequencies</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object of AR model</p>
</td></tr>
<tr><td><code>qser</code></td>
<td>
<p>matrix or array of quantile series if <code>y.qser = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y &lt;- cbind(y1,y2)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qspec.ar &lt;- qspec.ar(y,tau,p=1)$spec
qfa.plot(ff[sel.f],tau,Re(y.qspec.ar[1,1,sel.f,]))
y.qser &lt;- qcser(y1,tau)
y.qspec.ar &lt;- qspec.ar(y.qser=y.qser,p=1)$spec
qfa.plot(ff[sel.f],tau,Re(y.qspec.ar[sel.f,]))
y.qspec.arqs &lt;- qspec.ar(y.qser=y.qser,p=1,method="sp")$spec
qfa.plot(ff[sel.f],tau,Re(y.qspec.arqs[sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.lw'>Lag-Window (LW) Estimator of Quantile Spectrum</h2><span id='topic+qspec.lw'></span>

<h3>Description</h3>

<p>This function computes lag-window (LW) estimate of quantile spectrum
with or without quantile smoothing from time series or quantile autocovariance function (QACF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.lw(
  y,
  tau,
  y.qacf = NULL,
  M = NULL,
  method = c("none", "gamm", "sp"),
  spar = "GCV",
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qspec.lw_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_y.qacf">y.qacf</code></td>
<td>
<p>matrix or array of pre-calculated QACF (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qacf</code> is supplied, <code>y</code> and <code>tau</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_m">M</code></td>
<td>
<p>bandwidth parameter of lag window (default = <code>NULL</code>: quantile periodogram)</p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_method">method</code></td>
<td>
<p>quantile smoothing method:  <code>"gamm"</code> for <code>mgcv::gamm()</code>, 
<code>"sp"</code> for <code>stats::smooth.spline()</code>, or <code>"none"</code> (default)</p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter in <code>smooth.spline()</code> if <code>method = "sp"</code> (default = <code>"GCV"</code>)</p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.lw_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of spectral estimate</p>
</td></tr>
<tr><td><code>spec.lw</code></td>
<td>
<p>matrix or array of spectral estimate without quantile smoothing</p>
</td></tr>
<tr><td><code>lw</code></td>
<td>
<p>lag-window sequence</p>
</td></tr>
<tr><td><code>qacf</code></td>
<td>
<p>matrix or array of quantile autocovariance function if <code>y.qacf = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qacf &lt;- qacf(cbind(y1,y2),tau)
y.qper.lw &lt;- qspec.lw(y.qacf=y.qacf,M=5)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.lw[1,1,sel.f,]))
y.qper.lwqs &lt;- qspec.lw(y.qacf=y.qacf,M=5,method="sp",spar=0.9)$spec
qfa.plot(ff[sel.f],tau,Re(y.qper.lwqs[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec.sar'>Spline Autoregression (SAR) Estimator of Quantile Spectrum</h2><span id='topic+qspec.sar'></span>

<h3>Description</h3>

<p>This function computes spline autoregression (SAR) estimate of quantile spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec.sar(
  y,
  y.qser = NULL,
  tau,
  d = 1,
  p = NULL,
  order.max = NULL,
  spar = NULL,
  method = c("GCV", "AIC", "BIC"),
  weighted = FALSE,
  freq = NULL,
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qspec.sar_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of pre-calculated QSER (default = <code>NULL</code>: compute from <code>y</code> and <code>tau</code>);
if <code>y.qser</code> is supplied, <code>y</code> can be left unspecified</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_p">p</code></td>
<td>
<p>order of SAR model (default = <code>NULL</code>: automatically selected by AIC)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_order.max">order.max</code></td>
<td>
<p>maximum order for AIC if <code>p = NULL</code> (default = <code>NULL</code>: determined by <code>stats::ar()</code>)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_spar">spar</code></td>
<td>
<p>penalty parameter alla <code>smooth.spline</code> (default = <code>NULL</code>: automatically selected)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_method">method</code></td>
<td>
<p>criterion for penalty parameter selection: <code>"GCV"</code>, <code>"AIC"</code> (default), or <code>"BIC"</code></p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_freq">freq</code></td>
<td>
<p>sequence of frequencies in [0,1) (default = <code>NULL</code>: all Fourier frequencies)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing of QDFT if <code>y.qser = NULL</code> (default = 1)</p>
</td></tr>
<tr><td><code id="qspec.sar_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing of QDFT (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>spec</code></td>
<td>
<p>matrix or array of SAR quantile spectrum</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>sequence of frequencies</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object of SAR model</p>
</td></tr>
<tr><td><code>qser</code></td>
<td>
<p>matrix or array of quantile series if <code>y.qser = NULL</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
# compute from time series
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
qfa.plot(ff[sel.f],tau,Re(y.sar$spec[1,1,sel.f,]))
# compute from quantile series
y.qser &lt;- qser(cbind(y1,y2),tau)
y.sar &lt;- qspec.sar(y.qser=y.qser,tau=tau,p=1)
qfa.plot(ff[sel.f],tau,Re(y.sar$spec[1,1,sel.f,]))
</code></pre>

<hr>
<h2 id='qspec2qcoh'>Quantile Coherence Spectrum</h2><span id='topic+qspec2qcoh'></span>

<h3>Description</h3>

<p>This function computes quantile coherence spectrum (QCOH) from quantile spectrum of multiple time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qspec2qcoh(qspec, k = 1, kk = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qspec2qcoh_+3A_qspec">qspec</code></td>
<td>
<p>array of quantile spectrum</p>
</td></tr>
<tr><td><code id="qspec2qcoh_+3A_k">k</code></td>
<td>
<p>index of first series (default = 1)</p>
</td></tr>
<tr><td><code id="qspec2qcoh_+3A_kk">kk</code></td>
<td>
<p>index of second series (default = 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of quantile coherence evaluated at Fourier frequencies in (0,0.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
n &lt;- length(y1)
ff &lt;- c(0:(n-1))/n
sel.f &lt;- which(ff &gt; 0 &amp; ff &lt; 0.5)
y.qacf &lt;- qacf(cbind(y1,y2),tau)
y.qper.lw &lt;- qspec.lw(y.qacf=y.qacf,M=5)$spec
y.qcoh &lt;- qspec2qcoh(y.qper.lw,k=1,kk=2)
qfa.plot(ff[sel.f],tau,y.qcoh)
</code></pre>

<hr>
<h2 id='sar.eq.bootstrap'>Bootstrap Simulation of SAR Coefficients for Testing Equality of Granger-Causality in Two Samples</h2><span id='topic+sar.eq.bootstrap'></span>

<h3>Description</h3>

<p>This function simulates bootstrap samples of selected spline autoregression (SAR) coefficients 
for testing equality of Granger-causality in two samples based on their SAR models
under H0: effect in each sample equals the average effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.eq.bootstrap(
  y.qser,
  fit,
  fit2,
  index = c(1, 2),
  nsim = 1000,
  method = c("ar", "sar"),
  n.cores = 1,
  mthreads = TRUE,
  seed = 1234567
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar.eq.bootstrap_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of QSER from <code>qser()</code> or <code>qspec.sar()$qser</code></p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_fit">fit</code></td>
<td>
<p>object of SAR model from <code>qser2sar()</code> or <code>qspec.sar()$fit</code></p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_fit2">fit2</code></td>
<td>
<p>object of SAR model for the other sample</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_index">index</code></td>
<td>
<p>a pair of component indices for multiple time series 
or a sequence of lags for single time series (default = <code>c(1,2)</code>)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_nsim">nsim</code></td>
<td>
<p>number of bootstrap samples (default = 1000)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_method">method</code></td>
<td>
<p>method of residual calculation: <code>"ar"</code> (default) or <code>"sar"</code></p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>FALSE</code>, set <code>RhpcBLASctl::blas_set_num_threads(1)</code> (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="sar.eq.bootstrap_+3A_seed">seed</code></td>
<td>
<p>seed for random sampling (default = <code>1234567</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of simulated bootstrap samples of selected SAR coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y11 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y21 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y12 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y22 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y1.sar &lt;- qspec.sar(cbind(y11,y21),tau=tau,p=1)
y2.sar &lt;- qspec.sar(cbind(y12,y22),tau=tau,p=1)
A1.sim &lt;- sar.eq.bootstrap(y1.sar$qser,y1.sar$fit,y2.sar$fit,index=c(1,2),nsim=5)
A2.sim &lt;- sar.eq.bootstrap(y2.sar$qser,y2.sar$fit,y1.sar$fit,index=c(1,2),nsim=5)
</code></pre>

<hr>
<h2 id='sar.eq.test'>Wald Test and Confidence Band for Equality of Granger-Causality in Two Samples</h2><span id='topic+sar.eq.test'></span>

<h3>Description</h3>

<p>This function computes Wald test and confidence band for equality of Granger-causality in two samples
using bootstrap samples generated by <code>sar.eq.bootstrap()</code> based on the spline autoregression (SAR) models
of quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.eq.test(A1, A1.sim, A2, A2.sim, sel.lag = NULL, sel.tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar.eq.test_+3A_a1">A1</code></td>
<td>
<p>matrix of selected SAR coefficients for sample 1</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_a1.sim">A1.sim</code></td>
<td>
<p>simulated bootstrap samples from <code>sar.eq.bootstrap()</code> for sample 1</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_a2">A2</code></td>
<td>
<p>matrix of selected SAR coefficients for sample 2</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_a2.sim">A2.sim</code></td>
<td>
<p>simulated bootstrap samples from <code>sar.eq.bootstrap()</code> for sample 2</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_sel.lag">sel.lag</code></td>
<td>
<p>indices of time lags for Wald test (default = <code>NULL</code>: all lags)</p>
</td></tr>
<tr><td><code id="sar.eq.test_+3A_sel.tau">sel.tau</code></td>
<td>
<p>indices of quantile levels for Wald test (default = <code>NULL</code>: all quantiles)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>list of Wald test result containing <code>wald</code> and <code>p.value</code></p>
</td></tr>
<tr><td><code>D.u</code></td>
<td>
<p>matrix of upper limits of 95% confidence band for <code>A1 - A2</code></p>
</td></tr>
<tr><td><code>D.l</code></td>
<td>
<p>matrix of lower limits of 95% confidence band for <code>A1 - A2</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y11 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y21 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
y12 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y22 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y1.sar &lt;- qspec.sar(cbind(y11,y21),tau=tau,p=1)
y2.sar &lt;- qspec.sar(cbind(y12,y22),tau=tau,p=1)
A1.sim &lt;- sar.eq.bootstrap(y1.sar$qser,y1.sar$fit,y2.sar$fit,index=c(1,2),nsim=5)
A2.sim &lt;- sar.eq.bootstrap(y2.sar$qser,y2.sar$fit,y1.sar$fit,index=c(1,2),nsim=5)
A1 &lt;- sar.gc.coef(y1.sar$fit,index=c(1,2))
A2 &lt;- sar.gc.coef(y2.sar$fit,index=c(1,2))
test &lt;- sar.eq.test(A1,A1.sim,A2,A2.sim,sel.lag=NULL,sel.tau=NULL)
</code></pre>

<hr>
<h2 id='sar.gc.bootstrap'>Bootstrap Simulation of SAR Coefficients for Granger-Causality Analysis</h2><span id='topic+sar.gc.bootstrap'></span>

<h3>Description</h3>

<p>This function simulates bootstrap samples of selected spline autoregression (SAR) coefficients 
for Granger-causality analysis based on the SAR model of quantile series (QSER) under H0: 
(a) for multiple time series, the second series specified in <code>index</code> is not causal 
for the first series specified in <code>index</code>;
(b) for single time series, the series is not causal at the lags specified in <code>index</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.gc.bootstrap(
  y.qser,
  fit,
  index = c(1, 2),
  nsim = 1000,
  method = c("ar", "sar"),
  n.cores = 1,
  mthreads = TRUE,
  seed = 1234567
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar.gc.bootstrap_+3A_y.qser">y.qser</code></td>
<td>
<p>matrix or array of QSER from <code>qser()</code> or <code>qspec.sar()$qser</code></p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_fit">fit</code></td>
<td>
<p>object of SAR model from <code>qser2sar()</code> or <code>qspec.sar()$fit</code></p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_index">index</code></td>
<td>
<p>a pair of component indices for multiple time series 
or a sequence of lags for single time series (default = <code>c(1,2)</code>)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_nsim">nsim</code></td>
<td>
<p>number of bootstrap samples (default = 1000)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_method">method</code></td>
<td>
<p>method of residual calculation: <code>"ar"</code> (default) or <code>"sar"</code></p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>FALSE</code>, set <code>RhpcBLASctl::blas_set_num_threads(1)</code> (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="sar.gc.bootstrap_+3A_seed">seed</code></td>
<td>
<p>seed for random sampling (default = <code>1234567</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of simulated bootstrap samples of selected SAR coefficients
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
A.sim &lt;- sar.gc.bootstrap(y.sar$qser,y.sar$fit,index=c(1,2),nsim=5)
</code></pre>

<hr>
<h2 id='sar.gc.coef'>Extraction of SAR Coefficients for Granger-Causality Analysis</h2><span id='topic+sar.gc.coef'></span>

<h3>Description</h3>

<p>This function extracts the spline autoregression (SAR) coefficients from an SAR model for Granger-causality analysis.
See <code>sar.gc.bootstrap</code> for more details regarding the use of <code>index</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.gc.coef(fit, index = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar.gc.coef_+3A_fit">fit</code></td>
<td>
<p>object of SAR model from <code>qser2sar()</code> or <code>qspec.sar()$fit</code></p>
</td></tr>
<tr><td><code id="sar.gc.coef_+3A_index">index</code></td>
<td>
<p>a pair of component indices for multiple time series 
or a sequence of lags for single time series (default = <code>c(1,2)</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of selected SAR coefficients (number of lags by number of quantiles)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
A &lt;- sar.gc.coef(y.sar$fit,index=c(1,2))
</code></pre>

<hr>
<h2 id='sar.gc.test'>Wald Test and Confidence Band for Granger-Causality Analysis</h2><span id='topic+sar.gc.test'></span>

<h3>Description</h3>

<p>This function computes Wald test and confidence band for Granger-causality 
using bootstrap samples generated by <code>sar.gc.bootstrap()</code> 
based the spline autoregression (SAR) model of quantile series (QSER).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar.gc.test(A, A.sim, sel.lag = NULL, sel.tau = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sar.gc.test_+3A_a">A</code></td>
<td>
<p>matrix of selected SAR coefficients</p>
</td></tr>
<tr><td><code id="sar.gc.test_+3A_a.sim">A.sim</code></td>
<td>
<p>simulated bootstrap samples from <code>sar.gc.bootstrap()</code></p>
</td></tr>
<tr><td><code id="sar.gc.test_+3A_sel.lag">sel.lag</code></td>
<td>
<p>indices of time lags for Wald test (default = <code>NULL</code>: all lags)</p>
</td></tr>
<tr><td><code id="sar.gc.test_+3A_sel.tau">sel.tau</code></td>
<td>
<p>indices of quantile levels for Wald test (default = <code>NULL</code>: all quantiles)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>test</code></td>
<td>
<p>list of Wald test result containing <code>wald</code> and <code>p.value</code></p>
</td></tr>
<tr><td><code>A.u</code></td>
<td>
<p>matrix of upper limits of 95% confidence band of <code>A</code></p>
</td></tr>
<tr><td><code>A.l</code></td>
<td>
<p>matrix of lower limits of 95% confidence band of <code>A</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y1 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
y2 &lt;- stats::arima.sim(list(order=c(1,0,0), ar=-0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sar &lt;- qspec.sar(cbind(y1,y2),tau=tau,p=1)
A &lt;- sar.gc.coef(y.sar$fit,index=c(1,2))
A.sim &lt;- sar.gc.bootstrap(y.sar$qser,y.sar$fit,index=c(1,2),nsim=5)
y.gc &lt;- sar.gc.test(A,A.sim)
</code></pre>

<hr>
<h2 id='sqdft'>Spline Quantile Discrete Fourier Transform (SQDFT) of Time Series</h2><span id='topic+sqdft'></span>

<h3>Description</h3>

<p>This function computes spline quantile discrete Fourier transform (SQDFT) for univariate or multivariate time series
through trigonometric spline quantile regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqdft(
  y,
  tau,
  spar = NULL,
  d = 1,
  weighted = FALSE,
  method = c("AIC", "BIC", "SIC"),
  ztol = 1e-05,
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqdft_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter: if <code>spar=NULL</code>, smoothing parameter is selected by <code>method</code></p>
</td></tr>
<tr><td><code id="sqdft_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_method">method</code></td>
<td>
<p>crietrion for smoothing parameter selection when <code>spar=NULL</code> (<code>"AIC"</code>, <code>"BIC"</code>, or <code>"SIC"</code>)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_ztol">ztol</code></td>
<td>
<p>zero tolerance parameter used to determine the effective dimensionality of the fit</p>
</td></tr>
<tr><td><code id="sqdft_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="sqdft_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>matrix of regression coefficients</p>
</td></tr>
<tr><td><code>qdft</code></td>
<td>
<p>matrix or array of the spline quantile discrete Fourier transform of <code>y</code></p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>criteria for smoothing parameter selection: (AIC,BIC,SIC)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sqdft &lt;- sqdft(y,tau,spar=NULL,d=4,metho="AIC")$qdft
</code></pre>

<hr>
<h2 id='sqdft.fit'>Spline Quantile Discrete Fourier Transform (SQDFT) of Time Series Given Smoothing Parameter</h2><span id='topic+sqdft.fit'></span>

<h3>Description</h3>

<p>This function computes spline quantile discrete Fourier transform (SQDFT) for univariate or multivariate time series
through trigonometric spline quantile regression with user-supplied spar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqdft.fit(
  y,
  tau,
  spar = 1,
  d = 1,
  weighted = FALSE,
  ztol = 1e-05,
  n.cores = 1,
  cl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqdft.fit_+3A_y">y</code></td>
<td>
<p>vector or matrix of time series (if matrix, <code>nrow(y)</code> = length of time series)</p>
</td></tr>
<tr><td><code id="sqdft.fit_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="sqdft.fit_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter</p>
</td></tr>
<tr><td><code id="sqdft.fit_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="sqdft.fit_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sqdft.fit_+3A_ztol">ztol</code></td>
<td>
<p>zero tolerance parameter used to determine the effective dimensionality of the fit</p>
</td></tr>
<tr><td><code id="sqdft.fit_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores for parallel computing (default = 1)</p>
</td></tr>
<tr><td><code id="sqdft.fit_+3A_cl">cl</code></td>
<td>
<p>pre-existing cluster for repeated parallel computing (default = <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>matrix of regression coefficients</p>
</td></tr>
<tr><td><code>qdft</code></td>
<td>
<p>matrix or array of the spline quantile discrete Fourier transform of <code>y</code></p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>criteria for smoothing parameter selection: (AIC,BIC,SIC)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
y.sqdft &lt;- sqdft.fit(y,tau,spar=1,d=4)$qdft
</code></pre>

<hr>
<h2 id='sqr'>Spline Quantile Regression (SQR) by formula</h2><span id='topic+sqr'></span>

<h3>Description</h3>

<p>This function computes spline quantile regression (SQR) solution from response vector and design matrix.
It uses the FORTRAN code <code>rqfnb.f</code> in the &quot;quantreg&quot; package with the kind permission of Dr. R. Koenker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqr(
  formula,
  tau = seq(0.1, 0.9, 0.2),
  spar = NULL,
  d = 1,
  data,
  subset,
  na.action,
  model = TRUE,
  weighted = FALSE,
  mthreads = TRUE,
  method = c("AIC", "BIC", "SIC"),
  ztol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqr_+3A_formula">formula</code></td>
<td>
<p>a formula object, with the response on the left of a ~ operator, and the terms, separated by + operators, on the right.</p>
</td></tr>
<tr><td><code id="sqr_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="sqr_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter: if <code>spar=NULL</code>, smoothing parameter is selected by <code>method</code></p>
</td></tr>
<tr><td><code id="sqr_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="sqr_+3A_data">data</code></td>
<td>
<p>a data.frame in which to interpret the variables named in the formula</p>
</td></tr>
<tr><td><code id="sqr_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used</p>
</td></tr>
<tr><td><code id="sqr_+3A_na.action">na.action</code></td>
<td>
<p>a function to filter missing data (see <code>rq</code> in the 'quantreg' package)</p>
</td></tr>
<tr><td><code id="sqr_+3A_model">model</code></td>
<td>
<p>if <code>TRUE</code> then the model frame is returned (needed for calling <code>summary</code> subsequently)</p>
</td></tr>
<tr><td><code id="sqr_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sqr_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>FALSE</code>, set <code>RhpcBLASctl::blas_set_num_threads(1)</code> (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="sqr_+3A_method">method</code></td>
<td>
<p>a criterion for smoothing parameter selection if <code>spar=NULL</code> (<code>"AIC"</code>, <code>"BIC"</code>, or <code>"SIC"</code>)</p>
</td></tr>
<tr><td><code id="sqr_+3A_ztol">ztol</code></td>
<td>
<p>a zero tolerance parameter used to determine the effective dimensionality of the fit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of SQR fit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(quantreg)
data(engel)
engel$income &lt;- engel$income - mean(engel$income)
tau &lt;- seq(0.1,0.9,0.05)
fit &lt;- rq(foodexp ~ income,tau=tau,data=engel)
fit.sqr &lt;- sqr(foodexp ~ income,tau=tau,spar=0.5,data=engel)
par(mfrow=c(1,1),pty="m",lab=c(10,10,2),mar=c(4,4,2,1)+0.1,las=1)
plot(tau,fit$coef[2,],xlab="Quantile Level",ylab="Coeff1")
lines(tau,fit.sqr$coef[2,])
</code></pre>

<hr>
<h2 id='sqr.fit'>Spline Quantile Regression (SQR)</h2><span id='topic+sqr.fit'></span>

<h3>Description</h3>

<p>This function computes spline quantile regression (SQR) solution from response vector and design matrix.
It uses the FORTRAN code <code>rqfnb.f</code> in the &quot;quantreg&quot; package with the kind permission of Dr. R. Koenker.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqr.fit(
  X,
  y,
  tau,
  spar = 1,
  d = 1,
  weighted = FALSE,
  mthreads = TRUE,
  ztol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqr.fit_+3A_x">X</code></td>
<td>
<p>design matrix (<code>nrow(X) = length(y)</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_y">y</code></td>
<td>
<p>response vector</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>FALSE</code>, set <code>RhpcBLASctl::blas_set_num_threads(1)</code> (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit_+3A_ztol">ztol</code></td>
<td>
<p>zero tolerance parameter used to determine the effective dimensionality of the fit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>matrix of regression coefficients</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>sequence critera for smoothing parameter select: (AIC,BIC,SIC)</p>
</td></tr>
<tr><td><code>np</code></td>
<td>
<p>sequence of number of effective parameters</p>
</td></tr>
<tr><td><code>fid</code></td>
<td>
<p>sequence of fidelity measure as quasi-likelihood</p>
</td></tr>
<tr><td><code>nit</code></td>
<td>
<p>number of iterations</p>
</td></tr>
</table>

<hr>
<h2 id='sqr.fit.optim'>Spline Quantile Regression (SQR) by Gradient Algorithms</h2><span id='topic+sqr.fit.optim'></span>

<h3>Description</h3>

<p>This function computes spline quantile regression by a gradient algorithm BFGS, ADAM, or GRAD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqr.fit.optim(
  X,
  y,
  tau,
  spar = 0,
  d = 1,
  weighted = FALSE,
  method = c("BFGS", "ADAM", "GRAD"),
  beta.rq = NULL,
  theta0 = NULL,
  spar0 = NULL,
  sg.rate = c(1, 1),
  mthreads = TRUE,
  control = list(trace = 0)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqr.fit.optim_+3A_x">X</code></td>
<td>
<p>vecor or matrix of explanatory variables (including intercept)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_y">y</code></td>
<td>
<p>vector of dependent variable</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_method">method</code></td>
<td>
<p>optimization method: <code>"BFGS"</code> (default), <code>"ADAM"</code>, or <code>"GRAD"</code></p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_beta.rq">beta.rq</code></td>
<td>
<p>matrix of regression coefficients from <code>quantreg::rq(y~X)</code> for initialization (default = <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_theta0">theta0</code></td>
<td>
<p>initial value of spline coefficients (default = <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_spar0">spar0</code></td>
<td>
<p>smoothing parameter for <code>stats::smooth.spline()</code> to smooth <code>beta.rq</code> for initilaiztion (default = <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_sg.rate">sg.rate</code></td>
<td>
<p>vector of sampling rates for quantiles and observations in stochastic gradient version of GRAD and ADAM</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>FALSE</code>, set <code>RhpcBLASctl::blas_set_num_threads(1)</code> (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="sqr.fit.optim_+3A_control">control</code></td>
<td>
<p>a list of control parameters
</p>

<dl>
<dt><code>maxit</code>:</dt><dd><p>max number of iterations (default = 100)</p>
</dd>
<dt><code>stepsize</code>:</dt><dd><p>stepsize for ADAM and GRAD (default = 0.01)</p>
</dd>
<dt><code>warmup</code>:</dt><dd><p>length of warmup phase for ADAM and GRAD (default = 70)</p>
</dd>
<dt><code>stepupdate</code>:</dt><dd><p>frequency of update for ADAM and GRAD (default = 20)</p>
</dd>
<dt><code>stepredn</code>:</dt><dd><p>stepsize discount factor for ADAM and GRAD (default = 0.2)</p>
</dd>
<dt><code>line.search.type</code>:</dt><dd><p>line search option (1,2,3,4) for GRAD (default = 1)</p>
</dd>
<dt><code>line.search.max</code>:</dt><dd><p>max number of line search trials for GRAD (default = 1)</p>
</dd>
<dt><code>seed</code>:</dt><dd><p>seed for stochastic version of ADAM and GRAD (default = 1000)</p>
</dd>
<dt><code>trace</code>:</dt><dd><p>-1 return results from all iterations, 0 (default) return final result</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>matrix of regression coefficients</p>
</td></tr>
<tr><td><code>all.beta</code></td>
<td>
<p>coefficients from all iterations for GRAD and ADAM</p>
</td></tr>
<tr><td><code>spars</code></td>
<td>
<p>smoothing parameters from <code>stats::smooth.spline()</code> for initialization</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>object from the optimization algorithm</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(engel)
y &lt;- engel$foodexp
X &lt;- cbind(rep(1,length(y)),engel$income-mean(engel$income))
tau &lt;- seq(0.1,0.9,0.05)
fit.rq &lt;- quantreg::rq(y ~ X[,2],tau)
fit.sqr &lt;- sqr(y ~ X[,2],tau,d=2,spar=0.2)
fit &lt;- sqr.fit.optim(X,y,tau,spar=0.2,d=2,method="BFSG",beta.rq=fit.rq$coef)
fit &lt;- sqr.fit.optim(X,y,tau,spar=0.2,d=2,method="BFSG",beta.rq=fit.rq$coef)
par(mfrow=c(1,2),pty="m",lab=c(10,10,2),mar=c(4,4,2,1)+0.1,las=1)
for(j in c(1:2)) {
  plot(tau,fit.rq$coef[j,],type="n",xlab="QUANTILE LEVEL",ylab=paste0("COEFF",j))
  points(tau,fit.rq$coef[j,],pch=1,cex=0.5)
  lines(tau,fit.sqr$coef[j,],lty=1); lines(tau,fit$beta[j,],lty=2,col=2)
}
</code></pre>

<hr>
<h2 id='tqr.fit'>Trigonometric Quantile Regression (TQR)</h2><span id='topic+tqr.fit'></span>

<h3>Description</h3>

<p>This function computes trigonometric quantile regression (TQR) for univariate time series at a single frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tqr.fit(y, f0, tau, prepared = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tqr.fit_+3A_y">y</code></td>
<td>
<p>vector of time series</p>
</td></tr>
<tr><td><code id="tqr.fit_+3A_f0">f0</code></td>
<td>
<p>frequency in [0,1)</p>
</td></tr>
<tr><td><code id="tqr.fit_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="tqr.fit_+3A_prepared">prepared</code></td>
<td>
<p>if <code>TRUE</code>, intercept is removed and coef of cosine is doubled when <code>f0 = 0.5</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of <code>rq()</code> (coefficients in <code>$coef</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
fit &lt;- tqr.fit(y,f0=0.1,tau=tau)
plot(tau,fit$coef[1,],type='o',pch=0.75,xlab='QUANTILE LEVEL',ylab='TQR COEF')
</code></pre>

<hr>
<h2 id='tsqr.fit'>Trigonometric Spline Quantile Regression (TSQR) of Time Series</h2><span id='topic+tsqr.fit'></span>

<h3>Description</h3>

<p>This function computes trigonometric spline quantile regression (TSQR) for univariate time series at a single frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsqr.fit(
  y,
  f0,
  tau,
  spar = 1,
  d = 1,
  weighted = FALSE,
  mthreads = TRUE,
  prepared = TRUE,
  ztol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsqr.fit_+3A_y">y</code></td>
<td>
<p>time series</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_f0">f0</code></td>
<td>
<p>frequency in [0,1)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_tau">tau</code></td>
<td>
<p>sequence of quantile levels in (0,1)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_d">d</code></td>
<td>
<p>subsampling rate of quantile levels (default = 1)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_weighted">weighted</code></td>
<td>
<p>if <code>TRUE</code>, penalty function is weighted (default = <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_mthreads">mthreads</code></td>
<td>
<p>if <code>FALSE</code>, set <code>RhpcBLASctl::blas_set_num_threads(1)</code> (default = <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_prepared">prepared</code></td>
<td>
<p>if <code>TRUE</code>, intercept is removed and coef of cosine is doubled when <code>f0 = 0.5</code></p>
</td></tr>
<tr><td><code id="tsqr.fit_+3A_ztol">ztol</code></td>
<td>
<p>zero tolerance parameter used to determine the effective dimensionality of the fit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of <code>sqr.fit()</code> (coefficients in <code>$coef</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- stats::arima.sim(list(order=c(1,0,0), ar=0.5), n=64)
tau &lt;- seq(0.1,0.9,0.05)
fit &lt;- tqr.fit(y,f0=0.1,tau=tau)
fit.sqr &lt;- tsqr.fit(y,f0=0.1,tau=tau,spar=1,d=4)
plot(tau,fit$coef[1,],type='p',xlab='QUANTILE LEVEL',ylab='TQR COEF')
lines(tau,fit.sqr$coef[1,],type='l')
</code></pre>

<hr>
<h2 id='yearssn'>Yearly sunspot numbers</h2><span id='topic+yearssn'></span>

<h3>Description</h3>

<p>Sunspot numbers from 1700 to 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(yearssn)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 308 rows and 2 columns.
</p>


<h3>References</h3>

<p>Li, T.-H. (2014). Time Series with Mixed Spectra. CRC Press.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
