<!DOCTYPE html><html><head><title>Help for package subrank</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {subrank}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#corc'>
<p>Function to estimate copula using ranks and sub-sampling</p></a></li>
<li><a href='#corc0'>
<p>Function to estimate copula using ranks and sub-sampling, minimal version.</p></a></li>
<li><a href='#desscop'>
<p>Discrete copula graph, a two-dimensional projection</p></a></li>
<li><a href='#desscoptous'>
<p>Discrete copula graph, ALL two-dimensional projections</p></a></li>
<li><a href='#estimdep'>
<p>Dependence estimation</p></a></li>
<li><a href='#predictdep'>
<p>Probability forecasting</p></a></li>
<li><a href='#predonfly'>
<p>Probability forecasting</p></a></li>
<li><a href='#simany'>
<p>Test statistic distribution under any hypothesis</p></a></li>
<li><a href='#simnul'>
<p>Test statistic distribution under independence hypothesis</p></a></li>
<li><a href='#subrank-package'>
<p>Computes Copula using Ranks and Subsampling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Computes Copula using Ranks and Subsampling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.9.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Jerome Collet</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jerome Collet &lt;jeromepcollet@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of copula using ranks and subsampling. The main feature of this method is that simulation studies show a low sensitivity to dimension, on realistic cases.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-05 13:54:30 UTC; Jerome</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-05 17:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='corc'>
Function to estimate copula using ranks and sub-sampling
</h2><span id='topic+corc'></span>

<h3>Description</h3>

<p>Takes a sample, its dimension, a sub-sample size, and returns a discrete copula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corc(dataframe, varnames, subsampsize, nbsafe=5,mixties=FALSE,nthreads=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corc_+3A_dataframe">dataframe</code></td>
<td>

<p>a data frame, containing the observations
</p>
</td></tr>
<tr><td><code id="corc_+3A_varnames">varnames</code></td>
<td>

<p>the name of the variables we want to estimate the dependence between
</p>
</td></tr>
<tr><td><code id="corc_+3A_subsampsize">subsampsize</code></td>
<td>

<p>the sub-sample size
</p>
</td></tr>
<tr><td><code id="corc_+3A_nbsafe">nbsafe</code></td>
<td>

<p>the ratio between the number of sub-samples and the cardinality of the discretized copula.
</p>
</td></tr>
<tr><td><code id="corc_+3A_mixties">mixties</code></td>
<td>

<p>if <code>TRUE</code>, put equal weight on tied values, using random permutations 
</p>
</td></tr>
<tr><td><code id="corc_+3A_nthreads">nthreads</code></td>
<td>

<p>number of number of threads, assumed to be strictly positive. For &quot;full throttle&quot; computations, consider using parallel::detectCores()</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cop</code></td>
<td>
<p>an array representing the discretized copula</p>
</td></tr>
<tr><td><code>ties</code></td>
<td>
<p>the number of sub-samples with a tie</p>
</td></tr>
<tr><td><code>nsubsampreal</code></td>
<td>
<p>the effective number of sub-samples drawn</p>
</td></tr>
<tr><td><code>varnames</code></td>
<td>
<p>the name of the variables studied</p>
</td></tr>
<tr><td><code>nnm</code></td>
<td>
<p>the number of observations without missing values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon &lt;- 30
a &lt;- 2
x &lt;- rnorm(lon)
y = a*x^2+rnorm(lon)
datatable = as.data.frame(cbind(x,y))
c=corc(datatable,c("x","y"),8)
c
sum(c$cop)
</code></pre>

<hr>
<h2 id='corc0'>
Function to estimate copula using ranks and sub-sampling, minimal version.
</h2><span id='topic+corc0'></span>

<h3>Description</h3>

<p>Minimal version of function corc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corc0(datavector,sampsize,dimension,subsampsize,nboot,u,mixties=FALSE,nthreads=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corc0_+3A_datavector">datavector</code></td>
<td>

<p>a vector, containing the observations
</p>
</td></tr>
<tr><td><code id="corc0_+3A_sampsize">sampsize</code></td>
<td>

<p>the sample size
</p>
</td></tr>
<tr><td><code id="corc0_+3A_dimension">dimension</code></td>
<td>

<p>the sample dimension
</p>
</td></tr>
<tr><td><code id="corc0_+3A_subsampsize">subsampsize</code></td>
<td>

<p>the sub-sample size
</p>
</td></tr>
<tr><td><code id="corc0_+3A_nboot">nboot</code></td>
<td>

<p>the number of sub-samples (must be big)
</p>
</td></tr>
<tr><td><code id="corc0_+3A_u">u</code></td>
<td>

<p>a random seed, integer
</p>
</td></tr>
<tr><td><code id="corc0_+3A_mixties">mixties</code></td>
<td>

<p>if <code>TRUE</code>, put equal weight on tied values, using random permutations 
</p>
</td></tr>
<tr><td><code id="corc0_+3A_nthreads">nthreads</code></td>
<td>

<p>number of number of threads, assumed to be strictly positive. For &quot;full throttle&quot; computations, consider using parallel::detectCores()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the number of hits for each vector of ranks, plus 2 last values of the vector : number of ties and number of sub-samples really used.
</p>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon &lt;- 30
a &lt;- 2.85
x &lt;- rnorm(lon)
y = a*x^2+rnorm(lon)
c=corc0(c(x,y),lon,2,8,1e5,75014)
c

c0=c(
1203, 1671, 1766, 959, 1586, 1715, 1803, 1205, 1260,1988, 2348, 1917, 3506, 2045, 1340,
1093, 2694, 2757,2233, 1085, 2322, 1793, 1569, 1263, 1709, 1747, 1512,1308, 1778, 1354,
1184, 1097, 2487, 2730, 2112, 1100,2435, 2033, 1572, 1093, 1369, 1722, 1462, 1015, 1228,
1419, 1776, 1852, 1009, 1097, 1179, 1323, 1595, 1316,1477, 2628, 889, 1178, 1981, 4000, 
35, 840, 2091, 4467,0, 27405)
set.seed(75013)
lon=30
dimension=3
sssize=4
c0==corc0(rnorm(lon*dimension),lon,dimension,sssize,1e5,75014)
</code></pre>

<hr>
<h2 id='desscop'>
Discrete copula graph, a two-dimensional projection
</h2><span id='topic+desscop'></span>

<h3>Description</h3>

<p>Draws a discrete joint probability, for 2 variables, using bubbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desscop(copest, xname, yname, normalize = FALSE, axes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desscop_+3A_copest">copest</code></td>
<td>

<p>the estimated copula (the whole structure resulting from <code><a href="#topic+corc">corc</a></code>)
</p>
</td></tr>
<tr><td><code id="desscop_+3A_xname">xname</code></td>
<td>

<p>the name of the variable we want to put on the horizontal axis
</p>
</td></tr>
<tr><td><code id="desscop_+3A_yname">yname</code></td>
<td>

<p>the name of the variable we want to put on the vertical axis
</p>
</td></tr>
<tr><td><code id="desscop_+3A_normalize">normalize</code></td>
<td>

<p>if TRUE, the smallest probability is rescaled to 0, and the largest to 1
</p>
</td></tr>
<tr><td><code id="desscop_+3A_axes">axes</code></td>
<td>

<p>if TRUE, puts the name of the variables on the axes
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon &lt;- 31
a &lt;- 2.85
x &lt;- rnorm(lon)
y = a*x^2+rnorm(lon)
tablo = as.data.frame(cbind(x,y))
c=corc(tablo,c("x","y"),8)
desscop(c,"x","y")

tablo = as.data.frame(cbind(x=rep(0,each=lon),y=rep(0,each=lon)))
c=corc(tablo,c("x","y"),8,mixties=TRUE)
desscop(c,"x","y")

</code></pre>

<hr>
<h2 id='desscoptous'>
Discrete copula graph, ALL two-dimensional projections
</h2><span id='topic+desscoptous'></span>

<h3>Description</h3>

<p>Draws a discrete joint probability, for 2 variables, using bubbles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desscoptous(copest, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desscoptous_+3A_copest">copest</code></td>
<td>

<p>the estimated copula (the whole structure resulting from <code><a href="#topic+corc">corc</a></code>)
</p>
</td></tr>
<tr><td><code id="desscoptous_+3A_normalize">normalize</code></td>
<td>

<p>if TRUE, the smallest probability is rescaled to 0, and the largest to 1
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon &lt;- 31
a &lt;- 2.85
x &lt;- rnorm(lon)
y = a*x^2+rnorm(lon)
z = rnorm(lon)
tablo = as.data.frame(cbind(x,y,z))
c=corc(tablo,c("x","y","z"),8)
desscoptous(c)
</code></pre>

<hr>
<h2 id='estimdep'>
Dependence estimation
</h2><span id='topic+estimdep'></span>

<h3>Description</h3>

<p>From a set of observations, builds a description of the multivariate distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimdep(dataframe,varnames,subsampsize,nbsafe=5,mixties=FALSE,nthreads=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimdep_+3A_dataframe">dataframe</code></td>
<td>

<p>a data frame containing the observations
</p>
</td></tr>
<tr><td><code id="estimdep_+3A_varnames">varnames</code></td>
<td>

<p>the name of the variables we want to estimate the multivariate distribution
</p>
</td></tr>
<tr><td><code id="estimdep_+3A_subsampsize">subsampsize</code></td>
<td>

<p>the sub-sample size
</p>
</td></tr>
<tr><td><code id="estimdep_+3A_nbsafe">nbsafe</code></td>
<td>

<p>the ratio between the discretized copula size and the number of sub-samples
</p>
</td></tr>
<tr><td><code id="estimdep_+3A_mixties">mixties</code></td>
<td>

<p>if <code>TRUE</code>, put equal weight on tied values, using random permutations 
</p>
</td></tr>
<tr><td><code id="estimdep_+3A_nthreads">nthreads</code></td>
<td>

<p>number of number of threads, assumed to be strictly positive. For &quot;full throttle&quot; computations, consider using parallel::detectCores()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the description of the dependence, it is an object with the following parts:
</p>
<table>
<tr><td><code>cop</code></td>
<td>
<p>the array representing the discretized copula</p>
</td></tr>
<tr><td><code>margins</code></td>
<td>
<p>the matrix representing the margins, estimated using kernel density estimation</p>
</td></tr>
<tr><td><code>varnames</code></td>
<td>
<p>the names of the variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon=3000
plon=3000
subsampsize=20

##############
x=(runif(lon)-1/2)*3
y=x^2+rnorm(lon)
z=rnorm(lon)
donori=as.data.frame(cbind(x,y,z))
depori=estimdep(donori,c("x","y","z"),subsampsize)

knownvalues=data.frame(z=rnorm(plon))
prev &lt;- predictdep(knownvalues,depori)
plot(prev$x,prev$y,xlim=c(-2,2),ylim=c(-2,5),pch=20,cex=0.5)
points(donori[,1:2],col='red',pch=20,cex=.5)

knownvalues=data.frame(x=(runif(lon)-1/2)*3)
prev &lt;- predictdep(knownvalues,depori)
plot(prev$x,prev$y,xlim=c(-2,2),ylim=c(-2,5),pch=20,cex=0.5)
points(donori[,1:2],col='red',pch=20,cex=.5)

knownvalues=data.frame(y=runif(plon,min=-2,max=4))
prev &lt;- predictdep(knownvalues,depori)
plot(prev$x,prev$y,xlim=c(-2,2),ylim=c(-2,5),pch=20,cex=0.5)
points(donori[,1:2],col='red',pch=20,cex=.5)
</code></pre>

<hr>
<h2 id='predictdep'>
Probability forecasting
</h2><span id='topic+predictdep'></span>

<h3>Description</h3>

<p>From a set of incomplete observations, and a description of the dependence, provides simulated values of the unknown coordinates. It is also possible to simulate unconditionally, with empty observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictdep(knownvalues,dependence,smoothing=c("Uniform","Beta"),nthreads=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictdep_+3A_knownvalues">knownvalues</code></td>
<td>

<p>in case of conditional simulation, a matrix containing incomplete observations, the known coordinates being the same for all observations. If no variable name in <code>knwonvalues</code> appears in <code>dependence$varnames</code>, then the simulation is unconditional.
</p>
</td></tr>
<tr><td><code id="predictdep_+3A_dependence">dependence</code></td>
<td>

<p>the description of the dependence we want to use to forecast, as built by function <code><a href="#topic+estimdep">estimdep</a></code>
</p>
</td></tr>
<tr><td><code id="predictdep_+3A_smoothing">smoothing</code></td>
<td>

<p>the smoothing method for input and output ranks.
</p>
</td></tr>
<tr><td><code id="predictdep_+3A_nthreads">nthreads</code></td>
<td>

<p>number of number of threads, assumed to be strictly positive. For &quot;full throttle&quot; computations, consider using parallel::detectCores()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix of the completed observations
</p>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon=100
plon=100
subsampsize=10

shift=0
noise=0
knowndims=1

x=rnorm(lon)
y=2*x+noise*rnorm(lon)
donori=as.data.frame(cbind(x,y))
depori=estimdep(donori,c("x","y"),subsampsize)
##
knownvalues=data.frame(x=rnorm(plon)+shift)
prev &lt;- predictdep(knownvalues,depori)
##
plot(prev$x,prev$y,xlim=c(-2,2),ylim=c(-2,5),pch=20,cex=0.5)
points(donori[,1:2],col='red',pch=20,cex=.5)
##
knownvalues=data.frame(x=rnorm(plon)+shift)
prev &lt;- predictdep(knownvalues,depori,smoothing="Beta")
##
plot(prev$x,prev$y,xlim=c(-2,2),ylim=c(-2,5),pch=20,cex=0.5)
points(donori[,1:2],col='red',pch=20,cex=.5)

# souci normal si |shift|&gt;&gt;1

knownvalues=data.frame(z=rnorm(plon)+shift)
prev &lt;- predictdep(knownvalues,depori)
##
plot(prev$x,prev$y,xlim=c(-2,2),ylim=c(-2,5),pch=20,cex=0.5)
points(donori[,1:2],col='red',pch=20,cex=.5)
</code></pre>

<hr>
<h2 id='predonfly'>
Probability forecasting
</h2><span id='topic+predonfly'></span>

<h3>Description</h3>

<p>From two sets of observations, first one of complete observations and second one of incomplete observations, provides simulated values of the unknown coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predonfly(completeobs,incompleteobs,varnames,subsampsize,nbpreds=1,mixties=FALSE,
          maxtirs=1e5,complete=TRUE,nthreads=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predonfly_+3A_completeobs">completeobs</code></td>
<td>

<p>the set of complete observations.
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_incompleteobs">incompleteobs</code></td>
<td>

<p>the set of incomplete observations.
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_varnames">varnames</code></td>
<td>

<p>the modeled variables.
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_subsampsize">subsampsize</code></td>
<td>

<p>the sub-sample size.
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_nbpreds">nbpreds</code></td>
<td>

<p>the number of predictions for each incomplete observation.
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_mixties">mixties</code></td>
<td>

<p>if <code>TRUE</code>, should put equal weight on tied values, using random permutations (not yet implemented)
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_maxtirs">maxtirs</code></td>
<td>

<p>the maximum number of sub-samples, to stop the computation even if they did not provide <code>nbpreds</code> predictions for each incomplete observation.
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_complete">complete</code></td>
<td>

<p>If <code>TRUE</code>, predictions are completed with incomplete observations
</p>
</td></tr>
<tr><td><code id="predonfly_+3A_nthreads">nthreads</code></td>
<td>

<p>number of number of threads, assumed to be strictly positive. For &quot;full throttle&quot; computations, consider using parallel::detectCores()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix of the completed observations
</p>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon=100
plon=30
subsampsize=10

x=rnorm(lon)
y=2*x+rnorm(lon)*0
donori=as.data.frame(cbind(x,y))
##
knownvalues=data.frame(x=rnorm(plon))
prev &lt;- predonfly(donori,knownvalues,c("x","y"),subsampsize,100)

##
plot(prev$x,prev$y,pch=20,cex=0.5,
     ylim=range(c(prev$y,donori$y),na.rm=TRUE),xlim=range(c(prev$x,donori$x)))
points(donori[,1:2],col='red',pch=20,cex=.5)

lon=3000
mg=20
dimtot=4
rayon=6

genboules &lt;- function(lon,a,d)
{
  ss &lt;- function(vec)
  {return(sum(vec*vec))}
  surface=matrix(nrow=lon,ncol=d,data=rnorm(lon*d))
  rayons=sqrt(apply(surface,1,ss))
  surface=surface/rayons
  return(matrix(nrow=lon,ncol=d,data=rnorm(lon*d))+a*surface)
}

##############

donori=genboules(lon,rayon,dimtot)
donori=as.data.frame(donori)

dimconnues=3:dimtot
valconnues=matrix(nrow=1,ncol=length(dimconnues),data=0)
valconnues=as.data.frame(valconnues)
names(valconnues)=names(donori)[3:dimtot]
prev &lt;- predonfly(donori,valconnues,names(donori),subsampsize,100)

boule2=genboules(plon,rayon,2)

plot(boule2[,1:2],xlab='X1',ylab='X2',pch=20,cex=.5)
plot(prev$V1,prev$V2,xlab='X1',ylab='X2',pch=20,cex=.5)
</code></pre>

<hr>
<h2 id='simany'>
Test statistic distribution under any hypothesis
</h2><span id='topic+simany'></span>

<h3>Description</h3>

<p>Simulates the test statistic, under independence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simany(sampsize,dimension,subsampsizes,sampnum,nbsafe=5,nthreads=2, fun=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simany_+3A_sampsize">sampsize</code></td>
<td>

<p>sample size
</p>
</td></tr>
<tr><td><code id="simany_+3A_dimension">dimension</code></td>
<td>

<p>sample dimension
</p>
</td></tr>
<tr><td><code id="simany_+3A_subsampsizes">subsampsizes</code></td>
<td>

<p>vector of sub-sample sizes
</p>
</td></tr>
<tr><td><code id="simany_+3A_sampnum">sampnum</code></td>
<td>

<p>number of samples
</p>
</td></tr>
<tr><td><code id="simany_+3A_nbsafe">nbsafe</code></td>
<td>

<p>the ratio between the number of sub-samples and the cardinality of the discretized copula.
</p>
</td></tr>
<tr><td><code id="simany_+3A_nthreads">nthreads</code></td>
<td>

<p>number of number of threads, assumed to be strictly positive. For &quot;full throttle&quot; computations, consider using parallel::detectCores()</p>
</td></tr>
<tr><td><code id="simany_+3A_fun">fun</code></td>
<td>

<p>the function describing the dependence.
</p>
</td></tr>
<tr><td><code id="simany_+3A_...">...</code></td>
<td>

<p>optional arguments to <code>fun</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lrs</code></td>
<td>
<p>the distances with independent case</p>
</td></tr>
<tr><td><code>lrs2mean</code></td>
<td>
<p>the distances with theoretical value, given dependence <code>fun</code></p>
</td></tr>
<tr><td><code>scarcities</code></td>
<td>
<p>the proportions of non-reached vector ranks</p>
</td></tr>
<tr><td><code>DistTypes</code></td>
<td>
<p>a recall of the list of the distance types: &quot;KL&quot;,&quot;L2&quot;,&quot;L1&quot;,&quot;APE&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depquad &lt;- function(lon,dd,a)
{
  x &lt;- rnorm(lon)
  y0 &lt;- a*x^2
  y &lt;- y0 + rnorm(lon)
  reste=rnorm((dd-2)*lon)
  return(c(x,y,reste))
}
sims0=simany(101,3,8,50,nbsafe=1)
seuils=apply(sims0$lrs,3,quantile,0.95)
seuils=matrix(ncol=4,nrow=50,seuils,byrow=TRUE)
sims1=simany(101,3,8,50,nbsafe=1,fun=depquad,a=0.5)
apply(sims1$lrs[,1,]&gt;seuils,2,mean)
</code></pre>

<hr>
<h2 id='simnul'>
Test statistic distribution under independence hypothesis
</h2><span id='topic+simnul'></span>

<h3>Description</h3>

<p>Simulates the test statistic, under independence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simnul(sampsize, dimension, subsampsizes, sampnum,KL=TRUE,nbsafe=5,nthreads=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simnul_+3A_sampsize">sampsize</code></td>
<td>

<p>sample size
</p>
</td></tr>
<tr><td><code id="simnul_+3A_dimension">dimension</code></td>
<td>

<p>sample dimension
</p>
</td></tr>
<tr><td><code id="simnul_+3A_subsampsizes">subsampsizes</code></td>
<td>

<p>vector of sub-sample sizes
</p>
</td></tr>
<tr><td><code id="simnul_+3A_sampnum">sampnum</code></td>
<td>

<p>number of samples
</p>
</td></tr>
<tr><td><code id="simnul_+3A_kl">KL</code></td>
<td>

<p>if TRUE, returns the Kullback-Leibler divergence with the independent case, if FALSE, the L2 distance. There is no re-normalization, contrary to what happens for <code>simany</code>.
</p>
</td></tr>
<tr><td><code id="simnul_+3A_nbsafe">nbsafe</code></td>
<td>

<p>the ratio between the number of sub-samples and the cardinality of the discretized copula.
</p>
</td></tr>
<tr><td><code id="simnul_+3A_nthreads">nthreads</code></td>
<td>

<p>number of number of threads, assumed to be strictly positive. For &quot;full throttle&quot; computations, consider using parallel::detectCores()</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lrs</code></td>
<td>
<p>the distances with independent case</p>
</td></tr>
<tr><td><code>scarcities</code></td>
<td>
<p>the proportions of non-reached vector ranks</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(datasets)
# plot(swiss)
c=corc(swiss,1:3,8)
c
RV=sum(c$cop*log(c$cop),na.rm=TRUE)+3*log(8)
sims=simnul(47,3,8,100)
pvalue=mean(RV&lt;sims$lrs)
pvalue
RV
summary(sims$lrs)
</code></pre>

<hr>
<h2 id='subrank-package'>
Computes Copula using Ranks and Subsampling
</h2><span id='topic+subrank-package'></span><span id='topic+subrank'></span>

<h3>Description</h3>

<p>Estimation of copula using ranks and subsampling. The main feature of this method is that simulation studies show a low sensitivity to dimension, on realistic cases.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> subrank</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Computes Copula using Ranks and Subsampling</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.9.9.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-06</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Jerome Collet</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Jerome Collet &lt;jeromepcollet@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Estimation of copula using ranks and subsampling. The main feature of this method is that simulation studies show a low sensitivity to dimension, on realistic cases.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
corc                    Function to estimate copula using ranks and
                        sub-sampling
corc0                   Function to estimate copula using ranks and
                        sub-sampling, minimal version.
desscop                 Discrete copula graph, a two-dimensional
                        projection
desscoptous             Discrete copula graph, ALL two-dimensional
                        projections
estimdep                Dependence estimation
predictdep              Probability forecasting
predonfly               Probability forecasting
simany                  Test statistic distribution under any
                        hypothesis
simnul                  Test statistic distribution under independence
                        hypothesis
subrank-package         Computes Copula using Ranks and Subsampling
</pre>
<p>Taking a sample, its dimension, and a sub-sample size, allows to estimate a discretized copula. This object has interesting features: convergence to copula, robustness with respect to dimension.
</p>


<h3>Author(s)</h3>

<p>Jerome Collet
</p>
<p>Maintainer: Jerome Collet &lt;jeromepcollet@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lon &lt;- 31
a &lt;- 2.85
x &lt;- rnorm(lon)
y = a*x^2+rnorm(lon)
tablo = as.data.frame(cbind(x,y))
c=corc(tablo,c(1,2),8)
desscop(c,1,2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
