<!DOCTYPE html><html><head><title>Help for package rddtools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rddtools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.lm'><p>Convert a rdd object to lm</p></a></li>
<li><a href='#as.npregbw'><p>Convert an rdd_reg object to a  <code>npreg</code> object</p></a></li>
<li><a href='#clusterInf'><p>Post-inference for clustered data</p></a></li>
<li><a href='#covarTest_dis'><p>Testing for balanced covariates: equality of distribution</p></a></li>
<li><a href='#covarTest_mean'><p>Testing for balanced covariates: equality of means with t-test</p></a></li>
<li><a href='#dens_test'><p>Run the McCracy test for manipulation of the forcing variable</p></a></li>
<li><a href='#gen_mc_ik'><p>Generate Monte Carlo simulations of Imbens and Kalyanaraman</p></a></li>
<li><a href='#house'><p>Dataset used in Lee (2008)</p></a></li>
<li><a href='#indh'><p>INDH data set</p></a></li>
<li><a href='#plot.rdd_data'><p>Plot rdd_data</p></a></li>
<li><a href='#plotBin'><p>Bin plotting</p></a></li>
<li><a href='#plotPlacebo'><p>Draw a (density) plot of placebo tests</p></a></li>
<li><a href='#plotSensi'><p>Plot the sensitivity to the bandwidth</p></a></li>
<li><a href='#rdd_bw_cct_estim'><p>Bandwidth selection for Regression Discontinuity estimators, CTT 2014</p></a></li>
<li><a href='#rdd_bw_cct_plot'><p>Bandwidth selection for Regression Discontinuity visualisation, CTT 2015</p></a></li>
<li><a href='#rdd_bw_ik'><p>Imbens-Kalyanaraman Optimal Bandwidth Calculation</p></a></li>
<li><a href='#rdd_bw_rsw'><p>Global bandwidth selector of Ruppert, Sheather and Wand (1995) from package <span class="pkg">KernSmooth</span></p></a></li>
<li><a href='#rdd_coef'><p>RDD coefficient</p></a></li>
<li><a href='#rdd_data'><p>Construct rdd_data</p></a></li>
<li><a href='#rdd_gen_reg'><p>General polynomial estimator of the regression discontinuity</p></a></li>
<li><a href='#rdd_pred'><p>RDD coefficient prediction</p></a></li>
<li><a href='#rdd_reg_lm'><p>Parametric polynomial estimator of the regression discontinuity</p></a></li>
<li><a href='#rdd_reg_np'><p>Parametric polynomial estimator of the regression discontinuity</p></a></li>
<li><a href='#rddtools'><p>Regression Discontinuity Design</p></a></li>
<li><a href='#rot_bw'><p>Bandwidth selector</p></a></li>
<li><a href='#STAR_MHE'><p>Transformation of the STAR dataset as used in Angrist and Pischke (2008)</p></a></li>
<li><a href='#vcovCluster'><p>Cluster Heteroskedasticity-consistent estimation of the covariance matrix.</p></a></li>
<li><a href='#waldci'><p>Confint allowing vcov</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>Title:</td>
<td>Toolbox for Regression Discontinuity Design ('RDD')</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of functions for Regression Discontinuity Design ('RDD'), for
    data visualisation, estimation and testing.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bastiaan Quast &lt;bquast@gmail.com&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>KernSmooth, ggplot2, rdd, sandwich, lmtest, Formula, locpol,
methods, rdrobust, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>AER, np</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats4, car, knitr, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://qua.st/rddtools/">https://qua.st/rddtools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bquast/rddtools/issues">https://github.com/bquast/rddtools/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-10 11:18:42 UTC; bquast</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthieu Stigler <a href="https://orcid.org/0000-0002-6802-4290"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Bastiaan Quast <a href="https://orcid.org/0000-0002-2951-3577"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-10 12:42:49 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.lm'>Convert a rdd object to lm</h2><span id='topic+as.lm'></span>

<h3>Description</h3>

<p>Convert a rdd object to lm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.lm(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.lm_+3A_x">x</code></td>
<td>
<p>An object to convert to lm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>lm</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.npreg">as.npreg</a></code> which converts <code>rdd_reg</code> objects into <code>npreg</code> from package <code>np</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
reg_para &lt;- rdd_reg_lm(rdd_object=house_rdd)
reg_para_lm &lt;- as.lm(reg_para)
reg_para_lm
plot(reg_para_lm, which=4)
</code></pre>

<hr>
<h2 id='as.npregbw'>Convert an rdd_reg object to a  <code>npreg</code> object</h2><span id='topic+as.npregbw'></span><span id='topic+as.npreg'></span>

<h3>Description</h3>

<p>Convert an rdd_object to a non-parametric regression <code>npreg</code> from package <code>np</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.npregbw(x, ...)

as.npreg(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.npregbw_+3A_x">x</code></td>
<td>
<p>Object of class <code>rdd_reg</code> created by <code><a href="#topic+rdd_reg_np">rdd_reg_np</a></code> or <code><a href="#topic+rdd_reg_lm">rdd_reg_lm</a></code></p>
</td></tr>
<tr><td><code id="as.npregbw_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="np.html#topic+npregbw">npregbw</a></code> or <code><a href="np.html#topic+npreg">npreg</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts an rdd_reg object into an <code>npreg</code> object from package <code>np</code>
Note that the output won't be the same, since <code>npreg</code> does not offer a triangular kernel, but a Gaussian or Epanechinkov one. 
Another reason why estimates might differ slightly is that <code>npreg</code> implements a multivariate kernel, while rdd_reg 
proceeds as if the kernel was univariate. A simple solution to make the multivariate kernel similar to the  univariate one 
is to set the bandwidth for x and Dx to a large number, so that they converge towards a constant, and one obtains back the univariate kernel.
</p>


<h3>Value</h3>

<p>An object of class <code>npreg</code> or <code>npregbw</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.lm">as.lm</a></code> which converts <code>rdd_reg</code> objects into <code>lm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimate ususal rdd_reg:
 data(house)
 house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
 reg_nonpara &lt;- rdd_reg_np(rdd_object=house_rdd)

## Convert to npreg:
 reg_nonpara_np &lt;- as.npreg(reg_nonpara)
 reg_nonpara_np
 rdd_coef(reg_nonpara_np, allCo=TRUE, allInfo=TRUE)

## Compare with result obtained with a Gaussian kernel:
 bw_lm &lt;- dnorm(house_rdd$x, sd=rddtools:::getBW(reg_nonpara))
 reg_nonpara_gaus &lt;- rdd_reg_lm(rdd_object=house_rdd, w=bw_lm)
 all.equal(rdd_coef(reg_nonpara_gaus),rdd_coef(reg_nonpara_np)) 
</code></pre>

<hr>
<h2 id='clusterInf'>Post-inference for clustered data</h2><span id='topic+clusterInf'></span>

<h3>Description</h3>

<p>Correct standard-errors to account for clustered data, doing either a degrees of freedom correction or using a heteroskedasticidty-cluster robust covariance matrix
possibly on the range specified by bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterInf(object, clusterVar, vcov. = NULL, type = c("df-adj", "HC"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterInf_+3A_object">object</code></td>
<td>
<p>Object of class lm, from which rdd_reg also inherits.</p>
</td></tr>
<tr><td><code id="clusterInf_+3A_clustervar">clusterVar</code></td>
<td>
<p>The variable containing the cluster attributions.</p>
</td></tr>
<tr><td><code id="clusterInf_+3A_vcov.">vcov.</code></td>
<td>
<p>Specific covariance function to pass to coeftest. See help of sandwich</p>
</td></tr>
<tr><td><code id="clusterInf_+3A_type">type</code></td>
<td>
<p>The type of cluster correction to use: either the degrees of freedom, or a HC matrix.</p>
</td></tr>
<tr><td><code id="clusterInf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to coeftest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the coeftest function, which is itself of class <code>coeftest</code>
</p>


<h3>References</h3>

<p>Wooldridge (2003) Cluster-sample methods in applied econometrics. 
<em>AmericanEconomic Review</em>, 93, p. 133-138
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcovCluster">vcovCluster</a></code>, which implements the cluster-robust covariance matrix estimator used by <code>cluserInf</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
reg_para &lt;- rdd_reg_lm(rdd_object=house_rdd)

# here we just generate randomly a cluster variable:
nlet &lt;- sort(c(outer(letters, letters, paste, sep='')))
clusRandom &lt;- sample(nlet[1:60], size=nrow(house_rdd), replace=TRUE)

# now do post-inference:
clusterInf(reg_para, clusterVar=clusRandom)
clusterInf(reg_para, clusterVar=clusRandom, type='HC')
</code></pre>

<hr>
<h2 id='covarTest_dis'>Testing for balanced covariates: equality of distribution</h2><span id='topic+covarTest_dis'></span><span id='topic+covarTest_dis.rdd_data'></span><span id='topic+covarTest_dis.rdd_reg'></span>

<h3>Description</h3>

<p>Tests equality of distribution with a Kolmogorov-Smirnov for each covariates, between the two full groups or around the discontinuity threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covarTest_dis(
  object,
  bw,
  exact = NULL,
  p.adjust = c("none", "holm", "BH", "BY", "hochberg", "hommel", "bonferroni")
)

## S3 method for class 'rdd_data'
covarTest_dis(
  object,
  bw = NULL,
  exact = FALSE,
  p.adjust = c("none", "holm", "BH", "BY", "hochberg", "hommel", "bonferroni")
)

## S3 method for class 'rdd_reg'
covarTest_dis(
  object,
  bw = NULL,
  exact = FALSE,
  p.adjust = c("none", "holm", "BH", "BY", "hochberg", "hommel", "bonferroni")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covarTest_dis_+3A_object">object</code></td>
<td>
<p>object of class rdd_data</p>
</td></tr>
<tr><td><code id="covarTest_dis_+3A_bw">bw</code></td>
<td>
<p>a bandwidth</p>
</td></tr>
<tr><td><code id="covarTest_dis_+3A_exact">exact</code></td>
<td>
<p>Argument of the <code><a href="stats.html#topic+ks.test">ks.test</a></code> function: NULL or a logical indicating whether an exact p-value should be computed.</p>
</td></tr>
<tr><td><code id="covarTest_dis_+3A_p.adjust">p.adjust</code></td>
<td>
<p>Whether to adjust the p-values for multiple testing. Uses the <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame  with, for each covariate, the K-S statistic and its p-value.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler &lt;<a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covarTest_mean">covarTest_mean</a></code> for the t-test of equality of means
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)

## Add randomly generated covariates
set.seed(123)
n_Lee &lt;- nrow(house)
Z &lt;- data.frame(z1 = rnorm(n_Lee, sd=2), 
                z2 = rnorm(n_Lee, mean = ifelse(house&lt;0, 5, 8)), 
                z3 = sample(letters, size = n_Lee, replace = TRUE))
house_rdd_Z &lt;- rdd_data(y = house$y, x = house$x, covar = Z, cutpoint = 0)

## Kolmogorov-Smirnov test of equality in distribution:
covarTest_dis(house_rdd_Z, bw=0.3)

## Can also use function covarTest_dis() for a t-test for equality of means around cutoff:
covarTest_mean(house_rdd_Z, bw=0.3)
## covarTest_dis works also on regression outputs (bw will be taken from the model)
reg_nonpara &lt;- rdd_reg_np(rdd_object=house_rdd_Z)
covarTest_dis(reg_nonpara)
</code></pre>

<hr>
<h2 id='covarTest_mean'>Testing for balanced covariates: equality of means with t-test</h2><span id='topic+covarTest_mean'></span><span id='topic+covarTest_mean.rdd_data'></span><span id='topic+covarTest_mean.rdd_reg'></span>

<h3>Description</h3>

<p>Tests equality of means by a t-test for each covariate, between the two full groups or around the discontinuity threshold
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covarTest_mean(
  object,
  bw = NULL,
  paired = FALSE,
  var.equal = FALSE,
  p.adjust = c("none", "holm", "BH", "BY", "hochberg", "hommel", "bonferroni")
)

## S3 method for class 'rdd_data'
covarTest_mean(
  object,
  bw = NULL,
  paired = FALSE,
  var.equal = FALSE,
  p.adjust = c("none", "holm", "BH", "BY", "hochberg", "hommel", "bonferroni")
)

## S3 method for class 'rdd_reg'
covarTest_mean(
  object,
  bw = NULL,
  paired = FALSE,
  var.equal = FALSE,
  p.adjust = c("none", "holm", "BH", "BY", "hochberg", "hommel", "bonferroni")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covarTest_mean_+3A_object">object</code></td>
<td>
<p>object of class rdd_data</p>
</td></tr>
<tr><td><code id="covarTest_mean_+3A_bw">bw</code></td>
<td>
<p>a bandwidth</p>
</td></tr>
<tr><td><code id="covarTest_mean_+3A_paired">paired</code></td>
<td>
<p>Argument of the <code><a href="stats.html#topic+t.test">t.test</a></code> function: logical indicating whether you want paired t-tests.</p>
</td></tr>
<tr><td><code id="covarTest_mean_+3A_var.equal">var.equal</code></td>
<td>
<p>Argument of the <code><a href="stats.html#topic+t.test">t.test</a></code> function:  logical variable indicating whether to treat the two variances as being equal</p>
</td></tr>
<tr><td><code id="covarTest_mean_+3A_p.adjust">p.adjust</code></td>
<td>
<p>Whether to adjust the p-values for multiple testing. Uses the <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with, for each covariate, the mean on each size, the difference, t-stat and ts p-value.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler &lt;<a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covarTest_dis">covarTest_dis</a></code> for the Kolmogorov-Smirnov test of equality of distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)

## Add randomly generated covariates
set.seed(123)
n_Lee &lt;- nrow(house)
Z &lt;- data.frame(z1 = rnorm(n_Lee, sd=2), 
                z2 = rnorm(n_Lee, mean = ifelse(house&lt;0, 5, 8)), 
                z3 = sample(letters, size = n_Lee, replace = TRUE))
house_rdd_Z &lt;- rdd_data(y = house$y, x = house$x, covar = Z, cutpoint = 0)

## test for equality of means around cutoff:
covarTest_mean(house_rdd_Z, bw=0.3)

## Can also use function covarTest_dis() for Kolmogorov-Smirnov test:
covarTest_dis(house_rdd_Z, bw=0.3)

## covarTest_mean works also on regression outputs (bw will be taken from the model)
reg_nonpara &lt;- rdd_reg_np(rdd_object=house_rdd_Z)
covarTest_mean(reg_nonpara)
</code></pre>

<hr>
<h2 id='dens_test'>Run the McCracy test for manipulation of the forcing variable</h2><span id='topic+dens_test'></span>

<h3>Description</h3>

<p>Calls the <code><a href="rdd.html#topic+DCdensity">DCdensity</a></code> test from package <code>rdd</code> on a <code>rdd_object</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dens_test(rdd_object, bin = NULL, bw = NULL, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dens_test_+3A_rdd_object">rdd_object</code></td>
<td>
<p>object of class rdd_data</p>
</td></tr>
<tr><td><code id="dens_test_+3A_bin">bin</code></td>
<td>
<p>Argument of the <code><a href="rdd.html#topic+DCdensity">DCdensity</a></code> function, the binwidth</p>
</td></tr>
<tr><td><code id="dens_test_+3A_bw">bw</code></td>
<td>
<p>Argument of the <code><a href="rdd.html#topic+DCdensity">DCdensity</a></code> function, the bandwidth</p>
</td></tr>
<tr><td><code id="dens_test_+3A_plot">plot</code></td>
<td>
<p>Whether to return a plot. Logical, default ot TRUE.</p>
</td></tr>
<tr><td><code id="dens_test_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="rdd.html#topic+DCdensity">DCdensity</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
dens_test(house_rdd)
</code></pre>

<hr>
<h2 id='gen_mc_ik'>Generate Monte Carlo simulations of Imbens and Kalyanaraman</h2><span id='topic+gen_mc_ik'></span>

<h3>Description</h3>

<p>Generate the simulations reported in Imbens and Kalyanaraman (2012)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_mc_ik(
  n = 200,
  version = 1,
  sd = 0.1295,
  output = c("data.frame", "rdd_data"),
  size
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_mc_ik_+3A_n">n</code></td>
<td>
<p>The size of sampel to generate</p>
</td></tr>
<tr><td><code id="gen_mc_ik_+3A_version">version</code></td>
<td>
<p>The MC version of Imbens and Kalnayaraman (between 1 and 4).</p>
</td></tr>
<tr><td><code id="gen_mc_ik_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the error term.</p>
</td></tr>
<tr><td><code id="gen_mc_ik_+3A_output">output</code></td>
<td>
<p>Whether to return a data-frame, or already a rdd_data</p>
</td></tr>
<tr><td><code id="gen_mc_ik_+3A_size">size</code></td>
<td>
<p>The size of the effect, this depends on the specific version, defaults are as in ik: 0.04, NULL, 0.1, 0.1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An data frame with x and y variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mc1_dat &lt;- gen_mc_ik()
MC1_rdd &lt;- rdd_data(y=mc1_dat$y, x=mc1_dat$x, cutpoint=0)

## Use np regression:
reg_nonpara &lt;- rdd_reg_np(rdd_object=MC1_rdd)
reg_nonpara

# Represent the curves:
plotCu &lt;- function(version=1, xlim=c(-0.1,0.1)){
  res &lt;- gen_mc_ik(sd=0.0000001, n=1000, version=version)
  res &lt;- res[order(res$x),]
  ylim &lt;- range(subset(res, x&gt;=min(xlim) &amp; x&lt;=max(xlim), 'y'))
  plot(res, type='l', xlim=xlim, ylim=ylim, main=paste('DGP', version))
  abline(v=0)
  xCut &lt;- res[which(res$x==min(res$x[res$x&gt;=0]))+c(0,-1),]
  points(xCut, col=2)
}
layout(matrix(1:4,2, byrow=TRUE))
plotCu(version=1)
plotCu(version=2)
plotCu(version=3)
plotCu(version=4)
layout(matrix(1))
</code></pre>

<hr>
<h2 id='house'>Dataset used in Lee (2008)</h2><span id='topic+house'></span>

<h3>Description</h3>

<p>Randomized experiments from non-random selection in U.S. House elections
</p>
<p>Dataset described used in Imbens and Kalyamaran (2012), and probably the same dataset used in Lee (2008),
</p>


<h3>Format</h3>

<p>A data frame with 6558 observations and two variables:
</p>

<dl>
<dt>x</dt><dd><p>Vote at election t-1</p>
</dd>
<dt>y</dt><dd><p>Vote at election t</p>
</dd>
</dl>



<h3>Source</h3>

<p>Guido Imbens webpage: <a href="https://scholar.harvard.edu/imbens/scholar_software/regression-discontinuity">https://scholar.harvard.edu/imbens/scholar_software/regression-discontinuity</a>
</p>


<h3>References</h3>

<p>Imbens, Guido and Karthik Kalyanaraman. (2012) 'Optimal Bandwidth Choice for the regression discontinuity estimator,' 
Review of Economic Studies (2012) 79, 933-959
</p>
<p>Lee, D. (2008) Randomized experiments from non-random selection in U.S. House elections, 
<em>Journal of Econometrics</em>, 142, 675-697
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
rdd_house &lt;- rdd_data(x=x, y=y, data=house, cutpoint=0)
summary(rdd_house)
plot(rdd_house)
</code></pre>

<hr>
<h2 id='indh'>INDH data set</h2><span id='topic+indh'></span>

<h3>Description</h3>

<p>Data from the Initiative Nationale du Development Humaine, collected as the part of the SNSF project &quot;Development Aid and Social Dynamics&quot;
</p>


<h3>Format</h3>

<p>A data frame with two variables with 720 observations each
</p>


<h3>Source</h3>

<p>Development Aid and social Dyanmics website: <a href="https://qua.st/Development-Aid-Social-Dynamics/">https://qua.st/Development-Aid-Social-Dynamics/</a>
</p>


<h3>References</h3>

<p>Arcand, Rieger, and Nguyen (2015) 'Development Aid and Social Dyanmics Data Set'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the data
data(indh)

# construct rdd_data frame
rdd_dat_indh &lt;- rdd_data(y=choice_pg, x=poverty, data=indh, cutpoint=30)

# inspect data frame
summary(rdd_dat_indh)

# perform non-parametric regression
( reg_np_indh &lt;- rdd_reg_np(rdd_dat_indh) )
</code></pre>

<hr>
<h2 id='plot.rdd_data'>Plot rdd_data</h2><span id='topic+plot.rdd_data'></span>

<h3>Description</h3>

<p>Binned plot of the forcing and outcome variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rdd_data'
plot(
  x,
  h = NULL,
  nbins = NULL,
  xlim = range(object$x, na.rm = TRUE),
  cex = 0.7,
  nplot = 1,
  device = c("base", "ggplot"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rdd_data_+3A_x">x</code></td>
<td>
<p>Object of class rdd_data</p>
</td></tr>
<tr><td><code id="plot.rdd_data_+3A_h">h</code></td>
<td>
<p>The binwidth parameter (note this differs from the bandwidth parameter!)</p>
</td></tr>
<tr><td><code id="plot.rdd_data_+3A_nbins">nbins</code></td>
<td>
<p>Alternative to h, the total number of bins in the plot.</p>
</td></tr>
<tr><td><code id="plot.rdd_data_+3A_xlim">xlim</code></td>
<td>
<p>The range of the x data</p>
</td></tr>
<tr><td><code id="plot.rdd_data_+3A_cex">cex</code></td>
<td>
<p>Size of the points, see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.rdd_data_+3A_nplot">nplot</code></td>
<td>
<p>Number of plot to draw</p>
</td></tr>
<tr><td><code id="plot.rdd_data_+3A_device">device</code></td>
<td>
<p>Type of device used. Currently not used.</p>
</td></tr>
<tr><td><code id="plot.rdd_data_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a simple binned plot averaging values within each interval. The length of the intervals
is specified with the argument <code>h</code>, specifying the whole binwidth (contrary to the usual bandwidth
argument, that gives half of the length of the kernel window. 
When no bandwidth is given, the bandwidth of Ruppert et al is used, see <code><a href="#topic+rdd_bw_rsw">rdd_bw_rsw</a></code>.
</p>


<h3>Value</h3>

<p>A plot
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler &lt;<a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
plot(house_rdd)

## Specify manually the bandwidth:
plot(house_rdd, h=0.2)

## Show three plots with different bandwidth:
plot(house_rdd, h=c(0.2,0.3,0.4), nplot=3)

## Specify instead of the bandwidth, the final number of bins:
plot(house_rdd, nbins=22)

## If the specified number of bins is odd, the larger number is given to side with largest range
plot(house_rdd, nbins=21)
</code></pre>

<hr>
<h2 id='plotBin'>Bin plotting</h2><span id='topic+plotBin'></span>

<h3>Description</h3>

<p>Do a 'scatterplot bin smoothing'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBin(
  x,
  y,
  h = NULL,
  nbins = NULL,
  cutpoint = 0,
  plot = TRUE,
  type = c("value", "number"),
  xlim = range(x, na.rm = TRUE),
  cex = 0.9,
  main = NULL,
  xlab,
  ylab,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBin_+3A_x">x</code></td>
<td>
<p>Forcing variable</p>
</td></tr>
<tr><td><code id="plotBin_+3A_y">y</code></td>
<td>
<p>Output</p>
</td></tr>
<tr><td><code id="plotBin_+3A_h">h</code></td>
<td>
<p>the bandwidth (defaults to <code>2*sd(runvar)*length(runvar)^(-.5)</code>)</p>
</td></tr>
<tr><td><code id="plotBin_+3A_nbins">nbins</code></td>
<td>
<p>number of Bins</p>
</td></tr>
<tr><td><code id="plotBin_+3A_cutpoint">cutpoint</code></td>
<td>
<p>Cutpoint</p>
</td></tr>
<tr><td><code id="plotBin_+3A_plot">plot</code></td>
<td>
<p>Logical. Whether to plot or only returned silently</p>
</td></tr>
<tr><td><code id="plotBin_+3A_type">type</code></td>
<td>
<p>Whether returns the y averages, or the x frequencies</p>
</td></tr>
<tr><td><code id="plotBin_+3A_xlim">xlim</code>, <code id="plotBin_+3A_cex">cex</code>, <code id="plotBin_+3A_main">main</code>, <code id="plotBin_+3A_xlab">xlab</code>, <code id="plotBin_+3A_ylab">ylab</code></td>
<td>
<p>Usual parameters passed to plot(), see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plotBin_+3A_...">...</code></td>
<td>
<p>further arguments passed to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns silently values
</p>


<h3>References</h3>

<p>McCrary, Justin.
</p>

<hr>
<h2 id='plotPlacebo'>Draw a (density) plot of placebo tests</h2><span id='topic+plotPlacebo'></span><span id='topic+plotPlacebo.rdd_reg'></span><span id='topic+plotPlaceboDens'></span><span id='topic+plotPlaceboDens.rdd_reg'></span><span id='topic+computePlacebo'></span>

<h3>Description</h3>

<p>Draw a plot of placebo tests, estimating the impact on fake cutpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPlacebo(object, device = c("ggplot", "base"), ...)

## S3 method for class 'rdd_reg'
plotPlacebo(
  object,
  device = c("ggplot", "base"),
  from = 0.25,
  to = 0.75,
  by = 0.1,
  level = 0.95,
  same_bw = FALSE,
  vcov. = NULL,
  plot = TRUE,
  output = c("data", "ggplot"),
  ...
)

plotPlaceboDens(object, device = c("ggplot", "base"), ...)

## S3 method for class 'rdd_reg'
plotPlaceboDens(
  object,
  device = c("ggplot", "base"),
  from = 0.25,
  to = 0.75,
  by = 0.1,
  level = 0.95,
  same_bw = FALSE,
  vcov. = NULL,
  ...
)

computePlacebo(
  object,
  from = 0.25,
  to = 0.75,
  by = 0.1,
  level = 0.95,
  same_bw = FALSE,
  vcov. = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPlacebo_+3A_object">object</code></td>
<td>
<p>the output of an RDD regression</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_device">device</code></td>
<td>
<p>Whether to draw a base or a ggplot graph.</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_from">from</code></td>
<td>
<p>Starting point of the fake cutpoints sequence. Refers ot the quantile of each side of the true cutpoint</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_to">to</code></td>
<td>
<p>Ending   point of the fake cutpoints sequence. Refers ot the quantile of each side of the true cutpoint</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_by">by</code></td>
<td>
<p>Increments of the from-to sequence</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_level">level</code></td>
<td>
<p>Level of the confidence interval shown</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_same_bw">same_bw</code></td>
<td>
<p>Whether to re-estimate the bandwidth at each point</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_vcov.">vcov.</code></td>
<td>
<p>Specific covariance function to pass to coeftest. See help of package <code><a href="sandwich.html#topic+sandwich">sandwich</a></code>.</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_plot">plot</code></td>
<td>
<p>Whether to actually plot the data.</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_output">output</code></td>
<td>
<p>Whether to return (invisibly) the data frame containing the bandwidths and corresponding estimates, or the ggplot object</p>
</td></tr>
<tr><td><code id="plotPlacebo_+3A_...">...</code></td>
<td>
<p>Further arguments passed to specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the cutpoints, their corresponding estimates and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler &lt;<a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
reg_nonpara &lt;- rdd_reg_np(rdd_object=house_rdd)
plotPlacebo(reg_nonpara)

# Use with another vcov function; cluster case
reg_nonpara_lminf &lt;- rdd_reg_np(rdd_object=house_rdd, inference='lm')
# need to be a function applied to updated object!
vc &lt;- function(x) vcovCluster(x, clusterVar=model.frame(x)$x)
plotPlacebo(reg_nonpara_lminf, vcov. = vc)
</code></pre>

<hr>
<h2 id='plotSensi'>Plot the sensitivity to the bandwidth</h2><span id='topic+plotSensi'></span><span id='topic+plotSensi.rdd_reg_np'></span><span id='topic+plotSensi.rdd_reg_lm'></span>

<h3>Description</h3>

<p>Draw a plot showing the LATE estimates depending on multiple bandwidths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSensi(
  rdd_regobject,
  from,
  to,
  by = 0.01,
  level = 0.95,
  output = c("data", "ggplot"),
  plot = TRUE,
  ...
)

## S3 method for class 'rdd_reg_np'
plotSensi(
  rdd_regobject,
  from,
  to,
  by = 0.05,
  level = 0.95,
  output = c("data", "ggplot"),
  plot = TRUE,
  device = c("ggplot", "base"),
  vcov. = NULL,
  ...
)

## S3 method for class 'rdd_reg_lm'
plotSensi(
  rdd_regobject,
  from,
  to,
  by = 0.05,
  level = 0.95,
  output = c("data", "ggplot"),
  plot = TRUE,
  order,
  type = c("colour", "facet"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSensi_+3A_rdd_regobject">rdd_regobject</code></td>
<td>
<p>object of a RDD regression, from either <code><a href="#topic+rdd_reg_lm">rdd_reg_lm</a></code> or <code><a href="#topic+rdd_reg_np">rdd_reg_np</a></code></p>
</td></tr>
<tr><td><code id="plotSensi_+3A_from">from</code></td>
<td>
<p>First bandwidth point. Default value is max(1e-3, bw-0.1)</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_to">to</code></td>
<td>
<p>Last bandwidth point. Default value is bw+0.1</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_by">by</code></td>
<td>
<p>Increments in the <code>from</code> <code>to</code> sequence</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_level">level</code></td>
<td>
<p>Level of the confidence interval</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_output">output</code></td>
<td>
<p>Whether to return (invisibly) the data frame containing the bandwidths and corresponding estimates, or the ggplot object</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_plot">plot</code></td>
<td>
<p>Whether to actually plot the data.</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_device">device</code></td>
<td>
<p>Whether to draw a base or a ggplot graph.</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_vcov.">vcov.</code></td>
<td>
<p>Specific covariance function to pass to coeftest. See help of package <code><a href="sandwich.html#topic+sandwich">sandwich</a></code></p>
</td></tr>
<tr><td><code id="plotSensi_+3A_order">order</code></td>
<td>
<p>For parametric models (from <code><a href="#topic+rdd_reg_lm">rdd_reg_lm</a></code>), the order of the polynomial.</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_type">type</code></td>
<td>
<p>For parametric models (from <code><a href="#topic+rdd_reg_lm">rdd_reg_lm</a></code>) whether different orders are represented as different colour or as different facets.</p>
</td></tr>
<tr><td><code id="plotSensi_+3A_...">...</code></td>
<td>
<p>Further arguments passed to specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the bandwidths and corresponding estimates and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler &lt;<a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)

#Non-parametric estimate 
bw_ik &lt;- rdd_bw_ik(house_rdd)
reg_nonpara &lt;- rdd_reg_np(rdd_object=house_rdd, bw=bw_ik)
plotSensi(reg_nonpara)
plotSensi(reg_nonpara, device='base')

#Parametric estimate:
reg_para_ik &lt;- rdd_reg_lm(rdd_object=house_rdd, order=4, bw=bw_ik)
plotSensi(reg_para_ik)
plotSensi(reg_para_ik, type='facet')
</code></pre>

<hr>
<h2 id='rdd_bw_cct_estim'>Bandwidth selection for Regression Discontinuity estimators, CTT 2014</h2><span id='topic+rdd_bw_cct_estim'></span>

<h3>Description</h3>

<p>Simple wrapper of the Calonico-Cattaneo-Titiunik (2014) bandwidth selection procedures 
for RDD estimators <code><a href="rdrobust.html#topic+rdbwselect">rdbwselect</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_bw_cct_estim(
  rdd_object,
  method = c("mserd", "msetwo", "msesum", "msecomb1", "msecomb2", "cerrd", "certwo",
    "cersum", "cercomb1"),
  kernel = c("Triangular", "Uniform", "Epanechnikov"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_bw_cct_estim_+3A_rdd_object">rdd_object</code></td>
<td>
<p>of class rdd_data created by <code><a href="#topic+rdd_data">rdd_data</a></code></p>
</td></tr>
<tr><td><code id="rdd_bw_cct_estim_+3A_method">method</code></td>
<td>
<p>The type of method used. See</p>
</td></tr>
<tr><td><code id="rdd_bw_cct_estim_+3A_kernel">kernel</code></td>
<td>
<p>The type of kernel used: either <code>Triangular</code>, <code>Uniform</code> or <code>Epanechnikov</code>.</p>
</td></tr>
<tr><td><code id="rdd_bw_cct_estim_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="rdrobust.html#topic+rdbwselect">rdbwselect</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See documentation of <code><a href="rdrobust.html#topic+rdbwselect">rdbwselect</a></code>
</p>


<h3>Author(s)</h3>

<p>Original code written by Calonico, Cattaneo, Farrell and Titiuni, see <code><a href="rdrobust.html#topic+rdbwselect">rdbwselect</a></code>
</p>


<h3>References</h3>

<p>Calonico, S., M. D. Cattaneo, and R. Titiunik. 2014a. Robust Nonparametric Confidence Intervals for Regression-Discontinuity Designs. Econometrica 82(6): 2295-2326.
<a href="https://www.tandfonline.com/doi/abs/10.1080/01621459.2015.1017578">https://www.tandfonline.com/doi/abs/10.1080/01621459.2015.1017578</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdd_bw_ik">rdd_bw_ik</a></code> Local RDD bandwidth selector using the plug-in method of Imbens and Kalyanaraman (2012)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
rd&lt;- rdd_data(x=house$x, y=house$y, cutpoint=0)
rdd_bw_cct_estim(rd)

</code></pre>

<hr>
<h2 id='rdd_bw_cct_plot'>Bandwidth selection for Regression Discontinuity visualisation, CTT 2015</h2><span id='topic+rdd_bw_cct_plot'></span>

<h3>Description</h3>

<p>Simple wrapper of the Calonico-Cattaneo-Titiunik (2015) bandwidth selection procedures 
for RDD visualisation <code><a href="rdrobust.html#topic+rdplot">rdplot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_bw_cct_plot(
  rdd_object,
  method = c("esmv", "es", "espr", "esmvpr", "qs", "qspr", "qsmv", "qsmvpr"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_bw_cct_plot_+3A_rdd_object">rdd_object</code></td>
<td>
<p>of class rdd_data created by <code><a href="#topic+rdd_data">rdd_data</a></code></p>
</td></tr>
<tr><td><code id="rdd_bw_cct_plot_+3A_method">method</code></td>
<td>
<p>The type of method used. See <code><a href="rdrobust.html#topic+rdplot">rdplot</a></code>. 
Default is <code>esmv</code>, the variance mimicking evenly-spaced method.</p>
</td></tr>
<tr><td><code id="rdd_bw_cct_plot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="rdrobust.html#topic+rdplot">rdplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See documentation of <code><a href="rdrobust.html#topic+rdplot">rdplot</a></code>
</p>


<h3>Author(s)</h3>

<p>Original code written by Calonico, Cattaneo, Farrell and Titiuni, see <code><a href="rdrobust.html#topic+rdplot">rdplot</a></code>
</p>


<h3>References</h3>

<p>Calonico, S., M. D. Cattaneo, and R. Titiunik. 2015a. Optimal Data-Driven Regression Discontinuity Plots. Journal of the American Statistical Association 110(512): 1753-1769.
<a href="https://www.tandfonline.com/doi/abs/10.1080/01621459.2015.1017578">https://www.tandfonline.com/doi/abs/10.1080/01621459.2015.1017578</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdd_bw_ik">rdd_bw_ik</a></code> Local RDD bandwidth selector using the plug-in method of Imbens and Kalyanaraman (2012)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
rd&lt;- rdd_data(x=house$x, y=house$y, cutpoint=0)
rdd_bw_cct_plot(rd)

</code></pre>

<hr>
<h2 id='rdd_bw_ik'>Imbens-Kalyanaraman Optimal Bandwidth Calculation</h2><span id='topic+rdd_bw_ik'></span>

<h3>Description</h3>

<p>Imbens-Kalyanaraman optimal bandwidth
for local linear regression in Regression discontinuity designs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_bw_ik(rdd_object, kernel = c("Triangular", "Uniform", "Normal"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_bw_ik_+3A_rdd_object">rdd_object</code></td>
<td>
<p>of class rdd_data created by <code><a href="#topic+rdd_data">rdd_data</a></code></p>
</td></tr>
<tr><td><code id="rdd_bw_ik_+3A_kernel">kernel</code></td>
<td>
<p>The type of kernel used: either <code>triangular</code> or <code>uniform</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The optimal bandwidth
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler &lt;<a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a>&gt;
</p>


<h3>References</h3>

<p>Imbens, Guido and Karthik Kalyanaraman. (2012) 'Optimal Bandwidth Choice for the regression discontinuity estimator,' 
Review of Economic Studies (2012) 79, 933-959
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdd_bw_rsw">rdd_bw_rsw</a></code> Global bandwidth selector of Ruppert, Sheather and Wand (1995)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
rd&lt;- rdd_data(x=house$x, y=house$y, cutpoint=0)
rdd_bw_ik(rd)
</code></pre>

<hr>
<h2 id='rdd_bw_rsw'>Global bandwidth selector of Ruppert, Sheather and Wand (1995) from package <span class="pkg">KernSmooth</span></h2><span id='topic+rdd_bw_rsw'></span>

<h3>Description</h3>

<p>Uses the global bandwidth selector of Ruppert, Sheather and Wand (1995) 
either to the whole function, or to the functions below and above the cutpoint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_bw_rsw(object, type = c("global", "sided"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_bw_rsw_+3A_object">object</code></td>
<td>
<p>object of class rdd_data created by <code><a href="#topic+rdd_data">rdd_data</a></code></p>
</td></tr>
<tr><td><code id="rdd_bw_rsw_+3A_type">type</code></td>
<td>
<p>Whether to choose a global bandwidth for the whole function (<code>global</code>) 
or for each side (<code>sided</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One (or two for <code>sided</code>) bandwidth value.
</p>


<h3>References</h3>

<p>See <code><a href="KernSmooth.html#topic+dpill">dpill</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdd_bw_ik">rdd_bw_ik</a></code> Local RDD bandwidth selector using the plug-in method of Imbens and Kalyanaraman (2012)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
rd&lt;- rdd_data(x=house$x, y=house$y, cutpoint=0)
rdd_bw_rsw(rd)
</code></pre>

<hr>
<h2 id='rdd_coef'>RDD coefficient</h2><span id='topic+rdd_coef'></span><span id='topic+rdd_coef.default'></span><span id='topic+rdd_coef.rdd_reg_np'></span>

<h3>Description</h3>

<p>Function to access the RDD coefficient in the various regressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_coef(object, allInfo = FALSE, allCo = FALSE, ...)

## Default S3 method:
rdd_coef(object, allInfo = FALSE, allCo = FALSE, ...)

## S3 method for class 'rdd_reg_np'
rdd_coef(object, allInfo = FALSE, allCo = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_coef_+3A_object">object</code></td>
<td>
<p>A RDD regression object</p>
</td></tr>
<tr><td><code id="rdd_coef_+3A_allinfo">allInfo</code></td>
<td>
<p>whether to return just the coefficients (allInfo=FALSE) or also the se/t stat/pval.</p>
</td></tr>
<tr><td><code id="rdd_coef_+3A_allco">allCo</code></td>
<td>
<p>Whether to give only the RDD coefficient (allCo=FALSE) or all coefficients</p>
</td></tr>
<tr><td><code id="rdd_coef_+3A_...">...</code></td>
<td>
<p>Further arguments passed to/from specific methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a numeric value of the RDD coefficient estimate, or a data frame with the estimate, 
its standard value, t test and p-value and
</p>

<hr>
<h2 id='rdd_data'>Construct rdd_data</h2><span id='topic+rdd_data'></span>

<h3>Description</h3>

<p>Construct the base RDD object, containing x, y and the cutpoint, eventuallay covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_data(y, x, covar, cutpoint, z, labels, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_data_+3A_y">y</code></td>
<td>
<p>Output</p>
</td></tr>
<tr><td><code id="rdd_data_+3A_x">x</code></td>
<td>
<p>Forcing variable</p>
</td></tr>
<tr><td><code id="rdd_data_+3A_covar">covar</code></td>
<td>
<p>Exogeneous variables</p>
</td></tr>
<tr><td><code id="rdd_data_+3A_cutpoint">cutpoint</code></td>
<td>
<p>Cutpoint</p>
</td></tr>
<tr><td><code id="rdd_data_+3A_z">z</code></td>
<td>
<p>Assignment variable for the fuzzy case. Should be 0/1 or TRUE/FALSE variable.</p>
</td></tr>
<tr><td><code id="rdd_data_+3A_labels">labels</code></td>
<td>
<p>Additional labels to provide as list (with entries <code>x</code>, <code>y</code>, and eventually vector <code>covar</code>). Unused currently.</p>
</td></tr>
<tr><td><code id="rdd_data_+3A_data">data</code></td>
<td>
<p>A data-frame for the <code>x</code> and <code>y</code> variables. If this is provided, 
the column names can be entered directly for argument <code>x</code> and <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>rdd_data</code>, inheriting from <code>data.frame</code>
</p>


<h3>Author(s)</h3>

<p>Matthieu Stigler &lt;<a href="mailto:Matthieu.Stigler@gmail.com">Matthieu.Stigler@gmail.com</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(house)
rd&lt;- rdd_data(x=house$x, y=house$y, cutpoint=0)
rd2 &lt;- rdd_data(x=x, y=y, data=house, cutpoint=0)

# The print() function is the same as the print.data.frame:
rd

# The summary() and plot() function are specific to rdd_data
summary(rd)
plot(rd)

# for the fuzzy case, you need to specify the assignment variable z:
rd_dat_fakefuzzy &lt;- rdd_data(x=house$x, y=house$y, 
                             z=ifelse(house$x&gt;0+rnorm(nrow(house), sd=0.05),1,0), 
                             cutpoint=0)
summary(rd_dat_fakefuzzy)
</code></pre>

<hr>
<h2 id='rdd_gen_reg'>General polynomial estimator of the regression discontinuity</h2><span id='topic+rdd_gen_reg'></span>

<h3>Description</h3>

<p>Compute RDD estimate allowing a locally kernel weighted version of any estimation function
possibly on the range specified by bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_gen_reg(
  rdd_object,
  fun = glm,
  covariates = NULL,
  order = 1,
  bw = NULL,
  slope = c("separate", "same"),
  covar.opt = list(strategy = c("include", "residual"), slope = c("same", "separate"),
    bw = NULL),
  weights,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_gen_reg_+3A_rdd_object">rdd_object</code></td>
<td>
<p>Object of class rdd_data created by <code><a href="#topic+rdd_data">rdd_data</a></code></p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_fun">fun</code></td>
<td>
<p>The function to estimate the parameters</p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_covariates">covariates</code></td>
<td>
<p>Formula to include covariates</p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_order">order</code></td>
<td>
<p>Order of the polynomial regression.</p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_bw">bw</code></td>
<td>
<p>A bandwidth to specify the subset on which the kernel weighted regression is estimated</p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_slope">slope</code></td>
<td>
<p>Whether slopes should be different on left or right (separate), or the same.</p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_covar.opt">covar.opt</code></td>
<td>
<p>Options for the inclusion of covariates. Way to include covariates, either in the main regression (<code>include</code>) or as regressors of y in a first step (<code>residual</code>).</p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_weights">weights</code></td>
<td>
<p>Optional weights to pass to the lm function. Note this cannot be entered together with <code>bw</code></p>
</td></tr>
<tr><td><code id="rdd_gen_reg_+3A_...">...</code></td>
<td>
<p>Further arguments passed to fun. See the example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows the user to use a custom estimating function, instead of the traditional <code>lm()</code>. 
It is assumed that the custom funciton has following behaviour:
</p>

<ol>
<li><p> A formula interface, together with a <code>data</code> argument
</p>
</li>
<li><p> A <code>weight</code> argument
</p>
</li>
<li><p> A coef(summary(x)) returning a data-frame containing a column Estimate
</p>
</li></ol>

<p>Note that for the last requirement, this can be accomodated by writing a specific <code><a href="#topic+rdd_coef">rdd_coef</a></code> 
function for the class of the object returned by <code>fun</code>.
</p>


<h3>Value</h3>

<p>An object of class rdd_reg_lm and class lm, with specific print and plot methods
</p>


<h3>References</h3>

<p>TODO
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Step 0: prepare data
data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)

## Estimate a local probit:
house_rdd$y &lt;- with(house_rdd, ifelse(y&lt;quantile(y, 0.25), 0,1))
reg_bin_glm &lt;- rdd_gen_reg(rdd_object=house_rdd, fun= glm, family=binomial(link='probit'))
print(reg_bin_glm)
summary(reg_bin_glm)

</code></pre>

<hr>
<h2 id='rdd_pred'>RDD coefficient prediction</h2><span id='topic+rdd_pred'></span>

<h3>Description</h3>

<p>Function to predict the RDD coefficient in presence of covariate (without covariates, returns the same than <code><a href="#topic+rdd_coef">rdd_coef</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_pred(
  object,
  covdata,
  se.fit = TRUE,
  vcov. = NULL,
  newdata,
  stat = c("identity", "sum", "mean"),
  weights
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_pred_+3A_object">object</code></td>
<td>
<p>A RDD regression object</p>
</td></tr>
<tr><td><code id="rdd_pred_+3A_covdata">covdata</code></td>
<td>
<p>New data.frame specifying the values of the covariates, can have multiple rows.</p>
</td></tr>
<tr><td><code id="rdd_pred_+3A_se.fit">se.fit</code></td>
<td>
<p>A switch indicating if standard errors are required.</p>
</td></tr>
<tr><td><code id="rdd_pred_+3A_vcov.">vcov.</code></td>
<td>
<p>Specific covariance function (see package sandwich ), by default uses the <code><a href="stats.html#topic+vcov">vcov</a></code></p>
</td></tr>
<tr><td><code id="rdd_pred_+3A_newdata">newdata</code></td>
<td>
<p>Another data on which to evaluate the x/D variables. Useful in very few cases.</p>
</td></tr>
<tr><td><code id="rdd_pred_+3A_stat">stat</code></td>
<td>
<p>The statistic to use if there are multiple predictions, 'identity' just returns the single values, 'mean' averages them</p>
</td></tr>
<tr><td><code id="rdd_pred_+3A_weights">weights</code></td>
<td>
<p>Eventual weights for the averaging of the predicted values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>rdd_pred</code> does a simple prediction of the RDD effect
</p>
<p style="text-align: center;"><code class="reqn">RDDeffect= \mu(x, z, D=1) - \mu(x, z, D=0)</code>
</p>

<p>When there are no covariates (and z is irrelevant in the equation above), this amounts exactly to the usual RDD coefficient, 
shown in the outputs, or obtained with <code><a href="#topic+rdd_coef">rdd_coef</a></code>. If there were covariates, and if these covariates were estimated using the 
&ldquo;include&rdquo; <em>strategy</em> and with different coefficients left and right to the cutoff (i.e.
had argument <em>slope</em> = &ldquo;separate&rdquo;), than the RDD effect is also dependent on the value of the covariate(s). 
<code>rdd_pred</code> allows to set the value of the covariate(s) at which to evaluate the RDD effect, by providing a data.frame with
the values for the covariates. Note that the effect can be evaluated at multiple points, if you provide multiple rows of <code>covdata</code>. 
</p>
<p>In pressence of covariate-specific RDD effect, one may wish to estimate an average effect. This can be done by setting the argument <code>stat='mean'</code>. 
Weights can additionally be added, with the argument <code>weights</code>, to obtain a weighted-average of the predictions. Note however that in most cases, 
this will be equivalent to provide covariates at their (weighted) mean value, which will be much faster also!
</p>
<p>Standard errors, obtained setting the argument <code>se.fit=TRUE</code>, are computed using following formula:
</p>
<p style="text-align: center;"><code class="reqn">x_i \Omega x_i^{'}</code>
</p>

<p>where <code class="reqn">\Omega</code> is the estimated variance-covariance matrix ( by default <code class="reqn">\sigma^2(X^{'}X)^{-1}</code> using <code><a href="stats.html#topic+vcov">vcov</a></code>) and 
<code class="reqn">x_i</code> is the input data (a mix of covdata and input data). If one wishes individual predictions, standard errors are simply obtained 
as the square of that diagonal matrix, whereas for mean/sum, covariances are taken into account.
</p>


<h3>Value</h3>

<p>Returns the predicted value(s), and, if se.fit=TRUE, their standard errors.
</p>


<h3>References</h3>

<p>Froehlich (2007) Regression discontinuity design with covariates, IZA discussion paper 3024
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data, add (artificial) covariates:
data(house)
n_Lee &lt;- nrow(house)
z1 &lt;- runif(n_Lee)
house_rdd &lt;- rdd_data(y=y, x=x, data=house, covar=z1, cutpoint=0)

# estimation without covariates: rdd_pred is the same than rdd_coef:
reg_para &lt;- rdd_reg_lm(rdd_object=house_rdd)

rdd_pred(reg_para)
rdd_coef(reg_para, allInfo=TRUE)

# estimation with covariates: 
reg_para_cov &lt;- rdd_reg_lm(rdd_object=house_rdd,
                          covariates='z1',
                          covar.opt=list(slope='separate') )

# should obtain same result as with RDestimate                             
rdd_pred(reg_para_cov, covdata=data.frame(z1=0)) 
  
# evaluate at mean of z1 (as comes from uniform)
rdd_pred(reg_para_cov, covdata=data.frame(z1=0.5))
</code></pre>

<hr>
<h2 id='rdd_reg_lm'>Parametric polynomial estimator of the regression discontinuity</h2><span id='topic+rdd_reg_lm'></span>

<h3>Description</h3>

<p>Compute a parametric polynomial regression of the ATE, 
possibly on the range specified by bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_reg_lm(
  rdd_object,
  covariates = NULL,
  order = 1,
  bw = NULL,
  slope = c("separate", "same"),
  covar.opt = list(strategy = c("include", "residual"), slope = c("same", "separate"),
    bw = NULL),
  covar.strat = c("include", "residual"),
  weights
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_reg_lm_+3A_rdd_object">rdd_object</code></td>
<td>
<p>Object of class rdd_data created by <code><a href="#topic+rdd_data">rdd_data</a></code></p>
</td></tr>
<tr><td><code id="rdd_reg_lm_+3A_covariates">covariates</code></td>
<td>
<p>Formula to include covariates</p>
</td></tr>
<tr><td><code id="rdd_reg_lm_+3A_order">order</code></td>
<td>
<p>Order of the polynomial regression.</p>
</td></tr>
<tr><td><code id="rdd_reg_lm_+3A_bw">bw</code></td>
<td>
<p>A bandwidth to specify the subset on which the parametric regression is estimated</p>
</td></tr>
<tr><td><code id="rdd_reg_lm_+3A_slope">slope</code></td>
<td>
<p>Whether slopes should be different on left or right (separate), or the same.</p>
</td></tr>
<tr><td><code id="rdd_reg_lm_+3A_covar.opt">covar.opt</code></td>
<td>
<p>Options for the inclusion of covariates. Way to include covariates, either in the main regression (<code>include</code>) or as regressors of y in a first step (<code>residual</code>).</p>
</td></tr>
<tr><td><code id="rdd_reg_lm_+3A_covar.strat">covar.strat</code></td>
<td>
<p>DEPRECATED, use covar.opt instead.</p>
</td></tr>
<tr><td><code id="rdd_reg_lm_+3A_weights">weights</code></td>
<td>
<p>Optional weights to pass to the lm function. Note this cannot be entered together with <code>bw</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the standard <em>discontinuity regression</em>:
</p>
<p style="text-align: center;"><code class="reqn">Y=\alpha+\tau D+\beta_{1}(X-c)+\beta_{2}D(X-c)+\epsilon</code>
</p>

<p>with <code class="reqn">\tau</code> the main parameter of interest. Several versions of the regression can be estimated, either restricting the slopes to be the same, 
i.e <code class="reqn">\beta_{1}=\beta_{2}</code> (argument <code>slope</code>). The order of the polynomial in <code class="reqn">X-c</code> can also be adjusted with argument <code>order</code>. 
Note that a value of zero can be used, which corresponds to the simple <em>difference in means</em>, that one would use if the samples were random. 
Covariates can also be added in the regression, according to the two strategies discussed in Lee and Lemieux (2010, sec 4.5), through argument <code>covar.strat</code>:
</p>

<dl>
<dt>include</dt><dd><p>Covariates are simply added as supplementary regressors in the RD equation</p>
</dd>
<dt>residual</dt><dd><p>The dependent variable is first regressed on the covariates only, then the RDD equation is applied on the residuals from this first step</p>
</dd></dl>

<p>The regression can also be estimated in a neighborhood of the cutpoint with the argument <code>bw</code>. This make the parametric regression resemble 
the non-parametric local kernel <code><a href="#topic+rdd_reg_np">rdd_reg_np</a></code>. Similarly, weights can also be provided (but not simultaneously to <code>bw</code>). 
</p>
<p>The returned object is a classical <code>lm</code> object, augmented with a <code>RDDslot</code>, so usual methods can be applied. As is done in general in R, 
heteroskeadsticity-robust inference can be done later on with the usual function from package <span class="pkg">sandwich</span>. For the case of clustered observations
a specific function <code><a href="#topic+clusterInf">clusterInf</a></code> is provided.
</p>


<h3>Value</h3>

<p>An object of class rdd_reg_lm and class lm, with specific print and plot methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Step 0: prepare data
data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
## Step 2: regression
# Simple polynomial of order 1:
reg_para &lt;- rdd_reg_lm(rdd_object=house_rdd)
print(reg_para)
plot(reg_para)

# Simple polynomial of order 4:
reg_para4 &lt;- rdd_reg_lm(rdd_object=house_rdd, order=4)
reg_para4
plot(reg_para4)

# Restrict sample to bandwidth area:
bw_ik &lt;- rdd_bw_ik(house_rdd)
reg_para_ik &lt;- rdd_reg_lm(rdd_object=house_rdd, bw=bw_ik, order=4)
reg_para_ik
plot(reg_para_ik)
</code></pre>

<hr>
<h2 id='rdd_reg_np'>Parametric polynomial estimator of the regression discontinuity</h2><span id='topic+rdd_reg_np'></span>

<h3>Description</h3>

<p>Compute a parametric polynomial regression of the ATE, 
possibly on the range specified by bandwidth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdd_reg_np(
  rdd_object,
  covariates = NULL,
  bw = rdd_bw_ik(rdd_object),
  slope = c("separate", "same"),
  inference = c("np", "lm"),
  covar.opt = list(slope = c("same", "separate"), bw = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdd_reg_np_+3A_rdd_object">rdd_object</code></td>
<td>
<p>Object of class rdd_data created by <code><a href="#topic+rdd_data">rdd_data</a></code></p>
</td></tr>
<tr><td><code id="rdd_reg_np_+3A_covariates">covariates</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="rdd_reg_np_+3A_bw">bw</code></td>
<td>
<p>A bandwidth to specify the subset on which the parametric regression is estimated</p>
</td></tr>
<tr><td><code id="rdd_reg_np_+3A_slope">slope</code></td>
<td>
<p>Whether slopes should be different on left or right (separate), or the same.</p>
</td></tr>
<tr><td><code id="rdd_reg_np_+3A_inference">inference</code></td>
<td>
<p>Type of inference to conduct: non-parametric one (<code>np</code>) or standard (<code>lm</code>). See details.</p>
</td></tr>
<tr><td><code id="rdd_reg_np_+3A_covar.opt">covar.opt</code></td>
<td>
<p>Options for the inclusion of covariates. Way to include covariates, either in the main regression (<code>include</code>) or as regressors of y in a first step (<code>residual</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class rdd_reg_np and class lm, with specific print and plot methods
</p>


<h3>References</h3>

<p>TODO
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdd_bw_ik">rdd_bw_ik</a></code> Bandwidth selection using the plug-in bandwidth of Imbens and Kalyanaraman (2012)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Step 0: prepare data
data(house)
house_rdd &lt;- rdd_data(y=house$y, x=house$x, cutpoint=0)
## Step 2: regression
# Simple polynomial of order 1:
reg_nonpara &lt;- rdd_reg_np(rdd_object=house_rdd)
print(reg_nonpara)
plot(reg_nonpara)
</code></pre>

<hr>
<h2 id='rddtools'>Regression Discontinuity Design</h2><span id='topic+rddtools'></span>

<h3>Description</h3>

<p>Set of functions for Regression Discontinuity Design ('RDD'), for data visualisation, estimation and testing.
</p>

<hr>
<h2 id='rot_bw'>Bandwidth selector</h2><span id='topic+rot_bw'></span>

<h3>Description</h3>

<p>implements dpill
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rot_bw(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rot_bw_+3A_object">object</code></td>
<td>
<p>object of class rdd_data</p>
</td></tr>
</table>


<h3>References</h3>

<p>McCrary, Justin. (2008) 'Manipulation of the running variable in the regression discontinuity design: A density test,' <em>Journal of Econometrics</em>. 142(2): 698-714.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#No discontinuity
</code></pre>

<hr>
<h2 id='STAR_MHE'>Transformation of the STAR dataset as used in Angrist and Pischke (2008)</h2><span id='topic+STAR_MHE'></span>

<h3>Description</h3>

<p>Transformation of the STAR dataset as used in Table 8.2.1 of Angrist and Pischke (2008)
</p>


<h3>Format</h3>

<p>A data frame containing 5743 observations and 6 variables. The first variable is from the original dataset, 
all other are created by Angrist and Pischke STAT code.
</p>

<dl>
<dt>schidkn</dt><dd><p>School ID in kindergarden (original variable, schoolidk in <code><a href="AER.html#topic+STAR">STAR</a></code>)</p>
</dd>
<dt>pscore</dt><dd><p>The propensity score  (computed by A &amp; P)</p>
</dd>
<dt>classid</dt><dd><p>The id of the class (computed by A &amp; P)</p>
</dd>
<dt>cs</dt><dd><p>Class size (computed by A &amp; P)</p>
</dd>
<dt>female, nwhite</dt><dd><p>Various covariates (computed by A &amp; P)</p>
</dd>
</dl>



<h3>Details</h3>

<p>). This is a transformation of the dataset from the project STAR (Student/Teacher Achievement Ratio. 
The full dataset is described and available in package AER, <code><a href="AER.html#topic+STAR">STAR</a></code>. 
The transformed data was obtained using the STATA script krueger.do, obtained from Joshua Angrist website 
(<a href="https://economics.mit.edu/faculty/angrist/data1/mhe/krueger">https://economics.mit.edu/faculty/angrist/data1/mhe/krueger</a>), on the webstar.dta.
</p>


<h3>Source</h3>

<p>Data obtained using the script krueger.do on data webstar.rda, found on J. Angrist website 
<a href="https://economics.mit.edu/faculty/angrist/data1/mhe/krueger">https://economics.mit.edu/faculty/angrist/data1/mhe/krueger</a>, retrieved on 26 November 2012.
</p>


<h3>References</h3>

<p>Krueger, A. (1999) 'Experimental Estimates Of Education Production Functions,' 
<em>The Quarterly Journal of Economics</em>, Vol. 114(2), pages 497-532, May.
</p>
<p>Angrist, A. ad  Pischke J-S (2008) <em>Mostly Harmless Econometrics: An Empiricist's Companion</em>, 
Princeton University press
</p>


<h3>See Also</h3>

<p><code><a href="AER.html#topic+STAR">STAR</a></code> for the original dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(STAR_MHE)

# Compute the group means:
STAR_MHE_means &lt;- aggregate(STAR_MHE[, c('classid', 'pscore', 'cs')],
                            by=list(STAR_MHE$classid), mean)

# Regression of means, with weighted average:
reg_krug_gls &lt;- lm(pscore~cs, data=STAR_MHE_means, weights=cs)
coef(summary(reg_krug_gls))[2,2]
</code></pre>

<hr>
<h2 id='vcovCluster'>Cluster Heteroskedasticity-consistent estimation of the covariance matrix.</h2><span id='topic+vcovCluster'></span><span id='topic+vcovCluster2'></span>

<h3>Description</h3>

<p>Offer a cluster variant of the usual Heteroskedasticity-consistent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcovCluster(object, clusterVar)

vcovCluster2(object, clusterVar1, clusterVar2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcovCluster_+3A_object">object</code></td>
<td>
<p>Object of class lm, from which rdd_reg also inherits.</p>
</td></tr>
<tr><td><code id="vcovCluster_+3A_clustervar">clusterVar</code></td>
<td>
<p>The variable containing the cluster attributions.</p>
</td></tr>
<tr><td><code id="vcovCluster_+3A_clustervar1">clusterVar1</code>, <code id="vcovCluster_+3A_clustervar2">clusterVar2</code></td>
<td>
<p>The two cluster variables for the 2-cluster case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the covariance matrix estimate.
</p>


<h3>Author(s)</h3>

<p>Mahmood Arai, see <a href="http://people.su.se/~ma/econometrics.html">http://people.su.se/~ma/econometrics.html</a>
</p>


<h3>References</h3>

<p>Cameron, C.,  Gelbach, J. and Miller, D. (2011) Robust Inference With Multiway Clustering,
<em>Journal of Business and Economic Statistics</em>,  vol. 29(2), pages 238-249.
#' @references Wooldridge (2003) Cluster-sample methods in applied econometrics. 
<em>American Economic Review</em>, 93, p. 133-138
</p>
<p>Arai, M. (2011) Cluster-robust standard errors using R, Note available <a href="http://people.su.se/~ma/clustering.pdf">http://people.su.se/~ma/clustering.pdf</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clusterInf">clusterInf</a></code> for a direct function, allowing also alternative cluster inference methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(STAR_MHE)
if(all(c(require(sandwich), require(lmtest)))){

# Run simple regression:
reg_krug &lt;- lm(pscore~cs, data=STAR_MHE)

# Row 1 of Table 8.2.1, inference with standard vcovHC:
coeftest(reg_krug,vcov.=vcovHC(reg_krug, 'HC1'))[2,2]

# Row 4 of Table 8.2.1, inference with cluster vcovHC:
coeftest(reg_krug,vcov.=vcovCluster(reg_krug, clusterVar=STAR_MHE$classid))[2,2]
}
</code></pre>

<hr>
<h2 id='waldci'>Confint allowing vcov</h2><span id='topic+waldci'></span>

<h3>Description</h3>

<p>Version of vcov allowing for confint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waldci(x, parm = NULL, level = 0.95, vcov. = NULL, df = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waldci_+3A_x">x</code></td>
<td>
<p>Object of class lm or else</p>
</td></tr>
<tr><td><code id="waldci_+3A_parm">parm</code></td>
<td>
<p>specification of which parameters are to be given confidence intervals, see confint</p>
</td></tr>
<tr><td><code id="waldci_+3A_level">level</code></td>
<td>
<p>the confidence level required, see confint()</p>
</td></tr>
<tr><td><code id="waldci_+3A_vcov.">vcov.</code></td>
<td>
<p>Specific covariance function to pass to coeftest. See help of sandwich</p>
</td></tr>
<tr><td><code id="waldci_+3A_df">df</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr>
<tr><td><code id="waldci_+3A_...">...</code></td>
<td>
<p>Further arguments</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
