<!DOCTYPE html><html lang="en"><head><title>Help for package D2MCS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {D2MCS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Accuracy'><p>Computes the Accuracy measure.</p></a></li>
<li><a href='#BinaryPlot'><p>Plotting feature clusters following bi-class problem.</p></a></li>
<li><a href='#ChiSquareHeuristic'><p>Feature-clustering based on ChiSquare method.</p></a></li>
<li><a href='#ClassificationOutput'><p>D2MCS Classification Output.</p></a></li>
<li><a href='#ClassMajorityVoting'><p>Implementation of Majority Voting voting.</p></a></li>
<li><a href='#ClassWeightedVoting'><p>Implementation Weighted Voting scheme.</p></a></li>
<li><a href='#ClusterPredictions'><p>Manages the predictions achieved on a cluster.</p></a></li>
<li><a href='#CombinedMetrics'><p>Abstract class to compute the class prediction based on combination</p>
between metrics.</a></li>
<li><a href='#CombinedVoting'><p>Implementation of Combined Voting.</p></a></li>
<li><a href='#ConfMatrix'><p>Confusion matrix wrapper.</p></a></li>
<li><a href='#D2MCS'><p>Data Driven Multiple Classifier System.</p></a></li>
<li><a href='#Dataset'><p>Simple Dataset handler.</p></a></li>
<li><a href='#DatasetLoader'><p>Dataset creation.</p></a></li>
<li><a href='#DefaultModelFit'><p>Default model fitting implementation.</p></a></li>
<li><a href='#DependencyBasedStrategy'><p>Clustering strategy based on dependency between features.</p></a></li>
<li><a href='#DependencyBasedStrategyConfiguration'><p>Custom Strategy Configuration handler for the DependencyBasedStrategy</p>
strategy.</a></li>
<li><a href='#DIterator'><p>Iterator over a Subset object</p></a></li>
<li><a href='#ExecutedModels'><p>Handles training of M.L. models</p></a></li>
<li><a href='#FinalPred'><p>Stores the prediction for a specific voting scheme.</p></a></li>
<li><a href='#FisherTestHeuristic'><p>Feature-clustering based on Fisher's Exact Test.</p></a></li>
<li><a href='#FIterator'><p>Iterator over a file.</p></a></li>
<li><a href='#FN'><p>Computes the False Negative errors.</p></a></li>
<li><a href='#FP'><p>Computes the False Positive value.</p></a></li>
<li><a href='#GainRatioHeuristic'><p>Feature-clustering based on GainRatio methodology.</p></a></li>
<li><a href='#GenericClusteringStrategy'><p>Abstract Feature Clustering Strategy class.</p></a></li>
<li><a href='#GenericHeuristic'><p>Abstract Feature Clustering heuristic object.</p></a></li>
<li><a href='#GenericModelFit'><p>Abstract class for defining model fitting method.</p></a></li>
<li><a href='#GenericPlot'><p>Pseudo-abstract class for creating feature clustering plots.</p></a></li>
<li><a href='#HDDataset'><p>High Dimensional Dataset handler.</p></a></li>
<li><a href='#HDSubset'><p>High Dimensional Subset handler.</p></a></li>
<li><a href='#InformationGainHeuristic'><p>Feature-clustering based on InformationGain methodology.</p></a></li>
<li><a href='#Kappa'><p>Computes the Kappa Cohen value.</p></a></li>
<li><a href='#KendallHeuristic'><p>Feature-clustering based on Kendall Correlation Test.</p></a></li>
<li><a href='#MCC'><p>Computes the Matthews correlation coefficient.</p></a></li>
<li><a href='#MCCHeuristic'><p>Feature-clustering based on Matthews Correlation Coefficient score.</p></a></li>
<li><a href='#MeasureFunction'><p>Archetype to define customized measures.</p></a></li>
<li><a href='#Methodology'><p>Abstract class to compute the probability prediction based on</p>
combination between metrics.</a></li>
<li><a href='#MinimizeFN'><p>Combined metric strategy to minimize FN errors.</p></a></li>
<li><a href='#MinimizeFP'><p>Combined metric strategy to minimize FP errors.</p></a></li>
<li><a href='#Model'><p>Stores a previously trained M.L. model.</p></a></li>
<li><a href='#MultinformationHeuristic'><p>Feature-clustering based on Mutual Information Computation theory.</p></a></li>
<li><a href='#NoProbability'><p>Compute performance across resamples.</p></a></li>
<li><a href='#NPV'><p>Computes the Negative Predictive Value.</p></a></li>
<li><a href='#OddsRatioHeuristic'><p>Feature-clustering based on Odds Ratio measure.</p></a></li>
<li><a href='#PearsonHeuristic'><p>Feature-clustering based on Pearson Correlation Test.</p></a></li>
<li><a href='#PPV'><p>Computes the Positive Predictive Value.</p></a></li>
<li><a href='#Precision'><p>Computes the Precision Value.</p></a></li>
<li><a href='#Prediction'><p>Manages the prediction computed for a specific model.</p></a></li>
<li><a href='#PredictionOutput'><p>Encapsulates the achieved predictions.</p></a></li>
<li><a href='#ProbAverageVoting'><p>Implementation of Probabilistic Average voting.</p></a></li>
<li><a href='#ProbAverageWeightedVoting'><p>Implementation of Probabilistic Average Weighted voting.</p></a></li>
<li><a href='#ProbBasedMethodology'><p>Methodology to obtain the combination of the probability of different</p>
metrics.</a></li>
<li><a href='#Recall'><p>Computes the Recall Value.</p></a></li>
<li><a href='#Sensitivity'><p>Computes the Sensitivity Value.</p></a></li>
<li><a href='#SimpleStrategy'><p>Simple feature clustering strategy.</p></a></li>
<li><a href='#SimpleVoting'><p>Abtract class to define simple voting schemes.</p></a></li>
<li><a href='#SingleVoting'><p>Manages the execution of Simple Votings.</p></a></li>
<li><a href='#SpearmanHeuristic'><p>Feature-clustering based on Spearman Correlation Test.</p></a></li>
<li><a href='#Specificity'><p>Computes the Specificity Value.</p></a></li>
<li><a href='#StrategyConfiguration'><p>Default Strategy Configuration handler.</p></a></li>
<li><a href='#Subset'><p>Classification set.</p></a></li>
<li><a href='#SummaryFunction'><p>Abstract class to computing performance across resamples.</p></a></li>
<li><a href='#TN'><p>Computes the True Negative value.</p></a></li>
<li><a href='#TP'><p>Computes the True Positive Value.</p></a></li>
<li><a href='#TrainFunction'><p>Control parameters for train stage.</p></a></li>
<li><a href='#TrainOutput'><p>Stores the results achieved during training.</p></a></li>
<li><a href='#Trainset'><p>Trainning set.</p></a></li>
<li><a href='#TwoClass'><p>Control parameters for train stage (Bi-class problem).</p></a></li>
<li><a href='#TypeBasedStrategy'><p>Feature clustering strategy.</p></a></li>
<li><a href='#UseProbability'><p>Compute performance across resamples.</p></a></li>
<li><a href='#VotingStrategy'><p>Voting Strategy template.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Driving Multiple Classifier System</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>
        Provides a novel framework to able to automatically develop and deploy
    an accurate Multiple Classifier System based on the feature-clustering 
    distribution achieved from an input dataset. 'D2MCS' was developed focused on 
    four main aspects: (i) the ability to determine an effective method to 
    evaluate the independence of features, (ii) the identification of the 
    optimal number of feature clusters, (iii) the training and tuning of ML 
    models and (iv) the execution of voting schemes to combine the outputs of 
    each classifier comprising the Multiple  Classifier System.</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-22</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/drordas/D2MCS">https://github.com/drordas/D2MCS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/drordas/D2MCS/issues">https://github.com/drordas/D2MCS/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, devtools, dplyr, FSelector, ggplot2, ggrepel,
gridExtra, infotheo, mccr, mltools, ModelMetrics, questionr,
recipes, R6, tictoc, varhandle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grDevices, knitr, rmarkdown, testthat (&ge; 3.0.2)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-23 11:11:05 UTC; Maite</td>
</tr>
<tr>
<td>Author:</td>
<td>David Ruano-Ordás [aut, ctb],
  Miguel Ferreiro-Díaz [aut, cre],
  José Ramón Méndez [aut, ctb],
  University of Vigo [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miguel Ferreiro-Díaz &lt;miguel.ferreiro.diaz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-23 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Accuracy'>Computes the Accuracy measure.</h2><span id='topic+Accuracy'></span>

<h3>Description</h3>

<p>Computes the ratio of number of correct predictions to the total
number of input samples.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">Accuracy = (Number Correct Predictions) / (Total Number of
Predictions)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>Accuracy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Accuracy-new"><code>Accuracy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Accuracy-compute"><code>Accuracy$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-Accuracy-clone"><code>Accuracy$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Accuracy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Accuracy$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> used as
basis to compute the performance.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Accuracy-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>Accuracy</strong> achieved by the
M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Accuracy$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the
<strong>Accuracy</strong> measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-Accuracy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Accuracy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>.
</p>

<hr>
<h2 id='BinaryPlot'>Plotting feature clusters following bi-class problem.</h2><span id='topic+BinaryPlot'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+BinaryPlot">BinaryPlot</a></code> implements a basic plot for
bi-class problem.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericPlot">D2MCS::GenericPlot</a></code> -&gt; <code>BinaryPlot</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BinaryPlot-new"><code>BinaryPlot$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BinaryPlot-plot"><code>BinaryPlot$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-BinaryPlot-clone"><code>BinaryPlot$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BinaryPlot-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>BinaryPlot$new()</pre></div>


<hr>
<a id="method-BinaryPlot-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plots feature-clustering data from a bi-class problem.
</p>


<h5>Usage</h5>

<div class="r"><pre>BinaryPlot$plot(summary)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>summary</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> comprising the elements to be plotted.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-BinaryPlot-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BinaryPlot$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+GenericPlot">GenericPlot</a></code>
</p>

<hr>
<h2 id='ChiSquareHeuristic'>Feature-clustering based on ChiSquare method.</h2><span id='topic+ChiSquareHeuristic'></span>

<h3>Description</h3>

<p>Performs feature-clustering based on ChiSquare method.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>ChiSquareHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ChiSquareHeuristic-new"><code>ChiSquareHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ChiSquareHeuristic-heuristic"><code>ChiSquareHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-ChiSquareHeuristic-clone"><code>ChiSquareHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ChiSquareHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ChiSquareHeuristic$new()</pre></div>


<hr>
<a id="method-ChiSquareHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Functions responsible of performing the ChiSquare
feature-clustering operation.
</p>


<h5>Usage</h5>

<div class="r"><pre>ChiSquareHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-ChiSquareHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ChiSquareHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>

<hr>
<h2 id='ClassificationOutput'>D2MCS Classification Output.</h2><span id='topic+ClassificationOutput'></span>

<h3>Description</h3>

<p>Allows computing the classification performance values achieved
by D2MCS. The class is automatically created when <code><a href="#topic+D2MCS">D2MCS</a></code>
classification method is invoked.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ClassificationOutput-new"><code>ClassificationOutput$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-getMetrics"><code>ClassificationOutput$getMetrics()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-getPositiveClass"><code>ClassificationOutput$getPositiveClass()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-getModelInfo"><code>ClassificationOutput$getModelInfo()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-getPerformances"><code>ClassificationOutput$getPerformances()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-savePerformances"><code>ClassificationOutput$savePerformances()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-plotPerformances"><code>ClassificationOutput$plotPerformances()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-getPredictions"><code>ClassificationOutput$getPredictions()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-savePredictions"><code>ClassificationOutput$savePredictions()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassificationOutput-clone"><code>ClassificationOutput$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ClassificationOutput-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$new(voting.schemes, models)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>voting.schemes</code></dt><dd><p>A <a href="base.html#topic+list">list</a> containing the voting schemes used
(inherited from <code><a href="#topic+VotingStrategy">VotingStrategy</a></code>.</p>
</dd>
<dt><code>models</code></dt><dd><p>A <a href="base.html#topic+list">list</a> containing the used <code><a href="#topic+Model">Model</a></code>
during classification stage.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassificationOutput-getMetrics"></a>



<h4>Method <code>getMetrics()</code></h4>

<p>The function returns the measures used during training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$getMetrics()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector or <a href="base.html#topic+NULL">NULL</a> if training was not
performed.
</p>


<hr>
<a id="method-ClassificationOutput-getPositiveClass"></a>



<h4>Method <code>getPositiveClass()</code></h4>

<p>The function gets the name of the positive class used for
training/classification.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$getPositiveClass()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of size 1.
</p>


<hr>
<a id="method-ClassificationOutput-getModelInfo"></a>



<h4>Method <code>getModelInfo()</code></h4>

<p>The function compiled all the information concerning to
the M.L. models used during training/classification.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$getModelInfo(metrics = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the metrics used during
training/classification.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> with the information of each M.L. model.
</p>


<hr>
<a id="method-ClassificationOutput-getPerformances"></a>



<h4>Method <code>getPerformances()</code></h4>

<p>The function is used to compute the performance of D2MCS.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$getPerformances(
  test.set,
  measures,
  voting.names = NULL,
  metric.names = NULL,
  cutoff.values = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>test.set</code></dt><dd><p>A <code><a href="#topic+Subset">Subset</a></code> object used to compute the
performance.</p>
</dd>
<dt><code>measures</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the measures to be used to
compute performance value (inherited from <code><a href="#topic+MeasureFunction">MeasureFunction</a></code>).</p>
</dd>
<dt><code>voting.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the
voting schemes to analyze the performance. If not defined, all the voting
schemes used during classification stage will be taken into account.</p>
</dd>
<dt><code>metric.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> containing the measures used
during training stage. If not defined, all training metrics used during
classification will be taken into account.</p>
</dd>
<dt><code>cutoff.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum
probability used to perform a a positive classification. If is not
defined, all cutoffs used during classification stage will be taken into
account.</p>
</dd>
<dt><code>dir.path</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with location where the plot
will be saved.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> of performance values.
</p>


<hr>
<a id="method-ClassificationOutput-savePerformances"></a>



<h4>Method <code>savePerformances()</code></h4>

<p>The function is used to save the computed predictions into a
CSV file.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$savePerformances(
  dir.path,
  test.set,
  measures,
  voting.names = NULL,
  metric.names = NULL,
  cutoff.values = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with location where the plot
will be saved.</p>
</dd>
<dt><code>test.set</code></dt><dd><p>A <code><a href="#topic+Subset">Subset</a></code> object used to compute the
performance.</p>
</dd>
<dt><code>measures</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the measures to be used to
compute performance value (inherited from <code><a href="#topic+MeasureFunction">MeasureFunction</a></code>).</p>
</dd>
<dt><code>voting.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the voting
schemes to analyze the performance. If not defined, all the voting
schemes used during classification stage will be taken into account.</p>
</dd>
<dt><code>metric.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> containing the measures used
during training stage. If not defined, all training metrics used during
classification will be taken into account.</p>
</dd>
<dt><code>cutoff.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum
probability used to perform a a positive classification. If is not
defined, all cutoffs used during classification stage will be taken into
account.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassificationOutput-plotPerformances"></a>



<h4>Method <code>plotPerformances()</code></h4>

<p>The function allows to graphically visualize the computed
performance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$plotPerformances(
  dir.path,
  test.set,
  measures,
  voting.names = NULL,
  metric.names = NULL,
  cutoff.values = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with location where the plot
will be saved.</p>
</dd>
<dt><code>test.set</code></dt><dd><p>A <code><a href="#topic+Subset">Subset</a></code> object used to compute the
performance.</p>
</dd>
<dt><code>measures</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the measures to be used to
compute performance value (inherited from <code><a href="#topic+MeasureFunction">MeasureFunction</a></code>).</p>
</dd>
<dt><code>voting.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the voting
schemes to analyze the performance. If not defined, all the voting
schemes used during classification stage will be taken into account.</p>
</dd>
<dt><code>metric.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> containing the measures used
during training stage. If not defined, all training metrics used during
classification will be taken into account.</p>
</dd>
<dt><code>cutoff.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum
probability used to perform a positive classification. If is not defined,
all cutoffs used during classification stage will be taken into account.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassificationOutput-getPredictions"></a>



<h4>Method <code>getPredictions()</code></h4>

<p>The function is used to obtain the computed predictions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$getPredictions(
  voting.names = NULL,
  metric.names = NULL,
  cutoff.values = NULL,
  type = NULL,
  target = NULL,
  filter = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>voting.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the voting
schemes to analyze the performance. If not defined, all the voting
schemes used during classification stage will be taken into account.</p>
</dd>
<dt><code>metric.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> containing the measures used
during training stage. If not defined, all training metrics used during
classification will be taken into account.</p>
</dd>
<dt><code>cutoff.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum
probability used to perform a a positive classification. If is not
defined, all cutoffs used during classification stage will be taken into
account.</p>
</dd>
<dt><code>type</code></dt><dd><p>A <a href="base.html#topic+character">character</a> to define which type of predictions should
be returned. If not defined all type of probabilities will be returned.
Conversely if &quot;prob&quot; or &quot;raw&quot; is defined then computed 'probabilistic' or
'class' values are returned.</p>
</dd>
<dt><code>target</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the positive
class.</p>
</dd>
<dt><code>filter</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value used to specify if only predictions
matching the target value should be returned or not. If <a href="base.html#topic+TRUE">TRUE</a> the
function returns only the predictions matching the target value.
Conversely if <a href="base.html#topic+FALSE">FALSE</a> (by default) the function returns all the
predictions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+PredictionOutput">PredictionOutput</a></code> object.
</p>


<hr>
<a id="method-ClassificationOutput-savePredictions"></a>



<h4>Method <code>savePredictions()</code></h4>

<p>The function saves the predictions into a CSV file.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$savePredictions(
  dir.path,
  voting.names = NULL,
  metric.names = NULL,
  cutoff.values = NULL,
  type = NULL,
  target = NULL,
  filter = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with location defining the
location of the CSV file.</p>
</dd>
<dt><code>voting.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the
voting schemes to analyze the performance. If not defined, all the voting
schemes used during classification stage will be taken into account.</p>
</dd>
<dt><code>metric.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> containing the measures used
during training stage. If not defined, all training metrics used during
classification will be taken into account.</p>
</dd>
<dt><code>cutoff.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum
probability used to perform a positive classification. If is not defined,
all cutoffs used during classification stage will be taken into account.</p>
</dd>
<dt><code>type</code></dt><dd><p>A <a href="base.html#topic+character">character</a> to define which type of predictions should
be returned. If not defined all type of probabilities will be returned.
Conversely if &quot;prob&quot; or &quot;raw&quot; is defined then computed 'probabilistic' or
'class' values are returned.</p>
</dd>
<dt><code>target</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the positive class.</p>
</dd>
<dt><code>filter</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value used to specify if only predictions
matching the target value should be returned or not. If <a href="base.html#topic+TRUE">TRUE</a> the
function returns only the predictions matching the target value.
Conversely if <a href="base.html#topic+FALSE">FALSE</a> (by default) the function returns all the
predictions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassificationOutput-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassificationOutput$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>
</p>

<hr>
<h2 id='ClassMajorityVoting'>Implementation of Majority Voting voting.</h2><span id='topic+ClassMajorityVoting'></span>

<h3>Description</h3>

<p>Implementation of the parliamentary 'majority voting' procedure.
The majority class value is defined as final class. All class values have the
same importance.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SimpleVoting">D2MCS::SimpleVoting</a></code> -&gt; <code>ClassMajorityVoting</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ClassMajorityVoting-new"><code>ClassMajorityVoting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassMajorityVoting-getMajorityClass"><code>ClassMajorityVoting$getMajorityClass()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassMajorityVoting-getClassTie"><code>ClassMajorityVoting$getClassTie()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassMajorityVoting-execute"><code>ClassMajorityVoting$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassMajorityVoting-clone"><code>ClassMajorityVoting$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getCutoff"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getCutoff'><code>D2MCS::SimpleVoting$getCutoff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getFinalPred"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getFinalPred'><code>D2MCS::SimpleVoting$getFinalPred()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ClassMajorityVoting-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassMajorityVoting$new(cutoff = 0.5, class.tie = NULL, majority.class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cutoff</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum probability
used to perform a positive classification. If is not defined, 0.5 will be
used as default value.</p>
</dd>
<dt><code>class.tie</code></dt><dd><p>A <a href="base.html#topic+character">character</a> used to define the target class value
used when a tie is found. If <a href="base.html#topic+NULL">NULL</a> positive class value will be
assigned.</p>
</dd>
<dt><code>majority.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the
majority class. If <a href="base.html#topic+NULL">NULL</a> will be used same value as training stage.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassMajorityVoting-getMajorityClass"></a>



<h4>Method <code>getMajorityClass()</code></h4>

<p>The function returns the value of the majority class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassMajorityVoting$getMajorityClass()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length 1 with the name of the
majority class.
</p>


<hr>
<a id="method-ClassMajorityVoting-getClassTie"></a>



<h4>Method <code>getClassTie()</code></h4>

<p>The function gets the class value assigned to solve ties.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassMajorityVoting$getClassTie()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length 1.
</p>


<hr>
<a id="method-ClassMajorityVoting-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function implements the majority voting procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassMajorityVoting$execute(predictions, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
all the predictions achieved for each cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassMajorityVoting-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassMajorityVoting$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+ClassMajorityVoting">ClassMajorityVoting</a></code>,
<code><a href="#topic+ClassWeightedVoting">ClassWeightedVoting</a></code>, <code><a href="#topic+ProbAverageVoting">ProbAverageVoting</a></code>,
<code><a href="#topic+ProbAverageWeightedVoting">ProbAverageWeightedVoting</a></code>, <code><a href="#topic+ProbBasedMethodology">ProbBasedMethodology</a></code>
</p>

<hr>
<h2 id='ClassWeightedVoting'>Implementation Weighted Voting scheme.</h2><span id='topic+ClassWeightedVoting'></span>

<h3>Description</h3>

<p>A new implementation of <code><a href="#topic+ClassMajorityVoting">ClassMajorityVoting</a></code> where
each class value has different values (weights).
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SimpleVoting">D2MCS::SimpleVoting</a></code> -&gt; <code>ClassWeightedVoting</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ClassWeightedVoting-new"><code>ClassWeightedVoting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassWeightedVoting-getWeights"><code>ClassWeightedVoting$getWeights()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassWeightedVoting-setWeights"><code>ClassWeightedVoting$setWeights()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassWeightedVoting-execute"><code>ClassWeightedVoting$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-ClassWeightedVoting-clone"><code>ClassWeightedVoting$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getCutoff"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getCutoff'><code>D2MCS::SimpleVoting$getCutoff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getFinalPred"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getFinalPred'><code>D2MCS::SimpleVoting$getFinalPred()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ClassWeightedVoting-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassWeightedVoting$new(cutoff = 0.5, weights = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cutoff</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum probability
used to perform a positive classification. If is not defined, 0.5 will be
used as default value.</p>
</dd>
<dt><code>weights</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector with the weights of each cluster.
If <a href="base.html#topic+NULL">NULL</a> performance achieved during training will be used as
default.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassWeightedVoting-getWeights"></a>



<h4>Method <code>getWeights()</code></h4>

<p>The function returns the weights used to perform the voting
scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassWeightedVoting$getWeights()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector.
</p>


<hr>
<a id="method-ClassWeightedVoting-setWeights"></a>



<h4>Method <code>setWeights()</code></h4>

<p>The function allows changing the value of the weights.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassWeightedVoting$setWeights(weights)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>weights</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector containing the new weights.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassWeightedVoting-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function implements the cluster-weighted majority voting
procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassWeightedVoting$execute(predictions, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
all the predictions achieved for each cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClassWeightedVoting-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClassWeightedVoting$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+ClassMajorityVoting">ClassMajorityVoting</a></code>,
<code><a href="#topic+ClassWeightedVoting">ClassWeightedVoting</a></code>, <code><a href="#topic+ProbAverageVoting">ProbAverageVoting</a></code>,
<code><a href="#topic+ProbAverageWeightedVoting">ProbAverageWeightedVoting</a></code>, <code><a href="#topic+ProbBasedMethodology">ProbBasedMethodology</a></code>
</p>

<hr>
<h2 id='ClusterPredictions'>Manages the predictions achieved on a cluster.</h2><span id='topic+ClusterPredictions'></span>

<h3>Description</h3>

<p>Stores the predictions achieved by the best M.L. of each cluster.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ClusterPredictions-new"><code>ClusterPredictions$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ClusterPredictions-add"><code>ClusterPredictions$add()</code></a>
</p>
</li>
<li> <p><a href="#method-ClusterPredictions-get"><code>ClusterPredictions$get()</code></a>
</p>
</li>
<li> <p><a href="#method-ClusterPredictions-getAll"><code>ClusterPredictions$getAll()</code></a>
</p>
</li>
<li> <p><a href="#method-ClusterPredictions-size"><code>ClusterPredictions$size()</code></a>
</p>
</li>
<li> <p><a href="#method-ClusterPredictions-getPositiveClass"><code>ClusterPredictions$getPositiveClass()</code></a>
</p>
</li>
<li> <p><a href="#method-ClusterPredictions-getClassValues"><code>ClusterPredictions$getClassValues()</code></a>
</p>
</li>
<li> <p><a href="#method-ClusterPredictions-clone"><code>ClusterPredictions$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ClusterPredictions-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$new(class.values, positive.class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing the values of
the target class.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the positive
class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClusterPredictions-add"></a>



<h4>Method <code>add()</code></h4>

<p>The function is used to add the prediction achieved by a
specific M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$add(prediction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prediction</code></dt><dd><p>A <code><a href="#topic+Prediction">Prediction</a></code> object containing the
computed predictions.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ClusterPredictions-get"></a>



<h4>Method <code>get()</code></h4>

<p>The function returns the predictions placed at specific
position.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$get(position)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>position</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value indicating the position of the
predictions to be obtained.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+Prediction">Prediction</a></code> object.
</p>


<hr>
<a id="method-ClusterPredictions-getAll"></a>



<h4>Method <code>getAll()</code></h4>

<p>The function returns all the predictions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$getAll()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> containing all computed predictions.
</p>


<hr>
<a id="method-ClusterPredictions-size"></a>



<h4>Method <code>size()</code></h4>

<p>The function returns the number of computed predictions.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$size()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value.
</p>


<hr>
<a id="method-ClusterPredictions-getPositiveClass"></a>



<h4>Method <code>getPositiveClass()</code></h4>

<p>The function gets the value of the positive class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$getPositiveClass()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of size 1.
</p>


<hr>
<a id="method-ClusterPredictions-getClassValues"></a>



<h4>Method <code>getClassValues()</code></h4>

<p>The function returns all the values of the target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$getClassValues()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector containing all target values.
</p>


<hr>
<a id="method-ClusterPredictions-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ClusterPredictions$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+Prediction">Prediction</a></code>
</p>

<hr>
<h2 id='CombinedMetrics'>Abstract class to compute the class prediction based on combination
between metrics.</h2><span id='topic+CombinedMetrics'></span>

<h3>Description</h3>

<p>Abstract class used as a template to define new customized
strategies to combine the class predictions made by different metrics.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CombinedMetrics-new"><code>CombinedMetrics$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedMetrics-getRequiredMetrics"><code>CombinedMetrics$getRequiredMetrics()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedMetrics-getFinalPrediction"><code>CombinedMetrics$getFinalPrediction()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedMetrics-clone"><code>CombinedMetrics$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CombinedMetrics-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedMetrics$new(required.metrics)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>required.metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector of length greater than
2 with the name of the required metrics.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CombinedMetrics-getRequiredMetrics"></a>



<h4>Method <code>getRequiredMetrics()</code></h4>

<p>The function returns the required metrics that will
participate in the combined metric process.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedMetrics$getRequiredMetrics()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length greater than 2 with the name
of the required metrics.
</p>


<hr>
<a id="method-CombinedMetrics-getFinalPrediction"></a>



<h4>Method <code>getFinalPrediction()</code></h4>

<p>Function used to implement the strategy to obtain the final
prediction based on different metrics.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedMetrics$getFinalPrediction(
  raw.pred,
  prob.pred,
  positive.class,
  negative.class
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw.pred</code></dt><dd><p>A <a href="base.html#topic+character">character</a> list of length greater than 2 with the
class value of the predictions made by the metrics.</p>
</dd>
<dt><code>prob.pred</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> list of length greater than 2 with the
probability of the predictions made by the metrics.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the positive
class.</p>
</dd>
<dt><code>negative.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the negative
class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value indicating if the instance is predicted as
positive class or not.
</p>


<hr>
<a id="method-CombinedMetrics-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedMetrics$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+CombinedVoting">CombinedVoting</a></code>
</p>

<hr>
<h2 id='CombinedVoting'>Implementation of Combined Voting.</h2><span id='topic+CombinedVoting'></span>

<h3>Description</h3>

<p>Calculates the final prediction by performing the result of the
predictions of different metrics obtained through a <code><a href="#topic+SimpleVoting">SimpleVoting</a></code>
class.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+VotingStrategy">D2MCS::VotingStrategy</a></code> -&gt; <code>CombinedVoting</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CombinedVoting-new"><code>CombinedVoting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedVoting-getCombinedMetrics"><code>CombinedVoting$getCombinedMetrics()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedVoting-getMethodology"><code>CombinedVoting$getMethodology()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedVoting-getFinalPred"><code>CombinedVoting$getFinalPred()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedVoting-execute"><code>CombinedVoting$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-CombinedVoting-clone"><code>CombinedVoting$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="VotingStrategy" data-id="getMetrics"><a href='../../D2MCS/html/VotingStrategy.html#method-VotingStrategy-getMetrics'><code>D2MCS::VotingStrategy$getMetrics()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="VotingStrategy" data-id="getName"><a href='../../D2MCS/html/VotingStrategy.html#method-VotingStrategy-getName'><code>D2MCS::VotingStrategy$getName()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="VotingStrategy" data-id="getVotingSchemes"><a href='../../D2MCS/html/VotingStrategy.html#method-VotingStrategy-getVotingSchemes'><code>D2MCS::VotingStrategy$getVotingSchemes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CombinedVoting-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedVoting$new(voting.schemes, combined.metrics, methodology, metrics)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>voting.schemes</code></dt><dd><p>A <a href="base.html#topic+list">list</a> of elements inherited from
<code><a href="#topic+SimpleVoting">SimpleVoting</a></code>.</p>
</dd>
<dt><code>combined.metrics</code></dt><dd><p>An object defining the metrics used to combine
the voting schemes. The object must inherit from
<code><a href="#topic+CombinedMetrics">CombinedMetrics</a></code> class.</p>
</dd>
<dt><code>methodology</code></dt><dd><p>An object specifying the methodology used to execute
the combined voting. Object inherited from <code><a href="#topic+Methodology">Methodology</a></code>
object</p>
</dd>
<dt><code>metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the
metrics used to perform the combined voting operations. Metrics should be
previously defined during training stage.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CombinedVoting-getCombinedMetrics"></a>



<h4>Method <code>getCombinedMetrics()</code></h4>

<p>The function returns the metrics used to combine the metrics
results.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedVoting$getCombinedMetrics()</pre></div>



<h5>Returns</h5>

<p>An object inherited from <code><a href="#topic+CombinedMetrics">CombinedMetrics</a></code> class.
</p>


<hr>
<a id="method-CombinedVoting-getMethodology"></a>



<h4>Method <code>getMethodology()</code></h4>

<p>The function gets the methodology used to execute the
combined votings.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedVoting$getMethodology()</pre></div>



<h5>Returns</h5>

<p>An object inherited from <code><a href="#topic+Methodology">Methodology</a></code> class.
</p>


<hr>
<a id="method-CombinedVoting-getFinalPred"></a>



<h4>Method <code>getFinalPred()</code></h4>

<p>The function returns the predictions obtained after
executing the combined-voting methodology.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedVoting$getFinalPred(type = NULL, target = NULL, filter = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A <a href="base.html#topic+character">character</a> to define which type of predictions
should be returned. If not defined all type of probabilities will be
returned. Conversely if &quot;prob&quot; or &quot;raw&quot; is defined then computed
'probabilistic' or 'class' values are returned.</p>
</dd>
<dt><code>target</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the
positive class.</p>
</dd>
<dt><code>filter</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value used to specify if only predictions
matching the target value should be returned or not. If <a href="base.html#topic+TRUE">TRUE</a> the
function returns only the predictions matching the target value.
Conversely if <a href="base.html#topic+FALSE">FALSE</a> (by default) the function returns all the
predictions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> with the computed predictions.
</p>


<hr>
<a id="method-CombinedVoting-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function implements the combined voting scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedVoting$execute(predictions, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
the predictions computed for each cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CombinedVoting-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CombinedVoting$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+ClassMajorityVoting">ClassMajorityVoting</a></code>,
<code><a href="#topic+ClassWeightedVoting">ClassWeightedVoting</a></code>, <code><a href="#topic+ProbAverageVoting">ProbAverageVoting</a></code>,
<code><a href="#topic+ProbAverageWeightedVoting">ProbAverageWeightedVoting</a></code>, <code><a href="#topic+ProbBasedMethodology">ProbBasedMethodology</a></code>,
<code><a href="#topic+SimpleVoting">SimpleVoting</a></code>
</p>

<hr>
<h2 id='ConfMatrix'>Confusion matrix wrapper.</h2><span id='topic+ConfMatrix'></span>

<h3>Description</h3>

<p>Creates a <code><a href="R6.html#topic+R6">R6</a></code> confusion matrix from the
<code><a href="caret.html#topic+confusionMatrix">confusionMatrix</a></code> caret package.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ConfMatrix-new"><code>ConfMatrix$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-getConfusionMatrix"><code>ConfMatrix$getConfusionMatrix()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-getTP"><code>ConfMatrix$getTP()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-getTN"><code>ConfMatrix$getTN()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-getFN"><code>ConfMatrix$getFN()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-getFP"><code>ConfMatrix$getFP()</code></a>
</p>
</li>
<li> <p><a href="#method-ConfMatrix-clone"><code>ConfMatrix$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ConfMatrix-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method to create a confusion matrix object from a
<code>caret</code> <code><a href="caret.html#topic+confusionMatrix">confusionMatrix</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$new(confMatrix)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>confMatrix</code></dt><dd><p>A <code>caret</code> <a href="caret.html#topic+confusionMatrix">confusionMatrix</a> argument.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ConfMatrix-getConfusionMatrix"></a>



<h4>Method <code>getConfusionMatrix()</code></h4>

<p>The function obtains the <code><a href="caret.html#topic+confusionMatrix">confusionMatrix</a></code>
following the same structured as defined in the <code>caret</code> package
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$getConfusionMatrix()</pre></div>



<h5>Returns</h5>

<p>A <code><a href="caret.html#topic+confusionMatrix">confusionMatrix</a></code> object.
</p>


<hr>
<a id="method-ConfMatrix-getTP"></a>



<h4>Method <code>getTP()</code></h4>

<p>The function is used to compute the number of True Positive
values achieved.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$getTP()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1.
</p>


<hr>
<a id="method-ConfMatrix-getTN"></a>



<h4>Method <code>getTN()</code></h4>

<p>The function computes the True Negative values.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$getTN()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1.
</p>


<hr>
<a id="method-ConfMatrix-getFN"></a>



<h4>Method <code>getFN()</code></h4>

<p>The function returns the number of Type II errors
(False Negative).
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$getFN()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1.
</p>


<hr>
<a id="method-ConfMatrix-getFP"></a>



<h4>Method <code>getFP()</code></h4>

<p>The function returns the number of Type I errors
(False Negative).
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$getFP()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1.
</p>


<hr>
<a id="method-ConfMatrix-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ConfMatrix$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+MeasureFunction">MeasureFunction</a></code>,
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>
</p>

<hr>
<h2 id='D2MCS'>Data Driven Multiple Classifier System.</h2><span id='topic+D2MCS'></span>

<h3>Description</h3>

<p>The class is responsible of managing the whole process.
Concretely builds the M.L. models (optimizes models hyperparameters), selects
the best M.L. model for each cluster and executes the classification stage.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-D2MCS-new"><code>D2MCS$new()</code></a>
</p>
</li>
<li> <p><a href="#method-D2MCS-train"><code>D2MCS$train()</code></a>
</p>
</li>
<li> <p><a href="#method-D2MCS-classify"><code>D2MCS$classify()</code></a>
</p>
</li>
<li> <p><a href="#method-D2MCS-getAvailableModels"><code>D2MCS$getAvailableModels()</code></a>
</p>
</li>
<li> <p><a href="#method-D2MCS-clone"><code>D2MCS$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-D2MCS-new"></a>



<h4>Method <code>new()</code></h4>

<p>The function is used to initialize all parameters needed
to build a Multiple Classifier System.
</p>


<h5>Usage</h5>

<div class="r"><pre>D2MCS$new(
  dir.path,
  num.cores = NULL,
  socket.type = "PSOCK",
  outfile = NULL,
  serialize = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining location were the
trained models should be saved.</p>
</dd>
<dt><code>num.cores</code></dt><dd><p>An optional <a href="base.html#topic+numeric">numeric</a> value specifying
the number of CPU cores used for training the models (only if
parallelization is allowed). If not defined (num.cores - 2) cores will be
used.</p>
</dd>
<dt><code>socket.type</code></dt><dd><p>A <a href="base.html#topic+character">character</a> value defining the type of socket
used to communicate the workers. The default type, <code>"PSOCK"</code>, calls
makePSOCKcluster. Type <code>"FORK"</code> calls makeForkCluster. For more
information see <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code></p>
</dd>
<dt><code>outfile</code></dt><dd><p>Where to direct the stdout and stderr connection output
from the workers. &quot;&quot; indicates no redirection (which may only be useful
for workers on the local machine). Defaults to '/dev/null'</p>
</dd>
<dt><code>serialize</code></dt><dd><p>A <code><a href="base.html#topic+logical">logical</a></code> value. If <a href="base.html#topic+TRUE">TRUE</a> (default)
serialization will use XDR: where large amounts of data are to be
transferred and all the nodes are little-endian, communication may be
substantially faster if this is set to false.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-D2MCS-train"></a>



<h4>Method <code>train()</code></h4>

<p>The function is responsible of performing the M.L. model
training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>D2MCS$train(
  train.set,
  train.function,
  num.clusters = NULL,
  model.recipe = DefaultModelFit$new(),
  ex.classifiers = c(),
  ig.classifiers = c(),
  metrics = NULL,
  saveAllModels = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>train.set</code></dt><dd><p>A <code><a href="#topic+Trainset">Trainset</a></code> object used as training input
for the M.L. models</p>
</dd>
<dt><code>train.function</code></dt><dd><p>A <code><a href="#topic+TrainFunction">TrainFunction</a></code> defining the training
configuration options.</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>An <a href="base.html#topic+numeric">numeric</a> value used to define the number of
clusters from the <code><a href="#topic+Trainset">Trainset</a></code> that should be utilized during
the training stage. If not defined all clusters will we taken into
account for training.</p>
</dd>
<dt><code>model.recipe</code></dt><dd><p>An unprepared recipe object inherited from
<code><a href="#topic+GenericModelFit">GenericModelFit</a></code> class.</p>
</dd>
<dt><code>ex.classifiers</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing the name of
the M.L. models used in training stage. See
<code><a href="caret.html#topic+getModelInfo">getModelInfo</a></code> and
<a href="https://topepo.github.io/caret/available-models.html">https://topepo.github.io/caret/available-models.html</a> for more
information about all the available models.</p>
</dd>
<dt><code>ig.classifiers</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing the name of
the M.L. that should be ignored when performing the training stage. See
<code><a href="caret.html#topic+getModelInfo">getModelInfo</a></code> and
<a href="https://topepo.github.io/caret/available-models.html">https://topepo.github.io/caret/available-models.html</a> for more
information about all the available models.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing the metrics used to
perform the M.L. model hyperparameter optimization during the training
stage. See <code><a href="#topic+SummaryFunction">SummaryFunction</a></code>, <code><a href="#topic+UseProbability">UseProbability</a></code>
and <code><a href="#topic+NoProbability">NoProbability</a></code> for more information.</p>
</dd>
<dt><code>saveAllModels</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> parameter. A <a href="base.html#topic+TRUE">TRUE</a> saves all
trained models while A <a href="base.html#topic+FALSE">FALSE</a> saves only the M.L. model achieving
the best performance on each cluster.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+TrainOutput">TrainOutput</a></code> object containing all the information
computed during the training stage.
</p>


<hr>
<a id="method-D2MCS-classify"></a>



<h4>Method <code>classify()</code></h4>

<p>The function is responsible for executing the classification
stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>D2MCS$classify(train.output, subset, voting.types, positive.class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>train.output</code></dt><dd><p>The <code><a href="#topic+TrainOutput">TrainOutput</a></code> object computed in the
train stage.</p>
</dd>
<dt><code>subset</code></dt><dd><p>A <code><a href="#topic+Subset">Subset</a></code> containing the data to be classified.</p>
</dd>
<dt><code>voting.types</code></dt><dd><p>A <a href="base.html#topic+list">list</a> containing <code><a href="#topic+SingleVoting">SingleVoting</a></code>
or <code><a href="#topic+CombinedVoting">CombinedVoting</a></code> objects.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> parameter used
to define the positive class value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> with all the values computed
during classification stage.
</p>


<hr>
<a id="method-D2MCS-getAvailableModels"></a>



<h4>Method <code>getAvailableModels()</code></h4>

<p>The function obtains all the available M.L. models.
</p>


<h5>Usage</h5>

<div class="r"><pre>D2MCS$getAvailableModels()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> containing the information of the available
M.L. models.
</p>


<hr>
<a id="method-D2MCS-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>D2MCS$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="#topic+Subset">Subset</a></code>, <code><a href="#topic+Trainset">Trainset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Specify the random number generation
set.seed(1234)

## Create Dataset Handler object.
loader &lt;- DatasetLoader$new()

## Load 'hcc-data-complete-balanced.csv' dataset file.
data &lt;- loader$load(filepath = system.file(file.path("examples",
                                                     "hcc-data-complete-balanced.csv"),
                                           package = "D2MCS"),
                    header = TRUE, normalize.names = TRUE)
## Get column names
data$getColumnNames()

## Split data into 4 partitions keeping balance ratio of 'Class' column.
data$createPartitions(num.folds = 4, class.balance = "Class")

## Create a subset comprising the first 2 partitions for clustering purposes.
cluster.subset &lt;- data$createSubset(num.folds = c(1, 2), class.index = "Class",
                                    positive.class = "1")

## Create a subset comprising second and third partitions for trainning purposes.
train.subset &lt;- data$createSubset(num.folds = c(2, 3), class.index = "Class",
                                  positive.class = "1")

## Create a subset comprising last partitions for testing purposes.
test.subset &lt;- data$createSubset(num.folds = 4, class.index = "Class",
                                 positive.class = "1")

## Distribute the features into clusters using MCC heuristic.
distribution &lt;- SimpleStrategy$new(subset = cluster.subset,
                                   heuristic = MCCHeuristic$new())
distribution$execute()

## Get the best achieved distribution
distribution$getBestClusterDistribution()

## Create a train set from the computed clustering distribution
train.set &lt;- distribution$createTrain(subset = train.subset)

## Not run: 

## Initialization of D2MCS configuration parameters.
##  - Defining training operation.
##    + 10-fold cross-validation
##    + Use only 1 CPU core.
##    + Seed was set to ensure straightforward reproductivity of experiments.
trFunction &lt;- TwoClass$new(method = "cv", number = 10, savePredictions = "final",
                           classProbs = TRUE, allowParallel = TRUE,
                           verboseIter = FALSE, seed = 1234)

#' ## - Specify the models to be trained
ex.classifiers &lt;- c("ranger", "lda", "lda2")

## Initialize D2MCS
#' d2mcs &lt;- D2MCS$new(dir.path = tempdir(),
                      num.cores = 1)

## Execute training stage for using 'MCC' and 'PPV' measures to optimize model hyperparameters.
trained.models &lt;- d2mcs$train(train.set = train.set,
                              train.function = trFunction,
                              ex.classifiers = ex.classifiers,
                              metrics = c("MCC", "PPV"))

## Execute classification stage using two different voting schemes
predictions &lt;- d2mcs$classify(train.output = trained.models,
                              subset = test.subset,
                              voting.types = c(
                                    SingleVoting$new(voting.schemes = c(ClassMajorityVoting$new(),
                                                                        ClassWeightedVoting$new()),
                                                     metrics = c("MCC", "PPV"))))

## Compute the performance of each voting scheme using PPV and MMC measures.
predictions$getPerformances(test.subset, measures = list(MCC$new(), PPV$new()))

## Execute classification stage using multiple voting schemes (simple and combined)
predictions &lt;- d2mcs$classify(train.output = trained.models,
                              subset = test.subset,
                              voting.types = c(
                                    SingleVoting$new(voting.schemes = c(ClassMajorityVoting$new(),
                                                                         ClassWeightedVoting$new()),
                                                      metrics = c("MCC", "PPV")),
                                    CombinedVoting$new(voting.schemes = ClassMajorityVoting$new(),
                                                        combined.metrics = MinimizeFP$new(),
                                                        methodology = ProbBasedMethodology$new(),
                                                        metrics = c("MCC", "PPV"))))

## Compute the performance of each voting scheme using PPV and MMC measures.
predictions$getPerformances(test.subset, measures = list(MCC$new(), PPV$new()))

## End(Not run)


</code></pre>

<hr>
<h2 id='Dataset'>Simple Dataset handler.</h2><span id='topic+Dataset'></span>

<h3>Description</h3>

<p>Creates a valid simple dataset object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Dataset-new"><code>Dataset$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-getColumnNames"><code>Dataset$getColumnNames()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-getDataset"><code>Dataset$getDataset()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-getNcol"><code>Dataset$getNcol()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-getNrow"><code>Dataset$getNrow()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-getRemovedColumns"><code>Dataset$getRemovedColumns()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-cleanData"><code>Dataset$cleanData()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-removeColumns"><code>Dataset$removeColumns()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-createPartitions"><code>Dataset$createPartitions()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-createSubset"><code>Dataset$createSubset()</code></a>
</p>
</li>
<li> <p><a href="#method-Dataset-createTrain"><code>Dataset$createTrain()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Dataset-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$new(
  filepath,
  header = TRUE,
  sep = ",",
  skip = 0,
  normalize.names = FALSE,
  string.as.factor = FALSE,
  ignore.columns = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filepath</code></dt><dd><p>The name of the file which the data are to be read from.
Each row of the table appears as one line of the file. If it does not
contain an _absolute_ path, the file name is _relative_ to the current
working directory, '<code>getwd()</code>'.</p>
</dd>
<dt><code>header</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether the file contains
the names of the variables as its first line. If missing, the value is
determined from the file format: '<code>header</code>' is set to '<a href="base.html#topic+TRUE">TRUE</a>'
if and only if the first row contains one fewer field than the number of
columns.</p>
</dd>
<dt><code>sep</code></dt><dd><p>The field separator character. Values on each line of the file
are separated by this character.</p>
</dd>
<dt><code>skip</code></dt><dd><p>Defines the number of header lines should be skipped.</p>
</dd>
<dt><code>normalize.names</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether the
columns names should be automatically renamed to ensure R compatibility.</p>
</dd>
<dt><code>string.as.factor</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating if character
columns should be converted to factors (<code>default = FALSE</code>).</p>
</dd>
<dt><code>ignore.columns</code></dt><dd><p>Specify the columns from the input file that should
be ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dataset-getColumnNames"></a>



<h4>Method <code>getColumnNames()</code></h4>

<p>Get the name of the columns comprising the dataset.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$getColumnNames()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with the name of each column.
</p>


<hr>
<a id="method-Dataset-getDataset"></a>



<h4>Method <code>getDataset()</code></h4>

<p>Gets the full dataset.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$getDataset()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> with all the loaded information.
</p>


<hr>
<a id="method-Dataset-getNcol"></a>



<h4>Method <code>getNcol()</code></h4>

<p>Obtains the number of columns present in the dataset.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$getNcol()</pre></div>



<h5>Returns</h5>

<p>An <a href="base.html#topic+integer">integer</a> of length 1 or <a href="base.html#topic+NULL">NULL</a>
</p>


<hr>
<a id="method-Dataset-getNrow"></a>



<h4>Method <code>getNrow()</code></h4>

<p>Obtains the number of rows present in the dataset.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$getNrow()</pre></div>



<h5>Returns</h5>

<p>An <a href="base.html#topic+integer">integer</a> of length 1 or <a href="base.html#topic+NULL">NULL</a>
</p>


<hr>
<a id="method-Dataset-getRemovedColumns"></a>



<h4>Method <code>getRemovedColumns()</code></h4>

<p>Get the columns removed or ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$getRemovedColumns()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> containing the name of the removed columns.
</p>


<hr>
<a id="method-Dataset-cleanData"></a>



<h4>Method <code>cleanData()</code></h4>

<p>Removes <a href="base.html#topic+data.frame">data.frame</a> columns matching some criterion.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$cleanData(remove.funcs = NULL, remove.na = TRUE, remove.const = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>remove.funcs</code></dt><dd><p>A vector of functions use to define which columns
must be removed.</p>
</dd>
<dt><code>remove.na</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether <a href="base.html#topic+NA">NA</a>
values should be removed.</p>
</dd>
<dt><code>remove.const</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value used to indicate if constant
values should be removed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dataset-removeColumns"></a>



<h4>Method <code>removeColumns()</code></h4>

<p>Applies <code>cleanData</code> function over an specific set of
columns.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$removeColumns(
  columns,
  remove.funcs = NULL,
  remove.na = FALSE,
  remove.const = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>columns</code></dt><dd><p>Set of columns (<a href="base.html#topic+numeric">numeric</a> or <a href="base.html#topic+character">character</a>) where
removal operation should be applied.</p>
</dd>
<dt><code>remove.funcs</code></dt><dd><p>A vector of functions use to define which columns
must be removed.</p>
</dd>
<dt><code>remove.na</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether
<code><a href="base.html#topic+NA">NA</a></code> values should be removed.</p>
</dd>
<dt><code>remove.const</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value used to indicate if constant
values should be removed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dataset-createPartitions"></a>



<h4>Method <code>createPartitions()</code></h4>

<p>Creates a k-folds partition from the initial dataset.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$createPartitions(
  num.folds = NULL,
  percent.folds = NULL,
  class.balance = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.folds</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> for the number of folds (partitions)</p>
</dd>
<dt><code>percent.folds</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector with the percentage of
instances containing each fold.</p>
</dd>
<dt><code>class.balance</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating if class balance
should be kept.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Dataset-createSubset"></a>



<h4>Method <code>createSubset()</code></h4>

<p>Creates a <code><a href="#topic+Subset">Subset</a></code> for testing or classification
purposes. A target class should be provided for testing purposes.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$createSubset(
  num.folds = NULL,
  opts = list(remove.na = TRUE, remove.const = FALSE),
  class.index = NULL,
  positive.class = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.folds</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> defining the number of folds that
should we used to build the <a href="#topic+Subset">Subset</a>.</p>
</dd>
<dt><code>opts</code></dt><dd><p>A list with optional parameters. Valid arguments are
<code>remove.na</code> (removes columns with <a href="base.html#topic+NA">NA</a> values) and
<code>remove.const</code> (ignore columns with constant values).</p>
</dd>
<dt><code>class.index</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value identifying the column
representing the target class</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>Defines the positive class value.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="#topic+Subset">Subset</a> object.
</p>


<hr>
<a id="method-Dataset-createTrain"></a>



<h4>Method <code>createTrain()</code></h4>

<p>Creates a set for training purposes. A class should be
defined to guarantee full-compatibility with supervised models.
</p>


<h5>Usage</h5>

<div class="r"><pre>Dataset$createTrain(
  class.index,
  positive.class,
  num.folds = NULL,
  opts = list(remove.na = TRUE, remove.const = FALSE)
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class.index</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value identifying the column
representing the target class</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>Defines the positive class value.</p>
</dd>
<dt><code>num.folds</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> defining the number of folds that
should we used to build the <code><a href="#topic+Subset">Subset</a></code>.</p>
</dd>
<dt><code>opts</code></dt><dd><p>A list with optional parameters. Valid arguments are
<code>remove.na</code> (removes columns with <a href="base.html#topic+NA">NA</a> values) and
<code>remove.const</code> (ignore columns with constant values).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+Trainset">Trainset</a></code> object.
</p>




<h3>See Also</h3>

<p><code><a href="#topic+HDDataset">HDDataset</a></code>
</p>

<hr>
<h2 id='DatasetLoader'>Dataset creation.</h2><span id='topic+DatasetLoader'></span>

<h3>Description</h3>

<p>Wrapper class able to automatically create a
<code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="#topic+HDDataset">HDDataset</a></code> according to the input data.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DatasetLoader-new"><code>DatasetLoader$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DatasetLoader-load"><code>DatasetLoader$load()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DatasetLoader-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>DatasetLoader$new()</pre></div>


<hr>
<a id="method-DatasetLoader-load"></a>



<h4>Method <code>load()</code></h4>

<p>Stores the input source into a <code><a href="#topic+Dataset">Dataset</a></code> or
<code><a href="#topic+HDDataset">HDDataset</a></code> type object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DatasetLoader$load(
  filepath,
  header = TRUE,
  sep = ",",
  skip.lines = 0,
  normalize.names = FALSE,
  string.as.factor = FALSE,
  ignore.columns = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filepath</code></dt><dd><p>The name of the file which the data are to be read from.
Each row of the table appears as one line of the file. If it does not
contain an _absolute_ path, the file name is _relative_ to the current
working directory, '<code>getwd()</code>'.</p>
</dd>
<dt><code>header</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether the file contains
the names of the variables as its first line. If missing, the value is
determined from the file format: '<code>header</code>' is set to '<a href="base.html#topic+TRUE">TRUE</a>'
if and only if the first row contains one fewer field than the number of
columns.</p>
</dd>
<dt><code>sep</code></dt><dd><p>The field separator character. Values on each line of the file
are separated by this character.</p>
</dd>
<dt><code>skip.lines</code></dt><dd><p>Defines the number of header lines should be skipped.</p>
</dd>
<dt><code>normalize.names</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether the
columns names should be automatically renamed to ensure R compatibility.</p>
</dd>
<dt><code>string.as.factor</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating if character
columns should be converted to factors (default = FALSE).</p>
</dd>
<dt><code>ignore.columns</code></dt><dd><p>Specify the columns from the input file that should
be ignored.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+Dataset">Dataset</a></code> or <code><a href="#topic+HDDataset">HDDataset</a></code> object.
</p>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="#topic+HDDataset">HDDataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create Dataset Handler object.
  loader &lt;- DatasetLoader$new()

  # Load input file.
  data &lt;- loader$load(filepath = system.file(file.path("examples",
                                                       "hcc-data-complete-balanced.csv"),
                                             package = "D2MCS"),
                      header = T, normalize.names = T)

## End(Not run)


</code></pre>

<hr>
<h2 id='DefaultModelFit'>Default model fitting implementation.</h2><span id='topic+DefaultModelFit'></span>

<h3>Description</h3>

<p>Creates a default <code><a href="recipes.html#topic+recipe">recipe</a></code> and
<code><a href="stats.html#topic+formula">formula</a></code> objects used in model training stage.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericModelFit">D2MCS::GenericModelFit</a></code> -&gt; <code>DefaultModelFit</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DefaultModelFit-new"><code>DefaultModelFit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DefaultModelFit-createFormula"><code>DefaultModelFit$createFormula()</code></a>
</p>
</li>
<li> <p><a href="#method-DefaultModelFit-createRecipe"><code>DefaultModelFit$createRecipe()</code></a>
</p>
</li>
<li> <p><a href="#method-DefaultModelFit-clone"><code>DefaultModelFit$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DefaultModelFit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>DefaultModelFit$new()</pre></div>


<hr>
<a id="method-DefaultModelFit-createFormula"></a>



<h4>Method <code>createFormula()</code></h4>

<p>The function is responsible of creating a
<code><a href="stats.html#topic+formula">formula</a></code> for M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>DefaultModelFit$createFormula(instances, class.name, simplify = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instances</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> containing the instances used to
create the recipe.</p>
</dd>
<dt><code>class.name</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector representing the name of the
target class.</p>
</dd>
<dt><code>simplify</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> argument defining whether the formula
should be generated as simple as possible.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="stats.html#topic+formula">formula</a></code> object.
</p>


<hr>
<a id="method-DefaultModelFit-createRecipe"></a>



<h4>Method <code>createRecipe()</code></h4>

<p>The function is responsible of creating a
<code><a href="recipes.html#topic+recipe">recipe</a></code> with five operations over the data:
<code><a href="recipes.html#topic+step_zv">step_zv</a></code>, <code><a href="recipes.html#topic+step_nzv">step_nzv</a></code>,
<code><a href="recipes.html#topic+step_corr">step_corr</a></code>, <code><a href="recipes.html#topic+step_center">step_center</a></code>,
<code><a href="recipes.html#topic+step_scale">step_scale</a></code>
</p>


<h5>Usage</h5>

<div class="r"><pre>DefaultModelFit$createRecipe(instances, class.name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instances</code></dt><dd><p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the instances used
to create the recipe.</p>
</dd>
<dt><code>class.name</code></dt><dd><p>A <code><a href="base.html#topic+character">character</a></code> vector representing the name
of the target class.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoked by <code><a href="#topic+D2MCS">D2MCS</a></code>
during model training stage.
</p>



<h5>Returns</h5>

<p>An object of class <code><a href="recipes.html#topic+recipe">recipe</a></code>.
</p>


<hr>
<a id="method-DefaultModelFit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DefaultModelFit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+GenericModelFit">GenericModelFit</a></code>, <code><a href="caret.html#topic+train">train</a></code>
</p>

<hr>
<h2 id='DependencyBasedStrategy'>Clustering strategy based on dependency between features.</h2><span id='topic+DependencyBasedStrategy'></span>

<h3>Description</h3>

<p>Features are distributed according to their independence values.
This strategy is divided into two steps. The first phase focuses on forming
groups with those features most dependent on each other. This step also
identifies those that are independent from all the others in the group.
The second step is to try out different numbers of clusters until you find
the one you think is best. These clusters are formed by inserting in all the
independent characteristics identified previously and trying to distribute
the features of the groups formed in the previous step in separate clusters.
In this way, it seeks to ensure that the features are as independent as
possible from those found in the same cluster.
</p>


<h3>Details</h3>

<p>The strategy is suitable only for binary and real features. Other
features are automatically grouped into a specific cluster named as
'unclustered'. This class requires the <code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code>
type object implements the following methods:
</p>
<p>- <code>getBinaryCutoff()</code>: The function is used to define the interval to
consider the dependency between binary features.
</p>
<p>- <code>getRealCutoff()</code>: The function allows defining the cutoff to consider
the dependency between real features.
</p>
<p>- <code>tiebreak(feature, clus.candidates, fea.dep.dist.clus, corpus,
heuristic, class, class.name)</code>: The function solves the ties between two
(or more) features.
</p>
<p>- <code>qualityOfCluster(clusters, metrics)</code>: The function determines the
quality of a cluster
</p>
<p>- <code>isImprovingClustering(clusters.deltha)</code>: The function indicates if
clustering is getting better as the number of them increases.
</p>
<p>An example of implementation with the description of each parameter is the
<code><a href="#topic+DependencyBasedStrategyConfiguration">DependencyBasedStrategyConfiguration</a></code> class.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClusteringStrategy">D2MCS::GenericClusteringStrategy</a></code> -&gt; <code>DependencyBasedStrategy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DependencyBasedStrategy-new"><code>DependencyBasedStrategy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategy-execute"><code>DependencyBasedStrategy$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategy-getDistribution"><code>DependencyBasedStrategy$getDistribution()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategy-createTrain"><code>DependencyBasedStrategy$createTrain()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategy-plot"><code>DependencyBasedStrategy$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategy-saveCSV"><code>DependencyBasedStrategy$saveCSV()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategy-clone"><code>DependencyBasedStrategy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getBestClusterDistribution"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getBestClusterDistribution'><code>D2MCS::GenericClusteringStrategy$getBestClusterDistribution()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getConfiguration"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getConfiguration'><code>D2MCS::GenericClusteringStrategy$getConfiguration()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getDescription"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getDescription'><code>D2MCS::GenericClusteringStrategy$getDescription()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getHeuristic"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getHeuristic'><code>D2MCS::GenericClusteringStrategy$getHeuristic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getUnclustered"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getUnclustered'><code>D2MCS::GenericClusteringStrategy$getUnclustered()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DependencyBasedStrategy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object parameters during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategy$new(
  subset,
  heuristic,
  configuration = DependencyBasedStrategyConfiguration$new()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>The <code><a href="#topic+Subset">Subset</a></code> used to apply the feature-clustering
strategy.</p>
</dd>
<dt><code>heuristic</code></dt><dd><p>The heuristic used to compute the relevance of each
feature. Must inherit from <code><a href="#topic+GenericHeuristic">GenericHeuristic</a></code> abstract class.</p>
</dd>
<dt><code>configuration</code></dt><dd><p>optional parameter to customize configuration
parameters for the strategy. Must inherited from
<code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code> abstract class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategy-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Function responsible of performing the dependency-based
feature clustering strategy over the defined <code><a href="#topic+Subset">Subset</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategy$execute(verbose = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategy-getDistribution"></a>



<h4>Method <code>getDistribution()</code></h4>

<p>Function used to obtain a specific cluster distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategy$getDistribution(
  num.clusters = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.clusters</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> with the features comprising an specific
clustering distribution.
</p>


<hr>
<a id="method-DependencyBasedStrategy-createTrain"></a>



<h4>Method <code>createTrain()</code></h4>

<p>The function is used to create a <code><a href="#topic+Trainset">Trainset</a></code>
object from a specific clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategy$createTrain(
  subset,
  num.clusters = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>The <code><a href="#topic+Subset">Subset</a></code> object used as a basis to create
the train set (see <code><a href="#topic+Trainset">Trainset</a></code> class).</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If <code>num.clusters</code> and <code>num.groups</code> are not defined,
best clustering distribution is used to create the train set.
</p>


<hr>
<a id="method-DependencyBasedStrategy-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>The function is responsible for creating a plot to visualize
the clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategy$plot(dir.path = NULL, file.name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>An optional argument to define the name of the directory
where the exported plot will be saved. If not defined, the file path will
be automatically assigned to the current working directory,
'<code>getwd()</code>'.</p>
</dd>
<dt><code>file.name</code></dt><dd><p>A character to define the name of the PDF file where the
plot is exported.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategy-saveCSV"></a>



<h4>Method <code>saveCSV()</code></h4>

<p>The function is used to save the clustering distribution to
a CSV file.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategy$saveCSV(
  dir.path = NULL,
  name = NULL,
  num.clusters = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The name of the directory to save the CSV file.</p>
</dd>
<dt><code>name</code></dt><dd><p>Defines the name of the CSV file.</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>An optional parameter to select the number of
clusters to be saved. If not defined, all cluster distributions will be
saved.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a></code>,
<code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code>,
<code><a href="#topic+DependencyBasedStrategyConfiguration">DependencyBasedStrategyConfiguration</a></code>
</p>

<hr>
<h2 id='DependencyBasedStrategyConfiguration'>Custom Strategy Configuration handler for the DependencyBasedStrategy
strategy.</h2><span id='topic+DependencyBasedStrategyConfiguration'></span>

<h3>Description</h3>

<p>Define the default configuration parameters for the
<a href="#topic+DependencyBasedStrategy">DependencyBasedStrategy</a> strategy.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+StrategyConfiguration">D2MCS::StrategyConfiguration</a></code> -&gt; <code>DependencyBasedStrategyConfiguration</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-new"><code>DependencyBasedStrategyConfiguration$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-minNumClusters"><code>DependencyBasedStrategyConfiguration$minNumClusters()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-maxNumClusters"><code>DependencyBasedStrategyConfiguration$maxNumClusters()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-getBinaryCutoff"><code>DependencyBasedStrategyConfiguration$getBinaryCutoff()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-getRealCutoff"><code>DependencyBasedStrategyConfiguration$getRealCutoff()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-setBinaryCutoff"><code>DependencyBasedStrategyConfiguration$setBinaryCutoff()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-setRealCutoff"><code>DependencyBasedStrategyConfiguration$setRealCutoff()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-tiebreak"><code>DependencyBasedStrategyConfiguration$tiebreak()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-qualityOfCluster"><code>DependencyBasedStrategyConfiguration$qualityOfCluster()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-isImprovingClustering"><code>DependencyBasedStrategyConfiguration$isImprovingClustering()</code></a>
</p>
</li>
<li> <p><a href="#method-DependencyBasedStrategyConfiguration-clone"><code>DependencyBasedStrategyConfiguration$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$new(
  binaryCutoff = 0.6,
  realCutoff = 0.6,
  tiebreakMethod = "lfdc",
  metric = "dep.tar"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>binaryCutoff</code></dt><dd><p>The <a href="base.html#topic+numeric">numeric</a> value of binary cutoff.</p>
</dd>
<dt><code>realCutoff</code></dt><dd><p>The <a href="base.html#topic+numeric">numeric</a> value of real cutoff.</p>
</dd>
<dt><code>tiebreakMethod</code></dt><dd><p>The <a href="base.html#topic+character">character</a> value of tie-break method. The
two tiebreak methods available are &quot;lfdc&quot; (less dependence cluster with
the features) and &quot;ltdc&quot; (less dependence cluster with the target). These
methods are used to add the features in the candidate feature clusters.</p>
</dd>
<dt><code>metric</code></dt><dd><p>The <a href="base.html#topic+character">character</a> value of the metric to apply the mean
to obtain the quality of a cluster. The two metrics available are
&quot;dep.tar&quot; (Dependence of cluster features on the target) and &quot;dep.fea&quot;
(Dependence between cluster features).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-minNumClusters"></a>



<h4>Method <code>minNumClusters()</code></h4>

<p>Function used to return the minimum number of clusters
distributions used. By default the minimum is set in 2.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$minNumClusters(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>minNumClusters</code>
function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1.
</p>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-maxNumClusters"></a>



<h4>Method <code>maxNumClusters()</code></h4>

<p>The function is responsible of returning the maximum number
of cluster distributions used. By default the maximum number is set in 50.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$maxNumClusters(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>maxNumClusters</code>
function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1.
</p>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-getBinaryCutoff"></a>



<h4>Method <code>getBinaryCutoff()</code></h4>

<p>Gets the cutoff to consider the dependency between binary
features.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$getBinaryCutoff()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+numeric">numeric</a> value of binary cutoff.
</p>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-getRealCutoff"></a>



<h4>Method <code>getRealCutoff()</code></h4>

<p>Gets the cutoff to consider the dependency between real
features.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$getRealCutoff()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+numeric">numeric</a> value of real cutoff.
</p>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-setBinaryCutoff"></a>



<h4>Method <code>setBinaryCutoff()</code></h4>

<p>Sets the cutoff to consider the dependency between binary
features.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$setBinaryCutoff(cutoff)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cutoff</code></dt><dd><p>The new <a href="base.html#topic+numeric">numeric</a> value of binary cutoff.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-setRealCutoff"></a>



<h4>Method <code>setRealCutoff()</code></h4>

<p>Sets the cutoff to consider the dependency between real
features.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$setRealCutoff(cutoff)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cutoff</code></dt><dd><p>The new <a href="base.html#topic+numeric">numeric</a> value of real cutoff.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-tiebreak"></a>



<h4>Method <code>tiebreak()</code></h4>

<p>The function solves the ties between two (or more) features.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$tiebreak(
  feature,
  clus.candidates,
  fea.dep.dist.clus,
  corpus,
  heuristic,
  class,
  class.name
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>feature</code></dt><dd><p>A <a href="base.html#topic+character">character</a> containing the name of the feature</p>
</dd>
<dt><code>clus.candidates</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to
identify the candidate groups to insert the feature.</p>
</dd>
<dt><code>fea.dep.dist.clus</code></dt><dd><p>A <a href="base.html#topic+list">list</a> containing the groups chosen for
the features.</p>
</dd>
<dt><code>corpus</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> containing the features of the initial
data.</p>
</dd>
<dt><code>heuristic</code></dt><dd><p>The heuristic used to compute the relevance of each
feature. Must inherit from <a href="#topic+GenericHeuristic">GenericHeuristic</a> abstract class.</p>
</dd>
<dt><code>class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing all the values of the
target class.</p>
</dd>
<dt><code>class.name</code></dt><dd><p>A <a href="base.html#topic+character">character</a> value representing the name of the
target class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-qualityOfCluster"></a>



<h4>Method <code>qualityOfCluster()</code></h4>

<p>The function determines the quality of a cluster.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$qualityOfCluster(clusters, metrics)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clusters</code></dt><dd><p>A <a href="base.html#topic+list">list</a> with the feature distribution of each
cluster.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>A numeric <a href="base.html#topic+list">list</a> with the metrics associated to the
cluster (dependency between all features and dependency between the
features and the class).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1.
</p>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-isImprovingClustering"></a>



<h4>Method <code>isImprovingClustering()</code></h4>

<p>The function indicates if clustering is getting better as
the number of them increases.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$isImprovingClustering(clusters.deltha)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>clusters.deltha</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector value with the quality
values of the built clusters.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1.
</p>


<hr>
<a id="method-DependencyBasedStrategyConfiguration-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DependencyBasedStrategyConfiguration$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code>,
<code><a href="#topic+DependencyBasedStrategy">DependencyBasedStrategy</a></code>
</p>

<hr>
<h2 id='DIterator'>Iterator over a Subset object</h2><span id='topic+DIterator'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+DIterator">DIterator</a></code> object to iterate over the
<code><a href="#topic+Subset">Subset</a></code>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DIterator-new"><code>DIterator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-DIterator-getNext"><code>DIterator$getNext()</code></a>
</p>
</li>
<li> <p><a href="#method-DIterator-isLast"><code>DIterator$isLast()</code></a>
</p>
</li>
<li> <p><a href="#method-DIterator-finalize"><code>DIterator$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-DIterator-clone"><code>DIterator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-DIterator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>DIterator$new(data, chunk.size, verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> structure to be iterated.</p>
</dd>
<dt><code>chunk.size</code></dt><dd><p>An <a href="base.html#topic+integer">integer</a> value indicating the size of chunks
taken over each iteration. By default <code>chunk.size</code> is defined as
10000.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DIterator-getNext"></a>



<h4>Method <code>getNext()</code></h4>

<p>Gets the next chunk of data. Each iteration returns the same
instances (data.frame rows) as chunk.size. However, if remaining data if
less than chunk size, all the remaining data is returned. Conversely,
<a href="base.html#topic+NULL">NULL</a> when there is no more pending data. By default
<code>chunk.size</code> is defined as 10000.
</p>


<h5>Usage</h5>

<div class="r"><pre>DIterator$getNext()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> of <a href="base.html#topic+NULL">NULL</a> if all the data have been
previously returned.
</p>


<hr>
<a id="method-DIterator-isLast"></a>



<h4>Method <code>isLast()</code></h4>

<p>Checks if the <code><a href="#topic+DIterator">DIterator</a></code> object reached the end
of the <a href="base.html#topic+data.frame">data.frame</a>
</p>


<h5>Usage</h5>

<div class="r"><pre>DIterator$isLast()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value indicating if the end of <a href="base.html#topic+data.frame">data.frame</a>
has been reached.
</p>


<hr>
<a id="method-DIterator-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Destroys the <code><a href="#topic+DIterator">DIterator</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>DIterator$finalize()</pre></div>


<hr>
<a id="method-DIterator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DIterator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>
</p>

<hr>
<h2 id='ExecutedModels'>Handles training of M.L. models</h2><span id='topic+ExecutedModels'></span>

<h3>Description</h3>

<p>Allows to manage the executed M.L. models.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ExecutedModels-new"><code>ExecutedModels$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-getNames"><code>ExecutedModels$getNames()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-getBest"><code>ExecutedModels$getBest()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-add"><code>ExecutedModels$add()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-exist"><code>ExecutedModels$exist()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-size"><code>ExecutedModels$size()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-save"><code>ExecutedModels$save()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-delete"><code>ExecutedModels$delete()</code></a>
</p>
</li>
<li> <p><a href="#method-ExecutedModels-clone"><code>ExecutedModels$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-ExecutedModels-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$new(dir.path)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The location were the executed models will be saved.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExecutedModels-getNames"></a>



<h4>Method <code>getNames()</code></h4>

<p>The function is used to obtain the name of the ML model
achieved the best performance during training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$getNames()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length 1 of <a href="base.html#topic+NULL">NULL</a>
if no ML model have been trained.
</p>


<hr>
<a id="method-ExecutedModels-getBest"></a>



<h4>Method <code>getBest()</code></h4>

<p>The function is responsible of returning the model achieving
the best performance value during training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$getBest()</pre></div>



<h5>Returns</h5>

<p>A <code><a href="#topic+Model">Model</a></code> object.
</p>


<hr>
<a id="method-ExecutedModels-add"></a>



<h4>Method <code>add()</code></h4>

<p>The function inserts a new model to the list of executed
models.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$add(model, keep.best = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>A previously trained model (in <code><a href="#topic+Model">Model</a></code> object).</p>
</dd>
<dt><code>keep.best</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to define the saving operation.
If <a href="base.html#topic+TRUE">TRUE</a> only saves the best model, otherwise all executed models
are saved.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExecutedModels-exist"></a>



<h4>Method <code>exist()</code></h4>

<p>The function is used to discern if a specific model has been
executed previously.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$exist(model.name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model.name</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the
model to check for existence.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value. <a href="base.html#topic+TRUE">TRUE</a> if the model exists
and <a href="base.html#topic+FALSE">FALSE</a> otherwise.
</p>


<hr>
<a id="method-ExecutedModels-size"></a>



<h4>Method <code>size()</code></h4>

<p>The function is used to compute the number of executed ML
models.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$size()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector or size 1.
</p>


<hr>
<a id="method-ExecutedModels-save"></a>



<h4>Method <code>save()</code></h4>

<p>The function is responsible of saving the information of all
executed models into a hidden file.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$save()</pre></div>


<hr>
<a id="method-ExecutedModels-delete"></a>



<h4>Method <code>delete()</code></h4>

<p>The function removes an specific model.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$delete(model.name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model.name</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the name of the
model to be removed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ExecutedModels-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ExecutedModels$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Model">Model</a></code>
</p>

<hr>
<h2 id='FinalPred'>Stores the prediction for a specific voting scheme.</h2><span id='topic+FinalPred'></span>

<h3>Description</h3>

<p>The class is used to store the computed probability after
executing an specific voting scheme.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FinalPred-new"><code>FinalPred$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FinalPred-set"><code>FinalPred$set()</code></a>
</p>
</li>
<li> <p><a href="#method-FinalPred-getProb"><code>FinalPred$getProb()</code></a>
</p>
</li>
<li> <p><a href="#method-FinalPred-getRaw"><code>FinalPred$getRaw()</code></a>
</p>
</li>
<li> <p><a href="#method-FinalPred-getClassValues"><code>FinalPred$getClassValues()</code></a>
</p>
</li>
<li> <p><a href="#method-FinalPred-getPositiveClass"><code>FinalPred$getPositiveClass()</code></a>
</p>
</li>
<li> <p><a href="#method-FinalPred-getNegativeClass"><code>FinalPred$getNegativeClass()</code></a>
</p>
</li>
<li> <p><a href="#method-FinalPred-clone"><code>FinalPred$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FinalPred-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object variables during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$new()</pre></div>


<hr>
<a id="method-FinalPred-set"></a>



<h4>Method <code>set()</code></h4>

<p>Sets the computed probabilities after executing an specific
voting scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$set(prob, raw, class.values, positive.class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>prob</code></dt><dd><p>A <a href="base.html#topic+vector">vector</a> containing the probabilities of the
prediction for a specific voting scheme.</p>
</dd>
<dt><code>raw</code></dt><dd><p>A <a href="base.html#topic+vector">vector</a> containing the raw results of the prediction
for a specific voting scheme.</p>
</dd>
<dt><code>class.values</code></dt><dd><p>A <a href="base.html#topic+vector">vector</a> containing the class values.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> value containing the positive
class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FinalPred-getProb"></a>



<h4>Method <code>getProb()</code></h4>

<p>Gets the probabilities of the prediction for a specific
voting scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$getProb()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+vector">vector</a> value of probabilities of the prediction for a
specific voting scheme.
</p>


<hr>
<a id="method-FinalPred-getRaw"></a>



<h4>Method <code>getRaw()</code></h4>

<p>Gets the raw results of the prediction for a specific voting
scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$getRaw()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+vector">vector</a> value of raw results of the prediction for a
specific voting scheme.
</p>


<hr>
<a id="method-FinalPred-getClassValues"></a>



<h4>Method <code>getClassValues()</code></h4>

<p>Gets the class values (positive class + negative class).
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$getClassValues()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+vector">vector</a> value of class values.
</p>


<hr>
<a id="method-FinalPred-getPositiveClass"></a>



<h4>Method <code>getPositiveClass()</code></h4>

<p>Gets the positive class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$getPositiveClass()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+character">character</a> value of positive class.
</p>


<hr>
<a id="method-FinalPred-getNegativeClass"></a>



<h4>Method <code>getNegativeClass()</code></h4>

<p>Gets the negative class.
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$getNegativeClass()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+character">character</a> value of negative class.
</p>


<hr>
<a id="method-FinalPred-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FinalPred$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Prediction">Prediction</a></code>, <code><a href="#topic+SimpleVoting">SimpleVoting</a></code>,
<code><a href="#topic+SingleVoting">SingleVoting</a></code>, <code><a href="#topic+CombinedVoting">CombinedVoting</a></code>,
<code><a href="#topic+VotingStrategy">VotingStrategy</a></code>
</p>

<hr>
<h2 id='FisherTestHeuristic'>Feature-clustering based on Fisher's Exact Test.</h2><span id='topic+FisherTestHeuristic'></span>

<h3>Description</h3>

<p>Performs feature-clustering based on Fisher's exact test for
testing the null of independence of rows and columns in a contingency table
with fixed marginals.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>FisherTestHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FisherTestHeuristic-new"><code>FisherTestHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FisherTestHeuristic-heuristic"><code>FisherTestHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-FisherTestHeuristic-clone"><code>FisherTestHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FisherTestHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>FisherTestHeuristic$new()</pre></div>


<hr>
<a id="method-FisherTestHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Performs the Fisher's exact test for testing the null of
independence between two columns (col1 and col2).
</p>


<h5>Usage</h5>

<div class="r"><pre>FisherTestHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-FisherTestHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FisherTestHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="stats.html#topic+fisher.test">fisher.test</a></code>
</p>

<hr>
<h2 id='FIterator'>Iterator over a file.</h2><span id='topic+FIterator'></span>

<h3>Description</h3>

<p>Creates a <code><a href="#topic+FIterator">FIterator</a></code> object to iterate over high
dimensional files.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+HDDataset">HDDataset</a></code> class to ensure the creation of a valid
<code><a href="#topic+FIterator">FIterator</a></code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FIterator-new"><code>FIterator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FIterator-getNext"><code>FIterator$getNext()</code></a>
</p>
</li>
<li> <p><a href="#method-FIterator-isLast"><code>FIterator$isLast()</code></a>
</p>
</li>
<li> <p><a href="#method-FIterator-finalize"><code>FIterator$finalize()</code></a>
</p>
</li>
<li> <p><a href="#method-FIterator-clone"><code>FIterator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FIterator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>FIterator$new(config.params, chunk.size, verbose)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>config.params</code></dt><dd><p>A <a href="base.html#topic+list">list</a> of configuration options.</p>
</dd>
<dt><code>chunk.size</code></dt><dd><p>An <a href="base.html#topic+integer">integer</a> value indicating the size of chunks
taken over each iteration. By default <code>chunk.size</code> is defined as
10000.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FIterator-getNext"></a>



<h4>Method <code>getNext()</code></h4>

<p>Gets the next chunk of data. Each iteration returns the same
instances (data.frame rows) as chunk.size. However, if remaining data if
less than chunk size, all the remaining data is returned. Conversely,
<a href="base.html#topic+NULL">NULL</a> when there is no more pending data. By default
<code>chunk.size</code> is defined as 10000.
</p>


<h5>Usage</h5>

<div class="r"><pre>FIterator$getNext()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> of <a href="base.html#topic+NULL">NULL</a> if all the data have been
previously returned.
</p>


<hr>
<a id="method-FIterator-isLast"></a>



<h4>Method <code>isLast()</code></h4>

<p>Checks if the <code><a href="#topic+FIterator">FIterator</a></code> object reached the end
of the <a href="base.html#topic+data.frame">data.frame</a>
</p>


<h5>Usage</h5>

<div class="r"><pre>FIterator$isLast()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value indicating if the end of <a href="base.html#topic+data.frame">data.frame</a>
has been reached.
</p>


<hr>
<a id="method-FIterator-finalize"></a>



<h4>Method <code>finalize()</code></h4>

<p>Destroys the <code><a href="#topic+FIterator">FIterator</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>FIterator$finalize()</pre></div>


<hr>
<a id="method-FIterator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FIterator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>
</p>

<hr>
<h2 id='FN'>Computes the False Negative errors.</h2><span id='topic+FN'></span>

<h3>Description</h3>

<p>Computes the ratio of number of Type II errors achieved by the
final M.L. model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>FN</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FN-new"><code>FN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FN-compute"><code>FN$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-FN-clone"><code>FN$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>FN$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used to compute the <strong>FN</strong> measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FN-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>FN</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>FN$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <strong>FN</strong>
measure</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoked by the
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> framework.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-FN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='FP'>Computes the False Positive value.</h2><span id='topic+FP'></span>

<h3>Description</h3>

<p>This is the number of individuals with a negative condition for
which the test result is positive. The value entered here must be non-negative.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>FP</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FP-new"><code>FP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FP-compute"><code>FP$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-FP-clone"><code>FP$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FP-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>FP$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
used as basis to define the type of compute the <code>FP</code> measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FP-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>FP</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>FP$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <code>FP</code>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoked by the
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if
an error occurred.
</p>


<hr>
<a id="method-FP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='GainRatioHeuristic'>Feature-clustering based on GainRatio methodology.</h2><span id='topic+GainRatioHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using entropy-based filters.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>GainRatioHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GainRatioHeuristic-new"><code>GainRatioHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GainRatioHeuristic-heuristic"><code>GainRatioHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-GainRatioHeuristic-clone"><code>GainRatioHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GainRatioHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>GainRatioHeuristic$new()</pre></div>


<hr>
<a id="method-GainRatioHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>The algorithms find weights of discrete attributes basing on
their correlation with continuous class attribute.
</p>


<h5>Usage</h5>

<div class="r"><pre>GainRatioHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-GainRatioHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GainRatioHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="FSelector.html#topic+gain.ratio">gain.ratio</a></code>
</p>

<hr>
<h2 id='GenericClusteringStrategy'>Abstract Feature Clustering Strategy class.</h2><span id='topic+GenericClusteringStrategy'></span>

<h3>Description</h3>

<p>Abstract class used as a template to ensure the proper
definition of new customized clustering strategies.
</p>


<h3>Details</h3>

<p>The <a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a> is an archetype class so it
cannot be instantiated.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenericClusteringStrategy-new"><code>GenericClusteringStrategy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-getDescription"><code>GenericClusteringStrategy$getDescription()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-getHeuristic"><code>GenericClusteringStrategy$getHeuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-getConfiguration"><code>GenericClusteringStrategy$getConfiguration()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-getBestClusterDistribution"><code>GenericClusteringStrategy$getBestClusterDistribution()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-getUnclustered"><code>GenericClusteringStrategy$getUnclustered()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-execute"><code>GenericClusteringStrategy$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-getDistribution"><code>GenericClusteringStrategy$getDistribution()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-createTrain"><code>GenericClusteringStrategy$createTrain()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-plot"><code>GenericClusteringStrategy$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-saveCSV"><code>GenericClusteringStrategy$saveCSV()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericClusteringStrategy-clone"><code>GenericClusteringStrategy$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GenericClusteringStrategy-new"></a>



<h4>Method <code>new()</code></h4>

<p>A function responsible for creating a
<a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$new(subset, heuristic, description, configuration)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>A <code><a href="#topic+Subset">Subset</a></code> object to perform the clustering strategy.</p>
</dd>
<dt><code>heuristic</code></dt><dd><p>The heuristic to be applied. Must inherit from
<code><a href="#topic+GenericHeuristic">GenericHeuristic</a></code> class.</p>
</dd>
<dt><code>description</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector describing the strategy
operation.</p>
</dd>
<dt><code>configuration</code></dt><dd><p>Optional customized configuration parameters for the
strategy. Must inherited from <code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code>
abstract class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericClusteringStrategy-getDescription"></a>



<h4>Method <code>getDescription()</code></h4>

<p>The function is used to obtain the description of the
strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$getDescription()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of <a href="base.html#topic+NULL">NULL</a> if not defined.
</p>


<hr>
<a id="method-GenericClusteringStrategy-getHeuristic"></a>



<h4>Method <code>getHeuristic()</code></h4>

<p>The function returns the heuristic applied for the
clustering strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$getHeuristic()</pre></div>



<h5>Returns</h5>

<p>An object inherited from <code><a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a></code>
class.
</p>


<hr>
<a id="method-GenericClusteringStrategy-getConfiguration"></a>



<h4>Method <code>getConfiguration()</code></h4>

<p>The function returns the configuration parameters used to
perform the clustering strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$getConfiguration()</pre></div>



<h5>Returns</h5>

<p>An object inherited from <code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code>
class.
</p>


<hr>
<a id="method-GenericClusteringStrategy-getBestClusterDistribution"></a>



<h4>Method <code>getBestClusterDistribution()</code></h4>

<p>The function obtains the best clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$getBestClusterDistribution()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> of clusters. Each list element represents a feature
group.
</p>


<hr>
<a id="method-GenericClusteringStrategy-getUnclustered"></a>



<h4>Method <code>getUnclustered()</code></h4>

<p>The function is used to return the features that cannot be
clustered due to incompatibilities with the used heuristic.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$getUnclustered()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector containing the unclassified features.
</p>


<hr>
<a id="method-GenericClusteringStrategy-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Abstract function responsible of performing the clustering
strategy over the defined <code><a href="#topic+Subset">Subset</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$execute(verbose, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>execute</code> function.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericClusteringStrategy-getDistribution"></a>



<h4>Method <code>getDistribution()</code></h4>

<p>Abstract function used to obtain the set of features
following an specific clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$getDistribution(
  num.clusters = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.clusters</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> with the features comprising an specific clustering
distribution.
</p>


<hr>
<a id="method-GenericClusteringStrategy-createTrain"></a>



<h4>Method <code>createTrain()</code></h4>

<p>Abstract function in charge of creating a
<code><a href="#topic+Trainset">Trainset</a></code> object for training purposes.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$createTrain(
  subset,
  num.cluster = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>A <code><a href="#topic+Subset">Subset</a></code> object used as a basis to create the
<a href="#topic+Trainset">Trainset</a></p>
</dd>
<dt><code>num.cluster</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericClusteringStrategy-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Abstract function responsible of creating a plot to
visualize the clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$plot(dir.path = NULL, file.name = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> argument to define the name
of the directory where the exported plot will be saved. If not defined,
the file path will be automatically assigned to the current working
directory, '<code>getwd()</code>'.</p>
</dd>
<dt><code>file.name</code></dt><dd><p>The name of the PDF file where the plot is exported.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>execute</code> function.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericClusteringStrategy-saveCSV"></a>



<h4>Method <code>saveCSV()</code></h4>

<p>Abstract function to save the clustering distribution to a
CSV file.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$saveCSV(dir.path, name, num.clusters = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The name of the directory to save the CSV file.</p>
</dd>
<dt><code>name</code></dt><dd><p>Defines the name of the CSV file.</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>An optional parameter to select the number of
clusters to be saved. If not defined, all clusters will be saved.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericClusteringStrategy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericClusteringStrategy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Subset">Subset</a></code>, <code><a href="#topic+GenericHeuristic">GenericHeuristic</a></code>
</p>

<hr>
<h2 id='GenericHeuristic'>Abstract Feature Clustering heuristic object.</h2><span id='topic+GenericHeuristic'></span>

<h3>Description</h3>

<p>Abstract class used as a template to define new customized
clustering heuristics.
</p>


<h3>Details</h3>

<p>The <a href="#topic+GenericHeuristic">GenericHeuristic</a> is an archetype class so it cannot be
instantiated.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenericHeuristic-new"><code>GenericHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericHeuristic-heuristic"><code>GenericHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericHeuristic-clone"><code>GenericHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GenericHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericHeuristic$new()</pre></div>


<hr>
<a id="method-GenericHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Function used to implement the clustering heuristic.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericHeuristic$heuristic(col1, col2, column.names = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns</p>
</dd>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>heuristic</code> function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1.
</p>


<hr>
<a id="method-GenericHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>
</p>

<hr>
<h2 id='GenericModelFit'>Abstract class for defining model fitting method.</h2><span id='topic+GenericModelFit'></span>

<h3>Description</h3>

<p>Template to create a <code><a href="recipes.html#topic+recipe">recipe</a></code> or
<code><a href="stats.html#topic+formula">formula</a></code> objects used in model training stage.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenericModelFit-new"><code>GenericModelFit$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModelFit-createFormula"><code>GenericModelFit$createFormula()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModelFit-createRecipe"><code>GenericModelFit$createRecipe()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericModelFit-clone"><code>GenericModelFit$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GenericModelFit-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModelFit$new()</pre></div>


<hr>
<a id="method-GenericModelFit-createFormula"></a>



<h4>Method <code>createFormula()</code></h4>

<p>The function is responsible of creating a
<code><a href="stats.html#topic+formula">formula</a></code> for M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModelFit$createFormula(instances, class.name, simplify = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instances</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> containing the instances used to
create the recipe.</p>
</dd>
<dt><code>class.name</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector representing the name of the
target class.</p>
</dd>
<dt><code>simplify</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> argument defining whether the formula
should be generated as simple as possible.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="stats.html#topic+formula">formula</a></code> object.
</p>


<hr>
<a id="method-GenericModelFit-createRecipe"></a>



<h4>Method <code>createRecipe()</code></h4>

<p>The function is responsible of creating a
<code><a href="recipes.html#topic+recipe">recipe</a></code> for M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModelFit$createRecipe(instances, class.name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>instances</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> containing the instances used to
create the recipe.</p>
</dd>
<dt><code>class.name</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector representing the name of the
target class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A object of class <code><a href="recipes.html#topic+recipe">recipe</a></code>.
</p>


<hr>
<a id="method-GenericModelFit-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericModelFit$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+DefaultModelFit">DefaultModelFit</a></code>, <code><a href="caret.html#topic+train">train</a></code>
</p>

<hr>
<h2 id='GenericPlot'>Pseudo-abstract class for creating feature clustering plots.</h2><span id='topic+GenericPlot'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+GenericPlot">GenericPlot</a></code> implements a basic plot.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GenericPlot-new"><code>GenericPlot$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericPlot-plot"><code>GenericPlot$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-GenericPlot-clone"><code>GenericPlot$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GenericPlot-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericPlot$new()</pre></div>


<hr>
<a id="method-GenericPlot-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Implements a generic plot to visualize basic
feature-clustering data.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericPlot$plot(summary)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>summary</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> comprising the elements to be plotted.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GenericPlot-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GenericPlot$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+BinaryPlot">BinaryPlot</a></code>
</p>

<hr>
<h2 id='HDDataset'>High Dimensional Dataset handler.</h2><span id='topic+HDDataset'></span>

<h3>Description</h3>

<p>Creates a high dimensional dataset object. Only the required
instances are loaded in memory to avoid unnecessary of resources and memory.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HDDataset-new"><code>HDDataset$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDataset-getColumnNames"><code>HDDataset$getColumnNames()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDataset-getNcol"><code>HDDataset$getNcol()</code></a>
</p>
</li>
<li> <p><a href="#method-HDDataset-createSubset"><code>HDDataset$createSubset()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HDDataset-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDataset$new(
  filepath,
  header = TRUE,
  sep = ",",
  skip = 0,
  normalize.names = FALSE,
  ignore.columns = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>filepath</code></dt><dd><p>The name of the file which the data are to be read from.
Each row of the table appears as one line of the file. If it does not
contain an _absolute_ path, the file name is _relative_ to the current
working directory, '<code>getwd()</code>'.</p>
</dd>
<dt><code>header</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether the file contains
the names of the variables as its first line. If missing, the value is
determined from the file format: '<code>header</code>' is set to '<code>TRUE</code>'
if and only if the first row contains one fewer field than the number of
columns.</p>
</dd>
<dt><code>sep</code></dt><dd><p>The field separator character. Values on each line of the file
are separated by this character.</p>
</dd>
<dt><code>skip</code></dt><dd><p>Defines the number of header lines should be skipped.</p>
</dd>
<dt><code>normalize.names</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value indicating whether the
columns names should be automatically renamed to ensure R compatibility.</p>
</dd>
<dt><code>ignore.columns</code></dt><dd><p>Specify the columns from the input file that should
be ignored.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDDataset-getColumnNames"></a>



<h4>Method <code>getColumnNames()</code></h4>

<p>Gets the name of the columns comprising the dataset
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDataset$getColumnNames()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with the name of each column.
</p>


<hr>
<a id="method-HDDataset-getNcol"></a>



<h4>Method <code>getNcol()</code></h4>

<p>Obtains the number of columns present in the dataset.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDataset$getNcol()</pre></div>



<h5>Returns</h5>

<p>An <a href="base.html#topic+integer">integer</a> of length 1 or <a href="base.html#topic+NULL">NULL</a>
</p>


<hr>
<a id="method-HDDataset-createSubset"></a>



<h4>Method <code>createSubset()</code></h4>

<p>Creates a blinded <a href="#topic+HDSubset">HDSubset</a> for classification purposes.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDDataset$createSubset(column.id = FALSE, chunk.size = 1e+05)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>column.id</code></dt><dd><p>An <a href="base.html#topic+integer">integer</a> or <a href="base.html#topic+character">character</a> indicating the
column (number or name respectively) identifier. Default <a href="base.html#topic+NULL">NULL</a>
value is valid ignores defining a identification column.</p>
</dd>
<dt><code>chunk.size</code></dt><dd><p>an <a href="base.html#topic+integer">integer</a> value indicating the size of chunks
taken over each iteration.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+HDSubset">HDSubset</a></code> object.
</p>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="#topic+HDSubset">HDSubset</a></code>,
<code><a href="#topic+DatasetLoader">DatasetLoader</a></code>
</p>

<hr>
<h2 id='HDSubset'>High Dimensional Subset handler.</h2><span id='topic+HDSubset'></span>

<h3>Description</h3>

<p>Creates a high dimensional subset from a <code><a href="#topic+HDDataset">HDDataset</a></code>
object. Only the required instances are loaded in memory to avoid unnecessary
use of resources and memory.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+HDDataset">HDDataset</a></code> to ensure the creation of a valid
<code><a href="#topic+HDSubset">HDSubset</a></code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HDSubset-new"><code>HDSubset$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HDSubset-getColumnNames"><code>HDSubset$getColumnNames()</code></a>
</p>
</li>
<li> <p><a href="#method-HDSubset-getNcol"><code>HDSubset$getNcol()</code></a>
</p>
</li>
<li> <p><a href="#method-HDSubset-getID"><code>HDSubset$getID()</code></a>
</p>
</li>
<li> <p><a href="#method-HDSubset-getIterator"><code>HDSubset$getIterator()</code></a>
</p>
</li>
<li> <p><a href="#method-HDSubset-isBlinded"><code>HDSubset$isBlinded()</code></a>
</p>
</li>
<li> <p><a href="#method-HDSubset-clone"><code>HDSubset$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HDSubset-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDSubset$new(
  file.path,
  feature.names,
  feature.id,
  start.at = 0,
  sep = ",",
  chunk.size
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>file.path</code></dt><dd><p>The name of the file which the data are to be read from.
Each row of the table appears as one line of the file. If it does not
contain an _absolute_ path, the file name is _relative_ to the current
working directory, '<code>getwd()</code>'.</p>
</dd>
<dt><code>feature.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector specifying the name of the
features that should be included in the <code><a href="#topic+HDDataset">HDDataset</a></code> object.</p>
</dd>
<dt><code>feature.id</code></dt><dd><p>An <a href="base.html#topic+integer">integer</a> or <a href="base.html#topic+character">character</a> indicating the
column (number or name respectively) identifier. Default <a href="base.html#topic+NULL">NULL</a>
value is valid ignores defining a identification column.</p>
</dd>
<dt><code>start.at</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to identify the reading start
position.</p>
</dd>
<dt><code>sep</code></dt><dd><p>the field separator character. Values on each line of the file
are separated by this character.</p>
</dd>
<dt><code>chunk.size</code></dt><dd><p>an <a href="base.html#topic+integer">integer</a> value indicating the size of chunks
taken over each iteration. By default chunk.size is defined as 10000.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HDSubset-getColumnNames"></a>



<h4>Method <code>getColumnNames()</code></h4>

<p>Gets the name of the columns comprising the subset.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDSubset$getColumnNames()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector containing the name of each column.
</p>


<hr>
<a id="method-HDSubset-getNcol"></a>



<h4>Method <code>getNcol()</code></h4>

<p>Obtains the number of columns present in the dataset.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDSubset$getNcol()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value or 0 if is empty.
</p>


<hr>
<a id="method-HDSubset-getID"></a>



<h4>Method <code>getID()</code></h4>

<p>Obtains the column identifier.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDSubset$getID()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of size 1.
</p>


<hr>
<a id="method-HDSubset-getIterator"></a>



<h4>Method <code>getIterator()</code></h4>

<p>Creates the <code><a href="#topic+FIterator">FIterator</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDSubset$getIterator(chunk.size = private$chunk.size, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chunk.size</code></dt><dd><p>An <a href="base.html#topic+integer">integer</a> value indicating the size of chunks
taken over each iteration. By default <code>chunk.size</code> is defined as
10000.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+FIterator">FIterator</a></code> object to transverse through
<code><a href="#topic+HDSubset">HDSubset</a></code> instances
</p>


<hr>
<a id="method-HDSubset-isBlinded"></a>



<h4>Method <code>isBlinded()</code></h4>

<p>Checks if the subset contains a target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDSubset$isBlinded()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> to specify if the subset contains a target class
or not.
</p>


<hr>
<a id="method-HDSubset-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HDSubset$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+HDDataset">HDDataset</a></code>, <code><a href="#topic+DatasetLoader">DatasetLoader</a></code>
</p>

<hr>
<h2 id='InformationGainHeuristic'>Feature-clustering based on InformationGain methodology.</h2><span id='topic+InformationGainHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using entropy-based filters.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>InformationGainHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-InformationGainHeuristic-new"><code>InformationGainHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-InformationGainHeuristic-heuristic"><code>InformationGainHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-InformationGainHeuristic-clone"><code>InformationGainHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-InformationGainHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>InformationGainHeuristic$new()</pre></div>


<hr>
<a id="method-InformationGainHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>The algorithm find weights of discrete attributes basing on
their correlation with continuous class attribute. Particularly
Information Gain uses <code>H(Class) + H(Attribute) - H(Class, Attribute)</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>InformationGainHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>an optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-InformationGainHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>InformationGainHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="FSelector.html#topic+information.gain">information.gain</a></code>
</p>

<hr>
<h2 id='Kappa'>Computes the Kappa Cohen value.</h2><span id='topic+Kappa'></span>

<h3>Description</h3>

<p>Cohen's Kappa measures the agreement between two raters who each
classify N items into C mutually exclusive categories.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\kappa \hspace{0.1cm} is \hspace{0.1cm} equivalent
\hspace{0.1cm} to \hspace{0.1cm} (p_o - p_e) / (1 - p_e) = 1 - (1 - p_0) /
(1 - p_e)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>Kappa</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Kappa-new"><code>Kappa$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Kappa-compute"><code>Kappa$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-Kappa-clone"><code>Kappa$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Kappa-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kappa$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> used as
basis to compute the performance.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Kappa-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>Kappa</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kappa$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <code>Kappa</code>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoked by the
<a href="#topic+ClassificationOutput">ClassificationOutput</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-Kappa-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Kappa$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='KendallHeuristic'>Feature-clustering based on Kendall Correlation Test.</h2><span id='topic+KendallHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using Kendall correlation tests.
</p>


<h3>Details</h3>

<p>The method estimate the association between paired samples and
compute a test of the value being zero. They use different measures of
association, all in the range [-1, 1] with 0 indicating no association.
Method valid only for bi-class problems.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>KendallHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KendallHeuristic-new"><code>KendallHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KendallHeuristic-heuristic"><code>KendallHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-KendallHeuristic-clone"><code>KendallHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-KendallHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>KendallHeuristic$new()</pre></div>


<hr>
<a id="method-KendallHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Test for association between paired samples using Kendall's
tau value.
</p>


<h5>Usage</h5>

<div class="r"><pre>KendallHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-KendallHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KendallHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="stats.html#topic+cor.test">cor.test</a></code>
</p>

<hr>
<h2 id='MCC'>Computes the Matthews correlation coefficient.</h2><span id='topic+MCC'></span>

<h3>Description</h3>

<p>The Matthews correlation coefficient is used in machine learning
as a measure of the quality of binary (two-class) classifications. It takes
into account true and false positives and negatives and is generally regarded
as a balanced measure which can be used even if the classes are of very
different sizes. The MCC is in essence a correlation coefficient between the
observed and predicted binary classifications; it returns a value between -1
and +1.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">MCC = (TP × (TN - FP) × FN)/(\sqrt{(TP + FP) × (TP + FN) × (TN + FP) × (TN + FN)})</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>MCC</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MCC-new"><code>MCC$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MCC-compute"><code>MCC$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-MCC-clone"><code>MCC$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MCC-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCC$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
used as basis to compute the <code>MCC</code> measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MCC-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>MCC</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCC$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <code>MCC</code>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<a href="#topic+ClassificationOutput">ClassificationOutput</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-MCC-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCC$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='MCCHeuristic'>Feature-clustering based on Matthews Correlation Coefficient score.</h2><span id='topic+MCCHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using MCC score.
Valid for both bi-class and multi-class problems
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>MCCHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MCCHeuristic-new"><code>MCCHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MCCHeuristic-heuristic"><code>MCCHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-MCCHeuristic-clone"><code>MCCHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MCCHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCCHeuristic$new()</pre></div>


<hr>
<a id="method-MCCHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Calculates the Matthews correlation Coefficient (MCC) score.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCCHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-MCCHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCCHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="mccr.html#topic+mccr">mccr</a></code>
</p>

<hr>
<h2 id='MeasureFunction'>Archetype to define customized measures.</h2><span id='topic+MeasureFunction'></span>

<h3>Description</h3>

<p>Abstract class used as a template to define new M.L. performance
measures.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+GenericHeuristic">GenericHeuristic</a></code> is an full-abstract class so it cannot
be instantiated. To ensure the proper operation, <code>compute</code> method is
automatically invoke by <code><a href="#topic+D2MCS">D2MCS</a></code> framework when needed.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MeasureFunction-new"><code>MeasureFunction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MeasureFunction-compute"><code>MeasureFunction$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-MeasureFunction-clone"><code>MeasureFunction$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MeasureFunction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>MeasureFunction$new(performance = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter to
define the type of object used to compute the measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MeasureFunction-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function implements the metric used to measure the
performance achieved by the M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>MeasureFunction$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used to compute the measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the <code><a href="#topic+D2MCS">D2MCS</a></code>
framework.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-MeasureFunction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MeasureFunction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>
</p>

<hr>
<h2 id='Methodology'>Abstract class to compute the probability prediction based on
combination between metrics.</h2><span id='topic+Methodology'></span>

<h3>Description</h3>

<p>Abstract class used as a template to define new customized
strategies to combine the probability predictions made by different metrics.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Methodology-new"><code>Methodology$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Methodology-getRequiredMetrics"><code>Methodology$getRequiredMetrics()</code></a>
</p>
</li>
<li> <p><a href="#method-Methodology-compute"><code>Methodology$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-Methodology-clone"><code>Methodology$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Methodology-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Methodology$new(required.metrics)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>required.metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector of length greater than
2 with the name of the required metrics.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Methodology-getRequiredMetrics"></a>



<h4>Method <code>getRequiredMetrics()</code></h4>

<p>The function returns the required metrics that will
participate in the methodology to compute a metric based on all of them.
</p>


<h5>Usage</h5>

<div class="r"><pre>Methodology$getRequiredMetrics()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length greater than 2 with the name
of the required metrics.
</p>


<hr>
<a id="method-Methodology-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>Function to compute the probability of the final prediction
based on different metrics.
</p>


<h5>Usage</h5>

<div class="r"><pre>Methodology$compute(raw.pred, prob.pred, positive.class, negative.class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw.pred</code></dt><dd><p>A <a href="base.html#topic+character">character</a> list of length greater than 2 with the
class value of the predictions made by the metrics.</p>
</dd>
<dt><code>prob.pred</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> list of length greater than 2 with the
probability of the predictions made by the metrics.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the positive
class.</p>
</dd>
<dt><code>negative.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the negative
class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value indicating the probability of the instance
is predicted as positive class.
</p>


<hr>
<a id="method-Methodology-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Methodology$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+ProbBasedMethodology">ProbBasedMethodology</a></code>
</p>

<hr>
<h2 id='MinimizeFN'>Combined metric strategy to minimize FN errors.</h2><span id='topic+MinimizeFN'></span>

<h3>Description</h3>

<p>Calculates if the positive class is the predicted one in any of
the metrics, otherwise, the instance is not considered to have the positive
class associated.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CombinedMetrics">D2MCS::CombinedMetrics</a></code> -&gt; <code>MinimizeFN</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MinimizeFN-new"><code>MinimizeFN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MinimizeFN-getFinalPrediction"><code>MinimizeFN$getFinalPrediction()</code></a>
</p>
</li>
<li> <p><a href="#method-MinimizeFN-clone"><code>MinimizeFN$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="CombinedMetrics" data-id="getRequiredMetrics"><a href='../../D2MCS/html/CombinedMetrics.html#method-CombinedMetrics-getRequiredMetrics'><code>D2MCS::CombinedMetrics$getRequiredMetrics()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MinimizeFN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>MinimizeFN$new(required.metrics = c("MCC", "PPV"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>required.metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector of length 1 with the
name of the required metrics.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MinimizeFN-getFinalPrediction"></a>



<h4>Method <code>getFinalPrediction()</code></h4>

<p>Function to obtain the final prediction based on different
metrics.
</p>


<h5>Usage</h5>

<div class="r"><pre>MinimizeFN$getFinalPrediction(
  raw.pred,
  prob.pred,
  positive.class,
  negative.class
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw.pred</code></dt><dd><p>A <a href="base.html#topic+character">character</a> list of length greater than 2 with the
class value of the predictions made by the metrics.</p>
</dd>
<dt><code>prob.pred</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> list of length greater than 2 with the
probability of the predictions made by the metrics.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the positive
class.</p>
</dd>
<dt><code>negative.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the negative
class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value indicating if the instance is predicted
as positive class or not.
</p>


<hr>
<a id="method-MinimizeFN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MinimizeFN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+CombinedMetrics">CombinedMetrics</a></code>
</p>

<hr>
<h2 id='MinimizeFP'>Combined metric strategy to minimize FP errors.</h2><span id='topic+MinimizeFP'></span>

<h3>Description</h3>

<p>Calculates if the positive class is the predicted one in all
metrics, otherwise, the instance is not considered to have the positive
class associated.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+CombinedMetrics">D2MCS::CombinedMetrics</a></code> -&gt; <code>MinimizeFP</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MinimizeFP-new"><code>MinimizeFP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MinimizeFP-getFinalPrediction"><code>MinimizeFP$getFinalPrediction()</code></a>
</p>
</li>
<li> <p><a href="#method-MinimizeFP-clone"><code>MinimizeFP$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="CombinedMetrics" data-id="getRequiredMetrics"><a href='../../D2MCS/html/CombinedMetrics.html#method-CombinedMetrics-getRequiredMetrics'><code>D2MCS::CombinedMetrics$getRequiredMetrics()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-MinimizeFP-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>MinimizeFP$new(required.metrics = c("MCC", "PPV"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>required.metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector of length greater than
2 with the name of the required metrics.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-MinimizeFP-getFinalPrediction"></a>



<h4>Method <code>getFinalPrediction()</code></h4>

<p>Function to obtain the final prediction based on different
metrics.
</p>


<h5>Usage</h5>

<div class="r"><pre>MinimizeFP$getFinalPrediction(
  raw.pred,
  prob.pred,
  positive.class,
  negative.class
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw.pred</code></dt><dd><p>A <a href="base.html#topic+character">character</a> list of length greater than 2 with the
class value of the predictions made by the metrics.</p>
</dd>
<dt><code>prob.pred</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> list of length greater than 2 with the
probability of the predictions made by the metrics.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the positive
class.</p>
</dd>
<dt><code>negative.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the negative
class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value indicating if the instance is predicted as
positive class or not.
</p>


<hr>
<a id="method-MinimizeFP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MinimizeFP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+CombinedMetrics">CombinedMetrics</a></code>
</p>

<hr>
<h2 id='Model'>Stores a previously trained M.L. model.</h2><span id='topic+Model'></span>

<h3>Description</h3>

<p>Encapsulates and handles all the information and operations
associated with a M.L. model.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Model-new"><code>Model$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-isTrained"><code>Model$isTrained()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getDir"><code>Model$getDir()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getName"><code>Model$getName()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getFamily"><code>Model$getFamily()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getDescription"><code>Model$getDescription()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-train"><code>Model$train()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getTrainedModel"><code>Model$getTrainedModel()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getExecutionTime"><code>Model$getExecutionTime()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getPerformance"><code>Model$getPerformance()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-getConfiguration"><code>Model$getConfiguration()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-save"><code>Model$save()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-remove"><code>Model$remove()</code></a>
</p>
</li>
<li> <p><a href="#method-Model-clone"><code>Model$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Model-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$new(dir.path, model)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The location were the executed models will be saved.</p>
</dd>
<dt><code>model</code></dt><dd><p>A <code><a href="#topic+Model">Model</a></code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-isTrained"></a>



<h4>Method <code>isTrained()</code></h4>

<p>The function is used to determine is the model has been
already trained.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$isTrained()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value. <a href="base.html#topic+TRUE">TRUE</a> if the model
has been trained and <a href="base.html#topic+FALSE">FALSE</a> otherwise.
</p>


<hr>
<a id="method-Model-getDir"></a>



<h4>Method <code>getDir()</code></h4>

<p>The function returns the location path of the specific
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getDir()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector specifying the location of the
model.
</p>


<hr>
<a id="method-Model-getName"></a>



<h4>Method <code>getName()</code></h4>

<p>The function is used to obtain the name of the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getName()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with the name of the model.
</p>


<hr>
<a id="method-Model-getFamily"></a>



<h4>Method <code>getFamily()</code></h4>

<p>The function gets the family of the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getFamily()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector representing the family of the ML
model.
</p>


<hr>
<a id="method-Model-getDescription"></a>



<h4>Method <code>getDescription()</code></h4>

<p>The function allows obtaining the description associated
with an specific ML model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getDescription()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with the model description.
</p>


<hr>
<a id="method-Model-train"></a>



<h4>Method <code>train()</code></h4>

<p>The function is responsible of performing model training
operation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$train(train.set, fitting, trFunction, metric, logs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>train.set</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> with the data used for training the
model.</p>
</dd>
<dt><code>fitting</code></dt><dd><p>The model fitting formula. Must inherit from
<code><a href="#topic+GenericModelFit">GenericModelFit</a></code> class.</p>
</dd>
<dt><code>trFunction</code></dt><dd><p>An object inherited from <code><a href="#topic+TrainFunction">TrainFunction</a></code>
used to define how the training acts.</p>
</dd>
<dt><code>metric</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing the metrics used to
optimized model parameters.</p>
</dd>
<dt><code>logs</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing the path to store the
error logs.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-getTrainedModel"></a>



<h4>Method <code>getTrainedModel()</code></h4>

<p>The function allows obtaining the trained model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getTrainedModel()</pre></div>



<h5>Returns</h5>

<p>A <code><a href="caret.html#topic+train">train</a></code> class.
</p>


<hr>
<a id="method-Model-getExecutionTime"></a>



<h4>Method <code>getExecutionTime()</code></h4>

<p>The function is used to compute the time taken to
perform training operation.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getExecutionTime()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector with length 1.
</p>


<hr>
<a id="method-Model-getPerformance"></a>



<h4>Method <code>getPerformance()</code></h4>

<p>The function obtains the performance achieved by the model
during training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getPerformance(metric = private$metric)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>metric</code></dt><dd><p>A <a href="base.html#topic+character">character</a> used to specify the measure used to
compute the performance.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value with the performance achieved.
</p>


<hr>
<a id="method-Model-getConfiguration"></a>



<h4>Method <code>getConfiguration()</code></h4>

<p>The function is used to get the configuration parameters
achieved by the ML model after the training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$getConfiguration()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> object with the configuration parameters.
</p>


<hr>
<a id="method-Model-save"></a>



<h4>Method <code>save()</code></h4>

<p>The function is responsible of saving the model to disc into
a RDS file.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$save(replace = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>replace</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value used to determine if model should
be resaved. <a href="base.html#topic+TRUE">TRUE</a> forces to replace previous saved model while
<a href="base.html#topic+FALSE">FALSE</a> keeps unchanged the previous model.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Model-remove"></a>



<h4>Method <code>remove()</code></h4>

<p>The function is used to delete a model from disc.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$remove()</pre></div>


<hr>
<a id="method-Model-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+TrainFunction">TrainFunction</a></code>
</p>

<hr>
<h2 id='MultinformationHeuristic'>Feature-clustering based on Mutual Information Computation theory.</h2><span id='topic+MultinformationHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using MCC score.
Valid for both bi-class and multi-class problems. Only valid for bi-class
problems.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>MultinformationHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MultinformationHeuristic-new"><code>MultinformationHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MultinformationHeuristic-heuristic"><code>MultinformationHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-MultinformationHeuristic-clone"><code>MultinformationHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MultinformationHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>MultinformationHeuristic$new()</pre></div>


<hr>
<a id="method-MultinformationHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Mutinformation takes two random variables as input and
computes the mutual information in nats according to the entropy
estimator method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MultinformationHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A vector/factor denoting a random variable or a data.frame
denoting a random vector where columns contain variables/features and
rows contain outcomes/samples.</p>
</dd>
<dt><code>col2</code></dt><dd><p>An another random variable or random vector (vector/factor or
data.frame).</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns the mutual information I(X;Y) in nats.
</p>


<hr>
<a id="method-MultinformationHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MultinformationHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="infotheo.html#topic+mutinformation">mutinformation</a></code>
</p>

<hr>
<h2 id='NoProbability'>Compute performance across resamples.</h2><span id='topic+NoProbability'></span>

<h3>Description</h3>

<p>Computes the performance across resamples when class
probabilities cannot be computed.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SummaryFunction">D2MCS::SummaryFunction</a></code> -&gt; <code>NoProbability</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NoProbability-new"><code>NoProbability$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NoProbability-execute"><code>NoProbability$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-NoProbability-clone"><code>NoProbability$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SummaryFunction" data-id="getMeasures"><a href='../../D2MCS/html/SummaryFunction.html#method-SummaryFunction-getMeasures'><code>D2MCS::SummaryFunction$getMeasures()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-NoProbability-new"></a>



<h4>Method <code>new()</code></h4>

<p>The function defined during runtime the usage of five
measures: 'Kappa', 'Accuracy', 'TCR_9', 'MCC' and 'PPV'.
</p>


<h5>Usage</h5>

<div class="r"><pre>NoProbability$new()</pre></div>


<hr>
<a id="method-NoProbability-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function computes the performance across resamples using
the previously defined measures.
</p>


<h5>Usage</h5>

<div class="r"><pre>NoProbability$execute(data, lev = NULL, model = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> containing the data used to
compute the performance.</p>
</dd>
<dt><code>lev</code></dt><dd><p>An optional value used to define the levels of the target
class.</p>
</dd>
<dt><code>model</code></dt><dd><p>An optional value used to define the M.L. model used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of performance estimates.
</p>


<hr>
<a id="method-NoProbability-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NoProbability$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+SummaryFunction">SummaryFunction</a></code>
</p>

<hr>
<h2 id='NPV'>Computes the Negative Predictive Value.</h2><span id='topic+NPV'></span>

<h3>Description</h3>

<p>Negative Predictive Values are the proportions of negative
results in statistics and diagnostic tests that are true negative results.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">NPV = TN / (TN + FN)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>NPV</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-NPV-new"><code>NPV$new()</code></a>
</p>
</li>
<li> <p><a href="#method-NPV-compute"><code>NPV$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-NPV-clone"><code>NPV$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-NPV-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>NPV$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <code>NPV</code>
measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-NPV-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>NPV</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>NPV$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code>  parameter
to define the type of object used as basis to compute the <strong>NPV</strong>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<a href="#topic+ClassificationOutput">ClassificationOutput</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-NPV-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>NPV$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='OddsRatioHeuristic'>Feature-clustering based on Odds Ratio measure.</h2><span id='topic+OddsRatioHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using Odds Ratio methodology.
Valid only for bi-class problems.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>OddsRatioHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-OddsRatioHeuristic-new"><code>OddsRatioHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-OddsRatioHeuristic-heuristic"><code>OddsRatioHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-OddsRatioHeuristic-clone"><code>OddsRatioHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-OddsRatioHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>OddsRatioHeuristic$new()</pre></div>


<hr>
<a id="method-OddsRatioHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Calculates the Odds Ratio method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OddsRatioHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>The object from whom odds ratio will be computed.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A second <a href="base.html#topic+factor">factor</a> or <a href="base.html#topic+numeric">numeric</a> object.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-OddsRatioHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OddsRatioHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="questionr.html#topic+odds.ratio">odds.ratio</a></code>
</p>

<hr>
<h2 id='PearsonHeuristic'>Feature-clustering based on Pearson Correlation Test.</h2><span id='topic+PearsonHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using Pearson correlation tests.
Valid for both, bi-class and multi-class problems.
</p>


<h3>Details</h3>

<p>The test statistic is based on Pearson's product moment correlation
coefficient cor(x, y) and follows a t distribution with length(x)-2 degrees
of freedom if the samples follow independent normal distributions. If there
are at least 4 complete pairs of observation, an asymptotic confidence
interval is given based on Fisher's Z transform.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>PearsonHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PearsonHeuristic-new"><code>PearsonHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PearsonHeuristic-heuristic"><code>PearsonHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-PearsonHeuristic-clone"><code>PearsonHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PearsonHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a <a href="#topic+PearsonHeuristic">PearsonHeuristic</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>PearsonHeuristic$new()</pre></div>


<hr>
<a id="method-PearsonHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Test for association between paired samples using Pearson
test.
</p>


<h5>Usage</h5>

<div class="r"><pre>PearsonHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-PearsonHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PearsonHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="stats.html#topic+cor">cor</a></code>
</p>

<hr>
<h2 id='PPV'>Computes the Positive Predictive Value.</h2><span id='topic+PPV'></span>

<h3>Description</h3>

<p>Positive Predictive Values are the proportions of positive
results in statistics and diagnostic tests that are true positive results.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">PPV = TP / (TP + FP)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>PPV</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PPV-new"><code>PPV$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PPV-compute"><code>PPV$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-PPV-clone"><code>PPV$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PPV-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPV$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <strong>PPV</strong>
measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PPV-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>PPV</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPV$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <strong>PPV</strong>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<a href="#topic+ClassificationOutput">ClassificationOutput</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-PPV-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PPV$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='Precision'>Computes the Precision Value.</h2><span id='topic+Precision'></span>

<h3>Description</h3>

<p>Precision is the fraction of relevant instances among the
retrieved instances
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">precision = TP / (TP + FP)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>Precision</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Precision-new"><code>Precision$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Precision-compute"><code>Precision$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-Precision-clone"><code>Precision$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Precision-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Precision$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Precision-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>Precision</strong> achieved by the
M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Precision$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the
<strong>Precision</strong> measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<a href="#topic+ClassificationOutput">ClassificationOutput</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-Precision-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Precision$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='Prediction'>Manages the prediction computed for a specific model.</h2><span id='topic+Prediction'></span>

<h3>Description</h3>

<p>Allows to obtain predictions from the data provided using a pre-trained model.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Prediction-new"><code>Prediction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Prediction-execute"><code>Prediction$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-Prediction-getPrediction"><code>Prediction$getPrediction()</code></a>
</p>
</li>
<li> <p><a href="#method-Prediction-getModelName"><code>Prediction$getModelName()</code></a>
</p>
</li>
<li> <p><a href="#method-Prediction-getModelPerformance"><code>Prediction$getModelPerformance()</code></a>
</p>
</li>
<li> <p><a href="#method-Prediction-clone"><code>Prediction$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Prediction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Prediction$new(model, feature.id = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model</code></dt><dd><p>A <a href="base.html#topic+list">list</a> containing the information of the
trained model composed of five elements: &quot;model.name&quot;, &quot;exec.time&quot;,
&quot;model.performance&quot;, &quot;model.data&quot; and &quot;model.libs&quot;.</p>
</dd>
<dt><code>feature.id</code></dt><dd><p>A <a href="base.html#topic+character">character</a> value containing the column name
used as identifier.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Prediction-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Calculates predictions of the values passed by parameters
using the corresponding model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Prediction$execute(pred.values, class.values, positive.class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pred.values</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> containing the values to predict.</p>
</dd>
<dt><code>class.values</code></dt><dd><p>A <a href="base.html#topic+vector">vector</a> containing the class values.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> value containing the positive
class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Prediction-getPrediction"></a>



<h4>Method <code>getPrediction()</code></h4>

<p>The function is used to return the prediction values
computed.
</p>


<h5>Usage</h5>

<div class="r"><pre>Prediction$getPrediction(type = NULL, target = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A <a href="base.html#topic+character">character</a> to define which type of predictions
should be returned. If not defined all type of probabilities will be
returned. Conversely if &quot;prob&quot; or &quot;raw&quot; is defined then computed
'probabilistic' or 'class' values are returned.</p>
</dd>
<dt><code>target</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the positive
class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> with the computed prediction.
</p>


<hr>
<a id="method-Prediction-getModelName"></a>



<h4>Method <code>getModelName()</code></h4>

<p>Gets the model name.
</p>


<h5>Usage</h5>

<div class="r"><pre>Prediction$getModelName()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+character">character</a> value of model value.
</p>


<hr>
<a id="method-Prediction-getModelPerformance"></a>



<h4>Method <code>getModelPerformance()</code></h4>

<p>Gets the performance of the model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Prediction$getModelPerformance()</pre></div>



<h5>Returns</h5>

<p>The <a href="base.html#topic+numeric">numeric</a> value of the model's performance.
</p>


<hr>
<a id="method-Prediction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Prediction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code>
</p>

<hr>
<h2 id='PredictionOutput'>Encapsulates the achieved predictions.</h2><span id='topic+PredictionOutput'></span>

<h3>Description</h3>

<p>The class used to encapsulates all the computed predictions to
facilitate their access and maintenance.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PredictionOutput-new"><code>PredictionOutput$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictionOutput-getPredictions"><code>PredictionOutput$getPredictions()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictionOutput-getType"><code>PredictionOutput$getType()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictionOutput-getTarget"><code>PredictionOutput$getTarget()</code></a>
</p>
</li>
<li> <p><a href="#method-PredictionOutput-clone"><code>PredictionOutput$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PredictionOutput-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictionOutput$new(predictions, type, target)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <a href="base.html#topic+list">list</a> of <code><a href="#topic+FinalPred">FinalPred</a></code>
elements.</p>
</dd>
<dt><code>type</code></dt><dd><p>A <a href="base.html#topic+character">character</a> to define which type of predictions
should be returned. If not defined all type of probabilities will be
returned. Conversely if &quot;prob&quot; or &quot;raw&quot; is defined then computed
'probabilistic' or 'class' values are returned.</p>
</dd>
<dt><code>target</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the
positive class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-PredictionOutput-getPredictions"></a>



<h4>Method <code>getPredictions()</code></h4>

<p>The function returns the final predictions.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictionOutput$getPredictions()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> containing the final predictions or <a href="base.html#topic+NULL">NULL</a> if
classification stage was not successfully performed.
</p>


<hr>
<a id="method-PredictionOutput-getType"></a>



<h4>Method <code>getType()</code></h4>

<p>The function returns the type of prediction should be
returned. If &quot;prob&quot; or &quot;raw&quot; is defined then computed 'probabilistic' or
'class' values are returned.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictionOutput$getType()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> value.
</p>


<hr>
<a id="method-PredictionOutput-getTarget"></a>



<h4>Method <code>getTarget()</code></h4>

<p>The function returns the value of the target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictionOutput$getTarget()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> value.
</p>


<hr>
<a id="method-PredictionOutput-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PredictionOutput$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>
</p>

<hr>
<h2 id='ProbAverageVoting'>Implementation of Probabilistic Average voting.</h2><span id='topic+ProbAverageVoting'></span>

<h3>Description</h3>

<p>Computes the final prediction by performing the mean value of
the probability achieved by each prediction.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SimpleVoting">D2MCS::SimpleVoting</a></code> -&gt; <code>ProbAverageVoting</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ProbAverageVoting-new"><code>ProbAverageVoting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageVoting-getMajorityClass"><code>ProbAverageVoting$getMajorityClass()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageVoting-getClassTie"><code>ProbAverageVoting$getClassTie()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageVoting-execute"><code>ProbAverageVoting$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageVoting-clone"><code>ProbAverageVoting$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getCutoff"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getCutoff'><code>D2MCS::SimpleVoting$getCutoff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getFinalPred"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getFinalPred'><code>D2MCS::SimpleVoting$getFinalPred()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ProbAverageVoting-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageVoting$new(cutoff = 0.5, class.tie = NULL, majority.class = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cutoff</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum probability
used to perform a positive classification. If is not defined, 0.5 will be
used as default value.</p>
</dd>
<dt><code>class.tie</code></dt><dd><p>A <a href="base.html#topic+character">character</a> used to define the target class value
used when a tie is found. If <a href="base.html#topic+NULL">NULL</a> positive class value will be
assigned.</p>
</dd>
<dt><code>majority.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the
majority class. If <a href="base.html#topic+NULL">NULL</a> will be used same value as training stage.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProbAverageVoting-getMajorityClass"></a>



<h4>Method <code>getMajorityClass()</code></h4>

<p>The function returns the value of the majority class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageVoting$getMajorityClass()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length 1 with the name of the
majority class.
</p>


<hr>
<a id="method-ProbAverageVoting-getClassTie"></a>



<h4>Method <code>getClassTie()</code></h4>

<p>The function gets the class value assigned to solve ties.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageVoting$getClassTie()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length 1.
</p>


<hr>
<a id="method-ProbAverageVoting-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function implements the majority voting procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageVoting$execute(predictions, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
all the predictions achieved for each cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProbAverageVoting-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageVoting$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+ClassMajorityVoting">ClassMajorityVoting</a></code>,
<code><a href="#topic+ClassWeightedVoting">ClassWeightedVoting</a></code>, <code><a href="#topic+ProbAverageVoting">ProbAverageVoting</a></code>,
<code><a href="#topic+ProbAverageWeightedVoting">ProbAverageWeightedVoting</a></code>, <code><a href="#topic+ProbBasedMethodology">ProbBasedMethodology</a></code>
</p>

<hr>
<h2 id='ProbAverageWeightedVoting'>Implementation of Probabilistic Average Weighted voting.</h2><span id='topic+ProbAverageWeightedVoting'></span>

<h3>Description</h3>

<p>Computes the final prediction by performing the weighted mean of
the probability achieved by each cluster prediction. By default, weight
values are consistent with the performance value achieved by the best M.L.
model on each cluster.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SimpleVoting">D2MCS::SimpleVoting</a></code> -&gt; <code>ProbAverageWeightedVoting</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ProbAverageWeightedVoting-new"><code>ProbAverageWeightedVoting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageWeightedVoting-getClassTie"><code>ProbAverageWeightedVoting$getClassTie()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageWeightedVoting-getWeights"><code>ProbAverageWeightedVoting$getWeights()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageWeightedVoting-setWeights"><code>ProbAverageWeightedVoting$setWeights()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageWeightedVoting-execute"><code>ProbAverageWeightedVoting$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbAverageWeightedVoting-clone"><code>ProbAverageWeightedVoting$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getCutoff"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getCutoff'><code>D2MCS::SimpleVoting$getCutoff()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SimpleVoting" data-id="getFinalPred"><a href='../../D2MCS/html/SimpleVoting.html#method-SimpleVoting-getFinalPred'><code>D2MCS::SimpleVoting$getFinalPred()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ProbAverageWeightedVoting-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageWeightedVoting$new(cutoff = 0.5, class.tie = NULL, weights = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cutoff</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum probability
used to perform a positive classification. If is not defined, 0.5 will be
used as default value.</p>
</dd>
<dt><code>class.tie</code></dt><dd><p>A <a href="base.html#topic+character">character</a> used to define the target class value
used when a tie is found. If <a href="base.html#topic+NULL">NULL</a> positive class value will be
assigned.</p>
</dd>
<dt><code>weights</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector with the weights of each cluster.
If <a href="base.html#topic+NULL">NULL</a> performance achieved during training will be used as
default.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProbAverageWeightedVoting-getClassTie"></a>



<h4>Method <code>getClassTie()</code></h4>

<p>The function gets the class value assigned to solve ties.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageWeightedVoting$getClassTie()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length 1.
</p>


<hr>
<a id="method-ProbAverageWeightedVoting-getWeights"></a>



<h4>Method <code>getWeights()</code></h4>

<p>The function returns the value of the majority class.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageWeightedVoting$getWeights()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of length 1 with the name of the
majority class.
</p>


<hr>
<a id="method-ProbAverageWeightedVoting-setWeights"></a>



<h4>Method <code>setWeights()</code></h4>

<p>The function allows changing the value of the weights.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageWeightedVoting$setWeights(weights)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>weights</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector containing the new weights.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProbAverageWeightedVoting-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function implements the cluster-weighted probabilistic
voting procedure.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageWeightedVoting$execute(predictions, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
all the predictions achieved for each cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProbAverageWeightedVoting-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbAverageWeightedVoting$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+ClassMajorityVoting">ClassMajorityVoting</a></code>,
<code><a href="#topic+ClassWeightedVoting">ClassWeightedVoting</a></code>, <code><a href="#topic+ProbAverageVoting">ProbAverageVoting</a></code>,
<code><a href="#topic+ProbAverageWeightedVoting">ProbAverageWeightedVoting</a></code>, <code><a href="#topic+ProbBasedMethodology">ProbBasedMethodology</a></code>
</p>

<hr>
<h2 id='ProbBasedMethodology'>Methodology to obtain the combination of the probability of different
metrics.</h2><span id='topic+ProbBasedMethodology'></span>

<h3>Description</h3>

<p>Calculates the mean of the probabilities of the different
metrics.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Methodology">D2MCS::Methodology</a></code> -&gt; <code>ProbBasedMethodology</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ProbBasedMethodology-new"><code>ProbBasedMethodology$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbBasedMethodology-compute"><code>ProbBasedMethodology$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-ProbBasedMethodology-clone"><code>ProbBasedMethodology$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="Methodology" data-id="getRequiredMetrics"><a href='../../D2MCS/html/Methodology.html#method-Methodology-getRequiredMetrics'><code>D2MCS::Methodology$getRequiredMetrics()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ProbBasedMethodology-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbBasedMethodology$new(required.metrics = c("MCC", "PPV"))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>required.metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector of length
greater than 2 with the name of the required metrics.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ProbBasedMethodology-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>Function to compute the probability of the final prediction
based on different metrics.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbBasedMethodology$compute(
  raw.pred,
  prob.pred,
  positive.class,
  negative.class
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>raw.pred</code></dt><dd><p>A <a href="base.html#topic+character">character</a> list of length greater than 2 with the
class value of the predictions made by the metrics.</p>
</dd>
<dt><code>prob.pred</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> list of length greater than 2 with the
probability of the predictions made by the metrics.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the positive
class.</p>
</dd>
<dt><code>negative.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the
negative class.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value indicating the probability of the instance
is predicted as positive class.
</p>


<hr>
<a id="method-ProbBasedMethodology-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ProbBasedMethodology$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Methodology">Methodology</a></code>
</p>

<hr>
<h2 id='Recall'>Computes the Recall Value.</h2><span id='topic+Recall'></span>

<h3>Description</h3>

<p>Recall (also known as sensitivity) is the fraction of the total
amount of relevant instances that were actually retrieved.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">recall = TP / (TP + FN)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>Recall</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Recall-new"><code>Recall$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Recall-compute"><code>Recall$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-Recall-clone"><code>Recall$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Recall-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Recall$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Recall-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>Recall</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Recall$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <strong>Recall</strong>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if
an error occurred.
</p>


<hr>
<a id="method-Recall-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Recall$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='Sensitivity'>Computes the Sensitivity Value.</h2><span id='topic+Sensitivity'></span>

<h3>Description</h3>

<p>Sensitivity is a measure of the proportion of actual positive
cases that got predicted as positive (or true positive).
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">Sensitivity = TP / (TP + FN)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>Sensitivity</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Sensitivity-new"><code>Sensitivity$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Sensitivity-compute"><code>Sensitivity$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-Sensitivity-clone"><code>Sensitivity$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Sensitivity-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sensitivity$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the
<code>Sensitivity</code> measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Sensitivity-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>Sensitivity</strong> achieved by the
M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sensitivity$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the
<strong>Sensitivity</strong> measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<a href="#topic+ClassificationOutput">ClassificationOutput</a> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if
an error occurred.
</p>


<hr>
<a id="method-Sensitivity-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Sensitivity$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='SimpleStrategy'>Simple feature clustering strategy.</h2><span id='topic+SimpleStrategy'></span>

<h3>Description</h3>

<p>Features are sorted by descendant according to the relevance
value obtained after applying an specific heuristic. Next, features are
distributed into N clusters following a card-dealing methodology. Finally
best distribution is assigned to the distribution having highest homogeneity.
</p>


<h3>Details</h3>

<p>The strategy is suitable for all features that are valid for the
indicated heuristics. Invalid features are automatically grouped into a
specific cluster named as 'unclustered'.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClusteringStrategy">D2MCS::GenericClusteringStrategy</a></code> -&gt; <code>SimpleStrategy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimpleStrategy-new"><code>SimpleStrategy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-execute"><code>SimpleStrategy$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-getBestClusterDistribution"><code>SimpleStrategy$getBestClusterDistribution()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-getUnclustered"><code>SimpleStrategy$getUnclustered()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-getDistribution"><code>SimpleStrategy$getDistribution()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-createTrain"><code>SimpleStrategy$createTrain()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-plot"><code>SimpleStrategy$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-saveCSV"><code>SimpleStrategy$saveCSV()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleStrategy-clone"><code>SimpleStrategy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getConfiguration"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getConfiguration'><code>D2MCS::GenericClusteringStrategy$getConfiguration()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getDescription"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getDescription'><code>D2MCS::GenericClusteringStrategy$getDescription()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getHeuristic"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getHeuristic'><code>D2MCS::GenericClusteringStrategy$getHeuristic()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SimpleStrategy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$new(
  subset,
  heuristic,
  configuration = StrategyConfiguration$new()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>The <code><a href="#topic+Subset">Subset</a></code> used to apply the
feature-clustering strategy.</p>
</dd>
<dt><code>heuristic</code></dt><dd><p>The heuristic used to compute the relevance of each
feature. Must inherit from <code><a href="#topic+GenericHeuristic">GenericHeuristic</a></code> abstract class.</p>
</dd>
<dt><code>configuration</code></dt><dd><p>Optional parameter to customize configuration
parameters for the strategy. Must inherited from
<code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code> abstract class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleStrategy-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Function responsible of performing the clustering
strategy over the defined <code><a href="#topic+Subset">Subset</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$execute(verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>A logical value to specify if more verbosity is needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleStrategy-getBestClusterDistribution"></a>



<h4>Method <code>getBestClusterDistribution()</code></h4>

<p>The function obtains the best clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$getBestClusterDistribution()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> of clusters. Each list element represents a feature
group.
</p>


<hr>
<a id="method-SimpleStrategy-getUnclustered"></a>



<h4>Method <code>getUnclustered()</code></h4>

<p>The function is used to return the features that cannot be
clustered due to incompatibilities with the used heuristic.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$getUnclustered()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector containing the unclassified features.
</p>


<hr>
<a id="method-SimpleStrategy-getDistribution"></a>



<h4>Method <code>getDistribution()</code></h4>

<p>Function used to obtain a specific cluster distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$getDistribution(
  num.clusters = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.clusters</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> with the features comprising an specific clustering
distribution.
</p>


<hr>
<a id="method-SimpleStrategy-createTrain"></a>



<h4>Method <code>createTrain()</code></h4>

<p>The function is used to create a <code><a href="#topic+Trainset">Trainset</a></code>
object from a specific clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$createTrain(
  subset,
  num.clusters = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>The <code><a href="#topic+Subset">Subset</a></code> object used as a basis to create
the train set (see <code><a href="#topic+Trainset">Trainset</a></code> class).</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If <code>num.clusters</code> and <code>num.groups</code> are not defined,
best clustering distribution is used to create the train set.
</p>



<h5>Returns</h5>

<p>A <code><a href="#topic+Trainset">Trainset</a></code> object.
</p>


<hr>
<a id="method-SimpleStrategy-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>The function is responsible for creating a plot to visualize
the clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$plot(dir.path = NULL, file.name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>An optional argument to define the name of the directory
where the exported plot will be saved. If not defined, the file path will
be automatically assigned to the current working directory,
'<code>getwd()</code>'.</p>
</dd>
<dt><code>file.name</code></dt><dd><p>A character to define the name of the PDF file where the
plot is exported.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleStrategy-saveCSV"></a>



<h4>Method <code>saveCSV()</code></h4>

<p>The function is used to save the clustering distribution to
a CSV file.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$saveCSV(dir.path, name = NULL, num.clusters = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The name of the directory to save the CSV file.</p>
</dd>
<dt><code>name</code></dt><dd><p>Defines the name of the CSV file.</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>An optional parameter to select the number of
clusters to be saved. If not defined, all cluster distributions will be saved.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleStrategy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleStrategy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a></code>,
<code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code>
</p>

<hr>
<h2 id='SimpleVoting'>Abtract class to define simple voting schemes.</h2><span id='topic+SimpleVoting'></span>

<h3>Description</h3>

<p>Abstract class used as a template to define new customized
simple voting schemes.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SimpleVoting-new"><code>SimpleVoting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleVoting-getCutoff"><code>SimpleVoting$getCutoff()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleVoting-getFinalPred"><code>SimpleVoting$getFinalPred()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleVoting-execute"><code>SimpleVoting$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-SimpleVoting-clone"><code>SimpleVoting$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SimpleVoting-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleVoting$new(cutoff = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cutoff</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector defining the minimum probability
used to perform a positive classification. If is not defined, 0.5 will be
used as default value.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleVoting-getCutoff"></a>



<h4>Method <code>getCutoff()</code></h4>

<p>The function obtains the minimum probabilistic value used to
perform a positive classification.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleVoting$getCutoff()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value.
</p>


<hr>
<a id="method-SimpleVoting-getFinalPred"></a>



<h4>Method <code>getFinalPred()</code></h4>

<p>The function is used to return the prediction values
computed by a voting strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleVoting$getFinalPred(type = NULL, target = NULL, filter = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>type</code></dt><dd><p>A <a href="base.html#topic+character">character</a> to define which type of predictions
should be returned. If not defined all type of probabilities will be
returned. Conversely if 'prob' or 'raw' is defined then computed
'probabilistic' or 'class' values are returned.</p>
</dd>
<dt><code>target</code></dt><dd><p>A <a href="base.html#topic+character">character</a> defining the value of the positive
class.</p>
</dd>
<dt><code>filter</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value used to specify if only predictions
matching the target value should be returned or not. If <a href="base.html#topic+TRUE">TRUE</a> the
function returns only the predictions matching the target value.
Conversely if <a href="base.html#topic+FALSE">FALSE</a> (by default) the function returns all the
predictions.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="#topic+FinalPred">FinalPred</a> object.
</p>


<hr>
<a id="method-SimpleVoting-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Abstract function used to implement the operation of the
voting scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleVoting$execute(predictions, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
all the predictions achieved for each cluster.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SimpleVoting-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SimpleVoting$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+ClassMajorityVoting">ClassMajorityVoting</a></code>,
<code><a href="#topic+ClassWeightedVoting">ClassWeightedVoting</a></code>, <code><a href="#topic+ProbAverageVoting">ProbAverageVoting</a></code>,
<code><a href="#topic+ProbAverageWeightedVoting">ProbAverageWeightedVoting</a></code>, <code><a href="#topic+ProbBasedMethodology">ProbBasedMethodology</a></code>,
<code><a href="#topic+CombinedVoting">CombinedVoting</a></code>
</p>

<hr>
<h2 id='SingleVoting'>Manages the execution of Simple Votings.</h2><span id='topic+SingleVoting'></span>

<h3>Description</h3>

<p>The class is responsible of initializing and executing voting
schemes. Additionally, to ensure a proper operation, the class automatically
checks the compatibility of defined voting schemes.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+VotingStrategy">D2MCS::VotingStrategy</a></code> -&gt; <code>SingleVoting</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SingleVoting-new"><code>SingleVoting$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SingleVoting-execute"><code>SingleVoting$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-SingleVoting-clone"><code>SingleVoting$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="VotingStrategy" data-id="getMetrics"><a href='../../D2MCS/html/VotingStrategy.html#method-VotingStrategy-getMetrics'><code>D2MCS::VotingStrategy$getMetrics()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="VotingStrategy" data-id="getName"><a href='../../D2MCS/html/VotingStrategy.html#method-VotingStrategy-getName'><code>D2MCS::VotingStrategy$getName()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="VotingStrategy" data-id="getVotingSchemes"><a href='../../D2MCS/html/VotingStrategy.html#method-VotingStrategy-getVotingSchemes'><code>D2MCS::VotingStrategy$getVotingSchemes()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-SingleVoting-new"></a>



<h4>Method <code>new()</code></h4>

<p>The function initializes the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>SingleVoting$new(voting.schemes, metrics)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>voting.schemes</code></dt><dd><p>A <a href="base.html#topic+vector">vector</a> of voting schemes inheriting from
<code><a href="#topic+SimpleVoting">SimpleVoting</a></code> class.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>A <a href="base.html#topic+list">list</a> containing the metrics used as basis to
perform the voting strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SingleVoting-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function is used to execute all the previously defined
(and compatible) voting schemes.
</p>


<h5>Usage</h5>

<div class="r"><pre>SingleVoting$execute(predictions, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
all the predictions computed in the classification stage.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SingleVoting-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SingleVoting$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+SimpleVoting">SimpleVoting</a></code>,
<code><a href="#topic+CombinedVoting">CombinedVoting</a></code>
</p>

<hr>
<h2 id='SpearmanHeuristic'>Feature-clustering based on Spearman Correlation Test.</h2><span id='topic+SpearmanHeuristic'></span>

<h3>Description</h3>

<p>Performs the feature-clustering using Spearman's rho statistic.
</p>


<h3>Details</h3>

<p>Spearman's rho statistic is to estimate a rank-based measure of
association. These tests may be used if the data do not necessarily come from
a bivariate normal distribution.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericHeuristic">D2MCS::GenericHeuristic</a></code> -&gt; <code>SpearmanHeuristic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SpearmanHeuristic-new"><code>SpearmanHeuristic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SpearmanHeuristic-heuristic"><code>SpearmanHeuristic$heuristic()</code></a>
</p>
</li>
<li> <p><a href="#method-SpearmanHeuristic-clone"><code>SpearmanHeuristic$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SpearmanHeuristic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates a <a href="#topic+SpearmanHeuristic">SpearmanHeuristic</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpearmanHeuristic$new()</pre></div>


<hr>
<a id="method-SpearmanHeuristic-heuristic"></a>



<h4>Method <code>heuristic()</code></h4>

<p>Test for correlation between paired samples using Spearman
rho statistic.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpearmanHeuristic$heuristic(col1, col2, column.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>col1</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix required to perform the
clustering operation.</p>
</dd>
<dt><code>col2</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> vector or matrix to perform the clustering
operation.</p>
</dd>
<dt><code>column.names</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> vector with the names of
both columns.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1 or <a href="base.html#topic+NA">NA</a> if an error
occurs.
</p>


<hr>
<a id="method-SpearmanHeuristic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SpearmanHeuristic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="stats.html#topic+cor.test">cor.test</a></code>
</p>

<hr>
<h2 id='Specificity'>Computes the Specificity Value.</h2><span id='topic+Specificity'></span>

<h3>Description</h3>

<p>Specificity is defined as the proportion of actual negatives,
which got predicted as the negative (or true negative). This implies that
there will be another proportion of actual negative, which got predicted as
positive and could be termed as false positives.
</p>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">Specificity = True Negative / (True Negative + False Positive)</code>
</p>



<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>Specificity</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Specificity-new"><code>Specificity$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Specificity-compute"><code>Specificity$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-Specificity-clone"><code>Specificity$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Specificity-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Specificity$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Specificity-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>Specificity</strong> achieved by the
M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Specificity$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the
<strong>Specificity</strong> measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if an error
occurred.
</p>


<hr>
<a id="method-Specificity-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Specificity$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='StrategyConfiguration'>Default Strategy Configuration handler.</h2><span id='topic+StrategyConfiguration'></span>

<h3>Description</h3>

<p>Define default configuration parameters for the clustering
strategies.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code> can be used to define the
default configuration parameters for a feature clustering strategy or as an
archetype to define new customized parameters.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StrategyConfiguration-new"><code>StrategyConfiguration$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StrategyConfiguration-minNumClusters"><code>StrategyConfiguration$minNumClusters()</code></a>
</p>
</li>
<li> <p><a href="#method-StrategyConfiguration-maxNumClusters"><code>StrategyConfiguration$maxNumClusters()</code></a>
</p>
</li>
<li> <p><a href="#method-StrategyConfiguration-clone"><code>StrategyConfiguration$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StrategyConfiguration-new"></a>



<h4>Method <code>new()</code></h4>

<p>Empty function used to initialize the object arguments in
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>StrategyConfiguration$new()</pre></div>


<hr>
<a id="method-StrategyConfiguration-minNumClusters"></a>



<h4>Method <code>minNumClusters()</code></h4>

<p>Function used to return the minimum number of clusters
distributions used. By default the minimum is set in 2.
</p>


<h5>Usage</h5>

<div class="r"><pre>StrategyConfiguration$minNumClusters(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>minNumClusters</code>
function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1.
</p>


<hr>
<a id="method-StrategyConfiguration-maxNumClusters"></a>



<h4>Method <code>maxNumClusters()</code></h4>

<p>The function is responsible of returning the maximum number
of cluster distributions used. By default the maximum number is set in 50.
</p>


<h5>Usage</h5>

<div class="r"><pre>StrategyConfiguration$maxNumClusters(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>maxNumClusters</code>
function.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of length 1.
</p>


<hr>
<a id="method-StrategyConfiguration-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StrategyConfiguration$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+DependencyBasedStrategyConfiguration">DependencyBasedStrategyConfiguration</a></code>
</p>

<hr>
<h2 id='Subset'>Classification set.</h2><span id='topic+Subset'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+Subset">Subset</a></code> is used for testing or classification
purposes. If a target class is defined the <code><a href="#topic+Subset">Subset</a></code> can be used
as test and classification, otherwise the <code><a href="#topic+Subset">Subset</a></code> only
classification is compatible.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+Dataset">Dataset</a></code> to ensure the creation of a valid
<code><a href="#topic+Subset">Subset</a></code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Subset-new"><code>Subset$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getColumnNames"><code>Subset$getColumnNames()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getFeatures"><code>Subset$getFeatures()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getID"><code>Subset$getID()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getIterator"><code>Subset$getIterator()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getClassValues"><code>Subset$getClassValues()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getClassBalance"><code>Subset$getClassBalance()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getClassIndex"><code>Subset$getClassIndex()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getClassName"><code>Subset$getClassName()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getNcol"><code>Subset$getNcol()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getNrow"><code>Subset$getNrow()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-getPositiveClass"><code>Subset$getPositiveClass()</code></a>
</p>
</li>
<li> <p><a href="#method-Subset-isBlinded"><code>Subset$isBlinded()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Subset-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$new(
  dataset,
  class.index = NULL,
  class.values = NULL,
  positive.class = NULL,
  feature.id = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dataset</code></dt><dd><p>A fully filled <a href="base.html#topic+data.frame">data.frame</a>.</p>
</dd>
<dt><code>class.index</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value identifying the column
representing the target class</p>
</dd>
<dt><code>class.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing all the values
of the target class.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> value representing the positive
class value.</p>
</dd>
<dt><code>feature.id</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value specifying the column number
used as identifier.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Subset-getColumnNames"></a>



<h4>Method <code>getColumnNames()</code></h4>

<p>Get the name of the columns comprising the subset.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getColumnNames()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector containing the name of each column.
</p>


<hr>
<a id="method-Subset-getFeatures"></a>



<h4>Method <code>getFeatures()</code></h4>

<p>Gets the values of all features or those indicated by
arguments.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getFeatures(feature.names = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>feature.names</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector comprising the name of the
features to be obtained.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector or NULL if subset is empty.
</p>


<hr>
<a id="method-Subset-getID"></a>



<h4>Method <code>getID()</code></h4>

<p>Gets the column name used as identifier.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getID()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of size 1 of NULL if column id is not
defined.
</p>


<hr>
<a id="method-Subset-getIterator"></a>



<h4>Method <code>getIterator()</code></h4>

<p>Creates the <a href="#topic+DIterator">DIterator</a> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getIterator(chunk.size = private$chunk.size, verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>chunk.size</code></dt><dd><p>An <a href="base.html#topic+integer">integer</a> value indicating the size of chunks taken
over each iteration. By default chunk.size is defined as 10000.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code><a href="#topic+DIterator">DIterator</a></code> object to transverse through
<code><a href="#topic+Subset">Subset</a></code> instances.
</p>


<hr>
<a id="method-Subset-getClassValues"></a>



<h4>Method <code>getClassValues()</code></h4>

<p>Gets all the values of the target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getClassValues()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+factor">factor</a> vector with all the values of the target class.
</p>


<hr>
<a id="method-Subset-getClassBalance"></a>



<h4>Method <code>getClassBalance()</code></h4>

<p>The function is used to compute the ratio of each class
value in the <code><a href="#topic+Subset">Subset</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getClassBalance(target.value = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>target.value</code></dt><dd><p>The class value used as reference to perform the
comparison.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value.
</p>


<hr>
<a id="method-Subset-getClassIndex"></a>



<h4>Method <code>getClassIndex()</code></h4>

<p>The function is used to obtain the index of the column
containing the target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getClassIndex()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value.
</p>


<hr>
<a id="method-Subset-getClassName"></a>



<h4>Method <code>getClassName()</code></h4>

<p>The function is used to specify the name of the column
containing the target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getClassName()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> value.
</p>


<hr>
<a id="method-Subset-getNcol"></a>



<h4>Method <code>getNcol()</code></h4>

<p>The function is in charge of obtaining the number of columns
comprising the <code><a href="#topic+Subset">Subset</a></code>. See <code><a href="base.html#topic+ncol">ncol</a></code> for more
information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getNcol()</pre></div>



<h5>Returns</h5>

<p>An <a href="base.html#topic+integer">integer</a> of length 1 or <a href="base.html#topic+NULL">NULL</a>.
</p>


<hr>
<a id="method-Subset-getNrow"></a>



<h4>Method <code>getNrow()</code></h4>

<p>The function is used to determine the number of rows present
in the <code><a href="#topic+Subset">Subset</a></code>. See <code><a href="base.html#topic+nrow">nrow</a></code> for more information.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getNrow()</pre></div>



<h5>Returns</h5>

<p>An <a href="base.html#topic+integer">integer</a> of length 1 or <a href="base.html#topic+NULL">NULL</a>.
</p>


<hr>
<a id="method-Subset-getPositiveClass"></a>



<h4>Method <code>getPositiveClass()</code></h4>

<p>The function returns the value of the positive class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$getPositiveClass()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if not defined.
</p>


<hr>
<a id="method-Subset-isBlinded"></a>



<h4>Method <code>isBlinded()</code></h4>

<p>The function is used to check if the <a href="#topic+Subset">Subset</a> contains
a target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Subset$isBlinded()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value where <a href="base.html#topic+TRUE">TRUE</a> represents the absence
of target class and <a href="base.html#topic+FALSE">FALSE</a> its presence.
</p>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="#topic+DatasetLoader">DatasetLoader</a></code>,
<code><a href="#topic+Trainset">Trainset</a></code>
</p>

<hr>
<h2 id='SummaryFunction'>Abstract class to computing performance across resamples.</h2><span id='topic+SummaryFunction'></span>

<h3>Description</h3>

<p>Abstract used as template to define customized metrics to
compute model performance during train.
</p>


<h3>Details</h3>

<p>This class is an archetype, so it cannot be instantiated.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SummaryFunction-new"><code>SummaryFunction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SummaryFunction-execute"><code>SummaryFunction$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-SummaryFunction-getMeasures"><code>SummaryFunction$getMeasures()</code></a>
</p>
</li>
<li> <p><a href="#method-SummaryFunction-clone"><code>SummaryFunction$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SummaryFunction-new"></a>



<h4>Method <code>new()</code></h4>

<p>The function carries out the initialization of parameters
during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>SummaryFunction$new(measures)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>measures</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector with the measures used.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SummaryFunction-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Abstract function used to implement the performance
calculator method. To guarantee a proper operation, this method is
automatically invoked by <code><a href="#topic+D2MCS">D2MCS</a></code> framework.
</p>


<h5>Usage</h5>

<div class="r"><pre>SummaryFunction$execute()</pre></div>


<hr>
<a id="method-SummaryFunction-getMeasures"></a>



<h4>Method <code>getMeasures()</code></h4>

<p>The function obtains the measures used to compute the
performance across resamples.
</p>


<h5>Usage</h5>

<div class="r"><pre>SummaryFunction$getMeasures()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of <a href="base.html#topic+NULL">NULL</a> if measures are not
defined.
</p>


<hr>
<a id="method-SummaryFunction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SummaryFunction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+NoProbability">NoProbability</a></code>, <code><a href="#topic+UseProbability">UseProbability</a></code>
</p>

<hr>
<h2 id='TN'>Computes the True Negative value.</h2><span id='topic+TN'></span>

<h3>Description</h3>

<p>This is the number of individuals with a negative condition for
which the test result is negative. The value entered here must be non-negative.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>TN</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TN-new"><code>TN$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TN-compute"><code>TN$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-TN-clone"><code>TN$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TN-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>TN$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used to compute the <strong>TN</strong> measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TN-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>TN</strong> achieved by the M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>TN$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <strong>TN</strong>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if
an error occurred.
</p>


<hr>
<a id="method-TN-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TN$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='TP'>Computes the True Positive Value.</h2><span id='topic+TP'></span>

<h3>Description</h3>

<p>TP is the number of individuals with a positive condition for
which the test result is positive. The value entered here must be non-negative.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+MeasureFunction">D2MCS::MeasureFunction</a></code> -&gt; <code>TP</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TP-new"><code>TP$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TP-compute"><code>TP$compute()</code></a>
</p>
</li>
<li> <p><a href="#method-TP-clone"><code>TP$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TP-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>TP$new(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used to compute the measure.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TP-compute"></a>



<h4>Method <code>compute()</code></h4>

<p>The function computes the <strong>TP</strong> achieved by the M.L.
model.
</p>


<h5>Usage</h5>

<div class="r"><pre>TP$compute(performance.output = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>performance.output</code></dt><dd><p>An optional <code><a href="#topic+ConfMatrix">ConfMatrix</a></code> parameter
to define the type of object used as basis to compute the <strong>TP</strong>
measure.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>This function is automatically invoke by the
<code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code> object.
</p>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1 or <a href="base.html#topic+NULL">NULL</a> if
an error occurred.
</p>


<hr>
<a id="method-TP-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TP$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+MeasureFunction">MeasureFunction</a></code>, <code><a href="#topic+ClassificationOutput">ClassificationOutput</a></code>,
<code><a href="#topic+ConfMatrix">ConfMatrix</a></code>
</p>

<hr>
<h2 id='TrainFunction'>Control parameters for train stage.</h2><span id='topic+TrainFunction'></span>

<h3>Description</h3>

<p>Abstract class used as template to define customized functions
to control the computational nuances of train function.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TrainFunction-new"><code>TrainFunction$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-create"><code>TrainFunction$create()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getResamplingMethod"><code>TrainFunction$getResamplingMethod()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getNumberFolds"><code>TrainFunction$getNumberFolds()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getSavePredictions"><code>TrainFunction$getSavePredictions()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getClassProbs"><code>TrainFunction$getClassProbs()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getAllowParallel"><code>TrainFunction$getAllowParallel()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getVerboseIter"><code>TrainFunction$getVerboseIter()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getTrFunction"><code>TrainFunction$getTrFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getMeasures"><code>TrainFunction$getMeasures()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getType"><code>TrainFunction$getType()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-getSeed"><code>TrainFunction$getSeed()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-setSummaryFunction"><code>TrainFunction$setSummaryFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-setClassProbs"><code>TrainFunction$setClassProbs()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainFunction-clone"><code>TrainFunction$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TrainFunction-new"></a>



<h4>Method <code>new()</code></h4>

<p>Function used to initialize the object parameters during
execution time.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$new(
  method,
  number,
  savePredictions,
  classProbs,
  allowParallel,
  verboseIter,
  seed
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>The resampling method: &quot;boot&quot;, &quot;boot632&quot;, &quot;optimism_boot&quot;,
&quot;boot_all&quot;, &quot;cv&quot;, &quot;repeatedcv&quot;, &quot;LOOCV&quot;, &quot;LGOCV&quot; (for repeated
training/test splits), &quot;none&quot; (only fits one model to the entire training
set), &quot;oob&quot; (only for random forest, bagged trees, bagged earth, bagged
flexible discriminant analysis, or conditional tree forest models),
timeslice, &quot;adaptive_cv&quot;, &quot;adaptive_boot&quot; or &quot;adaptive_LGOCV&quot;</p>
</dd>
<dt><code>number</code></dt><dd><p>Either the number of folds or number of resampling
iterations</p>
</dd>
<dt><code>savePredictions</code></dt><dd><p>An indicator of how much of the hold-out
predictions for each resample should be saved. Values can be either
&quot;all&quot;, &quot;final&quot;, or &quot;none&quot;. A logical value can also be used that convert
to &quot;all&quot; (for true) or &quot;none&quot; (for false). &quot;final&quot; saves the predictions
for the optimal tuning parameters.</p>
</dd>
<dt><code>classProbs</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value. Should class probabilities be
computed for classification models (along with predicted values) in each
resample?</p>
</dd>
<dt><code>allowParallel</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value. If a parallel backend is
loaded and available, should the function use it?</p>
</dd>
<dt><code>verboseIter</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> for printing a training log.</p>
</dd>
<dt><code>seed</code></dt><dd><p>An optional <a href="base.html#topic+integer">integer</a> that will be used to set the seed
during model training stage.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainFunction-create"></a>



<h4>Method <code>create()</code></h4>

<p>Creates a <code><a href="caret.html#topic+trainControl">trainControl</a></code> requires for the
training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$create(summaryFunction, search.method = "grid", class.probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>summaryFunction</code></dt><dd><p>An object inherited from
<code><a href="#topic+SummaryFunction">SummaryFunction</a></code> class.</p>
</dd>
<dt><code>search.method</code></dt><dd><p>Either &quot;grid&quot; or &quot;random&quot;, describing how the tuning
parameter grid is determined.</p>
</dd>
<dt><code>class.probs</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> indicating if class probabilities
should be computed for classification models (along with predicted values)
in each resample.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainFunction-getResamplingMethod"></a>



<h4>Method <code>getResamplingMethod()</code></h4>

<p>Returns the resampling method used during training staged.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getResamplingMethod()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector or length 1 or <a href="base.html#topic+NULL">NULL</a>
if not defined.
</p>


<hr>
<a id="method-TrainFunction-getNumberFolds"></a>



<h4>Method <code>getNumberFolds()</code></h4>

<p>Returns the number or folds or number of iterations used
during training.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getNumberFolds()</pre></div>



<h5>Returns</h5>

<p>An <a href="base.html#topic+integer">integer</a> vector or length 1 or <a href="base.html#topic+NULL">NULL</a> if not
defined.
</p>


<hr>
<a id="method-TrainFunction-getSavePredictions"></a>



<h4>Method <code>getSavePredictions()</code></h4>

<p>Indicates if the predictions for each resample should be
saved.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getSavePredictions()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value or <a href="base.html#topic+NULL">NULL</a> if not defined.
</p>


<hr>
<a id="method-TrainFunction-getClassProbs"></a>



<h4>Method <code>getClassProbs()</code></h4>

<p>Indicates if class probabilities should be computed for
classification models in each resample.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getClassProbs()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value.
</p>


<hr>
<a id="method-TrainFunction-getAllowParallel"></a>



<h4>Method <code>getAllowParallel()</code></h4>

<p>Determines if model training is performed in parallel.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getAllowParallel()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value. <a href="base.html#topic+TRUE">TRUE</a> indicates parallelization is
enabled and <a href="base.html#topic+FALSE">FALSE</a> otherwise.
</p>


<hr>
<a id="method-TrainFunction-getVerboseIter"></a>



<h4>Method <code>getVerboseIter()</code></h4>

<p>Determines if training log should be printed.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getVerboseIter()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+logical">logical</a> value. <a href="base.html#topic+TRUE">TRUE</a> indicates training log is
enabled and <a href="base.html#topic+FALSE">FALSE</a> otherwise.
</p>


<hr>
<a id="method-TrainFunction-getTrFunction"></a>



<h4>Method <code>getTrFunction()</code></h4>

<p>Function used to return the
<code><a href="caret.html#topic+trainControl">trainControl</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getTrFunction()</pre></div>



<h5>Returns</h5>

<p>A <code><a href="caret.html#topic+trainControl">trainControl</a></code> object.
</p>


<hr>
<a id="method-TrainFunction-getMeasures"></a>



<h4>Method <code>getMeasures()</code></h4>

<p>Returns the measures used to optimize model hyperparameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getMeasures()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector.
</p>


<hr>
<a id="method-TrainFunction-getType"></a>



<h4>Method <code>getType()</code></h4>

<p>Obtains the type of classification problem (&quot;Bi-class&quot; or
&quot;Multi-class&quot;).
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getType()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with length 1. Either &quot;Bi-class&quot;
or &quot;Multi-class&quot;.
</p>


<hr>
<a id="method-TrainFunction-getSeed"></a>



<h4>Method <code>getSeed()</code></h4>

<p>Indicates seed used during model training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$getSeed()</pre></div>



<h5>Returns</h5>

<p>An <a href="base.html#topic+integer">integer</a> value or <a href="base.html#topic+NULL">NULL</a> if not defined.
</p>


<hr>
<a id="method-TrainFunction-setSummaryFunction"></a>



<h4>Method <code>setSummaryFunction()</code></h4>

<p>Function used to change the <code><a href="#topic+SummaryFunction">SummaryFunction</a></code>
used in the training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$setSummaryFunction(summaryFunction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>summaryFunction</code></dt><dd><p>An object inherited from
<code><a href="#topic+SummaryFunction">SummaryFunction</a></code> class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainFunction-setClassProbs"></a>



<h4>Method <code>setClassProbs()</code></h4>

<p>The function allows changing the class computation
capabilities.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$setClassProbs(class.probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class.probs</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> indicating if class probabilities
should be computed for classification models (along with predicted values)
in each resample</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainFunction-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainFunction$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+TwoClass">TwoClass</a></code>
</p>

<hr>
<h2 id='TrainOutput'>Stores the results achieved during training.</h2><span id='topic+TrainOutput'></span>

<h3>Description</h3>

<p>This class manages the results achieved during training stage
(such as optimized hyperparameters, model information, utilized metrics).
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TrainOutput-new"><code>TrainOutput$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-getModels"><code>TrainOutput$getModels()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-getPerformance"><code>TrainOutput$getPerformance()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-savePerformance"><code>TrainOutput$savePerformance()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-plot"><code>TrainOutput$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-getMetrics"><code>TrainOutput$getMetrics()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-getClassValues"><code>TrainOutput$getClassValues()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-getPositiveClass"><code>TrainOutput$getPositiveClass()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-getSize"><code>TrainOutput$getSize()</code></a>
</p>
</li>
<li> <p><a href="#method-TrainOutput-clone"><code>TrainOutput$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-TrainOutput-new"></a>



<h4>Method <code>new()</code></h4>

<p>Function used to initialize the object arguments during
runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$new(models, class.values, positive.class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>models</code></dt><dd><p>A <a href="base.html#topic+list">list</a> containing the best M.L. model for each
cluster.</p>
</dd>
<dt><code>class.values</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector containing the values of
the target class.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the positive
class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainOutput-getModels"></a>



<h4>Method <code>getModels()</code></h4>

<p>The function is used to obtain the best M.L. model of each
cluster.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$getModels(metric)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>metric</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector which specifies the metric(s)
used for configuring M.L. hyperparameters.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> is returned of class train.
</p>


<hr>
<a id="method-TrainOutput-getPerformance"></a>



<h4>Method <code>getPerformance()</code></h4>

<p>The function returns the performance value of M.L. models
during training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$getPerformance(metrics = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>metrics</code></dt><dd><p>A <a href="base.html#topic+character">character</a> vector which specifies the metric(s)
used to train the M.L. models.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector containing the metrics used for
configuring M.L. hyperparameters.
</p>


<hr>
<a id="method-TrainOutput-savePerformance"></a>



<h4>Method <code>savePerformance()</code></h4>

<p>The function is used to save into CSV file the performance
achieved by the M.L. models during training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$savePerformance(dir.path, metrics = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The location to store the into a CSV file the performance
of the trained M.L.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>An optional parameter specifying the metric(s) used to
train the M.L. models. If not defined, all the metrics used in train
stage will be saved.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainOutput-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>The function is responsible for creating a plot to visualize
the performance achieved by the best M.L. model on each cluster.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$plot(dir.path, metrics = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The location to store the exported plot will be saved.</p>
</dd>
<dt><code>metrics</code></dt><dd><p>An optional parameter specifying the metric(s) used to
train the M.L. models. If not defined, all the metrics used in train
stage will be plotted.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TrainOutput-getMetrics"></a>



<h4>Method <code>getMetrics()</code></h4>

<p>The function returns all metrics used for configuring M.L.
hyperparameters during train stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$getMetrics()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> value.
</p>


<hr>
<a id="method-TrainOutput-getClassValues"></a>



<h4>Method <code>getClassValues()</code></h4>

<p>The function is used to get the values of the target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$getClassValues()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> containing the values of the target class.
</p>


<hr>
<a id="method-TrainOutput-getPositiveClass"></a>



<h4>Method <code>getPositiveClass()</code></h4>

<p>The function returns the value of the positive class.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$getPositiveClass()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of size 1.
</p>


<hr>
<a id="method-TrainOutput-getSize"></a>



<h4>Method <code>getSize()</code></h4>

<p>The function is used to get the number of the trained M.L.
models. Each cluster contains the best M.L. model.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$getSize()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value or <a href="base.html#topic+NULL">NULL</a> training was not
successfully performed.
</p>


<hr>
<a id="method-TrainOutput-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TrainOutput$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>
</p>

<hr>
<h2 id='Trainset'>Trainning set.</h2><span id='topic+Trainset'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+Trainset">Trainset</a></code> is used to perform training
operations over M.L. models. A target class should be defined to guarantee a
full compatibility with supervised models.
</p>


<h3>Details</h3>

<p>Use <code><a href="#topic+Dataset">Dataset</a></code> object to ensure the creation of a valid
<code><a href="#topic+Trainset">Trainset</a></code> object.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Trainset-new"><code>Trainset$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Trainset-getPositiveClass"><code>Trainset$getPositiveClass()</code></a>
</p>
</li>
<li> <p><a href="#method-Trainset-getClassName"><code>Trainset$getClassName()</code></a>
</p>
</li>
<li> <p><a href="#method-Trainset-getClassValues"><code>Trainset$getClassValues()</code></a>
</p>
</li>
<li> <p><a href="#method-Trainset-getColumnNames"><code>Trainset$getColumnNames()</code></a>
</p>
</li>
<li> <p><a href="#method-Trainset-getFeatureValues"><code>Trainset$getFeatureValues()</code></a>
</p>
</li>
<li> <p><a href="#method-Trainset-getInstances"><code>Trainset$getInstances()</code></a>
</p>
</li>
<li> <p><a href="#method-Trainset-getNumClusters"><code>Trainset$getNumClusters()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Trainset-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$new(cluster.dist, class.name, class.values, positive.class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cluster.dist</code></dt><dd><p>The type of cluster distribution used as basis
to build the <code><a href="#topic+Trainset">Trainset</a></code>. See
<code><a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a></code> for more information.</p>
</dd>
<dt><code>class.name</code></dt><dd><p>Used to specify the name of the column containing the
target class.</p>
</dd>
<dt><code>class.values</code></dt><dd><p>Specifies all the possible values of the target class.</p>
</dd>
<dt><code>positive.class</code></dt><dd><p>A <a href="base.html#topic+character">character</a> with the value of the
positive class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Trainset-getPositiveClass"></a>



<h4>Method <code>getPositiveClass()</code></h4>

<p>The function is used to obtain the value of the positive
class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$getPositiveClass()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> value with the positive class value.
</p>


<hr>
<a id="method-Trainset-getClassName"></a>



<h4>Method <code>getClassName()</code></h4>

<p>The function is used to return the name of the target class.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$getClassName()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with length 1.
</p>


<hr>
<a id="method-Trainset-getClassValues"></a>



<h4>Method <code>getClassValues()</code></h4>

<p>The function is used to compute all the possible target class
values.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$getClassValues()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+factor">factor</a> value.
</p>


<hr>
<a id="method-Trainset-getColumnNames"></a>



<h4>Method <code>getColumnNames()</code></h4>

<p>The function returns the name of the columns comprising
an specific cluster distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$getColumnNames(num.cluster)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.cluster</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value used to specify the cluster
number of the cluster distribution used when creating the
<code><a href="#topic+Trainset">Trainset</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with all column names.
</p>


<hr>
<a id="method-Trainset-getFeatureValues"></a>



<h4>Method <code>getFeatureValues()</code></h4>

<p>The function returns the values of the columns comprising
an specific cluster distribution. Target class is omitted.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$getFeatureValues(num.cluster)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.cluster</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value used to specify the cluster
number of the cluster distribution used when creating the
<code><a href="#topic+Trainset">Trainset</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> with the values of the features comprising
the selected cluster distribution.
</p>


<hr>
<a id="method-Trainset-getInstances"></a>



<h4>Method <code>getInstances()</code></h4>

<p>The function returns the values of the columns comprising
an specific cluster distribution. Target class is included as the last
column.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$getInstances(num.cluster)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.cluster</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value used to specify the cluster
number of the cluster distribution used when creating the
<code><a href="#topic+Trainset">Trainset</a></code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+data.frame">data.frame</a> with the values of the features comprising
the selected cluster distribution.
</p>


<hr>
<a id="method-Trainset-getNumClusters"></a>



<h4>Method <code>getNumClusters()</code></h4>

<p>The function obtains the number of groups (clusters) that
forms the cluster distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>Trainset$getNumClusters()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+numeric">numeric</a> vector of size 1.
</p>




<h3>See Also</h3>

<p><code><a href="#topic+Dataset">Dataset</a></code>, <code><a href="#topic+DatasetLoader">DatasetLoader</a></code>,
<code><a href="#topic+Subset">Subset</a></code>, <code><a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a></code>
</p>

<hr>
<h2 id='TwoClass'>Control parameters for train stage (Bi-class problem).</h2><span id='topic+TwoClass'></span>

<h3>Description</h3>

<p>Implementation to control the computational nuances of train
function for bi-class problems.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+TrainFunction">D2MCS::TrainFunction</a></code> -&gt; <code>TwoClass</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TwoClass-new"><code>TwoClass$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TwoClass-create"><code>TwoClass$create()</code></a>
</p>
</li>
<li> <p><a href="#method-TwoClass-getTrFunction"><code>TwoClass$getTrFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-TwoClass-setClassProbs"><code>TwoClass$setClassProbs()</code></a>
</p>
</li>
<li> <p><a href="#method-TwoClass-getMeasures"><code>TwoClass$getMeasures()</code></a>
</p>
</li>
<li> <p><a href="#method-TwoClass-getType"><code>TwoClass$getType()</code></a>
</p>
</li>
<li> <p><a href="#method-TwoClass-setSummaryFunction"><code>TwoClass$setSummaryFunction()</code></a>
</p>
</li>
<li> <p><a href="#method-TwoClass-clone"><code>TwoClass$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="TrainFunction" data-id="getAllowParallel"><a href='../../D2MCS/html/TrainFunction.html#method-TrainFunction-getAllowParallel'><code>D2MCS::TrainFunction$getAllowParallel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="TrainFunction" data-id="getClassProbs"><a href='../../D2MCS/html/TrainFunction.html#method-TrainFunction-getClassProbs'><code>D2MCS::TrainFunction$getClassProbs()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="TrainFunction" data-id="getNumberFolds"><a href='../../D2MCS/html/TrainFunction.html#method-TrainFunction-getNumberFolds'><code>D2MCS::TrainFunction$getNumberFolds()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="TrainFunction" data-id="getResamplingMethod"><a href='../../D2MCS/html/TrainFunction.html#method-TrainFunction-getResamplingMethod'><code>D2MCS::TrainFunction$getResamplingMethod()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="TrainFunction" data-id="getSavePredictions"><a href='../../D2MCS/html/TrainFunction.html#method-TrainFunction-getSavePredictions'><code>D2MCS::TrainFunction$getSavePredictions()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="TrainFunction" data-id="getSeed"><a href='../../D2MCS/html/TrainFunction.html#method-TrainFunction-getSeed'><code>D2MCS::TrainFunction$getSeed()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="TrainFunction" data-id="getVerboseIter"><a href='../../D2MCS/html/TrainFunction.html#method-TrainFunction-getVerboseIter'><code>D2MCS::TrainFunction$getVerboseIter()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TwoClass-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>TwoClass$new(
  method,
  number,
  savePredictions,
  classProbs,
  allowParallel,
  verboseIter,
  seed = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>The resampling method: &quot;boot&quot;, &quot;boot632&quot;, &quot;optimism_boot&quot;,
&quot;boot_all&quot;, &quot;cv&quot;, &quot;repeatedcv&quot;, &quot;LOOCV&quot;, &quot;LGOCV&quot; (for repeated
training/test splits), &quot;none&quot; (only fits one model to the entire training
set), &quot;oob&quot; (only for random forest, bagged trees, bagged earth, bagged
flexible discriminant analysis, or conditional tree forest models),
timeslice, &quot;adaptive_cv&quot;, &quot;adaptive_boot&quot; or &quot;adaptive_LGOCV&quot;</p>
</dd>
<dt><code>number</code></dt><dd><p>Either the number of folds or number of resampling
iterations</p>
</dd>
<dt><code>savePredictions</code></dt><dd><p>An indicator of how much of the hold-out
predictions for each resample should be saved. Values can be either
&quot;all&quot;, &quot;final&quot;, or &quot;none&quot;. A logical value can also be used that convert
to &quot;all&quot; (for true) or &quot;none&quot; (for false). &quot;final&quot; saves the predictions
for the optimal tuning parameters.</p>
</dd>
<dt><code>classProbs</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value. Should class probabilities be
computed for classification models (along with predicted values) in each
resample?</p>
</dd>
<dt><code>allowParallel</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value. If a parallel backend is
loaded and available, should the function use it?</p>
</dd>
<dt><code>verboseIter</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> for printing a training log.</p>
</dd>
<dt><code>seed</code></dt><dd><p>An optional <a href="base.html#topic+integer">integer</a> that will be used to set the seed
during model training stage.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TwoClass-create"></a>



<h4>Method <code>create()</code></h4>

<p>Creates a <code><a href="caret.html#topic+trainControl">trainControl</a></code> requires for the
training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TwoClass$create(summaryFunction, search.method = "grid", class.probs = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>summaryFunction</code></dt><dd><p>An object inherited from
<code><a href="#topic+SummaryFunction">SummaryFunction</a></code> class.</p>
</dd>
<dt><code>search.method</code></dt><dd><p>Either &quot;grid&quot; or &quot;random&quot;, describing how the tuning
parameter grid is determined.</p>
</dd>
<dt><code>class.probs</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> indicating if class probabilities
should be computed for classification models (along with predicted values)
in each resample</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TwoClass-getTrFunction"></a>



<h4>Method <code>getTrFunction()</code></h4>

<p>Function used to return the
<code><a href="caret.html#topic+trainControl">trainControl</a></code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>TwoClass$getTrFunction()</pre></div>



<h5>Returns</h5>

<p>A <code><a href="caret.html#topic+trainControl">trainControl</a></code> object.
</p>


<hr>
<a id="method-TwoClass-setClassProbs"></a>



<h4>Method <code>setClassProbs()</code></h4>

<p>The function allows changing the class computation
capabilities.
</p>


<h5>Usage</h5>

<div class="r"><pre>TwoClass$setClassProbs(class.probs)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>class.probs</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value. <a href="base.html#topic+TRUE">TRUE</a> implies
classification probabilities should be computed for classification models
and <a href="base.html#topic+FALSE">FALSE</a> otherwise.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TwoClass-getMeasures"></a>



<h4>Method <code>getMeasures()</code></h4>

<p>Returns the measures used to optimize model hyperparameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>TwoClass$getMeasures()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector.
</p>


<hr>
<a id="method-TwoClass-getType"></a>



<h4>Method <code>getType()</code></h4>

<p>Obtains the type of classification problem (&quot;Bi-class&quot; or
&quot;Multi-class&quot;).
</p>


<h5>Usage</h5>

<div class="r"><pre>TwoClass$getType()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector with &quot;Bi-class&quot; value.
</p>


<hr>
<a id="method-TwoClass-setSummaryFunction"></a>



<h4>Method <code>setSummaryFunction()</code></h4>

<p>Function used to change the <code><a href="#topic+SummaryFunction">SummaryFunction</a></code>
used in the training stage.
</p>


<h5>Usage</h5>

<div class="r"><pre>TwoClass$setSummaryFunction(summaryFunction)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>summaryFunction</code></dt><dd><p>An object inherited from
<code><a href="#topic+SummaryFunction">SummaryFunction</a></code> class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TwoClass-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TwoClass$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+TrainFunction">TrainFunction</a></code>
</p>

<hr>
<h2 id='TypeBasedStrategy'>Feature clustering strategy.</h2><span id='topic+TypeBasedStrategy'></span>

<h3>Description</h3>

<p>Features are sorted by descendant according to the relevance
value obtained after applying an specific heuristic. Next, features are
distributed into N clusters following a card-dealing methodology. Finally
best distribution is assigned to the distribution having highest homogeneity.
</p>


<h3>Details</h3>

<p>The strategy is suitable only for binary and real features. Other
features are automatically grouped into a specific cluster named as 'unclustered'.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GenericClusteringStrategy">D2MCS::GenericClusteringStrategy</a></code> -&gt; <code>TypeBasedStrategy</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TypeBasedStrategy-new"><code>TypeBasedStrategy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TypeBasedStrategy-execute"><code>TypeBasedStrategy$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-TypeBasedStrategy-getDistribution"><code>TypeBasedStrategy$getDistribution()</code></a>
</p>
</li>
<li> <p><a href="#method-TypeBasedStrategy-createTrain"><code>TypeBasedStrategy$createTrain()</code></a>
</p>
</li>
<li> <p><a href="#method-TypeBasedStrategy-plot"><code>TypeBasedStrategy$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-TypeBasedStrategy-saveCSV"><code>TypeBasedStrategy$saveCSV()</code></a>
</p>
</li>
<li> <p><a href="#method-TypeBasedStrategy-clone"><code>TypeBasedStrategy$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getBestClusterDistribution"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getBestClusterDistribution'><code>D2MCS::GenericClusteringStrategy$getBestClusterDistribution()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getConfiguration"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getConfiguration'><code>D2MCS::GenericClusteringStrategy$getConfiguration()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getDescription"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getDescription'><code>D2MCS::GenericClusteringStrategy$getDescription()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getHeuristic"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getHeuristic'><code>D2MCS::GenericClusteringStrategy$getHeuristic()</code></a></span></li>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="GenericClusteringStrategy" data-id="getUnclustered"><a href='../../D2MCS/html/GenericClusteringStrategy.html#method-GenericClusteringStrategy-getUnclustered'><code>D2MCS::GenericClusteringStrategy$getUnclustered()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TypeBasedStrategy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Method for initializing the object arguments during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>TypeBasedStrategy$new(
  subset,
  heuristic,
  configuration = StrategyConfiguration$new()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>The <code><a href="#topic+Subset">Subset</a></code> used to apply the
feature-clustering strategy.</p>
</dd>
<dt><code>heuristic</code></dt><dd><p>The heuristic used to compute the relevance of each
feature. Must inherit from <code><a href="#topic+GenericHeuristic">GenericHeuristic</a></code> abstract class.</p>
</dd>
<dt><code>configuration</code></dt><dd><p>Optional parameter to customize configuration
parameters for the strategy. Must inherited from
<code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code> abstract class.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TypeBasedStrategy-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Function responsible of performing the clustering strategy
over the defined <code><a href="#topic+Subset">Subset</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>TypeBasedStrategy$execute(verbose = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>verbose</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to specify if more verbosity is
needed.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TypeBasedStrategy-getDistribution"></a>



<h4>Method <code>getDistribution()</code></h4>

<p>Function used to obtain a specific cluster distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>TypeBasedStrategy$getDistribution(
  num.clusters = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>num.clusters</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+list">list</a> with the features comprising an specific clustering
distribution.
</p>


<hr>
<a id="method-TypeBasedStrategy-createTrain"></a>



<h4>Method <code>createTrain()</code></h4>

<p>The function is used to create a <a href="#topic+Trainset">Trainset</a> object from
a specific clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>TypeBasedStrategy$createTrain(
  subset,
  num.clusters = NULL,
  num.groups = NULL,
  include.unclustered = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subset</code></dt><dd><p>The <code><a href="#topic+Subset">Subset</a></code> object used as a basis to create
the train set (see <code><a href="#topic+Trainset">Trainset</a></code> class).</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>A <a href="base.html#topic+numeric">numeric</a> value to select the number of
clusters (define the distribution).</p>
</dd>
<dt><code>num.groups</code></dt><dd><p>A single or <a href="base.html#topic+numeric">numeric</a> vector value to identify a
specific group that forms the clustering distribution.</p>
</dd>
<dt><code>include.unclustered</code></dt><dd><p>A <a href="base.html#topic+logical">logical</a> value to determine if
unclustered features should be included.</p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>If <code>num.clusters</code> and <code>num.groups</code> are not defined,
best clustering distribution is used to create the train set.
</p>



<h5>Returns</h5>

<p>A <code><a href="#topic+Trainset">Trainset</a></code> object.
</p>


<hr>
<a id="method-TypeBasedStrategy-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>The function is responsible for creating a plot to visualize
the clustering distribution.
</p>


<h5>Usage</h5>

<div class="r"><pre>TypeBasedStrategy$plot(dir.path = NULL, file.name = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>An optional <a href="base.html#topic+character">character</a> argument to define the name
of the directory where the exported plot will be saved. If not defined,
the file path will be automatically assigned to the current working
directory, '<code>getwd()</code>'.</p>
</dd>
<dt><code>file.name</code></dt><dd><p>A <a href="base.html#topic+character">character</a> to define the name of the PDF file
where the plot is exported.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TypeBasedStrategy-saveCSV"></a>



<h4>Method <code>saveCSV()</code></h4>

<p>The function is used to save the clustering distribution to
a CSV file.
</p>


<h5>Usage</h5>

<div class="r"><pre>TypeBasedStrategy$saveCSV(dir.path = NULL, name = NULL, num.clusters = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>dir.path</code></dt><dd><p>The name of the directory to save the CSV file.</p>
</dd>
<dt><code>name</code></dt><dd><p>Defines the name of the CSV file.</p>
</dd>
<dt><code>num.clusters</code></dt><dd><p>An optional parameter to select the number of
clusters to be saved. If not defined, all cluster distributions will be
saved.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TypeBasedStrategy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TypeBasedStrategy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+GenericClusteringStrategy">GenericClusteringStrategy</a></code>,
<code><a href="#topic+StrategyConfiguration">StrategyConfiguration</a></code>
</p>

<hr>
<h2 id='UseProbability'>Compute performance across resamples.</h2><span id='topic+UseProbability'></span>

<h3>Description</h3>

<p>Computes the performance across resamples when class
probabilities can be computed.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SummaryFunction">D2MCS::SummaryFunction</a></code> -&gt; <code>UseProbability</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-UseProbability-new"><code>UseProbability$new()</code></a>
</p>
</li>
<li> <p><a href="#method-UseProbability-execute"><code>UseProbability$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-UseProbability-clone"><code>UseProbability$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="D2MCS" data-topic="SummaryFunction" data-id="getMeasures"><a href='../../D2MCS/html/SummaryFunction.html#method-SummaryFunction-getMeasures'><code>D2MCS::SummaryFunction$getMeasures()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-UseProbability-new"></a>



<h4>Method <code>new()</code></h4>

<p>The function defined during runtime the usage of seven
measures: 'ROC', 'Sens', 'Kappa', 'Accuracy', 'TCR_9', 'MCC' and 'PPV'.
</p>


<h5>Usage</h5>

<div class="r"><pre>UseProbability$new()</pre></div>


<hr>
<a id="method-UseProbability-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>The function computes the performance across resamples using
the previously defined measures.
</p>


<h5>Usage</h5>

<div class="r"><pre>UseProbability$execute(data, lev = NULL, model = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>A <a href="base.html#topic+data.frame">data.frame</a> containing the data used to compute the
performance.</p>
</dd>
<dt><code>lev</code></dt><dd><p>An optional value used to define the levels of the target
class.</p>
</dd>
<dt><code>model</code></dt><dd><p>An optional value used to define the M.L. model used.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A vector of performance estimates.
</p>


<hr>
<a id="method-UseProbability-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>UseProbability$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+SummaryFunction">SummaryFunction</a></code>
</p>

<hr>
<h2 id='VotingStrategy'>Voting Strategy template.</h2><span id='topic+VotingStrategy'></span>

<h3>Description</h3>

<p>Abstract class used to define new <code><a href="#topic+SingleVoting">SingleVoting</a></code> and
<code><a href="#topic+CombinedVoting">CombinedVoting</a></code> schemes.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-VotingStrategy-new"><code>VotingStrategy$new()</code></a>
</p>
</li>
<li> <p><a href="#method-VotingStrategy-getVotingSchemes"><code>VotingStrategy$getVotingSchemes()</code></a>
</p>
</li>
<li> <p><a href="#method-VotingStrategy-getMetrics"><code>VotingStrategy$getMetrics()</code></a>
</p>
</li>
<li> <p><a href="#method-VotingStrategy-execute"><code>VotingStrategy$execute()</code></a>
</p>
</li>
<li> <p><a href="#method-VotingStrategy-getName"><code>VotingStrategy$getName()</code></a>
</p>
</li>
<li> <p><a href="#method-VotingStrategy-clone"><code>VotingStrategy$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-VotingStrategy-new"></a>



<h4>Method <code>new()</code></h4>

<p>Abstract method used to initialize the object arguments
during runtime.
</p>


<h5>Usage</h5>

<div class="r"><pre>VotingStrategy$new()</pre></div>


<hr>
<a id="method-VotingStrategy-getVotingSchemes"></a>



<h4>Method <code>getVotingSchemes()</code></h4>

<p>The function returns the voting schemes that will
participate in the voting strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>VotingStrategy$getVotingSchemes()</pre></div>



<h5>Returns</h5>

<p>A vector of object inheriting from <code><a href="#topic+VotingStrategy">VotingStrategy</a></code>
class.
</p>


<hr>
<a id="method-VotingStrategy-getMetrics"></a>



<h4>Method <code>getMetrics()</code></h4>

<p>The function is used to get the metric that will be used
during the voting strategy.
</p>


<h5>Usage</h5>

<div class="r"><pre>VotingStrategy$getMetrics()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector.
</p>


<hr>
<a id="method-VotingStrategy-execute"></a>



<h4>Method <code>execute()</code></h4>

<p>Abstract function used to implement the operation of the
voting schemes.
</p>


<h5>Usage</h5>

<div class="r"><pre>VotingStrategy$execute(predictions, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>predictions</code></dt><dd><p>A <code><a href="#topic+ClusterPredictions">ClusterPredictions</a></code> object containing
the prediction achieved for each cluster.</p>
</dd>
<dt><code>...</code></dt><dd><p>Further arguments passed down to <code>execute</code> function.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-VotingStrategy-getName"></a>



<h4>Method <code>getName()</code></h4>

<p>The function returns the name of the voting scheme.
</p>


<h5>Usage</h5>

<div class="r"><pre>VotingStrategy$getName()</pre></div>



<h5>Returns</h5>

<p>A <a href="base.html#topic+character">character</a> vector of size 1.
</p>


<hr>
<a id="method-VotingStrategy-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>VotingStrategy$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+D2MCS">D2MCS</a></code>, <code><a href="#topic+SingleVoting">SingleVoting</a></code>,
<code><a href="#topic+CombinedVoting">CombinedVoting</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
