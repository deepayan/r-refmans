<!DOCTYPE html><html lang="en"><head><title>Help for package gamlss.add</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gamlss.add}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gamlss.add-package'>
<p>Extra Additive Terms for Generalized Additive Models for Location Scale and Shape</p></a></li>
<li><a href='#centilesTwo'><p>Centiles contour plots in GAMLSS</p></a></li>
<li><a href='#fitFixedKnots'><p>Functions to Fit Univariate Break Point Regression Models</p></a></li>
<li><a href='#fk'><p>A  function to fit break points within GAMLSS</p></a></li>
<li><a href='#ga'><p>A interface functions to use Simon Wood's gam() and bam() functions within GAMLSS</p></a></li>
<li><a href='#gamlss.fk'>
<p>Support for Function fk()</p></a></li>
<li><a href='#gamlss.ga'><p>Support for Function ga() and ba()</p></a></li>
<li><a href='#gamlss.nn'>
<p>Support for Function nn()</p></a></li>
<li><a href='#nn'><p>A interface function to use  nnet() function within GAMLSS</p></a></li>
<li><a href='#plot.nnet'><p>Plotting fitted neural networks</p></a></li>
<li><a href='#tr'>
<p>A interface function to use rpart() function within GAMLSS</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Extra Additive Terms for Generalized Additive Models for
Location Scale and Shape</td>
</tr>
<tr>
<td>Version:</td>
<td>5.1-13</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-17</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface for extra smooth functions including tensor products, 
             neural networks and decision trees.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.gamlss.com/">https://www.gamlss.com/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gamlss-dev/gamlss.add/issues">https://github.com/gamlss-dev/gamlss.add/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), gamlss.dist, gamlss (&ge; 2.4.0), mgcv, nnet,
rpart, graphics, stats, utils, grDevices, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>lattice</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-27 09:16:11 UTC; dimitriosstasinopoulos</td>
</tr>
<tr>
<td>Author:</td>
<td>Mikis Stasinopoulos
    <a href="https://orcid.org/0000-0003-2407-5704"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Robert Rigby <a href="https://orcid.org/0000-0003-3853-1707"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Vlasios Voudouris [ctb],
  Daniil Kiose <a href="https://orcid.org/0000-0002-3596-5748"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mikis Stasinopoulos &lt;d.stasinopoulos@gre.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 08:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='gamlss.add-package'>
Extra Additive Terms for Generalized Additive Models for Location Scale and Shape
</h2><span id='topic+gamlss.add-package'></span><span id='topic+gamlss.add'></span>

<h3>Description</h3>

<p>Interface for extra smooth functions including tensor products, 
             neural networks and decision trees.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> gamlss.add</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Extra Additive Terms for Generalized Additive Models for Location Scale and Shape</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 5.1-13</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-03-17</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Mikis", "Stasinopoulos", role = c("aut", "cre"), 
             email = "d.stasinopoulos@gre.ac.uk", comment = c(ORCID = "0000-0003-2407-5704")),
           person("Robert", "Rigby", role = "aut", email = "r.rigby@gre.ac.uk", comment = c(ORCID = "0000-0003-3853-1707")),
           person("Vlasios", "Voudouris", role = "ctb"),
           person("Daniil", "Kiose", role = "ctb", comment = c(ORCID = "0000-0002-3596-5748"))
           )</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Interface for extra smooth functions including tensor products, 
             neural networks and decision trees.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://www.gamlss.com/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/gamlss-dev/gamlss.add/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.15.0), gamlss.dist, gamlss (&gt;= 2.4.0), mgcv, nnet, rpart, graphics, stats, utils, grDevices, methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> lattice</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Mikis Stasinopoulos [aut, cre]
    (&lt;https://orcid.org/0000-0003-2407-5704&gt;),
  Robert Rigby [aut] (&lt;https://orcid.org/0000-0003-3853-1707&gt;),
  Vlasios Voudouris [ctb],
  Daniil Kiose [ctb] (&lt;https://orcid.org/0000-0002-3596-5748&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Mikis Stasinopoulos &lt;d.stasinopoulos@gre.ac.uk&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
centilesTwo             Centiles contour plots in GAMLSS
fitFixedKnots           Functions to Fit Univariate Break Point
                        Regression Models
fk                      A function to fit break points within GAMLSS
ga                      A interface functions to use Simon Wood's gam()
                        and bam() functions within GAMLSS
gamlss.add-package      Extra Additive Terms for Generalized Additive
                        Models for Location Scale and Shape
gamlss.fk               Support for Function fk()
gamlss.ga               Support for Function ga() and ba()
gamlss.nn               Support for Function nn()
nn                      A interface function to use nnet() function
                        within GAMLSS
plot.nnet               Plotting fitted neural networks
tr                      A interface function to use rpart() function
                        within GAMLSS
</pre>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos [aut, cre]
    (&lt;https://orcid.org/0000-0003-2407-5704&gt;),
  Robert Rigby [aut] (&lt;https://orcid.org/0000-0003-3853-1707&gt;),
  Vlasios Voudouris [ctb],
  Daniil Kiose [ctb] (&lt;https://orcid.org/0000-0002-3596-5748&gt;)
</p>
<p>Maintainer: Mikis Stasinopoulos &lt;d.stasinopoulos@gre.ac.uk&gt;
</p>


<h3>References</h3>

<p>Ripley, B. D. (1996) <em>Pattern Recognition and Neural Networks</em>. Cambridge. 
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Therneau T. M., Atkinson E. J. (2015) An Introduction to Recursive Partitioning Using the RPART Routines. Vignette in package rpart.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S</em>. Fourth edition. Springer. 
</p>
<p>Wood S.N. (2006) <em>Generalized Additive Models: An Introduction with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="gamlss.html#topic+gamlss">gamlss</a></code>, <code><a href="gamlss.dist.html#topic+gamlss.family">gamlss.family</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(gamlss)
gn &lt;- gamlss(R~ga(~te(Fl,A)), data=rent, family=GA) 
</code></pre>

<hr>
<h2 id='centilesTwo'>Centiles contour plots in GAMLSS</h2><span id='topic+centilesTwo'></span>

<h3>Description</h3>

<p>This function <code>centilesTwo()</code> plots two dimensional centiles contour plots for GAMLSS models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centilesTwo(object, grid.x1, grid.x2, x1.name, x2.name, 
       cent = 0.05, dist = 0.01, points = TRUE, 
       other = list(), point.col = 1, point.pch = ".", 
       image = FALSE, image.col = heat.colors(12), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centilesTwo_+3A_object">object</code></td>
<td>
<p>an gamlss object</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_grid.x1">grid.x1</code></td>
<td>
<p>grid values for x-variable one</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_grid.x2">grid.x2</code></td>
<td>
<p>grid values for x-variable two</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_x1.name">x1.name</code></td>
<td>
<p>the name of x-variable on</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_x2.name">x2.name</code></td>
<td>
<p>the name of x-variable two</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_cent">cent</code></td>
<td>
<p>the required centiles</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_dist">dist</code></td>
<td>
<p>the distance</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_points">points</code></td>
<td>
<p>whether to plot the data points</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_other">other</code></td>
<td>
<p>a list having other explanatory variables at fixed values</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_point.col">point.col</code></td>
<td>
<p>the colour of the data points</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_point.pch">point.pch</code></td>
<td>
<p>the type of the data point</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_image">image</code></td>
<td>
<p>whether to plot using the <code>image9</code> function</p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_image.col">image.col</code></td>
<td>
<p>the colour scheme </p>
</td></tr>
<tr><td><code id="centilesTwo_+3A_...">...</code></td>
<td>
<p>for extra arguments for the <code>contour()</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the function <code>exclude.too.far()</code> of the package <span class="pkg">mgcv</span>.
</p>


<h3>Value</h3>

<p>Produce a contour plot.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby, Fernanda De Bastiani
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Wood S.N. (2006) <em>Generalized Additive Models: An Introduction with R</em>. Chapman and Hall/CRC Press. 
</p>


<h3>See Also</h3>

<p><code><a href="gamlss.html#topic+centiles">centiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  
data(plasma)
m1 &lt;- gamlss(betadiet ~ ga(~te(age, fiber)), sigma.formula = ~1,  
    nu.formula = ~ga(~te(age, fiber)), tau.formula = ~1,  
    family = BCTo, data = plasma)
centilesTwo(m1, 18:90, seq(2.5,38, 0.5), age, fiber, cent=0.05, dist=.1,
            xlab="age", ylab='fiber') 
centilesTwo(m1, 18:90, seq(2.5,38, 0.5), age, fiber, cent=0.95, dist=.1)

## End(Not run)</code></pre>

<hr>
<h2 id='fitFixedKnots'>Functions to Fit Univariate Break Point Regression Models</h2><span id='topic+fitFixedKnots'></span><span id='topic+fitFreeKnots'></span>

<h3>Description</h3>

<p>There are two main functions here. The functions <code>fitFixedKnots</code> allows the fit a univariate regression using piecewise polynomials with &quot;known&quot; break points while the function <code>fitFreeKnots</code> estimates the break points.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitFixedKnots(y, x, weights = NULL, knots = NULL, data = NULL, degree = 3, 
             fixed = NULL, base=c("trun","Bbase"), ...)
fitFreeKnots(y, x, weights = NULL, knots = NULL, degree = 3, fixed =
                 NULL, trace = 0, data = NULL, base=c("trun","Bbase"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitFixedKnots_+3A_x">x</code></td>
<td>
<p>the x variable (explanatory)</p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_y">y</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_weights">weights</code></td>
<td>
<p>the prior weights</p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_knots">knots</code></td>
<td>
<p>the position of the interior knots for  <code>fitFixedKnots</code> or starting values for <code>fitFreeKnots</code></p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_data">data</code></td>
<td>
<p>the data frame</p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_degree">degree</code></td>
<td>
<p>the degree if the piecewise  polynomials</p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_fixed">fixed</code></td>
<td>
<p>this is to be able to fit fixed break points</p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_base">base</code></td>
<td>
<p>The basis for the piecewise polynomials, <code>turn</code> for truncated (default) and <code>Bbase</code> for B-base piecewise polynomials   </p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_trace">trace</code></td>
<td>
<p>controlling the trace of of <code>optim()</code> </p>
</td></tr>
<tr><td><code id="fitFixedKnots_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>fitFreeKnots()</code> is loosely based on the  <code>curfit.free.knot()</code> function of package 
<span class="pkg">DierckxSpline</span> of  Sundar Dorai-Raj and Spencer Graves. 
</p>


<h3>Value</h3>

<p>The functions <code>fitFixedKnots</code> and <code>fitFreeKnots</code> return an object <code>FixBreakPointsReg</code> and 
<code>FreeBreakPointsReg</code> respectively with the following items:
</p>
<table role = "presentation">
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values of the model</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals of the model</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom fitted in the model</p>
</td></tr>
<tr><td><code>rss</code></td>
<td>
<p>the residuals sum of squares</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>the knots used in creating the beta-function base</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>the fixed break points if any</p>
</td></tr>
<tr><td><code>breakPoints</code></td>
<td>
<p>the interior (estimated) break points (or knots)</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>the coefficients of the linear  part of the model</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>the degree of the piecewise polynomial</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the y variable</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the x variable</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>the prior weights</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The prediction function in piecewise polynomials using the B-spline basis is tricky because by adding the newdata for x to the current one the B-basis function for the piecewise polynomials changes.  This does not seems to be the case with the truncated basis, that is, when the option <code>base="turn"</code> is used (see the example below).
</p>
<p>If the newdata are outside the range of the old x then there could a considerable discrepancies between the all fitted values and the predicted ones if the option <code>base="Bbase"</code> is used. The prediction function for the objects <code>FixBreakPointsReg</code> or <code>FreeBreakPointsReg</code>
has the option <code>old.x.range=TRUE</code> which allow the user two choices:  
</p>
<p>The first is to use the old end-points for the creation of the new B-basis which were determine from the original range of x. This choice is implemented as a default in the <code>predict</code> method for <code>FixBreakPointsReg</code> and <code>FreeBreakPointsReg</code> objects with the argument <code>old.x.range=TRUE</code>. 
</p>
<p>The second  is to create new end-points from the new and old data  x values. In this case 
the range of x  will be bigger that the original one if the <code>newdata</code> has values outside the original x range.  
In this case (<code>old.x.range=FALSE</code>) the prediction could be possible  better outside the x range but would not coincide with the original predictions i.e. fitted(model)
since basis have changed. 
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>
</p>


<h3>References</h3>

<p>Dierckx, P. (1991) <em>Curve and Surface Fitting with Splines</em>, Oxford Science Publications
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># creating  a linear + linear function
   x &lt;- seq(0,10, length.out=201)
knot &lt;- 5
 set.seed(12543)
 mu &lt;- ifelse(x&lt;=knot,5+0.5*x,5+0.5*x+(x-knot))
  y &lt;- rNO(201, mu=mu, sigma=.5)
# plot the data
 plot(y~x, xlim=c(-1,13), ylim=c(3,18))

# fit model using fixed break points
 m1 &lt;- fitFixedKnots(y, x, knots=5, degree=1)
knots(m1)
lines(fitted(m1)~x, col="red")

# now estimating the knot
m2 &lt;- fitFreeKnots(y, x, knots=5, degree=1)
knots(m2)
summary(m2)

# now predicting 
plot(y~x, xlim=c(-5,13), ylim=c(3,18))
lines(fitted(m2)~x, col="green", lwd=3)
points(-2:13,predict(m2, newdata=-2:13), col="red",pch = 21, bg="blue")
points(-2:13,predict(m2, newdata=-2:13, old.x.range=FALSE), col="red",pch = 21, bg="grey")

# fit different basis 
m21 &lt;- fitFreeKnots(y, x, knots=5, degree=1, base="Bbase")
deviance(m2) 
deviance(m21) # should be identical

# predicting with m21 
 plot(y~x, xlim=c(-5,13), ylim=c(3,18))
lines(fitted(m21)~x, col="green", lwd=3)
points(-2:13,predict(m21, newdata=-2:13), col="red",pch = 21, bg="blue")
points(-2:13,predict(m21, newdata=-2:13, old.x.range=FALSE), col="red",pch = 21, bg="grey")
</code></pre>

<hr>
<h2 id='fk'>A  function to fit break points within GAMLSS</h2><span id='topic+fk'></span><span id='topic+fk.control'></span>

<h3>Description</h3>

<p>The <code>fk()</code> function is a additive function to be used for GAMLSS models. 
It is an interface for the <code>fitFreeKnots()</code> function. The functions <code>fitFreeKnots()</code> was first based on the  <code>curfit.free.knot()</code> function of package DierckxSpline of  Sundar Dorai-Raj and Spencer Graves. The function <code>fk()</code> allows the user to use the free knots function <code>fitFreeKnots()</code> within <code>gamlss</code>. 
The great advantage of course comes from the fact GAMLSS models provide a variety of distributions and diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fk(x, start=NULL, control=fk.control(...), ...) 
fk.control(degree = 1, all.fixed = FALSE, fixed = NULL, base = c("trun", "Bbase"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fk_+3A_x">x</code></td>
<td>
<p>the x-variable</p>
</td></tr>
<tr><td><code id="fk_+3A_start">start</code></td>
<td>
<p>starting values for the breakpoints. If are set the number of break points is also determined by the length of <code>start</code></p>
</td></tr>
<tr><td><code id="fk_+3A_control">control</code></td>
<td>
<p>the degree of the spline function fitted</p>
</td></tr>
<tr><td><code id="fk_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
<tr><td><code id="fk_+3A_degree">degree</code></td>
<td>
<p>the degree of the based function</p>
</td></tr>
<tr><td><code id="fk_+3A_all.fixed">all.fixed</code></td>
<td>
<p>whether to fix all parameter</p>
</td></tr>
<tr><td><code id="fk_+3A_fixed">fixed</code></td>
<td>
<p>the fixed break points</p>
</td></tr>
<tr><td><code id="fk_+3A_base">base</code></td>
<td>
<p>Which base should be used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>fk</code> itself does no smoothing; it simply sets things up for the function <code>gamlss()</code> 
which in turn uses the function  <code>additive.fit()</code> for backfitting which in turn uses <code>gamlss.fk()</code>.
Note that, finding the break points is not a trivial problem and therefore  multiple maximum points can occur.  
More details about the free knot splines can be found in package Dierckx, (1991).
</p>
<p>The <code>gamlss</code> algorithm used a modified backfitting in this case, that is, it fits the linear part fist.  
Note that trying to predict outside the x-range can be dangerous as the example below shows.  
</p>


<h3>Value</h3>

<p>The <code>gamlss</code> object saved contains the last fitted object which can be accessed using 
<code>obj$par.coefSmo</code> where <code>obj</code> is the fitted <code>gamlss</code> object <code>par</code> is the relevant distribution
parameter.</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby 
</p>


<h3>References</h3>

<p>Dierckx, P. (1991) <em>Curve and Surface Fitting with Splines</em>, Oxford Science Publications
</p>
<p>Stasinopoulos D. M., Rigby R.A. and Akantziliotou C. (2006) Instructions on how to use the GAMLSS package in R.
Accompanying documentation in the current GAMLSS  help files, (see also  <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamlss.fk">gamlss.fk</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## creating  a linear + linear function
x &lt;- seq(0,10, length.out=201)
knot &lt;- 5
set.seed(12543)
mu &lt;- ifelse(x&lt;=knot,5+0.5*x,5+0.5*x+1.5*(x-knot))
y &lt;- rNO(201, mu=mu, sigma=.5)
## plot the data
plot(y~x, xlim=c(-1,13), ylim=c(3,23))
## fit model using curfit
m1 &lt;- fitFreeKnots(y, x, knots=3, degree=1)
knots(m1)
## fitted values
lines(fitted(m1)~x, col="red", lwd="3")
## predict
pm1&lt;-predict(m1, newdata=-1:12)
points(-1:12,pm1, col="red",pch = 21, bg="blue")
#------------------------------------------------
## now gamlss
#------------------------------------------------
## now negative binomial data 
knot=4
eta1 &lt;- ifelse(x&lt;=knot,0.8+0.08*x,.8+0.08*x+.3*(x-knot))
plot(eta1~x)
set.seed(143)
y &lt;- rNBI(201, mu=exp(eta1), sigma=.1)
da &lt;- data.frame(y=y,x=x)
plot(y~x, data=da)
## getting the break point using profile deviance
n1 &lt;- quote(gamlss(y ~ x+I((x&gt;this)*(x-this)), family=NBI, data=da))
prof.term(n1, min=1, max=9, criterion="GD", start.prev=FALSE)
## now fit the model using fk
g1 &lt;- gamlss(y~fk(x, degree=1, start=c(4)), data=da, family=NBI)
## get the breakpoint
knots(getSmo(g1))
## summary of the gamlss object FreeBreakPointsReg object
getSmo(g1)
## plot fitted model
plot(y~x, data=da)
lines(fitted(g1)~x, data=da, col="red")
#------------------------------------------------
## the aids data as example where things can go wrong
## using fk()
data(aids)
a1&lt;-gamlss(y~x+fk(x, degree=1, start=25)+qrt, data=aids, family=NBI)
knots(getSmo(a1))
# using profile deviance
aids.1 &lt;- quote(gamlss(y ~ x+I((x&gt;this)*(x-this))+qrt,family=NBI,data=aids))
prof.term(aids.1, min=16, max=21, step=.1,  start.prev=FALSE)
## The Maximum Likelihood estimator is  18.33231 not 17.37064 
## plotting the fit
with(aids, plot(x,y,pch=21,bg=c("red","green3","blue","yellow")[unclass(qrt)]))
lines(fitted(a1)~aids$x)
#-------------------------------------------------
</code></pre>

<hr>
<h2 id='ga'>A interface functions to use Simon Wood's gam() and bam() functions within GAMLSS</h2><span id='topic+ga'></span><span id='topic+ga.control'></span><span id='topic+ba'></span><span id='topic+ba.control'></span>

<h3>Description</h3>

<p>The <code>ga()</code> and <code>ba()</code>  functions are a additive functions to be used within GAMLSS models. 
They are  interfaces for the <code>gam()</code> and the <code>bam()</code> functions of package  <code>mgcv</code> of Simon Wood. The functions  <code>gam()</code> and the <code>bam()</code> allows the user to use all the available smoothers of the package <code>mcgv()</code> within <code>gamlss</code>. The great advantage of course come from fitting models outside the 
exponential family.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ga(formula, control = ga.control(...), ...)

ba(formula, control = ba.control(...), ...)

ga.control(offset = NULL, method = "REML",
         optimizer = c("outer", "newton"), control = list(), 
         scale = 0, select = FALSE, knots = NULL, 
         sp = NULL, min.sp = NULL, H = NULL, gamma = 1, 
         paraPen = NULL, in.out = NULL, 
         drop.unused.levels = TRUE, drop.intercept = NULL, 
         discrete = FALSE, ...)
     
ba.control(offset = NULL, method = "fREML", control = list(), 
          select = FALSE, scale = 0, gamma = 1, knots = NULL, 
          sp = NULL, min.sp = NULL, paraPen = NULL, 
          chunk.size = 10000, rho = 0, AR.start = NULL, 
          discrete = TRUE, cluster = NULL, nthreads = 2, 
          gc.level = 1, use.chol = FALSE, samfrac = 1, 
          coef = NULL, drop.unused.levels = TRUE, 
          drop.intercept = NULL, ...)     

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ga_+3A_formula">formula</code></td>
<td>
<p> A formula containing <code>s()</code> and <code>te</code> functions i.e. ~s(x1)+ te(x2,x3).</p>
</td></tr>
<tr><td><code id="ga_+3A_offset">offset</code></td>
<td>
<p>the offset in the formula</p>
</td></tr>
<tr><td><code id="ga_+3A_method">method</code></td>
<td>
<p>the <code>method</code> argument in <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_optimizer">optimizer</code></td>
<td>
<p>the method optimizer in <code>gam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_control">control</code></td>
<td>
<p>values for the <code>gam.control()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_scale">scale</code></td>
<td>
<p>for the scale parameter</p>
</td></tr>
<tr><td><code id="ga_+3A_select">select</code></td>
<td>
<p>the <code>select</code> argument in <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_knots">knots</code></td>
<td>
<p>the <code>knots</code> argument in <code>gam()</code> and <code>bam()</code></p>
</td></tr>  
<tr><td><code id="ga_+3A_sp">sp</code></td>
<td>
<p>the <code>sp</code> argument in <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_min.sp">min.sp</code></td>
<td>
<p>the <code>min.sp</code> argument in <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_h">H</code></td>
<td>
<p>a user supplied fixed quadratic penalty on the parameters in <code>gam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_gamma">gamma</code></td>
<td>
<p>the <code>gamma</code> argument in <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_parapen">paraPen</code></td>
<td>
<p>the <code>paraPen</code> argument in <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_in.out">in.out</code></td>
<td>
<p>the <code>in.out</code> argument in <code>gam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>by default unused levels are dropped from factors before fitting for <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_drop.intercept">drop.intercept</code></td>
<td>
<p>set to TRUE to force the model to really not have the a constant in the parametric model part for <code>gam()</code> and <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_discrete">discrete</code></td>
<td>
<p>see <code>bam</code> and <code>gam</code> for details</p>
</td></tr>
<tr><td><code id="ga_+3A_chunk.size">chunk.size</code></td>
<td>
<p>see the help for <code>bam()</code>.</p>
</td></tr>
<tr><td><code id="ga_+3A_rho">rho</code></td>
<td>
<p>for an <code>AR1</code> error model, see the help for <code>bam()</code>  </p>
</td></tr>
<tr><td><code id="ga_+3A_ar.start">AR.start</code></td>
<td>
<p>for an <code>AR1</code> error model, see the help for <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_cluster">cluster</code></td>
<td>
<p>see the help for <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_nthreads">nthreads</code></td>
<td>

<p>Number of threads to use for non-cluster computation see  the help for <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_gc.level">gc.level</code></td>
<td>
<p>keepingf the memory footprint down, see  the help for <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_use.chol">use.chol</code></td>
<td>
<p>see  the help for <code>bam()</code></p>
</td></tr>
<tr><td><code id="ga_+3A_samfrac">samfrac</code></td>
<td>

<p>see  the help for <code>bam()</code>
</p>
</td></tr>
<tr><td><code id="ga_+3A_coef">coef</code></td>
<td>
<p>initial values for model coefficients</p>
</td></tr>
<tr><td><code id="ga_+3A_...">...</code></td>
<td>
<p>extra options to pass to gam.control()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>ga</code> itself does no smoothing; it simply sets things up for the function <code>gamlss()</code> which in turn uses the function 
<code>additive.fit()</code> for back-fitting which in turn uses <code>gamlss.ga()</code>
</p>
<p>Note that, in our (limited) experience,  for normal errors or exponential family, the  fitted models using <code>gam()</code> 
and <code>ga()</code> within <code>gamlss()</code> are identical
or at least very similar.  This is particularly true if the default values for <code>gam()</code> are used.   
</p>


<h3>Value</h3>

<p> the fitted values of the smoother is returned, endowed with a number of attributes. 
The smoother fitted values are used in the construction of the overall fitted values of the particular distribution parameter.
The attributes can be use to obtain information about the individual fit. In particular the <code>coefSmo</code> within the parameters
of the fitted model contains the final additive fit.
</p>


<h3>Warning </h3>

<p>The function is experimental so please report any peculiar behaviour to the authors</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos, <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a> </p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Wood S.N. (2006) <em>Generalized Additive Models: An Introduction with R</em>. Chapman and Hall/CRC Press.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mgcv)
data(rent)
#---------------------------------------------------------
## normal errors one x-variable
ga1 &lt;- gam(R~s(Fl, bs="ps", k=20), data=rent, method="REML")
gn1 &lt;- gamlss(R~ga(~s(Fl, bs="ps", k=20), method="REML"), data=rent) # additive
gb1 &lt;- gamlss(R~pb(Fl), data=rent) # additive
AIC(ga1,gn1, gb1, k=0)
AIC(ga1,gn1, gb1)
#--------------------------------------------------------
## normal error additive in Fl and A
ga2 &lt;- gam(R~s(Fl)+s(A), method="REML", data=rent)
gn2 &lt;- gamlss(R~ga(~s(Fl)+s(A), method="REML"),  data=rent) # additive
gb2 &lt;- gamlss(R~pb(Fl)+pb(A), data=rent) # additive
AIC(ga2,gn2, gb2, k=0)
AIC(ga2,gn2, gb2)
#---------------------------------------------------------
## Not run: 
## gamma error additive in Fl and A
ga3 &lt;- gam(R~s(Fl)+s(A), method="REML", data=rent, family=Gamma(log))
gn3 &lt;- gamlss(R~ga(~s(Fl)+s(A), method="REML"), data=rent, family=GA)# additive
gb3 &lt;- gamlss(R~pb(Fl)+pb(A), data=rent, family=GA) # additive
AIC(ga3,gn3, gb3, k=0)
AIC(ga3,gn3, gb3)
#---------------------------------------------------------
## gamma error surface fitting
ga4 &lt;-gam(R~s(Fl,A), method="REML", data=rent, family=Gamma(log))
gn4 &lt;- gamlss(R~ga(~s(Fl,A), method="REML"), data=rent, family=GA) 
AIC(ga4,gn4, k=0)
AIC(ga4,gn4)
## plot the fitted surfaces
op&lt;-par(mfrow=c(1,2))
vis.gam(ga4)
vis.gam(getSmo(gn4))
par(op)
## contour plot using mgcv's plot() function
plot(getSmo(gn4))
#---------------------------------------------------------
## predict
newrent &lt;- data.frame(expand.grid(Fl=seq(30,120,5), A=seq(1890,1990,5 )))
newrent1 &lt;-newrent2 &lt;- newrent
newrent1$pred &lt;- predict(ga4, newdata=newrent, type="response")
newrent2$pred &lt;- predict(gn4, newdata=newrent, type="response")
library(lattice)
wf1&lt;-wireframe(pred~Fl*A, newrent1, aspect=c(1,0.5), drape=TRUE, 
             colorkey=(list(space="right", height=0.6)), main="gam()")
wf2&lt;-wireframe(pred~Fl*A, newrent2, aspect=c(1,0.5), drape=TRUE, 
          colorkey=(list(space="right", height=0.6)), main="gamlss()")
print(wf1, split=c(1,1,2,1), more=TRUE)
print(wf2, split=c(2,1,2,1))
#---------------------------------------------------------
##gamma error two variables te() function
ga5 &lt;-  gam(R~te(Fl,A), data=rent, family=Gamma(log))
gn5 &lt;- gamlss(R~ga(~te(Fl,A)), data=rent, family=GA) 
AIC(ga5,gn5)
AIC(ga5,gn5, k=0)
op&lt;-par(mfrow=c(1,2))
vis.gam(ga5)
vis.gam(getSmo(gn5))
par(op)
#----------------------------------------------------------
## use of Markov random fields 
## example from package mgcv of Simon Wood
## Load Columbus Ohio crime data (see ?columbus for details and credits)
data(columb)       ## data frame
data(columb.polys) ## district shapes list
xt &lt;- list(polys=columb.polys) ## neighbourhood structure info for MRF
## First a full rank MRF...
b &lt;- gam(crime ~ s(district,bs="mrf",xt=xt),data=columb,method="REML")
bb &lt;- gamlss(crime~ ga(~s(district,bs="mrf",xt=xt), method="REML"), data=columb)
AIC(b,bb, k=0)
op&lt;-par(mfrow=c(2,2))
plot(b,scheme=1)
plot(bb$mu.coefSmo[[1]], scheme=1)
## Compare to reduced rank version...
b &lt;- gam(crime ~ s(district,bs="mrf",k=20,xt=xt),data=columb,method="REML")
bb &lt;- gamlss(crime~ ga(~s(district,bs="mrf",k=20,xt=xt), method="REML"), 
             data=columb)
AIC(b,bb, k=0)
plot(b,scheme=1)
plot(bb$mu.coefSmo[[1]], scheme=1)
par(op)
## An important covariate added...
b &lt;- gam(crime ~ s(district,bs="mrf",k=20,xt=xt)+s(income),
         data=columb,method="REML")
## x in gam() 
bb &lt;- gamlss(crime~ ga(~s(district,bs="mrf",k=20,xt=xt)+s(income), 
             method="REML"), data=columb)
## x in gamlss()
bbb &lt;- gamlss(crime~ ga(~s(district,bs="mrf",k=20,xt=xt), 
             method="REML")+pb(income), data=columb)
AIC(b,bb,bbb)
## ploting the fitted models
op&lt;-par(mfrow=c(2,2))
plot(b,scheme=c(0,1))
plot(getSmo(bb), scheme=c(0,1))
par(op)
plot(getSmo(bbb, which=2))
## plot fitted values by district
op&lt;- par(mfrow=c(1,2))
fv &lt;- fitted(b)
names(fv) &lt;- as.character(columb$district)
fv1 &lt;- fitted(bbb)
names(fv1) &lt;- as.character(columb$district)
polys.plot(columb.polys,fv)
polys.plot(columb.polys,fv1)
par(op)
## End(Not run)
## bam 
</code></pre>

<hr>
<h2 id='gamlss.fk'>
Support for Function fk()
</h2><span id='topic+gamlss.fk'></span>

<h3>Description</h3>

<p>This is support for the functions <code>fk()</code>. 
It is not intended to be called directly by users. T
he function <code>gamlss.fk</code> is calling on the R function <code>curfit.free.knot()</code> of Sundar Dorai-Raj
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.fk(x, y, w, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamlss.fk_+3A_x">x</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code id="gamlss.fk_+3A_y">y</code></td>
<td>
<p>the response variable</p>
</td></tr>
<tr><td><code id="gamlss.fk_+3A_w">w</code></td>
<td>
<p> prior weights</p>
</td></tr>
<tr><td><code id="gamlss.fk_+3A_xeval">xeval</code></td>
<td>
<p>used in prediction </p>
</td></tr> 
<tr><td><code id="gamlss.fk_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby</p>


<h3>References</h3>

<p>Dierckx, P. (1991) <em>Curve and Surface Fitting with Splines</em>, Oxford Science Publications
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fk">fk</a></code> </p>

<hr>
<h2 id='gamlss.ga'>Support for Function ga() and ba()</h2><span id='topic+gamlss.ga'></span><span id='topic+gamlss.ba'></span>

<h3>Description</h3>

<p>This is support for the  smoother functions <code>ga()</code> and <code>ba()</code> intefaces for Simon Woood's <code>gam()</code> and <code>bam()</code>  functions from package <span class="pkg">mgcv</span>.
It is not intended to be called directly by users. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.ga(x, y, w, xeval = NULL, ...)
gamlss.ba(x, y, w, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamlss.ga_+3A_x">x</code></td>
<td>

<p>the explanatory variables
</p>
</td></tr>
<tr><td><code id="gamlss.ga_+3A_y">y</code></td>
<td>

<p>iterative y variable
</p>
</td></tr>
<tr><td><code id="gamlss.ga_+3A_w">w</code></td>
<td>

<p>iterative weights
</p>
</td></tr>
<tr><td><code id="gamlss.ga_+3A_xeval">xeval</code></td>
<td>

<p>if xeval=TRUE then predicion is used
</p>
</td></tr>
<tr><td><code id="gamlss.ga_+3A_...">...</code></td>
<td>

<p>for extra arguments
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Wood S.N. (2006) Generalized Additive Models: An Introduction with R. Chapman and Hall/CRC Press. 
</p>

<hr>
<h2 id='gamlss.nn'>
Support for Function nn() 
</h2><span id='topic+gamlss.nn'></span>

<h3>Description</h3>

<p>This is support for the  smoother function nn() an interface for Brian Reply's <code>nnet()</code> function.
It is not intended to be called directly by users. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss.nn(x, y, w, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamlss.nn_+3A_x">x</code></td>
<td>
<p>the explanatory variables</p>
</td></tr>
<tr><td><code id="gamlss.nn_+3A_y">y</code></td>
<td>
<p>iterative y variable</p>
</td></tr>
<tr><td><code id="gamlss.nn_+3A_w">w</code></td>
<td>
<p>iterative weights</p>
</td></tr>
<tr><td><code id="gamlss.nn_+3A_xeval">xeval</code></td>
<td>
<p>if xeval=TRUE then predicion is used</p>
</td></tr>
<tr><td><code id="gamlss.nn_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Ripley, B. D. (1996) <em>Pattern Recognition and Neural Networks</em>. Cambridge. 
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S</em>. Fourth edition. Springer. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fk">fk</a></code></p>

<hr>
<h2 id='nn'>A interface function to use  nnet() function within GAMLSS 
</h2><span id='topic+nn'></span><span id='topic+nn.control'></span>

<h3>Description</h3>

<p>The <code>nn()</code> function is a additive function to be used for GAMLSS models. 
It is an interface for the <code>nnet()</code> function of package 
<code>nnet</code> of Brian Ripley. The function <code>nn()</code> allows the user to use neural networks 
within <code>gamlss</code>. The great advantage of course comes from the fact GAMLSS models provide a variety of distributions and diagnostics.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nn(formula, control = nn.control(...), ...)
nn.control(size = 3, linout = TRUE, entropy = FALSE, softmax = FALSE, 
           censored = FALSE, skip = FALSE, rang = 0.7, decay = 0, 
           maxit = 100, Hess = FALSE, trace = FALSE, 
           MaxNWts = 1000, abstol = 1e-04, reltol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nn_+3A_formula">formula</code></td>
<td>
<p> A formula containing the expolanatory variables i.e. ~x1+x2+x3.</p>
</td></tr>
<tr><td><code id="nn_+3A_control">control</code></td>
<td>
<p>control to pass the arguments for the nnet() function</p>
</td></tr>
<tr><td><code id="nn_+3A_...">...</code></td>
<td>
<p>for extra arguments</p>
</td></tr>
<tr><td><code id="nn_+3A_size">size</code></td>
<td>
<p>number of units in the hidden layer. Can be zero if there are skip-layer units</p>
</td></tr>
<tr><td><code id="nn_+3A_linout">linout</code></td>
<td>
<p>switch for linear output units. Default is TRUE, identily link</p>
</td></tr>
<tr><td><code id="nn_+3A_entropy">entropy</code></td>
<td>
<p>switch for entropy (= maximum conditional likelihood) fitting. Default by least-squares.</p>
</td></tr>
<tr><td><code id="nn_+3A_softmax">softmax</code></td>
<td>
<p>switch for softmax (log-linear model) and maximum conditional likelihood fitting. linout, entropy, softmax and censored are mutually exclusive.</p>
</td></tr>
<tr><td><code id="nn_+3A_censored">censored</code></td>
<td>
<p>A variant on softmax, in which non-zero targets mean possible classes. Thus for softmax a row of (0, 1, 1) means one example each of classes 2 and 3, but for censored it means one example whose class is only known to be 2 or 3.</p>
</td></tr>
<tr><td><code id="nn_+3A_skip">skip</code></td>
<td>
<p>switch to add skip-layer connections from input to output</p>
</td></tr>
<tr><td><code id="nn_+3A_rang">rang</code></td>
<td>
<p>Initial random weights on <code>[-rang, rang]</code>. Value about 0.5 unless the inputs are large, in which case it should be chosen so that <code>rang * max(|x|)</code> is about 1</p>
</td></tr>
<tr><td><code id="nn_+3A_decay">decay</code></td>
<td>
<p>parameter for weight decay. Default 0. </p>
</td></tr>
<tr><td><code id="nn_+3A_maxit">maxit</code></td>
<td>
<p>parameter for weight decay. Default 0. </p>
</td></tr>
<tr><td><code id="nn_+3A_hess">Hess</code></td>
<td>
<p>If true, the Hessian of the measure of fit at the best set of weights found is returned as component Hessian. </p>
</td></tr>
<tr><td><code id="nn_+3A_trace">trace</code></td>
<td>
<p>switch for tracing optimization. Default FALSE</p>
</td></tr>
<tr><td><code id="nn_+3A_maxnwts">MaxNWts</code></td>
<td>
<p>The maximum allowable number of weights. There is no intrinsic limit in the code, but increasing MaxNWts will probably allow fits that are very slow and time-consuming. </p>
</td></tr>
<tr><td><code id="nn_+3A_abstol">abstol</code></td>
<td>
<p>Stop if the fit criterion falls below abstol, indicating an essentially perfect fit. </p>
</td></tr>
<tr><td><code id="nn_+3A_reltol">reltol</code></td>
<td>
<p>Stop if the optimizer is unable to reduce the fit criterion by a factor of at least 1 - reltol.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, neural networks are over parameterized models and therefor notorious for multiple maximum.  
There is no guarantee that two identical fits will produce identical results.</p>


<h3>Value</h3>

<p>Note that <code>nn</code> itself does no smoothing; it simply sets things up for the function <code>gamlss()</code> which in turn uses the function 
<code>additive.fit()</code> for backfitting which in turn uses <code>gamlss.nn()</code></p>


<h3>Warning </h3>

<p>You may have to fit the model several time to unsure that you obtain a reasonable minimum</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:d.stasinopoulos@londonmet.ac.uk">d.stasinopoulos@londonmet.ac.uk</a>, Bob Rigby 
based on work of  Venables &amp; Ripley wich also based on work by Kurt Hornik and Albrecht Gebhardt.
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Ripley, B. D. (1996) <em>Pattern Recognition and Neural Networks</em>. Cambridge. 
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S</em>. Fourth edition. Springer. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nnet)
data(rock)
area1&lt;- with(rock,area/10000)
peri1&lt;- with (rock,peri/10000) 
rock1&lt;- with(rock, data.frame(perm, area=area1, peri=peri1, shape))
# fit nnet
r1 &lt;- nnet(log(perm)~area+peri+shape, rock1, size=3, decay=1e-3, linout=TRUE, 
            skip=TRUE, max=1000, Hess=TRUE)
summary(r1) 
# get gamlss
library(gamlss) 
cc &lt;- nn.control(size=3, decay=1e-3, linout=TRUE, skip=TRUE, max=1000, 
      Hess=TRUE)
g1 &lt;- gamlss(log(perm)~nn(~area+peri+shape,size=3, control=cc), data=rock1)
summary(g1$mu.coefSmo[[1]])
# predict
Xp &lt;- expand.grid(area=seq(0.1,1.2,0.05), peri=seq(0,0.5, 0.02), shape=0.2)
rocknew &lt;- cbind(Xp, fit=predict(r1, newdata=Xp))
library(lattice)
wf1&lt;-wireframe(fit~area+peri, rocknew, screen=list(z=160, x=-60), 
               aspect=c(1, 0.5), drape=TRUE,  main="nnet()")
rocknew1 &lt;- cbind(Xp, fit=predict(g1, newdata=Xp))
wf2&lt;-wireframe(fit~area+peri, rocknew1, screen=list(z=160, x=-60), 
               aspect=c(1, 0.5), drape=TRUE,  main="nn()")
print(wf1, split=c(1,1,2,1), more=TRUE)
print(wf2, split=c(2,1,2,1))
#------------------------------------------------------------------------
 data(rent)
 mr1 &lt;- gamlss(R~nn(~Fl+A, size=5, decay=0.001), data=rent, family=GA)  
 library(gamlss.add)
 mg1&lt;-gamlss(R~ga(~s(Fl,A)), data=rent, family=GA) 
 AIC(mr1,mg1)
newrent &lt;- newrent1 &lt;-newrent2 &lt;- data.frame(expand.grid(Fl=seq(30,120,5),
                   A=seq(1890,1990,5 )))
newrent1$fit &lt;- predict(mr1, newdata=newrent, type="response") ##nn
newrent2$fit &lt;- predict(mg1, newdata=newrent, type="response")# gam
 library(lattice)
 wf1&lt;-wireframe(fit~Fl+A, newrent1, aspect=c(1,0.5), drape=TRUE, 
                colorkey=(list(space="right", height=0.6)), main="nn()")
 wf2&lt;-wireframe(fit~Fl+A, newrent2, aspect=c(1,0.5), drape=TRUE, 
                colorkey=(list(space="right", height=0.6)), main="ga()")
print(wf1, split=c(1,1,2,1), more=TRUE)
print(wf2, split=c(2,1,2,1))
#-------------------------------------------------------------------------
## Not run: 
data(db)
mdb1 &lt;- gamlss(head~nn(~age,size=20, decay=0.001), data=db)
plot(head~age, data=db)
points(fitted(mdb1)~db$age, col="red")
mdb2 &lt;- gamlss(head~nn(~age,size=20, decay=0.001), data=db, family=BCT)
plot(head~age, data=db)
points(fitted(mdb2)~db$age, col="red")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.nnet'>Plotting fitted neural networks
</h2><span id='topic+plot.nnet'></span>

<h3>Description</h3>

<p>A function to plot the results of a neural network fit based on the <code>plotnet()</code> function of the package <span class="pkg">NeuralNetTools</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'nnet'
## S3 method for class 'nnet'
plot(x, nid = TRUE, all.out = TRUE, all.in = TRUE, bias = TRUE, 
wts.only = FALSE, rel.rsc = 5, circle.cex = 5, node.labs = TRUE, 
var.labs = TRUE, x.lab = NULL, y.lab = NULL, line.stag = NULL, 
struct = NULL, cex.val = 1, alpha.val = 1, circle.col = "lightblue",
pos.col = "black", neg.col = "grey", max.sp = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.nnet_+3A_x">x</code></td>
<td>
<p>A neural network fitted model </p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_nid">nid</code></td>
<td>
<p>logical value indicating if neural interpretation diagram is plotted, default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_all.out">all.out</code></td>
<td>
<p>character string indicating names of response variables for which connections are plotted, default all</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_all.in">all.in</code></td>
<td>
<p>character string indicating names of input variables for which connections are plotted, default all</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_bias">bias</code></td>
<td>
<p>logical value indicating if bias nodes and connections are plotted, not applicable for networks from mlp function, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_wts.only">wts.only</code></td>
<td>
<p>logical value indicating if connections weights are returned rather than a plot, default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_rel.rsc">rel.rsc</code></td>
<td>
<p>numeric value indicating maximum width of connection lines, default 5</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_circle.cex">circle.cex</code></td>
<td>
<p>numeric value indicating size of nodes, passed to cex argument, default 5</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_node.labs">node.labs</code></td>
<td>
<p>logical value indicating if text labels are plotted, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_var.labs">var.labs</code></td>
<td>
<p>logical value indicating if variable names are plotted next to nodes, default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_x.lab">x.lab</code></td>
<td>
<p>character string indicating names for input variables, default from model object</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_y.lab">y.lab</code></td>
<td>
<p>character string indicating names for output variables, default from  model object</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_line.stag">line.stag</code></td>
<td>
<p>numeric value that specifies distance of connection weights from nodes</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_struct">struct</code></td>
<td>
<p>numeric value of length three indicating network architecture (no nodes for input, hidden, output), required only if mod.in is a numeric vector</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_cex.val">cex.val</code></td>
<td>
<p>numeric value indicating size of text labels, default 1</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_alpha.val">alpha.val</code></td>
<td>
<p>numeric value (0-1) indicating transparency of connections, default 1</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_circle.col">circle.col</code></td>
<td>
<p>text value indicating colour of nodes default &quot;lighrblue&quot; </p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_pos.col">pos.col</code></td>
<td>
<p>text value indicating colour of the possitive connections, default &quot;black&quot; </p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_neg.col">neg.col</code></td>
<td>
<p>text value indicating colour of the negative connections, default &quot;gray&quot;</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_max.sp">max.sp</code></td>
<td>
<p>logical value indication whether the space betwwen nodes in each laers is maximised</p>
</td></tr>
<tr><td><code id="plot.nnet_+3A_...">...</code></td>
<td>
<p>for further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plot.nnet()</code> is (almost) identical to the function <code>plot.nnet()</code> created by Marcus W. Beck it was first published in the web but  now is part of the <span class="pkg">NeuralNetTools</span> package in <span class="rlang"><b>R</b></span> under the name <code>plotnet()</code>. Here we modify the function it so it works within the <span class="pkg">gamlss.add</span> package. This involves of borrowing the functions <code>rescale()</code>, <code>zero_range()</code> and <code>alpha()</code> from package <span class="pkg">scales</span>. 
</p>


<h3>Value</h3>

<p>The function is producing a plot
</p>


<h3>Author(s)</h3>

<p>Marcus W. Beck &lt;mbafs2012@gmail.com&gt; modified by Mikis Stasinopoulos</p>


<h3>References</h3>

<p>Marcus W. Beck (2015). NeuralNetTools: Visualization and Analysis Tools for Neural Networks. R package version 1.4.1. <a href="https://cran.r-project.org/package=NeuralNetTools">https://cran.r-project.org/package=NeuralNetTools</a>
</p>
<p>Hadley Wickham (2014). scales: Scale functions for graphics. R package version 0.4.0. <a href="https://cran.r-project.org/package=scales">https://cran.r-project.org/package=scales</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nn">nn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>r1 &lt;- gamlss(R~nn(~Fl+A+H+loc, size=10, decay=0.2), data=rent, 
      family=GA, gd.tol=1000, n.cyc=5)
getSmo(r1)
plot(getSmo(r1), y.lab=expression(eta[1]))
plot(getSmo(r1), y.lab=expression(g[1](mu)))
## Not run: 
r2 &lt;- gamlss(R~nn(~Fl+A+H+loc, size=10, decay=0.2), 
      sigma.fo=~nn(~Fl+A+H+loc, size=10, decay=0.2),data=rent, 
      family=GA, gd.tol=1000, n.cyc=5)
plot(getSmo(r2), y.lab=expression(g[1](mu)))
plot(getSmo(r2, what="sigma"), y.lab=expression(g[2](sigma)))

## End(Not run)
</code></pre>

<hr>
<h2 id='tr'>
A interface function to use rpart() function within GAMLSS
</h2><span id='topic+tr'></span><span id='topic+gamlss.tr'></span>

<h3>Description</h3>

<p>The tr() function is a additive function to be used for GAMLSS models. It is an interface for the <code>rpart()</code> function of package <code>rpart</code>. The function tr() allows the user to use regression trees within gamlss. The great advantage of course comes from the fact GAMLSS models provide a variety of distributions and diagnostics. Note that the function gamlss.tr is not used by the user but it needed for the backfitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(formula, method = c("rpart"), control = rpart.control(...), ...)
gamlss.tr(x, y, w, xeval = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tr_+3A_formula">formula</code></td>
<td>
<p>A formula containing the expolanatory variables i.e. <code>~x1+x2+x3</code>.</p>
</td></tr>
<tr><td><code id="tr_+3A_method">method</code></td>
<td>
<p>only method &quot;rpart&quot; is supported at the moment</p>
</td></tr>
<tr><td><code id="tr_+3A_control">control</code></td>
<td>
<p> control here is equivalent to <code>rpart.control()</code> function od package <code>rpart</code> </p>
</td></tr>
<tr><td><code id="tr_+3A_x">x</code></td>
<td>
<p>object passing informatio to the function</p>
</td></tr>
<tr><td><code id="tr_+3A_y">y</code></td>
<td>
<p>the iterative y variable</p>
</td></tr>
<tr><td><code id="tr_+3A_w">w</code></td>
<td>
<p>the iterative weights</p>
</td></tr>
<tr><td><code id="tr_+3A_xeval">xeval</code></td>
<td>
<p>whether prediction or not is used</p>
</td></tr>
<tr><td><code id="tr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, the gamlss fit maybe would not coverged. Also occasianly  the <code>gd.tol</code> argument in <code>gamlss</code> has to be increased. The 
</p>


<h3>Value</h3>

<p>Note that <code>tr</code> itself does no smoothing; it simply sets things up for the function <code>gamlss()</code> which in turn uses the function <code>additive.fit()</code> for backfitting which in turn uses <code>gamlss.tr()</code>
The result is a <code>rpart</code> object.
</p>


<h3>Author(s)</h3>

<p>Mikis Stasinopoulos <a href="mailto:mikis.stasinopoulos@gamlss.org">mikis.stasinopoulos@gamlss.org</a>, Bob Rigby  based on work of Therneau and Atkison (2015)
</p>


<h3>References</h3>

<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location, scale and shape,(with discussion), 
<em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>
<p>Rigby R.A., Stasinopoulos D. M., Heller G., and De Bastiani F., (2019) <em>Distributions for Modeling Location, Scale and Shape: Using GAMLSS in R</em>, Chapman and Hall/CRC.
</p>
<p>Ripley, B. D. (1996) <em>Pattern Recognition and Neural Networks</em>. Cambridge. 
</p>
<p>Stasinopoulos D. M. Rigby R.A. (2007) Generalized additive models for location scale and shape (GAMLSS) in R.
<em>Journal of Statistical Software</em>, <b>23</b>(7), 1&ndash;46, <a href="https://doi.org/10.18637/jss.v023.i07">doi:10.18637/jss.v023.i07</a>
</p>
<p>Stasinopoulos D. M., Rigby R.A., Heller G., Voudouris V., and De Bastiani F., (2017) <em>Flexible Regression and Smoothing: Using GAMLSS in R</em>, Chapman and Hall/CRC. 
</p>
<p>(see also <a href="https://www.gamlss.com/">https://www.gamlss.com/</a>).
</p>
<p>Therneau T. M., Atkinson E. J. (2015) An Introduction to Recursive Partitioning Using the RPART Routines. Vignette in package rpart.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) <em>Modern Applied Statistics with S</em>. Fourth edition. Springer. 
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+nn">nn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rent)
#--- fitting gamlss+tree Nornal
library(rpart)
data(rent)
rg1 &lt;- gamlss(R ~ tr(~A+Fl), data=rent, family=NO)
plot(rg1)
plot(getSmo(rg1))
text(getSmo(rg1))
## Not run: 
# fitting Gamma  errors
rg2 &lt;- gamlss(R ~ tr(~A+Fl), data=rent, family=GA)
plot(rg2)
plot(getSmo(rg2))
text(getSmo(rg2))
#--- fitting also model in the variance
rg3 &lt;- gamlss(R ~ tr(~A+Fl), sigma.fo=~tr(~Fl+A), data=rent, 
                family=GA, gd.tol=100, c.crit=0.1)
plot(rg3)
plot(getSmo(rg3))
text(getSmo(rg3))
plot(getSmo(rg3, what="sigma"))
text(getSmo(rg3, what="sigma"))
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
