<!DOCTYPE html><html><head><title>Help for package IFC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IFC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addScaleBar'><p>Image Scale Bar Incrustation</p></a></li>
<li><a href='#addText'><p>Image Text Incrustation</p></a></li>
<li><a href='#adjustGraph'><p>IFC Graph Adjustment</p></a></li>
<li><a href='#applyGatingStrategy'><p>Apply Gating Strategy</p></a></li>
<li><a href='#applyTrans'><p>Apply Transformation</p></a></li>
<li><a href='#assert'><p>Assert that Certain Conditions are Met</p></a></li>
<li><a href='#autoplot'><p>Automatic Parameters Detection for IFC Graphs</p></a></li>
<li><a href='#base_axis_constr'><p>Axis Constructor</p></a></li>
<li><a href='#base_hist_constr'><p>Histogram Constructor for 'base' Plot</p></a></li>
<li><a href='#base64_encode'><p>Raw Images to Base64 Encoding</p></a></li>
<li><a href='#BatchReport'><p>Batch Generation of Graphical and Statistic Report</p></a></li>
<li><a href='#BatchStatsReport'><p>Batch Generation of Statistic Report</p></a></li>
<li><a href='#buildBatch'><p>Batch Builder</p></a></li>
<li><a href='#buildFeature'><p>IFC Feature Coercion</p></a></li>
<li><a href='#buildGraph'><p>IFC Graph Coercion</p></a></li>
<li><a href='#buildIFD'><p>Image Field Directory Builder</p></a></li>
<li><a href='#buildImage'><p>IFC Image Coercion</p></a></li>
<li><a href='#buildMask'><p>IFC Mask Coercion</p></a></li>
<li><a href='#buildPopulation'><p>IFC Population Coercion</p></a></li>
<li><a href='#buildRegion'><p>IFC Region Coercion</p></a></li>
<li><a href='#buildStats'><p>IFC Statistics Coercion</p></a></li>
<li><a href='#calcDensity'><p>2D Binned Kernel Density Estimation</p></a></li>
<li><a href='#checkColor'><p>Character Color Check and RGB Conversion</p></a></li>
<li><a href='#checkObj'><p>'IFC_data' Object Check</p></a></li>
<li><a href='#checksumDAF'><p>DAF File Checksum</p></a></li>
<li><a href='#checksumIFC'><p>IFC Files Checksum</p></a></li>
<li><a href='#checksumXIF'><p>RIF/CIF File Checksum</p></a></li>
<li><a href='#colConv'><p>Integer to Hexadecimal Color Conversion</p></a></li>
<li><a href='#collapse_raw'><p>Raw Vectors Collapse</p></a></li>
<li><a href='#computeGamma'><p>Image Gamma Computation</p></a></li>
<li><a href='#convert_spillover'><p>Spillover Converter</p></a></li>
<li><a href='#coord_to_px'><p>User's Coordinates to Pixels Conversion</p></a></li>
<li><a href='#cpp_align'><p>Spatial Offsets Image Correction</p></a></li>
<li><a href='#cpp_as_nativeRaster'><p>Image to Native Raster Conversion</p></a></li>
<li><a href='#cpp_assert'><p>Input Parameters Assertive Tool</p></a></li>
<li><a href='#cpp_base64_encode'><p>Raw to Base64 Conversion</p></a></li>
<li><a href='#cpp_checksum'><p>Checksum for RIF/CIF</p></a></li>
<li><a href='#cpp_checkTIFF'><p>TIFF Checker</p></a></li>
<li><a href='#cpp_cleanse'><p>Matrix Cleanser</p></a></li>
<li><a href='#cpp_computeGamma'><p>Gamma Computation</p></a></li>
<li><a href='#cpp_coord_to_px'><p>Coordinates to Pixels</p></a></li>
<li><a href='#cpp_crop'><p>Matrix Cropping</p></a></li>
<li><a href='#cpp_decomp'><p>IFC_object Decompression</p></a></li>
<li><a href='#cpp_draw'><p>Draw Shape to Image</p></a></li>
<li><a href='#cpp_ell_coord'><p>Ellipse Boundaries to Coordinates</p></a></li>
<li><a href='#cpp_extract'><p>IFC_object Extraction</p></a></li>
<li><a href='#cpp_fast_factor'><p>Fast Factorize Vector</p></a></li>
<li><a href='#cpp_fast_listAny'><p>Use Rcpp to Apply Any on List members</p></a></li>
<li><a href='#cpp_fast_range'><p>Use Rcpp for Range</p></a></li>
<li><a href='#cpp_fast_rowAny'><p>Use Rcpp to Apply Any on Matrix Rows</p></a></li>
<li><a href='#cpp_fast_sample'><p>Use Rcpp for Sampling</p></a></li>
<li><a href='#cpp_fastTAGS'><p>IFD Fast Tags Extraction</p></a></li>
<li><a href='#cpp_get_bytes_order'><p>Get Bytes Order</p></a></li>
<li><a href='#cpp_getBits'><p>Get Current Compilation Bits Depth</p></a></li>
<li><a href='#cpp_getoffsets_noid'><p>IFC_offsets Computation without Id Determination</p></a></li>
<li><a href='#cpp_getoffsets_wid'><p>IFC_offsets Computation with Object Identification</p></a></li>
<li><a href='#cpp_getTAGS'><p>IFD Tags Extraction</p></a></li>
<li><a href='#cpp_group_df'><p>Data Frame Merge Groups with Rcpp</p></a></li>
<li><a href='#cpp_int32_to_uint32'><p>Int32 to Uint32 32bits Conversion</p></a></li>
<li><a href='#cpp_int64_to_uint64'><p>Int64 to Uint64 64bits Conversion</p></a></li>
<li><a href='#cpp_inv_smoothLinLog'><p>Inverse Smooth LinLog Transformation with Rcpp</p></a></li>
<li><a href='#cpp_M_HSV2RGB'><p>Matrix HSV to RGB Conversion</p></a></li>
<li><a href='#cpp_mark'><p>Matrix to Matrix Writer According to Mask with Offsets</p></a></li>
<li><a href='#cpp_mask'><p>Equal Sized Matrix to Matrix Writer According to Mask</p></a></li>
<li><a href='#cpp_mpfmatch'><p>Multiple Pattern Fixed Matching</p></a></li>
<li><a href='#cpp_normalize'><p>Matrix Normalization</p></a></li>
<li><a href='#cpp_offset_to_raw'><p>Offset to Raw Conversion</p></a></li>
<li><a href='#cpp_pnt_in_gate'><p>Point in Gate</p></a></li>
<li><a href='#cpp_raster'><p>Raster Image</p></a></li>
<li><a href='#cpp_raw_to_offset'><p>Offset to Raw Conversion</p></a></li>
<li><a href='#cpp_rawdecomp'><p>IFC_object Decompression to RAW</p></a></li>
<li><a href='#cpp_replace_non_finite'><p>Non Finite Values Replacement</p></a></li>
<li><a href='#cpp_resize'><p>Matrix Resizing</p></a></li>
<li><a href='#cpp_scanFirst'><p>File Scanner</p></a></li>
<li><a href='#cpp_seqmatch'><p>Sequence of Strings Matching</p></a></li>
<li><a href='#cpp_smoothLinLog'><p>Smooth LinLog Transformation with Rcpp</p></a></li>
<li><a href='#cpp_transform'><p>Matrix Transformation</p></a></li>
<li><a href='#cpp_uint32_to_int32'><p>Uint32 to Int32 32bits Conversion</p></a></li>
<li><a href='#cpp_uint32_to_raw'><p>Uint32 to Raw Conversion</p></a></li>
<li><a href='#cpp_uint64_to_int64'><p>Uint64 to Int64 64bits Conversion</p></a></li>
<li><a href='#cpp_v_int32_to_uint32'><p>Vectorize Int32 to Uint32 32bits Conversion</p></a></li>
<li><a href='#cpp_v_int64_to_uint64'><p>Vectorize Int64 to Uint64 64bits Conversion</p></a></li>
<li><a href='#cpp_writeBMP'><p>BMP Writer</p></a></li>
<li><a href='#CreateGraphReport'><p>Graph Report Generation</p></a></li>
<li><a href='#data_add_features'><p>Add Feature to IFC_data Object</p></a></li>
<li><a href='#data_add_graphs'><p>Add Graphs to IFC_data Object</p></a></li>
<li><a href='#data_add_pop_sample'><p>Population Sampling</p></a></li>
<li><a href='#data_add_pops'><p>Add Population to IFC_data Object</p></a></li>
<li><a href='#data_add_regions'><p>Add Region to IFC_data Object</p></a></li>
<li><a href='#data_modify_pops'><p>Modify Populations within IFC_data Object</p></a></li>
<li><a href='#data_modify_regions'><p>Modify Populations within IFC_data Object</p></a></li>
<li><a href='#data_rm_features'><p>Remove Features from an IFC_data Object</p></a></li>
<li><a href='#data_rm_graphs'><p>Remove Graph from an IFC_data Object</p></a></li>
<li><a href='#data_rm_pops'><p>Remove Population from an IFC_data Object</p></a></li>
<li><a href='#data_rm_regions'><p>Remove Region from an IFC_data Object</p></a></li>
<li><a href='#data_to_AST'><p>AST File Writer</p></a></li>
<li><a href='#data_to_DAF'><p>DAF File Writer</p></a></li>
<li><a href='#densCols'><p>Colors for Smooth Density Plots</p></a></li>
<li><a href='#DisplayGallery'><p>Gallery Display</p></a></li>
<li><a href='#DisplayReport'><p>Graphical and Statistic Report Display</p></a></li>
<li><a href='#endPB'><p>Progress Bar Terminator</p></a></li>
<li><a href='#escape_entities'><p>XML Entities Protection</p></a></li>
<li><a href='#expand_list'><p>XML Node List Expansion</p></a></li>
<li><a href='#ExportToBATCH'><p>Batch File Writer</p></a></li>
<li><a href='#ExportToDAF'><p>DAF File Writer</p></a></li>
<li><a href='#ExportToFCS'><p>FCS File Writer</p></a></li>
<li><a href='#ExportToGallery'><p>Gallery Export</p></a></li>
<li><a href='#ExportToNumpy'><p>Numpy Export</p></a></li>
<li><a href='#ExportToReport'><p>Graphical and Statistic Report Generation</p></a></li>
<li><a href='#ExportToXIF'><p>RIF/CIF File Writer</p></a></li>
<li><a href='#ExtractFromDAF'><p>DAF File Reader</p></a></li>
<li><a href='#ExtractFromFCS'><p>FCS File Reader</p></a></li>
<li><a href='#ExtractFromXIF'><p>RIF/CIF File Reader</p></a></li>
<li><a href='#ExtractImages_toBase64'><p>Shortcut for Batch Images Extraction to Base64</p></a></li>
<li><a href='#ExtractImages_toFile'><p>Shortcut for Batch Images Extraction to Files</p></a></li>
<li><a href='#ExtractImages_toMatrix'><p>Shortcut for Batch Images Extraction to Matrices/Arrays</p></a></li>
<li><a href='#ExtractMasks_toBase64'><p>Shortcut for Batch Masks Extraction to Base64</p></a></li>
<li><a href='#ExtractMasks_toFile'><p>Shortcut for Batch Masks Extraction to Files</p></a></li>
<li><a href='#ExtractMasks_toMatrix'><p>Shortcut for Batch Masks Extraction to Matrices/Arrays</p></a></li>
<li><a href='#extractStats'><p>Statistics Extraction</p></a></li>
<li><a href='#fastAny'><p>Any with Rcpp</p></a></li>
<li><a href='#fastCbind'><p>Combine by Columns</p></a></li>
<li><a href='#FCS_check_keywords'><p>FCS Keyword Checker</p></a></li>
<li><a href='#FCS_merge_dataset'><p>FCS Object Data Sets Merging</p></a></li>
<li><a href='#FCS_merge_sample'><p>FCS Object Samples Merging</p></a></li>
<li><a href='#FCS_to_data'><p>FCS Object Converter</p></a></li>
<li><a href='#feature_namer'><p>Feature Default Name Computation</p></a></li>
<li><a href='#featureIFC'><p>List IFC features</p></a></li>
<li><a href='#fetch_seed'><p>Seed Instructions Extraction</p></a></li>
<li><a href='#formatn'><p>File Path Placeholders Formatting</p></a></li>
<li><a href='#fromXML2_gating'><p>GatingML Conversion from XML2</p></a></li>
<li><a href='#gen_altnames'><p>Alternative Names Generator</p></a></li>
<li><a href='#get_coordmap_adjusted'><p>Device Adjusted Coordinates</p></a></li>
<li><a href='#get_coordmap_raw'><p>Device Raw Coordinates</p></a></li>
<li><a href='#get_feat_value'><p>Feature Values Computation</p></a></li>
<li><a href='#get_pops_stats'><p>Statistics Extraction from Populations</p></a></li>
<li><a href='#get_ylim'><p>Histogram y-Axis Limits Constructor</p></a></li>
<li><a href='#getAborted'><p>Aborted Batch Files Retrieval</p></a></li>
<li><a href='#getASSIST'><p>ASSIST Database Extraction</p></a></li>
<li><a href='#getFeaturesValues'><p>Features Values Extraction</p></a></li>
<li><a href='#getFileExt'><p>File Extension Retrieval</p></a></li>
<li><a href='#getFullTag'><p>Image Field Directory Full Tag Retrieval</p></a></li>
<li><a href='#getIFD'><p>RIF/CIF Image Field Directories Extraction</p></a></li>
<li><a href='#getImagesValues'><p>RIF/CIF Image Values Extraction</p></a></li>
<li><a href='#getInfo'><p>IFC File Information Extraction</p></a></li>
<li><a href='#getLuminance'><p>Luminance Computation</p></a></li>
<li><a href='#getOffsets'><p>RIF/CIF File Image Field Directories Offsets Extraction</p></a></li>
<li><a href='#getSTATSREPORT'><p>Statistics Report Template Extraction</p></a></li>
<li><a href='#group'><p>Groups Combination</p></a></li>
<li><a href='#gseq'><p>String Sequence Replacement</p></a></li>
<li><a href='#hist_constr'><p>Histogram Constructor</p></a></li>
<li><a href='#IFC-package'><p>Tools for Imaging Flow Cytometry</p></a></li>
<li><a href='#inv_colConv'><p>Hexadecimal to Integer Color Conversion</p></a></li>
<li><a href='#inv_smoothAsinh'><p>Inverse Smooth Asinh Transformation</p></a></li>
<li><a href='#inv_smoothLinLog'><p>Inverse Smooth LinLog Transformation</p></a></li>
<li><a href='#layoutReport'><p>Report Layout Extraction</p></a></li>
<li><a href='#map_color'><p>Color Mapping</p></a></li>
<li><a href='#map_style'><p>Style Mapping</p></a></li>
<li><a href='#mergeXIF'><p>RIF/CIF File Merging</p></a></li>
<li><a href='#modifyGamma'><p>Image Gamma Modification</p></a></li>
<li><a href='#myScales'><p>Scale Constructor for IFC Graphs Plotting</p></a></li>
<li><a href='#newPB'><p>Progress Bar Initializer</p></a></li>
<li><a href='#next_bool'><p>Next Component Prediction</p></a></li>
<li><a href='#num_to_string'><p>Numeric to String Formatting</p></a></li>
<li><a href='#objectCleanse'><p>Object Cleanser</p></a></li>
<li><a href='#objectColorize'><p>Object Colorizer</p></a></li>
<li><a href='#objectDisplay'><p>Object Display</p></a></li>
<li><a href='#objectExtract'><p>Object Extraction</p></a></li>
<li><a href='#objectNormalize'><p>Object Intensity Normalization</p></a></li>
<li><a href='#objectParam'><p>Object Extraction Parameters Definition</p></a></li>
<li><a href='#objectResize'><p>Object Resizing</p></a></li>
<li><a href='#objectTransform'><p>Object Transformation</p></a></li>
<li><a href='#objectWrite'><p>Object File Export</p></a></li>
<li><a href='#paletteIFC'><p>R/IDEAS Color Palette Mapping</p></a></li>
<li><a href='#pan_hist'><p>Lattice Histogram Panel Contructor</p></a></li>
<li><a href='#pan_key'><p>Lattice Key Panel Contructor</p></a></li>
<li><a href='#pan_smooth'><p>Histogram Smooth Constructor</p></a></li>
<li><a href='#parseFCSname'><p>FCS Name Parser</p></a></li>
<li><a href='#parseTrans'><p>Parse Transformation Information</p></a></li>
<li><a href='#plot_base'><p>&lsquo;IFC_plot' Conversion to &rsquo;base' Plot</p></a></li>
<li><a href='#plot_lattice'><p>&lsquo;IFC_plot' Conversion to &rsquo;lattice' Plot</p></a></li>
<li><a href='#plot_raster'><p>&lsquo;IFC_plot' Conversion to &rsquo;raster' Plot</p></a></li>
<li><a href='#plot_stats'><p>'IFC_plot' Statistics Extraction</p></a></li>
<li><a href='#plotGraph'><p>Plot and Stats Computation for IFC Graph</p></a></li>
<li><a href='#polyExtractTo'><p>Shortcut for Batch Images or Masks Extraction</p></a></li>
<li><a href='#popsCompute'><p>IFC_pops Computation</p></a></li>
<li><a href='#popsCopy'><p>Copy Populations from One File to Another File</p></a></li>
<li><a href='#popsGetAffiliation'><p>IFC_pops Affiliation Finder</p></a></li>
<li><a href='#popsGetLevels'><p>IFC_pops Levels Dependency Determination</p></a></li>
<li><a href='#popsGetObjectsIds'><p>IFC_pops Object Numbers</p></a></li>
<li><a href='#popsGetSiblings'><p>IFC_pops Sibling Population Identification</p></a></li>
<li><a href='#popsGetSiblings1'><p>IFC_pops Sibling Population from Same Base Identification</p></a></li>
<li><a href='#popsGetSiblings2'><p>IFC_pops Sibling Population from Same Region Identification</p></a></li>
<li><a href='#popsNetwork'><p>IFC_pops Network Display</p></a></li>
<li><a href='#popsOrderNodes'><p>IFC_pops Population Level Ordering</p></a></li>
<li><a href='#popsRename'><p>Populations Renaming</p></a></li>
<li><a href='#popsRetrieveGraph'><p>Graph Retrieval from Graphical IFC_pops</p></a></li>
<li><a href='#popsWithin'><p>IFC_pops Checker for Object Membership to Populations</p></a></li>
<li><a href='#pow2'><p>Power of Two</p></a></li>
<li><a href='#protectn'><p>Name Protection</p></a></li>
<li><a href='#pseudo_seed'><p>Pseudo Seed</p></a></li>
<li><a href='#random_name'><p>Random Name Generator</p></a></li>
<li><a href='#rasterplot'><p>Fast 2D plot</p></a></li>
<li><a href='#readFCS'><p>FCS File Parser</p></a></li>
<li><a href='#readFCSdata'><p>FCS Data Parser</p></a></li>
<li><a href='#readFCSdataset'><p>FCS Dataset Parser</p></a></li>
<li><a href='#readFCSdelimiter'><p>FCS Delimiter Reader</p></a></li>
<li><a href='#readFCSheader'><p>FCS Header Parser</p></a></li>
<li><a href='#readFCStext'><p>FCS Text Parser</p></a></li>
<li><a href='#readGatingML'><p>GatingML File Reader</p></a></li>
<li><a href='#readGatingStrategy'><p>Gating Strategy File Reader</p></a></li>
<li><a href='#readIFC'><p>IFC Files Generic Reader</p></a></li>
<li><a href='#redefine_features_def'><p>IFC_features_def Redefinition</p></a></li>
<li><a href='#redefine_features_def_feat'><p>IFC_features_def Feature Redefinition</p></a></li>
<li><a href='#redefine_features_def_msk_img'><p>IFC_features_def Mask or Image Redefinition</p></a></li>
<li><a href='#redefine_masks'><p>IFC_masks Redefinition</p></a></li>
<li><a href='#redefine_masks_image'><p>IFC_masks Image Redefinition</p></a></li>
<li><a href='#redefine_masks_mask'><p>IFC_masks Mask Redefinition</p></a></li>
<li><a href='#redefine_obj'><p>IFC_data Redefinition</p></a></li>
<li><a href='#relayout'><p>Change Graphs Layout</p></a></li>
<li><a href='#remove_ext'><p>File Extension Removal</p></a></li>
<li><a href='#rev_string'><p>Reverse String</p></a></li>
<li><a href='#setPB'><p>Progress Bar Updater</p></a></li>
<li><a href='#smoothAsinh'><p>Smooth Asinh Transformation</p></a></li>
<li><a href='#smoothLinLog'><p>Smooth LinLog Transformation</p></a></li>
<li><a href='#specialr'><p>Special Character Replacement</p></a></li>
<li><a href='#split_feat'><p>IFC_features_def Definition Splitting</p></a></li>
<li><a href='#splitf'><p>File Path Decomposition</p></a></li>
<li><a href='#splitn'><p>String Decomposition with Operators</p></a></li>
<li><a href='#splitp'><p>String Decomposition with Placeholders</p></a></li>
<li><a href='#StatsReport'><p>Statistical Report Generation</p></a></li>
<li><a href='#subsetOffsets'><p>IFC_offset Subsetting</p></a></li>
<li><a href='#subsetXIF'><p>RIF/CIF File Subsetting</p></a></li>
<li><a href='#swap_channel'><p>Channel Swap</p></a></li>
<li><a href='#switch_channel'><p>Channel Switch</p></a></li>
<li><a href='#testXIF'><p>RIF/CIF Image Order Test</p></a></li>
<li><a href='#texttomatrix'><p>Text to Image Conversion</p></a></li>
<li><a href='#to_list_node'><p>XML Node to List Conversion</p></a></li>
<li><a href='#to_xml_list'><p>List to XML Node Conversion</p></a></li>
<li><a href='#toBIN_features'><p>IFC_features Raw Conversion</p></a></li>
<li><a href='#toBIN_images'><p>IFC_images Raw Conversion</p></a></li>
<li><a href='#toCapFirstOnly'><p>First Letter Only Capitalization</p></a></li>
<li><a href='#toEllipse'><p>Ellipsoid Polygon Constructor</p></a></li>
<li><a href='#toXML2_boolpop_gs'><p>Boolean Population GatingML Conversion to XML2</p></a></li>
<li><a href='#toXML2_features'><p>IFC_features XML Conversion</p></a></li>
<li><a href='#toXML2_features_def'><p>IFC_features_def XML Conversion</p></a></li>
<li><a href='#toXML2_graphpop_gs'><p>Graphical Population GatingML Conversion to XML2</p></a></li>
<li><a href='#toXML2_graphs'><p>IFC_graphs XML Conversion</p></a></li>
<li><a href='#toXML2_graphs_gs'><p>IFC_graphs GatingML Conversion</p></a></li>
<li><a href='#toXML2_images'><p>IFC_images XML Conversion</p></a></li>
<li><a href='#toXML2_masks'><p>IFC_masks XML Conversion</p></a></li>
<li><a href='#toXML2_pops'><p>IFC_pops XML Conversion</p></a></li>
<li><a href='#toXML2_regions'><p>IFC_regions XML Conversion</p></a></li>
<li><a href='#toXML2_spillover_gs'><p>Spillover GatingML Conversion</p></a></li>
<li><a href='#toXML2_stats'><p>IFC_stats XML Conversion</p></a></li>
<li><a href='#trunc_string'><p>String Truncation</p></a></li>
<li><a href='#tryReportFileCreation'><p>Report File Creation</p></a></li>
<li><a href='#type_constr'><p>Histogram Type Constructor</p></a></li>
<li><a href='#usedefault_obj'><p>IFC_data Default Naming</p></a></li>
<li><a href='#val_constr'><p>Histogram Val Constructor</p></a></li>
<li><a href='#validate_bool'><p>Boolean Expression Validation</p></a></li>
<li><a href='#whoami'><p>Input Identification</p></a></li>
<li><a href='#with_seed'><p>With Seed Evaluation</p></a></li>
<li><a href='#writeGatingStrategy'><p>Gating Strategy File Writer</p></a></li>
<li><a href='#writeIFC'><p>IFC Files Generic Writer</p></a></li>
<li><a href='#writeIFD'><p>Image Field Directory Writer</p></a></li>
<li><a href='#XIFtoTIFF'><p>RIF/CIF File Conversion to TIFF</p></a></li>
<li><a href='#xml_new_node'><p>List to XML Conversion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Imaging Flow Cytometry</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-13</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yohann Demont &lt;git.demont@gmail.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gitdemont/IFC/issues">https://github.com/gitdemont/IFC/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Contains several tools to treat imaging flow cytometry data from 'ImageStream®' and 'FlowSight®' cytometers ('Amnis®' 'Cytek®'). Provides an easy and simple way to read and write .fcs, .rif, .cif and .daf files. Information such as masks, features, regions and populations set within these files can be retrieved for each single cell. In addition, raw data such as images stored can also be accessed. Users, may hopefully increase their productivity thanks to dedicated functions to extract, visualize, manipulate and export 'IFC' data. Toy data example can be installed through the 'IFCdata' package of approximately 32 MB, which is available in a 'drat' repository <a href="https://gitdemont.github.io/IFCdata/">https://gitdemont.github.io/IFCdata/</a>. See file 'COPYRIGHTS' and file 'AUTHORS' for a list of copyright holders and authors.</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file inst/COPYRIGHTS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.10.0), xml2, utils, grid, gridExtra, gridGraphics,
lattice, latticeExtra, KernSmooth, DT, visNetwork</td>
</tr>
<tr>
<td>Suggests:</td>
<td>IFCdata, shiny, reticulate, png, tiff, jpeg</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://gitdemont.github.io/IFCdata/">https://gitdemont.github.io/IFCdata/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-13 14:58:28 UTC; Amnis</td>
</tr>
<tr>
<td>Author:</td>
<td>Yohann Demont [aut, cre],
  Gautier Stoll [ctb],
  Guido Kroemer [ldr],
  Jean-Pierre Marolleau [ldr],
  Loïc Garçon [ldr]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-13 22:32:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='addScaleBar'>Image Scale Bar Incrustation</h2><span id='topic+addScaleBar'></span>

<h3>Description</h3>

<p>Adds scale bar to image
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addScaleBar(
  image,
  size,
  style = c("dash", "line")[1],
  color = "white",
  res = 96,
  xoff = 0,
  yoff = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addScaleBar_+3A_image">image</code></td>
<td>
<p>a [0,1] image.</p>
</td></tr>
<tr><td><code id="addScaleBar_+3A_size">size</code></td>
<td>
<p>positive integer. Scale's bar size in micro-meter. Default is '7'.<br />
This parameter can't be lesser than 6px and higher than image width + scale text.</p>
</td></tr>
<tr><td><code id="addScaleBar_+3A_style">style</code></td>
<td>
<p>a character string. Scale's bar style, either 'dash' or 'line'. Default is 'dash'.</p>
</td></tr>
<tr><td><code id="addScaleBar_+3A_color">color</code></td>
<td>
<p>a character string. color of the scale. Default is 'white'.</p>
</td></tr>
<tr><td><code id="addScaleBar_+3A_res">res</code></td>
<td>
<p>positive integer. Resolution in ppi of 'image'. Default is '96'.</p>
</td></tr>
<tr><td><code id="addScaleBar_+3A_xoff">xoff</code></td>
<td>
<p>positive integer. x offset in image to draw scale, starting from bottom left corner.</p>
</td></tr>
<tr><td><code id="addScaleBar_+3A_yoff">yoff</code></td>
<td>
<p>positive integer. y offset in image to draw scale, starting from bottom left corner.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an image with scale added to the bottom left corner.
</p>

<hr>
<h2 id='addText'>Image Text Incrustation</h2><span id='topic+addText'></span>

<h3>Description</h3>

<p>Adds Text to image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addText(image, text, color, xoff = 0, yoff = 0, corner = "TL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addText_+3A_image">image</code></td>
<td>
<p>a [0,1] image.</p>
</td></tr>
<tr><td><code id="addText_+3A_text">text</code></td>
<td>
<p>a character string.</p>
</td></tr>
<tr><td><code id="addText_+3A_color">color</code></td>
<td>
<p>a character string. color of the text.</p>
</td></tr>
<tr><td><code id="addText_+3A_xoff">xoff</code></td>
<td>
<p>positive integer. x offset in image to start writing text.</p>
</td></tr>
<tr><td><code id="addText_+3A_yoff">yoff</code></td>
<td>
<p>positive integer. y offset in image to start writing text.</p>
</td></tr>
<tr><td><code id="addText_+3A_corner">corner</code></td>
<td>
<p>a character string. where to position text in the image. Allowed are &quot;TL&quot;, &quot;TR&quot;, &quot;BL&quot;, &quot;BR&quot;, for top-left, top-right, bottom-left, bottom-right, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One-lined text will be added so has to be fully contained within image and anchored at desired corner plus x and y offset from it.
</p>


<h3>Value</h3>

<p>an image with text added.
</p>

<hr>
<h2 id='adjustGraph'>IFC Graph Adjustment</h2><span id='topic+adjustGraph'></span>

<h3>Description</h3>

<p>Helper to readjust 'IFC_data' graphs in case of missing feature, region, population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustGraph(obj, graph, adjust_graph = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustGraph_+3A_obj">obj</code></td>
<td>
<p>an object of class 'IFC_data' extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="adjustGraph_+3A_graph">graph</code></td>
<td>
<p>a graph from 'obj' or a list that can be coerced by <code><a href="#topic+buildGraph">buildGraph</a></code>.</p>
</td></tr>
<tr><td><code id="adjustGraph_+3A_adjust_graph">adjust_graph</code></td>
<td>
<p>whether to try to adjust graph(s) when possible. Default is TRUE.<br />
-TRUE, graph(s) will be kept if possible using only regions, pops it depends that can be found in 'obj',<br />
-FALSE, graph(s) will be kept only if all features, regions, pops it refers to are found in 'obj',<br />
-NA, graph(s) will be removed no matter if features, regions, pops it refers to are found in 'obj'.</p>
</td></tr>
<tr><td><code id="adjustGraph_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='applyGatingStrategy'>Apply Gating Strategy</h2><span id='topic+applyGatingStrategy'></span>

<h3>Description</h3>

<p>Applies Gating Strategy to an 'IFC_data' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyGatingStrategy(
  obj,
  gating,
  keep,
  display_progress = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyGatingStrategy_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="applyGatingStrategy_+3A_gating">gating</code></td>
<td>
<p>an 'IFC_gating' object extracted by <code><a href="#topic+readGatingStrategy">readGatingStrategy</a></code>.</p>
</td></tr>
<tr><td><code id="applyGatingStrategy_+3A_keep">keep</code></td>
<td>
<p>names of population(s) that should not be overwritten using 'gating'.</p>
</td></tr>
<tr><td><code id="applyGatingStrategy_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="applyGatingStrategy_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="applyGatingStrategy_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>/!\ Please note that all former gating strategy (i.e. regions, pops, graphs and stats) will be removed from returned object, with the exception of population(s) described in 'keep'.<br />
An error will be thrown if a feature is required to create a population or a graph but can't be found in 'obj'.<br />
When tagged population(s) is(are) imported, objects from this(these) population(s) outside 'obj' will be discarded.<br />
If this results in NULL, then all objects will be tagged.
</p>


<h3>Value</h3>

<p>A named list of class 'IFC_data' with new regions, pops and graphs
</p>

<hr>
<h2 id='applyTrans'>Apply Transformation</h2><span id='topic+applyTrans'></span>

<h3>Description</h3>

<p>Helper apply transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyTrans(x, trans, inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyTrans_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="applyTrans_+3A_trans">trans</code></td>
<td>
<p>the object returned by parseTrans().</p>
</td></tr>
<tr><td><code id="applyTrans_+3A_inverse">inverse</code></td>
<td>
<p>whether or not to apply the inverse transformation. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for the moment, in addition to no transformation, only &quot;smoothLinLog&quot;, &quot;asinh&quot;, and &quot;sqrt&quot; are supported.
</p>


<h3>Value</h3>

<p>the transformation of the input
</p>

<hr>
<h2 id='assert'>Assert that Certain Conditions are Met</h2><span id='topic+assert'></span>

<h3>Description</h3>

<p>Ensures that a variable respects several parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert(x, len = NULL, cla = NULL, typ = NULL, alw = NULL, fun = "stop")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_+3A_x">x</code></td>
<td>
<p>variable to test</p>
</td></tr>
<tr><td><code id="assert_+3A_len">len</code></td>
<td>
<p>integer vector of allowed length for x. Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="assert_+3A_cla">cla</code></td>
<td>
<p>character vector of allowed classes of x. Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="assert_+3A_typ">typ</code></td>
<td>
<p>character vector of allowed types of x. Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="assert_+3A_alw">alw</code></td>
<td>
<p>allowed values for x. Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="assert_+3A_fun">fun</code></td>
<td>
<p>function to execute when mandatory parameters are not met. Default is &quot;stop&quot;. Allowed are &quot;stop&quot;,&quot;warning&quot;,&quot;message&quot;,&quot;return&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>/!\ alw parameter when used should be coercible to a logical, integer, numeric, complex or character vector. Otherwise, an error will be thrown.
</p>

<hr>
<h2 id='autoplot'>Automatic Parameters Detection for IFC Graphs</h2><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>Function intended to generate IFC graphs with minimal inputs from users.<br />
It is essentially based on automatic detection of graphical parameters thanks to 'shown_pops' argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot(
  obj,
  shown_pops = NULL,
  subset = NULL,
  x = NULL,
  x_trans = NULL,
  y = NULL,
  y_trans = NULL,
  type = NULL,
  smoothingfactor = NULL,
  normalize = NULL,
  bin,
  viewport = "ideas",
  precision = c("light", "full")[1],
  color_mode = c("white", "black")[1],
  draw = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="autoplot_+3A_shown_pops">shown_pops</code></td>
<td>
<p>one or several populations present in 'obj'. Default is NULL.<br />
If provided, <code><a href="#topic+autoplot">autoplot</a></code> will try to display these populations. See details when not provided.<br />
<br />
<code><a href="#topic+autoplot">autoplot</a></code> will try to determine x and y and their transformations based on 'shown_pops' parameter.
If all populations provided in 'shown_pops' are siblings, region(s) from which 'shown_pops' were defined 
will be displayed.<br />
In case 'shown_pops' are not siblings, they will be treated as populations and a graph will be generating with an overlay of these populations.
Order of this overlay is given by order of 'shown_pops'.<br />
Finally, changing any of the following arguments (x, x_trans, y, y_trans, type)
to something else than the one detected from 'shown_pops' will prevent from displaying region(s) and
'shown_pops' populations will be displayed as overlay.<br />
However, please consider that if original type is 'histogram' changing x_trans transformation will have no impact on this.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_subset">subset</code></td>
<td>
<p>a population present in 'obj'. Default is NULL.
Background population that will be used to generate graph.
This argument will not be used when graph is an histogram.
If this argument is filled with a different population than what can be determined thanks to 'shown_pops',
Then 'shown_pops' will be treated as overlay.
However, 'shown_pops' argument can still be used to determine x, y axis and their transformation</p>
</td></tr>
<tr><td><code id="autoplot_+3A_x">x</code></td>
<td>
<p>feature for x-axis. Default is NULL.
When empty, <code><a href="#topic+autoplot">autoplot</a></code> will try to determine if automatically from 'shown_pops' argument.
If provided, x feature has to be a name from 'obj' features.
Note that providing x feature :
- takes precedence on automatic x-axis detection.
- will reset x-axis transformation to &quot;P&quot; except if 'x_trans' is filled.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_x_trans">x_trans</code></td>
<td>
<p>parameter for x-axis transformation. Default is NULL.
If not provided, transformation will be determined thanks to 'shown_pops'.
It takes precedence when provided and if provided it has to be be either &quot;P&quot; or coercible to a positive numeric.
&quot;P&quot; will leave x-axis as is but a positive numeric will be passed has hyper argument of <code><a href="#topic+smoothLinLog">smoothLinLog</a></code> to transform x-axis.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_y">y</code></td>
<td>
<p>feature for y-axis. Default is NULL.
When empty, <code><a href="#topic+autoplot">autoplot</a></code> will try to determine it automatically from 'shown_pops' argument.
If provided, y feature has to be a name from obj features.
Note that providing y feature 
- takes precedence on automatic y-axis detection.
- will reset y-axis transformation to &quot;P&quot; except if 'y_trans' is filled.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_y_trans">y_trans</code></td>
<td>
<p>parameter for y-axis transformation. Default is NULL.
If not provided, transformation will be determined thanks to 'shown_pops'.
It takes precedence when provided and and if provided it has to be be either &quot;P&quot; or coercible to a positive numeric.
&quot;P&quot; will leave y-axis as is but a positive numeric will be passed has hyper argument of <code><a href="#topic+smoothLinLog">smoothLinLog</a></code> to transform y-axis.
Note that it is irrelevant for &quot;histogram&quot;.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_type">type</code></td>
<td>
<p>type of plot. Default is NULL to allow <code><a href="#topic+autoplot">autoplot</a></code> to detemine 'type' automatically.
If provided it has to be either &quot;histogram&quot;, &quot;scatter&quot;, &quot;density&quot;.
Note that when &quot;histogram&quot; is choosen, 'subset' parameter will not be used.
Note that &quot;density&quot; will be possible only when 'subset' will be automatically determined or filled with only one population.
Note that when <code><a href="#topic+autoplot">autoplot</a></code> has determined, thanks to 'shown_pops' that original plot is an &quot;histogram&quot;, 
&quot;Object Number&quot; will be used as y-axis by default when 'type' is forced to &quot;scatter&quot; or &quot;density&quot;.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_smoothingfactor">smoothingfactor</code></td>
<td>
<p>when type of graph is &quot;histogram&quot;, whether to smooth it or not. Default is NULL. Should be an integer [0:20]
Note that 0 means no smoothing and other values will produce smoothing</p>
</td></tr>
<tr><td><code id="autoplot_+3A_normalize">normalize</code></td>
<td>
<p>when type of graph is &quot;histogram&quot;, whether to normalize it or not. Default is NULL. Should be a logical.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_bin">bin</code></td>
<td>
<p>number of bins when graph's type is &quot;histogram&quot; / number of equally spaced grid points for density.
Default is missing to allow <code><a href="#topic+autoplot">autoplot</a></code> to determine it by itself.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_viewport">viewport</code></td>
<td>
<p>Either &quot;ideas&quot;, &quot;data&quot; or &quot;max&quot; defining limits used for the graph. Default is &quot;ideas&quot;.<br />
-&quot;ideas&quot; will use same limits as the one defined in ideas.<br />
-&quot;data&quot; will use data to define limits.<br />
-&quot;max&quot; will use data and regions drawn to define limits.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_precision">precision</code></td>
<td>
<p>when graphs is a 2D scatter with population overlay, this argument controls amount of information displayed. Default is &quot;light&quot;.<br />
-&quot;light&quot;, the default, will only display points of same coordinates that are amoung the other layers.<br />
-&quot;full&quot; will display all the layers.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_color_mode">color_mode</code></td>
<td>
<p>Whether to extract colors from obj in white or black mode. Default is &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_draw">draw</code></td>
<td>
<p>whether to draw plot. Default is TRUE.</p>
</td></tr>
<tr><td><code id="autoplot_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when 'shown_pops' are not provided, <code><a href="#topic+autoplot">autoplot</a></code> can't determine anything.<br />
So, if not provided default values will be used:<br />
-'subset' = &quot;All&quot;<br />
-'x' = &quot;Object Number&quot;<br />
-'x_trans' = &quot;P&quot;<br />
-'y' = &quot;Object Number&quot;<br />
-'y_trans' = &quot;P&quot;<br />
-'type' = &quot;histogram&quot;
</p>


<h3>Value</h3>

<p>an <span class="pkg">lattice</span> trellis object
</p>

<hr>
<h2 id='base_axis_constr'>Axis Constructor</h2><span id='topic+base_axis_constr'></span>

<h3>Description</h3>

<p>Helper to rescale and label axes when linlog / asinh transformation is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_axis_constr(lim, trans = "P", nint = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_axis_constr_+3A_lim">lim</code></td>
<td>
<p>vector of length 2 of axis extents.</p>
</td></tr>
<tr><td><code id="base_axis_constr_+3A_trans">trans</code></td>
<td>
<p>transformation applied. Defaut is &quot;P&quot;.</p>
</td></tr>
<tr><td><code id="base_axis_constr_+3A_nint">nint</code></td>
<td>
<p>positive integer value indicating (approximately) the desired number of intervals. Default is 10.</p>
</td></tr>
</table>

<hr>
<h2 id='base_hist_constr'>Histogram Constructor for 'base' Plot</h2><span id='topic+base_hist_constr'></span>

<h3>Description</h3>

<p>Helper to create histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_hist_constr(
  x,
  type,
  br,
  normalize,
  fill,
  smooth,
  lwd,
  lty,
  col,
  alpha,
  border,
  include.lowest = TRUE,
  right = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base_hist_constr_+3A_x">x</code></td>
<td>
<p>a vector of values for which the histogram is desired.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_type">type</code></td>
<td>
<p>histogram type. Default is missing. Allowed are &quot;count&quot; and &quot;percent&quot;.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_br">br</code></td>
<td>
<p>breakpoints given an interval and the number of pieces to break it into.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_normalize">normalize</code></td>
<td>
<p>whether to normalize. Default is missing.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_fill">fill</code></td>
<td>
<p>whether to fill. Default is missing.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_smooth">smooth</code></td>
<td>
<p>whether to smooth. Default is missing.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_lwd">lwd</code>, <code id="base_hist_constr_+3A_lty">lty</code>, <code id="base_hist_constr_+3A_col">col</code>, <code id="base_hist_constr_+3A_alpha">alpha</code>, <code id="base_hist_constr_+3A_border">border</code></td>
<td>
<p>graphical parameters. See par() from package 'graphics'.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_include.lowest">include.lowest</code></td>
<td>
<p>logical; if TRUE, an x[i] equal to the breaks value will be included in the first (or last, for right = FALSE) bar. This will be ignored (with a warning) unless breaks is a vector.</p>
</td></tr>
<tr><td><code id="base_hist_constr_+3A_right">right</code></td>
<td>
<p>logical; if TRUE, the histogram cells are right-closed (left open) intervals.</p>
</td></tr>
</table>

<hr>
<h2 id='base64_encode'>Raw Images to Base64 Encoding</h2><span id='topic+base64_encode'></span>

<h3>Description</h3>

<p>Encodes raw image vector to base64 string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base64_encode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="base64_encode_+3A_x">x</code></td>
<td>
<p>a raw vector.</p>
</td></tr>
</table>


<h3>Source</h3>

<p><a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64">https://en.wikibooks.org/wiki/Algorithm_Implementation/Miscellaneous/Base64</a>
</p>

<hr>
<h2 id='BatchReport'>Batch Generation of Graphical and Statistic Report</h2><span id='topic+BatchReport'></span>

<h3>Description</h3>

<p>Batch creates graphical an statistical report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BatchReport(
  fileName,
  obj,
  selection,
  write_to,
  overwrite = FALSE,
  gating,
  main,
  byrow = FALSE,
  times = 5,
  color_mode = c("white", "black")[1],
  add_key = "panel",
  precision = c("light", "full")[1],
  trunc_labels = 38,
  trans = "asinh",
  bin,
  viewport = "ideas",
  backend = "lattice",
  display_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BatchReport_+3A_filename">fileName</code>, <code id="BatchReport_+3A_obj">obj</code></td>
<td>
<p>either one or the other. Path to file(s) to read from for 'fileName' or list of 'IFC_data' objects for obj.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_selection">selection</code></td>
<td>
<p>indices of desired graphs. It can be provided as an integer vector or as a matrix.<br />
In such case, the layout of the matrix will reflect the layout of the extracted graphs for each 'fileName' or &rdquo;obj'.<br />
NA value will result in an empty place. When missing, it will be determined by the whole layout of 1st 'fileName' or 'obj' with 'gating' applied when provided</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file(s).
Placeholders, like c(&quot;%d/%s_fromR.pdf&quot;, &quot;%d/%s_fromR.csv&quot;), will be substituted:<br />
-%d: with full path directory<br />
-%p: with first parent directory<br />
-%e: with extension (without leading .)<br />
-%s: with shortname (i.e. basename without extension).<br />
Exported file(s) extension(s) will be deduced from this pattern using either 1st 'fileName' or 'obj'. Note that has to be a .pdf and/or .csv.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.
Note that if TRUE, it will overwrite file. In addition a warning message will be sent.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_gating">gating</code></td>
<td>
<p>an 'IFC_gating' object as extracted by readGatingStrategy(). Default is missing.
If not missing, each &lsquo;IFC_data' provided in &rsquo;obj' or read from 'fileName' will be passed to applyGatingStrategy() before creating the report.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_main">main</code></td>
<td>
<p>the main title of the document. Default is missing.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_byrow">byrow</code></td>
<td>
<p>whether to add selected graphs for each file by row or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_times">times</code></td>
<td>
<p>number of files to add before starting a new row or column (depending on 'byrow').</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_color_mode">color_mode</code></td>
<td>
<p>Whether to extract colors in white or black mode. Default is &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_add_key">add_key</code></td>
<td>
<p>whether to draw a &quot;global&quot; key under title or in the first &quot;panel&quot; or &quot;both&quot;. Default is &quot;panel&quot;.<br />
Accepted values are either: FALSE, &quot;panel&quot;, &quot;global&quot;, &quot;both&quot; or c(&quot;panel&quot;, &quot;global&quot;).<br />
Note that it only applies when display is seen as overlaying populations.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_precision">precision</code></td>
<td>
<p>when graphs is a 2D scatter with population overlay, this argument controls amount of information displayed. Default is &quot;light&quot;.<br />
-&quot;light&quot;, the default, will only display points of same coordinates that are among the other layers.<br />
-&quot;full&quot; will display all the layers.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_trunc_labels">trunc_labels</code></td>
<td>
<p>maximum number of characters to display for labels. Default is 38.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_trans">trans</code></td>
<td>
<p>name of the transformation function for density graphs. If missing the default, the BasePop[[1]]$densitytrans, if any, will be retrieved, otherwise &quot;asinh&quot; will be used.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_bin">bin</code></td>
<td>
<p>default number of bin used for histogram. Default is missing.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_viewport">viewport</code></td>
<td>
<p>Either &quot;ideas&quot;, &quot;data&quot; or &quot;max&quot; defining limits used for the graph. Default is &quot;ideas&quot;.<br />
-&quot;ideas&quot; will use same limits as the one defined in ideas.<br />
-&quot;data&quot; will use data to define limits.<br />
-&quot;max&quot; will use data and regions drawn to define limits.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_backend">backend</code></td>
<td>
<p>backend used for drawing. Allowed are &quot;lattice&quot;, &quot;base&quot;, &quot;raster&quot;. Default is &quot;lattice&quot;.<br />
-&quot;lattice&quot; is the original one used in <span class="pkg">IFC</span> using <span class="pkg">lattice</span>,<br />
-&quot;base&quot; will produce the plot using <span class="pkg">base</span>,<br />
-&quot;raster&quot; uses &quot;base&quot; for plotting but 2D graphs points will be produced as <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>.<br />
This has the main advantage of being super fast allowing for plotting a huge amount of points while generating smaller objects (in bytes).
However, plot quality is impacted with &quot;raster&quot; method and resizing can lead to unpleasant looking.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="BatchReport_+3A_...">...</code></td>
<td>
<p>other parameters to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It invisibly returns full path of exported .pdf and/or .csv file(s).
</p>

<hr>
<h2 id='BatchStatsReport'>Batch Generation of Statistic Report</h2><span id='topic+BatchStatsReport'></span>

<h3>Description</h3>

<p>Generates statistics report on batch of files or 'IFC_data' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BatchStatsReport(fileName, obj, stats, gating, display_progress = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BatchStatsReport_+3A_filename">fileName</code>, <code id="BatchStatsReport_+3A_obj">obj</code></td>
<td>
<p>either one or the other. Path to file(s) to read from for 'fileName' or list of 'IFC_data' objects for obj.</p>
</td></tr>
<tr><td><code id="BatchStatsReport_+3A_stats">stats</code></td>
<td>
<p>template defining stats to compute as extracted by getSTATSREPORT().</p>
</td></tr>
<tr><td><code id="BatchStatsReport_+3A_gating">gating</code></td>
<td>
<p>an 'IFC_gating' object as extracted by readGatingStrategy(). Default is missing.
If not missing, each &lsquo;IFC_data' provided in &rsquo;obj' or read from 'fileName' will be passed to applyGatingStrategy() before creating the report.</p>
</td></tr>
<tr><td><code id="BatchStatsReport_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="BatchStatsReport_+3A_...">...</code></td>
<td>
<p>other parameters to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of statistics
</p>

<hr>
<h2 id='buildBatch'>Batch Builder</h2><span id='topic+buildBatch'></span>

<h3>Description</h3>

<p>Prepares XML node for <code><a href="#topic+ExportToBATCH">ExportToBATCH</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildBatch(
  files,
  compensation,
  analysis,
  default_batch_dir,
  config_file,
  name = "Batch1",
  use_acquisition = FALSE,
  suffix = "",
  allow_channels_dissimilarity = FALSE,
  overwrite = TRUE,
  segment_rif = "None",
  options
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildBatch_+3A_files">files</code></td>
<td>
<p>path of files to batch.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_compensation">compensation</code></td>
<td>
<p>path to compensation file.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_analysis">analysis</code></td>
<td>
<p>path to analysis file.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_default_batch_dir">default_batch_dir</code></td>
<td>
<p>directory where batches are stored.<br />
It can be found in IDEAS(R) software, under Options -&gt; Application Defaults -&gt; Directories -&gt; Default Batch Report Files Directory.<br />
If missing, the default, it will be deduced from IDEAS(R) config file, However, if it can't be deduced then tempdir(check = TRUE) from <span class="pkg">base</span> will be used.<br />
This argument takes precedence over 'config_file' and filling 'default_batch_dir' prevents the use of 'config_file' argument.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_config_file">config_file</code></td>
<td>
<p>path to IDEAS(R) config file.<br />
It may depends on IDEAS(R) software installation but one may use &quot;C:/Users/%USER%/AppData/Roaming/Amnis Corporation/userconfig.xml&quot;.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_name">name</code></td>
<td>
<p>name of batch. Default is &quot;Batch1&quot;.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_use_acquisition">use_acquisition</code></td>
<td>
<p>whether to use acquisition as analysis template. Default is FALSE.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_suffix">suffix</code></td>
<td>
<p>suffix to add to files when batched. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_allow_channels_dissimilarity">allow_channels_dissimilarity</code></td>
<td>
<p>whether to allow building batch when all files were not acquired with same channels. Default is FALSE.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite files or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_segment_rif">segment_rif</code></td>
<td>
<p>size of file segmentation. Default is &quot;None&quot;, for no segmentation.<br />
Allowed are &quot;None&quot;, &quot;100&quot;, &quot;1K&quot;, &quot;5K&quot;, &quot;10K&quot;, &quot;50K&quot;, &quot;100K&quot;.</p>
</td></tr>
<tr><td><code id="buildBatch_+3A_options">options</code></td>
<td>
<p>A list of arguments to be passed.<br />
If missing, the default, options will be set to:<br />
-&quot;Brightfield compensation&quot;=TRUE,<br />
-&quot;EDF deconvolution&quot;=TRUE,<br />
-&quot;Camera background&quot;=TRUE,<br />
-&quot;Spatial alignment&quot;=TRUE.<br />
Allowed are TRUE or FALSE for all, excepted for 'Spatial aligment' which can also be path to .rif file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing batch information:<br />
-xml, the xml object to be written,<br />
-batch_dir, the directory where xml file is desired to be saved according to 'default_batch_dir' and 'config_file'.
</p>

<hr>
<h2 id='buildFeature'>IFC Feature Coercion</h2><span id='topic+buildFeature'></span>

<h3>Description</h3>

<p>Helper to build a list to allow feature export.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildFeature(
  name,
  type = c("single", "combined", "computed")[1],
  def = "Camera Line Number",
  val = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildFeature_+3A_name">name</code></td>
<td>
<p>feature's name. If missing, it will be determined thanks to def.</p>
</td></tr>
<tr><td><code id="buildFeature_+3A_type">type</code></td>
<td>
<p>feature's type. Default is &quot;single&quot;. Allowed are &quot;single&quot;, &quot;combined&quot;, &quot;computed&quot;.</p>
</td></tr>
<tr><td><code id="buildFeature_+3A_def">def</code></td>
<td>
<p>definition of the feature. Default is &quot;Camera Line Number&quot;.</p>
</td></tr>
<tr><td><code id="buildFeature_+3A_val">val</code></td>
<td>
<p>a coercible to numeric vector of feature values. Default is NULL.<br />
Note that although not mandatory for <code><a href="#topic+buildFeature">buildFeature</a></code>it has to be provided to
allow feature export in <code><a href="#topic+ExportToDAF">ExportToDAF</a></code> and <code><a href="#topic+data_add_features">data_add_features</a></code>.</p>
</td></tr>
<tr><td><code id="buildFeature_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all feature information.
</p>

<hr>
<h2 id='buildGraph'>IFC Graph Coercion</h2><span id='topic+buildGraph'></span>

<h3>Description</h3>

<p>Helper to build a list to allow graph export.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGraph(
  type = c("histogram", "scatter", "density")[3],
  xlocation = 0,
  ylocation = 0,
  f1 = "Object Number",
  f2 = "Object Number",
  scaletype = 1,
  xmin = -1,
  xmax = 1,
  ymin = 0,
  ymax = 1,
  title = paste0(unlist(lapply(BasePop, FUN = function(x) x$name)), collapse = ", "),
  xlabel = f1,
  ylabel = f2,
  axislabelsfontsize = 10,
  axistickmarklabelsfontsize = 10,
  graphtitlefontsize = 12,
  regionlabelsfontsize = 10,
  bincount = 0,
  freq = c("T", "F")[1],
  histogramsmoothingfactor = 0,
  xlogrange = "P",
  ylogrange = "P",
  maxpoints = +Inf,
  stats = c("true", "false")[2],
  xsize = c(320, 480, 640)[1],
  ysize = xsize + ifelse(stats == "true", splitterdistance, 0),
  splitterdistance = 120,
  xstats = "Count|%Gated|Mean",
  ystats = xstats,
  order,
  xstatsorder,
  Legend,
  BasePop = list(list()),
  GraphRegion = list(list()),
  ShownPop = list(list()),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGraph_+3A_type">type</code></td>
<td>
<p>Graph's type. Either &quot;histogram&quot;, &quot;scatter&quot; or &quot;density&quot;. Default is &quot;density&quot;.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xlocation">xlocation</code></td>
<td>
<p>Integer. Graph's x location. Default is 0.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_ylocation">ylocation</code></td>
<td>
<p>Integer. Graph's x location. Default is 0.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_f1">f1</code></td>
<td>
<p>Character. Graph x axis parameter. Default is &quot;Object Number&quot;.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_f2">f2</code></td>
<td>
<p>Character. Graph y axis parameter. Default is &quot;Object Number&quot;. Only used when 'type' is not &quot;histogram&quot;.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_scaletype">scaletype</code></td>
<td>
<p>Integer. Graph scale. Either 0 (auto), 1 (manual). Default is 1.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xmin">xmin</code></td>
<td>
<p>Double. Graph's xmin. Default -1.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xmax">xmax</code></td>
<td>
<p>Double. Graph's xmax. Default 1.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_ymin">ymin</code></td>
<td>
<p>Double. Graph's xmin. Default 0.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_ymax">ymax</code></td>
<td>
<p>Double. Graph's xmax. Default 1.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_title">title</code></td>
<td>
<p>Character. Graph title label. Default will use names of BasePop collapse with ', '.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xlabel">xlabel</code></td>
<td>
<p>Character. Graph x axis label.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_ylabel">ylabel</code></td>
<td>
<p>Character. Graph y axis label.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_axislabelsfontsize">axislabelsfontsize</code></td>
<td>
<p>Integer. Axis label font size. Default is 10. Allowed are: 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28.<br />
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_axistickmarklabelsfontsize">axistickmarklabelsfontsize</code></td>
<td>
<p>Integer. Axis tick font size. Default is 10. Allowed are: 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28.<br />
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_graphtitlefontsize">graphtitlefontsize</code></td>
<td>
<p>Integer. Axis title font size. Default is 12. Allowed are: 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28.<br />
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_regionlabelsfontsize">regionlabelsfontsize</code></td>
<td>
<p>Integer. Axis region font size. Default is 10. Allowed are: 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28.<br />
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_bincount">bincount</code></td>
<td>
<p>Integer. Histogram bin count. Default is 0. Allowed are: 0, 8, 16, 32, 64, 128, 256, 512, 1024.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_freq">freq</code></td>
<td>
<p>Character. Histogram with frequency normalization of not. Default is &quot;T&quot;, allowed are &quot;T&quot; or &quot;F&quot;.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_histogramsmoothingfactor">histogramsmoothingfactor</code></td>
<td>
<p>Integer. Histogram smoothing factor. Allowed are [0-20]. Only partly implemented, default is 0 for no smoothing other values will produce same smoothing.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xlogrange">xlogrange</code></td>
<td>
<p>determines transformation instruction for x-axis. Default is &quot;P&quot; for no transformation.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_ylogrange">ylogrange</code></td>
<td>
<p>determines transformation instruction for y-axis. Default is &quot;P&quot; for no transformation.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_maxpoints">maxpoints</code></td>
<td>
<p>determines the maximum number of points to display. Default is +Inf to display all points.<br />
If provided, values from ]0,1] will be used as a proportion of the total number of points to show.<br />
While values values superior to 1 will be interpreted as the maximal number of points to show.<br />
It only applies to 2D graphs. When 'type' is &quot;histogram&quot;, +Inf will be used whatever the value provided as input.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_stats">stats</code></td>
<td>
<p>Character. Either &quot;true&quot; or &quot;false&quot; to display stats. Default is &quot;false&quot;.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xsize">xsize</code></td>
<td>
<p>Integer. Graph's x size. Default is 320 for small. Regular are: 320 (small), 480 (medium), 640 (big).
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_ysize">ysize</code></td>
<td>
<p>Integer. Graph's y size. Default is 'ysize' + 'splitterdistance' when 'stats' is set to &quot;true&quot;.
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_splitterdistance">splitterdistance</code></td>
<td>
<p>Integer. Default is 120.
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xstats">xstats</code></td>
<td>
<p>Character. x stats to be computed. Default is 'Count|%Gated|Mean'.
It has to be a filled with the concatenation of 'Count', '%Total', '%Gated', 
'%Plotted', 'Objects/mL', 'Mean', 'Median', 'Std. Dev.', 'MAD', 'CV',
'Minimum', 'Maximum', 'Geo. Mean', 'Mode', 'Variance' and /or 'NaN', collapse with '|'.
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_ystats">ystats</code></td>
<td>
<p>Character. y stats to be computed. Should be identical to 'xstats'. Default is xstats.
Checked but not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_order">order</code></td>
<td>
<p>Character. Order to display populations. 
When 'type' is &quot;density&quot; it will be BasePop[[1]]$name.
When 'type' is &quot;histogram&quot; or &quot;density&quot; 'ShownPop' are not allowed
Otherwise, it will use each of 'GraphRegion', 'BasePop' and 'ShownPop' names, collapse with '|'.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_xstatsorder">xstatsorder</code></td>
<td>
<p>Character. Order of stat rows.
It will use each of 'GraphRegion' names &amp; each of 'BasePop' names, reverted and collapse with '|'.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_legend">Legend</code></td>
<td>
<p>Default is list(list(onoff='false',x='0',y='0',witdh='96',height='128')).
Not yet implemented.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_basepop">BasePop</code></td>
<td>
<p>Default is list(list()). See details.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_graphregion">GraphRegion</code></td>
<td>
<p>Default is list(list()). Only allowed member are sub-list(s) with only one character component named 'name'.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_shownpop">ShownPop</code></td>
<td>
<p>Default is list(list()). Only allowed member are sub-list(s) with only one character component named 'name'.</p>
</td></tr>
<tr><td><code id="buildGraph_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many parameters are not used or are only partly implemented, but most are checked in order to be compatible for further export.<br />
For 'BasePop', if left as is &quot;All&quot; will be used as default.<br />
This parameter will be built / checked according to 'type' argument.<br />
'BasePop' has to be a list of list(s) and each sub-list should can contain several elements, but only &quot;name&quot; is mandatory.<br />
The sublist members are:<br />
-&quot;name&quot;, &quot;linestyle&quot;, &quot;fill&quot;,<br />
and only when 'type' is &quot;density&quot;<br />
-&quot;densitybincount&quot;, &quot;densitymin&quot;, &quot;densitymax&quot;,<br />
-&quot;densitycolors&quot;, &quot;densitycolorslightmode&quot;, &quot;densitycolorsdarkmode&quot;,<br />
-&quot;densitylevel&quot;, &quot;densitytrans&quot;.<br />
Each sub-list will be created automatically with the following default values (except if explicitly provided):<br />
-linestyle=&quot;Solid&quot;,<br />
-fill=&quot;true&quot;,<br />
-densitybincount=&quot;128&quot;,densitymin=&quot;0&quot;,densitymax=&quot;0&quot;,<br />
-densitycolors=&quot;-16776961|-13447886|-256|-23296|-65536|&quot;,<br />
-densitycolorslightmode=&quot;-16776961|-13447886|-256|-23296|-65536|&quot;,<br />
-densitycolorsdarkmode=&quot;-16776961|-13447886|-256|-23296|-65536|&quot;,<br />
-densitylevel=&quot;&quot;,<br />
*when provided it has to be in a format of &quot;fill[true,false]|lines[true,false]|nlevels[integer&gt;1]|lowest[numeric[0-1[]|&quot;
*describing how the levelplot should be drawn.<br />
*Besides, 'densitrans' will not be used.
-densitytrans=&quot;asinh&quot;<br />
*it can take a function to be applied to the 2D local densities<br />
*or a name of a feature within 'IFC_data' object to draw a gradient against this feature<br />
Note that when 'type' is &quot;density&quot;, 'BasePop' should be of length one.<br />
and fill will be overwritten to &quot;true&quot;.
</p>


<h3>Value</h3>

<p>a list containing all graph information.
</p>

<hr>
<h2 id='buildIFD'>Image Field Directory Builder</h2><span id='topic+buildIFD'></span>

<h3>Description</h3>

<p>Builds Image Field Directory (IFD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildIFD(val, typ, tag, endianness = .Platform$endian)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildIFD_+3A_val">val</code></td>
<td>
<p>the value of the IFD</p>
</td></tr>
<tr><td><code id="buildIFD_+3A_typ">typ</code></td>
<td>
<p>desired IFD type</p>
</td></tr>
<tr><td><code id="buildIFD_+3A_tag">tag</code></td>
<td>
<p>the desired IFD 'tag'</p>
</td></tr>
<tr><td><code id="buildIFD_+3A_endianness">endianness</code></td>
<td>
<p>the desired endian-ness (&quot;big&quot; or &quot;little&quot;). Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if 'val' if of type &quot;character&quot;, 'tag' is automatically set to 2.<br />
if 'val' is of length 0 NULL is returned.
</p>


<h3>Value</h3>

<p>NULL or a list of 2 members:<br />
-min_content: the minimal IFD content,<br />
-add_content: the additional IFD content if 'val' converted to raw does not fit in 4 bytes.
</p>

<hr>
<h2 id='buildImage'>IFC Image Coercion</h2><span id='topic+buildImage'></span>

<h3>Description</h3>

<p>Helper to build a list image values to allow export
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildImage(physicalChannel = 1, ..., BF = FALSE, MODE = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildImage_+3A_physicalchannel">physicalChannel</code></td>
<td>
<p>the channel. Default is 1. Allowed are [1-12].</p>
</td></tr>
<tr><td><code id="buildImage_+3A_...">...</code></td>
<td>
<p>other arguments to be passed. See members in returned value.</p>
</td></tr>
<tr><td><code id="buildImage_+3A_bf">BF</code></td>
<td>
<p>should 'physicalChannel' channel be considered as brightfield. Default is FALSE.</p>
</td></tr>
<tr><td><code id="buildImage_+3A_mode">MODE</code></td>
<td>
<p>collection mode (as retrieved by getInfo) determining the range. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list whose members are &quot;name&quot;, &quot;color&quot;, &quot;physicalChannel&quot;, &quot;xmin&quot;, &quot;xmax&quot;,
&quot;xmid&quot;, &quot;ymid&quot;, &quot;scalemin&quot;, &quot;scalemax&quot;, &quot;tokens&quot;, &quot;baseimage&quot;, &quot;function&quot;, &quot;saturation&quot;.
</p>

<hr>
<h2 id='buildMask'>IFC Mask Coercion</h2><span id='topic+buildMask'></span>

<h3>Description</h3>

<p>Helper to build a mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildMask(
  masks,
  images,
  definition = TRUE,
  to_match_mask = NULL,
  to_replace_mask = NULL,
  to_match_image = NULL,
  to_replace_image = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildMask_+3A_masks">masks</code></td>
<td>
<p>an 'IFC_masks' object or a data.frame containing masks definition and name. Default is missing.</p>
</td></tr>
<tr><td><code id="buildMask_+3A_images">images</code></td>
<td>
<p>a data.frame containing images definition. Default is missing.</p>
</td></tr>
<tr><td><code id="buildMask_+3A_definition">definition</code></td>
<td>
<p>whether to compute masks definition or masks names. Default is TRUE, to compute definition.</p>
</td></tr>
<tr><td><code id="buildMask_+3A_to_match_mask">to_match_mask</code></td>
<td>
<p>a vector of masks names to use for matching 'masks' names. Default is NULL</p>
</td></tr>
<tr><td><code id="buildMask_+3A_to_replace_mask">to_replace_mask</code></td>
<td>
<p>a vector of masks names to use for replacing 'masks' names. Default is NULL</p>
</td></tr>
<tr><td><code id="buildMask_+3A_to_match_image">to_match_image</code></td>
<td>
<p>a vector of images names to use for matching 'images' names. Default is NULL</p>
</td></tr>
<tr><td><code id="buildMask_+3A_to_replace_image">to_replace_image</code></td>
<td>
<p>a vector of images names to use for replacing 'images' names. Default is NULL</p>
</td></tr>
<tr><td><code id="buildMask_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function that can either change definition or name
it will be used in a loop to incorporate new definition.
causing name to be changed. allowing new redefinition of mask 
dependent on other mask to be changed, and so on
when a mask or an image name is not found because not yet defined 
an error is raised and catched
TODO maybe this error catching causes some overhead to be improved
</p>


<h3>Value</h3>

<p>a vector of masks definition or names depending on 'definition' parameter.
</p>

<hr>
<h2 id='buildPopulation'>IFC Population Coercion</h2><span id='topic+buildPopulation'></span>

<h3>Description</h3>

<p>Helper to build a list to allow population export.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPopulation(
  name,
  type,
  base = "All",
  color,
  lightModeColor,
  style,
  region,
  fx,
  fy,
  definition,
  obj,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildPopulation_+3A_name">name</code></td>
<td>
<p>name of the population.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_type">type</code></td>
<td>
<p>type of population. Either &quot;B&quot;, &quot;C&quot;, &quot;G&quot; or &quot;T&quot; for Base, Combined, Graphical or Tagged, respectively.<br />
If missing, the default, 'type' will be deduced from other parameters.
If 'name' is &quot;All&quot; type will be &quot;B&quot;. Otherwise, if 'fx' is given type will be &quot;G&quot;.
Otherwise, &quot;T&quot;, if 'definition' is missing but not 'obj' or &quot;C&quot; if 'definition' is not missing.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_base">base</code></td>
<td>
<p>which population is based on. It will be base=&quot;All&quot;, for 'type' &quot;T&quot; and &quot;C&quot; and base=&quot;&quot;, for 'type' &quot;B&quot;. It is only needed when type = &quot;G&quot;.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_color">color</code></td>
<td>
<p>color of the population. See <code><a href="#topic+paletteIFC">paletteIFC</a></code> for allowed colors. If not provided, it will be sampled.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_lightmodecolor">lightModeColor</code></td>
<td>
<p>lightModeColor of the population. See <code><a href="#topic+paletteIFC">paletteIFC</a></code> for allowed colors. If not provided, it will be sampled.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_style">style</code></td>
<td>
<p>style of the population. Either 20, 4, 3, 1, 5, 0, 2, 18, 15, 17, respectively for:
&quot;Simple Dot&quot;, &quot;Cross&quot;, &quot;Plus&quot;, &quot;Empty Circle&quot;, &quot;Empty Diamond&quot;, &quot;Empty Square&quot;,
&quot;Empty Triangle&quot;, &quot;Solid Diamond&quot;, &quot;Solid Square&quot;, &quot;Solid Triangle&quot;.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_region">region</code></td>
<td>
<p>Only if type=&quot;G&quot;. Name of the region defining the population.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_fx">fx</code></td>
<td>
<p>Only needed if type=&quot;G&quot;. Name of the x-feature defining the population.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_fy">fy</code></td>
<td>
<p>Only needed if type=&quot;G&quot; and only if region is defined in 2D. Name of the y-feature defining the population.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_definition">definition</code></td>
<td>
<p>Only needed if type=&quot;C&quot;. Parameters defining the population.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_obj">obj</code></td>
<td>
<p>Only needed if type=&quot;T&quot;. Either a:<br />
-Logical vector of same length as &quot;All&quot; population indicating if a cell belongs to the population or not.<br />
-Integer vector of indices of cells that belongs to the population. Note that first object is 0.</p>
</td></tr>
<tr><td><code id="buildPopulation_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all population information.
</p>

<hr>
<h2 id='buildRegion'>IFC Region Coercion</h2><span id='topic+buildRegion'></span>

<h3>Description</h3>

<p>Helper to build a list to allow region export.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildRegion(
  type,
  label,
  cx,
  cy,
  color,
  lightcolor,
  ismarker = "false",
  doesnotoverride = "false",
  xlogrange,
  ylogrange,
  x,
  y,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildRegion_+3A_type">type</code></td>
<td>
<p>Region's type. Either &quot;line&quot;, &quot;rect&quot;, &quot;poly&quot; or &quot;oval&quot;.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_label">label</code></td>
<td>
<p>label of the region.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_cx">cx</code></td>
<td>
<p>x label's position. If not provided x center will be used.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_cy">cy</code></td>
<td>
<p>y label's position. If not provided y center will be used.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_color">color</code></td>
<td>
<p>color of the region. See <code><a href="#topic+paletteIFC">paletteIFC</a></code> for allowed colors.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_lightcolor">lightcolor</code></td>
<td>
<p>lightcolor of the region. See <code><a href="#topic+paletteIFC">paletteIFC</a></code> for allowed colors.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_ismarker">ismarker</code></td>
<td>
<p>Default is 'false'. Allowed are 'true' or 'false'. Used for compatibility with amnis file but role remains unknown.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_doesnotoverride">doesnotoverride</code></td>
<td>
<p>Default is 'false'. Allowed are 'true' or 'false'. Used for compatibility with amnis file but role remains unknown.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_xlogrange">xlogrange</code></td>
<td>
<p>determines transformation instruction for x-axis. Default is &quot;P&quot; for no transformation.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_ylogrange">ylogrange</code></td>
<td>
<p>determines transformation instruction for y-axis. Default is &quot;P&quot; for no transformation.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_x">x</code></td>
<td>
<p>vector of x vertices values.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_y">y</code></td>
<td>
<p>vector of y vertices values.</p>
</td></tr>
<tr><td><code id="buildRegion_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing all region information.
</p>

<hr>
<h2 id='buildStats'>IFC Statistics Coercion</h2><span id='topic+buildStats'></span>

<h3>Description</h3>

<p>Helper to build a list to allow statistics export.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildStats(
  obj,
  stats = list(list(type = "COUNT", title = "Count", def = ""), list(type =
    "PERCENT_GATED", title = "%Gated", def = "")),
  width = 80 * (1 + length(stats)),
  height = 240,
  xlocation = 0,
  ylocation = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildStats_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object</p>
</td></tr>
<tr><td><code id="buildStats_+3A_stats">stats</code></td>
<td>
<p>list of statistics instructions, whose members are list containing 3 instructions:<br />
- 'type' stats's type. Allowed are &quot;COUNT&quot;,&quot;PERCENT_GATED&quot;,&quot;CONCENTRATION&quot;,&quot;PERCENT&quot;,&quot;MEAN&quot;,&quot;MEDIAN&quot;,&quot;STDDEV&quot;,&quot;MAD&quot;,&quot;CV&quot;,&quot;MINIMUM&quot;,&quot;MAXIMUM&quot;,&quot;GEOMETRIC_MEAN&quot;,&quot;MODE&quot;,&quot;VARIANCE&quot;,&quot;NAN&quot;,&quot;MEAN_RD&quot;,&quot;MEDIAN_RD&quot;.<br />
- 'title' stats's title. If missing, it will be determined thanks to def.<br />
- 'def' definition of the stats.<br />
Default is:<br />
list(list(type=&quot;COUNT&quot;,title=&quot;Count&quot;,def=&quot;&quot;),<br />
list(type=&quot;PERCENT_GATED&quot;,title=&quot;%Gated&quot;,def=&quot;&quot;))</p>
</td></tr>
<tr><td><code id="buildStats_+3A_width">width</code></td>
<td>
<p>desired width. Default is 80 * (1 + length(stats)).</p>
</td></tr>
<tr><td><code id="buildStats_+3A_height">height</code></td>
<td>
<p>desired height Default is 400.</p>
</td></tr>
<tr><td><code id="buildStats_+3A_xlocation">xlocation</code></td>
<td>
<p>x location in analysis workspace. Default is 0.</p>
</td></tr>
<tr><td><code id="buildStats_+3A_ylocation">ylocation</code></td>
<td>
<p>y location in analysis workspace. Default is 0.</p>
</td></tr>
<tr><td><code id="buildStats_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when stats$type is:<br />
- &quot;COUNT&quot;,&quot;PERCENT_GATED&quot;,&quot;CONCENTRATION&quot;, stats$def will be &quot;&quot;,<br />
- &quot;PERCENT&quot;, stats$def has to be a population name,<br />
- &quot;MEAN_RD&quot;,&quot;MEDIAN_RD&quot; stats$def has to be the concatenation of a feature name and a population name collapse with &quot;|&quot;. e.g. &quot;Area_MC|All&quot;,<br />
- otherwise, stats$def has to be a feature name.
</p>


<h3>Value</h3>

<p>an object of class 'IFC_stats'.
</p>

<hr>
<h2 id='calcDensity'>2D Binned Kernel Density Estimation</h2><span id='topic+calcDensity'></span>

<h3>Description</h3>

<p>Helper to compute density plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcDensity(x, nbin, bandwidth, range.x)
</code></pre>

<hr>
<h2 id='checkColor'>Character Color Check and RGB Conversion</h2><span id='topic+checkColor'></span>

<h3>Description</h3>

<p>Checks that color is R compatible by converting it to RGB matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkColor(color)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkColor_+3A_color">color</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>

<hr>
<h2 id='checkObj'>'IFC_data' Object Check</h2><span id='topic+checkObj'></span>

<h3>Description</h3>

<p>Ensures 'IFC_data' obj$features correctly reflects actual number of collected objects.
When 'obj' is from rif or cif, number of objects can be different from actual number of collected objects
e.g. when it comes from merged of subset of file. There is no way to link an object with its feature value,
so the only solution is to remove all features and only keep &quot;Object Number&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkObj(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkObj_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'IFC_data' object.
</p>

<hr>
<h2 id='checksumDAF'>DAF File Checksum</h2><span id='topic+checksumDAF'></span>

<h3>Description</h3>

<p>This function returns CIF checksum computed from images values found in DAF
Checksum is the sum of img IFDs (Image Field Directory) offsets of objects 0, 1, 2, 3 and 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checksumDAF(fileName, endianness = .Platform$endian, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checksumDAF_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="checksumDAF_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="checksumDAF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='checksumIFC'>IFC Files Checksum</h2><span id='topic+checksumIFC'></span>

<h3>Description</h3>

<p>This function returns RIF/CIF checksum.
Checksum is the sum of img IFDs (Image Field Directory) offsets of objects 0, 1, 2, 3 and 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checksumIFC(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checksumIFC_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="checksumIFC_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="#topic+checksumDAF">checksumDAF</a></code> or <code><a href="#topic+checksumXIF">checksumXIF</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if fileName is a DAF file, then CIF checksum is computed from images values found in DAF.
</p>


<h3>Value</h3>

<p>an integer corresponding to IFC file checksum.
</p>

<hr>
<h2 id='checksumXIF'>RIF/CIF File Checksum</h2><span id='topic+checksumXIF'></span>

<h3>Description</h3>

<p>This function returns RIF/CIF checksum.
Checksum is the sum of img IFDs (Image Field Directory) offsets of objects 0, 1, 2, 3 and 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checksumXIF(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checksumXIF_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="checksumXIF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='colConv'>Integer to Hexadecimal Color Conversion</h2><span id='topic+colConv'></span>

<h3>Description</h3>

<p>Helper to convert color to hex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colConv(col)
</code></pre>

<hr>
<h2 id='collapse_raw'>Raw Vectors Collapse</h2><span id='topic+collapse_raw'></span>

<h3>Description</h3>

<p>Collapses raw vectors together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_raw(x, collapse = as.raw(124))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_raw_+3A_x">x</code></td>
<td>
<p>a list of raw vectors.</p>
</td></tr>
<tr><td><code id="collapse_raw_+3A_collapse">collapse</code></td>
<td>
<p>a raw vector used to collapse. Default is as.raw(0x7c)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a collapsed raw vector
</p>

<hr>
<h2 id='computeGamma'>Image Gamma Computation</h2><span id='topic+computeGamma'></span>

<h3>Description</h3>

<p>Computes image gamma transformation value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeGamma(V)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeGamma_+3A_v">V</code></td>
<td>
<p>channel display properties containing 'xmin', 'xmax', 'xmid' and 'ymid'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Thanks to 
http://www.libpng.org/pub/png/book/chapter10.html
image_sample = light_out ^ gamma
it is said that
Once again, bear in mind that light_out and image_sample are scaled to the interval between 0 and 1;
that is, if the sample depth is 8 bits, the file samples range between 0 and 255, so image_sample is
obtained by dividing a given file sample by 255, in floating-point arithmetic. 
So,
image_sample = ymid and its range is [0,255]
light_out = xmid and its range is [xmin,xmax]
we have ymid / 255 = ((xmid - xmin) / (xmax - xmin)) ^ gamma
log(ymid / 255) = log((xmid - xmin) / (xmax - xmin)) * gamma
gamma = log(ymid / 255) / log((xmid - xmin) / (xmax - xmin))
</p>

<hr>
<h2 id='convert_spillover'>Spillover Converter</h2><span id='topic+convert_spillover'></span>

<h3>Description</h3>

<p>Converts spillover matrix to spillover keyword and reversely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_spillover(spillover)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_spillover_+3A_spillover">spillover</code></td>
<td>
<p>either a spillover matrix or a spillover keyword</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'spillover' is a matrix, it returns a string. If 'spillover' is a string, it returns a matrix. In all cases if spillover is of length 0, it will return NULL.
</p>

<hr>
<h2 id='coord_to_px'>User's Coordinates to Pixels Conversion</h2><span id='topic+coord_to_px'></span>

<h3>Description</h3>

<p>Helper map user's coordinates to pixels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord_to_px(coord, coordmap, pntsonedge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_to_px_+3A_coord">coord</code></td>
<td>
<p>coordinates in user system. A matrix where rows are points and with at least 2 columns named &quot;x&quot; and &quot;y&quot; for x and y coordinates, respectively.</p>
</td></tr>
<tr><td><code id="coord_to_px_+3A_coordmap">coordmap</code></td>
<td>
<p>current device adjusted coordinates. Default is missing.</p>
</td></tr>
<tr><td><code id="coord_to_px_+3A_pntsonedge">pntsonedge</code></td>
<td>
<p>whether points outside of plotting region should be bounded on the edge. Default is FALSE to clip points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2-columns matrix with &quot;x&quot; and &quot;y&quot; coordinates.
</p>

<hr>
<h2 id='cpp_align'>Spatial Offsets Image Correction</h2><span id='topic+cpp_align'></span>

<h3>Description</h3>

<p>This function uses bilinear interpolation to apply spatial offset correction on image
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_align_+3A_mat">mat</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_align_+3A_dx">dx</code></td>
<td>
<p>a double x spatial offset. It has to be within ]-1,+1[. Default is NA_REAL for no change.</p>
</td></tr>
<tr><td><code id="cpp_align_+3A_dy">dy</code></td>
<td>
<p>a double y spatial offset. It has to be within ]-1,+1[. Default is NA_REAL for no change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is intended to be applied on raw images matrices from .rif files so has to generate spatial offset corrected image matrices.<br />
See William E. Ortyn et al. Sensitivity Measurement and Compensation in Spectral Imaging. Cytometry A 69 852-862 (2006).
doi: <a href="https://doi.org/10.1002/cyto.a.20306">10.1002/cyto.a.20306</a>
</p>


<h3>Value</h3>

<p>a NumericMatrix.
</p>

<hr>
<h2 id='cpp_as_nativeRaster'>Image to Native Raster Conversion</h2><span id='topic+cpp_as_nativeRaster'></span>

<h3>Description</h3>

<p>Converts 3D image array to nativeRaster
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_as_nativeRaster_+3A_x">x</code></td>
<td>
<p>an IntegerVecter /!\ It should be coercible to 3D array [height, width, rgba]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a nativeRaster IntegerMatrix
</p>

<hr>
<h2 id='cpp_assert'>Input Parameters Assertive Tool</h2><span id='topic+cpp_assert'></span>

<h3>Description</h3>

<p>Ensures that x respects several parameters
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_assert_+3A_len">len</code></td>
<td>
<p>IntegerVector, of allowed length for x. Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="cpp_assert_+3A_cla">cla</code></td>
<td>
<p>CharacterVector, of allowed classes of x. Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="cpp_assert_+3A_typ">typ</code></td>
<td>
<p>CharacterVector, of allowed types of x. Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="cpp_assert_+3A_robject">Robject</code></td>
<td>
<p>of allowed values for x (will be passed to cpp_allowed). Default is NULL, for not checking this parameter.</p>
</td></tr>
<tr><td><code id="cpp_assert_+3A_fun">fun</code></td>
<td>
<p>CharacterVector, function to execute when mandatory parameters are not met. Default is &quot;stop&quot;. Allowed are &quot;stop&quot;,&quot;warning&quot;,&quot;message&quot;,&quot;return&quot;.
fun is placed in cpp_assert() in order to check it is correct before being used in assert() function.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_base64_encode'>Raw to Base64 Conversion</h2><span id='topic+cpp_base64_encode'></span>

<h3>Description</h3>

<p>Converts a raw vector to base64 string.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_base64_encode_+3A_x">x</code></td>
<td>
<p>RawVector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string, representing the base64 encoding of x.
</p>

<hr>
<h2 id='cpp_checksum'>Checksum for RIF/CIF</h2><span id='topic+cpp_checksum'></span>

<h3>Description</h3>

<p>Computes sum of img IFDs (Image Field Directory) offsets of objects 0, 1, 2, 3 and 4.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_checksum_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>

<hr>
<h2 id='cpp_checkTIFF'>TIFF Checker</h2><span id='topic+cpp_checkTIFF'></span>

<h3>Description</h3>

<p>Checks if file is a TIFF.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_checkTIFF_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If file is a TIFF it returns endianness of file, 'big' or 'little.
Otherwise, it shows an error and returns an empty string.
</p>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>

<hr>
<h2 id='cpp_cleanse'>Matrix Cleanser</h2><span id='topic+cpp_cleanse'></span>

<h3>Description</h3>

<p>Replaces values in matrix mat according to mask msk.
Depending of <code>'add_noise'</code> parameter, values of <code>'mat'</code> will be replaced with noise or not.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_cleanse_+3A_mat">mat</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_cleanse_+3A_msk">msk</code></td>
<td>
<p>a IntegerMatrix.</p>
</td></tr>
<tr><td><code id="cpp_cleanse_+3A_add_noise">add_noise</code></td>
<td>
<p>bool, whether to add normal noise or not, <code>Rcpp::Rf_rnorm(bg, sd)</code> function is used. Default is <code>true</code>.</p>
</td></tr>
<tr><td><code id="cpp_cleanse_+3A_bg">bg</code></td>
<td>
<p>double, mean value of the background added if <code>'add_noise'</code> is <code>true</code>. Default is <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="cpp_cleanse_+3A_sd">sd</code></td>
<td>
<p>double, standard deviation of the background added if <code>'add_noise'</code> is <code>true</code>. Default is <code>0.0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a NumericMatrix cleansed according to <code>'msk'</code>.
</p>

<hr>
<h2 id='cpp_computeGamma'>Gamma Computation</h2><span id='topic+cpp_computeGamma'></span>

<h3>Description</h3>

<p>This function computes image gamma transformation value.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_computeGamma_+3A_v">V</code></td>
<td>
<p>named NumericVector of channel display properties containing 'xmin', 'xmax', 'xmid' and 'ymid'.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_coord_to_px'>Coordinates to Pixels</h2><span id='topic+cpp_coord_to_px'></span>

<h3>Description</h3>

<p>low-level function to compute pixels coordinates
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_coord_to_px_+3A_x">x</code></td>
<td>
<p>NumericVector of x-coordinates of the points.</p>
</td></tr>
<tr><td><code id="cpp_coord_to_px_+3A_y">y</code></td>
<td>
<p>NumericVector of y-coordinates of the points.</p>
</td></tr>
<tr><td><code id="cpp_coord_to_px_+3A_param">param</code></td>
<td>
<p>NumericVector of parameters to scale raw points coordinates to pixels coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 2 columns NumericMatrix of x and y pixels coordinates.
</p>

<hr>
<h2 id='cpp_crop'>Matrix Cropping</h2><span id='topic+cpp_crop'></span>

<h3>Description</h3>

<p>Crops mat according to new_height and new_width parameters.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_crop_+3A_mat">mat</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="cpp_crop_+3A_new_height">new_height</code></td>
<td>
<p>an unsigned integer, giving the new height of returned mat. Default is 0 for no change.</p>
</td></tr>
<tr><td><code id="cpp_crop_+3A_new_width">new_width</code></td>
<td>
<p>an unsigned integer, giving the new width of returned mat. Default is 0 for no change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cropped matrix.
</p>

<hr>
<h2 id='cpp_decomp'>IFC_object Decompression</h2><span id='topic+cpp_decomp'></span>

<h3>Description</h3>

<p>Operates decompression of compressed image stored in TIFF file.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_decomp_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_offset">offset</code></td>
<td>
<p>std::size_t, position of the beginning of compressed image.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_nbytes">nbytes</code></td>
<td>
<p>uint32_t, number of bytes of compressed image.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_imgwidth">imgWidth</code></td>
<td>
<p>R_len_t, Width of the decompressed image. Default is 1.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_imgheight">imgHeight</code></td>
<td>
<p>R_len_t, Height of the decompressed image. Default is 1.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_nb_channels">nb_channels</code></td>
<td>
<p>R_len_t, number of channels of the decompressed image. Default is 1.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_removal">removal</code></td>
<td>
<p>uint8_t, object removal method. Only apply for 30818 compression. Default is 0.<br />
-1, for clipped removal: height OR width clipped pixels will be set to -1.<br />
-2, height clipped removal: height clipped pixels will be set to -1.<br />
-3, width clipped removal: width clipped pixels will be set to -1.<br />
-4, only keep background: background pixels will be set to 1 and all others to 0.<br />
-5, only keep foreground: foreground pixels will be set to 1 and all others to 0.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_compression">compression</code></td>
<td>
<p>uint32_t, compression algorithm used. Default is 30818.</p>
</td></tr>
<tr><td><code id="cpp_decomp_+3A_verbose">verbose</code></td>
<td>
<p>bool, whether to display information (use for debugging purpose). Default is false.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>For image decompression, Lee Kamentsky's code porting from <a href="https://github.com/ome/bioformats/blob/4146b9a1797501f0fec7d6cfe69124959bff96ee/components/formats-bsd/src/loci/formats/in/FlowSightReader.java">https://github.com/ome/bioformats/blob/4146b9a1797501f0fec7d6cfe69124959bff96ee/components/formats-bsd/src/loci/formats/in/FlowSightReader.java</a><br />
cited in <a href="https://linkinghub.elsevier.com/retrieve/pii/S1046-2023(16)30291-2">https://linkinghub.elsevier.com/retrieve/pii/S1046-2023(16)30291-2</a><br />
<code style="white-space: pre;">&#8288;
BSD implementations of Bio-Formats readers and writers

Copyright (C) 2005 - 2017 Open Microscopy Environment:
  - Board of Regents of the University of Wisconsin-Madison
  - Glencoe Software, Inc.
  - University of Dundee

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
&#8288;</code>
</p>

<hr>
<h2 id='cpp_draw'>Draw Shape to Image</h2><span id='topic+cpp_draw'></span>

<h3>Description</h3>

<p>low-level function to add shape on image
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_draw_+3A_img">img</code></td>
<td>
<p>an IntegerVector. A non null array of dimensions [nrow, ncol, 4].</p>
</td></tr>
<tr><td><code id="cpp_draw_+3A_coords">coords</code></td>
<td>
<p>an IntegerMatrix whose rows are points to draw and with:<br />
- 1st column being img col coordinate in px,<br />
- 2nd column being img row coordinate in px.</p>
</td></tr>
<tr><td><code id="cpp_draw_+3A_mask">mask</code></td>
<td>
<p>a LogicalMatrix where every true value will be added to the image.</p>
</td></tr>
<tr><td><code id="cpp_draw_+3A_color">color</code></td>
<td>
<p>a 4 rows IntegerMatrix specifying rgba, from 0 to 255.</p>
</td></tr>
<tr><td><code id="cpp_draw_+3A_blur_size">blur_size</code></td>
<td>
<p>a R_len_t the size of the gaussian blurring kernel. Default is 9.</p>
</td></tr>
<tr><td><code id="cpp_draw_+3A_blur_sd">blur_sd</code></td>
<td>
<p>a double the sd of the gaussian blurring kernel. Default is 3.0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>shape according to 'mask' will be drawn on 'img' centered at coordinates coords[, 1], coords[, 0]
and every pixels being part of the shape will be filled with 'color'.
If only one 'color' is provided, this 'color' will be used for each points.
If more than one 'color' is provided, then if number of colors (ncol) equals the number of points 'color' will be used as is for each single point.
Otherwise, 'color' will be considered as a color-gradient and density will be computed.
/!\ please note that IFC:::densCols() is faster to compute color based on density for n &lt; 20000 points, so it's worth using it when number of points are lower.
</p>


<h3>Value</h3>

<p>/!\ nothing is returned but img is modified in-place
</p>

<hr>
<h2 id='cpp_ell_coord'>Ellipse Boundaries to Coordinates</h2><span id='topic+cpp_ell_coord'></span>

<h3>Description</h3>

<p>Transforms ellipse boundaries to usefull coordinates.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_ell_coord_+3A_bound_x">bound_x</code></td>
<td>
<p>NumericVector, x-boundaries of the ellipse.</p>
</td></tr>
<tr><td><code id="cpp_ell_coord_+3A_bound_y">bound_y</code></td>
<td>
<p>NumericVector, y-boundaries of the ellipse.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_extract'>IFC_object Extraction</h2><span id='topic+cpp_extract'></span>

<h3>Description</h3>

<p>Extracts object from ifd
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_extract_+3A_fname">fname</code></td>
<td>
<p>string, path to file</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_ifd">ifd</code></td>
<td>
<p>List, ifd information of class IFC_ifd</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_colors">colors</code></td>
<td>
<p>List of colors to use.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_channels">channels</code></td>
<td>
<p>DataFrame, channels information.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_physicalchannel">physicalChannel</code></td>
<td>
<p>CharacterVector of indices for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_xmin">xmin</code></td>
<td>
<p>NumericVector of minimal values for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_xmax">xmax</code></td>
<td>
<p>NumericVector of maximal values for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_spatialx">spatialX</code></td>
<td>
<p>NumericVector of X spatial offset correction for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_spatialy">spatialY</code></td>
<td>
<p>NumericVector of Y spatial offset correction for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_removal">removal</code></td>
<td>
<p>IntegerVector of removal method to be used for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_add_noise">add_noise</code></td>
<td>
<p>LogicalVector of whether to <code>'add_noise'</code> for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_full_range">full_range</code></td>
<td>
<p>LogicalVector of whether to use <code>'full_range'</code> for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_force_range">force_range</code></td>
<td>
<p>LogicalVector of whether to use <code>'force_range'</code> for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_gamma">gamma</code></td>
<td>
<p>NumericVector of the <code>'gamma'</code> for each channel.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_chan_to_extract">chan_to_extract</code></td>
<td>
<p>IntegerVector, channels to extract.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_extract_msk">extract_msk</code></td>
<td>
<p>uint8_t, type of mask to extract:<br />
-<code>0</code>: no mask,<br />
-<code>1</code>: at least one <code>"raw"</code>,<br />
-<code>2</code>: at least one <code>"clipped"</code>,<br />
-<code>3</code>: at least one <code>"masked"</code>,<br />
-<code>4</code>: at least one <code>"MC"</code> mask.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_mode">mode</code></td>
<td>
<p>string, color mode export. Either <code>"rgb"</code>, <code>"gray"</code> or <code>"raw"</code>. Default is <code>"raw"</code>.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_size">size</code></td>
<td>
<p>a length 2 IntegerVector of final dimensions (height,width) of the image. Default is <code>0,0</code> for no change.</p>
</td></tr>
<tr><td><code id="cpp_extract_+3A_verbose">verbose</code></td>
<td>
<p>bool, whether to display information (use for debugging purpose). Default is <code>false</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>'add_noise'</code> is <code>false</code>, background will be automatically set to minimal pixel value for <code>"masked"</code> and <code>"MC"</code> <code>'removal'</code> method.
</p>

<hr>
<h2 id='cpp_fast_factor'>Fast Factorize Vector</h2><span id='topic+cpp_fast_factor'></span>

<h3>Description</h3>

<p>Makes factor with Rcpp
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_fast_factor_+3A_x">x</code></td>
<td>
<p>a SEXP only NILSXP, LGLSXP, INTSXP, REALSXP, STRSXP, RAWSXP are handled.</p>
</td></tr>
<tr><td><code id="cpp_fast_factor_+3A_handlena">handleNA</code></td>
<td>
<p>a bool specifying if NA should be returned as NA or if they should be attributed a unique integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>returned object should not be of class &lsquo;factor' so has to prevent malformed factor&rsquo; error when printing the result in R.
For this reason, it is aimed to be wrap in an R function to handle factor class / handleNA balance.<br />
e.g. either:
- structure(cpp_fast_factor(df, TRUE), class = &quot;factor&quot;), or,
- structure(cpp_fast_factor(unclass(df), FALSE), levels = NULL)
</p>


<h3>Value</h3>

<p>an IntegerVector, with attributes &quot;levels&quot; being the non-NA unique value(s) found
and &quot;lvs&quot; the total number of unique values found (including NA).
</p>


<h3>Source</h3>

<p>adaptation from Kevin Ushey code <a href="https://gallery.rcpp.org/articles/fast-factor-generation/">https://gallery.rcpp.org/articles/fast-factor-generation/</a>
</p>

<hr>
<h2 id='cpp_fast_listAny'>Use Rcpp to Apply Any on List members</h2><span id='topic+cpp_fast_listAny'></span>

<h3>Description</h3>

<p>Computes any across list members
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_fast_listAny_+3A_l_">L_</code></td>
<td>
<p>a Nullable List.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a LogicalVector.
</p>

<hr>
<h2 id='cpp_fast_range'>Use Rcpp for Range</h2><span id='topic+cpp_fast_range'></span>

<h3>Description</h3>

<p>Determines range of numeric vector
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_fast_range_+3A_x_">x_</code></td>
<td>
<p>a Nullable NumericVector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the behaviour is the same as R base::range(x_, na.rm = TRUE, finite = TRUE) without creating warnings
</p>


<h3>Value</h3>

<p>a NumericVector.
</p>

<hr>
<h2 id='cpp_fast_rowAny'>Use Rcpp to Apply Any on Matrix Rows</h2><span id='topic+cpp_fast_rowAny'></span>

<h3>Description</h3>

<p>Computes any across matrix rows.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_fast_rowAny_+3A_m_">M_</code></td>
<td>
<p>a Nullable LogicalVector. /!\ But cast to LogicalMatrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a LogicalVector.
</p>

<hr>
<h2 id='cpp_fast_sample'>Use Rcpp for Sampling</h2><span id='topic+cpp_fast_sample'></span>

<h3>Description</h3>

<p>Create a sample of integers
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_fast_sample_+3A_n">n</code></td>
<td>
<p>a R_len_t, max number integers to choose from.</p>
</td></tr>
<tr><td><code id="cpp_fast_sample_+3A_size">size</code></td>
<td>
<p>a R_len_t the desired size of return integers.</p>
</td></tr>
<tr><td><code id="cpp_fast_sample_+3A_replace">replace</code></td>
<td>
<p>a bool determining if sampling should be done with replacement. Default is false.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_fastTAGS'>IFD Fast Tags Extraction</h2><span id='topic+cpp_fastTAGS'></span>

<h3>Description</h3>

<p>Returns TAGS contained within an IFD (Image Field Directory) entry.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_fastTAGS_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
<tr><td><code id="cpp_fastTAGS_+3A_offset">offset</code></td>
<td>
<p>std::size_t, position of the IFD beginning.</p>
</td></tr>
<tr><td><code id="cpp_fastTAGS_+3A_swap">swap</code></td>
<td>
<p>bool, whether to swap bytes or not. Default is 'false'.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>

<hr>
<h2 id='cpp_get_bytes_order'>Get Bytes Order</h2><span id='topic+cpp_get_bytes_order'></span>

<h3>Description</h3>

<p>This function expands bytes order to the whole data
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_get_bytes_order_+3A_obj">obj</code></td>
<td>
<p>number of objects in the data.</p>
</td></tr>
<tr><td><code id="cpp_get_bytes_order_+3A_byt_">byt_</code></td>
<td>
<p>IntegerVector of number of bytes to take from 'ord_'.</p>
</td></tr>
<tr><td><code id="cpp_get_bytes_order_+3A_ord_">ord_</code></td>
<td>
<p>IntegerVector bytes order.</p>
</td></tr>
<tr><td><code id="cpp_get_bytes_order_+3A_rev">rev</code></td>
<td>
<p>bool whether to reverse order or not. Default is false.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_getBits'>Get Current Compilation Bits Depth</h2><span id='topic+cpp_getBits'></span>

<h3>Description</h3>

<p>Retrieve size of std::size_t.
</p>


<h3>Value</h3>

<p>an unsigned integer
</p>

<hr>
<h2 id='cpp_getoffsets_noid'>IFC_offsets Computation without Id Determination</h2><span id='topic+cpp_getoffsets_noid'></span>

<h3>Description</h3>

<p>Returns offsets of the IFDs (Image Field Directory) within a TIFF file.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_getoffsets_noid_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_noid_+3A_obj_count">obj_count</code></td>
<td>
<p>R_len_t, numbers of objects present in the file. Default is 0.
If obj_count &lt;= 0 then progress_bar is forced to false.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_noid_+3A_display_progress">display_progress</code></td>
<td>
<p>bool, whether to display a progress bar. Default is false.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_noid_+3A_pb">pb</code></td>
<td>
<p>a List of class 'IFC_progress' containing a progress bar of class 'txtProgressBar', 'winProgressBar' or 'Progress'. Default is R_Nilvalue.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_noid_+3A_verbose">verbose</code></td>
<td>
<p>bool, whether to display information (use for debugging purpose). Default is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an numeric vector with offsets of IFDs found.
</p>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>

<hr>
<h2 id='cpp_getoffsets_wid'>IFC_offsets Computation with Object Identification</h2><span id='topic+cpp_getoffsets_wid'></span>

<h3>Description</h3>

<p>Returns offsets of the IFD (Image Field Directory) within a TIFF file.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_getoffsets_wid_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_wid_+3A_obj_count">obj_count</code></td>
<td>
<p>R_len_t, numbers of objects present in the file. Default is 0.
If obj_count &lt;= 0 then progress_bar is forced to false.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_wid_+3A_display_progress">display_progress</code></td>
<td>
<p>bool, whether to display a progress bar. Default is false.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_wid_+3A_pb">pb</code></td>
<td>
<p>a List of class 'IFC_progress' containing a progress bar of class 'txtProgressBar', 'winProgressBar' or 'Progress'. Default is R_Nilvalue.</p>
</td></tr>
<tr><td><code id="cpp_getoffsets_wid_+3A_verbose">verbose</code></td>
<td>
<p>bool, whether to display information (use for debugging purpose). Default is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of numeric vectors with OBJECT_ID, TYPE and OFFSET of IFDs found.
</p>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>

<hr>
<h2 id='cpp_getTAGS'>IFD Tags Extraction</h2><span id='topic+cpp_getTAGS'></span>

<h3>Description</h3>

<p>Returns TAGS contained within an IFD (Image Field Directory) entry.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_getTAGS_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
<tr><td><code id="cpp_getTAGS_+3A_offset">offset</code></td>
<td>
<p>std::size_t, position of the IFD beginning.</p>
</td></tr>
<tr><td><code id="cpp_getTAGS_+3A_verbose">verbose</code></td>
<td>
<p>bool, whether to display information (use for debugging purpose). Default is 'false'.</p>
</td></tr>
<tr><td><code id="cpp_getTAGS_+3A_trunc_bytes">trunc_bytes</code></td>
<td>
<p>uint32_t maximal number of individual scalar to extract BYTE/ASCII/SBYTE/UNDEFINED for TAGS (1, 2, 6 or 7). Default is 12.<br />
However, if less is found, less is returned in map.
Note that, if 0 is provided, it will be automatically set to 1.</p>
</td></tr>
<tr><td><code id="cpp_getTAGS_+3A_force_trunc">force_trunc</code></td>
<td>
<p>whether to force truncation for all TAGS types. Default is FALSE.<br />
If 'true', 'trunc_bytes' will be used for TAGS (3, 4, 5, 8, 9, 10, 11 and 12) to extract desired number of individual scalar corresponding to each types.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>

<hr>
<h2 id='cpp_group_df'>Data Frame Merge Groups with Rcpp</h2><span id='topic+cpp_group_df'></span>

<h3>Description</h3>

<p>Computes global grouping factor from data.frame columns
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_group_df_+3A_df">df</code></td>
<td>
<p>a DataFrame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an IntegerVector with the resulting global grouping factor and a &quot;table&quot; attribute representing the amount of scalar in each resulting level.
</p>

<hr>
<h2 id='cpp_int32_to_uint32'>Int32 to Uint32 32bits Conversion</h2><span id='topic+cpp_int32_to_uint32'></span>

<h3>Description</h3>

<p>Converts 32bits integer from signed to unsigned
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_int32_to_uint32_+3A_x">x</code></td>
<td>
<p>int32_t.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_int64_to_uint64'>Int64 to Uint64 64bits Conversion</h2><span id='topic+cpp_int64_to_uint64'></span>

<h3>Description</h3>

<p>Converts 64bits integer from signed to unsigned
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_int64_to_uint64_+3A_x">x</code></td>
<td>
<p>int64_t.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_inv_smoothLinLog'>Inverse Smooth LinLog Transformation with Rcpp</h2><span id='topic+cpp_inv_smoothLinLog'></span>

<h3>Description</h3>

<p>Takes a numeric vector and return its transformation:
- to linear, if abs(x) &lt; log(base) / lin_comp.
- to exp, if abs(x) &gt; log(base) / lin_comp.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_inv_smoothLinLog_+3A_x">x</code></td>
<td>
<p>NumericVector.</p>
</td></tr>
<tr><td><code id="cpp_inv_smoothLinLog_+3A_hyper">hyper</code></td>
<td>
<p>double, value where transition between Lin/Log is applied.</p>
</td></tr>
<tr><td><code id="cpp_inv_smoothLinLog_+3A_base">base</code></td>
<td>
<p>double, base of Log scale.</p>
</td></tr>
<tr><td><code id="cpp_inv_smoothLinLog_+3A_lin_comp">lin_comp</code></td>
<td>
<p>double, value that is used to smooth transition between Lin/Log.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_M_HSV2RGB'>Matrix HSV to RGB Conversion</h2><span id='topic+cpp_M_HSV2RGB'></span>

<h3>Description</h3>

<p>Converts grayscale [0,1] mat to 3D rgb array according to hsv space.
hue and saturation determines tint whereas v is given by each element of mat
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_M_HSV2RGB_+3A_mat">mat</code></td>
<td>
<p>NumericMatrix, [0,1].</p>
</td></tr>
<tr><td><code id="cpp_M_HSV2RGB_+3A_h">h</code></td>
<td>
<p>double, [0,1], hue. Default is 0.0</p>
</td></tr>
<tr><td><code id="cpp_M_HSV2RGB_+3A_s">s</code></td>
<td>
<p>double, [0,1], saturation. Default is 0.0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a NumericVector with 3 dimensions attribute i.e. a 3D array
- 1st Dim is matrix rows count,
- 2nd Dim is matrix cols count,
- 3rd Dim is RGB
</p>

<hr>
<h2 id='cpp_mark'>Matrix to Matrix Writer According to Mask with Offsets</h2><span id='topic+cpp_mark'></span>

<h3>Description</h3>

<p>Writes matrix <code>'B'</code> in matrix <code>'A'</code> according to <code>'mask'</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_mark_+3A_a">A</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_mark_+3A_b">B</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_mark_+3A_mask">mask</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_mark_+3A_xoff">xoff</code></td>
<td>
<p>x offset in <code>'A'</code> to start writing <code>'B'</code>.</p>
</td></tr>
<tr><td><code id="cpp_mark_+3A_yoff">yoff</code></td>
<td>
<p>x offset in <code>'A'</code> to start writing <code>'B'</code>.</p>
</td></tr>
<tr><td><code id="cpp_mark_+3A_invert">invert</code></td>
<td>
<p>a logical. Default is <code>false</code>.
When <code>false</code>, the default, values of <code>'B'</code> are written into <code>'A'</code> when <code>'mask'</code> is not <code>0.0</code>.
When <code>true</code>, values of '<code>1-B</code>' are written into <code>'A'</code> when <code>'mask'</code> is not <code>0.0</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_mask'>Equal Sized Matrix to Matrix Writer According to Mask</h2><span id='topic+cpp_mask'></span>

<h3>Description</h3>

<p>Writes matrix <code>'B'</code> in matrix <code>'A'</code> according to <code>'mask'</code>.
If <code>'mask'</code> is not <code>0.0</code> <code>'B'</code> is written, <code>'A'</code> otherwise.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_mask_+3A_a">A</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_mask_+3A_b">B</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_mask_+3A_mask">mask</code></td>
<td>
<p>a NumericMatrix.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_mpfmatch'>Multiple Pattern Fixed Matching</h2><span id='topic+cpp_mpfmatch'></span>

<h3>Description</h3>

<p>String matching with multiple pattern.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_mpfmatch_+3A_x">x</code>, <code id="cpp_mpfmatch_+3A_pattern">pattern</code></td>
<td>
<p>Nullable Rcpp CharacterVector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>equivalent of as.logical(sum(unlist(lapply(pattern, grepl, x = x, fixed = TRUE)))).
</p>


<h3>Value</h3>

<p>a bool
</p>

<hr>
<h2 id='cpp_normalize'>Matrix Normalization</h2><span id='topic+cpp_normalize'></span>

<h3>Description</h3>

<p>Normalizes a finite matrix to [0,1]
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_normalize_+3A_mat">mat</code></td>
<td>
<p>a finite NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_normalize_+3A_input_range">input_range</code></td>
<td>
<p>a finite NumericVector, sets the range of the input intensity values. Values outside this range are clipped. Default is <code>[0.0,4095.0]</code>.</p>
</td></tr>
<tr><td><code id="cpp_normalize_+3A_full_range">full_range</code></td>
<td>
<p>if <code>'full_range'</code> is <code>true</code>, then <code>'input_range'</code> will be set to <code>[0.0,4095.0]</code> and <code>'gamma'</code> forced to <code>1.0</code>. Default is <code>false</code>.</p>
</td></tr>
<tr><td><code id="cpp_normalize_+3A_force_range">force_range</code></td>
<td>
<p>if <code>'force_range'</code> is <code>true</code>, then <code>'input_range'</code> will be adjusted to <code>'mat'</code> range in <code>[-4095.0, +inf]</code> and <code>'gamma'</code> forced to <code>1.0</code>. Default is <code>false</code>.<br />
Note that this parameter takes the precedence over <code>'input_range'</code> and <code>'full_range'</code>.</p>
</td></tr>
<tr><td><code id="cpp_normalize_+3A_gamma">gamma</code></td>
<td>
<p>correction. Default is <code>1.0</code>, for no correction.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_offset_to_raw'>Offset to Raw Conversion</h2><span id='topic+cpp_offset_to_raw'></span>

<h3>Description</h3>

<p>Converts offset to raw
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_offset_to_raw_+3A_x">x</code></td>
<td>
<p>double.</p>
</td></tr>
<tr><td><code id="cpp_offset_to_raw_+3A_swap">swap</code></td>
<td>
<p>bool, whether to swap or not.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_pnt_in_gate'>Point in Gate</h2><span id='topic+cpp_pnt_in_gate'></span>

<h3>Description</h3>

<p>This function checks if points lie in a polygon or ellipse.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_pnt_in_gate_+3A_pnts">pnts</code></td>
<td>
<p>NumericMatrix, a 2-columns matrix with (x and y) coordinates of the points of interest.</p>
</td></tr>
<tr><td><code id="cpp_pnt_in_gate_+3A_gate">gate</code></td>
<td>
<p>NumericMatrix, a 2-columns matrix defining polygon vertices or ellipse boundaries.</p>
</td></tr>
<tr><td><code id="cpp_pnt_in_gate_+3A_algorithm">algorithm</code></td>
<td>
<p>int, used for computation. Default is 1.<br />
1: Trigonometry.<br />
2: Special case = axes-aligned rectangle.<br />
3: Special case = axes-aligned ellipse.</p>
</td></tr>
<tr><td><code id="cpp_pnt_in_gate_+3A_epsilon">epsilon</code></td>
<td>
<p>double, epsilon threshold value. Default is 0.000000000001</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_raster'>Raster Image</h2><span id='topic+cpp_raster'></span>

<h3>Description</h3>

<p>low-level function to create plot raster
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_raster_+3A_width">width</code></td>
<td>
<p>a uint16_t determining the returned image width.</p>
</td></tr>
<tr><td><code id="cpp_raster_+3A_height">height</code></td>
<td>
<p>a uint16_t determining the returned image height.</p>
</td></tr>
<tr><td><code id="cpp_raster_+3A_obj">obj</code></td>
<td>
<p>a List containing drawing information:<br />
- pch, an integer specifying a symbol to draw. Handled are [0-20]. Otherwise only a pixel will be drawn.<br />
- size, an integer specifying the size in pixel of the shape, from 1 to 255.<br />
- color a 4 rows IntegerMatrix (rgba) of the color used to draw the shape.<br />
- coords, an IntegerMatrix whose rows are points to draw and with:<br />
-* 1st column being img col coordinate in px,<br />
-* 2nd column being img row coordinate in px.
- blur_size an integer controlling the size of the blurring gaussian kernel.<br />
- blur_sd a double controlling the sd of the blurring gaussian kernel.</p>
</td></tr>
<tr><td><code id="cpp_raster_+3A_bg_">bg_</code></td>
<td>
<p>a Nullable IntegerVector that will be cast to 3D array when not NULL. Default is R_NilValue.<br />
When not NULL, its dimensions should be the same as required by 'width' and 'height', otherwise an error will be thrown.<br />
When not NULL, it will serve as a background to draw new points on top of it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>shape according to 'pch' will be drawn centered at coordinates obj$coord[, 1], obj$coord[, 0]
and every pixels being part of the shape will be filled with 'color'.
If only one 'color' is provided, this 'color' will be used for each points.
If more than one 'color' is provided, then if number of colors (ncol) equals the number of points 'color' will be used as is for each single point.
Otherwise, 'color' will be considered as a color-gradient and density will be computed.
/!\ please note that IFC:::densCols() is faster to compute color based on density for n &lt; 20000 points, so it's worth using it when number of points are lower.
</p>


<h3>Value</h3>

<p>an IntegerVector with dimensions [height, width, 4]
</p>

<hr>
<h2 id='cpp_raw_to_offset'>Offset to Raw Conversion</h2><span id='topic+cpp_raw_to_offset'></span>

<h3>Description</h3>

<p>Converts raw to offset
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_raw_to_offset_+3A_x">x</code></td>
<td>
<p>RawVector.</p>
</td></tr>
<tr><td><code id="cpp_raw_to_offset_+3A_swap">swap</code></td>
<td>
<p>bool, whether to swap or not.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_rawdecomp'>IFC_object Decompression to RAW</h2><span id='topic+cpp_rawdecomp'></span>

<h3>Description</h3>

<p>Operates decompression to raw of compressed image stored in TIFF file.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_rawdecomp_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
<tr><td><code id="cpp_rawdecomp_+3A_offset">offset</code></td>
<td>
<p>std::size_t, position of the beginning of compressed image.</p>
</td></tr>
<tr><td><code id="cpp_rawdecomp_+3A_nbytes">nbytes</code></td>
<td>
<p>uint32_t, number of bytes of compressed image.</p>
</td></tr>
<tr><td><code id="cpp_rawdecomp_+3A_imgwidth">imgWidth</code></td>
<td>
<p>uint32_t, Width of the decompressed image. Default is 1.</p>
</td></tr>
<tr><td><code id="cpp_rawdecomp_+3A_imgheight">imgHeight</code></td>
<td>
<p>uint32_t, Height of the decompressed image. Default is 1.</p>
</td></tr>
<tr><td><code id="cpp_rawdecomp_+3A_compression">compression</code></td>
<td>
<p>uint32_t, compression algorithm used. Default is 30818.</p>
</td></tr>
<tr><td><code id="cpp_rawdecomp_+3A_swap">swap</code></td>
<td>
<p>bool, whether to swap bytes or not. Default is false.</p>
</td></tr>
<tr><td><code id="cpp_rawdecomp_+3A_verbose">verbose</code></td>
<td>
<p>bool, whether to display information (use for debugging purpose). Default is false.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>For image decompression, Lee Kamentsky's code porting from <a href="https://github.com/ome/bioformats/blob/4146b9a1797501f0fec7d6cfe69124959bff96ee/components/formats-bsd/src/loci/formats/in/FlowSightReader.java">https://github.com/ome/bioformats/blob/4146b9a1797501f0fec7d6cfe69124959bff96ee/components/formats-bsd/src/loci/formats/in/FlowSightReader.java</a><br />
cited in <a href="https://linkinghub.elsevier.com/retrieve/pii/S1046-2023(16)30291-2">https://linkinghub.elsevier.com/retrieve/pii/S1046-2023(16)30291-2</a><br />
<code style="white-space: pre;">&#8288;
BSD implementations of Bio-Formats readers and writers

Copyright (C) 2005 - 2017 Open Microscopy Environment:
  - Board of Regents of the University of Wisconsin-Madison
  - Glencoe Software, Inc.
  - University of Dundee

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
&#8288;</code>
</p>

<hr>
<h2 id='cpp_replace_non_finite'>Non Finite Values Replacement</h2><span id='topic+cpp_replace_non_finite'></span>

<h3>Description</h3>

<p>This function replaces non finite values (NA, NaN -Inf and +Inf)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_replace_non_finite_+3A_v_">V_</code></td>
<td>
<p>a NumericVector.</p>
</td></tr>
<tr><td><code id="cpp_replace_non_finite_+3A_by">by</code></td>
<td>
<p>a double used as replcaement value. Default is 0.0</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_resize'>Matrix Resizing</h2><span id='topic+cpp_resize'></span>

<h3>Description</h3>

<p>Resizes mat according to new_height and new_width parameters.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_resize_+3A_mat">mat</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="cpp_resize_+3A_new_height">new_height</code></td>
<td>
<p>an unsigned integer, giving the new height of returned mat. Default is 0 for no change.</p>
</td></tr>
<tr><td><code id="cpp_resize_+3A_new_width">new_width</code></td>
<td>
<p>an unsigned integer, giving the new width of returned mat. Default is 0 for no change.</p>
</td></tr>
<tr><td><code id="cpp_resize_+3A_add_noise">add_noise</code></td>
<td>
<p>logical, if true adds normal noise when at least one new dimension is larger than original mat dimensions 
Rcpp::rnorm() function is used. Default is true.</p>
</td></tr>
<tr><td><code id="cpp_resize_+3A_bg">bg</code></td>
<td>
<p>double, mean value of the background added if add_noise is true. Default is 0.</p>
</td></tr>
<tr><td><code id="cpp_resize_+3A_sd">sd</code></td>
<td>
<p>double, standard deviation of the background added if add_noise is true. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a resized matrix with padding background if new_height or new_width is larger than original mat dimensions.
</p>

<hr>
<h2 id='cpp_scanFirst'>File Scanner</h2><span id='topic+cpp_scanFirst'></span>

<h3>Description</h3>

<p>Scans file for 1st occurence of a target string.
If found, it returns the position in bytes of the target.
Otherwise, it returns 0.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_scanFirst_+3A_fname">fname</code></td>
<td>
<p>string, path to file.</p>
</td></tr>
<tr><td><code id="cpp_scanFirst_+3A_raw">raw</code></td>
<td>
<p>a Rcpp::RawVector, exact target to be searched for. When converted to string it should be of at least 1 character and not exceed 1024 characters.</p>
</td></tr>
<tr><td><code id="cpp_scanFirst_+3A_start">start</code></td>
<td>
<p>size_t, position where to begin search.
It can't be superior or equal than file size or end (when end is different from 0 and inferior than file size).</p>
</td></tr>
<tr><td><code id="cpp_scanFirst_+3A_end">end</code></td>
<td>
<p>size_t, position where to stop searching. Default is 0.
Search will end up at this position unless it is higher than file size.
In such case, search will end up when file end will be reached.</p>
</td></tr>
<tr><td><code id="cpp_scanFirst_+3A_buf_size">buf_size</code></td>
<td>
<p>uint8_t, size of buffer used to search for target (in kilo-Bytes, will be forced to be between 2 and 1024). Default is 64.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>size_t index of first target character found within target plus 1 or 0 if not found.
</p>

<hr>
<h2 id='cpp_seqmatch'>Sequence of Strings Matching</h2><span id='topic+cpp_seqmatch'></span>

<h3>Description</h3>

<p>Match a sequence of strings in another string
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_seqmatch_+3A_x">x</code>, <code id="cpp_seqmatch_+3A_y">y</code></td>
<td>
<p>StringVector to match</p>
</td></tr>
</table>


<h3>Details</h3>

<p>smallest sequence will be searched into the largest one.
</p>


<h3>Value</h3>

<p>the index (starting at 1) when a match has been found. Otherwise 0.
</p>

<hr>
<h2 id='cpp_smoothLinLog'>Smooth LinLog Transformation with Rcpp</h2><span id='topic+cpp_smoothLinLog'></span>

<h3>Description</h3>

<p>Takes a numeric vector and return its transformation:
- to linear, if abs(x) &lt; hyper.
- to log, if abs(x) &gt; hyper.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_smoothLinLog_+3A_x">x</code></td>
<td>
<p>NumericVector.</p>
</td></tr>
<tr><td><code id="cpp_smoothLinLog_+3A_hyper">hyper</code></td>
<td>
<p>double, value where transition between Lin/Log is applied.</p>
</td></tr>
<tr><td><code id="cpp_smoothLinLog_+3A_base">base</code></td>
<td>
<p>double, base of Log scale.</p>
</td></tr>
<tr><td><code id="cpp_smoothLinLog_+3A_lin_comp">lin_comp</code></td>
<td>
<p>double, value that is used to smooth transition between Lin/Log.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_transform'>Matrix Transformation</h2><span id='topic+cpp_transform'></span>

<h3>Description</h3>

<p>Function to normalize, colorize and add background to images.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_transform_+3A_mat">mat</code></td>
<td>
<p>NumericMatrix.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_color">color</code></td>
<td>
<p>NumericVector, whose members are h,s,v color.
This vector has to be named with 1st name being the name of this color.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_msk">msk</code></td>
<td>
<p>IntegerMatrix.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_size">size</code></td>
<td>
<p>a length 2 IntegerVector, of final dimensions (height,width) of the image. Default is <code>0,0</code> for no change.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_mode">mode</code></td>
<td>
<p>string, color mode export. Either <code>"rgb"</code>, <code>"gray"</code> or <code>"raw"</code>. Default is <code>"raw"</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_type">type</code></td>
<td>
<p>uint16_t image object type. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_input_range">input_range</code></td>
<td>
<p>a finite NumericVector, only apply when <code>'mode'</code> is not <code>"raw"</code>, sets the range of the input intensity values. Values outside this range are clipped. Default is <code>[0.0,4095.0]</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_add_noise">add_noise</code></td>
<td>
<p>bool, whether to add normal noise or not. Default is <code>true</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_bg">bg</code></td>
<td>
<p>double, mean value of the background added if <code>'add_noise'</code> is <code>true</code>. Default is <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_sd">sd</code></td>
<td>
<p>double, standard deviation of the background added if <code>'add_noise'</code> is <code>true</code>. Default is <code>0.0</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_full_range">full_range</code></td>
<td>
<p>bool, only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'full_range'</code> is <code>true</code>, then <code>'input_range'</code> will be set to <code>[0.0,4095.0]</code> and <code>'gamma'</code> forced to <code>1.0</code>. Default is <code>false</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_force_range">force_range</code></td>
<td>
<p>bool, only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'force_range'</code> is <code>true</code>, then <code>'input_range'</code> will be adjusted to object range in <code>[-4095.0, +inf]</code> and <code>'gamma'</code> forced to <code>1.0</code>. Default is <code>false</code>.<br />
Note that this parameter takes the precedence over <code>'input_range'</code> and <code>'full_range'</code>.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_gamma">gamma</code></td>
<td>
<p>correction. Default is <code>1.0</code>, for no correction.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_spatialx">spatialX</code></td>
<td>
<p>X offset correction. Default is <code>0.0</code> for no change.</p>
</td></tr>
<tr><td><code id="cpp_transform_+3A_spatialy">spatialY</code></td>
<td>
<p>Y offset correction. Default is <code>0.0</code> for no change.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a mask is detected, <code>'add_noise'</code>, <code>'full_range'</code> and <code>'force_range'</code> are set to <code>false</code>, <code>'bg'</code> and <code>'sd'</code> to <code>0.0</code>, <code>'input_range'</code> to <code>[0.0,3.0]</code> and <code>'gamma'</code> to <code>1.0</code>.<br /><br />
Experimental (as of v0.2.0.501): when <code>'mode'</code> is not <code>"raw"</code>, if <code>'input_range'</code> is within <code>]0,1[</code>, it will be used as <code>'probs'</code> argument to <a href="stats.html#topic+quantile">quantile</a> to determine clipping range from image object, in addition, <code>'gamma'</code> will be forced to <code>1.0</code>.
</p>

<hr>
<h2 id='cpp_uint32_to_int32'>Uint32 to Int32 32bits Conversion</h2><span id='topic+cpp_uint32_to_int32'></span>

<h3>Description</h3>

<p>Converts 32bits integer from unsigned to signed
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_uint32_to_int32_+3A_x">x</code></td>
<td>
<p>uint32_t.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_uint32_to_raw'>Uint32 to Raw Conversion</h2><span id='topic+cpp_uint32_to_raw'></span>

<h3>Description</h3>

<p>Converts unsigned 32bits integer to raw
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_uint32_to_raw_+3A_x">x</code></td>
<td>
<p>uint32_t.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_uint64_to_int64'>Uint64 to Int64 64bits Conversion</h2><span id='topic+cpp_uint64_to_int64'></span>

<h3>Description</h3>

<p>Converts 64bits integer from unsigned to signed
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_uint64_to_int64_+3A_x">x</code></td>
<td>
<p>uint64_t.</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_v_int32_to_uint32'>Vectorize Int32 to Uint32 32bits Conversion</h2><span id='topic+cpp_v_int32_to_uint32'></span>

<h3>Description</h3>

<p>Converts 32bits vector of integers from unsigned to signed
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_v_int32_to_uint32_+3A_v">V</code></td>
<td>
<p>a NumericVector</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_v_int64_to_uint64'>Vectorize Int64 to Uint64 64bits Conversion</h2><span id='topic+cpp_v_int64_to_uint64'></span>

<h3>Description</h3>

<p>Converts 64bits vector of integers from unsigned to signed
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_v_int64_to_uint64_+3A_v">V</code></td>
<td>
<p>a NumericVector</p>
</td></tr>
</table>

<hr>
<h2 id='cpp_writeBMP'>BMP Writer</h2><span id='topic+cpp_writeBMP'></span>

<h3>Description</h3>

<p>Transforms 3D [0,1] image to uncompressed bmp
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_writeBMP_+3A_image">image</code></td>
<td>
<p>a [0,1] normalized image matrix or 3D array. If 3D array, 3rd dimension should be of length 1 or 3.</p>
</td></tr>
</table>

<hr>
<h2 id='CreateGraphReport'>Graph Report Generation</h2><span id='topic+CreateGraphReport'></span>

<h3>Description</h3>

<p>Generates graph report (plot + statistics) from 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateGraphReport(
  obj,
  selection,
  onepage = TRUE,
  color_mode = c("white", "black")[1],
  add_key = "panel",
  precision = c("light", "full")[1],
  trunc_labels = 38,
  trans = "asinh",
  bin,
  viewport = "ideas",
  backend = "lattice",
  display_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateGraphReport_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_selection">selection</code></td>
<td>
<p>indices of desired graphs. It can be provided as an integer vector or as a matrix.<br />
In such case, the layout of the matrix will reflect the layout of the extracted graphs.<br />
NA value will result in an empty place.<br />
Otherwise, when 'selection' is provided as a vector not identical to seq_along(obj$graphs), 'onepage' parameter will be set to FALSE.<br />
Note that indices are read from left to right, from top to bottom. Default is missing for extracting all graphs.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_onepage">onepage</code></td>
<td>
<p>whether to generate a pdf with all graphs on one page or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_color_mode">color_mode</code></td>
<td>
<p>Whether to extract colors from obj in white or black mode. Default is &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_add_key">add_key</code></td>
<td>
<p>whether to draw a &quot;global&quot; key under title or in the first &quot;panel&quot; or &quot;both&quot;. Default is &quot;panel&quot;.<br />
Accepted values are either: FALSE, &quot;panel&quot;, &quot;global&quot;, &quot;both&quot; or c(&quot;panel&quot;, &quot;global&quot;).<br />
Note that it only applies when display is seen as overlaying populations.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_precision">precision</code></td>
<td>
<p>when graphs is a 2D scatter with population overlay, this argument controls amount of information displayed. Default is &quot;light&quot;.<br />
-&quot;light&quot;, the default, will only display points of same coordinates that are among the other layers.<br />
-&quot;full&quot; will display all the layers.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_trunc_labels">trunc_labels</code></td>
<td>
<p>maximum number of characters to display for labels. Default is 38.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_trans">trans</code></td>
<td>
<p>name of the transformation function for density graphs. If missing the default, the BasePop[[1]]$densitytrans, if any, will be retrieved, otherwise &quot;asinh&quot; will be used.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_bin">bin</code></td>
<td>
<p>default number of bin used for histogram. Default is missing.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_viewport">viewport</code></td>
<td>
<p>Either &quot;ideas&quot;, &quot;data&quot; or &quot;max&quot; defining limits used for the graph. Default is &quot;ideas&quot;.<br />
-&quot;ideas&quot; will use same limits as the one defined in ideas.<br />
-&quot;data&quot; will use data to define limits.<br />
-&quot;max&quot; will use data and regions drawn to define limits.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_backend">backend</code></td>
<td>
<p>backend used for drawing. Allowed are &quot;lattice&quot;, &quot;base&quot;, &quot;raster&quot;. Default is &quot;lattice&quot;.<br />
-&quot;lattice&quot; is the original one used in <span class="pkg">IFC</span> using <span class="pkg">lattice</span>,<br />
-&quot;base&quot; will produce the plot using <span class="pkg">base</span>,<br />
-&quot;raster&quot; uses &quot;base&quot; for plotting but 2D graphs points will be produced as <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>.<br />
This has the main advantage of being super fast allowing for plotting a huge amount of points while generating smaller objects (in bytes).
However, plot quality is impacted with &quot;raster&quot; method and resizing can lead to unpleasant looking.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="CreateGraphReport_+3A_...">...</code></td>
<td>
<p>other parameters to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with onepage, layout, layout_matrix, graphs, grobs, and stats.
</p>

<hr>
<h2 id='data_add_features'>Add Feature to IFC_data Object</h2><span id='topic+data_add_features'></span>

<h3>Description</h3>

<p>Adds features to an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_add_features(obj, features, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_add_features_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_add_features_+3A_features">features</code></td>
<td>
<p>a list of features to add to obj. Each element of this list will be coerced by <code><a href="#topic+buildFeature">buildFeature</a></code>.</p>
</td></tr>
<tr><td><code id="data_add_features_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A warning will be thrown if a provided feature is already existing in obj.<br />
In such a case this feature will not be added to obj.<br />
If any input feature is not well defined and can't be created then an error will occur.
</p>


<h3>Value</h3>

<p>an IFC_data object with features added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf)
  ## copy 1st feature found in daf
  feat_def &lt;- daf$features_def[[1]]
  if(length(feat_def) != 0) {
    feat_def_copy &lt;- feat_def
    ## modify name and value of copied features
    feat_def_copy$name &lt;- "copied_feature"
    feat &lt;- daf$features[, feat_def$name]
    feat_copy &lt;- feat
    feat_copy &lt;- feat_copy * 10
    ## create new object with this new feature
    dafnew &lt;- data_add_features(obj = daf, features = list(c(feat_def_copy, list(val = feat_copy))))
  }
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='data_add_graphs'>Add Graphs to IFC_data Object</h2><span id='topic+data_add_graphs'></span>

<h3>Description</h3>

<p>Adds graphs to an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_add_graphs(obj, graphs, adjust_graph = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_add_graphs_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_add_graphs_+3A_graphs">graphs</code></td>
<td>
<p>a list of graph(s) to add to obj. Each element of this list will be coerced by <code><a href="#topic+buildGraph">buildGraph</a></code>.</p>
</td></tr>
<tr><td><code id="data_add_graphs_+3A_adjust_graph">adjust_graph</code></td>
<td>
<p>whether to try to adjust graph(s) when possible. Default is TRUE.<br />
-TRUE, graph(s) will be kept if possible using only regions, pops it depends that can be found in 'obj',<br />
-FALSE, graph(s) will be kept only if all features, regions, pops it refers to are found in 'obj',<br />
-NA, is not allowed and will throw an error.</p>
</td></tr>
<tr><td><code id="data_add_graphs_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an IFC_data object with graphs added.
</p>

<hr>
<h2 id='data_add_pop_sample'>Population Sampling</h2><span id='topic+data_add_pop_sample'></span>

<h3>Description</h3>

<p>Creates a sample from a population
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_add_pop_sample(obj, pop, size, new_name, random_seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_add_pop_sample_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_add_pop_sample_+3A_pop">pop</code></td>
<td>
<p>name of the population to sample.</p>
</td></tr>
<tr><td><code id="data_add_pop_sample_+3A_size">size</code></td>
<td>
<p>a non-negative integer giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="data_add_pop_sample_+3A_new_name">new_name</code></td>
<td>
<p>name of the exported population.</p>
</td></tr>
<tr><td><code id="data_add_pop_sample_+3A_random_seed">random_seed</code></td>
<td>
<p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL to be used when 'add_noise' is set to TRUE. Default is NULL.
Note that NA_integer_ or list(seed = NA_integer_) can be used to not call <a href="base.html#topic+set.seed">set.seed</a> at all.</p>
</td></tr>
<tr><td><code id="data_add_pop_sample_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>population is exported as tagged population.
</p>


<h3>Value</h3>

<p>an IFC_data object with sampled pop added.
</p>

<hr>
<h2 id='data_add_pops'>Add Population to IFC_data Object</h2><span id='topic+data_add_pops'></span>

<h3>Description</h3>

<p>Adds populations to an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_add_pops(
  obj,
  pops,
  pnt_in_poly_algorithm = 1,
  pnt_in_poly_epsilon = 1e-12,
  display_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_add_pops_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_add_pops_+3A_pops">pops</code></td>
<td>
<p>a list of population(s) to add to 'obj'. Each element of this list will be coerced by <code><a href="#topic+buildPopulation">buildPopulation</a></code>.</p>
</td></tr>
<tr><td><code id="data_add_pops_+3A_pnt_in_poly_algorithm">pnt_in_poly_algorithm</code></td>
<td>
<p>algorithm used to determine if object belongs to a polygon region or not. Default is 1.<br />
Note that for the moment only 1(Trigonometry) is available.</p>
</td></tr>
<tr><td><code id="data_add_pops_+3A_pnt_in_poly_epsilon">pnt_in_poly_epsilon</code></td>
<td>
<p>epsilon to determine if object belongs to a polygon region or not. It only applies when algorithm is 1. Default is 1e-12.</p>
</td></tr>
<tr><td><code id="data_add_pops_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="data_add_pops_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A warning will be thrown if a provided population is already existing in 'obj'.<br />
In such a case this population will not be added to 'obj'.<br />
If any input population is not well defined and can't be created then an error will occur.
</p>


<h3>Value</h3>

<p>an IFC_data object with pops added.
</p>


<h3>Source</h3>

<p>For pnt_in_poly_algorithm, Trigonometry, is an adaptation of Jeremy VanDerWal's code <a href="https://github.com/jjvanderwal/SDMTools">https://github.com/jjvanderwal/SDMTools</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf)
  ## copy 1st population from existing daf
  pop &lt;- daf$pops[[1]]
  if(length(pop) != 0) {
    pop_copy &lt;- pop
    ## modify name, obj and type of copied population
    pop_copy$name &lt;- paste0(pop_copy$name,"_copy")
    pop_copy$obj &lt;- (which(pop_copy$obj)-1)[1]
    pop_copy$type &lt;- "T"
    ## create new object with this new population
    dafnew &lt;- data_add_pops(obj = daf, pops = list(pop_copy))
  }
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='data_add_regions'>Add Region to IFC_data Object</h2><span id='topic+data_add_regions'></span>

<h3>Description</h3>

<p>Adds regions to an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_add_regions(obj, regions, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_add_regions_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_add_regions_+3A_regions">regions</code></td>
<td>
<p>a list of region(s) to add to obj. Each element of this list will be coerced by <code><a href="#topic+buildRegion">buildRegion</a></code>.</p>
</td></tr>
<tr><td><code id="data_add_regions_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A warning will be thrown if a provided region is already existing in 'obj'.<br />
In such a case this region will not be added to 'obj'.<br />
If any input population is not well defined and can't be created then an error will occur.
</p>


<h3>Value</h3>

<p>an IFC_data object with regions added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf)
  ## copy 1st region found in daf
  reg &lt;- daf$regions[[1]]
  if(length(reg) != 0) {
    reg_copy &lt;- reg
    ## modify region label and x boundaries
    reg_copy$label &lt;- paste0(reg_copy$label,"_copy")
    reg_copy$x &lt;- reg_copy$x*0.9
    ## create new object with this new region
    dafnew &lt;- data_add_regions(obj = daf, regions = list(reg_copy))
  }
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='data_modify_pops'>Modify Populations within IFC_data Object</h2><span id='topic+data_modify_pops'></span>

<h3>Description</h3>

<p>Modify populations in an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_modify_pops(obj, pops, display_progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_modify_pops_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_modify_pops_+3A_pops">pops</code></td>
<td>
<p>a list of population(s) to modify in 'obj'. Each element of this list will be coerced by <code><a href="#topic+buildPopulation">buildPopulation</a></code>.</p>
</td></tr>
<tr><td><code id="data_modify_pops_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="data_modify_pops_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>pops names should be present in names(obj$pops), otherwise an error will be raised.<br />
Note that If you want to rename pops, you should do it by changing 'name' member,
e.g. pops[[1]]$name &lt;- &quot;bar&quot; while names(pops[[1]]) is &quot;foo&quot; and &quot;foo&quot; is part of names(obj$pops).
However, new names should not be present in 'obj'.
</p>


<h3>Value</h3>

<p>an IFC_data object with pops modified.
</p>

<hr>
<h2 id='data_modify_regions'>Modify Populations within IFC_data Object</h2><span id='topic+data_modify_regions'></span>

<h3>Description</h3>

<p>Modify populations in an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_modify_regions(obj, regions, display_progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_modify_regions_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_modify_regions_+3A_regions">regions</code></td>
<td>
<p>a list of region(s) to modify in 'obj'. Each element of this list will be coerced by <code><a href="#topic+buildRegion">buildRegion</a></code>.</p>
</td></tr>
<tr><td><code id="data_modify_regions_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="data_modify_regions_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>regions names should be present in names(obj$regions), otherwise an error will be raised.<br />
Note that If you want to rename regions, you should do it by changing 'label' member,
e.g. regions[[1]]$label &lt;- &quot;bar&quot; while names(regions[[1]]) is &quot;foo&quot; and &quot;foo&quot; is part of names(obj$regions).
</p>


<h3>Value</h3>

<p>an IFC_data object with regions modified.
</p>

<hr>
<h2 id='data_rm_features'>Remove Features from an IFC_data Object</h2><span id='topic+data_rm_features'></span>

<h3>Description</h3>

<p>Removes regions from an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_rm_features(obj, features, list_only = TRUE, adjust_graph = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_rm_features_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_rm_features_+3A_features">features</code></td>
<td>
<p>a character vector of features names to remove within 'obj'. Note that &quot;Object Number&quot; is not allowed and will be excluded from 'features' if present.</p>
</td></tr>
<tr><td><code id="data_rm_features_+3A_list_only">list_only</code></td>
<td>
<p>whether to return a list of elements that will be impacted by the removal. Default is TRUE.
If FALSE then modified object will be returned.</p>
</td></tr>
<tr><td><code id="data_rm_features_+3A_adjust_graph">adjust_graph</code></td>
<td>
<p>whether to try to adjust graph(s) when possible. Default is TRUE.<br />
-TRUE, graph(s) will be kept if possible using only regions, pops it depends that can be found in 'obj',<br />
-FALSE, graph(s) will be kept only if all features, regions, pops it refers to are found in 'obj',<br />
-NA, graph(s) will be removed no matter if features, regions, pops it refers to are found in 'obj'.</p>
</td></tr>
<tr><td><code id="data_rm_features_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;IFC_data' object or a list of elements impacted by removal depending on &rsquo;list_only' parameter.
</p>

<hr>
<h2 id='data_rm_graphs'>Remove Graph from an IFC_data Object</h2><span id='topic+data_rm_graphs'></span>

<h3>Description</h3>

<p>Removes graphs from an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_rm_graphs(obj, graphs, list_only = TRUE, adjust_graph = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_rm_graphs_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_rm_graphs_+3A_graphs">graphs</code></td>
<td>
<p>an integer vector of graph(s) to remove within 'obj'.</p>
</td></tr>
<tr><td><code id="data_rm_graphs_+3A_list_only">list_only</code></td>
<td>
<p>whether to return a list of elements that will be impacted by the removal. Default is TRUE.
If FALSE then modified object will be returned.</p>
</td></tr>
<tr><td><code id="data_rm_graphs_+3A_adjust_graph">adjust_graph</code></td>
<td>
<p>whether to try to adjust graph(s) when possible. Default is TRUE.<br />
-TRUE, graph(s) will be kept if possible using only regions, pops it depends that can be found in 'obj',<br />
-FALSE, graph(s) will be kept only if all features, regions, pops it refers to are found in 'obj',<br />
-NA, graph(s) will be removed no matter if features, regions, pops it refers to are found in 'obj'.</p>
</td></tr>
<tr><td><code id="data_rm_graphs_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;IFC_data' object or a list of elements impacted by removal depending on &rsquo;list_only' parameter.
</p>

<hr>
<h2 id='data_rm_pops'>Remove Population from an IFC_data Object</h2><span id='topic+data_rm_pops'></span>

<h3>Description</h3>

<p>Removes populations from an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_rm_pops(obj, pops, list_only = TRUE, adjust_graph = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_rm_pops_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_rm_pops_+3A_pops">pops</code></td>
<td>
<p>a character vector of population names to remove within 'obj'. Note that &quot;All&quot; and &quot;&quot; are not allowed and will be excluded from 'pops' if present.</p>
</td></tr>
<tr><td><code id="data_rm_pops_+3A_list_only">list_only</code></td>
<td>
<p>whether to return a list of elements that will be impacted by the removal. Default is TRUE.
If FALSE then modified object will be returned.</p>
</td></tr>
<tr><td><code id="data_rm_pops_+3A_adjust_graph">adjust_graph</code></td>
<td>
<p>whether to try to adjust graph(s) when possible. Default is TRUE.<br />
-TRUE, graph(s) will be kept if possible using only regions, pops it depends that can be found in 'obj',<br />
-FALSE, graph(s) will be kept only if all features, regions, pops it refers to are found in 'obj',<br />
-NA, graph(s) will be removed no matter if features, regions, pops it refers to are found in 'obj'.</p>
</td></tr>
<tr><td><code id="data_rm_pops_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;IFC_data' object or a list of elements impacted by removal depending on &rsquo;list_only' parameter.
</p>

<hr>
<h2 id='data_rm_regions'>Remove Region from an IFC_data Object</h2><span id='topic+data_rm_regions'></span>

<h3>Description</h3>

<p>Removes regions from an already existing 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_rm_regions(obj, regions, list_only = TRUE, adjust_graph = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_rm_regions_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="data_rm_regions_+3A_regions">regions</code></td>
<td>
<p>a character vector of regions names to remove within 'obj'.</p>
</td></tr>
<tr><td><code id="data_rm_regions_+3A_list_only">list_only</code></td>
<td>
<p>whether to return a list of elements that will be impacted by the removal. Default is TRUE.
If FALSE then modified object will be returned.</p>
</td></tr>
<tr><td><code id="data_rm_regions_+3A_adjust_graph">adjust_graph</code></td>
<td>
<p>whether to try to adjust graph(s) when possible. Default is TRUE.<br />
-TRUE, graph(s) will be kept if possible using only regions, pops it depends that can be found in 'obj',<br />
-FALSE, graph(s) will be kept only if all features, regions, pops it refers to are found in 'obj',<br />
-NA, graph(s) will be removed no matter if features, regions, pops it refers to are found in 'obj'.</p>
</td></tr>
<tr><td><code id="data_rm_regions_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an &lsquo;IFC_data' object or a list of elements impacted by removal depending on &rsquo;list_only' parameter.
</p>

<hr>
<h2 id='data_to_AST'>AST File Writer</h2><span id='topic+data_to_AST'></span>

<h3>Description</h3>

<p>Writes an 'IFC_data' object to a ast file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_AST(
  obj,
  write_to,
  viewing_pop = "All",
  overwrite = FALSE,
  display_progress = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_to_AST_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="data_to_AST_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'obj$fileName'<br />
-%p: with first parent directory of 'obj$fileName'<br />
-%e: with extension of 'obj$fileName' (without leading .)<br />
-%s: with shortname from 'obj$fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. Note that it has to be a .ast.</p>
</td></tr>
<tr><td><code id="data_to_AST_+3A_viewing_pop">viewing_pop</code></td>
<td>
<p>Character String. Allow user to change displayed population. Default is 'All'.</p>
</td></tr>
<tr><td><code id="data_to_AST_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.
Note that if TRUE, it will overwrite exported file if path of 'obj$fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
Otherwise, you will get an error saying that overwriting original file is not allowed.</p>
</td></tr>
<tr><td><code id="data_to_AST_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="data_to_AST_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="data_to_AST_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>

<hr>
<h2 id='data_to_DAF'>DAF File Writer</h2><span id='topic+data_to_DAF'></span>

<h3>Description</h3>

<p>Writes an 'IFC_data' object to a daf file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_to_DAF(
  obj,
  write_to,
  viewing_pop = "All",
  overwrite = FALSE,
  binary = TRUE,
  endianness = .Platform$endian,
  display_progress = TRUE,
  verbose = FALSE,
  fullname = TRUE,
  cifdir = dirname(obj$fileName),
  ntry = +Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_to_DAF_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'obj$fileName'<br />
-%p: with first parent directory of 'obj$fileName'<br />
-%e: with extension of 'obj$fileName' (without leading .)<br />
-%s: with shortname from 'obj$fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. Note that it has to be a .daf.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_viewing_pop">viewing_pop</code></td>
<td>
<p>Character String. Allow user to change displayed population. Default is 'All'.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.
Note that if TRUE, it will overwrite exported file if path of 'obj$fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
Otherwise, you will get an error saying that overwriting original file is not allowed.<br /></p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_binary">binary</code></td>
<td>
<p>whether to write object to file in binary mode or not. Default is TRUE.<br />
Note that it can represent a convenient way to make file written in binary mode back-compatible with former version of IDEAS software.<br />
/!\ However unexpected behaviour may happen if features, regions, pops, ... are depending on masks (e.g. AdaptiveErode, Component, LevelSet, Watershed) introduced in newer version of IDEAS software.<br />
/!\ Important please note that conversion from binary to non-binary and back to binary may create some rounding adjustment resulting in some features/image values changes.<br />
Finally, if data originate from FCS, 'binary' will be forced to FALSE.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_fullname">fullname</code></td>
<td>
<p>whether to export daf file with full name of its corresponding cif, if found. Default is TRUE.
If cif can't be found, daf file will be exported with the original cif file name.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_cifdir">cifdir</code></td>
<td>
<p>the path of the directory to initially look to cif file. Default is dirname(obj$fileName). Only apply when 'fullname' is set to TRUE.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_ntry">ntry</code></td>
<td>
<p>number of times <code><a href="#topic+data_to_DAF">data_to_DAF</a></code> will be allowed to find corresponding cif file. Default is +Inf. Only apply when 'fullname' is set to TRUE.</p>
</td></tr>
<tr><td><code id="data_to_DAF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  tmp &lt;- tempdir(check = TRUE)
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf)
  ## add a new population to daf
  dafnew &lt;- data_add_pops(daf, list(buildPopulation(name = "test", type = "T", obj = 0)))
  ## export obj to file using binary mode
  data_to_DAF(obj = dafnew, write_to = paste0(tmp, "\\test_bin.daf"),
              overwrite = TRUE, binary = TRUE)
  ## exporting to non binary mode
  data_to_DAF(obj = dafnew, write_to = paste0(tmp, "\\test_notbin.daf"),
              overwrite = TRUE, binary = FALSE)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='densCols'>Colors for Smooth Density Plots</h2><span id='topic+densCols'></span>

<h3>Description</h3>

<p>Helper to map density to colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densCols(
  x,
  y = NULL,
  xlim = range(x, na.rm = TRUE, finite = TRUE),
  ylim = range(y, na.rm = TRUE, finite = TRUE),
  nbin = 128,
  colramp = colorRampPalette(c("blue", "green", "red")),
  transformation = "asinh"
)
</code></pre>


<h3>Source</h3>

<p>derived from <span class="pkg">grDevices</span> R Core Team, Florian Hahne at FHCRC, originally
</p>

<hr>
<h2 id='DisplayGallery'>Gallery Display</h2><span id='topic+DisplayGallery'></span>

<h3>Description</h3>

<p>Displays gallery of 'IFC_img' / 'IFC_msk' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DisplayGallery(
  ...,
  objects,
  offsets,
  image_type = "img",
  layout,
  name = "DisplayGallery",
  caption = FALSE,
  pageLength = 10L,
  pdf_pageSize = "A2",
  pdf_pageOrientation = "landscape",
  pdf_image_dpi = 96,
  extract_max = 10,
  sampling = FALSE,
  display_progress = TRUE,
  mode = c("rgb", "gray")[1]
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DisplayGallery_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of 'ifd' and 'bypass'(=TRUE).<br />
If 'param' is provided 'export'(=&quot;base64&quot;) and the above parameters will be overwritten.<br />
If 'offsets' are not provided extra arguments can also be passed with ... to <code><a href="#topic+getOffsets">getOffsets</a></code>.<br />
/!\ If not any of 'fileName', 'info' and 'param' can be found in ... then attr(offsets, &quot;fileName_image&quot;) will be used as 'fileName' input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'. 
This argument is not mandatory but it may allow to save time for repeated image export on same file.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_image_type">image_type</code></td>
<td>
<p>image_type of desired offsets. Either &quot;img&quot; or &quot;msk&quot;. Default is &quot;img&quot;.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_layout">layout</code></td>
<td>
<p>a character vector of [acquired channels + 'composite' images] members to export. Default is missing to export everything.<br />
Note that members can be missing to be removed from final display.<br />
Note that members not found will be automatically removed and a warning will be thrown.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_name">name</code></td>
<td>
<p>id of the datatable container. Default is DisplayGallery.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_caption">caption</code></td>
<td>
<p>whether to display caption name or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_pagelength">pageLength</code></td>
<td>
<p>integer, number of objects to display per page. Default is 10.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_pdf_pagesize">pdf_pageSize</code></td>
<td>
<p>string, page dimension when exporting to pdf. Default is &quot;A2&quot;.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_pdf_pageorientation">pdf_pageOrientation</code></td>
<td>
<p>string, page orientation when exporting to pdf. Default is &quot;landscape&quot;. Allowed are &quot;landscape&quot; or &quot;portrait&quot;.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_pdf_image_dpi">pdf_image_dpi</code></td>
<td>
<p>integer, desired image resolution. Default is 96, for full resolution.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_extract_max">extract_max</code></td>
<td>
<p>maximum number of objects to extract. Default is 10. Use +Inf to extract all.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_sampling">sampling</code></td>
<td>
<p>whether to sample objects or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="DisplayGallery_+3A_mode">mode</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) color mode export. Either &quot;rgb&quot; or &quot;gray&quot;. Default is &quot;rgb&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+DisplayGallery">DisplayGallery</a></code> input arguments.<br />
Please note that PDF export link will be available if 'write_to' will not result in a &quot;bmp&quot;.<br />
Please note that exporting to &quot;tiff&quot; may depend on browser capabilities.<br />
Please note that a warning may be sent if gallery to display contains large amount of data. This is due to use of datatable() from <span class="pkg">DT</span>.<br />
Warning message:<br />
In instance$preRenderHook(instance) :<br />
It seems your data is too big for client-side DataTables. You may consider server-side processing: http://rstudio.github.io/DT/server.html<br />
For these reasons, it may be better to use &quot;png&quot; extension to display images.
</p>


<h3>Value</h3>

<p>it invisibly returns a list whose members are:<br />
-data, data for DT::datatable(),<br />
-args, associated arguments to pass to DT::datatable().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a cif file
  file_cif &lt;- system.file("extdata", "example.cif", package = "IFCdata")
  cif &lt;- ExtractFromXIF(fileName = file_cif)
  info &lt;- getInfo(fileName = file_cif, from = "analysis")
  ## randomly show at most 10 "img" objects from file
  DisplayGallery(info = info, image_type = "img", extract_max = 10,
                 sampling = TRUE, write_to = "example.bmp")
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='DisplayReport'>Graphical and Statistic Report Display</h2><span id='topic+DisplayReport'></span>

<h3>Description</h3>

<p>Displays report from 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DisplayReport(obj, display_progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DisplayReport_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="DisplayReport_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="DisplayReport_+3A_...">...</code></td>
<td>
<p>other parameters to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It invisibly returns NULL
</p>

<hr>
<h2 id='endPB'>Progress Bar Terminator</h2><span id='topic+endPB'></span>

<h3>Description</h3>

<p>Terminates a progress bar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>endPB(pb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="endPB_+3A_pb">pb</code></td>
<td>
<p>an object of class 'IFC_progress' containing a progress bar of class 'txtProgressBar', 'winProgressBar' or 'Progress'.</p>
</td></tr>
</table>

<hr>
<h2 id='escape_entities'>XML Entities Protection</h2><span id='topic+escape_entities'></span>

<h3>Description</h3>

<p>Helper to escape xml entities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>escape_entities(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="escape_entities_+3A_text">text</code></td>
<td>
<p>value return by xml2::as_list. Default is 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>entities will be replaced by:<br />
-&amp; to &quot;&amp;amp;&quot;<br />
-&gt; to &quot;&amp;gt;&quot;<br />
-&lt; to &quot;&amp;lt;&quot;<br />
-' to &quot;&amp;apos;&quot;<br />
-&quot; to &quot;&amp;quot;&quot;<br />
</p>


<h3>Value</h3>

<p>a character vector where xml entities have been escaped.
</p>

<hr>
<h2 id='expand_list'>XML Node List Expansion</h2><span id='topic+expand_list'></span>

<h3>Description</h3>

<p>Helper to stringify XML node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_list(x, max = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_list_+3A_x">x</code></td>
<td>
<p>value return by xml2::as_list.</p>
</td></tr>
<tr><td><code id="expand_list_+3A_max">max</code></td>
<td>
<p>maximum number of recurrence into subnodes. Default is 5.</p>
</td></tr>
</table>

<hr>
<h2 id='ExportToBATCH'>Batch File Writer</h2><span id='topic+ExportToBATCH'></span>

<h3>Description</h3>

<p>Writes an XML file to batch files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportToBATCH(batch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportToBATCH_+3A_batch">batch</code></td>
<td>
<p>list of batch nodes as created by <code><a href="#topic+buildBatch">buildBatch</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It invisibly returns full path of xml batch file.
</p>

<hr>
<h2 id='ExportToDAF'>DAF File Writer</h2><span id='topic+ExportToDAF'></span>

<h3>Description</h3>

<p>Writes a new DAF file based on another one and exports new region(s), pop(s), feature(s), graph(s) and / or mask(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportToDAF(
  fileName,
  write_to,
  pops = list(),
  regions = list(),
  features = list(),
  graphs = list(),
  masks = list(),
  viewing_pop = "All",
  endianness = .Platform$endian,
  verbose = FALSE,
  overwrite = FALSE,
  fullname = TRUE,
  cifdir = dirname(fileName),
  ntry = +Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportToDAF_+3A_filename">fileName</code></td>
<td>
<p>path of file to read data from.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'fileName'<br />
-%p: with first parent directory of 'fileName'<br />
-%e: with extension of 'fileName' (without leading .)<br />
-%s: with shortname from 'fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. Note that has to be a .daf.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_pops">pops</code></td>
<td>
<p>list of population(s) to export. Will be coerced to exportable format by buildPopulation.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_regions">regions</code></td>
<td>
<p>list of region(s) to export. Will be coerced to exportable format by buildRegion.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_features">features</code></td>
<td>
<p>list of feature(s) to export.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_graphs">graphs</code></td>
<td>
<p>list of graph(s) to export. Not yet implemented.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_masks">masks</code></td>
<td>
<p>list of mask(s) to export. Not yet implemented.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_viewing_pop">viewing_pop</code></td>
<td>
<p>Character String. Allow user to change displayed population. Default is 'All'.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.
Note that if TRUE, it will overwrite exported file if path of 'fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.<br />
Otherwise, you will get an error saying that overwriting original file is not allowed.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_fullname">fullname</code></td>
<td>
<p>whether to export daf file with full name of its corresponding cif, if found. Default is TRUE.
If cif can't be found, daf file will be exported with the original cif file name.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_cifdir">cifdir</code></td>
<td>
<p>the path of the directory to initially look to cif file. Default is dirname(fileName). Only apply when 'fullname' is set to TRUE.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_ntry">ntry</code></td>
<td>
<p>number of times <code><a href="#topic+ExportToDAF">ExportToDAF</a></code> will be allowed to find corresponding cif file. Default is +Inf. Only apply when 'fullname' is set to TRUE.</p>
</td></tr>
<tr><td><code id="ExportToDAF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  tmp &lt;- tempdir(check = TRUE)
  ## create a tagged population named test with 1st object
  pop &lt;- buildPopulation(name = "test", type = "T", obj = 0)
  ExportToDAF(file_daf, write_to = paste0(tmp, "\\test.daf"),
              overwrite = TRUE, pops = list(pop))
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='ExportToFCS'>FCS File Writer</h2><span id='topic+ExportToFCS'></span>

<h3>Description</h3>

<p>Writes an 'IFC_data' object to a Flow Cytometry Standard (FCS) file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportToFCS(
  obj,
  write_to,
  overwrite = FALSE,
  delimiter = "/",
  cytometer = "Image Stream",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportToFCS_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="ExportToFCS_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'obj$fileName'<br />
-%p: with first parent directory of 'obj$fileName'<br />
-%e: with extension of 'obj$fileName' (without leading .)<br />
-%s: with shortname from 'obj$fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. Note that it has to be a .fcs.</p>
</td></tr>
<tr><td><code id="ExportToFCS_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.
Note that if TRUE, it will overwrite exported file if path of 'fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file will never be overwritten.</p>
</td></tr>
<tr><td><code id="ExportToFCS_+3A_delimiter">delimiter</code></td>
<td>
<p>an ASCII character to separate the FCS keyword-value pairs. Default is : &quot;/&quot;.</p>
</td></tr>
<tr><td><code id="ExportToFCS_+3A_cytometer">cytometer</code></td>
<td>
<p>string, if provided it will be used to fill $CYT keyword.<br />
However, when missing $CYT will be filled with obj$description$FCS$instrument if found, or &quot;Image Stream&quot; otherwise.</p>
</td></tr>
<tr><td><code id="ExportToFCS_+3A_...">...</code></td>
<td>
<p>other arguments to be passed. keyword-value pairs can be passed here.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns full path of exported file.
</p>

<hr>
<h2 id='ExportToGallery'>Gallery Export</h2><span id='topic+ExportToGallery'></span>

<h3>Description</h3>

<p>Exports gallery of 'IFC_img' / 'IFC_msk' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportToGallery(
  ...,
  objects,
  offsets,
  image_type = "img",
  layout,
  export = c("file", "matrix", "base64")[2],
  write_to,
  base64_id = FALSE,
  base64_att = "",
  overwrite = FALSE,
  main = "",
  add_channels = TRUE,
  add_ids = 1,
  add_lines = 2,
  bg_color = "grey20",
  dpi = 300,
  scale = list(),
  extract_max = 10,
  sampling = FALSE,
  display_progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportToGallery_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of 'ifd' and 'bypass'(=TRUE).<br />
If 'param' is provided 'mode'(=&quot;rgb&quot;) and the above parameters will be overwritten.<br />
If 'offsets' are not provided extra arguments can also be passed with ... <code><a href="#topic+getOffsets">getOffsets</a></code>.<br />
/!\ If not any of 'fileName', 'info' and 'param' can be found in ... then attr(offsets, &quot;fileName_image&quot;) will be used as 'fileName' input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'. 
This argument is not mandatory but it may allow to save time for repeated image export on same file.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_image_type">image_type</code></td>
<td>
<p>image_type of desired offsets. Either &quot;img&quot; or &quot;msk&quot;. Default is &quot;img&quot;.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_layout">layout</code></td>
<td>
<p>a character vector of [acquired channels + 'composite' images] members to export. Default is missing to export everything.
Note that members can be missing to be removed from final gallery export.
Note that members not found will be automatically removed and a warning will be thrown.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_export">export</code></td>
<td>
<p>export format. Either &quot;file&quot;, &quot;matrix&quot;, &quot;base64&quot;. Default is &quot;matrix&quot;.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_write_to">write_to</code></td>
<td>
<p>used when 'export' is &quot;file&quot; or &quot;base64&quot; to compute respectively filename or base64 id attribute.
Exported type will be deduced from this pattern. Allowed export are '.bmp', '.jpg', '.jpeg', '.png', '.tif', '.tiff'.
Note that '.bmp' are faster but not compressed producing bigger data.<br />
Placeholders, if found, will be substituted:<br />
-%d: with full path directory<br />
-%p: with first parent directory<br />
-%e: with extension (without leading .)<br />
-%s: with shortname (i.e. basename without extension)<br />
-%o: with objects (at most 10, will be collapse with &quot;_&quot;, if more than one).<br />
-%c: with channel_id (will be collapse with &quot;_&quot;, if more than one, composite in any will be bracketed).
A good trick is to use:<br />
-&quot;%d/%s_gallery_Obj[%o]_Ch[%c].tiff&quot;, when 'export' is &quot;file&quot;<br />
-&quot;%s_gallery.bmp&quot;, when 'export' is &quot;base64&quot;.<br />
Note that if missing and 'export' is not &quot;file&quot;, 'write_to' will be set to &quot;%s_gallery.bmp&quot;.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_base64_id">base64_id</code></td>
<td>
<p>whether to add id attribute to base64 exported object. Default is TRUE.<br />
Only applied when 'export' is &quot;base64&quot;.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_base64_att">base64_att</code></td>
<td>
<p>attributes to add to base64 exported object. Default is &quot;&quot;.<br />
Only applied when export is &quot;base64&quot;. For example, use &quot;class=draggable&quot;.<br />
Note that id (if base64_id is TRUE) and width and height are already used.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_main">main</code></td>
<td>
<p>main title that will be displayed on top center of the image.
If too large it will be clipped.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_add_channels">add_channels</code></td>
<td>
<p>whether to add channels names. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_add_ids">add_ids</code></td>
<td>
<p>integer, indice of column to mark objects ids number. Default is 1.
If add_ids &lt; 1, no ids are added.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_add_lines">add_lines</code></td>
<td>
<p>integer, size of separating lines between objects. Default is 1.
If add_lines &lt; 1, no separating lines are added.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_bg_color">bg_color</code></td>
<td>
<p>background color for main, channels and separating lines. Default is &quot;grey20&quot;.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_dpi">dpi</code></td>
<td>
<p>integer, the resolution of the image in DPI (dots per inch). Default is 300.<br />
Please note that whetever this parameter is final resolution will be 96 dpi.<br />
However image will be scaled according this parameter and magnification factor will be equal to this parameter divided by 96.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_scale">scale</code></td>
<td>
<p>a named list whose members are 'size', 'style', 'color', 'xoff', 'yoff'. Default is list() to draw no scale. Otherwise,<br />
-'size' positive integer. Scale's bar size in micro-meter. Default is '7'.<br />
This parameter can't be lesser than 6px nor higher than image width + scale text.<br />
-'style' a character string. Scale's bar style, either &quot;dash&quot; or &quot;line&quot;. Default is &quot;dash&quot;.<br />
-'color' a character string. color of the scale. Default is &quot;white&quot;.<br />
-'xoff' positive integer. x offset in image to draw scale, starting from bottom left corner.<br />
-'yoff' positive integer. y offset in image to draw scale, starting from bottom left corner.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_extract_max">extract_max</code></td>
<td>
<p>maximum number of objects to extract. Default is 10. Use +Inf to extract all.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_sampling">sampling</code></td>
<td>
<p>whether to sample objects or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ExportToGallery_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExportToGallery">ExportToGallery</a></code> input arguments.
TRICK: for exporting only ONE 'objects', set 'add_channels' = FALSE, 'add_ids' &gt;= 1, 'force_width' = FALSE, 'dpi' = 96; this allows generating image with its original size incrusted with its id number.
</p>


<h3>Value</h3>

<p>Depending on 'export':<br />
-&quot;matrix&quot;, a rgb array,<br />
-&quot;base64&quot;, a data-uri string,<br />
-&quot;file&quot;, an invisible vector of ids corresponding to the objects exported.
</p>

<hr>
<h2 id='ExportToNumpy'>Numpy Export</h2><span id='topic+ExportToNumpy'></span>

<h3>Description</h3>

<p>Exports IFC objects to numpy array [objects,height,width,channels]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportToNumpy(
  ...,
  objects,
  offsets,
  image_type = "img",
  size = c(64, 64),
  force_width = FALSE,
  display_progress = TRUE,
  python = Sys.getenv("RETICULATE_PYTHON"),
  dtype = c("uint8", "int16", "uint16", "double")[3],
  mode = c("raw", "gray")[1],
  export = c("file", "matrix")[2],
  write_to,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportToNumpy_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_image_type">image_type</code></td>
<td>
<p>type of desired object offsets. Either <code>"img"</code> or <code>"msk"</code>. Default is <code>"img"</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_size">size</code></td>
<td>
<p>a length 2 integer vector of final dimensions of the image, height 1st and width 2nd. Default is <code>c(64,64)</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_force_width">force_width</code></td>
<td>
<p>whether to use information in <code>'info'</code> to fill <code>'size'</code>. Default is <code>FALSE</code>.
When set to <code>TRUE</code>, width of <code>'size'</code> argument will be overwritten.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_python">python</code></td>
<td>
<p>path to python. Default is <code>Sys.getenv("RETICULATE_PYTHON")</code>.<br />
Note that <code>numpy</code> should be available in this <code>python</code> to allow export to <code>".npy"</code> file, otherwise <code>'export'</code> will be forced to <code>"matrix"</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_dtype">dtype</code></td>
<td>
<p>desired arrays data-type. Default is <code>"double"</code>. Allowed are <code>"uint8"</code>, <code>"int16"</code>, <code>"uint16"</code> or <code>"double"</code>. If <code>'mode'</code> is <code>"raw"</code>, this parameter will be forced to <code>"int16"</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_mode">mode</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) color mode export. Either <code>"raw"</code>, <code>"gray"</code>. Default is <code>"raw"</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_export">export</code></td>
<td>
<p>export format. Either <code>"file"</code>, <code>"matrix"</code>. Default is <code>"matrix"</code>.<br />
Note that you will need <code>reticulate</code> package installed to be able to export to <code>".npy"</code> file, otherwise <code>'export'</code> will be forced to <code>"matrix"</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_write_to">write_to</code></td>
<td>
<p>used when <code>'export'</code> is <code>"file"</code> to compute exported file name and type.
Exported type will be deduced from this pattern. Allowed exported file extension is <code>".npy"</code>.<br />
Placeholders, if found, will be substituted:<br />
-<code>%d</code>: with full path directory<br />
-<code>%p</code>: with first parent directory<br />
-<code>%e</code>: with extension of (without leading .)<br />
-<code>%s</code>: with shortname (i.e. basename without extension)<br />
-<code>%o</code>: with objects (at most 10, will be collapse with &quot;_&quot;, if more than one).<br />
-<code>%c</code>: with channel_id (will be collapse with &quot;_&quot;, if more than one, composite in any will be bracketed).
A good trick is to use:<br />
-<code>"%d/%s_Obj[%o]_Ch[%c].npy"</code>, when <code>'export'</code> is <code>"file"</code>.</p>
</td></tr>
<tr><td><code id="ExportToNumpy_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that <code>'size'</code> parameter has to be supplied and could not be set to (0,) when <code>'object'</code> length is not equal to one<br />
<code><a href="#topic+ExportToNumpy">ExportToNumpy</a></code> requires <code>reticulate</code> package, <code>python</code> and <code>numpy</code> installed to create <code>".npy"</code> file.<br />
If one of these is missing, <code>'export'</code> will be set to <code>"matrix"</code>.
If <code>'param'</code> is provided in <code>'...'</code>, <code>param$export &lt;- "matrix"</code>, <code>param$mode &lt;- 'mode'</code> and <code>param$size &lt;- 'size'</code> and will be overwritten.
</p>


<h3>Value</h3>

<p>Depending on <code>'export'</code>:<br />
-<code>"matrix"</code>, an array whose dimensions are [object, height, width, channel].<br />
-<code>"file"</code>, it invisibly returns path of <code>".npy"</code> exported file.
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExportToNumpy">ExportToNumpy</a></code> input arguments.
</p>

<hr>
<h2 id='ExportToReport'>Graphical and Statistic Report Generation</h2><span id='topic+ExportToReport'></span>

<h3>Description</h3>

<p>Generates report from 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportToReport(
  obj,
  selection,
  write_to,
  overwrite = FALSE,
  onepage = TRUE,
  color_mode = c("white", "black")[1],
  add_key = "panel",
  precision = c("light", "full")[1],
  trunc_labels = 38,
  trans = "asinh",
  bin,
  viewport = "ideas",
  backend = "lattice",
  display_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportToReport_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_selection">selection</code></td>
<td>
<p>indices of desired graphs. It can be provided as an integer vector or as a matrix.<br />
In such case, the layout of the matrix will reflect the layout of the extracted graphs.<br />
NA value will result in an empty place.<br />
Otherwise, when 'selection' is provided as a vector not identical to seq_along(obj$graphs), 'onepage' parameter will be set to FALSE.<br />
Note that indices are read from left to right, from top to bottom. Default is missing for extracting all graphs.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file(s).
Placeholders, like c(&quot;%d/%s_fromR.pdf&quot;, &quot;%d/%s_fromR.csv&quot;), will be substituted:<br />
-%d: with full path directory of 'obj$fileName'<br />
-%p: with first parent directory of 'obj$fileName'<br />
-%e: with extension of 'obj$fileName' (without leading .)<br />
-%s: with shortname from 'obj$fileName' (i.e. basename without extension).<br />
Exported file(s) extension(s) will be deduced from this pattern. Note that has to be a .pdf and/or .csv.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.
Note that if TRUE, it will overwrite file. In addition a warning message will be sent.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_onepage">onepage</code></td>
<td>
<p>whether to generate a pdf with all graphs on one page or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_color_mode">color_mode</code></td>
<td>
<p>Whether to extract colors from obj in white or black mode. Default is &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_add_key">add_key</code></td>
<td>
<p>whether to draw a &quot;global&quot; key under title or in the first &quot;panel&quot; or &quot;both&quot;. Default is &quot;panel&quot;.<br />
Accepted values are either: FALSE, &quot;panel&quot;, &quot;global&quot;, &quot;both&quot; or c(&quot;panel&quot;, &quot;global&quot;).<br />
Note that it only applies when display is seen as overlaying populations.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_precision">precision</code></td>
<td>
<p>when graphs is a 2D scatter with population overlay, this argument controls amount of information displayed. Default is &quot;light&quot;.<br />
-&quot;light&quot;, the default, will only display points of same coordinates that are amoung the other layers.<br />
-&quot;full&quot; will display all the layers.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_trunc_labels">trunc_labels</code></td>
<td>
<p>maximum number of characters to display for labels. Default is 38.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_trans">trans</code></td>
<td>
<p>name of the transformation function for density graphs. If missing the default, the BasePop[[1]]$densitytrans, if any, will be retrieved, otherwise &quot;asinh&quot; will be used.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_bin">bin</code></td>
<td>
<p>default number of bin used for histogram. Default is missing.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_viewport">viewport</code></td>
<td>
<p>Either &quot;ideas&quot;, &quot;data&quot; or &quot;max&quot; defining limits used for the graph. Default is &quot;ideas&quot;.<br />
-&quot;ideas&quot; will use same limits as the one defined in ideas.<br />
-&quot;data&quot; will use data to define limits.<br />
-&quot;max&quot; will use data and regions drawn to define limits.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_backend">backend</code></td>
<td>
<p>backend used for drawing. Allowed are &quot;lattice&quot;, &quot;base&quot;, &quot;raster&quot;. Default is &quot;lattice&quot;.<br />
-&quot;lattice&quot; is the original one used in <span class="pkg">IFC</span> using <span class="pkg">lattice</span>,<br />
-&quot;base&quot; will produce the plot using <span class="pkg">base</span>,<br />
-&quot;raster&quot; uses &quot;base&quot; for plotting but 2D graphs points will be produced as <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>.<br />
This has the main advantage of being super fast allowing for plotting a huge amount of points while generating smaller objects (in bytes).
However, plot quality is impacted with &quot;raster&quot; method and resizing can lead to unpleasant looking.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExportToReport_+3A_...">...</code></td>
<td>
<p>other parameters to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>depending on 'write_to', function will create .pdf and/or .csv file(s) report with according to graphs found in 'obj'.<br />
- csv file if created will contain &quot;Min.&quot;,&quot;1st Qu.&quot;,&quot;Median&quot;,&quot;Mean&quot;,&quot;3rd Qu.&quot;,&quot;Max.&quot; for each graph found for x and y (if not histogram) for drawn populations and regions.<br />
- pdf file if created will contain graphs and to a certain extent some stats &quot;Min.&quot;, &quot;Median&quot;, &quot;Mean&quot;, &quot;Max.&quot; (no more than 7 rows).<br />
Note that only graphs will be exported (no images, features values, population stats, ...) in the same layout they were created and without sizing.
</p>


<h3>Value</h3>

<p>It invisibly returns full path of exported .pdf and/or .csv file(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  tmp &lt;- tempdir(check = TRUE)
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf, extract_images = FALSE,
                        extract_offsets = FALSE, display_progress = FALSE)
  L = length(daf$graphs)
  if(L &gt; 0) { 
    ## randomly export at most 5 graphs from daf
    sel = sample(1:L, min(5, L))
    ExportToReport(obj = daf, selection = sel,
                   write_to = paste0(tmp, "\\test.pdf"), overwrite = TRUE)
  }
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='ExportToXIF'>RIF/CIF File Writer</h2><span id='topic+ExportToXIF'></span>

<h3>Description</h3>

<p>Subsets or merges RIF or CIF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExportToXIF(
  fileName,
  write_to,
  objects,
  offsets,
  fast = TRUE,
  extract_features = FALSE,
  endianness = .Platform$endian,
  verbose = FALSE,
  verbosity = 1,
  overwrite = FALSE,
  display_progress = TRUE,
  add_tracking = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExportToXIF_+3A_filename">fileName</code></td>
<td>
<p>path(s) of file(s) to subset or merge.
If multiple files are provided they will be merged. Otherwise, if only one file is input it will be subsetted.
All files have to be either '.rif' or '.cif' files.
All files should have same channels.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of first element of 'fileName'<br />
-%p: with first parent directory of first element of 'fileName'<br />
-%e: with extension of first element of 'fileName' (without leading .)<br />
-%s: with shortname from of first element of 'fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. It has to be the same as 'fileName', i.e. .cif or .rif.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use. If missing, the default, all objects will be used. Only apply for subsetting.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_offsets">offsets</code></td>
<td>
<p>object of class &lsquo;IFC_offset'. If missing, the default, offsets will be extracted from &rsquo;fileName'.<br />
This param is not mandatory but it may allow to save time for repeated XIF export on same file. Only apply for subsetting.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_fast">fast</code></td>
<td>
<p>whether to fast extract 'objects' or not. Default is TRUE.
Meaning that 'objects' will be extracted expecting that 'objects' are stored in ascending order.<br />
Note that a warning will be sent if an 'object' is found at an unexpected order.
In such a case you may need to rerun function with 'fast' = FALSE.
If set to FALSE, all object_ids will be scanned from 'fileName' to ensure extraction of desired 'objects'.<br />
IMPORTANT: whatever this argument is, features are extracted assuming an ascending order of storage in file.<br />
Only apply for subsetting.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_extract_features">extract_features</code></td>
<td>
<p>whether to try to extract features. Default is FALSE.
IMPORTANT: it is not clear if how features are stored and which objects they rely to when input file is already a merge or a subset.
For this reason it should be carefully checked.
Note that features extraction is not implemented for merging.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_endianness">endianness</code></td>
<td>
<p>the endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_verbosity">verbosity</code></td>
<td>
<p>quantity of information displayed when verbose is TRUE; 1: normal, 2: rich. Default is 1.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.<br />
Note that if TRUE, it will overwrite exported file if path(s) of file(s) in 'fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
Otherwise, you will get an error saying that overwriting original file is not allowed.<br /></p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_add_tracking">add_tracking</code></td>
<td>
<p>whether to register files' paths and objects' ids in the exported file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExportToXIF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when 'extract_features' is set TRUE, only features stored in binary format will be extracted if found.<br />
If the input 'fileName' is a merged of several files then features will be extracted from these files.<br />
If these files can't be found, Warning(s) will be thrown and input 'fileName' will be extracted without features values.
</p>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  tmp &lt;- tempdir(check = TRUE)
  ## use a cif file, but you can also subset rif
  file_cif &lt;- system.file("extdata", "example.cif", package = "IFCdata")
  ## subset objects 0,1 and 4 from file
  exported &lt;- ExportToXIF(fileName = file_cif, write_to = paste0(tmp, "\\test.cif"),
                          overwrite = TRUE, objects = c(0,1,4))
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='ExtractFromDAF'>DAF File Reader</h2><span id='topic+ExtractFromDAF'></span>

<h3>Description</h3>

<p>Extracts data from DAF Files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractFromDAF(
  fileName,
  extract_features = TRUE,
  extract_images = TRUE,
  extract_offsets = TRUE,
  extract_stats = TRUE,
  endianness = .Platform$endian,
  pnt_in_poly_algorithm = 1,
  pnt_in_poly_epsilon = 1e-12,
  display_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractFromDAF_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_extract_features">extract_features</code></td>
<td>
<p>whether to extract features (and graphs, pops and regions) from file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_extract_images">extract_images</code></td>
<td>
<p>whether to extract images information from file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_extract_offsets">extract_offsets</code></td>
<td>
<p>whether to extract IFDs offsets from corresponding. Default is TRUE.<br />
See <code><a href="#topic+getOffsets">getOffsets</a></code> for further details.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_extract_stats">extract_stats</code></td>
<td>
<p>whether to extract population statistics. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_pnt_in_poly_algorithm">pnt_in_poly_algorithm</code></td>
<td>
<p>algorithm used to determine if object belongs to a polygon region or not. Default is 1.<br />
Note that for the moment only 1(Trigonometry) is available.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_pnt_in_poly_epsilon">pnt_in_poly_epsilon</code></td>
<td>
<p>epsilon to determine if object belongs to a polygon region or not. It only applies when algorithm is 1. Default is 1e-12.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractFromDAF_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When extract_features is TRUE it allows features, graphs, pops, regions to be extracted.<br />
If extract_features is TRUE, extract_stats will be automatically forced to TRUE.<br />
If extract_stats is TRUE, extract_features will be automatically forced to TRUE.<br />
If extract_offsets is TRUE, extract_images will be automatically forced to TRUE.<br />
If extract_images is TRUE, information about images will be extracted.
</p>


<h3>Value</h3>

<p>A named list of class 'IFC_data', whose members are:<br />
-description, a list of descriptive information,<br />
-fileName, path of fileName input,<br />
-fileName_image, path of .cif image fileName is refering to,<br />
-features, a data.frame of features,<br />
-features_def, a describing how features are defined,<br />
-graphs, a list of graphical elements found,<br />
-pops, a list describing populations found,<br />
-regions, a list describing how regions are defined,<br />
-images, a data.frame describing information about images,<br />
-offsets, an integer vector of images and masks IFDs offsets,<br />
-stats, a data.frame describing populations count and percentage to parent and total population,<br />
-checksum, checksum of .cif image fileName is refering to computed from images values found in current daf.
</p>


<h3>Source</h3>

<p>For pnt_in_poly_algorithm, Trigonometry, is an adaptation of Jeremy VanDerWal's code <a href="https://github.com/jjvanderwal/SDMTools">https://github.com/jjvanderwal/SDMTools</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='ExtractFromFCS'>FCS File Reader</h2><span id='topic+ExtractFromFCS'></span>

<h3>Description</h3>

<p>Extracts data from Flow Cytometry Standard (FCS) Files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractFromFCS(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractFromFCS_+3A_filename">fileName</code></td>
<td>
<p>path(s) of file(s). If multiple files are provided they will be merged and 
populations will be created to identify each single file within returned 'IFC_data' object.</p>
</td></tr>
<tr><td><code id="ExtractFromFCS_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to readFCS function, with the exception of 'options$text_only'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class 'IFC_data', whose members are:<br />
-description, a list of descriptive information,<br />
-Merged_fcs, character vector of path of files used to create fcs, if input was a merged,<br />
-Keywords, a named-list of keywords values, only keywords from 1st 'fcs' segment will be retrieved<br />
-fileName, path of fileName input,<br />
-fileName_image, path of .cif image fileName is referring to,<br />
-features, a data.frame of features,<br />
-features_def, a describing how features are defined,<br />
-graphs, a list of graphical elements found,<br />
-pops, a list describing populations found,<br />
-regions, a list describing how regions are defined,<br />
-images, a data.frame describing information about images,<br />
-offsets, an integer vector of images and masks IFDs offsets,<br />
-stats, a data.frame describing populations count and percentage to parent and total population,<br />
-checksum, a checksum integer.
</p>


<h3>Source</h3>

<p>Data File Standard for Flow Cytometry, version FCS 3.1 from Spidlen J. et al. available at doi: <a href="https://doi.org/10.1002/cyto.a.20825">10.1002/cyto.a.20825</a>.
</p>

<hr>
<h2 id='ExtractFromXIF'>RIF/CIF File Reader</h2><span id='topic+ExtractFromXIF'></span>

<h3>Description</h3>

<p>Extracts data from RIF or CIF Files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractFromXIF(
  fileName,
  extract_features = TRUE,
  extract_images = FALSE,
  extract_offsets = FALSE,
  extract_stats = TRUE,
  pnt_in_poly_algorithm = 1,
  pnt_in_poly_epsilon = 1e-12,
  force_default = TRUE,
  verbose = FALSE,
  verbosity = 1,
  display_progress = TRUE,
  fast = TRUE,
  recursive = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractFromXIF_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_extract_features">extract_features</code></td>
<td>
<p>whether to extract features from file. Default is TRUE.<br />
If TRUE, <code><a href="#topic+ExtractFromXIF">ExtractFromXIF</a></code> will try to export features. It it fails a message will be sent.<br />
Otherwise, graphs, pops and regions will be also extracted.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_extract_images">extract_images</code></td>
<td>
<p>whether to extract images information from file. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_extract_offsets">extract_offsets</code></td>
<td>
<p>whether to extract IFDs offsets from corresponding. Default is FALSE.<br />
See <code><a href="#topic+getOffsets">getOffsets</a></code> for further details.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_extract_stats">extract_stats</code></td>
<td>
<p>whether to extract population statistics. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_pnt_in_poly_algorithm">pnt_in_poly_algorithm</code></td>
<td>
<p>algorithm used to determine if object belongs to a polygon region or not. Default is 1.<br />
Note that for the moment only 1(Trigonometry) is available.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_pnt_in_poly_epsilon">pnt_in_poly_epsilon</code></td>
<td>
<p>epsilon to determine if object belongs to a polygon region or not. It only applies when algorithm is 1. Default is 1e-12.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_force_default">force_default</code></td>
<td>
<p>when display information can't be retrieved whether to use default values. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_verbosity">verbosity</code></td>
<td>
<p>quantity of information displayed when verbose is TRUE; 1: normal, 2: rich. Default is 1.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_fast">fast</code></td>
<td>
<p>whether to fast extract 'objects' or not. Default is TRUE.<br />
Meaning that offsets will be extracted expecting that 'objects' are stored in ascending order.
if extract_images is FALSE, a message will be thrown since extraction method does not ensure correct mapping between objects and offsets.<br />
if extract_images is TRUE, a warning will be sent if an object is found at an unexpected order.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_recursive">recursive</code></td>
<td>
<p>whether to recursively apply <code><a href="#topic+ExtractFromXIF">ExtractFromXIF</a></code> on files defining input fileName when it is a merged. Default is FALSE.</p>
</td></tr>
<tr><td><code id="ExtractFromXIF_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If extract_stats is TRUE, extract_features will be automatically forced to TRUE.<br />
If extract_images is TRUE, extract_offsets will be automatically forced to TRUE.<br />
If extract_offsets is TRUE, offsets of images and masks IFDs will be extracted.<br />
If extract_images is TRUE, information about images will be extracted.<br />
If the input fileName is a merged of several files and recursive is set to TRUE, then ExtractFromXIF will be applied recursively on these files.<br />
/!\ Note that features extraction is mandatory to correctly extract graphs, pops, regions and statistics values.<br />
</p>


<h3>Value</h3>

<p>A named list of class 'IFC_data', whose members are:<br />
-description, a list of descriptive information,<br />
-fileName, path of fileName input,<br />
-fileName_image, same as fileName,<br />
-features, a data.frame of features,<br />
-features_def, a describing how features are defined,<br />
-graphs, a list of graphical elements found,<br />
-pops, a list describing populations found,<br />
-regions, a list describing how regions are defined,<br />
-images, a data.frame describing information about images,<br />
-offsets, an integer vector of images and masks IFDs offsets,<br />
-stats, a data.frame describing populations count and percentage to parent and total population,<br />
-checksum, current file checksum.<br />
If fileName is a merged of several files returned object will be of class 'IFC_data' and 'Merged'.
If recursive is set to &quot;TRUE&quot;, ExtractFromXIF will be applied recursively on files defining the merged.
and the returned object will be a list of the above-mentionned list for each of these files.
</p>


<h3>Source</h3>

<p>For pnt_in_poly_algorithm, Trigonometry, is an adaptation of Jeremy VanDerWal's code <a href="https://github.com/jjvanderwal/SDMTools">https://github.com/jjvanderwal/SDMTools</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a cif file, but you can also read rif
  file_cif &lt;- system.file("extdata", "example.cif", package = "IFCdata")
  cif &lt;- ExtractFromXIF(fileName = file_cif)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='ExtractImages_toBase64'>Shortcut for Batch Images Extraction to Base64</h2><span id='topic+ExtractImages_toBase64'></span>

<h3>Description</h3>

<p>Function to shortcut extraction, normalization and eventually colorization of images to base64 ! excludes mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractImages_toBase64(
  ...,
  objects,
  offsets,
  display_progress = TRUE,
  mode = c("rgb", "gray")[1],
  write_to,
  base64_id,
  base64_att
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractImages_toBase64_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toBase64_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExtractImages_toBase64_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toBase64_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractImages_toBase64_+3A_mode">mode</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) color mode export. Either <code>"rgb"</code>, <code>"gray"</code>. Default is <code>"rgb"</code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toBase64_+3A_write_to">write_to</code></td>
<td>
<p>used to compute respectively exported file name.<br />
Exported base64 data-uri will be deduced from this pattern. Allowed export are <code>".bmp"</code>, <code>".jpg"</code>, <code>".jpeg"</code>, <code>".png"</code>, <code>".tif"</code>, <code>".tiff"</code>.
Note that <code>".bmp"</code> is faster but files are not compressed producing bigger data.<br />
Placeholders, if found, will be substituted:<br />
-<code>%d</code>: with full path directory<br />
-<code>%p</code>: with first parent directory<br />
-<code>%e</code>: with extension (without leading .)<br />
-<code>%s</code>: with shortname (i.e. basename without extension)<br />
-<code>%o</code>: with object_id<br />
-<code>%c</code>: with channel_id<br />
A good trick is to use: <code>"%o_%c.bmp"</code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toBase64_+3A_base64_id">base64_id</code></td>
<td>
<p>whether to add id attribute to base64 exported object.</p>
</td></tr>
<tr><td><code id="ExtractImages_toBase64_+3A_base64_att">base64_att</code></td>
<td>
<p>attributes to add to base64 exported object.<br />
For example, use <code>"class='draggable'"</code>.<br />
Note that <code>id</code> (if <code>'base64_id'</code> is <code>TRUE</code>) and <code>width</code> and <code>height</code> are already used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'param'</code> is provided 'in <code>'...'</code>:<br />
-<code>'param$export'&lt;-"base64"</code> and <code>'param$mode'&lt;-'mode'</code> <strong>only</strong> will be overwritten.<br />
-if <code>'write_to'</code> is not missing, <code>'param$write_to'&lt;-'write_to'</code> will be overwritten. Otherwise, <code>'param$write_to'</code> will be used.<br />
-if <code>'base64_id'</code> is not missing, <code>'param$base64_id'&lt;-'base64_id'</code> will be overwritten. Otherwise, <code>'param$base64_id'</code> will be used.<br />
-if <code>'base64_att'</code> is not missing, <code>'param$base64_att'&lt;-'base64_att'</code> will be overwritten. Otherwise, <code>'param$base64_att'</code> will be used.<br /><br />
When missing and not found <code>'param'</code>, default values will be used for <code>'write_to'</code>(=<strong>&quot;%o_%c.bmp&quot;</strong>), <code>'base64_id'</code>(=<strong>FALSE</strong>) and <code>'base64_att'</code>(=<strong>&quot;&quot;</strong>)
</p>


<h3>Value</h3>

<p>A list of base64 encoded images corresponding to objects extracted.
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExtractImages_toBase64">ExtractImages_toBase64</a></code> input arguments.
</p>

<hr>
<h2 id='ExtractImages_toFile'>Shortcut for Batch Images Extraction to Files</h2><span id='topic+ExtractImages_toFile'></span>

<h3>Description</h3>

<p>Function to shortcut extraction, normalization and eventually colorization of images to file ! excludes mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractImages_toFile(
  ...,
  objects,
  offsets,
  display_progress = TRUE,
  mode = c("rgb", "gray")[1],
  write_to,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractImages_toFile_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toFile_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExtractImages_toFile_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toFile_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractImages_toFile_+3A_mode">mode</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) color mode export. Either <code>"rgb"</code>, <code>"gray"</code>. Default is <code>"rgb"</code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toFile_+3A_write_to">write_to</code></td>
<td>
<p>used to compute respectively exported file name.<br />
Exported <code>"file"</code> extension will be deduced from this pattern. Allowed export are <code>".bmp"</code>, <code>".jpg"</code>, <code>".jpeg"</code>, <code>".png"</code>, <code>".tif"</code>, <code>".tiff"</code>.
Note that <code>".bmp"</code> is faster but files are not compressed producing bigger data.<br />
Placeholders, if found, will be substituted:<br />
-<code>%d</code>: with full path directory<br />
-<code>%p</code>: with first parent directory<br />
-<code>%e</code>: with extension (without leading .)<br />
-<code>%s</code>: with shortname (i.e. basename without extension)<br />
-<code>%o</code>: with object_id<br />
-<code>%c</code>: with channel_id<br />
A good trick is to use: <code>"%d/%s/%s_%o_%c.tiff"</code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toFile_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'param'</code> is provided in <code>'...'</code>:<br />
-<code>'param$export'&lt;-"file"</code>, <code>'param$mode'&lt;-'mode'</code> and <code>'param$overwrite'&lt;-'overwrite'</code> will be overwritten.<br />
-if <code>'write_to'</code> is not missing, <code>'param$write_to'&lt;-'write_to'</code> will be overwritten. Otherwise, <code>'param$write_to'</code> will be used <strong>only</strong> if <code>'param$export'</code> was <code>"file"</code>.<br /><br />
<code>'write_to'</code> has to be provided if <code>'param'</code> can't be found in <code>'...'</code> or if <code>'param$export'</code> was not <code>"file"</code>.
</p>


<h3>Value</h3>

<p>It invisibly returns a list of exported file path of corresponding to objects extracted.
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExtractImages_toFile">ExtractImages_toFile</a></code> input arguments.
</p>

<hr>
<h2 id='ExtractImages_toMatrix'>Shortcut for Batch Images Extraction to Matrices/Arrays</h2><span id='topic+ExtractImages_toMatrix'></span>

<h3>Description</h3>

<p>Function to shortcut extraction, normalization and eventually colorization of images to matrix ! excludes mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractImages_toMatrix(..., objects, offsets, display_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractImages_toMatrix_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toMatrix_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExtractImages_toMatrix_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractImages_toMatrix_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'param'</code> is provided in <code>'...'</code>, <code>'param$export'&lt;-"matrix"</code> <strong>only</strong> will be overwritten.
</p>


<h3>Value</h3>

<p>A list of matrices/arrays of images corresponding to objects extracted.
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExtractImages_toMatrix">ExtractImages_toMatrix</a></code> input arguments.
</p>

<hr>
<h2 id='ExtractMasks_toBase64'>Shortcut for Batch Masks Extraction to Base64</h2><span id='topic+ExtractMasks_toBase64'></span>

<h3>Description</h3>

<p>Function to shortcut extraction, normalization and eventually colorization of masks to base64 ! excludes image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractMasks_toBase64(
  ...,
  objects,
  offsets,
  display_progress = TRUE,
  mode = c("rgb", "gray")[1],
  write_to,
  base64_id,
  base64_att
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractMasks_toBase64_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toBase64_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toBase64_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toBase64_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toBase64_+3A_mode">mode</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) color mode export. Either <code>"rgb"</code>, <code>"gray"</code>. Default is <code>"rgb"</code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toBase64_+3A_write_to">write_to</code></td>
<td>
<p>used to compute respectively exported file name.<br />
Exported base64 data-uri will be deduced from this pattern. Allowed export are <code>".bmp"</code>, <code>".jpg"</code>, <code>".jpeg"</code>, <code>".png"</code>, <code>".tif"</code>, <code>".tiff"</code>.
Note that <code>".bmp"</code> is faster but files are not compressed producing bigger data.<br />
Placeholders, if found, will be substituted:<br />
-<code>%d</code>: with full path directory<br />
-<code>%p</code>: with first parent directory<br />
-<code>%e</code>: with extension (without leading .)<br />
-<code>%s</code>: with shortname (i.e. basename without extension)<br />
-<code>%o</code>: with object_id<br />
-<code>%c</code>: with channel_id<br />
A good trick is to use: <code>"%o_%c.bmp"</code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toBase64_+3A_base64_id">base64_id</code></td>
<td>
<p>whether to add id attribute to base64 exported object.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toBase64_+3A_base64_att">base64_att</code></td>
<td>
<p>attributes to add to base64 exported object.<br />
For example, use <code>"class='draggable'"</code>.<br />
Note that <code>id</code> (if <code>'base64_id'</code> is <code>TRUE</code>) and <code>width</code> and <code>height</code> are already used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'param'</code> is provided 'in <code>'...'</code>:<br />
-<code>'param$export'&lt;-"base64"</code> and <code>'param$mode'&lt;-'mode'</code> <strong>only</strong> will be overwritten.<br />
-if <code>'write_to'</code> is not missing, <code>'param$write_to'&lt;-'write_to'</code> will be overwritten. Otherwise, <code>'param$write_to'</code> will be used.<br />
-if <code>'base64_id'</code> is not missing, <code>'param$base64_id'&lt;-'base64_id'</code> will be overwritten. Otherwise, <code>'param$base64_id'</code> will be used.<br />
-if <code>'base64_att'</code> is not missing, <code>'param$base64_att'&lt;-'base64_att'</code> will be overwritten. Otherwise, <code>'param$base64_att'</code> will be used.<br /><br />
When missing and not found <code>'param'</code>, default values will be used for <code>'write_to'</code>(=<strong>&quot;%o_%c.bmp&quot;</strong>), <code>'base64_id'</code>(=<strong>FALSE</strong>) and <code>'base64_att'</code>(=<strong>&quot;&quot;</strong>)
</p>


<h3>Value</h3>

<p>A list of base64 encoded images corresponding to objects extracted.
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExtractMasks_toBase64">ExtractMasks_toBase64</a></code> input arguments.
</p>

<hr>
<h2 id='ExtractMasks_toFile'>Shortcut for Batch Masks Extraction to Files</h2><span id='topic+ExtractMasks_toFile'></span>

<h3>Description</h3>

<p>Function to shortcut extraction, normalization and eventually colorization of masks to file ! excludes image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractMasks_toFile(
  ...,
  objects,
  offsets,
  display_progress = TRUE,
  mode = c("rgb", "gray")[1],
  write_to,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractMasks_toFile_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toFile_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toFile_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toFile_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toFile_+3A_mode">mode</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) color mode export. Either <code>"rgb"</code>, <code>"gray"</code>. Default is <code>"rgb"</code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toFile_+3A_write_to">write_to</code></td>
<td>
<p>used to compute respectively exported file name.<br />
Exported <code>"file"</code> extension will be deduced from this pattern. Allowed export are <code>".bmp"</code>, <code>".jpg"</code>, <code>".jpeg"</code>, <code>".png"</code>, <code>".tif"</code>, <code>".tiff"</code>.
Note that <code>".bmp"</code> is faster but files are not compressed producing bigger data.<br />
Placeholders, if found, will be substituted:<br />
-<code>%d</code>: with full path directory<br />
-<code>%p</code>: with first parent directory<br />
-<code>%e</code>: with extension (without leading .)<br />
-<code>%s</code>: with shortname (i.e. basename without extension)<br />
-<code>%o</code>: with object_id<br />
-<code>%c</code>: with channel_id<br />
A good trick is to use: <code>"%d/%s/%s_%o_%c.tiff"</code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toFile_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'param'</code> is provided in <code>'...'</code>:<br />
-<code>'param$export'&lt;-"file"</code>, <code>'param$mode'&lt;-'mode'</code> and <code>'param$overwrite'&lt;-'overwrite'</code> will be overwritten.<br />
-if <code>'write_to'</code> is not missing, <code>'param$write_to'&lt;-'write_to'</code> will be overwritten. Otherwise, <code>'param$write_to'</code> will be used <strong>only</strong> if <code>'param$export'</code> was <code>"file"</code>.<br /><br />
<code>'write_to'</code> has to be provided if <code>'param'</code> can't be found in <code>'...'</code> or if <code>'param$export'</code> was not <code>"file"</code>.
</p>


<h3>Value</h3>

<p>It invisibly returns a list of exported file path of corresponding to objects extracted.
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExtractMasks_toFile">ExtractMasks_toFile</a></code> input arguments.
</p>

<hr>
<h2 id='ExtractMasks_toMatrix'>Shortcut for Batch Masks Extraction to Matrices/Arrays</h2><span id='topic+ExtractMasks_toMatrix'></span>

<h3>Description</h3>

<p>Function to shortcut extraction, normalization and eventually colorization of masks to matrix ! excludes image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractMasks_toMatrix(..., objects, offsets, display_progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractMasks_toMatrix_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toMatrix_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toMatrix_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="ExtractMasks_toMatrix_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'param'</code> is provided in <code>'...'</code>, <code>'param$export'&lt;-"matrix"</code> <strong>only</strong> will be overwritten.
</p>


<h3>Value</h3>

<p>A list of matrices/arrays of images corresponding to objects extracted.
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from <code><a href="#topic+ExtractMasks_toMatrix">ExtractMasks_toMatrix</a></code> input arguments.
</p>

<hr>
<h2 id='extractStats'>Statistics Extraction</h2><span id='topic+extractStats'></span>

<h3>Description</h3>

<p>Extracts statistics from 'IFC_data' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractStats(obj, feat_name, trans = "P")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractStats_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object</p>
</td></tr>
<tr><td><code id="extractStats_+3A_feat_name">feat_name</code></td>
<td>
<p>a feature name.</p>
</td></tr>
<tr><td><code id="extractStats_+3A_trans">trans</code></td>
<td>
<p>character string describing transformation used and its parameters. See parseTrans().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with computed statistics.
</p>

<hr>
<h2 id='fastAny'>Any with Rcpp</h2><span id='topic+fastAny'></span>

<h3>Description</h3>

<p>Helper to compute any
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastAny(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastAny_+3A_x">x</code></td>
<td>
<p>either a list or an object coercible to logical matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if <code>'x'</code> is a list it will return any across list members.
if <code>'x'</code> is coercible to a logical matrix, it will return any across matrix rows
</p>


<h3>Value</h3>

<p>a logical vector
</p>

<hr>
<h2 id='fastCbind'>Combine by Columns</h2><span id='topic+fastCbind'></span>

<h3>Description</h3>

<p>Helper to combine by columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastCbind(obj1, obj2, add_id = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastCbind_+3A_obj1">obj1</code></td>
<td>
<p>an object either a data.frame, a list or something coercible to numeric matrix.</p>
</td></tr>
<tr><td><code id="fastCbind_+3A_obj2">obj2</code></td>
<td>
<p>an object either a data.frame, a list or something coercible to numeric matrix.</p>
</td></tr>
<tr><td><code id="fastCbind_+3A_add_id">add_id</code></td>
<td>
<p>a bool determining if 1st column of returned object should be given 1 to nrow integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if obj1 or obj2 is a data.frame returned object will inherit class of obj1 or obj2 respectively in this order.
/!\ if obj1 or obj2 needs to be coerced take care that it can not handle factor during object coercion
</p>


<h3>Value</h3>

<p>a combined object
</p>

<hr>
<h2 id='FCS_check_keywords'>FCS Keyword Checker</h2><span id='topic+FCS_check_keywords'></span>

<h3>Description</h3>

<p>Helper to check that FCS keyword-value pairs are compliant with specifications
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FCS_check_keywords(
  text,
  delimiter,
  version = 3,
  encoding = "UTF-8",
  fun = "warning",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCS_check_keywords_+3A_text">text</code></td>
<td>
<p>a named list of keywords values.</p>
</td></tr>
<tr><td><code id="FCS_check_keywords_+3A_delimiter">delimiter</code></td>
<td>
<p>delimiter used to separate keyword-value pairs. /!\ NOTE that files with 0x00 'delimiter' can _NOT_ be parsed.</p>
</td></tr>
<tr><td><code id="FCS_check_keywords_+3A_version">version</code></td>
<td>
<p>version to check keywords compliance against. Default is 3.0.</p>
</td></tr>
<tr><td><code id="FCS_check_keywords_+3A_encoding">encoding</code></td>
<td>
<p>name of the encoding for raw to character conversion. Default is &quot;UTF-8&quot;.</p>
</td></tr>
<tr><td><code id="FCS_check_keywords_+3A_fun">fun</code></td>
<td>
<p>function to execute when mandatory parameters are not met. Default is &quot;warning&quot;. Allowed are &quot;stop&quot;,&quot;warning&quot;,&quot;message&quot;,&quot;return&quot;.</p>
</td></tr>
<tr><td><code id="FCS_check_keywords_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='FCS_merge_dataset'>FCS Object Data Sets Merging</h2><span id='topic+FCS_merge_dataset'></span>

<h3>Description</h3>

<p>Merges FCS data object with various data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FCS_merge_dataset(fcs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCS_merge_dataset_+3A_fcs">fcs</code></td>
<td>
<p>'IFC_fcs' object as extracted by readFCS().</p>
</td></tr>
<tr><td><code id="FCS_merge_dataset_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>in data can contain extra columns named 'import_file' and 'import_subfile' intended to allow file/dataset identification
</p>


<h3>Value</h3>

<p>a list of list containing:<br />
- header, list of header information corresponding to 'options'<br />
- delimiter, unique character used to separate keyword-value pairs<br />
- text, list of keywords values,<br />
- data, data.frame of values.
</p>

<hr>
<h2 id='FCS_merge_sample'>FCS Object Samples Merging</h2><span id='topic+FCS_merge_sample'></span>

<h3>Description</h3>

<p>Merges FCS data object with various samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FCS_merge_sample(fcs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCS_merge_sample_+3A_fcs">fcs</code></td>
<td>
<p>'IFC_fcs' object as extracted by readFCS().</p>
</td></tr>
<tr><td><code id="FCS_merge_sample_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>in data can contain extra columns named 'import_file' and 'import_subfile' intended to allow file/dataset identification
</p>


<h3>Value</h3>

<p>a list of list containing:<br />
- header, list of header information corresponding to 'options'<br />
- delimiter, unique character used to separate keyword-value pairs<br />
- text, list of keywords values,<br />
- data, data.frame of values.
</p>

<hr>
<h2 id='FCS_to_data'>FCS Object Converter</h2><span id='topic+FCS_to_data'></span>

<h3>Description</h3>

<p>Converts FCS data object to 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FCS_to_data(fcs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FCS_to_data_+3A_fcs">fcs</code></td>
<td>
<p>'IFC_fcs' object as extracted by readFCS().</p>
</td></tr>
<tr><td><code id="FCS_to_data_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>in data can contain extra columns named 'import_file' and 'import_subfile' intended to allow file/dataset identification
</p>


<h3>Value</h3>

<p>A named list of class 'IFC_data', whose members are:<br />
-description, a list of descriptive information,<br />
-Merged_fcs, character vector of path of files used to create fcs, if input was a merged,<br />
-Keywords, a named-list of keywords values, only keywords from 1st 'fcs' segment will be retrieved<br />
-fileName, path of fileName input,<br />
-fileName_image, path of .cif image fileName is referring to,<br />
-features, a data.frame of features,<br />
-features_def, a describing how features are defined,<br />
-graphs, a list of graphical elements found,<br />
-pops, a list describing populations found,<br />
-regions, a list describing how regions are defined,<br />
-images, a data.frame describing information about images,<br />
-offsets, an integer vector of images and masks IFDs offsets,<br />
-stats, a data.frame describing populations count and percentage to parent and total population,<br />
-checksum, a checksum integer.
</p>

<hr>
<h2 id='feature_namer'>Feature Default Name Computation</h2><span id='topic+feature_namer'></span>

<h3>Description</h3>

<p>Helper to compute default name of a feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feature_namer(feat_def)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="feature_namer_+3A_feat_def">feat_def</code></td>
<td>
<p>list containing feature definition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string with default name
</p>

<hr>
<h2 id='featureIFC'>List IFC features</h2><span id='topic+featureIFC'></span>

<h3>Description</h3>

<p>Helper to give the list of available features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>featureIFC()
</code></pre>


<h3>Value</h3>

<p>a list of all features
</p>

<hr>
<h2 id='fetch_seed'>Seed Instructions Extraction</h2><span id='topic+fetch_seed'></span>

<h3>Description</h3>

<p>Retrieve seed instructions from input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch_seed(seed = NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_seed_+3A_seed">seed</code></td>
<td>
<p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL. NA_integer_ or list(seed = NA_integer_) can be used to prevent 'seed' argument from being passed to <a href="base.html#topic+set.seed">set.seed</a>. Default is NA_integer_.</p>
</td></tr>
</table>

<hr>
<h2 id='formatn'>File Path Placeholders Formatting</h2><span id='topic+formatn'></span>

<h3>Description</h3>

<p>Helper to format splitp_obj using splitf_obj, channel and object information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>formatn(splitp_obj, splitf_obj, channel = "", object = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formatn_+3A_splitp_obj">splitp_obj</code></td>
<td>
<p>object returned by <code><a href="#topic+splitp">splitp</a></code>.</p>
</td></tr>
<tr><td><code id="formatn_+3A_splitf_obj">splitf_obj</code></td>
<td>
<p>object returned by <code><a href="#topic+splitf">splitf</a></code>. It will be used to substitute %d, %p, %s and %e.</p>
</td></tr>
<tr><td><code id="formatn_+3A_channel">channel</code></td>
<td>
<p>string to be used to substitute %c</p>
</td></tr>
<tr><td><code id="formatn_+3A_object">object</code></td>
<td>
<p>string to be used to substitute %o</p>
</td></tr>
</table>

<hr>
<h2 id='fromXML2_gating'>GatingML Conversion from XML2</h2><span id='topic+fromXML2_gating'></span>

<h3>Description</h3>

<p>Helper to convert boolean and graphical pops and corresponding regions from XML nodes in GatingML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fromXML2_gating(xml_nodes, type = "rect")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fromXML2_gating_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>a set of xml_nodes</p>
</td></tr>
<tr><td><code id="fromXML2_gating_+3A_type">type</code></td>
<td>
<p>type of the gate to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of:<br />
-region, region information<br />
-pop, population information
</p>

<hr>
<h2 id='gen_altnames'>Alternative Names Generator</h2><span id='topic+gen_altnames'></span>

<h3>Description</h3>

<p>Generates unique non matching alternative names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_altnames(
  x,
  n = 10,
  forbidden = character(),
  random_seed = list(seed = 252, "Mersenne-Twister", "Inversion", "Rounding")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_altnames_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
<tr><td><code id="gen_altnames_+3A_n">n</code></td>
<td>
<p>number of characters of the desired returned name. Default is 10.</p>
</td></tr>
<tr><td><code id="gen_altnames_+3A_forbidden">forbidden</code></td>
<td>
<p>forbidden character vector. Default is character().</p>
</td></tr>
<tr><td><code id="gen_altnames_+3A_random_seed">random_seed</code></td>
<td>
<p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL.
Default is list(seed = 0xFC, &quot;Mersenne-Twister&quot;, &quot;Inversion&quot;, &quot;Rounding&quot;).
Note that NA_integer_ or list(seed = NA_integer_) can be used to not call <a href="base.html#topic+set.seed">set.seed</a> at all.
Note also that the default is chosen because it is compatible with old R version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'forbidden' should not encompass all possible returned value otherwise the function will never end.
</p>


<h3>Value</h3>

<p>a character vector.
</p>

<hr>
<h2 id='get_coordmap_adjusted'>Device Adjusted Coordinates</h2><span id='topic+get_coordmap_adjusted'></span>

<h3>Description</h3>

<p>Helper to extract current device plotting region adjusted to device size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_coordmap_adjusted(
  coordmap,
  width = grDevices::dev.size("px")[1],
  height = grDevices::dev.size("px")[2],
  ratio = graphics::par("din")/graphics::par("pin")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_coordmap_adjusted_+3A_coordmap">coordmap</code></td>
<td>
<p>current device plotting region. Default is missing.</p>
</td></tr>
<tr><td><code id="get_coordmap_adjusted_+3A_width">width</code></td>
<td>
<p>current device height in pixel. Default is grDevices::dev.size(&quot;px&quot;)[1].</p>
</td></tr>
<tr><td><code id="get_coordmap_adjusted_+3A_height">height</code></td>
<td>
<p>current device width in pixel. Default is grDevices::dev.size(&quot;px&quot;)[2].</p>
</td></tr>
<tr><td><code id="get_coordmap_adjusted_+3A_ratio">ratio</code></td>
<td>
<p>current device ratio. Default is graphics::par('din') / graphics::par('pin').</p>
</td></tr>
</table>


<h3>Source</h3>

<p>computes drawing region in a similar way as shiny:::getPrevPlotCoordmap()
</p>

<hr>
<h2 id='get_coordmap_raw'>Device Raw Coordinates</h2><span id='topic+get_coordmap_raw'></span>

<h3>Description</h3>

<p>Helper to extract current device plotting region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_coordmap_raw()
</code></pre>


<h3>Source</h3>

<p>computes drawing region in a similar way as shiny:::getPrevPlotCoordmap()
</p>

<hr>
<h2 id='get_feat_value'>Feature Values Computation</h2><span id='topic+get_feat_value'></span>

<h3>Description</h3>

<p>Computes feature values from feature definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_feat_value(
  feat_def,
  features,
  alt_names,
  operators = c("+", "-", "*", "/", "(", ")", "ABS", "COS", "SIN", "SQR", "SQRT"),
  split = "|"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_feat_value_+3A_feat_def">feat_def</code></td>
<td>
<p>a feature definition as created by <code><a href="#topic+buildFeature">buildFeature</a></code>.</p>
</td></tr>
<tr><td><code id="get_feat_value_+3A_features">features</code></td>
<td>
<p>a data.frame of features, typically an object of class 'IFC_features'.</p>
</td></tr>
<tr><td><code id="get_feat_value_+3A_alt_names">alt_names</code></td>
<td>
<p>vector of same length as features to use for substitution. It can be used to speed up the process.</p>
</td></tr>
<tr><td><code id="get_feat_value_+3A_operators">operators</code></td>
<td>
<p>operators used. Default is c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;(&quot;, &quot;)&quot;, &quot;ABS&quot;, &quot;COS&quot;, &quot;SIN&quot;, &quot;SQR&quot;, &quot;SQRT&quot;).</p>
</td></tr>
<tr><td><code id="get_feat_value_+3A_split">split</code></td>
<td>
<p>string used for splitting. Default is &quot;|&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if 'feat_def$type' is &quot;combined&quot; returned value will be computed according in the scope of 'features' according to 'feat_def$def'.
Otherwise, 'feat_def$name' will be searched in 'features' to return value, and if not found 'feat_def$val' will be returned.
</p>


<h3>Value</h3>

<p>a vector of feature values.
</p>

<hr>
<h2 id='get_pops_stats'>Statistics Extraction from Populations</h2><span id='topic+get_pops_stats'></span>

<h3>Description</h3>

<p>Extracts populations statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pops_stats(pops, objcount = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pops_stats_+3A_pops">pops</code></td>
<td>
<p>list of populations</p>
</td></tr>
<tr><td><code id="get_pops_stats_+3A_objcount">objcount</code></td>
<td>
<p>total number of objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with computed statistics.
</p>

<hr>
<h2 id='get_ylim'>Histogram y-Axis Limits Constructor</h2><span id='topic+get_ylim'></span>

<h3>Description</h3>

<p>Helper to extract ylim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ylim(x, type, br, include.lowest = TRUE, right = TRUE)
</code></pre>


<h3>Source</h3>

<p>derived from <span class="pkg">lattice</span> from Deepayan Sarkar
</p>

<hr>
<h2 id='getAborted'>Aborted Batch Files Retrieval</h2><span id='topic+getAborted'></span>

<h3>Description</h3>

<p>Try to retrieve files whose processing failed during batch. This is a very beta version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAborted(aborted, default_batch_dir, config_file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAborted_+3A_aborted">aborted</code></td>
<td>
<p>path to file containing aborted information.<br />
If missing, the default, a dialog box will be displayed to choose this file.
Note, that if provided 'default_batch_dir' and 'config_file' will not be used.</p>
</td></tr>
<tr><td><code id="getAborted_+3A_default_batch_dir">default_batch_dir</code></td>
<td>
<p>directory where batches are stored.<br />
It can be found in IDEAS(R) software, under Options -&gt; Application Defaults -&gt; Directories -&gt; Default Batch Report Files Directory.
If missing, the default, it will be deduced from IDEAS(R) config file, However, if it can't be deduced then current working directory will be used.<br />
This argument takes precedence over 'config_file' and filling 'default_batch_dir' prevents the use of 'config_file' argument.</p>
</td></tr>
<tr><td><code id="getAborted_+3A_config_file">config_file</code></td>
<td>
<p>path to IDEAS(R) config file.<br />
It may depends on IDEAS(R) software installation but one may use &quot;C:/Users/%USER%/AppData/Roaming/Amnis Corporation/userconfig.xml&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 4 elements:<br />
-not_existing: a list of files paths that caused failure because they were not found during batch,<br />
-not_handled: a list of failed files and the retrieved error message.<br />
-failed_found: a list of failed files and their unique corresponding paths,<br />
-failed_match: a list of failed files and their all paths that could match.
</p>

<hr>
<h2 id='getASSIST'>ASSIST Database Extraction</h2><span id='topic+getASSIST'></span>

<h3>Description</h3>

<p>Retrieves ASSIST tests values stored within .cif / .rif files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getASSIST(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getASSIST_+3A_filename">fileName</code></td>
<td>
<p>path to file..</p>
</td></tr>
<tr><td><code id="getASSIST_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class 'IFC_assist' of parsed ASSIST tests database.
</p>

<hr>
<h2 id='getFeaturesValues'>Features Values Extraction</h2><span id='topic+getFeaturesValues'></span>

<h3>Description</h3>

<p>Extracts features values according to features definitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFeaturesValues(
  features,
  features_def,
  operators = c("+", "-", "*", "/", "(", ")", "ABS", "COS", "SIN", "SQR", "SQRT"),
  split = "|",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFeaturesValues_+3A_features">features</code></td>
<td>
<p>a data.frame of features, typically an object of class 'IFC_features'.</p>
</td></tr>
<tr><td><code id="getFeaturesValues_+3A_features_def">features_def</code></td>
<td>
<p>a list of features definitions, typically an object of class 'IFC_features_def'.</p>
</td></tr>
<tr><td><code id="getFeaturesValues_+3A_operators">operators</code></td>
<td>
<p>operators used. Default is c(&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, &quot;(&quot;, &quot;)&quot;, &quot;ABS&quot;, &quot;COS&quot;, &quot;SIN&quot;, &quot;SQR&quot;, &quot;SQRT&quot;).</p>
</td></tr>
<tr><td><code id="getFeaturesValues_+3A_split">split</code></td>
<td>
<p>string used for splitting. Default is &quot;|&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame of features values.
</p>

<hr>
<h2 id='getFileExt'>File Extension Retrieval</h2><span id='topic+getFileExt'></span>

<h3>Description</h3>

<p>Determines extension from alpha numeric file name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFileExt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFileExt_+3A_x">x</code></td>
<td>
<p>path to file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the file extension in lower case if found. Otherwise, &quot;&quot;.
</p>


<h3>Source</h3>

<p>derived from file_ext() in <span class="pkg">tools</span>, R Core Team, Kurt Hornik and Friedrich Leisch.
</p>

<hr>
<h2 id='getFullTag'>Image Field Directory Full Tag Retrieval</h2><span id='topic+getFullTag'></span>

<h3>Description</h3>

<p>Retrieves full tag value from IFDs (Image Field Directory) extracted by <code><a href="#topic+getIFD">getIFD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFullTag(IFD, which = 1, tag = "256", raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFullTag_+3A_ifd">IFD</code></td>
<td>
<p>an object of class 'IFC_ifd_list' extracted by <code><a href="#topic+getIFD">getIFD</a></code>.</p>
</td></tr>
<tr><td><code id="getFullTag_+3A_which">which</code></td>
<td>
<p>scalar, integer (index) or the name of 'IFD' sub-element to extract 'tag' from. Default is 1 to extract 'tag' from the first member of 'IFD'.</p>
</td></tr>
<tr><td><code id="getFullTag_+3A_tag">tag</code></td>
<td>
<p>scalar, integer (index) or the name of the IFD[[which]] of the desired 'tag'.</p>
</td></tr>
<tr><td><code id="getFullTag_+3A_raw">raw</code></td>
<td>
<p>whether to return tag as a raw vector. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It may be usefull to extract all information contained in a specific 'tag' since <code><a href="#topic+getIFD">getIFD</a></code> is designed to be run with argument trunc_bytes so as to only extract essential bytes to run faster and save memory.
Nonetheless, thanks to <code><a href="#topic+getFullTag">getFullTag</a></code> users will still be able to get full extraction of specific tag.
</p>


<h3>Value</h3>

<p>the full value of the corresponding IFD tag.
</p>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>

<hr>
<h2 id='getIFD'>RIF/CIF Image Field Directories Extraction</h2><span id='topic+getIFD'></span>

<h3>Description</h3>

<p>Extracts IFDs (Image File Directory) in RIF or CIF files.<br />
IFDs contain information about images or masks of objects stored within XIF files.<br />
The first IFD is special in that it does not contain image of mask information but general information about the file.<br />
Users are highly encouraged to read TIFF specifications to have a better understanding about what IFDs are.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getIFD(
  fileName,
  offsets = "first",
  trunc_bytes = 12,
  force_trunc = FALSE,
  verbose = FALSE,
  verbosity = 1,
  display_progress = FALSE,
  bypass = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getIFD_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_offsets">offsets</code></td>
<td>
<p>either &quot;all&quot;, &quot;first&quot; or an object of class 'IFC_offset'. Default is &quot;first&quot;.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_trunc_bytes">trunc_bytes</code></td>
<td>
<p>a positive integer maximal number of individual scalar to extract BYTE/ASCII/SBYTE/UNDEFINED for TAGS (1, 2, 6 or 7). Default is 12.<br />
However, if less is found, less is returned in map. 
Note that, if 0 is provided, it will be automatically set to 1.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_force_trunc">force_trunc</code></td>
<td>
<p>whether to force truncation for all TAGS types. Default is FALSE.<br />
If TRUE, 'trunc_bytes' will be used for TAGS (3, 4, 5, 8, 9, 10, 11 and 12) to extract desired number of individual scalar corresponding to each types.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_verbosity">verbosity</code></td>
<td>
<p>quantity of information displayed when verbose is TRUE; 1: normal, 2: rich. Default is 1.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is FALSE.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_bypass">bypass</code></td>
<td>
<p>whether to bypass checks on 'trunc_bytes', 'force_trunc', 'verbose', 'verbosity' and 'display_progress'. Default is FALSE.</p>
</td></tr>
<tr><td><code id="getIFD_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function will return IFDs (image, mask or first) from the file using provided offsets argument.<br />
IFDs contain several tags that can be viewed as descriptive meta-information of raw data stored within RIF or CIF file. For more details see TIFF specifications.<br />
If 'offsets' == &quot;first&quot; only first IFD will be returned.<br />
If 'offsets' == &quot;all&quot; all images and masks IFDs will be returned but not &quot;first&quot; one.
Be aware that errors may occur if offsets are not extracted with <code><a href="#topic+getOffsets">getOffsets</a></code> or <code><a href="#topic+subsetOffsets">subsetOffsets</a></code>.
</p>


<h3>Value</h3>

<p>A list of named lists, each containing:<br />
-tags, a named list whose names are tags found, where each tag is a list of tag, typ, siz, val, byt, len, off, map information.<br />
-infos, a named list containing essential information about IFDs,
IMAGE_LENGTH, IMAGE_WIDTH, OBJECT_ID, COMPRESSION,
TYPE, STRIP_OFFSETS, STRIP_BYTE_COUNTS,
BG_MEAN, BG_STD<br />
-curr_IFD_offset, the position of current IFD offset<br />
-next_IFD_offset, the position of next IFD offset
</p>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a cif file
  file_cif &lt;- system.file("extdata", "example.cif", package = "IFCdata")
  ## read 1st IFD
  IFD_first &lt;- getIFD(fileName = file_cif, offsets = "first")
  ## show information contained in 1st IFD
  print(sapply(IFD_first[[1]]$tags, FUN=function(x) x)) 
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='getImagesValues'>RIF/CIF Image Values Extraction</h2><span id='topic+getImagesValues'></span>

<h3>Description</h3>

<p>Extracts the image values from RIF or CIF as what can be found in DAF files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getImagesValues(
  fileName,
  offsets,
  objects,
  display_progress = FALSE,
  fast = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getImagesValues_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="getImagesValues_+3A_offsets">offsets</code></td>
<td>
<p>Object of class &lsquo;IFC_offset'. If missing, the default, &rsquo;offsets' will be extracted from 'fileName'.<br />
This param is not mandatory but it may allow to save time when exporting repeated image value on same file.</p>
</td></tr>
<tr><td><code id="getImagesValues_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to extract.<br />
If missing, the default, images values from all objects will be extracted.</p>
</td></tr>
<tr><td><code id="getImagesValues_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is FALSE.</p>
</td></tr>
<tr><td><code id="getImagesValues_+3A_fast">fast</code></td>
<td>
<p>when no 'offsets' are provided whether to fast extract 'objects' or not. Default is TRUE.<br />
Meaning that 'objects' will be extracted expecting that 'objects' are stored in ascending order.<br />
Only apply when 'offsets' are not provided.<br />
Note that a warning will be sent if an object is found at an unexpected order.</p>
</td></tr>
<tr><td><code id="getImagesValues_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame is returned.
</p>

<hr>
<h2 id='getInfo'>IFC File Information Extraction</h2><span id='topic+getInfo'></span>

<h3>Description</h3>

<p>Retrieves rich information from RIF, CIF and DAF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getInfo(
  fileName,
  from = c("acquisition", "analysis")[2],
  verbose = FALSE,
  verbosity = 1,
  warn = TRUE,
  force_default = TRUE,
  cifdir = dirname(fileName),
  ntry = +Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getInfo_+3A_filename">fileName</code></td>
<td>
<p>path to file..</p>
</td></tr>
<tr><td><code id="getInfo_+3A_from">from</code></td>
<td>
<p>whether to extract information from 'acquisition' or 'analysis'. Default is 'analysis'.</p>
</td></tr>
<tr><td><code id="getInfo_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="getInfo_+3A_verbosity">verbosity</code></td>
<td>
<p>quantity of information print to console when verbose is TRUE; 1: normal, 2: rich. Default is 1.</p>
</td></tr>
<tr><td><code id="getInfo_+3A_warn">warn</code></td>
<td>
<p>whether to send warning message when trying to read 'analysis' information from a 'rif' file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="getInfo_+3A_force_default">force_default</code></td>
<td>
<p>when display information can't be retrieved whether to use default values. Default is TRUE.</p>
</td></tr>
<tr><td><code id="getInfo_+3A_cifdir">cifdir</code></td>
<td>
<p>the path of the directory to initially look to cif file. Default is dirname(fileName). Only apply when 'fileName' is a .daf file.</p>
</td></tr>
<tr><td><code id="getInfo_+3A_ntry">ntry</code></td>
<td>
<p>number of times <code><a href="#topic+getInfo">getInfo</a></code> will be allowed to find corresponding cif file. Default is +Inf. Only apply when 'fileName' is a .daf file.
If cif can't be found, but 'ntry' is reached, then an error will be thrown.</p>
</td></tr>
<tr><td><code id="getInfo_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of information (open .daf file in an text editor for more details) about input fileName of class 'IFC_info' and 'acquistion' or 'analysis', whose members are:<br />
-objcount, number of object in file,<br />
-date, date of file creation,<br />
-instrument, instrument identification,<br />
-sw_raw, version of software for raw data,<br />
-sw_processed, version of software for processed data,<br />
-channelwidth, default channel width in pixel,<br />
-in_use, channels used,<br />
-brightfield, whether brightfield is applied on channels and its intensity,<br />
-illumination, laser illumination parameters,<br />
-collectionmode, the collection mode,<br />
-magnification, magnification used,<br />
-coremode, the core mode,<br />
-evmode, the high gain mode,<br />
-CrossTalkMatrix. compensation matrix applied,<br />
-ChannelPresets, channel preset,<br />
-ImageDisplaySettings, image display settings,<br />
-Images, information about colors, range and channels,<br />
-masks, masks defined,<br />
-ViewingModes, modes of visualization,<br />
-checksum, checksum computed,<br />
-Merged_rif, character vector of path of files used to create rif, if input file was a merged,<br />
-Merged_cif, character vector of path of files used to create cif, if input file was a merged,<br />
-XIF_test, integer defining XIF type,<br />
-checksum, integer corresponding to file checksum,<br />
-fileName, path of fileName input,<br />
-fileName_image, path of fileName_image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  info &lt;- getInfo(fileName = file_daf, from = "analysis")
  ## show some information
  print(info$Images)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='getLuminance'>Luminance Computation</h2><span id='topic+getLuminance'></span>

<h3>Description</h3>

<p>Determines color's luminance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLuminance(color)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLuminance_+3A_color">color</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>

<hr>
<h2 id='getOffsets'>RIF/CIF File Image Field Directories Offsets Extraction</h2><span id='topic+getOffsets'></span>

<h3>Description</h3>

<p>Extracts offsets of the IFDs (Image Field Directories) within a XIF file.
Users are highly encouraged to read TIFF specifications to have a better understanding about what offsets and IFDs are.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOffsets(fileName, fast = TRUE, display_progress = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOffsets_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="getOffsets_+3A_fast">fast</code></td>
<td>
<p>whether to fast extract 'objects' or not. Default is TRUE.<br />
Meaning that offsets will be extracted expecting that 'objects' are stored in ascending order.<br />
A message will be thrown since fast extraction method does not ensure correct mapping between objects and offsets.<br />
If set to FALSE, all object_ids will be scanned from 'fileName' to ensure extraction of desired offsets.</p>
</td></tr>
<tr><td><code id="getOffsets_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="getOffsets_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Offsets are byte positions of IFDs found within RIF or CIF file. For more details see TIFF specifications.
</p>


<h3>Value</h3>

<p>an integer vector of class 'IFC_offset' of IFDs offsets found in XIF file.
</p>


<h3>Source</h3>

<p>TIFF 6.0 specifications archived from web <a href="https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html">https://web.archive.org/web/20211209104854/https://www.adobe.io/open/standards/TIFF.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a cif file
  file_cif &lt;- system.file("extdata", "example.cif", package = "IFCdata")
  system.time(offsets_fast &lt;- getOffsets(fileName = file_cif, fast = TRUE))
  system.time(offsets_slow &lt;- getOffsets(fileName = file_cif, fast = FALSE))
  identical(offsets_fast, offsets_slow)   
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='getSTATSREPORT'>Statistics Report Template Extraction</h2><span id='topic+getSTATSREPORT'></span>

<h3>Description</h3>

<p>Retrieves statistics report template from .ast / .daf files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSTATSREPORT(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSTATSREPORT_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Allowed <code>'statistics'</code> names are: <code>"Count"</code>,<code>"Mean"</code>,<code>"%Total"</code>,<code>"%Gated"</code>,<code>"%"</code>,<code>"Objects/mL"</code>,<code>"RD - Mean"</code>,
<code>"Median"</code>,<code>"CV"</code>,<code>"stddev"</code>,<code>"NaN"</code>,<code>"MAD"</code>,<code>"min"</code>,<code>"RD - Median"</code>,<code>"Variance"</code>,<code>"max"</code>,<code>"geomean"</code>,<code>"Mode"</code>.<br />
For <code>"%Total"</code>,<code>"%Gated"</code>,<code>"%"</code>,<code>"RD - Mean"</code>,<code>"RD - Median"</code>, <code>'type'</code> has to be <code>"ratio"</code> and both <code>'population1'</code>
and <code>'population2'</code> should be provided. Otherwise, <code>'type'</code> is <code>"value"</code> and only <code>'population1'</code> is mandatory.<br />
<strong>/!\</strong> Note that <code>"Mode"</code> and <code>"Objects/mL"</code> can't be determined and will result in <code>NA</code>.
</p>


<h3>Value</h3>

<p>a 6-columns character matrix describing report instructions:<br />
- <code>'name'</code>, for the desired name of exported <code>'statistics'</code>,<br />
- <code>'type'</code>, for the type of stats to return (either <code>"value"</code> or <code>"ratio"</code>),<br />
- <code>'population1'</code>, determines the population on which <code>'statistics'</code> will be performed,<br />
- <code>'population2'</code>, determines the reference population (when <code>'type'</code> is <code>"ratio"</code>, see <strong>Details</strong>),<br />
- <code>'feature'</code>, determines the feature's name on which <code>'statistics'</code> will be computed,<br />
- <code>'statistics'</code>, controls the mathematical function that will be applied (see <strong>Details</strong>).
</p>

<hr>
<h2 id='group'>Groups Combination</h2><span id='topic+group'></span>

<h3>Description</h3>

<p>Combines data.frame groups into a unique one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group(df, collapse = ".", keepNAlevels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_+3A_df">df</code></td>
<td>
<p>a data.frame whose columns represent grouping factor.</p>
</td></tr>
<tr><td><code id="group_+3A_collapse">collapse</code></td>
<td>
<p>a string used to collapse groups levels.</p>
</td></tr>
<tr><td><code id="group_+3A_keepnalevels">keepNAlevels</code></td>
<td>
<p>whether to keep NA levels resulting from groups merging</p>
</td></tr>
<tr><td><code id="group_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list containing row indices of grouping combinations.
</p>

<hr>
<h2 id='gseq'>String Sequence Replacement</h2><span id='topic+gseq'></span>

<h3>Description</h3>

<p>Replaces a sequence of strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gseq(x, pattern = "", replacement = character(), all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gseq_+3A_x">x</code>, <code id="gseq_+3A_pattern">pattern</code>, <code id="gseq_+3A_replacement">replacement</code></td>
<td>
<p>non empty character vectors.</p>
</td></tr>
<tr><td><code id="gseq_+3A_all">all</code></td>
<td>
<p>whether to replace all instances of 'pattern' or only the 1st one. Default is TRUE, to replace all instances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if 'pattern' is found within 'x', 'pattern' will be removed from 'x' and replace by 'replacement'.<br />
It looks like gsub but it is different e.g.:<br />
x=c(&quot;ABD&quot;,&quot;A&quot;,&quot;B&quot;)<br />
pattern=c(&quot;A&quot;,&quot;B&quot;)<br />
replacement=c(&quot;C&quot;)<br />
- gsub(x=paste0(x,collapse=&quot;&quot;),pattern=paste0(pattern,collapse=&quot;&quot;),replacement=paste0(replacement,collapse=&quot;&quot;),fixed=TRUE) will give &quot;CDC&quot;,<br />
- gseq(x=x,pattern=pattern,replacement=replacement) will give &quot;ABD&quot;,&quot;C&quot;.
</p>


<h3>Value</h3>

<p>'x' where 'pattern' is replaced by replacement.
</p>

<hr>
<h2 id='hist_constr'>Histogram Constructor</h2><span id='topic+hist_constr'></span>

<h3>Description</h3>

<p>Helper to construct histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_constr(x, breaks, include.lowest = TRUE, right = TRUE, ...)
</code></pre>

<hr>
<h2 id='IFC-package'>Tools for Imaging Flow Cytometry</h2><span id='topic+IFC-package'></span><span id='topic+IFC'></span>

<h3>Description</h3>

<p>Contains several tools to treat Imaging Flow Cytometry data from ImageStream(R) and FlowSight(R) cytometers (Amnis(R) Cytek(R)). Provides an easy and simple way to read or write .fcs, .rif, .cif and .daf files. Information such as masks, features, regions and populations set within these files can be retrieved for each single cell. In addition, raw data such as images stored can also be accessed. Users, may hopefully increase their productivity thanks to dedicated functions to extract, visualize, manipulate and export IFC data.
</p>


<h3>Details</h3>

<p>The IFC package provides several categories of functions:<br />
- to read / write / export / visualize:<br />
<code><a href="#topic+readIFC">readIFC</a></code>, <code><a href="#topic+writeIFC">writeIFC</a></code>, <code><a href="#topic+ExtractFromDAF">ExtractFromDAF</a></code>, <code><a href="#topic+ExportToDAF">ExportToDAF</a></code>, <code><a href="#topic+data_to_DAF">data_to_DAF</a></code>, <code><a href="#topic+ExtractFromXIF">ExtractFromXIF</a></code>, <code><a href="#topic+ExportToXIF">ExportToXIF</a></code>, <code><a href="#topic+ExtractFromFCS">ExtractFromFCS</a></code>, <code><a href="#topic+ExportToFCS">ExportToFCS</a></code>, <code><a href="#topic+ExportToBATCH">ExportToBATCH</a></code>, <code><a href="#topic+BatchReport">BatchReport</a></code>, <code><a href="#topic+ExportToReport">ExportToReport</a></code>, <code><a href="#topic+ExportToGallery">ExportToGallery</a></code>, <code><a href="#topic+ExportToNumpy">ExportToNumpy</a></code>, <code><a href="#topic+DisplayGallery">DisplayGallery</a></code>, <code><a href="#topic+ExtractImages_toBase64">ExtractImages_toBase64</a></code>, <code><a href="#topic+ExtractImages_toFile">ExtractImages_toFile</a></code>, <code><a href="#topic+ExtractImages_toMatrix">ExtractImages_toMatrix</a></code>, <code><a href="#topic+ExtractMasks_toMatrix">ExtractMasks_toMatrix</a></code>, <code><a href="#topic+objectExtract">objectExtract</a></code>, <code><a href="#topic+popsNetwork">popsNetwork</a></code>, <code><a href="#topic+plotGraph">plotGraph</a></code>, <code><a href="#topic+paletteIFC">paletteIFC</a></code>, <code><a href="#topic+autoplot">autoplot</a></code><br />
- to transform features values<br />
<code><a href="#topic+smoothLinLog">smoothLinLog</a></code>, <code><a href="#topic+inv_smoothLinLog">inv_smoothLinLog</a></code><br />
- to deeply extract information from files:<br />
<code><a href="#topic+getInfo">getInfo</a></code>, <code><a href="#topic+getOffsets">getOffsets</a></code>, <code><a href="#topic+getIFD">getIFD</a></code>, <code><a href="#topic+getFullTag">getFullTag</a></code>, <code><a href="#topic+getAborted">getAborted</a></code><br />
- dedicated to populations:<br />
<code><a href="#topic+popsCopy">popsCopy</a></code>, <code><a href="#topic+popsGetObjectsIds">popsGetObjectsIds</a></code>, <code><a href="#topic+popsNetwork">popsNetwork</a></code>, <code><a href="#topic+popsRename">popsRename</a></code><br />
- for adding  / removing features, regions, populations:<br />
<code><a href="#topic+data_add_features">data_add_features</a></code>, <code><a href="#topic+data_add_regions">data_add_regions</a></code>, <code><a href="#topic+data_add_pops">data_add_pops</a></code>, <code><a href="#topic+data_rm_features">data_rm_features</a></code>, <code><a href="#topic+data_rm_regions">data_rm_regions</a></code>, <code><a href="#topic+data_rm_pops">data_rm_pops</a></code><br />
- to allow several coercion:<br />
<code><a href="#topic+buildBatch">buildBatch</a></code>, <code><a href="#topic+buildFeature">buildFeature</a></code>, <code><a href="#topic+buildGraph">buildGraph</a></code>, <code><a href="#topic+buildPopulation">buildPopulation</a></code>, <code><a href="#topic+buildRegion">buildRegion</a></code>
</p>


<h3>Author(s)</h3>

<p>Maintainer: Yohann Demont &lt;git.demont@gmail.com&gt;
</p>

<hr>
<h2 id='inv_colConv'>Hexadecimal to Integer Color Conversion</h2><span id='topic+inv_colConv'></span>

<h3>Description</h3>

<p>Helper to convert color from hex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_colConv(col)
</code></pre>

<hr>
<h2 id='inv_smoothAsinh'>Inverse Smooth Asinh Transformation</h2><span id='topic+inv_smoothAsinh'></span>

<h3>Description</h3>

<p>Gets values back just to their original values before applying smoothAsinh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_smoothAsinh(x, hyper = 1000)
</code></pre>

<hr>
<h2 id='inv_smoothLinLog'>Inverse Smooth LinLog Transformation</h2><span id='topic+inv_smoothLinLog'></span>

<h3>Description</h3>

<p>Gets values back just to their original values before applying smoothLinLog.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_smoothLinLog(x, hyper = 1000, base = 10, lin_comp = log(base))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_smoothLinLog_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="inv_smoothLinLog_+3A_hyper">hyper</code></td>
<td>
<p>value where transition between Lin/Log is applied.</p>
</td></tr>
<tr><td><code id="inv_smoothLinLog_+3A_base">base</code></td>
<td>
<p>base of Log scale.</p>
</td></tr>
<tr><td><code id="inv_smoothLinLog_+3A_lin_comp">lin_comp</code></td>
<td>
<p>value that is used to smooth transition between Lin/Log. Default is log(base).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the inverse smoothLinLog transformation of the input.
</p>

<hr>
<h2 id='layoutReport'>Report Layout Extraction</h2><span id='topic+layoutReport'></span>

<h3>Description</h3>

<p>Extracts report layout from 'IFC_graphs' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layoutReport(graphs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layoutReport_+3A_graphs">graphs</code></td>
<td>
<p>an 'IFC_graphs' object extracted with features extracted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:<br />
-lay, a 3 columns (N, x, y) data.frame, where N is the graph index and x and y its coordinates on the layout,<br />
-mat, a matrix describing the layout.
</p>

<hr>
<h2 id='map_color'>Color Mapping</h2><span id='topic+map_color'></span>

<h3>Description</h3>

<p>Converts IDEAS/INSPIRE colors toR and inversely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_color(color, toR = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_color_+3A_color">color</code></td>
<td>
<p>a character vector Default is missing.</p>
</td></tr>
<tr><td><code id="map_color_+3A_tor">toR</code></td>
<td>
<p>whether to convert color toR or back. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector.
</p>

<hr>
<h2 id='map_style'>Style Mapping</h2><span id='topic+map_style'></span>

<h3>Description</h3>

<p>Converts IDEAS/INSPIRE style toR and inversely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_style(style, toR = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_style_+3A_style">style</code></td>
<td>
<p>a pch (converted to integer) or a character vector. Default is missing.</p>
</td></tr>
<tr><td><code id="map_style_+3A_tor">toR</code></td>
<td>
<p>whether to convert color toR or back. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer vector when toR is TRUE or a character vector.
</p>

<hr>
<h2 id='mergeXIF'>RIF/CIF File Merging</h2><span id='topic+mergeXIF'></span>

<h3>Description</h3>

<p>Merges RIF or CIF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeXIF(
  fileName,
  write_to,
  extract_features = FALSE,
  endianness = .Platform$endian,
  verbose = FALSE,
  verbosity = 1,
  overwrite = FALSE,
  display_progress = TRUE,
  add_tracking = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeXIF_+3A_filename">fileName</code></td>
<td>
<p>paths of files to merge.
All files have to be either '.rif' or '.cif' files.
All files should have same channels.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of first element of 'fileName'<br />
-%p: with first parent directory of first element of 'fileName'<br />
-%e: with extension of 'fileName' (without leading .)<br />
-%s: with shortname from of first element of 'fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. It has to be the same as 'fileName', i.e. .cif or .rif.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_extract_features">extract_features</code></td>
<td>
<p>whether to try to extract features. Default is FALSE. Not yet implemented.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_endianness">endianness</code></td>
<td>
<p>the endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_verbosity">verbosity</code></td>
<td>
<p>quantity of information displayed when verbose is TRUE; 1: normal, 2: rich. Default is 1.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.<br />
Note that if TRUE, it will overwrite exported file if paths of files in 'fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
Otherwise, you will get an error saying that overwriting original file is not allowed.<br /></p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_add_tracking">add_tracking</code></td>
<td>
<p>whether to register files' paths and objects' ids in the exported file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="mergeXIF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>

<hr>
<h2 id='modifyGamma'>Image Gamma Modification</h2><span id='topic+modifyGamma'></span>

<h3>Description</h3>

<p>Determines best xmid, ymid computes ymid for a given gamma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyGamma(V, gamma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modifyGamma_+3A_v">V</code></td>
<td>
<p>named NumericVector of channel display properties containing 'xmin', 'xmax', 'xmid' and 'ymid'.</p>
</td></tr>
<tr><td><code id="modifyGamma_+3A_gamma">gamma</code></td>
<td>
<p>gamma</p>
</td></tr>
</table>

<hr>
<h2 id='myScales'>Scale Constructor for IFC Graphs Plotting</h2><span id='topic+myScales'></span>

<h3>Description</h3>

<p>Helper to rescale and label axes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myScales(x = list(), y = list())
</code></pre>

<hr>
<h2 id='newPB'>Progress Bar Initializer</h2><span id='topic+newPB'></span>

<h3>Description</h3>

<p>Initializes a progress bar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newPB(
  title,
  label,
  min = 0,
  max = 1,
  initial = 0,
  steps = 21,
  width,
  style,
  char = "=",
  file = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newPB_+3A_title">title</code>, <code id="newPB_+3A_label">label</code></td>
<td>
<p>character strings, giving the 'title'(='message' for shiny progress bar) and the 'label'(='detail' for shiny progress bar).</p>
</td></tr>
<tr><td><code id="newPB_+3A_min">min</code>, <code id="newPB_+3A_max">max</code></td>
<td>
<p>(finite) numeric values for the extremes of the progress bar. Must have 'min' &lt; 'max'.</p>
</td></tr>
<tr><td><code id="newPB_+3A_initial">initial</code></td>
<td>
<p>initial value for the progress bar.</p>
</td></tr>
<tr><td><code id="newPB_+3A_steps">steps</code></td>
<td>
<p>(finite) numeric value for the number of individual chunk of the progress bar. Default is 21.</p>
</td></tr>
<tr><td><code id="newPB_+3A_width">width</code></td>
<td>
<p>the width of the progress bar. If missing, the default, will be NA for &quot;txtProgressBar&quot; and 300 for &quot;winProgressBar&quot;.</p>
</td></tr>
<tr><td><code id="newPB_+3A_style">style</code></td>
<td>
<p>does not apply for &quot;winProgressBar&quot;, the style of the bar. If missing, the default, will be 3 &quot;txtProgressBar&quot; and getShinyOption(&quot;progress.style&quot;, default = &quot;notification&quot;) for shiny progress bar.</p>
</td></tr>
<tr><td><code id="newPB_+3A_char">char</code></td>
<td>
<p>only apply for &quot;txtProgressBar&quot;, the character (or character string) to form the progress bar.</p>
</td></tr>
<tr><td><code id="newPB_+3A_file">file</code></td>
<td>
<p>only apply for &quot;txtProgressBar&quot;, an open connection object or &quot;&quot; which indicates the console: stderr() might be useful here. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="newPB_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>shiny progress bar will be available only if shiny package is found and within a shiny app.
</p>


<h3>Value</h3>

<p>pb an object of class 'IFC_progress' containing a progress bar of class 'txtProgressBar', 'winProgressBar' or 'Progress'.
</p>

<hr>
<h2 id='next_bool'>Next Component Prediction</h2><span id='topic+next_bool'></span>

<h3>Description</h3>

<p>Helper to define next allowed component in a boolean vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_bool(x = "", count = 0L, obj_alias)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_bool_+3A_x">x</code></td>
<td>
<p>a string, current component.</p>
</td></tr>
<tr><td><code id="next_bool_+3A_count">count</code></td>
<td>
<p>an integer, representing current number of opened/closed bracket.</p>
</td></tr>
<tr><td><code id="next_bool_+3A_obj_alias">obj_alias</code></td>
<td>
<p>a string, alias used for population name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of next allowed components.
</p>

<hr>
<h2 id='num_to_string'>Numeric to String Formatting</h2><span id='topic+num_to_string'></span>

<h3>Description</h3>

<p>Formats numeric to string used for features, images, ... values conversion when exporting to xml.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num_to_string(x, precision = 22)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num_to_string_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="num_to_string_+3A_precision">precision</code></td>
<td>
<p>number of significant decimal digits to keep. Default is 22.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string vector.
</p>

<hr>
<h2 id='objectCleanse'>Object Cleanser</h2><span id='topic+objectCleanse'></span>

<h3>Description</h3>

<p>Removes abnormalities (clipped/debris) from image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectCleanse(mat, msk, add_noise = TRUE, random_seed = NULL, bg = 0, sd = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectCleanse_+3A_mat">mat</code></td>
<td>
<p>a numeric matrix (image).</p>
</td></tr>
<tr><td><code id="objectCleanse_+3A_msk">msk</code></td>
<td>
<p>a numeric matrix (mask identifying abnormalities).</p>
</td></tr>
<tr><td><code id="objectCleanse_+3A_add_noise">add_noise</code></td>
<td>
<p>if TRUE adds normal noise to background using rnorm(), from <span class="pkg">Rcpp</span>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="objectCleanse_+3A_random_seed">random_seed</code></td>
<td>
<p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL to be used when 'add_noise' is set to TRUE. Default is NULL.
Note that NA_integer_ or list(seed = NA_integer_) can be used to not call <a href="base.html#topic+set.seed">set.seed</a> at all.</p>
</td></tr>
<tr><td><code id="objectCleanse_+3A_bg">bg</code></td>
<td>
<p>mean value of the background added if add_noise is TRUE. Default is 0.</p>
</td></tr>
<tr><td><code id="objectCleanse_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the background added if add_noise is TRUE. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>According to msk, pixel values in mat are substituted by either bg [add_noise == FALSE] or rnorm(n = prod(dim(mat), mean=bg, sd=sd)) [add_noise == TRUE].
</p>

<hr>
<h2 id='objectColorize'>Object Colorizer</h2><span id='topic+objectColorize'></span>

<h3>Description</h3>

<p>Colorizes a [0,1] grayscale image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectColorize(mat, color)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectColorize_+3A_mat">mat</code></td>
<td>
<p>a [0,1] numeric matrix.</p>
</td></tr>
<tr><td><code id="objectColorize_+3A_color">color</code></td>
<td>
<p>a color</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3D array where 3rd dimension is rgb.
</p>

<hr>
<h2 id='objectDisplay'>Object Display</h2><span id='topic+objectDisplay'></span>

<h3>Description</h3>

<p>This function is intended to display object extracted by <code><a href="#topic+objectExtract">objectExtract</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectDisplay(
  image,
  input_range = c(0, 4095),
  full_range = FALSE,
  force_range = FALSE,
  gamma = 1,
  color = "Green",
  dpi = 300
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectDisplay_+3A_image">image</code></td>
<td>
<p>An object extracted by <code><a href="#topic+objectExtract">objectExtract</a></code> of class 'IFC_img' or 'IFC_msk'.<br />
Note that a matrix with finite values can also be used.</p>
</td></tr>
<tr><td><code id="objectDisplay_+3A_input_range">input_range</code></td>
<td>
<p>a finite numeric vector of 2 values, sets the range of the input intensity values. Values outside this range are clipped. Default is <code>[0,4095]</code>.</p>
</td></tr>
<tr><td><code id="objectDisplay_+3A_full_range">full_range</code></td>
<td>
<p>if <code>'full_range'</code> is <code>TRUE</code>, then <code>'input_range'</code> will be set to <code>[0,4095]</code> and <code>'gamma'</code> forced to <code>1</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectDisplay_+3A_force_range">force_range</code></td>
<td>
<p>if <code>'force_range'</code> is <code>TRUE</code>, then <code>'input_range'</code> will be adjusted to <code>'image'</code> range in <code>[-4095,+inf]</code> and <code>'gamma'</code> forced to <code>1</code>. Default is <code>FALSE</code>.<br />
Note that this parameter takes the precedence over <code>input_range</code>' and <code>full_range</code>'.</p>
</td></tr>
<tr><td><code id="objectDisplay_+3A_gamma">gamma</code></td>
<td>
<p><code>'gamma'</code> correction. Default is <code>1</code>, for no correction.</p>
</td></tr>
<tr><td><code id="objectDisplay_+3A_color">color</code></td>
<td>
<p>a color. Default is <code>"Green"</code>.</p>
</td></tr>
<tr><td><code id="objectDisplay_+3A_dpi">dpi</code></td>
<td>
<p>display resolution. Default is <code>300</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'image'</code> is of class 'IFC_img' or 'IFC_msk', then if <code>'input_range'</code>, <code>'full_range'</code>, <code>'force_range'</code>, <code>'gamma'</code> and/or <code>'color'</code> parameters is/are missing,
it/they will be extracted from <code>'image'</code> attributes.<br />
If <code>'image'</code> is not of one of class 'IFC_img' or 'IFC_msk', then <code>'force_range'</code> will be forced to <code>TRUE</code>.<br />
An error will be thrown if input image contains non finite values.
</p>


<h3>Value</h3>

<p>it invisibly returns <code>NULL</code>
</p>

<hr>
<h2 id='objectExtract'>Object Extraction</h2><span id='topic+objectExtract'></span>

<h3>Description</h3>

<p>Extracts / Decompress objects stored in RIF or CIF Files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectExtract(ifd, param, verbose = FALSE, bypass = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectExtract_+3A_ifd">ifd</code></td>
<td>
<p>list of sub elements of IFD data information extracted by <code><a href="#topic+getIFD">getIFD</a></code>. This argument can't be missing.</p>
</td></tr>
<tr><td><code id="objectExtract_+3A_param">param</code></td>
<td>
<p>object of class 'IFC_param', containing extraction parameters defined by <code><a href="#topic+objectParam">objectParam</a></code>.<br />
This argument is not mandatory but it may allow to save time for repeated image export on same file.
If this argument is missing, <code><a href="#topic+objectExtract">objectExtract</a></code> will use named arguments in <code>'...'</code> as input to <code><a href="#topic+objectParam">objectParam</a></code> to control object extraction.<br />
However, if <code>'param'</code> is provided, <code>'...'</code> will be <strong>ignored</strong>.</p>
</td></tr>
<tr><td><code id="objectExtract_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectExtract_+3A_bypass">bypass</code></td>
<td>
<p>whether to bypass checks on <code>'ifd'</code> and <code>'param'</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectExtract_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+objectParam">objectParam</a></code>
</p>

<dl>
<dt><code>info</code></dt><dd><p>object of class 'IFC_info', rich information extracted by <code><a href="#topic+getInfo">getInfo</a></code>. 
This argument is not mandatory but it may allow to save time for repeated image export on same file.
If missing, the default, <code>'info'</code> will be extracted thanks to <code>'...'</code>.</p>
</dd>
<dt><code>mode</code></dt><dd><p>color mode export. Either <code>"rgb"</code>, <code>"gray"</code> or <code>"raw"</code>. Default is <code>"raw"</code>.
Note that <code>"raw"</code> is only possible when <code>'export'</code> is <code>"matrix"</code>.</p>
</dd>
<dt><code>export</code></dt><dd><p>format mode export. Either <code>"file"</code>, <code>"matrix"</code>, <code>"base64"</code>. Default is <code>"matrix"</code>.</p>
</dd>
<dt><code>write_to</code></dt><dd><p>used when export is <code>"file"</code> or <code>"base64"</code> to compute respectively exported file name or base64 id attribute.<br />
Exported file extension and base64 MIME type will be deduced from this pattern. Allowed export are <code>".bmp"</code>, <code>".jpg"</code>, <code>".jpeg"</code>, <code>".png"</code>, <code>".tif"</code>, <code>".tiff"</code>.
Note that <code>".bmp"</code> are faster but not compressed producing bigger data.<br />
Placeholders, if found, will be substituted:<br />
-<code>%d</code>: with full path directory,<br />
-<code>%p</code>: with first parent directory,<br />
-<code>%e</code>: with extension (without leading .),<br />
-<code>%s</code>: with shortname (i.e. basename without extension),<br />
-<code>%o</code>: with object_id,<br />
-<code>%c</code>: with channel_id.<br />
A good trick is to use:<br />
-<code>"%d/%s/%s_%o_%c.tiff"</code>, when <code>'export'</code> is <code>"file"</code>,<br />
-<code>"%o_%c.bmp"</code>, when <code>'export'</code> is <code>"base64"</code>.<br />
Note that if missing and <code>'export'</code> is not <code>"file"</code>, <code>'write_to'</code> will be set to <code>"%o_%c.bmp"</code>.</p>
</dd>
<dt><code>base64_id</code></dt><dd><p>whether to add id attribute to base64 exported object. Default is <code>FALSE</code>.<br />
Only applied when export is <code>"base64"</code>.</p>
</dd>
<dt><code>base64_att</code></dt><dd><p>attributes to add to base64 exported object. Default is <code>""</code>.<br />
Only applied when export is <code>"base64"</code>. For example, use <code>"class='draggable'"</code>.<br />
Note that <code>id</code> (if <code>'base64_id'</code> is <code>TRUE</code>) and <code>width</code> and <code>height</code> are already used.</p>
</dd>
<dt><code>overwrite</code></dt><dd><p>only apply when <code>'export'</code> is <code>"file"</code> whether to overwrite file or not. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>composite</code></dt><dd><p>character vector of image composite. Default is <code>""</code>, for no image composite.<br />
Should be like <code>"1.05/2.4/4.55"</code> for a composition of 5 perc. of channel 1, 40 perc. of channel 2 and 50 perc. of channel 55.<br />
Note that channels should have been acquired and final image composition should be 100 perc., otherwise an error is thrown.<br />
Note that each composite will be appended after <code>'selection'</code>.</p>
</dd>
<dt><code>selection</code></dt><dd><p>physical channels to extract.<br />
Note that this parameter will be ordered.<br />
Default is <code>"all"</code> to extract all acquired channels.<br />
Use <code>"none"</code> to only extract composite.</p>
</dd>
<dt><code>random_seed</code></dt><dd><p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL to be used when <code>'add_noise'</code> is set to <code>TRUE</code>. Default is <code>NULL</code>.
Note that <code>NA_integer_</code> or <code>list(seed = NA_integer_)</code> can be used to not call <a href="base.html#topic+set.seed">set.seed</a> at all.</p>
</dd>
<dt><code>size</code></dt><dd><p>a length 2 integer vector of final dimensions of the image, height 1st and width 2nd. Default is <code>c(0,0)</code> for no change.</p>
</dd>
<dt><code>force_width</code></dt><dd><p>whether to use information in <code>'info'</code> to fill size. Default is <code>TRUE</code>.
When set to <code>TRUE</code>, width of <code>'size'</code> argument will be overwritten.</p>
</dd>
<dt><code>removal</code></dt><dd><p>removal method: Either <code>"none"</code>, <code>"raw"</code>, <code>"clipped"</code>, <code>"masked"</code>, <code>"MC"</code>.<br />
-<code>"none"</code>, to keep image as is, no mask extraction will be performed resulting in faster extraction,<br />
-<code>"raw"</code>, to keep image as is, it provides a convenient way to retrieve <code>"raw"</code> value for the mask,<br />
-<code>"clipped"</code>, to remove clipped object from image,<br />
-<code>"masked"</code>, to only keep masked object from image,<br />
-<code>"MC"</code>, to keep MC masked object from image.
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.</p>
</dd>
<dt><code>add_noise</code></dt><dd><p>if <code>TRUE</code> adds normal noise to background using <span class="pkg">Rcpp</span>. Default is <code>TRUE</code>.<br />
Note that it is better to set it to <code>FALSE</code> when <code>'removal'</code> is <code>"masked"</code> or <code>"MC"</code>. Doing so will allow to place masked object in a zero filled background,
otherwise background will still be filled with noise.
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.</p>
</dd>
<dt><code>full_range</code></dt><dd><p>only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'full_range'</code> is <code>TRUE</code>, then object range will be considered as 0 to 4095, it is like <code>"raw"</code> <code>'mode'</code> but resulting in [0,4095] normalization to [0,1]. Default is <code>FALSE</code>.<br />
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.</p>
</dd>
<dt><code>force_range</code></dt><dd><p>only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'force_range'</code> is <code>TRUE</code>, then range will be adjusted to object range in <code>[-4095,+inf]</code> resulting in normalization to [0,1]. Default is <code>FALSE</code>.<br />
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.<br />
Note that this parameter takes the precedence over <code>'full_range'</code>.</p>
</dd>
<dt><code>spatial_correction</code></dt><dd><p>only apply on RIF file, whether to apply spatial correction. Default is <code>FALSE</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>When a mask is detected, <code>'add_noise'</code>, <code>'full_range'</code> and <code>'force_range'</code> are set to <code>FALSE</code> and range used will be forced to <code>[0,3]</code>.<br /><br />
Range of image is controlled by <code>'Images'</code> information from supplied <code>'info'</code> or as extracted by <code><a href="#topic+getInfo">getInfo</a></code> and will be returned as <code>'channels'</code> by <code><a href="#topic+objectParam">objectParam</a></code>.
In case <code>'mode'</code> is not <code>"raw"</code>, '<code>channels$xmin</code>', '<code>channels$xmax</code>', '<code>channels$gamma</code>' will be used for object extraction by <code><a href="#topic+objectExtract">objectExtract</a></code> unless any of <code>'force_range'</code> or <code>'full_range'</code> is <code>TRUE</code>.<br /><br />
Experimental (as of v0.2.0.501): once returned by <code><a href="#topic+objectParam">objectParam</a></code>, those '<code>channels$xmin</code>' and '<code>channels$xmax</code>' can be manually adjusted to <code>]0,1[</code> so as to be used as <code>'probs'</code> argument to <a href="stats.html#topic+quantile">quantile</a> to allow quantile normalization during object extraction (<code><a href="#topic+objectExtract">objectExtract</a></code>) afterwards.
</p>


<h3>Value</h3>

<p>A list (for every extracted objects) of list (for every exported channels) depending on '<code>param$export</code>' parameter:<br />
-<code>"matrix"</code>, a matrix when '<code>param$mode</code>' is set to <code>"raw"</code> or <code>"gray"</code> OR an array when '<code>param$mode</code>' is <code>"rgb"</code>,<br />
-<code>"base64"</code>, a data-uri string,<br />
-<code>"file"</code>, an invisible file path corresponding to the location of exported file(s).
</p>


<h3>Note</h3>

<p><code>'...'</code> will be used to compute <code>'param'</code> <strong>only</strong> if <code>'param'</code> is <strong>not</strong> provided.<br />
<strong>/!\</strong> When <code>'param'</code> is not provided, if not any of <code>'fileName'</code>, <code>'info'</code> can be found in <code>'...'</code>, then <code>attr(ifd, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.
</p>


<h3>Source</h3>

<p>For image decompression, Lee Kamentsky's code porting from <a href="https://github.com/ome/bioformats/blob/4146b9a1797501f0fec7d6cfe69124959bff96ee/components/formats-bsd/src/loci/formats/in/FlowSightReader.java">https://github.com/ome/bioformats/blob/4146b9a1797501f0fec7d6cfe69124959bff96ee/components/formats-bsd/src/loci/formats/in/FlowSightReader.java</a><br />
cited in <a href="https://linkinghub.elsevier.com/retrieve/pii/S1046-2023(16)30291-2">https://linkinghub.elsevier.com/retrieve/pii/S1046-2023(16)30291-2</a><br />
<code style="white-space: pre;">&#8288;
BSD implementations of Bio-Formats readers and writers

Copyright (C) 2005 - 2017 Open Microscopy Environment:
  - Board of Regents of the University of Wisconsin-Madison
  - Glencoe Software, Inc.
  - University of Dundee

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
   this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a cif file
  file_cif &lt;- system.file("extdata", "example.cif", package = "IFCdata")
  cif_offs &lt;- getOffsets(fileName = file_cif, fast = TRUE)
  ## extract infomation
  info &lt;- getInfo(fileName = file_cif, from = "analysis")
  ## retrieve number of objects stored
  nobj &lt;- as.integer(info$objcount)
  ## randomly subset the offsets of at most 5 "img" objects
  sel = sample(0:(nobj-1), min(5, nobj))
  sub_offs &lt;- subsetOffsets(cif_offs, objects = sel, image_type = "img")
  ## read IFDs from these "img" objects
  IFDs &lt;- getIFD(fileName = file_cif, offsets = sub_offs)
  ## extract raw data of these"img" objects to matrix
  raw = objectExtract(ifd = IFDs, info = info, mode = "raw", 
                      export = "matrix")
  ## extract base64 "rgb" colorized version of these "img" objects to base64
  b64 = objectExtract(ifd = IFDs, info = info, mode = "rgb", 
                      export = "base64", base64_id = TRUE,
                      write_to = "example_%o_%c.bmp")
  ## use DisplayGallery to show the first "img" objects and play with ... extra parameters
  ## force_range, add_noise, selection, composite, see objectParam
  DisplayGallery(info = info, offsets = cif_offs, objects = sel,
                 base64_id = TRUE, write_to = "example_%o_%c.bmp",
                 force_range = c(FALSE,TRUE,FALSE,TRUE), add_noise = FALSE,
                 selection = c(1,2,4,6), composite = "1.7/4.3")
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='objectNormalize'>Object Intensity Normalization</h2><span id='topic+objectNormalize'></span>

<h3>Description</h3>

<p>Normalizes a matrix to [0,1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectNormalize(
  mat,
  input_range = c(0, 4095),
  full_range = FALSE,
  force_range = FALSE,
  gamma = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectNormalize_+3A_mat">mat</code></td>
<td>
<p>a finite numeric matrix.</p>
</td></tr>
<tr><td><code id="objectNormalize_+3A_input_range">input_range</code></td>
<td>
<p>a finite numeric vector of 2 values, sets the range of the input intensity values. Values outside this range are clipped. Default is <code>[0,4095]</code>.</p>
</td></tr>
<tr><td><code id="objectNormalize_+3A_full_range">full_range</code></td>
<td>
<p>if '<code>full_range</code>' is <code>TRUE</code>, then '<code>input_range</code>' will be set to <code>[0,4095]</code> and '<code>gamma</code>' forced to <code>1</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectNormalize_+3A_force_range">force_range</code></td>
<td>
<p>if '<code>force_range</code>' is <code>TRUE</code>, then '<code>input_range</code>' will be adjusted to '<code>mat</code>' range in <code>[-4095,+inf]</code> and '<code>gamma</code>' forced to <code>1</code>. Default is <code>FALSE</code>.<br />
Note that this parameter takes the precedence over <code>input_range</code>' and <code>full_range</code>'.</p>
</td></tr>
<tr><td><code id="objectNormalize_+3A_gamma">gamma</code></td>
<td>
<p>'<code>gamma</code>' correction. Default is <code>1</code>, for no correction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that negative values are used internally for removal of unmasked objects.
</p>


<h3>Value</h3>

<p>a [0,1] normalized matrix
</p>

<hr>
<h2 id='objectParam'>Object Extraction Parameters Definition</h2><span id='topic+objectParam'></span>

<h3>Description</h3>

<p>Defines 'IFC_object' object extraction parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectParam(
  ...,
  info,
  mode = c("rgb", "gray", "raw")[3],
  export = c("file", "matrix", "base64")[2],
  write_to,
  base64_id = FALSE,
  base64_att = "",
  overwrite = FALSE,
  composite = "",
  selection = "all",
  size = c(0, 0),
  force_width = TRUE,
  random_seed = NULL,
  removal = "none",
  add_noise = TRUE,
  full_range = FALSE,
  force_range = FALSE,
  spatial_correction = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectParam_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+getInfo">getInfo</a></code>, <strong>only</strong> if <code>'info'</code> is <strong>not</strong> provided.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_info">info</code></td>
<td>
<p>object of class 'IFC_info', rich information extracted by <code><a href="#topic+getInfo">getInfo</a></code>. 
This argument is not mandatory but it may allow to save time for repeated image export on same file.
If missing, the default, <code>'info'</code> will be extracted thanks to <code>'...'</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_mode">mode</code></td>
<td>
<p>color mode export. Either <code>"rgb"</code>, <code>"gray"</code> or <code>"raw"</code>. Default is <code>"raw"</code>.
Note that <code>"raw"</code> is only possible when <code>'export'</code> is <code>"matrix"</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_export">export</code></td>
<td>
<p>format mode export. Either <code>"file"</code>, <code>"matrix"</code>, <code>"base64"</code>. Default is <code>"matrix"</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_write_to">write_to</code></td>
<td>
<p>used when export is <code>"file"</code> or <code>"base64"</code> to compute respectively exported file name or base64 id attribute.<br />
Exported file extension and base64 MIME type will be deduced from this pattern. Allowed export are <code>".bmp"</code>, <code>".jpg"</code>, <code>".jpeg"</code>, <code>".png"</code>, <code>".tif"</code>, <code>".tiff"</code>.
Note that <code>".bmp"</code> are faster but not compressed producing bigger data.<br />
Placeholders, if found, will be substituted:<br />
-<code>%d</code>: with full path directory,<br />
-<code>%p</code>: with first parent directory,<br />
-<code>%e</code>: with extension (without leading .),<br />
-<code>%s</code>: with shortname (i.e. basename without extension),<br />
-<code>%o</code>: with object_id,<br />
-<code>%c</code>: with channel_id.<br />
A good trick is to use:<br />
-<code>"%d/%s/%s_%o_%c.tiff"</code>, when <code>'export'</code> is <code>"file"</code>,<br />
-<code>"%o_%c.bmp"</code>, when <code>'export'</code> is <code>"base64"</code>.<br />
Note that if missing and <code>'export'</code> is not <code>"file"</code>, <code>'write_to'</code> will be set to <code>"%o_%c.bmp"</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_base64_id">base64_id</code></td>
<td>
<p>whether to add id attribute to base64 exported object. Default is <code>FALSE</code>.<br />
Only applied when export is <code>"base64"</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_base64_att">base64_att</code></td>
<td>
<p>attributes to add to base64 exported object. Default is <code>""</code>.<br />
Only applied when export is <code>"base64"</code>. For example, use <code>"class='draggable'"</code>.<br />
Note that <code>id</code> (if <code>'base64_id'</code> is <code>TRUE</code>) and <code>width</code> and <code>height</code> are already used.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_overwrite">overwrite</code></td>
<td>
<p>only apply when <code>'export'</code> is <code>"file"</code> whether to overwrite file or not. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_composite">composite</code></td>
<td>
<p>character vector of image composite. Default is <code>""</code>, for no image composite.<br />
Should be like <code>"1.05/2.4/4.55"</code> for a composition of 5 perc. of channel 1, 40 perc. of channel 2 and 50 perc. of channel 55.<br />
Note that channels should have been acquired and final image composition should be 100 perc., otherwise an error is thrown.<br />
Note that each composite will be appended after <code>'selection'</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_selection">selection</code></td>
<td>
<p>physical channels to extract.<br />
Note that this parameter will be ordered.<br />
Default is <code>"all"</code> to extract all acquired channels.<br />
Use <code>"none"</code> to only extract composite.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_size">size</code></td>
<td>
<p>a length 2 integer vector of final dimensions of the image, height 1st and width 2nd. Default is <code>c(0,0)</code> for no change.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_force_width">force_width</code></td>
<td>
<p>whether to use information in <code>'info'</code> to fill size. Default is <code>TRUE</code>.
When set to <code>TRUE</code>, width of <code>'size'</code> argument will be overwritten.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_random_seed">random_seed</code></td>
<td>
<p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL to be used when <code>'add_noise'</code> is set to <code>TRUE</code>. Default is <code>NULL</code>.
Note that <code>NA_integer_</code> or <code>list(seed = NA_integer_)</code> can be used to not call <a href="base.html#topic+set.seed">set.seed</a> at all.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_removal">removal</code></td>
<td>
<p>removal method: Either <code>"none"</code>, <code>"raw"</code>, <code>"clipped"</code>, <code>"masked"</code>, <code>"MC"</code>.<br />
-<code>"none"</code>, to keep image as is, no mask extraction will be performed resulting in faster extraction,<br />
-<code>"raw"</code>, to keep image as is, it provides a convenient way to retrieve <code>"raw"</code> value for the mask,<br />
-<code>"clipped"</code>, to remove clipped object from image,<br />
-<code>"masked"</code>, to only keep masked object from image,<br />
-<code>"MC"</code>, to keep MC masked object from image.
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_add_noise">add_noise</code></td>
<td>
<p>if <code>TRUE</code> adds normal noise to background using <span class="pkg">Rcpp</span>. Default is <code>TRUE</code>.<br />
Note that it is better to set it to <code>FALSE</code> when <code>'removal'</code> is <code>"masked"</code> or <code>"MC"</code>. Doing so will allow to place masked object in a zero filled background,
otherwise background will still be filled with noise.
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_full_range">full_range</code></td>
<td>
<p>only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'full_range'</code> is <code>TRUE</code>, then object range will be considered as 0 to 4095, it is like <code>"raw"</code> <code>'mode'</code> but resulting in [0,4095] normalization to [0,1]. Default is <code>FALSE</code>.<br />
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_force_range">force_range</code></td>
<td>
<p>only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'force_range'</code> is <code>TRUE</code>, then range will be adjusted to object range in <code>[-4095,+inf]</code> resulting in normalization to [0,1]. Default is <code>FALSE</code>.<br />
This parameter will be repeated with rep_len() from <span class="pkg">base</span> for every physical channel that needs to be extracted according to <code>'selection'</code> and <code>'composite'</code> parameters.<br />
Note that this parameter takes the precedence over <code>'full_range'</code>.</p>
</td></tr>
<tr><td><code id="objectParam_+3A_spatial_correction">spatial_correction</code></td>
<td>
<p>only apply on RIF file, whether to apply spatial correction. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a mask is detected, <code>'add_noise'</code>, <code>'full_range'</code> and <code>'force_range'</code> are set to <code>FALSE</code> and range used will be forced to <code>[0,3]</code>.<br /><br />
Range of image is controlled by <code>'Images'</code> information from supplied <code>'info'</code> or as extracted by <code><a href="#topic+getInfo">getInfo</a></code> and will be returned as <code>'channels'</code> by <code><a href="#topic+objectParam">objectParam</a></code>.
In case <code>'mode'</code> is not <code>"raw"</code>, '<code>channels$xmin</code>', '<code>channels$xmax</code>', '<code>channels$gamma</code>' will be used for object extraction by <code><a href="#topic+objectExtract">objectExtract</a></code> unless any of <code>'force_range'</code> or <code>'full_range'</code> is <code>TRUE</code>.<br /><br />
Experimental (as of v0.2.0.501): once returned by <code><a href="#topic+objectParam">objectParam</a></code>, those '<code>channels$xmin</code>' and '<code>channels$xmax</code>' can be manually adjusted to <code>]0,1[</code> so as to be used as <code>'probs'</code> argument to <a href="stats.html#topic+quantile">quantile</a> to allow quantile normalization during object extraction (<code><a href="#topic+objectExtract">objectExtract</a></code>) afterwards.
</p>


<h3>Value</h3>

<p>an object of class 'IFC_param'.
</p>

<hr>
<h2 id='objectResize'>Object Resizing</h2><span id='topic+objectResize'></span>

<h3>Description</h3>

<p>Resizes mat to new dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectResize(
  mat,
  size = c(0, 0),
  add_noise = TRUE,
  random_seed = NULL,
  bg = 0,
  sd = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectResize_+3A_mat">mat</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="objectResize_+3A_size">size</code></td>
<td>
<p>a length 2 integer vector of final dimensions of the image, height 1st and width 2nd. Default is c(0,0) for no change.</p>
</td></tr>
<tr><td><code id="objectResize_+3A_add_noise">add_noise</code></td>
<td>
<p>if TRUE adds normal noise when size is larger than mat dimensions using rnorm(), from <span class="pkg">Rcpp</span>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="objectResize_+3A_random_seed">random_seed</code></td>
<td>
<p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL to be used when 'add_noise' is set to TRUE. Default is NULL.
Note that NA_integer_ or list(seed = NA_integer_) can be used to not call <a href="base.html#topic+set.seed">set.seed</a> at all.</p>
</td></tr>
<tr><td><code id="objectResize_+3A_bg">bg</code></td>
<td>
<p>mean value of the background added if add_noise is TRUE. Default is 0.</p>
</td></tr>
<tr><td><code id="objectResize_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the background added if add_noise is TRUE. Default is 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a resized matrix with padding background if desired size is larger than original mat dimensions.
</p>

<hr>
<h2 id='objectTransform'>Object Transformation</h2><span id='topic+objectTransform'></span>

<h3>Description</h3>

<p>Function to normalize, colorize and add background to images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectTransform(
  mat,
  msk,
  color,
  input_range,
  mode,
  type,
  add_noise = TRUE,
  random_seed = NULL,
  size = c(0, 0),
  bg_mean = 0,
  bg_sd = 0,
  full_range = FALSE,
  force_range = FALSE,
  gamma = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectTransform_+3A_mat">mat</code></td>
<td>
<p>a finite numeric matrix.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_msk">msk</code></td>
<td>
<p>a finite numeric matrix (mask identifying abnormalities). If missing, the default no cleansing will be done.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_color">color</code></td>
<td>
<p>a color.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_input_range">input_range</code></td>
<td>
<p>a finite numeric vector of 2 values, sets the range of the input intensity values. Values outside this range are clipped. Default is <code>[0,4095]</code>.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_mode">mode</code></td>
<td>
<p>color mode export. Either <code>"rgb"</code>, <code>"gray"</code> or <code>"raw"</code>.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_type">type</code></td>
<td>
<p>image object type.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_add_noise">add_noise</code></td>
<td>
<p>whether to add normal noise to background or not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_random_seed">random_seed</code></td>
<td>
<p>a list of elements to pass to <a href="base.html#topic+set.seed">set.seed</a> or a single value, interpreted as an integer, or NULL to be used when <code>'add_noise'</code> is set to <code>TRUE</code>. Default is <code>NULL</code>.
Note that <code>NA_integer_</code> or <code>list(seed = NA_integer_)</code> can be used to not call <a href="base.html#topic+set.seed">set.seed</a> at all.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_size">size</code></td>
<td>
<p>a length 2 integer vector of final dimensions of the image, height 1st and width 2nd. Default is <code>c(0,0)</code> for no change.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_bg_mean">bg_mean</code></td>
<td>
<p>mean value of the background added if <code>'add_noise'</code> is <code>TRUE</code>. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_bg_sd">bg_sd</code></td>
<td>
<p>standard deviation of the background added if <code>'add_noise'</code> is <code>TRUE</code>. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_full_range">full_range</code></td>
<td>
<p>only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'full_range'</code> is <code>TRUE</code>, then <code>'input_range'</code> will be set to <code>[0,4095]</code> and <code>'gamma'</code> forced to <code>1</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_force_range">force_range</code></td>
<td>
<p>bool, only apply when <code>'mode'</code> is not <code>"raw"</code>, if <code>'force_range'</code> is <code>TRUE</code>, then <code>'input_range'</code> will be adjusted to object range in <code>[-4095,+inf]</code> and <code>'gamma'</code> forced to <code>1</code>. Default is <code>FALSE</code>.<br />
Note that this parameter takes the precedence over <code>'input_range'</code> and <code>'full_range'</code>.</p>
</td></tr>
<tr><td><code id="objectTransform_+3A_gamma">gamma</code></td>
<td>
<p>correction. Default is <code>1</code>, for no correction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>'add_noise'</code> is <code>FALSE</code> and <code>attr(msk, "removal")</code> is <code>"masked"</code> or <code>"MC"</code>,
background will be automatically set to minimal pixel value.
</p>


<h3>Value</h3>

<p>the matrix transformed according to input parameters
</p>

<hr>
<h2 id='objectWrite'>Object File Export</h2><span id='topic+objectWrite'></span>

<h3>Description</h3>

<p>Exports images to various types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objectWrite(x, type, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objectWrite_+3A_x">x</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
<tr><td><code id="objectWrite_+3A_type">type</code></td>
<td>
<p>image type. Supported values are: &quot;bmp&quot;, &quot;jpeg&quot;, &quot;png&quot;, and &quot;tiff&quot;.</p>
</td></tr>
<tr><td><code id="objectWrite_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='paletteIFC'>R/IDEAS Color Palette Mapping</h2><span id='topic+paletteIFC'></span>

<h3>Description</h3>

<p>Maps colors between IDEAS and R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paletteIFC(
  x = c("", "palette", "palette_R", "to_light", "to_dark")[1],
  col = "White"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paletteIFC_+3A_x">x</code></td>
<td>
<p>either &quot;&quot;, &quot;palette&quot;,&quot;palette_R&quot;, to_light, to_dark. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="paletteIFC_+3A_col">col</code></td>
<td>
<p>a compatible color to transform to color or lightModeColor. Default is &quot;White&quot;.<br />
if 'x' == to_light, function will convert 'col' to lightModeColor.<br />
if 'x' == to_dark, function will convert 'col' to color.<br />
if 'col' is not found or 'x' is anything else then a data.frame of compatible colors is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IFC palette of available colors.
</p>

<hr>
<h2 id='pan_hist'>Lattice Histogram Panel Contructor</h2><span id='topic+pan_hist'></span>

<h3>Description</h3>

<p>Helper to create histogram panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pan_hist(
  x,
  type,
  br,
  normalize,
  fill,
  lwd,
  lty,
  col,
  alpha,
  ylim,
  bin,
  border,
  include.lowest = TRUE,
  right = TRUE
)
</code></pre>


<h3>Source</h3>

<p>derived from <span class="pkg">lattice</span> from Deepayan Sarkar
</p>

<hr>
<h2 id='pan_key'>Lattice Key Panel Contructor</h2><span id='topic+pan_key'></span>

<h3>Description</h3>

<p>Helper to add key to panel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pan_key(key, corner = c(0, 0.98), x = corner[1], y = corner[2])
</code></pre>


<h3>Source</h3>

<p>derived from <span class="pkg">lattice</span> from Deepayan Sarkar
</p>

<hr>
<h2 id='pan_smooth'>Histogram Smooth Constructor</h2><span id='topic+pan_smooth'></span>

<h3>Description</h3>

<p>Helper to smooth histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pan_smooth(
  x,
  type,
  br,
  normalize,
  fill,
  lwd,
  lty,
  col,
  alpha,
  ylim,
  bin,
  border,
  include.lowest = TRUE,
  right = TRUE,
  factor = 0
)
</code></pre>


<h3>Source</h3>

<p>derived from <span class="pkg">lattice</span> from Deepayan Sarkar
</p>

<hr>
<h2 id='parseFCSname'>FCS Name Parser</h2><span id='topic+parseFCSname'></span>

<h3>Description</h3>

<p>Separates names and alt-names from FCS features names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseFCSname(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseFCSname_+3A_x">x</code></td>
<td>
<p>a character vector of FCS features names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when created FCS features names are formatted as 'PnN &lt; PnS &gt;'.
The current function allows the separation between PnN and PnS.
</p>


<h3>Value</h3>

<p>a 2 columns data.frame of names (PnN) and alt-names (PnS).
</p>

<hr>
<h2 id='parseTrans'>Parse Transformation Information</h2><span id='topic+parseTrans'></span>

<h3>Description</h3>

<p>Helper to parse transformation parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parseTrans(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parseTrans_+3A_string">string</code></td>
<td>
<p>character string describing transformation used and its parameters, if any.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>-If string is &quot;P&quot; no transformation will be applied.<br />
-If string is of length 1 and coercible to a numeric, smoothLinLog will be applied with 'hyper' parameter set with as.numeric(string) value.<br />
-Otherwise, string will be split with &quot;|&quot;, 1st element will be considered as function to call
and all other elements will be passed to this function after being coerced to numeric
in the order they are provided with the exception of 1st one;
if coercion results in NA, the argument will be skipped.
</p>


<h3>Value</h3>

<p>a list with 3 members:<br />
-what, the transformation function,<br />
-args, he parameters to pass to this function (with the exception of the 1st one),<br />
-trans, the transformation instruction coerced to character.
</p>

<hr>
<h2 id='plot_base'>&lsquo;IFC_plot' Conversion to &rsquo;base' Plot</h2><span id='topic+plot_base'></span>

<h3>Description</h3>

<p>Helper to convert &lsquo;IFC_plot' to &rsquo;base' plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_base(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_base_+3A_obj">obj</code></td>
<td>
<p>an object of class 'IFC_plot' as created by <code><a href="#topic+plotGraph">plotGraph</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_lattice'>&lsquo;IFC_plot' Conversion to &rsquo;lattice' Plot</h2><span id='topic+plot_lattice'></span>

<h3>Description</h3>

<p>Helper to convert &lsquo;IFC_plot' to &rsquo;lattice' plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_lattice(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_lattice_+3A_obj">obj</code></td>
<td>
<p>an object of class 'IFC_plot' as created by <code><a href="#topic+plotGraph">plotGraph</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_raster'>&lsquo;IFC_plot' Conversion to &rsquo;raster' Plot</h2><span id='topic+plot_raster'></span>

<h3>Description</h3>

<p>Helper to convert &lsquo;IFC_plot' to &rsquo;raster' plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_raster(obj, pntsonedge = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_raster_+3A_obj">obj</code></td>
<td>
<p>an object of class 'IFC_plot' as created by <code><a href="#topic+plotGraph">plotGraph</a></code>.</p>
</td></tr>
<tr><td><code id="plot_raster_+3A_pntsonedge">pntsonedge</code></td>
<td>
<p>whether points outside of plotting region should be bounded on the edge. Default is FALSE to clip points.
NA can be used to produce hybrid display, with plot being drawn with 'pntsonedge' = FALSE on top of plot with 'pntsonedge' = TRUE.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_stats'>'IFC_plot' Statistics Extraction</h2><span id='topic+plot_stats'></span>

<h3>Description</h3>

<p>Helper to extract 'IFC_plot' statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_stats(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_stats_+3A_obj">obj</code></td>
<td>
<p>an object of class 'IFC_plot' as created by <code><a href="#topic+plotGraph">plotGraph</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plotGraph'>Plot and Stats Computation for IFC Graph</h2><span id='topic+plotGraph'></span>

<h3>Description</h3>

<p>Computes plot and stats from a IFC graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGraph(
  obj,
  graph,
  draw = FALSE,
  stats_print = draw,
  color_mode = c("white", "black")[1],
  add_key = "panel",
  precision = c("light", "full")[1],
  trunc_labels = 38,
  trans = "asinh",
  bin,
  viewport = "ideas",
  backend = "lattice",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGraph_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_graph">graph</code></td>
<td>
<p>a graph from 'obj' or a list that can be coerced by <code><a href="#topic+buildGraph">buildGraph</a></code>.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_draw">draw</code></td>
<td>
<p>whether to draw plot or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_stats_print">stats_print</code></td>
<td>
<p>whether to print stats or not. Default is given by 'draw' argument.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_color_mode">color_mode</code></td>
<td>
<p>whether to extract colors from 'obj' in white or black mode. Default is &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_add_key">add_key</code></td>
<td>
<p>whether to draw a &quot;global&quot; key under title or in the first &quot;panel&quot; or &quot;both&quot;. Default is &quot;panel&quot;.<br />
Accepted values are either: FALSE, &quot;panel&quot;, &quot;global&quot;, &quot;both&quot; or c(&quot;panel&quot;, &quot;global&quot;).<br />
Note that it only applies when display is seen as overlaying populations.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_precision">precision</code></td>
<td>
<p>when graphs is a 2D scatter with population overlay, this argument controls amount of information displayed. Default is &quot;light&quot;.<br />
-&quot;light&quot;, the default, will only display points of same coordinates that are among the other layers.<br />
-&quot;full&quot; will display all the layers.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_trunc_labels">trunc_labels</code></td>
<td>
<p>maximum number of characters to display for labels. Default is 38.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_trans">trans</code></td>
<td>
<p>the name of a transformation function for density graphs. If missing the default, the BasePop[[1]]$densitytrans, if any, will be retrieved, otherwise &quot;asinh&quot; will be used.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_bin">bin</code></td>
<td>
<p>number of bin used for histogram / density. Default is missing.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_viewport">viewport</code></td>
<td>
<p>either &quot;ideas&quot;, &quot;data&quot; or &quot;max&quot; defining limits used for the graph. Default is &quot;ideas&quot;.<br />
-&quot;ideas&quot; will use same limits as the one defined in ideas.<br />
-&quot;data&quot; will use data to define limits.<br />
-&quot;max&quot; will use data and regions drawn to define limits.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_backend">backend</code></td>
<td>
<p>backend used for drawing. Allowed are &quot;lattice&quot;, &quot;base&quot;, &quot;raster&quot;, &quot;raster-edge&quot;, &quot;raster-hybrid&quot;. Default is &quot;lattice&quot;.<br />
-&quot;lattice&quot; is the original one used in <span class="pkg">IFC</span> using <span class="pkg">lattice</span>,<br />
-&quot;base&quot; will produce the plot using <span class="pkg">base</span>,<br />
-&quot;raster&quot; uses &quot;base&quot; for plotting but 2D graphs points will be produced as <code><a href="graphics.html#topic+rasterImage">rasterImage</a></code>.<br />
This has the main advantage of being super fast allowing for plotting a huge amount of points while generating smaller objects (in bytes).
However, plot quality is impacted with &quot;raster&quot; method and resizing can lead to unpleasant looking.
-&quot;raster-edge&quot; is the same as &quot;raster&quot; except that points outside of limits will be drawn onto the edge.<br />
-&quot;raster-hybrid&quot; uses &quot;raster&quot; for drawing on top of a first &quot;raster-edge&quot; pass to produce an hybrid display.</p>
</td></tr>
<tr><td><code id="plotGraph_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it invisibly returns a list whose members are:<br />
-stats, a table of statistics computed for the graph, if 'stats_print' was TRUE,<br />
-input, a list with input parameters.
</p>

<hr>
<h2 id='polyExtractTo'>Shortcut for Batch Images or Masks Extraction</h2><span id='topic+polyExtractTo'></span>

<h3>Description</h3>

<p>Function to shortcut extraction, normalization and eventually colorization of images or masks to various format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyExtractTo(
  ...,
  objects,
  offsets,
  display_progress = TRUE,
  image_type = "img",
  export = "matrix",
  mode = "raw"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyExtractTo_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="#topic+objectExtract">objectExtract</a></code> with the exception of <code>'ifd'</code> and <code>'bypass'</code>(=<strong>TRUE</strong>).<br />
<strong>/!\</strong> If not any of <code>'fileName'</code>, <code>'info'</code> and <code>'param'</code> can be found in <code>'...'</code> then <code>attr(offsets, "fileName_image")</code> will be used as <code>'fileName'</code> input parameter to pass to <code><a href="#topic+objectParam">objectParam</a></code>.</p>
</td></tr>
<tr><td><code id="polyExtractTo_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use.
This argument is not mandatory, if missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="polyExtractTo_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset'.
This argument is not mandatory but it may allow to save time for repeated image export on same file.<br />
If <code>'offsets'</code> are not provided, extra arguments can also be passed with <code>'...'</code> to <code><a href="#topic+getOffsets">getOffsets</a></code>.</p>
</td></tr>
<tr><td><code id="polyExtractTo_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="polyExtractTo_+3A_image_type">image_type</code></td>
<td>
<p>(<code><a href="#topic+subsetOffsets">subsetOffsets</a></code> argument) type of desired object offsets. Default is <code>"img"</code>. Allowed are <code>"img"</code> or <code>"msk"</code>.</p>
</td></tr>
<tr><td><code id="polyExtractTo_+3A_export">export</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) format mode export. Either <code>"file"</code>, <code>"matrix"</code>, <code>"base64"</code>. Default is <code>"matrix"</code>.</p>
</td></tr>
<tr><td><code id="polyExtractTo_+3A_mode">mode</code></td>
<td>
<p>(<code><a href="#topic+objectParam">objectParam</a></code> argument) color mode export. Either <code>"raw"</code>, <code>"rgb"</code>, <code>"gray"</code>. Default is <code>"raw"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>'param'</code> is provided in <code>'...'</code>, <code>'param$export'&lt;-'export'</code> and <code>'param$mode'&lt;-'mode'</code> <strong>only</strong> will be overwritten.
</p>


<h3>Value</h3>

<p>A list (for every extracted objects) of list (for every exported channels) depending on '<code>param$export</code>' parameter:<br />
-<code>"matrix"</code>, a matrix when '<code>param$mode</code>' is set to <code>"raw"</code> or <code>"gray"</code> OR an array when '<code>param$mode</code>' is <code>"rgb"</code>,<br />
-<code>"base64"</code>, a data-uri string,<br />
-<code>"file"</code>, an invisible file path corresponding to the location of exported file(s).
</p>


<h3>Note</h3>

<p>Arguments of <code><a href="#topic+objectExtract">objectExtract</a></code> will be deduced from input arguments.
</p>

<hr>
<h2 id='popsCompute'>IFC_pops Computation</h2><span id='topic+popsCompute'></span>

<h3>Description</h3>

<p>Function used to compute 'IFC_pops' object<br />
It requires pops, regions and features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsCompute(
  pops,
  regions,
  features,
  pnt_in_poly_algorithm = 1,
  pnt_in_poly_epsilon = 1e-12,
  display_progress = TRUE,
  title_progress = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsCompute_+3A_pops">pops</code></td>
<td>
<p>list of populations that will be coerced by <code><a href="#topic+buildPopulation">buildPopulation</a></code>.</p>
</td></tr>
<tr><td><code id="popsCompute_+3A_regions">regions</code></td>
<td>
<p>an object of class 'IFC_regions', list of regions.</p>
</td></tr>
<tr><td><code id="popsCompute_+3A_features">features</code></td>
<td>
<p>an object of class 'IFC_features', data.frame of features.</p>
</td></tr>
<tr><td><code id="popsCompute_+3A_pnt_in_poly_algorithm">pnt_in_poly_algorithm</code></td>
<td>
<p>algorithm used to determine if object belongs to a polygon region or not. Default is 1.<br />
Note that for the moment only 1(Trigonometry) is available.</p>
</td></tr>
<tr><td><code id="popsCompute_+3A_pnt_in_poly_epsilon">pnt_in_poly_epsilon</code></td>
<td>
<p>epsilon to determine if object belongs to a polygon region or not. It only applies when algorithm is 1. Default is 1e-12.</p>
</td></tr>
<tr><td><code id="popsCompute_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="popsCompute_+3A_title_progress">title_progress</code></td>
<td>
<p>character string, giving the title of the progress bar. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="popsCompute_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'IFC_pops'.
</p>


<h3>Source</h3>

<p>For pnt_in_poly_algorithm, Trigonometry, is an adaptation of Jeremy VanDerWal's code <a href="https://github.com/jjvanderwal/SDMTools">https://github.com/jjvanderwal/SDMTools</a>
</p>

<hr>
<h2 id='popsCopy'>Copy Populations from One File to Another File</h2><span id='topic+popsCopy'></span>

<h3>Description</h3>

<p>Copies populations from a DAF file into a copy of another DAF file.
Only creates new file with copied population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsCopy(
  from,
  into,
  write_to,
  pops,
  use_regex = FALSE,
  overwrite = FALSE,
  append_name = TRUE,
  offset = 0,
  endianness = .Platform$endian,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsCopy_+3A_from">from</code></td>
<td>
<p>path to file to copy populations from.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_into">into</code></td>
<td>
<p>path to file that will be used as a template to copy population into.
Caution, it is mandatory that 'into' contains 'from' starting at 'offset'.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'into'<br />
-%p: with first parent directory of 'into'<br />
-%e: with extension of 'into' (without leading .)<br />
-%s: with shortname from 'into' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. Note that it has to be a .daf.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_pops">pops</code></td>
<td>
<p>regular expression or vector of desired populations present in 'from'.<br />
If missing, the default, all populations found will be copied.<br />
If given but not found, a warning will be sent.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_use_regex">use_regex</code></td>
<td>
<p>whether to use regex to pick up population into 'from'. Default is FALSE.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite existing file or not. Default is FALSE.
Note that if TRUE, it will overwrite exported file if path of 'into' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
Otherwise, you will get an error saying that overwriting original file is not allowed.<br /></p>
</td></tr>
<tr><td><code id="popsCopy_+3A_append_name">append_name</code></td>
<td>
<p>whether to append_name basename(from) to exported populations. Default is TRUE.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_offset">offset</code></td>
<td>
<p>Object number of 1st object of 'from' in 'into'. Default is 0.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="popsCopy_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Populations are exported as tagged populations.
</p>


<h3>Value</h3>

<p>a new file is created containing exported populations.<br />
It invisibly returns full path of exported file.
</p>

<hr>
<h2 id='popsGetAffiliation'>IFC_pops Affiliation Finder</h2><span id='topic+popsGetAffiliation'></span>

<h3>Description</h3>

<p>Helper that extracts populations dependencies/affiliations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsGetAffiliation(pops, operators = c("And", "Or", "Not", "(", ")"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsGetAffiliation_+3A_pops">pops</code></td>
<td>
<p>list of populations</p>
</td></tr>
</table>

<hr>
<h2 id='popsGetLevels'>IFC_pops Levels Dependency Determination</h2><span id='topic+popsGetLevels'></span>

<h3>Description</h3>

<p>Helper that extract population levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsGetLevels(pops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsGetLevels_+3A_pops">pops</code></td>
<td>
<p>list of populations.</p>
</td></tr>
</table>

<hr>
<h2 id='popsGetObjectsIds'>IFC_pops Object Numbers</h2><span id='topic+popsGetObjectsIds'></span>

<h3>Description</h3>

<p>Retrieves objects ids belonging to a population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsGetObjectsIds(obj, pop = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsGetObjectsIds_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="popsGetObjectsIds_+3A_pop">pop</code></td>
<td>
<p>a population name from 'obj'. Default is &quot;&quot;.
If left as is or not found an error is thrown displaying all available population in 'obj'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf)
  obj &lt;- popsGetObjectsIds(obj = daf, pop = names(daf$pops)[length(daf$pops)])
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='popsGetSiblings'>IFC_pops Sibling Population Identification</h2><span id='topic+popsGetSiblings'></span>

<h3>Description</h3>

<p>Gives names of graphical pops's siblings in a 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsGetSiblings(obj, pops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsGetSiblings_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="popsGetSiblings_+3A_pops">pops</code></td>
<td>
<p>graphical populations names to get siblings of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>names of population siblings.
</p>

<hr>
<h2 id='popsGetSiblings1'>IFC_pops Sibling Population from Same Base Identification</h2><span id='topic+popsGetSiblings1'></span>

<h3>Description</h3>

<p>Gives names of graphical pops's siblings in a 'IFC_data' object.
Siblings are built from a same population but different regions drawn on axes
of same feature(s) with same transformation(s) applied if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsGetSiblings1(obj, pops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsGetSiblings1_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="popsGetSiblings1_+3A_pops">pops</code></td>
<td>
<p>graphical populations names to get siblings of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>names of population siblings.
</p>

<hr>
<h2 id='popsGetSiblings2'>IFC_pops Sibling Population from Same Region Identification</h2><span id='topic+popsGetSiblings2'></span>

<h3>Description</h3>

<p>Gives names of graphical pops's siblings in a 'IFC_data' object.
Siblings are built from different populations but a same region drawn on axes
of same feature(s) with same transformation(s) applied if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsGetSiblings2(obj, pops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsGetSiblings2_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="popsGetSiblings2_+3A_pops">pops</code></td>
<td>
<p>graphical populations names to get siblings of.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>names of population siblings.
</p>

<hr>
<h2 id='popsNetwork'>IFC_pops Network Display</h2><span id='topic+popsNetwork'></span>

<h3>Description</h3>

<p>Builds and displays populations network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsNetwork(
  obj,
  hierarchical = TRUE,
  color_mode = "white",
  highlight = NULL,
  seed = NULL,
  direction = "LR",
  weighted = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsNetwork_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="popsNetwork_+3A_hierarchical">hierarchical</code></td>
<td>
<p>whether to display network using a hierarchical layout or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="popsNetwork_+3A_color_mode">color_mode</code></td>
<td>
<p>Whether to extract colors from 'obj' in &quot;white&quot; or &quot;black&quot; mode. Default is &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="popsNetwork_+3A_highlight">highlight</code></td>
<td>
<p>population to permanently highlight. If found in 'obj', this population will be displayed with its color. Default is NULL.</p>
</td></tr>
<tr><td><code id="popsNetwork_+3A_seed">seed</code></td>
<td>
<p>If you provide a seed manually, the layout will be the same every time. Default is NULL.</p>
</td></tr>
<tr><td><code id="popsNetwork_+3A_direction">direction</code></td>
<td>
<p>The direction of the hierarchical layout. Default is 'LR'.<br />
The available options are: 'UD', 'DU', 'LR', 'RL'. To simplify: up-down, down-up, left-right, right-left.</p>
</td></tr>
<tr><td><code id="popsNetwork_+3A_weighted">weighted</code></td>
<td>
<p>whether to scale population's node size according to count. Default is TRUE.</p>
</td></tr>
<tr><td><code id="popsNetwork_+3A_...">...</code></td>
<td>
<p>other argument to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <span class="pkg">visNetwork</span> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  daf &lt;- ExtractFromDAF(fileName = file_daf)
  popsNetwork(obj = daf)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='popsOrderNodes'>IFC_pops Population Level Ordering</h2><span id='topic+popsOrderNodes'></span>

<h3>Description</h3>

<p>Helper that sort populations so that populations that depend from other are placed after.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsOrderNodes(pops)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsOrderNodes_+3A_pops">pops</code></td>
<td>
<p>list of populations.</p>
</td></tr>
</table>

<hr>
<h2 id='popsRename'>Populations Renaming</h2><span id='topic+popsRename'></span>

<h3>Description</h3>

<p>Renames populations in an 'IFC_data' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsRename(
  obj,
  old_names = character(),
  new_names = character(),
  loops = 10L,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsRename_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data'.</p>
</td></tr>
<tr><td><code id="popsRename_+3A_old_names">old_names</code></td>
<td>
<p>character vector of name(s) of population(s) to rename inside 'obj'. Default is character().</p>
</td></tr>
<tr><td><code id="popsRename_+3A_new_names">new_names</code></td>
<td>
<p>character vector of desired new population(s) name(s). Default is character().</p>
</td></tr>
<tr><td><code id="popsRename_+3A_loops">loops</code></td>
<td>
<p>a positive integer specifying the maximum number of recursive loops before raising an error. Default is 10L.</p>
</td></tr>
<tr><td><code id="popsRename_+3A_verbose">verbose</code></td>
<td>
<p>whether to show a final message about the renaming. Default is TRUE.</p>
</td></tr>
<tr><td><code id="popsRename_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class 'IFC_data'.
</p>

<hr>
<h2 id='popsRetrieveGraph'>Graph Retrieval from Graphical IFC_pops</h2><span id='topic+popsRetrieveGraph'></span>

<h3>Description</h3>

<p>Retrieves the graph a graphical population originate from
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsRetrieveGraph(obj, pops, vis2D = "density", all_siblings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsRetrieveGraph_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted by ExtractFromDAF(extract_features = TRUE) or ExtractFromXIF(extract_features = TRUE).</p>
</td></tr>
<tr><td><code id="popsRetrieveGraph_+3A_pops">pops</code></td>
<td>
<p>names of graphical populations present in 'obj'. Note that they should be siblings.</p>
</td></tr>
<tr><td><code id="popsRetrieveGraph_+3A_vis2d">vis2D</code></td>
<td>
<p>when original graph is not an histogram, whether to display it as &quot;scatter&quot; or &quot;density&quot;. Default is &quot;density&quot;.</p>
</td></tr>
<tr><td><code id="popsRetrieveGraph_+3A_all_siblings">all_siblings</code></td>
<td>
<p>whether to add all 'pop' siblings in the graph. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of parameters needed to build an IFC graph.
</p>

<hr>
<h2 id='popsWithin'>IFC_pops Checker for Object Membership to Populations</h2><span id='topic+popsWithin'></span>

<h3>Description</h3>

<p>Helper that will be used by popsCompute to determine which objects are within populations or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popsWithin(
  pops,
  regions,
  features,
  pnt_in_poly_algorithm = 1,
  pnt_in_poly_epsilon = 1e-12,
  display_progress = TRUE,
  title_progress = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popsWithin_+3A_pops">pops</code></td>
<td>
<p>list of populations.</p>
</td></tr>
<tr><td><code id="popsWithin_+3A_regions">regions</code></td>
<td>
<p>list of regions.</p>
</td></tr>
<tr><td><code id="popsWithin_+3A_features">features</code></td>
<td>
<p>dataframe of features.</p>
</td></tr>
<tr><td><code id="popsWithin_+3A_pnt_in_poly_algorithm">pnt_in_poly_algorithm</code></td>
<td>
<p>algorithm used to determine if object belongs to a polygon region or not. Default is 1.<br />
Note that for the moment only 1(Trigonometry) is available.</p>
</td></tr>
<tr><td><code id="popsWithin_+3A_pnt_in_poly_epsilon">pnt_in_poly_epsilon</code></td>
<td>
<p>epsilon to determine if object belongs to a polygon region or not. It only applies when algorithm is 1. Default is 1e-12.</p>
</td></tr>
<tr><td><code id="popsWithin_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="popsWithin_+3A_title_progress">title_progress</code></td>
<td>
<p>character string, giving the title of the progress bar. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="popsWithin_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Source</h3>

<p>For pnt_in_poly_algorithm, Trigonometry, is an adaptation of Jeremy VanDerWal's code <a href="https://github.com/jjvanderwal/SDMTools">https://github.com/jjvanderwal/SDMTools</a>
</p>

<hr>
<h2 id='pow2'>Power of Two</h2><span id='topic+pow2'></span>

<h3>Description</h3>

<p>Raise values to power of two
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pow2(x)
</code></pre>

<hr>
<h2 id='protectn'>Name Protection</h2><span id='topic+protectn'></span>

<h3>Description</h3>

<p>Helper to protect population/region name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>protectn(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="protectn_+3A_name">name</code></td>
<td>
<p>population/region names</p>
</td></tr>
</table>

<hr>
<h2 id='pseudo_seed'>Pseudo Seed</h2><span id='topic+pseudo_seed'></span>

<h3>Description</h3>

<p>Creates seed from a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo_seed(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pseudo_seed_+3A_x">x</code></td>
<td>
<p>a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer.
</p>

<hr>
<h2 id='random_name'>Random Name Generator</h2><span id='topic+random_name'></span>

<h3>Description</h3>

<p>Generates random name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_name(
  n = 10,
  ALPHA = LETTERS,
  alpha = letters,
  num = 0L:9L,
  special = c("#", "@", "?", "!", "&amp;", "%", "$"),
  forbidden = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_name_+3A_n">n</code></td>
<td>
<p>number of characters of the desired return name. Default is 10.</p>
</td></tr>
<tr><td><code id="random_name_+3A_alpha">ALPHA</code></td>
<td>
<p>upper case letters. Default is LETTERS.</p>
</td></tr>
<tr><td><code id="random_name_+3A_alpha">alpha</code></td>
<td>
<p>lower case letters. Default is letters.</p>
</td></tr>
<tr><td><code id="random_name_+3A_num">num</code></td>
<td>
<p>integer to use. Default is 0:9</p>
</td></tr>
<tr><td><code id="random_name_+3A_special">special</code></td>
<td>
<p>characters. Default is c(&quot;#&quot;, &quot;@&quot;, &quot;?&quot;, &quot;!&quot;, &quot;&amp;&quot;, &quot;%&quot;, &quot;$&quot;).</p>
</td></tr>
<tr><td><code id="random_name_+3A_forbidden">forbidden</code></td>
<td>
<p>forbidden character vector. Default is character().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'forbidden' should not encompass all possible returned value otherwise the function will never end.
</p>


<h3>Value</h3>

<p>a character string.
</p>

<hr>
<h2 id='rasterplot'>Fast 2D plot</h2><span id='topic+rasterplot'></span>

<h3>Description</h3>

<p>Creates fast 2D plots with Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterplot(
  x,
  y = NULL,
  pch = ".",
  size = 7,
  alpha = 255,
  col = "black",
  rgba = NULL,
  force = FALSE,
  draw = TRUE,
  new = is.null(bg_),
  interpolate = FALSE,
  width = 512,
  height = 512,
  pntsonedge = FALSE,
  blur_size = 9,
  blur_sd = 3,
  bg_ = NULL,
  bg_map = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterplot_+3A_x">x</code>, <code id="rasterplot_+3A_y">y</code></td>
<td>
<p>the x and y coordinates for the plot. If 'y' is NULL, it will be same as 'x'.
x and y should have same length.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_pch">pch</code></td>
<td>
<p>a vector of plotting symbols. Default is &quot;.&quot; (resulting in a 1-pixel dot). Allowed are 0 to 20 and &quot;.&quot;. It will be repeated along 'x'. 
With the exception of &quot;.&quot;, NA resulting its coercion to integer(s) from the conversion will be omitted
(i.e. points won't be displayed, but their x-y coordinates will account for xlim, ylim range computation when not provided through ...).
Everything else (coercible to integer) will result in a dot (a 1-pixel pixel).</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_size">size</code></td>
<td>
<p>an integer vector giving the size(s) of the 'pch'. Default is 7. It will be repeated along 'x'.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_alpha">alpha</code></td>
<td>
<p>a [0,255] integer. Default is 255.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_col">col</code></td>
<td>
<p>a vector of desired colors of the symbols that will be passed by grDevices::col2rgb('x', alpha = TRUE). Default is &quot;black&quot;.
If number of colors equals number of points every point will be assigned this color.
Otherwise, if color is of length 1 for a single combination of size / pch, all points with this combination will be assigned this color.
Finally, if there is only one combination of size / pch and color not equals 1 nor the total number of points,
then, colors will be used as a gradient for density (in such case 'blur_size' and 'blur_sd' will be taken in consideration)
This only applies when 'force' is FALSE.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_rgba">rgba</code></td>
<td>
<p>a 4 rows color matrix, with rows being Red, Green, Blue and Alpha and number of columns identical to number of points.<br />
/!\ When provided this argument will take precedence over 'col' and 'alpha'.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_force">force</code></td>
<td>
<p>whether to force scatter instead of density when multiple 'col' are provided</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_draw">draw</code></td>
<td>
<p>whether to draw to plot (when TRUE), or to image only (when FALSE). Default is TRUE.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_new">new</code></td>
<td>
<p>whether a new plot should be created, only applies when 'draw' is TRUE. Default is is.null(bg_).
If FALSE, the current plot will be used to draw points.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_interpolate">interpolate</code></td>
<td>
<p>whether to use linear interpolation, only applies when 'draw' is TRUE. Default is FALSE.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_width">width</code></td>
<td>
<p>the desired width of the raster Default is 512. It only applies when draw is FALSE.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_height">height</code></td>
<td>
<p>the desired height of the raster Default is 512. It only applies when draw is FALSE.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_pntsonedge">pntsonedge</code></td>
<td>
<p>whether points outside of plotting region should be bounded on the edge. Default is FALSE to clip points.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_blur_size">blur_size</code></td>
<td>
<p>(for density) an integer controlling the size of the blurring gaussian kernel. Default is 9.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_blur_sd">blur_sd</code></td>
<td>
<p>(for density) a double controlling the sd of the blurring gaussian kernel. Default is 3.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_bg_">bg_</code></td>
<td>
<p>an 'rasterplot' object as returned by rasterplot() that will be used to add points to. Default is NULL.
If provided it will have to be compatible with current drawing size or 'width' and 'height' when 'draw' is FALSE.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_bg_map">bg_map</code></td>
<td>
<p>whether to use 'bg_' when provided to compute points coordinates. Default is TRUE.
This allows to get same &quot;user&quot; to &quot;pixel&quot; coordinates conversion as the one used to create 'bg_'.</p>
</td></tr>
<tr><td><code id="rasterplot_+3A_...">...</code></td>
<td>
<p>other arguments to pass to graphics::plot().
For example, providing xlim and/or ylim will controls if point will be shown or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>some examples:<br />
set.seed(2)<br />
n_points = 1e7; n_clusters = 5<br />
x = c(t(sapply(1:5, FUN = function(i) rnorm(n_points / n_clusters, mean = sample(-2:2, size = 1), sd = 1/sample(1:10, 1)))))<br />
y = c(t(sapply(1:5, FUN = function(i) rnorm(n_points / n_clusters, mean = sample(-2:2, size = 1), sd = 1/sample(1:10, 1)))))<br />
# plot points<br />
rasterplot(x = x, y = y, col = &quot;black&quot;)<br />
# generate img<br />
rasterplot(x = x, y = y, col = &quot;black&quot;, draw = FALSE)<br />
# plot multiple shapes<br />
rasterplot(x = x, y = y, pch = c(3,5,9,10,2))<br />
# plot multiple shapes + colors<br />
bg_ = rasterplot(x = x, y = y, pch = c(3,5,9,10,2), col = c(&quot;plum&quot;, &quot;green&quot;, &quot;indianred&quot;, &quot;blue&quot;, &quot;black&quot;))<br />
# addition of new points to an already drawn background, it a kind of points(...)<br />
rasterplot(x = x[1:1e5], y = y[1:1e5], col = &quot;black&quot;, bg_ = bg_, bg_map = TRUE)<br />
# plot 1 shape  + multiple colors<br />
rasterplot(x = x, y = y, pch = &quot;.&quot;, col = c(&quot;plum&quot;, &quot;green&quot;, &quot;indianred&quot;, &quot;blue&quot;, &quot;black&quot;), force = TRUE)<br />
# density<br />
rasterplot(x = x, y = y, pch = 20, size = 7, draw = TRUE, col = colorRampPalette(c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;))(100))<br />
# density with limits<br />
rasterplot(x = x, y = y, draw = TRUE, xlim = c(0, 1.5), pntsonedge = FALSE, col = colorRampPalette(c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;))(100))<br />
# density with limits + computation on drawn points only<br />
rasterplot(x = x, y = y, draw = TRUE, xlim = c(0, 1.5), pntsonedge = TRUE, col = colorRampPalette(c(&quot;blue&quot;, &quot;green&quot;, &quot;red&quot;))(100))<br />
# using rgba<br />
col = c(&quot;plum&quot;, &quot;green&quot;, &quot;indianred&quot;, &quot;blue&quot;, &quot;black&quot;)<br />
rgba = col2rgb(col, alpha = TRUE)<br />
rgba = t(apply(rgba, 1, FUN = function(x) rep(x, length.out = n_points)))<br />
rasterplot(x = x, y = y, pch = &quot;.&quot;, rgba = rgba, draw = TRUE)
</p>


<h3>Value</h3>

<p>an [0, 255] integer array of (height, width, 4) of class 'rasterplot'
</p>

<hr>
<h2 id='readFCS'>FCS File Parser</h2><span id='topic+readFCS'></span>

<h3>Description</h3>

<p>Parse data from Flow Cytometry Standard (FCS) compliant files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFCS(
  fileName,
  options = list(header = list(start = list(at = 0, n = 6), space = list(at = 6, n =
    4), text_beg = list(at = 10, n = 8), text_end = list(at = 18, n = 8), data_beg =
    list(at = 26, n = 8), data_end = list(at = 34, n = 8)), apply_scale = TRUE, dataset =
    1, force_header = FALSE, text_only = FALSE, text_check = FALSE, text_empty = FALSE,
    text_trim = "none"),
  display_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFCS_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="readFCS_+3A_options">options</code></td>
<td>
<p>list of options used to parse FCS file. It should contain (otherwise, it will be filled with the default values listed below):<br />
- header, a list whose members define the &quot;at&quot; offset from header$start$at and the &quot;n&quot; number of bytes to extract:<br />
&ndash; start: where to start reading current FCS dataset.       Default is list(at = 0,  n = 6),<br />
&ndash; space: where to retrieve space.                          Default is list(at = 6,  n = 4),<br />
&ndash; text_beg: where to retrieve file text segment beginning. Default is list(at = 10, n = 8),<br />
&ndash; text_end: where to retrieve file text segment end.       Default is list(at = 18, n = 8),<br />
&ndash; data_beg: where to retrieve file data segment beginning. Default is list(at = 26, n = 8),<br />
&ndash; data_end: where to retrieve file data segment end.       Default is list(at = 34, n = 8),<br />
- apply_scale, whether to apply data scaling. It only applies when fcs file is stored as DATATYPE &quot;I&quot;. Default is TRUE.<br />
- dataset, (coerced to) an ordered vector of unique indices of desired dataset(s) to extract. Default is 1 to extract only the first dataset, whereas NULL allows to extract all available datasets.<br />
- force_header, whether to force the use of header to determine the position of data segment. Default is FALSE, for using positions found in &quot;$BEGINDATA&quot; and &quot;$ENDDATA&quot; keywords.<br />
- text_only, whether to only extract text segment. Default is FALSE.<br />
- text_check, whether to check text segment is compliant with FCS specifications. Default is FALSE.<br />
- text_empty, whether to allow empty values when parsing text segment. Default is FALSE.<br />
- text_trim, remove whitespace in keywords names. Default is &quot;none&quot;. Allowed are &quot;both&quot;, &quot;left&quot;, &quot;right&quot; and &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="readFCS_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="readFCS_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'options' may be tweaked according to file type, instrument and software used to generate it.<br />
Default 'options' should allow to read most files.<br />
'options' members with the exception of 'header' may be passed thanks to '...'.
</p>


<h3>Value</h3>

<p>a list whose elements are lists for each dataset stored within the file.<br />
each sub-list contains:<br />
- header, list of header information corresponding to 'options'<br />
- delimiter, unique character used to separate keyword-value pairs<br />
- text, list of keywords values,<br />
- data, data.frame of values.
</p>


<h3>Source</h3>

<p>Data File Standard for Flow Cytometry, version FCS 3.1 from Spidlen J. et al. available at doi: <a href="https://doi.org/10.1002/cyto.a.20825">10.1002/cyto.a.20825</a>.
</p>

<hr>
<h2 id='readFCSdata'>FCS Data Parser</h2><span id='topic+readFCSdata'></span>

<h3>Description</h3>

<p>Helper to parse data segment from Flow Cytometry Standard (FCS) compliant files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFCSdata(
  fileName,
  text,
  start = 0,
  end = 0,
  scale = TRUE,
  display_progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFCSdata_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="readFCSdata_+3A_text">text</code></td>
<td>
<p>a named list of keywords values.</p>
</td></tr>
<tr><td><code id="readFCSdata_+3A_start">start</code></td>
<td>
<p>offset of text start. Default is 0.</p>
</td></tr>
<tr><td><code id="readFCSdata_+3A_end">end</code></td>
<td>
<p>offset of text end. Default is 0.</p>
</td></tr>
<tr><td><code id="readFCSdata_+3A_scale">scale</code></td>
<td>
<p>whether to apply data scaling. It only applies when fcs file is stored as DATATYPE &quot;I&quot;. Default is TRUE.<br /></p>
</td></tr>
<tr><td><code id="readFCSdata_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="readFCSdata_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='readFCSdataset'>FCS Dataset Parser</h2><span id='topic+readFCSdataset'></span>

<h3>Description</h3>

<p>Helper to parse dataset from Flow Cytometry Standard (FCS) compliant files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFCSdataset(fileName, options, display_progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFCSdataset_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="readFCSdataset_+3A_options">options</code></td>
<td>
<p>list of options used to parse FCS file. It should contain (otherwise, it will be filled with the default values listed below):<br />
- header, a list whose members define the &quot;at&quot; offset from header$start$at and the &quot;n&quot; number of bytes to extract:<br />
&ndash; start: where to start reading current FCS dataset.       Default is list(at = 0,  n = 6),<br />
&ndash; space: where to retrieve space.                          Default is list(at = 6,  n = 4),<br />
&ndash; text_beg: where to retrieve file text segment beginning. Default is list(at = 10, n = 8),<br />
&ndash; text_end: where to retrieve file text segment end.       Default is list(at = 18, n = 8),<br />
&ndash; data_beg: where to retrieve file data segment beginning. Default is list(at = 26, n = 8),<br />
&ndash; data_end: where to retrieve file data segment end.       Default is list(at = 34, n = 8),<br />
- apply_scale, whether to apply data scaling. It only applies when fcs file is stored as DATATYPE &quot;I&quot;. Default is TRUE.<br />
- dataset, (coerced to) an ordered vector of unique indices of desired dataset(s) to extract. Default is 1 to extract only the first dataset, whereas NULL allows to extract all available datasets.<br />
- force_header, whether to force the use of header to determine the position of data segment. Default is FALSE, for using positions found in &quot;$BEGINDATA&quot; and &quot;$ENDDATA&quot; keywords.<br />
- text_only, whether to only extract text segment. Default is FALSE.<br />
- text_check, whether to check if text segment is compliant with FCS specifications. Default is FALSE.<br />
- text_empty, whether to allow empty values when parsing text segment. Default is FALSE.<br />
- text_trim, remove whitespace in keywords names. Default is &quot;none&quot;. Allowed are &quot;both&quot;, &quot;left&quot;, &quot;right&quot; and &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="readFCSdataset_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="readFCSdataset_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'options' may be tweaked according to file type, instrument and software used to generate it.<br />
Default 'options' should allow to read most files.<br />
'options' members with the exception of 'header' may be passed thanks to '...'.
</p>


<h3>Value</h3>

<p>a list containing:<br />
- options, list of 'options' used<br />
- header, list of header information corresponding to 'options'<br />
- delimiter, unique character used to separate keyword-value pairs<br />
- text, list of keywords values,<br />
- data, data.frame of values.
</p>

<hr>
<h2 id='readFCSdelimiter'>FCS Delimiter Reader</h2><span id='topic+readFCSdelimiter'></span>

<h3>Description</h3>

<p>Helper to extract delimiter from Flow Cytometry Standard (FCS) compliant files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFCSdelimiter(fileName, at = 58, version = 3, encoding = "UTF-8", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFCSdelimiter_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="readFCSdelimiter_+3A_at">at</code></td>
<td>
<p>offset of delimiter. Default is 58.</p>
</td></tr>
<tr><td><code id="readFCSdelimiter_+3A_version">version</code></td>
<td>
<p>version to check keywords compliance against. Default is 3.0.</p>
</td></tr>
<tr><td><code id="readFCSdelimiter_+3A_encoding">encoding</code></td>
<td>
<p>name of the encoding for raw to character conversion. Default is &quot;UTF-8&quot;.</p>
</td></tr>
<tr><td><code id="readFCSdelimiter_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='readFCSheader'>FCS Header Parser</h2><span id='topic+readFCSheader'></span>

<h3>Description</h3>

<p>Helper to parse header segment from Flow Cytometry Standard (FCS) compliant files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFCSheader(fileName, header, encoding = "UTF-8", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFCSheader_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="readFCSheader_+3A_header">header</code></td>
<td>
<p>a list whose members define the &quot;at&quot; offset from header$start$at and the &quot;n&quot; number of bytes to extract:<br />
- start: where to start reading current FCS dataset.       Default is list(at = 0,  n = 6),<br />
- space: where to retrieve space.                          Default is list(at = 6,  n = 4),<br />
- text_beg: where to retrieve file text segment beginning. Default is list(at = 10, n = 8),<br />
- text_end: where to retrieve file text segment end.       Default is list(at = 18, n = 8),<br />
- data_beg: where to retrieve file data segment beginning. Default is list(at = 26, n = 8),<br />
- data_end: where to retrieve file data segment end.       Default is list(at = 34, n = 8).</p>
</td></tr>
<tr><td><code id="readFCSheader_+3A_encoding">encoding</code></td>
<td>
<p>name of the encoding for raw to character conversion. Default is &quot;UTF-8&quot;.</p>
</td></tr>
<tr><td><code id="readFCSheader_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='readFCStext'>FCS Text Parser</h2><span id='topic+readFCStext'></span>

<h3>Description</h3>

<p>Helper to parse text segment from Flow Cytometry Standard (FCS) compliant files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readFCStext(
  fileName,
  delimiter,
  start = 0,
  end = 0,
  encoding = "UTF-8",
  empty = FALSE,
  trim = "none",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readFCStext_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="readFCStext_+3A_delimiter">delimiter</code></td>
<td>
<p>delimiter used to separate keyword-value pairs. /!\ NOTE that files with 0x00 'delimiter' can _NOT_ be parsed.</p>
</td></tr>
<tr><td><code id="readFCStext_+3A_start">start</code></td>
<td>
<p>offset of text start. Default is 0.</p>
</td></tr>
<tr><td><code id="readFCStext_+3A_end">end</code></td>
<td>
<p>offset of text end. Default is 0.</p>
</td></tr>
<tr><td><code id="readFCStext_+3A_encoding">encoding</code></td>
<td>
<p>name of the encoding for raw to character conversion. Default is &quot;UTF-8&quot;.</p>
</td></tr>
<tr><td><code id="readFCStext_+3A_empty">empty</code></td>
<td>
<p>whether to allow empty values when parsing text segment. Default is FALSE.</p>
</td></tr>
<tr><td><code id="readFCStext_+3A_trim">trim</code></td>
<td>
<p>remove whitespace in keywords names. Default is &quot;none&quot;. Allowed are &quot;both&quot;, &quot;left&quot;, &quot;right&quot; and &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="readFCStext_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>

<hr>
<h2 id='readGatingML'>GatingML File Reader</h2><span id='topic+readGatingML'></span>

<h3>Description</h3>

<p>Extracts GatingML from file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readGatingML(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readGatingML_+3A_filename">fileName</code></td>
<td>
<p>path to file. It should be a .xml file.</p>
</td></tr>
<tr><td><code id="readGatingML_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>reading GatingML files is in development and partly implemented.
For the moment, only files generated with IFC package can be read.
</p>


<h3>Value</h3>

<p>A named list of class 'IFC_gating', whose members are:<br />
-graphs, a list of graphical elements found,<br />
-pops, a list describing populations found,<br />
-regions, a list describing how regions are defined.
</p>

<hr>
<h2 id='readGatingStrategy'>Gating Strategy File Reader</h2><span id='topic+readGatingStrategy'></span>

<h3>Description</h3>

<p>Extracts Gating Strategy from files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readGatingStrategy(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readGatingStrategy_+3A_filename">fileName</code></td>
<td>
<p>path to file. It should be a .ast, .cif, .daf, .ist, .rif or .xml file.</p>
</td></tr>
<tr><td><code id="readGatingStrategy_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class 'IFC_gating', whose members are:<br />
-spillover, a list of spillover matrices found,<br />
-graphs, a list of graphical elements found,<br />
-pops, a list describing populations found,<br />
-regions, a list describing how regions are defined.
</p>

<hr>
<h2 id='readIFC'>IFC Files Generic Reader</h2><span id='topic+readIFC'></span>

<h3>Description</h3>

<p>Reads IFC data from IFC files no matter if they are FCS, DAF, RIF or CIF.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readIFC(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readIFC_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="readIFC_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="#topic+ExtractFromDAF">ExtractFromDAF</a></code> or <code><a href="#topic+ExtractFromXIF">ExtractFromXIF</a></code> or <code><a href="#topic+ExtractFromFCS">ExtractFromFCS</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If input 'fileName' is a DAF file <code><a href="#topic+ExtractFromDAF">ExtractFromDAF</a></code> will be used to read the file.<br />
If it is a CIF or RIF file <code><a href="#topic+readIFC">readIFC</a></code> will use <code><a href="#topic+ExtractFromXIF">ExtractFromXIF</a></code>.<br />
Finally, if 'fileName' is not a DAF, nor a CIF, nor a RIF file <code><a href="#topic+readIFC">readIFC</a></code> will use <code><a href="#topic+ExtractFromFCS">ExtractFromFCS</a></code>.
</p>


<h3>Value</h3>

<p>an object of class 'IFC_data'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a rif file, but you can also read daf or cif
  file_rif &lt;- system.file("extdata", "example.rif", package = "IFCdata")
  rif &lt;- readIFC(fileName = file_rif)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='redefine_features_def'>IFC_features_def Redefinition</h2><span id='topic+redefine_features_def'></span>

<h3>Description</h3>

<p>Helper modify features_def according to masks or images redefinition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redefine_features_def(
  features_def,
  masks,
  images,
  to_match_feat = NULL,
  to_replace_feat = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redefine_features_def_+3A_features_def">features_def</code></td>
<td>
<p>an 'IFC_features_def' object, or a list containing features definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_features_def_+3A_masks">masks</code></td>
<td>
<p>an 'IFC_masks' object or a data.frame containing masks definition and name. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_features_def_+3A_images">images</code></td>
<td>
<p>a data.frame containing images definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_features_def_+3A_to_match_feat">to_match_feat</code></td>
<td>
<p>a string with a features_def name to use for matching 'features_def' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_features_def_+3A_to_replace_feat">to_replace_feat</code></td>
<td>
<p>a string of features_def name to use for replacing 'features_def' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_features_def_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list whose members are:<br />
-features_def, an 'IFC_features_def' object, or a list containing features definition<br />
-masks, an 'IFC_masks' object or a data.frame containing masks definition and name.<br />
-images, a data.frame containing images definition.
</p>

<hr>
<h2 id='redefine_features_def_feat'>IFC_features_def Feature Redefinition</h2><span id='topic+redefine_features_def_feat'></span>

<h3>Description</h3>

<p>Helper to rename a feature within IFC_features_def.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redefine_features_def_feat(
  features_def,
  to_match_feat = NULL,
  to_replace_feat = NULL,
  force_default = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redefine_features_def_feat_+3A_features_def">features_def</code></td>
<td>
<p>an 'IFC_features_def' object or a list containing features definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_features_def_feat_+3A_to_match_feat">to_match_feat</code></td>
<td>
<p>a string with a features_def name to use for matching 'features_def' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_features_def_feat_+3A_to_replace_feat">to_replace_feat</code></td>
<td>
<p>a string of features_def name to use for replacing 'features_def' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_features_def_feat_+3A_force_default">force_default</code></td>
<td>
<p>whether to force default names for features (except the one defined by 'to_replace_feat').
This removes custom names and replaces them with default values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redefine_features_def_feat_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'IFC_features_def' object, or a list containing features definition
</p>

<hr>
<h2 id='redefine_features_def_msk_img'>IFC_features_def Mask or Image Redefinition</h2><span id='topic+redefine_features_def_msk_img'></span>

<h3>Description</h3>

<p>Helper to modify features_def according to masks or images redefinition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redefine_features_def_msk_img(
  features_def,
  masks,
  images,
  force_default = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redefine_features_def_msk_img_+3A_features_def">features_def</code></td>
<td>
<p>an 'IFC_features_def' object, or a list containing features definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_features_def_msk_img_+3A_masks">masks</code></td>
<td>
<p>an 'IFC_masks' object or a data.frame containing masks definition and name. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_features_def_msk_img_+3A_images">images</code></td>
<td>
<p>a data.frame containing images definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_features_def_msk_img_+3A_force_default">force_default</code></td>
<td>
<p>whether to force default names for masks and features.
This removes custom names and replaces them with default values. Default is FALSE.</p>
</td></tr>
<tr><td><code id="redefine_features_def_msk_img_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list whose members are:<br />
-features_def, an 'IFC_features_def' object, or a list containing features definition<br />
-masks, an 'IFC_masks' object or a data.frame containing masks definition and name.<br />
-images, a data.frame containing images definition.
</p>

<hr>
<h2 id='redefine_masks'>IFC_masks Redefinition</h2><span id='topic+redefine_masks'></span>

<h3>Description</h3>

<p>Helper to modify features_def according to masks or images redefinition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redefine_masks(
  masks,
  images,
  new_images_names = images$name,
  to_match_mask = NULL,
  to_replace_mask = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redefine_masks_+3A_masks">masks</code></td>
<td>
<p>an 'IFC_masks' object or a data.frame containing masks definition and name. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_masks_+3A_images">images</code></td>
<td>
<p>a data.frame containing images definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_masks_+3A_new_images_names">new_images_names</code></td>
<td>
<p>a vector of image name to use for replacing 'images' names. Default is images$name</p>
</td></tr>
<tr><td><code id="redefine_masks_+3A_to_match_mask">to_match_mask</code></td>
<td>
<p>a string with a mask name to use for matching 'masks' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_masks_+3A_to_replace_mask">to_replace_mask</code></td>
<td>
<p>a string of mask name to use for replacing 'masks' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_masks_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list whose members are:
-masks, an 'IFC_masks' object or data.frame containing masks definition and name.
-images, a data.frame containing images definition.
</p>

<hr>
<h2 id='redefine_masks_image'>IFC_masks Image Redefinition</h2><span id='topic+redefine_masks_image'></span>

<h3>Description</h3>

<p>Helper to rename images within masks definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redefine_masks_image(masks, images, new_images_names = images$name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redefine_masks_image_+3A_masks">masks</code></td>
<td>
<p>an 'IFC_masks' object or a data.frame containing masks definition and name. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_masks_image_+3A_images">images</code></td>
<td>
<p>a data.frame containing images definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_masks_image_+3A_new_images_names">new_images_names</code></td>
<td>
<p>a vector of image name to use for replacing 'images' names. Default is images$name</p>
</td></tr>
<tr><td><code id="redefine_masks_image_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list whose members are:
-masks, an 'IFC_masks' object or data.frame containing masks definition and name.
-images, a data.frame containing images definition.
</p>

<hr>
<h2 id='redefine_masks_mask'>IFC_masks Mask Redefinition</h2><span id='topic+redefine_masks_mask'></span>

<h3>Description</h3>

<p>Helper to rename a mask within IFC_masks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redefine_masks_mask(
  masks,
  images,
  to_match_mask = NULL,
  to_replace_mask = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redefine_masks_mask_+3A_masks">masks</code></td>
<td>
<p>an 'IFC_masks' object or a data.frame containing masks definition and name. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_masks_mask_+3A_images">images</code></td>
<td>
<p>a data.frame containing images definition. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_masks_mask_+3A_to_match_mask">to_match_mask</code></td>
<td>
<p>a string with a mask name to use for matching 'masks' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_masks_mask_+3A_to_replace_mask">to_replace_mask</code></td>
<td>
<p>a string of mask name to use for replacing 'masks' names. Default is NULL</p>
</td></tr>
<tr><td><code id="redefine_masks_mask_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of masks definition or names depending on definition.
</p>

<hr>
<h2 id='redefine_obj'>IFC_data Redefinition</h2><span id='topic+redefine_obj'></span>

<h3>Description</h3>

<p>Helper to modify images, masks, features, pops, graphs in a 'IFC_data' object when features_def is changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redefine_obj(obj, new_feat_def, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redefine_obj_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object. Default is missing.</p>
</td></tr>
<tr><td><code id="redefine_obj_+3A_new_feat_def">new_feat_def</code></td>
<td>
<p>a list with new definitions from redefine_features_def() or redefine_features_def_msk_img().</p>
</td></tr>
<tr><td><code id="redefine_obj_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'IFC_data' object.
</p>

<hr>
<h2 id='relayout'>Change Graphs Layout</h2><span id='topic+relayout'></span>

<h3>Description</h3>

<p>Reconstructs 'IFC_graphs' object layout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relayout(
  graphs,
  size = 320,
  splitterdistance = 120,
  stats = TRUE,
  byrow = FALSE,
  times = 4,
  layout = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relayout_+3A_graphs">graphs</code></td>
<td>
<p>an 'IFC_graphs' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="relayout_+3A_size">size</code></td>
<td>
<p>Integer, graphs' sizes. Default is 320.</p>
</td></tr>
<tr><td><code id="relayout_+3A_splitterdistance">splitterdistance</code></td>
<td>
<p>Integer. Default is 120.</p>
</td></tr>
<tr><td><code id="relayout_+3A_stats">stats</code></td>
<td>
<p>Logical. Whether to show stats or not. Default is TRUE.</p>
</td></tr>
<tr><td><code id="relayout_+3A_byrow">byrow</code></td>
<td>
<p>Logical. Whether to layout graphs by row or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="relayout_+3A_times">times</code></td>
<td>
<p>Integer. Max number of graphs by row/column (depending on 'byrow'). Default is 4.</p>
</td></tr>
<tr><td><code id="relayout_+3A_layout">layout</code></td>
<td>
<p>Integer matrix. Desired layout. Default is NULL.
When NULL, the default, graphs will be relayout using 'times' and 'byrow' parameters.
Otherwise, layout will be used to determine the position of the graphs (NA value can be used for empty place).
Note that when not NULL layout should contain all indices of graphs only once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an  'IFC_graphs' object
</p>

<hr>
<h2 id='remove_ext'>File Extension Removal</h2><span id='topic+remove_ext'></span>

<h3>Description</h3>

<p>Removes file extension from file path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_ext(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_ext_+3A_x">x</code></td>
<td>
<p>a file path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>file extension will be removed
</p>

<hr>
<h2 id='rev_string'>Reverse String</h2><span id='topic+rev_string'></span>

<h3>Description</h3>

<p>Reverses string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rev_string(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rev_string_+3A_x">x</code></td>
<td>
<p>a character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='setPB'>Progress Bar Updater</h2><span id='topic+setPB'></span>

<h3>Description</h3>

<p>Updates a progress bar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPB(pb, value = NULL, title = NULL, label = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPB_+3A_pb">pb</code></td>
<td>
<p>an object of class 'IFC_progress' containing a progress bar of class 'txtProgressBar', 'winProgressBar' or 'Progress'.</p>
</td></tr>
<tr><td><code id="setPB_+3A_value">value</code></td>
<td>
<p>new value for the progress bar.</p>
</td></tr>
<tr><td><code id="setPB_+3A_title">title</code>, <code id="setPB_+3A_label">label</code></td>
<td>
<p>character strings, giving the 'title'(='message' for shiny progress bar) and the 'label'(='detail' for shiny progress bar).</p>
</td></tr>
</table>

<hr>
<h2 id='smoothAsinh'>Smooth Asinh Transformation</h2><span id='topic+smoothAsinh'></span>

<h3>Description</h3>

<p>Transforms values in asinh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothAsinh(x, hyper = 1000)
</code></pre>

<hr>
<h2 id='smoothLinLog'>Smooth LinLog Transformation</h2><span id='topic+smoothLinLog'></span>

<h3>Description</h3>

<p>Transforms values in lin-log
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothLinLog(x, hyper = 1000, base = 10, lin_comp = log(base))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothLinLog_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="smoothLinLog_+3A_hyper">hyper</code></td>
<td>
<p>value where transition between Lin/Log is applied.</p>
</td></tr>
<tr><td><code id="smoothLinLog_+3A_base">base</code></td>
<td>
<p>base of Log scale.</p>
</td></tr>
<tr><td><code id="smoothLinLog_+3A_lin_comp">lin_comp</code></td>
<td>
<p>value that is used to smooth transition between Lin/Log. Default is log(base).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the smoothLinLog transformation of the input.
</p>

<hr>
<h2 id='specialr'>Special Character Replacement</h2><span id='topic+specialr'></span>

<h3>Description</h3>

<p>Helper to replace special character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specialr(
  string = "",
  replacement = "_",
  specials = "[\\|\\/|\\:|\\*|\\?|\\\"|'|\\&lt;|\\&gt;|\\|]"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specialr_+3A_string">string</code></td>
<td>
<p>string where specials will be replaced if found.</p>
</td></tr>
<tr><td><code id="specialr_+3A_replacement">replacement</code></td>
<td>
<p>string replacement. Default is &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="specialr_+3A_specials">specials</code></td>
<td>
<p>Default is '[\|\/|\:|\*|\?|\&quot;|\'|\&lt;|\&gt;|\|]'.</p>
</td></tr>
</table>

<hr>
<h2 id='split_feat'>IFC_features_def Definition Splitting</h2><span id='topic+split_feat'></span>

<h3>Description</h3>

<p>Helper to split a features definitions within IFC_features_def.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_feat(
  features_def,
  all_names = names(features_def),
  alt_names = NULL,
  m_names = sprintf("M%02i", 1:12),
  i_names = sprintf("Ch%02i", 1:12),
  comb_operators = c("+", "-", "*", "/", "(", ")", "ABS", "COS", "SIN", "SQR", "SQRT"),
  extr_operators = c("true", "false", "True", "False"),
  split = "|",
  force = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_feat_+3A_features_def">features_def</code></td>
<td>
<p>an 'IFC_features_def' object or a list containing features definition. Default is missing.</p>
</td></tr>
<tr><td><code id="split_feat_+3A_all_names">all_names</code></td>
<td>
<p>the names of all allowed names.</p>
</td></tr>
<tr><td><code id="split_feat_+3A_alt_names">alt_names</code></td>
<td>
<p>vector of same length as <code>'all_names'</code> to use for substitution. It can be used to speed up the process.</p>
</td></tr>
<tr><td><code id="split_feat_+3A_m_names">m_names</code></td>
<td>
<p>names of masks.</p>
</td></tr>
<tr><td><code id="split_feat_+3A_i_names">i_names</code></td>
<td>
<p>names of images.</p>
</td></tr>
<tr><td><code id="split_feat_+3A_comb_operators">comb_operators</code></td>
<td>
<p>operators used for combined features. Default is <code>c("+", "-", "*", "/", "(", ")", "ABS", "COS", "SIN", "SQR", "SQRT")</code>.</p>
</td></tr>
<tr><td><code id="split_feat_+3A_extr_operators">extr_operators</code></td>
<td>
<p>operators used for non combined features. Default is <code>c("true", "false", "True", "False")</code>.
Those will be added to <code>'m_names'</code>, <code>'i_names'</code> and all possible features names (as given by the <code>getFromNamespace("featureIFC", "IFC")()</code>).</p>
</td></tr>
<tr><td><code id="split_feat_+3A_split">split</code></td>
<td>
<p>string used for splitting. Default is <code>"|"</code>.</p>
</td></tr>
<tr><td><code id="split_feat_+3A_force">force</code></td>
<td>
<p>whether to force splitting even if <code>'split'</code> is detected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'IFC_features_def' object, or a list containing features definition
</p>

<hr>
<h2 id='splitf'>File Path Decomposition</h2><span id='topic+splitf'></span>

<h3>Description</h3>

<p>Helper that will split file name into chunks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitf(file = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitf_+3A_file">file</code></td>
<td>
<p>path to file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector with chunks of 'file'<br />
dir: full path directory of 'file'<br />
parent: first parent directory of 'file'<br />
ext: 'file' extension without leading dot<br />
short: 'file' with no extension nor dir<br />
input: 'file' path as it was provided.
</p>

<hr>
<h2 id='splitn'>String Decomposition with Operators</h2><span id='topic+splitn'></span>

<h3>Description</h3>

<p>Helper that will split definition into chunks of names and operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitn(
  definition,
  all_names,
  alt_names,
  operators = c("And", "Or", "Not", "(", ")"),
  split = "|",
  scalar = FALSE,
  dsplit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitn_+3A_definition">definition</code></td>
<td>
<p>definition to be split</p>
</td></tr>
<tr><td><code id="splitn_+3A_all_names">all_names</code></td>
<td>
<p>the names of all allowed names.</p>
</td></tr>
<tr><td><code id="splitn_+3A_alt_names">alt_names</code></td>
<td>
<p>vector of same length as 'all_names' to use for substitution. It can be used to speed up the process.</p>
</td></tr>
<tr><td><code id="splitn_+3A_operators">operators</code></td>
<td>
<p>operators used. Default is c(&quot;And&quot;, &quot;Or&quot;, &quot;Not&quot;, &quot;(&quot;, &quot;)&quot;).</p>
</td></tr>
<tr><td><code id="splitn_+3A_split">split</code></td>
<td>
<p>string used for splitting. Default is &quot;|&quot;.</p>
</td></tr>
<tr><td><code id="splitn_+3A_scalar">scalar</code></td>
<td>
<p>whether to allow presence of scalar or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="splitn_+3A_dsplit">dsplit</code></td>
<td>
<p>whether to allow presence of duplicated occurrences of 'split' or not. Default is FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='splitp'>String Decomposition with Placeholders</h2><span id='topic+splitp'></span>

<h3>Description</h3>

<p>Helper aiming to detect placeholder pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitp(write_to = "%d/%s_fromR.%e")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitp_+3A_write_to">write_to</code></td>
<td>
<p>string. Default is &quot;%d/%s_fromR.%e&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>-%s: shortname (i.e. basename without extension)<br />
-%p: first parent directory<br />
-%d: full path directory<br />
-%e: file extension<br />
-%o: object id<br />
-%c: channel
</p>

<hr>
<h2 id='StatsReport'>Statistical Report Generation</h2><span id='topic+StatsReport'></span>

<h3>Description</h3>

<p>Generates stats report from 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatsReport(obj, stats)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="StatsReport_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object.</p>
</td></tr>
<tr><td><code id="StatsReport_+3A_stats">stats</code></td>
<td>
<p>template defining stats to compute as extracted by getSTATSREPORT().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector with extracted statistics.
</p>

<hr>
<h2 id='subsetOffsets'>IFC_offset Subsetting</h2><span id='topic+subsetOffsets'></span>

<h3>Description</h3>

<p>Subsets 'IFC_offset'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetOffsets(offsets, objects, image_type = c("img", "msk"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetOffsets_+3A_offsets">offsets</code></td>
<td>
<p>object of class 'IFC_offset' to subset.</p>
</td></tr>
<tr><td><code id="subsetOffsets_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to extract.</p>
</td></tr>
<tr><td><code id="subsetOffsets_+3A_image_type">image_type</code></td>
<td>
<p>image_type of desired offsets. Default is c(&quot;img&quot;, &quot;msk&quot;). Allowed are &quot;img&quot; and/or &quot;msk&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a class 'IFC_offset' integer vector or empty integer() if objects are outside of offsets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  ## use a cif file
  file_cif &lt;- system.file("extdata", "example.cif", package = "IFCdata")
  ## extract offsets
  offsets &lt;- getOffsets(fileName = file_cif)
  ## subset offsets of the 4 first "img" objects
  sub_offs &lt;- subsetOffsets(offsets = offsets, objects = 0:3, image_type = "img")
  ## show subsetted offsets' structure
  str(sub_offs)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='subsetXIF'>RIF/CIF File Subsetting</h2><span id='topic+subsetXIF'></span>

<h3>Description</h3>

<p>Subsets RIF or CIF files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetXIF(
  fileName,
  write_to,
  objects,
  offsets,
  fast = TRUE,
  extract_features = FALSE,
  endianness = .Platform$endian,
  verbose = FALSE,
  verbosity = 1,
  overwrite = FALSE,
  display_progress = TRUE,
  add_tracking = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetXIF_+3A_filename">fileName</code></td>
<td>
<p>path of file to subset.
It has to be a '.rif' or '.cif' file.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'fileName'<br />
-%p: with first parent directory of 'fileName'<br />
-%e: with extension of 'fileName' (without leading .)<br />
-%s: with shortname from 'fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. It has to be the same as 'fileName', i.e. .cif or .rif.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use. If missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_offsets">offsets</code></td>
<td>
<p>object of class &lsquo;IFC_offset'. If missing, the default, offsets will be extracted from &rsquo;fileName'.<br />
This param is not mandatory but it may allow to save time for repeated XIF export on same file.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_fast">fast</code></td>
<td>
<p>whether to fast extract 'objects' or not. Default is TRUE.
Meaning that 'objects' will be extracted expecting that 'objects' are stored in ascending order.<br />
Note that a warning will be sent if an 'object' is found at an unexpected order.
In such a case you may need to rerun function with 'fast' = FALSE.
If set to FALSE, all raw object_ids will be scanned from 'fileName' to ensure extraction of desired 'objects'.<br />
IMPORTANT: whatever this argument is, features are extracted assuming an ascending order of storage in file.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_extract_features">extract_features</code></td>
<td>
<p>whether to try to extract features. Default is FALSE.
IMPORTANT: it is not clear if how features are stored and which objects they rely to when input file is already a merge or a subset.
For this reason it should be carefully checked.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_verbosity">verbosity</code></td>
<td>
<p>quantity of information displayed when verbose is TRUE; 1: normal, 2: rich. Default is 1.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.<br />
Note that if TRUE, it will overwrite exported file if path of 'fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
Otherwise, you will get an error saying that overwriting original file is not allowed.<br /></p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_add_tracking">add_tracking</code></td>
<td>
<p>whether to register files' paths and objects' ids in the exported file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="subsetXIF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>when 'extract_features' is set TRUE, only features stored in binary format will be extracted if found.<br />
If the input 'fileName' is a merged of several files then features will be extracted from these files.<br />
If these files can't be found, Warning(s) will be thrown and input 'fileName' will be extracted without features values.
</p>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>

<hr>
<h2 id='swap_channel'>Channel Swap</h2><span id='topic+swap_channel'></span>

<h3>Description</h3>

<p>Swaps Channels within 'IFC_data' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_channel(obj, chan1, chan2, BF = TRUE, MODE = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_channel_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="swap_channel_+3A_chan1">chan1</code>, <code id="swap_channel_+3A_chan2">chan2</code></td>
<td>
<p>an integer index of channel. 'chan1' and 'chan2' should be different.</p>
</td></tr>
<tr><td><code id="swap_channel_+3A_bf">BF</code></td>
<td>
<p>should 'from' channel be considered as brightfield. Default is TRUE.</p>
</td></tr>
<tr><td><code id="swap_channel_+3A_mode">MODE</code></td>
<td>
<p>collection mode (as retrieved by getInfo) determining the range. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'BF' and 'MODE' will be used only if 'chan1' or 'chan2' is not found in 'obj'.<br />
/!\ NOTE: In case of conflict between resulting names, 'chan2' will be preferred, maximizing number of features with 'chan2'.
</p>


<h3>Value</h3>

<p>a list, intended to be passed to 'new_feat_def' argument of getFromNamespace(&quot;redefine_obj&quot;, &quot;IFC&quot;) whose members are:<br />
-features_def, an 'IFC_features_def' object, or a list containing features definition<br />
-masks, an 'IFC_masks' object or a data.frame containing masks definition and name.<br />
-images, a data.frame containing images definition.
</p>

<hr>
<h2 id='switch_channel'>Channel Switch</h2><span id='topic+switch_channel'></span>

<h3>Description</h3>

<p>Switches Channel in 'IFC_data' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>switch_channel(obj, from, to, BF = TRUE, MODE = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="switch_channel_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="switch_channel_+3A_from">from</code>, <code id="switch_channel_+3A_to">to</code></td>
<td>
<p>an integer index of channel. 'from' and 'to' should be different.</p>
</td></tr>
<tr><td><code id="switch_channel_+3A_bf">BF</code></td>
<td>
<p>should 'from' channel be considered as brightfield. Default is TRUE.</p>
</td></tr>
<tr><td><code id="switch_channel_+3A_mode">MODE</code></td>
<td>
<p>collection mode (as retrieved by getInfo) determining the range. Default is 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'BF' and 'MODE' will be used only if 'to' is not found in 'obj'.<br />
If switching channel results in duplicated features definition, e.g. &quot;Intensity_M01_Ch01&quot; and &quot;Intensity_M04_Ch04&quot; exists in 'from'
and user called switch_channel(obj, 4, 1). So, &quot;Intensity_M01_Ch01&quot; will become &quot;Intensity_M01_Ch01&quot; (the same) and,
&quot;Intensity_M04_Ch04&quot; will become &quot;Intensity_M01_Ch01&quot;. Meaning that resulting &quot;Intensity_M01_Ch01&quot; can originate from
either &quot;Intensity_M01_Ch01&quot; or &quot;Intensity_M04_Ch04&quot;. In such case duplicates will be collected in 'dup' member of attr(, &quot;map&quot;).<br />
/!\ Note also that 'initial' member of attr(, &quot;map&quot;) will always be the one of 'from', i.e. &quot;Intensity_M01_Ch01&quot; will be mapped with &quot;Intensity_M04_Ch04&quot; .
</p>


<h3>Value</h3>

<p>a list, intended to be passed to 'new_feat_def' argument of getFromNamespace(&quot;redefine_obj&quot;, &quot;IFC&quot;) whose members are:<br />
-features_def, an 'IFC_features_def' object, or a list containing features definition<br />
-masks, an 'IFC_masks' object or a data.frame containing masks definition and name.<br />
-images, a data.frame containing images definition.
</p>

<hr>
<h2 id='testXIF'>RIF/CIF Image Order Test</h2><span id='topic+testXIF'></span>

<h3>Description</h3>

<p>Tests order of IFD within RIF and XIF file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testXIF(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testXIF_+3A_filename">fileName</code></td>
<td>
<p>path of file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer<br />
-1: not a XIF file<br />
0: non regular XIF file, i.e. no mask found after 1st Image itself after 1st IFD<br />
+1: regular XIF file, i.e. a mask is found after 1st Image itself after 1st IFD.
</p>

<hr>
<h2 id='texttomatrix'>Text to Image Conversion</h2><span id='topic+texttomatrix'></span>

<h3>Description</h3>

<p>Converts string to matrix of 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>texttomatrix(text = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="texttomatrix_+3A_text">text</code></td>
<td>
<p>a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>at symbol @ is a special character used for scale
</p>

<hr>
<h2 id='to_list_node'>XML Node to List Conversion</h2><span id='topic+to_list_node'></span>

<h3>Description</h3>

<p>Helper to convert xml node to R list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_list_node(x, max = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_list_node_+3A_x">x</code></td>
<td>
<p>A document, node, or node set.</p>
</td></tr>
<tr><td><code id="to_list_node_+3A_max">max</code></td>
<td>
<p>maximum number of recurrence into subnodes. Default is 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>it acts as_list but value returned is different, with attributes
expanded to sublists rather than recovered as attributes
</p>

<hr>
<h2 id='to_xml_list'>List to XML Node Conversion</h2><span id='topic+to_xml_list'></span>

<h3>Description</h3>

<p>Helper to convert R list to xml node (character representation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_xml_list(x, name, kids, indent = "  ", escape = "\n")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_xml_list_+3A_x">x</code></td>
<td>
<p>a list to convert</p>
</td></tr>
<tr><td><code id="to_xml_list_+3A_name">name</code></td>
<td>
<p>name of the node to create</p>
</td></tr>
<tr><td><code id="to_xml_list_+3A_kids">kids</code></td>
<td>
<p>a list containing children xml nodes elements (each elements should come from to_xml_list)</p>
</td></tr>
<tr><td><code id="to_xml_list_+3A_indent">indent</code></td>
<td>
<p>indent used for kids when provided. Default is &quot;  &quot;.</p>
</td></tr>
<tr><td><code id="to_xml_list_+3A_escape">escape</code></td>
<td>
<p>escape used for kids when provided. Default is &quot;\n&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>it acts as_list but value returned is different, with attributes
expanded to sublists rather than recovered as attributes
</p>

<hr>
<h2 id='toBIN_features'>IFC_features Raw Conversion</h2><span id='topic+toBIN_features'></span>

<h3>Description</h3>

<p>Helper to convert features ('IFC_features' object) to raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toBIN_features(
  features,
  w_con = raw(),
  endianness = .Platform$endian,
  verbose = FALSE,
  display_progress = TRUE,
  title_progress = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toBIN_features_+3A_features">features</code></td>
<td>
<p>an 'IFC_features' object.</p>
</td></tr>
<tr><td><code id="toBIN_features_+3A_w_con">w_con</code></td>
<td>
<p>a connection opened for writing. Default is raw().</p>
</td></tr>
<tr><td><code id="toBIN_features_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="toBIN_features_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
<tr><td><code id="toBIN_features_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="toBIN_features_+3A_title_progress">title_progress</code></td>
<td>
<p>character string, giving the title of the progress bar. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="toBIN_features_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a raw vector of features binaries.
</p>

<hr>
<h2 id='toBIN_images'>IFC_images Raw Conversion</h2><span id='topic+toBIN_images'></span>

<h3>Description</h3>

<p>Helper to convert images ('IFC_images' object) to raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toBIN_images(
  images,
  w_con = raw(),
  endianness = .Platform$endian,
  verbose = FALSE,
  display_progress = TRUE,
  title_progress = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toBIN_images_+3A_images">images</code></td>
<td>
<p>an 'IFC_images' object.</p>
</td></tr>
<tr><td><code id="toBIN_images_+3A_w_con">w_con</code></td>
<td>
<p>a connection opened for writing. Default is raw().</p>
</td></tr>
<tr><td><code id="toBIN_images_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="toBIN_images_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
<tr><td><code id="toBIN_images_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="toBIN_images_+3A_title_progress">title_progress</code></td>
<td>
<p>character string, giving the title of the progress bar. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="toBIN_images_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an raw vector of images binaries.
</p>

<hr>
<h2 id='toCapFirstOnly'>First Letter Only Capitalization</h2><span id='topic+toCapFirstOnly'></span>

<h3>Description</h3>

<p>Helper to capitalize the first letter of strings and leave the rest to lower case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toCapFirstOnly(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toCapFirstOnly_+3A_text">text</code></td>
<td>
<p>a string</p>
</td></tr>
</table>

<hr>
<h2 id='toEllipse'>Ellipsoid Polygon Constructor</h2><span id='topic+toEllipse'></span>

<h3>Description</h3>

<p>Helper to transform gate boundaries to ellipsoid polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toEllipse(gate, theta = 2 * pi, npoints = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toEllipse_+3A_gate">gate</code></td>
<td>
<p>list containing x and y ellipse boundaries coordinates.</p>
</td></tr>
<tr><td><code id="toEllipse_+3A_theta">theta</code></td>
<td>
<p>rotation angle of the ellipse. Default is 2*pi. It should not be modified since ellipse gate are axis-aligned.</p>
</td></tr>
<tr><td><code id="toEllipse_+3A_npoints">npoints</code></td>
<td>
<p>number of polygon vertices desired.</p>
</td></tr>
</table>

<hr>
<h2 id='toXML2_boolpop_gs'>Boolean Population GatingML Conversion to XML2</h2><span id='topic+toXML2_boolpop_gs'></span>

<h3>Description</h3>

<p>Helper to convert boolean population to XML nodes in GatingML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_boolpop_gs(obj, pop, already = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_boolpop_gs_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object.</p>
</td></tr>
<tr><td><code id="toXML2_boolpop_gs_+3A_pop">pop</code></td>
<td>
<p>a member of 'IFC_pops' object.</p>
</td></tr>
<tr><td><code id="toXML2_boolpop_gs_+3A_already">already</code></td>
<td>
<p>already attributed names. Default is character().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of xml_node.
</p>

<hr>
<h2 id='toXML2_features'>IFC_features XML Conversion</h2><span id='topic+toXML2_features'></span>

<h3>Description</h3>

<p>Helper to convert features ('IFC_features' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_features(
  features,
  verbose = FALSE,
  display_progress = TRUE,
  title_progress = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_features_+3A_features">features</code></td>
<td>
<p>an 'IFC_features' object.</p>
</td></tr>
<tr><td><code id="toXML2_features_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="toXML2_features_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="toXML2_features_+3A_title_progress">title_progress</code></td>
<td>
<p>character string, giving the title of the progress bar. Default is <code>""</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_features_def'>IFC_features_def XML Conversion</h2><span id='topic+toXML2_features_def'></span>

<h3>Description</h3>

<p>Helper to convert features definition ('IFC_features_def' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_features_def(features_def, verbose = verbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_features_def_+3A_features_def">features_def</code></td>
<td>
<p>an <code>`IFC_features_def`</code> object.</p>
</td></tr>
<tr><td><code id="toXML2_features_def_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a XML::xmlNode.
</p>

<hr>
<h2 id='toXML2_graphpop_gs'>Graphical Population GatingML Conversion to XML2</h2><span id='topic+toXML2_graphpop_gs'></span>

<h3>Description</h3>

<p>Helper to convert pops and regions to XML nodes in GatingML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_graphpop_gs(pop, reg, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_graphpop_gs_+3A_pop">pop</code></td>
<td>
<p>a member of 'IFC_pops' object.</p>
</td></tr>
<tr><td><code id="toXML2_graphpop_gs_+3A_reg">reg</code></td>
<td>
<p>a member of 'IFC_regions' object.</p>
</td></tr>
<tr><td><code id="toXML2_graphpop_gs_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_graphs'>IFC_graphs XML Conversion</h2><span id='topic+toXML2_graphs'></span>

<h3>Description</h3>

<p>Helper to convert graphs ('IFC_graphs' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_graphs(graphs, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_graphs_+3A_graphs">graphs</code></td>
<td>
<p>an 'IFC_graphs' object.</p>
</td></tr>
<tr><td><code id="toXML2_graphs_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_graphs_gs'>IFC_graphs GatingML Conversion</h2><span id='topic+toXML2_graphs_gs'></span>

<h3>Description</h3>

<p>Helper to convert graphs ('IFC_graphs' object) to XML nodes in GatingML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_graphs_gs(graphs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_graphs_gs_+3A_graphs">graphs</code></td>
<td>
<p>an 'IFC_graphs' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_images'>IFC_images XML Conversion</h2><span id='topic+toXML2_images'></span>

<h3>Description</h3>

<p>Helper to convert images ('IFC_images' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_images(
  images,
  verbose = FALSE,
  display_progress = TRUE,
  title_progress = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_images_+3A_images">images</code></td>
<td>
<p>an 'IFC_images' object.</p>
</td></tr>
<tr><td><code id="toXML2_images_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
<tr><td><code id="toXML2_images_+3A_title_progress">title_progress</code></td>
<td>
<p>character string, giving the title of the progress bar. Default is &quot;&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_masks'>IFC_masks XML Conversion</h2><span id='topic+toXML2_masks'></span>

<h3>Description</h3>

<p>Helper to convert masks ('IFC_masks' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_masks(masks, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_masks_+3A_masks">masks</code></td>
<td>
<p>an 'IFC_masks' object.</p>
</td></tr>
<tr><td><code id="toXML2_masks_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_pops'>IFC_pops XML Conversion</h2><span id='topic+toXML2_pops'></span>

<h3>Description</h3>

<p>Helper to convert populations ('IFC_pops' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_pops(
  pops,
  verbose = FALSE,
  display_progress = TRUE,
  title_progress = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_pops_+3A_pops">pops</code></td>
<td>
<p>an 'IFC_pops' object.</p>
</td></tr>
<tr><td><code id="toXML2_pops_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
<tr><td><code id="toXML2_pops_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="toXML2_pops_+3A_title_progress">title_progress</code></td>
<td>
<p>character string, giving the title of the progress bar. Default is &quot;&quot;.</p>
</td></tr>
<tr><td><code id="toXML2_pops_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_regions'>IFC_regions XML Conversion</h2><span id='topic+toXML2_regions'></span>

<h3>Description</h3>

<p>Helper to convert regions ('IFC_regions' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_regions(regions, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_regions_+3A_regions">regions</code></td>
<td>
<p>an 'IFC_regions' object.</p>
</td></tr>
<tr><td><code id="toXML2_regions_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_spillover_gs'>Spillover GatingML Conversion</h2><span id='topic+toXML2_spillover_gs'></span>

<h3>Description</h3>

<p>Helper to convert spillover to XML nodes in GatingML files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_spillover_gs(spillover, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_spillover_gs_+3A_spillover">spillover</code></td>
<td>
<p>a spillover matrix. It has to have colnames and rownames.</p>
</td></tr>
<tr><td><code id="toXML2_spillover_gs_+3A_name">name</code></td>
<td>
<p>the name to use to identify the node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='toXML2_stats'>IFC_stats XML Conversion</h2><span id='topic+toXML2_stats'></span>

<h3>Description</h3>

<p>Helper to convert stats ('IFC_stats' object) to XML nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toXML2_stats(stats, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toXML2_stats_+3A_stats">stats</code></td>
<td>
<p>an 'IFC_stats' object.</p>
</td></tr>
<tr><td><code id="toXML2_stats_+3A_verbose">verbose</code></td>
<td>
<p>whether to display message about current action. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a xml_node.
</p>

<hr>
<h2 id='trunc_string'>String Truncation</h2><span id='topic+trunc_string'></span>

<h3>Description</h3>

<p>Truncates character strings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trunc_string(x, n = 22)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trunc_string_+3A_x">x</code></td>
<td>
<p>a string</p>
</td></tr>
<tr><td><code id="trunc_string_+3A_n">n</code></td>
<td>
<p>desired length</p>
</td></tr>
</table>


<h3>Details</h3>

<p>x will be truncated according to 'n' parameter. If x is longer than n '...' are appended.
</p>

<hr>
<h2 id='tryReportFileCreation'>Report File Creation</h2><span id='topic+tryReportFileCreation'></span>

<h3>Description</h3>

<p>Checks if report files can be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tryReportFileCreation(fileName, write_to, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tryReportFileCreation_+3A_filename">fileName</code></td>
<td>
<p>default fileName path.</p>
</td></tr>
<tr><td><code id="tryReportFileCreation_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file(s).
Placeholders, like c(&quot;%d/%s_fromR.pdf&quot;, &quot;%d/%s_fromR.csv&quot;), will be substituted:<br />
-%d: with full path directory of 'fileName'<br />
-%p: with first parent directory of 'fileName'<br />
-%e: with extension of 'fileName' (without leading .)<br />
-%s: with shortname from 'fileName' (i.e. basename without extension).<br />
Exported file(s) extension(s) will be deduced from this pattern. Note that has to be a .pdf and/or .csv.</p>
</td></tr>
<tr><td><code id="tryReportFileCreation_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.
Note that if TRUE, it will overwrite file. In addition a warning message will be sent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with path(s) to pdf and csv file and overwritten status
</p>

<hr>
<h2 id='type_constr'>Histogram Type Constructor</h2><span id='topic+type_constr'></span>

<h3>Description</h3>

<p>Helper to construct histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_constr(x, br, type, include.lowest = TRUE, right = TRUE, plot = FALSE)
</code></pre>


<h3>Source</h3>

<p>derived from <span class="pkg">lattice</span> from Deepayan Sarkar
</p>

<hr>
<h2 id='usedefault_obj'>IFC_data Default Naming</h2><span id='topic+usedefault_obj'></span>

<h3>Description</h3>

<p>Helper to reset masks and features names to their default values in a 'IFC_data' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usedefault_obj(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="usedefault_obj_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object. Default is missing.</p>
</td></tr>
<tr><td><code id="usedefault_obj_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'IFC_data' object.
</p>

<hr>
<h2 id='val_constr'>Histogram Val Constructor</h2><span id='topic+val_constr'></span>

<h3>Description</h3>

<p>Helper to construct histogram
</p>


<h3>Usage</h3>

<pre><code class='language-R'>val_constr(x, h, type)
</code></pre>


<h3>Source</h3>

<p>derived from <span class="pkg">lattice</span> from Deepayan Sarkar
</p>

<hr>
<h2 id='validate_bool'>Boolean Expression Validation</h2><span id='topic+validate_bool'></span>

<h3>Description</h3>

<p>Helper to check if a boolean vector is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_bool(x = "", all_names = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_bool_+3A_x">x</code></td>
<td>
<p>a string vector representing the boolean expression to be validated.</p>
</td></tr>
<tr><td><code id="validate_bool_+3A_all_names">all_names</code></td>
<td>
<p>a character vector of scalars which are allowed to be part of the the boolean expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x is returned if no exception is raised during validation process.
</p>

<hr>
<h2 id='whoami'>Input Identification</h2><span id='topic+whoami'></span>

<h3>Description</h3>

<p>Helper that identifies input arguments thanks to their IFC classes even if they are not or mis named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whoami(
  entries = as.list(match.call()),
  search = list(info = "IFC_info", param = "IFC_param", offsets = "IFC_offset"),
  reinit = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whoami_+3A_entries">entries</code></td>
<td>
<p>arguments from the function <code><a href="#topic+whoami">whoami</a></code> is called.
/!\ <code><a href="#topic+whoami">whoami</a></code> MUST be called explicitly this way: whoami(entries = as.list(match.call())).</p>
</td></tr>
<tr><td><code id="whoami_+3A_search">search</code></td>
<td>
<p>a non duplicated named list of classes to search for entries.</p>
</td></tr>
<tr><td><code id="whoami_+3A_reinit">reinit</code></td>
<td>
<p>whether to reinitialize arguments to their default values in called environment. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if two argument of the same 'search' class are found an error will be thrown.
'fileName' will be searched every time.<br />
-at first, as an argument (named or not) of the class designated in 'search' to be the &quot;fileName&quot;,<br />
-otherwise, as an argument (named or not) of class 'fileName',<br />
-otherwise, as a named argument of name &quot;fileName&quot; that was not found using 'search',<br />
-and finally, if still not found as the first not named argument not found in 'search' of type string.
</p>


<h3>Value</h3>

<p>a list whose members are 'fileName': value of fileName if provided as a named argument 
in entries and all classes defined in 'search'
</p>

<hr>
<h2 id='with_seed'>With Seed Evaluation</h2><span id='topic+with_seed'></span>

<h3>Description</h3>

<p>Evaluates expression with a seed and resets to initial seed state on exit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_seed(
  expr,
  seed = NA_integer_,
  kind = NULL,
  normal.kind = NULL,
  sample.kind = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="with_seed_+3A_expr">expr</code></td>
<td>
<p>expression to evaluate.</p>
</td></tr>
<tr><td><code id="with_seed_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer, or NULL, with the exception that NA can be provided to prevent passing 'seed' argument. Default is NA_integer_.</p>
</td></tr>
<tr><td><code id="with_seed_+3A_kind">kind</code></td>
<td>
<p>character or NULL. If kind is a character string, set R's RNG to the kind desired. Use &quot;default&quot; to return to the R default.</p>
</td></tr>
<tr><td><code id="with_seed_+3A_normal.kind">normal.kind</code></td>
<td>
<p>character string or NULL. If it is a character string, set the method of Normal generation. Use &quot;default&quot; to return to the R default. NULL makes no change.</p>
</td></tr>
<tr><td><code id="with_seed_+3A_sample.kind">sample.kind</code></td>
<td>
<p>character string or NULL. If it is a character string, set the method of discrete uniform generation (used in sample, for instance). Use &quot;default&quot; to return to the R default. NULL makes no change. Only applies on R version &gt;= 3.6.0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see ‘Details’, from  <a href="base.html#topic+set.seed">set.seed</a>, with the exception of 'seed'. Using seed = NA_integer_, NOTHING will be passed to <a href="base.html#topic+set.seed">set.seed</a> nor <a href="base.html#topic+RNGkind">RNGkind</a> and NOTHING will be restored once done.
Otherwise, <a href="base.html#topic+set.seed">set.seed</a> will be used and once done <a href="base.html#topic+RNGkind">RNGkind</a> will be restored and &quot;.Random.seed&quot; from <a href="base.html#topic+globalenv">globalenv</a> set back to its initial value (included removed if it did not exist).
</p>

<hr>
<h2 id='writeGatingStrategy'>Gating Strategy File Writer</h2><span id='topic+writeGatingStrategy'></span>

<h3>Description</h3>

<p>Writes GatingML from an 'IFC_data' object to a xml file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeGatingStrategy(
  obj,
  write_to,
  overwrite = FALSE,
  display_progress = TRUE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeGatingStrategy_+3A_obj">obj</code></td>
<td>
<p>an 'IFC_data' object extracted with features extracted.</p>
</td></tr>
<tr><td><code id="writeGatingStrategy_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'obj$fileName'<br />
-%p: with first parent directory of 'obj$fileName'<br />
-%e: with extension of 'obj$fileName' (without leading .)<br />
-%s: with shortname from 'obj$fileName' (i.e. basename without extension).<br />
Exported file extension will be deduced from this pattern. Note that it has to be a .xml.</p>
</td></tr>
<tr><td><code id="writeGatingStrategy_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.</p>
</td></tr>
<tr><td><code id="writeGatingStrategy_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="writeGatingStrategy_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="writeGatingStrategy_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partial implementation of ISAC's Gating-ML 2.0 data exchange standard for gating description.
See Josef Spidlen et al. Cytometry A 87 683-687 (2015). doi: <a href="https://doi.org/10.1002/cyto.a.22690">10.1002/cyto.a.22690</a><br />
GatingML is partly implemented because:<br />
-Tagged population are not part of GatingML gates<br />
-IDEAS/INSPIRE regions are different from the collection of gates listed in GatingML. Notably,<br />
&ndash;only 1 or 2 dimensions gates will be used,
&ndash;range gates and quadrant gates are absent from IDEAS/INSPIRE
&ndash;ellipse gates exist in IDEAS/INSPIRE but are axis aligned and not rotated.
-Transformation applied in <span class="pkg">IFC</span> is not part of GatingML.
Nonetheless, when possible additional information are provided in dedicated custom_info field.
</p>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>

<hr>
<h2 id='writeIFC'>IFC Files Generic Writer</h2><span id='topic+writeIFC'></span>

<h3>Description</h3>

<p>Writes IFC data to DAF and subsets or merges RIF/CIF Files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeIFC(fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeIFC_+3A_filename">fileName</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="writeIFC_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="#topic+ExportToDAF">ExportToDAF</a></code>, <code><a href="#topic+ExportToXIF">ExportToXIF</a></code>, <code><a href="#topic+ExportToFCS">ExportToFCS</a></code>, or <code><a href="#topic+data_to_DAF">data_to_DAF</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an &lsquo;IFC_data' object is provided as &rsquo;fileName' or in '...' <code><a href="#topic+ExportToFCS">ExportToFCS</a></code> or <code><a href="#topic+data_to_DAF">data_to_DAF</a></code> will be used to export object.
Otherwise, if 'fileName' is a DAF file <code><a href="#topic+ExportToDAF">ExportToDAF</a></code> will be used to write file whereas if it is RIF or CIF file(s) <code><a href="#topic+writeIFC">writeIFC</a></code> will use <code><a href="#topic+ExportToXIF">ExportToXIF</a></code>.
</p>


<h3>Value</h3>

<p>it invisible returns the path of exported file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("IFCdata", quietly = TRUE)) {
  tmp &lt;- tempdir(check = TRUE)
  ## use a daf file
  file_daf &lt;- system.file("extdata", "example.daf", package = "IFCdata")
  ## create a tagged population named test with 1st object
  pop &lt;- buildPopulation(name = "test", type = "T", obj = 0)
  writeIFC(file_daf, write_to = paste0(tmp, "\\test_write.daf"),
           overwrite = TRUE, pops = list(pop))
  ## use a rif file, but you can also use a cif
  file_rif &lt;- system.file("extdata", "example.rif", package = "IFCdata")
  writeIFC(fileName = file_rif, write_to = paste0(tmp, "\\test_write.rif"), 
           overwrite = TRUE, objects = 0)
} else {
  message(sprintf('Please run `install.packages("IFCdata", repos = "%s", type = "source")` %s',
                  'https://gitdemont.github.io/IFCdata/',
                  'to install extra files required to run this example.'))
}
</code></pre>

<hr>
<h2 id='writeIFD'>Image Field Directory Writer</h2><span id='topic+writeIFD'></span>

<h3>Description</h3>

<p>Writes Image Field Directory (IFD)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeIFD(
  ifd,
  r_con,
  w_con,
  pos = 0,
  extra = NULL,
  endianness = .Platform$endian,
  last = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeIFD_+3A_ifd">ifd</code></td>
<td>
<p>an ifd extracted by cpp_fastTAGS</p>
</td></tr>
<tr><td><code id="writeIFD_+3A_r_con">r_con</code></td>
<td>
<p>a connection opened for reading</p>
</td></tr>
<tr><td><code id="writeIFD_+3A_w_con">w_con</code></td>
<td>
<p>a connection opened for writing</p>
</td></tr>
<tr><td><code id="writeIFD_+3A_pos">pos</code></td>
<td>
<p>current position within 'w_con'. Default is 0.</p>
</td></tr>
<tr><td><code id="writeIFD_+3A_extra">extra</code></td>
<td>
<p>extra entries to add to 'ifd'. Default is NULL</p>
</td></tr>
<tr><td><code id="writeIFD_+3A_endianness">endianness</code></td>
<td>
<p>the desired endian-ness (&quot;big&quot; or &quot;little&quot;). Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the position within 'w_con' after 'IFD' and 'extra' content have been written<br />
</p>

<hr>
<h2 id='XIFtoTIFF'>RIF/CIF File Conversion to TIFF</h2><span id='topic+XIFtoTIFF'></span>

<h3>Description</h3>

<p>Converts and subsets RIF or CIF files to TIFF.
This function is experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XIFtoTIFF(
  fileName,
  write_to,
  objects,
  offsets,
  fast = TRUE,
  endianness = .Platform$endian,
  verbose = FALSE,
  verbosity = 1,
  overwrite = FALSE,
  display_progress = TRUE,
  add_tracking = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XIFtoTIFF_+3A_filename">fileName</code></td>
<td>
<p>path of file to subset.
It has to be a '.rif' or '.cif' file.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_write_to">write_to</code></td>
<td>
<p>pattern used to export file.
Placeholders, like &quot;%d/%s_fromR.%e&quot;, will be substituted:<br />
-%d: with full path directory of 'fileName'<br />
-%p: with first parent directory of 'fileName'<br />
-%e: with extension of 'fileName' (without leading .)<br />
-%s: with shortname from 'fileName' (i.e. basename without extension).<br />
Exported file extension has to be .tif or .tiff.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_objects">objects</code></td>
<td>
<p>integer vector, IDEAS objects ids numbers to use. If missing, the default, all objects will be used.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_offsets">offsets</code></td>
<td>
<p>object of class &lsquo;IFC_offset'. If missing, the default, offsets will be extracted from &rsquo;fileName'.<br />
This param is not mandatory but it may allow to save time for repeated XIF export on same file.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_fast">fast</code></td>
<td>
<p>whether to fast extract 'objects' or not. Default is TRUE.
Meaning that 'objects' will be extracted expecting that 'objects' are stored in ascending order.<br />
Note that a warning will be sent if an 'object' is found at an unexpected order.
In such a case you may need to rerun function with 'fast' = FALSE.
If set to FALSE, all raw object_ids will be scanned from 'fileName' to ensure extraction of desired 'objects'.<br />
IMPORTANT: whatever this argument is, features are extracted assuming an ascending order of storage in file.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_endianness">endianness</code></td>
<td>
<p>The endian-ness (&quot;big&quot; or &quot;little&quot;) of the target system for the file. Default is .Platform$endian.<br />
Endianness describes the bytes order of data stored within the files. This parameter may not be modified.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_verbose">verbose</code></td>
<td>
<p>whether to display information (use for debugging purpose). Default is FALSE.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_verbosity">verbosity</code></td>
<td>
<p>quantity of information displayed when verbose is TRUE; 1: normal, 2: rich. Default is 1.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_overwrite">overwrite</code></td>
<td>
<p>whether to overwrite file or not. Default is FALSE.<br />
Note that if TRUE, it will overwrite exported file if path of 'fileName' and deduced from 'write_to' arguments are different.
Otherwise, you will get an error saying that overwriting source file is not allowed.<br />
Note also that an original file, i.e. generated by IDEAS(R) or INSPIRE(R), will never be overwritten.
Otherwise, you will get an error saying that overwriting original file is not allowed.<br /></p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_display_progress">display_progress</code></td>
<td>
<p>whether to display a progress bar. Default is TRUE.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_add_tracking">add_tracking</code></td>
<td>
<p>whether to register files' paths and objects' ids in the exported file. Default is TRUE.</p>
</td></tr>
<tr><td><code id="XIFtoTIFF_+3A_...">...</code></td>
<td>
<p>other arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is experiment and under development inputs and outputs may change in the future
</p>


<h3>Value</h3>

<p>It invisibly returns full path of exported file.
</p>

<hr>
<h2 id='xml_new_node'>List to XML Conversion</h2><span id='topic+xml_new_node'></span>

<h3>Description</h3>

<p>Helper to convert R list to xml node (character representation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_new_node(name, attrs, .children, text, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xml_new_node_+3A_name">name</code></td>
<td>
<p>name of the node to create.</p>
</td></tr>
<tr><td><code id="xml_new_node_+3A_attrs">attrs</code></td>
<td>
<p>a named list of name-value pairs to be used as attributes for the XML node.</p>
</td></tr>
<tr><td><code id="xml_new_node_+3A_.children">.children</code></td>
<td>
<p>a list containing XML node elements or content.</p>
</td></tr>
<tr><td><code id="xml_new_node_+3A_text">text</code></td>
<td>
<p>the text content for the new XML node.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an R object that points to the C-level structure instance.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
