<!DOCTYPE html><html lang="en-GB"><head><title>Help for package ggsurveillance</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggsurveillance}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#align_dates_seasonal'><p>Align dates for seasonal comparison</p></a></li>
<li><a href='#create_agegroups'><p>Create Age Groups from Numeric Values</p></a></li>
<li><a href='#geom_epicurve'><p>Create an epidemic curve plot or bin/count observations by date periods</p></a></li>
<li><a href='#geom_epigantt'><p>Epi Gantt Chart: Visualize Epidemiological Time Intervals</p></a></li>
<li><a href='#geom_vline_year'><p>Automatically create lines at the turn of every year</p></a></li>
<li><a href='#geometric_mean'><p>Compute a Geometric Mean</p></a></li>
<li><a href='#influenza_germany'><p>Germany Influenza (FLU) Surveillance data</p></a></li>
<li><a href='#linelist_hospital_outbreak'><p>Line list of a fictional hospital outbreak (Data)</p></a></li>
<li><a href='#scale_y_cases_5er'><p>Continuous x-axis and y-axis scale for (case) counts</p></a></li>
<li><a href='#scale_y_discrete_reverse'><p>Reversed discrete scale for 'ggplot2'</p></a></li>
<li><a href='#uncount'><p>Duplicate rows according to a weighting variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tools for Outbreak Investigation/Infectious Disease Surveillance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Create epicurves or epigantt charts in 'ggplot2'. Prepare
    data for visualisation or other reporting for infectious disease
    surveillance and outbreak investigation. Includes tidy functions to solve
    date based transformations for common reporting tasks, like 
    (A) seasonal date alignment for respiratory disease surveillance, 
    (B) date-based case binning based on specified time intervals like
    isoweek, epiweek, month and more, (C) automated detection and marking
    of the new year based on the date/datetime axis of the 'ggplot2'. 
    An introduction on how to use epicurves can be found on the US CDC website 
    (2012, <a href="https://www.cdc.gov/training/quicklearns/epimode/index.html">https://www.cdc.gov/training/quicklearns/epimode/index.html</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ggsurveillance.biostats.dev">https://ggsurveillance.biostats.dev</a>,
<a href="https://github.com/biostats-dev/ggsurveillance">https://github.com/biostats-dev/ggsurveillance</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/biostats-dev/ggsurveillance/issues">https://github.com/biostats-dev/ggsurveillance/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr, forcats, ggplot2, glue, ISOweek, lubridate, rlang,
scales, stringr, tidyr, tidyselect, tsibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Hmisc, knitr, outbreaks, rmarkdown, spelling, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-02 10:23:11 UTC; Alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Bartel <a href="https://orcid.org/0000-0002-1280-6138"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Bartel &lt;alexander.bartel@fu-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-02 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='align_dates_seasonal'>Align dates for seasonal comparison</h2><span id='topic+align_dates_seasonal'></span><span id='topic+align_and_bin_dates_seasonal'></span>

<h3>Description</h3>

<p>Standardizes dates from multiple years to enable comparison of epidemic curves
and visualization of seasonal patterns in infectious disease surveillance data.
Commonly used for creating periodicity plots of respiratory diseases like
influenza, RSV, or COVID-19.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align_dates_seasonal(
  x,
  dates_from = NULL,
  date_resolution = c("week", "isoweek", "epiweek", "day", "month"),
  start = NULL,
  target_year = NULL,
  drop_leap_week = TRUE
)

align_and_bin_dates_seasonal(
  x,
  n = 1,
  dates_from,
  population = 1,
  fill_gaps = FALSE,
  date_resolution = c("week", "isoweek", "epiweek", "day", "month"),
  start = NULL,
  target_year = NULL,
  drop_leap_week = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="align_dates_seasonal_+3A_x">x</code></td>
<td>
<p>Either a data frame with a date column, or a date vector.<br />
Supported date formats are <code>date</code> and <code>datetime</code> and also commonly used character strings:
</p>

<ul>
<li><p> ISO dates <code>"2024-03-09"</code>
</p>
</li>
<li><p> Month <code>"2024-03"</code>
</p>
</li>
<li><p> Week <code>"2024-W09"</code> or <code>"2024-W09-1"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_dates_from">dates_from</code></td>
<td>
<p>Column name containing the dates to align. Used when x is a data.frame.</p>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_date_resolution">date_resolution</code></td>
<td>
<p>Character string specifying the temporal resolution.
One of:
</p>

<ul>
<li> <p><code>"week"</code> or <code>"isoweek"</code> - Calendar weeks (ISO 8601), reporting weeks as used by the ECDC.
</p>
</li>
<li> <p><code>"epiweek"</code> - Epidemiological weeks (US CDC), i.e. ISO weeks with Sunday as week start.
</p>
</li>
<li> <p><code>"month"</code> - Calendar months
</p>
</li>
<li> <p><code>"day"</code> - Daily resolution
</p>
</li></ul>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_start">start</code></td>
<td>
<p>Numeric value indicating epidemic season start:
</p>

<ul>
<li><p> For <code>week/epiweek</code>: week number (default: 28, approximately July)
</p>
</li>
<li><p> For <code>month</code>: month number (default: 7 for July)
</p>
</li>
<li><p> For <code>day</code>: day of year (default: 150, approximately June)
</p>
</li></ul>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_target_year">target_year</code></td>
<td>
<p>Numeric value for the reference year to align dates to. The default target year
is the start of the most recent season in the data. This way the most recent dates stay unchanged.</p>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_drop_leap_week">drop_leap_week</code></td>
<td>
<p>If <code>TRUE</code> and date_resolution is <code>week</code>, <code>isoweek</code> or <code>epiweek</code>, leap weeks (week 53)
are dropped if they are not in the most recent season. Disable if data should be returned.
Dropping week 53 from historical data is the most common approach. Otherwise historical data for week 53 would
map to week 52 if the target season has no leap week, resulting in a doubling of the case counts.</p>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_n">n</code></td>
<td>
<p>Numeric column with case counts. Supports quoted and unquoted column names.</p>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_population">population</code></td>
<td>
<p>A number or a numeric column with the population size. Used to calculate the incidence.</p>
</td></tr>
<tr><td><code id="align_dates_seasonal_+3A_fill_gaps">fill_gaps</code></td>
<td>
<p>Logical; If <code>TRUE</code>, gaps in the time series will be filled with 0 cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function helps create standardized epidemic curves by aligning surveillance
data from different years. This enables:
</p>

<ul>
<li><p> Comparison of disease patterns across multiple seasons
</p>
</li>
<li><p> Identification of typical seasonal trends
</p>
</li>
<li><p> Detection of unusual disease activity
</p>
</li>
<li><p> Assessment of current season against historical patterns
</p>
</li></ul>

<p>The alignment can be done at different temporal resolutions (daily, weekly,
monthly) with customizable season start points to match different disease
patterns or surveillance protocols.
</p>


<h3>Value</h3>

<p>A data frame with standardized date columns:
</p>

<ul>
<li> <p><code>year</code>: Calendar year from original date
</p>
</li>
<li> <p><code>week/month/day</code>: Time unit based on chosen resolution
</p>
</li>
<li> <p><code>date_aligned</code>: Date standardized to target year
</p>
</li>
<li> <p><code>season</code>: Epidemic season identifier (e.g., &quot;2023/24&quot;)
</p>
</li>
<li> <p><code>current_season</code>: Logical flag for most recent season
</p>
</li></ul>

<p>Binning also creates the columns:
</p>

<ul>
<li> <p><code>n</code>: Sum of cases in bin
</p>
</li>
<li> <p><code>incidence</code>: Incidence calculated using n/population
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Sesonal Visualization of Germany Influenza Surveillance Data
library(ggplot2)

influenza_germany |&gt;
  align_dates_seasonal(
    dates_from = ReportingWeek, date_resolution = "epiweek", start = 28
  ) -&gt; df_flu_aligned

ggplot(df_flu_aligned, aes(x = date_aligned, y = Incidence, color = season)) +
  geom_line() +
  facet_wrap(~AgeGroup) +
  theme_bw()

</code></pre>

<hr>
<h2 id='create_agegroups'>Create Age Groups from Numeric Values</h2><span id='topic+create_agegroups'></span>

<h3>Description</h3>

<p>Creates age groups from numeric values using customizable break points and formatting options.
The function allows for flexible formatting and customization of age group labels.
</p>
<p>If a factor is returned, this factor includes factor levels of unobserved age groups.
This allows for reproducible age groups, which can be used for joining data
(e.g. adding age grouped population numbers for incidence calculation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_agegroups(
  values,
  age_breaks = c(5, 10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90),
  breaks_as_lower_bound = TRUE,
  first_group_format = "0-{x}",
  interval_format = "{x}-{y}",
  last_group_format = "{x}+",
  pad_numbers = FALSE,
  pad_with = "0",
  collapse_single_year_groups = FALSE,
  na_label = NA,
  return_factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_agegroups_+3A_values">values</code></td>
<td>
<p>Numeric vector of ages to be grouped</p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_age_breaks">age_breaks</code></td>
<td>
<p>Numeric vector of break points for age groups. <br />
Default: <code>c(5, 10, 15, 20, 25, 30, 40, 50, 60, 70, 80, 90)</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_breaks_as_lower_bound">breaks_as_lower_bound</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), breaks are treated as lower bounds of the intervals.
If <code>FALSE</code>, as upper bounds.</p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_first_group_format">first_group_format</code></td>
<td>
<p>Character string template for the first age group. Uses glue syntax. <br />
Default: <code>"0-{x}"</code>, Other common styles: <code>"&lt;={x}", "&lt;{x+1}"</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_interval_format">interval_format</code></td>
<td>
<p>Character string template for intermediate age groups. Uses glue syntax.<br />
Default: <code>"{x}-{y}"</code>, Other common styles: <code>"{x} to {y}"</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_last_group_format">last_group_format</code></td>
<td>
<p>Character string template for the last age group. Uses glue syntax. <br />
Default: <code>"{x}+"</code>, Other common styles: <code>"&gt;={x}","&gt;{x-1}"</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_pad_numbers">pad_numbers</code></td>
<td>
<p>Logical or numeric; if numeric, pad numbers up to the specified length (Tip: use <code>2</code>).
Not compatible with calculations within glue formats. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_pad_with">pad_with</code></td>
<td>
<p>Character to use for padding numbers. Default: <code>"0"</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_collapse_single_year_groups">collapse_single_year_groups</code></td>
<td>
<p>Logical; if <code>TRUE</code>, groups spanning single years are collapsed. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_na_label">na_label</code></td>
<td>
<p>Label for <code>NA</code> values. If <code>NA</code>, keeps default <code>NA</code> handling. Default: <code>NA</code></p>
</td></tr>
<tr><td><code id="create_agegroups_+3A_return_factor">return_factor</code></td>
<td>
<p>Logical; if <code>TRUE</code>, returns a factor, if <code>FALSE</code> returns character vector. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of age group labels (character or factor depending on return_factor)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic usage
create_agegroups(1:100)

# Custom formatting with upper bounds
create_agegroups(1:100,
  breaks_as_lower_bound = FALSE,
  interval_format = "{x} to {y}",
  first_group_format = "0 to {x}"
)

# Ages 1 to 5 are kept as numbers by collapsing single year groups
create_agegroups(1:10,
  age_breaks = c(1, 2, 3, 4, 5, 10),
  collapse_single_year_groups = TRUE
)

</code></pre>

<hr>
<h2 id='geom_epicurve'>Create an epidemic curve plot or bin/count observations by date periods</h2><span id='topic+geom_epicurve'></span><span id='topic+stat_bin_date'></span><span id='topic+stat_date_count'></span><span id='topic+StatEpicurve'></span><span id='topic+StatBinDate'></span><span id='topic+StatDateCount'></span>

<h3>Description</h3>

<p>Creates a epicurve plot for visualizing epidemic case counts in outbreaks (epidemiological curves).
An epicurve is a bar plot, where every case is outlined. <code>geom_epicurve</code> additionally provides
date-based aggregation of cases (e.g. per week or month and many more).
</p>

<ul>
<li><p> For week aggregation both isoweek (World + ECDC) and epiweek (US CDC) are supported.
</p>
</li>
<li> <p><code>stat_bin_date</code> and its alias <code>stat_date_count</code> provide date based binning only. After binning the by date, these
stats behave like <a href="ggplot2.html#topic+geom_bar">ggplot2::stat_count</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>geom_epicurve(
  mapping = NULL,
  data = NULL,
  stat = "epicurve",
  position = "stack",
  date_resolution = NULL,
  week_start = getOption("lubridate.week.start", 1),
  width = NULL,
  relative.width = 1,
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin_date(
  mapping = NULL,
  data = NULL,
  geom = "line",
  position = "identity",
  date_resolution = NULL,
  week_start = getOption("lubridate.week.start", 1),
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_date_count(
  mapping = NULL,
  data = NULL,
  geom = "line",
  position = "identity",
  date_resolution = NULL,
  week_start = getOption("lubridate.week.start", 1),
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_epicurve_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes</a></code>. Commonly used mappings:
</p>

<ul>
<li> <p><strong>x or y</strong>: date or datetime. Numeric is technically supported.
</p>
</li>
<li> <p><strong>fill</strong>: for colouring groups
</p>
</li>
<li> <p><strong>weight</strong>: if data is already aggregated (e.g. case counts)
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_data">data</code></td>
<td>
<p>The data frame containing the variables for the plot</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_stat">stat</code></td>
<td>
<p>either &quot;<code>epicurve</code>&quot; for outlines around cases or &quot;<code>bin_date</code>&quot; for outlines around (fill) groups.
For large numbers of cases please use &quot;<code>bin_date</code>&quot; to reduce the number of drawn rectangles.</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_position">position</code></td>
<td>
<p>Position adjustment. Currently supports &quot;<code>stack</code>&quot; for <code>geom_epicurve()</code>.</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_date_resolution">date_resolution</code></td>
<td>
<p>Character string specifying the time unit for date aggregation.
Set to <code>NULL</code> or <code>NA</code> for no date aggregation <br />
Possible values are: <code>"day"</code>, <code>"week"</code>, <code>"month"</code>, <code>"bimonth"</code>, <code>"season"</code>, <code>"quarter"</code>, <code>"halfyear"</code>, <code>"year"</code>.
To special values enforce ISO or US week standard:
</p>

<ul>
<li> <p><code>isoweek</code> will force <code>dadte_resolution = week</code> and <code>week_start = 1</code> (ISO and ECDC Standard)
</p>
</li>
<li> <p><code>epiweek</code> will force <code>date_resolution = week</code> and <code>week_start = 7</code> (US CDC Standard)
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_week_start">week_start</code></td>
<td>
<p>Integer specifying the start of the week (1 = Monday, 7 = Sunday). <br />
Only used when date_resolution includes weeks. Defaults to 1 (Monday). <br />
For isoweek use <code>week_start = 1</code> and for epiweek use <code>week_start = 7</code>.</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_width">width</code></td>
<td>
<p>Numeric value specifying the width of the bars. If <code>NULL</code>, calculated
based on resolution and relative.width</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_relative.width">relative.width</code></td>
<td>
<p>Numeric value between 0 and 1 adjusting the relative width
of bars. Defaults to 1</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer</a></code>. For example:
</p>

<ul>
<li> <p><code>colour</code> Colour of the outlines around cases. Disable with colour = NA. Defaults to &quot;white&quot;.
</p>
</li>
<li> <p><code>linewidth</code>  Width of the case outlines.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_epicurve_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use to display the data for this layer.
When using a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function to construct a layer, the <code>geom</code> argument
can be used to override the default coupling between stats and geoms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Epi Curves are a public health tool for outbreak investigation. For more details see the references.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> geom layer that can be added to a plot
</p>


<h3>References</h3>


<ul>
<li><p> Centers for Disease Control and Prevention. Quick-Learn Lesson:
Using an Epi Curve to Determine Mode of Spread. USA. <a href="https://www.cdc.gov/training/quicklearns/epimode/">https://www.cdc.gov/training/quicklearns/epimode/</a>
</p>
</li>
<li><p> Dicker, Richard C., Fátima Coronado, Denise Koo, and R. Gibson Parrish. 2006.
Principles of Epidemiology in Public Health Practice; an Introduction to Applied Epidemiology and Biostatistics.
3rd ed. USA. <a href="https://stacks.cdc.gov/view/cdc/6914">https://stacks.cdc.gov/view/cdc/6914</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+scale_y_cases_5er">scale_y_cases_5er()</a></code>, <code><a href="#topic+geom_vline_year">geom_vline_year()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic epicurve with dates
library(ggplot2)
set.seed(1)

plot_data_epicurve_imp &lt;- data.frame(
  date = rep(as.Date("2023-12-01") + ((0:300) * 1), times = rpois(301, 0.5))
)

ggplot(plot_data_epicurve_imp, aes(x = date, weight = 2)) +
  geom_vline_year(year_break = "01-01", show.legend = TRUE) +
  geom_epicurve(date_resolution = "week") +
  labs(title = "Epicurve Example") +
  scale_y_cases_5er() +
  scale_x_date(date_breaks = "4 weeks", date_labels = "W%V'%g") + # Correct ISOWeek labels week'year
  coord_equal(ratio = 7) + # Use coord_equal for square boxes. 'ratio' are the days per week.
  theme_bw()

# Categorical epicurve
library(tidyr)
library(outbreaks)

sars_canada_2003 |&gt; # SARS dataset from outbreaks
  pivot_longer(starts_with("cases"), names_prefix = "cases_", names_to = "origin") |&gt;
  ggplot(aes(x = date, weight = value, fill = origin)) +
  geom_epicurve(date_resolution = "week") +
  scale_x_date(date_labels = "W%V'%g", date_breaks = "2 weeks") +
  scale_y_cases_5er() +
  theme_classic()
</code></pre>

<hr>
<h2 id='geom_epigantt'>Epi Gantt Chart: Visualize Epidemiological Time Intervals</h2><span id='topic+geom_epigantt'></span>

<h3>Description</h3>

<p>Creates Epi Gantt charts, which are specialized timeline visualizations used in
outbreak investigations to track potential exposure periods and identify transmission
patterns. They are particularly useful for:
</p>

<ul>
<li><p> Hospital outbreak investigations to visualize patient movements between wards
</p>
</li>
<li><p> Identifying potential transmission events by showing when cases were in the same location
</p>
</li>
<li><p> Visualizing common exposure times using overlapping exposure time intervals
</p>
</li></ul>

<p>The chart displays time intervals as horizontal bars, typically with one row per case/patient.
Different colours can be used to represent different locations (e.g., hospital wards) or
exposure types. Additional points or markers can show important events like symptom onset
or test dates.
</p>
<p><code>geom_epigantt()</code> will adjust the linewidth depending on the number of cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_epigantt(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_epigantt_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings. Must include:
</p>

<ul>
<li> <p><code>y</code>: Case/patient identifier
</p>
</li>
<li> <p><code>xmin</code>: Start date/time of interval
</p>
</li>
<li> <p><code>xmax</code>: End date/time of interval
</p>
</li>
<li><p> Optional: <code>colour</code> or <code>fill</code> for different locations/categories
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_epigantt_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="geom_epigantt_+3A_stat">stat</code></td>
<td>
<p>A <code>ggplot2</code> stat. Defaults to <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="geom_epigantt_+3A_position">position</code></td>
<td>
<p>A <code>ggplot2</code> position. Defaults to <code>"identity"</code>.</p>
</td></tr>
<tr><td><code id="geom_epigantt_+3A_...">...</code></td>
<td>
<p>Additional parameters:
</p>

<ul>
<li> <p><code>linewidth</code>: Set width of bars directly, disables auto-scaling if set.
</p>
</li>
<li> <p><code>lw_scaling_factor</code>: Scaling factor for auto-width calculation.
The linewidth is calculated as lw_scaling_factor/number_of_rows (default: 90)
</p>
</li>
<li> <p><code>lw_min</code>: Minimum auto-scaled line width cutoff (default: 1)
</p>
</li>
<li> <p><code>lw_max</code>: Maximum auto-scaled line width cutoff (default: 8)
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_epigantt_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>FALSE</code>, the default, missing values are removed with
a warning. If <code>TRUE</code>, missing values are silently removed.</p>
</td></tr>
<tr><td><code id="geom_epigantt_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="geom_epigantt_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> geom layer that can be added to a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tidyr)
library(ggplot2)

# Transform hospital outbreak line list to long format
linelist_hospital_outbreak |&gt;
  pivot_longer(
    cols = starts_with("ward"),
    names_to = c(".value", "num"),
    names_pattern = "ward_(name|start_of_stay|end_of_stay)_([0-9]+)",
    values_drop_na = TRUE
  ) -&gt; df_stays_long

linelist_hospital_outbreak |&gt;
  pivot_longer(cols = starts_with("pathogen"), values_to = "date") -&gt; df_detections_long

# Create Epi Gantt chart showing ward stays and test dates
ggplot(df_stays_long) +
  geom_epigantt(aes(y = Patient, xmin = start_of_stay, xmax = end_of_stay, color = name)) +
  geom_point(aes(y = Patient, x = date, shape = "Date of pathogen detection"),
    data = df_detections_long
  ) +
  scale_y_discrete_reverse() +
  theme_bw() +
  theme(legend.position = "bottom")

</code></pre>

<hr>
<h2 id='geom_vline_year'>Automatically create lines at the turn of every year</h2><span id='topic+geom_vline_year'></span><span id='topic+geom_hline_year'></span>

<h3>Description</h3>

<p>Determines turn of year dates based on the range of either the x or y axis of the ggplot.
</p>

<ul>
<li> <p><code>geom_vline_year()</code> draws vertical lines at the turn of each year
</p>
</li>
<li> <p><code>geom_hline_year()</code> draws horizontal lines at the turn of each year
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>geom_vline_year(
  mapping = NULL,
  position = "identity",
  year_break = "01-01",
  just = -0.5,
  ...,
  show.legend = NA
)

geom_hline_year(
  mapping = NULL,
  position = "identity",
  year_break = "01-01",
  just = -0.5,
  ...,
  show.legend = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_vline_year_+3A_mapping">mapping</code></td>
<td>
<p>Mapping created using <code><a href="ggplot2.html#topic+aes">ggplot2::aes()</a></code>. Can be used to add the lines to the legend.
E.g. <code>aes(linetype = 'End of Year')</code>. Cannot access data specified in <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>.
Panels created by <code><a href="ggplot2.html#topic+facet_wrap">ggplot2::facet_wrap()</a></code> or <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code> are available with <code>aes(linetype = PANEL)</code>.</p>
</td></tr>
<tr><td><code id="geom_vline_year_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a call to
a position adjustment function.</p>
</td></tr>
<tr><td><code id="geom_vline_year_+3A_year_break">year_break</code></td>
<td>
<p>String specifying the month and day of the year break (&quot;MM-DD&quot;).
Defaults to: <code>"01-01"</code> for January 1.</p>
</td></tr>
<tr><td><code id="geom_vline_year_+3A_just">just</code></td>
<td>
<p>Numeric offset in days (justification). Shifts the lines from the year break date.
Defaults to <code>-0.5</code>, which shifts the line by half a day so if falls in the middle between December 31 and January 1.</p>
</td></tr>
<tr><td><code id="geom_vline_year_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="ggplot2.html#topic+layer">layer</a></code>. For example:
</p>

<ul>
<li> <p><code>colour</code> Colour of the line. Try: <code>colour = "grey50"</code>
</p>
</li>
<li> <p><code>linetype</code> Linetype. Try: <code>linetype = "dashed"</code> or <code>linetype = "dotted"</code>
</p>
</li>
<li> <p><code>linewidth</code> Width of the line.
</p>
</li>
<li> <p><code>alpha</code>  Transparency of the line.
used to set an aesthetic to a fixed value, like <code>colour = "grey25"</code> or <code>linetype = 2</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="geom_vline_year_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends? <code>NA</code>, the default,
includes if any aesthetics are mapped. <code>FALSE</code> never includes, and <code>TRUE</code> always includes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 layer that can be added to a plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_epicurve">geom_epicurve()</a></code>, <code><a href="ggplot2.html#topic+geom_abline">ggplot2::geom_vline()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
set.seed(1)

plot_data_epicurve_imp &lt;- data.frame(
  date = rep(as.Date("2023-12-01") + ((0:300) * 1), times = rpois(301, 0.5))
)

ggplot(plot_data_epicurve_imp, aes(x = date, weight = 2)) +
  geom_epicurve(date_resolution = "week") +
  geom_vline_year(year_break = "01-01", show.legend = TRUE) +
  labs(title = "Epicurve Example") +
  scale_y_cases_5er() +
  scale_x_date(date_breaks = "4 weeks", date_labels = "W%V'%g") + # Correct ISOWeek labels week'year
  theme_bw()

</code></pre>

<hr>
<h2 id='geometric_mean'>Compute a Geometric Mean</h2><span id='topic+geometric_mean'></span>

<h3>Description</h3>

<p>The geometric mean is typically defined for strictly positive values.
This function computes the geometric mean of a numeric vector,
with the option to replace certain values (e.g., zeros, non-positive values,
or values below a user-specified threshold) before computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geometric_mean(
  x,
  na.rm = FALSE,
  replace_value = NULL,
  replace = c("all", "non-positive", "zero"),
  warning = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geometric_mean_+3A_x">x</code></td>
<td>
<p>A numeric or complex vector of values.</p>
</td></tr>
<tr><td><code id="geometric_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>Logical. If <code>FALSE</code> (default), the presence of zero or
negative values triggers a warning and returns <code>NA</code>. If <code>TRUE</code>,
such values (and any <code>NA</code>) are removed before computing the geometric mean.</p>
</td></tr>
<tr><td><code id="geometric_mean_+3A_replace_value">replace_value</code></td>
<td>
<p>Numeric or <code>NULL</code>. The value used for replacement,
depending on <code>replace</code> (e.g., a detection limit (LOD) or quantification limit (LOQ)).
If <code>NULL</code>, no replacement is performed. For recommendations how to use, see details.</p>
</td></tr>
<tr><td><code id="geometric_mean_+3A_replace">replace</code></td>
<td>
<p>Character string indicating which values to replace:
</p>

<dl>
<dt><code>"all"</code></dt><dd><p>Replaces all values less than <code>replace_value</code>
with <code>replace_value</code>. This is useful if you have a global threshold
(such as a limit of detection) below which any measurement is replaced.</p>
</dd>
<dt><code>"non-positive"</code></dt><dd><p>Replaces all non-positive values (<code>x &lt;= 0</code>)
with <code>replace_value</code>. This is helpful if zeros or negative values
are known to be invalid or below a certain limit.</p>
</dd>
<dt><code>"zero"</code></dt><dd><p>Replaces only exact zeros (<code>x == 0</code>) with
<code>replace_value</code>. Useful if negative values should be treated as missing.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="geometric_mean_+3A_warning">warning</code></td>
<td>
<p>Disable warnings by setting it to <code>FALSE</code>. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Replacement Considerations</strong>:
The geometric mean is only defined for strictly positive numbers (<code class="reqn">x &gt; 0</code>).
Despite this, the geometric mean can be useful for laboratory measurements which can contain 0 or negative values.
If these values are treated as NA and are removed, this results in an upward bias due to missingness.
To reduce this, values below the limit of detection (LOD) or limit of quantification (LOQ)
are often replaced with the chosen limit, making this limit the practical lower limit of the measurement scale.
This is therefore an often recommended approach.
</p>
<p>There are also alternatives approaches, where values are replaced by
either <code class="reqn">\frac{LOD}{2}</code> or <code class="reqn">\frac{LOD}{\sqrt{2}}</code> (or LOQ). These approaches create a gap in the distribution
of values (e.g. no values for <code class="reqn">\frac{LOD}{2} &lt; x &lt; LOD</code>) and should therefore be used with caution.
</p>
<p><strong>If the replacement approach for values below LOD or LOQ has a material effect on the
interpretation of the results, the values should be treated as statistically censored. In this case,
proper statistical methods to handle (left) censored data should be used.</strong>
</p>
<p>When <code>replace_value</code> is provided, the function will <em>first</em> perform
the specified replacements, then proceed with the geometric mean calculation.
If no replacements are requested but zero or negative values remain and
<code>na.rm = FALSE</code>, an <code>NA</code> will be returned with a warning.
</p>


<h3>Value</h3>

<p>A single numeric value representing the geometric mean of the
processed vector <code>x</code>, or <code>NA</code> if the resulting vector is empty
(e.g., if <code>na.rm = TRUE</code> removes all positive values) or if non-positive
values exist when <code>na.rm = FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Basic usage with no replacements:
x &lt;- c(1, 2, 3, 4, 5)
geometric_mean(x)

# Replace all values &lt; 0.5 with 0.5 (common in LOD scenarios):
x3 &lt;- c(0.1, 0.2, 0.4, 1, 5)
geometric_mean(x3, replace_value = 0.5, replace = "all")

# Remove zero or negative values, since log(0) = -Inf and log(-1) = NaN
x4 &lt;- c(-1, 0, 1, 2, 3)
geometric_mean(x4, na.rm = TRUE)

</code></pre>

<hr>
<h2 id='influenza_germany'>Germany Influenza (FLU) Surveillance data</h2><span id='topic+influenza_germany'></span>

<h3>Description</h3>

<p>A subset of the weekly German influenza surveillance data from January 2020 to January 2025.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>influenza_germany
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 1037 rows and 4 columns.
</p>


<h3>Details</h3>

<p>A data frame with 1,037 rows and 4 columns:
</p>

<dl>
<dt>ReportingWeek</dt><dd><p>Reporting Week in &quot;2024-W03&quot; format</p>
</dd>
<dt>AgeGroup</dt><dd><p>Age groups: <code style="white-space: pre;">&#8288;00+&#8288;</code> for all and <code>00-14</code>, <code>15-59</code> and <code style="white-space: pre;">&#8288;60+&#8288;</code> for age stratified cases.</p>
</dd>
<dt>Cases</dt><dd><p>Weekly case count</p>
</dd>
<dt>Incidence</dt><dd><p>Calculated weekly incidence</p>
</dd>
</dl>



<h3>Source</h3>

<p>License CC-BY 4.0: Robert Koch-Institut (2025): Laborbestätigte Influenzafälle in Deutschland. Dataset. Zenodo.
DOI:10.5281/zenodo.14619502. <a href="https://github.com/robert-koch-institut/Influenzafaelle_in_Deutschland">https://github.com/robert-koch-institut/Influenzafaelle_in_Deutschland</a>
</p>

<hr>
<h2 id='linelist_hospital_outbreak'>Line list of a fictional hospital outbreak (Data)</h2><span id='topic+linelist_hospital_outbreak'></span>

<h3>Description</h3>

<p>This hospital outbreak is inspired by typical hospital outbreaks with resistant 4MRGN bacterial pathogens.
These outbreaks start silent, since they are not initially apparent from the symptoms of the patient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linelist_hospital_outbreak
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows and 9 columns:
</p>

<ul>
<li> <p><code>Patient</code> - Patient ID (0-7)
</p>
</li>
<li> <p><code>ward_name_1</code> - Name of first ward where patient stayed
</p>
</li>
<li> <p><code>ward_start_of_stay_1</code> - Start date of stay in first ward
</p>
</li>
<li> <p><code>ward_end_of_stay_1</code> - End date of stay in first ward
</p>
</li>
<li> <p><code>ward_name_2</code> - Name of second ward where patient stayed (if applicable)
</p>
</li>
<li> <p><code>ward_start_of_stay_2</code> - Start date of stay in second ward (if applicable)
</p>
</li>
<li> <p><code>ward_end_of_stay_2</code> - End date of stay in second ward (if applicable)
</p>
</li>
<li> <p><code>pathogen_detection_1</code> - Date of first positive pathogen test
</p>
</li>
<li> <p><code>pathogen_detection_2</code> - Date of second positive pathogen test (if applicable)
</p>
</li></ul>

<p>Patient details:
</p>

<ul>
<li><p> Patient 0: Index case (ICU), infected early on but detected June 30, 2024
</p>
</li>
<li><p> Patient 1-2: ICU patients, found during initial screening
</p>
</li>
<li><p> Patient 3: Case who moved from ICU to general ward prior to the detection of patient 0,
potentially linking both outbreak clusters. Detected during extended case search
</p>
</li>
<li><p> Patient 4-6: General ward cases, found after Patient 3's detection
</p>
</li>
<li><p> Patient 7: General ward case, detected post-discharge by GP, who notified the hospital
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(tidyr)
library(ggplot2)

# Transform hospital outbreak line list to long format
linelist_hospital_outbreak |&gt;
  pivot_longer(
    cols = starts_with("ward"),
    names_to = c(".value", "num"),
    names_pattern = "ward_(name|start_of_stay|end_of_stay)_([0-9]+)",
    values_drop_na = TRUE
  ) -&gt; df_stays_long

linelist_hospital_outbreak |&gt;
  pivot_longer(cols = starts_with("pathogen"), values_to = "date") -&gt; df_detections_long

# Create Epi Gantt chart showing ward stays and test dates
ggplot(df_stays_long) +
  geom_epigantt(aes(y = Patient, xmin = start_of_stay, xmax = end_of_stay, color = name)) +
  geom_point(aes(y = Patient, x = date, shape = "Date of pathogen detection"),
    data = df_detections_long
  ) +
  scale_y_discrete_reverse() +
  theme_bw() +
  theme(legend.position = "bottom")

</code></pre>

<hr>
<h2 id='scale_y_cases_5er'>Continuous x-axis and y-axis scale for (case) counts</h2><span id='topic+scale_y_cases_5er'></span><span id='topic+scale_x_cases_5er'></span>

<h3>Description</h3>

<p>A continuous ggplot scale for count data with sane defaults for breaks.
It uses <code><a href="base.html#topic+pretty">base::pretty()</a></code> to increase the default number of breaks and prefers 5er breaks.
Additionally, the first tick (i.e. zero) is aligned to the lower left corner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_cases_5er(
  name = waiver(),
  n = 8,
  n.min = 5,
  u5.bias = 4,
  expand = NULL,
  labels = waiver(),
  limits = NULL,
  oob = scales::censor,
  na.value = NA_real_,
  transform = "identity",
  position = "left",
  sec.axis = waiver(),
  guide = waiver(),
  ...
)

scale_x_cases_5er(
  name = waiver(),
  n = 8,
  n.min = 5,
  u5.bias = 4,
  expand = NULL,
  labels = waiver(),
  limits = NULL,
  oob = scales::censor,
  na.value = NA_real_,
  transform = "identity",
  position = "bottom",
  sec.axis = waiver(),
  guide = waiver(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_y_cases_5er_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_n">n</code></td>
<td>
<p>Target number of breaks passed to <code><a href="base.html#topic+pretty">base::pretty()</a></code>. Defaults to 8.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_n.min">n.min</code></td>
<td>
<p>Minimum number of breaks passed to <code><a href="base.html#topic+pretty">base::pretty()</a></code>. Defaults to 5.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_u5.bias">u5.bias</code></td>
<td>
<p>The &quot;5-bias&quot; parameter passed to <code><a href="base.html#topic+pretty">base::pretty()</a></code>; higher values
push the breaks more strongly toward multiples of 5. Defaults to 4.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_expand">expand</code></td>
<td>
<p>Uses own expansion logic. Use <code>expand = waiver()</code> to restore ggplot defaults
or <code><a href="ggplot2.html#topic+expansion">ggplot2::expansion()</a></code> to modify</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_labels">labels</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> for no labels
</p>
</li>
<li> <p><code>waiver()</code> for the default labels computed by the
transformation object
</p>
</li>
<li><p> A character vector giving labels (must be same length as <code>breaks</code>)
</p>
</li>
<li><p> An expression vector (must be the same length as breaks). See ?plotmath for details.
</p>
</li>
<li><p> A function that takes the breaks as input and returns labels
as output. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_limits">limits</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>NULL</code> to use the default scale range
</p>
</li>
<li><p> A numeric vector of length two providing limits of the scale.
Use <code>NA</code> to refer to the existing minimum or maximum
</p>
</li>
<li><p> A function that accepts the existing (automatic) limits and returns
new limits. Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a> function
notation.
Note that setting limits on positional scales will <strong>remove</strong> data outside of the limits.
If the purpose is to zoom, use the limit argument in the coordinate system
(see <code><a href="ggplot2.html#topic+coord_cartesian">coord_cartesian()</a></code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_oob">oob</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> Function that handles limits outside of the scale limits
(out of bounds). Also accepts rlang <a href="rlang.html#topic+as_function">lambda</a>
function notation.
</p>
</li>
<li><p> The default (<code><a href="scales.html#topic+oob">scales::censor()</a></code>) replaces out of
bounds values with <code>NA</code>.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish()</a></code> for squishing out of bounds values into range.
</p>
</li>
<li> <p><code><a href="scales.html#topic+oob">scales::squish_infinite()</a></code> for squishing infinite values into range.
</p>
</li></ul>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_na.value">na.value</code></td>
<td>
<p>Missing values will be replaced with this value.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_transform">transform</code></td>
<td>
<p>For continuous scales, the name of a transformation object
or the object itself. Built-in transformations include &quot;asn&quot;, &quot;atanh&quot;,
&quot;boxcox&quot;, &quot;date&quot;, &quot;exp&quot;, &quot;hms&quot;, &quot;identity&quot;, &quot;log&quot;, &quot;log10&quot;, &quot;log1p&quot;, &quot;log2&quot;,
&quot;logit&quot;, &quot;modulus&quot;, &quot;probability&quot;, &quot;probit&quot;, &quot;pseudo_log&quot;, &quot;reciprocal&quot;,
&quot;reverse&quot;, &quot;sqrt&quot; and &quot;time&quot;.
</p>
<p>A transformation object bundles together a transform, its inverse,
and methods for generating breaks and labels. Transformation objects
are defined in the scales package, and are called <code style="white-space: pre;">&#8288;transform_&lt;name&gt;&#8288;</code>. If
transformations require arguments, you can call them from the scales
package, e.g. <code><a href="scales.html#topic+transform_boxcox">scales::transform_boxcox(p = 2)</a></code>.
You can create your own transformation with <code><a href="scales.html#topic+new_transform">scales::new_transform()</a></code>.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_sec.axis">sec.axis</code></td>
<td>
<p><code><a href="ggplot2.html#topic+sec_axis">sec_axis()</a></code> is used to specify a secondary axis.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_guide">guide</code></td>
<td>
<p>A function used to create a guide or its name. See
<code><a href="ggplot2.html#topic+guides">guides()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="scale_y_cases_5er_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="base.html#topic+pretty">base::pretty()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> scale object that can be added to a plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_epicurve">geom_epicurve()</a></code>, <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_y_continuous()</a></code>, <code><a href="base.html#topic+pretty">base::pretty()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

data &lt;- data.frame(date = as.Date("2024-01-01") + 0:30)
ggplot(data, aes(x = date)) +
  geom_epicurve(date_resolution = "week") +
  scale_y_cases_5er()
</code></pre>

<hr>
<h2 id='scale_y_discrete_reverse'>Reversed discrete scale for 'ggplot2'</h2><span id='topic+scale_y_discrete_reverse'></span><span id='topic+scale_x_discrete_reverse'></span>

<h3>Description</h3>

<p><code>scale_y_discrete_reverse()</code> and <code>scale_x_discrete_reverse()</code> are standard discrete 'ggplot2'
scales with a reversed order of values. Since the ggplot2 coordinate system starts with 0 in
the lower left corner, factors on the y-axis are sorted is descending order by default
(i.e. alphabetically from Z to A). With this scale the the y-axis will start with the
first factor level at the top or with alphabetically correctly ordered values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_y_discrete_reverse(
  name = waiver(),
  limits = NULL,
  ...,
  expand = waiver(),
  position = "left"
)

scale_x_discrete_reverse(
  name = waiver(),
  limits = NULL,
  ...,
  expand = waiver(),
  position = "bottom"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_y_discrete_reverse_+3A_name">name</code></td>
<td>
<p>The name of the scale. Used as the axis or legend title. If
<code>waiver()</code>, the default, the name of the scale is taken from the first
mapping used for that aesthetic. If <code>NULL</code>, the legend title will be
omitted.</p>
</td></tr>
<tr><td><code id="scale_y_discrete_reverse_+3A_limits">limits</code></td>
<td>
<p>Can be either NULL which uses the default reversed scale values
or a character vector which will be reversed.</p>
</td></tr>
<tr><td><code id="scale_y_discrete_reverse_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="ggplot2.html#topic+discrete_scale">ggplot2::discrete_scale()</a></code></p>
</td></tr>
<tr><td><code id="scale_y_discrete_reverse_+3A_expand">expand</code></td>
<td>
<p>For position scales, a vector of range expansion constants used to add some
padding around the data to ensure that they are placed some distance
away from the axes. Use the convenience function <code><a href="ggplot2.html#topic+expansion">expansion()</a></code>
to generate the values for the <code>expand</code> argument. The defaults are to
expand the scale by 5% on each side for continuous variables, and by
0.6 units on each side for discrete variables.</p>
</td></tr>
<tr><td><code id="scale_y_discrete_reverse_+3A_position">position</code></td>
<td>
<p>For position scales, The position of the axis.
<code>left</code> or <code>right</code> for y axes, <code>top</code> or <code>bottom</code> for x axes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> scale object that can be added to a plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+geom_epigantt">geom_epigantt()</a></code>, <code><a href="ggplot2.html#topic+scale_discrete">ggplot2::scale_y_discrete()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)

# Create sample data
df &lt;- data.frame(
  category = factor(c("A", "B", "C", "D")),
  value = c(10, 5, 8, 3)
)

# Basic plot with reversed y-axis
ggplot(df, aes(x = value, y = category)) +
  geom_col() +
  scale_y_discrete_reverse()

</code></pre>

<hr>
<h2 id='uncount'>Duplicate rows according to a weighting variable</h2><span id='topic+uncount'></span><span id='topic+expand_counts'></span>

<h3>Description</h3>

<p><code>uncount()</code> is provided by the tidyr package, and re-exported
by ggsurveillance. See <code><a href="tidyr.html#topic+uncount">tidyr::uncount()</a></code> for more details.
</p>
<p><code>uncount()</code> and its alias <code>expand_counts()</code> are complements of <code><a href="dplyr.html#topic+count">dplyr::count()</a></code>: they take
a data frame with a column of frequencies and duplicate each row according to
those frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncount(data, weights, ..., .remove = TRUE, .id = NULL)

expand_counts(data, weights, ..., .remove = TRUE, .id = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uncount_+3A_data">data</code></td>
<td>
<p>A data frame, tibble, or grouped tibble.</p>
</td></tr>
<tr><td><code id="uncount_+3A_weights">weights</code></td>
<td>
<p>A vector of weights. Evaluated in the context of <code>data</code>;
supports quasiquotation.</p>
</td></tr>
<tr><td><code id="uncount_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods.</p>
</td></tr>
<tr><td><code id="uncount_+3A_.remove">.remove</code></td>
<td>
<p>If <code>TRUE</code>, and <code>weights</code> is the name of a column in <code>data</code>,
then this column is removed.</p>
</td></tr>
<tr><td><code id="uncount_+3A_.id">.id</code></td>
<td>
<p>Supply a string to create a new variable which gives a unique
identifier for each created row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with rows duplicated according to weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = c("a", "b"), n = c(2, 3))
df |&gt; uncount(n)
# Or equivalently:
df |&gt; expand_counts(n)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
