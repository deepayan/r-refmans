<!DOCTYPE html><html lang="en"><head><title>Help for package LSTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LSTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#block.smooth.periodogram'><p>Smooth Periodogram by Blocks</p></a></li>
<li><a href='#Box.Ljung.Test'><p>Ljung-Box Test Plot</p></a></li>
<li><a href='#hessian'><p>Hessian Matrix</p></a></li>
<li><a href='#LS.kalman'><p>Kalman filter for locally stationary processes</p></a></li>
<li><a href='#LS.summary'><p>Summary for Locally Stationary Time Series</p></a></li>
<li><a href='#LS.whittle'><p>Whittle estimator to Locally Stationary Time Series</p></a></li>
<li><a href='#LS.whittle.loglik'><p>Locally Stationary Whittle log-likelihood Function</p></a></li>
<li><a href='#LS.whittle.loglik.sd'><p>Locally Stationary Whittle Log-likelihood sigma</p></a></li>
<li><a href='#LS.whittle.loglik.theta'><p>Locally Stationary Whittle Log-likelihood theta</p></a></li>
<li><a href='#malleco'><p>Average Araucaria Araucana Tree Ring Width</p></a></li>
<li><a href='#periodogram'><p>Periodogram function</p></a></li>
<li><a href='#smooth.periodogram'><p>Smoothing periodogram</p></a></li>
<li><a href='#spectral.density'><p>Spectral Density</p></a></li>
<li><a href='#ts.diag'><p>Diagnostic Plots for Time Series fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Locally Stationary Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions that allow stationary analysis and locally stationary time series analysis.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pacha.dev/LSTS/">https://pacha.dev/LSTS/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pachadotdev/LSTS/issues/">https://github.com/pachadotdev/LSTS/issues/</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, Rdpack, ggplot2, scales, patchwork</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-29 15:45:41 UTC; pacha</td>
</tr>
<tr>
<td>Author:</td>
<td>Ricardo Olea [aut, cph],
  Wilfredo Palma [aut, cph],
  Pilar Rubio [aut],
  Mauricio Vargas <a href="https://orcid.org/0000-0003-1017-7574"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mauricio Vargas &lt;mavargas11@uc.cl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-29 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='block.smooth.periodogram'>Smooth Periodogram by Blocks</h2><span id='topic+block.smooth.periodogram'></span>

<h3>Description</h3>

<p>Plots the contour plot of the smoothing periodogram of a time series, by
blocks or windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block.smooth.periodogram(
  y,
  x = NULL,
  N = NULL,
  S = NULL,
  p = 0.25,
  spar.freq = 0,
  spar.time = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="block.smooth.periodogram_+3A_y">y</code></td>
<td>
<p>(type: numeric) data vector</p>
</td></tr>
<tr><td><code id="block.smooth.periodogram_+3A_x">x</code></td>
<td>
<p>(type: numeric) optional vector, if <code>x = NULL</code> then the
function uses <code class="reqn">(1,\ldots,n)</code> where <code>n</code> is the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="block.smooth.periodogram_+3A_n">N</code></td>
<td>
<p>(type: numeric) value corresponding to the length of the window to
compute periodogram.
If <code>N=NULL</code> then the function will use
<code class="reqn">N = \textrm{trunc}(n^{0.8})</code>, see
Dahlhaus and Giraitis (1998) where <code class="reqn">n</code> is the length of
the <code>y</code> vector.</p>
</td></tr>
<tr><td><code id="block.smooth.periodogram_+3A_s">S</code></td>
<td>
<p>(type: numeric) value corresponding to the lag with which will be
taking the blocks or windows to calculate the periodogram.</p>
</td></tr>
<tr><td><code id="block.smooth.periodogram_+3A_p">p</code></td>
<td>
<p>(type: numeric) value used if it is desired that <code>S</code> is
proportional to <code>N</code>. By default <code>p=0.25</code>, if <code>S</code> and <code>N</code>
are not entered.</p>
</td></tr>
<tr><td><code id="block.smooth.periodogram_+3A_spar.freq">spar.freq</code></td>
<td>
<p>(type: numeric) smoothing parameter, typically (but not
necessarily) in <code class="reqn">(0,1]</code>.</p>
</td></tr>
<tr><td><code id="block.smooth.periodogram_+3A_spar.time">spar.time</code></td>
<td>
<p>(type: numeric) smoothing parameter, typically (but not
necessarily) in <code class="reqn">(0,1]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of windows of the function is <code class="reqn">m = \textrm{trunc}((n-N)/S+1)</code>,
where <code><a href="base.html#topic+trunc">trunc</a></code> truncates de entered value and <em>n</em> is
the length of the vector <code>y</code>. All windows are of the same length
<code>N</code>, if this value isn't entered by user then is computed as
<code class="reqn">N=\textrm{trunc}(n^{0.8})</code> (Dahlhaus).
<code>LSTS_spb</code> computes the periodogram in each of the
<em>M</em> windows and then smoothes it two times with
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function; the first time using
<code>spar.freq</code> parameter and the second time with <code>spar.time</code>. These
windows overlap between them.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>References</h3>

<p>For more information on theoretical foundations and estimation methods see
Dahlhaus R, others (1997).
&ldquo;Fitting time series models to nonstationary processes.&rdquo;
<em>The annals of Statistics</em>, <b>25</b>(1), 1&ndash;37.
Dahlhaus R, Giraitis L (1998).
&ldquo;On the optimal segment length for parameter estimates for locally stationary time series.&rdquo;
<em>Journal of Time Series Analysis</em>, <b>19</b>(6), 629&ndash;655.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima.sim">arima.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>block.smooth.periodogram(malleco)
</code></pre>

<hr>
<h2 id='Box.Ljung.Test'>Ljung-Box Test Plot</h2><span id='topic+Box.Ljung.Test'></span>

<h3>Description</h3>

<p>Plots the p-values Ljung-Box test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Box.Ljung.Test(z, lag = NULL, main = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Box.Ljung.Test_+3A_z">z</code></td>
<td>
<p>(type: numeric) data vector</p>
</td></tr>
<tr><td><code id="Box.Ljung.Test_+3A_lag">lag</code></td>
<td>
<p>(type: numeric) the number of periods for the autocorrelation</p>
</td></tr>
<tr><td><code id="Box.Ljung.Test_+3A_main">main</code></td>
<td>
<p>(type: character) a title for the returned plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ljung-Box test is used to check if exists autocorrelation in a time
series. The statistic is
</p>
<p style="text-align: center;"><code class="reqn">q = n(n+2)\cdot\sum_{j=1}^h \hat{\rho}(j)^2/(n-j)</code>
</p>
<p> with <em>n</em> the
number of observations and <code class="reqn">\hat{\rho}(j)</code> the autocorrelation
coefficient in the sample when the lag is <em>j</em>. <code>LSTS_lbtp</code>
computes <code class="reqn">q</code> and returns the p-values graph with lag <em>j</em>.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>References</h3>

<p>For more information on theoretical foundations and estimation methods see
Brockwell PJ, Davis RA, Calder MV (2002).
<em>Introduction to time series and forecasting</em>, volume 2.
Springer.
Ljung GM, Box GE (1978).
&ldquo;On a measure of lack of fit in time series models.&rdquo;
<em>Biometrika</em>, <b>65</b>(2), 297&ndash;303.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+periodogram">periodogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Box.Ljung.Test(malleco, lag = 5)
</code></pre>

<hr>
<h2 id='hessian'>Hessian Matrix</h2><span id='topic+hessian'></span>

<h3>Description</h3>

<p>Numerical aproximation of the Hessian of a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hessian(f, x0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hessian_+3A_f">f</code></td>
<td>
<p>(type: numeric) name of function that defines log likelihood
(or negative of it).</p>
</td></tr>
<tr><td><code id="hessian_+3A_x0">x0</code></td>
<td>
<p>(type: numeric) scalar or vector of parameters that give the point
at which you want the hessian estimated (usually will be the mle).</p>
</td></tr>
<tr><td><code id="hessian_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the numerical approximation of the Hessian of <code>f</code>, evaluated at
<code>x0</code>.
Usually needs to pass additional parameters (e.g. data).  N.B. this uses no
numerical sophistication.
</p>


<h3>Value</h3>

<p>An <code class="reqn">n \times n</code> matrix of 2nd derivatives, where <code class="reqn">n</code> is the length of
<code>x0</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima.sim">arima.sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Variance of the maximum likelihood estimator for mu parameter in
# gaussian data
loglik &lt;- function(series, x, sd = 1) {
  -sum(log(dnorm(series, mean = x, sd = sd)))
}
sqrt(c(var(malleco) / length(malleco), diag(solve(hessian(
  f = loglik, x = mean(malleco), series = malleco,
  sd = sd(malleco)
)))))
</code></pre>

<hr>
<h2 id='LS.kalman'>Kalman filter for locally stationary processes</h2><span id='topic+LS.kalman'></span>

<h3>Description</h3>

<p>This function run the state-space equations for expansion
infinite of moving average in processes LS-ARMA or LS-ARFIMA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.kalman(
  series,
  start,
  order = c(p = 0, q = 0),
  ar.order = NULL,
  ma.order = NULL,
  sd.order = NULL,
  d.order = NULL,
  include.d = FALSE,
  m = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS.kalman_+3A_series">series</code></td>
<td>
<p>(type: numeric) univariate time series.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_start">start</code></td>
<td>
<p>(type: numeric) numeric vector, initial values for parameters to
run the model.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_order">order</code></td>
<td>
<p>(type: numeric) vector corresponding to <code>ARMA</code> model
entered.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_ar.order">ar.order</code></td>
<td>
<p>(type: numeric) AR polimonial order.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_ma.order">ma.order</code></td>
<td>
<p>(type: numeric) MA polimonial order.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_sd.order">sd.order</code></td>
<td>
<p>(type: numeric) polinomial order noise scale factor.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_d.order">d.order</code></td>
<td>
<p>(type: numeric) <code>d</code> polinomial order, where <code>d</code> is
the <code>ARFIMA</code> parameter.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_include.d">include.d</code></td>
<td>
<p>(type: numeric) logical argument for <code>ARFIMA</code> models.
If <code>include.d=FALSE</code> then the model is an ARMA process.</p>
</td></tr>
<tr><td><code id="LS.kalman_+3A_m">m</code></td>
<td>
<p>(type: numeric) truncation order of the MA infinity process. By
default <code class="reqn">m = 0.25n^{0.8}</code> where <code>n</code> the length of <code>series</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model fit is done using the Whittle likelihood, while the generation of
innovations is through Kalman Filter.
Details about <code>ar.order, ma.order, sd.order</code> and <code>d.order</code> can be
viewed in <code><a href="#topic+LS.whittle">LS.whittle</a></code>.
</p>


<h3>Value</h3>

<p>A list with:
</p>
<table role = "presentation">
<tr><td><code>residuals</code></td>
<td>
<p>standard residuals.</p>
</td></tr>
<tr><td><code>fitted_values</code></td>
<td>
<p>model fitted values.</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>variance prediction error.</p>
</td></tr>
</table>


<h3>References</h3>

<p>For more information on theoretical foundations and estimation methods see
Brockwell PJ, Davis RA, Calder MV (2002).
<em>Introduction to time series and forecasting</em>, volume 2.
Springer.
Palma W (2007).
<em>Long-memory time series: theory and methods</em>, volume 662.
John Wiley \&amp; Sons.
Palma W, Olea R, Ferreira G (2013).
&ldquo;Estimation and forecasting of locally stationary processes.&rdquo;
<em>Journal of Forecasting</em>, <b>32</b>(1), 86&ndash;96.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_kalman &lt;- LS.kalman(malleco, start(malleco))
</code></pre>

<hr>
<h2 id='LS.summary'>Summary for Locally Stationary Time Series</h2><span id='topic+LS.summary'></span>

<h3>Description</h3>

<p>Produces a summary of the results to Whittle
estimator to Locally Stationary Time Series (<code><a href="#topic+LS.whittle">LS.whittle</a></code>
function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.summary(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS.summary_+3A_object">object</code></td>
<td>
<p>(type: list) the output of <code><a href="#topic+LS.whittle">LS.whittle</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calls the output from <code><a href="#topic+LS.whittle">LS.whittle</a></code> and computes the standard
error and p-values to provide a detailed summary.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>summary</code></td>
<td>
<p>a resume table with estimate, std. error, z-value and p-value
of the model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC of the model.</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>
<p>number of parameters in the model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+LS.whittle">LS.whittle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit_whittle &lt;- LS.whittle(
  series = malleco, start = c(1, 1, 1, 1),
  order = c(p = 1, q = 0), ar.order = 1, sd.order = 1, N = 180, n.ahead = 10
)
LS.summary(fit_whittle)
</code></pre>

<hr>
<h2 id='LS.whittle'>Whittle estimator to Locally Stationary Time Series</h2><span id='topic+LS.whittle'></span>

<h3>Description</h3>

<p>This function computes Whittle estimator to LS-ARMA and
LS-ARFIMA models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.whittle(
  series,
  start,
  order = c(p = 0, q = 0),
  ar.order = NULL,
  ma.order = NULL,
  sd.order = NULL,
  d.order = NULL,
  include.d = FALSE,
  N = NULL,
  S = NULL,
  include.taper = TRUE,
  control = list(),
  lower = -Inf,
  upper = Inf,
  m = NULL,
  n.ahead = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS.whittle_+3A_series">series</code></td>
<td>
<p>(type: numeric) univariate time series.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_start">start</code></td>
<td>
<p>(type: numeric) numeric vector, initial values for parameters to
run the model.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_order">order</code></td>
<td>
<p>(type: numeric) vector corresponding to <code>ARMA</code> model
entered.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_ar.order">ar.order</code></td>
<td>
<p>(type: numeric) AR polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_ma.order">ma.order</code></td>
<td>
<p>(type: numeric) MA polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_sd.order">sd.order</code></td>
<td>
<p>(type: numeric) polinomial order noise scale factor.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_d.order">d.order</code></td>
<td>
<p>(type: numeric) <code>d</code> polinomial order, where <code>d</code> is
the <code>ARFIMA</code> parameter.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_include.d">include.d</code></td>
<td>
<p>(type: numeric) logical argument for <code>ARFIMA</code> models.
If <code>include.d=FALSE</code> then the model is an ARMA process.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_n">N</code></td>
<td>
<p>(type: numeric) value corresponding to the length of the window to
compute periodogram. If <code>N=NULL</code> then the function will use
<code class="reqn">N = \textrm{trunc}(n^{0.8})</code>, see Dahlhaus (1998) where <code class="reqn">n</code> is the
length of the <code>y</code> vector.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_s">S</code></td>
<td>
<p>(type: numeric) value corresponding to the lag with which will go
taking the blocks or windows.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_include.taper">include.taper</code></td>
<td>
<p>(type: logical) logical argument that by default is
<code>TRUE</code>. See <code><a href="#topic+periodogram">periodogram</a></code>.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_control">control</code></td>
<td>
<p>(type: list) A list of control parameters. More details in
<code><a href="stats.html#topic+nlminb">nlminb</a></code> .</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_lower">lower</code></td>
<td>
<p>(type: numeric) lower bound, replicated to be as long as
<code>start</code>. If unspecified, all parameters are assumed to be lower
unconstrained.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_upper">upper</code></td>
<td>
<p>(type: numeric) upper bound, replicated to be as long as
<code>start</code>. If unspecified, all parameters are assumed to be upper
unconstrained.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_m">m</code></td>
<td>
<p>(type: numeric) truncation order of the MA infinity process, by
default <code class="reqn">m = 0.25n^{0.8}</code>. Parameter used in <code>LSTS_kalman</code>.</p>
</td></tr>
<tr><td><code id="LS.whittle_+3A_n.ahead">n.ahead</code></td>
<td>
<p>(type: numeric) The number of steps ahead for which prediction
is required. By default is zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates the parameters in models: LS-ARMA
</p>
<p style="text-align: center;"><code class="reqn">\Phi(t/T, \, B)\, Y_{t, T} = \Theta(t/T,\, B)\,\sigma(t/T)\,
\varepsilon_t</code>
</p>
<p> and LS-ARFIMA </p>
<p style="text-align: center;"><code class="reqn">\Phi(t/T, \, B)\, Y_{t, T} =
\Theta(t/T,\, B)\, (1-B)^{-d(t/T)}\, \sigma(t/T)\, \varepsilon_t,</code>
</p>

<p>with infinite moving average expansion
</p>
<p style="text-align: center;"><code class="reqn">Y_{t, T} = \sigma(t/T)\, \sum_{j=0}^{\infty}
\psi(t/T)\,\varepsilon_t,</code>
</p>
<p> for <code class="reqn">t = 1,\ldots, T</code>, where for
<code class="reqn">u = t/T \in [0,1]</code>, <code class="reqn">\Phi(u,B)=1+\phi_1(u)B +\cdots+\phi_p(u)B^p</code>
is an autoregressive polynomial,
<code class="reqn">\Theta(u, B) = 1 + \theta_1(u)B + \cdots  + \theta_q(u)B^q</code> is a
moving average polynomial, <code class="reqn">d(u)</code> is a long-memory parameter,
<code class="reqn">\sigma(u)</code> is a noise scale factor and <code class="reqn">\{\varepsilon_t \}</code> is a
Gaussian white noise sequence with zero mean and unit variance. This class
of models extends the well-known ARMA and ARFIMA process, which is obtained
when the components <code class="reqn">\Phi(u, B)</code>, <code class="reqn">\Theta(u, B)</code>, <code class="reqn">d(u)</code> and
<code class="reqn">\sigma(u)</code> do not depend on <code class="reqn">u</code>.
The evolution of these models can be specified in terms of a general class
of functions. For example, let <code class="reqn">\{g_j(u)\}</code>, <code class="reqn">j = 1, 2, \ldots</code>, be
a basis for a space of smoothly varying functions and let
<code class="reqn">d_{\theta}(u)</code> be the time-varying long-memory parameter in model
LS-ARFIMA. Then we could write <code class="reqn">d_{\theta}(u)</code> in terms of the basis
<code class="reqn">\{g_j(u) = u^j\}</code> as follows
<code class="reqn">d_{\theta}(u) = \sum_{j=0}^{k} \alpha_j\,g_j(u)</code>
for unknown values of <code class="reqn">k</code> and
<code class="reqn">\theta = (\alpha_0,\,\alpha_1,\,\ldots, \,\alpha_k)^{\prime}</code>.
In this situation, estimating <code class="reqn">\theta</code> involves determining <code class="reqn">k</code> and
estimating the coefficients <code class="reqn">\alpha_0,\,\alpha_1,\,\ldots, \,\alpha_k</code>.
<code>LS.whittle</code> optimizes <code><a href="#topic+LS.whittle.loglik">LS.whittle.loglik</a></code> as objective
function using <code><a href="stats.html#topic+nlminb">nlminb</a></code> function, for both LS-ARMA
(<code>include.d=FALSE</code>) and LS-ARFIMA (<code>include.d=TRUE</code>) models.
Also computes Kalman filter with <code><a href="#topic+LS.kalman">LS.kalman</a></code> and this values
are given in <code>var.coef</code> in the output.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>The best set of parameters found.</p>
</td></tr>
<tr><td><code>var.coef</code></td>
<td>
<p>covariance matrix approximated for maximum likelihood
estimator <code class="reqn">\hat{\theta}</code> of
<code class="reqn">\theta:=(\theta_1,\ldots,\theta_k)^{\prime}</code>. This matrix is
approximated by <code class="reqn">H^{-1}/n</code>, where <code class="reqn">H</code> is the Hessian matrix
<code class="reqn">[\partial^2 \ell(\theta)/\partial\theta_i
\partial\theta_j]_{i,j=1}^{k}</code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of <code>coef</code>, calculated with
<code><a href="#topic+LS.whittle">LS.whittle</a></code>.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>Akaike'S &lsquo;An Information Criterion&rsquo;, for one fitted model LS-ARMA
or LS-ARFIMA. The formula is <code class="reqn">-2L + 2k/n</code>, where <em>L</em> represents the
log-likelihood, <em>k</em> represents the number of parameters in the fitted
model and <em>n</em> is equal to the length of the <code>series</code>.</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>original time serie.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>standard residuals.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>model fitted values.</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>predictions of the model.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the estimated standard errors.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list representing the fitted model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nlminb">nlminb</a></code>, <code><a href="#topic+LS.kalman">LS.kalman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Analysis by blocks of phi and sigma parameters
N &lt;- 200
S &lt;- 100
M &lt;- trunc((length(malleco) - N) / S + 1)
table &lt;- c()
for (j in 1:M) {
  x &lt;- malleco[(1 + S * (j - 1)):(N + S * (j - 1))]
  table &lt;- rbind(table, nlminb(
    start = c(0.65, 0.15), N = N,
    objective = LS.whittle.loglik,
    series = x, order = c(p = 1, q = 0)
  )$par)
}
u &lt;- (N / 2 + S * (1:M - 1)) / length(malleco)
table &lt;- as.data.frame(cbind(u, table))
colnames(table) &lt;- c("u", "phi", "sigma")
# Start parameters
phi &lt;- smooth.spline(table$phi, spar = 1, tol = 0.01)$y
fit.1 &lt;- nls(phi ~ a0 + a1 * u, start = list(a0 = 0.65, a1 = 0.00))
sigma &lt;- smooth.spline(table$sigma, spar = 1)$y
fit.2 &lt;- nls(sigma ~ b0 + b1 * u, start = list(b0 = 0.65, b1 = 0.00))
fit_whittle &lt;- LS.whittle(
  series = malleco, start = c(coef(fit.1), coef(fit.2)), order = c(p = 1, q = 0),
  ar.order = 1, sd.order = 1, N = 180, n.ahead = 10
)
</code></pre>

<hr>
<h2 id='LS.whittle.loglik'>Locally Stationary Whittle log-likelihood Function</h2><span id='topic+LS.whittle.loglik'></span>

<h3>Description</h3>

<p>This function computes Whittle estimator for LS-ARMA and
LS-ARFIMA models, in data with mean zero. If mean is not zero, then it is
subtracted to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.whittle.loglik(
  x,
  series,
  order = c(p = 0, q = 0),
  ar.order = NULL,
  ma.order = NULL,
  sd.order = NULL,
  d.order = NULL,
  include.d = FALSE,
  N = NULL,
  S = NULL,
  include.taper = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS.whittle.loglik_+3A_x">x</code></td>
<td>
<p>(type: numeric) parameter vector.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_series">series</code></td>
<td>
<p>(type: numeric) univariate time series.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_order">order</code></td>
<td>
<p>(type: numeric) vector corresponding to <code>ARMA</code> model
entered.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_ar.order">ar.order</code></td>
<td>
<p>(type: numeric) AR polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_ma.order">ma.order</code></td>
<td>
<p>(type: numeric) MA polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_sd.order">sd.order</code></td>
<td>
<p>(type: numeric) polinomial order noise scale factor.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_d.order">d.order</code></td>
<td>
<p>(type: numeric) <code>d</code> polinomial order, where <code>d</code> is
the <code>ARFIMA</code> parameter.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_include.d">include.d</code></td>
<td>
<p>(type: numeric) logical argument for <code>ARFIMA</code> models.
If <code>include.d=FALSE</code> then the model is an ARMA process.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_n">N</code></td>
<td>
<p>(type: numeric) value corresponding to the length of the window to
compute periodogram. If <code>N=NULL</code> then the function will use
<code class="reqn">N = \textrm{trunc}(n^{0.8})</code>, see Dahlhaus (1998) where <code class="reqn">n</code> is the
length of the <code>y</code> vector.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_s">S</code></td>
<td>
<p>(type: numeric) value corresponding to the lag with which will go
taking the blocks or windows.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik_+3A_include.taper">include.taper</code></td>
<td>
<p>(type: logical) logical argument that by default is
<code>TRUE</code>. See <code><a href="#topic+periodogram">periodogram</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation of the time-varying parameters can be carried out by means of
the Whittle log-likelihood function proposed by Dahlhaus (1997),
</p>
<p style="text-align: center;"><code class="reqn">L_n(\theta) = \frac{1}{4\pi}\frac{1}{M} \int_{-\pi}^{\pi}
\bigg\{log f_{\theta}(u_j,\lambda) +
\frac{I_N(u_j, \lambda)}{f_{\theta}(u_j,\lambda)}\bigg\}\,d\lambda</code>
</p>

<p>where <code class="reqn">M</code> is the number of blocks, <code class="reqn">N</code> the length of the series per
block, <code class="reqn">n =S(M-1)+N</code>, <code class="reqn">S</code> is the shift from block to block,
<code class="reqn">u_j =t_j/n</code>, <code class="reqn">t_j =S(j-1)+N/2</code>, <code class="reqn">j =1,\ldots,M</code> and
<code class="reqn">\lambda</code> the Fourier frequencies in the block
(<code class="reqn">2\,\pi\,k/N</code>, <code class="reqn">k = 1,\ldots, N</code>).
</p>


<h3>References</h3>

<p>For more information on theoretical foundations and estimation methods see
Brockwell PJ, Davis RA, Calder MV (2002).
<em>Introduction to time series and forecasting</em>, volume 2.
Springer.
Palma W, Olea R, others (2010).
&ldquo;An efficient estimator for locally stationary Gaussian long-memory processes.&rdquo;
<em>The Annals of Statistics</em>, <b>38</b>(5), 2958&ndash;2997.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+nlminb">nlminb</a></code>, <code><a href="#topic+LS.kalman">LS.kalman</a></code>
</p>

<hr>
<h2 id='LS.whittle.loglik.sd'>Locally Stationary Whittle Log-likelihood sigma</h2><span id='topic+LS.whittle.loglik.sd'></span>

<h3>Description</h3>

<p>This function calculates log-likelihood with known <code class="reqn">\theta</code>,
through <code>LS.whittle.loglik</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.whittle.loglik.sd(
  x,
  series,
  order = c(p = 0, q = 0),
  ar.order = NULL,
  ma.order = NULL,
  sd.order = NULL,
  d.order = NULL,
  include.d = FALSE,
  N = NULL,
  S = NULL,
  include.taper = TRUE,
  theta.par = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS.whittle.loglik.sd_+3A_x">x</code></td>
<td>
<p>(type: numeric) parameter vector.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_series">series</code></td>
<td>
<p>(type: numeric) univariate time series.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_order">order</code></td>
<td>
<p>(type: numeric) vector corresponding to <code>ARMA</code> model
entered.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_ar.order">ar.order</code></td>
<td>
<p>(type: numeric) AR polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_ma.order">ma.order</code></td>
<td>
<p>(type: numeric) MA polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_sd.order">sd.order</code></td>
<td>
<p>(type: numeric) polinomial order noise scale factor.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_d.order">d.order</code></td>
<td>
<p>(type: numeric) <code>d</code> polinomial order, where <code>d</code> is
the <code>ARFIMA</code> parameter.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_include.d">include.d</code></td>
<td>
<p>(type: numeric) logical argument for <code>ARFIMA</code> models.
If <code>include.d=FALSE</code> then the model is an ARMA process.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_n">N</code></td>
<td>
<p>(type: numeric) value corresponding to the length of the window to
compute periodogram. If <code>N=NULL</code> then the function will use
<code class="reqn">N = \textrm{trunc}(n^{0.8})</code>, see Dahlhaus (1998) where <code class="reqn">n</code> is the
length of the <code>y</code> vector.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_s">S</code></td>
<td>
<p>(type: numeric) value corresponding to the lag with which will go
taking the blocks or windows.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_include.taper">include.taper</code></td>
<td>
<p>(type: logical) logical argument that by default is
<code>TRUE</code>. See <code><a href="#topic+periodogram">periodogram</a></code>.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.sd_+3A_theta.par">theta.par</code></td>
<td>
<p>(type: numeric) vector with the known parameters of the
model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes <code><a href="#topic+LS.whittle.loglik">LS.whittle.loglik</a></code> with <code>x</code> as
<code>x = c(theta.par, x)</code>.
</p>

<hr>
<h2 id='LS.whittle.loglik.theta'>Locally Stationary Whittle Log-likelihood theta</h2><span id='topic+LS.whittle.loglik.theta'></span>

<h3>Description</h3>

<p>Calculate the log-likelihood with <code class="reqn">\sigma</code> known, through
<code>LS.whittle.loglik</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LS.whittle.loglik.theta(
  x,
  series,
  order = c(p = 0, q = 0),
  ar.order = NULL,
  ma.order = NULL,
  sd.order = NULL,
  d.order = NULL,
  include.d = FALSE,
  N = NULL,
  S = NULL,
  include.taper = TRUE,
  sd.par = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LS.whittle.loglik.theta_+3A_x">x</code></td>
<td>
<p>(type: numeric) parameter vector.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_series">series</code></td>
<td>
<p>(type: numeric) univariate time series.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_order">order</code></td>
<td>
<p>(type: numeric) vector corresponding to <code>ARMA</code> model
entered.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_ar.order">ar.order</code></td>
<td>
<p>(type: numeric) AR polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_ma.order">ma.order</code></td>
<td>
<p>(type: numeric) MA polimonial order.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_sd.order">sd.order</code></td>
<td>
<p>(type: numeric) polinomial order noise scale factor.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_d.order">d.order</code></td>
<td>
<p>(type: numeric) <code>d</code> polinomial order, where <code>d</code> is
the <code>ARFIMA</code> parameter.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_include.d">include.d</code></td>
<td>
<p>(type: numeric) logical argument for <code>ARFIMA</code> models.
If <code>include.d=FALSE</code> then the model is an ARMA process.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_n">N</code></td>
<td>
<p>(type: numeric) value corresponding to the length of the window to
compute periodogram. If <code>N=NULL</code> then the function will use
<code class="reqn">N = \textrm{trunc}(n^{0.8})</code>, see Dahlhaus (1998) where <code class="reqn">n</code> is the
length of the <code>y</code> vector.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_s">S</code></td>
<td>
<p>(type: numeric) value corresponding to the lag with which will go
taking the blocks or windows.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_include.taper">include.taper</code></td>
<td>
<p>(type: logical) logical argument that by default is
<code>TRUE</code>. See <code><a href="#topic+periodogram">periodogram</a></code>.</p>
</td></tr>
<tr><td><code id="LS.whittle.loglik.theta_+3A_sd.par">sd.par</code></td>
<td>
<p>(type: numeric) value corresponding to known variance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes <code><a href="#topic+LS.whittle.loglik">LS.whittle.loglik</a></code> with <code>x</code> as
<code>x = c(x, sd.par)</code>.
</p>

<hr>
<h2 id='malleco'>Average Araucaria Araucana Tree Ring Width</h2><span id='topic+malleco'></span>

<h3>Description</h3>

<p>A ts object containing average annual ring width measured in
milimiters for different Araucaria Araucana trees in the Malleco Region
(Chile). The years of observation in this data cover the period 1242-1975.
</p>


<h3>Format</h3>

<p>A time series object with 734 elements
</p>


<h3>Author(s)</h3>

<p>National Oceanic and Atmospheric Administration (NOAA)
</p>

<hr>
<h2 id='periodogram'>Periodogram function</h2><span id='topic+periodogram'></span>

<h3>Description</h3>

<p>This function computes the periodogram from a stationary time
serie. Returns the periodogram, its graph and the Fourier frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodogram(y, plot = TRUE, include.taper = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="periodogram_+3A_y">y</code></td>
<td>
<p>(type: numeric) data vector</p>
</td></tr>
<tr><td><code id="periodogram_+3A_plot">plot</code></td>
<td>
<p>(type: logical) logical argument which allows to plot the
periodogram. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="periodogram_+3A_include.taper">include.taper</code></td>
<td>
<p>(type: logical) logical argument which by default is
<code>FALSE</code>. If <code>include.taper=TRUE</code> then <code>y</code> is multiplied by
<code class="reqn">0.5(1 - \cos(2\pi(n-1)/n))</code> (cosine bell).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tapered periodogram it is given by
</p>
<p style="text-align: center;"><code class="reqn">I(\lambda) = \frac{|D_n(\lambda)|^2}{2\pi
H_{2,n}(0)}</code>
</p>
<p> with <code class="reqn">D(\lambda) = \sum_{s=0}^{n-1} h
\left(\frac{s}{N}\right) y_{s+1}\,
e^{-i\,\lambda\,s}</code>, <code class="reqn">H_{k,n} = \sum_{s=0}^{n-1}h
\left(\frac{s}{N}\right)^k\,
e^{-i\,\lambda\,s}</code> and <code class="reqn">\lambda</code> are Fourier frequencies defined as
<code class="reqn">2\pi k/n</code>, with <code class="reqn">k = 1,\,\ldots,\, n</code>.
The data taper used is the cosine bell function,
<code class="reqn">h(x) = \frac{1}{2}[1-\cos(2\pi x)]</code>. If the series has missing data,
these are replaced by the average of the data and <code class="reqn">n</code> it is corrected by
$n-N$, where <code class="reqn">N</code> is the amount of missing values of serie. The plot of
the periodogram is <code>periodogram</code> values vs. <code class="reqn">\lambda</code>.
</p>


<h3>Value</h3>

<p>A list with with the periodogram and the lambda values.
</p>


<h3>References</h3>

<p>For more information on theoretical foundations and estimation methods see
Brockwell PJ, Davis RA, Calder MV (2002).
<em>Introduction to time series and forecasting</em>, volume 2.
Springer.
Dahlhaus R, others (1997).
&ldquo;Fitting time series models to nonstationary processes.&rdquo;
<em>The annals of Statistics</em>, <b>25</b>(1), 1&ndash;37.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fft">fft</a></code>, <code><a href="base.html#topic+Mod">Mod</a></code>,
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR(1) simulated
set.seed(1776)
ts.sim &lt;- arima.sim(n = 1000, model = list(order = c(1, 0, 0), ar = 0.7))
per &lt;- periodogram(ts.sim)
per$plot
</code></pre>

<hr>
<h2 id='smooth.periodogram'>Smoothing periodogram</h2><span id='topic+smooth.periodogram'></span>

<h3>Description</h3>

<p>This function returns the smoothing periodogram of a stationary
time serie, its plot and its Fourier frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.periodogram(y, plot = TRUE, spar = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.periodogram_+3A_y">y</code></td>
<td>
<p>(type: numeric) data vector.</p>
</td></tr>
<tr><td><code id="smooth.periodogram_+3A_plot">plot</code></td>
<td>
<p>(type: logical) logical argument which allows to plot the
periodogram. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="smooth.periodogram_+3A_spar">spar</code></td>
<td>
<p>(type: numeric) smoothing parameter, typically (but not
necessarily) in <code class="reqn">(0,1].</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>smooth.periodogram</code> computes the periodogram from <code>y</code> vector and
then smooth it with <em>smoothing spline</em> method, which basically
approximates a curve using a cubic spline (see more details in
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>). <code class="reqn">\lambda</code> is the Fourier frequency
obtained through <code><a href="#topic+periodogram">periodogram</a></code>.
It must have caution with the minimum length of <code>y</code>, because
<code>smooth.spline</code> requires the entered vector has at least length 4 and
the length of <code>y</code> does not equal to the length of the data of the
periodogram that <code>smooth.spline</code> receives.
If it presents problems with tol (<b>tol</b>erance), see
<code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.
</p>


<h3>Value</h3>

<p>A list with with the smooth periodogram and the lambda values
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># AR(1) simulated
require(ggplot2)
set.seed(1776)
ts.sim &lt;- arima.sim(n = 1000, model = list(order = c(1, 0, 0), ar = 0.7))
per &lt;- periodogram(ts.sim)
aux &lt;- smooth.periodogram(ts.sim, plot = FALSE, spar = .7)
sm_p &lt;- data.frame(x = aux$lambda, y = aux$smooth.periodogram)
sp_d &lt;- data.frame(
  x = aux$lambda,
  y = spectral.density(ar = 0.7, lambda = aux$lambda)
)
g &lt;- per$plot
g +
  geom_line(data = sm_p, aes(x, y), color = "#ff7f0e") +
  geom_line(data = sp_d, aes(x, y), color = "#d31244")
</code></pre>

<hr>
<h2 id='spectral.density'>Spectral Density</h2><span id='topic+spectral.density'></span>

<h3>Description</h3>

<p>Returns theoretical spectral density evaluated in ARMA and
ARFIMA processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spectral.density(ar = numeric(), ma = numeric(), d = 0, sd = 1, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spectral.density_+3A_ar">ar</code></td>
<td>
<p>(type: numeric) AR vector. If the time serie doesn't have AR term
then omit it. For more details see the examples.</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_ma">ma</code></td>
<td>
<p>(type: numeric) MA vector. If the time serie doesn't have MA term
then omit it. For more details see the examples.</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_d">d</code></td>
<td>
<p>(type: numeric) Long-memory parameter. If d is zero, then the
process is ARMA(p,q).</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_sd">sd</code></td>
<td>
<p>(type: numeric) Noise scale factor, by default is 1.</p>
</td></tr>
<tr><td><code id="spectral.density_+3A_lambda">lambda</code></td>
<td>
<p>(type: numeric) <code class="reqn">\lambda</code> parameter on which the spectral
density is calculated/computed. If <code>lambda=NULL</code> then it is considered a
sequence between 0 and <code class="reqn">\pi</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spectral density of an ARFIMA(p,d,q) processes is
</p>
<p style="text-align: center;"><code class="reqn">f(\lambda) = \frac{\sigma^2}{2\pi} \cdot \bigg(2\,
\sin(\lambda/2)\bigg)^{-2d} \cdot
\frac{\bigg|\theta\bigg(\exp\bigg(-i\lambda\bigg)\bigg)\bigg|^2}
{\bigg|\phi\bigg(\exp\bigg(-i\lambda\bigg)\bigg)\bigg|^2}</code>
</p>

<p>With <code class="reqn">-\pi \le \lambda \le \pi</code> and <code class="reqn">-1 &lt; d &lt; 1/2</code>. <code class="reqn">|x|</code> is the
<code><a href="base.html#topic+Mod">Mod</a></code> of <code class="reqn">x</code>. <code>LSTS_sd</code> returns the
values corresponding to <code class="reqn">f(\lambda)</code>. When <code>d</code> is zero, the spectral
density corresponds to an ARMA(p,q).
</p>


<h3>Value</h3>

<p>An unnamed vector of numeric class.
</p>


<h3>References</h3>

<p>For more information on theoretical foundations and estimation methods see
Brockwell PJ, Davis RA, Calder MV (2002).
<em>Introduction to time series and forecasting</em>, volume 2.
Springer.
Palma W (2007).
<em>Long-memory time series: theory and methods</em>, volume 662.
John Wiley \&amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Spectral Density AR(1)
require(ggplot2)
f &lt;- spectral.density(ar = 0.5, lambda = malleco)
ggplot(data.frame(x = malleco, y = f)) +
  geom_line(aes(x = as.numeric(x), y = as.numeric(y))) +
  labs(x = "Frequency", y = "Spectral Density") +
  theme_minimal()
</code></pre>

<hr>
<h2 id='ts.diag'>Diagnostic Plots for Time Series fits</h2><span id='topic+ts.diag'></span>

<h3>Description</h3>

<p>Plot time-series diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts.diag(x, lag = 10, band = qnorm(0.975)/sqrt(length(x)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ts.diag_+3A_x">x</code></td>
<td>
<p>(type: numeric) residuals of the fitted time series model.</p>
</td></tr>
<tr><td><code id="ts.diag_+3A_lag">lag</code></td>
<td>
<p>(type: numeric) maximum lag at which to calculate the acf and
Ljung-Box test. By default set to 10.</p>
</td></tr>
<tr><td><code id="ts.diag_+3A_band">band</code></td>
<td>
<p>(type: numeric) absolute value for bandwidth in the the ACF plot.
By default set to 'qnorm(0.975)/sqrt(n)' which approximates to 0.07 for 
malleco data (n = 734)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plot the residuals, the autocorrelation function of the
residuals (ACF) and the p-values of the Ljung-Box Test for all lags up to
<code>lag</code>.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Box.Ljung.Test">Box.Ljung.Test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts.diag(malleco)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
