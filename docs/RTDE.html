<!DOCTYPE html><html><head><title>Help for package RTDE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RTDE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dataRTDE'><p>Data object used for a Tail Dependence model</p></a></li>
<li><a href='#EPD'><p>The Extended Pareto Distribution</p></a></li>
<li><a href='#FGM'><p>The Eyraud Farlie Gumbel Morgenstern Distribution</p></a></li>
<li><a href='#fitRTDE'><p>Fitting a Tail Dependence model with a Robust Estimator</p></a></li>
<li><a href='#Frank'><p>The Frank Distribution</p></a></li>
<li><a href='#Frechet'><p>The Frechet Distribution</p></a></li>
<li><a href='#MDPD'><p>The Minimum Distance Power Divergence statistics</p></a></li>
<li><a href='#qqparetoplot'><p>The QQ Pareto plot</p></a></li>
<li><a href='#RTDE'><p>Data object used for a Tail Dependence model</p></a></li>
<li><a href='#upareto'><p>The unit Pareto Distribution</p></a></li>
<li><a href='#zvalueRTDE'><p>The Z-value random variable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Tail Dependence Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-1</td>
</tr>
<tr>
<td>Author:</td>
<td>Christophe Dutang [aut, cre], Armelle Guillou [ctb], Yuri Goegebeur [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christophe Dutang &lt;christophe.dutang@ensimag.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Robust tail dependence estimation for bivariate models. This package is based on two papers by the authors:'Robust and bias-corrected estimation of the coefficient of tail dependence' and 'Robust and bias-corrected estimation of probabilities of extreme failure sets'. This work was supported by a research grant (VKR023480) from VILLUM FONDEN and an international project for scientific cooperation (PICS-6416).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), parallel, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tseries</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-20 21:14:07 UTC; dutang</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-08 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dataRTDE'>Data object used for a Tail Dependence model</h2><span id='topic+dataRTDE'></span><span id='topic+summary.dataRTDE'></span><span id='topic+print.dataRTDE'></span><span id='topic+plot.dataRTDE'></span>

<h3>Description</h3>

<p>Data object used for a Tail Dependence model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dataRTDE(obs, simu.nb, simu.marg=c("ufrechet", "upareto"), 
    simu.cop=c("indep", "FGM", "Frank"), simu.cop.par=NULL,
    contamin.eps=NULL, contamin.method=c("NA","max+","+"),
    contamin.marg=c("ufrechet", "upareto"),
    contamin.cop=c("indep", "FGM", "Frank"),
    contamin.cop.par=NULL, control=list())


## S3 method for class 'dataRTDE'
print(x, ...)
## S3 method for class 'dataRTDE'
summary(object, ...)
## S3 method for class 'dataRTDE'
plot(x, which=1:2, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataRTDE_+3A_obs">obs</code></td>
<td>
<p>bivariate numeric dataset.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_simu.nb">simu.nb</code></td>
<td>
<p>a numeric for the sample size of simulated data.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_simu.marg">simu.marg</code></td>
<td>
<p>a character string for the marginal distribution: 
either <code>"ufrechet"</code> (default) or <code>"upareto"</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_simu.cop">simu.cop</code></td>
<td>
<p>a character string ofr the copula: 
either <code>"indep"</code> (default), <code>"FGM"</code> or <code>"Frank"</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_simu.cop.par">simu.cop.par</code></td>
<td>
<p>a numeric for the copula parameter, default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_contamin.eps">contamin.eps</code></td>
<td>
<p>a numeric for the percentage (of <code>simu.nb</code>) of contaminated data.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_contamin.method">contamin.method</code></td>
<td>
<p>a character string for the contamination method:
either <code>"NA"</code> (default), <code>"max+"</code> or <code>"+"</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_contamin.marg">contamin.marg</code></td>
<td>
<p>a character string for the marginal distribution:
either <code>"ufrechet"</code> (default) or <code>"upareto"</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_contamin.cop">contamin.cop</code></td>
<td>
<p>a character string ofr the copula:
either <code>"indep"</code> (default), <code>"FGM"</code> or <code>"Frank"</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_contamin.cop.par">contamin.cop.par</code></td>
<td>
<p>a numeric for the copula parameter, default to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_control">control</code></td>
<td>
<p>A list of control paremeters. Unused.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_x">x</code>, <code id="dataRTDE_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from <code>"dataRTDE"</code>.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_...">...</code></td>
<td>
<p>arguments to be passed to subsequent methods.</p>
</td></tr>
<tr><td><code id="dataRTDE_+3A_which">which</code></td>
<td>
<p>an integer (1 or 2) to specify whether to plot in 
original scale or unit-Pareto scale, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>dataRTDE</code> handles empirical or simulated data and may 
add a contamination. 
</p>

<dl>
<dt>Empirical data</dt><dd><p>When <code>obs</code> is provided, <code>dataRTDE</code> just wraps the 
two-column matrix <code class="reqn">(X_i, Y_i)_i</code>.</p>
</dd>
<dt>Simulated data</dt><dd><p>When <code>simu.XXX</code> are provided, 
<code>dataRTDE</code> simulates random vectors <code class="reqn">(X_i, Y_i)_i</code>
from the copula <code>simu.cop</code> with parameter <code>simu.cop.par</code> and 
marginal <code>simu.marg</code>.</p>
</dd>
</dl>

<p>Note that end-user must choose between empirical data (<code>obs</code> is provided) and simulated
data (<code>simu.XXX</code> are provided). Not both can be provided.
In addition to data handling <code class="reqn">(X_i, Y_i)_i</code>, 
a contamination can be processed by adding new simulated points <code class="reqn">(\tilde X_i, \tilde Y_i)_i</code>
when <code>contamin.method != "NA"</code>.
Those points <code class="reqn">(\tilde X_i, \tilde Y_i)_i</code> are simulated from the copula 
<code>contamin.cop</code> with parameter <code>contamin.cop.par</code> and marginal <code>contamin.cop.par</code>.
If <code>contamin.method != "+"</code>, the points <code class="reqn">(\tilde X_i, \tilde Y_i)_i</code> are the contaminations,
while if <code>contamin.method != "max+"</code> the contaminations are obtained by adding the
component-wise maximum of the data: <code class="reqn">(\tilde X_i + X_{n,n}, \tilde Y_i)_i + Y_{n,n}</code>,
where <code class="reqn">X_{n,n}=max(X_1,...,X_n)</code>, idem for <code class="reqn">Y_{n,n}</code>.
</p>


<h3>Value</h3>

<p><code>dataRTDE</code> returns an object of class <code>"dataRTDE"</code>
having the following components:
</p>

<dl>
<dt><code>n</code></dt><dd><p>rownumber of <code>data</code>.</p>
</dd>
<dt><code>n0</code></dt><dd><p>rownumber of <code>contamin</code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>original or simulated data.</p>
</dd>
<dt><code>contamin</code></dt><dd><p>contaminated data.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>C. Dutang, Y. Goegebeur, A. Guillou (2014),
<em>Robust and bias-corrected estimation of the coefficient of tail dependence</em>,
Volume 57, Insurance: Mathematics and Economics
</p>
<p>This work was supported by a research grant (VKR023480) from VILLUM FONDEN and an international project for scientific cooperation (PICS-6416).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+fitRTDE">fitRTDE</a></code> for the fitting process and
<code><a href="#topic+zvalueRTDE">zvalueRTDE</a></code> for the z-value computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) simulation

n &lt;- 100
x &lt;- dataRTDE(simu.nb=n, simu.marg="ufrechet", simu.cop="indep")
print(x)
summary(x)
plot(x, xlab="x", ylab="y")

#####
# (2) part of the workers' compensation dataset

x1 &lt;- c(
  21.798086,  22.640528,  22.572010,  24.789710,  25.876764,  28.033613,
  22.525887,  12.004031,  12.713178,  13.596610,  14.811727,  12.774073,
  20.245789,  24.242468,  50.216515,  56.099793,  58.109747,  67.807105,
  73.852437,  84.208474,  83.604216,  19.507341,  20.810822,  23.838122,
  24.212193,  25.367578,  35.401344,  37.580989,  12.428727,  13.492474,
  23.471988,  24.101833,  24.766193,  26.078216)

x2 &lt;- c(
 0.538707, 0.439184, 1.059775, 0.560013, 1.004997, 1.097314, 0.609833, 0.270222,
 0.229566, 0.596850, 0.196539, 0.134248, 0.489312, 0.418218, 0.769208, 0.649707,
 0.503919, 0.675466, 0.545745, 1.562266, 0.931762, 0.291125, 0.499927, 0.151084,
 0.141910, 0.300373, 0.119761, 0.141300, 0.377662, 0.169574, 0.243585, 0.061215,
 0.055272, 0.312816, 0.160196, 0.623029, 0.280707, 0.174422, 0.176666, 0.153907,
 0.605122, 0.664457, 0.348918, 0.370878)

obs &lt;- dataRTDE(cbind(x1, x2))
obs
summary(obs)

plot(obs)

</code></pre>

<hr>
<h2 id='EPD'>The Extended Pareto Distribution</h2><span id='topic+EPD'></span><span id='topic+dEPD'></span><span id='topic+pEPD'></span><span id='topic+qEPD'></span><span id='topic+rEPD'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dEPD(x, eta, delta, rho, tau, log = FALSE)
pEPD(q, eta, delta, rho, tau, lower.tail=TRUE, log.p = FALSE)
qEPD(p, eta, delta, rho, tau, lower.tail=TRUE, log.p = FALSE,
    control=list())
rEPD(n, eta, delta, rho, tau)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPD_+3A_x">x</code>, <code id="EPD_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="EPD_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="EPD_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="EPD_+3A_eta">eta</code></td>
<td>
<p>first shape parameter.</p>
</td></tr>
<tr><td><code id="EPD_+3A_delta">delta</code></td>
<td>
<p>nuisance parameter.</p>
</td></tr>
<tr><td><code id="EPD_+3A_rho">rho</code>, <code id="EPD_+3A_tau">tau</code></td>
<td>
<p>second shape parameter.</p>
</td></tr>
<tr><td><code id="EPD_+3A_log">log</code>, <code id="EPD_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="EPD_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="EPD_+3A_control">control</code></td>
<td>
<p>A list of control paremeters. See section Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extended Pareto distribution is defined by the following density
</p>
<p style="text-align: center;"><code class="reqn">
        f(x) = \frac{1}{\eta} x^{-1/\eta-1}[1+\delta(1-x^{-\tau})]^{-1/\eta-1}[1+\delta(1-(1-\tau)x^{-\tau})]
    </code>
</p>

<p>for all <code class="reqn">x&gt;1</code> when parametrized by <code class="reqn">\tau</code>.
However, a typical parametrization is obtained by
setting <code class="reqn">\tau=-\rho/\eta</code>, i.e.
</p>
<p style="text-align: center;"><code class="reqn">
        f(x) = \frac{1}{\eta} x^{-1/\eta-1}[1+\delta(1-x^{\rho/\eta})]^{-1/\eta-1}[1+\delta(1-(1+\rho/\eta)x^{\rho/\eta})]
    </code>
</p>

<p>for all <code class="reqn">x&gt;1</code> when parametrized by <code class="reqn">\rho</code>.
</p>
<p>The <code>control</code> argument is a list that can supply any of the
following components:
</p>

<dl>
<dt><code>upperbound</code></dt><dd><p>The upperbound used in the <code>optimize</code> function
when computing numerical quantiles, default to <code>1e6</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>the desired accuracy used in the <code>optimize</code> function
when computing numerical quantiles, default to <code>1e-9</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>dEPD</code> gives the density,
<code>pEPD</code> gives the distribution function,
<code>qEPD</code> gives the quantile function, and
<code>rEPD</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rEPD</code>, and is the maximum of the lengths of the
numerical parameters for the other functions.  
</p>
<p>The numerical parameters other than <code>n</code> are recycled to the
length of the result.  Only the first elements of the logical
parameters are used.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>J. Beirlant, E. Joossens, J. Segers (2009),
<em>Second-order refined peaks-over-threshold modelling for heavy-tailed distributions</em>, 
Journal of Statistical Planning and Inference,
Volume 139, Issue 8, Pages 2800-2815.
</p>
<p>C. Dutang, Y. Goegebeur, A. Guillou (2014),
<em>Robust and bias-corrected estimation of the coefficient of tail dependence</em>,
Insurance: Mathematics and Economics
</p>
<p>This work was supported by a research grant (VKR023480) from VILLUM FONDEN and an international project for scientific cooperation (PICS-6416).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) density function
x &lt;- seq(0, 5, length=24)

cbind(x, dEPD(x, 1/2, 1/4, -1))

#####
# (2) distribution function

cbind(x, pEPD(x, 1/2, 1/4, -1, lower=FALSE))




		
</code></pre>

<hr>
<h2 id='FGM'>The Eyraud Farlie Gumbel Morgenstern Distribution</h2><span id='topic+FGM'></span><span id='topic+dFGM'></span><span id='topic+pFGM'></span><span id='topic+qFGM'></span><span id='topic+rFGM'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dFGM(u, v, alpha, log = FALSE)
pFGM(u, v, alpha, lower.tail=TRUE, log.p = FALSE)
qFGM(p, alpha, lower.tail=TRUE, log.p = FALSE)
rFGM(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FGM_+3A_u">u</code>, <code id="FGM_+3A_v">v</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="FGM_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="FGM_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="FGM_+3A_alpha">alpha</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="FGM_+3A_log">log</code>, <code id="FGM_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="FGM_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The FGM is defined by the following distribution function
</p>
<p style="text-align: center;"><code class="reqn">
        C(u,v) = u*v*(1+\alpha*(1-u)*(1-v))
    </code>
</p>

<p>for all <code class="reqn">u,v</code> in [0,1] and <code class="reqn">\alpha</code> in [0,1].
When <code>lower.tail=FALSE</code>, <code>pFGM</code> returns the survival copula 
<code class="reqn">P(U &gt; u, V &gt; v)</code>.
</p>


<h3>Value</h3>

<p><code>dFGM</code> gives the density,
<code>pFGM</code> gives the distribution function,
<code>qFGM</code> gives the quantile function, and
<code>rFGM</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rFGM</code>, and is the maximum of the lengths of the
numerical parameters for the other functions.  
</p>
<p>The numerical parameters other than <code>n</code> are recycled to the
length of the result.  Only the first elements of the logical
parameters are used.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>Nelsen, R. (2006),
<em>An Introduction to Copula, Second Edition</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) density function
u &lt;- v &lt;- seq(0, 1, length=25)

cbind(u, v, dFGM(u, v, 1/2))
cbind(u, v, outer(u, v, dFGM, alpha=1/2))


#####
# (2) distribution function

cbind(u, v, pFGM(u, v, 1/2))
cbind(u, v, outer(u, v, pFGM, alpha=1/2))




		
</code></pre>

<hr>
<h2 id='fitRTDE'>Fitting a Tail Dependence model with a Robust Estimator</h2><span id='topic+fitRTDE'></span><span id='topic+summary.fitRTDE'></span><span id='topic+print.fitRTDE'></span><span id='topic+plot.fitRTDE'></span>

<h3>Description</h3>

<p>Fit a Tail Dependence model with a Robust Estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitRTDE(obs, nbpoint, alpha, omega, method="MDPDE", fix.arg=list(rho=-1),
    boundary.method="log", control=list())


## S3 method for class 'fitRTDE'
print(x, ...)
## S3 method for class 'fitRTDE'
summary(object, ...)
## S3 method for class 'fitRTDE'
plot(x, which=1:2, main, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitRTDE_+3A_obs">obs</code></td>
<td>
<p>bivariate numeric dataset.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_nbpoint">nbpoint</code></td>
<td>
<p>a numeric for the number of largest points to be selected.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_alpha">alpha</code></td>
<td>
<p>a numeric for the power divergence parameter.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_omega">omega</code></td>
<td>
<p>a numeric for omega, see section Details.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_method">method</code></td>
<td>
<p>a character string equals to <code>"MDPDE"</code>.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_fix.arg">fix.arg</code></td>
<td>
<p>a named list of fixed arguments:
either <code class="reqn">rho</code> only e.g. <code>list(rho=-1)</code>
or <code class="reqn">rho, delta</code> e.g. <code>list(rho=-1, delta=0)</code>.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_boundary.method">boundary.method</code></td>
<td>
<p>a character string: either &quot;log&quot;
or &quot;simple&quot;, see section Details.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_control">control</code></td>
<td>
<p>A list of control paremeters. See section Details.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_x">x</code>, <code id="fitRTDE_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from <code>"fitRTDE"</code>.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_...">...</code></td>
<td>
<p>arguments to be passed to subsequent methods.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_which">which</code></td>
<td>
<p>an integer (1 or 2) to specify whether to plot eta or
delta, respectively.</p>
</td></tr>
<tr><td><code id="fitRTDE_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fitRTDE</code> fits an extended Pareto distribution 
(<code class="reqn">\eta,\tau</code> are fitted while <code class="reqn">\rho</code> is fixed)
on the relative excess of <code class="reqn">Z_\omega</code> (see <code><a href="#topic+zvalueRTDE">zvalueRTDE</a></code>)
using a robust estimator based on the minimum distance power 
divergence criterion (see <code><a href="#topic+MDPD">MDPD</a></code>).
The boundary enforcement on <code class="reqn">\eta,\tau</code> is either done
by the bounded BFGS algorithm (see <code><a href="stats.html#topic+optim">optim</a></code> with 
<code>method="L-BFGS-B"</code>) or by the bounded Nelder-Mead
algorithm (see <code><a href="stats.html#topic+constrOptim">constrOptim</a></code> with
<code>method="Nelder-Mead"</code>) .
</p>


<h3>Value</h3>

<p><code>fitRTDE</code> returns an object of class <code>"fitRTDE"</code>
having the following components:
</p>

<dl>
<dt><code>n</code></dt><dd><p>rownumber of <code>data</code>.</p>
</dd>
<dt><code>n0</code></dt><dd><p>rownumber of <code>contamin</code>.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a vector of <code>alpha</code> parameters.</p>
</dd>
<dt><code>omega</code></dt><dd><p>a vector of <code>omega</code> parameters.</p>
</dd>
<dt><code>m</code></dt><dd><p>a vector of <code>nbpoint</code>.</p>
</dd>
<dt><code>rho</code></dt><dd><p>a numeric for <code>rho</code>.</p>
</dd>
<dt><code>eta</code></dt><dd><p>estimate of <code class="reqn">eta</code>.</p>
</dd>
<dt><code>delta</code></dt><dd><p>estimate of <code class="reqn">delta</code>.</p>
</dd>
<dt><code>Ztilde</code></dt><dd><p>see <code><a href="#topic+zvalueRTDE">zvalueRTDE</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>C. Dutang, Y. Goegebeur, A. Guillou (2014),
<em>Robust and bias-corrected estimation of the coefficient of tail dependence</em>,
Volume 57, Insurance: Mathematics and Economics
</p>
<p>This work was supported by a research grant (VKR023480) from VILLUM FONDEN and an international project for scientific cooperation (PICS-6416).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) simulation 

omega &lt;- 1/2
m &lt;- 48
n &lt;- 100
obs &lt;- cbind(rupareto(n), rupareto(n)) + rupareto(n)

#function of m
system.time(
x &lt;- fitRTDE(obs, nbpoint=m:(n-m), 0, 1/2)
)
x
summary(x)
plot(x, which=1)
plot(x, which=2)


</code></pre>

<hr>
<h2 id='Frank'>The Frank Distribution</h2><span id='topic+Frank'></span><span id='topic+dfrank'></span><span id='topic+pfrank'></span><span id='topic+qfrank'></span><span id='topic+rfrank'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfrank(u, v, alpha, log = FALSE)
pfrank(u, v, alpha, lower.tail=TRUE, log.p = FALSE)
qfrank(p, alpha, lower.tail=TRUE, log.p = FALSE)
rfrank(n, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Frank_+3A_u">u</code>, <code id="Frank_+3A_v">v</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Frank_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Frank_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Frank_+3A_alpha">alpha</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="Frank_+3A_log">log</code>, <code id="Frank_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Frank_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Frank is defined by the following distribution function
</p>
<p style="text-align: center;"><code class="reqn">
        C(u,v) = - \frac{1}{\alpha} \log\left[1-\frac{(1-e^{-\alpha u})(1-e^{-\alpha v}) }{ 1-e^{-\alpha}}\right],
    </code>
</p>

<p>for all <code class="reqn">u,v</code> in [0,1].
When <code>lower.tail=FALSE</code>, <code>pfrank</code> returns the survival copula 
<code class="reqn">P(U &gt; u, V &gt; v)</code>.
</p>


<h3>Value</h3>

<p><code>dfrank</code> gives the density,
<code>pfrank</code> gives the distribution function,
<code>qfrank</code> gives the quantile function, and
<code>rfrank</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rfrank</code>, and is the maximum of the lengths of the
numerical parameters for the other functions.  
</p>
<p>The numerical parameters other than <code>n</code> are recycled to the
length of the result.  Only the first elements of the logical
parameters are used.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>Nelsen, R. (2006),
<em>An Introduction to Copula, Second Edition</em>, Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) density function
u &lt;- v &lt;- seq(0, 1, length=25)

cbind(u, v, dfrank(u, v, 1/2))
cbind(u, v, outer(u, v, dfrank, alpha=1/2))


#####
# (2) distribution function

cbind(u, v, pfrank(u, v, 1/2))
cbind(u, v, outer(u, v, pfrank, alpha=1/2))




		
</code></pre>

<hr>
<h2 id='Frechet'>The Frechet Distribution</h2><span id='topic+Frechet'></span><span id='topic+dfrechet'></span><span id='topic+pfrechet'></span><span id='topic+qfrechet'></span><span id='topic+rfrechet'></span><span id='topic+dufrechet'></span><span id='topic+pufrechet'></span><span id='topic+qufrechet'></span><span id='topic+rufrechet'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfrechet(x, shape, xmin, log = FALSE)
pfrechet(q, shape, xmin, lower.tail=TRUE, log.p = FALSE)
qfrechet(p, shape, xmin, lower.tail=TRUE, log.p = FALSE)
rfrechet(n, shape, xmin)

dufrechet(x, log = FALSE)
pufrechet(q, lower.tail=TRUE, log.p = FALSE)
qufrechet(p, lower.tail=TRUE, log.p = FALSE)
rufrechet(n)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Frechet_+3A_x">x</code>, <code id="Frechet_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_shape">shape</code></td>
<td>
<p>shape parameter.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_xmin">xmin</code></td>
<td>
<p>lower bound parameter.</p>
</td></tr>
<tr><td><code id="Frechet_+3A_log">log</code>, <code id="Frechet_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="Frechet_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Frechet distribution is defined by the following density
</p>
<p style="text-align: center;"><code class="reqn">
        f(x) = shape * (x - xmin)^{(-shape-1)} * exp(-(x - xmin)^{(-shape)})
    </code>
</p>

<p>for all <code class="reqn">x&gt;xmin</code>.
The unit Frechet distribution corresponds to <code>xmin=0</code> and 
<code>shape=1</code>.
</p>


<h3>Value</h3>

<p><code>dfrechet, dufrechet</code> give the density,
<code>pfrechet, pufrechet</code> give the distribution function,
<code>qfrechet, qufrechet</code> give the quantile function, and
<code>rfrechet, rufrechet</code> generate random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rfrechet, rufrechet</code>, and is the maximum of the lengths of the
numerical parameters for the other functions.  
</p>
<p>The numerical parameters other than <code>n</code> are recycled to the
length of the result.  Only the first elements of the logical
parameters are used.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>Kotz, S. and Nadarajah, S. (2000),
<em>Extreme Value Distributions: Theory and Applications</em>, 
Imperial College Press.
</p>
<p>Beirlant, J., Goegebeur, Y., Teugels, J., Segers (2004),
<em>Statistics of Extremes: Theory and Applications</em>,
John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) density function
x &lt;- seq(0, 5, length=24)

cbind(x, dfrechet(x, 1/2, 1/4))

#####
# (2) distribution function

cbind(x, pfrechet(x, 1/2, 1/4))




		
</code></pre>

<hr>
<h2 id='MDPD'>The Minimum Distance Power Divergence statistics</h2><span id='topic+MDPD'></span>

<h3>Description</h3>

<p>Computes the power divergence statistics then used a minimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDPD(theta, densfun, obs, alpha, ..., control=list())

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDPD_+3A_theta">theta</code></td>
<td>
<p>the parameter of the distribution given as a vector.</p>
</td></tr>
<tr><td><code id="MDPD_+3A_densfun">densfun</code></td>
<td>
<p>a function computing the theoretical density function.</p>
</td></tr>
<tr><td><code id="MDPD_+3A_obs">obs</code></td>
<td>
<p>a numeric vector of observations</p>
</td></tr>
<tr><td><code id="MDPD_+3A_alpha">alpha</code></td>
<td>
<p>a numeric for the power divergence parameter.</p>
</td></tr>
<tr><td><code id="MDPD_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the density function.</p>
</td></tr>
<tr><td><code id="MDPD_+3A_control">control</code></td>
<td>
<p>A list of control paremeters. See section Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Power Divergence for a density function <code class="reqn">f</code> and
observations <code class="reqn">X_1,...,X_n</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">
        \Delta(f,\alpha) = \int_{R} f^{1+\alpha}(x)dx-\left ( 1+\frac{1}{\alpha} \right )
        \frac{1}{n} \sum_{i=1}^n f^\alpha(X_i)
    </code>
</p>

<p>for <code class="reqn">\alpha&gt; 0</code>
</p>
<p style="text-align: center;"><code class="reqn">
        \Delta(f,0) = -\frac{1}{n}\sum_{i=1}^n \log f(X_i)
    </code>
</p>

<p>for <code class="reqn">\alpha = 0</code>.
</p>
<p>The <code>control</code> argument is a list that can supply any of the
following components:
</p>

<dl>
<dt><code>eps</code></dt><dd><p>a small positive floating-point number used when
<code>integrate</code> stalled, default to <code>1e-3</code>.</p>
</dd>
<dt><code>tol</code></dt><dd><p>the desired accuracy used in the <code>integrate</code> function
when computing the power divergence, default to <code>1e-3</code>.</p>
</dd>
<dt><code>lower</code></dt><dd><p>the lower bound of the domain of the density function, 
default to 1.</p>
</dd>
<dt><code>upper</code></dt><dd><p>the lower bound of the domain of the density function, 
default to infinity.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>MDPD</code> returns the power divergence against the density function <code>densfun</code>
as a numeric.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>Basu, A., Harris, I.R., Hjort, N.L., Jones, M.C., (1998).
<em>Robust and efficient estimation by minimizing a density power divergence</em>, 
Biometrika, 85, 549-559.
</p>
<p>C. Dutang, Y. Goegebeur, A. Guillou (2014),
<em>Robust and bias-corrected estimation of the coefficient of tail dependence</em>,
Insurance: Mathematics and Economics
</p>
<p>This work was supported by a research grant (VKR023480) from VILLUM FONDEN and an international project for scientific cooperation (PICS-6416).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) small example

omega &lt;- 1/2
m &lt;- 10
n &lt;- 100
obs &lt;- cbind(rupareto(n), rupareto(n)) + rupareto(n)

#unit Pareto transform
z &lt;- zvalueRTDE(obs, omega, nbpoint=m, output="relexcess")

MDPD(c(1/2, 1/4), dEPD, z$Z, alpha=0, rho=-1)




		
</code></pre>

<hr>
<h2 id='qqparetoplot'>The QQ Pareto plot</h2><span id='topic+qqparetoplot'></span>

<h3>Description</h3>

<p>Plot the quantile-quantile Pareto plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qqparetoplot(x, ..., highlight=c("red","cross"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qqparetoplot_+3A_x">x</code></td>
<td>
<p>data vector.</p>
</td></tr>
<tr><td><code id="qqparetoplot_+3A_highlight">highlight</code></td>
<td>
<p>character string used in <code>points</code>
to plot outliers.</p>
</td></tr>
<tr><td><code id="qqparetoplot_+3A_...">...</code></td>
<td>
<p>further arguments for <code>plot.default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qqparetoplot</code> plots the quantile-quantile Pareto plot
and may highlight some points having name <code>"new"</code>.
</p>


<h3>Value</h3>

<p>Invisible list with component <code>x</code> for the x-coordinates
and <code>y</code> for the y-coordinates.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) small examples

set.seed(1234)
x &lt;- rupareto(100)
qqparetoplot(x)

x &lt;- rexp(100)
qqparetoplot(x)

		
</code></pre>

<hr>
<h2 id='RTDE'>Data object used for a Tail Dependence model</h2><span id='topic+RTDE'></span><span id='topic+summary.RTDE'></span><span id='topic+print.RTDE'></span><span id='topic+plot.RTDE'></span><span id='topic+prob'></span><span id='topic+prob.default'></span><span id='topic+prob.RTDE'></span>

<h3>Description</h3>

<p>Data object used for a Tail Dependence model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RTDE(obs=NULL, simu=list(), contamin=list(),
    nbpoint, alpha, omega, method="MDPDE", fix.arg=list(rho=-1),
    boundary.method="log", core=1, keepdata, control=list())


## S3 method for class 'RTDE'
print(x, ...)
## S3 method for class 'RTDE'
summary(object, ...)
## S3 method for class 'RTDE'
plot(x, which=1:3, FUN=mean, main, ...)

prob(object, q, ...)
## Default S3 method:
prob(object, q, ...)
## S3 method for class 'RTDE'
prob(object, q, ...)


</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RTDE_+3A_obs">obs</code></td>
<td>
<p>bivariate numeric dataset.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_simu">simu</code></td>
<td>
<p>a names list with components:
<code>"nb"</code>, <code>"marg"</code>, <code>"cop"</code>, <code>"replicate"</code>.
When needed, <code>"cop.par"</code> must be provided,
see <code><a href="#topic+dataRTDE">dataRTDE</a></code>.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_contamin">contamin</code></td>
<td>
<p>a names list with components:
<code>"eps"</code>, <code>"method"</code>, <code>"marg"</code>, <code>"cop"</code>.
When needed, <code>"cop.par"</code> must be provided,
see <code><a href="#topic+dataRTDE">dataRTDE</a></code>.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_nbpoint">nbpoint</code></td>
<td>
<p>a numeric for the number of largest points to be selected.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_alpha">alpha</code></td>
<td>
<p>a numeric for the power divergence parameter.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_omega">omega</code></td>
<td>
<p>a numeric for omega, see section Details.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_method">method</code></td>
<td>
<p>a character string equals to <code>"MDPDE"</code>.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_fix.arg">fix.arg</code></td>
<td>
<p>a named list of fixed arguments:
either <code class="reqn">rho</code> only e.g. <code>list(rho=-1)</code>
or <code class="reqn">rho, delta</code> e.g. <code>list(rho=-1, delta=0)</code>.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_boundary.method">boundary.method</code></td>
<td>
<p>a character string: either &quot;log&quot;
or &quot;simple&quot;, see section Details.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_core">core</code></td>
<td>
<p>a numeric for the number of core to be used,
only relevant for simulated data.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_keepdata">keepdata</code></td>
<td>
<p>a logical whether to return or not the dataset.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_control">control</code></td>
<td>
<p>A list of control paremeters for <code><a href="#topic+fitRTDE">fitRTDE</a></code>.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_x">x</code>, <code id="RTDE_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from <code>"RTDE"</code>.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_...">...</code></td>
<td>
<p>arguments to be passed to subsequent methods.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_which">which</code></td>
<td>
<p>an integer to specify what to plot: 1 eta, 2 delta, 
3 probability estimates.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied, default to <code><a href="base.html#topic+mean">mean</a></code>.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_main">main</code></td>
<td>
<p>a main title for the plot.</p>
</td></tr>
<tr><td><code id="RTDE_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>RTDE</code> handles (empirical or simulated) data 
(cf. <code><a href="#topic+dataRTDE">dataRTDE</a></code>)
and then fits a bivariate tail model using a <code>method</code> criterion
(cf. <code><a href="#topic+fitRTDE">fitRTDE</a></code> and <code><a href="#topic+MDPD">MDPD</a></code>) based
on an extended Pareto distribution approximation (<code><a href="#topic+EPD">EPD</a></code>).
Typical distributions for simulated data and/or contaminations are
</p>

<ul>
<li><p>MarginalUnit Pareto <code><a href="#topic+upareto">upareto</a></code>, Frechet <code><a href="#topic+Frechet">Frechet</a></code>.
</p>
</li>
<li><p>CopulaFrank <code><a href="#topic+Frank">Frank</a></code>, FGM <code><a href="#topic+FGM">FGM</a></code>.
</p>
</li></ul>

<p>For a good introduction, please refer to references.
</p>


<h3>Value</h3>

<p><code>RTDE</code> returns an object of class <code>"RTDE"</code>
having the following components:
</p>

<dl>
<dt><code>obs.type</code></dt><dd><p>see <code><a href="#topic+dataRTDE">dataRTDE</a></code>.</p>
</dd>
<dt><code>data</code></dt><dd><p>see <code><a href="#topic+dataRTDE">dataRTDE</a></code>.</p>
</dd>
<dt><code>fit</code></dt><dd><p>see <code><a href="#topic+fitRTDE">fitRTDE</a></code>.</p>
</dd>
<dt><code>simu</code></dt><dd><p>see <code><a href="#topic+dataRTDE">dataRTDE</a></code>.</p>
</dd>
<dt><code>contamin</code></dt><dd><p>see <code><a href="#topic+dataRTDE">dataRTDE</a></code>.</p>
</dd>
<dt><code>setting</code></dt><dd><p>a list summarizing the computation.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>C. Dutang, Y. Goegebeur, A. Guillou (2014),
<em>Robust and bias-corrected estimation of the coefficient of tail dependence</em>,
Volume 57, Insurance: Mathematics and Economics
</p>
<p>This work was supported by a research grant (VKR023480) from VILLUM FONDEN and an international project for scientific cooperation (PICS-6416).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+fitRTDE">fitRTDE</a></code> for the fitting process and
<code><a href="#topic+dataRTDE">dataRTDE</a></code> for the data-handling process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) simulation

n &lt;- 100
x &lt;- RTDE(simu=list(nb=n, marg="ufrechet", cop="indep", replicate=1),
	nbpoint=10:11, alpha=0, omega=1/2)
x	
summary(x)


</code></pre>

<hr>
<h2 id='upareto'>The unit Pareto Distribution</h2><span id='topic+upareto'></span><span id='topic+dupareto'></span><span id='topic+pupareto'></span><span id='topic+qupareto'></span><span id='topic+rupareto'></span>

<h3>Description</h3>

<p>Density function, distribution function, quantile function, random generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dupareto(x, log = FALSE)
pupareto(q, lower.tail=TRUE, log.p = FALSE)
qupareto(p, lower.tail=TRUE, log.p = FALSE)
rupareto(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upareto_+3A_x">x</code>, <code id="upareto_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="upareto_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="upareto_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="upareto_+3A_log">log</code>, <code id="upareto_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="upareto_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The extended Pareto distribution is defined by the following density
and distribution function
</p>
<p style="text-align: center;"><code class="reqn">
        f(x) = \frac{1}{x^2}, F(x) = 1-\frac{1}{x},
    </code>
</p>

<p>for all <code class="reqn">x&gt;0</code>.
</p>


<h3>Value</h3>

<p><code>dupareto</code> gives the density,
<code>pupareto</code> gives the distribution function,
<code>qupareto</code> gives the quantile function, and
<code>rupareto</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rupareto</code>, and is the maximum of the lengths of the
numerical parameters for the other functions.  
</p>
<p>The numerical parameters other than <code>n</code> are recycled to the
length of the result.  Only the first elements of the logical
parameters are used.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>Johnson, N.L., Kotz, S. and Balakrishnan, N. (2000),
<em>Continuous Univariate Distributions, Volume 1, Second Edition</em>, 
John Wiley and Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) density function
x &lt;- seq(0, 5, length=24)

cbind(x, dupareto(x))

#####
# (2) distribution function

cbind(x, pupareto(x))




		
</code></pre>

<hr>
<h2 id='zvalueRTDE'>The Z-value random variable</h2><span id='topic+zvalueRTDE'></span><span id='topic+summary.zvalueRTDE'></span><span id='topic+print.zvalueRTDE'></span><span id='topic+relexcess'></span><span id='topic+relexcess.default'></span><span id='topic+relexcess.zvalueRTDE'></span>

<h3>Description</h3>

<p>Compute the Z-value variable from a bivariate dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zvalueRTDE(obs, omega, nbpoint, output=c("orig", "relexcess"), 
    marg=c("upareto", "ufrechet", "uunif"))

## S3 method for class 'zvalueRTDE'
print(x, ...)
## S3 method for class 'zvalueRTDE'
summary(object, ...)


relexcess(x, nbpoint, ...)
## Default S3 method:
relexcess(x, nbpoint, ...)
## S3 method for class 'zvalueRTDE'
relexcess(x, nbpoint, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zvalueRTDE_+3A_obs">obs</code></td>
<td>
<p>bivariate numeric dataset.</p>
</td></tr>
<tr><td><code id="zvalueRTDE_+3A_omega">omega</code></td>
<td>
<p>a numeric for omega, see Details.</p>
</td></tr>
<tr><td><code id="zvalueRTDE_+3A_nbpoint">nbpoint</code></td>
<td>
<p>a numeric for the number of largest points to be selected.</p>
</td></tr>
<tr><td><code id="zvalueRTDE_+3A_output">output</code></td>
<td>
<p>a character string for the output: 
either <code>"orig"</code> for original value 
or <code>"relexcess"</code> for relative excess.</p>
</td></tr>
<tr><td><code id="zvalueRTDE_+3A_marg">marg</code></td>
<td>
<p>a character string for the empirical margin transformation:
either <code>"upareto"</code> for unit Pareto, 
<code>"ufrechet"</code> for unit Frechet or 
<code>"uunif"</code> for unit uniform margin.</p>
</td></tr>
<tr><td><code id="zvalueRTDE_+3A_x">x</code>, <code id="zvalueRTDE_+3A_object">object</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from <code>"zvalueRTDE"</code>.</p>
</td></tr>
<tr><td><code id="zvalueRTDE_+3A_...">...</code></td>
<td>
<p>arguments to be passed to subsequent methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a bivariate dataset <code class="reqn">(X_i, Y_i)_i</code> of <code class="reqn">n</code> points,
two variables are defined:
(1) for <code>output="orig"</code>, the <code class="reqn">\tilde Z_{\omega,i}</code> variable
</p>
<p style="text-align: center;"><code class="reqn">\tilde Z_{\omega,i} = \min \left(
        f\left(\frac{R_i^X}{n+1}\right),
        \frac{\omega}{1-\omega} f\left(\frac{R_i^Y}{n+1}\right) \right)
    </code>
</p>

<p>where <code class="reqn">f(x)</code> is the margin transformation and <code class="reqn">i=1,...,n</code>;
(2) for <code>output="relexcess"</code>, the <code class="reqn">Z_{j}</code> variable
</p>
<p style="text-align: center;"><code class="reqn">
        \frac{\widetilde Z_{\omega,n-m+j,n}}{\widetilde Z_{\omega,n-m,n}}
    </code>
</p>

<p>where <code class="reqn">m</code> equals <code>nbpoint</code>, <code class="reqn">j=1,\dots, m</code>,
and <code class="reqn">\widetilde Z_{\omega,1,n},...,
     \widetilde Z_{\omega,n,n}</code> are the order statistics of 
<code class="reqn">\widetilde Z_{\omega,1},...,\widetilde Z_{\omega,n}</code>.
The margin transformation is 
</p>
<p style="text-align: center;"><code class="reqn">
    f(x) = \frac{1}{1-x}, f(x) = \frac{1}{-\log(x)}, f(x) = x,
    </code>
</p>

<p>respectively for unit Pareto (<code>marg="upareto"</code>),
unit Frechet (<code>marg="ufrechet"</code>) and unit uniform margin
(<code>marg="uunif"</code>).
</p>


<h3>Value</h3>

<p><code>zvalueRTDE</code> computes the Z-variable and
returns an object of class <code>"zvalueRTDE"</code>
having the following components <code>type</code> (either
<code>"orig"</code> or <code>"relexcess"</code>), <code>omega</code>,
<code>Ztilde</code> or <code>Z</code>, <code>n</code>, possibly <code>m</code>.
</p>
<p><code>relexcess</code> computes the relative excesses
from a Z-variable and returns an object of class <code>"zvalueRTDE"</code>
of type <code>"relexcess"</code>.
</p>


<h3>Author(s)</h3>

<p>Christophe Dutang
</p>


<h3>References</h3>

<p>C. Dutang, Y. Goegebeur, A. Guillou (2014),
<em>Robust and bias-corrected estimation of the coefficient of tail dependence</em>,
Volume 57, Insurance: Mathematics and Economics
</p>
<p>This work was supported by a research grant (VKR023480) from VILLUM FONDEN and an international project for scientific cooperation (PICS-6416).
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+fitRTDE">fitRTDE</a></code> for the fitting process and
<code><a href="#topic+dataRTDE">dataRTDE</a></code> for the data-handling process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####
# (1) example

omega &lt;- 1/2
m &lt;- 10
n &lt;- 100
obs &lt;- cbind(rupareto(n), rupareto(n)) + rupareto(n)

#unit Pareto transform
zvalueRTDE(obs, omega, output="orig")

relexcess(zvalueRTDE(obs, omega, output="orig"), m)
zvalueRTDE(obs, omega, nbpoint=m, output="relexcess")

		
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
