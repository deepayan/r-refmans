<!DOCTYPE html><html><head><title>Help for package LocKer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LocKer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LocKer'><p>Locally sparse estimator of generalized varying coefficient model for asynchronous longitudinal data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Locally Sparse Estimator of Generalized Varying Coefficient
Model for Asynchronous Longitudinal Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Locally sparse estimator of generalized varying coefficient model for asynchronous longitudinal data by kernel-weighted estimating equation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>fda, Matrix, psych, splines, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-26 02:43:17 UTC; 11013</td>
</tr>
<tr>
<td>Author:</td>
<td>Rou Zhong [aut, cre],
  Jingxiao Zhang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rou Zhong &lt;zhong_rou@163.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-27 23:10:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='LocKer'>Locally sparse estimator of generalized varying coefficient model for asynchronous longitudinal data.</h2><span id='topic+LocKer'></span>

<h3>Description</h3>

<p>Locally sparse estimator of generalized varying coefficient model for asynchronous longitudinal data by kernel-weighted estimating equation. The function is suitable for generalized varying coefficient model with one covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LocKer(
  X,
  Y,
  family,
  X_obser_num,
  Y_obser_num,
  X_obser,
  Y_obser,
  timeint,
  L_list,
  roupen_para_list,
  lambda_list,
  absTol_list,
  nfold = 5,
  d = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LocKer_+3A_x">X</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of the covariate for each subject at the observation time correspond to <code>X_obser</code>.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_y">Y</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the measurements of the response for each subject at the observation time correspond to <code>Y_obser</code>.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_family">family</code></td>
<td>
<p>A <code>character</code> string representing the distribution family of the response. The value can be &quot;Gaussian&quot;, &quot;binomial&quot;, &quot;poisson&quot;.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_x_obser_num">X_obser_num</code></td>
<td>
<p>A <code>vector</code> denoting the observation size of the covariate for each subject.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_y_obser_num">Y_obser_num</code></td>
<td>
<p>A <code>vector</code> denoting the observation size of the response for each subject.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_x_obser">X_obser</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation times of the covariate for each subject.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_y_obser">Y_obser</code></td>
<td>
<p>A <code>list</code> of <em>n</em> vectors, where <em>n</em> is the sample size. Each entry contains the observation times of the response for each subject.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_timeint">timeint</code></td>
<td>
<p>A <code>vector</code> of length two denoting the supporting interval.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_l_list">L_list</code></td>
<td>
<p>A <code>vector</code> denoting the candidates for the number of B-spline basis functions. The best <code>L</code> is chosen by cross-validation.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_roupen_para_list">roupen_para_list</code></td>
<td>
<p>A <code>vector</code> denoting the candidates for the roughness parameters. The best roughness parameter is chosen by <code>EBIC</code> together with sparseness parameter.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_lambda_list">lambda_list</code></td>
<td>
<p>A <code>vector</code> denoting the candidates for the sparseness parameter. The best sparseness parameter is chosen by <code>EBIC</code> together with roughness parameter.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_abstol_list">absTol_list</code></td>
<td>
<p>A <code>vector</code> denoting the threshold of the norm for coefficient function on each sub-interval. The <code>vector</code> is related to <code>L_list</code>, with the same length as <code>L_list</code>.</p>
</td></tr>
<tr><td><code id="LocKer_+3A_nfold">nfold</code></td>
<td>
<p>An <code>integer</code> denoting the number of fold for the selection of <code>L</code> by cross-validation. (default: 5)</p>
</td></tr>
<tr><td><code id="LocKer_+3A_d">d</code></td>
<td>
<p>An <code>integer</code> denoting the degree of B-spline basis functions. (default: 3)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the following components:
</p>
<table>
<tr><td><code>beta0fd_est</code></td>
<td>
<p>A functional data object denoting the estimated intercept function.</p>
</td></tr>
<tr><td><code>betafd_est</code></td>
<td>
<p>A functional data object denoting the estimated coefficient function.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>A <code>scalar</code> denoting the computation time.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>An <code>integer</code> denoting the selected number of B-spline basis function.</p>
</td></tr>
<tr><td><code>roupen_select</code></td>
<td>
<p>A <code>scalar</code> denoting the selected roughness parameter.</p>
</td></tr>
<tr><td><code>lambda_select</code></td>
<td>
<p>A <code>scalar</code> denoting the selected sparseness parameter.</p>
</td></tr>
<tr><td><code>EBIC</code></td>
<td>
<p>A <code>matrix</code> denoting the <code>EBIC</code> scores for various roughness parameters and sparseness parameters belongs to the candidates when using the selected <code>L</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>####Generate data
n &lt;- 200
beta0 &lt;- function(x){cos(2 * pi * x)}
beta &lt;- function(x){sin(2 * pi * x)}
Y_rate &lt;- 15
X_rate &lt;- 15
Y_obser_num &lt;- NULL
X_obser_num &lt;- NULL
Y_obser &lt;- list()
X_obser &lt;- list()
for(i in 1:n){
Y_obser_num[i] &lt;- stats::rpois(1, Y_rate) + 1
Y_obser[[i]] &lt;- stats::runif(Y_obser_num[i], 0, 1)
X_obser_num[i] &lt;- stats::rpois(1, X_rate) + 1
X_obser[[i]] &lt;- stats::runif(X_obser_num[i], 0, 1)
}
## The covariate functions Xi(t)
X_basis &lt;- fda::create.bspline.basis(c(0, 1), nbasis = 74, norder = 5,
breaks = seq(0, 1, length.out = 71))
a &lt;- matrix(0, nrow = n, ncol = 74)
X &lt;- list()
XY &lt;- list() #X at the observation time of Y
muY &lt;- list()
for(i in 1:n){
a[i,] &lt;- stats::rnorm(74)
Xi_B &lt;- splines::bs(X_obser[[i]], knots = seq(0, 1, length.out = 71)[-c(1, 71)],
degree = 4, intercept = TRUE)
X[[i]] &lt;- Xi_B %*% a[i,]
Yi_B &lt;- splines::bs(Y_obser[[i]], knots = seq(0, 1, length.out = 71)[-c(1, 71)],
degree = 4, intercept = TRUE)
XY[[i]] &lt;- Yi_B %*% a[i,]
muY[[i]] &lt;- beta0(Y_obser[[i]]) + XY[[i]] * beta(Y_obser[[i]])
}
Y &lt;- list()
errY &lt;- list()
for(i in 1:n){
errY[[i]] &lt;- stats::rnorm(Y_obser_num[[i]], mean = 0, sd = 1)
Y[[i]] &lt;- muY[[i]] + errY[[i]]
}
L_list &lt;- 20
absTol_list &lt;- 10^(-3)
roupen_para_list &lt;- 1.5 * 10^(-3)
lambda_list &lt;- c(0, 0.001, 0.002)
LocKer_list &lt;- LocKer(X, Y, family = "Gaussian", X_obser_num, Y_obser_num, X_obser,
Y_obser, timeint = c(0, 1), L_list, roupen_para_list, lambda_list, absTol_list)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
