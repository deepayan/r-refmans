<!DOCTYPE html><html lang="en"><head><title>Help for package tidyhte</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyhte}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidyhte-package'><p>tidyhte: Tidy Estimation of Heterogeneous Treatment Effects</p></a></li>
<li><a href='#add_effect_diagnostic'><p>Add an additional diagnostic to the effect model</p></a></li>
<li><a href='#add_effect_model'><p>Add an additional model to the joint effect ensemble</p></a></li>
<li><a href='#add_known_propensity_score'><p>Uses a known propensity score</p></a></li>
<li><a href='#add_moderator'><p>Adds moderators to the configuration</p></a></li>
<li><a href='#add_outcome_diagnostic'><p>Add an additional diagnostic to the outcome model</p></a></li>
<li><a href='#add_outcome_model'><p>Add an additional model to the outcome ensemble</p></a></li>
<li><a href='#add_propensity_diagnostic'><p>Add an additional diagnostic to the propensity score</p></a></li>
<li><a href='#add_propensity_score_model'><p>Add an additional model to the propensity score ensemble</p></a></li>
<li><a href='#add_vimp'><p>Adds variable importance information</p></a></li>
<li><a href='#attach_config'><p>Attach an <code>HTE_cfg</code> to a dataframe</p></a></li>
<li><a href='#basic_config'><p>Create a basic config for HTE estimation</p></a></li>
<li><a href='#calculate_ate'><p>Calculates a SATE and a PATE using AIPW</p></a></li>
<li><a href='#calculate_diagnostics'><p>Calculate diagnostics</p></a></li>
<li><a href='#calculate_linear_vimp'><p>Calculate Linear Variable Importance of HTEs</p></a></li>
<li><a href='#calculate_pcate_quantities'><p>Calculate &quot;partial&quot; CATE estimates</p></a></li>
<li><a href='#calculate_rroc'><p>Regression ROC Curve calculation</p></a></li>
<li><a href='#calculate_vimp'><p>Calculate Variable Importance of HTEs</p></a></li>
<li><a href='#check_data_has_hte_cfg'><p>Checks that a dataframe has an attached configuration for HTEs</p></a></li>
<li><a href='#check_identifier'><p>Checks that an appropriate identifier has been provided</p></a></li>
<li><a href='#check_nuisance_models'><p>Checks that nuisance models have been estimated and exist in the supplied dataset.</p></a></li>
<li><a href='#check_splits'><p>Checks that splits have been properly created.</p></a></li>
<li><a href='#check_weights'><p>Checks that an appropriate weighting variable has been provided</p></a></li>
<li><a href='#Constant_cfg'><p>Configuration of a Constant Estimator</p></a></li>
<li><a href='#construct_pseudo_outcomes'><p>Construct Pseudo-outcomes</p></a></li>
<li><a href='#Diagnostics_cfg'><p>Configuration of Model Diagnostics</p></a></li>
<li><a href='#estimate_diagnostic'><p>Function to calculate diagnostics based on model outputs</p></a></li>
<li><a href='#estimate_QoI'><p>Estimate Quantities of Interest</p></a></li>
<li><a href='#fit_effect'><p>Fits a treatment effect model using the appropriate settings</p></a></li>
<li><a href='#fit_fx_predictor'><p>Fit a predictor for treatment effects</p></a></li>
<li><a href='#fit_plugin'><p>Fits a plugin model using the appropriate settings</p></a></li>
<li><a href='#fit_plugin_A'><p>Fits a propensity score model using the appropriate settings</p></a></li>
<li><a href='#fit_plugin_Y'><p>Fits a T-learner using the appropriate settings</p></a></li>
<li><a href='#FX.Predictor'><p>Predictor class for the cross-fit predictor of &quot;partial&quot; CATEs</p></a></li>
<li><a href='#HTE_cfg'><p>Configuration of Quantities of Interest</p></a></li>
<li><a href='#HTEFold'><p>R6 class to represent partitions of the data between training and held-out</p></a></li>
<li><a href='#KernelSmooth_cfg'><p>Configuration for a Kernel Smoother</p></a></li>
<li><a href='#Known_cfg'><p>Configuration of Known Model</p></a></li>
<li><a href='#listwise_deletion'><p>Removes rows which have missing data on any of the supplied columns.</p></a></li>
<li><a href='#make_splits'><p>Define splits for cross-fitting</p></a></li>
<li><a href='#MCATE_cfg'><p>Configuration of Marginal CATEs</p></a></li>
<li><a href='#Model_cfg'><p>Base Class of Model Configurations</p></a></li>
<li><a href='#Model_data'><p>R6 class to represent data to be used in estimating a model</p></a></li>
<li><a href='#PCATE_cfg'><p>Configuration of Partial CATEs</p></a></li>
<li><a href='#predict.SL.glmnet.interaction'><p>Prediction for an SL.glmnet object</p></a></li>
<li><a href='#produce_plugin_estimates'><p>Estimate models of nuisance functions</p></a></li>
<li><a href='#QoI_cfg'><p>Configuration of Quantities of Interest</p></a></li>
<li><a href='#remove_vimp'><p>Removes variable importance information</p></a></li>
<li><a href='#SL.glmnet.interaction'><p>Elastic net regression with pairwise interactions</p></a></li>
<li><a href='#SLEnsemble_cfg'><p>Configuration for a SuperLearner Ensemble</p></a></li>
<li><a href='#SLLearner_cfg'><p>Configuration of SuperLearner Submodel</p></a></li>
<li><a href='#split_data'><p>Partition the data into folds</p></a></li>
<li><a href='#Stratified_cfg'><p>Configuration for a Stratification Estimator</p></a></li>
<li><a href='#VIMP_cfg'><p>Configuration of Variable Importance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tidy Estimation of Heterogeneous Treatment Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates heterogeneous treatment effects using tidy semantics 
    on experimental or observational data.  Methods are based on the doubly-robust
    learner of Kennedy (n.d.) &lt;<a href="https://doi.org/10.48550/arXiv.2004.14497">doi:10.48550/arXiv.2004.14497</a>&gt;. You provide a simple
    recipe for what machine learning algorithms to use in estimating the nuisance
    functions and 'tidyhte' will take care of cross-validation, estimation, model
    selection, diagnostics and construction of relevant quantities of interest about
    the variability of treatment effects.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ddimmery/tidyhte">https://github.com/ddimmery/tidyhte</a>
<a href="https://ddimmery.github.io/tidyhte/index.html">https://ddimmery.github.io/tidyhte/index.html</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ddimmery/tidyhte/issues">https://github.com/ddimmery/tidyhte/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, devtools, estimatr, ggplot2, glmnet, knitr, mockr,
nprobust, palmerpenguins, quadprog, quickblock, rmarkdown,
testthat (&ge; 3.0.0), vimp, WeightedROC</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, dplyr, lifecycle, magrittr, progress, purrr, R6,
rlang, SuperLearner, tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-11 15:35:39 UTC; drewd</td>
</tr>
<tr>
<td>Author:</td>
<td>Drew Dimmery <a href="https://orcid.org/0000-0001-9602-6325"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Drew Dimmery &lt;drew.dimmery@univie.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-14 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidyhte-package'>tidyhte: Tidy Estimation of Heterogeneous Treatment Effects</h2><span id='topic+tidyhte'></span><span id='topic+tidyhte-package'></span>

<h3>Description</h3>

<p>Estimates heterogeneous treatment effects using tidy semantics on experimental or observational data. Methods are based on the doubly-robust learner of Kennedy (n.d.) <a href="https://arxiv.org/abs/2004.14497">arXiv:2004.14497</a>. You provide a simple recipe for what machine learning algorithms to use in estimating the nuisance functions and 'tidyhte' will take care of cross-validation, estimation, model selection, diagnostics and construction of relevant quantities of interest about the variability of treatment effects.
</p>


<h3>Details</h3>

<p>The best place to get started with <code>tidyhte</code> is <code>vignette("experimental_analysis")</code> which
walks through a full analysis of HTE on simulated data, or <code>vignette("methodological_details")</code>
which gets into more of the details underlying the method.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Drew Dimmery <a href="mailto:drew.dimmery@univie.ac.at">drew.dimmery@univie.ac.at</a> (<a href="https://orcid.org/0000-0001-9602-6325">ORCID</a>) [copyright holder]
</p>


<h3>References</h3>

<p>Kennedy, E. H. (2020). Towards optimal doubly robust estimation of heterogeneous
causal effects. <em>arXiv preprint arXiv:2004.14497</em>.
</p>


<h3>See Also</h3>

<p>The core public-facing functions are <code>make_splits</code>, <code>produce_plugin_estimates</code>,
<code>construct_pseudo_outcomes</code> and <code>estimate_QoI</code>. Configuration is accomplished through <code>HTE_cfg</code>
in addition to a variety of related classes (see <code>basic_config</code>).
</p>

<hr>
<h2 id='add_effect_diagnostic'>Add an additional diagnostic to the effect model</h2><span id='topic+add_effect_diagnostic'></span>

<h3>Description</h3>

<p>This adds a diagnostic to the effect model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_effect_diagnostic(hte_cfg, diag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_effect_diagnostic_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_effect_diagnostic_+3A_diag">diag</code></td>
<td>
<p>Character indicating the name of the diagnostic
to include. Possible values are <code>"MSE"</code>, <code>"RROC"</code> and, for
<code>SuperLearner</code> ensembles, <code>"SL_risk"</code> and <code>"SL_coefs"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_effect_diagnostic("RROC") -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_effect_model'>Add an additional model to the joint effect ensemble</h2><span id='topic+add_effect_model'></span>

<h3>Description</h3>

<p>This adds a learner to the ensemble used for estimating a model
of the conditional expectation of the pseudo-outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_effect_model(hte_cfg, model_name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_effect_model_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_effect_model_+3A_model_name">model_name</code></td>
<td>
<p>Character indicating the name of the model to
incorporate into the joint effect ensemble. Possible values
use <code>SuperLearner</code> naming conventions. A full list is available
with <code>SuperLearner::listWrappers("SL")</code></p>
</td></tr>
<tr><td><code id="add_effect_model_+3A_...">...</code></td>
<td>
<p>Parameters over which to grid-search for this model class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_effect_model("SL.glm.interaction") -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_known_propensity_score'>Uses a known propensity score</h2><span id='topic+add_known_propensity_score'></span>

<h3>Description</h3>

<p>This replaces the propensity score model with a known value
of the propensity score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_known_propensity_score(hte_cfg, covariate_name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_known_propensity_score_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_known_propensity_score_+3A_covariate_name">covariate_name</code></td>
<td>
<p>Character indicating the name of the covariate
name in the dataframe corresponding to the known propensity score.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_known_propensity_score("ps") -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_moderator'>Adds moderators to the configuration</h2><span id='topic+add_moderator'></span>

<h3>Description</h3>

<p>This adds a definition about how to display a moderators to
the MCATE config. A moderator is any variable that you want to view information
about CATEs with respect to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_moderator(hte_cfg, model_type, ..., .model_arguments = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_moderator_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_moderator_+3A_model_type">model_type</code></td>
<td>
<p>Character indicating the model type for these moderators.
Currently two model types are supported: <code>"Stratified"</code> for discrete moderators
and <code>"KernelSmooth"</code> for continuous ones.</p>
</td></tr>
<tr><td><code id="add_moderator_+3A_...">...</code></td>
<td>
<p>The (unquoted) names of the moderator variables.</p>
</td></tr>
<tr><td><code id="add_moderator_+3A_.model_arguments">.model_arguments</code></td>
<td>
<p>A named list from argument name to value to pass into the
constructor for the model. See <code>Stratified_cfg</code> and <code>KernelSmooth_cfg</code> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_moderator("Stratified", x2, x3) %&gt;%
   add_moderator("KernelSmooth", x1, x4, x5) -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_outcome_diagnostic'>Add an additional diagnostic to the outcome model</h2><span id='topic+add_outcome_diagnostic'></span>

<h3>Description</h3>

<p>This adds a diagnostic to the outcome model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_outcome_diagnostic(hte_cfg, diag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_outcome_diagnostic_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_outcome_diagnostic_+3A_diag">diag</code></td>
<td>
<p>Character indicating the name of the diagnostic
to include. Possible values are <code>"MSE"</code>, <code>"RROC"</code> and, for
<code>SuperLearner</code> ensembles, <code>"SL_risk"</code> and <code>"SL_coefs"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_outcome_diagnostic("RROC") -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_outcome_model'>Add an additional model to the outcome ensemble</h2><span id='topic+add_outcome_model'></span>

<h3>Description</h3>

<p>This adds a learner to the ensemble used for estimating a model
of the conditional expectation of the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_outcome_model(hte_cfg, model_name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_outcome_model_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_outcome_model_+3A_model_name">model_name</code></td>
<td>
<p>Character indicating the name of the model to
incorporate into the outcome ensemble. Possible values
use <code>SuperLearner</code> naming conventions. A full list is available
with <code>SuperLearner::listWrappers("SL")</code></p>
</td></tr>
<tr><td><code id="add_outcome_model_+3A_...">...</code></td>
<td>
<p>Parameters over which to grid-search for this model class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_outcome_model("SL.glm.interaction") -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_propensity_diagnostic'>Add an additional diagnostic to the propensity score</h2><span id='topic+add_propensity_diagnostic'></span>

<h3>Description</h3>

<p>This adds a diagnostic to the propensity score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_propensity_diagnostic(hte_cfg, diag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_propensity_diagnostic_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_propensity_diagnostic_+3A_diag">diag</code></td>
<td>
<p>Character indicating the name of the diagnostic
to include. Possible values are <code>"MSE"</code>, <code>"AUC"</code> and, for
<code>SuperLearner</code> ensembles, <code>"SL_risk"</code> and <code>"SL_coefs"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_propensity_diagnostic(c("AUC", "MSE")) -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_propensity_score_model'>Add an additional model to the propensity score ensemble</h2><span id='topic+add_propensity_score_model'></span>

<h3>Description</h3>

<p>This adds a learner to the ensemble used for estimating propensity
scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_propensity_score_model(hte_cfg, model_name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_propensity_score_model_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_propensity_score_model_+3A_model_name">model_name</code></td>
<td>
<p>Character indicating the name of the model to
incorporate into the propensity score ensemble. Possible values
use <code>SuperLearner</code> naming conventions. A full list is available
with <code>SuperLearner::listWrappers("SL")</code></p>
</td></tr>
<tr><td><code id="add_propensity_score_model_+3A_...">...</code></td>
<td>
<p>Parameters over which to grid-search for this model class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_propensity_score_model("SL.glmnet", alpha = c(0, 0.5, 1)) -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='add_vimp'>Adds variable importance information</h2><span id='topic+add_vimp'></span>

<h3>Description</h3>

<p>This adds a variable importance quantity of interest to the outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_vimp(hte_cfg, sample_splitting = TRUE, linear_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_vimp_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
<tr><td><code id="add_vimp_+3A_sample_splitting">sample_splitting</code></td>
<td>
<p>Logical indicating whether to use sample splitting or not.
Choosing not to use sample splitting means that inference will only be valid for
moderators with non-null importance.</p>
</td></tr>
<tr><td><code id="add_vimp_+3A_linear_only">linear_only</code></td>
<td>
<p>Logical indicating whether the variable importance should use only a single
linear-only model. Variable importance measure will only be consistent for the population
quantity if the true model of pseudo-outcomes is linear.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>References</h3>


<ul>
<li><p> Williamson, B. D., Gilbert, P. B., Carone, M., &amp; Simon, N. (2021).
Nonparametric variable importance assessment using machine learning techniques.
Biometrics, 77(1), 9-22.
</p>
</li>
<li><p> Williamson, B. D., Gilbert, P. B., Simon, N. R., &amp; Carone, M. (2021).
A general framework for inference on algorithm-agnostic variable importance.
Journal of the American Statistical Association, 1-14.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_vimp(sample_splitting = FALSE) -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='attach_config'>Attach an <code>HTE_cfg</code> to a dataframe</h2><span id='topic+attach_config'></span>

<h3>Description</h3>

<p>This adds a configuration attribute to a dataframe for HTE estimation.
This configuration details the full analysis of HTE that should be performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attach_config(data, .HTE_cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="attach_config_+3A_data">data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="attach_config_+3A_.hte_cfg">.HTE_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object representing the full configuration of the HTE analysis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For information about how to set up an <code>HTE_cfg</code> object, see the Recipe API
documentation <code><a href="#topic+basic_config">basic_config()</a></code>.
</p>
<p>To see an example analysis, read <code>vignette("experimental_analysis")</code> in the context
of an experiment, <code>vignette("experimental_analysis")</code> for an observational study, or
<code>vignette("methodological_details")</code> for a deeper dive under the hood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basic_config">basic_config()</a></code>, <code><a href="#topic+make_splits">make_splits()</a></code>, <code><a href="#topic+produce_plugin_estimates">produce_plugin_estimates()</a></code>,
<code><a href="#topic+construct_pseudo_outcomes">construct_pseudo_outcomes()</a></code>, <code><a href="#topic+estimate_QoI">estimate_QoI()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
if(require("palmerpenguins")) {
data(package = 'palmerpenguins')
penguins$unitid = seq_len(nrow(penguins))
penguins$propensity = rep(0.5, nrow(penguins))
penguins$treatment = rbinom(nrow(penguins), 1, penguins$propensity)
cfg &lt;- basic_config() %&gt;% 
add_known_propensity_score("propensity") %&gt;%
add_outcome_model("SL.glm.interaction") %&gt;%
remove_vimp()
attach_config(penguins, cfg) %&gt;%
make_splits(unitid, .num_splits = 4) %&gt;%
produce_plugin_estimates(outcome = body_mass_g, treatment = treatment, species, sex) %&gt;%
construct_pseudo_outcomes(body_mass_g, treatment) %&gt;%
estimate_QoI(species, sex)
}
</code></pre>

<hr>
<h2 id='basic_config'>Create a basic config for HTE estimation</h2><span id='topic+basic_config'></span>

<h3>Description</h3>

<p>This provides a basic recipe for HTE estimation that can
be extended by providing additional information about models
to be estimated and what quantities of interest should be
returned based on those models. This basic model includes
only linear models for nuisance function estimation, and
basic diagnostics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basic_config()
</code></pre>


<h3>Details</h3>

<p>Additional models, diagnostics and quantities of interest should
be added using their respective helper functions provided as part
of the Recipe API.
</p>
<p>To see an example analysis, read <code>vignette("experimental_analysis")</code> in the context
of an experiment, <code>vignette("experimental_analysis")</code> for an observational study, or
<code>vignette("methodological_details")</code> for a deeper dive under the hood.
</p>


<h3>Value</h3>

<p><code>HTE_cfg</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+add_propensity_score_model">add_propensity_score_model()</a></code>, <code><a href="#topic+add_known_propensity_score">add_known_propensity_score()</a></code>,
<code><a href="#topic+add_propensity_diagnostic">add_propensity_diagnostic()</a></code>, <code><a href="#topic+add_outcome_model">add_outcome_model()</a></code>, <code><a href="#topic+add_outcome_diagnostic">add_outcome_diagnostic()</a></code>,
<code><a href="#topic+add_effect_model">add_effect_model()</a></code>, <code><a href="#topic+add_effect_diagnostic">add_effect_diagnostic()</a></code>, <code><a href="#topic+add_moderator">add_moderator()</a></code>, <code><a href="#topic+add_vimp">add_vimp()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   add_known_propensity_score("ps") %&gt;%
   add_outcome_model("SL.glm.interaction") %&gt;%
   add_outcome_model("SL.glmnet", alpha = c(0.05, 0.15, 0.2, 0.25, 0.5, 0.75)) %&gt;%
   add_outcome_model("SL.glmnet.interaction", alpha = c(0.05, 0.15, 0.2, 0.25, 0.5, 0.75)) %&gt;%
   add_outcome_diagnostic("RROC") %&gt;%
   add_effect_model("SL.glm.interaction") %&gt;%
   add_effect_model("SL.glmnet", alpha = c(0.05, 0.15, 0.2, 0.25, 0.5, 0.75)) %&gt;%
   add_effect_model("SL.glmnet.interaction", alpha = c(0.05, 0.15, 0.2, 0.25, 0.5, 0.75)) %&gt;%
   add_effect_diagnostic("RROC") %&gt;%
   add_moderator("Stratified", x2, x3) %&gt;%
   add_moderator("KernelSmooth", x1, x4, x5) %&gt;%
   add_vimp(sample_splitting = FALSE) -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='calculate_ate'>Calculates a SATE and a PATE using AIPW</h2><span id='topic+calculate_ate'></span>

<h3>Description</h3>

<p>This function takes fully prepared data (with all auxilliary columns from the
necessary models) and estimates average treatment effects using AIPW.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_ate(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_ate_+3A_data">data</code></td>
<td>
<p>The dataset of interest after it has been prepared fully.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Kennedy, E. H. (2020). Towards optimal doubly robust estimation of heterogeneous
causal effects. <em>arXiv preprint arXiv:2004.14497</em>.
</p>
</li>
<li><p> Tsiatis, A. A., Davidian, M., Zhang, M., &amp; Lu, X. (2008). Covariate adjustment
for two‐sample treatment comparisons in randomized clinical trials: a principled
yet flexible approach. <em>Statistics in medicine</em>, 27(23), 4658-4677.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+basic_config">basic_config()</a></code>, <code><a href="#topic+attach_config">attach_config()</a></code>, <code><a href="#topic+make_splits">make_splits()</a></code>, <code><a href="#topic+produce_plugin_estimates">produce_plugin_estimates()</a></code>,
<code><a href="#topic+construct_pseudo_outcomes">construct_pseudo_outcomes()</a></code>, <code><a href="#topic+estimate_QoI">estimate_QoI()</a></code>
</p>

<hr>
<h2 id='calculate_diagnostics'>Calculate diagnostics</h2><span id='topic+calculate_diagnostics'></span>

<h3>Description</h3>

<p>This function calculates the diagnostics requested by the <code>Diagnostics_cfg</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_diagnostics(data, treatment, outcome, .diag.cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_diagnostics_+3A_data">data</code></td>
<td>
<p>Data frame with all additional columns (such as model predictions) included.</p>
</td></tr>
<tr><td><code id="calculate_diagnostics_+3A_treatment">treatment</code></td>
<td>
<p>Unquoted treatment variable name</p>
</td></tr>
<tr><td><code id="calculate_diagnostics_+3A_outcome">outcome</code></td>
<td>
<p>Unquoted outcome variable name</p>
</td></tr>
<tr><td><code id="calculate_diagnostics_+3A_.diag.cfg">.diag.cfg</code></td>
<td>
<p><code>Diagnostics_cfg</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with columns:
</p>

<ul>
<li> <p><code>estimand</code> - Character indicating the diagnostic that was calculated
</p>
</li>
<li> <p><code>level</code> - Indicates the scope of this diagnostic (e.g. does it apply
only to the model of the outcome under treatment).
</p>
</li>
<li> <p><code>term</code> - Indicates a more granular descriptor of what the value is for,
such as the specific model within the SuperLearner ensemble.
</p>
</li>
<li> <p><code>estimate</code> - Point estimate of the diagnostic.
</p>
</li>
<li> <p><code>std_error</code> - Standard error of the diagnostic.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+Diagnostics_cfg">Diagnostics_cfg</a>
</p>

<hr>
<h2 id='calculate_linear_vimp'>Calculate Linear Variable Importance of HTEs</h2><span id='topic+calculate_linear_vimp'></span>

<h3>Description</h3>

<p><code>calculate_linear_vimp</code> estimates the linear hypothesis test of removing a particular moderator
from a linear model containing all moderators. Unlike <code>calculate_vimp</code>, this will only be
unbiased and have correct asymptotic coverage rates if the true model is linear. This linear
approach is also substantially faster, so may be useful when prototyping an analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_linear_vimp(
  full_data,
  weight_col,
  pseudo_outcome,
  ...,
  .VIMP_cfg,
  .Model_cfg
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_linear_vimp_+3A_full_data">full_data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="calculate_linear_vimp_+3A_weight_col">weight_col</code></td>
<td>
<p>Unquoted name of the weight column.</p>
</td></tr>
<tr><td><code id="calculate_linear_vimp_+3A_pseudo_outcome">pseudo_outcome</code></td>
<td>
<p>Unquoted name of the pseudo-outcome.</p>
</td></tr>
<tr><td><code id="calculate_linear_vimp_+3A_...">...</code></td>
<td>
<p>Unquoted names of covariates to include in the joint effect model.
The variable importance will be calculated for each of these covariates.</p>
</td></tr>
<tr><td><code id="calculate_linear_vimp_+3A_.vimp_cfg">.VIMP_cfg</code></td>
<td>
<p>A <code>VIMP_cfg</code> object defining how VIMP should be estimated.</p>
</td></tr>
<tr><td><code id="calculate_linear_vimp_+3A_.model_cfg">.Model_cfg</code></td>
<td>
<p>A <code>Model_cfg</code> object defining how the joint effect model should be estimated.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Williamson, B. D., Gilbert, P. B., Carone, M., &amp; Simon, N. (2021).
Nonparametric variable importance assessment using machine learning techniques.
Biometrics, 77(1), 9-22.
</p>
</li>
<li><p> Williamson, B. D., Gilbert, P. B., Simon, N. R., &amp; Carone, M. (2021).
A general framework for inference on algorithm-agnostic variable importance.
Journal of the American Statistical Association, 1-14.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+calculate_vimp">calculate_vimp()</a></code>
</p>

<hr>
<h2 id='calculate_pcate_quantities'>Calculate &quot;partial&quot; CATE estimates</h2><span id='topic+calculate_pcate_quantities'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_pcate_quantities(
  full_data,
  .weights,
  .outcome,
  fx_model,
  ...,
  .MCATE_cfg
)
</code></pre>

<hr>
<h2 id='calculate_rroc'>Regression ROC Curve calculation</h2><span id='topic+calculate_rroc'></span>

<h3>Description</h3>

<p>This function calculates the RegressionROC Curve of
of Hernández-Orallo
<a href="https://doi.org/10.1016/j.patcog.2013.06.014">doi:10.1016/j.patcog.2013.06.014</a>.
It provides estimates for the positive and negative
errors when predictions are shifted by a variety
of constants (which range across the domain of observed
residuals). Curves closer to the axes are, in general, to be
preferred. In general, this curve provides a simple way to
visualize the error properties of a regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_rroc(label, prediction, nbins = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_rroc_+3A_label">label</code></td>
<td>
<p>True label</p>
</td></tr>
<tr><td><code id="calculate_rroc_+3A_prediction">prediction</code></td>
<td>
<p>Model prediction of the label (out of sample)</p>
</td></tr>
<tr><td><code id="calculate_rroc_+3A_nbins">nbins</code></td>
<td>
<p>Number of shift values to sweep over</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dot shows the errors when no shift is applied, corresponding
to the base model predictions.
</p>


<h3>Value</h3>

<p>A tibble with <code>nbins</code> rows.
</p>


<h3>References</h3>

<p>Hernández-Orallo, J. (2013). ROC curves for regression.
Pattern Recognition, 46(12), 3395-3411.
</p>

<hr>
<h2 id='calculate_vimp'>Calculate Variable Importance of HTEs</h2><span id='topic+calculate_vimp'></span>

<h3>Description</h3>

<p><code>calculate_vimp</code> estimates the reduction in (population) $R^2$ from
removing a particular moderator from a model containing all moderators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_vimp(
  full_data,
  weight_col,
  pseudo_outcome,
  ...,
  .VIMP_cfg,
  .Model_cfg
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate_vimp_+3A_full_data">full_data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="calculate_vimp_+3A_weight_col">weight_col</code></td>
<td>
<p>Unquoted name of the weight column.</p>
</td></tr>
<tr><td><code id="calculate_vimp_+3A_pseudo_outcome">pseudo_outcome</code></td>
<td>
<p>Unquoted name of the pseudo-outcome.</p>
</td></tr>
<tr><td><code id="calculate_vimp_+3A_...">...</code></td>
<td>
<p>Unquoted names of covariates to include in the joint effect model.
The variable importance will be calculated for each of these covariates.</p>
</td></tr>
<tr><td><code id="calculate_vimp_+3A_.vimp_cfg">.VIMP_cfg</code></td>
<td>
<p>A <code>VIMP_cfg</code> object defining how VIMP should be estimated.</p>
</td></tr>
<tr><td><code id="calculate_vimp_+3A_.model_cfg">.Model_cfg</code></td>
<td>
<p>A <code>Model_cfg</code> object defining how the joint effect model should be estimated.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Williamson, B. D., Gilbert, P. B., Carone, M., &amp; Simon, N. (2021).
Nonparametric variable importance assessment using machine learning techniques.
Biometrics, 77(1), 9-22.
</p>
</li>
<li><p> Williamson, B. D., Gilbert, P. B., Simon, N. R., &amp; Carone, M. (2021).
A general framework for inference on algorithm-agnostic variable importance.
Journal of the American Statistical Association, 1-14.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+calculate_linear_vimp">calculate_linear_vimp()</a></code>
</p>

<hr>
<h2 id='check_data_has_hte_cfg'>Checks that a dataframe has an attached configuration for HTEs</h2><span id='topic+check_data_has_hte_cfg'></span>

<h3>Description</h3>

<p>This helper function ensures that the provided dataframe has
the necessary auxilliary configuration information for HTE
estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_has_hte_cfg(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_data_has_hte_cfg_+3A_data">data</code></td>
<td>
<p>Dataframe of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Errors if a problem is discovered.
</p>

<hr>
<h2 id='check_identifier'>Checks that an appropriate identifier has been provided</h2><span id='topic+check_identifier'></span>

<h3>Description</h3>

<p>This helper function makes a few simple checks to identify obvious
issues with the way provided column of unit identifiers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_identifier(data, id_col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_identifier_+3A_data">data</code></td>
<td>
<p>Dataframe of interest.</p>
</td></tr>
<tr><td><code id="check_identifier_+3A_id_col">id_col</code></td>
<td>
<p>Quoted name of identifier column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Errors if a problem is discovered.
</p>

<hr>
<h2 id='check_nuisance_models'>Checks that nuisance models have been estimated and exist in the supplied dataset.</h2><span id='topic+check_nuisance_models'></span>

<h3>Description</h3>

<p>This helper function makes a few simple checks to identify obvious
issues with the way that nuisance functions are created and prepared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_nuisance_models(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_nuisance_models_+3A_data">data</code></td>
<td>
<p>Dataframe which should have appropriate columns of nuisance function
predictions: <code>.pi_hat</code>, <code>.mu0_hat</code>, and <code>.mu1_hat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Errors if a problem is discovered.
</p>

<hr>
<h2 id='check_splits'>Checks that splits have been properly created.</h2><span id='topic+check_splits'></span>

<h3>Description</h3>

<p>This helper function makes a few simple checks to identify obvious
issues with the way that splits have been made in the supplied data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_splits(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_splits_+3A_data">data</code></td>
<td>
<p>Dataframe which should have appropriate <code>.split_id</code> column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Errors if a problem is discovered.
</p>

<hr>
<h2 id='check_weights'>Checks that an appropriate weighting variable has been provided</h2><span id='topic+check_weights'></span>

<h3>Description</h3>

<p>This helper function makes a few simple checks to identify obvious
issues with the weights provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_weights(data, weight_col)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_weights_+3A_data">data</code></td>
<td>
<p>Dataframe of interest.</p>
</td></tr>
<tr><td><code id="check_weights_+3A_weight_col">weight_col</code></td>
<td>
<p>Quoted name of weights column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns NULL. Errors if a problem is discovered.
</p>

<hr>
<h2 id='Constant_cfg'>Configuration of a Constant Estimator</h2><span id='topic+Constant_cfg'></span>

<h3>Description</h3>

<p><code>Constant_cfg</code> is a configuration class for estimating a constant model.
That is, the model is a simple, one-parameter mean model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Model_cfg">tidyhte::Model_cfg</a></code> -&gt; <code>Constant_cfg</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>model_class</code></dt><dd><p>The class of the model, required for all classes
which inherit from <code>Model_cfg</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Constant_cfg-new"><code>Constant_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Constant_cfg-clone"><code>Constant_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Constant_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Constant_cfg</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Constant_cfg$new()</pre></div>



<h5>Returns</h5>

<p>A new <code>Constant_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Constant_cfg$new()
</pre>
</div>


<hr>
<a id="method-Constant_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Constant_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Constant_cfg$new`
## ------------------------------------------------

Constant_cfg$new()
</code></pre>

<hr>
<h2 id='construct_pseudo_outcomes'>Construct Pseudo-outcomes</h2><span id='topic+construct_pseudo_outcomes'></span>

<h3>Description</h3>

<p><code>construct_pseudo_outcomes</code> takes a dataset which has been prepared
with plugin estimators of nuisance parameters and transforms these into
a &quot;pseudo-outcome&quot;: an unbiased estimator of the conditional average
treatment effect under exogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_pseudo_outcomes(data, outcome, treatment, type = "dr")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="construct_pseudo_outcomes_+3A_data">data</code></td>
<td>
<p>dataframe (already prepared with <code>attach_config</code>, <code>make_splits</code>,
and <code>produce_plugin_estimates</code>)</p>
</td></tr>
<tr><td><code id="construct_pseudo_outcomes_+3A_outcome">outcome</code></td>
<td>
<p>Unquoted name of outcome variable.</p>
</td></tr>
<tr><td><code id="construct_pseudo_outcomes_+3A_treatment">treatment</code></td>
<td>
<p>Unquoted name of treatment variable.</p>
</td></tr>
<tr><td><code id="construct_pseudo_outcomes_+3A_type">type</code></td>
<td>
<p>String representing how to construct the pseudo-outcome. Valid
values are &quot;dr&quot; (the default), &quot;ipw&quot; and &quot;plugin&quot;. See &quot;Details&quot; for more
discussion of these options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Taking averages of these pseudo-outcomes (or fitting a model to them)
will approximate averages (or models) of the underlying treatment effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attach_config">attach_config()</a></code>, <code><a href="#topic+make_splits">make_splits()</a></code>, <code><a href="#topic+produce_plugin_estimates">produce_plugin_estimates()</a></code>, <code><a href="#topic+estimate_QoI">estimate_QoI()</a></code>
</p>

<hr>
<h2 id='Diagnostics_cfg'>Configuration of Model Diagnostics</h2><span id='topic+Diagnostics_cfg'></span>

<h3>Description</h3>

<p><code>Diagnostics_cfg</code> is a configuration class for estimating a variety of
diagnostics for the models trained in the course of HTE estimation.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>ps</code></dt><dd><p>Model diagnostics for the propensity score model.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>Model diagnostics for the outcome models.</p>
</dd>
<dt><code>effect</code></dt><dd><p>Model diagnostics for the joint effect model.</p>
</dd>
<dt><code>params</code></dt><dd><p>Parameters for any requested diagnostics.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Diagnostics_cfg-new"><code>Diagnostics_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Diagnostics_cfg-add"><code>Diagnostics_cfg$add()</code></a>
</p>
</li>
<li> <p><a href="#method-Diagnostics_cfg-clone"><code>Diagnostics_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Diagnostics_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Diagnostics_cfg</code> object with specified diagnostics to estimate.
</p>


<h5>Usage</h5>

<div class="r"><pre>Diagnostics_cfg$new(ps = NULL, outcome = NULL, effect = NULL, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ps</code></dt><dd><p>Model diagnostics for the propensity score model.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>Model diagnostics for the outcome models.</p>
</dd>
<dt><code>effect</code></dt><dd><p>Model diagnostics for the joint effect model.</p>
</dd>
<dt><code>params</code></dt><dd><p>List providing values for parameters to any requested diagnostics.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Diagnostics_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE", "RROC"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)
</pre>
</div>


<hr>
<a id="method-Diagnostics_cfg-add"></a>



<h4>Method <code>add()</code></h4>

<p>Add diagnostics to the <code>Diagnostics_cfg</code> object.
</p>


<h5>Usage</h5>

<div class="r"><pre>Diagnostics_cfg$add(ps = NULL, outcome = NULL, effect = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>ps</code></dt><dd><p>Model diagnostics for the propensity score model.</p>
</dd>
<dt><code>outcome</code></dt><dd><p>Model diagnostics for the outcome models.</p>
</dd>
<dt><code>effect</code></dt><dd><p>Model diagnostics for the joint effect model.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>Diagnostics_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>cfg &lt;- Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE", "RROC"),
   ps = c("SL_risk", "SL_coefs")
)
cfg &lt;- cfg$add(ps = "AUC")
</pre>
</div>


<hr>
<a id="method-Diagnostics_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Diagnostics_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE", "RROC"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)

## ------------------------------------------------
## Method `Diagnostics_cfg$new`
## ------------------------------------------------

Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE", "RROC"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)

## ------------------------------------------------
## Method `Diagnostics_cfg$add`
## ------------------------------------------------

cfg &lt;- Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE", "RROC"),
   ps = c("SL_risk", "SL_coefs")
)
cfg &lt;- cfg$add(ps = "AUC")
</code></pre>

<hr>
<h2 id='estimate_diagnostic'>Function to calculate diagnostics based on model outputs</h2><span id='topic+estimate_diagnostic'></span>

<h3>Description</h3>

<p>This function defines the calculations of common model diagnostics
which are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_diagnostic(data, label, prediction, diag_name, params)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_diagnostic_+3A_data">data</code></td>
<td>
<p>The full data frame with all auxilliary columns.</p>
</td></tr>
<tr><td><code id="estimate_diagnostic_+3A_label">label</code></td>
<td>
<p>The (string) column name for the labels to evaluate against.</p>
</td></tr>
<tr><td><code id="estimate_diagnostic_+3A_prediction">prediction</code></td>
<td>
<p>The (string) column name of predictions from the model to diagnose.</p>
</td></tr>
<tr><td><code id="estimate_diagnostic_+3A_diag_name">diag_name</code></td>
<td>
<p>The (string) name of the diagnostic to calculate. Currently
available are &quot;AUC&quot;, &quot;MSE&quot;, &quot;SL_coefs&quot;, &quot;SL_risk&quot;, &quot;RROC&quot;</p>
</td></tr>
<tr><td><code id="estimate_diagnostic_+3A_params">params</code></td>
<td>
<p>Any other necessary options to pass to the given diagnostic.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- dplyr::tibble(y = rbinom(100, 1, 0.5), p = rep(0.5, 100), w = rexp(100), u = 1:100)
attr(df, "weights") &lt;- "w"
attr(df, "identifier") &lt;- "u"
estimate_diagnostic(df, "y", "p", "AUC")
</code></pre>

<hr>
<h2 id='estimate_QoI'>Estimate Quantities of Interest</h2><span id='topic+estimate_QoI'></span>

<h3>Description</h3>

<p><code>estimate_QoI</code> takes a dataframe already prepared with split IDs,
plugin estimates and pseudo-outcomes and calculates the requested
quantities of interest (QoIs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_QoI(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimate_QoI_+3A_data">data</code></td>
<td>
<p>data frame (already prepared with <code>attach_config</code>, <code>make_splits</code>,
<code>produce_plugin_estimates</code> and <code>construct_pseudo_outcomes</code>)</p>
</td></tr>
<tr><td><code id="estimate_QoI_+3A_...">...</code></td>
<td>
<p>Unquoted names of moderators to calculate QoIs for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To see an example analysis, read <code>vignette("experimental_analysis")</code> in the context
of an experiment, <code>vignette("experimental_analysis")</code> for an observational study, or
<code>vignette("methodological_details")</code> for a deeper dive under the hood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attach_config">attach_config()</a></code>, <code><a href="#topic+make_splits">make_splits()</a></code>, <code><a href="#topic+produce_plugin_estimates">produce_plugin_estimates()</a></code>,
<code><a href="#topic+construct_pseudo_outcomes">construct_pseudo_outcomes()</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
if(require("palmerpenguins")) {
data(package = 'palmerpenguins')
penguins$unitid = seq_len(nrow(penguins))
penguins$propensity = rep(0.5, nrow(penguins))
penguins$treatment = rbinom(nrow(penguins), 1, penguins$propensity)
cfg &lt;- basic_config() %&gt;% 
add_known_propensity_score("propensity") %&gt;%
add_outcome_model("SL.glm.interaction") %&gt;%
remove_vimp()
attach_config(penguins, cfg) %&gt;%
make_splits(unitid, .num_splits = 4) %&gt;%
produce_plugin_estimates(outcome = body_mass_g, treatment = treatment, species, sex) %&gt;%
construct_pseudo_outcomes(body_mass_g, treatment) %&gt;%
estimate_QoI(species, sex)
}
</code></pre>

<hr>
<h2 id='fit_effect'>Fits a treatment effect model using the appropriate settings</h2><span id='topic+fit_effect'></span>

<h3>Description</h3>

<p>This function prepares data, fits the appropriate model and returns the
resulting estimates in a standardized format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_effect(full_data, weight_col, fx_col, ..., .Model_cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_effect_+3A_full_data">full_data</code></td>
<td>
<p>The full dataset of interest for the modelling problem.</p>
</td></tr>
<tr><td><code id="fit_effect_+3A_weight_col">weight_col</code></td>
<td>
<p>The unquoted weighting variable name to use in model fitting.</p>
</td></tr>
<tr><td><code id="fit_effect_+3A_fx_col">fx_col</code></td>
<td>
<p>The unquoted column name of the pseudo-outcome.</p>
</td></tr>
<tr><td><code id="fit_effect_+3A_...">...</code></td>
<td>
<p>The unquoted names of covariates to use in the model.</p>
</td></tr>
<tr><td><code id="fit_effect_+3A_.model_cfg">.Model_cfg</code></td>
<td>
<p>A <code>Model_cfg</code> object configuring the appropriate model type to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one element, <code>fx</code>. This element contains a <code>Predictor</code> object of
the appropriate subclass corresponding to the <code>Model_cfg</code> fit to the data.
</p>

<hr>
<h2 id='fit_fx_predictor'>Fit a predictor for treatment effects</h2><span id='topic+fit_fx_predictor'></span>

<h3>Description</h3>

<p>This function predicts treatment effects in a second stage model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_fx_predictor(full_data, weights, psi_col, ..., .pcate.cfg, .Model_cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_fx_predictor_+3A_full_data">full_data</code></td>
<td>
<p>The full original data with all auxilliary columns.</p>
</td></tr>
<tr><td><code id="fit_fx_predictor_+3A_weights">weights</code></td>
<td>
<p>Weights to be used in the analysis.</p>
</td></tr>
<tr><td><code id="fit_fx_predictor_+3A_psi_col">psi_col</code></td>
<td>
<p>The unquoted column name of the calculated pseudo-outcome.</p>
</td></tr>
<tr><td><code id="fit_fx_predictor_+3A_...">...</code></td>
<td>
<p>Covariate data, passed in as the unquoted names of columns in <code>full_data</code></p>
</td></tr>
<tr><td><code id="fit_fx_predictor_+3A_.pcate.cfg">.pcate.cfg</code></td>
<td>
<p>A <code>PCATE_cfg</code> object describing what PCATEs to calculate (and how)</p>
</td></tr>
<tr><td><code id="fit_fx_predictor_+3A_.model_cfg">.Model_cfg</code></td>
<td>
<p>A <code>Model_cfg</code> object describing how the effect model should be estimated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two items:
</p>

<ul>
<li> <p><code>model</code> - The <code>FX.Predictor</code> model object used internally for PCATE estimation.
</p>
</li>
<li> <p><code>data</code> - The data augmented with column <code>.pseudo_outcome_hat</code> for the cross-fit predictions
of the HTE for each unit.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+Model_cfg">Model_cfg</a>, <a href="#topic+PCATE_cfg">PCATE_cfg</a>
</p>

<hr>
<h2 id='fit_plugin'>Fits a plugin model using the appropriate settings</h2><span id='topic+fit_plugin'></span>

<h3>Description</h3>

<p>This function prepares data, fits the appropriate models and returns the
resulting estimates in a standardized format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_plugin(full_data, weight_col, outcome_col, ..., .Model_cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_plugin_+3A_full_data">full_data</code></td>
<td>
<p>The full dataset of interest for the modelling problem.</p>
</td></tr>
<tr><td><code id="fit_plugin_+3A_weight_col">weight_col</code></td>
<td>
<p>The unquoted weighting variable name to use in model fitting.</p>
</td></tr>
<tr><td><code id="fit_plugin_+3A_outcome_col">outcome_col</code></td>
<td>
<p>The unquoted column name to use as a label for the supervised
learning problem.</p>
</td></tr>
<tr><td><code id="fit_plugin_+3A_...">...</code></td>
<td>
<p>The unquoted names of covariates to use in the model.</p>
</td></tr>
<tr><td><code id="fit_plugin_+3A_.model_cfg">.Model_cfg</code></td>
<td>
<p>A <code>Model_cfg</code> object configuring the appropriate model type to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code>Predictor</code> object of the appropriate subclass corresponding to the
<code>Model_cfg</code> fit to the data.
</p>

<hr>
<h2 id='fit_plugin_A'>Fits a propensity score model using the appropriate settings</h2><span id='topic+fit_plugin_A'></span>

<h3>Description</h3>

<p>This function prepares data, fits the appropriate model and returns the
resulting estimates in a standardized format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_plugin_A(full_data, weight_col, a_col, ..., .Model_cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_plugin_A_+3A_full_data">full_data</code></td>
<td>
<p>The full dataset of interest for the modelling problem.</p>
</td></tr>
<tr><td><code id="fit_plugin_A_+3A_weight_col">weight_col</code></td>
<td>
<p>The unquoted weighting variable name to use in model fitting.</p>
</td></tr>
<tr><td><code id="fit_plugin_A_+3A_a_col">a_col</code></td>
<td>
<p>The unquoted column name of the treatment.</p>
</td></tr>
<tr><td><code id="fit_plugin_A_+3A_...">...</code></td>
<td>
<p>The unquoted names of covariates to use in the model.</p>
</td></tr>
<tr><td><code id="fit_plugin_A_+3A_.model_cfg">.Model_cfg</code></td>
<td>
<p>A <code>Model_cfg</code> object configuring the appropriate model type to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one element, <code>ps</code>. This element contains a <code>Predictor</code> object of
the appropriate subclass corresponding to the <code>Model_cfg</code> fit to the data.
</p>

<hr>
<h2 id='fit_plugin_Y'>Fits a T-learner using the appropriate settings</h2><span id='topic+fit_plugin_Y'></span>

<h3>Description</h3>

<p>This function prepares data, fits the appropriate model and returns the
resulting estimates in a standardized format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_plugin_Y(full_data, weight_col, y_col, a_col, ..., .Model_cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_plugin_Y_+3A_full_data">full_data</code></td>
<td>
<p>The full dataset of interest for the modelling problem.</p>
</td></tr>
<tr><td><code id="fit_plugin_Y_+3A_weight_col">weight_col</code></td>
<td>
<p>The unquoted weighting variable name to use in model fitting.</p>
</td></tr>
<tr><td><code id="fit_plugin_Y_+3A_y_col">y_col</code></td>
<td>
<p>The unquoted column name of the outcome.</p>
</td></tr>
<tr><td><code id="fit_plugin_Y_+3A_a_col">a_col</code></td>
<td>
<p>The unquoted column name of the treatment.</p>
</td></tr>
<tr><td><code id="fit_plugin_Y_+3A_...">...</code></td>
<td>
<p>The unquoted names of covariates to use in the model.</p>
</td></tr>
<tr><td><code id="fit_plugin_Y_+3A_.model_cfg">.Model_cfg</code></td>
<td>
<p>A <code>Model_cfg</code> object configuring the appropriate model type to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements, <code>mu1</code> and <code>mu0</code> corresponding to the models fit to
the treatment and control potential outcomes, respectively. Each is a new <code>Predictor</code>
object of the appropriate subclass corresponding to the the <code>Model_cfg</code> fit to the data.
</p>

<hr>
<h2 id='FX.Predictor'>Predictor class for the cross-fit predictor of &quot;partial&quot; CATEs</h2><span id='topic+FX.Predictor'></span>

<h3>Description</h3>

<p>Predictor class for the cross-fit predictor of &quot;partial&quot; CATEs
</p>
<p>Predictor class for the cross-fit predictor of &quot;partial&quot; CATEs
</p>


<h3>Details</h3>

<p>The class makes it easier to manage the K predictors for retrieving K-fold
cross-validated estimates, as well as to measure how treatment effects change
when only a single covariate is changed from its &quot;natural&quot; levels (in the sense
&quot;natural&quot; used by the direct / indirect effects literature).
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>models</code></dt><dd><p>A list of the K model fits</p>
</dd>
<dt><code>num_splits</code></dt><dd><p>The number of folds used in cross-fitting.</p>
</dd>
<dt><code>num_mc_samples</code></dt><dd><p>The number of samples to retrieve across the covariate space.
If num_mc_samples is larger than the sample size, then the entire dataset will be used.</p>
</dd>
<dt><code>covariates</code></dt><dd><p>The unquoted names of the covariates used in the second-stage model.</p>
</dd>
<dt><code>model_class</code></dt><dd><p>The model class (in the sense of <code>Model_cfg</code>). For instance,
a SuperLearner model will have model class &quot;SL&quot;.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-FX.Predictor-new"><code>FX.Predictor$new()</code></a>
</p>
</li>
<li> <p><a href="#method-FX.Predictor-predict"><code>FX.Predictor$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-FX.Predictor-clone"><code>FX.Predictor$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-FX.Predictor-new"></a>



<h4>Method <code>new()</code></h4>

<p><code>FX.predictor</code> is a class which simplifies the management of a set of cross-fit
prediction models of treatment effects and provides the ability to get the &quot;partial&quot;
effects of particular covariates.
</p>


<h5>Usage</h5>

<div class="r"><pre>FX.Predictor$new(models, num_splits, num_mc_samples, covariates, model_class)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>models</code></dt><dd><p>A list of the K model fits.</p>
</dd>
<dt><code>num_splits</code></dt><dd><p>Integer number of cross-fitting folds.</p>
</dd>
<dt><code>num_mc_samples</code></dt><dd><p>Integer number of Monte-Carlo samples across the covariate
space. If this is larger than the sample size, then the whole dataset will be used.</p>
</dd>
<dt><code>covariates</code></dt><dd><p>The unquoted names of the covariates.</p>
</dd>
<dt><code>model_class</code></dt><dd><p>The model class (in the sense of <code>Model_cfg</code>).</p>
</dd>
</dl>

</div>


<hr>
<a id="method-FX.Predictor-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predicts the PCATE surface over a particular covariate, returning a tibble with
the predicted HTE for every Monte-Carlo sample.
</p>


<h5>Usage</h5>

<div class="r"><pre>FX.Predictor$predict(data, covariate)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>The full dataset</p>
</dd>
<dt><code>covariate</code></dt><dd><p>The unquoted covariate name for which to calculate predicted
treatment effects.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A tibble with columns:
</p>

<ul>
<li> <p><code>covariate_value</code> - The value of the covariate of interest
</p>
</li>
<li> <p><code>.hte</code> - An estimated HTE
</p>
</li>
<li> <p><code>.id</code> - The identifier for the original row (which had
<code>covariate</code> modified to <code>covariate_value</code>).
</p>
</li></ul>



<hr>
<a id="method-FX.Predictor-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FX.Predictor$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='HTE_cfg'>Configuration of Quantities of Interest</h2><span id='topic+HTE_cfg'></span>

<h3>Description</h3>

<p><code>HTE_cfg</code> is a configuration class that pulls everything together, indicating
the full configuration for a given HTE analysis. This includes how to estimate
models and what Quantities of Interest to calculate based off those underlying models.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>outcome</code></dt><dd><p><code>Model_cfg</code> object indicating how outcome models should be estimated.</p>
</dd>
<dt><code>treatment</code></dt><dd><p><code>Model_cfg</code> object indicating how the propensity score
model should be estimated.</p>
</dd>
<dt><code>effect</code></dt><dd><p><code>Model_cfg</code> object indicating how the joint effect model
should be estimated.</p>
</dd>
<dt><code>qoi</code></dt><dd><p><code>QoI_cfg</code> object indicating what the Quantities of Interest
are and providing all
necessary detail on how they should be estimated.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Logical indicating whether to print debugging information.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HTE_cfg-new"><code>HTE_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HTE_cfg-clone"><code>HTE_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HTE_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>HTE_cfg</code> object with all necessary information about how
to carry out an HTE analysis.
</p>


<h5>Usage</h5>

<div class="r"><pre>HTE_cfg$new(
  outcome = NULL,
  treatment = NULL,
  effect = NULL,
  qoi = NULL,
  verbose = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>outcome</code></dt><dd><p><code>Model_cfg</code> object indicating how outcome models should
be estimated.</p>
</dd>
<dt><code>treatment</code></dt><dd><p><code>Model_cfg</code> object indicating how the propensity score
model should be estimated.</p>
</dd>
<dt><code>effect</code></dt><dd><p><code>Model_cfg</code> object indicating how the joint effect model
should be estimated.</p>
</dd>
<dt><code>qoi</code></dt><dd><p><code>QoI_cfg</code> object indicating what the Quantities of Interest
are and providing all
necessary detail on how they should be estimated.</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Logical indicating whether to print debugging information.</p>
</dd>
</dl>

</div>



<h5>Examples</h5>

<div class="r example copy">
<pre>mcate_cfg &lt;- MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
pcate_cfg &lt;- PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
vimp_cfg &lt;- VIMP_cfg$new()
diag_cfg &lt;- Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)
qoi_cfg &lt;- QoI_cfg$new(
    mcate = mcate_cfg,
    pcate = pcate_cfg,
    vimp = vimp_cfg,
    diag = diag_cfg
)
ps_cfg &lt;- SLEnsemble_cfg$new(
   learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
y_cfg &lt;- SLEnsemble_cfg$new(
   learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
fx_cfg &lt;- SLEnsemble_cfg$new(
   learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
HTE_cfg$new(outcome = y_cfg, treatment = ps_cfg, effect = fx_cfg, qoi = qoi_cfg)
</pre>
</div>


<hr>
<a id="method-HTE_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HTE_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `HTE_cfg$new`
## ------------------------------------------------

mcate_cfg &lt;- MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
pcate_cfg &lt;- PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
vimp_cfg &lt;- VIMP_cfg$new()
diag_cfg &lt;- Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)
qoi_cfg &lt;- QoI_cfg$new(
    mcate = mcate_cfg,
    pcate = pcate_cfg,
    vimp = vimp_cfg,
    diag = diag_cfg
)
ps_cfg &lt;- SLEnsemble_cfg$new(
   learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
y_cfg &lt;- SLEnsemble_cfg$new(
   learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
fx_cfg &lt;- SLEnsemble_cfg$new(
   learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
HTE_cfg$new(outcome = y_cfg, treatment = ps_cfg, effect = fx_cfg, qoi = qoi_cfg)
</code></pre>

<hr>
<h2 id='HTEFold'>R6 class to represent partitions of the data between training and held-out</h2><span id='topic+HTEFold'></span>

<h3>Description</h3>

<p>R6 class to represent partitions of the data between training and held-out
</p>
<p>R6 class to represent partitions of the data between training and held-out
</p>


<h3>Details</h3>

<p>This takes a set of folds calculated elsewhere and represents
these folds in a consistent format.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>train</code></dt><dd><p>A dataframe containing only the training set</p>
</dd>
<dt><code>holdout</code></dt><dd><p>A dataframe containing only the held-out data</p>
</dd>
<dt><code>in_holdout</code></dt><dd><p>A logical vector indicating if the initial data
lies in the holdout set.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HTEFold-new"><code>HTEFold$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HTEFold-clone"><code>HTEFold$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HTEFold-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates an R6 object of the data split between training and test set.
</p>


<h5>Usage</h5>

<div class="r"><pre>HTEFold$new(data, split_id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>The dataset to be split</p>
</dd>
<dt><code>split_id</code></dt><dd><p>An identifier indicating which data should lie in the holdout set.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>Returns an object of class <code>HTEFold</code>
</p>


<hr>
<a id="method-HTEFold-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HTEFold$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='KernelSmooth_cfg'>Configuration for a Kernel Smoother</h2><span id='topic+KernelSmooth_cfg'></span>

<h3>Description</h3>

<p><code>KernelSmooth_cfg</code> is a configuration class for non-parametric local-linear
regression to construct a smooth representation of the relationship between
two variables. This is typically used for displaying a surface of the conditional
average treatment effect over a continuous covariate.
</p>
<p>Kernel smoothing is handled by the <code>nprobust</code> package.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Model_cfg">tidyhte::Model_cfg</a></code> -&gt; <code>KernelSmooth_cfg</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>model_class</code></dt><dd><p>The class of the model, required for all classes
which inherit from <code>Model_cfg</code>.</p>
</dd>
<dt><code>neval</code></dt><dd><p>The number of points at which to evaluate the local
regression. More points will provide a smoother line at the cost
of somewhat higher computation.</p>
</dd>
<dt><code>eval_min_quantile</code></dt><dd><p>Minimum quantile at which to evaluate the smoother.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-KernelSmooth_cfg-new"><code>KernelSmooth_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-KernelSmooth_cfg-clone"><code>KernelSmooth_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-KernelSmooth_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>KernelSmooth_cfg</code> object with specified number of evaluation points.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelSmooth_cfg$new(neval = 100, eval_min_quantile = 0.05)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>neval</code></dt><dd><p>The number of points at which to evaluate the local
regression. More points will provide a smoother line at the cost
of somewhat higher computation.</p>
</dd>
<dt><code>eval_min_quantile</code></dt><dd><p>Minimum quantile at which to evaluate the smoother.
A value of zero will do no clipping. Clipping is performed from both the
top and the bottom of the empirical distribution. A value of alpha would
evaluate over [alpha, 1 - alpha].</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>KernelSmooth_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>KernelSmooth_cfg$new(neval = 100)
</pre>
</div>


<hr>
<a id="method-KernelSmooth_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>KernelSmooth_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="nprobust.html#topic+lprobust">nprobust::lprobust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `KernelSmooth_cfg$new`
## ------------------------------------------------

KernelSmooth_cfg$new(neval = 100)
</code></pre>

<hr>
<h2 id='Known_cfg'>Configuration of Known Model</h2><span id='topic+Known_cfg'></span>

<h3>Description</h3>

<p><code>Known_cfg</code> is a configuration class for when a particular model is known
a-priori. The prototypical usage of this class is when heterogeneous
treatment effects are estimated in the context of a randomized control
trial with known propensity scores.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Model_cfg">tidyhte::Model_cfg</a></code> -&gt; <code>Known_cfg</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>covariate_name</code></dt><dd><p>The name of the column in the dataset
which corresponds to the known model score.</p>
</dd>
<dt><code>model_class</code></dt><dd><p>The class of the model, required for all classes
which inherit from <code>Model_cfg</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Known_cfg-new"><code>Known_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Known_cfg-clone"><code>Known_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Known_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Known_cfg</code> object with specified covariate column.
</p>


<h5>Usage</h5>

<div class="r"><pre>Known_cfg$new(covariate_name)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covariate_name</code></dt><dd><p>The name of the column, a string, in the dataset
corresponding to the known model score (i.e. the true conditional expectation).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Known_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Known_cfg$new("propensity_score")
</pre>
</div>


<hr>
<a id="method-Known_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Known_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Known_cfg$new`
## ------------------------------------------------

Known_cfg$new("propensity_score")
</code></pre>

<hr>
<h2 id='listwise_deletion'>Removes rows which have missing data on any of the supplied columns.</h2><span id='topic+listwise_deletion'></span>

<h3>Description</h3>

<p>This function removes rows with missingness based on the columns provided.
If rows are dropped, a message is displayed to the user to inform them of this
fact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listwise_deletion(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="listwise_deletion_+3A_data">data</code></td>
<td>
<p>The dataset from which to drop cases which are not fully observed.</p>
</td></tr>
<tr><td><code id="listwise_deletion_+3A_...">...</code></td>
<td>
<p>Unquoted column names which must be non-missing. Missingness in these
columns will result in dropped observations. Missingness in other columns will not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data with all observations which are fully observed.
</p>

<hr>
<h2 id='make_splits'>Define splits for cross-fitting</h2><span id='topic+make_splits'></span>

<h3>Description</h3>

<p>This takes a dataset, a column with a unique identifier and an
arbitrary number of covariates on which to stratify the splits.
It returns the original dataset with an additional column <code>.split_id</code>
corresponding to an identifier for the split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_splits(data, identifier, ..., .num_splits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_splits_+3A_data">data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="make_splits_+3A_identifier">identifier</code></td>
<td>
<p>Unquoted name of unique identifier column</p>
</td></tr>
<tr><td><code id="make_splits_+3A_...">...</code></td>
<td>
<p>variables on which to stratify (requires that <code>quickblock</code> be installed.)</p>
</td></tr>
<tr><td><code id="make_splits_+3A_.num_splits">.num_splits</code></td>
<td>
<p>number of splits to create. If VIMP is requested in <code>QoI_cfg</code>, this
must be an even number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To see an example analysis, read <code>vignette("experimental_analysis")</code> in the context
of an experiment, <code>vignette("experimental_analysis")</code> for an observational study, or
<code>vignette("methodological_details")</code> for a deeper dive under the hood.
</p>


<h3>Value</h3>

<p>original dataframe with additional <code>.split_id</code> column
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attach_config">attach_config()</a></code>, <code><a href="#topic+produce_plugin_estimates">produce_plugin_estimates()</a></code>, <code><a href="#topic+construct_pseudo_outcomes">construct_pseudo_outcomes()</a></code>,
<code><a href="#topic+estimate_QoI">estimate_QoI()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
if(require("palmerpenguins")) {
data(package = 'palmerpenguins')
penguins$unitid = seq_len(nrow(penguins))
penguins$propensity = rep(0.5, nrow(penguins))
penguins$treatment = rbinom(nrow(penguins), 1, penguins$propensity)
cfg &lt;- basic_config() %&gt;% 
add_known_propensity_score("propensity") %&gt;%
add_outcome_model("SL.glm.interaction") %&gt;%
remove_vimp()
attach_config(penguins, cfg) %&gt;%
make_splits(unitid, .num_splits = 4) %&gt;%
produce_plugin_estimates(outcome = body_mass_g, treatment = treatment, species, sex) %&gt;%
construct_pseudo_outcomes(body_mass_g, treatment) %&gt;%
estimate_QoI(species, sex)
}
</code></pre>

<hr>
<h2 id='MCATE_cfg'>Configuration of Marginal CATEs</h2><span id='topic+MCATE_cfg'></span>

<h3>Description</h3>

<p><code>MCATE_cfg</code> is a configuration class for estimating marginal response
surfaces based on heterogeneous treatment effect estimates. &quot;Marginal&quot;
in this context implies that all other covariates are marginalized.
Thus, if two covariates are highly correlated, it is likely that their
MCATE surfaces will be extremely similar.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>cfgs</code></dt><dd><p>Named list of covariates names to a <code>Model_cfg</code> object defining
how to present that covariate's CATE surface (while marginalizing
over all other covariates).</p>
</dd>
<dt><code>std_errors</code></dt><dd><p>Boolean indicating whether the results should be
returned with standard errors or not.</p>
</dd>
<dt><code>estimand</code></dt><dd><p>String indicating the estimand to target.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MCATE_cfg-new"><code>MCATE_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MCATE_cfg-add_moderator"><code>MCATE_cfg$add_moderator()</code></a>
</p>
</li>
<li> <p><a href="#method-MCATE_cfg-clone"><code>MCATE_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MCATE_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>MCATE_cfg</code> object with specified model name and hyperparameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCATE_cfg$new(cfgs, std_errors = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cfgs</code></dt><dd><p>Named list from moderator name to a <code>Model_cfg</code> object
defining how to present that covariate's CATE surface (while
marginalizing over all other covariates)</p>
</dd>
<dt><code>std_errors</code></dt><dd><p>Boolean indicating whether the results should be returned with standard
errors or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>MCATE_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
</pre>
</div>


<hr>
<a id="method-MCATE_cfg-add_moderator"></a>



<h4>Method <code>add_moderator()</code></h4>

<p>Add a moderator to the <code>MCATE_cfg</code> object. This entails defining a configuration
for displaying the effect surface for that moderator.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCATE_cfg$add_moderator(var_name, cfg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var_name</code></dt><dd><p>The name of the moderator to add (and the name of the column in
the dataset).</p>
</dd>
<dt><code>cfg</code></dt><dd><p>A <code>Model_cfg</code> defining how to display the selected moderator's effect
surface.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>MCATE_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>cfg &lt;- MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
cfg &lt;- cfg$add_moderator("x2", KernelSmooth_cfg$new(neval = 100))
</pre>
</div>


<hr>
<a id="method-MCATE_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MCATE_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))

## ------------------------------------------------
## Method `MCATE_cfg$new`
## ------------------------------------------------

MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))

## ------------------------------------------------
## Method `MCATE_cfg$add_moderator`
## ------------------------------------------------

cfg &lt;- MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
cfg &lt;- cfg$add_moderator("x2", KernelSmooth_cfg$new(neval = 100))
</code></pre>

<hr>
<h2 id='Model_cfg'>Base Class of Model Configurations</h2><span id='topic+Model_cfg'></span>

<h3>Description</h3>

<p><code>Model_cfg</code> is the base class from which all other model configurations
inherit.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>model_class</code></dt><dd><p>The class of the model, required for all classes
which inherit from <code>Model_cfg</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Model_cfg-new"><code>Model_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Model_cfg-clone"><code>Model_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Model_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Model_cfg</code> object with any necessary parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model_cfg$new()</pre></div>



<h5>Returns</h5>

<p>A new <code>Model_cfg</code> object.
</p>


<hr>
<a id="method-Model_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='Model_data'>R6 class to represent data to be used in estimating a model</h2><span id='topic+Model_data'></span>

<h3>Description</h3>

<p>R6 class to represent data to be used in estimating a model
</p>
<p>R6 class to represent data to be used in estimating a model
</p>


<h3>Details</h3>

<p>This class provides consistent names and interfaces to data which will
be used in a supervised regression / classification model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>label</code></dt><dd><p>The labels for the eventual model as a vector.</p>
</dd>
<dt><code>features</code></dt><dd><p>The matrix representation of the data to be used for model fitting.
Constructed using <code>stats::model.matrix</code>.</p>
</dd>
<dt><code>model_frame</code></dt><dd><p>The data-frame representation of the data as constructed by
<code>stats::model.frame</code>.</p>
</dd>
<dt><code>split_id</code></dt><dd><p>The split identifiers as a vector.</p>
</dd>
<dt><code>num_splits</code></dt><dd><p>The integer number of splits in the data.</p>
</dd>
<dt><code>cluster</code></dt><dd><p>A cluster ID as a vector, constructed using the unit identifiers.</p>
</dd>
<dt><code>weights</code></dt><dd><p>The case-weights as a vector.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Model_data-new"><code>Model_data$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Model_data-SL_cv_control"><code>Model_data$SL_cv_control()</code></a>
</p>
</li>
<li> <p><a href="#method-Model_data-clone"><code>Model_data$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Model_data-new"></a>



<h4>Method <code>new()</code></h4>

<p>Creates an R6 object to represent data to be used in a prediction model.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model_data$new(data, label_col, ..., .weight_col = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>data</code></dt><dd><p>The full dataset to populate the class with.</p>
</dd>
<dt><code>label_col</code></dt><dd><p>The unquoted name of the column to use as the label in
supervised learning models.</p>
</dd>
<dt><code>...</code></dt><dd><p>The unquoted names of features to use in the model.</p>
</dd>
<dt><code>.weight_col</code></dt><dd><p>The unquoted name of the column to use as case-weights
in subsequent models.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A <code>Model_data</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>library("dplyr")
df &lt;- dplyr::tibble(
    uid = 1:100,
    x1 = rnorm(100),
    x2 = rnorm(100),
    x3 = sample(4, 100, replace = TRUE)
) %&gt;% dplyr::mutate(
    y = x1 + x2 + x3 + rnorm(100),
    x3 = factor(x3)
)
df &lt;- make_splits(df, uid, .num_splits = 5)
data &lt;- Model_data$new(df, y, x1, x2, x3)
</pre>
</div>


<hr>
<a id="method-Model_data-SL_cv_control"></a>



<h4>Method <code>SL_cv_control()</code></h4>

<p>A helper function to create the cross-validation options to be used by SuperLearner.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model_data$SL_cv_control()</pre></div>


<hr>
<a id="method-Model_data-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Model_data$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><a href="SuperLearner.html#topic+SuperLearner.CV.control">SuperLearner::SuperLearner.CV.control</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Model_data$new`
## ------------------------------------------------

library("dplyr")
df &lt;- dplyr::tibble(
    uid = 1:100,
    x1 = rnorm(100),
    x2 = rnorm(100),
    x3 = sample(4, 100, replace = TRUE)
) %&gt;% dplyr::mutate(
    y = x1 + x2 + x3 + rnorm(100),
    x3 = factor(x3)
)
df &lt;- make_splits(df, uid, .num_splits = 5)
data &lt;- Model_data$new(df, y, x1, x2, x3)
</code></pre>

<hr>
<h2 id='PCATE_cfg'>Configuration of Partial CATEs</h2><span id='topic+PCATE_cfg'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
<code>PCATE_cfg</code> is a configuration class for estimating marginal
response surfaces based on heterogeneous treatment effect estimates.
&quot;Partial&quot; in this context is used similarly to the use in partial
dependence plots or in partial regression. In essence, a PCATE
attempts to partial out the contribution to the CATE from all other
covariates. Two highly correlated variables may have very different
PCATE surfaces.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>cfgs</code></dt><dd><p>Named list of covariates names to a <code>Model_cfg</code> object defining
how to present that covariate's CATE surface.</p>
</dd>
<dt><code>model_covariates</code></dt><dd><p>A character vector of all the covariates
to be included in the second-level effect regression.</p>
</dd>
<dt><code>num_mc_samples</code></dt><dd><p>A named list from covariate name to the number
of Monte Carlo samples to take to calculate the double integral (See Details).</p>
</dd>
<dt><code>estimand</code></dt><dd><p>String indicating the estimand to target.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-PCATE_cfg-new"><code>PCATE_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-PCATE_cfg-add_moderator"><code>PCATE_cfg$add_moderator()</code></a>
</p>
</li>
<li> <p><a href="#method-PCATE_cfg-clone"><code>PCATE_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-PCATE_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>PCATE_cfg</code> object with specified model name and hyperparameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>PCATE_cfg$new(model_covariates, cfgs, num_mc_samples = 100)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model_covariates</code></dt><dd><p>A character vector of all the covariates to be
included in the second-level effect regression.</p>
</dd>
<dt><code>cfgs</code></dt><dd><p>Named list from moderator name to a <code>Model_cfg</code> object defining how to
present that covariate's CATE surface.</p>
</dd>
<dt><code>num_mc_samples</code></dt><dd><p>A named list from covariate name to the number of Monte Carlo
samples to take to calculate the double integral (See Details). If all covariates
should use the same number of samples, simply pass the (integer) number of samples.</p>
</dd>
<dt><code>effect_cfg</code></dt><dd><p>A <code>Model_cfg</code> object indicating how to fit the second level effect
regression (joint across all selected covariates).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>PCATE_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
</pre>
</div>


<hr>
<a id="method-PCATE_cfg-add_moderator"></a>



<h4>Method <code>add_moderator()</code></h4>

<p>Add a moderator to the <code>PCATE_cfg</code> object. This entails adding it to the joint
model of effects and defines a configuration for displaying the effect surface
for that moderator.
</p>


<h5>Usage</h5>

<div class="r"><pre>PCATE_cfg$add_moderator(var_name, cfg)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>var_name</code></dt><dd><p>The name of the moderator to add (and the name of the column in
the dataset).</p>
</dd>
<dt><code>cfg</code></dt><dd><p>A <code>Model_cfg</code> defining how to display the selected moderator's effect
surface.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>An updated <code>PCATE_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>cfg &lt;- PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
cfg &lt;- cfg$add_moderator("x2", KernelSmooth_cfg$new(neval = 100))
</pre>
</div>


<hr>
<a id="method-PCATE_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PCATE_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)

## ------------------------------------------------
## Method `PCATE_cfg$new`
## ------------------------------------------------

PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)

## ------------------------------------------------
## Method `PCATE_cfg$add_moderator`
## ------------------------------------------------

cfg &lt;- PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
cfg &lt;- cfg$add_moderator("x2", KernelSmooth_cfg$new(neval = 100))
</code></pre>

<hr>
<h2 id='predict.SL.glmnet.interaction'>Prediction for an SL.glmnet object</h2><span id='topic+predict.SL.glmnet.interaction'></span>

<h3>Description</h3>

<p>Prediction for the glmnet wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SL.glmnet.interaction'
predict(
  object,
  newdata,
  remove_extra_cols = TRUE,
  add_missing_cols = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.SL.glmnet.interaction_+3A_object">object</code></td>
<td>
<p>Result object from SL.glmnet</p>
</td></tr>
<tr><td><code id="predict.SL.glmnet.interaction_+3A_newdata">newdata</code></td>
<td>
<p>Dataframe or matrix that will generate predictions.</p>
</td></tr>
<tr><td><code id="predict.SL.glmnet.interaction_+3A_remove_extra_cols">remove_extra_cols</code></td>
<td>
<p>Remove any extra columns in the new data that were
not part of the original model.</p>
</td></tr>
<tr><td><code id="predict.SL.glmnet.interaction_+3A_add_missing_cols">add_missing_cols</code></td>
<td>
<p>Add any columns from original data that do not exist
in the new data, and set values to 0.</p>
</td></tr>
<tr><td><code id="predict.SL.glmnet.interaction_+3A_...">...</code></td>
<td>
<p>Any additional arguments (not used).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="SuperLearner.html#topic+SL.glmnet">SL.glmnet</a></code>
</p>

<hr>
<h2 id='produce_plugin_estimates'>Estimate models of nuisance functions</h2><span id='topic+produce_plugin_estimates'></span>

<h3>Description</h3>

<p>This takes a dataset with an identified outcome and treatment column along
with any number of covariates and appends three columns to the dataset corresponding
to an estimate of the conditional expectation of treatment (<code>.pi_hat</code>), along with the
conditional expectation of the control and treatment potential outcome surfaces
(<code>.mu0_hat</code> and <code>.mu1_hat</code> respectively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>produce_plugin_estimates(data, outcome, treatment, ..., .weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="produce_plugin_estimates_+3A_data">data</code></td>
<td>
<p>dataframe (already prepared with <code>attach_config</code> and <code>make_splits</code>)</p>
</td></tr>
<tr><td><code id="produce_plugin_estimates_+3A_outcome">outcome</code></td>
<td>
<p>Unquoted name of the outcome variable.</p>
</td></tr>
<tr><td><code id="produce_plugin_estimates_+3A_treatment">treatment</code></td>
<td>
<p>Unquoted name of the treatment variable.</p>
</td></tr>
<tr><td><code id="produce_plugin_estimates_+3A_...">...</code></td>
<td>
<p>Unquoted names of covariates to include in the models of the nuisance functions.</p>
</td></tr>
<tr><td><code id="produce_plugin_estimates_+3A_.weights">.weights</code></td>
<td>
<p>Unquoted name of weights column. If NULL, all analysis will assume weights
are all equal to one and sample-based quantities will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To see an example analysis, read <code>vignette("experimental_analysis")</code> in the context
of an experiment, <code>vignette("experimental_analysis")</code> for an observational study, or
<code>vignette("methodological_details")</code> for a deeper dive under the hood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+attach_config">attach_config()</a></code>, <code><a href="#topic+make_splits">make_splits()</a></code>, <code><a href="#topic+construct_pseudo_outcomes">construct_pseudo_outcomes()</a></code>, <code><a href="#topic+estimate_QoI">estimate_QoI()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
if(require("palmerpenguins")) {
data(package = 'palmerpenguins')
penguins$unitid = seq_len(nrow(penguins))
penguins$propensity = rep(0.5, nrow(penguins))
penguins$treatment = rbinom(nrow(penguins), 1, penguins$propensity)
cfg &lt;- basic_config() %&gt;% 
add_known_propensity_score("propensity") %&gt;%
add_outcome_model("SL.glm.interaction") %&gt;%
remove_vimp()
attach_config(penguins, cfg) %&gt;%
make_splits(unitid, .num_splits = 4) %&gt;%
produce_plugin_estimates(outcome = body_mass_g, treatment = treatment, species, sex) %&gt;%
construct_pseudo_outcomes(body_mass_g, treatment) %&gt;%
estimate_QoI(species, sex)
}
</code></pre>

<hr>
<h2 id='QoI_cfg'>Configuration of Quantities of Interest</h2><span id='topic+QoI_cfg'></span>

<h3>Description</h3>

<p><code>QoI_cfg</code> is a configuration class for the Quantities of Interest to be
generated by the HTE analysis.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>mcate</code></dt><dd><p>A configuration object of type <code>MCATE_cfg</code> of
marginal effects to calculate.</p>
</dd>
<dt><code>pcate</code></dt><dd><p>A configuration object of type <code>PCATE_cfg</code> of
partial effects to calculate.</p>
</dd>
<dt><code>vimp</code></dt><dd><p>A configuration object of type <code>VIMP_cfg</code> of
variable importance to calculate.</p>
</dd>
<dt><code>diag</code></dt><dd><p>A configuration object of type <code>Diagnostics_cfg</code> of
model diagnostics to calculate.</p>
</dd>
<dt><code>ate</code></dt><dd><p>Logical flag indicating whether an estimate of the
ATE should be returned.</p>
</dd>
<dt><code>predictions</code></dt><dd><p>Logical flag indicating whether estimates of
the CATE for every unit should be returned.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-QoI_cfg-new"><code>QoI_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-QoI_cfg-clone"><code>QoI_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-QoI_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>QoI_cfg</code> object with specified Quantities of Interest
to estimate.
</p>


<h5>Usage</h5>

<div class="r"><pre>QoI_cfg$new(
  mcate = NULL,
  pcate = NULL,
  vimp = NULL,
  diag = NULL,
  ate = TRUE,
  predictions = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mcate</code></dt><dd><p>A configuration object of type <code>MCATE_cfg</code> of marginal
effects to calculate.</p>
</dd>
<dt><code>pcate</code></dt><dd><p>A configuration object of type <code>PCATE_cfg</code> of partial
effects to calculate.</p>
</dd>
<dt><code>vimp</code></dt><dd><p>A configuration object of type <code>VIMP_cfg</code> of variable
importance to calculate.</p>
</dd>
<dt><code>diag</code></dt><dd><p>A configuration object of type <code>Diagnostics_cfg</code> of
model diagnostics to calculate.</p>
</dd>
<dt><code>ate</code></dt><dd><p>A logical flag for whether to calculate the Average
Treatment Effect (ATE) or not.</p>
</dd>
<dt><code>predictions</code></dt><dd><p>A logical flag for whether to return predictions
of the CATE for every unit or not.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Diagnostics_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>mcate_cfg &lt;- MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
pcate_cfg &lt;- PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
vimp_cfg &lt;- VIMP_cfg$new()
diag_cfg &lt;- Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)
QoI_cfg$new(
    mcate = mcate_cfg,
    pcate = pcate_cfg,
    vimp = vimp_cfg,
    diag = diag_cfg
)
</pre>
</div>


<hr>
<a id="method-QoI_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>QoI_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>mcate_cfg &lt;- MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
pcate_cfg &lt;- PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
vimp_cfg &lt;- VIMP_cfg$new()
diag_cfg &lt;- Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)
QoI_cfg$new(
    mcate = mcate_cfg,
    pcate = pcate_cfg,
    vimp = vimp_cfg,
    diag = diag_cfg
)

## ------------------------------------------------
## Method `QoI_cfg$new`
## ------------------------------------------------

mcate_cfg &lt;- MCATE_cfg$new(cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)))
pcate_cfg &lt;- PCATE_cfg$new(
   cfgs = list(x1 = KernelSmooth_cfg$new(neval = 100)),
   model_covariates = c("x1", "x2", "x3"),
   num_mc_samples = list(x1 = 100)
)
vimp_cfg &lt;- VIMP_cfg$new()
diag_cfg &lt;- Diagnostics_cfg$new(
   outcome = c("SL_risk", "SL_coefs", "MSE"),
   ps = c("SL_risk", "SL_coefs", "AUC")
)
QoI_cfg$new(
    mcate = mcate_cfg,
    pcate = pcate_cfg,
    vimp = vimp_cfg,
    diag = diag_cfg
)
</code></pre>

<hr>
<h2 id='remove_vimp'>Removes variable importance information</h2><span id='topic+remove_vimp'></span>

<h3>Description</h3>

<p>This removes the variable importance quantity of interest
from an <code>HTE_cfg</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_vimp(hte_cfg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_vimp_+3A_hte_cfg">hte_cfg</code></td>
<td>
<p><code>HTE_cfg</code> object to update.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>HTE_cfg</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("dplyr")
basic_config() %&gt;%
   remove_vimp() -&gt; hte_cfg
</code></pre>

<hr>
<h2 id='SL.glmnet.interaction'>Elastic net regression with pairwise interactions</h2><span id='topic+SL.glmnet.interaction'></span>

<h3>Description</h3>

<p>Penalized regression using elastic net. Alpha = 0 corresponds to ridge
regression and alpha = 1 corresponds to Lasso. Included in the model
are pairwise interactions between covariates.
</p>
<p>See <code>vignette("glmnet_beta", package = "glmnet")</code> for a nice tutorial on
glmnet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SL.glmnet.interaction(
  Y,
  X,
  newX,
  family,
  obsWeights,
  id,
  alpha = 1,
  nfolds = 10,
  nlambda = 100,
  useMin = TRUE,
  loss = "deviance",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SL.glmnet.interaction_+3A_y">Y</code></td>
<td>
<p>Outcome variable</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_x">X</code></td>
<td>
<p>Covariate dataframe</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_newx">newX</code></td>
<td>
<p>Dataframe to predict the outcome</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_family">family</code></td>
<td>
<p>&quot;gaussian&quot; for regression, &quot;binomial&quot; for binary
classification. Untested options: &quot;multinomial&quot; for multiple classification
or &quot;mgaussian&quot; for multiple response, &quot;poisson&quot; for non-negative outcome
with proportional mean and variance, &quot;cox&quot;.</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_obsweights">obsWeights</code></td>
<td>
<p>Optional observation-level weights</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_id">id</code></td>
<td>
<p>Optional id to group observations from the same unit (not used
currently).</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_alpha">alpha</code></td>
<td>
<p>Elastic net mixing parameter, range [0, 1]. 0 = ridge regression
and 1 = lasso.</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds for internal cross-validation to optimize lambda.</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of lambda values to check, recommended to be 100 or more.</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_usemin">useMin</code></td>
<td>
<p>If TRUE use lambda that minimizes risk, otherwise use 1
standard-error rule which chooses a higher penalty with performance within
one standard error of the minimum (see Breiman et al. 1984 on CART for
background).</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_loss">loss</code></td>
<td>
<p>Loss function, can be &quot;deviance&quot;, &quot;mse&quot;, or &quot;mae&quot;. If family =
binomial can also be &quot;auc&quot; or &quot;class&quot; (misclassification error).</p>
</td></tr>
<tr><td><code id="SL.glmnet.interaction_+3A_...">...</code></td>
<td>
<p>Any additional arguments are passed through to cv.glmnet.</p>
</td></tr>
</table>

<hr>
<h2 id='SLEnsemble_cfg'>Configuration for a SuperLearner Ensemble</h2><span id='topic+SLEnsemble_cfg'></span>

<h3>Description</h3>

<p><code>SLEnsemble_cfg</code> is a configuration class for estimation of a model
using an ensemble of models using <code>SuperLearner</code>.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Model_cfg">tidyhte::Model_cfg</a></code> -&gt; <code>SLEnsemble_cfg</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>cvControl</code></dt><dd><p>A list of parameters for controlling the
cross-validation used in SuperLearner.</p>
</dd>
<dt><code>SL.library</code></dt><dd><p>A vector of the names of learners to
include in the SuperLearner ensemble.</p>
</dd>
<dt><code>SL.env</code></dt><dd><p>An environment containing all of the programmatically
generated learners to be included
in the SuperLearner ensemble.</p>
</dd>
<dt><code>family</code></dt><dd><p><code>stats::family</code> object to determine how SuperLearner
should be fitted.</p>
</dd>
<dt><code>model_class</code></dt><dd><p>The class of the model, required for all classes
which inherit from <code>Model_cfg</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SLEnsemble_cfg-new"><code>SLEnsemble_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SLEnsemble_cfg-add_sublearner"><code>SLEnsemble_cfg$add_sublearner()</code></a>
</p>
</li>
<li> <p><a href="#method-SLEnsemble_cfg-clone"><code>SLEnsemble_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SLEnsemble_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>SLEnsemble_cfg</code> object with specified settings.
</p>


<h5>Usage</h5>

<div class="r"><pre>SLEnsemble_cfg$new(
  cvControl = NULL,
  learner_cfgs = NULL,
  family = stats::gaussian()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cvControl</code></dt><dd><p>A list of parameters for controlling the
cross-validation used in SuperLearner.
For more details, see <code>SuperLearner::SuperLearner.CV.control</code>.</p>
</dd>
<dt><code>learner_cfgs</code></dt><dd><p>A list of <code>SLLearner_cfg</code> objects.</p>
</dd>
<dt><code>family</code></dt><dd><p><code>stats::family</code> object to determine how SuperLearner should be fitted.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>SLEnsemble_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>SLEnsemble_cfg$new(
learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
</pre>
</div>


<hr>
<a id="method-SLEnsemble_cfg-add_sublearner"></a>



<h4>Method <code>add_sublearner()</code></h4>

<p>Adds a model (or class of models) to the SuperLearner ensemble.
If hyperparameter values are specified, this method will
add a learner for every element in the cross-product of provided
hyperparameter values.
</p>


<h5>Usage</h5>

<div class="r"><pre>SLEnsemble_cfg$add_sublearner(learner_name, hps = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>learner_name</code></dt><dd><p>Possible values
use <code>SuperLearner</code> naming conventions. A full list is available
with <code>SuperLearner::listWrappers("SL")</code></p>
</dd>
<dt><code>hps</code></dt><dd><p>A named list of hyper-parameters. Every element of the
cross-product of these hyper-parameters will be included in the
ensemble.
cfg &lt;- SLEnsemble_cfg$new(
learner_cfgs = list(SLLearner_cfg$new(&quot;SL.glm&quot;))
)
cfg &lt;- cfg$add_sublearner(&quot;SL.gam&quot;, list(deg.gam = c(2, 3)))</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SLEnsemble_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SLEnsemble_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>SLEnsemble_cfg$new(
learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)

## ------------------------------------------------
## Method `SLEnsemble_cfg$new`
## ------------------------------------------------

SLEnsemble_cfg$new(
learner_cfgs = list(SLLearner_cfg$new("SL.glm"), SLLearner_cfg$new("SL.gam"))
)
</code></pre>

<hr>
<h2 id='SLLearner_cfg'>Configuration of SuperLearner Submodel</h2><span id='topic+SLLearner_cfg'></span>

<h3>Description</h3>

<p><code>SLLearner_cfg</code> is a configuration class for a single
sublearner to be included in SuperLearner. By constructing with a named list
of hyperparameters, this configuration allows distinct submodels
for each unique combination of hyperparameters. To understand what models
and hyperparameters are available, examine the methods listed in
<code>SuperLearner::listWrappers("SL")</code>.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>model_name</code></dt><dd><p>The name of the model as passed to <code>SuperLearner</code>
through the <code>SL.library</code> parameter.</p>
</dd>
<dt><code>hyperparameters</code></dt><dd><p>Named list from hyperparameter name to a vector of
values that should be swept over.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SLLearner_cfg-new"><code>SLLearner_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SLLearner_cfg-clone"><code>SLLearner_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SLLearner_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>SLLearner_cfg</code> object with specified model name and hyperparameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>SLLearner_cfg$new(model_name, hp = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>model_name</code></dt><dd><p>The name of the model as passed to <code>SuperLearner</code>
through the <code>SL.library</code> parameter.</p>
</dd>
<dt><code>hp</code></dt><dd><p>Named list from hyperparameter name to a vector of values that should be
swept over. Hyperparameters not included in this list are left at their SuperLearner
default values.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>SLLearner_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>SLLearner_cfg$new("SL.glm")
SLLearner_cfg$new("SL.gam", list(deg.gam = c(2, 3)))
</pre>
</div>


<hr>
<a id="method-SLLearner_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SLLearner_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `SLLearner_cfg$new`
## ------------------------------------------------

SLLearner_cfg$new("SL.glm")
SLLearner_cfg$new("SL.gam", list(deg.gam = c(2, 3)))
</code></pre>

<hr>
<h2 id='split_data'>Partition the data into folds</h2><span id='topic+split_data'></span>

<h3>Description</h3>

<p>This takes a dataset and a split ID and generates two subsets of the
data corresponding to a training set and a holdout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_data(data, split_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_data_+3A_data">data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="split_data_+3A_split_id">split_id</code></td>
<td>
<p>integer representing the split to construct</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an R6 object <code>HTEFold</code> with three public fields:
</p>

<ul>
<li> <p><code>train</code> - The split to be used for training the plugin estimates
</p>
</li>
<li> <p><code>holdout</code> - The split not used for training
</p>
</li>
<li> <p><code>in_holdout</code> - A logical vector indicating for each unit whether they lie in the holdout.
</p>
</li></ul>


<hr>
<h2 id='Stratified_cfg'>Configuration for a Stratification Estimator</h2><span id='topic+Stratified_cfg'></span>

<h3>Description</h3>

<p><code>Stratified_cfg</code> is a configuration class for stratifying a covariate
and calculating statistics within each cell.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Model_cfg">tidyhte::Model_cfg</a></code> -&gt; <code>Stratified_cfg</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>model_class</code></dt><dd><p>The class of the model, required for all classes
which inherit from <code>Model_cfg</code>.</p>
</dd>
<dt><code>covariate</code></dt><dd><p>The name of the column in the dataset
which corresponds to the covariate on which to stratify.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Stratified_cfg-new"><code>Stratified_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Stratified_cfg-clone"><code>Stratified_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Stratified_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Stratified_cfg</code> object with specified number of evaluation points.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stratified_cfg$new(covariate)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>covariate</code></dt><dd><p>The name of the column in the dataset
which corresponds to the covariate on which to stratify.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Stratified_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>Stratified_cfg$new(covariate = "test_covariate")
</pre>
</div>


<hr>
<a id="method-Stratified_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Stratified_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>
## ------------------------------------------------
## Method `Stratified_cfg$new`
## ------------------------------------------------

Stratified_cfg$new(covariate = "test_covariate")
</code></pre>

<hr>
<h2 id='VIMP_cfg'>Configuration of Variable Importance</h2><span id='topic+VIMP_cfg'></span>

<h3>Description</h3>

<p><code>VIMP_cfg</code> is a configuration class for estimating a variable importance measure
across all moderators. This provides a meaningful measure of which moderators
explain the most of the CATE surface.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>estimand</code></dt><dd><p>String indicating the estimand to target.</p>
</dd>
<dt><code>sample_splitting</code></dt><dd><p>Logical indicating whether to use sample
splitting in the calculation of variable importance.</p>
</dd>
<dt><code>linear</code></dt><dd><p>Logical indicating whether the variable importance
assuming a linear model should be estimated.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-VIMP_cfg-new"><code>VIMP_cfg$new()</code></a>
</p>
</li>
<li> <p><a href="#method-VIMP_cfg-clone"><code>VIMP_cfg$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-VIMP_cfg-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>VIMP_cfg</code> object with specified model configuration.
</p>


<h5>Usage</h5>

<div class="r"><pre>VIMP_cfg$new(sample_splitting = TRUE, linear_only = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>sample_splitting</code></dt><dd><p>Logical indicating whether to use sample splitting
in the calculation of variable importance. Choosing not to use sample
splitting means that inference will only be valid for moderators with
non-null importance.</p>
</dd>
<dt><code>linear_only</code></dt><dd><p>Logical indicating whether the variable importance
should use only a single linear-only model. Variable importance measure
will only be consistent for the population quantity if the true model
of pseudo-outcomes is linear.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>VIMP_cfg</code> object.
</p>



<h5>Examples</h5>

<div class="r example copy">
<pre>VIMP_cfg$new()
</pre>
</div>


<hr>
<a id="method-VIMP_cfg-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>VIMP_cfg$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>


<ul>
<li><p> Williamson, B. D., Gilbert, P. B., Carone, M., &amp; Simon, N. (2021).
Nonparametric variable importance assessment using machine learning techniques.
Biometrics, 77(1), 9-22.
</p>
</li>
<li><p> Williamson, B. D., Gilbert, P. B., Simon, N. R., &amp; Carone, M. (2021).
A general framework for inference on algorithm-agnostic variable importance.
Journal of the American Statistical Association, 1-14.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>VIMP_cfg$new()

## ------------------------------------------------
## Method `VIMP_cfg$new`
## ------------------------------------------------

VIMP_cfg$new()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
