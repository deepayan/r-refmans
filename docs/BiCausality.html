<!DOCTYPE html><html><head><title>Help for package BiCausality</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BiCausality}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjustmentProb'><p>adjustmentProb function</p></a></li>
<li><a href='#assocSignTest'><p>indpFunc function</p></a></li>
<li><a href='#bin2dec'><p>bin2dec function</p></a></li>
<li><a href='#bIndpTest'><p>bIndpTest function</p></a></li>
<li><a href='#bSCMCausalGraphFunc'><p>bSCMCausalGraphFunc function</p></a></li>
<li><a href='#bSCMdeConfoundingGraphFunc'><p>bSCMdeConfoundingGraphFunc function</p></a></li>
<li><a href='#bSCMDepndentGraphFastFunc'><p>bSCMDepndentGraphFastFunc function</p></a></li>
<li><a href='#bSCMDepndentGraphFunc'><p>bSCMDepndentGraphFunc function</p></a></li>
<li><a href='#CausalGraphInferMainFunc'><p>CausalGraphInferMainFunc function</p></a></li>
<li><a href='#comparePredAdjMatrix2TrueAdjMat'><p>comparePredAdjMatrix2TrueAdjMat</p></a></li>
<li><a href='#CondProb'><p>CondProb function</p></a></li>
<li><a href='#confNetFunc'><p>confNetFunc function</p></a></li>
<li><a href='#D'><p>An example of aligned list of transactions</p></a></li>
<li><a href='#getReachableNodes'><p>getReachableNodes function</p></a></li>
<li><a href='#getTransitiveClosureMat'><p>getTransitiveClosureMat function</p></a></li>
<li><a href='#indpFunc'><p>indpFunc function</p></a></li>
<li><a href='#mat'><p>A simulation dataset</p></a></li>
<li><a href='#num2Bits'><p>num2Bits function</p></a></li>
<li><a href='#oddDiffFunc'><p>oddDiffFunc function</p></a></li>
<li><a href='#oddRatioFunc'><p>oddRatioFunc function</p></a></li>
<li><a href='#resC'><p>An example of causal inference result</p></a></li>
<li><a href='#supp'><p>supp function</p></a></li>
<li><a href='#VecAlignment'><p>VecAlignment function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Binary Causality Inference Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chainarong Amornbunchornvej &lt;grandca@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A framework to infer causality on binary data using techniques in frequent pattern mining and estimation statistics. Given a set of individual vectors S={x} where x(i) is a realization value of binary variable i, the framework infers empirical causal relations of binary variables i,j from S in a form of causal graph G=(V,E) where V is a set of nodes representing binary variables and there is an edge from i to j in E if the variable i causes j. The framework determines dependency among variables as well as analyzing confounding factors before deciding whether i causes j.  The publication of this package is at Chainarong Amornbunchornvej, Navaporn Surasvadi, Anon Plangprasopchok, and Suttipong Thajchayapong (2023) &lt;<a href="https://doi.org/10.1016%2Fj.heliyon.2023.e15947">doi:10.1016/j.heliyon.2023.e15947</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DarkEyes/BiCausality">https://github.com/DarkEyes/BiCausality</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DarkEyes/BiCausality/issues">https://github.com/DarkEyes/BiCausality/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, markdown, igraph</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-28 03:49:38 UTC; 006005</td>
</tr>
<tr>
<td>Author:</td>
<td>Chainarong Amornbunchornvej
    <a href="https://orcid.org/0000-0003-3131-0370"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-28 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjustmentProb'>adjustmentProb function</h2><span id='topic+adjustmentProb'></span>

<h3>Description</h3>

<p>This function evaluates the P(Y=yflag|do(X=xflag)) given only marginal distributions using parent adjustment method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustmentProb(EValHat, mat, yflag = 1, xflag = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustmentProb_+3A_evalhat">EValHat</code></td>
<td>
<p>is an adjacency matrix of weighted directed causal graph where edge weights are P(Y=yflag|X=xflag) or probabilities of effect being 1 given cause being either 1 for positive association or 0 for negative association.</p>
</td></tr>
<tr><td><code id="adjustmentProb_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
<tr><td><code id="adjustmentProb_+3A_yflag">yflag</code></td>
<td>
<p>is value set for Y in P(Y=yflag|X=xflag,z) for the adjustment method.</p>
</td></tr>
<tr><td><code id="adjustmentProb_+3A_xflag">xflag</code></td>
<td>
<p>is value set for X in P(Y=yflag|X=xflag,z) for the adjustment method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an adjacency matrix of weighted directed causal graph where the edge weights are P(Y=yflag|do(X=xflag) ).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adjustmentProb(resC$CausalGRes$EValHat,mat)

</code></pre>

<hr>
<h2 id='assocSignTest'>indpFunc function</h2><span id='topic+assocSignTest'></span>

<h3>Description</h3>

<p>This function provides association signs (positive/negative association) inference between i and j.
If there is a positive association, it implies i and j trend to have a similar value.
For a negative association, however, i and j trend to have an opposite value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assocSignTest(mat, i, j, z = c(), alpha = 0.05, IndpThs = 0.05, nboot = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assocSignTest_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
<tr><td><code id="assocSignTest_+3A_i">i</code></td>
<td>
<p>is an ith dimension in <code>mat</code>.</p>
</td></tr>
<tr><td><code id="assocSignTest_+3A_j">j</code></td>
<td>
<p>is an jth dimension in <code>mat</code>.</p>
</td></tr>
<tr><td><code id="assocSignTest_+3A_z">z</code></td>
<td>
<p>is a conditioning d-dimensional vector on <code>mat</code>.
Given k non-negative-bit positions of <code>z</code>, all k bit positions of samples in the subset of <code>mat</code> must have similar values with these bits.</p>
</td></tr>
<tr><td><code id="assocSignTest_+3A_alpha">alpha</code></td>
<td>
<p>is a significance threshold for hypothesis tests (Mann Whitney)
that deploys for testing degrees of dependency, association direction, and causal direction. The default is 0.5.</p>
</td></tr>
<tr><td><code id="assocSignTest_+3A_indpths">IndpThs</code></td>
<td>
<p>is a threshold for the degree of dependency. In the independence test, to claim that any variables are dependent, the dependency degree must greater than this value significantly. The default is 0.05.</p>
</td></tr>
<tr><td><code id="assocSignTest_+3A_nboot">nboot</code></td>
<td>
<p>is a number of bootstrap replicates for bootstrapping deployed to infer confidence intervals and distributions for hypothesis tests. The default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns results of inference of association signs (positive/negative association) between i and j.
</p>
<table>
<tr><td><code>bmean</code></td>
<td>
<p>A mean of sign dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>confInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of sign dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>testRes</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for an independence test between variables i and j. The null hypothesis is that the distributions of dependency degrees of i,j differ by a location shift of <code>IndpThs</code> and the alternative is  that distributions of dependency degrees of i,j is shifted greater than <code>IndpThs</code>. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>assocSignTest(mat=mat,i=1,j=2)
</code></pre>

<hr>
<h2 id='bin2dec'>bin2dec function</h2><span id='topic+bin2dec'></span>

<h3>Description</h3>

<p>This function convertes a binary vector into its decimal value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin2dec(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin2dec_+3A_x">X</code></td>
<td>
<p>is a binary vector where <code>X[i]</code> is the ith bit of vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a decimal value of <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin2dec(X=c(1,1,1,0))

</code></pre>

<hr>
<h2 id='bIndpTest'>bIndpTest function</h2><span id='topic+bIndpTest'></span>

<h3>Description</h3>

<p>This function infers dependency for a pair of variables i,j with bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bIndpTest(
  mat,
  i,
  j,
  z = c(),
  alpha = 0.05,
  IndpThs = 0.05,
  nboot = 100,
  pflag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bIndpTest_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
<tr><td><code id="bIndpTest_+3A_i">i</code></td>
<td>
<p>is an ith dimension in <code>mat</code>.</p>
</td></tr>
<tr><td><code id="bIndpTest_+3A_j">j</code></td>
<td>
<p>is an jth dimension in <code>mat</code>.</p>
</td></tr>
<tr><td><code id="bIndpTest_+3A_z">z</code></td>
<td>
<p>is a conditioning d-dimensional vector on <code>mat</code>.
Given k non-negative-bit positions of <code>z</code>, all k bit positions of samples in the subset of <code>mat</code> must have similar values with these bits.</p>
</td></tr>
<tr><td><code id="bIndpTest_+3A_alpha">alpha</code></td>
<td>
<p>is a significance threshold for hypothesis tests (Mann Whitney)
that deploys for testing degrees of dependency, association direction, and causal direction. The default is 0.5.</p>
</td></tr>
<tr><td><code id="bIndpTest_+3A_indpths">IndpThs</code></td>
<td>
<p>is a threshold for the degree of dependency. In the independence test, to claim that any variables are dependent, the dependency degree must greater than this value significantly. The default is 0.05.</p>
</td></tr>
<tr><td><code id="bIndpTest_+3A_nboot">nboot</code></td>
<td>
<p>is a number of bootstrap replicates for bootstrapping deployed to infer confidence intervals and distributions for hypothesis tests. The default is 100.</p>
</td></tr>
<tr><td><code id="bIndpTest_+3A_pflag">pflag</code></td>
<td>
<p>is a flag for printing progress message (TRUE). The default is FALSE (no printing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns results of dependency inference between i and j.
</p>
<table>
<tr><td><code>bmean</code></td>
<td>
<p>A mean of dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>confInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>testRes</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for an independence test between variables i and j. The null hypothesis is that the distributions of dependency degrees of i,j differ by a location shift of <code>IndpThs</code> and the alternative is  that distributions of dependency degrees of i,j is shifted greater than <code>IndpThs</code>. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bIndpTest(mat=mat,i=1,j=2)


</code></pre>

<hr>
<h2 id='bSCMCausalGraphFunc'>bSCMCausalGraphFunc function</h2><span id='topic+bSCMCausalGraphFunc'></span>

<h3>Description</h3>

<p>This function infers a causal graph from a result of confounding factor filtering by <code>bSCMdeConfoundingGraphFunc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bSCMCausalGraphFunc(E1, Dboot, alpha = 0.05, SignThs = 0.05, CausalThs = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bSCMCausalGraphFunc_+3A_e1">E1</code></td>
<td>
<p>is an adjacency matrix of undirected graph after filtering associations without true causal directions from any confounding factor.</p>
</td></tr>
<tr><td><code id="bSCMCausalGraphFunc_+3A_dboot">Dboot</code></td>
<td>
<p>is a list of <code>D</code>s (aligned list of transactions) that are generated from sampling with replacement on input samples (<code>mat</code>) <code>nboot</code> times.</p>
</td></tr>
<tr><td><code id="bSCMCausalGraphFunc_+3A_alpha">alpha</code></td>
<td>
<p>is a significance threshold for hypothesis tests (Mann Whitney)
that deploys for testing degrees of dependency, association direction, and causal direction. The default is 0.5.</p>
</td></tr>
<tr><td><code id="bSCMCausalGraphFunc_+3A_signths">SignThs</code></td>
<td>
<p>is a threshold for the degree of dependency for association direction inference. In the independence test of sign direction, to claim that any variables are dependent, the dependency degree must greater than this value significantly. The default is 0.05.</p>
</td></tr>
<tr><td><code id="bSCMCausalGraphFunc_+3A_causalths">CausalThs</code></td>
<td>
<p>is a threshold for the degree of causal direction In the causal-direction test, to claim that any variables have causal relations, the degree of causal direction must greater than this value significantly. The default is 0.1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns causal inference results from E1 matrix that is an output of <code>bSCMdeConfoundingGraphFunc</code>.
</p>
<table>
<tr><td><code>Ehat</code></td>
<td>
<p>An adjacency matrix of directed causal graph where <code>CausalGRes$Ehat[i,j]=1</code> implies i causes j.</p>
</td></tr>
<tr><td><code>EValHat</code></td>
<td>
<p>An adjacency matrix of weighted directed causal graph where edge weights are estimated means of probabilities of effect being 1 given cause being either 1 for positive association or 0 for negative association using CondProb() and bootstrapping to estimate.</p>
</td></tr>
<tr><td><code>i</code></td>
<td>
<p>An index</p>
</td></tr>
<tr><td><code>j</code></td>
<td>
<p>An index</p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$CDirConfValInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of estimated conditional probability of effect j being 1/0 given cause i's value being either the same (positive association) or opposite (negative association).</p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$CDirConfInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of estimated causal direction degree of i cause j. </p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$CDirmean</code></td>
<td>
<p>A mean-estimated-causal-direction degree of i cause j.</p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$testRes2</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for existence of causal direction. The null hypothesis is that the distributions of causal-direction degrees of i,j differ by a location shift of <code>CausalThs</code> and the alternative is  that distributions of causal-direction degrees of i,j is shifted greater than <code>CausalThs</code>.</p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$testRes1</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for existence of association by odd differences from <code>oddDiffFunc()</code>. The null hypothesis is that the distributions of absolute odd difference of i,j differ by a location shift of <code>IndpThs</code> and the alternative is  that distributions of absolute odd difference of i,j is shifted greater than <code>IndpThs</code>.</p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$sign</code></td>
<td>
<p>A direction of i,j association: 1 for positive, 0 for negative, and -1 for no association.</p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$SignConfInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of i,j odd difference from bootstrapping. </p>
</td></tr>
<tr><td><code>causalInfo$'i</code>, <code>j'$Signmean</code></td>
<td>
<p>A mean of i,j odd difference from bootstrapping.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bSCMCausalGraphFunc(resC$ConfoundRes$E1,resC$depRes$Dboot)
</code></pre>

<hr>
<h2 id='bSCMdeConfoundingGraphFunc'>bSCMdeConfoundingGraphFunc function</h2><span id='topic+bSCMdeConfoundingGraphFunc'></span>

<h3>Description</h3>

<p>This function removes any association/dependency of variables i,j that have any confounding factor k s.t. given k, i and j are independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bSCMdeConfoundingGraphFunc(dat, IndpThs = 0.05, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bSCMdeConfoundingGraphFunc_+3A_dat">dat</code></td>
<td>
<p>is the result of inferring dependencies between all pairs of variables from <code>bSCMDepndentGraphFunc()</code>.</p>
</td></tr>
<tr><td><code id="bSCMdeConfoundingGraphFunc_+3A_indpths">IndpThs</code></td>
<td>
<p>is a threshold for the degree of dependency. In the independence test, to claim that any variables are dependent, the dependency degree must greater than this value significantly. The default is 0.05.</p>
</td></tr>
<tr><td><code id="bSCMdeConfoundingGraphFunc_+3A_alpha">alpha</code></td>
<td>
<p>is a significance threshold for hypothesis tests (Mann Whitney)
that deploys for testing degrees of dependency, association direction, and causal direction. The default is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an adjacency matrix of dependencies that have no confounding factors.
</p>
<table>
<tr><td><code>E1</code></td>
<td>
<p>An adjacency matrix of undirected graph after filtering associations without true causal directions from any confounding factor.</p>
</td></tr>
<tr><td><code>E2</code></td>
<td>
<p>A matrix of associations that have confounding factors where <code>E2[i,j]=0</code> if no confounding factor and <code>E2[i,j]=k</code> if k is a confounding factor of i and j.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bSCMdeConfoundingGraphFunc(resC$depRes)

</code></pre>

<hr>
<h2 id='bSCMDepndentGraphFastFunc'>bSCMDepndentGraphFastFunc function</h2><span id='topic+bSCMDepndentGraphFastFunc'></span>

<h3>Description</h3>

<p>This function infers dependencies for all pairs of variables without bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bSCMDepndentGraphFastFunc(mat, IndpThs = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bSCMDepndentGraphFastFunc_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
<tr><td><code id="bSCMDepndentGraphFastFunc_+3A_indpths">IndpThs</code></td>
<td>
<p>is a threshold for the degree of dependency. In the independence test, to claim that any variables are dependent, the dependency degree must greater than this value significantly. The default is 0.05.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns results of dependency inference among variables.
</p>
<table>
<tr><td><code>E0</code></td>
<td>
<p>An adjacency matrix of undirected graph where there is an edge between any pair of variables if they are dependent.</p>
</td></tr>
<tr><td><code>E0raw</code></td>
<td>
<p>A matrix of the degree of dependency of variable pairs.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bSCMDepndentGraphFastFunc(mat)


</code></pre>

<hr>
<h2 id='bSCMDepndentGraphFunc'>bSCMDepndentGraphFunc function</h2><span id='topic+bSCMDepndentGraphFunc'></span>

<h3>Description</h3>

<p>This function infers dependencies for all pairs of variables with bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bSCMDepndentGraphFunc(
  mat,
  nboot = 100,
  alpha = 0.05,
  IndpThs = 0.05,
  pflag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bSCMDepndentGraphFunc_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
<tr><td><code id="bSCMDepndentGraphFunc_+3A_nboot">nboot</code></td>
<td>
<p>is a number of bootstrap replicates for bootstrapping deployed to infer confidence intervals and distributions for hypothesis tests. The default is 100.</p>
</td></tr>
<tr><td><code id="bSCMDepndentGraphFunc_+3A_alpha">alpha</code></td>
<td>
<p>is a significance threshold for hypothesis tests (Mann Whitney)
that deploys for testing degrees of dependency, association direction, and causal direction. The default is 0.5.</p>
</td></tr>
<tr><td><code id="bSCMDepndentGraphFunc_+3A_indpths">IndpThs</code></td>
<td>
<p>is a threshold for the degree of dependency. In the independence test, to claim that any variables are dependent, the dependency degree must greater than this value significantly. The default is 0.05.</p>
</td></tr>
<tr><td><code id="bSCMDepndentGraphFunc_+3A_pflag">pflag</code></td>
<td>
<p>is a flag for printing progress message (TRUE). The default is FALSE (no printing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns results of dependency inference among variables.
</p>
<table>
<tr><td><code>E0</code></td>
<td>
<p>An adjacency matrix of undirected graph where there is an edge between any pair of variables if they are dependent.</p>
</td></tr>
<tr><td><code>E0pval</code></td>
<td>
<p>A matrix of p-values from independence test of pairs of variables.</p>
</td></tr>
<tr><td><code>E0mean</code></td>
<td>
<p>A matrix of means of dependency degrees between variables.</p>
</td></tr>
<tr><td><code>E0lowbound</code></td>
<td>
<p>A matrix of lower bounds of dependency-degree confidence intervals between variables.</p>
</td></tr>
<tr><td><code>depInfo$'i</code>, <code>j'$bmean</code></td>
<td>
<p>A mean of dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>depInfo$'i</code>, <code>j'$confInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>depInfo$'i</code>, <code>j'$testRes</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for an independence test between variables i and j. The null hypothesis is that the distributions of dependency degrees of i,j differ by a location shift of <code>IndpThs</code> and the alternative is  that distributions of dependency degrees of i,j is shifted greater than <code>IndpThs</code>. </p>
</td></tr>
<tr><td><code>depInfo$'i</code>, <code>j'$indices</code></td>
<td>
<p>A pair of indices of i and j in a numeric vector.</p>
</td></tr>
<tr><td><code>Dboot</code></td>
<td>
<p>A list of <code>D</code>s (aligned list of transactions) that are generated from sampling with replacement on input samples (<code>mat</code>) <code>nboot</code> times. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bSCMDepndentGraphFunc(mat, nboot=50)

</code></pre>

<hr>
<h2 id='CausalGraphInferMainFunc'>CausalGraphInferMainFunc function</h2><span id='topic+CausalGraphInferMainFunc'></span>

<h3>Description</h3>

<p>A framework to infer causality on binary data using techniques in frequent pattern mining and estimation statistics. Given a set of individual vectors S={x} where x(i) is a realization value of binary variable i, the framework infers empirical causal relations of binary variables i,j from S in a form of causal graph G=(V,E) where V is a set of nodes representing binary variables and there is an edge from i to j in E if the variable i causes j. The framework determines dependency among variables as well as analyzing confounding factors before deciding whether i causes j.
</p>
<p>Note that all statistics (e.g. means) and confidence intervals as well as hypothesis testing are inferred by bootstrapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CausalGraphInferMainFunc(
  mat,
  alpha = 0.05,
  nboot = 100,
  IndpThs = 0.05,
  CausalThs = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CausalGraphInferMainFunc_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
<tr><td><code id="CausalGraphInferMainFunc_+3A_alpha">alpha</code></td>
<td>
<p>is a significance threshold for hypothesis tests (Mann Whitney)
that deploys for testing degrees of dependency, association direction, and causal direction. The default is 0.5.</p>
</td></tr>
<tr><td><code id="CausalGraphInferMainFunc_+3A_nboot">nboot</code></td>
<td>
<p>is a number of bootstrap replicates for bootstrapping deployed to infer confidence intervals and distributions for hypothesis tests. The default is 100.</p>
</td></tr>
<tr><td><code id="CausalGraphInferMainFunc_+3A_indpths">IndpThs</code></td>
<td>
<p>is a threshold for the degree of dependency. In the independence test, to claim that any variables are dependent, the dependency degree must greater than this value significantly. The default is 0.05.</p>
</td></tr>
<tr><td><code id="CausalGraphInferMainFunc_+3A_causalths">CausalThs</code></td>
<td>
<p>is a threshold for the degree of causal direction In the causal-direction test, to claim that any variables have causal relations, the degree of causal direction must greater than this value significantly. The default is 0.1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns causal inference results. #TODO: provide list of results.
</p>
<table>
<tr><td><code>depRes</code></td>
<td>
<p>The result of inferring dependencies between all pairs of variables.</p>
</td></tr>
<tr><td><code>ConfoundRes</code></td>
<td>
<p>The result of filtering associations without true causal directions from any confounding factor.</p>
</td></tr>
<tr><td><code>CausalGRes</code></td>
<td>
<p>The result of inferring causal directions between all pairs of dependent variables that have no confounding factors.</p>
</td></tr>
<tr><td><code>depRes$E0</code></td>
<td>
<p>An adjacency matrix of undirected graph where there is an edge between any pair of variables if they are dependent.</p>
</td></tr>
<tr><td><code>depRes$E0pval</code></td>
<td>
<p>A matrix of p-values from independence test of pairs of variables.</p>
</td></tr>
<tr><td><code>depRes$E0mean</code></td>
<td>
<p>A matrix of means of dependency degrees between variables.</p>
</td></tr>
<tr><td><code>depRes$E0lowbound</code></td>
<td>
<p>A matrix of lower bounds of dependency-degree confidence intervals between variables.</p>
</td></tr>
<tr><td><code>depRes$depInfo$'i</code>, <code>j'$bmean</code></td>
<td>
<p>A mean of dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>depRes$depInfo$'i</code>, <code>j'$confInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of dependency degrees between variables i and j.</p>
</td></tr>
<tr><td><code>depRes$depInfo$'i</code>, <code>j'$testRes</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for an independence test between variables i and j. The null hypothesis is that the distributions of dependency degrees of i,j differ by a location shift of <code>IndpThs</code> and the alternative is  that distributions of dependency degrees of i,j is shifted greater than <code>IndpThs</code>. </p>
</td></tr>
<tr><td><code>depRes$depInfo$'i</code>, <code>j'$indices</code></td>
<td>
<p>A pair of indices of i and j in a numeric vector.</p>
</td></tr>
<tr><td><code>depRes$Dboot</code></td>
<td>
<p>A list of <code>D</code>s (aligned list of transactions) that are generated from sampling with replacement on input samples (<code>mat</code>) <code>nboot</code> times. </p>
</td></tr>
<tr><td><code>ConfoundRes$E1</code></td>
<td>
<p>An adjacency matrix of undirected graph after filtering associations without true causal directions from any confounding factor.</p>
</td></tr>
<tr><td><code>ConfoundRes$E2</code></td>
<td>
<p>A matrix of associations that have confounding factors where <code>E2[i,j]=0</code> if no confounding factor and <code>E2[i,j]=k</code> if k is a confounding factor of i and j.</p>
</td></tr>
<tr><td><code>CausalGRes$Ehat</code></td>
<td>
<p>An adjacency matrix of directed causal graph where <code>CausalGRes$Ehat[i,j]=1</code> implies i causes j.</p>
</td></tr>
<tr><td><code>CausalGRes$EValHat</code></td>
<td>
<p>An adjacency matrix of weighted directed causal graph where edge weights are estimated means of probabilities of effect being 1 given cause being either 1 for positive association or 0 for negative association using CondProb() and bootstrapping to estimate</p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$CDirConfValInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of estimated conditional probability of effect j being 1/0 given cause i's value being either the same (positive association) or opposite (negative association).</p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$CDirConfInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of estimated causal direction degree of i cause j. </p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$CDirmean</code></td>
<td>
<p>A mean-estimated-causal-direction degree of i cause j.</p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$testRes2</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for existence of causal direction. The null hypothesis is that the distributions of causal-direction degrees of i,j differ by a location shift of <code>CausalThs</code> and the alternative is  that distributions of causal-direction degrees of i,j is shifted greater than <code>CausalThs</code>.</p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$testRes1</code></td>
<td>
<p>A Mann-Whitney hypothesis test result for existence of association by odd differences from <code>oddDiffFunc()</code>. The null hypothesis is that the distributions of absolute odd difference of i,j differ by a location shift of <code>IndpThs</code> and the alternative is  that distributions of absolute odd difference of i,j is shifted greater than <code>IndpThs</code>.</p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$sign</code></td>
<td>
<p>A direction of i,j association: 1 for positive, 0 for negative, and -1 for no association.</p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$SignConfInv</code></td>
<td>
<p>An <code>alpha</code>*100th percentile confidence interval of i,j odd difference from bootstrapping. </p>
</td></tr>
<tr><td><code>CausalGRes$causalInfo$'i</code>, <code>j'$Signmean</code></td>
<td>
<p>A mean of i,j odd difference from bootstrapping.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>resC&lt;-CausalGraphInferMainFunc(mat = mat, nboot =50)

</code></pre>

<hr>
<h2 id='comparePredAdjMatrix2TrueAdjMat'>comparePredAdjMatrix2TrueAdjMat</h2><span id='topic+comparePredAdjMatrix2TrueAdjMat'></span>

<h3>Description</h3>

<p>comparePredAdjMatrix2TrueAdjMat is a support function that can compare two adjacency matrices: ground-truth and inferred matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparePredAdjMatrix2TrueAdjMat(trueAdjMat, adjMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comparePredAdjMatrix2TrueAdjMat_+3A_trueadjmat">trueAdjMat</code></td>
<td>
<p>a ground-truth matrix.</p>
</td></tr>
<tr><td><code id="comparePredAdjMatrix2TrueAdjMat_+3A_adjmat">adjMat</code></td>
<td>
<p>an inferred matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a list of precision <code>prec</code>, recall <code>rec</code>, and F1 score <code>F1</code> of inferred vs. groundtruth matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate simulation data
G&lt;-matrix(FALSE,10,10) # groundtruth
G[1,c(4,7,8,10)]&lt;-TRUE
G[2,c(5,7,9,10)]&lt;-TRUE
G[3,c(6,8,9,10)]&lt;-TRUE
comparePredAdjMatrix2TrueAdjMat(trueAdjMat=G,adjMat=G)

</code></pre>

<hr>
<h2 id='CondProb'>CondProb function</h2><span id='topic+CondProb'></span>

<h3>Description</h3>

<p>This function computes a confidence value of <code>y</code> given <code>c</code>
or <code>conf(y|z)</code> from an aligned list <code>D</code>.
For any<code>y[i],z[j]</code>, their values are -1 by default.
The function computes the numbers of transactions
that satisfy the following conditions.
</p>

<ol>
<li><p> All transactions must have values at any k position equal to <code>z[k]</code>
for any <code>z[k]</code> that is not -1.
Let <code>count</code> be the number of these transactions in <code>D</code>.
</p>
</li>
<li><p> All transactions must have values at any k position equal to either <code>z[k]</code> or <code>y[k]</code>
that is not -1. Let <code>countTotal</code> be the number of these transactions in <code>D</code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>CondProb(D, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CondProb_+3A_d">D</code></td>
<td>
<p>is an aligned list of transactions that was converted from any matrix n by d <code>mat</code> using
<code>D&lt;-VecAlignment(mat)</code> where n is a number of transactions or samples
and d is a number of dimensions for each sample.</p>
</td></tr>
<tr><td><code id="CondProb_+3A_y">y</code></td>
<td>
<p>is a d-dimensional vector.</p>
</td></tr>
<tr><td><code id="CondProb_+3A_z">z</code></td>
<td>
<p>is a d-dimensional vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the ratio <code>condP=count/countTotal</code>, which is the confidence of <code>y</code> given <code>z</code>.
</p>
<table>
<tr><td><code>condP</code></td>
<td>
<p>The confidence of <code>y</code> given <code>z</code> in <code>D</code>. </p>
</td></tr>
<tr><td><code>nD</code></td>
<td>
<p> The subset of <code>D</code> such that all transactions
have values at any position similar to <code>z[k]</code> when <code>z[k]</code> is not -1. </p>
</td></tr>
<tr><td><code>count</code></td>
<td>
<p> A number of transactions that have values at any position similar
to either <code>z[k]</code> or <code>y[k]</code> that is not -1. </p>
</td></tr>
<tr><td><code>countTotal</code></td>
<td>
<p> A number of transactions in <code>nD</code> </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d=10 # dimensions of example vectors
z&lt;-numeric(d)-1
y&lt;-numeric(d)-1
y[1]&lt;-c(1)
z[c(2,3)]&lt;-c(1,1)
CondProb(BiCausality::D,y=y,z=z)$condP # conf(inx1 is 1 |inx 2,3 are 1 ) y|z

</code></pre>

<hr>
<h2 id='confNetFunc'>confNetFunc function</h2><span id='topic+confNetFunc'></span>

<h3>Description</h3>

<p>This function Computes a confidence network in data mining.
Given a set of n transactions or samples in <code>mat</code> s.t. each transaction has d binary items.
The  <code>conf(mat[,j]=1|mat[,i]=1)</code> is a ratio of a number of samples in jth and ith dimensions that have values equal to
one divided by a number of samples in the ith dimension that has a value equal to one.
The confNetFunc computes the network where the nodes are dimensions and the edge weights are <code>conf(mat[,j]=1|mat[,i]=1)</code> for any directed edge from i to j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confNetFunc(mat, ths = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confNetFunc_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
<tr><td><code id="confNetFunc_+3A_ths">ths</code></td>
<td>
<p>is a threshold parameter for cutting of the edge weights. There exists the directed edge from i to j if its edge weight if above or equal <code>ths</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns  a binary adjacency matrix <code>confNet</code> and the weighted adjacency matrix <code>confValMat</code>.
</p>
<table>
<tr><td><code>confNet</code></td>
<td>
<p>A binary adjacency matrix that has <code>confNet[i,j]=1</code> if <code>confValMat[i,j]&gt;=ths</code>. Otherwise, it is zero.</p>
</td></tr>
<tr><td><code>confValMat</code></td>
<td>
<p>A weighted adjacency matrix where <code>confValMat[i,j]</code> is <code>conf(mat[,j]=1|mat[,i]=1)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>res&lt;-confNetFunc(mat)

</code></pre>

<hr>
<h2 id='D'>An example of aligned list of transactions</h2><span id='topic+D'></span>

<h3>Description</h3>

<p>A dataset containing simulated data that is used for examples in the package.
</p>
<p>The <code>D</code> is an aligned list of transactions that was converted by using <code>D&lt;-VecAlignment(mat)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D
</code></pre>


<h3>Format</h3>

<p>An aligned list of a matrix with 200 samples and 10 dimensions generated from Bernoulli distribution.
</p>

<dl>
<dt>D</dt><dd><p>It is an aligned list of transactions that was converted from <code>mat</code>.</p>
</dd>
</dl>


<hr>
<h2 id='getReachableNodes'>getReachableNodes function</h2><span id='topic+getReachableNodes'></span>

<h3>Description</h3>

<p>getReachableNodes is a support function for inferring reachable nodes that have some directed path to a node <code>targetNode</code>.
This function uses Breadth-first search (BFS) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getReachableNodes(adjMat, targetNode)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getReachableNodes_+3A_adjmat">adjMat</code></td>
<td>
<p>is an adjacency matrix of a  directed graph of which its elements are binary: zero for no edge, and one for having an edge.</p>
</td></tr>
<tr><td><code id="getReachableNodes_+3A_targetnode">targetNode</code></td>
<td>
<p>is a node in a graph that we want to find a set of nodes that can reach this target node via some paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a set of node IDs that have some directed path to a node <code>targetNode</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Given an example of adjacency matrix
A&lt;-matrix(FALSE,5,5)
A[2,1]&lt;-TRUE
A[c(3,4),2]&lt;-TRUE
A[5,3]&lt;-TRUE
# Get a set of reachable nodes of targetNode.

followers&lt;-getReachableNodes(adjMat=A,targetNode=1)

</code></pre>

<hr>
<h2 id='getTransitiveClosureMat'>getTransitiveClosureMat function</h2><span id='topic+getTransitiveClosureMat'></span>

<h3>Description</h3>

<p>getTransitiveClosureMat is a support function for inferring a transitive-closure adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTransitiveClosureMat(adjMat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTransitiveClosureMat_+3A_adjmat">adjMat</code></td>
<td>
<p>is an adjacency matrix of a  directed graph of which its elements are binary: zero for no edge, and one for having an edge.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a transitive-closure adjacency matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Given an example of adjacency matrix
A&lt;-matrix(FALSE,5,5)
A[2,1]&lt;-TRUE
A[c(3,4),2]&lt;-TRUE
A[5,3]&lt;-TRUE
# Get a set of reachable nodes of targetNode.

trsClosureMat&lt;-getTransitiveClosureMat(adjMat=A)

</code></pre>

<hr>
<h2 id='indpFunc'>indpFunc function</h2><span id='topic+indpFunc'></span>

<h3>Description</h3>

<p>This function computes the degree of dependency between variables.
Let i and j be variables, if they are independent, then |p(i,j) -p(i)*p(j)| should be zero.
Given the samples in the n by d matrix <code>mat</code> where n is a number of samples and d is a number of dimensions,
an aligned list of transactions <code>D</code> is computed by
<code>D&lt;-VecAlignment(mat)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indpFunc(D, i, j, z = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indpFunc_+3A_d">D</code></td>
<td>
<p>is an aligned list of transactions that was converted from <code>mat</code>.</p>
</td></tr>
<tr><td><code id="indpFunc_+3A_i">i</code></td>
<td>
<p>is an ith dimension in <code>mat</code>.</p>
</td></tr>
<tr><td><code id="indpFunc_+3A_j">j</code></td>
<td>
<p>is an jth dimension in <code>mat</code>.</p>
</td></tr>
<tr><td><code id="indpFunc_+3A_z">z</code></td>
<td>
<p>is a conditioning d-dimensional vector on <code>D</code>.
Given k non-negative-bit positions of <code>z</code>, all k bit positions of samples in the subset of <code>D</code> must have similar values with these bits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the degree of dependency between variables:
zero implies both variables are independent, and non-zero value implies the degree of dependency (higher implies more dependent degree).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>indpFunc(D,i=1,j=2)

</code></pre>

<hr>
<h2 id='mat'>A simulation dataset</h2><span id='topic+mat'></span>

<h3>Description</h3>

<p>A dataset containing simulated data that is used for examples in the package.
The matrix <code>mat</code> is generated by the following code.
</p>
<p><code>seedN&lt;-2022</code>
</p>
<p><code>n&lt;-200</code> # 200 individuals
</p>
<p><code>d&lt;-10</code> # 10 variables
</p>
<p><code>mat&lt;-matrix(nrow=n,ncol=d)</code> # the input of framework
</p>
<p>#Simulate binary data from Bernoulli distribution distribution where the probability of value being 1 is 0.5.
</p>
<p><code>for(i in seq(n)) </code>
<code> { set.seed(seedN+i) </code>
</p>
<p><code>  mat[i,] &lt;- rbinom(n=d, size=1, prob=0.5) } </code>
</p>
<p><code>mat[,1]&lt;-mat[,2] | mat[,3] </code> # 1 causes by 2 and 3
</p>
<p><code>mat[,4] &lt;-mat[,2] | mat[,5] </code># 4 causes by 2 and 5
</p>
<p><code>mat[,6] &lt;- mat[,1] | mat[,4] </code> # 6 causes by 1 and 4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat
</code></pre>


<h3>Format</h3>

<p>A matrix with 200 samples and 10 dimensions generated from Bernoulli distribution.
</p>

<dl>
<dt>mat</dt><dd><p> It is a 200 by 10 matrix where n is a number of transactions or samples and d is a number of dimensions.</p>
</dd>
</dl>
<p>...

</p>

<hr>
<h2 id='num2Bits'>num2Bits function</h2><span id='topic+num2Bits'></span>

<h3>Description</h3>

<p>Given a natural number and number of bits, the function provides an n-dimensional vector of bits that represents <code>num</code>.
The ith bits of binary vector represents the ith bit of <code>num</code>.
For example, if <code>vec&lt;-num2Bits(num=2,n=4)</code>, the first bit <code>vec[1]</code> is 0 and the second bit <code>vec[2]</code> is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>num2Bits(num, n = 32)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="num2Bits_+3A_num">num</code></td>
<td>
<p>is a natural number.</p>
</td></tr>
<tr><td><code id="num2Bits_+3A_n">n</code></td>
<td>
<p>is a number of bits representing <code>num</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an n-dimensional vector of bits that represents <code>num</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num2Bits(num=10,n=4)

</code></pre>

<hr>
<h2 id='oddDiffFunc'>oddDiffFunc function</h2><span id='topic+oddDiffFunc'></span>

<h3>Description</h3>

<p>Given the samples in the n by d matrix <code>mat</code> where n is a number of samples and d is a number of dimensions.
This function computes an odd difference value of variables of ith and jth dimensions from
a given an aligned list of transactions <code>D</code> (compute by <code>D&lt;-VecAlignment(mat)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oddDiffFunc(D, i, j, z = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oddDiffFunc_+3A_d">D</code></td>
<td>
<p>is an aligned list of transactions that was converted from <code>mat</code>.</p>
</td></tr>
<tr><td><code id="oddDiffFunc_+3A_i">i</code></td>
<td>
<p>is an ith dimension in <code>mat</code> for computing the odd difference with.</p>
</td></tr>
<tr><td><code id="oddDiffFunc_+3A_j">j</code></td>
<td>
<p>is an jth dimension in <code>mat</code> for computing compute the odd difference with.</p>
</td></tr>
<tr><td><code id="oddDiffFunc_+3A_z">z</code></td>
<td>
<p>is a conditioning d-dimensional vector on <code>D</code>.
Given k non-negative-bit positions of <code>z</code>, all k bit positions of samples in the subset of <code>D</code> must have similar values with these bits.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an odd difference value of variables of ith and jth dimensions from <code>D</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oddDiffFunc(D,i=1,j=2)

</code></pre>

<hr>
<h2 id='oddRatioFunc'>oddRatioFunc function</h2><span id='topic+oddRatioFunc'></span>

<h3>Description</h3>

<p>Given the samples in the n by d matrix <code>mat</code> where n is a number of samples and d is a number of dimensions.
This function computes an odd ratio value of variables of ith and jth dimensions from
a given an aligned list of transactions <code>D</code> (compute by <code>D&lt;-VecAlignment(mat)</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oddRatioFunc(D, i, j, z = c(), slack = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oddRatioFunc_+3A_d">D</code></td>
<td>
<p>is an aligned list of transactions that was converted from <code>mat</code>.</p>
</td></tr>
<tr><td><code id="oddRatioFunc_+3A_i">i</code></td>
<td>
<p>is an ith dimension in <code>mat</code> for computing the odd ratio with.</p>
</td></tr>
<tr><td><code id="oddRatioFunc_+3A_j">j</code></td>
<td>
<p>is an jth dimension in <code>mat</code> for computing compute the odd ratio with.</p>
</td></tr>
<tr><td><code id="oddRatioFunc_+3A_z">z</code></td>
<td>
<p>is a conditioning d-dimensional vector on <code>D</code>.
Given k non-negative-bit positions of <code>z</code>, all k bit positions of samples in the subset of <code>D</code> must have similar values with these bits.</p>
</td></tr>
<tr><td><code id="oddRatioFunc_+3A_slack">slack</code></td>
<td>
<p>is a parameter to prevent the issue of division by zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns an odd ratio value of variables of ith and jth dimensions from <code>D</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oddRatioFunc(D,i=1,j=2)

</code></pre>

<hr>
<h2 id='resC'>An example of causal inference result</h2><span id='topic+resC'></span>

<h3>Description</h3>

<p>A dataset containing a result of causal inference from simulated data that is used for examples in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resC
</code></pre>


<h3>Format</h3>

<p>A result of causal inference using <code>mat</code> as an input.
</p>

<dl>
<dt>resC</dt><dd><p>It is a result of causal inference using simData$mat as an input by running
<code>resC&lt;-BiCausality::CausalGraphInferMainFunc(mat = mat,CausalThs=0.1, nboot =50, IndpThs=0.05)</code>. </p>
</dd></dl>
<p>.

</p>

<hr>
<h2 id='supp'>supp function</h2><span id='topic+supp'></span>

<h3>Description</h3>

<p>This function computes a support value from a matrix <code>X</code> given a <code>values</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>supp(X, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supp_+3A_x">X</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples
and d is a number of dimensions for each sample.</p>
</td></tr>
<tr><td><code id="supp_+3A_values">values</code></td>
<td>
<p>is a d-dimensional vector
we use to count how many of it within <code>X</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the support of <code>values</code> in <code>X</code> by counting
the ratio of how many samples in <code>X</code> are similar to <code>values</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rbinom(n=100, size=1, prob=0.5)
ny&lt;-rbinom(n=100, size=1, prob=0.25)
y &lt;- x |  ny
supp(X=cbind(x,y),values=c(1,1) )

</code></pre>

<hr>
<h2 id='VecAlignment'>VecAlignment function</h2><span id='topic+VecAlignment'></span>

<h3>Description</h3>

<p>This function rearranges the samples in the <code>mat</code> into
an aligned list of transactions, which is mainly used by other functions in the package.
Suppose <code>mat[i,]</code> is a binary vector  we are interested, we use  <code>A&lt;-bin2dec(mat[i,])</code>
to store the decimal value of <code>mat[i,]</code> in <code>A</code>. Then, we call <code>D[[A]]$count</code>
to get number of samples in <code>mat</code> that are similar to <code>mat[i,]</code> and
the <code>D[[A]]$name</code> is <code>mat[i,]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VecAlignment(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VecAlignment_+3A_mat">mat</code></td>
<td>
<p>is a matrix n by d where n is a number of transactions or samples and d is a number of dimensions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns  an aligned list of transactions <code>D</code>, is an aligned list of transactions that was converted from any matrix n by d <code>mat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>VecAlignment(mat=mat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
