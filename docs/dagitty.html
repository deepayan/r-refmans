<!DOCTYPE html><html><head><title>Help for package dagitty</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dagitty}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjustmentSets'><p>Covariate Adjustment Sets</p></a></li>
<li><a href='#ancestorGraph'><p>Ancestor Graph</p></a></li>
<li><a href='#AncestralRelations'><p>Ancestral Relations</p></a></li>
<li><a href='#as.dagitty'><p>Convert to DAGitty object</p></a></li>
<li><a href='#backDoorGraph'><p>Back-Door Graph</p></a></li>
<li><a href='#canonicalize'><p>Canonicalize an Ancestral Graph</p></a></li>
<li><a href='#completeDAG'><p>Generate Complete DAG</p></a></li>
<li><a href='#convert'><p>Convert from DAGitty object to other graph types</p></a></li>
<li><a href='#coordinates'><p>Plot Coordinates of Variables in Graph</p></a></li>
<li><a href='#dagitty'><p>Parse DAGitty Graph</p></a></li>
<li><a href='#dconnected'><p>d-Separation</p></a></li>
<li><a href='#downloadGraph'><p>Load Graph from dagitty.net</p></a></li>
<li><a href='#edges'><p>Graph Edges</p></a></li>
<li><a href='#EquivalentModels'><p>Generating Equivalent Models</p></a></li>
<li><a href='#exogenousVariables'><p>Retrieve Exogenous Variables</p></a></li>
<li><a href='#getExample'><p>Get Bundled Examples</p></a></li>
<li><a href='#graphLayout'><p>Generate Graph Layout</p></a></li>
<li><a href='#graphType'><p>Get Graph Type</p></a></li>
<li><a href='#impliedConditionalIndependencies'><p>List Implied Conditional Independencies</p></a></li>
<li><a href='#impliedCovarianceMatrix'><p>Implied Covariance Matrix of a Gaussian Graphical Model</p></a></li>
<li><a href='#instrumentalVariables'><p>Find Instrumental Variables</p></a></li>
<li><a href='#is.dagitty'><p>Test for Graph Class</p></a></li>
<li><a href='#isAcyclic'><p>Test for Cycles</p></a></li>
<li><a href='#isAdjustmentSet'><p>Adjustment Criterion</p></a></li>
<li><a href='#isCollider'><p>Test for Colliders</p></a></li>
<li><a href='#lavaanToGraph'><p>Convert Lavaan Model to DAGitty Graph</p></a></li>
<li><a href='#localTests'><p>Test Graph against Data</p></a></li>
<li><a href='#measurementPart'><p>Extract Measurement Part from Structural Equation Model</p></a></li>
<li><a href='#moralize'><p>Moral Graph</p></a></li>
<li><a href='#names.dagitty'><p>Names of Variables in Graph</p></a></li>
<li><a href='#orientPDAG'><p>Orient Edges in PDAG.</p></a></li>
<li><a href='#paths'><p>Show Paths</p></a></li>
<li><a href='#plot.dagitty'><p>Plot Graph</p></a></li>
<li><a href='#plotLocalTestResults'><p>Plot Results of Local Tests</p></a></li>
<li><a href='#randomDAG'><p>Generate DAG at Random</p></a></li>
<li><a href='#simulateLogistic'><p>Simulate Binary Data from DAG Structure</p></a></li>
<li><a href='#simulateSEM'><p>Simulate Data from Structural Equation Model</p></a></li>
<li><a href='#structuralPart'><p>Extract Structural Part from Structural Equation Model</p></a></li>
<li><a href='#toMAG'><p>Convert DAG to MAG.</p></a></li>
<li><a href='#topologicalOrdering'><p>Get Topological Ordering of DAG</p></a></li>
<li><a href='#vanishingTetrads'><p>List Implied Vanishing Tetrads</p></a></li>
<li><a href='#VariableStatus'><p>Variable Statuses</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Graphical Analysis of Structural Causal Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Johannes Textor, Benito van der Zander, Ankur Ankan</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johannes Textor &lt;johannes.textor@gmx.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A port of the web-based software 'DAGitty', available at 
    <a href="https://dagitty.net">https://dagitty.net</a>, for analyzing structural causal models 
    (also known as directed acyclic graphs or DAGs).
    This package computes covariate adjustment sets for estimating causal
    effects, enumerates instrumental variables, derives testable
    implications (d-separation and vanishing tetrads), generates equivalent
    models, and includes a simple facility for data simulation. </td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.dagitty.net">https://www.dagitty.net</a>, <a href="https://github.com/jtextor/dagitty">https://github.com/jtextor/dagitty</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jtextor/dagitty/issues">https://github.com/jtextor/dagitty/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>V8, jsonlite, boot, MASS, methods, grDevices, stats, utils,
graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, knitr, base64enc (&ge; 0.1-3), testthat, markdown,
rmarkdown, lavaan, CCP, fastDummies</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 15:40:28 UTC; johannes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-07 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjustmentSets'>Covariate Adjustment Sets</h2><span id='topic+adjustmentSets'></span>

<h3>Description</h3>

<p>Enumerates sets of covariates that (asymptotically) allow unbiased estimation of causal
effects from observational data, assuming that the input causal graph is correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjustmentSets(
  x,
  exposure = NULL,
  outcome = NULL,
  type = c("minimal", "canonical", "all"),
  effect = c("total", "direct"),
  max.results = Inf
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustmentSets_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, PDAG, or PAG.</p>
</td></tr>
<tr><td><code id="adjustmentSets_+3A_exposure">exposure</code></td>
<td>
<p>name(s) of the exposure variable(s). If not given (default), then the 
exposure variables are supposed to be defined in the graph itself.</p>
</td></tr>
<tr><td><code id="adjustmentSets_+3A_outcome">outcome</code></td>
<td>
<p>name(s) of the outcome variable(s), also taken from the graph if 
not given.</p>
</td></tr>
<tr><td><code id="adjustmentSets_+3A_type">type</code></td>
<td>
<p>which type of adjustment set(s) to compute. If <code>type="minimal"</code>,
then only minimal sufficient adjustment sets are returned (default). For 
<code>type="all"</code>, all valid adjustment sets are returned. For <code>type="canonical"</code>,
a single adjustment set is returned that consists of all (possible) ancestors
of exposures and outcomes, minus (possible) descendants of nodes on proper causal
paths. This canonical adjustment set is always valid if any valid set exists
at all.</p>
</td></tr>
<tr><td><code id="adjustmentSets_+3A_effect">effect</code></td>
<td>
<p>which effect is to be identified. If <code>effect="total"</code>, then the
total effect is to be identified, and the adjustment criterion by Perkovic et 
al (2015; see also van der Zander et al., 2014), 
an extension of Pearl's back-door criterion, is used. Otherwise, if 
<code>effect="direct"</code>, then the average direct effect is to be identified, and Pearl's
single-door criterion is used (Pearl, 2009). In a structural equation model (Gaussian
graphical model), direct effects are simply the path coefficients.</p>
</td></tr>
<tr><td><code id="adjustmentSets_+3A_max.results">max.results</code></td>
<td>
<p>integer. The listing of adjustment set is stopped once
this many results have been found. Use <code>Inf</code> to generate them all. 
This only applys when <code>type="minimal"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input graph is a MAG or PAG, then it must not contain any undirected
edges (=hidden selection variables).
</p>


<h3>References</h3>

<p>J. Pearl (2009), Causality: Models, Reasoning and Inference. 
Cambridge University Press.
</p>
<p>B. van der Zander, M. Liskiewicz and J. Textor (2014),
Constructing separators and adjustment sets in ancestral graphs.
In <em>Proceedings of UAI 2014.</em>
</p>
<p>E. Perkovic, J. Textor, M. Kalisch and M. H. Maathuis (2015), A
Complete Generalized Adjustment Criterion. In <em>Proceedings of UAI
2015.</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The M-bias graph showing that adjustment for 
# pre-treatment covariates is not always valid
g &lt;- dagitty( "dag{ x -&gt; y ; x &lt;-&gt; m &lt;-&gt; y }" )
adjustmentSets( g, "x", "y" ) # empty set
# Generate data where true effect (=path coefficient) is .5
set.seed( 123 ); d &lt;- simulateSEM( g, .5, .5 )
confint( lm( y ~ x, d ) )["x",] # includes .5
confint( lm( y ~ x + m, d ) )["x",] # does not include .5

# Adjustment sets can also sometimes be computed for graphs in which not all 
# edge directions are known
g &lt;- dagitty("pdag { x[e] y[o] a -- {i z b}; {a z i} -&gt; x -&gt; y &lt;- {z b} }")
adjustmentSets( g )
</code></pre>

<hr>
<h2 id='ancestorGraph'>Ancestor Graph</h2><span id='topic+ancestorGraph'></span>

<h3>Description</h3>

<p>Creates the induced subgraph containing only the vertices
in <code>v</code>, their ancestors, and the edges between them. All
other vertices and edges are discarded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ancestorGraph(x, v = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ancestorGraph_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, or PDAG.</p>
</td></tr>
<tr><td><code id="ancestorGraph_+3A_v">v</code></td>
<td>
<p>variable names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input graph is a MAG or PDAG, then all *possible* ancestors
will be returned (see Examples).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- dagitty("dag{ z &lt;- x -&gt; y }")
ancestorGraph( g, "z" )

g &lt;- dagitty("pdag{ z -- x -&gt; y }")
ancestorGraph( g, "y" ) # includes z

</code></pre>

<hr>
<h2 id='AncestralRelations'>Ancestral Relations</h2><span id='topic+AncestralRelations'></span><span id='topic+descendants'></span><span id='topic+ancestors'></span><span id='topic+children'></span><span id='topic+parents'></span><span id='topic+neighbours'></span><span id='topic+spouses'></span><span id='topic+adjacentNodes'></span><span id='topic+markovBlanket'></span>

<h3>Description</h3>

<p>Retrieve the names of all variables in a given graph that are in the specified 
ancestral relationship to the input variable <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>descendants(x, v, proper = FALSE)

ancestors(x, v, proper = FALSE)

children(x, v)

parents(x, v)

neighbours(x, v)

spouses(x, v)

adjacentNodes(x, v)

markovBlanket(x, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AncestralRelations_+3A_x">x</code></td>
<td>
<p>the input graph, of any type.</p>
</td></tr>
<tr><td><code id="AncestralRelations_+3A_v">v</code></td>
<td>
<p>name(s) of variable(s).</p>
</td></tr>
<tr><td><code id="AncestralRelations_+3A_proper">proper</code></td>
<td>
<p>logical. By default (<code>proper=FALSE</code>), the <code>descendants</code> or <code>ancestors</code>
of a variable include the variable itself. For (<code>proper=TRUE</code>), the variable itself 
is not included.
</p>
<p><code>descendants(x,v)</code> retrieves variables that are are reachable from <code>v</code> via 
a directed path.
</p>
<p><code>ancestors(x,v)</code> retrieves variables from which <code>v</code> is reachable via a 
directed path.
</p>
<p><code>children(x,v)</code> finds all variables <code>w</code> connected to <code>v</code> 
by an edge <code class="reqn">v</code> -&gt; <code class="reqn">w</code>.
</p>
<p><code>parents(x,v)</code> finds all variables <code>w</code> connected to <code>v</code> 
by an edge <code class="reqn">w</code> -&gt; <code class="reqn">v</code>.
</p>
<p><code>markovBlanket(x,v</code>) returns <code>x</code>'s parents, its children, and all other
parents of its children. The Markov blanket always renders <code>x</code> independent
of all other nodes in the graph.
</p>
<p>By convention, <code>descendants(x,v)</code> and <code>ancestors(x,v)</code> include 
<code>v</code> but <code>children(x,v)</code> and <code>parents(x,v)</code> do not.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- dagitty("graph{ a &lt;-&gt; x -&gt; b ; c -- x &lt;- d }")
# Includes "x"
descendants(g,"x")
# Does not include "x"
descendants(g,"x",TRUE)
parents(g,"x")
spouses(g,"x") 

</code></pre>

<hr>
<h2 id='as.dagitty'>Convert to DAGitty object</h2><span id='topic+as.dagitty'></span>

<h3>Description</h3>

<p>Converts its argument to a DAGitty object, if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.dagitty(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.dagitty_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
<tr><td><code id="as.dagitty_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='backDoorGraph'>Back-Door Graph</h2><span id='topic+backDoorGraph'></span>

<h3>Description</h3>

<p>Removes every first edge on a proper causal path from <code>x</code>.
If <code>x</code> is a MAG or PAG, then only &ldquo;visible&rdquo; directed
edges are removed (Zhang, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backDoorGraph(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backDoorGraph_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, PDAG, or PAG.</p>
</td></tr>
</table>


<h3>References</h3>

<p>J. Zhang (2008), Causal Reasoning with Ancestral Graphs. 
<em>Journal of Machine Learning Research</em> 9: 1437-1474.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- dagitty( "dag { x &lt;-&gt; m &lt;-&gt; y &lt;- x }" )
backDoorGraph( g ) # x-&gt;y edge is removed

g &lt;- dagitty( "mag { x &lt;-&gt; m &lt;-&gt; y &lt;- x }" )
backDoorGraph( g ) # x-&gt;y edge is not removed

g &lt;- dagitty( "mag { x &lt;-&gt; m &lt;-&gt; y &lt;- x &lt;- i }" )
backDoorGraph( g ) # x-&gt;y edge is removed

</code></pre>

<hr>
<h2 id='canonicalize'>Canonicalize an Ancestral Graph</h2><span id='topic+canonicalize'></span>

<h3>Description</h3>

<p>Takes an input ancestral graph (a graph with directed, bidirected and undirected
edges) and converts it to a DAG by replacing every bidirected edge x &lt;-&gt; y with a 
substructure x &lt;- L -&gt; y, where L is a latent variable, and every undirected edge
x &ndash; y with a substructure x -&gt; S &lt;- y, where S is a selection variable. This function
does not check whether the input is actually an ancestral graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canonicalize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="canonicalize_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG or MAG.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt>g</dt><dd><p>The resulting graph.</p>
</dd>
<dt>L</dt><dd><p>Names of newly inserted latent variables.</p>
</dd>
<dt>S</dt><dd><p>Names of newly inserted selection variables.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>canonicalize("mag{x&lt;-&gt;y--z}") # introduces two new variables
</code></pre>

<hr>
<h2 id='completeDAG'>Generate Complete DAG</h2><span id='topic+completeDAG'></span>

<h3>Description</h3>

<p>Generates a complete DAG on the given variable names. The order
in which the variables are given corresponds to the topological ordering
of the DAG. Returns a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>completeDAG(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="completeDAG_+3A_x">x</code></td>
<td>
<p>variable names. Can also be a positive integer, in which case 
the variables will be called  x1,...,xN.</p>
</td></tr>
</table>

<hr>
<h2 id='convert'>Convert from DAGitty object to other graph types</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>Converts its argument from a DAGitty object (or character string describing it)
to another package's format, if possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_x">x</code></td>
<td>
<p>a <code>dagitty</code> object or a character string.</p>
</td></tr>
<tr><td><code id="convert_+3A_to">to</code></td>
<td>
<p>destination format, currently one of &quot;dagitty&quot;, &quot;tikz&quot;, &quot;lavaan&quot;, &quot;bnlearn&quot;, or &quot;causaleffect&quot;.</p>
</td></tr>
<tr><td><code id="convert_+3A_...">...</code></td>
<td>
<p>further arguments passed on to methods (currently unused)</p>
</td></tr>
</table>

<hr>
<h2 id='coordinates'>Plot Coordinates of Variables in Graph</h2><span id='topic+coordinates'></span><span id='topic+coordinates+3C-'></span>

<h3>Description</h3>

<p>The DAGitty syntax allows specification of plot coordinates for each variable in a 
graph. This function extracts these plot coordinates from the graph description in a
<code>dagitty</code> object. Note that the coordinate system is undefined, typically one 
needs to compute the bounding box before plotting the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordinates(x)

coordinates(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinates_+3A_x">x</code></td>
<td>
<p>the input graph, of any type.</p>
</td></tr>
<tr><td><code id="coordinates_+3A_value">value</code></td>
<td>
<p>a list with components <code>x</code> and <code>y</code>, 
giving relative coordinates for each variable. This format is suitable 
for <code><a href="grDevices.html#topic+xy.coords">xy.coords</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Function <a href="#topic+graphLayout">graphLayout</a> for automtically generating layout coordinates, and function
<a href="#topic+plot.dagitty">plot.dagitty</a> for plotting graphs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot localization of each node in the Shrier example
plot( coordinates( getExample("Shrier") ) )

## Define a graph and set coordinates afterwards
x &lt;- dagitty('dag{
    G &lt;-&gt; H &lt;-&gt; I &lt;-&gt; G
    D &lt;- B -&gt; C -&gt; I &lt;- F &lt;- B &lt;- A
    H &lt;- E &lt;- C -&gt; G &lt;- D
}')
coordinates( x ) &lt;-
    list( x=c(A=1, B=2, D=3, C=3, F=3, E=4, G=5, H=5, I=5),
        y=c(A=0, B=0, D=1, C=0, F=-1, E=0, G=1, H=0, I=-1) )
plot( x )

</code></pre>

<hr>
<h2 id='dagitty'>Parse DAGitty Graph</h2><span id='topic+dagitty'></span>

<h3>Description</h3>

<p>Constructs a <code>dagitty</code> graph object from a textual description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dagitty(x, layout = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dagitty_+3A_x">x</code></td>
<td>
<p>character, string describing a graphical model in dagitty syntax.</p>
</td></tr>
<tr><td><code id="dagitty_+3A_layout">layout</code></td>
<td>
<p>logical, whether to automatically generate layout coordinates for each
variable (see <code><a href="#topic+graphLayout">graphLayout</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The textual syntax for DAGitty graph is based on the dot language of the 
graphviz software (<a href="https://graphviz.gitlab.io/_pages/doc/info/lang.html">https://graphviz.gitlab.io/_pages/doc/info/lang.html</a>). This is a
fairly intuitive syntax &ndash; use the examples below and in the other functions to
get you started. An important difference to graphviz is that the DAGitty language
supports several types of graphs, which have different semantics. However, many users
will mainly focus on DAGs.
</p>
<p>A DAGitty graph description has the following form:
</p>
<p><code>[graph type] '{' [statements] '}'</code>
</p>
<p>where <code>[graph type]</code> is one of 'dag', 'mag', 'pdag', or 'pag' and <code>[statements]</code>
is a list of variables statements and edge statements, which may (optionally) be
separated by semicolons. Whitespace, including newlines, has no semantic role.
</p>
<p>Variable statments look like
</p>
<p><code>[variable id] '[' [properties] ']'</code>
</p>
<p>For example, the statement
</p>
<p><code>x [exposure,pos="1,0"]</code>
</p>
<p>declares a variable with ID x that is an exposure variable and has a layout position
of 1,0.
</p>
<p>The edge statement
</p>
<p><code>x -&gt; y</code>
</p>
<p>declares a directed edge from variable x to variable y. Explicit variable statements
are not required for the variables involved in edge statements, unless attributes 
such as position or exposure/outcome status need to be set.
</p>
<p>DAGs (directed acyclic graphs) can contain the following edges: <code>-&gt;</code>, <code>&lt;-&gt;</code>. 
Bidirected edges in DAGs are simply shorthands for substructures <code>&lt;- U -&gt;</code>, 
where U is an unobserved variable.
</p>
<p>MAGs (maximal ancestral graphs) can contain the following edges: <code>-&gt;</code>,
<code>&lt;-&gt;</code>, <code>--</code>. 
The bidirected and directed edges of MAGs can represent latent confounders, and 
the undirected edges represent latent selection variables. 
For details, see Richardson and Spirtes (2002).
</p>
<p>PDAGs (partially directed acyclic graphs) can contain the following edges: <code>-&gt;</code>,
<code>&lt;-&gt;</code>, <code>--</code>. 
The bidirected edges mean the same thing as in DAGs. The undirected edges represent
edges whose direction is not known. Thus, PDAGs are used to represent equivalence
classes of DAGs (see also the function <code><a href="#topic+equivalenceClass">equivalenceClass</a></code>).
</p>
<p>PAGs (partial ancestral graphs) are to MAGs what PDAGs are to DAGs: they represent
equivalence classes of MAGs. MAGs can contain the following edges: <code>@-@</code>, 
<code>-&gt;</code>, <code>@-&gt;</code>, <code>--</code>, <code>@--</code>
(the @ symbols are written as circle marks in most of the literature). For
details on PAGs, see Zhang et al (2008). For now, only a few DAGitty functions
support PAGs (for instance, <code><a href="#topic+adjustmentSets">adjustmentSets</a></code>.
</p>
<p>The DAGitty parser does not perform semantic validation. That is, 
it will not check whether a DAG is actually acyclic, or whether all chain components
in a PAG are actually chordal. This is not done because it can be computationally
rather expensive.
</p>


<h3>References</h3>

<p>Richardson, Thomas; Spirtes, Peter (2002), Ancestral graph Markov models.
<em>The Annals of Statistics</em> 30(4): 962-1030.
</p>
<p>J. Zhang (2008), Causal Reasoning with Ancestral Graphs. 
<em>Journal of Machine Learning Research</em> 9: 1437-1474.
</p>
<p>B. van der Zander and M. Liskiewicz (2016), 
Separators and Adjustment Sets in Markov Equivalent DAGs.
In <em>Proceedings of the Thirtieth AAAI Conference on Artificial Intelligence (AAAI'16)</em>, 
Phoenix, Arizona, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify a simple DAG containing one path
g &lt;- dagitty("dag{ 
  a -&gt; b ;
  b -&gt; c ;
  d -&gt; c
 }")
# Newlines and semicolons are optional
g &lt;- dagitty("dag{ 
  a -&gt; b b -&gt; c c -&gt; d
 }")
# Paths can be specified in one go; the semicolon below is
# optional
g &lt;- dagitty("dag{ 
  a -&gt; b -&gt;c ; c -&gt; d
 }")
# Edges can be written in reverse notation
g &lt;- dagitty("dag{ 
  a -&gt; b -&gt; c &lt;- d
 }")
# Spaces are optional as well
g &lt;- dagitty("dag{a-&gt;b-&gt;c&lt;-d}")
# Variable attributes can be set in square brackets
# Example: DAG with one exposure, one outcome, and one unobserved variable
g &lt;- dagitty("dag{
  x -&gt; y ; x &lt;- z -&gt; y
  x [exposure]
  y [outcome]
  z [unobserved]
}") 
# The same graph as above
g &lt;- dagitty("dag{x[e]y[o]z[u]x&lt;-z-&gt;y&lt;-x}")
# A two-factor latent variable model
g &lt;- dagitty("dag {
  X &lt;-&gt; Y
  X -&gt; a X -&gt; b X -&gt; c X -&gt; d
  Y -&gt; a Y -&gt; b Y -&gt; c Y -&gt; d
}")
# Curly braces can be used to "group" variables and 
# specify edges to whole groups of variables
# The same two-factor model
g &lt;- dagitty("dag{ {X&lt;-&gt;Y} -&gt; {a b c d} }")
# A MAG
g &lt;- dagitty("mag{ a -- x -&gt; y &lt;-&gt; z }")
# A PDAG
g &lt;- dagitty("pdag{ x -- y -- z }")
# A PAG
g &lt;- dagitty("pag{ x @-@ y @-@ z }")  
</code></pre>

<hr>
<h2 id='dconnected'>d-Separation</h2><span id='topic+dconnected'></span><span id='topic+dseparated'></span>

<h3>Description</h3>

<p>A set Z d-separates a path p if (1) Z contains a non-collider
on p, e.g. x-&gt;m-&gt;y with <code>Z=c("m")</code>; or (2) some collider on p is not
on Z, e.g. x-&gt;m&lt;-y with <code>Z=c()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dconnected(x, X, Y = list(), Z = list())

dseparated(x, X, Y = list(), Z = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dconnected_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, PDAG, or MAG.</p>
</td></tr>
<tr><td><code id="dconnected_+3A_x">X</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code id="dconnected_+3A_y">Y</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code id="dconnected_+3A_z">Z</code></td>
<td>
<p>vector of variable names.
</p>
<p><code>dseparated(x,X,Y,Z)</code> checks if all paths between X and Y are 
d-separated by Z.
</p>
<p><code>dconnected(x,X,Y,Z)</code> checks if at least one path between X and Y
is not d-separated by Z.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions also work for mixed graphs with directed, undirected,
and bidirected edges. The definition of a collider in such graphs
is: a node where two arrowheads collide, e.g. x&lt;-&gt;m&lt;-y but not
x-&gt;m&ndash;y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dconnected( "dag{x-&gt;m-&gt;y}", "x", "y", c() ) # TRUE
dconnected( "dag{x-&gt;m-&gt;y}", "x", "y", c("m") ) # FALSE
dseparated( "dag{x-&gt;m-&gt;y}", "x", "y", c() ) # FALSE 
dseparated( "dag{x-&gt;m-&gt;y}", "x", "y", c("m") ) # TRUE

</code></pre>

<hr>
<h2 id='downloadGraph'>Load Graph from dagitty.net</h2><span id='topic+downloadGraph'></span>

<h3>Description</h3>

<p>Downloads a graph that has been built and stored online using the dagitty.net GUI.
Users who store graphs online will receive a unique URL for their graph, which
can be fed into this function to continue working with the graph in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadGraph(x = "dagitty.net/mz-Tuw9")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downloadGraph_+3A_x">x</code></td>
<td>
<p>dagitty model URL.</p>
</td></tr>
</table>

<hr>
<h2 id='edges'>Graph Edges</h2><span id='topic+edges'></span>

<h3>Description</h3>

<p>Extracts edge information from the input graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_+3A_x">x</code></td>
<td>
<p>the input graph, of any type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the following variables:
</p>

<dl>
<dt>v</dt><dd><p> name of the start node.</p>
</dd>
<dt>w</dt><dd><p> name of the end node. For symmetric edges (bidirected and undirected), the
order of start and end node is arbitrary.</p>
</dd>
<dt>e</dt><dd><p> type of edge. Can be one of <code>"-&gt;"</code>, <code>"&lt;-&gt;"</code> and <code>"--"</code>.</p>
</dd>
<dt>x</dt><dd><p> X coordinate for a control point. If this is not <code>NA</code>, then the edge
is drawn as an <code><a href="graphics.html#topic+xspline">xspline</a></code> through the start point, this control point, 
and the end point. This is especially important for cases where there is more than
one edge between two variables (for instance, both a directed and a bidirected edge).</p>
</dd>
<dt>y</dt><dd><p> Y coordinate for a control point.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Which kinds of edges are used in the Shrier example?
levels( edges( getExample("Shrier") )$e )
</code></pre>

<hr>
<h2 id='EquivalentModels'>Generating Equivalent Models</h2><span id='topic+EquivalentModels'></span><span id='topic+equivalenceClass'></span><span id='topic+equivalentDAGs'></span>

<h3>Description</h3>

<p><code>equivalenceClass(x)</code> generates a complete partially directed acyclic graph 
(CPDAG) from an input DAG <code>x</code>. The CPDAG represents all graphs that are Markov 
equivalent to <code>x</code>: undirected
edges in the CPDAG can be oriented either way, as long as this does not create a cycle
or a new v-structure (a sugraph a -&gt; m &lt;- b, where a and b are not adjacent).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalenceClass(x)

equivalentDAGs(x, n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EquivalentModels_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG (or CPDAG for <code>equivalentDAGs</code>).</p>
</td></tr>
<tr><td><code id="EquivalentModels_+3A_n">n</code></td>
<td>
<p>maximal number of returned graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>equivalentDAGs(x,n)</code> enumerates at most <code>n</code> DAGs that are Markov equivalent
to the input DAG or CPDAG <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># How many equivalent DAGs are there for the sports DAG example?
g &lt;- getExample("Shrier")
length(equivalentDAGs(g))
# Plot all equivalent DAGs
par( mfrow=c(2,3) )
lapply( equivalentDAGs(g), plot )
# How many edges can be reversed without changing the equivalence class?
sum(edges(equivalenceClass(g))$e == "--")
</code></pre>

<hr>
<h2 id='exogenousVariables'>Retrieve Exogenous Variables</h2><span id='topic+exogenousVariables'></span>

<h3>Description</h3>

<p>Returns the names of all variables that have no directed arrow pointing to them.
Note that this does not preclude variables connected to bidirected arrows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exogenousVariables(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exogenousVariables_+3A_x">x</code></td>
<td>
<p>the input graph, of any type.</p>
</td></tr>
</table>

<hr>
<h2 id='getExample'>Get Bundled Examples</h2><span id='topic+getExample'></span>

<h3>Description</h3>

<p>Provides access to the builtin examples of the dagitty website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExample(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getExample_+3A_x">x</code></td>
<td>
<p>name of the example, or part thereof. Supported values are:
</p>

<dl>
<dt>&quot;M-bias&quot;</dt><dd><p> the M-bias graph.</p>
</dd>
<dt>&quot;confounding&quot;</dt><dd><p> an extended confounding triangle.</p>
</dd>
<dt>&quot;mediator&quot;</dt><dd><p> a small model with a mediator.</p>
</dd>
<dt>&quot;paths&quot;</dt><dd><p> a graph with many variables but few paths</p>
</dd>
<dt>&quot;Sebastiani&quot;</dt><dd><p> a small part of a genetics study (Sebastiani et al., 2005)</p>
</dd>
<dt>&quot;Polzer&quot;</dt><dd><p> DAG from a dentistry study (Polzer et al., 2012)</p>
</dd>
<dt>&quot;Schipf&quot;</dt><dd><p> DAG from a study on diabetes (Schipf et al., 2010)</p>
</dd>
<dt>&quot;Shrier&quot;</dt><dd><p> DAG from a classic sports medicine example (Shrier &amp; Platt, 2008)</p>
</dd>
<dt>&quot;Thoemmes&quot;</dt><dd><p> DAG with unobserved variables 
(communicated by Felix Thoemmes, 2013)</p>
</dd></dl>
<p>.
</p>
<dl>
<dt>&quot;Kampen&quot;</dt><dd><p> DAG from a psychiatry study (van Kampen, 2014)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>References</h3>

<p>Sabine Schipf, Robin Haring, Nele Friedrich, Matthias Nauck, Katharina Lau,
Dietrich Alte, Andreas Stang, Henry Voelzke, and Henri Wallaschofski (2011),
Low total testosterone is associated with increased risk of incident
type 2 diabetes mellitus in men: Results from the study of health in
pomerania (SHIP). <em>The Aging Male</em> <b>14</b>(3):168&ndash;75.
</p>
<p>Paola Sebastiani, Marco F. Ramoni, Vikki Nolan, Clinton T. Baldwin, and
Martin H. Steinberg (2005), Genetic dissection and prognostic modeling of overt 
stroke in sickle cell anemia. <em>Nature Genetics</em>, <b>37</b>:435&ndash;440.
</p>
<p>Ian Shrier and Robert W. Platt (2008), 
Reducing bias through directed acyclic graphs.
<em>BMC Medical Research Methodology</em>, <b>8</b>(70).
</p>
<p>Ines Polzer, Christian Schwahn, Henry Voelzke, Torsten Mundt, and Reiner
Biffar (2012), The association of tooth loss with all-cause and circulatory
mortality. Is there a benefit of replaced teeth? A systematic review and
meta-analysis. <em>Clinical Oral Investigations</em>, <b>16</b>(2):333&ndash;351.
</p>
<p>Dirk van Kampen (2014),
The SSQ model of schizophrenic prodromal unfolding revised: An
analysis of its causal chains based on the language of directed graphs.
<em>European Psychiatry</em>, <b>29</b>(7):437&ndash;48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- getExample("Shrier")
plot(g)

</code></pre>

<hr>
<h2 id='graphLayout'>Generate Graph Layout</h2><span id='topic+graphLayout'></span>

<h3>Description</h3>

<p>This function generates plot coordinates for each variable in a graph that does not
have them already. To this end, the well-known &ldquo;Spring&rdquo; layout algorithm is
used. Note that this is a stochastic algorithm, so the generated layout will be 
different every time (which also means that you can try several times until you find
a decent layout).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphLayout(x, method = "spring")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphLayout_+3A_x">x</code></td>
<td>
<p>the input graph, of any type.</p>
</td></tr>
<tr><td><code id="graphLayout_+3A_method">method</code></td>
<td>
<p>the layout method; currently, only <code>"spring"</code> is supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same graph as <code>x</code> but with layout coordinates added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a layout for the M-bias graph and plot it
plot( graphLayout( dagitty( "dag { X &lt;- U1 -&gt; M &lt;- U2 -&gt; Y } " ) ) )
## Plot larger graph and abbreviate its variable names.
plot( getExample("Shrier"), abbreviate.names=TRUE )

</code></pre>

<hr>
<h2 id='graphType'>Get Graph Type</h2><span id='topic+graphType'></span>

<h3>Description</h3>

<p>Get Graph Type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphType(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphType_+3A_x">x</code></td>
<td>
<p>the input graph.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>graphType( "mag{ x&lt;-&gt; y }" ) == "mag"
</code></pre>

<hr>
<h2 id='impliedConditionalIndependencies'>List Implied Conditional Independencies</h2><span id='topic+impliedConditionalIndependencies'></span>

<h3>Description</h3>

<p>Generates a list of conditional independence statements that must hold in every
probability distribution compatible with the given model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impliedConditionalIndependencies(x, type = "missing.edge", max.results = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impliedConditionalIndependencies_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, or PDAG.</p>
</td></tr>
<tr><td><code id="impliedConditionalIndependencies_+3A_type">type</code></td>
<td>
<p>can be one of &quot;missing.edge&quot;, &quot;basis.set&quot;, or &quot;all.pairs&quot;. With the first, one or 
more minimal testable implication (with the smallest possible conditioning set)
is returned per missing edge of the graph. With &quot;basis.set&quot;, one testable
implication is returned per vertex of the graph that has non-descendants other than
its parents. Basis sets can be smaller, but they involve higher-dimensional independencies,
whereas missing edge sets involve only independencies between two variables at a time.
With &quot;all.pairs&quot;, the function will return a list of all implied conditional independencies
between two variables at a time. Beware, because this can be a very long list and it 
may not be feasible to compute this except for small graphs.</p>
</td></tr>
<tr><td><code id="impliedConditionalIndependencies_+3A_max.results">max.results</code></td>
<td>
<p>integer. The listing of conditional independencies is stopped once
this many results have been found. Use <code>Inf</code> to generate them all. This applies
only when <code>type="missing.edge"</code> or <code>type="all"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- dagitty( "dag{ x -&gt; m -&gt; y }" )
impliedConditionalIndependencies( g ) # one
latents( g ) &lt;- c("m")
impliedConditionalIndependencies( g ) # none
</code></pre>

<hr>
<h2 id='impliedCovarianceMatrix'>Implied Covariance Matrix of a Gaussian Graphical Model</h2><span id='topic+impliedCovarianceMatrix'></span>

<h3>Description</h3>

<p>Implied Covariance Matrix of a Gaussian Graphical Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impliedCovarianceMatrix(
  x,
  b.default = NULL,
  b.lower = -0.6,
  b.upper = 0.6,
  eps = 1,
  standardized = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impliedCovarianceMatrix_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG (which may contain bidirected edges).</p>
</td></tr>
<tr><td><code id="impliedCovarianceMatrix_+3A_b.default">b.default</code></td>
<td>
<p>default path coefficient applied to arrows for which no coefficient is 
defined in the model syntax.</p>
</td></tr>
<tr><td><code id="impliedCovarianceMatrix_+3A_b.lower">b.lower</code></td>
<td>
<p>lower bound for random path coefficients, applied if <code>b.default=NULL</code>.</p>
</td></tr>
<tr><td><code id="impliedCovarianceMatrix_+3A_b.upper">b.upper</code></td>
<td>
<p>upper bound for path coefficients.</p>
</td></tr>
<tr><td><code id="impliedCovarianceMatrix_+3A_eps">eps</code></td>
<td>
<p>residual variance (only meaningful if <code>standardized=FALSE</code>).</p>
</td></tr>
<tr><td><code id="impliedCovarianceMatrix_+3A_standardized">standardized</code></td>
<td>
<p>logical. If true, a standardized population covariance matrix
is generated (all variables have variance 1).</p>
</td></tr>
</table>

<hr>
<h2 id='instrumentalVariables'>Find Instrumental Variables</h2><span id='topic+instrumentalVariables'></span>

<h3>Description</h3>

<p>Generates a list of instrumental variables that can be used to infer the total effect
of an exposure on an outcome in the presence of latent confounding, under linearity
assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instrumentalVariables(x, exposure = NULL, outcome = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="instrumentalVariables_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG.</p>
</td></tr>
<tr><td><code id="instrumentalVariables_+3A_exposure">exposure</code></td>
<td>
<p>name of the exposure variable. If not given (default), then the 
exposure variable is supposed to be defined in the graph itself. Only a single
exposure variable and a single outcome variable supported.</p>
</td></tr>
<tr><td><code id="instrumentalVariables_+3A_outcome">outcome</code></td>
<td>
<p>name of the outcome variable, also taken from the graph if not given.
Only a single outcome variable is supported.</p>
</td></tr>
</table>


<h3>References</h3>

<p>B. van der Zander, J. Textor and M. Liskiewicz (2015),
Efficiently Finding Conditional Instruments for Causal Inference.
In <em>Proceedings of the 24th International Joint Conference on 
Artificial Intelligence (IJCAI 2015)</em>, pp. 3243-3249. AAAI Press, 2015.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The classic IV model
instrumentalVariables( "dag{ i-&gt;x-&gt;y; x&lt;-&gt;y }", "x", "y" )
# A conditional instrumental variable
instrumentalVariables( "dag{ i-&gt;x-&gt;y; x&lt;-&gt;y ; y&lt;-z-&gt;i }", "x", "y" )
</code></pre>

<hr>
<h2 id='is.dagitty'>Test for Graph Class</h2><span id='topic+is.dagitty'></span>

<h3>Description</h3>

<p>A function to check whether an object has class <code>dagitty</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dagitty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dagitty_+3A_x">x</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>

<hr>
<h2 id='isAcyclic'>Test for Cycles</h2><span id='topic+isAcyclic'></span><span id='topic+findCycle'></span>

<h3>Description</h3>

<p><code>isAcyclic(x)</code> returns <code>TRUE</code> if the given graph does not contain a directed cycle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isAcyclic(x)

findCycle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isAcyclic_+3A_x">x</code></td>
<td>
<p>the input graph, of any graph type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>findCycle(x)</code> will try to find at least one cycle in x and return it as a list of node names.
</p>
<p>These functions will only consider simple directed edges in the
given graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- dagitty("dag{X -&gt; Y -&gt; Z}")
stopifnot( isTRUE(isAcyclic( g1 )) )
g2 &lt;- dagitty("dag{X -&gt; Y -&gt; Z -&gt; X}")
stopifnot( isTRUE(!isAcyclic( g2 )) )
g3 &lt;- dagitty("mag{X -- Y -- Z -- X}")
stopifnot( isTRUE(isAcyclic( g3 )) )
</code></pre>

<hr>
<h2 id='isAdjustmentSet'>Adjustment Criterion</h2><span id='topic+isAdjustmentSet'></span>

<h3>Description</h3>

<p>Test whether a set fulfills the adjustment criterion, that means,
it removes all confounding bias when estimating a *total* effect.
This is an #' Back-door criterion (Shpitser et al, 2010; van der Zander et al, 
2014; Perkovic et al, 2015) 
which is complete in the sense that either a set
fulfills this criterion, or it does not remove all confounding bias.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isAdjustmentSet(x, Z, exposure = NULL, outcome = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isAdjustmentSet_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, PDAG, or PAG.</p>
</td></tr>
<tr><td><code id="isAdjustmentSet_+3A_z">Z</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code id="isAdjustmentSet_+3A_exposure">exposure</code></td>
<td>
<p>name(s) of the exposure variable(s). If not given (default), then the 
exposure variables are supposed to be defined in the graph itself.</p>
</td></tr>
<tr><td><code id="isAdjustmentSet_+3A_outcome">outcome</code></td>
<td>
<p>name(s) of the outcome variable(s), also taken from the graph if 
not given.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input graph is a MAG or PAG, then it must not contain any undirected
edges (=hidden selection variables).
</p>


<h3>References</h3>

<p>E. Perkovic, J. Textor, M. Kalisch and M. H. Maathuis (2015), A
Complete Generalized Adjustment Criterion. In <em>Proceedings of UAI
2015.</em>
</p>
<p>I. Shpitser, T. VanderWeele and J. M. Robins (2010), On the
validity of covariate adjustment for estimating causal effects. In
<em>Proceedings of UAI 2010.</em>
</p>

<hr>
<h2 id='isCollider'>Test for Colliders</h2><span id='topic+isCollider'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if three given variables form a collider in a given graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCollider(x, u, v, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isCollider_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG.</p>
</td></tr>
<tr><td><code id="isCollider_+3A_u">u</code></td>
<td>
<p>the first endpoint of the putative collider</p>
</td></tr>
<tr><td><code id="isCollider_+3A_v">v</code></td>
<td>
<p>the midpoint of the putative collider</p>
</td></tr>
<tr><td><code id="isCollider_+3A_w">w</code></td>
<td>
<p>the second endpoint of the putative collider</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>g1 &lt;- dagitty("dag{X -&gt; Y -&gt; Z}")
stopifnot( isTRUE(!isCollider( g1, "X", "Y", "Z" )) )
g2 &lt;- dagitty("dag{X -&gt; Y &lt;- Z }")
stopifnot( isTRUE(isCollider( g2, "X", "Y", "Z" )) )
</code></pre>

<hr>
<h2 id='lavaanToGraph'>Convert Lavaan Model to DAGitty Graph</h2><span id='topic+lavaanToGraph'></span>

<h3>Description</h3>

<p>The <code>lavaan</code> package is a popular package for structural equation 
modeling. To provide interoperability with lavaan, this function 
converts models specified in lavaan syntax to dagitty graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lavaanToGraph(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lavaanToGraph_+3A_x">x</code></td>
<td>
<p>data frame, lavaan parameter table such as returned by 
<code><a href="lavaan.html#topic+lavaanify">lavaanify</a></code>. Can also be a <code>lavaan</code> object
or a lavaan model string.</p>
</td></tr>
<tr><td><code id="lavaanToGraph_+3A_digits">digits</code></td>
<td>
<p>number of significant digits to use when representing 
path coefficients, if any</p>
</td></tr>
<tr><td><code id="lavaanToGraph_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if( require(lavaan) ){
mdl &lt;- lavaanify("
X ~ C1 + C3
M ~ X + C3
Y ~ X + M + C3 + C5
C1 ~ C2
C3 ~ C2 + C4
C5 ~ C4
C1 ~~ C2 \n C1 ~~ C3 \n C1 ~~ C4 \n C1 ~~ C5
C2 ~~ C3 \n C2 ~~ C4 \n C2 ~~ C5
C3 ~~ C4 \n C3 ~~ C5",fixed.x=FALSE)
plot( lavaanToGraph( mdl ) )
}
</code></pre>

<hr>
<h2 id='localTests'>Test Graph against Data</h2><span id='topic+localTests'></span><span id='topic+ciTest'></span>

<h3>Description</h3>

<p>Derives testable implications from the given graphical model and tests them against
the given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localTests(
  x = NULL,
  data = NULL,
  type = c("cis", "cis.loess", "cis.chisq", "cis.pillai", "tetrads", "tetrads.within",
    "tetrads.between", "tetrads.epistemic"),
  tests = NULL,
  sample.cov = NULL,
  sample.nobs = NULL,
  conf.level = 0.95,
  R = NULL,
  max.conditioning.variables = NULL,
  abbreviate.names = TRUE,
  tol = NULL,
  loess.pars = NULL
)

ciTest(X, Y, Z = NULL, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localTests_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, or PDAG. Either an input graph or an explicit
list of tests needs to be specified.</p>
</td></tr>
<tr><td><code id="localTests_+3A_data">data</code></td>
<td>
<p>matrix or data frame containing the data.</p>
</td></tr>
<tr><td><code id="localTests_+3A_type">type</code></td>
<td>
<p>character indicating which kind of local
test to perform. Supported values are <code>"cis"</code> (linear conditional independence),
<code>"cis.loess"</code> (conditional independence using loess regression), 
<code>"cis.chisq"</code> (for categorical data, based on the chi-square test),
<code>"cis.pillai"</code> (for mixed data, based on canonical correlations),
<code>"tetrads"</code> and <code>"tetrads.type"</code>, where &quot;type&quot; is one of the items of the 
tetrad typology, e.g. <code>"tetrads.within"</code> (see <code><a href="#topic+vanishingTetrads">vanishingTetrads</a></code>).
Tetrad testing is only implemented for DAGs.</p>
</td></tr>
<tr><td><code id="localTests_+3A_tests">tests</code></td>
<td>
<p>list of the precise tests to perform. If not given, the list
of tests is automatically derived from the input graph. Can be used to restrict 
testing to only a certain subset of tests (for instance, to test only those conditional
independencies for which the conditioning set is of a reasonably low dimension, such
as shown in the example).</p>
</td></tr>
<tr><td><code id="localTests_+3A_sample.cov">sample.cov</code></td>
<td>
<p>the sample covariance matrix; ignored if <code>data</code> is supplied.
Either <code>data</code> or <code>sample.cov</code> and <code>sample.nobs</code> must be supplied.</p>
</td></tr>
<tr><td><code id="localTests_+3A_sample.nobs">sample.nobs</code></td>
<td>
<p>number of observations; ignored if <code>data</code> is supplied.</p>
</td></tr>
<tr><td><code id="localTests_+3A_conf.level">conf.level</code></td>
<td>
<p>determines the size of confidence intervals for test
statistics.</p>
</td></tr>
<tr><td><code id="localTests_+3A_r">R</code></td>
<td>
<p>how many bootstrap replicates for estimating confidence
intervals. If <code>NULL</code>, then confidence intervals are based on normal
approximation. For tetrads, the normal approximation is only valid in 
large samples even if the data are normally distributed.</p>
</td></tr>
<tr><td><code id="localTests_+3A_max.conditioning.variables">max.conditioning.variables</code></td>
<td>
<p>for conditional independence testing, this 
parameter can be used to perform only those tests where the number of conditioning
variables does not exceed the given value. High-dimensional
conditional independence tests can be very unreliable.</p>
</td></tr>
<tr><td><code id="localTests_+3A_abbreviate.names">abbreviate.names</code></td>
<td>
<p>logical. Whether to abbreviate variable names (these are used as 
row names in the returned data frame).</p>
</td></tr>
<tr><td><code id="localTests_+3A_tol">tol</code></td>
<td>
<p>bound value for tolerated deviation from local test value. By default, we perform
a two-sided test of the hypothesis theta=0. If this parameter is given, the test changes
to abs(theta)=tol versus abs(theta)&gt;tol.</p>
</td></tr>
<tr><td><code id="localTests_+3A_loess.pars">loess.pars</code></td>
<td>
<p>list of parameter to be passed on to  <code><a href="stats.html#topic+loess">loess</a></code>
(for <code>type="cis.loess"</code>), for example the smoothing range.
</p>
<p><code>ciTest(X,Y,Z,data)</code> is a convenience function to test a single conditional independence
independently of a DAG.</p>
</td></tr>
<tr><td><code id="localTests_+3A_x">X</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code id="localTests_+3A_y">Y</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code id="localTests_+3A_z">Z</code></td>
<td>
<p>vector of variable names.</p>
</td></tr>
<tr><td><code id="localTests_+3A_...">...</code></td>
<td>
<p>parameters passed on from <code>ciTest</code> to <code>localTests</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tetrad implications can only be derived if a Gaussian model (i.e., a linear
structural equation model) is postulated. Conditional independence implications (CI)
do not require this assumption. However, both Tetrad and CI implications are tested
parametrically: for Tetrads, Wishart's confidence interval formula is used, whereas
for CIs, a Z test of zero conditional covariance (if the covariance
matrix is given) or a test of residual independence after linear regression
(it the raw data is given) is performed.
Both tetrad and CI tests also support bootstrapping instead of estimating parametric
confidence intervals.
For the canonical correlations approach, all ordinal variables are integer-coded, and 
all categorical variables are dummy-coded (omitting the dummy representing the most frequent 
category). To text X _||_ Y | Z, we first regress both X and Y (which now can be multivariate)
on Z, and then we compute the canonical correlations between the residuals. The effect size
is the root mean square canonical correlation (closely related to Pillai's trace, which is the 
root of the squared sum of all canonical correlations).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate full mediation model with measurement error of M1
set.seed(123)
d &lt;- simulateSEM("dag{X-&gt;{U1 M2}-&gt;Y U1-&gt;M1}",.6,.6)

# Postulate and test full mediation model without measurement error
r &lt;- localTests( "dag{ X -&gt; {M1 M2} -&gt; Y }", d, "cis" )
plotLocalTestResults( r )

# Simulate data from example SEM
g &lt;- getExample("Polzer")
d &lt;- simulateSEM(g,.1,.1)

# Compute independencies with at most 3 conditioning variables
r &lt;- localTests( g, d, "cis.loess", R=100, loess.pars=list(span=0.6),
        max.conditioning.variables=3 )
plotLocalTestResults( r )

# Test independencies for categorical data using chi-square test
d &lt;- simulateLogistic("dag{X-&gt;{U1 M2}-&gt;Y U1-&gt;M1}",2)
localTests( "dag{X-&gt;{M1 M2}-&gt;Y}", d, type="cis.chisq" )

</code></pre>

<hr>
<h2 id='measurementPart'>Extract Measurement Part from Structural Equation Model</h2><span id='topic+measurementPart'></span>

<h3>Description</h3>

<p>Removes all edges between latent variables, then removes any
latent variables without adjacent edges, then returns the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurementPart(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurementPart_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that x is a graph where there are edges between 
the latent variables, between the observed variables, and 
from latent to observed variables, but no edge between
a latent L and an observed X may have an arrowhead at L.
</p>

<hr>
<h2 id='moralize'>Moral Graph</h2><span id='topic+moralize'></span>

<h3>Description</h3>

<p>Graph obtained from <code>x</code> by (1) &ldquo;marrying&rdquo; (inserting an undirected
ede between) all nodes that have common children, and then replacing all edges
by undirected edges. If <code>x</code> contains bidirected edges, then all sets of 
nodes connected by a path containing only bidirected edges are treated like a 
single node (see Examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moralize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moralize_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, or PDAG.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># returns a complete graph
moralize( "dag{ x-&gt;m&lt;-y }" )
# also returns a complete graph
moralize( "dag{ x -&gt; m1 &lt;-&gt; m2 &lt;-&gt; m3 &lt;-&gt; m4 &lt;- y }" )

</code></pre>

<hr>
<h2 id='names.dagitty'>Names of Variables in Graph</h2><span id='topic+names.dagitty'></span>

<h3>Description</h3>

<p>Extracts the variable names from an input graph. Useful for iterating
over all variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dagitty'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.dagitty_+3A_x">x</code></td>
<td>
<p>the input graph, of any type.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## A "DAG" with Romanian and Swedish variable names. These can be
## input using quotes to overcome the limitations on unquoted identifiers.
g &lt;- dagitty( 'digraph {
  "corao" [pos="0.297,0.502"]
  "hjrta" [pos="0.482,0.387"]
  "corao" -&gt; "hjrta"
}' )
names( g )
</code></pre>

<hr>
<h2 id='orientPDAG'>Orient Edges in PDAG.</h2><span id='topic+orientPDAG'></span>

<h3>Description</h3>

<p>Orients as many edges as possible in a  partially directed acyclic graph (PDAG)
by converting induced subgraphs
X -&gt; Y &ndash; Z to X -&gt; Y -&gt; Z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orientPDAG(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orientPDAG_+3A_x">x</code></td>
<td>
<p>the input graph, a PDAG.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>orientPDAG( "pdag { x -&gt; y -- z }" )
</code></pre>

<hr>
<h2 id='paths'>Show Paths</h2><span id='topic+paths'></span>

<h3>Description</h3>

<p>Returns a list with two compontents: <code>path</code> gives the actual
paths, and <code>open</code> shows whether each path is open (d-connected)
or closed (d-separated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paths(
  x,
  from = exposures(x),
  to = outcomes(x),
  Z = list(),
  limit = 100,
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paths_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, PDAG, or MAG.</p>
</td></tr>
<tr><td><code id="paths_+3A_from">from</code></td>
<td>
<p>name(s) of first variable(s).</p>
</td></tr>
<tr><td><code id="paths_+3A_to">to</code></td>
<td>
<p>name(s) of last variable(s).</p>
</td></tr>
<tr><td><code id="paths_+3A_z">Z</code></td>
<td>
<p>names of variables to condition on for determining open
paths.</p>
</td></tr>
<tr><td><code id="paths_+3A_limit">limit</code></td>
<td>
<p>maximum amount of paths to show. In general, the number of paths grows
exponentially with the number of variables in the graph, such that path inspection
is not useful except for the most simple models.</p>
</td></tr>
<tr><td><code id="paths_+3A_directed">directed</code></td>
<td>
<p>logical; should only directed (i.e., causal) paths 
be shown?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sum( paths(backDoorGraph(getExample("Shrier")))$open ) # Any open Back-Door paths?

</code></pre>

<hr>
<h2 id='plot.dagitty'>Plot Graph</h2><span id='topic+plot.dagitty'></span>

<h3>Description</h3>

<p>A simple plot method to quickly visualize a graph. This is intended mainly for 
simple visualization purposes and not as a full-fledged graph drawing
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dagitty'
plot(
  x,
  abbreviate.names = FALSE,
  show.coefficients = FALSE,
  adjust.coefficients = NA,
  node.names = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dagitty_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG, MAG, or PDAG.</p>
</td></tr>
<tr><td><code id="plot.dagitty_+3A_abbreviate.names">abbreviate.names</code></td>
<td>
<p>logical. Whether to abbreviate variable names.</p>
</td></tr>
<tr><td><code id="plot.dagitty_+3A_show.coefficients">show.coefficients</code></td>
<td>
<p>logical. Whether to plot coefficients defined in the graph syntax
on the edges.</p>
</td></tr>
<tr><td><code id="plot.dagitty_+3A_adjust.coefficients">adjust.coefficients</code></td>
<td>
<p>numerical. Adjustment for coefficient labels; the distance between 
the edge labels and the midpoint of the edge can be controlled using this paramer. 
Can also be a vector of 2 numbers for separate horizontal and vertical adjustment. NA means
no adjustment (default).</p>
</td></tr>
<tr><td><code id="plot.dagitty_+3A_node.names">node.names</code></td>
<td>
<p>If not NULL, a named vector or expression list 
to rename the nodes.</p>
</td></tr>
<tr><td><code id="plot.dagitty_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>node.names</code> is not <code>NULL</code>, it should be a 
named vector of characters or expressions to use to rename (some of) 
the nodes, e.g. node <code>"X"</code> could be renamed using <code>expression(X = alpha^2)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Showing usage of "node.names"
plot(dagitty('{x[pos="0,0"]}-&gt;{y[pos="1,0"]}'), node.names=expression(x = alpha^2, y=gamma^2))


</code></pre>

<hr>
<h2 id='plotLocalTestResults'>Plot Results of Local Tests</h2><span id='topic+plotLocalTestResults'></span>

<h3>Description</h3>

<p>Generates a summary plot of the results of local tests
(see <a href="#topic+localTests">localTests</a>). For each test, a test statistic and
the confidence interval are shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotLocalTestResults(
  x,
  xlab = "test statistic (95% CI)",
  xlim = range(x[, c(ncol(x) - 1, ncol(x))]),
  sort.by.statistic = TRUE,
  n = Inf,
  axis.pars = list(las = 1),
  auto.margin = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotLocalTestResults_+3A_x">x</code></td>
<td>
<p>data frame; results of the local tests as returned by 
<a href="#topic+localTests">localTests</a>.</p>
</td></tr>
<tr><td><code id="plotLocalTestResults_+3A_xlab">xlab</code></td>
<td>
<p>X axis label.</p>
</td></tr>
<tr><td><code id="plotLocalTestResults_+3A_xlim">xlim</code></td>
<td>
<p>numerical vector with 2 elements; range of X axis.</p>
</td></tr>
<tr><td><code id="plotLocalTestResults_+3A_sort.by.statistic">sort.by.statistic</code></td>
<td>
<p>logical. Sort the rows of <code>x</code> by
the absolute value of the test statistic before plotting.</p>
</td></tr>
<tr><td><code id="plotLocalTestResults_+3A_n">n</code></td>
<td>
<p>plot only the n tests for which the absolute value of 
the test statistics diverges most from 0.</p>
</td></tr>
<tr><td><code id="plotLocalTestResults_+3A_axis.pars">axis.pars</code></td>
<td>
<p>arguments to be passed on to <code><a href="graphics.html#topic+axis">axis</a></code>
when generating the Y axis for the plot.</p>
</td></tr>
<tr><td><code id="plotLocalTestResults_+3A_auto.margin">auto.margin</code></td>
<td>
<p>logical. Computes the left margin to fit the 
Y axis labels.</p>
</td></tr>
<tr><td><code id="plotLocalTestResults_+3A_...">...</code></td>
<td>
<p>further arguments to be passed on to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- simulateSEM("dag{X-&gt;{U1 M2}-&gt;Y U1-&gt;M1}",.6,.6)
par(mar=c(2,8,1,1)) # so we can see the test names
plotLocalTestResults(localTests( "dag{ X -&gt; {M1 M2} -&gt; Y }", d, "cis" ))

</code></pre>

<hr>
<h2 id='randomDAG'>Generate DAG at Random</h2><span id='topic+randomDAG'></span>

<h3>Description</h3>

<p>Generates a random DAG with N variables called x1,...,xN. For each
pair of variables xi,xj with i&lt;j, an edge i-&gt;j will be present with
probability p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomDAG(N, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomDAG_+3A_n">N</code></td>
<td>
<p>desired number of variables.</p>
</td></tr>
<tr><td><code id="randomDAG_+3A_p">p</code></td>
<td>
<p>connectivity parameter, a number between 0 and 1.</p>
</td></tr>
</table>

<hr>
<h2 id='simulateLogistic'>Simulate Binary Data from DAG Structure</h2><span id='topic+simulateLogistic'></span>

<h3>Description</h3>

<p>Interprets input DAG as a structural description of a logistic
model in which each variable is binary and its log-odds ratio is 
a linear combination of its parent values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateLogistic(
  x,
  b.default = NULL,
  b.lower = -0.6,
  b.upper = 0.6,
  eps = 0,
  N = 500,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateLogistic_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG (which may contain bidirected edges).</p>
</td></tr>
<tr><td><code id="simulateLogistic_+3A_b.default">b.default</code></td>
<td>
<p>default path coefficient applied to arrows for which no coefficient is 
defined in the model syntax.</p>
</td></tr>
<tr><td><code id="simulateLogistic_+3A_b.lower">b.lower</code></td>
<td>
<p>lower bound for random path coefficients, applied if <code>b.default=NULL</code>.</p>
</td></tr>
<tr><td><code id="simulateLogistic_+3A_b.upper">b.upper</code></td>
<td>
<p>upper bound for path coefficients.</p>
</td></tr>
<tr><td><code id="simulateLogistic_+3A_eps">eps</code></td>
<td>
<p>base log-odds ratio.</p>
</td></tr>
<tr><td><code id="simulateLogistic_+3A_n">N</code></td>
<td>
<p>number of samples to generate.</p>
</td></tr>
<tr><td><code id="simulateLogistic_+3A_verbose">verbose</code></td>
<td>
<p>logical. If true, prints the order in which the data are generated (which
should be a topological order).</p>
</td></tr>
</table>

<hr>
<h2 id='simulateSEM'>Simulate Data from Structural Equation Model</h2><span id='topic+simulateSEM'></span>

<h3>Description</h3>

<p>Interprets the input graph as a structural equation model, generates random path 
coefficients, and simulates data from the model. This is a very bare-bones 
function and probably not very useful 
except for quick validation purposes (e.g. checking that an implied vanishing 
tetrad truly vanishes in simulated data). For more elaborate simulation studies, please
use the lavaan package or similar facilities in other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateSEM(
  x,
  b.default = NULL,
  b.lower = -0.6,
  b.upper = 0.6,
  eps = 1,
  N = 500,
  standardized = TRUE,
  empirical = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateSEM_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG (which may contain bidirected edges).</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_b.default">b.default</code></td>
<td>
<p>default path coefficient applied to arrows for which no coefficient is 
defined in the model syntax.</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_b.lower">b.lower</code></td>
<td>
<p>lower bound for random path coefficients, applied if <code>b.default=NULL</code>.</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_b.upper">b.upper</code></td>
<td>
<p>upper bound for path coefficients.</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_eps">eps</code></td>
<td>
<p>residual variance (only meaningful if <code>standardized=FALSE</code>).</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_n">N</code></td>
<td>
<p>number of samples to generate.</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_standardized">standardized</code></td>
<td>
<p>logical. If true, a standardized population covariance matrix
is generated (all variables have variance 1).</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_empirical">empirical</code></td>
<td>
<p>logical. If true, the empirical covariance matrix will be equal to the
population covariance matrix.</p>
</td></tr>
<tr><td><code id="simulateSEM_+3A_verbose">verbose</code></td>
<td>
<p>logical. If true, prints the generated population covariance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data are generated in the following manner. 
Each directed arrow is assigned a path coefficient that can be given using the attribute
&quot;beta&quot; in the model syntax (see the examples). All coefficients not set in this manner are
set to the <code>b.default</code> argument, or if that is not given, are chosen uniformly
at random from the interval given by <code>b.lower</code> and <code>b.upper</code> (inclusive; set
both parameters to the same value for constant path coefficients). Each bidirected 
arrow a &lt;-&gt; b is replaced by a substructure  a &lt;- L -&gt; b, where L is an exogenous latent
variable. Path coefficients on such substructures are set to <code>sqrt(x)</code>, where 
<code>x</code> is again chosen at random from the given interval; if <code>x</code> is negative,
one path coefficient is set to <code>-sqrt(x)</code> and the other to <code>sqrt(x)</code>. All
residual variances are set to <code>eps</code>.
</p>
<p>If <code>standardized=TRUE</code>, all path coefficients are interpreted as standardized coefficients.
But not all standardized coefficients are compatible with all graph structures.
For instance, the graph structure z &lt;- x -&gt; y -&gt; z is incompatible with standardized
coefficients of 0.9, since this would imply that the variance of z must be larger than
1. For large graphs with many parallel paths, it can be very difficult to find coefficients 
that work.
</p>


<h3>Value</h3>

<p>Returns a data frame containing <code>N</code> values for each variable in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data with pre-defined path coefficients of -.6
g &lt;- dagitty('dag{z -&gt; x [beta=-.6] x &lt;- y [beta=-.6] }')
x &lt;- simulateSEM( g ) 
cov(x)


</code></pre>

<hr>
<h2 id='structuralPart'>Extract Structural Part from Structural Equation Model</h2><span id='topic+structuralPart'></span>

<h3>Description</h3>

<p>Removes all observed variables from the input graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structuralPart(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structuralPart_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that x is a graph where there are edges between 
the latent variables, between the observed variables, and 
from latent to observed variables, but no edge between
a latent L and an observed X may have an arrowhead at L.
</p>

<hr>
<h2 id='toMAG'>Convert DAG to MAG.</h2><span id='topic+toMAG'></span>

<h3>Description</h3>

<p>Given a DAG, possibly with latent variables, construct a MAG that represents its
marginal independence model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toMAG(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toMAG_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>toMAG( "dag { ParentalSmoking-&gt;Smoking 
  { Profession [latent] } -&gt; {Income-&gt;Smoking}
  Genotype -&gt; {Smoking-&gt;LungCancer} }")
</code></pre>

<hr>
<h2 id='topologicalOrdering'>Get Topological Ordering of DAG</h2><span id='topic+topologicalOrdering'></span>

<h3>Description</h3>

<p>Computes a topological ordering of the nodes, i.e., a number for each node
such that every node's number is smaller than the one of all its descendants.
Bidirected edges (&lt;-&gt;) are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topologicalOrdering(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topologicalOrdering_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG</p>
</td></tr>
</table>

<hr>
<h2 id='vanishingTetrads'>List Implied Vanishing Tetrads</h2><span id='topic+vanishingTetrads'></span>

<h3>Description</h3>

<p>Interpret the given graph as a structural equation model and list all the
vanishing tetrads that it implies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanishingTetrads(x, type = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vanishingTetrads_+3A_x">x</code></td>
<td>
<p>the input graph, a DAG.</p>
</td></tr>
<tr><td><code id="vanishingTetrads_+3A_type">type</code></td>
<td>
<p>restrict output to one level of Kenny's tetrad typology.
Possible values are &quot;within&quot; (homogeneity within constructs; all four
variables have the same parents), &quot;between&quot; (homogeneity between constructs;
two pairs of variables each sharing one parent) 
and &quot;epistemic&quot; (consistency of epistemic correlations; three variables have
the same parent). By default, all tetrads are listed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with four columns, where each row of the form
i,j,k,l means that the tetrad Cov(i,j)Cov(k,l) - Cov(i,k)Cov(j,l) vanishes
(is equal to 0) according to the model.
</p>


<h3>References</h3>

<p>Kenny, D. A. (1979), Correlation and Causality. Wiley, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Specify two-factor model with 4 indicators each
g &lt;- dagitty("dag{{x1 x2 x3 x4} &lt;- x &lt;-&gt; y -&gt; {y1 y2 y3 y4}}")
latents(g) &lt;- c("x","y")

# Check how many tetrads are implied
nrow(vanishingTetrads(g))
# Check how these distribute across the typology
nrow(vanishingTetrads(g,"within"))
nrow(vanishingTetrads(g,"between"))
nrow(vanishingTetrads(g,"epistemic"))

</code></pre>

<hr>
<h2 id='VariableStatus'>Variable Statuses</h2><span id='topic+VariableStatus'></span><span id='topic+exposures'></span><span id='topic+exposures+3C-'></span><span id='topic+outcomes'></span><span id='topic+outcomes+3C-'></span><span id='topic+latents'></span><span id='topic+latents+3C-'></span><span id='topic+adjustedNodes'></span><span id='topic+adjustedNodes+3C-'></span><span id='topic+setVariableStatus'></span>

<h3>Description</h3>

<p>Get or set variables with a given status in a graph. Variables in dagitty graphs can
have one of several statuses. Variables with status <em>exposure</em> and 
<em>outcome</em> are important when determining causal effects via the functions 
<code><a href="#topic+adjustmentSets">adjustmentSets</a></code> and <code><a href="#topic+instrumentalVariables">instrumentalVariables</a></code>. Variables
with status <em>latent</em> are assumed 
to be unobserved variables or latent constructs, which is respected when deriving
testable implications of a graph via the functions 
<code><a href="#topic+impliedConditionalIndependencies">impliedConditionalIndependencies</a></code> or <code><a href="#topic+vanishingTetrads">vanishingTetrads</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exposures(x)

exposures(x) &lt;- value

outcomes(x)

outcomes(x) &lt;- value

latents(x)

latents(x) &lt;- value

adjustedNodes(x)

adjustedNodes(x) &lt;- value

setVariableStatus(x, status, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VariableStatus_+3A_x">x</code></td>
<td>
<p>the input graph, of any type.</p>
</td></tr>
<tr><td><code id="VariableStatus_+3A_value">value</code></td>
<td>
<p>character vector; names of variables to receive the given status.</p>
</td></tr>
<tr><td><code id="VariableStatus_+3A_status">status</code></td>
<td>
<p>character, one of &quot;exposure&quot;, &quot;outcome&quot; or &quot;latent&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>setVariableStatus</code> first removes the given status from all variables in the graph
that had it, and then sets it on the given variables.
For instance, if  <code>status="exposure"</code>  and <code>value="X"</code> are given, then
<code>X</code> will be the only exposure in the resulting graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- dagitty("dag{ x&lt;-&gt;m&lt;-&gt;y&lt;-x }") # m-bias graph
exposures(g) &lt;- "x"
outcomes(g) &lt;- "y"
adjustmentSets(g)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
