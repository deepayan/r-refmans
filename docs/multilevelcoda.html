<!DOCTYPE html><html><head><title>Help for package multilevelcoda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multilevelcoda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.complr'><p>Extract Compositional Data from <code>complr</code> object.</p></a></li>
<li><a href='#basesub'><p>Base Pairwise Substitution</p></a></li>
<li><a href='#bayes_factor.brmcoda'><p>Bayes Factors from Marginal Likelihoods</p></a></li>
<li><a href='#brmcoda'><p>Fit Bayesian generalised (non-)linear multilevel compositional model</p>
via full Bayesian inference</a></li>
<li><a href='#bsub'><p>Between-person Simple Substitution</p></a></li>
<li><a href='#bsubmargins'><p>Between-person Average Substitution</p></a></li>
<li><a href='#build.rg'><p>Reference Grid for <code>substitution</code> model.</p></a></li>
<li><a href='#coef.brmcoda'><p>Model Coefficients</p></a></li>
<li><a href='#compilr'><p>Indices from a (dataset of) Multilevel Composition(s) (deprecated.)</p></a></li>
<li><a href='#complr'><p>Indices from a (dataset of) Multilevel Composition(s)</p></a></li>
<li><a href='#create_substitution'><p>Constructor function for <code>substitution</code> class.</p></a></li>
<li><a href='#diagnostic-quantities-brmcoda'><p>Extract Diagnostic Quantities from <code>brmsfit</code> Models in <code>brmcoda</code></p></a></li>
<li><a href='#draws-index-brmcoda'><p>Index <code>brmcoda</code> objects</p></a></li>
<li><a href='#fitted.brmcoda'><p>Expected Values of the Posterior Predictive Distribution</p></a></li>
<li><a href='#fixef.brmcoda'><p>Population-Level Estimates</p></a></li>
<li><a href='#get-substitution'><p>Helper functions used only internally to estimate substitution model</p></a></li>
<li><a href='#is.brmcoda'><p>Checks if argument is a <code>brmcoda</code> object</p></a></li>
<li><a href='#is.complr'><p>Checks if argument is a <code>complr</code> object</p></a></li>
<li><a href='#is.substitution'><p>Checks if argument is a <code>substitution</code> object</p></a></li>
<li><a href='#launch_shinystan.brmcoda'><p>Interface to <span class="pkg">shinystan</span></p></a></li>
<li><a href='#loo.brmcoda'><p>Efficient approximate leave-one-out cross-validation (LOO)</p></a></li>
<li><a href='#mcmc_plot.brmcoda'><p>MCMC Plots Implemented in <span class="pkg">bayesplot</span></p></a></li>
<li><a href='#mcompd'><p>Multilevel Compositional Data</p></a></li>
<li><a href='#mean.complr'><p>Mean amounts and mean compositions presented in a <code>complr</code> object.</p></a></li>
<li><a href='#model.frame.brmcoda'><p>Extracting the Model Frame from a Formula or Fit from <span class="pkg">brmcoda</span> object</p></a></li>
<li><a href='#multilevelcoda_sim'><p>multilevelcoda Simulation Study Results</p></a></li>
<li><a href='#nobs.brmcoda'><p>Extract Number of Observations from <span class="pkg">brmcoda</span> object</p></a></li>
<li><a href='#pairs.brmcoda'><p>Create a matrix of output plots from a <code>brmcoda</code>'s <code>brmsfit</code> object</p></a></li>
<li><a href='#plot.brmcoda'><p>Trace and Density Plots for MCMC Draws plot</p></a></li>
<li><a href='#plot.substitution'><p>Substitution Plot</p></a></li>
<li><a href='#pp_check.brmcoda'><p>Posterior Predictive Checks for <code>brmcoda</code> Objects</p></a></li>
<li><a href='#predict.brmcoda'><p>Draws from the Posterior Predictive Distribution</p></a></li>
<li><a href='#print.brmcoda'><p>Print a Summary for a fitted <code>brmsfit</code> model in a <code>brmcoda</code> object</p></a></li>
<li><a href='#print.complr'><p>Print a Summary for a <code>complr</code> object</p></a></li>
<li><a href='#print.substitution'><p>Print a Summary for a <code>substitution</code> object</p></a></li>
<li><a href='#print.summary.complr'><p>Summary for a <code>complr</code> object</p></a></li>
<li><a href='#prior_summary.brmcoda'><p>Extract Priors of a <code>brmsfit</code> from a <code>brmcoda</code> object</p></a></li>
<li><a href='#psub'><p>Possible Pairwise Substitutions</p></a></li>
<li><a href='#ranef.brmcoda'><p>Group-Level Estimates</p></a></li>
<li><a href='#residuals.brmcoda'><p>Posterior Draws of Residuals/Predictive Errors</p></a></li>
<li><a href='#sbp'><p>Sequential Binary Partition</p></a></li>
<li><a href='#sim'><p>multilevelcoda Simulation Study results</p></a></li>
<li><a href='#sub'><p>Simple Substitution</p></a></li>
<li><a href='#submargins'><p>Average Substitution</p></a></li>
<li><a href='#substitution'><p>Multilevel Compositional Substitution Analysis</p></a></li>
<li><a href='#summary.brmcoda'><p>Create a Summary of a fitted <code>brmsfit</code> model in a <code>brmcoda</code> object</p></a></li>
<li><a href='#summary.complr'><p>Create a Summary of a <code>complr</code> object</p></a></li>
<li><a href='#summary.substitution'><p>Create a Summary of a Substitution Model represented by a <code>substitution</code> object</p></a></li>
<li><a href='#update.brmcoda'><p>Update <code>brmcoda</code> models</p></a></li>
<li><a href='#update.complr'><p>Update <code>complr</code></p></a></li>
<li><a href='#var.complr'><p>Variance of compositions presented in a <code>complr</code> object.</p></a></li>
<li><a href='#VarCorr.brmcoda'><p>Extract Variance and Correlation Components</p></a></li>
<li><a href='#vcov.brmcoda'><p>Covariance and Correlation Matrix of Population-Level Effects</p></a></li>
<li><a href='#wsub'><p>Within-person Simple Substitution</p></a></li>
<li><a href='#wsubmargins'><p>Within-person Average Substitution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Bayesian Multilevel Models for Compositional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-6-13</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://florale.github.io/multilevelcoda/">https://florale.github.io/multilevelcoda/</a>,
<a href="https://github.com/florale/multilevelcoda">https://github.com/florale/multilevelcoda</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/florale/multilevelcoda/issues">https://github.com/florale/multilevelcoda/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implement Bayesian Multilevel Modelling for compositional data 
             in a multilevel framework. Compute multilevel compositional data and 
             Isometric log ratio (ILR) at between and within-person levels, 
             fit Bayesian multilevel models for compositional predictors and outcomes, 
             and run post-hoc analyses such as isotemporal substitution models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, data.table (&ge; 1.12.0), compositions, brms, bayestestR,
extraoperators, ggplot2, foreach, future, doFuture, abind,
graphics, shiny, shinystan, plotly, hrbrthemes, bslib, DT, loo,
bayesplot, emmeans, insight</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr, withr, knitr, rmarkdown, lme4,
cmdstanr (&ge; 0.5.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-09 04:07:29 UTC; florale</td>
</tr>
<tr>
<td>Author:</td>
<td>Flora Le <a href="https://orcid.org/0000-0003-0089-8167"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Joshua F. Wiley <a href="https://orcid.org/0000-0002-0271-6702"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Flora Le &lt;13florale@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-09 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.complr'>Extract Compositional Data from <code>complr</code> object.</h2><span id='topic+as.data.frame.complr'></span><span id='topic+as.matrix.complr'></span>

<h3>Description</h3>

<p>Extract amounts and compositions in conventional formats
as data.frames, matrices, or arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'complr'
as.data.frame(x, row.names = NULL, optional = TRUE, ...)

## S3 method for class 'complr'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.complr_+3A_x">x</code></td>
<td>
<p>An object of class <code>complr</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.complr_+3A_row.names">row.names</code>, <code id="as.data.frame.complr_+3A_optional">optional</code></td>
<td>
<p>Unused and only added for consistency with
the <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> generic.</p>
</td></tr>
<tr><td><code id="as.data.frame.complr_+3A_...">...</code></td>
<td>
<p>generic argument, not in use.</p>
</td></tr>
</table>

<hr>
<h2 id='basesub'>Base Pairwise Substitution</h2><span id='topic+basesub'></span>

<h3>Description</h3>

<p>Make a data set of all possible pairwise substitution of a composition which can be used as
the base for substitution models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basesub(parts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basesub_+3A_parts">parts</code></td>
<td>
<p>A character vector specifying the names of compositional variables to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table of all possible pairwise substitution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ps1 &lt;- basesub(parts = c("TST", "WAKE", "MVPA", "LPA", "SB"))
print(ps1)

ps2 &lt;- basesub(c("WAKE", "MVPA", "LPA", "SB"))
print(ps2)
</code></pre>

<hr>
<h2 id='bayes_factor.brmcoda'>Bayes Factors from Marginal Likelihoods</h2><span id='topic+bayes_factor.brmcoda'></span>

<h3>Description</h3>

<p>Compute Bayes factors from marginal likelihoods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
bayes_factor(x1, x2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayes_factor.brmcoda_+3A_x1">x1</code></td>
<td>
<p>A <code>brmcoda</code> object.</p>
</td></tr>
<tr><td><code id="bayes_factor.brmcoda_+3A_x2">x2</code></td>
<td>
<p>Another <code>brmcoda</code> object based on the same responses.</p>
</td></tr>
<tr><td><code id="bayes_factor.brmcoda_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="brms.html#topic+bayes_factor.brmsfit">bayes_factor.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+bayes_factor.brmsfit">bayes_factor.brmsfit</a></code>
</p>

<hr>
<h2 id='brmcoda'>Fit Bayesian generalised (non-)linear multilevel compositional model
via full Bayesian inference</h2><span id='topic+brmcoda'></span>

<h3>Description</h3>

<p>Fit a <code>brm</code> model with multilevel ILR coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brmcoda(complr, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brmcoda_+3A_complr">complr</code></td>
<td>
<p>A <code><a href="#topic+complr">complr</a></code> object containing data of composition,
ILR coordinates, and other variables used in the model.</p>
</td></tr>
<tr><td><code id="brmcoda_+3A_formula">formula</code></td>
<td>
<p>A object of class <code>formula</code>, <code>brmsformula</code>:
A symbolic description of the model to be fitted.
Details of the model specification can be found in <code><a href="brms.html#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+brm">brm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+brmcoda">brmcoda</a></code> with two elements
</p>
<table>
<tr><td><code>complr</code></td>
<td>
<p> An object of class <code>complr</code> used in the <code>brm</code> model. </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> An object of class <code>brmsfit</code>, which contains the posterior draws
along with many other useful information about the model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
  cilr &lt;- complr(data = mcompd, sbp = sbp,
                 parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID")
  
  # inspects ILRs before passing to brmcoda
  names(cilr$between_logratio)
  names(cilr$within_logratio)
  names(cilr$logratio)
  
  # model with compositional predictor at between and within-person levels
  m1 &lt;- brmcoda(complr = cilr,
                formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                                   wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
                chain = 1, iter = 500,
                backend = "cmdstanr")
  
  # model with compositional outcome
  m2 &lt;- brmcoda(complr = cilr,
                formula = mvbind(ilr1, ilr2, ilr3, ilr4) ~ Stress + Female + (1 | ID),
                chain = 1, iter = 500,
                backend = "cmdstanr")
  }
</code></pre>

<hr>
<h2 id='bsub'>Between-person Simple Substitution</h2><span id='topic+bsub'></span>

<h3>Description</h3>

<p>This function is an alias of <code><a href="#topic+substitution">substitution</a></code> to estimates the the difference in an outcome
when compositional parts are substituted for specific unit(s) at <em>between</em> level
using a single reference composition (e.g., compositional mean at sample level).
It is recommended that users run substitution model using the <code><a href="#topic+substitution">substitution</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsub(
  object,
  delta,
  basesub,
  summary = TRUE,
  ref = "grandmean",
  level = "between",
  weight = "equal",
  scale = c("response", "linear"),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsub_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="bsub_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the amount of substituted change between compositional parts.</p>
</td></tr>
<tr><td><code id="bsub_+3A_basesub">basesub</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> of the base possible substitution of compositional parts.
This data set can be computed using function <code><a href="#topic+basesub">basesub</a></code>.
If <code>NULL</code>, all possible pairwise substitution of compositional parts are used.</p>
</td></tr>
<tr><td><code id="bsub_+3A_summary">summary</code></td>
<td>
<p>A logical value.
Should the estimate at each level of the reference grid (<code>FALSE</code>)
or their average (<code>TRUE</code>) be returned?
Default is <code>TRUE</code>.
Only applicable for model with covariates in addition to
the isometric log-ratio coordinates (i.e., adjusted model).</p>
</td></tr>
<tr><td><code id="bsub_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="bsub_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="bsub_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="bsub_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale of the response variable.
If <code>"linear"</code>, results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or other transformations.</p>
</td></tr>
<tr><td><code id="bsub_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
we recommend setting the <code>mc.cores</code> option
to be as many processors as the hardware and RAM allow (up to the number of compositional parts).
For non-Windows OS in non-interactive R sessions, forking is used instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="bsub_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of multilevel compositional substitution model.
The first six lists contain the results of the substitution estimation for a compositional part.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+substitution">substitution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
cilr &lt;- complr(data = mcompd, sbp = sbp, 
               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID", total = 1440)

# model with compositional predictor at between and between-person levels
m &lt;- brmcoda(complr = cilr, 
             formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 + 
                                wilr1 + wilr2 + wilr3 + wilr4 + Female + (1 | ID), 
             chain = 1, iter = 500,
             backend = "cmdstanr")
subm &lt;- bsub(object = m, basesub = psub, delta = 5)
}
</code></pre>

<hr>
<h2 id='bsubmargins'>Between-person Average Substitution</h2><span id='topic+bsubmargins'></span>

<h3>Description</h3>

<p>This function is an alias of <code><a href="#topic+substitution">substitution</a></code> to estimates the the difference in an outcome
when compositional parts are substituted for specific unit(s) at <em>between</em> level
using cluster mean (e.g., compositional mean at individual level) as reference composition.
It is recommended that users run substitution model using the <code><a href="#topic+substitution">substitution</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsubmargins(
  object,
  delta,
  basesub,
  ref = "clustermean",
  level = "between",
  weight = "proportional",
  scale = c("response", "linear"),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bsubmargins_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the amount of substituted change between compositional parts.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_basesub">basesub</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> of the base possible substitution of compositional parts.
This data set can be computed using function <code><a href="#topic+basesub">basesub</a></code>.
If <code>NULL</code>, all possible pairwise substitution of compositional parts are used.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale of the response variable.
If <code>"linear"</code>, results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or other transformations.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
we recommend setting the <code>mc.cores</code> option
to be as many processors as the hardware and RAM allow (up to the number of compositional parts).
For non-Windows OS in non-interactive R sessions, forking is used instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="bsubmargins_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of multilevel compositional substitution model.
The first six lists contain the results of the substitution estimation for a compositional part.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+substitution">substitution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
cilr &lt;- complr(data = mcompd[ID %in% 1:10, .SD[1:3], by = ID], sbp = sbp, 
               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID", total = 1440)

m &lt;- brmcoda(complr = cilr, 
             formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 + wilr1 + 
                                wilr2 + wilr3 + wilr4 + Female + (1 | ID), 
             chains = 1, iter = 500,
             backend = "cmdstanr")
             
subm &lt;- bsubmargins(object = m, basesub = psub, delta = 5)
}
</code></pre>

<hr>
<h2 id='build.rg'>Reference Grid for <code>substitution</code> model.</h2><span id='topic+build.rg'></span>

<h3>Description</h3>

<p>Build a dataset for <code>fitted.brmcoda</code> used in <code>substitution</code> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.rg(object, ref, level, weight, fill = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.rg_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="build.rg_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="build.rg_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="build.rg_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="build.rg_+3A_fill">fill</code></td>
<td>
<p>Logical value only relevant when <code>ref</code> is an user's specified reference grid
in which information about some, but not all covariates is provided
(e.g., models including age and sex as covariate but only age was provided in the reference grid).
If <code>TRUE</code>, the unspecified covariates are filled with the default reference grid.
If <code>FALSE</code>, users will be asked to provide a full reference grid.
Currently only support the default to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A reference grid consisting of a combination of covariates in <code>brmcoda</code>
</p>

<hr>
<h2 id='coef.brmcoda'>Model Coefficients</h2><span id='topic+coef.brmcoda'></span><span id='topic+coef'></span>

<h3>Description</h3>

<p>Extract model coefficients, which are the sum of population-level
effects and corresponding group-level effects
of the <code>brmsfit</code> object in a <code>brmcoda</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="coef.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+coef.brmsfit">coef.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3D arrays (one per grouping factor).
If <code>summary</code> is <code>TRUE</code>,
the 1st dimension contains the factor levels,
the 2nd dimension contains the summary statistics
(see <code><a href="brms.html#topic+posterior_summary">posterior_summary</a></code>), and
the 3rd dimension contains the group-level effects.
If <code>summary</code> is <code>FALSE</code>, the 1st dimension contains
the posterior draws, the 2nd dimension contains the factor levels,
and the 3rd dimension contains the group-level effects.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+coef.brmsfit">coef.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a model
if(requireNamespace("cmdstanr")){
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  ## extract population and group-level coefficients separately
  fixef(m)
  ranef(m)
  
  ## extract combined coefficients
  coef(m)
}
</code></pre>

<hr>
<h2 id='compilr'>Indices from a (dataset of) Multilevel Composition(s) (deprecated.)</h2><span id='topic+compilr'></span>

<h3>Description</h3>

<p>Indices from a (dataset of) Multilevel Composition(s) (deprecated.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compilr(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compilr_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+complr">complr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+complr">complr</a></code> object with at least the following elements.
</p>
<table>
<tr><td><code>comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed composition
or a matrix of class <code>acomp</code> representing multiple closed  compositions each in one row.</p>
</td></tr>
<tr><td><code>between_comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed between-person composition
or a matrix of class <code>acomp</code> representing multiple closed between-person compositions each in one row.</p>
</td></tr>
<tr><td><code>within_comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed within-person composition
or a matrix of class <code>acomp</code> representing multiple closed within-person compositions each in one row.</p>
</td></tr>
<tr><td><code>logratio</code></td>
<td>
<p> Log ratio transform of composition.</p>
</td></tr>
<tr><td><code>between_logratio</code></td>
<td>
<p> Log ratio transform of between-person composition.</p>
</td></tr>
<tr><td><code>within_logratio</code></td>
<td>
<p> Log ratio transform of within-person composition.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> The user's dataset or imputed dataset if the input data contains zeros.</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p> Type of transform applied on compositional data.</p>
</td></tr>
<tr><td><code>parts</code></td>
<td>
<p> Names of compositional variables.</p>
</td></tr>
<tr><td><code>idvar</code></td>
<td>
<p> Name of the variable containing IDs.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p> Total amount to which the compositions is closed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+complr">complr</a></code>
</p>

<hr>
<h2 id='complr'>Indices from a (dataset of) Multilevel Composition(s)</h2><span id='topic+complr'></span>

<h3>Description</h3>

<p>Compute sets of compositions and log ratio transformation for multilevel compositional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complr(data, parts, sbp = NULL, total = 1, idvar = NULL, transform = "ilr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complr_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code>
containing data of all variables used in the analysis.
It must include a composition and a ID variable. Required.</p>
</td></tr>
<tr><td><code id="complr_+3A_parts">parts</code></td>
<td>
<p>A character vector specifying the names of compositional variables to be used.</p>
</td></tr>
<tr><td><code id="complr_+3A_sbp">sbp</code></td>
<td>
<p>A signary matrix indicating sequential binary partition.</p>
</td></tr>
<tr><td><code id="complr_+3A_total">total</code></td>
<td>
<p>A numeric value of the total amount to which the compositions should be closed.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="complr_+3A_idvar">idvar</code></td>
<td>
<p>Only for multilevel data, a character string specifying the name of the variable containing IDs.</p>
</td></tr>
<tr><td><code id="complr_+3A_transform">transform</code></td>
<td>
<p>A character value naming a log ratio transformation to be applied on compositional data.
Can be either <code>"ilr"</code> (isometric logratio), <code>"alr"</code> (additive logratio), or <code>"clr"</code> (centered logratio).
Default is <code>"ilr"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>ilr</em>-transform maps the D-part compositional data from the simplex into non-overlapping
subgroups in the (D-1)-dimension Euclidean space isometrically by using an orthonormal basis,
thereby preserving the compositional properties and yielding a full-rank covariance matrix.
<em>ilr</em> transformation should be preferred.
However, the <em>alr</em> and <em>clr</em> are alternatives.
The <em>alr</em>-transform maps a D-part composition
in the Aitchison-simplex non-isometrically to a
(D-1)-dimension Euclidian vectors,
commonly treating the last part as the common denominator of the others.
<em>alr</em> transformation does not rely on distance which breaks
the constraint of compositional data.
<em>clr</em>-transform maps a D-part composition in the Aitchison-simplex
isometrically to a D-dimensional Euclidian vector subspace.
<em>clr</em> transformation is not injetive,
resulting in singular covariance matrices.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+complr">complr</a></code> object with at least the following elements.
</p>
<table>
<tr><td><code>comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed composition
or a matrix of class <code>acomp</code> representing multiple closed  compositions each in one row.</p>
</td></tr>
<tr><td><code>between_comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed between-person composition
or a matrix of class <code>acomp</code> representing multiple closed between-person compositions each in one row.</p>
</td></tr>
<tr><td><code>within_comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed within-person composition
or a matrix of class <code>acomp</code> representing multiple closed within-person compositions each in one row.</p>
</td></tr>
<tr><td><code>logratio</code></td>
<td>
<p> Log ratio transform of composition.</p>
</td></tr>
<tr><td><code>between_logratio</code></td>
<td>
<p> Log ratio transform of between-person composition.</p>
</td></tr>
<tr><td><code>within_logratio</code></td>
<td>
<p> Log ratio transform of within-person composition.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> The user's dataset or imputed dataset if the input data contains zeros.</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p> Type of transform applied on compositional data.</p>
</td></tr>
<tr><td><code>parts</code></td>
<td>
<p> Names of compositional variables.</p>
</td></tr>
<tr><td><code>idvar</code></td>
<td>
<p> Name of the variable containing IDs.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p> Total amount to which the compositions is closed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cilr &lt;- complr(data = mcompd, sbp = sbp,
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                idvar = "ID", total = 1440)
str(cilr)

calr &lt;- complr(data = mcompd, sbp = sbp,
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                idvar = "ID",
                transform = "alr")
str(calr)

cclr &lt;- complr(data = mcompd, sbp = sbp,
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                idvar = "ID",
                 transform = "clr")
str(cclr)

cilr_wide &lt;- complr(data = mcompd[!duplicated(ID)], sbp = sbp,
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"))
str(cilr_wide)
</code></pre>

<hr>
<h2 id='create_substitution'>Constructor function for <code>substitution</code> class.</h2><span id='topic+create_substitution'></span>

<h3>Description</h3>

<p>Constructor function for <code>substitution</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_substitution(
  between_simple_sub,
  within_simple_sub,
  simple_sub,
  between_avg_sub,
  within_avg_sub,
  avg_sub,
  delta,
  ref,
  level,
  weight,
  parts,
  summary
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_substitution_+3A_between_simple_sub">between_simple_sub</code></td>
<td>
<p>A list of results from <code>bsub</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="create_substitution_+3A_within_simple_sub">within_simple_sub</code></td>
<td>
<p>A list of results from <code>wsub</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="create_substitution_+3A_simple_sub">simple_sub</code></td>
<td>
<p>A list of results from <code>sub</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="create_substitution_+3A_between_avg_sub">between_avg_sub</code></td>
<td>
<p>A list of results from <code>bsubmargins</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="create_substitution_+3A_within_avg_sub">within_avg_sub</code></td>
<td>
<p>A list of results from <code>wsubmargins</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="create_substitution_+3A_avg_sub">avg_sub</code></td>
<td>
<p>A list of results from <code>submargins</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="create_substitution_+3A_delta">delta</code></td>
<td>
<p>A numeric vector of the amount of substitution</p>
</td></tr>
<tr><td><code id="create_substitution_+3A_ref">ref</code></td>
<td>
<p>A character value specifying the reference grid</p>
</td></tr>
<tr><td><code id="create_substitution_+3A_level">level</code></td>
<td>
<p>A character value specifying the level of substitution</p>
</td></tr>
<tr><td><code id="create_substitution_+3A_weight">weight</code></td>
<td>
<p>The weight to use in calculation of the reference composition</p>
</td></tr>
<tr><td><code id="create_substitution_+3A_parts">parts</code></td>
<td>
<p>The parts of the composition</p>
</td></tr>
<tr><td><code id="create_substitution_+3A_summary">summary</code></td>
<td>
<p>A logical value specifying whether to summarize the results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>substitution</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+substitution">substitution</a></code>
</p>

<hr>
<h2 id='diagnostic-quantities-brmcoda'>Extract Diagnostic Quantities from <code>brmsfit</code> Models in <code>brmcoda</code></h2><span id='topic+diagnostic-quantities-brmcoda'></span><span id='topic+log_posterior'></span><span id='topic+nuts_params'></span><span id='topic+rhat'></span><span id='topic+neff_ratio'></span><span id='topic+log_posterior.brmcoda'></span><span id='topic+nuts_params.brmcoda'></span><span id='topic+rhat.brmcoda'></span><span id='topic+neff_ratio.brmcoda'></span>

<h3>Description</h3>

<p>Extract Diagnostic Quantities from <code>brmsfit</code> Models in <code>brmcoda</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
log_posterior(object, ...)

## S3 method for class 'brmcoda'
nuts_params(object, ...)

## S3 method for class 'brmcoda'
rhat(x, ...)

## S3 method for class 'brmcoda'
neff_ratio(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic-quantities-brmcoda_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
<tr><td><code id="diagnostic-quantities-brmcoda_+3A_x">x</code>, <code id="diagnostic-quantities-brmcoda_+3A_object">object</code></td>
<td>
<p>A <code>brmcoda</code> object or another <span class="rlang"><b>R</b></span> object for which
the methods are defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The exact form of the output depends on the method.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+log_posterior.brmsfit">log_posterior.brmsfit</a></code>
</p>
<p><code><a href="brms.html#topic+nuts_params.brmsfit">nuts_params.brmsfit</a></code>
</p>
<p><code><a href="brms.html#topic+rhat.brmsfit">rhat.brmsfit</a></code>
</p>
<p><code><a href="brms.html#topic+neff_ratio.brmsfit">neff_ratio.brmsfit</a></code>
</p>

<hr>
<h2 id='draws-index-brmcoda'>Index <code>brmcoda</code> objects</h2><span id='topic+draws-index-brmcoda'></span><span id='topic+variables'></span><span id='topic+nvariables'></span><span id='topic+niterations'></span><span id='topic+nchains'></span><span id='topic+ndraws'></span><span id='topic+variables.brmcoda'></span><span id='topic+nvariables.brmcoda'></span><span id='topic+niterations.brmcoda'></span><span id='topic+nchains.brmcoda'></span><span id='topic+ndraws.brmcoda'></span>

<h3>Description</h3>

<p>Index <code>brmcoda</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
variables(x, ...)

## S3 method for class 'brmcoda'
nvariables(x, ...)

## S3 method for class 'brmcoda'
niterations(x)

## S3 method for class 'brmcoda'
nchains(x)

## S3 method for class 'brmcoda'
ndraws(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draws-index-brmcoda_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="draws-index-brmcoda_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+variables">variables.brmsfit</a></code>
</p>
<p><code><a href="brms.html#topic+nvariables.brmsfit">nvariables.brmsfit</a></code>
</p>
<p><code><a href="brms.html#topic+niterations.brmsfit">niterations.brmsfit</a></code>
</p>
<p><code><a href="brms.html#topic+nchains.brmsfit">nchains.brmsfit</a></code>
</p>
<p><code><a href="brms.html#topic+ndraws.brmsfit">ndraws.brmsfit</a></code>
</p>

<hr>
<h2 id='fitted.brmcoda'>Expected Values of the Posterior Predictive Distribution</h2><span id='topic+fitted.brmcoda'></span><span id='topic+fitted'></span>

<h3>Description</h3>

<p>Compute posterior draws of the expected value of the posterior predictive
distribution of a <code>brmsfit</code> model in the <code>brmcoda</code> object.
Can be performed for the data used to fit the model (posterior
predictive checks) or for new data. By definition, these predictions have
smaller variance than the posterior predictions performed by the
<code><a href="#topic+predict.brmcoda">predict.brmcoda</a></code> method. This is because only the
uncertainty in the expected value of the posterior predictive distribution is
incorporated in the draws computed by <code>fitted</code> while the
residual error is ignored there. However, the estimated means of both methods
averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
fitted(object, scale = c("linear", "response"), summary = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="fitted.brmcoda_+3A_scale">scale</code></td>
<td>
<p>Specifically for models with compositional responses,
either <code>"response"</code> or <code>"linear"</code>.
If <code>"linear"</code>,
results are returned on the log-ratio scale.
If <code>"response"</code>, results are returned on the compositional scale
of the response variable.</p>
</td></tr>
<tr><td><code id="fitted.brmcoda_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+fitted.brmsfit">fitted.brmsfit</a></code>
that control additional aspects of prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>array</code> of predicted <em>mean</em> response values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="brms.html#topic+posterior_epred.brmsfit">posterior_epred.brmsfit</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output depends on the family: For categorical
and ordinal families, the output is an N x E x C array, where N is the
number of observations, E is the number of summary statistics, and C is the
number of categories. For all other families, the output is an N x E
matrix. The number of summary statistics E is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>
<p>In multivariate models, an additional dimension is added to the output
which indexes along the different response variables.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+fitted.brmsfit">fitted.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a model
if(requireNamespace("cmdstanr")){
  ## compute composition and ilr coordinates
  cilr &lt;- complr(data = mcompd, sbp = sbp,
                 parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                 idvar = "ID", total = 1440)
  
  ## fit a model
  m1 &lt;- brmcoda(complr = cilr,
                formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                  wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
                chain = 1, iter = 500,
                backend = "cmdstanr")
  
  ## compute expected predictions
  epred &lt;- fitted(m1)
  head(epred)
  
  ## fit a model with compositional outcome
  m2 &lt;- brmcoda(complr = cilr,
                formula = mvbind(ilr1, ilr2, ilr3, ilr4) ~ Stress + Female + (1 | ID),
                chain = 1, iter = 500,
                backend = "cmdstanr")
  
  ## expected predictions on compositional scale
  epredcomp &lt;- fitted(m2, scale = "response")
  head(epredcomp)
}
</code></pre>

<hr>
<h2 id='fixef.brmcoda'>Population-Level Estimates</h2><span id='topic+fixef.brmcoda'></span><span id='topic+fixef'></span>

<h3>Description</h3>

<p>Extract the population-level ('fixed') effects
from the <code>brmsfit</code> object in a <code>brmcoda</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
fixef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixef.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="fixef.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+fixef.brmsfit">fixef.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>summary</code> is <code>TRUE</code>, a matrix returned
by <code><a href="brms.html#topic+posterior_summary">posterior_summary</a></code> for the population-level effects.
If <code>summary</code> is <code>FALSE</code>, a matrix with one row per
posterior draw and one column per population-level effect.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+fixef.brmsfit">fixef.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a model
if(requireNamespace("cmdstanr")){
  ## fit a model
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  ## extract population-Level coefficients
  fixef(m)
}
</code></pre>

<hr>
<h2 id='get-substitution'>Helper functions used only internally to estimate substitution model</h2><span id='topic+get-substitution'></span>

<h3>Description</h3>

<p>Helper functions used only internally to estimate substitution model
</p>

<hr>
<h2 id='is.brmcoda'>Checks if argument is a <code>brmcoda</code> object</h2><span id='topic+is.brmcoda'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>brmcoda</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.brmcoda(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.brmcoda_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='is.complr'>Checks if argument is a <code>complr</code> object</h2><span id='topic+is.complr'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>complr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.complr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.complr_+3A_x">x</code></td>
<td>
<p>An object of class <code>complr</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='is.substitution'>Checks if argument is a <code>substitution</code> object</h2><span id='topic+is.substitution'></span>

<h3>Description</h3>

<p>Checks if argument is a <code>substitution</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.substitution(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.substitution_+3A_x">x</code></td>
<td>
<p>An object of class <code>substitution</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='launch_shinystan.brmcoda'>Interface to <span class="pkg">shinystan</span></h2><span id='topic+launch_shinystan.brmcoda'></span><span id='topic+launch_shinystan'></span>

<h3>Description</h3>

<p>Provide an interface to <span class="pkg">shinystan</span> for models fitted with <span class="pkg">brms</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
launch_shinystan(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launch_shinystan.brmcoda_+3A_object">object</code></td>
<td>
<p>A fitted model object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="launch_shinystan.brmcoda_+3A_...">...</code></td>
<td>
<p>Optional arguments to pass to
<code><a href="shinystan.html#topic+launch_shinystan">launch_shinystan</a></code> or
<code><a href="shiny.html#topic+runApp">runApp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 shinystan object
</p>


<h3>See Also</h3>

<p><code><a href="shinystan.html#topic+launch_shinystan">launch_shinystan</a></code>
</p>

<hr>
<h2 id='loo.brmcoda'>Efficient approximate leave-one-out cross-validation (LOO)</h2><span id='topic+loo.brmcoda'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p>Perform approximate leave-one-out cross-validation based
on the posterior likelihood using the <span class="pkg">loo</span> package.
For more details see <code><a href="loo.html#topic+loo">loo</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
loo(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.brmcoda_+3A_x">x</code></td>
<td>
<p>A <code>brmcoda</code> object.</p>
</td></tr>
<tr><td><code id="loo.brmcoda_+3A_...">...</code></td>
<td>
<p>More <code>brmsfit</code> objects or further arguments
passed to the underlying post-processing functions.
In particular, see <code><a href="brms.html#topic+prepare_predictions">prepare_predictions</a></code> for further
supported arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If just one object is provided, an object of class <code>loo</code>.
If multiple objects are provided, an object of class <code>loolist</code>.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+loo.brmsfit">loo.brmsfit</a></code>
</p>

<hr>
<h2 id='mcmc_plot.brmcoda'>MCMC Plots Implemented in <span class="pkg">bayesplot</span></h2><span id='topic+mcmc_plot.brmcoda'></span>

<h3>Description</h3>

<p>Call MCMC plotting functions
implemented in the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
mcmc_plot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_plot.brmcoda_+3A_object">object</code></td>
<td>
<p>A <code>brmcoda</code> class object.</p>
</td></tr>
<tr><td><code id="mcmc_plot.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+mcmc_plot.brmsfit">mcmc_plot.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
that can be further customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+mcmc_plot.brmsfit">mcmc_plot.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cilr &lt;- complr(data = mcompd, sbp = sbp,
        parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID")

# model with compositional predictor at between and within-person levels
fit &lt;- brmcoda(complr = cilr,
               formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                                 wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
               chain = 1, iter = 500)
mcmc_plot(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='mcompd'>Multilevel Compositional Data</h2><span id='topic+mcompd'></span>

<h3>Description</h3>

<p>A simulated dataset containing multiple days of compositional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcompd
</code></pre>


<h3>Format</h3>

<p>A data table containing 10 variables.
</p>

<dl>
<dt>ID</dt><dd><p>A unique identifier for each individual</p>
</dd>
<dt>Time</dt><dd><p>Recurrence time of repeated measures by individual</p>
</dd>
<dt>Stress</dt><dd><p>Self report stress measures on a 0 to 10 scale &mdash; repeated measure</p>
</dd>
<dt>TST</dt><dd><p>Total Sleep Time (minutes) &mdash; repeated measure</p>
</dd>
<dt>WAKE</dt><dd><p>Wake time while in bed, trying to sleep (minutes) &mdash; repeated measure</p>
</dd>
<dt>MVPA</dt><dd><p>Moderate to Vigorous Physical Activity (minutes) &mdash; repeated measure</p>
</dd>
<dt>LPA</dt><dd><p>Light Physical Activity (minutes) &mdash; repeated measure</p>
</dd>
<dt>SB</dt><dd><p>Sedentary Behavior (minutes) &mdash; repeated measure</p>
</dd>
<dt>Age</dt><dd><p>Age in years &mdash; baseline measure only</p>
</dd>
<dt>Female</dt><dd><p>Binary: whether participants identified as female (1) or not (0) &mdash; baseline measure only</p>
</dd>
</dl>


<hr>
<h2 id='mean.complr'>Mean amounts and mean compositions presented in a <code>complr</code> object.</h2><span id='topic+mean.complr'></span>

<h3>Description</h3>

<p>Mean amounts and mean compositions presented in a <code>complr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'complr'
mean(x, weight = c("equal", "proportional"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.complr_+3A_x">x</code></td>
<td>
<p>An object of class <code>complr</code>.</p>
</td></tr>
<tr><td><code id="mean.complr_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals)
Default is <code>equal</code>.</p>
</td></tr>
<tr><td><code id="mean.complr_+3A_...">...</code></td>
<td>
<p>generic argument, not in use.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cilr &lt;- complr(data = mcompd, sbp = sbp, 
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), 
                idvar = "ID")
mean(cilr)
</code></pre>

<hr>
<h2 id='model.frame.brmcoda'>Extracting the Model Frame from a Formula or Fit from <span class="pkg">brmcoda</span> object</h2><span id='topic+model.frame.brmcoda'></span>

<h3>Description</h3>

<p>Extracting the Model Frame from a Formula or Fit from <span class="pkg">brmcoda</span> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
model.frame(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.brmcoda_+3A_formula">formula</code></td>
<td>
<p>A <code>brmcoda</code> object.</p>
</td></tr>
<tr><td><code id="model.frame.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='multilevelcoda_sim'>multilevelcoda Simulation Study Results</h2><span id='topic+multilevelcoda_sim'></span>

<h3>Description</h3>

<p>Provide the full results for a simulation study testing the performance of <span class="pkg">multilevelcoda</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilevelcoda_sim()
</code></pre>


<h3>Value</h3>

<p>An S4 shiny object
</p>

<hr>
<h2 id='nobs.brmcoda'>Extract Number of Observations from <span class="pkg">brmcoda</span> object</h2><span id='topic+nobs.brmcoda'></span>

<h3>Description</h3>

<p>Extract Number of Observations from <span class="pkg">brmcoda</span> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.brmcoda_+3A_object">object</code></td>
<td>
<p>A <code>brmcoda</code> object.</p>
</td></tr>
<tr><td><code id="nobs.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='pairs.brmcoda'>Create a matrix of output plots from a <code><a href="#topic+brmcoda">brmcoda</a></code>'s <code><a href="brms.html#topic+brmsfit">brmsfit</a></code> object</h2><span id='topic+pairs.brmcoda'></span>

<h3>Description</h3>

<p>A <code><a href="graphics.html#topic+pairs">pairs</a></code>
method that is customized for MCMC output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
pairs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.brmcoda_+3A_x">x</code></td>
<td>
<p>A <code>brmcoda</code> class object.</p>
</td></tr>
<tr><td><code id="pairs.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+pairs.brmsfit">pairs.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+pairs.brmsfit">pairs.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cilr &lt;- complr(data = mcompd, sbp = sbp,
        parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID")

# model with compositional predictor at between and within-person levels
fit &lt;- brmcoda(complr = cilr,
               formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                                 wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
               chain = 1, iter = 500)
pairs(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.brmcoda'>Trace and Density Plots for MCMC Draws plot</h2><span id='topic+plot.brmcoda'></span>

<h3>Description</h3>

<p>Make a plot of <code>brmcoda</code> model results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.brmcoda_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+brmcoda">brmcoda</a></code> class object.</p>
</td></tr>
<tr><td><code id="plot.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+plot.brmsfit">plot.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible list of
<code><a href="gtable.html#topic+gtable">gtable</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+plot.brmsfit">plot.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cilr &lt;- complr(data = mcompd, sbp = sbp,
        parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID")

# model with compositional predictor at between and within-person levels
fit &lt;- brmcoda(complr = cilr,
               formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                                 wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
               chain = 1, iter = 500)
plot(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.substitution'>Substitution Plot</h2><span id='topic+plot.substitution'></span>

<h3>Description</h3>

<p>Make a plot of <code><a href="#topic+substitution">substitution</a></code> model results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'substitution'
plot(x, to, ref, level, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.substitution_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+substitution">substitution</a></code> class object.</p>
</td></tr>
<tr><td><code id="plot.substitution_+3A_to">to</code></td>
<td>
<p>A character value or vector specifying the names of the compositional parts
that were reallocated to in the model.</p>
</td></tr>
<tr><td><code id="plot.substitution_+3A_ref">ref</code></td>
<td>
<p>A character value of ((<code>"grandmean"</code> or <code>"clustermean"</code> or <code>"users"</code>),</p>
</td></tr>
<tr><td><code id="plot.substitution_+3A_level">level</code></td>
<td>
<p>A character value of (<code>"between"</code>, <code>"within"</code>), or <code>"aggregate"</code>).</p>
</td></tr>
<tr><td><code id="plot.substitution_+3A_...">...</code></td>
<td>
<p>Further components to the plot, followed by a plus sign (+).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot graph object showing the estimated difference in outcome when
each pair of compositional variables are substituted for a specific time.
</p>

<hr>
<h2 id='pp_check.brmcoda'>Posterior Predictive Checks for <code>brmcoda</code> Objects</h2><span id='topic+pp_check.brmcoda'></span><span id='topic+pp_check'></span>

<h3>Description</h3>

<p>Perform posterior predictive checks with the help of the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
pp_check(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pp_check.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="pp_check.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+predict.brmsfit">predict.brmsfit</a></code>
as well as to the PPC function specified in <code>type</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+pp_check.brmsfit">pp_check.brmsfit</a></code>
</p>

<hr>
<h2 id='predict.brmcoda'>Draws from the Posterior Predictive Distribution</h2><span id='topic+predict.brmcoda'></span><span id='topic+predict'></span>

<h3>Description</h3>

<p>Compute posterior draws of the posterior predictive distribution
of a <code>brmsfit</code> model in the <code>brmcoda</code> object.
Can be performed for the data used to fit the model (posterior predictive checks) or
for new data. By definition, these draws have higher variance than draws
of the expected value of the posterior predictive distribution computed by
<code><a href="#topic+fitted.brmcoda">fitted.brmcoda</a></code>. This is because the residual error
is incorporated in <code>posterior_predict</code>. However, the estimated means of
both methods averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
predict(object, scale = c("linear", "response"), summary = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="predict.brmcoda_+3A_scale">scale</code></td>
<td>
<p>Specifically for models with compositional responses,
either <code>"response"</code> or <code>"linear"</code>.
If <code>"linear"</code>,
results are returned on the log-ratio scale.
If <code>"response"</code>, results are returned on the compositional scale
of the response variable.</p>
</td></tr>
<tr><td><code id="predict.brmcoda_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+predict.brmsfit">predict.brmsfit</a></code>
that control additional aspects of prediction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>array</code> of predicted response values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="brms.html#topic+posterior_predict.brmsfit">posterior_predict.brmsfit</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output depends on the family: For categorical
and ordinal families, the output is an N x C matrix, where N is the number
of observations, C is the number of categories, and the values are
predicted category probabilities. For all other families, the output is a N
x E matrix where E = <code>2 + length(probs)</code> is the number of summary
statistics: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+predict.brmsfit">predict.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
  ## fit a model
  cilr &lt;- complr(data = mcompd, sbp = sbp,
                 parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                 idvar = "ID", total = 1440)
  
  m1 &lt;- brmcoda(complr = cilr,
                formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                  wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
                chain = 1, iter = 500,
                backend = "cmdstanr")
  
  ## predicted responses
  pred &lt;- predict(m1)
  head(pred)
  
  ## fit a model with compositional outcome
  m2 &lt;- brmcoda(complr = cilr,
                formula = mvbind(ilr1, ilr2, ilr3, ilr4) ~ Stress + Female + (1 | ID),
                chain = 1, iter = 500,
                backend = "cmdstanr")
  
  ## predicted responses on compositional scale
  predcomp &lt;- predict(m2, scale = "linear")
  head(predcomp)
}
</code></pre>

<hr>
<h2 id='print.brmcoda'>Print a Summary for a fitted <code>brmsfit</code> model in a <code>brmcoda</code> object</h2><span id='topic+print.brmcoda'></span>

<h3>Description</h3>

<p>Print a Summary for a fitted <code>brmsfit</code> model in a <code>brmcoda</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.brmcoda_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="print.brmcoda_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code>summary.brmcoda</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.brmcoda">summary.brmcoda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
 print(m)
}
</code></pre>

<hr>
<h2 id='print.complr'>Print a Summary for a <code>complr</code> object</h2><span id='topic+print.complr'></span>

<h3>Description</h3>

<p>Print a Summary for a <code>complr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'complr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.complr_+3A_x">x</code></td>
<td>
<p>An object of class <code>complr</code>.</p>
</td></tr>
<tr><td><code id="print.complr_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+summary.complr">summary.complr</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.complr">summary.complr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cilr &lt;- complr(data = mcompd, sbp = sbp, 
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), 
                idvar = "ID")
print(cilr)
</code></pre>

<hr>
<h2 id='print.substitution'>Print a Summary for a <code>substitution</code> object</h2><span id='topic+print.substitution'></span>

<h3>Description</h3>

<p>Print a Summary for a <code>substitution</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'substitution'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.substitution_+3A_x">x</code></td>
<td>
<p>A <code>substitution</code> object.</p>
</td></tr>
<tr><td><code id="print.substitution_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to to method <code>summary</code> of <code>substitution</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.substitution">summary.substitution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
  ## fit a model with compositional predictor at between and between-person levels
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  subm &lt;- substitution(object = m, delta = 5)
  print(subm)
}
</code></pre>

<hr>
<h2 id='print.summary.complr'>Summary for a <code>complr</code> object</h2><span id='topic+print.summary.complr'></span>

<h3>Description</h3>

<p>Summary for a <code>complr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.complr'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.complr_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.complr</code>.</p>
</td></tr>
<tr><td><code id="print.summary.complr_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+summary.complr">summary.complr</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+summary.complr">summary.complr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cilr &lt;- complr(data = mcompd, sbp = sbp, 
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), 
                idvar = "ID")
print(cilr)
</code></pre>

<hr>
<h2 id='prior_summary.brmcoda'>Extract Priors of a <code>brmsfit</code> from a <code>brmcoda</code> object</h2><span id='topic+prior_summary.brmcoda'></span>

<h3>Description</h3>

<p>Compute Bayes factors from marginal likelihoods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
prior_summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prior_summary.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="prior_summary.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+prior_summary.brmsfit">prior_summary.brmsfit</a></code>
</p>

<hr>
<h2 id='psub'>Possible Pairwise Substitutions</h2><span id='topic+psub'></span>

<h3>Description</h3>

<p>A dataset containing possible pairwise subsitutions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psub
</code></pre>


<h3>Format</h3>

<p>A data table containing 5 variables.
</p>

<dl>
<dt>TST</dt><dd><p>first compositional variable</p>
</dd>
<dt>WAKE</dt><dd><p>second compositional variable</p>
</dd>
<dt>MVPA</dt><dd><p>third compositional variable</p>
</dd>
<dt>LPA</dt><dd><p>fourth compositional variable</p>
</dd>
<dt>SB</dt><dd><p>fifth compositional variable</p>
</dd>
</dl>


<hr>
<h2 id='ranef.brmcoda'>Group-Level Estimates</h2><span id='topic+ranef.brmcoda'></span><span id='topic+ranef'></span>

<h3>Description</h3>

<p>Extract the group-level ('random') effects of each level
of the <code>brmsfit</code> object in a <code>brmcoda</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
ranef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="ranef.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+ranef.brmsfit">ranef.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 3D arrays (one per grouping factor).
If <code>summary</code> is <code>TRUE</code>,
the 1st dimension contains the factor levels,
the 2nd dimension contains the summary statistics
(see <code><a href="brms.html#topic+posterior_summary">posterior_summary</a></code>), and
the 3rd dimension contains the group-level effects.
If <code>summary</code> is <code>FALSE</code>, the 1st dimension contains
the posterior draws, the 2nd dimension contains the factor levels,
and the 3rd dimension contains the group-level effects.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+ranef.brmsfit">ranef.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a model
if(requireNamespace("cmdstanr")){
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  ## extract group-level coefficients
  ranef(m)
}
</code></pre>

<hr>
<h2 id='residuals.brmcoda'>Posterior Draws of Residuals/Predictive Errors</h2><span id='topic+residuals.brmcoda'></span>

<h3>Description</h3>

<p>Compute posterior draws of residuals/predictive errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="residuals.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+residuals.brmsfit">residuals.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>array</code> of predictive error/residual draws. If
<code>summary = FALSE</code> the output resembles those of
<code><a href="brms.html#topic+predictive_error.brmsfit">predictive_error.brmsfit</a></code>. If <code>summary = TRUE</code> the output
is an N x E matrix, where N is the number of observations and E denotes
the summary statistics computed from the draws.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+residuals.brmsfit">residuals.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a model
if(requireNamespace("cmdstanr")){
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  ## extract residuals
  res &lt;- residuals(m)
  head(res)
}
</code></pre>

<hr>
<h2 id='sbp'>Sequential Binary Partition</h2><span id='topic+sbp'></span>

<h3>Description</h3>

<p>A matrix of sequential binary partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbp
</code></pre>


<h3>Format</h3>

<p>A matrix with 5 columns and 4 rows.
</p>

<dl>
<dt>TST</dt><dd><p>first compositional variable</p>
</dd>
<dt>WAKE</dt><dd><p>second compositional variable</p>
</dd>
<dt>MVPA</dt><dd><p>third compositional variable</p>
</dd>
<dt>LPA</dt><dd><p>fourth compositional variable</p>
</dd>
<dt>SB</dt><dd><p>fifth compositional variable</p>
</dd>
</dl>


<hr>
<h2 id='sim'>multilevelcoda Simulation Study results</h2><span id='topic+sim'></span>

<h3>Description</h3>

<p>A list of 4 components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim
</code></pre>


<h3>Format</h3>

<p>A list with 5 columns and 4 rows.
</p>

<dl>
<dt>brmcoda_tab</dt><dd><p>Simulation results for brmcoda() for tables</p>
</dd>
<dt>sub_tab</dt><dd><p>Simulation results for substitution() for tables</p>
</dd>
<dt>brmcoda_plot</dt><dd><p>Simulation results for brmcoda() for graphs</p>
</dd>
<dt>sub_plot</dt><dd><p>Simulation results for substitution() for graphs</p>
</dd>
</dl>


<hr>
<h2 id='sub'>Simple Substitution</h2><span id='topic+sub'></span>

<h3>Description</h3>

<p>This function is an alias of <code><a href="#topic+substitution">substitution</a></code> to estimates the the difference in an outcome
when compositional parts are substituted for specific unit(s)
using a aggregate reference composition
(e.g., compositional mean at sample level, not seperated by between- and within effects).
It is recommended that users run substitution model using the <code><a href="#topic+substitution">substitution</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub(
  object,
  delta,
  basesub,
  summary = TRUE,
  ref = "grandmean",
  level = "aggregate",
  weight = "equal",
  scale = c("response", "linear"),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="sub_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the amount of substituted change between compositional parts.</p>
</td></tr>
<tr><td><code id="sub_+3A_basesub">basesub</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> of the base possible substitution of compositional parts.
This data set can be computed using function <code><a href="#topic+basesub">basesub</a></code>.
If <code>NULL</code>, all possible pairwise substitution of compositional parts are used.</p>
</td></tr>
<tr><td><code id="sub_+3A_summary">summary</code></td>
<td>
<p>A logical value.
Should the estimate at each level of the reference grid (<code>FALSE</code>)
or their average (<code>TRUE</code>) be returned?
Default is <code>TRUE</code>.
Only applicable for model with covariates in addition to
the isometric log-ratio coordinates (i.e., adjusted model).</p>
</td></tr>
<tr><td><code id="sub_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="sub_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="sub_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="sub_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale of the response variable.
If <code>"linear"</code>, results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or other transformations.</p>
</td></tr>
<tr><td><code id="sub_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
we recommend setting the <code>mc.cores</code> option
to be as many processors as the hardware and RAM allow (up to the number of compositional parts).
For non-Windows OS in non-interactive R sessions, forking is used instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="sub_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of multilevel compositional substitution model.
The first six lists contain the results of the substitution estimation for a compositional part.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+substitution">substitution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){

cilr &lt;- complr(data = mcompd, sbp = sbp, 
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID", total = 1440)

# model with compositional predictor at between and within-person levels
m &lt;- brmcoda(complr = cilr, 
             formula = Stress ~ ilr1 + ilr2 + ilr3 + ilr4 + (1 | ID), 
             chain = 1, iter = 500,
             backend = "cmdstanr")
             
subm &lt;- sub(object = m, basesub = psub, delta = 5)
}
</code></pre>

<hr>
<h2 id='submargins'>Average Substitution</h2><span id='topic+submargins'></span>

<h3>Description</h3>

<p>This function is an alias of <code><a href="#topic+substitution">substitution</a></code> to estimates the the difference in an outcome
when compositional parts are substituted for specific unit(s)
using cluster mean (e.g., compositional mean at individual level) as reference composition.
It is recommended that users run substitution model using the <code><a href="#topic+substitution">substitution</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submargins(
  object,
  delta,
  basesub,
  ref = "clustermean",
  level = "aggregate",
  weight = "proportional",
  scale = c("response", "linear"),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submargins_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="submargins_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the amount of substituted change between compositional parts.</p>
</td></tr>
<tr><td><code id="submargins_+3A_basesub">basesub</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> of the base possible substitution of compositional parts.
This data set can be computed using function <code><a href="#topic+basesub">basesub</a></code>.
If <code>NULL</code>, all possible pairwise substitution of compositional parts are used.</p>
</td></tr>
<tr><td><code id="submargins_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="submargins_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="submargins_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="submargins_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale of the response variable.
If <code>"linear"</code>, results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or other transformations.</p>
</td></tr>
<tr><td><code id="submargins_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
we recommend setting the <code>mc.cores</code> option
to be as many processors as the hardware and RAM allow (up to the number of compositional parts).
For non-Windows OS in non-interactive R sessions, forking is used instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="submargins_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of multilevel compositional substitution model.
The first six lists contain the results of the substitution estimation for a compositional part.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+substitution">substitution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){

cilr &lt;- complr(data = mcompd, sbp = sbp, 
               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID", total = 1440)

# model with compositional predictor at between and within-person levels
m &lt;- brmcoda(complr = cilr, 
             formula = Stress ~ ilr1 + ilr2 + ilr3 + ilr4 + (1 | ID), 
             chain = 1, iter = 500,
             backend = "cmdstanr")
                     
subm &lt;- submargins(object = m, basesub = psub, delta = 5)
}
</code></pre>

<hr>
<h2 id='substitution'>Multilevel Compositional Substitution Analysis</h2><span id='topic+substitution'></span>

<h3>Description</h3>

<p>Estimate the difference in an outcome
when compositional parts are substituted for specific unit(s).
The <code>substitution</code> output encapsulates
the substitution results for all compositional parts
present in the <code><a href="#topic+brmcoda">brmcoda</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substitution(
  object,
  delta,
  basesub = NULL,
  summary = TRUE,
  ref = c("grandmean", "clustermean"),
  level = c("between", "within", "aggregate"),
  weight = c("equal", "proportional"),
  scale = c("response", "linear"),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="substitution_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="substitution_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the amount of substituted change between compositional parts.</p>
</td></tr>
<tr><td><code id="substitution_+3A_basesub">basesub</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> of the base possible substitution of compositional parts.
This data set can be computed using function <code><a href="#topic+basesub">basesub</a></code>.
If <code>NULL</code>, all possible pairwise substitution of compositional parts are used.</p>
</td></tr>
<tr><td><code id="substitution_+3A_summary">summary</code></td>
<td>
<p>A logical value.
Should the estimate at each level of the reference grid (<code>FALSE</code>)
or their average (<code>TRUE</code>) be returned?
Default is <code>TRUE</code>.
Only applicable for model with covariates in addition to
the isometric log-ratio coordinates (i.e., adjusted model).</p>
</td></tr>
<tr><td><code id="substitution_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="substitution_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="substitution_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="substitution_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale of the response variable.
If <code>"linear"</code>, results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or other transformations.</p>
</td></tr>
<tr><td><code id="substitution_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
we recommend setting the <code>mc.cores</code> option
to be as many processors as the hardware and RAM allow (up to the number of compositional parts).
For non-Windows OS in non-interactive R sessions, forking is used instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="substitution_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of multilevel compositional substitution model.
The first six lists contain the results of the substitution estimation for a compositional part.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
  cilr &lt;- complr(data = mcompd, sbp = sbp,
                 parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                 idvar = "ID", total = 1440)

  # model with compositional predictor at between and between-person levels of variance
  fit1 &lt;- brmcoda(complr = cilr,
                  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                                     wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
                  chain = 1, iter = 500, backend = "cmdstanr")
  sub1 &lt;- substitution(object = fit1, delta = 5, level = c("between", "within"))

  # model with compositional predictor at aggregate level of variance
  fit2 &lt;- brmcoda(complr = cilr,
                  formula = Stress ~ ilr1 + ilr2 + ilr3 + ilr4 + (1 | ID),
                  chain = 1, iter = 500, backend = "cmdstanr")
  sub2 &lt;- substitution(object = fit2, delta = 5, level = c("aggregate"))

}
</code></pre>

<hr>
<h2 id='summary.brmcoda'>Create a Summary of a fitted <code>brmsfit</code> model in a <code>brmcoda</code> object</h2><span id='topic+summary.brmcoda'></span>

<h3>Description</h3>

<p>Create a Summary of a fitted <code>brmsfit</code> model in a <code>brmcoda</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="summary.brmcoda_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="brms.html#topic+summary.brmsfit">summary.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                                 parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                                 idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  summary(m)
}
</code></pre>

<hr>
<h2 id='summary.complr'>Create a Summary of a <code>complr</code> object</h2><span id='topic+summary.complr'></span>

<h3>Description</h3>

<p>Create a Summary of a <code>complr</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'complr'
summary(object, weight = c("equal", "proportional"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.complr_+3A_object">object</code></td>
<td>
<p>An object of class <code>complr</code>.</p>
</td></tr>
<tr><td><code id="summary.complr_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default is <code>equal</code>.</p>
</td></tr>
<tr><td><code id="summary.complr_+3A_...">...</code></td>
<td>
<p>generic argument, not in use.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cilr &lt;- complr(data = mcompd, sbp = sbp, 
               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), 
               idvar = "ID")
summary(cilr)
</code></pre>

<hr>
<h2 id='summary.substitution'>Create a Summary of a Substitution Model represented by a <code>substitution</code> object</h2><span id='topic+summary.substitution'></span>

<h3>Description</h3>

<p>Create a Summary of a Substitution Model represented by a <code>substitution</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'substitution'
summary(object, delta, to, from, ref, level, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.substitution_+3A_object">object</code></td>
<td>
<p>A <code>substitution</code> class object.</p>
</td></tr>
<tr><td><code id="summary.substitution_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the desired <code>delta</code>
at which substitution results should be summarised.
Default to all <code>delta</code> available in the <code>substitution</code> object.</p>
</td></tr>
<tr><td><code id="summary.substitution_+3A_to">to</code></td>
<td>
<p>A character value or vector specifying the names of the compositional parts
that were reallocated to in the model.</p>
</td></tr>
<tr><td><code id="summary.substitution_+3A_from">from</code></td>
<td>
<p>A character value or vector specifying the names of the compositional parts
that were reallocated from in the model.</p>
</td></tr>
<tr><td><code id="summary.substitution_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector ((<code>"grandmean"</code> and/or <code>"clustermean"</code> or <code>"users"</code>),
Default to all <code>ref</code> available in the <code>substitution</code> object.</p>
</td></tr>
<tr><td><code id="summary.substitution_+3A_level">level</code></td>
<td>
<p>A character string or vector (<code>"between"</code> and/or <code>"within"</code>).
Default to all <code>level</code> available in the <code>substitution</code> object.</p>
</td></tr>
<tr><td><code id="summary.substitution_+3A_digits">digits</code></td>
<td>
<p>A integer value used for number formatting. Default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="summary.substitution_+3A_...">...</code></td>
<td>
<p>generic argument, not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of <code>substitution</code> object.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place. Either <code>between</code> or <code>within</code>.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){
  ## fit a model with compositional predictor at between and between-person levels
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  subm &lt;- substitution(object = m, delta = 5)
  summary(subm)
}
</code></pre>

<hr>
<h2 id='update.brmcoda'>Update <code><a href="#topic+brmcoda">brmcoda</a></code> models</h2><span id='topic+update.brmcoda'></span>

<h3>Description</h3>

<p>This method allows for updating an existing <code><a href="#topic+brmcoda">brmcoda</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
update(object, formula. = NULL, newdata = NULL, newcomplr = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.brmcoda_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object to be updated.</p>
</td></tr>
<tr><td><code id="update.brmcoda_+3A_formula.">formula.</code></td>
<td>
<p>Changes to the formula; for details see
<code><a href="stats.html#topic+update.formula">update.formula</a></code> and <code><a href="brms.html#topic+brmsformula">brmsformula</a></code>.</p>
</td></tr>
<tr><td><code id="update.brmcoda_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code>
containing data of all variables used in the analysis.
It must include a composition and the same ID variable as the existing <code><a href="#topic+complr">complr</a></code> object.</p>
</td></tr>
<tr><td><code id="update.brmcoda_+3A_newcomplr">newcomplr</code></td>
<td>
<p>A <code><a href="#topic+complr">complr</a></code> object containing data of composition,
ILR coordinates, and other variables used in the updated model.</p>
</td></tr>
<tr><td><code id="update.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+brm">brm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+brmcoda">brmcoda</a></code> with two elements
</p>
<table>
<tr><td><code>complr</code></td>
<td>
<p> An object of class <code>complr</code> used in the <code>brm</code> model. </p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p> An object of class <code>brmsfit</code>, which contains the posterior draws
along with many other useful information about the model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+brmcoda">brmcoda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){

# model with compositional predictor at between and within-person levels
fit &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp, 
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), 
                               idvar = "ID"), 
              formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
                                 wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID), 
              chain = 1, iter = 500,
              backend = "cmdstanr")

# removing the effect of wilr1
fit1 &lt;- update(fit, formula. = ~ . - wilr1)

# using only a subset
fit2 &lt;- update(fit, newdata = mcompd[ID != 1])
}
</code></pre>

<hr>
<h2 id='update.complr'>Update <code><a href="#topic+complr">complr</a></code></h2><span id='topic+update.complr'></span>

<h3>Description</h3>

<p>This method allows for updating an existing <code><a href="#topic+complr">complr</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'complr'
update(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.complr_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+complr">complr</a></code> class object to be updated.</p>
</td></tr>
<tr><td><code id="update.complr_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code>
containing data of all variables used in the analysis.
It must include a composition and the same ID variable as the existing <code><a href="#topic+complr">complr</a></code> object.</p>
</td></tr>
<tr><td><code id="update.complr_+3A_...">...</code></td>
<td>
<p>generic argument, not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+complr">complr</a></code> object with at least the following elements.
</p>
<table>
<tr><td><code>comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed composition
or a matrix of class <code>acomp</code> representing multiple closed  compositions each in one row.</p>
</td></tr>
<tr><td><code>between_comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed between-person composition
or a matrix of class <code>acomp</code> representing multiple closed between-person compositions each in one row.</p>
</td></tr>
<tr><td><code>within_comp</code></td>
<td>
<p> A vector of class <code>acomp</code> representing one closed within-person composition
or a matrix of class <code>acomp</code> representing multiple closed within-person compositions each in one row.</p>
</td></tr>
<tr><td><code>logratio</code></td>
<td>
<p> Log ratio transform of composition.</p>
</td></tr>
<tr><td><code>between_logratio</code></td>
<td>
<p> Log ratio transform of between-person composition.</p>
</td></tr>
<tr><td><code>within_logratio</code></td>
<td>
<p> Log ratio transform of within-person composition.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p> The user's dataset or imputed dataset if the input data contains zeros.</p>
</td></tr>
<tr><td><code>transform</code></td>
<td>
<p> Type of transform applied on compositional data.</p>
</td></tr>
<tr><td><code>parts</code></td>
<td>
<p> Names of compositional variables.</p>
</td></tr>
<tr><td><code>idvar</code></td>
<td>
<p> Name of the variable containing IDs.</p>
</td></tr>
<tr><td><code>total</code></td>
<td>
<p> Total amount to which the compositions is closed.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+complr">complr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cilr &lt;- complr(data = mcompd, sbp = sbp, 
               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID")

# update with new data
newdat &lt;- mcompd[ID != 1] # excluding ID 1
cilr1 &lt;- update(object = cilr, newdata = newdat)
</code></pre>

<hr>
<h2 id='var.complr'>Variance of compositions presented in a <code>complr</code> object.</h2><span id='topic+var.complr'></span>

<h3>Description</h3>

<p>Variance of compositions presented in a <code>complr</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.complr(x, weight = c("equal", "proportional"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.complr_+3A_x">x</code></td>
<td>
<p>An object of class <code>complr</code>.</p>
</td></tr>
<tr><td><code id="var.complr_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals)
Default is <code>equal</code>.</p>
</td></tr>
<tr><td><code id="var.complr_+3A_...">...</code></td>
<td>
<p>generic argument, not in use.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cilr &lt;- complr(data = mcompd, sbp = sbp, 
                parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), 
                idvar = "ID")
var.complr(cilr)
</code></pre>

<hr>
<h2 id='VarCorr.brmcoda'>Extract Variance and Correlation Components</h2><span id='topic+VarCorr.brmcoda'></span><span id='topic+VarCorr'></span>

<h3>Description</h3>

<p>Calculates the estimated standard deviations,
correlations and covariances of the group-level terms
of the <code>brmsfit</code> object in a <code>brmcoda</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
VarCorr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VarCorr.brmcoda_+3A_x">x</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="VarCorr.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+VarCorr.brmsfit">VarCorr.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists (one per grouping factor), each with
three elements: a matrix containing the standard deviations,
an array containing the correlation matrix, and an array
containing the covariance matrix with variances on the diagonal.
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+VarCorr.brmsfit">VarCorr.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a model
if(requireNamespace("cmdstanr")){
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  VarCorr(m)
}
</code></pre>

<hr>
<h2 id='vcov.brmcoda'>Covariance and Correlation Matrix of Population-Level Effects</h2><span id='topic+vcov.brmcoda'></span>

<h3>Description</h3>

<p>Get a point estimate of the covariance or
correlation matrix of population-level parameters
of the <code>brmsfit</code> object in a <code>brmcoda</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'brmcoda'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.brmcoda_+3A_object">object</code></td>
<td>
<p>An object of class <code>brmcoda</code>.</p>
</td></tr>
<tr><td><code id="vcov.brmcoda_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+vcov.brmsfit">vcov.brmsfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>covariance or correlation matrix of population-level parameters
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+vcov.brmsfit">vcov.brmsfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## fit a model
if(requireNamespace("cmdstanr")){
  m &lt;- brmcoda(complr = complr(data = mcompd, sbp = sbp,
                               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"),
                               idvar = "ID", total = 1440),
  formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 +
    wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID),
  chain = 1, iter = 500,
  backend = "cmdstanr")
  
  vcov(m)
}
</code></pre>

<hr>
<h2 id='wsub'>Within-person Simple Substitution</h2><span id='topic+wsub'></span>

<h3>Description</h3>

<p>This function is an alias of <code><a href="#topic+substitution">substitution</a></code> to estimates the the difference in an outcome
when compositional parts are substituted for specific unit(s) at <em>within</em> level
using a single reference composition (e.g., compositional mean at sample level).
It is recommended that users run substitution model using the <code><a href="#topic+substitution">substitution</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wsub(
  object,
  basesub,
  delta,
  summary = TRUE,
  ref = "grandmean",
  level = "within",
  weight = "equal",
  scale = c("response", "linear"),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wsub_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="wsub_+3A_basesub">basesub</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> of the base possible substitution of compositional parts.
This data set can be computed using function <code><a href="#topic+basesub">basesub</a></code>.
If <code>NULL</code>, all possible pairwise substitution of compositional parts are used.</p>
</td></tr>
<tr><td><code id="wsub_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the amount of substituted change between compositional parts.</p>
</td></tr>
<tr><td><code id="wsub_+3A_summary">summary</code></td>
<td>
<p>A logical value.
Should the estimate at each level of the reference grid (<code>FALSE</code>)
or their average (<code>TRUE</code>) be returned?
Default is <code>TRUE</code>.
Only applicable for model with covariates in addition to
the isometric log-ratio coordinates (i.e., adjusted model).</p>
</td></tr>
<tr><td><code id="wsub_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="wsub_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="wsub_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="wsub_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale of the response variable.
If <code>"linear"</code>, results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or other transformations.</p>
</td></tr>
<tr><td><code id="wsub_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
we recommend setting the <code>mc.cores</code> option
to be as many processors as the hardware and RAM allow (up to the number of compositional parts).
For non-Windows OS in non-interactive R sessions, forking is used instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="wsub_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of multilevel compositional substitution model.
The first six lists contain the results of the substitution estimation for a compositional part.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+substitution">substitution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){

cilr &lt;- complr(data = mcompd, sbp = sbp, 
               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID", total = 1440)

# model with compositional predictor at between and within-person levels
m &lt;- brmcoda(complr = cilr, 
             formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 + 
                                wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID), 
             chain = 1, iter = 500,
             backend = "cmdstanr")
             
subm &lt;- wsub(object = m, basesub = psub, delta = 60)
}
</code></pre>

<hr>
<h2 id='wsubmargins'>Within-person Average Substitution</h2><span id='topic+wsubmargins'></span>

<h3>Description</h3>

<p>This function is an alias of <code><a href="#topic+substitution">substitution</a></code> to estimates the the difference in an outcome
when compositional parts are substituted for specific unit(s) at <em>within</em> level
using cluster mean (e.g., compositional mean at individual level) as reference composition.
It is recommended that users run substitution model using the <code><a href="#topic+substitution">substitution</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wsubmargins(
  object,
  delta,
  basesub,
  ref = "clustermean",
  level = "within",
  weight = "proportional",
  scale = c("response", "linear"),
  cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wsubmargins_+3A_object">object</code></td>
<td>
<p>A fitted <code><a href="#topic+brmcoda">brmcoda</a></code> object.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_delta">delta</code></td>
<td>
<p>A integer, numeric value or vector indicating the amount of substituted change between compositional parts.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_basesub">basesub</code></td>
<td>
<p>A <code>data.frame</code> or <code>data.table</code> of the base possible substitution of compositional parts.
This data set can be computed using function <code><a href="#topic+basesub">basesub</a></code>.
If <code>NULL</code>, all possible pairwise substitution of compositional parts are used.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_ref">ref</code></td>
<td>
<p>Either a character value or vector or a dataset.
Can be <code>"grandmean"</code> and/or <code>"clustermean"</code>, or
a <code>data.frame</code> or <code>data.table</code> of user's specified reference grid consisting
of combinations of covariates over which predictions are made.
User's specified reference grid is only possible for simple substitution.
Single level models are default to <code>"grandmean"</code>.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_level">level</code></td>
<td>
<p>A character string or vector.
Should the estimate of multilevel models focus on the <code>"between"</code> and/or <code>"within"</code> or <code>"aggregate"</code> variance?
Single-level models are default to <code>"aggregate"</code>.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_weight">weight</code></td>
<td>
<p>A character value specifying the weight to use in calculation of the reference composition.
If <code>"equal"</code>, give equal weight to units (e.g., individuals).
If <code>"proportional"</code>, weights in proportion to the frequencies of units being averaged
(e.g., observations across individuals).
Default to <code>"equal"</code> for <code>ref = "grandmean"</code> and <code>"proportional"</code> for <code>ref = "clustermean"</code>.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale of the response variable.
If <code>"linear"</code>, results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or other transformations.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
we recommend setting the <code>mc.cores</code> option
to be as many processors as the hardware and RAM allow (up to the number of compositional parts).
For non-Windows OS in non-interactive R sessions, forking is used instead of PSOCK clusters.</p>
</td></tr>
<tr><td><code id="wsubmargins_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the results of multilevel compositional substitution model.
The first six lists contain the results of the substitution estimation for a compositional part.
</p>
<table>
<tr><td><code>Mean</code></td>
<td>
<p> Posterior means.</p>
</td></tr>
<tr><td><code>CI_low and CI_high</code></td>
<td>
<p> 95% credible intervals.</p>
</td></tr>
<tr><td><code>Delta</code></td>
<td>
<p> Amount substituted across compositional parts.</p>
</td></tr>
<tr><td><code>From</code></td>
<td>
<p> Compositional part that is substituted from.</p>
</td></tr>
<tr><td><code>To</code></td>
<td>
<p> Compositional parts that is substituted to.</p>
</td></tr>
<tr><td><code>Level</code></td>
<td>
<p> Level where changes in composition takes place.</p>
</td></tr>
<tr><td><code>Reference</code></td>
<td>
<p> Either <code>grandmean</code>, <code>clustermean</code>, or <code>users</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+substitution">substitution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("cmdstanr")){

cilr &lt;- complr(data = mcompd, sbp = sbp, 
               parts = c("TST", "WAKE", "MVPA", "LPA", "SB"), idvar = "ID", total = 1440)

# model with compositional predictor at between and within-person levels
m &lt;- brmcoda(complr = cilr, 
             formula = Stress ~ bilr1 + bilr2 + bilr3 + bilr4 + 
                                wilr1 + wilr2 + wilr3 + wilr4 + (1 | ID), 
             chain = 1, iter = 500,
             backend = "cmdstanr")
                     
subm &lt;- wsubmargins(object = m, basesub = psub, delta = 5)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
