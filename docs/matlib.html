<!DOCTYPE html><html><head><title>Help for package matlib</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matlib}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#matlib-package'><p>matlib: Matrix Functions for Teaching and Learning Linear Algebra and Multivariate Statistics.</p></a></li>
<li><a href='#adjoint'><p>Calculate the Adjoint of a matrix</p></a></li>
<li><a href='#angle'><p>Angle between two vectors</p></a></li>
<li><a href='#arc'><p>Draw an arc showing the angle between vectors</p></a></li>
<li><a href='#arrows3d'><p>Draw 3D arrows</p></a></li>
<li><a href='#buildTmat'><p>Build/Get transformation matrices</p></a></li>
<li><a href='#cholesky'><p>Cholesky Square Root of a Matrix</p></a></li>
<li><a href='#circle3d'><p>Draw a horizontal circle</p></a></li>
<li><a href='#class'>
<p>Class Data Set</p></a></li>
<li><a href='#cofactor'><p>Cofactor of A[i,j]</p></a></li>
<li><a href='#cone3d'><p>Draw a 3D cone</p></a></li>
<li><a href='#corner'><p>Draw a corner showing the angle between two vectors</p></a></li>
<li><a href='#Det'><p>Determinant of a Square Matrix</p></a></li>
<li><a href='#echelon'><p>Echelon Form of a Matrix</p></a></li>
<li><a href='#Eigen'><p>Eigen Decomposition of a Square Symmetric Matrix</p></a></li>
<li><a href='#gaussianElimination'><p>Gaussian Elimination</p></a></li>
<li><a href='#Ginv'><p>Generalized Inverse of a Matrix</p></a></li>
<li><a href='#GramSchmidt'><p>Gram-Schmidt Orthogonalization of a Matrix</p></a></li>
<li><a href='#gsorth'><p>Gram-Schmidt Orthogonalization of a Matrix</p></a></li>
<li><a href='#Inverse'><p>Inverse of a Matrix</p></a></li>
<li><a href='#is_square_matrix'><p>Test for square matrix</p></a></li>
<li><a href='#J'><p>Create a vector, matrix or array of constants</p></a></li>
<li><a href='#len'><p>Length of a Vector or Column Lengths of a Matrix</p></a></li>
<li><a href='#LU'><p>LU Decomposition</p></a></li>
<li><a href='#matrix2latex'><p>Convert matrix to LaTeX equation</p></a></li>
<li><a href='#minor'><p>Minor of A[i,j]</p></a></li>
<li><a href='#MoorePenrose'><p>Moore-Penrose inverse of a matrix</p></a></li>
<li><a href='#mpower'><p>Matrix Power</p></a></li>
<li><a href='#plot.regvec3d'><p>Plot method for regvec3d objects</p></a></li>
<li><a href='#plotEqn'><p>Plot Linear Equations</p></a></li>
<li><a href='#plotEqn3d'><p>Plot Linear Equations in 3D</p></a></li>
<li><a href='#pointOnLine'><p>Position of a point along a line</p></a></li>
<li><a href='#powerMethod'><p>Power Method for Eigenvectors</p></a></li>
<li><a href='#printMatEqn'><p>Print Matrices or Matrix Operations Side by Side</p></a></li>
<li><a href='#printMatrix'><p>Print a matrix, allowing fractions or LaTeX output</p></a></li>
<li><a href='#Proj'><p>Projection of Vector y on columns of X</p></a></li>
<li><a href='#QR'><p>QR Decomposition by Graham-Schmidt Orthonormalization</p></a></li>
<li><a href='#R'><p>Rank of a Matrix</p></a></li>
<li><a href='#regvec3d'><p>Vector space representation of a two-variable regression model</p></a></li>
<li><a href='#rowadd'><p>Add multiples of rows to other rows</p></a></li>
<li><a href='#rowCofactors'><p>Row Cofactors of A[i,]</p></a></li>
<li><a href='#rowMinors'><p>Row Minors of A[i,]</p></a></li>
<li><a href='#rowmult'><p>Multiply Rows by Constants</p></a></li>
<li><a href='#rowswap'><p>Interchange two rows of a matrix</p></a></li>
<li><a href='#showEig'><p>Show the eigenvectors associated with a covariance matrix</p></a></li>
<li><a href='#showEqn'><p>Show Matrices (A, b) as Linear Equations</p></a></li>
<li><a href='#Solve'><p>Solve and Display Solutions for Systems of Linear Simultaneous Equations</p></a></li>
<li><a href='#SVD'><p>Singular Value Decomposition of a Matrix</p></a></li>
<li><a href='#svdDemo'><p>Demonstrate the SVD for a 3 x 3 matrix</p></a></li>
<li><a href='#swp'><p>The Matrix Sweep Operator</p></a></li>
<li><a href='#symMat'><p>Create a Symmetric Matrix from a Vector</p></a></li>
<li><a href='#therapy'>
<p>Therapy Data</p></a></li>
<li><a href='#tr'><p>Trace of a Matrix</p></a></li>
<li><a href='#vandermode'><p>Vandermode Matrix</p></a></li>
<li><a href='#vec'><p>Vectorize a Matrix</p></a></li>
<li><a href='#vectors'><p>Draw geometric vectors in 2D</p></a></li>
<li><a href='#vectors3d'><p>Draw 3D vectors</p></a></li>
<li><a href='#workers'>
<p>Workers Data</p></a></li>
<li><a href='#xprod'><p>Generalized Vector Cross Product</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matrix Functions for Teaching and Learning Linear Algebra and
Multivariate Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Friendly &lt;friendly@yorku.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of matrix functions for teaching and learning matrix
    linear algebra as used in multivariate statistical methods. These functions are
    mainly for tutorial purposes in learning matrix algebra ideas using R. In some
    cases, functions are provided for concepts available elsewhere in R, but where
    the function call or name is not obvious. In other cases, functions are provided
    to show or demonstrate an algorithm. In addition, a collection of functions are
    provided for drawing vector diagrams in 2D and 3D.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/friendly/matlib">https://github.com/friendly/matlib</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/friendly/matlib/issues">https://github.com/friendly/matlib/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, carData, webshot2, markdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>xtable, MASS, rgl, car, methods</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-08 16:28:30 UTC; friendly</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Friendly <a href="https://orcid.org/0000-0002-3237-0941"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  John Fox [aut],
  Phil Chalmers [aut],
  Georges Monette [ctb],
  Gaston Sanchez [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-08 17:20:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='matlib-package'>matlib: Matrix Functions for Teaching and Learning Linear Algebra and Multivariate Statistics.</h2><span id='topic+matlib-package'></span><span id='topic+matlib'></span>

<h3>Description</h3>

<p>These functions are designed mainly for tutorial purposes in teaching &amp; learning matrix algebra
ideas and applications to statistical methods using R.
</p>


<h3>Details</h3>

<p>In some cases, functions are provided for concepts available
elsewhere in R, but where the function call or name is not obvious.  In other
cases, functions are provided to show or demonstrate an algorithm, sometimes
providing a <code>verbose</code> argument to print the details of computations.
</p>
<p>In addition,
a collection of functions are provided for drawing vector diagrams in 2D and 3D.
</p>
<p>These are not meant for production uses. Other methods are more efficient for larger problems.
</p>


<h3>Topics</h3>

<p>The functions in this package are grouped under the following topics
</p>

<ul>
<li><p> Convenience functions: <br />
<code><a href="#topic+tr">tr</a></code>, <code><a href="#topic+R">R</a></code>, <code><a href="#topic+J">J</a></code>, <code><a href="#topic+len">len</a></code>,
<code><a href="#topic+vec">vec</a></code>, <code><a href="#topic+Proj">Proj</a></code>, <code><a href="#topic+mpower">mpower</a></code>, <code><a href="#topic+vandermode">vandermode</a></code>
</p>
</li>
<li><p> Determinants: functions for calculating determinants by cofactor expansion <br />
<code><a href="#topic+minor">minor</a></code>, <code><a href="#topic+cofactor">cofactor</a></code>, <code><a href="#topic+rowMinors">rowMinors</a></code>, <code><a href="#topic+rowCofactors">rowCofactors</a></code>
</p>
</li>
<li><p> Elementary row operations: functions for solving linear equations &quot;manually&quot; by the steps used in
row echelon form and Gaussian elimination <br />
<code><a href="#topic+rowadd">rowadd</a></code>, <code><a href="#topic+rowmult">rowmult</a></code>, <code><a href="#topic+rowswap">rowswap</a></code>
</p>
</li>
<li><p> Linear equations: functions to illustrate linear equations of the form $A x = b$ <br />
<code><a href="#topic+showEqn">showEqn</a></code>, <code><a href="#topic+plotEqn">plotEqn</a></code>
</p>
</li>
<li><p> Gaussian elimination: functions for illustrating Gaussian elimination for solving
systems of linear equations of the form $A x = b$. <br />
<code><a href="#topic+gaussianElimination">gaussianElimination</a></code>, <code><a href="#topic+Inverse">Inverse</a></code>, <code><a href="#topic+inv">inv</a></code>, <code><a href="#topic+echelon">echelon</a></code>,
<code><a href="#topic+Ginv">Ginv</a></code>, <code><a href="#topic+LU">LU</a></code>, <code><a href="#topic+cholesky">cholesky</a></code>, <code><a href="#topic+swp">swp</a></code>
</p>
</li>
<li><p> Eigenvalues: functions to illustrate the algorithms for calculating eigenvalues
and eigenvectors <br />
<code><a href="base.html#topic+eigen">eigen</a></code>, <code><a href="#topic+SVD">SVD</a></code>, <code><a href="#topic+powerMethod">powerMethod</a></code>, <code><a href="#topic+showEig">showEig</a></code>
</p>
</li>
<li><p> Vector diagrams: functions for drawing vector diagrams in 2D and 3D <br />
<code><a href="#topic+arrows3d">arrows3d</a></code>, <code><a href="#topic+corner">corner</a></code>, <code><a href="#topic+arc">arc</a></code>, <code><a href="#topic+pointOnLine">pointOnLine</a></code>,
<code><a href="#topic+vectors">vectors</a></code>, <code><a href="#topic+vectors3d">vectors3d</a></code>, <code><a href="#topic+regvec3d">regvec3d</a></code>
</p>
</li></ul>

<p>Most of these ideas and implementations arose in courses and books by the authors.
[Psychology 6140](http://friendly.apps01.yorku.ca/psy6140/) was a starting point.
Fox (1984) introduced illustrations of vector geometry.
</p>


<h3>macOS Installation Note</h3>

<p>The functions that draw 3D graphs use the <span class="pkg">rgl</span> package.
On macOS, the <span class="pkg">rgl</span> package requires that <a href="https://www.xquartz.org/">XQuartz</a>
be installed. After installing XQuartz, it's necessary either to log out of and back
into your macOS account or to reboot your Mac.
</p>


<h3>References</h3>

<p>Fox, J. Linear Statistical Models and Related Methods. John Wiley and Sons, 1984
</p>
<p>Fox, J. and Friendly, M. (2016). &quot;Visualizing Simultaneous Linear Equations, Geometric Vectors, and
Least-Squares Regression with the matlib Package for R&quot;. <em>useR Conference</em>, Stanford, CA, June 27 - June 30, 2016.
</p>

<hr>
<h2 id='adjoint'>Calculate the Adjoint of a matrix</h2><span id='topic+adjoint'></span>

<h3>Description</h3>

<p>This function calculates the adjoint of a square matrix, defined as the transposed
matrix of cofactors of all elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjoint(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjoint_+3A_a">A</code></td>
<td>
<p>a square matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the same size as <code>A</code>
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p>Other determinants: 
<code><a href="#topic+Det">Det</a>()</code>,
<code><a href="#topic+cofactor">cofactor</a>()</code>,
<code><a href="#topic+minor">minor</a>()</code>,
<code><a href="#topic+rowCofactors">rowCofactors</a>()</code>,
<code><a href="#topic+rowMinors">rowMinors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- J(3, 3) + 2*diag(3)
adjoint(A)
</code></pre>

<hr>
<h2 id='angle'>Angle between two vectors</h2><span id='topic+angle'></span>

<h3>Description</h3>

<p><code>angle</code> calculates the angle between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>angle(x, y, degree = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="angle_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="angle_+3A_y">y</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="angle_+3A_degree">degree</code></td>
<td>
<p>logical; should the angle be computed in degrees? 
If <code>FALSE</code> the result is returned in radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar containing the angle between the vectors
</p>


<h3>See Also</h3>

<p><code><a href="#topic+len">len</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(2,1)
y &lt;- c(1,1)
angle(x, y) # degrees
angle(x, y, degree = FALSE) # radians

# visually
xlim &lt;- c(0,2.5)
ylim &lt;- c(0,2)
# proper geometry requires asp=1
plot( xlim, ylim, type="n", xlab="X", ylab="Y", asp=1,
  main = expression(theta == 18.4))
abline(v=0, h=0, col="gray")
vectors(rbind(x,y), col=c("red", "blue"), cex.lab=c(2, 2)) 
text(.5, .37, expression(theta))


####
x &lt;- c(-2,1)
y &lt;- c(1,1)
angle(x, y) # degrees
angle(x, y, degree = FALSE) # radians

# visually
xlim &lt;- c(-2,1.5)
ylim &lt;- c(0,2)
# proper geometry requires asp=1
plot( xlim, ylim, type="n", xlab="X", ylab="Y", asp=1,
  main = expression(theta == 108.4))
abline(v=0, h=0, col="gray")
vectors(rbind(x,y), col=c("red", "blue"), cex.lab=c(2, 2)) 
text(0, .4, expression(theta), cex=1.5)
</code></pre>

<hr>
<h2 id='arc'>Draw an arc showing the angle between vectors</h2><span id='topic+arc'></span>

<h3>Description</h3>

<p>A utility function for drawing vector diagrams. Draws a circular arc to show the angle between two vectors in 2D or 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arc(p1, p2, p3, d = 0.1, absolute = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arc_+3A_p1">p1</code></td>
<td>
<p>Starting point of first vector</p>
</td></tr>
<tr><td><code id="arc_+3A_p2">p2</code></td>
<td>
<p>End point of first vector, and also start of second vector</p>
</td></tr>
<tr><td><code id="arc_+3A_p3">p3</code></td>
<td>
<p>End point of second vector</p>
</td></tr>
<tr><td><code id="arc_+3A_d">d</code></td>
<td>
<p>The distance from <code>p2</code> along each vector for drawing their corner</p>
</td></tr>
<tr><td><code id="arc_+3A_absolute">absolute</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>d</code> is taken as an absolute distance along the vectors; otherwise it
is calculated as a relative distance, i.e., a fraction of the length of the vectors.</p>
</td></tr>
<tr><td><code id="arc_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>link[graphics]{lines}</code> or to <code>link[rgl]{lines3d}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this implementation, the two vectors are specified by three points, <code>p1</code>, <code>p2</code>, <code>p3</code>, meaning
a line from <code>p1</code> to <code>p2</code>, and another line from <code>p2</code> to <code>p3</code>.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>References</h3>

<p><a href="https://math.stackexchange.com/questions/1507248/find-arc-between-two-tips-of-vectors-in-3d">https://math.stackexchange.com/questions/1507248/find-arc-between-two-tips-of-vectors-in-3d</a>
</p>


<h3>See Also</h3>

<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
vec &lt;- rbind(diag(3), c(1,1,1))
rownames(vec) &lt;- c("X", "Y", "Z", "J")
open3d()
aspect3d("iso")
vectors3d(vec, col=c(rep("black",3), "red"), lwd=2)
# draw the XZ plane, whose equation is Y=0
planes3d(0, 0, 1, 0, col="gray", alpha=0.2)
# show projections of the unit vector J
segments3d(rbind( c(1,1,1), c(1, 1, 0)))
segments3d(rbind( c(0,0,0), c(1, 1, 0)))
segments3d(rbind( c(1,0,0), c(1, 1, 0)))
segments3d(rbind( c(0,1,0), c(1, 1, 0)))
segments3d(rbind( c(1,1,1), c(1, 0, 0)))

# show some orthogonal vectors
p1 &lt;- c(0,0,0)
p2 &lt;- c(1,1,0)
p3 &lt;- c(1,1,1)
p4 &lt;- c(1,0,0)
# show some angles
arc(p1, p2, p3, d=.2)
arc(p4, p1, p2, d=.2)
arc(p3, p1, p2, d=.2)
</code></pre>

<hr>
<h2 id='arrows3d'>Draw 3D arrows</h2><span id='topic+arrows3d'></span>

<h3>Description</h3>

<p>Draws nice 3D arrows with <code>cone3d</code>s at their tips.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arrows3d(
  coords,
  headlength = 0.035,
  head = "end",
  scale = NULL,
  radius = NULL,
  ref.length = NULL,
  draw = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arrows3d_+3A_coords">coords</code></td>
<td>
<p>A 2n x 3 matrix giving the start and end (x,y,z) coordinates of n arrows, in pairs.  The first vector
in each pair is taken as the starting coordinates of the arrow, the second as the end coordinates.</p>
</td></tr>
<tr><td><code id="arrows3d_+3A_headlength">headlength</code></td>
<td>
<p>Length of the arrow heads, in device units</p>
</td></tr>
<tr><td><code id="arrows3d_+3A_head">head</code></td>
<td>
<p>Position of the arrow head. Only <code>head="end"</code> is presently implemented.</p>
</td></tr>
<tr><td><code id="arrows3d_+3A_scale">scale</code></td>
<td>
<p>Scale factor for base and tip of arrow head, a vector of length 3, giving relative scale factors for X, Y, Z</p>
</td></tr>
<tr><td><code id="arrows3d_+3A_radius">radius</code></td>
<td>
<p>radius of the base of the arrow head</p>
</td></tr>
<tr><td><code id="arrows3d_+3A_ref.length">ref.length</code></td>
<td>
<p>length of vector to be used to scale all of the arrow heads (permits drawing arrow heads of the same size as in a previous call);
if <code>NULL</code>, arrows are scaled relative to the longest vector</p>
</td></tr>
<tr><td><code id="arrows3d_+3A_draw">draw</code></td>
<td>
<p>if <code>TRUE</code> (the default) draw the arrow(s)</p>
</td></tr>
<tr><td><code id="arrows3d_+3A_...">...</code></td>
<td>
<p>rgl arguments passed down to <code><a href="rgl.html#topic+segments3d">segments3d</a></code> and <code>cone3d</code>, for example, <code>col</code> and <code>lwd</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is meant to be analogous to <code><a href="graphics.html#topic+arrows">arrows</a></code>, but for 3D plots using <code><a href="rgl.html#topic+rgl">rgl</a></code>.
<code>headlength</code>, <code>scale</code> and <code>radius</code> set the length, scale factor and base radius of the arrow head, a
3D cone. The units of these are all in terms of the ranges of the current rgl 3D scene.
</p>


<h3>Value</h3>

<p>invisibly returns the length of the vector used to scale the arrow heads
</p>


<h3>Author(s)</h3>

<p>January Weiner, borrowed from the <span class="pkg">pca3d</span> package, slightly modified by John Fox
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vectors3d">vectors3d</a></code>
</p>
<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #none yet
</code></pre>

<hr>
<h2 id='buildTmat'>Build/Get transformation matrices</h2><span id='topic+buildTmat'></span><span id='topic+as.matrix.trace'></span><span id='topic+print.trace'></span>

<h3>Description</h3>

<p>Recover the history of the row operations that have been performed.
This function combines the transformation matrices into a single transformation matrix
representing all row operations or may optionally print all the individual operations which have
been performed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildTmat(x, all = FALSE)

## S3 method for class 'trace'
as.matrix(x, ...)

## S3 method for class 'trace'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildTmat_+3A_x">x</code></td>
<td>
<p>a matrix A, joined with a vector of constants, b, that has been passed to
<code><a href="#topic+gaussianElimination">gaussianElimination</a></code> or the row operator matrix functions</p>
</td></tr>
<tr><td><code id="buildTmat_+3A_all">all</code></td>
<td>
<p>logical; print individual transformation ies?</p>
</td></tr>
<tr><td><code id="buildTmat_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the transformation matrix or a list of individual transformation matrices
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+echelon">echelon</a></code>, <code><a href="#topic+gaussianElimination">gaussianElimination</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(2, 1, -1,
             -3, -1, 2,
             -2,  1, 2), 3, 3, byrow=TRUE)
b &lt;- c(8, -11, -3)

# using row operations to reduce below diagonal to 0
Abt &lt;- Ab &lt;- cbind(A, b)
Abt &lt;- rowadd(Abt, 1, 2, 3/2)
Abt &lt;- rowadd(Abt, 1, 3, 1)
Abt &lt;- rowadd(Abt, 2, 3, -4)
Abt

# build T matrix and multiply by original form
(T &lt;- buildTmat(Abt))
T %*% Ab    # same as Abt

# print all transformation matrices
buildTmat(Abt, TRUE)

# invert transformation matrix to reverse operations
inv(T) %*% Abt

# gaussian elimination
(soln &lt;- gaussianElimination(A, b))
T &lt;- buildTmat(soln)
inv(T) %*% soln

</code></pre>

<hr>
<h2 id='cholesky'>Cholesky Square Root of a Matrix</h2><span id='topic+cholesky'></span>

<h3>Description</h3>

<p>Returns the Cholesky square root of the non-singular, symmetric matrix <code>X</code>.
The purpose is mainly to demonstrate the algorithm used by Kennedy &amp; Gentle (1980).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cholesky(X, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cholesky_+3A_x">X</code></td>
<td>
<p>a square symmetric matrix</p>
</td></tr>
<tr><td><code id="cholesky_+3A_tol">tol</code></td>
<td>
<p>tolerance for checking for 0 pivot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the Cholesky square root of <code>X</code>
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>References</h3>

<p>Kennedy W.J. Jr, Gentle J.E. (1980). <em>Statistical Computing</em>. Marcel Dekker.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+chol">chol</a></code> for the base R function
</p>
<p><code><a href="#topic+gsorth">gsorth</a></code> for Gram-Schmidt orthogonalization of a data matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- matrix(c(1,2,3,2,5,6,3,6,10), 3, 3) # nonsingular, symmetric
C
cholesky(C)
cholesky(C) %*% t(cholesky(C))  # check

</code></pre>

<hr>
<h2 id='circle3d'>Draw a horizontal circle</h2><span id='topic+circle3d'></span>

<h3>Description</h3>

<p>A utility function for drawing a horizontal circle in the (x,y) plane in a 3D graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circle3d(center, radius, segments = 100, fill = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circle3d_+3A_center">center</code></td>
<td>
<p>A vector of length 3.</p>
</td></tr>
<tr><td><code id="circle3d_+3A_radius">radius</code></td>
<td>
<p>A positive number.</p>
</td></tr>
<tr><td><code id="circle3d_+3A_segments">segments</code></td>
<td>
<p>An integer specifying the number of line segments to use to draw the circle (default, 100).</p>
</td></tr>
<tr><td><code id="circle3d_+3A_fill">fill</code></td>
<td>
<p>logical; if <code>TRUE</code>, the circle is filled (the default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="circle3d_+3A_...">...</code></td>
<td>
<p><span class="pkg">rgl</span> material properties for the circle.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctr=c(0,0,0)
circle3d(ctr, 3, fill = TRUE)
circle3d(ctr - c(-1,-1,0), 3, col="blue")
circle3d(ctr + c(1,1,0),   3, col="red")
</code></pre>

<hr>
<h2 id='class'>
Class Data Set
</h2><span id='topic+class'></span>

<h3>Description</h3>

<p>A small artificial data set used to illustrate statistical concepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("class")</code></pre>


<h3>Format</h3>

<p>A data frame with 15 observations on the following 4 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>F</code> <code>M</code></p>
</dd>
<dt><code>age</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>height</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>weight</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(class)
plot(class)
</code></pre>

<hr>
<h2 id='cofactor'>Cofactor of A[i,j]</h2><span id='topic+cofactor'></span>

<h3>Description</h3>

<p>Returns the cofactor of element (i,j) of the square matrix A, i.e., the signed minor of the
sub-matrix that results when row i and column j are deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cofactor(A, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cofactor_+3A_a">A</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="cofactor_+3A_i">i</code></td>
<td>
<p>row index</p>
</td></tr>
<tr><td><code id="cofactor_+3A_j">j</code></td>
<td>
<p>column index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the cofactor of A[i,j]
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowCofactors">rowCofactors</a></code> for all cofactors of a given row
</p>
<p>Other determinants: 
<code><a href="#topic+Det">Det</a>()</code>,
<code><a href="#topic+adjoint">adjoint</a>()</code>,
<code><a href="#topic+minor">minor</a>()</code>,
<code><a href="#topic+rowCofactors">rowCofactors</a>()</code>,
<code><a href="#topic+rowMinors">rowMinors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(4, -12, -4,
              2,   1,  3,
             -1,  -3,  2), 3, 3, byrow=TRUE)
cofactor(M, 1, 1)
cofactor(M, 1, 2)
cofactor(M, 1, 3)

</code></pre>

<hr>
<h2 id='cone3d'>Draw a 3D cone</h2><span id='topic+cone3d'></span>

<h3>Description</h3>

<p>Draws a cone in 3D from a <code>base</code> point to a <code>tip</code> point, with a given <code>radius</code> at the base.
This is used to draw nice arrow heads in <code><a href="#topic+arrows3d">arrows3d</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cone3d(base, tip, radius = 10, col = "grey", scale = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cone3d_+3A_base">base</code></td>
<td>
<p>coordinates of base of the cone</p>
</td></tr>
<tr><td><code id="cone3d_+3A_tip">tip</code></td>
<td>
<p>coordinates of tip of the cone</p>
</td></tr>
<tr><td><code id="cone3d_+3A_radius">radius</code></td>
<td>
<p>radius of the base</p>
</td></tr>
<tr><td><code id="cone3d_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="cone3d_+3A_scale">scale</code></td>
<td>
<p>scale factor for base and tip</p>
</td></tr>
<tr><td><code id="cone3d_+3A_...">...</code></td>
<td>
<p>rgl arguments passed down; see <code><a href="rgl.html#topic+rgl.material">rgl.material</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the integer object ID of the shape that was added to the scene
</p>


<h3>Author(s)</h3>

<p>January Weiner, borrowed from from the <span class="pkg">pca3d</span> package
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arrows3d">arrows3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># none yet
</code></pre>

<hr>
<h2 id='corner'>Draw a corner showing the angle between two vectors</h2><span id='topic+corner'></span>

<h3>Description</h3>

<p>A utility function for drawing vector diagrams. Draws two line segments to indicate the angle between two vectors,
typically used for indicating orthogonal vectors are at right angles in 2D and 3D diagrams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corner(p1, p2, p3, d = 0.1, absolute = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corner_+3A_p1">p1</code></td>
<td>
<p>Starting point of first vector</p>
</td></tr>
<tr><td><code id="corner_+3A_p2">p2</code></td>
<td>
<p>End point of first vector, and also start of second vector</p>
</td></tr>
<tr><td><code id="corner_+3A_p3">p3</code></td>
<td>
<p>End point of second vector</p>
</td></tr>
<tr><td><code id="corner_+3A_d">d</code></td>
<td>
<p>The distance from <code>p2</code> along each vector for drawing their corner</p>
</td></tr>
<tr><td><code id="corner_+3A_absolute">absolute</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>d</code> is taken as an absolute distance along the vectors; otherwise it
is calculated as a relative distance, i.e., a fraction of the length of the vectors.
See <code><a href="#topic+pointOnLine">pointOnLine</a></code> for the precise definition.</p>
</td></tr>
<tr><td><code id="corner_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>link[graphics]{lines}</code> or to <code>link[rgl]{lines3d}</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this implementation, the two vectors are specified by three points, <code>p1</code>, <code>p2</code>, <code>p3</code>, meaning
a line from <code>p1</code> to <code>p2</code>, and another line from <code>p2</code> to <code>p3</code>.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>See Also</h3>

<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># none yet
</code></pre>

<hr>
<h2 id='Det'>Determinant of a Square Matrix</h2><span id='topic+Det'></span>

<h3>Description</h3>

<p>Returns the determinant of a square matrix <code>X</code>,
computed either by Gaussian elimination, expansion by cofactors, or as the product of the eigenvalues of the matrix.
If the latter, <code>X</code> must be symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Det(
  X,
  method = c("elimination", "eigenvalues", "cofactors"),
  verbose = FALSE,
  fractions = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Det_+3A_x">X</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="Det_+3A_method">method</code></td>
<td>
<p>one of '&quot;elimination&quot;' (the default), '&quot;eigenvalues&quot;', or '&quot;cofactors&quot;' (for computation by minors and cofactors)</p>
</td></tr>
<tr><td><code id="Det_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, print intermediate steps</p>
</td></tr>
<tr><td><code id="Det_+3A_fractions">fractions</code></td>
<td>
<p>logical; if <code>TRUE</code>, try to express non-integers as rational numbers, using the <code><a href="MASS.html#topic+fractions">fractions</a></code> 
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
<tr><td><code id="Det_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+gaussianElimination">gaussianElimination</a></code> or <code><a href="#topic+Eigen">Eigen</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the determinant of <code>X</code>
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+det">det</a></code> for the base R function
</p>
<p><code><a href="#topic+gaussianElimination">gaussianElimination</a></code>, <code><a href="#topic+Eigen">Eigen</a></code>
</p>
<p>Other determinants: 
<code><a href="#topic+adjoint">adjoint</a>()</code>,
<code><a href="#topic+cofactor">cofactor</a>()</code>,
<code><a href="#topic+minor">minor</a>()</code>,
<code><a href="#topic+rowCofactors">rowCofactors</a>()</code>,
<code><a href="#topic+rowMinors">rowMinors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1,2,3,2,5,6,3,6,10), 3, 3) # nonsingular, symmetric
A
Det(A)
Det(A, verbose=TRUE, fractions=TRUE)
B &lt;- matrix(1:9, 3, 3) # a singular matrix
B
Det(B)
C &lt;- matrix(c(1, .5, .5, 1), 2, 2) # square, symmetric, nonsingular
Det(C)
Det(C, method="eigenvalues")
Det(C, method="cofactors")
</code></pre>

<hr>
<h2 id='echelon'>Echelon Form of a Matrix</h2><span id='topic+echelon'></span>

<h3>Description</h3>

<p>Returns the (reduced) row-echelon form of the matrix <code>A</code>, using <code><a href="#topic+gaussianElimination">gaussianElimination</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>echelon(A, B, reduced = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="echelon_+3A_a">A</code></td>
<td>
<p>coefficient matrix</p>
</td></tr>
<tr><td><code id="echelon_+3A_b">B</code></td>
<td>
<p>right-hand side vector or matrix. If <code>B</code> is a matrix, the result gives solutions for each column as the right-hand
side of the equations with coefficients in <code>A</code>.</p>
</td></tr>
<tr><td><code id="echelon_+3A_reduced">reduced</code></td>
<td>
<p>logical; should reduced row echelon form be returned? If <code>FALSE</code> a non-reduced
row echelon form will be returned</p>
</td></tr>
<tr><td><code id="echelon_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>gaussianElimination</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the matrix <code>A</code> is square and non-singular, the reduced row-echelon result will be the
identity matrix, while the row-echelon from will be an upper triangle matrix.
Otherwise, the result will have some all-zero rows, and the rank of the matrix
is the number of not all-zero rows.
</p>


<h3>Value</h3>

<p>the reduced echelon form of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(2, 1, -1,
             -3, -1, 2,
             -2,  1, 2), 3, 3, byrow=TRUE)
b &lt;- c(8, -11, -3)
echelon(A, b, verbose=TRUE, fractions=TRUE) # reduced row-echelon form
echelon(A, b, reduced=FALSE, verbose=TRUE, fractions=TRUE) # row-echelon form

A &lt;- matrix(c(1,2,3,4,5,6,7,8,10), 3, 3) # a nonsingular matrix
A
echelon(A, reduced=FALSE) # the row-echelon form of A
echelon(A) # the reduced row-echelon form of A

b &lt;- 1:3
echelon(A, b)  # solving the matrix equation Ax = b
echelon(A, diag(3)) # inverting A

B &lt;- matrix(1:9, 3, 3) # a singular matrix
B
echelon(B)
echelon(B, reduced=FALSE)
echelon(B, b)
echelon(B, diag(3))

</code></pre>

<hr>
<h2 id='Eigen'>Eigen Decomposition of a Square Symmetric Matrix</h2><span id='topic+Eigen'></span>

<h3>Description</h3>

<p><code>Eigen</code> calculates the eigenvalues and eigenvectors of a square, symmetric matrix using the iterated QR decomposition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen(X, tol = sqrt(.Machine$double.eps), max.iter = 100, retain.zeroes = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Eigen_+3A_x">X</code></td>
<td>
<p>a square symmetric matrix</p>
</td></tr>
<tr><td><code id="Eigen_+3A_tol">tol</code></td>
<td>
<p>tolerance passed to <code><a href="#topic+QR">QR</a></code></p>
</td></tr>
<tr><td><code id="Eigen_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of QR iterations</p>
</td></tr>
<tr><td><code id="Eigen_+3A_retain.zeroes">retain.zeroes</code></td>
<td>
<p>logical; retain 0 eigenvalues?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements: <code>values</code>&ndash; eigenvalues, <code>vectors</code>&ndash; eigenvectors
</p>


<h3>Author(s)</h3>

<p>John Fox and Georges Monette
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code>
</p>
<p><code><a href="#topic+SVD">SVD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- matrix(c(1,2,3,2,5,6,3,6,10), 3, 3) # nonsingular, symmetric
C
EC &lt;- Eigen(C) # eigenanalysis of C
EC$vectors %*% diag(EC$values) %*% t(EC$vectors) # check
</code></pre>

<hr>
<h2 id='gaussianElimination'>Gaussian Elimination</h2><span id='topic+gaussianElimination'></span><span id='topic+print.enhancedMatrix'></span>

<h3>Description</h3>

<p><code>gaussianElimination</code> demonstrates the algorithm of row reduction used for solving
systems of linear equations of the form <code class="reqn">A x = B</code>. Optional arguments <code>verbose</code>
and <code>fractions</code> may be used to see how the algorithm works.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianElimination(
  A,
  B,
  tol = sqrt(.Machine$double.eps),
  verbose = FALSE,
  latex = FALSE,
  fractions = FALSE
)

## S3 method for class 'enhancedMatrix'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussianElimination_+3A_a">A</code></td>
<td>
<p>coefficient matrix</p>
</td></tr>
<tr><td><code id="gaussianElimination_+3A_b">B</code></td>
<td>
<p>right-hand side vector or matrix. If <code>B</code> is a matrix, the result gives solutions for each column as the right-hand
side of the equations with coefficients in <code>A</code>.</p>
</td></tr>
<tr><td><code id="gaussianElimination_+3A_tol">tol</code></td>
<td>
<p>tolerance for checking for 0 pivot</p>
</td></tr>
<tr><td><code id="gaussianElimination_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, print intermediate steps</p>
</td></tr>
<tr><td><code id="gaussianElimination_+3A_latex">latex</code></td>
<td>
<p>logical; if <code>TRUE</code>, and verbose is <code>TRUE</code>, print intermediate steps using LaTeX
equation outputs rather than R output</p>
</td></tr>
<tr><td><code id="gaussianElimination_+3A_fractions">fractions</code></td>
<td>
<p>logical; if <code>TRUE</code>, try to express non-integers as rational numbers, using the <code><a href="MASS.html#topic+fractions">fractions</a></code>
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
<tr><td><code id="gaussianElimination_+3A_x">x</code></td>
<td>
<p>matrix to print</p>
</td></tr>
<tr><td><code id="gaussianElimination_+3A_...">...</code></td>
<td>
<p>arguments to pass down</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>B</code> is absent, returns the reduced row-echelon form of <code>A</code>.
If <code>B</code> is present, returns the reduced row-echelon form of <code>A</code>, with the
same operations applied to <code>B</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- matrix(c(2, 1, -1,
               -3, -1, 2,
               -2,  1, 2), 3, 3, byrow=TRUE)
  b &lt;- c(8, -11, -3)
  gaussianElimination(A, b)
  gaussianElimination(A, b, verbose=TRUE, fractions=TRUE)
  gaussianElimination(A, b, verbose=TRUE, fractions=TRUE, latex=TRUE)

  # determine whether matrix is solvable
  gaussianElimination(A, numeric(3))

  # find inverse matrix by elimination: A = I -&gt; A^-1 A = A^-1 I -&gt; I = A^-1
  gaussianElimination(A, diag(3))
  inv(A)

  # works for 1-row systems (issue # 30)
  A2 &lt;- matrix(c(1, 1), nrow=1)
  b2 = 2
  gaussianElimination(A2, b2)
  showEqn(A2, b2)
  # plotEqn works for this case
  plotEqn(A2, b2)

</code></pre>

<hr>
<h2 id='Ginv'>Generalized Inverse of a Matrix</h2><span id='topic+Ginv'></span>

<h3>Description</h3>

<p><code>Ginv</code> returns an arbitrary generalized inverse of the matrix <code>A</code>, using <code>gaussianElimination</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ginv(A, tol = sqrt(.Machine$double.eps), verbose = FALSE, fractions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ginv_+3A_a">A</code></td>
<td>
<p>numerical matrix</p>
</td></tr>
<tr><td><code id="Ginv_+3A_tol">tol</code></td>
<td>
<p>tolerance for checking for 0 pivot</p>
</td></tr>
<tr><td><code id="Ginv_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, print intermediate steps</p>
</td></tr>
<tr><td><code id="Ginv_+3A_fractions">fractions</code></td>
<td>
<p>logical; if <code>TRUE</code>, try to express non-integers as rational numbers, using the <code><a href="MASS.html#topic+fractions">fractions</a></code>
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A generalized inverse is a matrix <code class="reqn">\mathbf{A}^-</code> satisfying <code class="reqn">\mathbf{A A^- A} = \mathbf{A}</code>.
</p>
<p>The purpose of this function is mainly to show how the generalized inverse can be computed using
Gaussian elimination.
</p>


<h3>Value</h3>

<p>the generalized inverse of <code>A</code>, expressed as fractions if <code>fractions=TRUE</code>, or rounded
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+ginv">ginv</a></code> for a more generally usable function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1,2,3,4,5,6,7,8,10), 3, 3) # a nonsingular matrix
A
Ginv(A, fractions=TRUE)  # a generalized inverse of A = inverse of A
round(Ginv(A) %*% A, 6)  # check

B &lt;- matrix(1:9, 3, 3) # a singular matrix
B
Ginv(B, fractions=TRUE)  # a generalized inverse of B
B %*% Ginv(B) %*% B   # check

</code></pre>

<hr>
<h2 id='GramSchmidt'>Gram-Schmidt Orthogonalization of a Matrix</h2><span id='topic+GramSchmidt'></span>

<h3>Description</h3>

<p>Carries out simple Gram-Schmidt orthogonalization of a matrix.
Treating the columns of the matrix <code>X</code> in the given order,
each successive column after the first is made orthogonal to all
previous columns by subtracting their projections on the current
column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GramSchmidt(
  X,
  normalize = TRUE,
  verbose = FALSE,
  tol = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GramSchmidt_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="GramSchmidt_+3A_normalize">normalize</code></td>
<td>
<p>logical; should the resulting columns be normalized to unit length?</p>
</td></tr>
<tr><td><code id="GramSchmidt_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, print intermediate steps</p>
</td></tr>
<tr><td><code id="GramSchmidt_+3A_tol">tol</code></td>
<td>
<p>the tolerance for detecting linear dependencies in the columns of a. The default is <code>.Machine$double.eps</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same size as <code>X</code>, with orthogonal columns
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers, John Fox
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(xx &lt;- matrix(c( 1:3, 3:1, 1, 0, -2), 3, 3))
crossprod(xx)
(zz &lt;- GramSchmidt(xx, normalize=FALSE))
zapsmall(crossprod(zz))

# normalized
(zz &lt;- GramSchmidt(xx))
zapsmall(crossprod(zz))

# print steps
GramSchmidt(xx, verbose=TRUE)

# A non-invertible matrix;  hence, it is of deficient rank
(xx &lt;- matrix(c( 1:3, 3:1, 1, 0, -1), 3, 3))
R(xx)
crossprod(xx)
# GramSchmidt finds an orthonormal basis
(zz &lt;- GramSchmidt(xx))
zapsmall(crossprod(zz))

</code></pre>

<hr>
<h2 id='gsorth'>Gram-Schmidt Orthogonalization of a Matrix</h2><span id='topic+gsorth'></span>

<h3>Description</h3>

<p>Calculates a matrix with uncorrelated columns using the Gram-Schmidt process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsorth(y, order, recenter = TRUE, rescale = TRUE, adjnames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsorth_+3A_y">y</code></td>
<td>
<p>a numeric matrix or data frame</p>
</td></tr>
<tr><td><code id="gsorth_+3A_order">order</code></td>
<td>
<p>if specified, a permutation of the column indices of <code>y</code></p>
</td></tr>
<tr><td><code id="gsorth_+3A_recenter">recenter</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result has same means as the original <code>y</code>, else means = 0 for cols 2:p</p>
</td></tr>
<tr><td><code id="gsorth_+3A_rescale">rescale</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result has same sd as original, else, sd = residual sd</p>
</td></tr>
<tr><td><code id="gsorth_+3A_adjnames">adjnames</code></td>
<td>
<p>logical; if <code>TRUE</code>, colnames are adjusted to Y1, Y2.1, Y3.12, ...</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, originally from the <span class="pkg">heplots</span> package has now been deprecated in <span class="pkg">matlib</span>. Use
<code><a href="#topic+GramSchmidt">GramSchmidt</a></code> instead.
</p>


<h3>Value</h3>

<p>a matrix/data frame with uncorrelated columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 set.seed(1234)
 A &lt;- matrix(c(1:60 + rnorm(60)), 20, 3)
 cor(A)
 G &lt;- gsorth(A)
 zapsmall(cor(G))
 
## End(Not run)
</code></pre>

<hr>
<h2 id='Inverse'>Inverse of a Matrix</h2><span id='topic+Inverse'></span><span id='topic+inv'></span>

<h3>Description</h3>

<p>Uses <code><a href="#topic+gaussianElimination">gaussianElimination</a></code> to find the inverse of a square, non-singular matrix, <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Inverse(X, tol = sqrt(.Machine$double.eps), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Inverse_+3A_x">X</code></td>
<td>
<p>a square numeric matrix</p>
</td></tr>
<tr><td><code id="Inverse_+3A_tol">tol</code></td>
<td>
<p>tolerance for checking for 0 pivot</p>
</td></tr>
<tr><td><code id="Inverse_+3A_...">...</code></td>
<td>
<p>other arguments passed on</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is purely didactic: The identity matrix, <code class="reqn">I</code>, is appended to <code class="reqn">X</code>, giving
<code class="reqn">X | I</code>.  Applying Gaussian elimination gives <code class="reqn">I | X^{-1}</code>, and the portion corresponding
to <code class="reqn">X^{-1}</code> is returned.
</p>


<h3>Value</h3>

<p>the inverse of <code>X</code>
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- matrix(c(2, 1, -1,
               -3, -1, 2,
               -2,  1, 2), 3, 3, byrow=TRUE)
  Inverse(A)
  Inverse(A, verbose=TRUE, fractions=TRUE)
</code></pre>

<hr>
<h2 id='is_square_matrix'>Test for square matrix</h2><span id='topic+is_square_matrix'></span><span id='topic+is_symmetric_matrix'></span><span id='topic+is_orthogonal_matrix'></span>

<h3>Description</h3>

<p>Test for square matrix
</p>
<p>Test for square, symmetric matrix
</p>
<p>Test for orthogonal matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_square_matrix(x)

is_symmetric_matrix(x)

is_orthogonal_matrix(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_square_matrix_+3A_x">x</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if <code>x</code> is a square matrix, else <code>FALSE</code>
</p>
<p><code>TRUE</code> if <code>x</code> is a square, symmetric matrix, else <code>FALSE</code>
</p>
<p><code>TRUE</code> if <code>x</code> is an orthogonal matrix, else <code>FALSE</code>
</p>

<hr>
<h2 id='J'>Create a vector, matrix or array of constants</h2><span id='topic+J'></span>

<h3>Description</h3>

<p>This function creates a vector, matrix or array of constants, typically used for
the unit vector or unit matrix in matrix expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>J(..., constant = 1, dimnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="J_+3A_...">...</code></td>
<td>
<p>One or more arguments supplying the dimensions of the array, all non-negative integers</p>
</td></tr>
<tr><td><code id="J_+3A_constant">constant</code></td>
<td>
<p>The value of the constant used in the array</p>
</td></tr>
<tr><td><code id="J_+3A_dimnames">dimnames</code></td>
<td>
<p>Either <code>NULL</code> or the names for the dimensions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"dimnames"</code> attribute is optional: if present it is a list with one component for each dimension,
either <code>NULL</code> or a character vector of the length given by the element of the <code>"dim"</code> attribute for that
dimension. The list can be named, and the list names will be used as names for the dimensions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J(3)
J(2,3)
J(2,3,2)
J(2,3, constant=2, dimnames=list(letters[1:2], LETTERS[1:3]))

X &lt;- matrix(1:6, nrow=2, ncol=3)
dimnames(X) &lt;- list(sex=c("M", "F"), day=c("Mon", "Wed", "Fri"))
J(2) %*% X      # column sums
X %*% J(3)      # row sums
</code></pre>

<hr>
<h2 id='len'>Length of a Vector or Column Lengths of a Matrix</h2><span id='topic+len'></span>

<h3>Description</h3>

<p><code>len</code> calculates the Euclidean length (also called Euclidean norm) of a vector or the
length of each column of a numeric matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>len(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="len_+3A_x">X</code></td>
<td>
<p>a numeric vector or matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar or vector containing the length(s)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+norm">norm</a></code> for more general matrix norms
</p>


<h3>Examples</h3>

<pre><code class='language-R'>len(1:3)
len(matrix(1:9, 3, 3))

# distance between two vectors
len(1:3 - c(1,1,1))
</code></pre>

<hr>
<h2 id='LU'>LU Decomposition</h2><span id='topic+LU'></span>

<h3>Description</h3>

<p><code>LU</code> computes the LU decomposition of a matrix, <code class="reqn">A</code>, such that <code class="reqn">P A = L U</code>,
where <code class="reqn">L</code> is a lower triangle matrix, <code class="reqn">U</code> is an upper triangle, and <code class="reqn">P</code> is a
permutation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LU(A, b, tol = sqrt(.Machine$double.eps), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LU_+3A_a">A</code></td>
<td>
<p>coefficient matrix</p>
</td></tr>
<tr><td><code id="LU_+3A_b">b</code></td>
<td>
<p>right-hand side vector. When supplied the returned object will also contain the solved
<code class="reqn">d</code> and <code>x</code> elements</p>
</td></tr>
<tr><td><code id="LU_+3A_tol">tol</code></td>
<td>
<p>tolerance for checking for 0 pivot</p>
</td></tr>
<tr><td><code id="LU_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, print intermediate steps</p>
</td></tr>
<tr><td><code id="LU_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+showEqn">showEqn</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LU decomposition is used to solve the equation <code class="reqn">A x = b</code> by calculating
<code class="reqn">L(Ux - d) = 0</code>, where <code class="reqn">Ld = b</code>. If row exchanges are necessary for
<code class="reqn">A</code> then the permutation matrix <code class="reqn">P</code> will be required to exchange the rows in <code class="reqn">A</code>;
otherwise, <code class="reqn">P</code> will be an identity matrix and the LU equation will be simplified to
<code class="reqn">A = L U</code>.
</p>


<h3>Value</h3>

<p>A list of matrix components of the solution, <code>P</code>, <code>L</code> and <code>U</code>. If <code>b</code>
is supplied, the vectors <code class="reqn">d</code> and <code>x</code> are also returned.
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  A &lt;- matrix(c(2, 1, -1,
               -3, -1, 2,
               -2,  1, 2), 3, 3, byrow=TRUE)
  b &lt;- c(8, -11, -3)
  (ret &lt;- LU(A)) # P is an identity; no row swapping
  with(ret, L %*% U) # check that A = L * U
  LU(A, b)
  
  LU(A, b, verbose=TRUE)
  LU(A, b, verbose=TRUE, fractions=TRUE)

  # permutations required in this example
  A &lt;- matrix(c(1,  1, -1,
                2,  2,  4,
                1, -1,  1), 3, 3, byrow=TRUE)
  b &lt;- c(1, 2, 9)
  (ret &lt;- LU(A, b))
  with(ret, P %*% A)
  with(ret, L %*% U)

</code></pre>

<hr>
<h2 id='matrix2latex'>Convert matrix to LaTeX equation</h2><span id='topic+matrix2latex'></span>

<h3>Description</h3>

<p>This function provides a soft-wrapper to <code>xtable::xtableMatharray()</code> with support for
<code>fraction</code>s output and square <code>bracket</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix2latex(x, fractions = FALSE, brackets = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix2latex_+3A_x">x</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="matrix2latex_+3A_fractions">fractions</code></td>
<td>
<p>logical; if <code>TRUE</code>, try to express non-integers as rational numbers, using the <code><a href="MASS.html#topic+fractions">fractions</a></code> 
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
<tr><td><code id="matrix2latex_+3A_brackets">brackets</code></td>
<td>
<p>logical; include square brackets around the matrices?</p>
</td></tr>
<tr><td><code id="matrix2latex_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>xtable::xtableMatharray()</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Phil Chalmers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(2, 1, -1,
             -3, -1, 2,
             -2,  1, 2), 3, 3, byrow=TRUE)
b &lt;- c(8, -11, -3)

matrix2latex(cbind(A,b))
matrix2latex(cbind(A,b), digits = 0)
matrix2latex(cbind(A/2,b), fractions = TRUE)

</code></pre>

<hr>
<h2 id='minor'>Minor of A[i,j]</h2><span id='topic+minor'></span>

<h3>Description</h3>

<p>Returns the minor of element (i,j) of the square matrix A, i.e., the determinant of the
sub-matrix that results when row i and column j are deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minor(A, i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minor_+3A_a">A</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="minor_+3A_i">i</code></td>
<td>
<p>row index</p>
</td></tr>
<tr><td><code id="minor_+3A_j">j</code></td>
<td>
<p>column index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the minor of A[i,j]
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rowMinors">rowMinors</a></code> for all minors of a given row
</p>
<p>Other determinants: 
<code><a href="#topic+Det">Det</a>()</code>,
<code><a href="#topic+adjoint">adjoint</a>()</code>,
<code><a href="#topic+cofactor">cofactor</a>()</code>,
<code><a href="#topic+rowCofactors">rowCofactors</a>()</code>,
<code><a href="#topic+rowMinors">rowMinors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(4, -12, -4,
              2,   1,  3,
             -1,  -3,  2), 3, 3, byrow=TRUE)
minor(M, 1, 1)
minor(M, 1, 2)
minor(M, 1, 3)
</code></pre>

<hr>
<h2 id='MoorePenrose'>Moore-Penrose inverse of a matrix</h2><span id='topic+MoorePenrose'></span>

<h3>Description</h3>

<p>The Moore-Penrose inverse is a generalization of the regular inverse of a square, non-singular, symmetric matrix
to other cases (rectangular, singular), yet retain similar properties to a regular inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MoorePenrose(X, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MoorePenrose_+3A_x">X</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
<tr><td><code id="MoorePenrose_+3A_tol">tol</code></td>
<td>
<p>Tolerance for a singular (rank-deficient) matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Moore-Penrose inverse of <code>X</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rnorm(20), ncol=2)
# introduce a linear dependency in X[,3]
X &lt;- cbind(X, 1.5*X[, 1] - pi*X[, 2])

Y &lt;- MoorePenrose(X)
# demonstrate some properties of the M-P inverse
# X Y X = X
round(X %*% Y %*% X - X, 8)
# Y X Y = Y
round(Y %*% X %*% Y - Y, 8)
# X Y = t(X Y)
round(X %*% Y - t(X %*% Y), 8)
# Y X = t(Y X)
round(Y %*% X - t(Y %*% X), 8)
</code></pre>

<hr>
<h2 id='mpower'>Matrix Power</h2><span id='topic+mpower'></span>

<h3>Description</h3>

<p>A simple function to demonstrate calculating the power of a square symmetric matrix in terms of its eigenvalues and eigenvectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpower(A, p, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpower_+3A_a">A</code></td>
<td>
<p>a square symmetric matrix</p>
</td></tr>
<tr><td><code id="mpower_+3A_p">p</code></td>
<td>
<p>matrix power, not necessarily a positive integer</p>
</td></tr>
<tr><td><code id="mpower_+3A_tol">tol</code></td>
<td>
<p>tolerance for determining if the matrix is symmetric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix power <code>p</code> can be a fraction or other non-integer.  For example, <code>p=1/2</code> and
<code>p=1/3</code> give a square-root and cube-root of the matrix.
</p>
<p>Negative powers are also allowed. For example, <code>p=-1</code> gives the inverse and <code>p=-1/2</code>
gives the inverse square-root.
</p>


<h3>Value</h3>

<p><code>A</code> raised to the power <code>p</code>: <code>A^p</code>
</p>


<h3>See Also</h3>

<p>The <code>{%^%}</code> operator in the <span class="pkg">expm</span> package is far more efficient
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- matrix(c(1,2,3,2,5,6,3,6,10), 3, 3) # nonsingular, symmetric
C
mpower(C, 2)
zapsmall(mpower(C, -1))
solve(C)    # check
</code></pre>

<hr>
<h2 id='plot.regvec3d'>Plot method for regvec3d objects</h2><span id='topic+plot.regvec3d'></span><span id='topic+summary.regvec3d'></span><span id='topic+print.regvec3d'></span>

<h3>Description</h3>

<p>The plot method for <code>regvec3d</code> objects uses the low-level graphics tools in this package to draw 3D and 3D
vector diagrams reflecting the partial and marginal
relations of <code>y</code> to <code>x1</code> and <code>x2</code> in a bivariate multiple linear regression model,
<code>lm(y ~ x1 + x2)</code>.
</p>
<p>The <code>summary</code> method prints the vectors and their vector lengths, followed by the <code>summary</code>
for the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regvec3d'
plot(
  x,
  y,
  dimension = 3,
  col = c("black", "red", "blue", "brown", "lightgray"),
  col.plane = "gray",
  cex.lab = 1.2,
  show.base = 2,
  show.marginal = FALSE,
  show.hplane = TRUE,
  show.angles = TRUE,
  error.sphere = c("none", "e", "y.hat"),
  scale.error.sphere = x$scale,
  level.error.sphere = 0.95,
  grid = FALSE,
  add = FALSE,
  ...
)

## S3 method for class 'regvec3d'
summary(object, ...)

## S3 method for class 'regvec3d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.regvec3d_+3A_x">x</code></td>
<td>
<p>A &ldquo;regvec3d&rdquo; object</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_y">y</code></td>
<td>
<p>Ignored; only included for compatibility with the S3 generic</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_dimension">dimension</code></td>
<td>
<p>Number of dimensions to plot: <code>3</code> (default) or <code>2</code></p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_col">col</code></td>
<td>
<p>A vector of 5 colors. <code>col[1]</code> is used for the y and residual (e) vectors, and for x1 and x2;
<code>col[2]</code> is used for the vectors <code>y -&gt; yhat</code> and <code>y -&gt; e</code>;
<code>col[3]</code> is used for the vectors <code>yhat -&gt; b1</code> and <code>yhat -&gt; b2</code>;</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_col.plane">col.plane</code></td>
<td>
<p>Color of the base plane in a 3D plot or axes in a 2D plot</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_cex.lab">cex.lab</code></td>
<td>
<p>character expansion applied to vector labels. May be a number or numeric vector corresponding to the the
rows of <code>X</code>, recycled as necessary.</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_show.base">show.base</code></td>
<td>
<p>If <code>show.base &gt; 0</code>, draws the base plane in a 3D plot; if <code>show.base &gt; 1</code>,
the plane is drawn thicker</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_show.marginal">show.marginal</code></td>
<td>
<p>If <code>TRUE</code> also draws lines showing the marginal relations of <code>y</code> on <code>x1</code> and on <code>x2</code></p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_show.hplane">show.hplane</code></td>
<td>
<p>If <code>TRUE</code>, draws the plane defined by <code>y</code>, <code>yhat</code> and the origin in the 3D</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_show.angles">show.angles</code></td>
<td>
<p>If <code>TRUE</code>, draw and label the angle between the <code>x1</code> and <code>x2</code> and between <code>y</code> and <code>yhat</code>,
corresponding respectively to the correlation between the xs and the multiple correlation</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_error.sphere">error.sphere</code></td>
<td>
<p>Plot a sphere (or in 2D, a circle) of radius proportional to the length of
the residual vector, centered either at the origin (<code>"e"</code>)
or at the fitted-values vector (<code>"y.hat"</code>; the default is <code>"none"</code>.)</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_scale.error.sphere">scale.error.sphere</code></td>
<td>
<p>Whether to scale the error sphere if <code>error.sphere="y.hat"</code>; defaults to <code>TRUE</code> if the
vectors representing the variables are scaled, in which case the oblique projections of the error spheres
can represent confidence intervals for the coefficients; otherwise defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_level.error.sphere">level.error.sphere</code></td>
<td>
<p>The confidence level for the error sphere, applied if <code>scale.error.sphere=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_grid">grid</code></td>
<td>
<p>If <code>TRUE</code>, draws a light grid on the base plane</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add to the current plot; otherwise start a new rgl or plot window</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_...">...</code></td>
<td>
<p>Parameters passed down to functions [unused now]</p>
</td></tr>
<tr><td><code id="plot.regvec3d_+3A_object">object</code></td>
<td>
<p>A <code>regvec3d</code> object for the <code>summary</code> method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 3D diagram shows the vector <code>y</code> and the plane formed by the predictors,
<code>x1</code> and <code>x2</code>, where all variables are represented in deviation form, so that
the intercept need not be included.
</p>
<p>A 2D diagram, using the first two columns of the result, can be used to show the projection
of the space in the <code>x1</code>, <code>x2</code> plane.
</p>
<p>The drawing functions <code><a href="#topic+vectors">vectors</a></code> and <code>link{vectors3d}</code> used by the <code><a href="#topic+plot.regvec3d">plot.regvec3d</a></code> method only work
reasonably well if the variables are shown on commensurate scales, i.e., with
either <code>scale=TRUE</code> or <code>normalize=TRUE</code>.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>References</h3>

<p>Fox, J. (2016). <em>Applied Regression Analysis and Generalized Linear Models</em>, 3rd ed., Sage, Chapter 10.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regvec3d">regvec3d</a></code>, <code><a href="#topic+vectors3d">vectors3d</a></code>, <code><a href="#topic+vectors">vectors</a></code>
</p>
<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(carData)) {
   data("Duncan", package="carData")
   dunc.reg &lt;- regvec3d(prestige ~ income + education, data=Duncan)
   plot(dunc.reg)
   plot(dunc.reg, dimension=2)
   plot(dunc.reg, error.sphere="e")
   summary(dunc.reg)

   # Example showing Simpson's paradox
   data("States", package="carData")
   states.vec &lt;- regvec3d(SATM ~ pay + percent, data=States, scale=TRUE)
   plot(states.vec, show.marginal=TRUE)
   plot(states.vec, show.marginal=TRUE, dimension=2)
   summary(states.vec)
}
</code></pre>

<hr>
<h2 id='plotEqn'>Plot Linear Equations</h2><span id='topic+plotEqn'></span>

<h3>Description</h3>

<p>Shows what matrices <code class="reqn">A, b</code> look like as the system of linear equations, <code class="reqn">A x = b</code> with two unknowns,
x1, x2, by plotting a line for each equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEqn(
  A,
  b,
  vars,
  xlim,
  ylim,
  col = 1:nrow(A),
  lwd = 2,
  lty = 1,
  axes = TRUE,
  labels = TRUE,
  solution = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEqn_+3A_a">A</code></td>
<td>
<p>either the matrix of coefficients of a system of linear equations, or the matrix <code>cbind(A,b)</code>.
The <code>A</code> matrix must have two columns.</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_b">b</code></td>
<td>
<p>if supplied, the vector of constants on the right hand side of the equations, of length matching
the number of rows of <code>A</code>.</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_vars">vars</code></td>
<td>
<p>a numeric or character vector of names of the variables.
If supplied, the length must be equal to the number of unknowns in the equations, i.e., 2.
The default is <code>c(expression(x[1]), expression(x[2]))</code>.</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_xlim">xlim</code></td>
<td>
<p>horizontal axis limits for the first variable</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_ylim">ylim</code></td>
<td>
<p>vertical axis limits for the second variable; if missing, <code>ylim</code> is calculated from the
range of the set of equations over the <code>xlim</code>.</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_col">col</code></td>
<td>
<p>scalar or vector of colors for the lines, recycled as necessary</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_lwd">lwd</code></td>
<td>
<p>scalar or vector of line widths for the lines, recycled as necessary</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_lty">lty</code></td>
<td>
<p>scalar or vector of line types for the lines, recycled as necessary</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_axes">axes</code></td>
<td>
<p>logical; draw horizontal and vertical axes through (0,0)?</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_labels">labels</code></td>
<td>
<p>logical, or a vector of character labels for the equations; if <code>TRUE</code>, each equation is labeled
using the character string resulting from <code><a href="#topic+showEqn">showEqn</a></code>, modified so that the
<code>x</code>s are properly subscripted.</p>
</td></tr>
<tr><td><code id="plotEqn_+3A_solution">solution</code></td>
<td>
<p>logical; should the solution points for pairs of equations be marked?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing; used for the side effect of making a plot
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>References</h3>

<p>Fox, J. and Friendly, M. (2016). &quot;Visualizing Simultaneous Linear Equations, Geometric Vectors, and
Least-Squares Regression with the matlib Package for R&quot;. <em>useR Conference</em>, Stanford, CA, June 27 - June 30, 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+showEqn">showEqn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># consistent equations
A&lt;- matrix(c(1,2,3, -1, 2, 1),3,2)
b &lt;- c(2,1,3)
showEqn(A, b)
plotEqn(A,b)

# inconsistent equations
b &lt;- c(2,1,6)
showEqn(A, b)
plotEqn(A,b)
</code></pre>

<hr>
<h2 id='plotEqn3d'>Plot Linear Equations in 3D</h2><span id='topic+plotEqn3d'></span>

<h3>Description</h3>

<p>Shows what matrices <code class="reqn">A, b</code> look like as the system of linear equations, <code class="reqn">A x = b</code> with three unknowns,
x1, x2, and x3, by plotting a plane for each equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEqn3d(
  A,
  b,
  vars,
  xlim = c(-2, 2),
  ylim = c(-2, 2),
  zlim,
  col = 2:(nrow(A) + 1),
  alpha = 0.9,
  labels = FALSE,
  solution = TRUE,
  axes = TRUE,
  lit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEqn3d_+3A_a">A</code></td>
<td>
<p>either the matrix of coefficients of a system of linear equations, or the matrix <code>cbind(A,b)</code>
The <code>A</code> matrix must have three columns.</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_b">b</code></td>
<td>
<p>if supplied, the vector of constants on the right hand side of the equations, of length matching
the number of rows of <code>A</code>.</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_vars">vars</code></td>
<td>
<p>a numeric or character vector of names of the variables.
If supplied, the length must be equal to the number of unknowns in the equations.
The default is <code>paste0("x", 1:ncol(A)</code>.</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_xlim">xlim</code></td>
<td>
<p>axis limits for the first variable</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_ylim">ylim</code></td>
<td>
<p>axis limits for the second variable</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_zlim">zlim</code></td>
<td>
<p>horizontal axis limits for the second variable; if missing, <code>zlim</code> is calculated from the
range of the set of equations over the <code>xlim</code> and <code>ylim</code></p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_col">col</code></td>
<td>
<p>scalar or vector of colors for the lines, recycled as necessary</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_alpha">alpha</code></td>
<td>
<p>transparency applied to each plane</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_labels">labels</code></td>
<td>
<p>logical, or a vector of character labels for the equations; not yet implemented.</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_solution">solution</code></td>
<td>
<p>logical; should the solution point for all equations be marked (if possible)</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_axes">axes</code></td>
<td>
<p>logical; whether to frame the plot with coordinate axes</p>
</td></tr>
<tr><td><code id="plotEqn3d_+3A_lit">lit</code></td>
<td>
<p>logical, specifying if lighting calculation should take place on geometry; see <code><a href="rgl.html#topic+rgl.material">rgl.material</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing; used for the side effect of making a plot
</p>


<h3>Author(s)</h3>

<p>Michael Friendly, John Fox
</p>


<h3>References</h3>

<p>Fox, J. and Friendly, M. (2016). &quot;Visualizing Simultaneous Linear Equations, Geometric Vectors, and
Least-Squares Regression with the matlib Package for R&quot;. <em>useR Conference</em>, Stanford, CA, June 27 - June 30, 2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three consistent equations in three unknowns
A &lt;- matrix(c(13, -4, 2, -4, 11, -2, 2, -2, 8), 3,3)
b &lt;- c(1,2,4)
plotEqn3d(A,b)
</code></pre>

<hr>
<h2 id='pointOnLine'>Position of a point along a line</h2><span id='topic+pointOnLine'></span>

<h3>Description</h3>

<p>A utility function for drawing vector diagrams. Find position of an interpolated point along a line from <code>x1</code> to <code>x2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pointOnLine(x1, x2, d, absolute = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pointOnLine_+3A_x1">x1</code></td>
<td>
<p>A vector of length 2 or 3, representing the starting point of a line in  2D or 3D space</p>
</td></tr>
<tr><td><code id="pointOnLine_+3A_x2">x2</code></td>
<td>
<p>A vector of length 2 or 3, representing the ending point of a line in  2D or 3D space</p>
</td></tr>
<tr><td><code id="pointOnLine_+3A_d">d</code></td>
<td>
<p>The distance along the line from <code>x1</code> to <code>x2</code> of the point to be found.</p>
</td></tr>
<tr><td><code id="pointOnLine_+3A_absolute">absolute</code></td>
<td>
<p>logical; if <code>TRUE</code>, <code>d</code> is taken as an absolute distance along the line; otherwise it
is calculated as a relative distance, i.e., a fraction of the length of the line.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a step of length <code>d</code> along the line defined by the difference between the two points, <code>x2 - x1</code>.
When <code>absolute=FALSE</code>, this step is proportional to the difference,
while when <code>absolute=TRUE</code>, the difference is first scaled to unit length so that the step is always of length <code>d</code>.
Note that the physical length of a line in different directions in a graph depends on the aspect ratio of the plot axes,
and lines of the same length will only appear equal if the aspect ratio is one
(<code>asp=1</code> in 2D, or <code>aspect3d("iso")</code> in 3D).
</p>


<h3>Value</h3>

<p>The interpolated point, a vector of the same length as <code>x1</code>
</p>


<h3>See Also</h3>

<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(0, 0)
x2 &lt;- c(1, 4)
pointOnLine(x1, x2, 0.5)
pointOnLine(x1, x2, 0.5, absolute=FALSE)
pointOnLine(x1, x2, 1.1)

y1 &lt;- c(1, 2, 3)
y2 &lt;- c(3, 2, 1)
pointOnLine(y1, y2, 0.5)
pointOnLine(y1, y2, 0.5, absolute=FALSE)
</code></pre>

<hr>
<h2 id='powerMethod'>Power Method for Eigenvectors</h2><span id='topic+powerMethod'></span>

<h3>Description</h3>

<p>Finds a dominant eigenvalue, <code class="reqn">\lambda_1</code>, and its corresponding
eigenvector, <code class="reqn">v_1</code>, of a square matrix by applying Hotelling's (1933) Power Method with scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerMethod(A, v = NULL, eps = 1e-06, maxiter = 100, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerMethod_+3A_a">A</code></td>
<td>
<p>a square numeric matrix</p>
</td></tr>
<tr><td><code id="powerMethod_+3A_v">v</code></td>
<td>
<p>optional starting vector; if not supplied, it uses a unit vector of length equal to the number of rows / columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="powerMethod_+3A_eps">eps</code></td>
<td>
<p>convergence threshold for terminating iterations</p>
</td></tr>
<tr><td><code id="powerMethod_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="powerMethod_+3A_plot">plot</code></td>
<td>
<p>logical; if <code>TRUE</code>, plot the series of iterated eigenvectors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method is based upon the fact that repeated multiplication of a matrix <code class="reqn">A</code> by a trial
vector <code class="reqn">v_1^{(k)}</code> converges to the value of the eigenvector,
</p>
<p style="text-align: center;"><code class="reqn">v_1^{(k+1)} = A v_1^{(k)} / \vert\vert A v_1^{(k)} \vert\vert </code>
</p>

<p>The corresponding eigenvalue is then found as
</p>
<p style="text-align: center;"><code class="reqn">\lambda_1 = \frac{v_1^T A v_1}{v_1^T  v_1}</code>
</p>

<p>In pre-computer days, this method could be extended to find subsequent eigenvalue - eigenvector
pairs by &quot;deflation&quot;, i.e., by applying the method again to the new matrix.
<code class="reqn">A - \lambda_1 v_1 v_1^{T} </code>.
</p>
<p>This method is still used in some computer-intensive applications with huge matrices where only the
dominant eigenvector is required, e.g., the Google Page Rank algorithm.
</p>


<h3>Value</h3>

<p>a list containing the eigenvector (<code>vector</code>), eigenvalue (<code>value</code>), iterations (<code>iter</code>),
and iteration history (<code>vector_iterations</code>)
</p>


<h3>Author(s)</h3>

<p>Gaston Sanchez (from matrixkit)
</p>


<h3>References</h3>

<p>Hotelling, H. (1933). Analysis of a complex of statistical variables into principal components. <em>Journal of Educational Psychology</em>, 24, 417-441, and 498-520.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- cbind(c(7, 3), c(3, 6))
powerMethod(A)
eigen(A)$values[1] # check
eigen(A)$vectors[,1]

# demonstrate how the power method converges to a solution
powerMethod(A, v = c(-.5, 1), plot = TRUE)

B &lt;- cbind(c(1, 2, 0), c(2, 1, 3), c(0, 3, 1))
(rv &lt;- powerMethod(B))

# deflate to find 2nd latent vector
l &lt;- rv$value
v &lt;- c(rv$vector)
B1 &lt;- B - l * outer(v, v)
powerMethod(B1)
eigen(B)$vectors     # check

# a positive, semi-definite matrix, with eigenvalues 12, 6, 0
C &lt;- matrix(c(7, 4, 1,  4, 4, 4,  1, 4, 7), 3, 3)
eigen(C)$vectors
powerMethod(C)
</code></pre>

<hr>
<h2 id='printMatEqn'>Print Matrices or Matrix Operations Side by Side</h2><span id='topic+printMatEqn'></span>

<h3>Description</h3>

<p>This function is designed to print a collection of matrices, vectors, character strings
and matrix expressions side by side. A typical use is to illustrate matrix equations in a compact and
comprehensible way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printMatEqn(..., space = 1, tol = sqrt(.Machine$double.eps), fractions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printMatEqn_+3A_...">...</code></td>
<td>
<p>matrices and character operations to be passed and printed to the console. These
can include named arguments, character string operation symbols (e.g., <code>"+"</code>)</p>
</td></tr>
<tr><td><code id="printMatEqn_+3A_space">space</code></td>
<td>
<p>amount of blank spaces to place around operations such as <code>"+"</code>,
<code>"-"</code>, <code>"="</code>, etc</p>
</td></tr>
<tr><td><code id="printMatEqn_+3A_tol">tol</code></td>
<td>
<p>tolerance for rounding</p>
</td></tr>
<tr><td><code id="printMatEqn_+3A_fractions">fractions</code></td>
<td>
<p>logical; if <code>TRUE</code>, try to express non-integers as rational numbers, using the <code><a href="MASS.html#topic+fractions">fractions</a></code>
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL; A formatted sequence of matrices and matrix operations is printed to the console
</p>


<h3>Author(s)</h3>

<p>Phil Chalmers
</p>


<h3>See Also</h3>

<p><code><a href="#topic+showEqn">showEqn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(c(2, 1, -1,
             -3, -1, 2,
             -2,  1, 2), 3, 3, byrow=TRUE)
x &lt;- c(2, 3, -1)

# provide implicit or explicit labels
printMatEqn(AA = A, "*", xx = x, '=', b = A %*% x)
printMatEqn(A, "*", x, '=', b = A %*% x)
printMatEqn(A, "*", x, '=', A %*% x)

# compare with showEqn
b &lt;- c(4, 2, 1)
printMatEqn(A, x=paste0("x", 1:3),"=", b)
showEqn(A, b)

# decimal example
A &lt;- matrix(c(0.5, 1, 3, 0.75, 2.8, 4), nrow = 2)
x &lt;- c(0.5, 3.7, 2.3)
y &lt;- c(0.7, -1.2)
b &lt;- A %*% x - y

printMatEqn(A, "*", x, "-", y, "=", b)
printMatEqn(A, "*", x, "-", y, "=", b, fractions=TRUE)

</code></pre>

<hr>
<h2 id='printMatrix'>Print a matrix, allowing fractions or LaTeX output</h2><span id='topic+printMatrix'></span>

<h3>Description</h3>

<p>Print a matrix, allowing fractions or LaTeX output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printMatrix(
  A,
  parent = TRUE,
  fractions = FALSE,
  latex = FALSE,
  tol = sqrt(.Machine$double.eps)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printMatrix_+3A_a">A</code></td>
<td>
<p>A numeric matrix</p>
</td></tr>
<tr><td><code id="printMatrix_+3A_parent">parent</code></td>
<td>
<p>flag used to search in the parent envir for suitable definitions of other arguments.
Set to <code>TRUE</code> (the default) if you want to only use the inputs provided.</p>
</td></tr>
<tr><td><code id="printMatrix_+3A_fractions">fractions</code></td>
<td>
<p>If <code>TRUE</code>, print numbers as rational fractions, using the <code><a href="MASS.html#topic+fractions">fractions</a></code>
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
<tr><td><code id="printMatrix_+3A_latex">latex</code></td>
<td>
<p>If <code>TRUE</code>, print the matrix in LaTeX format</p>
</td></tr>
<tr><td><code id="printMatrix_+3A_tol">tol</code></td>
<td>
<p>Tolerance for rounding small numbers to 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formatted matrix
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+fractions">fractions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(1:12, 3, 4) / 6
printMatrix(A, fractions=TRUE)
printMatrix(A, latex=TRUE)
</code></pre>

<hr>
<h2 id='Proj'>Projection of Vector y on columns of X</h2><span id='topic+Proj'></span>

<h3>Description</h3>

<p>Fitting a linear model, <code>lm(y ~ X)</code>, by least squares can be thought of geometrically as the orthogonal projection of
<code>y</code> on the column space of <code>X</code>. This function is designed to allow exploration of projections
and orthogonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Proj(y, X, list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Proj_+3A_y">y</code></td>
<td>
<p>a vector, treated as a one-column matrix</p>
</td></tr>
<tr><td><code id="Proj_+3A_x">X</code></td>
<td>
<p>a vector or matrix.  Number of rows of <code>y</code> and <code>X</code> must match</p>
</td></tr>
<tr><td><code id="Proj_+3A_list">list</code></td>
<td>
<p>logical; if FALSE, return just the projected vector; otherwise returns a list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The projection is defined as <code class="reqn">P y</code> where <code class="reqn">P = X (X'X)^- X'</code>
and <code class="reqn">X^-</code> is a generalized inverse.
</p>


<h3>Value</h3>

<p>the projection of <code>y</code> on <code>X</code> (if <code>list=FALSE</code>) or a list with elements <code>y</code> and <code>P</code>
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p>Other vector diagrams: 
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix( c(1, 1, 1, 1, 1, -1, 1, -1), 4,2, byrow=TRUE)
y &lt;- 1:4
Proj(y, X[,1])  # project y on unit vector
Proj(y, X[,2])
Proj(y, X)

# project unit vector on line between two points
y &lt;- c(1,1)
p1 &lt;- c(0,0)
p2 &lt;- c(1,0)
Proj(y, cbind(p1, p2))

# orthogonal complements
y &lt;- 1:4
yp &lt;-Proj(y, X, list=TRUE)
yp$y
P &lt;- yp$P
IP &lt;- diag(4) - P
yc &lt;- c(IP %*% y)
crossprod(yp$y, yc)

# P is idempotent:  P P = P
P %*% P
all.equal(P, P %*% P)
</code></pre>

<hr>
<h2 id='QR'>QR Decomposition by Graham-Schmidt Orthonormalization</h2><span id='topic+QR'></span>

<h3>Description</h3>

<p><code>QR</code> computes the QR decomposition of a matrix, <code class="reqn">X</code>, that is an orthonormal matrix, <code class="reqn">Q</code> and an upper triangular
matrix, <code class="reqn">R</code>, such that <code class="reqn">X = Q R</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QR(X, tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QR_+3A_x">X</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="QR_+3A_tol">tol</code></td>
<td>
<p>tolerance for detecting linear dependencies in the columns of <code>X</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The QR decomposition plays an important role in many statistical techniques.
In particular it can be used to solve the equation <code class="reqn">Ax = b</code> for given matrix <code class="reqn">A</code> and vector <code class="reqn">b</code>.
The function is included here simply to show the algorithm of Gram-Schmidt orthogonalization.  The standard
<code><a href="base.html#topic+qr">qr</a></code> function is faster and more accurate.
</p>


<h3>Value</h3>

<p>a list of three elements, consisting of an orthonormal matrix <code>Q</code>, an upper triangular matrix <code>R</code>, and the <code>rank</code>
of the matrix <code>X</code>
</p>


<h3>Author(s)</h3>

<p>John Fox and Georges Monette
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+qr">qr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1,2,3,4,5,6,7,8,10), 3, 3) # a square nonsingular matrix
res &lt;- QR(A)
res
q &lt;- res$Q
zapsmall( t(q) %*% q)   # check that q' q = I
r &lt;- res$R
q %*% r                 # check that q r = A

# relation to determinant: det(A) = prod(diag(R))
det(A)
prod(diag(r))

B &lt;- matrix(1:9, 3, 3) # a singular matrix
QR(B)
</code></pre>

<hr>
<h2 id='R'>Rank of a Matrix</h2><span id='topic+R'></span>

<h3>Description</h3>

<p>Returns the rank of a matrix <code>X</code>, using the QR decomposition, <code><a href="#topic+QR">QR</a></code>.
Included here as a simple function, because <code>rank</code> does something different
and it is not obvious what to use for matrix rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rank of <code>X</code>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+qr">qr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- outer(1:3, 3:1)
M
R(M)

M &lt;- matrix(1:9, 3, 3)
M
R(M)
# why rank=2?
echelon(M)

set.seed(1234)
M &lt;- matrix(sample(1:9), 3, 3)
M
R(M)
</code></pre>

<hr>
<h2 id='regvec3d'>Vector space representation of a two-variable regression model</h2><span id='topic+regvec3d'></span><span id='topic+regvec3d.formula'></span><span id='topic+regvec3d.default'></span>

<h3>Description</h3>

<p><code>regvec3d</code> calculates the 3D vectors that represent the projection of a two-variable multiple
regression model from n-D <em>observation</em> space into the 3D mean-deviation <em>variable</em> space that they span, thus
showing the regression of <code>y</code> on <code>x1</code> and <code>x2</code> in the model <code>lm(y ~ x1 + x2)</code>.
The result can be used to draw 2D and 3D vector diagrams accurately reflecting the partial and marginal
relations of <code>y</code> to <code>x1</code> and <code>x2</code> as vectors in this representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regvec3d(x1, ...)

## S3 method for class 'formula'
regvec3d(
  formula,
  data = NULL,
  which = 1:2,
  name.x1,
  name.x2,
  name.y,
  name.e,
  name.y.hat,
  name.b1.x1,
  name.b2.x2,
  abbreviate = 0,
  ...
)

## Default S3 method:
regvec3d(
  x1,
  x2,
  y,
  scale = FALSE,
  normalize = TRUE,
  name.x1 = deparse(substitute(x1)),
  name.x2 = deparse(substitute(x2)),
  name.y = deparse(substitute(y)),
  name.e = "residuals",
  name.y.hat = paste0(name.y, "hat"),
  name.b1.x1 = paste0("b1", name.x1),
  name.b2.x2 = paste0("b2", name.x2),
  name.y1.hat = paste0(name.y, "hat 1"),
  name.y2.hat = paste0(name.y, "hat 2"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regvec3d_+3A_x1">x1</code></td>
<td>
<p>The generic argument or the first predictor passed to the default method</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_formula">formula</code></td>
<td>
<p>A two-sided formula for the linear regression model. It must contain two quantitative predictors
(<code>x1</code> and <code>x2</code>) on the right-hand-side.  If further predictors are included, <code>y</code>,
<code>x1</code> and <code>x2</code> are taken as residuals from the their linear fits on these variables.</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_data">data</code></td>
<td>
<p>A data frame in which the variables in the model are found</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_which">which</code></td>
<td>
<p>Indices of predictors variables in the model taken as <code>x1</code> and <code>x2</code></p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.x1">name.x1</code></td>
<td>
<p>Name for <code>x1</code> to be used in the result and plots. By default, this is taken as the
name of the <code>x1</code> variable in the <code>formula</code>, possibly abbreviated according to <code>abbreviate</code>.</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.x2">name.x2</code></td>
<td>
<p>Ditto for the name of <code>x2</code></p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.y">name.y</code></td>
<td>
<p>Ditto for the name of <code>y</code></p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.e">name.e</code></td>
<td>
<p>Name for the residual vector. Default: <code>"residuals"</code></p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.y.hat">name.y.hat</code></td>
<td>
<p>Name for the fitted vector</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.b1.x1">name.b1.x1</code></td>
<td>
<p>Name for the vector corresponding to the partial coefficient of <code>x1</code></p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.b2.x2">name.b2.x2</code></td>
<td>
<p>Name for the vector corresponding to the partial coefficient of <code>x2</code></p>
</td></tr>
<tr><td><code id="regvec3d_+3A_abbreviate">abbreviate</code></td>
<td>
<p>An integer.  If <code>abbreviate &gt;0</code>, the names of <code>x1</code>, <code>x2</code> and <code>y</code>
are abbreviated to this length before being combined with the other <code>name.*</code> arguments</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_x2">x2</code></td>
<td>
<p>second predictor variable in the model</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_y">y</code></td>
<td>
<p>response variable in the model</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_scale">scale</code></td>
<td>
<p>logical; if <code>TRUE</code>, standardize each of <code>y</code>, <code>x1</code>, <code>x2</code> to standard scores</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_normalize">normalize</code></td>
<td>
<p>logical; if <code>TRUE</code>, normalize each vector relative to the maximum length of all</p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.y1.hat">name.y1.hat</code></td>
<td>
<p>Name for the vector corresponding to the marginal coefficient of <code>x1</code></p>
</td></tr>
<tr><td><code id="regvec3d_+3A_name.y2.hat">name.y2.hat</code></td>
<td>
<p>Name for the vector corresponding to the marginal coefficient of <code>x2</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If additional variables are included in the model, e.g., <code>lm(y ~ x1 + x2 + x3 + ...)</code>, then
<code>y</code>, <code>x1</code> and <code>x2</code> are all taken as <em>residuals</em> from their separate linear fits
on <code>x3 + ...</code>, thus showing their partial relations net of (or adjusting for) these additional predictors.
</p>
<p>A 3D diagram shows the vector <code>y</code> and the plane formed by the predictors,
<code>x1</code> and <code>x2</code>, where all variables are represented in deviation form, so that
the intercept need not be included.
</p>
<p>A 2D diagram, using the first two columns of the result, can be used to show the projection
of the space in the <code>x1</code>, <code>x2</code> plane.
</p>
<p>In these views, the ANOVA representation of the various sums of squares for the regression
predictors appears as the lengths of the various vectors.  For example, the error sum of
squares is the squared length of the <code>e</code> vector, and the regression sum of squares is
the squared length of the <code>yhat</code> vector.
</p>
<p>The drawing functions <code><a href="#topic+vectors">vectors</a></code> and <code>link{vectors3d}</code> used by the <code><a href="#topic+plot.regvec3d">plot.regvec3d</a></code> method only work
reasonably well if the variables are shown on commensurate scales, i.e., with
either <code>scale=TRUE</code> or <code>normalize=TRUE</code>.
</p>


<h3>Value</h3>

<p>An object of class &ldquo;regvec3d&rdquo;, containing the following components
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The &ldquo;lm&rdquo; object corresponding to <code>lm(y ~ x1 + x2)</code>.</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>A 9 x 3 matrix, whose rows correspond to the variables in the model,
the residual vector, the fitted vector, the partial fits for <code>x1</code>, <code>x2</code>,
and the marginal fits of <code>y</code> on <code>x1</code> and <code>x2</code>.
The columns effectively represent <code>x1</code>, <code>x2</code>, and <code>y</code>, but
are named <code>"x"</code>, <code>"y"</code> and <code>"z"</code>.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>regvec3d(formula)</code>: Formula method for regvec3d
</p>
</li>
<li> <p><code>regvec3d(default)</code>: Default method for regvec3d
</p>
</li></ul>


<h3>References</h3>

<p>Fox, J. (2016). <em>Applied Regression Analysis and Generalized Linear Models</em>, 3rd ed., Sage, Chapter 10.
</p>
<p>Fox, J. and Friendly, M. (2016). &quot;Visualizing Simultaneous Linear Equations, Geometric Vectors, and
Least-Squares Regression with the matlib Package for R&quot;. <em>useR Conference</em>, Stanford, CA, June 27 - June 30, 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.regvec3d">plot.regvec3d</a></code>
</p>
<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rgl)
therapy.vec &lt;- regvec3d(therapy ~ perstest + IE, data=therapy)
therapy.vec
plot(therapy.vec, col.plane="darkgreen")
plot(therapy.vec, dimension=2)
</code></pre>

<hr>
<h2 id='rowadd'>Add multiples of rows to other rows</h2><span id='topic+rowadd'></span>

<h3>Description</h3>

<p>The elementary row operation <code>rowadd</code> adds multiples of one or more rows to other rows of a matrix.
This is usually used as a means to solve systems of linear equations, of the form <code class="reqn">A x = b</code>, and <code>rowadd</code>
corresponds to adding equals to equals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowadd(x, from, to, mult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowadd_+3A_x">x</code></td>
<td>
<p>a numeric matrix, possibly consisting of the coefficient matrix, A, joined with a vector of constants, b.</p>
</td></tr>
<tr><td><code id="rowadd_+3A_from">from</code></td>
<td>
<p>the index of one or more source rows. If <code>from</code> is a vector, it must have the same length as <code>to</code>.</p>
</td></tr>
<tr><td><code id="rowadd_+3A_to">to</code></td>
<td>
<p>the index of one or more destination rows</p>
</td></tr>
<tr><td><code id="rowadd_+3A_mult">mult</code></td>
<td>
<p>the multiplier(s)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code><a href="#topic+rowmult">rowmult</a></code> and <code><a href="#topic+rowswap">rowswap</a></code> complete the basic operations used in reduction
to row echelon form and Gaussian elimination. These functions are used for demonstration purposes.
</p>


<h3>Value</h3>

<p>the matrix <code>x</code>, as modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+echelon">echelon</a></code>, <code><a href="#topic+gaussianElimination">gaussianElimination</a></code>
</p>
<p>Other elementary row operations: 
<code><a href="#topic+rowmult">rowmult</a>()</code>,
<code><a href="#topic+rowswap">rowswap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(2, 1, -1,
             -3, -1, 2,
             -2,  1, 2), 3, 3, byrow=TRUE)
b &lt;- c(8, -11, -3)

# using row operations to reduce below diagonal to 0
Ab &lt;- cbind(A, b)
(Ab &lt;- rowadd(Ab, 1, 2, 3/2))  # row 2 &lt;- row 2 + 3/2 row 1
(Ab &lt;- rowadd(Ab, 1, 3, 1))    # row 3 &lt;- row 3 + 1 row 1
(Ab &lt;- rowadd(Ab, 2, 3, -4))   # row 3 &lt;- row 3 - 4 row 2
# multiply to make diagonals = 1
(Ab &lt;- rowmult(Ab, 1:3, c(1/2, 2, -1)))
# The matrix is now in triangular form

# Could continue to reduce above diagonal to zero
echelon(A, b, verbose=TRUE, fractions=TRUE)

</code></pre>

<hr>
<h2 id='rowCofactors'>Row Cofactors of A[i,]</h2><span id='topic+rowCofactors'></span>

<h3>Description</h3>

<p>Returns the vector of cofactors of row i of the square matrix A.  The determinant, <code>Det(A)</code>,
can then be found as <code>M[i,] %*% rowCofactors(M,i)</code> for any row, i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowCofactors(A, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowCofactors_+3A_a">A</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="rowCofactors_+3A_i">i</code></td>
<td>
<p>row index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the cofactors of A[i,]
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Det">Det</a></code> for the determinant
</p>
<p>Other determinants: 
<code><a href="#topic+Det">Det</a>()</code>,
<code><a href="#topic+adjoint">adjoint</a>()</code>,
<code><a href="#topic+cofactor">cofactor</a>()</code>,
<code><a href="#topic+minor">minor</a>()</code>,
<code><a href="#topic+rowMinors">rowMinors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(4, -12, -4,
              2,   1,  3,
             -1,  -3,  2), 3, 3, byrow=TRUE)
minor(M, 1, 1)
minor(M, 1, 2)
minor(M, 1, 3)
rowCofactors(M, 1)
Det(M)
# expansion by cofactors of row 1
M[1,] %*% rowCofactors(M,1)

</code></pre>

<hr>
<h2 id='rowMinors'>Row Minors of A[i,]</h2><span id='topic+rowMinors'></span>

<h3>Description</h3>

<p>Returns the vector of minors of row i of the square matrix A
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowMinors(A, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowMinors_+3A_a">A</code></td>
<td>
<p>a square matrix</p>
</td></tr>
<tr><td><code id="rowMinors_+3A_i">i</code></td>
<td>
<p>row index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the minors of A[i,]
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p>Other determinants: 
<code><a href="#topic+Det">Det</a>()</code>,
<code><a href="#topic+adjoint">adjoint</a>()</code>,
<code><a href="#topic+cofactor">cofactor</a>()</code>,
<code><a href="#topic+minor">minor</a>()</code>,
<code><a href="#topic+rowCofactors">rowCofactors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(c(4, -12, -4,
              2,   1,  3,
             -1,  -3,  2), 3, 3, byrow=TRUE)
minor(M, 1, 1)
minor(M, 1, 2)
minor(M, 1, 3)
rowMinors(M, 1)
</code></pre>

<hr>
<h2 id='rowmult'>Multiply Rows by Constants</h2><span id='topic+rowmult'></span>

<h3>Description</h3>

<p>Multiplies one or more rows of a matrix by constants. This corresponds to multiplying or dividing equations
by constants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowmult(x, row, mult)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowmult_+3A_x">x</code></td>
<td>
<p>a matrix, possibly consisting of the coefficient matrix, A, joined with a vector of constants, b.</p>
</td></tr>
<tr><td><code id="rowmult_+3A_row">row</code></td>
<td>
<p>index of one or more rows.</p>
</td></tr>
<tr><td><code id="rowmult_+3A_mult">mult</code></td>
<td>
<p>row multiplier(s)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix <code>x</code>, modified
</p>


<h3>See Also</h3>

<p><code><a href="#topic+echelon">echelon</a></code>, <code><a href="#topic+gaussianElimination">gaussianElimination</a></code>
</p>
<p>Other elementary row operations: 
<code><a href="#topic+rowadd">rowadd</a>()</code>,
<code><a href="#topic+rowswap">rowswap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(2, 1, -1,
             -3, -1, 2,
             -2,  1, 2), 3, 3, byrow=TRUE)
b &lt;- c(8, -11, -3)

# using row operations to reduce below diagonal to 0
Ab &lt;- cbind(A, b)
(Ab &lt;- rowadd(Ab, 1, 2, 3/2))  # row 2 &lt;- row 2 + 3/2 row 1
(Ab &lt;- rowadd(Ab, 1, 3, 1))    # row 3 &lt;- row 3 + 1 row 1
(Ab &lt;- rowadd(Ab, 2, 3, -4))
# multiply to make diagonals = 1
(Ab &lt;- rowmult(Ab, 1:3, c(1/2, 2, -1)))
# The matrix is now in triangular form

</code></pre>

<hr>
<h2 id='rowswap'>Interchange two rows of a matrix</h2><span id='topic+rowswap'></span>

<h3>Description</h3>

<p>This elementary row operation corresponds to interchanging two equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rowswap(x, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rowswap_+3A_x">x</code></td>
<td>
<p>a matrix, possibly consisting of the coefficient matrix, A, joined with a vector of constants, b.</p>
</td></tr>
<tr><td><code id="rowswap_+3A_from">from</code></td>
<td>
<p>source row.</p>
</td></tr>
<tr><td><code id="rowswap_+3A_to">to</code></td>
<td>
<p>destination row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix <code>x</code>, with rows <code>from</code> and <code>to</code> interchanged
</p>


<h3>See Also</h3>

<p><code><a href="#topic+echelon">echelon</a></code>, <code><a href="#topic+gaussianElimination">gaussianElimination</a></code>
</p>
<p>Other elementary row operations: 
<code><a href="#topic+rowadd">rowadd</a>()</code>,
<code><a href="#topic+rowmult">rowmult</a>()</code>
</p>

<hr>
<h2 id='showEig'>Show the eigenvectors associated with a covariance matrix</h2><span id='topic+showEig'></span>

<h3>Description</h3>

<p>This function is designed for illustrating the eigenvectors associated with the
covariance matrix for a given bivariate data set.  It draws a data ellipse of
the data and adds vectors showing the eigenvectors of the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showEig(
  X,
  col.vec = "blue",
  lwd.vec = 3,
  mult = sqrt(qchisq(levels, 2)),
  asp = 1,
  levels = c(0.5, 0.95),
  plot.points = TRUE,
  add = !plot.points,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showEig_+3A_x">X</code></td>
<td>
<p>A two-column matrix or data frame</p>
</td></tr>
<tr><td><code id="showEig_+3A_col.vec">col.vec</code></td>
<td>
<p>color for eigenvectors</p>
</td></tr>
<tr><td><code id="showEig_+3A_lwd.vec">lwd.vec</code></td>
<td>
<p>line width for eigenvectors</p>
</td></tr>
<tr><td><code id="showEig_+3A_mult">mult</code></td>
<td>
<p>length multiplier(s) for eigenvectors</p>
</td></tr>
<tr><td><code id="showEig_+3A_asp">asp</code></td>
<td>
<p>aspect ratio of plot, set to <code>asp=1</code> by default, and passed to dataEllipse</p>
</td></tr>
<tr><td><code id="showEig_+3A_levels">levels</code></td>
<td>
<p>passed to dataEllipse determining the coverage of the data ellipse(s)</p>
</td></tr>
<tr><td><code id="showEig_+3A_plot.points">plot.points</code></td>
<td>
<p>logical; should the points be plotted?</p>
</td></tr>
<tr><td><code id="showEig_+3A_add">add</code></td>
<td>
<p>logical; should this call add to an existing plot?</p>
</td></tr>
<tr><td><code id="showEig_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>link[car]{dataEllipse}</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+dataEllipse">dataEllipse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(200)
y &lt;- .5 * x + .5 * rnorm(200)
X &lt;- cbind(x,y)
showEig(X)

# Duncan data
data(Duncan, package="carData")
showEig(Duncan[, 2:3], levels=0.68)
showEig(Duncan[,2:3], levels=0.68, robust=TRUE, add=TRUE, fill=TRUE)
</code></pre>

<hr>
<h2 id='showEqn'>Show Matrices (A, b) as Linear Equations</h2><span id='topic+showEqn'></span>

<h3>Description</h3>

<p>Shows what matrices <code class="reqn">A, b</code> look like as the system of linear equations, <code class="reqn">A x = b</code>, but written out
as a set of equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showEqn(
  A,
  b,
  vars,
  simplify = FALSE,
  reduce = FALSE,
  fractions = FALSE,
  latex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showEqn_+3A_a">A</code></td>
<td>
<p>either the matrix of coefficients of a system of linear equations, or the matrix <code>cbind(A,b)</code>.
Alternatively, can be of class <code>'lm'</code> to print the equations for the design matrix in a linear
regression model</p>
</td></tr>
<tr><td><code id="showEqn_+3A_b">b</code></td>
<td>
<p>if supplied, the vector of constants on the right hand side of the equations. When omitted
the values <code>b1, b2, ..., bn</code> will be used as placeholders</p>
</td></tr>
<tr><td><code id="showEqn_+3A_vars">vars</code></td>
<td>
<p>a numeric or character vector of names of the variables.
If supplied, the length must be equal to the number of unknowns in the equations.
The default is <code>paste0("x", 1:ncol(A)</code>.</p>
</td></tr>
<tr><td><code id="showEqn_+3A_simplify">simplify</code></td>
<td>
<p>logical; try to simplify the equations?</p>
</td></tr>
<tr><td><code id="showEqn_+3A_reduce">reduce</code></td>
<td>
<p>logical; only show the unique linear equations</p>
</td></tr>
<tr><td><code id="showEqn_+3A_fractions">fractions</code></td>
<td>
<p>logical; express numbers as rational fractions, using the <code><a href="MASS.html#topic+fractions">fractions</a></code> 
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
<tr><td><code id="showEqn_+3A_latex">latex</code></td>
<td>
<p>logical; print equations in a form suitable for LaTeX output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a one-column character matrix, one row for each equation
</p>


<h3>Author(s)</h3>

<p>Michael Friendly, John Fox, and Phil Chalmers
</p>


<h3>References</h3>

<p>Fox, J. and Friendly, M. (2016). &quot;Visualizing Simultaneous Linear Equations, Geometric Vectors, and
Least-Squares Regression with the matlib Package for R&quot;. <em>useR Conference</em>, Stanford, CA, June 27 - June 30, 2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotEqn">plotEqn</a></code>, <code><a href="#topic+plotEqn3d">plotEqn3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- matrix(c(2, 1, -1,
               -3, -1, 2,
               -2,  1, 2), 3, 3, byrow=TRUE)
  b &lt;- c(8, -11, -3)
  showEqn(A, b)
  # show numerically
  x &lt;- solve(A, b)
  showEqn(A, b, vars=x)

  showEqn(A, b, simplify=TRUE)
  showEqn(A, b, latex=TRUE)

  # lower triangle of equation with zeros omitted (for back solving)
  A &lt;- matrix(c(2, 1, 2,
               -3, -1, 2,
               -2,  1, 2), 3, 3, byrow=TRUE)
  U &lt;- LU(A)$U
  showEqn(U, simplify=TRUE, fractions=TRUE)
  showEqn(U, b, simplify=TRUE, fractions=TRUE)

  ####################
  # Linear models Design Matricies
  data(mtcars)
  ancova &lt;- lm(mpg ~ wt + vs, mtcars)
  summary(ancova)
  showEqn(ancova)
  showEqn(ancova, simplify=TRUE)
  showEqn(ancova, vars=round(coef(ancova),2))
  showEqn(ancova, vars=round(coef(ancova),2), simplify=TRUE)

  twoway_int &lt;- lm(mpg ~ vs * am, mtcars)
  summary(twoway_int)
  car::Anova(twoway_int)
  showEqn(twoway_int)
  showEqn(twoway_int, reduce=TRUE)
  showEqn(twoway_int, reduce=TRUE, simplify=TRUE)

  # Piece-wise linear regression
  x &lt;- c(1:10, 13:22)
  y &lt;- numeric(20)
  y[1:10] &lt;- 20:11 + rnorm(10, 0, 1.5)
  y[11:20] &lt;- seq(11, 15, len=10) + rnorm(10, 0, 1.5)
  plot(x, y, pch = 16)

  x2 &lt;- as.numeric(x &gt; 10)
  mod &lt;- lm(y ~ x + I((x - 10) * x2))
  summary(mod)
  lines(x, fitted(mod))
  showEqn(mod)
  showEqn(mod, vars=round(coef(mod),2))
  showEqn(mod, simplify=TRUE)

</code></pre>

<hr>
<h2 id='Solve'>Solve and Display Solutions for Systems of Linear Simultaneous Equations</h2><span id='topic+Solve'></span>

<h3>Description</h3>

<p>Solve the equation system <code class="reqn">Ax = b</code>, given the coefficient matrix
<code class="reqn">A</code> and right-hand side vector <code class="reqn">b</code>, using <code>link{gaussianElimination}</code>.
Display the solutions using <code><a href="#topic+showEqn">showEqn</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Solve(
  A,
  b = rep(0, nrow(A)),
  vars,
  verbose = FALSE,
  simplify = TRUE,
  fractions = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Solve_+3A_a">A</code></td>
<td>
<p>the matrix of coefficients of a system of linear equations</p>
</td></tr>
<tr><td><code id="Solve_+3A_b">b</code></td>
<td>
<p>the vector of constants on the right hand side of the equations. The default is a vector of zeros,
giving the homogeneous equations <code class="reqn">Ax = 0</code>.</p>
</td></tr>
<tr><td><code id="Solve_+3A_vars">vars</code></td>
<td>
<p>a numeric or character vector of names of the variables.
If supplied, the length must be equal to the number of unknowns in the equations.
The default is <code>paste0("x", 1:ncol(A)</code>.</p>
</td></tr>
<tr><td><code id="Solve_+3A_verbose">verbose</code></td>
<td>
<p>logical; show the steps of the Gaussian elimination algorithm?</p>
</td></tr>
<tr><td><code id="Solve_+3A_simplify">simplify</code></td>
<td>
<p>logical; try to simplify the equations?</p>
</td></tr>
<tr><td><code id="Solve_+3A_fractions">fractions</code></td>
<td>
<p>logical; express numbers as rational fractions, using the <code><a href="MASS.html#topic+fractions">fractions</a></code> 
function; if you require greater accuracy, you can set the <code>cycles</code> (default 10)
and/or <code>max.denominator</code> (default 2000) arguments to <code>fractions</code> as a global option, e.g.,
<code>options(fractions=list(cycles=100, max.denominator=10^4))</code>.</p>
</td></tr>
<tr><td><code id="Solve_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>link{gaussianElimination}</code> and <code><a href="#topic+showEqn">showEqn</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mimics the base function <code><a href="base.html#topic+solve">solve</a></code> when supplied with two arguments,
<code>(A, b)</code>, but gives a prettier result, as a set of equations for the solution.  The call
<code>solve(A)</code> with a single argument overloads this, returning the inverse of the matrix <code>A</code>.
For that sense, use the function <code><a href="#topic+inv">inv</a></code> instead.
</p>


<h3>Value</h3>

<p>the function is used primarily for its side effect of printing the solution in a
readable form, but it invisibly returns the solution as a character vector
</p>


<h3>Author(s)</h3>

<p>John Fox
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gaussianElimination">gaussianElimination</a></code>, <code><a href="#topic+showEqn">showEqn</a></code> <code><a href="#topic+inv">inv</a></code>, <code><a href="base.html#topic+solve">solve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A1 &lt;- matrix(c(2, 1, -1,
               -3, -1, 2,
               -2,  1, 2), 3, 3, byrow=TRUE)
  b1 &lt;- c(8, -11, -3)
  Solve(A1, b1) # unique solution

  A2 &lt;- matrix(1:9, 3, 3)
  b2 &lt;- 1:3
  Solve(A2,  b2, fractions=TRUE) # underdetermined

  b3 &lt;- c(1, 2, 4)
  Solve(A2, b3, fractions=TRUE) # overdetermined
</code></pre>

<hr>
<h2 id='SVD'>Singular Value Decomposition of a Matrix</h2><span id='topic+SVD'></span>

<h3>Description</h3>

<p>Compute the singular-value decomposition of a matrix <code class="reqn">X</code> either by Jacobi
rotations (the default) or from the eigenstructure of <code class="reqn">X'X</code> using
<code><a href="#topic+Eigen">Eigen</a></code>. Both methods are iterative.
The result consists of two orthonormal matrices, <code class="reqn">U</code>, and <code class="reqn">V</code> and the vector <code class="reqn">d</code>
of singular values, such that <code class="reqn">X = U diag(d) V'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SVD(
  X,
  method = c("Jacobi", "eigen"),
  tol = sqrt(.Machine$double.eps),
  max.iter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SVD_+3A_x">X</code></td>
<td>
<p>a square symmetric matrix</p>
</td></tr>
<tr><td><code id="SVD_+3A_method">method</code></td>
<td>
<p>either <code>"Jacobi"</code> (the default) or <code>"eigen"</code></p>
</td></tr>
<tr><td><code id="SVD_+3A_tol">tol</code></td>
<td>
<p>zero and convergence tolerance</p>
</td></tr>
<tr><td><code id="SVD_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method is more numerically stable, but the eigenstructure method
is much simpler.
Singular values of zero are not retained in the solution.
</p>


<h3>Value</h3>

<p>a list of three elements: <code>d</code>&ndash; singular values, <code>U</code>&ndash; left singular vectors, <code>V</code>&ndash; right singular vectors
</p>


<h3>Author(s)</h3>

<p>John Fox and Georges Monette
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+svd">svd</a></code>, the standard svd function
</p>
<p><code><a href="#topic+Eigen">Eigen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>C &lt;- matrix(c(1,2,3,2,5,6,3,6,10), 3, 3) # nonsingular, symmetric
C
SVD(C)

# least squares by the SVD
data("workers")
X &lt;- cbind(1, as.matrix(workers[, c("Experience", "Skill")]))
head(X)
y &lt;- workers$Income
head(y)
(svd &lt;- SVD(X))
VdU &lt;- svd$V %*% diag(1/svd$d) %*%t(svd$U)
(b &lt;- VdU %*% y)
coef(lm(Income ~ Experience + Skill, data=workers))
</code></pre>

<hr>
<h2 id='svdDemo'>Demonstrate the SVD for a 3 x 3 matrix</h2><span id='topic+svdDemo'></span>

<h3>Description</h3>

<p>This function draws an <code>rgl</code> scene consisting of a representation of the identity matrix and a
3 x 3 matrix <code>A</code>, together with the corresponding representation of the
matrices U, D, and V in the SVD decomposition,
A = U D V'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svdDemo(A, shape = c("cube", "sphere"), alpha = 0.7, col = rainbow(6))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svdDemo_+3A_a">A</code></td>
<td>
<p>A 3 x 3 numeric matrix</p>
</td></tr>
<tr><td><code id="svdDemo_+3A_shape">shape</code></td>
<td>
<p>Basic shape used to represent the identity matrix: <code>"cube"</code> or <code>"sphere"</code></p>
</td></tr>
<tr><td><code id="svdDemo_+3A_alpha">alpha</code></td>
<td>
<p>transparency value used to draw the shape</p>
</td></tr>
<tr><td><code id="svdDemo_+3A_col">col</code></td>
<td>
<p>Vector of 6 colors for the faces of the basic cube</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Original idea from Duncan Murdoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(1,2,0.1, 0.1,1,0.1, 0.1,0.1,0.5), 3,3)
svdDemo(A)

## Not run: 
B &lt;- matrix(c( 1, 0, 1, 0, 2, 0,  1, 0, 2), 3, 3)
svdDemo(B)

# a positive, semi-definite matrix with eigenvalues 12, 6, 0
C &lt;- matrix(c(7, 4, 1,  4, 4, 4,  1, 4, 7), 3, 3)
svdDemo(C)

## End(Not run)

</code></pre>

<hr>
<h2 id='swp'>The Matrix Sweep Operator</h2><span id='topic+swp'></span>

<h3>Description</h3>

<p>The <code>swp</code> function &ldquo;sweeps&rdquo; a matrix on the rows and columns given in <code>index</code> to produce a new matrix
with those rows and columns &ldquo;partialled out&rdquo; by orthogonalization. This was defined as a fundamental statistical operation in
multivariate methods by Beaton (1964) and expanded by Dempster (1969). It is closely related to orthogonal projection,
but applied to a cross-products or covariance matrix, rather than to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swp(M, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swp_+3A_m">M</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
<tr><td><code id="swp_+3A_index">index</code></td>
<td>
<p>a numeric vector indicating the rows/columns to be swept.  The entries must be less than or equal
to the number or rows or columns in <code>M</code>.  If missing, the function sweeps on all rows/columns <code>1:min(dim(M))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>M</code> is the partitioned matrix
</p>
<p style="text-align: center;"><code class="reqn">\left[ \begin{array}{cc} \mathbf {R} &amp;  \mathbf {S} \\ \mathbf {T} &amp;  \mathbf {U} \end{array} \right]</code>
</p>

<p>where <code class="reqn">R</code> is <code class="reqn">q \times q</code> then <code>swp(M, 1:q)</code> gives
</p>
<p style="text-align: center;"><code class="reqn">\left[ \begin{array}{cc} \mathbf {R}^{-1} &amp;  \mathbf {R}^{-1}\mathbf {S} \\ -\mathbf {TR}^{-1} &amp;  \mathbf {U}-\mathbf {TR}^{-1}\mathbf {S} \\ \end{array} \right]</code>
</p>



<h3>Value</h3>

<p>the matrix <code>M</code> with rows and columns in <code>indices</code> swept.
</p>


<h3>References</h3>

<p>Beaton, A. E. (1964), <em>The Use of Special Matrix Operations in Statistical Calculus</em>, Princeton, NJ: Educational Testing Service.
</p>
<p>Dempster, A. P. (1969) <em>Elements of Continuous Multivariate Analysis</em>. Addison-Wesley, Reading, Mass.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Proj">Proj</a></code>, <code><a href="#topic+QR">QR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(therapy)
mod3 &lt;- lm(therapy ~ perstest + IE + sex, data=therapy)
X &lt;- model.matrix(mod3)
XY &lt;- cbind(X, therapy=therapy$therapy)
XY
M &lt;- crossprod(XY)
swp(M, 1)
swp(M, 1:2)
</code></pre>

<hr>
<h2 id='symMat'>Create a Symmetric Matrix from a Vector</h2><span id='topic+symMat'></span>

<h3>Description</h3>

<p>Creates a square symmetric matrix from a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symMat(x, diag = TRUE, byrow = FALSE, names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symMat_+3A_x">x</code></td>
<td>
<p>A numeric vector used to fill the upper or lower triangle of the matrix.</p>
</td></tr>
<tr><td><code id="symMat_+3A_diag">diag</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default), the diagonals of the created matrix are replaced
by elements of x; otherwise, the diagonals of the created matrix are replaced by &quot;1&quot;.</p>
</td></tr>
<tr><td><code id="symMat_+3A_byrow">byrow</code></td>
<td>
<p>Logical. If <code>FALSE</code> (the default), the created matrix is filled by columns;
otherwise, the matrix is filled by rows.</p>
</td></tr>
<tr><td><code id="symMat_+3A_names">names</code></td>
<td>
<p>Either a logical or a character vector of names for the rows and columns of the matrix.
If <code>FALSE</code>, no names are assigned; if <code>TRUE</code>, rows and columns are named
<code>X1</code>, <code>X2</code>, ... .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric square matrix based on column major ordering of the elements in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Originally from <code>metaSEM::vec2symMat</code>, Mike W.-L. Cheung &lt;mikewlcheung@nus.edu.sg&gt;; modified by Michael Friendly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>symMat(1:6)
symMat(1:6, byrow=TRUE)
symMat(5:0, diag=FALSE)
</code></pre>

<hr>
<h2 id='therapy'>
Therapy Data
</h2><span id='topic+therapy'></span>

<h3>Description</h3>

<p>A toy data set on outcome in <code>therapy</code> in relation to a personality test (<code>perstest</code>)
and a scale of internal-external locus of control (<code>IE</code>)
used to illustrate linear and multiple regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("therapy")</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 4 variables.
</p>

<dl>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>F</code> <code>M</code></p>
</dd>
<dt><code>perstest</code></dt><dd><p>score on a personality test, a numeric vector</p>
</dd>
<dt><code>therapy</code></dt><dd><p>outcome in psychotherapy, a numeric vector</p>
</dd>
<dt><code>IE</code></dt><dd><p>score on a scale of internal-external locus of control, a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(therapy)
plot(therapy ~ perstest, data=therapy, pch=16)
abline(lm(therapy ~ perstest, data=therapy), col="red")

plot(therapy ~ perstest, data=therapy, cex=1.5, pch=16, 
	col=ifelse(sex=="M", "red","blue"))
</code></pre>

<hr>
<h2 id='tr'>Trace of a Matrix</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Calculates the trace of a square numeric matrix, i.e., the sum of its diagonal elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_x">X</code></td>
<td>
<p>a numeric matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value, the sum of <code>diag(X)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1:9, 3, 3)
tr(X)

</code></pre>

<hr>
<h2 id='vandermode'>Vandermode Matrix</h2><span id='topic+vandermode'></span>

<h3>Description</h3>

<p>The function returns the Vandermode matrix of a numeric vector, <code>x</code>, whose columns are the vector
raised to the powers <code>0:n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vandermode(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vandermode_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="vandermode_+3A_n">n</code></td>
<td>
<p>a numeric scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size <code>length(x)</code> x <code>n</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vandermode(1:5, 4)
</code></pre>

<hr>
<h2 id='vec'>Vectorize a Matrix</h2><span id='topic+vec'></span>

<h3>Description</h3>

<p>Returns a 1-column matrix, stacking the columns of <code>x</code>, a matrix or vector.
Also supports comma-separated inputs similar to the concatenation
function <code><a href="base.html#topic+c">c</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_+3A_x">x</code></td>
<td>
<p>A matrix or vector</p>
</td></tr>
<tr><td><code id="vec_+3A_...">...</code></td>
<td>
<p>(optional) additional objects to be stacked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A one-column matrix containing the elements of <code>x</code> and <code>...</code>
in column order
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec(1:3)
vec(matrix(1:6, 2, 3))
vec(c("hello", "world"))
vec("hello", "world")
vec(1:3, "hello", "world")
</code></pre>

<hr>
<h2 id='vectors'>Draw geometric vectors in 2D</h2><span id='topic+vectors'></span>

<h3>Description</h3>

<p>This function draws vectors in a 2D plot, in a way that facilitates constructing vector diagrams. It allows vectors to be
specified as rows of a matrix, and can draw labels on the vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectors(
  X,
  origin = c(0, 0),
  lwd = 2,
  angle = 13,
  length = 0.15,
  labels = TRUE,
  cex.lab = 1.5,
  pos.lab = 4,
  frac.lab = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectors_+3A_x">X</code></td>
<td>
<p>a vector or two-column matrix representing a set of geometric vectors; if a matrix, one vector is drawn for each row</p>
</td></tr>
<tr><td><code id="vectors_+3A_origin">origin</code></td>
<td>
<p>the origin from which they are drawn, a vector of length 2.</p>
</td></tr>
<tr><td><code id="vectors_+3A_lwd">lwd</code></td>
<td>
<p>line width(s) for the vectors, a constant or vector of length equal to the number of rows of <code>X</code>.</p>
</td></tr>
<tr><td><code id="vectors_+3A_angle">angle</code></td>
<td>
<p>the <code>angle</code> argument passed to <code><a href="graphics.html#topic+arrows">arrows</a></code> determining the angle of arrow heads.</p>
</td></tr>
<tr><td><code id="vectors_+3A_length">length</code></td>
<td>
<p>the <code>length</code> argument passed to <code><a href="graphics.html#topic+arrows">arrows</a></code> determining the length of arrow heads.</p>
</td></tr>
<tr><td><code id="vectors_+3A_labels">labels</code></td>
<td>
<p>a logical or a character vector of labels for the vectors. If <code>TRUE</code> and <code>X</code> is a matrix,
labels are taken from <code>rownames(X)</code>. If <code>NULL</code>, no labels are drawn.</p>
</td></tr>
<tr><td><code id="vectors_+3A_cex.lab">cex.lab</code></td>
<td>
<p>character expansion applied to vector labels. May be a number or numeric vector corresponding to the the
rows of <code>X</code>, recycled as necessary.</p>
</td></tr>
<tr><td><code id="vectors_+3A_pos.lab">pos.lab</code></td>
<td>
<p>label position relative to the label point as in <code><a href="graphics.html#topic+text">text</a></code>, recycled as necessary.</p>
</td></tr>
<tr><td><code id="vectors_+3A_frac.lab">frac.lab</code></td>
<td>
<p>location of label point, as a fraction of the distance between <code>origin</code> and <code>X</code>, recycled as necessary.
Values <code>frac.lab &gt; 1</code> locate the label beyond the end of the vector.</p>
</td></tr>
<tr><td><code id="vectors_+3A_...">...</code></td>
<td>
<p>other arguments passed on to graphics functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+arrows">arrows</a></code>, <code><a href="graphics.html#topic+text">text</a></code>
</p>
<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors3d">vectors3d</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># shows addition of vectors
u &lt;- c(3,1)
v &lt;- c(1,3)
sum &lt;- u+v

xlim &lt;- c(0,5)
ylim &lt;- c(0,5)
# proper geometry requires asp=1
plot( xlim, ylim, type="n", xlab="X", ylab="Y", asp=1)
abline(v=0, h=0, col="gray")

vectors(rbind(u,v,`u+v`=sum), col=c("red", "blue", "purple"), cex.lab=c(2, 2, 2.2))
# show the opposing sides of the parallelogram
vectors(sum, origin=u, col="red", lty=2)
vectors(sum, origin=v, col="blue", lty=2)

# projection of vectors
vectors(Proj(v,u), labels="P(v,u)", lwd=3)
vectors(v, origin=Proj(v,u))
corner(c(0,0), Proj(v,u), v, col="grey")
</code></pre>

<hr>
<h2 id='vectors3d'>Draw 3D vectors</h2><span id='topic+vectors3d'></span>

<h3>Description</h3>

<p>This function draws vectors in a 3D plot, in a way that facilitates constructing vector diagrams. It allows vectors to be
specified as rows of a matrix, and can draw labels on the vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vectors3d(
  X,
  origin = c(0, 0, 0),
  headlength = 0.035,
  ref.length = NULL,
  radius = 1/60,
  labels = TRUE,
  cex.lab = 1.2,
  adj.lab = 0.5,
  frac.lab = 1.1,
  draw = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vectors3d_+3A_x">X</code></td>
<td>
<p>a vector or three-column matrix representing a set of geometric vectors; if a matrix, one vector is drawn for each row</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_origin">origin</code></td>
<td>
<p>the origin from which they are drawn, a vector of length 3.</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_headlength">headlength</code></td>
<td>
<p>the <code>headlength</code> argument passed to <code><a href="#topic+arrows3d">arrows3d</a></code> determining the length of arrow heads</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_ref.length">ref.length</code></td>
<td>
<p>vector length to be used in scaling arrow heads so that they are all the same size; if <code>NULL</code>
the longest vector is used to scale the arrow heads</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_radius">radius</code></td>
<td>
<p>radius of the base of the arrow heads</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_labels">labels</code></td>
<td>
<p>a logical or a character vector of labels for the vectors. If <code>TRUE</code> and <code>X</code> is a matrix,
labels are taken from <code>rownames(X)</code>. If <code>FALSE</code> or <code>NULL</code>, no labels are drawn.</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_cex.lab">cex.lab</code></td>
<td>
<p>character expansion applied to vector labels. May be a number or numeric vector corresponding to the the
rows of <code>X</code>, recycled as necessary.</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_adj.lab">adj.lab</code></td>
<td>
<p>label position relative to the label point as in <code><a href="rgl.html#topic+text3d">text3d</a></code>, recycled as necessary.</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_frac.lab">frac.lab</code></td>
<td>
<p>location of label point, as a fraction of the distance between <code>origin</code> and <code>X</code>, recycled as necessary.
Values <code>frac.lab &gt; 1</code> locate the label beyond the end of the vector.</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_draw">draw</code></td>
<td>
<p>if <code>TRUE</code> (the default), draw the vector(s).</p>
</td></tr>
<tr><td><code id="vectors3d_+3A_...">...</code></td>
<td>
<p>other arguments passed on to graphics functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly returns the vector <code>ref.length</code> used to scale arrow heads
</p>


<h3>Bugs</h3>

<p>At present, the color (<code>color=</code>) argument is not handled as expected when more than one vector is to be drawn.
</p>


<h3>Author(s)</h3>

<p>Michael Friendly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arrows3d">arrows3d</a></code>, code<a href="rgl.html#topic+texts3d">texts3d</a>, code<a href="rgl.html#topic+rgl.material">rgl.material</a>
</p>
<p>Other vector diagrams: 
<code><a href="#topic+Proj">Proj</a>()</code>,
<code><a href="#topic+arc">arc</a>()</code>,
<code><a href="#topic+arrows3d">arrows3d</a>()</code>,
<code><a href="#topic+circle3d">circle3d</a>()</code>,
<code><a href="#topic+corner">corner</a>()</code>,
<code><a href="#topic+plot.regvec3d">plot.regvec3d</a>()</code>,
<code><a href="#topic+pointOnLine">pointOnLine</a>()</code>,
<code><a href="#topic+regvec3d">regvec3d</a>()</code>,
<code><a href="#topic+vectors">vectors</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- rbind(diag(3), c(1,1,1))
rownames(vec) &lt;- c("X", "Y", "Z", "J")
library(rgl)
open3d()
vectors3d(vec, color=c(rep("black",3), "red"), lwd=2)
# draw the XZ plane, whose equation is Y=0
planes3d(0, 0, 1, 0, col="gray", alpha=0.2)
vectors3d(c(1,1,0), col="green", lwd=2)
# show projections of the unit vector J
segments3d(rbind(c(1,1,1), c(1, 1, 0)))
segments3d(rbind(c(0,0,0), c(1, 1, 0)))
segments3d(rbind(c(1,0,0), c(1, 1, 0)))
segments3d(rbind(c(0,1,0), c(1, 1, 0)))
# show some orthogonal vectors
p1 &lt;- c(0,0,0)
p2 &lt;- c(1,1,0)
p3 &lt;- c(1,1,1)
p4 &lt;- c(1,0,0)
corner(p1, p2, p3, col="red")
corner(p1, p4, p2, col="red")
corner(p1, p4, p3, col="blue")

rgl.bringtotop()
</code></pre>

<hr>
<h2 id='workers'>
Workers Data
</h2><span id='topic+workers'></span>

<h3>Description</h3>

<p>A toy data set comprised of information on workers <code>Income</code> in relation
to other variables, used for illustrating linear and multiple regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("workers")</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 4 variables.
</p>

<dl>
<dt><code>Income</code></dt><dd><p>income from the job, a numeric vector</p>
</dd>
<dt><code>Experience</code></dt><dd><p>number of years of experience, a numeric vector</p>
</dd>
<dt><code>Skill</code></dt><dd><p>skill level in the job, a numeric vector</p>
</dd>
<dt><code>Gender</code></dt><dd><p>a factor with levels <code>Female</code> <code>Male</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(workers)
plot(Income ~ Experience, data=workers, main="Income ~ Experience", pch=20, cex=2)

# simple linear regression
reg1 &lt;- lm(Income ~ Experience, data=workers)
abline(reg1, col="red", lwd=3)

# quadratic fit?
plot(Income ~ Experience, data=workers, main="Income ~ poly(Experience,2)", pch=20, cex=2)
reg2 &lt;- lm(Income ~ poly(Experience,2), data=workers)
fit2 &lt;-predict(reg2)
abline(reg1, col="red", lwd=1, lty=1)
lines(workers$Experience, fit2, col="blue", lwd=3)

# How does Income depend on a factor?
plot(Income ~ Gender, data=workers, main="Income ~ Gender")
points(workers$Gender, jitter(workers$Income), cex=2, pch=20)
means&lt;-aggregate(workers$Income,list(workers$Gender),mean)
points(means,col="red", pch="+", cex=2)
lines(means,col="red", lwd=2)

</code></pre>

<hr>
<h2 id='xprod'>Generalized Vector Cross Product</h2><span id='topic+xprod'></span>

<h3>Description</h3>

<p>Given two linearly independent length 3 vectors **a** and **b**, the cross product, <code class="reqn">\mathbf{a} \times \mathbf{b}</code>
(read &quot;a cross b&quot;), is a vector that is perpendicular to both **a** and **b**
thus normal to the plane containing them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xprod(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xprod_+3A_...">...</code></td>
<td>
<p>N-1 linearly independent vectors of the same length, N.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A generalization of this idea applies to two or more dimensional vectors.
</p>
<p>See: [https://en.wikipedia.org/wiki/Cross_product] for geometric and algebraic properties.
<img src="../help/figures/CrossProduct.png" alt="Cross-product of 3D vectors" />

</p>


<h3>Value</h3>

<p>Returns the generalized vector cross-product, a vector of length N.
</p>


<h3>Author(s)</h3>

<p>Matthew Lundberg, in a [Stack Overflow post][https://stackoverflow.com/questions/36798301/r-compute-cross-product-of-vectors-physics]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xprod(1:3, 4:6)

# This works for an dimension
xprod(c(0,1))             # 2d
xprod(c(1,0,0), c(0,1,0)) # 3d
xprod(c(1,1,1), c(0,1,0)) # 3d
xprod(c(1,0,0,0), c(0,1,0,0), c(0,0,1,0)) # 4d

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
