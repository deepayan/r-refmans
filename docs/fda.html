<!DOCTYPE html><html lang="en"><head><title>Help for package fda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AmpPhaseDecomp'>
<p>Decomposition for Amplitude and Phase Variation</p></a></li>
<li><a href='#arithmetic.basisfd'>
<p>Arithmatic on functional basis objects</p></a></li>
<li><a href='#arithmetic.fd'>
<p>Arithmetic on functional data ('fd') objects</p></a></li>
<li><a href='#as.array3'>
<p>Reshape a vector or array to have 3 dimensions.</p></a></li>
<li><a href='#as.fd'>
<p>Convert a spline object to class 'fd'</p></a></li>
<li><a href='#as.POSIXct1970'>
<p><code>as.POXIXct</code> for number of seconds since the start of 1970.</p></a></li>
<li><a href='#axisIntervals'>
<p>Mark Intervals on a Plot Axis</p></a></li>
<li><a href='#basisfd'>
<p>Define a Functional Basis Object</p></a></li>
<li><a href='#basisfd.product'>
<p>Product of two basisfd objects</p></a></li>
<li><a href='#bifd'>
<p>Create a bivariate functional data object</p></a></li>
<li><a href='#bifdPar'>
<p>Define a Bivariate Functional Parameter Object</p></a></li>
<li><a href='#bsplinepen'>
<p>B-Spline Penalty Matrix</p></a></li>
<li><a href='#bsplineS'>
<p>B-spline Basis Function Values</p></a></li>
<li><a href='#CanadianWeather'>
<p>Canadian average annual weather cycle</p></a></li>
<li><a href='#cca.fd'>
<p>Functional Canonical Correlation Analysis</p></a></li>
<li><a href='#center.fd'>
<p>Center Functional Data</p></a></li>
<li><a href='#checkDims3'>
<p>Compare dimensions and dimnames of arrays</p></a></li>
<li><a href='#checkLogicalInteger'>
<p>Does an argument satisfy required conditions?</p></a></li>
<li><a href='#coef.fd'>
<p>Extract functional coefficients</p></a></li>
<li><a href='#cor.fd'>
<p>Correlation matrix from functional data object(s)</p></a></li>
<li><a href='#covPACE'>
<p>Estimate of the covariance surface</p></a></li>
<li><a href='#CRAN'>
<p>Test if running as CRAN</p></a></li>
<li><a href='#create.basis'><p>Create Basis Set for Functional Data Analysis</p></a></li>
<li><a href='#create.bspline.basis'>
<p>Create a B-spline Basis</p></a></li>
<li><a href='#create.constant.basis'>
<p>Create a Constant Basis</p></a></li>
<li><a href='#create.exponential.basis'>
<p>Create an Exponential Basis</p></a></li>
<li><a href='#create.fourier.basis'>
<p>Create a Fourier Basis</p></a></li>
<li><a href='#create.monomial.basis'>
<p>Create a Monomial Basis</p></a></li>
<li><a href='#create.polygonal.basis'>
<p>Create a Polygonal Basis</p></a></li>
<li><a href='#create.power.basis'>
<p>Create a Power Basis Object</p></a></li>
<li><a href='#CSTR'>
<p>Continuously Stirred Tank Reactor</p></a></li>
<li><a href='#cumfd'>
<p>Compute a Cumulative Distribution Functional Data Object</p></a></li>
<li><a href='#cycleplot.fd'>
<p>Plot Cycles for a Periodic Bivariate Functional Data Object</p></a></li>
<li><a href='#Data2fd'>
<p>Create smooth functions that fit scatterplot data.</p></a></li>
<li><a href='#dateAccessories'>
<p>Numeric and character vectors to facilitate working with dates</p></a></li>
<li><a href='#density.fd'>
<p>Compute a Probability Density Function</p></a></li>
<li><a href='#deriv.fd'>
<p>Compute a Derivative of a Functional Data Object</p></a></li>
<li><a href='#df.residual.fRegress'>
<p>Degrees of Freedom for Residuals from a Functional Regression</p></a></li>
<li><a href='#df2lambda'>
<p>Convert Degrees of Freedom to a Smoothing Parameter Value</p></a></li>
<li><a href='#dirs'>
<p>Get subdirectories</p></a></li>
<li><a href='#Eigen'>
<p>Eigenanalysis preserving dimnames</p></a></li>
<li><a href='#eigen.pda'>
<p>Stability Analysis for Principle Differential Analysis</p></a></li>
<li><a href='#ElectricDemand'>
<p>Predicting electricity demand in Adelaide from temperature</p></a></li>
<li><a href='#eval.basis'>
<p>Values of Basis Functions or their Derivatives</p></a></li>
<li><a href='#eval.bifd'>
<p>Values a Two-argument Functional Data Object</p></a></li>
<li><a href='#eval.fd'>
<p>Values of a Functional Data Object</p></a></li>
<li><a href='#eval.monfd'>
<p>Values of a Monotone Functional Data Object</p></a></li>
<li><a href='#eval.penalty'>
<p>Evaluate a Basis Penalty Matrix</p></a></li>
<li><a href='#eval.posfd'>
<p>Evaluate a Positive Functional Data Object</p></a></li>
<li><a href='#eval.surp'><p>Values of a Functional Data Object Defining Surprisal Curves.</p></a></li>
<li><a href='#evaldiag.bifd'>
<p>Evaluate the Diagonal of a Bivariate Functional Data Object</p></a></li>
<li><a href='#expon'>
<p>Exponential Basis Function Values</p></a></li>
<li><a href='#exponentiate.fd'>
<p>Powers of a functional data ('fd') object</p></a></li>
<li><a href='#exponpen'>
<p>Exponential Penalty Matrix</p></a></li>
<li><a href='#fbplot'>
<p>Functional Boxplots</p></a></li>
<li><a href='#fd'>
<p>Define a Functional Data Object</p></a></li>
<li><a href='#fd2list'>
<p>Convert a univariate functional data object to a list</p></a></li>
<li><a href='#fda'><p>Functions for statistical analyses of functions</p></a></li>
<li><a href='#fdlabels'>
<p>Extract plot labels and names for replicates and variables</p></a></li>
<li><a href='#fdPar'>
<p>Define a Functional Parameter Object</p></a></li>
<li><a href='#fdParcheck'>
<p>Convert <code>fd</code> or <code>basisfd</code> Objects to <code>fdPar</code> Objects</p></a></li>
<li><a href='#fourier'>
<p>Fourier Basis Function Values</p></a></li>
<li><a href='#fourierpen'>
<p>Fourier Penalty Matrix</p></a></li>
<li><a href='#Fperm.fd'>
<p>Permutation F-test for functional linear regression.</p></a></li>
<li><a href='#fRegress'>
<p>Functional Regression Analysis</p></a></li>
<li><a href='#fRegress.CV'>
<p>Computes Cross-validated Error Sum of Integrated Squared Errors for a</p>
Functional Regression Model</a></li>
<li><a href='#fRegress.stderr'>
<p>Compute Standard errors of Coefficient Functions Estimated by</p>
Functional Regression Analysis</a></li>
<li><a href='#Fstat.fd'>
<p>F-statistic for functional linear regression.</p></a></li>
<li><a href='#gait'>
<p>Hip and knee angle while walking</p></a></li>
<li><a href='#geigen'>
<p>Generalized eigenanalysis</p></a></li>
<li><a href='#getbasismatrix'>
<p>Values of Basis Functions or their Derivatives</p></a></li>
<li><a href='#getbasispenalty'>
<p>Evaluate a Roughness Penalty Matrix</p></a></li>
<li><a href='#getbasisrange'>
<p>Extract the range from a basis object</p></a></li>
<li><a href='#growth'>
<p>Berkeley Growth Study data</p></a></li>
<li><a href='#handwrit'>
<p>Cursive handwriting samples</p></a></li>
<li><a href='#infantGrowth'>
<p>Tibia Length for One Baby</p></a></li>
<li><a href='#inprod'>
<p>Inner products of Functional Data Objects.</p></a></li>
<li><a href='#inprod.bspline'>
<p>Compute Inner Products B-spline Expansions.</p></a></li>
<li><a href='#int2Lfd'>
<p>Convert Integer to Linear Differential Operator</p></a></li>
<li><a href='#intensity.fd'>
<p>Intensity Function for Point Process</p></a></li>
<li><a href='#is.basis'>
<p>Confirm Object is Class &quot;Basisfd&quot;</p></a></li>
<li><a href='#is.eqbasis'>
<p>Confirm that two objects of  class &quot;Basisfd&quot; are identical</p></a></li>
<li><a href='#is.fd'>
<p>Confirm Object has Class &quot;fd&quot;</p></a></li>
<li><a href='#is.fdPar'>
<p>Confirm Object has Class &quot;fdPar&quot;</p></a></li>
<li><a href='#is.fdSmooth'>
<p>Confirm Object has Class &quot;fdSmooth&quot;</p></a></li>
<li><a href='#is.Lfd'>
<p>Confirm Object has Class &quot;Lfd&quot;</p></a></li>
<li><a href='#knots.fd'><p>Extract the knots from a function basis or data object</p></a></li>
<li><a href='#lambda2df'>
<p>Convert Smoothing Parameter to Degrees of Freedom</p></a></li>
<li><a href='#lambda2gcv'>
<p>Compute GCV Criterion</p></a></li>
<li><a href='#landmarkreg'>
<p>Landmark Registration of Functional Observations with Differing Ranges</p></a></li>
<li><a href='#Lfd'>
<p>Define a Linear Differential Operator Object</p></a></li>
<li><a href='#lines.fd'>
<p>Add Lines from Functional Data to a Plot</p></a></li>
<li><a href='#linmod'>
<p>Fit Fully Functional Linear Model</p></a></li>
<li><a href='#lip'>
<p>Lip motion</p></a></li>
<li><a href='#lnsrch'>
<p>Search along a line for a minimum within an optimisation algorithm.</p></a></li>
<li><a href='#matplot'>
<p>Plot Columns of Matrices</p></a></li>
<li><a href='#mean.fd'>
<p>Mean of Functional Data</p></a></li>
<li><a href='#melanoma'>
<p>melanoma 1936-1972</p></a></li>
<li><a href='#monfn'><p>Evaluate the a monotone function</p></a></li>
<li><a href='#mongrad'>
<p>Evaluate the gradient of a monotone function</p></a></li>
<li><a href='#monhess'>
<p>Evaluate the Hessian matrix of a monotone function</p></a></li>
<li><a href='#monomial'>
<p>Evaluate Monomial Basis</p></a></li>
<li><a href='#monomialpen'>
<p>Evaluate Monomial Roughness Penalty Matrix</p></a></li>
<li><a href='#MontrealTemp'>
<p>Montreal Daily Temperature</p></a></li>
<li><a href='#nondurables'>
<p>Nondurable goods index</p></a></li>
<li><a href='#norder'>
<p>Order of a B-spline</p></a></li>
<li><a href='#objAndNames'>
<p>Add names to an object</p></a></li>
<li><a href='#odesolv'>
<p>Numerical Solution mth Order Differential Equation System</p></a></li>
<li><a href='#pca.fd'>
<p>Functional Principal Components Analysis</p></a></li>
<li><a href='#pcaPACE'>
<p>Estimate the functional principal components</p></a></li>
<li><a href='#pda.fd'>
<p>Principal Differential Analysis</p></a></li>
<li><a href='#pda.overlay'>
<p>Stability Analysis for Principle Differential Analysis</p></a></li>
<li><a href='#phaseplanePlot'>
<p>Phase-plane plot</p></a></li>
<li><a href='#pinch'>
<p>pinch force data</p></a></li>
<li><a href='#plot.basisfd'>
<p>Plot a Basis Object</p></a></li>
<li><a href='#plot.cca.fd'>
<p>Plot Functional Canonical Correlation Weight Functions</p></a></li>
<li><a href='#plot.fd'>
<p>Plot a Functional Data Object</p></a></li>
<li><a href='#plot.Lfd'>
<p>Plot a Linear Differential Operator Object</p></a></li>
<li><a href='#plot.pca.fd'>
<p>Plot Functional Principal Components</p></a></li>
<li><a href='#plot.pda.fd'>
<p>Plot Principle Differential Analysis Components</p></a></li>
<li><a href='#plotbeta'>
<p>Plot a functional parameter object with confidence limits</p></a></li>
<li><a href='#plotfit'>
<p>Plot a Functional Data Object With Data</p></a></li>
<li><a href='#plotscores'>
<p>Plot Principal Component Scores</p></a></li>
<li><a href='#polintmat'>
<p>Polynomial extrapolation for a converging sequence of one or more values</p></a></li>
<li><a href='#polyg'>
<p>Polygonal Basis Function Values</p></a></li>
<li><a href='#polygpen'>
<p>Polygonal Penalty Matrix</p></a></li>
<li><a href='#powerbasis'>
<p>Power Basis Function Values</p></a></li>
<li><a href='#powerpen'>
<p>Power Penalty Matrix</p></a></li>
<li><a href='#ppBspline'><p>Convert a B-spline function to piece-wise polynomial form</p></a></li>
<li><a href='#predict.fRegress'>
<p>Predict method for Functional Regression</p></a></li>
<li><a href='#project.basis'>
<p>Approximate Functional Data Using a Basis</p></a></li>
<li><a href='#quadset'>
<p>Quadrature points and weights for Simpson's rule</p></a></li>
<li><a href='#reconsCurves'>
<p>Reconstruct data curves using functional principal components</p></a></li>
<li><a href='#refinery'>
<p>Reflux and tray level in a refinery</p></a></li>
<li><a href='#ReginaPrecip'>
<p>Regina Daily Precipitation</p></a></li>
<li><a href='#register.fd'>
<p>Register Functional Data Objects Using a Continuous Criterion</p></a></li>
<li><a href='#register.newfd'>
<p>Register Functional Data Objects with Pre-Computed Warping Functions</p></a></li>
<li><a href='#scoresPACE'><p>Estimates of functional Principal Component scores through PACE</p></a></li>
<li><a href='#sd.fd'>
<p>Standard Deviation of Functional Data</p></a></li>
<li><a href='#seabird'><p>Sea Bird Counts</p></a></li>
<li><a href='#smooth.basis'>
<p>Construct a functional data object by smoothing data using a roughness</p>
penalty</a></li>
<li><a href='#smooth.basis.sparse'>
<p>Construct a functional data object by smoothing data using a roughness</p>
penalty</a></li>
<li><a href='#smooth.basisPar'>
<p>Smooth Data Using a Directly Specified Roughness Penalty</p></a></li>
<li><a href='#smooth.bibasis'>
<p>Smooth a discrete surface over a rectangular lattice</p></a></li>
<li><a href='#smooth.fd'>
<p>Smooth a Functional Data Object Using an Indirectly Specified</p>
Roughness Penalty</a></li>
<li><a href='#smooth.fdPar'>
<p>Smooth a functional data object using a directly specified roughness</p>
penalty</a></li>
<li><a href='#smooth.monotone'>
<p>Monotone Smoothing of Data</p></a></li>
<li><a href='#smooth.morph'>
<p>Estimates a Smooth Warping Function Mapping an Interval into Another</p></a></li>
<li><a href='#smooth.pos'>
<p>Smooth Data with a Positive Function</p></a></li>
<li><a href='#smooth.sparse.mean'>
<p>Smooth the mean function of sparse data</p></a></li>
<li><a href='#smooth.surp'>
<p>Fit data with surprisal smoothing.</p></a></li>
<li><a href='#sparse.list'><p>Creates a list of sparse data from a matrix</p></a></li>
<li><a href='#sparse.mat'><p>Creates a matrix of sparse data with NAs out of a list</p></a></li>
<li><a href='#stepchk'>
<p>Check a step size value for being within parameter limits.</p></a></li>
<li><a href='#stepit'>
<p>Compute a new step size for a linear search within an optimization algorithm.</p></a></li>
<li><a href='#sum.fd'>
<p>Sum of Functional Data</p></a></li>
<li><a href='#summary.basisfd'>
<p>Summarize a Functional Data Object</p></a></li>
<li><a href='#summary.bifd'>
<p>Summarize a Bivariate Functional Data Object</p></a></li>
<li><a href='#summary.fd'>
<p>Summarize a Functional Data Object</p></a></li>
<li><a href='#summary.fdPar'>
<p>Summarize a Functional Parameter Object</p></a></li>
<li><a href='#summary.Lfd'>
<p>Summarize a Linear Differential Operator Object</p></a></li>
<li><a href='#surp.fit'>
<p>Evaluate the fit of surprisal curves to binned psychometric data.</p></a></li>
<li><a href='#symsolve'>
<p>solve(A, B) where A is symmetric</p></a></li>
<li><a href='#tperm.fd'>
<p>Permutation t-test for two groups of functional data objects.</p></a></li>
<li><a href='#trapzmat'>
<p>Approximate the functional inner product of two functional data objects using the</p>
trapezpoidal rule over a fine mesh of value.</a></li>
<li><a href='#var.fd'>
<p>Variance, Covariance, and Correlation Surfaces for</p>
Functional Data Object(s)</a></li>
<li><a href='#varmx'>
<p>Rotate a Matrix of Component Loadings using the VARIMAX Criterion</p></a></li>
<li><a href='#varmx.cca.fd'>
<p>Rotation of Functional Canonical Components with VARIMAX</p></a></li>
<li><a href='#varmx.pca.fd'>
<p>Rotation of Functional Principal Components with VARIMAX</p>
Criterion</a></li>
<li><a href='#vec2Lfd'>
<p>Make a Linear Differential Operator Object from a Vector</p></a></li>
<li><a href='#wtcheck'>
<p>Check a vector of weights</p></a></li>
<li><a href='#ycheck'>
<p>Check Data Arrays for Smoothing Functions</p></a></li>
<li><a href='#zerobasis'>
<p>Orthonormal Matrix with Columns Summing to Zero</p></a></li>
<li><a href='#zerofind'>
<p>Does the range of the input contain 0?</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>6.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Data Analysis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Ramsay &lt;ramsay@psych.mcgill.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), splines, fds, deSolve</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>These functions were developed to support functional data
 analysis as described in Ramsay, J. O. and Silverman, B. W.
 (2005) Functional Data Analysis. New York: Springer and in 
 Ramsay, J. O., Hooker, Giles, and Graves, Spencer (2009). 
 Functional Data Analysis with R and Matlab (Springer). 
 The package includes data sets and script files working many examples 
 including all but one of the 76 figures in this latter book.  Matlab versions 
 are available by ftp from 
 <a href="https://www.psych.mcgill.ca/misc/fda/downloads/FDAfuns/">https://www.psych.mcgill.ca/misc/fda/downloads/FDAfuns/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.functionaldata.org">http://www.functionaldata.org</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-17 20:02:31 UTC; jimramsay</td>
</tr>
<tr>
<td>Author:</td>
<td>James Ramsay [aut, cre],
  Giles Hooker [ctb],
  Spencer Graves [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-17 21:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AmpPhaseDecomp'>
Decomposition for Amplitude and Phase Variation
</h2><span id='topic+AmpPhaseDecomp'></span>

<h3>Description</h3>

<p>Registration is the process of aligning peaks, valleys and other
features in a sample of curves.  Once the registration has taken
place, this function computes two mean squared error measures, one for
amplitude variation, and the other for phase variation.  It also
computes a squared multiple correlation index of the amount of
variation in the unregistered functions is due to  phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AmpPhaseDecomp(xfd, yfd, hfd, rng=xrng)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AmpPhaseDecomp_+3A_xfd">xfd</code></td>
<td>

<p>a functional data object containing the unregistered curves.
</p>
</td></tr>
<tr><td><code id="AmpPhaseDecomp_+3A_yfd">yfd</code></td>
<td>

<p>a functional data object containing the registered curves.
</p>
</td></tr>
<tr><td><code id="AmpPhaseDecomp_+3A_hfd">hfd</code></td>
<td>

<p>a functional data object containing the strictly monotone warping
functions $h(t)$.  This is typically returned by the functions
<code>landmarkreg</code> and <code>register.fd</code>.
</p>
</td></tr>
<tr><td><code id="AmpPhaseDecomp_+3A_rng">rng</code></td>
<td>

<p>a vector of length 2 specifying a range of values over which the
decomposition is to be computed.  Both values must be within the
range of the functional data objects in the argument.  By default
the whole range of the functional data objects is used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decomposition can yield negative values for <code>MS.phas</code> if the
registration does not improve the alignment of the curves, or if used
to compare two registration processes based on different principles,
such as  is the case for functions <code>landmarkreg</code> and
<code>register.fd</code>.
</p>


<h3>Value</h3>

<p>a named list with the following components:
</p>
<table role = "presentation">
<tr><td><code>MS.amp</code></td>
<td>

<p>the mean squared error for amplitude variation.
</p>
</td></tr>
<tr><td><code>MS.phas</code></td>
<td>

<p>the mean squared error for phase variation.
</p>
</td></tr>
<tr><td><code>RSQR</code></td>
<td>

<p>the squared correlation measure of the  proportion of the total
variation that is due to phase variation.
</p>
</td></tr>
<tr><td><code>C</code></td>
<td>

<p>a constant required for the decomposition.  Its value is one if the
derivatives the warping functions are independent of the squared
registered functions.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+register.fd">register.fd</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the analysis for the growth data in the examples.
</code></pre>

<hr>
<h2 id='arithmetic.basisfd'>
Arithmatic on functional basis objects
</h2><span id='topic+arithmetic.basisfd'></span><span id='topic++3D+3D.basisfd'></span>

<h3>Description</h3>

<p>Arithmatic on functional basis objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basisfd'
basis1 == basis2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arithmetic.basisfd_+3A_basis1">basis1</code>, <code id="arithmetic.basisfd_+3A_basis2">basis2</code></td>
<td>

<p>functional basis object
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basisobj1 == basisobj2 returns a logical scalar.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009), 
Functional data analysis with R and Matlab, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2006), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+basisfd.product">basisfd.product</a></code>
<code><a href="#topic+arithmetic.fd">arithmetic.fd</a></code>
</p>

<hr>
<h2 id='arithmetic.fd'>
Arithmetic on functional data ('fd') objects
</h2><span id='topic+arithmetic.fd'></span><span id='topic++2B.fd'></span><span id='topic+plus.fd'></span><span id='topic+-.fd'></span><span id='topic+minus.fd'></span><span id='topic++2A.fd'></span><span id='topic+times.fd'></span>

<h3>Description</h3>

<p>Arithmetic on functional data objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
e1 + e2
## S3 method for class 'fd'
e1 - e2
## S3 method for class 'fd'
e1 * e2
plus.fd(e1, e2, basisobj=NULL)
minus.fd(e1, e2, basisobj=NULL)
times.fd(e1, e2, basisobj=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arithmetic.fd_+3A_e1">e1</code>, <code id="arithmetic.fd_+3A_e2">e2</code></td>
<td>

<p>object of class 'fd' or a numeric vector.  Note that 'e1+e2' will
dispatch to plus.fd(e1, e2) only if e1 has class 'fd'.  Similarly,
'e1-e2' or 'e1*e2' will dispatch to minus.fd(e1, e2) or time.fd(e1,
e2), respectively, only if e1 is of class 'fd'.
</p>
</td></tr>
<tr><td><code id="arithmetic.fd_+3A_basisobj">basisobj</code></td>
<td>

<p>reference basis;  defaults to e1[['basis']] * e2[['basis']];
ignored for <code>plus.fd</code> and <code>minus.fd</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function data object corresponding to the pointwise sum, difference
or product of e1 and e2.
</p>
<p>If both arguments are functional data objects, the bases are the same,
and the coefficient matrices are the same dims, the indicated
operation is applied to the coefficient matrices of the two objects.
In other words, e1+e2 is obtained for this case by adding the
coefficient matrices from e1 and e2.
</p>
<p>If e1 or e2 is a numeric scalar,  that scalar is applied to the
coefficient matrix of the functional data object.
</p>
<p>If either e1 or e2 is a numeric vector, it must be the same length as
the number of replicated functional observations in the other
argument.
</p>
<p>When both arguments are functional data objects, they need not have
the same bases.  However, if they don't have the same number of
replicates, then one of them must have a single replicate.  In the
second case, the singleton function is replicated to match the number
of replicates of the other function. In either case, they must have
the same number of functions. When both arguments are functional data
objects, and the bases are not the same, the basis used for the sum is
constructed to be of higher dimension than the basis for either factor
according to rules described in function TIMES for two basis objects.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+basisfd.product">basisfd.product</a></code>,
<code><a href="#topic+exponentiate.fd">exponentiate.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## add a parabola to itself
##
bspl4 &lt;- create.bspline.basis(nbasis=4)
parab4.5 &lt;- fd(c(3, -1, -1, 3)/3, bspl4)

coef2 &lt;- matrix(c(6, -2, -2, 6)/3, 4)
dimnames(coef2) &lt;- list(NULL, 'reps 1')

all.equal(coef(parab4.5+parab4.5), coef2)


##
## Same example with interior knots at 1/3 and 1/2
##
bspl5.3 &lt;- create.bspline.basis(breaks=c(0, 1/3, 1))
plot(bspl5.3)
x. &lt;- seq(0, 1, .1)
para4.5.3 &lt;- smooth.basis(x., 4*(x.-0.5)^2, bspl5.3)$fd
plot(para4.5.3)

bspl5.2 &lt;- create.bspline.basis(breaks=c(0, 1/2, 1))
plot(bspl5.2)
para4.5.2 &lt;- smooth.basis(x., 4*(x.-0.5)^2, bspl5.2)$fd
plot(para4.5.2)

#str(para4.5.3+para4.5.2)

coef2. &lt;- matrix(0, 9, 1)
dimnames(coef2.) &lt;- list(NULL, 'rep1')

all.equal(coef(para4.5.3-para4.5.2), coef2.)


##
## product
##
quart &lt;- para4.5.3*para4.5.2


# norder(quart) = norder(para4.5.2)+norder(para4.5.3)-1 = 7

norder(quart) == (norder(para4.5.2)+norder(para4.5.3)-1)


# para4.5.2 with knot at 0.5 and para4.5.3 with knot at 1/3
# both have (2 end points + 1 interior knot) + norder-2
#     = 5 basis functions
# quart has (2 end points + 2 interior knots)+norder-2
#     = 9 basis functions
# coefficients look strange because the knots are at
# (1/3, 1/2) and not symmetrical


all.equal(as.numeric(coef(quart)),
0.1*c(90, 50, 14, -10, 6, -2, -2, 30, 90)/9)


plot(para4.5.3*para4.5.2) # quartic, not parabolic ...

##
## product with Fourier bases
##
f3 &lt;- fd(c(0,0,1), create.fourier.basis())
f3^2 # number of basis functions = 7?

##
## fd+numeric
##
coef1 &lt;- matrix(c(6, 2, 2, 6)/3, 4)
dimnames(coef1) &lt;- list(NULL, 'reps 1')

all.equal(coef(parab4.5+1), coef1)



all.equal(1+parab4.5, parab4.5+1)


##
## fd-numeric
##
coefneg &lt;- matrix(c(-3, 1, 1, -3)/3, 4)
dimnames(coefneg) &lt;- list(NULL, 'reps 1')

all.equal(coef(-parab4.5), coefneg)


plot(parab4.5-1)

plot(1-parab4.5)

par(oldpar)

</code></pre>

<hr>
<h2 id='as.array3'>
Reshape a vector or array to have 3 dimensions.  
</h2><span id='topic+as.array3'></span>

<h3>Description</h3>

<p>Coerce a vector or array to have 3 dimensions, preserving dimnames if
feasible.  Throw an error if length(dim(x)) &gt; 3.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.array3(x) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.array3_+3A_x">x</code></td>
<td>

<p>A vector or array.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  dimx &lt;- dim(x);  ndim &lt;- length(dimx) 
</p>
<p>2.  if(ndim==3)return(x).
</p>
<p>3.  if(ndim&gt;3)stop.
</p>
<p>4.  x2 &lt;- as.matrix(x)
</p>
<p>5.  dim(x2) &lt;- c(dim(x2), 1)
</p>
<p>6.  xnames &lt;- dimnames(x)
</p>
<p>7.  if(is.list(xnames))dimnames(x2) &lt;- list(xnames[[1]], xnames[[2]],
NULL) 
</p>


<h3>Value</h3>

<p>A 3-dimensional array with names matching <code>x</code> 
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dim">dim</a></code>,
<code><a href="base.html#topic+dimnames">dimnames</a></code>
<code><a href="#topic+checkDims3">checkDims3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ##
  ## vector -&gt; array 
  ##
  as.array3(c(a=1, b=2)) 

  ##
  ## matrix -&gt; array 
  ##
  
  as.array3(matrix(1:6, 2))
  as.array3(matrix(1:6, 2, dimnames=list(letters[1:2],
      LETTERS[3:5]))) 

  ##
  ## array -&gt; array 
  ##
  
  as.array3(array(1:6, 1:3)) 

  ##
  ## 4-d array 
  ##
  # These lines throw an error because the dimensionality woud be 4
  # and as.array3 only allows dimensions 3 or less.
  # if(!CRAN()) {
  #   as.array3(array(1:24, 1:4)) 
  # }
</code></pre>

<hr>
<h2 id='as.fd'>
Convert a spline object to class 'fd'
</h2><span id='topic+as.fd'></span><span id='topic+as.fd.fdSmooth'></span><span id='topic+as.fd.function'></span><span id='topic+as.fd.smooth.spline'></span>

<h3>Description</h3>

<p>Translate a spline object of another class into the 
Functional Data (class <code>fd</code>) format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.fd(x, ...)
## S3 method for class 'fdSmooth'
as.fd(x, ...)
## S3 method for class 'function'
as.fd(x, ...)
## S3 method for class 'smooth.spline'
as.fd(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.fd_+3A_x">x</code></td>
<td>

<p>an object to be converted to class <code>fd</code>.
</p>
</td></tr>
<tr><td><code id="as.fd_+3A_...">...</code></td>
<td>

<p>optional arguments passed to specific methods, currently
unused.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behavior depends on the <code>class</code> and nature of <code>x</code>.
</p>

<dl>
<dt>as.fd.fdSmooth</dt><dd><p>extract the <code>fd</code> component</p>
</dd>
<dt>as.fd.function</dt><dd>
<p>Create an <code>fd</code> object from a function of the form
created by <code>splinefun</code>.  This will translate method
= 'fmn' and 'natural' but not 'periodic':  'fmn' splines
are isomorphic to standard B-splines with coincident
boundary knots, which is the basis produced by 
<code>create.bspline.basis</code>.  'natural' splines occupy 
a subspace of this space, with the restriction that the
second derivative at the end points is zero (as noted in
the Wikipedia <code>spline</code> article).  'periodic' splines
do not use coincident boundary knots and are not 
currently supported in <code>fda</code>;  instead, <code>fda</code>
uses finite Fourier bases for periodic phenomena.
</p>
</dd>
<dt>as.fd.smooth.spline</dt><dd>
<p>Create an <code>fd</code> object from a <code>smooth.spline</code>
object.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009), 
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p><code>spline</code> entry in <em>Wikipedia</em>
<a href="https://en.wikipedia.org/wiki/Spline_(mathematics)">https://en.wikipedia.org/wiki/Spline_(mathematics)</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd">fd</a></code>
<code><a href="stats.html#topic+splinefun">splinefun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## as.fd.fdSmooth
##
girlGrowthSm &lt;- with(growth, 
  smooth.basisPar(argvals=age, y=hgtf, lambda=0.1))
girlGrowth.fd &lt;- as.fd(girlGrowthSm)

##
## as.fd.function(splinefun(...), ...)
##
x2 &lt;- 1:7
y2 &lt;- sin((x2-0.5)*pi)
fd_function &lt;- splinefun(x2, y2)
fd.  &lt;- as.fd(fd_function)
x.   &lt;- seq(1, 7, .02)
fdx. &lt;- fda::eval.fd(x., fd.)

# range(y2, fx., fdx.) generates an error 2012.04.22

rfdx &lt;- range(fdx.)

oldpar &lt;- par(no.readonly= TRUE)
plot(range(x2), range(y2, fdx., rfdx), type='n')
points(x2, y2)
lines(x., sin((x.-0.5)*pi), lty='dashed')
lines(x., fdx., col='blue')
lines(x., eval.fd(x., fd.), col='red', lwd=3, lty='dashed')
# splinefun and as.fd(splineful(...)) are close
# but quite different from the actual function
# apart from the actual 7 points fitted,
# which are fitted exactly
# ... and there is no information in the data
# to support a better fit!

# Translate also a natural spline
fn &lt;- splinefun(x2, y2, method='natural')
fn. &lt;- as.fd(fn)
lines(x., fn(x.), lty='dotted', col='blue')
lines(x., eval.fd(x., fn.), col='green', lty='dotted', lwd=3)

if(!CRAN()) {
# Will NOT translate a periodic spline
# fp &lt;- splinefun(x, y, method='periodic')
# as.fd(fp)
# Error in as.fd.function(fp) :
#  x (fp)  uses periodic B-splines, and as.fd is programmed
#   to translate only B-splines with coincident boundary knots.
}

##
## as.fd.smooth.spline ... this doesn't work (24 January 2024)
##
#cars.spl &lt;- with(cars, smooth.spline(speed, dist))
#cars.fd  &lt;- as.fd(cars.spl)

#plot(dist~speed, cars)
#lines(cars.spl)
#sp. &lt;- with(cars, seq(min(speed), max(speed), len=101))
#d. &lt;- eval.fd(sp., cars.fd)
#lines(sp., d., lty=2, col='red', lwd=3)
par(oldpar)
</code></pre>

<hr>
<h2 id='as.POSIXct1970'>
<code>as.POXIXct</code> for number of seconds since the start of 1970.
</h2><span id='topic+as.POSIXct1970'></span>

<h3>Description</h3>

<p><code>as.POSIXct.numeric</code> requires origin to be specified.  This assumes that
it is the start of 1970.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.POSIXct1970(x, tz="GMT", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.POSIXct1970_+3A_x">x</code></td>
<td>

<p>a numeric vector of times in seconds since the start of 1970.  (If
<code>x</code> is not numeric, call <code>as.POSIXct</code>.)
</p>
</td></tr>
<tr><td><code id="as.POSIXct1970_+3A_tz">tz</code></td>
<td>

<p>A timezone specification to be used for the conversion, if one is
required. System-specific (see time zones), but &quot;&quot; is the current
timezone, and &quot;GMT&quot; is UTC (Universal Time, Coordinated).
</p>
</td></tr>
<tr><td><code id="as.POSIXct1970_+3A_...">...</code></td>
<td>
<p>optional arguments to pass to as.POSIXct.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>o1970 &lt;- strptime('1970-01-01', '
o1970. &lt;- as.POSIXct(o1970),
as.POSIXct(x, origin=o1970.)
</p>


<h3>Value</h3>

<p>Returns a vector of class <code>POSIXct</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.POSIXct">as.POSIXct</a></code>,
<code><a href="base.html#topic+ISOdate">ISOdate</a></code>,
<code><a href="base.html#topic+strptime">strptime</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sec &lt;- c(0, 1, 60, 3600, 24*3600, 31*24*3600, 365*24*3600)
Sec &lt;- as.POSIXct1970(sec)

all.equal(sec, as.numeric(Sec))

</code></pre>

<hr>
<h2 id='axisIntervals'>
Mark Intervals on a Plot Axis
</h2><span id='topic+axisIntervals'></span><span id='topic+axesIntervals'></span>

<h3>Description</h3>

<p>Adds an axis (axisintervals) or two axes (axesIntervals)
to the current plot with tick marks delimiting interval
described by labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axisIntervals(side=1, atTick1=fda::monthBegin.5, atTick2=fda::monthEnd.5,
      atLabels=fda::monthMid, labels=month.abb, cex.axis=0.9, ...)
axesIntervals(side=1:2, atTick1=fda::monthBegin.5, atTick2=fda::monthEnd.5,
      atLabels=fda::monthMid, labels=month.abb, cex.axis=0.9, las=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="axisIntervals_+3A_side">side</code></td>
<td>

<p>an integer specifying which side of the plot the axis is to
be drawn on.  The axis is placed as follows: 1=below, 2=left,
3=above and 4=right.
</p>
</td></tr>
<tr><td><code id="axisIntervals_+3A_attick1">atTick1</code></td>
<td>

<p>the points at which tick-marks marking the starting points of the
intervals are to be drawn.  This defaults to 'monthBegin.5' to mark
monthly periods for an annual cycle.  These are constructed by
calling axis(side, at=atTick1, labels=FALSE, ...).  For more detail
on this, see 'axis'.
</p>
</td></tr>
<tr><td><code id="axisIntervals_+3A_attick2">atTick2</code></td>
<td>

<p>the points at which tick-marks marking the ends of the
intervals are to be drawn.  This defaults to 'monthEnd.5' to mark
monthly periods for an annual cycle.  These are constructed by
calling axis(side, at=atTick2, labels=FALSE, ...).  Use atTick2=NA
to rely only on atTick1.  For more detail
on this, see 'axis'.
</p>
</td></tr>
<tr><td><code id="axisIntervals_+3A_atlabels">atLabels</code></td>
<td>

<p>the points at which 'labels' should be typed.  These are constructed
by calling axis(side, at=atLabels, tick=FALSE, ...).  For more detail
on this, see 'axis'.
</p>
</td></tr>
<tr><td><code id="axisIntervals_+3A_labels">labels</code></td>
<td>

<p>Labels to be typed at locations 'atLabels'.  This is accomplished by
calling axis(side, at=atLabels, labels=labels, tick=FALSE, ...).
For more detail on this, see 'axis'.
</p>
</td></tr>
<tr><td><code id="axisIntervals_+3A_cex.axis">cex.axis</code></td>
<td>

<p>Character expansion (magnification) used for axis annotations
('labels' in this function call) relative
to the current setting of 'cex'.  For more detail, see 'par'.
</p>
</td></tr>
<tr><td><code id="axisIntervals_+3A_las">las</code></td>
<td>

<p>line axis style;  see <code>par</code>.
</p>
</td></tr>
<tr><td><code id="axisIntervals_+3A_...">...</code></td>
<td>

<p>additional arguments passed to <code>axis</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value from the third (labels) call to 'axis'.  This function is
usually invoked for its side effect, which is to add an axis to an
already existing plot.
</p>
<p><code>axesIntervals</code> calls <code>axisIntervals(side[1], ...)</code> then
<code>axis(side[2], ...)</code>.
</p>


<h3>Side Effects</h3>

<p>An axis is added to the current plot.
</p>


<h3>Author(s)</h3>

<p> Spencer Graves  </p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+axis">axis</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>
<code><a href="#topic+monthBegin.5">monthBegin.5</a></code>
<code><a href="#topic+monthEnd.5">monthEnd.5</a></code>
<code><a href="#topic+monthMid">monthMid</a></code>
<code><a href="base.html#topic+month.abb">month.abb</a></code>
<code><a href="#topic+monthLetters">monthLetters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly= TRUE)
daybasis65 &lt;- create.fourier.basis(c(0, 365), 65)

daytempfd &lt;- with(CanadianWeather, smooth.basis(
       day.5,  dailyAv[,,"Temperature.C"], 
       daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd )

with(CanadianWeather, plotfit.fd(
      dailyAv[,,"Temperature.C"], argvals=day.5,
          daytempfd, index=1, titles=place, axes=FALSE) )
# Label the horizontal axis with the month names
axisIntervals(1)
axis(2)
# Depending on the physical size of the plot,
# axis labels may not all print.
# In that case, there are 2 options:
# (1) reduce 'cex.lab'.
# (2) Use different labels as illustrated by adding
#     such an axis to the top of this plot

with(CanadianWeather, plotfit.fd(
      dailyAv[,,"Temperature.C"], argvals=day.5,
          daytempfd, index=1, titles=place, axes=FALSE) )
# Label the horizontal axis with the month names
axesIntervals()

axisIntervals(3, labels=monthLetters, cex.lab=1.2, line=-0.5)
# 'line' argument here is passed to 'axis' via '...'
par(oldpar)
</code></pre>

<hr>
<h2 id='basisfd'>
Define a Functional Basis Object
</h2><span id='topic+basisfd'></span><span id='topic++5B.basisfd'></span>

<h3>Description</h3>

<p>This is the constructor function for objects of the <code>basisfd</code>
class.  Each function that sets up an object of this class must call
this function.  This includes functions <code>create.bspline.basis</code>,
<code>create.constant.basis</code>, <code>create.fourier.basis</code>, and so
forth that set up basis objects of a specific type.  Ordinarily, user
of the functional data analysis software will not need to call this
function directly, but these notes are valuable to understanding what
the &quot;slots&quot; or &quot;members&quot; of the <code>basisfd</code> class are.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basisfd(type, rangeval, nbasis, params,
        dropind=vector('list', 0),
        quadvals=vector('list', 0),
        values=vector("list", 0),
        basisvalues=vector('list', 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basisfd_+3A_type">type</code></td>
<td>

<p>a character string indicating the type of basis.  Currently,
there are eight possible types:
</p>

<dl>
<dt>Bspline, bspline, Bsp, bsp</dt><dd><p>b-spline basis</p>
</dd>
<dt>const, con, constant</dt><dd><p>constant basis</p>
</dd>
<dt>exp, expon, exponen, exponential</dt><dd><p>exponential basis</p>
</dd>
<dt>Fourier, fourier, Fou, fou</dt><dd><p>Fourier basis</p>
</dd>
<dt>mon, monom, monomial</dt><dd><p>monomial basis</p>
</dd>
<dt>polyg, polygon, polygonal</dt><dd><p>polygonal basis</p>
</dd>
<dt>polynomial, poly</dt><dd><p>polynomial basis</p>
</dd>
<dt>power, pow</dt><dd><p>power basis</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="basisfd_+3A_rangeval">rangeval</code></td>
<td>

<p>a vector of length 2 containing the lower and upper boundaries
of the range over which the basis is defined
</p>
</td></tr>
<tr><td><code id="basisfd_+3A_nbasis">nbasis</code></td>
<td>

<p>the number of basis functions
</p>
</td></tr>
<tr><td><code id="basisfd_+3A_params">params</code></td>
<td>

<p>a vector of parameter values defining the basis.
</p>
<p>If the basis is &quot;fourier&quot;, this is a single number indicating the
period.  That is, the basis functions are periodic on the interval
(0,PARAMS) or any translation of it.
</p>
<p>If the basis is &quot;bspline&quot;, the values are interior points at which
the piecewise polynomials join.  Note that the number of basis
functions NBASIS is equal to the order of the Bspline functions plus
the number of interior knots, that is the length of PARAMS.  This
means that NBASIS must be at least 1 larger than the length of PARAMS.
</p>
</td></tr>
<tr><td><code id="basisfd_+3A_dropind">dropind</code></td>
<td>

<p>a vector of integers specifiying the basis functions to
be dropped, if any.  For example, if it is required that
a function be zero at the left boundary, this is achieved
by dropping the first basis function, the only one that
is nonzero at that point.
</p>
</td></tr>
<tr><td><code id="basisfd_+3A_quadvals">quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of argument values used to approximate an integral using Simpson's
rule.  The first column contains these argument values.  A minimum
of 5 values are required for each inter-knot interval, and that is
often enough. These are equally spaced between two adjacent knots.
The second column contains the weights used for Simpson's rule.
These are proportional to 1, 4, 2, 4, ..., 2, 4, 1.
</p>
</td></tr>
<tr><td><code id="basisfd_+3A_values">values</code></td>
<td>

<p>a list, with entries containing the values of the basis function
derivatives starting with 0 and going up to the highest derivative
needed.  The values correspond to quadrature points in
<code>quadvals</code> and it is up to the user to decide whether or not to
multiply the derivative values by the square roots of the quadrature
weights so as to make numerical integration a simple matrix
multiplication.  Values are checked against <code>quadvals</code> to
ensure the correct number of rows, and against <code>nbasis</code> to
ensure the correct number of columns.
</p>
<p><code>values</code> contains values of basis functions and derivatives at
quadrature points weighted by square root of quadrature weights.
These values are only generated as required, and only if the
<code>quadvals</code> is not matrix(&quot;numeric&quot;,0,0).



</p>
</td></tr>
<tr><td><code id="basisfd_+3A_basisvalues">basisvalues</code></td>
<td>

<p>a list of lists.  This is designed to avoid evaluation of a basis
system repeatedly at a set of argument values. Each sublist
corresponds to a specific set of argument values, and must have at
least two components, which may be named as you wish.  The first
component in an element of the list vector contains the argument
values.  The second component is a matrix of values of the basis
functions evaluated at the arguments in the first component.
Subsequent components, if present, are matrices of values their
derivatives up to a maximum derivative order.  Whenever function
<code>getbasismatrix</code> is called, it checks the first list in each
row to see, first, if the number of argument values corresponds to
the size of the first dimension, and if this test succeeds, checks
that all of the argument values match.  This takes time, of course,
but is much faster than re-evaluation of the basis system.  Even
this time can be avoided by direct retrieval of the desired array.
For example, you might set up a vector of argument values called
&quot;evalargs&quot; along with a matrix of basis function values for these
argument values called &quot;basismat&quot;.  You might want too use tags like
&quot;args&quot; and &quot;values&quot;, respectively for these.  You would then assign
them to BASISVALUES with code such as basisobj$basisvalues &lt;-
vector(&quot;list&quot;,1);  basisobj$basisvalues[[1]] &lt;- list(args=evalargs,
values=basismat).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Previous versions of the 'fda' software used the name <code>basis</code>
for this class, and the code in Matlab still does.  However, this
class name was already used elsewhere in the S languages, and there
was a potential for a clash that might produce mysterious and perhaps
disastrous consequences.
</p>
<p>To check that an object is of this class, use function
<code><a href="#topic+is.basis">is.basis</a></code>.
</p>
<p>It is comparatively simple to add new basis types.  The code in
the following functions needs to be estended to allow for the new
type: <code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+getbasismatrix">getbasismatrix</a></code> and <code><a href="#topic+getbasispenalty">getbasispenalty</a></code>.
In addition, a new &quot;create&quot; function should be written for the
new type, as well as functions analogous to <code><a href="#topic+fourier">fourier</a></code> and
<code><a href="#topic+fourierpen">fourierpen</a></code> for evaluating basis functions for basis
penalty matrices.
</p>
<p>The &quot;create&quot; function names are rather long, and users who mind
all that typing might be advised to modify these to versions with
shorter names, such as &quot;splbas&quot;, &quot;conbas&quot;, and etc.  However, a
principle of good programming practice is to keep the code readable,
preferably by somebody other than the programmer.
</p>
<p>Normally only developers of new basis types will actually need
to use this function, so no examples are provided.
</p>


<h3>Value</h3>

<p>an object of class <code>basisfd</code>, being a list with the following
components:
</p>
<table role = "presentation">
<tr><td><code>type</code></td>
<td>
<p>type of basis</p>
</td></tr>
<tr><td><code>rangeval</code></td>
<td>
<p>acceptable range for the argument</p>
</td></tr>
<tr><td><code>nbasis</code></td>
<td>
<p>number of bases</p>
</td></tr>
<tr><td><code>params</code></td>
<td>

<p>a vector of parameter values defining the basis.
</p>
</td></tr>
<tr><td><code>dropind</code></td>
<td>
<p>input argument dropind</p>
</td></tr>
<tr><td><code>quadvals</code></td>
<td>
<p>quadrature values ...</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>a list of basis functions and derivatives
</p>
</td></tr>
<tr><td><code>basisvalues</code></td>
<td>
<p>input argument basisvalues</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles and Graves, Spencer (2009)
<em>Functional Data Analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.basis">is.basis</a></code>,
<code><a href="#topic+is.eqbasis">is.eqbasis</a></code>,
<code><a href="#topic+plot.basisfd">plot.basisfd</a></code>,
<code><a href="#topic+getbasismatrix">getbasismatrix</a></code>,
<code><a href="#topic+getbasispenalty">getbasispenalty</a></code>,
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>,
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>,
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>,
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>,
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
</p>

<hr>
<h2 id='basisfd.product'>
Product of two basisfd objects
</h2><span id='topic+basisfd.product'></span><span id='topic++2A.basisfd'></span>

<h3>Description</h3>

<p>pointwise multiplication method for basisfd class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basisfd'
basisobj1 * basisobj2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basisfd.product_+3A_basisobj1">basisobj1</code>, <code id="basisfd.product_+3A_basisobj2">basisobj2</code></td>
<td>
<p>objects of class basisfd</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TIMES for (two basis objects sets up a basis suitable for expanding
the pointwise product of two functional data objects with these
respective bases.  In the absence of a true product basis system in
this code, the rules followed are inevitably a compromise:
(1) if both bases are B-splines, the norder is the sum of the
two orders - 1, and the breaks are the union of the
two knot sequences, each knot multiplicity being the maximum
of the multiplicities of the value in the two break sequences.
That is, no knot in the product knot sequence will have a
multiplicity greater than the multiplicities of this value
in the two knot sequences.
The rationale this rule is that order of differentiability
of the product at eachy value will be controlled  by
whichever knot sequence has the greater multiplicity.
In the case where one of the splines is order 1, or a step
function, the problem is dealt with by replacing the
original knot values by multiple values at that location
to give a discontinuous derivative.
(2) if both bases are Fourier bases, AND the periods are the
the same, the product is a Fourier basis with number of
basis functions the sum of the two numbers of basis fns.
(3) if only one of the bases is B-spline, the product basis
is B-spline with the same knot sequence and order two
higher.
(4) in all other cases, the product is a B-spline basis with
number of basis functions equal to the sum of the two
numbers of bases and equally spaced knots.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f1 &lt;- create.fourier.basis()
  f1.2 &lt;- f1*f1
  
  all.equal(f1.2, create.fourier.basis(nbasis=5))
  
</code></pre>

<hr>
<h2 id='bifd'>
Create a bivariate functional data object 
</h2><span id='topic+bifd'></span>

<h3>Description</h3>

<p>This function creates a bivariate functional data object, which
consists of two bases for expanding a functional data object of two 
variables, s and t, and a set of coefficients defining this expansion.
The bases are contained in &quot;basisfd&quot; objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bifd (coef=matrix(0,2,1), sbasisobj=create.bspline.basis(),
      tbasisobj=create.bspline.basis(), fdnames=defaultnames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bifd_+3A_coef">coef</code></td>
<td>

<p>a two-, three-, or four-dimensional array containing
coefficient values for the expansion of each set of bivariate
function values=terms of a set of basis function values
</p>
<p>If 'coef' is two dimensional, this implies that there is only
one variable and only one replication.  In that case, 
the first and second dimensions correspond to
the basis functions for the first and second argument,
respectively.
</p>
<p>If 'coef' is three dimensional, this implies that there are multiple
replicates on only one variable.  In that case, 
the first and second dimensions correspond to
the basis functions for the first and second argument,
respectively, and the third dimension corresponds to
replications.
</p>
<p>If 'coef' has four dimensions, the fourth dimension
corresponds to variables.
</p>
</td></tr>
<tr><td><code id="bifd_+3A_sbasisobj">sbasisobj</code></td>
<td>

<p>a functional data basis object
for the first argument s of the bivariate function.  
</p>
</td></tr>
<tr><td><code id="bifd_+3A_tbasisobj">tbasisobj</code></td>
<td>

<p>a functional data basis object
for the second argument t of the bivariate function.  
</p>
</td></tr>
<tr><td><code id="bifd_+3A_fdnames">fdnames</code></td>
<td>

<p>A list of length 4 containing dimnames for 'coefs' if it is a
4-dimensional array.  If it is only 2- or 3-dimensional, the later
components of fdnames are not applied to 'coefs'.  In any event, the
components of fdnames describe the following:
</p>
<p>(1) The row of 'coefs' corresponding to the bases in sbasisobj.
Defaults to sbasisobj[[&quot;names&quot;]] if non-null and of the proper
length, or to existing dimnames(coefs)[[1]] if non-null and of the
proper length, and to 's1', 's2', ...,
otherwise.  
</p>
<p>(2) The columns of 'coefs' corresponding to the bases in tbasisobj.
Defaults to tbasisobj[[&quot;names&quot;]] if non-null and of the proper
length, or to existing dimnames(coefs)[[2]] if non-null and of the
proper length, and to 't1', 't2', ...,  
otherwise.  
</p>
<p>(3) The replicates.  Defaults to dimnames(coefs)[[3]] if non-null
and of the proper length, and to 'rep1', ..., otherwise.
</p>
<p>(4) Variable names.  Defaults to dimnames(coefs)[[4]] if non-null
and of the proper length, and to 'var1', ..., otherwise.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bivariate functional data object = a list of class 'bifd' 
with the following components:
</p>
<table role = "presentation">
<tr><td><code>coefs</code></td>
<td>

<p>the input 'coefs' possible with dimnames from dfnames if provided or
from sbasisobj$names and tbasisobsj$names
</p>
</td></tr>
<tr><td><code>sbasisobj</code></td>
<td>

<p>a functional data basis object
for the first argument s of the bivariate function.  
</p>
</td></tr>
<tr><td><code>tbasisobj</code></td>
<td>

<p>a functional data basis object
for the second argument t of the bivariate function.  
</p>
</td></tr>
<tr><td><code>bifdnames</code></td>
<td>

<p>a list of length 4 giving names for the dimensions of coefs, with
one or two unused lists of names if length(dim(coefs)) is only two
or one, respectively.  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Spencer Graves  </p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>
<code><a href="#topic+objAndNames">objAndNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Bspl2 &lt;- create.bspline.basis(nbasis=2, norder=1)
Bspl3 &lt;- create.bspline.basis(nbasis=3, norder=2)

(bBspl2.3 &lt;- bifd(array(1:6, dim=2:3), Bspl2, Bspl3))
str(bBspl2.3)

</code></pre>

<hr>
<h2 id='bifdPar'>
Define a Bivariate Functional Parameter Object
</h2><span id='topic+bifdPar'></span>

<h3>Description</h3>

<p>Functional parameter objects are used as arguments to functions that
estimate functional parameters, such as smoothing functions like
<code>smooth.basis</code>.  A bivariate functional parameter object supplies
the analogous information required for smoothing bivariate data using
a bivariate functional data object $x(s,t)$.  The arguments are the same as
those for <code>fdPar</code> objects, except that two linear differential
operator objects and two smoothing parameters must be applied,
each pair corresponding to one of the arguments $s$ and $t$ of the
bivariate functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bifdPar(bifdobj, Lfdobjs=int2Lfd(2), Lfdobjt=int2Lfd(2), lambdas=0, lambdat=0,
      estimate=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bifdPar_+3A_bifdobj">bifdobj</code></td>
<td>

<p>a bivariate functional data object.
</p>
</td></tr>
<tr><td><code id="bifdPar_+3A_lfdobjs">Lfdobjs</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object for the first argument $s$.
</p>
<p>If <code>NULL</code>, Lfdobjs depends on bifdobj[['sbasis']][['type']]:
</p>

<dl>
<dt>bspline</dt><dd>
<p>Lfdobjs &lt;- int2Lfd(max(0, norder-2)), where norder =
norder(bifdobj[['sbasis']]).
</p>
</dd>
<dt>fourier</dt><dd>
<p>Lfdobjs = a harmonic acceleration operator:
</p>
<p><code>Lfdobj &lt;- vec2Lfd(c(0,(2*pi/diff(rngs))^2,0), rngs)</code>
</p>
<p>where rngs = bifdobj[['sbasis']][['rangeval']].
</p>
</dd>
<dt>anything else</dt><dd><p>Lfdobj &lt;- int2Lfd(0)</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="bifdPar_+3A_lfdobjt">Lfdobjt</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object for the first argument $t$.
</p>
<p>If <code>NULL</code>, Lfdobjt depends on bifdobj[['tbasis']][['type']]:
</p>

<dl>
<dt>bspline</dt><dd>
<p>Lfdobj &lt;- int2Lfd(max(0, norder-2)), where norder =
norder(bifdobj[['tbasis']]).
</p>
</dd>
<dt>fourier</dt><dd>
<p>Lfdobj = a harmonic acceleration operator:
</p>
<p><code>Lfdobj &lt;- vec2Lfd(c(0,(2*pi/diff(rngt))^2,0), rngt)</code>
</p>
<p>where rngt = bifdobj[['tbasis']][['rangeval']].
</p>
</dd>
<dt>anything else</dt><dd><p>Lfdobj &lt;- int2Lfd(0)</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="bifdPar_+3A_lambdas">lambdas</code></td>
<td>

<p>a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter $x(s,t)$
as a function of $s$..
</p>
</td></tr>
<tr><td><code id="bifdPar_+3A_lambdat">lambdat</code></td>
<td>

<p>a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter $x(s,t)$
as a function of $t$..
</p>
</td></tr>
<tr><td><code id="bifdPar_+3A_estimate">estimate</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a bivariate functional parameter object (i.e., an object of class 
<code>bifdPar</code>), which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>bifd</code></td>
<td>

<p>a functional data object (i.e., with class <code>bifd</code>)
</p>
</td></tr>
<tr><td><code>Lfdobjs</code></td>
<td>

<p>a linear differential operator object (i.e., with class
<code>Lfdobjs</code>)
</p>
</td></tr>
<tr><td><code>Lfdobjt</code></td>
<td>

<p>a linear differential operator object (i.e., with class
<code>Lfdobjt</code>)
</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>

<p>a nonnegative real number
</p>
</td></tr>
<tr><td><code>lambdat</code></td>
<td>

<p>a nonnegative real number
</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009)
<em>Functional Data Analysis in R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linmod">linmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the prediction of precipitation using temperature as
#the independent variable in the analysis of the daily weather
#data, and the analysis of the Swedish mortality data.
</code></pre>

<hr>
<h2 id='bsplinepen'>
B-Spline Penalty Matrix
</h2><span id='topic+bsplinepen'></span>

<h3>Description</h3>

<p>Computes the matrix defining the roughness penalty for functions
expressed in terms of a B-spline basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bsplinepen(basisobj, Lfdobj=2, rng=basisobj$rangeval, returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsplinepen_+3A_basisobj">basisobj</code></td>
<td>

<p>a B-spline basis object.
</p>
</td></tr>
<tr><td><code id="bsplinepen_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator object.
</p>
</td></tr>
<tr><td><code id="bsplinepen_+3A_rng">rng</code></td>
<td>

<p>a vector of length 2 defining range over which the basis penalty is to
be computed.
</p>
</td></tr>
<tr><td><code id="bsplinepen_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A roughness penalty for a function $x(t)$ is defined by
integrating the square of either the derivative of $x(t)$ or,
more generally, the result of applying a linear differential operator
$L$ to it.  The most common roughness penalty is the integral of
the square of the second derivative, and
this is the default. To apply this roughness penalty, the matrix of
inner products of the basis functions (possibly after applying the
linear differential operator to them) defining this function
is necessary. This function just calls the roughness penalty evaluation
function specific to the basis involved.
</p>


<h3>Value</h3>

<p>a symmetric matrix of order equal to the number of basis functions
defined by the B-spline basis object.  Each element is the inner product
of two B-spline basis functions after applying the derivative or linear
differential operator defined by <code>Lfdobj</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## bsplinepen with only one basis function
##
bspl1.1 &lt;- create.bspline.basis(nbasis=1, norder=1)
pen1.1 &lt;- bsplinepen(bspl1.1, 0)

##
## bspline pen for a cubic spline with knots at seq(0, 1, .1)
##
basisobj &lt;- create.bspline.basis(c(0,1),13)
#  compute the 13 by 13 matrix of inner products of second derivatives
penmat &lt;- bsplinepen(basisobj)

##
## with rng of class Date or POSIXct
##
# Date
invasion1 &lt;- as.Date('1775-09-04')
invasion2 &lt;- as.Date('1812-07-12')
earlyUS.Canada &lt;- c(invasion1, invasion2)
BspInvade1 &lt;- create.bspline.basis(earlyUS.Canada)
Binvadmat &lt;- bsplinepen(BspInvade1)

# POSIXct
AmRev.ct &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev1.ct &lt;- create.bspline.basis(AmRev.ct)
Brevmat &lt;- bsplinepen(BspRev1.ct)

</code></pre>

<hr>
<h2 id='bsplineS'>
B-spline Basis Function Values
</h2><span id='topic+bsplineS'></span>

<h3>Description</h3>

<p>Evaluates a set of B-spline basis functions, or a derivative of these
functions, at a set of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bsplineS(x, breaks, norder=4, nderiv=0, returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bsplineS_+3A_x">x</code></td>
<td>

<p>A vector of argument values at which the B-spline basis functions
are to be evaluated.
</p>
</td></tr>
<tr><td><code id="bsplineS_+3A_breaks">breaks</code></td>
<td>

<p>A strictly increasing set of break values defining the B-spline
basis.  The argument values <code>x</code> should be within the interval
spanned by the break values.
</p>
</td></tr>
<tr><td><code id="bsplineS_+3A_norder">norder</code></td>
<td>

<p>The order of the B-spline basis functions.  The order less one is
the degree of the piece-wise polynomials that make up any B-spline
function. The default is order 4, meaning piece-wise cubic.
</p>
</td></tr>
<tr><td><code id="bsplineS_+3A_nderiv">nderiv</code></td>
<td>

<p>A nonnegative integer specifying the order of derivative to be
evaluated.  The derivative must not exceed the order.  The default
derivative is 0, meaning that the basis functions themselves are
evaluated.
</p>
</td></tr>
<tr><td><code id="bsplineS_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of function values.  The number of rows equals the number of
arguments, and the number of columns equals the number of basis
functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Minimal example:  A B-spline of order 1 (i.e., a step function)
# with 0 interior knots:
bS &lt;- bsplineS(seq(0, 1, .2), 0:1, 1, 0)

# check

all.equal(bS, matrix(1, 6))


#  set up break values at 0.0, 0.2,..., 0.8, 1.0.
breaks &lt;- seq(0,1,0.2)
#  set up a set of 11 argument values
x &lt;- seq(0,1,0.1)
#  the order willl be 4, and the number of basis functions
#  is equal to the number of interior break values (4 here)
#  plus the order, for a total here of 8.
norder &lt;- 4
#  compute the 11 by 8 matrix of basis function values
basismat &lt;- bsplineS(x, breaks, norder)
</code></pre>

<hr>
<h2 id='CanadianWeather'>
Canadian average annual weather cycle
</h2><span id='topic+CanadianWeather'></span><span id='topic+daily'></span>

<h3>Description</h3>

<p>Daily temperature and precipitation at 35 different locations
in Canada averaged over 1960 to 1994.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CanadianWeather
daily
</code></pre>


<h3>Format</h3>

<p>'CanadianWeather' and 'daily' are lists containing essentially the
same data.  'CanadianWeather' may be preferred for most purposes;
'daily' is included primarily for compatibility with scripts written
before the other format became available and for compatibility with
the Matlab 'fda' code.
</p>

<dl>
<dt>CanadianWeather</dt><dd>
<p>A list with the following components:
</p>

<dl>
<dt>dailyAv</dt><dd>
<p>a three dimensional array c(365, 35, 3) summarizing data
collected at 35 different weather stations in Canada on the
following:
</p>
<p>[,,1] = [,, 'Temperature.C']:  average daily temperature for
each day of the year
</p>
<p>[,,2] = [,, 'Precipitation.mm']:  average daily rainfall for
each day of the year rounded to 0.1 mm.
</p>
<p>[,,3] = [,, 'log10precip']:  base 10 logarithm of
Precipitation.mm after first replacing 27 zeros by 0.05 mm
(Ramsay and Silverman 2006, p. 248).
</p>
</dd>
<dt>place</dt><dd>
<p>Names of the 35 different weather stations in Canada whose data
are summarized in 'dailyAv'.  These names vary between 6 and 11
characters in length.  By contrast, daily[[&quot;place&quot;]] which are
all 11 characters, with names having fewer characters being
extended with trailing blanks.
</p>
</dd>
<dt>province</dt><dd>
<p>names of the Canadian province containing each place
</p>
</dd>
<dt>coordinates</dt><dd>
<p>a numeric matrix giving 'N.latitude' and 'W.longitude' for each
place.
</p>
</dd>
<dt>region</dt><dd>
<p>Which of 4 climate zones contain each place:  Atlantic, Pacific,
Continental, Arctic.
</p>
</dd>
<dt>monthlyTemp</dt><dd>
<p>A matrix of dimensions (12, 35) giving the average temperature
in degrees celcius for each month of the year.
</p>
</dd>
<dt>monthlyPrecip</dt><dd>
<p>A matrix of dimensions (12, 35) giving the average daily
precipitation in millimeters for each month of the year.
</p>
</dd>
<dt>geogindex</dt><dd>
<p>Order the weather stations from East to West to North
</p>
</dd>
</dl>

</dd>
<dt>daily</dt><dd>
<p>A list with the following components:
</p>

<dl>
<dt>place</dt><dd>
<p>Names of the 35 different weather stations in Canada whose
data are summarized in 'dailyAv'.  These names are all 11
characters, with shorter names being extended with trailing
blanks.  This is different from CanadianWeather[[&quot;place&quot;]],
where trailing blanks have been dropped.
</p>
</dd>
<dt>tempav</dt><dd>
<p>a matrix of dimensions (365, 35) giving the average
temperature in degrees celcius for each day of the year.  This
is essentially the same as CanadianWeather[[&quot;dailyAv&quot;]][,,
&quot;Temperature.C&quot;].
</p>
</dd>
<dt>precipav</dt><dd>
<p>a matrix of dimensions (365, 35) giving the average
temperature in degrees celcius for each day of the year.  This
is essentially the same as CanadianWeather[[&quot;dailyAv&quot;]][,,
&quot;Precipitation.mm&quot;].
</p>
</dd>
</dl>

</dd>
</dl>



<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monthAccessories">monthAccessories</a></code>
<code><a href="#topic+MontrealTemp">MontrealTemp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  Plot (latitude &amp; longitude) of stations by region
##
with(CanadianWeather, plot(-coordinates[, 2], coordinates[, 1], type='n',
                           xlab="West Longitude", ylab="North Latitude",
                           axes=FALSE) )
Wlon &lt;- pretty(CanadianWeather$coordinates[, 2])
axis(1, -Wlon, Wlon)
axis(2)

rgns &lt;- 1:4
names(rgns) &lt;- c('Arctic', 'Atlantic', 'Continental', 'Pacific')
Rgns &lt;- rgns[CanadianWeather$region]
with(CanadianWeather, points(-coordinates[, 2], coordinates[, 1],
                             col=Rgns, pch=Rgns) )
legend('topright', legend=names(rgns), col=rgns, pch=rgns)

##
## 2.  Plot dailyAv[, 'Temperature.C'] for 4 stations
##
data(CanadianWeather)
# Expand the left margin to allow space for place names
op &lt;- par(mar=c(5, 4, 4, 5)+.1)
# Plot
stations &lt;- c("Pr. Rupert", "Montreal", "Edmonton", "Resolute")
matplot(day.5, CanadianWeather$dailyAv[, stations, "Temperature.C"],
        type="l", axes=FALSE, xlab="", ylab="Mean Temperature (deg C)")
axis(2, las=1)
# Label the horizontal axis with the month names
axis(1, monthBegin.5, labels=FALSE)
axis(1, monthEnd.5, labels=FALSE)
axis(1, monthMid, monthLetters, tick=FALSE)
# Add the monthly averages
matpoints(monthMid, CanadianWeather$monthlyTemp[, stations])
# Add the names of the weather stations
mtext(stations, side=4,
      at=CanadianWeather$dailyAv[365, stations, "Temperature.C"],
     las=1)
# clean up
par(op)
</code></pre>

<hr>
<h2 id='cca.fd'>
Functional Canonical Correlation Analysis
</h2><span id='topic+cca.fd'></span>

<h3>Description</h3>

<p>Carry out a functional canonical correlation analysis with
regularization or roughness penalties on the estimated
canonical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cca.fd(fdobj1, fdobj2=fdobj1, ncan = 2,
       ccafdPar1=fdPar(basisobj1, 2, 1e-10),
       ccafdPar2=ccafdPar1, centerfns=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cca.fd_+3A_fdobj1">fdobj1</code></td>
<td>

<p>a functional data object.
</p>
</td></tr>
<tr><td><code id="cca.fd_+3A_fdobj2">fdobj2</code></td>
<td>

<p>a functional data object.  By default this is <code> fdobj1 </code>, in
which case the first argument must be a bivariate functional data
object.
</p>
</td></tr>
<tr><td><code id="cca.fd_+3A_ncan">ncan</code></td>
<td>

<p>the number of canonical variables and weight functions to be
computed.  The default is 2.
</p>
</td></tr>
<tr><td><code id="cca.fd_+3A_ccafdpar1">ccafdPar1</code></td>
<td>

<p>a functional parameter object defining the first set of canonical
weight functions.  The object may contain specifications for a
roughness penalty. The default is defined using the same basis
as that used for <code> fdobj1 </code> with a slight penalty on its
second derivative.
</p>
</td></tr>
<tr><td><code id="cca.fd_+3A_ccafdpar2">ccafdPar2</code></td>
<td>

<p>a functional parameter object defining the second set of canonical
weight functions.  The object may contain specifications for a
roughness penalty. The default is <code> ccafdParobj1 </code>.
</p>
</td></tr>
<tr><td><code id="cca.fd_+3A_centerfns">centerfns</code></td>
<td>

<p>if TRUE, the functions are centered prior to analysis. This is the
default.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>cca.fd</code> with the 5 slots:
</p>
<table role = "presentation">
<tr><td><code>ccwtfd1</code></td>
<td>

<p>a functional data object for the first
canonical variate weight function
</p>
</td></tr>
<tr><td><code>ccwtfd2</code></td>
<td>

<p>a functional data object for the second
canonical variate weight function
</p>
</td></tr>
<tr><td><code>cancorr</code></td>
<td>

<p>a vector of canonical correlations
</p>
</td></tr>
<tr><td><code>ccavar1</code></td>
<td>

<p>a matrix of scores on the first canonical variable.
</p>
</td></tr>
<tr><td><code>ccavar2</code></td>
<td>

<p>a matrix of scores on the second canonical variable.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cca.fd">plot.cca.fd</a></code>,
<code><a href="#topic+varmx.cca.fd">varmx.cca.fd</a></code>,
<code><a href="#topic+pca.fd">pca.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Canonical correlation analysis of knee-hip curves

gaittime  &lt;- (1:20)/21
gaitrange &lt;- c(0,1)
gaitbasis &lt;- create.fourier.basis(gaitrange,21)
lambda    &lt;- 10^(-11.5)
harmaccelLfd &lt;- vec2Lfd(c(0, 0, (2*pi)^2, 0))

gaitfd    &lt;- fda::fd(matrix(0,gaitbasis$nbasis,1), gaitbasis)
gaitfdPar &lt;- fda::fdPar(gaitfd, harmaccelLfd, lambda)
gaitfd    &lt;- fda::smooth.basis(gaittime, gait, gaitfdPar)$fd
ccafdPar  &lt;- fda::fdPar(gaitfd, harmaccelLfd, 1e-8)
ccafd0    &lt;- cca.fd(gaitfd[,1], gaitfd[,2], ncan=3, ccafdPar, ccafdPar)
#  display the canonical correlations
round(ccafd0$ccacorr[1:6],3)
#  compute a VARIMAX rotation of the canonical variables
ccafd &lt;- varmx.cca.fd(ccafd0)
#  plot the canonical weight functions
oldpar &lt;- par(no.readonly= TRUE)
plot.cca.fd(ccafd)
par(oldpar)

</code></pre>

<hr>
<h2 id='center.fd'>
Center Functional Data
</h2><span id='topic+center.fd'></span>

<h3>Description</h3>

<p>Subtract the pointwise mean from each of the functions
in a functional data object; that is, to center them on the mean function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> center.fd(fdobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="center.fd_+3A_fdobj">fdobj</code></td>
<td>
<p>a functional data object to be centered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functional data object whose mean is zero.</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.fd">mean.fd</a></code>,
<code><a href="#topic+sum.fd">sum.fd</a></code>,
<code><a href="#topic+stddev.fd">stddev.fd</a></code>,
<code><a href="#topic+std.fd">std.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daytime    &lt;- (1:365)-0.5
daybasis   &lt;- create.fourier.basis(c(0,365), 365)
harmLcoef  &lt;- c(0,(2*pi/365)^2,0)
harmLfd    &lt;- vec2Lfd(harmLcoef, c(0,365))
templambda &lt;- 0.01
dayfd      &lt;- fda::fd(matrix(0, daybasis$nbasis, 1), daybasis)
tempfdPar  &lt;- fda::fdPar(dayfd, harmLfd, templambda)

# do not run on CRAN because it takes too long.
tempfd     &lt;- smooth.basis(daytime,
       CanadianWeather$dailyAv[,,"Temperature.C"], tempfdPar)$fd
tempctrfd  &lt;- center.fd(tempfd)
oldpar &lt;- par(no.readonly= TRUE)
plot(tempctrfd, xlab="Day", ylab="deg. C",
     main = "Centered temperature curves")
par(oldpar)
</code></pre>

<hr>
<h2 id='checkDims3'>
Compare dimensions and dimnames of arrays
</h2><span id='topic+checkDim3'></span><span id='topic+checkDims3'></span>

<h3>Description</h3>

<p>Compare selected dimensions and dimnames of arrays, coercing objects
to 3-dimensional arrays and either give an error or force matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDim3(x, y=NULL, xdim=1, ydim=1, defaultNames='x',
         subset=c('xiny', 'yinx', 'neither'),
         xName=substring(deparse(substitute(x)), 1, 33),
         yName=substring(deparse(substitute(y)), 1, 33) )
checkDims3(x, y=NULL, xdim=2:3, ydim=2:3, defaultNames='x',
         subset=c('xiny', 'yinx', 'neither'),
         xName=substring(deparse(substitute(x)), 1, 33),
         yName=substring(deparse(substitute(y)), 1, 33) )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDims3_+3A_x">x</code>, <code id="checkDims3_+3A_y">y</code></td>
<td>

<p>arrays to be compared.  If <code>y</code> is missing, <code>x</code> is used.
</p>
<p>Currently, both <code>x</code> and <code>y</code> can have at most 3
dimensions.  If either has more, an error will be thrown.  If either
has fewer, it will be expanded to 3 dimensions using
<code>as.array3</code>.
</p>
</td></tr>
<tr><td><code id="checkDims3_+3A_xdim">xdim</code>, <code id="checkDims3_+3A_ydim">ydim</code></td>
<td>

<p>For <code>checkDim3</code>, these are positive integers indicating which
dimension of <code>x</code> will be compared with which dimension of
<code>y</code>.
</p>
<p>For <code>checkDims3</code>, these are positive integer vectors of the same
length, passed one at a time to <code>checkDim3</code>.  The default here
is to force matching dimensions for <code><a href="#topic+plotfit.fd">plotfit.fd</a></code>.
</p>
</td></tr>
<tr><td><code id="checkDims3_+3A_defaultnames">defaultNames</code></td>
<td>

<p>Either NULL, FALSE or a character string or vector or list.  If
NULL, no checking is done of dimnames.  If FALSE, an error is thrown
unless the corresponding dimensions of <code>x</code> and <code>y</code> match
exactly.
</p>
<p>If it is a character string, vector, or list, it is used as the
default names if neither <code>x</code> nor <code>y</code> have dimenames for
the compared dimensions.  If it is a character vector that is too
short, it is extended to the required length using
paste(defaultNames, 1:ni), where <code>ni</code> = the required length.
</p>
<p>If it is a list, it should have length (length(xdim)+1).  Each
component must be either a character vector or NULL.  If neither
<code>x</code> nor <code>y</code> have dimenames for the first compared
dimensions, defaultNames[[1]] will be used instead unless it is
NULL, in which case the last component of defaultNames will be
used.  If it is null, an error is thrown.
</p>
</td></tr>
<tr><td><code id="checkDims3_+3A_subset">subset</code></td>
<td>

<p>If 'xiny', and any(dim(y)[ydim] &lt; dim(x)[xdim]), an error is
thrown.  Else if any(dim(y)[ydim] &gt; dim(x)[xdim]) the larger is
reduced to match the smaller.  If 'yinx', this procedure is
reversed.
</p>
<p>If 'neither', any dimension mismatch generates an error.
</p>
</td></tr>
<tr><td><code id="checkDims3_+3A_xname">xName</code>, <code id="checkDims3_+3A_yname">yName</code></td>
<td>

<p>names of the arguments <code>x</code> and <code>y</code>, used only to in error
messages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>checkDims3</code>, confirm that <code>xdim</code> and <code>ydim</code> have
the same length, and call <code>checkDim3</code> for each pair.
</p>
<p>For <code>checkDim3</code>, proceed as follows:
</p>
<p>1.  if((xdim&gt;3) | (ydim&gt;3)) throw an error.
</p>
<p>2.  ixperm &lt;- list(1:3, c(2, 1, 3), c(3, 2, 1))[xdim];
iyperm &lt;- list(1:3, c(2, 1, 3), c(3, 2, 1))[ydim];
</p>
<p>3.  x3 &lt;- aperm(as.array3(x), ixperm);
y3 &lt;- aperm(as.array3(y), iyperm)
</p>
<p>4.  xNames &lt;- dimnames(x3);  yNames &lt;- dimnames(y3)
</p>
<p>5.  Check subset.  For example, for subset='xiny', use the following:
<code>
    if(is.null(xNames)){
      if(dim(x3)[1]&gt;dim(y3)[1]) stop
      else y. &lt;- y3[1:dim(x3)[1],,]
      dimnames(x) &lt;- list(yNames[[1]], NULL, NULL)
    }
    else {
      if(is.null(xNames[[1]])){
	if(dim(x3)[1]&gt;dim(y3)[1]) stop
	else y. &lt;- y3[1:dim(x3)[1],,]
	dimnames(x3)[[1]] &lt;- yNames[[1]]
      }
      else {
	if(any(!is.element(xNames[[1]], yNames[[1]])))stop
	else y. &lt;- y3[xNames[[1]],,]
      }
    }
  </code>
</p>
<p>6.  return(list(x=aperm(x3, ixperm), y=aperm(y., iyperm)))
</p>


<h3>Value</h3>

<p>a list with components <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.array3">as.array3</a></code>
<code><a href="#topic+plotfit.fd">plotfit.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Select the first two rows of y
stopifnot(all.equal(
checkDim3(1:2, 3:5),
list(x=array(1:2, c(2,1,1), list(c('x1','x2'), NULL, NULL)),
     y=array(3:4, c(2,1,1), list(c('x1','x2'), NULL, NULL)) )
))

# Select the first two rows of a matrix y
stopifnot(all.equal(
checkDim3(1:2, matrix(3:8, 3)),
list(x=array(1:2,         c(2,1,1), list(c('x1','x2'), NULL, NULL)),
     y=array(c(3:4, 6:7), c(2,2,1), list(c('x1','x2'), NULL, NULL)) )
))

# Select the first column of y
stopifnot(all.equal(
checkDim3(1:2, matrix(3:8, 3), 2, 2),
list(x=array(1:2,         c(2,1,1), list(NULL, 'x', NULL)),
     y=array(3:5, c(3,1,1), list(NULL, 'x', NULL)) )
))

# Select the first two rows and the first column of y
stopifnot(all.equal(
checkDims3(1:2, matrix(3:8, 3), 1:2, 1:2),
list(x=array(1:2, c(2,1,1), list(c('x1','x2'), 'x', NULL)),
     y=array(3:4, c(2,1,1), list(c('x1','x2'), 'x', NULL)) )
))

# Select the first 2 rows of y
x1 &lt;- matrix(1:4, 2, dimnames=list(NULL, LETTERS[2:3]))
x1a &lt;- x1. &lt;- as.array3(x1)
dimnames(x1a)[[1]] &lt;- c('x1', 'x2')
y1 &lt;- matrix(11:19, 3, dimnames=list(NULL, LETTERS[1:3]))
y1a &lt;- y1. &lt;- as.array3(y1)
dimnames(y1a)[[1]] &lt;- c('x1', 'x2', 'x3')

stopifnot(all.equal(
checkDim3(x1, y1),
list(x=x1a, y=y1a[1:2, , , drop=FALSE])
))

# Select columns 2 &amp; 3 of y
stopifnot(all.equal(
checkDim3(x1, y1, 2, 2),
list(x=x1., y=y1.[, 2:3, , drop=FALSE ])
))

# Select the first 2 rows and  columns 2 &amp; 3 of y
stopifnot(all.equal(
checkDims3(x1, y1, 1:2, 1:2),
list(x=x1a, y=y1a[1:2, 2:3, , drop=FALSE ])
))

# y = columns 2 and 3 of x
x23 &lt;- matrix(1:6, 2, dimnames=list(letters[2:3], letters[1:3]))
x23. &lt;- as.array3(x23)
stopifnot(all.equal(
checkDim3(x23, xdim=1, ydim=2),
list(x=x23., y=x23.[, 2:3,, drop=FALSE ])
))

# Transfer dimnames from y to x
x4a &lt;- x4 &lt;- matrix(1:4, 2)
y4 &lt;- matrix(5:8, 2, dimnames=list(letters[1:2], letters[3:4]))
dimnames(x4a) &lt;- dimnames(t(y4))
stopifnot(all.equal(
checkDims3(x4, y4, 1:2, 2:1),
list(x=as.array3(x4a), y=as.array3(y4))
))

# as used in plotfit.fd
daybasis65 &lt;- create.fourier.basis(c(0, 365), 65)

daytempfd &lt;- with(CanadianWeather, smooth.basis(
       day.5, dailyAv[,,"Temperature.C"], 
       daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd )

defaultNms &lt;- with(daytempfd, c(fdnames[2], fdnames[3], x='x'))
subset &lt;- checkDims3(CanadianWeather$dailyAv[, , "Temperature.C"],
               daytempfd$coef, defaultNames=defaultNms)
# Problem:  dimnames(...)[[3]] = '1'
# Fix:
subset3 &lt;- checkDims3(
        CanadianWeather$dailyAv[, , "Temperature.C", drop=FALSE],
               daytempfd$coef, defaultNames=defaultNms)
</code></pre>

<hr>
<h2 id='checkLogicalInteger'>
Does an argument satisfy required conditions?    
</h2><span id='topic+checkLogical'></span><span id='topic+checkNumeric'></span><span id='topic+checkLogicalInteger'></span>

<h3>Description</h3>

<p>Check whether an argument is a logical vector of a certain length or a
numeric vector in a certain range and issue an appropriate error or
warning if not:
</p>
<p><code>checkLogical</code> throws an error or returns FALSE with a warning
unless <code>x</code> is a  logical vector of exactly the required
<code>length</code>.
</p>
<p><code>checkNumeric</code> throws an error or returns FALSE with a warning
unless <code>x</code> is either NULL or a <code>numeric</code> vector of at most
<code>length</code> with <code>x</code> in the desired range.  
</p>
<p><code>checkLogicalInteger</code> returns a logical vector of exactly
<code>length</code> unless <code>x</code> is neither NULL nor <code>logical</code> of
the required <code>length</code> nor <code>numeric</code> with <code>x</code> in the
desired range. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLogical(x, length., warnOnly=FALSE)
checkNumeric(x, lower, upper, length., integer=TRUE, unique=TRUE,
             inclusion=c(TRUE,TRUE), warnOnly=FALSE)
checkLogicalInteger(x, length., warnOnly=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkLogicalInteger_+3A_x">x</code></td>
<td>
<p> an object to be checked </p>
</td></tr>
<tr><td><code id="checkLogicalInteger_+3A_length.">length.</code></td>
<td>
   
<p>The required length for <code>x</code> if <code>logical</code> and not NULL or
the maximum length if <code>numeric</code>.  
</p>
</td></tr>
<tr><td><code id="checkLogicalInteger_+3A_lower">lower</code>, <code id="checkLogicalInteger_+3A_upper">upper</code></td>
<td>

<p>lower and upper limits for <code>x</code>.  
</p>
</td></tr> 
<tr><td><code id="checkLogicalInteger_+3A_integer">integer</code></td>
<td>

<p>logical:  If true, a <code>numeric</code> <code>x</code> must be
<code>integer</code>.  
</p>
</td></tr>
<tr><td><code id="checkLogicalInteger_+3A_unique">unique</code></td>
<td>

<p>logical:  TRUE if duplicates are NOT allowed in <code>x</code>.  
</p>
</td></tr>
<tr><td><code id="checkLogicalInteger_+3A_inclusion">inclusion</code></td>
<td>

<p>logical vector of length 2, similar to
<code>link[ifultools]{checkRange}</code>:  
</p>
<p>if(inclusion[1]) (lower &lt;= x) else (lower &lt; x)
</p>
<p>if(inclusion[2]) (x &lt;= upper) else (x &lt; upper)
</p>
</td></tr>   
<tr><td><code id="checkLogicalInteger_+3A_warnonly">warnOnly</code></td>
<td>

<p>logical:  If TRUE, violations are reported as warnings, not as
errors.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  xName &lt;- deparse(substitute(x)) to use in any required error or
warning.  
</p>
<p>2.  if(is.null(x)) handle appropriately:  Return FALSE for
<code>checkLogical</code>, TRUE for <code>checkNumeric</code> and rep(TRUE,
length.) for <code>checkLogicalInteger</code>.  
</p>
<p>3.  Check class(x).
</p>
<p>4.  Check other conditions.  
</p>


<h3>Value</h3>

<p><code>checkLogical</code> returns a logical vector of the required
<code>length.</code>, unless it issues an error message.
</p>
<p><code>checkNumeric</code> returns a numeric vector of at most <code>length.</code>
with all elements between <code>lower</code> and <code>upper</code>, and
optionally <code>unique</code>, unless it issues an error message.
</p>
<p><code>checkLogicalInteger</code> returns a logical vector of the required
<code>length.</code>, unless it issues an error message.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## checkLogical
##
checkLogical(NULL, length=3, warnOnly=TRUE)
checkLogical(c(FALSE, TRUE, TRUE), length=4, warnOnly=TRUE)
checkLogical(c(FALSE, TRUE, TRUE), length=3)

##
## checkNumeric
##
checkNumeric(NULL, lower=1, upper=3)
checkNumeric(1:3, 1, 3)
checkNumeric(1:3, 1, 3, inclusion=FALSE, warnOnly=TRUE)
checkNumeric(pi, 1, 4, integer=TRUE, warnOnly=TRUE)
checkNumeric(c(1, 1), 1, 4, warnOnly=TRUE)
checkNumeric(c(1, 1), 1, 4, unique=FALSE, warnOnly=TRUE)

##
## checkLogicalInteger
##
checkLogicalInteger(NULL, 3)
checkLogicalInteger(c(FALSE, TRUE), warnOnly=TRUE) 
checkLogicalInteger(1:2, 3) 
checkLogicalInteger(2, warnOnly=TRUE) 
checkLogicalInteger(c(2, 4), 3, warnOnly=TRUE)

##
## checkLogicalInteger names its calling function 
## rather than itself as the location of error detection
## if possible
##
tstFun &lt;- function(x, length., warnOnly=FALSE){
   checkLogicalInteger(x, length., warnOnly) 
}
tstFun(NULL, 3)
tstFun(4, 3, warnOnly=TRUE)

tstFun2 &lt;- function(x, length., warnOnly=FALSE){
   tstFun(x, length., warnOnly)
}
tstFun2(4, 3, warnOnly=TRUE)

</code></pre>

<hr>
<h2 id='coef.fd'>
Extract functional coefficients 
</h2><span id='topic+coef.fd'></span><span id='topic+coef.fdPar'></span><span id='topic+coef.fdSmooth'></span><span id='topic+coefficients.fd'></span><span id='topic+coefficients.fdPar'></span><span id='topic+coefficients.fdSmooth'></span>

<h3>Description</h3>

<p>Obtain the coefficients component from a functional object (functional
data, class <code>fd</code>, functional parameter, class <code>fdPar</code>, a
functional smooth, class <code>fdSmooth</code>, or a Taylor spline
representation, class <code>Taylor</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
coef(object, ...)
## S3 method for class 'fdPar'
coef(object, ...)
## S3 method for class 'fdSmooth'
coef(object, ...)
## S3 method for class 'fd'
coefficients(object, ...)
## S3 method for class 'fdPar'
coefficients(object, ...)
## S3 method for class 'fdSmooth'
coefficients(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.fd_+3A_object">object</code></td>
<td>

<p>An object whose functional coefficients are desired 
</p>
</td></tr>
<tr><td><code id="coef.fd_+3A_...">...</code></td>
<td>

<p>other arguments 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional representations are evaluated by multiplying a basis
function matrix times a coefficient vector, matrix or 3-dimensional
array. (The basis function matrix contains the basis functions as
columns evaluated at the <code>evalarg</code> values as rows.)  
</p>


<h3>Value</h3>

<p>A numeric vector or array of the coefficients.  
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code>
<code><a href="#topic+fd">fd</a></code>
<code><a href="#topic+fdPar">fdPar</a></code>
<code><a href="#topic+smooth.basisPar">smooth.basisPar</a></code>
<code><a href="#topic+smooth.basis">smooth.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## coef.fd
##
bspl1.1 &lt;- create.bspline.basis(norder=1, breaks=0:1)
fd.bspl1.1 &lt;- fd(0, basisobj=bspl1.1)
coef(fd.bspl1.1)


##
## coef.basisPar 
##
rangeval &lt;- c(-3,3)
#  set up some standard normal data
x &lt;- rnorm(50)
#  make sure values within the range
x[x &lt; -3] &lt;- -2.99
x[x &gt;  3] &lt;-  2.99
#  set up basis for W(x)
basisobj &lt;- create.bspline.basis(rangeval, 11)
#  set up initial value for Wfdobj
Wfd0 &lt;- fd(matrix(0,11,1), basisobj)
WfdParobj &lt;- fdPar(Wfd0)

coef(WfdParobj)


##
## coef.fdSmooth
##

girlGrowthSm &lt;- with(growth, smooth.basisPar(argvals=age, y=hgtf, 
                                             lambda=0.1)$fd)
coef(girlGrowthSm)


</code></pre>

<hr>
<h2 id='cor.fd'>
Correlation matrix from functional data object(s) 
</h2><span id='topic+cor.fd'></span>

<h3>Description</h3>

<p>Compute a correlation matrix for one or two functional data objects.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor.fd(evalarg1, fdobj1, evalarg2=evalarg1, fdobj2=fdobj1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor.fd_+3A_evalarg1">evalarg1</code></td>
<td>

<p>a vector of argument values for fdobj1.   
</p>
</td></tr>
<tr><td><code id="cor.fd_+3A_evalarg2">evalarg2</code></td>
<td>

<p>a vector of argument values for fdobj2.  
</p>
</td></tr>
<tr><td><code id="cor.fd_+3A_fdobj1">fdobj1</code>, <code id="cor.fd_+3A_fdobj2">fdobj2</code></td>
<td>

<p>functional data objects 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  var1 &lt;- var.fd(fdobj1) 
2.  evalVar1 &lt;- eval.bifd(evalarg1, evalarg1, var1)
3.  if(missing(fdobj2)) Convert evalVar1 to correlations
4.  else:  
4.1.  var2 &lt;- var.fd(fdobj2)
4.2.  evalVar2 &lt;- eval.bifd(evalarg2, evalarg2, var2)
4.3.  var12 &lt;- var.df(fdobj1, fdobj2)
4.4.  evalVar12 &lt;- eval.bifd(evalarg1, evalarg2, var12)
4.5.  Convert evalVar12 to correlations  
</p>


<h3>Value</h3>

<p>A matrix or array:
</p>
<p>With one or two functional data objects, fdobj1 and possibly fdobj2,
the value is a matrix of dimensions length(evalarg1) by length(evalarg2) giving the
correlations at those points of fdobj1 if missing(fdobj2) or of
correlations between eval.fd(evalarg1, fdobj1) and eval.fd(evalarg2,
fdobj2).
</p>
<p>With a single multivariate data object with k variables, the value is
a 4-dimensional array of dim = c(nPts, nPts, 1, choose(k+1, 2)), where
nPts = length(evalarg1).  
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.fd">mean.fd</a></code>, 
<code><a href="#topic+sd.fd">sd.fd</a></code>, 
<code><a href="#topic+std.fd">std.fd</a></code>
<code><a href="#topic+stdev.fd">stdev.fd</a></code>
<code><a href="#topic+var.fd">var.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daybasis3 &lt;- create.fourier.basis(c(0, 365))
daybasis5 &lt;- create.fourier.basis(c(0, 365), 5)
tempfd3 &lt;- with(CanadianWeather, smooth.basis(
       day.5, dailyAv[,,"Temperature.C"], 
       daybasis3, fdnames=list("Day", "Station", "Deg C"))$fd )
precfd5 &lt;- with(CanadianWeather, smooth.basis(
       day.5, dailyAv[,,"log10precip"], 
       daybasis5, fdnames=list("Day", "Station", "Deg C"))$fd )

# Correlation matrix for a single functional data object
(tempCor3 &lt;- cor.fd(seq(0, 356, length=4), tempfd3))

# Cross correlation matrix between two functional data objects 
# Compare with structure described above under 'value':
(tempPrecCor3.5 &lt;- cor.fd(seq(0, 365, length=4), tempfd3,
                          seq(0, 356, length=6), precfd5))

# The following produces contour and perspective plots

daybasis65 &lt;- create.fourier.basis(rangeval=c(0, 365), nbasis=65)
daytempfd &lt;- with(CanadianWeather, smooth.basis(
       day.5, dailyAv[,,"Temperature.C"], 
       daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd )
dayprecfd &lt;- with(CanadianWeather, smooth.basis(
       day.5, dailyAv[,,"log10precip"], 
       daybasis65, fdnames=list("Day", "Station", "log10(mm)"))$fd )

str(tempPrecCor &lt;- cor.fd(weeks, daytempfd, weeks, dayprecfd))
# dim(tempPrecCor)= c(53, 53)

op &lt;- par(mfrow=c(1,2), pty="s")
contour(weeks, weeks, tempPrecCor, 
        xlab="Average Daily Temperature",
        ylab="Average Daily log10(precipitation)",
        main=paste("Correlation function across locations\n",
          "for Canadian Anual Temperature Cycle"),
        cex.main=0.8, axes=FALSE)
axisIntervals(1, atTick1=seq(0, 365, length=5), atTick2=NA, 
            atLabels=seq(1/8, 1, 1/4)*365,
            labels=paste("Q", 1:4) )
axisIntervals(2, atTick1=seq(0, 365, length=5), atTick2=NA, 
            atLabels=seq(1/8, 1, 1/4)*365,
            labels=paste("Q", 1:4) )
persp(weeks, weeks, tempPrecCor,
      xlab="Days", ylab="Days", zlab="Correlation")
mtext("Temperature-Precipitation Correlations", line=-4, outer=TRUE)
par(op)

# Correlations and cross correlations
# in a bivariate functional data object
gaittime   &lt;- (1:20)/21
gaitbasis5 &lt;- create.fourier.basis(c(0,1),nbasis=5)
gaitfd5    &lt;- smooth.basis(gaittime, gait, gaitbasis5)$fd

gait.t3 &lt;- (0:2)/2
(gaitCor3.5 &lt;- cor.fd(gait.t3, gaitfd5))
# Check the answers with manual computations
gait3.5 &lt;- eval.fd(gait.t3, gaitfd5)
all.equal(cor(t(gait3.5[,,1])), gaitCor3.5[,,,1])
# TRUE
all.equal(cor(t(gait3.5[,,2])), gaitCor3.5[,,,3])
# TRUE
all.equal(cor(t(gait3.5[,,2]), t(gait3.5[,,1])),
               gaitCor3.5[,,,2])
# TRUE

# NOTE:
dimnames(gaitCor3.5)[[4]]
# [1] Hip-Hip
# [2] Knee-Hip 
# [3] Knee-Knee
# If [2] were "Hip-Knee", then
# gaitCor3.5[,,,2] would match 
# cor(t(gait3.5[,,1]), t(gait3.5[,,2]))
# *** It does NOT.  Instead, it matches:  
# cor(t(gait3.5[,,2]), t(gait3.5[,,1]))

</code></pre>

<hr>
<h2 id='covPACE'>
Estimate of the covariance surface 
</h2><span id='topic+covPACE'></span>

<h3>Description</h3>

<p>Function <code>covPACE</code> does a bivariate smoothing for estimating the 
covariance surface for data that has not yet been smoothed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  covPACE(data,rng , time, meanfd, basis, lambda, Lfdobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covPACE_+3A_data">data</code></td>
<td>

<p>a matrix object or list &ndash; If the set is supplied as a matrix object, 
the rows must correspond to argument values and columns to replications, 
and it will be assumed that there is only one variable per observation.  
If y is a three-dimensional array, the first dimension corresponds to  
argument values, the second to replications, and the third to variables 
within replications. &ndash; If it is a list, each element must be a matrix
object, the rows correspond to argument values per individual. First 
column corresponds to time points and following columns to argument values 
per variable.
</p>
</td></tr>
<tr><td><code id="covPACE_+3A_rng">rng</code></td>
<td>

<p>a vector of length 2 defining a restricted range where the data was observed
</p>
</td></tr>
<tr><td><code id="covPACE_+3A_time">time</code></td>
<td>

<p>Array with time points where data was taken. <code>length(time) == dim(data)[1]</code>
</p>
</td></tr>
<tr><td><code id="covPACE_+3A_meanfd">meanfd</code></td>
<td>

<p>Fd object corresponding to the mean function of the data
</p>
</td></tr>
<tr><td><code id="covPACE_+3A_basis">basis</code></td>
<td>

<p>basisfd object for smoothing the covariate function
</p>
</td></tr>
<tr><td><code id="covPACE_+3A_lambda">lambda</code></td>
<td>

<p>a nonnegative real number specifying the amount of smoothing to be applied to
the estimated functional parameter
</p>
</td></tr>
<tr><td><code id="covPACE_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>a linear differential operator object for smoothing penalty of the estimated 
functional parameter
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with these two named entries:
</p>
<table role = "presentation">
<tr><td><code>cov.estimate</code></td>
<td>

<p>an object of class &quot;bifd&quot; object or a list of &quot;bifd&quot; elements
</p>
</td></tr>
<tr><td><code>meanfd</code></td>
<td>

<p>a functional data object giving the mean function
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='CRAN'>
Test if running as CRAN
</h2><span id='topic+CRAN'></span>

<h3>Description</h3>

<p>This function allows package developers to run tests themselves that
should not run on CRAN or with &quot;R CMD check &ndash;as-cran&quot; because of
compute time constraints with CRAN tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CRAN(CRAN_pattern, n_R_CHECK4CRAN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CRAN_+3A_cran_pattern">CRAN_pattern</code></td>
<td>

<p>a regular expressions to apply to the names of <code>Sys.getenv()</code>
to identify possible CRAN parameters.  Defaults to
<code>Sys.getenv('_CRAN_pattern_')</code> if available and '^_R_' if not.
</p>
</td></tr>
<tr><td><code id="CRAN_+3A_n_r_check4cran">n_R_CHECK4CRAN</code></td>
<td>

<p>Assume this is CRAN if at least n_R_CHECK4CRAN elements of
<code>Sys.getenv()</code> have names matching x.  Defaults to
<code>Sys.getenv('_n_R_CHECK4CRAN_')</code> if available and 5 if not.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The &quot;Writing R Extensions&quot; manual says that &quot;R CMD check&quot; can be
customized &quot;by setting environment variables _R_CHECK_*_:, as
described in&quot; the Tools section of the &quot;R Internals&quot; manual.
</p>
<p>'R CMD check' was tested with R 3.0.1 under Fedora 18 Linux and with
Rtools 3.0 from April 16, 2013 under Windows 7.  With the '&ndash;as-cran'
option, 7 matches were found;  without it, only 3 were found.  These
numbers were unaffected by the presence or absence of the '&ndash;timings'
parameter.  On this basis, the default value of n_R_CHECK4CRAN was set
at 5.
</p>
<p>1.  x. &lt;- Sys.getenv()
</p>
<p>2.  Fix <code>CRAN_pattern</code> and <code>n_R_CHECK4CRAN</code> if missing.
</p>
<p>3.  Let i be the indices of x. whose names match all the patterns in
the vector x.
</p>
<p>4.  Assume this is CRAN if length(i) &gt;= n_R_CHECK4CRAN
</p>


<h3>Value</h3>

<p>a logical scalar with attributes 'Sys.getenv' containing the results
of <code>Sys.getenv()</code> and 'matches' contining <code>i</code> per step 3
above.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Sys.getenv">Sys.getenv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Look in fda-ex.R
  # for the results from R CMD check
  # Modified defaults were tested with environment variables
  # _CRAN_pattern_ = 'A' and _n_R_CHECK4CRAN_ = '10'
  # 'R CMD check' found 26 matches and CRAN() returned TRUE
  cran &lt;- CRAN()
  str(cran)
  gete &lt;- attr(cran, 'Sys.getenv')
  (ngete &lt;- names(gete))
  iget &lt;- grep('^_', names(gete))
  gete[iget]
  # if (!CRAN()) {
  #   if (CRAN()) {
  #     stop("CRAN")
  #   } else {
  #     stop("NOT CRAN")
  #   }
  # }
</code></pre>

<hr>
<h2 id='create.basis'>Create Basis Set for Functional Data Analysis</h2><span id='topic+create.basis'></span>

<h3>Description</h3>

<p>Functional data analysis proceeds by selecting a finite basis set and
fitting data to it.  The current <code>fda</code> package supports fitting
via least squares penalized with lambda times the integral over the
(finite) support of the basis set of the squared deviations from a
linear differential operator.
</p>


<h3>Details</h3>

<p>The most commonly used basis in <code>fda</code> is probably B-splines.  For
periodic phenomena, Fourier bases are quite useful.  A constant basis
is provided to facilitation arithmetic with functional data objects.
To restrict attention to solutions of certain differential equations,
it may be useful to use a corresponding basis set such as exponential,
monomial or power basis sets.
</p>
<p>Power bases support the use of negative and fractional powers, while
monomial bases are restricted only to nonnegative integer exponents.
</p>
<p>The polygonal basis is essentially a B-spline of order 2, degree 1.
</p>
<p>The following summarizes arguments used by some or all of the current
<code>create.basis</code> functions:
</p>

<dl>
<dt>rangeval</dt><dd>
<p>a vector of length 2 giving the lower and upper limits of the
range of permissible values for the function argument.
</p>
<p>For <code>bspline</code> bases, this can be inferred from
range(breaks).  For <code>polygonal</code> bases, this can be inferred
from range(argvals).  In all other cases, this defaults to 0:1.
</p>
</dd>
<dt>nbasis</dt><dd>
<p>an integer giving the number of basis functions.
</p>
<p>This is not used for two of the <code>create.basis</code> functions:
For <code>constant</code> this is 1, so there is no need to specify it.
For <code>polygonal</code> bases, it is length(argvals), and again there
is no need to specify it.
</p>
<p>For <code>bspline</code> bases, if <code>nbasis</code> is not specified, it
defaults to (length(breaks) + norder - 2) if <code>breaks</code> is
provided.  Otherwise, <code>nbasis</code> defaults to 20 for
<code>bspline</code> bases.
</p>
<p>For <code>exponential</code> bases, if <code>nbasis</code> is not specified,
it defaults to length(ratevec) if <code>ratevec</code> is provided.
Otherwise, in <code>fda_2.0.2</code>, <code>ratevec</code> defaults to 1,
which makes <code>nbasis</code> = 1;  in <code>fda_2.0.4</code>,
<code>ratevec</code> will default to 0:1, so <code>nbasis</code> will then
default to 2.
</p>
<p>For <code>monomial</code> and <code>power</code> bases, if <code>nbasis</code> is
not specified, it defaults to length(exponents) if
<code>exponents</code> is provided.  Otherwise, <code>nbasis</code> defaults
to 2 for <code>monomial</code> and <code>power</code> bases.  (Temporary
exception:  In <code>fda_2.0.2</code>, the default <code>nbasis</code> for
<code>power</code> bases is 1.  This will be increased to 2 in
<code>fda_2.0.4</code>.)
</p>
</dd>
</dl>
<p>In addition to <code>rangeval</code> and <code>nbasis</code>, all but
<code>constant</code> bases have one or two parameters unique to that
basis type or shared with one other:
</p>

<dl>
<dt>bspline</dt><dd>
<p>Argument <code>norder</code> = the order of the spline, which is one
more than the degree of the polynomials used.  This defaults to
4, which gives cubic splines.
</p>
<p>Argument <code>breaks</code> = the locations of the break or join
points;  also called <code>knots</code>.  This defaults to
seq(rangeval[1], rangeval[2], nbasis-norder+2).
</p>
</dd>
<dt>polygonal</dt><dd>
<p>Argument <code>argvals</code> = the locations of the break or join
points;  also called <code>knots</code>.  This defaults to
seq(rangeval[1], rangeval[2], nbasis).
</p>
</dd>
<dt>fourier</dt><dd>
<p>Argument <code>period</code> defaults to diff(rangeval).
</p>
</dd>
<dt>exponential</dt><dd>
<p>Argument <code>ratevec</code>.  In <code>fda_2.0.2</code>, this defaulted to
1.  In <code>fda_2.0.3</code>, it will default to 0:1.
</p>
</dd>
<dt>monomial, power</dt><dd>
<p>Argument <code>exponents</code>.  Default = 0:(nbasis-1).  For
<code>monomial</code> bases, <code>exponents</code> must be distinct
nonnegative integers.  For <code>power</code> bases, they must be
distinct real numbers.
</p>
</dd>
</dl>

<p>Beginning with <code>fda_2.1.0</code>, the last 6 arguments for all the
<code>create.basis</code> functions will be as follows;  some but not all
are available in the previous versions of <code>fda</code>:
</p>

<dl>
<dt>dropind</dt><dd>
<p>a vector of integers specifiying the basis functions to be
dropped, if any.
</p>
</dd>
<dt>quadvals</dt><dd>
<p>a matrix with two columns and a number of rows equal to the
number of quadrature points for numerical evaluation of the
penalty integral.  The first column of <code>quadvals</code> contains
the quadrature points, and the second column the quadrature
weights.  A minimum of 5 values are required for each inter-knot
interval, and that is often enough.  For Simpson's rule, these
points are equally spaced, and the weights are proportional to
1, 4, 2, 4, ..., 2, 4, 1.
</p>
</dd>
<dt>values</dt><dd>
<p>a list of matrices with one row for each row of <code>quadvals</code>
and one column for each basis function.  The elements of the
list correspond to the basis functions and their derivatives
evaluated at the quadrature points contained in the first column
of <code>quadvals</code>.
</p>
</dd>
<dt>basisvalues</dt><dd>
<p>A list of lists, allocated by code such as vector(&quot;list&quot;,1).
This field is designed to avoid evaluation of a basis system
repeatedly at a set of argument values.  Each list within the
vector corresponds to a specific set of argument values, and
must have at least two components, which may be tagged as you
wish.  'The first component in an element of the list vector
contains the argument values.  The second component in an
element of the list vector contains a matrix of values of the
basis functions evaluated at the arguments in the first
component.  The third and subsequent components, if present,
contain matrices of values their derivatives up to a maximum
derivative order.  Whenever function getbasismatrix is called,
it checks the first list in each row to see, first, if the
number of argument values corresponds to the size of the first
dimension, and if this test succeeds, checks that all of the
argument values match.  This takes time, of course, but is much
faster than re-evaluation of the basis system.  Even this time
can be avoided by direct retrieval of the desired array.  For
example, you might set up a vector of argument values called
&quot;evalargs&quot; along with a matrix of basis function values for
these argument values called &quot;basismat&quot;.  You might want too use
tags like &quot;args&quot; and &quot;values&quot;, respectively for these.  You
would then assign them to <code>basisvalues</code> with code such as
the following:
</p>
<p>basisobj$basisvalues &lt;- vector(&quot;list&quot;,1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs,
values=basismat)
</p>
</dd>
<dt>names</dt><dd>
<p>either a character vector of the same length as the number of
basis functions or a simple stem used to construct such a
vector.
</p>
<p>For <code>bspline</code> bases, this defaults to paste('bspl', norder,
'.', 1:nbreaks, sep=&rdquo;).
</p>
<p>For other bases, there are crudely similar defaults.
</p>
</dd>
<dt>axes</dt><dd>
<p>an optional list used by selected <code>plot</code> functions to
create custom <code>axes</code>.  If this <code>axes</code> argument is not
NULL, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>,
and <code>plot.Lfd</code> will create axes via
<code>do.call(x$axes[[1]], x$axes[-1])</code>.  The primary example of
this is to create <code>CanadianWeather</code> plots using
<code>list("axesIntervals")</code>
</p>
</dd>
</dl>




<h3>Author(s)</h3>

<p>J. O. Ramsay and Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
</p>

<hr>
<h2 id='create.bspline.basis'>
Create a B-spline Basis
</h2><span id='topic+create.bspline.basis'></span>

<h3>Description</h3>

<p>Functional data objects are constructed by specifying a set of basis
functions and a set of coefficients defining a linear combination of
these basis functions.  The B-spline basis is used for non-periodic
functions.  B-spline basis functions are polynomial segments jointed
end-to-end at at argument values called knots, breaks or join points.
The segments have specifiable smoothness across these breaks.  B-spline
basis functions have the advantages of very fast computation and great
flexibility.  A polygonal basis generated by
<code>create.polygonal.basis</code> is essentially a B-spline basis of order
2, degree 1.  Monomial and polynomial bases can be obtained as linear
transformations of certain B-spline bases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.bspline.basis(rangeval=NULL, nbasis=NULL, norder=4,
      breaks=NULL, dropind=NULL, quadvals=NULL, values=NULL,
      basisvalues=NULL, names="bspl")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.bspline.basis_+3A_rangeval">rangeval</code></td>
<td>

<p>a numeric vector of length 2 defining the interval over which the
functional data object can be evaluated;  default value is
<code>if(is.null(breaks)) 0:1 else range(breaks)</code>.
</p>
<p>If <code>length(rangeval) == 1</code> and <code>rangeval &lt;= 0</code>, this is an
error.  Otherwise, if <code>length(rangeval) == 1</code>, <code>rangeval</code>
is replaced by <code>c(0,rangeval)</code>.
</p>
<p>If length(rangeval)&gt;2 and neither <code>breaks</code> nor <code>nbasis</code>
are provided, this extra long <code>rangeval</code> argument is assigned
to <code>breaks</code>, and then <code>rangeval = range(breaks)</code>.
</p>
<p>NOTE:  Nonnumerics are also accepted provided
<code>sum(is.na(as.numeric(rangeval))) == 0</code>.  However, as of July
2, 2012, nonnumerics may not work for <code>argvals</code> in other
<code>fda</code> functions.
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_nbasis">nbasis</code></td>
<td>

<p>an integer variable specifying the number of basis functions.  This
'nbasis' argument is ignored if <code>breaks</code> is supplied, in which
case
</p>
<p>nbasis = nbreaks + norder - 2,
</p>
<p>where nbreaks = length(breaks).  If <code>breaks</code> is not supplied
and <code>nbasis</code> is, then
</p>
<p>nbreaks = nbasis - norder + 2,
</p>
<p>and breaks = seq(rangevals[1], rangevals[2], nbreaks).
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_norder">norder</code></td>
<td>

<p>an integer specifying the order of b-splines, which is one higher
than their degree. The default of 4 gives cubic splines.
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_breaks">breaks</code></td>
<td>

<p>a vector specifying the break points defining the b-spline.
Also called knots, these are a strictly increasing sequence
of junction points between piecewise polynomial segments.
They must satisfy <code>breaks[1] = rangeval[1]</code> and
<code>breaks[nbreaks] = rangeval[2]</code>, where <code>nbreaks</code> is the
length of <code>breaks</code>.  There must be at least 2 values in
<code>breaks</code>.
</p>
<p>As for rangeval, must satisfy <code>sum(is.na(as.numeric(breaks)))
      == 0</code>.
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_dropind">dropind</code></td>
<td>

<p>a vector of integers specifying the basis functions to
be dropped, if any.  For example, if it is required that
a function be zero at the left boundary, this is achieved
by dropping the first basis function, the only one that
is nonzero at that point.
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_quadvals">quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of quadrature points for numerical evaluation of the penalty
integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to 1, 4, 2, 4, ..., 2, 4,
1.
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_values">values</code></td>
<td>

<p>a list containing the basis functions and their derivatives
evaluated at the quadrature points contained in the first
column of <code> quadvals </code>.
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_basisvalues">basisvalues</code></td>
<td>

<p>a vector of lists, allocated by code such as  <code>vector("list",1)</code>.
This argument is designed to avoid evaluation of a basis system repeatedly
at a set of argument values.  Each list within the vector corresponds to a
specific set of argument values, and must have at least two components,
which may be tagged as you wish.  The first component in an element of the
list vector contains the argument values.  The second component in an
element of the list vector contains a matrix of values of the basis
functions evaluated at the arguments in the first component.  The third and
subsequent components, if present, contain matrices of values their
derivatives up to a maximum derivative order. Whenever function
<code>getbasismatrix()</code> is called, it checks the first list in each row to
see, first, if the number of argument values corresponds to the size of the
first dimension, and if this test succeeds, checks that all of the argument
values match.  This takes time, of course, but is much  faster than
re-evaluation of the basis system.
</p>
</td></tr>
<tr><td><code id="create.bspline.basis_+3A_names">names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a single character string to which <code>norder, "."</code>
and <code>1:nbasis</code> are appended as <code>paste(names, norder, ".",
    1:nbasis, sep="")</code>.  For example, if <code>norder = 4</code>, this
defaults to <code>'bspl4.1', 'bspl4.2'</code>, ... .
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Spline functions are constructed by joining polynomials end-to-end at
argument values called <em>break points</em> or <em>knots</em>. First, the
interval is subdivided into a set of adjoining intervals
separated the knots.  Then a polynomial of order $m$ (degree $m-1$) is
defined for each interval.  To make the resulting piecewise polynomial
smooth, two adjoining polynomials are constrained to have their values
and all their derivatives up to order $m-2$ match at the point where
they join.
</p>
<p>Consider as an illustration the very common case where the order is 4
for all polynomials, so that degree of each polynomials is 3.  That
is, the polynomials are <em>cubic</em>.  Then at each break point or
knot, the values of adjacent polynomials must match, and so also for
their first and second derivatives.  Only their third derivatives will
differ at the point of junction.
</p>
<p>The number of degrees of freedom of a cubic spline function of this
nature is calculated as follows.  First, for the first interval, there
are four degrees of freedom.  Then, for each additional interval, the
polynomial over that interval now has only one degree of freedom
because of the requirement for matching values and derivatives.  This
means that the number of degrees of freedom is the number of interior
knots (that is, not counting the lower and upper limits) plus the
order of the polynomials:
</p>
<p><code>nbasis = norder + length(breaks) - 2</code>
</p>
<p>The consistency of the values of <code>nbasis</code>, <code>norder</code> and
<code>breaks</code> is checked, and an error message results if this
equation is not satisfied.
</p>
<p><em>B-splines</em> are a set of special spline functions that can be
used to construct any such piecewise polynomial by computing the
appropriate linear combination.  They derive their computational
convenience from the fact that any B-spline basis function is nonzero
over at most m adjacent intervals.  The number of basis functions is
given by the rule above for the number of degrees of freedom.
</p>
<p>The number of intervals controls the flexibility of the spline;  the
more knots, the more flexible the resulting spline will be. But the
position of the knots also plays a role.  Where do we position the
knots?  There is room for judgment here, but two considerations must
be kept in mind:  (1) you usually want at least one argument value
between two adjacent knots, and (2) there should be more knots where
the curve needs to have sharp curvatures such as a sharp peak or
valley or an abrupt change of level, but only a few knots are required
where the curve is changing very slowly.
</p>
<p>This function automatically includes <code>norder</code> replicates of the
end points rangeval.  By contrast, the analogous functions
<a href="splines.html#topic+splineDesign">splineDesign</a> and <a href="splines.html#topic+spline.des">spline.des</a> in the
<code>splines</code> package do NOT automatically replicate the end points.
To compare answers, the end knots must be replicated manually when
using <a href="splines.html#topic+splineDesign">splineDesign</a> or <a href="splines.html#topic+spline.des">spline.des</a>.
</p>


<h3>Value</h3>

<p>a basis object of the type <code>bspline</code>
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New
York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>,
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>,
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>,
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>,
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
<code><a href="splines.html#topic+splineDesign">splineDesign</a></code>
<code><a href="splines.html#topic+spline.des">spline.des</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## The simplest basis currently available with this function:
##
bspl1.1 &lt;- create.bspline.basis(norder=1)
oldpar &lt;- par(no.readonly=TRUE)
plot(bspl1.1)
# 1 basis function, order 1 = degree 0 = step function:
# should be the same as above:
b1.1 &lt;- create.bspline.basis(0:1, nbasis=1, norder=1, breaks=0:1)

all.equal(bspl1.1, b1.1)

bspl2.2 &lt;- create.bspline.basis(norder=2)
plot(bspl2.2)
bspl3.3 &lt;- create.bspline.basis(norder=3)
plot(bspl3.3)
bspl4.4 &lt;- create.bspline.basis()
plot(bspl4.4)
bspl1.2 &lt;- create.bspline.basis(norder=1, breaks=c(0,.5, 1))
plot(bspl1.2)
# 2 bases, order 1 = degree 0 = step functions:
# (1) constant 1 between 0 and 0.5 and 0 otherwise
# (2) constant 1 between 0.5 and 1 and 0 otherwise.
bspl2.3 &lt;- create.bspline.basis(norder=2, breaks=c(0,.5, 1))
plot(bspl2.3)
# 3 bases:  order 2 = degree 1 = linear
# (1) line from (0,1) down to (0.5, 0), 0 after
# (2) line from (0,0) up to (0.5, 1), then down to (1,0)
# (3) 0 to (0.5, 0) then up to (1,1).
bspl3.4 &lt;- create.bspline.basis(norder=3, breaks=c(0,.5, 1))
plot(bspl3.4)
# 4 bases:  order 3 = degree 2 = parabolas.
# (1) (x-.5)^2 from 0 to .5, 0 after
# (2) 2*(x-1)^2 from .5 to 1, and a parabola
#     from (0,0 to (.5, .5) to match
# (3 &amp; 4) = complements to (2 &amp; 1).
bSpl4. &lt;- create.bspline.basis(c(-1,1))
plot(bSpl4.)
# Same as bSpl4.23 but over (-1,1) rather than (0,1).
# set up the b-spline basis for the lip data, using 23 basis functions,
#   order 4 (cubic), and equally spaced knots.
#  There will be 23 - 4 = 19 interior knots at 0.05, ..., 0.95
lipbasis &lt;- create.bspline.basis(c(0,1), 23)
plot(lipbasis)
bSpl.growth &lt;- create.bspline.basis(growth$age)
# cubic spline (order 4)
bSpl.growth6 &lt;- create.bspline.basis(growth$age,norder=6)
# quintic spline (order 6)
##
## Nonnumeric rangeval
##
# Date
July4.1776 &lt;- as.Date('1776-07-04')
Apr30.1789 &lt;- as.Date('1789-04-30')
AmRev &lt;- c(July4.1776, Apr30.1789)
BspRevolution &lt;- create.bspline.basis(AmRev)
# POSIXct
July4.1776ct &lt;- as.POSIXct1970('1776-07-04')
Apr30.1789ct &lt;- as.POSIXct1970('1789-04-30')
AmRev.ct &lt;- c(July4.1776ct, Apr30.1789ct)
BspRev.ct &lt;- create.bspline.basis(AmRev.ct)
par(oldpar)
</code></pre>

<hr>
<h2 id='create.constant.basis'>
Create a Constant Basis
</h2><span id='topic+create.constant.basis'></span>

<h3>Description</h3>

<p>Create a constant basis object, defining a single basis function
whose value is everywhere 1.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.constant.basis(rangeval=c(0, 1), names="const", axes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.constant.basis_+3A_rangeval">rangeval</code></td>
<td>

<p>a vector of length 2 containing the initial and final
values of argument t defining the interval over which the functional
data object can be evaluated.  However, this is seldom used
since the value of the basis function does not depend on the range
or any argument values.
</p>
</td></tr>
<tr><td><code id="create.constant.basis_+3A_names">names</code></td>
<td>

<p>a character vector of length 1.
</p>
</td></tr>
<tr><td><code id="create.constant.basis_+3A_axes">axes</code></td>
<td>

<p>an optional list used by selected <code>plot</code> functions to create
custom <code>axes</code>.  If this <code>axes</code> argument is not
<code>NULL</code>, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>, and
<code>plot.Lfd</code> will create axes via <code>x$axes[[1]]</code> and
<code>x$axes[-1]</code>.  The primary example of this uses
<code>list("axesIntervals", ...)</code>, e.g., with <code>Fourier</code> bases
to create <code>CanadianWeather</code> plots
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a basis object with type component <code>const</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>,
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>,
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>,
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basisobj &lt;- create.constant.basis(c(-1,1))
</code></pre>

<hr>
<h2 id='create.exponential.basis'>
Create an Exponential Basis
</h2><span id='topic+create.exponential.basis'></span>

<h3>Description</h3>

<p>Create an exponential basis object defining a set of exponential
functions with rate constants in argument ratevec.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.exponential.basis(rangeval=c(0,1), nbasis=NULL, ratevec=NULL,
                         dropind=NULL, quadvals=NULL, values=NULL,
                         basisvalues=NULL, names='exp', axes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.exponential.basis_+3A_rangeval">rangeval</code></td>
<td>

<p>a vector of length 2 containing the initial and final values of the
interval over which the functional data object can be evaluated.
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_nbasis">nbasis</code></td>
<td>

<p>the number of basis functions.  Default = <code>if(is.null(ratevec))
      2 else length(ratevec)</code>.
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_ratevec">ratevec</code></td>
<td>

<p>a vector of length <code>nbasis</code> of rate constants defining basis
functions of the form <code>exp(rate*x)</code>.  Default = 0:(nbasis-1).
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_dropind">dropind</code></td>
<td>

<p>a vector of integers specifiying the basis functions to be dropped,
if any.  For example, if it is required that a function be zero at
the left boundary, this is achieved by dropping the first basis
function, the only one that is nonzero at that point.
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_quadvals">quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of quadrature points for numerical evaluation of the penalty
integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to 1, 4, 2, 4, ..., 2, 4,
1.
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_values">values</code></td>
<td>

<p>a list of matrices with one row for each row of <code>quadvals</code> and
one column for each basis function.  The elements of the list
correspond to the basis functions and their derivatives evaluated at
the quadrature points contained in the first column of
<code>quadvals</code>.
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_basisvalues">basisvalues</code></td>
<td>

<p>A list of lists, allocated by code such as vector(&quot;list&quot;,1).  This
field is designed to avoid evaluation of a basis system repeatedly
at a set of argument values.  Each list within the vector
corresponds to a specific set of argument values, and must have at
least two components, which may be tagged as you wish.  'The first
component in an element of the list vector contains the argument
values.  The second component in an element of the list vector
contains a matrix of values of the basis functions evaluated at the
arguments in the first component.  The third and subsequent
components, if present, contain matrices of values their derivatives
up to a maximum derivative order.  Whenever function getbasismatrix
is called, it checks the first list in each row to see, first, if
the number of argument values corresponds to the size of the first
dimension, and if this test succeeds, checks that all of the
argument values match.  This takes time, of course, but is much
faster than re-evaluation of the basis system.  Even this time can
be avoided by direct retrieval of the desired array.  For example,
you might set up a vector of argument values called &quot;evalargs&quot; along
with a matrix of basis function values for these argument values
called &quot;basismat&quot;.  You might want too use names like &quot;args&quot; and
&quot;values&quot;, respectively for these.  You would then assign them to
<code>basisvalues</code> with code such as the following:
</p>
<p>basisobj$basisvalues &lt;- vector(&quot;list&quot;,1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs,
values=basismat)
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_names">names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a simple stem used to construct such a vector.
</p>
<p>For <code>exponential</code> bases, this defaults to paste('exp',
0:(nbasis-1), sep=&rdquo;).
</p>
</td></tr>
<tr><td><code id="create.exponential.basis_+3A_axes">axes</code></td>
<td>

<p>an optional list used by selected <code>plot</code> functions to create
custom <code>axes</code>.  If this <code>axes</code> argument is not
<code>NULL</code>, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>, and
<code>plot.Lfd</code> will create axes via <code>x$axes[[1]]</code> and
<code>x$axes[-1]</code>.  The primary example of this uses
<code>list("axesIntervals", ...)</code>, e.g., with <code>Fourier</code> bases
to create <code>CanadianWeather</code> plots
</p>
</td></tr></table>


<h3>Details</h3>

<p>Exponential functions are of the type $exp(bx)$ where $b$
is the rate constant.  If $b = 0$, the constant function is
defined.
</p>


<h3>Value</h3>

<p>a basis object with the type <code>expon</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>,
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>,
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>,
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  Create an exponential basis over interval [0,5]
#  with basis functions 1, exp(-t) and exp(-5t)
basisobj &lt;- create.exponential.basis(c(0,5),3,c(0,-1,-5))
#  plot the basis
oldpar &lt;- par(no.readonly=TRUE)
plot(basisobj)
par(oldpar)
</code></pre>

<hr>
<h2 id='create.fourier.basis'>
Create a Fourier Basis
</h2><span id='topic+create.fourier.basis'></span>

<h3>Description</h3>

<p>Create an Fourier basis object defining a set of Fourier
functions with specified period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.fourier.basis(rangeval=c(0, 1), nbasis=3,
              period=diff(rangeval), dropind=NULL, quadvals=NULL,
              values=NULL, basisvalues=NULL, names=NULL,
              axes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.fourier.basis_+3A_rangeval">rangeval</code></td>
<td>

<p>a vector of length 2 containing the initial and final values of the
interval over which the functional data object can be evaluated.
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_nbasis">nbasis</code></td>
<td>

<p>positive odd integer:  If an even number is specified, it is rounded
up to the nearest odd integer to preserve the pairing of sine and
cosine functions.  An even number of basis functions  only makes
sense when there are always only an even number of observations at
equally spaced points;  that case can be accommodated using dropind =
nbasis-1 (because the bases are <code>const</code>, <code>sin</code>,
<code>cos</code>, ...).
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_period">period</code></td>
<td>

<p>the width of any interval over which the Fourier functions repeat
themselves or are periodic.
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_dropind">dropind</code></td>
<td>

<p>an optional vector of integers specifiying basis functions to be
dropped.
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_quadvals">quadvals</code></td>
<td>

<p>an optional matrix with two columns and a number of rows equal to
the number of quadrature points for numerical evaluation of the
penalty integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to 1, 4, 2, 4, ..., 2, 4,
1.
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_values">values</code></td>
<td>

<p>an optional list of matrices with one row for each row of
<code>quadvals</code> and one column for each basis function.  The
elements of the list correspond to the basis functions and their
derivatives evaluated at the quadrature points contained in the
first column of <code>quadvals</code>.
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_basisvalues">basisvalues</code></td>
<td>

<p>an optional list of lists, allocated by code such as
vector(&quot;list&quot;,1).  This field is designed to avoid evaluation of a
basis system repeatedly at a set of argument values.  Each sublist
corresponds to a specific set of argument values, and must have at
least two components:  a vector of argument values and a matrix of
the values the basis functions evaluated at the arguments in the
first component.  Third and subsequent components, if present,
contain matrices of values their derivatives.  Whenever function
getbasismatrix is called, it checks the first list in each row to
see, first, if the number of argument values corresponds to the size
of the first dimension, and if this test succeeds, checks that all
of the argument values match.  This takes time, of course, but is
much faster than re-evaluation of the basis system.  Even this time
can be avoided by direct retrieval of the desired array.  For
example, you might set up a vector of argument values called
&quot;evalargs&quot; along with a matrix of basis function values for these
argument values called &quot;basismat&quot;.  You might want too use tags like
&quot;args&quot; and &quot;values&quot;, respectively for these.  You would then assign
them to <code>basisvalues</code> with code such as the following:
</p>
<p>basisobj$basisvalues &lt;- vector(&quot;list&quot;,1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs,
values=basismat)
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_names">names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a simple stem used to construct such a vector.
</p>
<p>If <code>nbasis</code> = 3, <code>names</code> defaults to c('const', 'cos',
'sin').  If <code>nbasis</code> &gt; 3, <code>names</code> defaults to c('const',
outer(c('cos', 'sin'), 1:((nbasis-1)/2), paste, sep=&rdquo;)).
</p>
<p>If names = NA, no names are used.
</p>
</td></tr>
<tr><td><code id="create.fourier.basis_+3A_axes">axes</code></td>
<td>

<p>an optional list used by selected <code>plot</code> functions to create
custom <code>axes</code>.  If this <code>axes</code> argument is not
<code>NULL</code>, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>, and
<code>plot.Lfd</code> will create axes via <code>x$axes[[1]]</code> and
<code>x$axes[-1]</code>.  The primary example of this is to create
<code>CanadianWeather</code> plots using <code>list("axesIntervals")</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional data objects are constructed by specifying a set of basis
functions and a set of coefficients defining a linear combination of
these basis functions.  The Fourier basis is a system
that is usually used for periodic functions.  It has the advantages
of very fast computation and great flexibility.   If the data are
considered to be nonperiod, the Fourier basis is usually preferred.
The first Fourier basis function is the constant function.  The
remainder are sine and cosine pairs with integer multiples of the
base period. The number of basis functions generated is always odd.
</p>


<h3>Value</h3>

<p>a basis object with the type <code>fourier</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>,
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>,
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>,
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a minimal Fourier basis for annual data
#  using 3 basis functions
yearbasis3 &lt;- create.fourier.basis(c(0,365),
                    axes=list("axesIntervals") )
#  plot the basis
oldpar &lt;- par(no.readonly=TRUE)
plot(yearbasis3)

# Identify the months with letters
plot(yearbasis3, axes=list('axesIntervals', labels=monthLetters))

# The same labels as part of the basis object
yearbasis3. &lt;- create.fourier.basis(c(0,365),
       axes=list("axesIntervals", labels=monthLetters) )
plot(yearbasis3.)

# set up the Fourier basis for the monthly temperature data,
#  using 9 basis functions with period 12 months.
monthbasis &lt;- create.fourier.basis(c(0,12), 9, 12.0)

#  plot the basis
plot(monthbasis)

# Create a false Fourier basis using 1 basis function.
falseFourierBasis &lt;- create.fourier.basis(nbasis=1)
#  plot the basis:  constant
plot(falseFourierBasis)
par(oldpar)
</code></pre>

<hr>
<h2 id='create.monomial.basis'>
Create a Monomial Basis
</h2><span id='topic+create.monomial.basis'></span>

<h3>Description</h3>

<p>Creates a set of basis functions consisting of powers
of the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.monomial.basis(rangeval=c(0, 1), nbasis=NULL,
         exponents=NULL, dropind=NULL, quadvals=NULL,
         values=NULL, basisvalues=NULL, names='monomial',
         axes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.monomial.basis_+3A_rangeval">rangeval</code></td>
<td>

<p>a vector of length 2 containing the initial and final
values of the interval over which the functional
data object can be evaluated.
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_nbasis">nbasis</code></td>
<td>

<p>the number of basis functions = <code>length(exponents)</code>.  Default =
if(is.null(exponents)) 2 else length(exponents).
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_exponents">exponents</code></td>
<td>

<p>the nonnegative integer powers to be used.  By default,
these are 0, 1, 2, ..., (nbasis-1).
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_dropind">dropind</code></td>
<td>

<p>a vector of integers specifiying the basis functions to be dropped,
if any.  For example, if it is required that a function be zero at
the left boundary when rangeval[1] = 0, this is achieved by dropping
the first basis function, the only one that is nonzero at that
point.
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_quadvals">quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of quadrature points for numerical evaluation of the penalty
integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to 1, 4, 2, 4, ..., 2, 4,
1.
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_values">values</code></td>
<td>

<p>a list of matrices with one row for each row of <code>quadvals</code> and
one column for each basis function.  The elements of the list
correspond to the basis functions and their derivatives evaluated at
the quadrature points contained in the first column of
<code>quadvals</code>.
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_basisvalues">basisvalues</code></td>
<td>

<p>A list of lists, allocated by code such as vector(&quot;list&quot;,1).  This
field is designed to avoid evaluation of a basis system repeatedly
at a set of argument values.  Each list within the vector
corresponds to a specific set of argument values, and must have at
least two components, which may be tagged as you wish.  'The first
component in an element of the list vector contains the argument
values.  The second component in an element of the list vector
contains a matrix of values of the basis functions evaluated at the
arguments in the first component.  The third and subsequent
components, if present, contain matrices of values their derivatives
up to a maximum derivative order.  Whenever function getbasismatrix
is called, it checks the first list in each row to see, first, if
the number of argument values corresponds to the size of the first
dimension, and if this test succeeds, checks that all of the
argument values match.  This takes time, of course, but is much
faster than re-evaluation of the basis system.  Even this time can
be avoided by direct retrieval of the desired array.  For example,
you might set up a vector of argument values called &quot;evalargs&quot; along
with a matrix of basis function values for these argument values
called &quot;basismat&quot;.  You might want too use names like &quot;args&quot; and
&quot;values&quot;, respectively for these.  You would then assign them to
<code>basisvalues</code> with code such as the following:
</p>
<p>basisobj$basisvalues &lt;- vector(&quot;list&quot;,1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs,
values=basismat)
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_names">names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a simple stem used to construct such a vector.
</p>
<p>For <code>monomial</code> bases, this defaults to paste('monomial',
1:nbreaks, sep=&rdquo;).
</p>
</td></tr>
<tr><td><code id="create.monomial.basis_+3A_axes">axes</code></td>
<td>

<p>an optional list used by selected <code>plot</code> functions to create
custom <code>axes</code>.  If this <code>axes</code> argument is not
<code>NULL</code>, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>, and
<code>plot.Lfd</code> will create axes via <code>x$axes[[1]]</code> and
<code>x$axes[-1]</code>.  The primary example of this uses
<code>list("axesIntervals", ...)</code>, e.g., with <code>Fourier</code> bases
to create <code>CanadianWeather</code> plots.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a basis object with the type <code>monom</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code>link{create.basis}</code>
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>,
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>,
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>,
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## simplest example: one constant 'basis function'
##
m0 &lt;- create.monomial.basis(nbasis=1)
plot(m0)

##
## Create a monomial basis over the interval [-1,1]
##  consisting of the first three powers of t
##
basisobj &lt;- create.monomial.basis(c(-1,1), 5)
#  plot the basis
oldpar &lt;- par(no.readonly=TRUE)
plot(basisobj)

##
## rangeval of class Date or POSIXct
##
# Date
invasion1 &lt;- as.Date('1775-09-04')
invasion2 &lt;- as.Date('1812-07-12')
earlyUS.Canada &lt;- c(invasion1, invasion2)
BspInvade1 &lt;- create.monomial.basis(earlyUS.Canada)

# POSIXct
AmRev.ct &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev1.ct &lt;- create.monomial.basis(AmRev.ct)
par(oldpar)
</code></pre>

<hr>
<h2 id='create.polygonal.basis'>
Create a Polygonal Basis
</h2><span id='topic+create.polygonal.basis'></span>

<h3>Description</h3>

<p>A basis is set up for constructing polygonal lines, consisting of
straight line segments that join together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.polygonal.basis(rangeval=NULL, argvals=NULL, dropind=NULL,
        quadvals=NULL, values=NULL, basisvalues=NULL, names='polygon',
        axes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.polygonal.basis_+3A_rangeval">rangeval</code></td>
<td>

<p>a numeric vector of length 2 defining the interval over which the
functional data object can be evaluated;  default value is
<code>if(is.null(argvals)) 0:1 else range(argvals)</code>.
</p>
<p>If <code>length(rangeval) == 1</code> and <code>rangeval &lt;= 0</code>, this is an
error.  Otherwise, if <code>length(rangeval) == 1</code>, <code>rangeval</code>
is replaced by <code>c(0,rangeval)</code>.
</p>
<p>If length(rangeval)&gt;2 and <code>argvals</code> is not provided, this extra
long <code>rangeval</code> argument is assigned to <code>argvals</code>, and
then <code>rangeval = range(argvale)</code>.
</p>
</td></tr>
<tr><td><code id="create.polygonal.basis_+3A_argvals">argvals</code></td>
<td>

<p>a strictly increasing vector of argument values at which line
segments join to form a polygonal line.
</p>
</td></tr>
<tr><td><code id="create.polygonal.basis_+3A_dropind">dropind</code></td>
<td>

<p>a vector of integers specifiying the basis functions to
be dropped, if any.  For example, if it is required that
a function be zero at the left boundary, this is achieved
by dropping the first basis function, the only one that
is nonzero at that point.
</p>
</td></tr>
<tr><td><code id="create.polygonal.basis_+3A_quadvals">quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of quadrature points for numerical evaluation of the penalty
integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to These are proportional
to 1, 4, 2, 4, ..., 2, 4, 1.
</p>
</td></tr>
<tr><td><code id="create.polygonal.basis_+3A_values">values</code></td>
<td>

<p>a list containing the basis functions and their derivatives
evaluated at the quadrature points contained in the first
column of <code> quadvals </code>.
</p>
</td></tr>
<tr><td><code id="create.polygonal.basis_+3A_basisvalues">basisvalues</code></td>
<td>

<p>A list of lists, allocated by code such as vector(&quot;list&quot;,1).  This
is designed to avoid evaluation of a basis system repeatedly
at a set of argument values.  Each sublist corresponds to a specific
set of argument values, and must have at least two components, which
may be named as you wish.  The first component of a sublist contains
the argument values.  The second component contains a matrix of
values of the basis functions evaluated at the arguments in the
first component.  The third and subsequent components, if present,
contain matrices of values their derivatives up to a maximum
derivative order.  Whenever function <code>getbasismatrix</code> is
called, it checks the first list in each row to see, first, if the
number of argument values corresponds to the size of the first
dimension, and if this test succeeds, checks that all of the
argument values match.  This takes time, of course, but is much
faster than re-evaluation of the basis system.  Even this time can
be avoided by direct retrieval of the desired array. For example,
you might set up a vector of argument values called &quot;evalargs&quot; along
with a matrix of basis function values for these argument values
called &quot;basismat&quot;.  You might want too use tags like &quot;args&quot; and
&quot;values&quot;, respectively for these.  You would then assign them to
<code>basisvalues</code> with code such as the following:
</p>
<p>basisobj$basisvalues &lt;- vector(&quot;list&quot;,1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs, values=basismat)
</p>
</td></tr>
<tr><td><code id="create.polygonal.basis_+3A_names">names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a single character string to which <code>1:nbasis</code> are
appended as <code>paste(names, 1:nbasis, sep=''</code>.  For example, if
<code>nbasis = 4</code>, this defaults to <code>c('polygon1', 'polygon2',
      'polygon3', 'polygon4')</code>.
</p>
</td></tr>
<tr><td><code id="create.polygonal.basis_+3A_axes">axes</code></td>
<td>

<p>an optional list used by selected <code>plot</code> functions to create
custom <code>axes</code>.  If this <code>axes</code> argument is not
<code>NULL</code>, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>, and
<code>plot.Lfd</code> will create axes via <code>x$axes[[1]]</code> and
<code>x$axes[-1]</code>.  The primary example of this uses
<code>list("axesIntervals", ...)</code>, e.g., with <code>Fourier</code> bases
to create <code>CanadianWeather</code> plots
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual basis functions consist of triangles, each with its apex
over an argument value. Note that in effect the polygonal basis is
identical to a B-spline basis of order 2 and a knot or break value at
each argument value.  The range of the polygonal basis is set to the
interval defined by the smallest and largest argument values.
</p>


<h3>Value</h3>

<p>a basis object with the type <code>polyg</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>,
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>,
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>,
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>,
<code><a href="#topic+create.power.basis">create.power.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Create a polygonal basis over the interval [0,1]
#  with break points at 0, 0.1, ..., 0.95, 1
(basisobj &lt;- create.polygonal.basis(seq(0,1,0.1)))
#  plot the basis
oldpar &lt;- par(no.readonly=TRUE)
plot(basisobj)
par(oldpar)
</code></pre>

<hr>
<h2 id='create.power.basis'>
Create a Power Basis Object
</h2><span id='topic+create.power.basis'></span>

<h3>Description</h3>

<p>The basis system is a set of powers of argument $x$.  That is, a basis
function would be <code>x^exponent</code>, where <code>exponent</code> is a vector
containing a set of powers or exponents.  The power basis would
normally only be used for positive values of x, since the power of a
negative number is only defined for nonnegative integers, and the
exponents here can be any real numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.power.basis(rangeval=c(0, 1), nbasis=NULL, exponents=NULL,
            dropind=NULL, quadvals=NULL, values=NULL,
            basisvalues=NULL, names='power', axes=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.power.basis_+3A_rangeval">rangeval</code></td>
<td>

<p>a vector of length 2 with the first element being the lower limit of
the range of argument values, and the second the upper limit.  Of
course the lower limit must be less than the upper limit.
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_nbasis">nbasis</code></td>
<td>

<p>the number of basis functions = <code>length(exponents)</code>.  Default =
if(is.null(exponents)) 2 else length(exponents).
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_exponents">exponents</code></td>
<td>

<p>a numeric vector of length <code>nbasis</code> containing the powers of
<code>x</code> in the basis.
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_dropind">dropind</code></td>
<td>

<p>a vector of integers specifiying the basis functions to be dropped,
if any.  For example, if it is required that a function be zero at
the left boundary, this is achieved by dropping the first basis
function, the only one that is nonzero at that point.
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_quadvals">quadvals</code></td>
<td>

<p>a matrix with two columns and a number of rows equal to the number
of quadrature points for numerical evaluation of the penalty
integral.  The first column of <code>quadvals</code> contains the
quadrature points, and the second column the quadrature weights.  A
minimum of 5 values are required for each inter-knot interval, and
that is often enough.  For Simpson's rule, these points are equally
spaced, and the weights are proportional to 1, 4, 2, 4, ..., 2, 4,
1.
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_values">values</code></td>
<td>

<p>a list of matrices with one row for each row of <code>quadvals</code> and
one column for each basis function.  The elements of the list
correspond to the basis functions and their derivatives evaluated at
the quadrature points contained in the first column of
<code>quadvals</code>.
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_basisvalues">basisvalues</code></td>
<td>

<p>A list of lists, allocated by code such as vector(&quot;list&quot;,1).  This
field is designed to avoid evaluation of a basis system repeatedly
at a set of argument values.  Each list within the vector
corresponds to a specific set of argument values, and must have at
least two components, which may be tagged as you wish.  'The first
component in an element of the list vector contains the argument
values.  The second component in an element of the list vector
contains a matrix of values of the basis functions evaluated at the
arguments in the first component.  The third and subsequent
components, if present, contain matrices of values their derivatives
up to a maximum derivative order.  Whenever function getbasismatrix
is called, it checks the first list in each row to see, first, if
the number of argument values corresponds to the size of the first
dimension, and if this test succeeds, checks that all of the
argument values match.  This takes time, of course, but is much
faster than re-evaluation of the basis system.  Even this time can
be avoided by direct retrieval of the desired array.  For example,
you might set up a vector of argument values called &quot;evalargs&quot; along
with a matrix of basis function values for these argument values
called &quot;basismat&quot;.  You might want too use names like &quot;args&quot; and
&quot;values&quot;, respectively for these.  You would then assign them to
<code>basisvalues</code> with code such as the following:
</p>
<p>basisobj$basisvalues &lt;- vector(&quot;list&quot;,1)
</p>
<p>basisobj$basisvalues[[1]] &lt;- list(args=evalargs,
values=basismat)
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_names">names</code></td>
<td>

<p>either a character vector of the same length as the number of basis
functions or a simple stem used to construct such a vector.
</p>
<p>For <code>power</code> bases, this defaults to paste(power',
0:(nbasis-1), sep=&rdquo;).
</p>
</td></tr>
<tr><td><code id="create.power.basis_+3A_axes">axes</code></td>
<td>

<p>an optional list used by selected <code>plot</code> functions to create
custom <code>axes</code>.  If this <code>axes</code> argument is not
<code>NULL</code>, functions <code>plot.basisfd</code>, <code>plot.fd</code>,
<code>plot.fdSmooth</code> <code>plotfit.fd</code>, <code>plotfit.fdSmooth</code>, and
<code>plot.Lfd</code> will create axes via <code>x$axes[[1]]</code> and
<code>x$axes[-1]</code>.  The primary example of this uses
<code>list("axesIntervals", ...)</code>, e.g., with <code>Fourier</code> bases
to create <code>CanadianWeather</code> plots
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The power basis differs from the monomial
basis in two ways.  First, the powers may be nonintegers.
Secondly, they may be negative.  Consequently, a power
basis is usually used with arguments that only take
positive values, although a zero value can be tolerated
if none of the powers are negative.
</p>


<h3>Value</h3>

<p>a basis object of type <code>power</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
<code><a href="#topic+create.constant.basis">create.constant.basis</a></code>,
<code><a href="#topic+create.exponential.basis">create.exponential.basis</a></code>,
<code><a href="#topic+create.fourier.basis">create.fourier.basis</a></code>,
<code><a href="#topic+create.monomial.basis">create.monomial.basis</a></code>,
<code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Create a power basis over the interval [1e-7,1]
#  with powers or exponents -1, -0.5, 0, 0.5 and 1
basisobj &lt;- create.power.basis(c(1e-7,1), 5, seq(-1,1,0.5))
#  plot the basis
oldpar &lt;- par(no.readonly=TRUE)
plot(basisobj)
par(oldpar)
</code></pre>

<hr>
<h2 id='CSTR'>
Continuously Stirred Tank Reactor
</h2><span id='topic+CSTR'></span><span id='topic+CSTR2in'></span><span id='topic+CSTR2'></span><span id='topic+CSTRfn'></span><span id='topic+CSTRfitLS'></span><span id='topic+CSTRres'></span><span id='topic+CSTRsse'></span>

<h3>Description</h3>

<p>Functions for solving the Continuously Stirred Tank Reactor
(CSTR) Ordinary Differential Equations (ODEs).  A solution for
observations where metrology error is assumed to be negligible can be
obtained via lsoda(y, Time, CSTR2, parms);  CSTR2 calls CSTR2in.  When
metrology error can not be ignored, use CSTRfn (which calls
CSTRfitLS).  To estimate parameters in the CSTR differential equation
system (kref, EoverR, a, and / or b), pass CSTRres to nls.  If nls
fails to converge, first use optim or nlminb with CSTRsse, then pass
the estimates to nls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CSTR2in(Time, condition =
   c('all.cool.step', 'all.hot.step', 'all.hot.ramp', 'all.cool.ramp',
     'Tc.hot.exponential', 'Tc.cool.exponential', 'Tc.hot.ramp',
     'Tc.cool.ramp', 'Tc.hot.step', 'Tc.cool.step'),
   tau=1)
CSTR2(Time, y, parms)

CSTRfitLS(coef, datstruct, fitstruct, lambda, gradwrd=FALSE)
CSTRfn(parvec, datstruct, fitstruct, CSTRbasis, lambda, gradwrd=TRUE)
CSTRres(kref=NULL, EoverR=NULL, a=NULL, b=NULL,
        datstruct, fitstruct, CSTRbasis, lambda, gradwrd=FALSE)
CSTRsse(par, datstruct, fitstruct, CSTRbasis, lambda)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CSTR_+3A_time">Time</code></td>
<td>

<p>The time(s) for which computation(s) are desired
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_condition">condition</code></td>
<td>

<p>a character string with the name of one of ten preprogrammed input
scenarios.
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_tau">tau</code></td>
<td>

<p>time for exponential decay of exp(-1) under condition =
'Tc.hot.exponential' or 'Tc.cool.exponential';  ignored for other
values of 'condition'.
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_y">y</code></td>
<td>

<p>Either a vector of length 2 or a matrix with 2 columns giving the
observation(s) on Concentration and Temperature for which
computation(s) are desired
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_parms">parms</code></td>
<td>

<p>a list of CSTR model parameters passed via the lsoda 'parms'
argument.  This list consists of the following 3 components:
</p>

<dl>
<dt>fitstruct</dt><dd>
<p>a list with 12 components describing the structure for fitting.
This is the same as the 'fitstruct' argument of 'CSTRfitLS' and
'CSTRfn' without the 'fit' component;  see below.
</p>
</dd>
<dt>condition</dt><dd>
<p>a character string identifying the inputs to the simulation.
Currently, any of the following are accepted:  'all.cool.step',
'all.hot.step', 'all.hot.ramp', 'all.cool.ramp',
'Tc.hot.exponential', 'Tc.cool.exponential', 'Tc.hot.ramp',
'Tc.cool.ramp', 'Tc.hot.step', or 'Tc.cool.step'.
</p>
</dd>
<dt>Tlim</dt><dd>
<p>end time for the computations.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="CSTR_+3A_coef">coef</code></td>
<td>

<p>a matrix with one row for each basis function in fitstruct and
columns c(&quot;Conc&quot;, &quot;Temp&quot;) or a vector form of such a matrix.
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_datstruct">datstruct</code></td>
<td>

<p>a list describing the structure of the data.  CSTRfitLS uses the
following components:
</p>

<dl>
<dt>basismat, Dbasismat</dt><dd>
<p>basis coefficent matrices with one row for each observation and
one column for each basis vector.  These are typically produced
by code something like the following:
</p>
<p>basismat &lt;- eval.basis(Time, CSTRbasis)
</p>
<p>Dbasismat &lt;- eval.basis(Time, CSTRbasis, 1)
</p>
</dd>
<dt>Cwt, Twt</dt><dd>
<p>scalar variances of 'fd' functional data objects for
Concentration and Temperature used to place the two series on
comparable scales.
</p>
</dd>
<dt>y</dt><dd>
<p>a matrix with 2 columns for the observed 'Conc' and 'Temp'.
</p>
</dd>
<dt>quadbasismat, Dquadbasismat</dt><dd>
<p>basis coefficient matrices with one row for each quadrature
point and one column for each basis vector.  These are typically
produced by code something like the following:
</p>
<p>quadbasismat &lt;- eval.basis(quadpts, CSTRbasis)
</p>
<p>Dquadbasismat &lt;- eval.basis(quadpts, CSTRbasis, 1)
</p>
</dd>
<dt>Fc, F., CA0, T0, Tc</dt><dd>
<p>input series for CSTRfitLS and CSTRfn as the output list
produced by CSTR2in.
</p>
</dd>
<dt>quadpts</dt><dd>
<p>Quadrature points created by 'quadset' and stored in
CSTRbasis[[&quot;quadvals&quot;]][, &quot;quadpts&quot;].
</p>
</dd>
<dt>quadwts</dt><dd>
<p>Quadrature weights created by 'quadset' and stored in
CSTRbasis[[&quot;quadvals&quot;]][, &quot;quadpts&quot;].
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="CSTR_+3A_fitstruct">fitstruct</code></td>
<td>

<p>a list with 14 components:
</p>

<dl>
<dt>V</dt><dd>
<p>volume in cubic meters
</p>
</dd>
<dt>Cp</dt><dd>
<p>concentration in cal/(g.K) for computing betaTC and betaTT;  see
details below.
</p>
</dd>
<dt>rho</dt><dd>
<p>density in grams per cubic meter
</p>
</dd>
<dt>delH</dt><dd>
<p>cal/kmol
</p>
</dd>
<dt>Cpc</dt><dd>
<p>concentration in cal/(g.K) used for computing alpha;  see
details below.
</p>
</dd>
<dt>Tref</dt><dd>
<p>reference temperature.
</p>
</dd>
<dt>kref</dt><dd>
<p>reference value
</p>
</dd>
<dt>EoverR</dt><dd>
<p>E/R in units of K/1e4
</p>
</dd>
<dt>a</dt><dd>
<p>scale factor for Fco in alpha;  see details below.
</p>
</dd>
<dt>b</dt><dd>
<p>power of Fco in alpha;  see details below.
</p>
</dd>
<dt>Tcin</dt><dd>
<p>Tc input temperature vector.
</p>
</dd>
<dt>fit</dt><dd>
<p>logical vector of length 2 indicating whether Contentration or
Temperature or both are considered to be observed and used for
parameter estimation.
</p>
</dd>
<dt>coef0</dt><dd>
<p>data.frame(Conc = Cfdsmth[[&quot;coef&quot;]], Temp = Tfdsmth[[&quot;coef&quot;]]),
where Cfdsmth and Tfdsmth are the objects returned by
smooth.basis when applied to the observations on Conc and Temp,
respectively.
</p>
</dd>
<dt>estimate</dt><dd>
<p>logical vector of length 4 indicating which of kref, EoverR, a
and b are taken from 'parvec';  all others are taken from
'fitstruct'.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="CSTR_+3A_lambda">lambda</code></td>
<td>

<p>a 2-vector of rate parameters 'lambdaC' and 'lambdaT'.
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_gradwrd">gradwrd</code></td>
<td>

<p>a logical scalar TRUE if the gradient is to be returned as well as
the residuals matrix.
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_parvec">parvec</code>, <code id="CSTR_+3A_par">par</code></td>
<td>

<p>initial values for the parameters specified by fitstruct[[
&quot;estimate&quot;]] to be estimated.
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_cstrbasis">CSTRbasis</code></td>
<td>

<p>Quadrature basis returned by 'quadset'.
</p>
</td></tr>
<tr><td><code id="CSTR_+3A_kref">kref</code>, <code id="CSTR_+3A_eoverr">EoverR</code>, <code id="CSTR_+3A_a">a</code>, <code id="CSTR_+3A_b">b</code></td>
<td>

<p>the kref, EoverR, a, and b coefficients of the CSTR model as
individual arguments of CSTRres to support using 'nls' with the CSTR
model.  Those actually provided by name will be estimated;  the
others will be taken from '.fitstruct';  see details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ramsay et al. (2007) considers the following differential equation
system for a continuously stirred tank reactor (CSTR):
</p>
<p>dC/dt = (-betaCC(T, F.in)*C + F.in*C.in)
</p>
<p>dT/dt = (-betaTT(Fcvec, F.in)*T + betaTC(T, F.in)*C +
alpha(Fcvec)*T.co)
</p>
<p>where
</p>
<p>betaCC(T, F.in) = kref*exp(-1e4*EoverR*(1/T - 1/Tref)) + F.in
</p>
<p>betaTT(Fcvec, F.in) = alpha(Fcvec) + F.in
</p>
<p>betaTC(T, F.in) = (-delH/(rho*Cp))*betaCC(T, F.in)
</p>
<p style="text-align: center;"><code class="reqn">
    alpha(Fcvec) = (a*Fcvec^(b+1) / (K1*(Fcvec + K2*Fcvec^b)))
  </code>
</p>

<p>K1 = V*rho*Cp
</p>
<p>K2 = 1/(2*rhoc*Cpc)
</p>
<p>The four functions CSTR2in, CSTR2, CSTRfitLS, and CSTRfn compute
coefficients of basis vectors for two different solutions to this set
of differential equations.  Functions CSTR2in and CSTR2 work with
'lsoda' to provide a solution to this system of equations.  Functions
CSTSRitLS and CSTRfn are used to estimate parameters to fit this
differential equation system to noisy data.  These solutions are
conditioned on specified values for kref, EoverR, a, and b.  The other
function, CSTRres, support estimation of these parameters using
'nls'.
</p>
<p>CSTR2in translates a character string 'condition' into a data.frame
containing system inputs for which the reaction of the system is
desired.  CSTR2 calls CSTR2in and then computes the corresponding
predicted first derivatives of CSTR system outputs according to the
right hand side of the system equations.  CSTR2 can be called by
'lsoda' in the 'deSolve' package to actually solve the system of
equations.  To solve the CSTR equations for another set of inputs, the
easiest modification might be to change CSTR2in to return the desired
inputs.  Another alternative would be to add an argument
'input.data.frame' that would be used in place of CSTR2in when
present.
</p>
<p>CSTRfitLS computes standardized residuals for systems outputs Conc,
Temp or both as specified by fitstruct[[&quot;fit&quot;]], a logical vector of
length 2.  The standardization is sqrt(datstruct[[&quot;Cwt&quot;]]) and / or
sqrt(datstruct[[&quot;Twt&quot;]]) for Conc and Temp, respectively.  CSTRfitLS
also returns standardized deviations from the predicted first
derivatives for Conc and Temp.
</p>
<p>CSTRfn uses a Gauss-Newton optimization to estimates the coefficients
of CSTRbasis to minimize the weighted sum of squares of residuals
returned by CSTRfitLS.
</p>
<p>CSTRres provides an interface between 'nls' and 'CSTRfn'.  It gets the
parameters to be estimated via the official function arguments, kref,
EoverR, a, and / or b.  The subset of these parameters to estimate must
be specified both directly in the function call to 'nls' and
indirectly via fitstruct[[&quot;estimate&quot;]].  CSTRres gets the other CSTRfn
arguments (datstruct, fitstruct, CSTRbasis, and lambda) via the 'data'
argument of 'nls'.
</p>
<p>CSTRsse computes sum of squares of residuals for use with optim or
nlminb.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>CSTR2in</code></td>
<td>

<p>a matrix with number of rows = length(Time) and columns for F., CA0,
T0, Tcin, and Fc.  This gives the inputs to the CSTR simulation for
the chosen 'condition'.
</p>
</td></tr>
<tr><td><code>CSTR2</code></td>
<td>

<p>a list with one component being a matrix with number of rows =
length(tobs) and 2 columns giving the first derivatives of Conc and
Temp according to the right hand side of the differential equation.
CSTR2 calls CSTR2in to get its inputs.
</p>
</td></tr>
<tr><td><code>CSTRfitLS</code></td>
<td>

<p>a list with one or two components as follows:
</p>

<dl>
<dt>res</dt><dd>
<p>a list with two components
</p>
<p>Sres = a matrix giving the residuals between observed and
predicted datstruct[[&quot;y&quot;]] divided by sqrt(datstruct[[c(&quot;Cwt&quot;,
&quot;Twt&quot;)]]) so the result is dimensionless.  dim(Sres) =
dim(datstruct[[&quot;y&quot;]]).  Thus, if datstruct[[&quot;y&quot;]] has only one
column, 'Sres' has only one column.
</p>
<p>Lres = a matrix with two columns giving the difference between
left and right hand sides of the CSTR differential equation at
all the quadrature points.  dim(Lres) = c(nquad, 2).
</p>
</dd>
<dt>Dres</dt><dd>
<p>If gradwrd=TRUE, a list with two components:
</p>
<p>DSres = a matrix with one row for each element of res[[&quot;Sres&quot;]]
and two columns for each basis function.
</p>
<p>DLres = a matrix with two rows for each quadrature point and two
columns for each basis function.
</p>
<p>If gradwrd=FALSE, this component is not present.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code>CSTRfn</code></td>
<td>

<p>a list with five components:
</p>

<dl>
<dt>res</dt><dd>
<p>the 'res' component of the final 'CSTRfitLS' object reformatted
with its component Sres first followed by Lres, using
with(CSTRfitLS(...)[[&quot;res&quot;]], c(Sres, Lres)).
</p>
</dd>
<dt>Dres</dt><dd>
<p>one of two very different gradient matrices depending on the
value of 'gradwrd'.
</p>
<p>If gradwrd = TRUE, Dres is a matrix with one row for each
observation value to match and one column for each parameter
taken from 'parvec' per fitstruct[[&quot;estimate&quot;]].  Also, if
fitstruct[[&quot;fit&quot;]] = c(1,1), CSTRfn tries to  match both
Concentration and Temperature, and rows corresponding to
Concentration come first following by rows corresponding to
Temperature.
</p>
<p>If gradwrd = FALSE, this is the 'Dres' component of the final
'CSTRfitLS' object reformatted as follows:
</p>
<p>Dres &lt;- with(CSTRfitLS(...)[[&quot;Dres&quot;]], rbind(DSres, DLres))
</p>
</dd>
<dt>fitstruct</dt><dd>
<p>a list components matching the 'fitstruct' input, with
coefficients estimated replaced by their initial values from
parvec and with coef0 replace by its final estimate.
</p>
</dd>
<dt>df</dt><dd>
<p>estimated degrees of freedom as the trace of the appropriate
matrix.
</p>
</dd>
<dt>gcv</dt><dd>
<p>the Generalized cross validation estimate of the mean square
error, as discussed in Ramsay and Silverman (2006, sec. 5.4).
</p>
</dd>
</dl>

</td></tr>
<tr><td><code>CSTRres</code></td>
<td>

<p>the 'res' component of CSTRfd(...) as a column vector.  This allows
us to use 'nls' with the CSTR model.  This can be especially useful
as 'nls' has several helper functions to facilitate evaluating
goodness of fit and and uncertainty in parameter estimates.
</p>
</td></tr>
<tr><td><code>CSTRsse</code></td>
<td>

<p>sum(res*res) from CSTRfd(...).  This allows us to use 'optim' or
'nlminb' with the CSTR model.  This can also be used to obtain
starting values for 'nls' in cases where 'nls' fails to converge
from the initial provided starting values.  Apart from 'par', the
other arguments 'datstruct', 'fitstruct', 'CSTRbasis', and 'lambda',
must be passed via '...' in 'optim' or 'nlminb'.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, J. O., Hooker, G., Cao, J. and Campbell, D. (2007) Parameter
estimation for differential equations: A generalized smoothing
approach (with discussion). <em>Journal of the Royal Statistical
Society</em>, Series B, 69, 741-796.
</p>
<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="deSolve.html#topic+lsoda">lsoda</a></code>
<code><a href="stats.html#topic+nls">nls</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###
###
### 1.  lsoda(y, times, func=CSTR2, parms=...)
###
###
#  The system of two nonlinear equations has five forcing or
#  input functions.
#  These equations are taken from
#  Marlin, T. E. (2000) Process Control, 2nd Edition, McGraw Hill,
#  pages 899-902.
##
##  Set up the problem
##
fitstruct &lt;- list(V    = 1.0,#  volume in cubic meters
                  Cp   = 1.0,#  concentration in cal/(g.K)
                  rho  = 1.0,#  density in grams per cubic meter
                  delH = -130.0,# cal/kmol
                  Cpc  = 1.0,#  concentration in cal/(g.K)
                  rhoc = 1.0,#  cal/kmol
                  Tref = 350)#  reference temperature
#  store true values of known parameters
EoverRtru = 0.83301#   E/R in units K/1e4
kreftru   = 0.4610 #   reference value
atru      = 1.678#     a in units (cal/min)/K/1e6
btru      = 0.5#       dimensionless exponent

#% enter these parameter values into fitstruct

fitstruct[["kref"]]   = kreftru#
fitstruct[["EoverR"]] = EoverRtru#  kref = 0.4610
fitstruct[["a"]]      = atru#       a in units (cal/min)/K/1e6
fitstruct[["b"]]      = btru#       dimensionless exponent

Tlim  = 64#    reaction observed over interval [0, Tlim]
delta = 1/12#  observe every five seconds
tspan = seq(0, Tlim, delta)#

coolStepInput &lt;- CSTR2in(tspan, 'all.cool.step')

#  set constants for ODE solver

#  cool condition solution
#  initial conditions

Cinit.cool = 1.5965#  initial concentration in kmol per cubic meter
Tinit.cool = 341.3754# initial temperature in deg K
yinit = c(Conc = Cinit.cool, Temp=Tinit.cool)

#  load cool input into fitstruct

fitstruct[["Tcin"]] = coolStepInput[, "Tcin"];

#  solve  differential equation with true parameter values

if (require(deSolve)) {
coolStepSoln &lt;- lsoda(y=yinit, times=tspan, func=CSTR2,
  parms=list(fitstruct=fitstruct, condition='all.cool.step', Tlim=Tlim) )
}
###
###
### 2.  CSTRfn
###
###

# See the script in '~R\library\fda\scripts\CSTR\CSTR_demo.R'
#  for more examples.

</code></pre>

<hr>
<h2 id='cumfd'>
Compute a Cumulative Distribution Functional Data Object
</h2><span id='topic+cumfd'></span>

<h3>Description</h3>

<p>Function <code>smooth.morph()</code> maps a sorted set of variable values inside
a closed interval into a set of equally-spaced probabilities in [0,1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumfd(xrnd, xrng, nbreaks=7, nfine=101)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumfd_+3A_xrnd">xrnd</code></td>
<td>
<p>A vector of variable unsorted values.</p>
</td></tr>
<tr><td><code id="cumfd_+3A_xrng">xrng</code></td>
<td>
<p>A vector of length 2 containing the boundary values.</p>
</td></tr>
<tr><td><code id="cumfd_+3A_nbreaks">nbreaks</code></td>
<td>
<p>The number of knots to use to define object <code>WfdPar</code> in
function <code>smooth.morph()</code>.</p>
</td></tr>
<tr><td><code id="cumfd_+3A_nfine">nfine</code></td>
<td>
<p>The number of equally spaced values spanning xrng.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the values of x within the interior of xrng are used 
in order to avoid distortion due to boundary inflation or deflation.
</p>


<h3>Value</h3>

<p>A named list of length 2 containing:
</p>
<table role = "presentation">
<tr><td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the monotone function that it
defines.
</p>
</td></tr>
<tr><td><code>cdffine</code></td>
<td>

<p>a vector of length nfine of an equally spaced mesh of values for
the cumulative distribution function.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.morph">smooth.morph</a></code>,
<code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+register.fd">register.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  see the use of smooth.morph in landmarkreg.R
xrnd &lt;- rbeta(50, 2, 5)
xrng &lt;- c(0,1)
hist(xrnd)
range(xrnd)
cdfd &lt;- cumfd(xrnd, xrng)
</code></pre>

<hr>
<h2 id='cycleplot.fd'>
Plot Cycles for a Periodic Bivariate Functional Data Object
</h2><span id='topic+cycleplot.fd'></span>

<h3>Description</h3>

<p>A plotting function for data such as the knee-hip angles in
the gait data or temperature-precipitation curves for the
weather data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycleplot.fd(fdobj, matplt=TRUE, nx=201, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cycleplot.fd_+3A_fdobj">fdobj</code></td>
<td>

<p>a bivariate functional data object to be plotted.
</p>
</td></tr>
<tr><td><code id="cycleplot.fd_+3A_matplt">matplt</code></td>
<td>

<p>if TRUE, all cycles are plotted simultaneously; otherwise
each cycle in turn is plotted.
</p>
</td></tr>
<tr><td><code id="cycleplot.fd_+3A_nx">nx</code></td>
<td>

<p>the number of argument values in a fine mesh to be
plotted.  Increase the default number of 201 if
the curves have a lot of detail in them.
</p>
</td></tr>
<tr><td><code id="cycleplot.fd_+3A_...">...</code></td>
<td>

<p>additional plotting parameters such as axis labels and
etc. that are used in all plot functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Side Effects</h3>

<p>A plot of the cycles
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fd">plot.fd</a></code>, 
<code><a href="#topic+plotfit.fd">plotfit.fd</a></code>, 
</p>

<hr>
<h2 id='Data2fd'>
Create smooth functions that fit scatterplot data.
</h2><span id='topic+Data2fd'></span>

<h3>Description</h3>

<p>The function converts scatter plot data into one or a set of curves that do
a satisfactory job of representing their corresponding abscissa and ordinate 
values by smooth curves.  It returns a list object of class <code>fdSmooth</code> 
that contains curves defined by functional data objects of class <code>fd</code>
as well as a variety of other results related to the data smoothing process.
</p>
<p>The function tries to do as much for the user as possible before setting up a 
call to function <code>smooth.basisPar</code>. This is achieved by an initial call
to function <code>argvalsSwap</code> that examines arguments <code>argvals</code> that 
contains abscissa values and <code>y</code> that contains ordinate values.  
</p>
<p>If the arguments are provided in an order that is not the one above, 
<code>Data2fd</code> attempts to swap argument positions to provide the correct 
order. A warning message is returned if this swap takes place.  Any such 
automatic decision, though, has the possibility of being wrong, and the 
results should be carefully checked.  
</p>
<p>Preferably, the order of the arguments should be respected: <code>argvals</code> 
comes first and <code>y</code> comes second.
</p>
<p>Be warned that the result that the <code>fdSmooth</code> object that is returned may 
not define a satisfactory smooth of the data, and consequently that it may be 
necessary to use the more sophisticated data smoothing function 
<code>smooth.basis</code> instead.  Its help file provides a great deal more 
information than is provided here.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Data2fd(argvals=NULL, y=NULL, basisobj=NULL, nderiv=NULL,
          lambda=3e-8/diff(as.numeric(range(argvals))),
          fdnames=NULL, covariates=NULL, method="chol")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Data2fd_+3A_argvals">argvals</code></td>
<td>
<p>a set of argument values.  If this is a vector, the same set of 
argument values is used for all columns of <code>y</code>.  If <code>argvals</code> is a 
matrix, the columns correspond to the columns of <code>y</code>, and contain the 
argument values for that replicate or case.
Dimensions for <code>argvals</code> must match the first dimensions of <code>y</code>, 
though <code>y</code> can have more dimensions.  For example, if dim(y) = 
c(9, 5, 2), <code>argvals</code> can be a vector of length 9 or a matrix of 
dimensions c(9, 5) or an array of dimensions c(9, 5, 2).</p>
</td></tr>
<tr><td><code id="Data2fd_+3A_y">y</code></td>
<td>
<p>an array containing sampled values of curves.  If <code>y</code> is a 
vector, only one replicate and variable are assumed.  If <code>y</code> is a 
matrix, rows must correspond to argument values and columns to replications 
or cases, and it will be assumed that there is only one variable per 
observation.  If <code>y</code> is a three-dimensional array, the first dimension 
(rows) corresponds to argument values, the second (columns) to replications, 
and the third (layers) to variables within replications.  Missing values are 
permitted, and the number of values may vary from one replication to 
another.  If this is the case, the number of rows must equal the maximum 
number of argument values, and columns of <code>y</code> having fewer values 
must be padded out with NA's.</p>
</td></tr>
<tr><td><code id="Data2fd_+3A_basisobj">basisobj</code></td>
<td>
<p>An object of one of the following classes:
</p>

<dl>
<dt>basisfd</dt><dd><p>a functional basis object (class <code>basisfd</code>).</p>
</dd>
<dt>fd</dt><dd><p>a functional data object (class <code>fd</code>), from which its 
<code>basis</code> component is extracted.</p>
</dd>
<dt>fdPar</dt><dd><p>a functional parameter object (class <code>fdPar</code>), from 
which	its <code>basis</code> component is extracted.</p>
</dd>
<dt>integer</dt><dd><p>an integer giving the order of	a B-spline basis, 
<code>create.bspline.basis(argvals, norder=basisobj)</code></p>
</dd>
<dt>numeric vector</dt><dd><p>specifying the knots for a B-spline basis, 
<code>create.bspline.basis(basisobj)</code></p>
</dd>
<dt>NULL</dt><dd><p>Defaults to create.bspline.basis(argvals).</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="Data2fd_+3A_nderiv">nderiv</code></td>
<td>
<p>Smoothing typically specified as an integer order for the 
derivative whose square is integrated and weighted by <code>lambda</code> to 
smooth.  By default, <code>if basisobj[['type']] == 'bspline'</code>, the 
smoothing operator is <code>int2Lfd(max(0, norder-2)).</code>
</p>
<p>A general linear differential operator can also be supplied.</p>
</td></tr>
<tr><td><code id="Data2fd_+3A_lambda">lambda</code></td>
<td>
<p>weight on the smoothing operator specified by <code>nderiv</code>.</p>
</td></tr>
<tr><td><code id="Data2fd_+3A_fdnames">fdnames</code></td>
<td>
<p>Either a character vector of length 3 or a named list of length 
3.  In either case, the three elements correspond to the following:
</p>

<dl>
<dt>argname</dt><dd><p>name of the argument, e.g. &quot;time&quot; or &quot;age&quot;.</p>
</dd>
<dt>repname</dt><dd><p>a description of the cases, e.g. &quot;reps&quot; or &quot;weather 
stations&quot;.</p>
</dd>
<dt>value</dt><dd><p>the name of the observed function value, e.g. &quot;temperature&quot;.</p>
</dd>
</dl>

<p>If fdnames is a list, the components provide labels for the levels of the 
corresponding dimension of <code>y</code>.</p>
</td></tr>
<tr><td><code id="Data2fd_+3A_covariates">covariates</code></td>
<td>
<p>the observed values in <code>y</code> are assumed to be primarily 
determined by the height of the curve being estimated.  However, from time 
to time certain values can also be influenced by other known variables.  For 
example, multi-year sets of climate variables may be also determined by
the presence of absence of an El Nino event, or a volcanic eruption.One or 
more of these covariates can be supplied as an <code>n</code> by<code>p</code> matrix, 
where <code>p</code> is the number of such covariates.  When such covariates are 
available, the smoothing is called &quot;semi-parametric.&quot;  Matrices or arrays of 
regression coefficients are then estimated that define the impacts of each 
of these covariates for each curve and each variable.</p>
</td></tr>
<tr><td><code id="Data2fd_+3A_method">method</code></td>
<td>
<p>by default the function uses the usual textbook equations for 
computing the coefficients of the basis function expansions.  But, as in 
regression analysis, a price is paid in terms of rounding error for such 
computations since they involved cross-products of  basis function values.  
Optionally, if <code>method</code> is set equal to the string &quot;qr&quot;, the 
computation uses an algorithm based on the qr-decomposition which is more 
accurate, but will require substantially more computing timewhen <code>n</code> is 
large, meaning more than 500 or so.  The defaultis &quot;chol&quot;, referring the 
Choleski decomposition of a symmetric positive definite matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tends to be used in rather simple applications where there is no 
need to control the roughness of the resulting curve with any great finesse.  
The roughness is essentially controlled by how many basis functions are used.  
In more sophisticated applications, it would be better to use the function   
<code><a href="#topic+smooth.basisPar">smooth.basisPar</a></code>.
</p>
<p>It may happen that a value in argvals is outside the basis object interval 
due to rounding error and other causes of small violations.  The code tests
for this and pulls these near values into the interval if they are within
1e-7 times the interval width.
</p>


<h3>Value</h3>

<p>an S3 list object of class <code>fdSmooth</code> defined in file 
<code>smooth.basis1.R</code> containing:
</p>

<dl>
<dt>fd</dt><dd><p>the functional data object defining smooth B-spline curves that
fit the data</p>
</dd>
<dt>df</dt><dd><p>the degrees of freedom in the fits</p>
</dd>
<dt>gcv</dt><dd><p>a generalized cross-validation value</p>
</dd>
<dt>beta</dt><dd><p>the semi-parametric coefficient array</p>
</dd>
<dt>SSE</dt><dd><p>Error sum of squares</p>
</dd>
<dt>penmat</dt><dd><p>the symmetric matrix defining roughness penalty</p>
</dd>
<dt>argvals</dt><dd><p>the argument values</p>
</dd>
<dt>y</dt><dd><p>the array of ordinate values in the scatter-plot</p>
</dd> 
</dl>



<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basisPar">smooth.basisPar</a></code>,
<code><a href="#topic+smooth.basis">smooth.basis</a></code>,
<code><a href="#topic+smooth.basis1">smooth.basis1</a></code>,
<code><a href="#topic+project.basis">project.basis</a></code>,
<code><a href="#topic+smooth.fd">smooth.fd</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+smooth.pos">smooth.pos</a></code>,
<code><a href="#topic+day.5">day.5</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Simplest possible example:  constant function
##
# 1 basis, order 1 = degree 0 = constant function
b1.1 &lt;- create.bspline.basis(nbasis=1, norder=1)
# data values: 1 and 2, with a mean of 1.5
y12 &lt;- 1:2
# smooth data, giving a constant function with value 1.5
fd1.1 &lt;- Data2fd(y12, basisobj=b1.1)
oldpar &lt;- par(no.readonly=TRUE)
plot(fd1.1)
# now repeat the analysis with some smoothing, which moves the
# toward 0.
fd1.5 &lt;- Data2fd(y12, basisobj=b1.1, lambda=0.5)
#  values of the smooth:
# fd1.1 = sum(y12)/(n+lambda*integral(over arg=0 to 1 of 1))
#         = 3 / (2+0.5) = 1.2
#. JR ... Data2fd returns an fdsmooth object and a member of the
#         is an fd smooth object.  Calls to functions expecting 
#         an fd object require attaching $fd to the fdsmooth object
#         this is required in lines 268, 311 and 337
eval.fd(seq(0, 1, .2), fd1.5)
##
## step function smoothing
##
# 2 step basis functions: order 1 = degree 0 = step functions
b1.2 &lt;- create.bspline.basis(nbasis=2, norder=1)
#  fit the data without smoothing
fd1.2 &lt;- Data2fd(1:2, basisobj=b1.2)
# plot the result:  A step function:  1 to 0.5, then 2
op &lt;- par(mfrow=c(2,1))
plot(b1.2, main='bases')
plot(fd1.2, main='fit')
par(op)
##
## Simple oversmoothing
##
# 3 step basis functions: order 1 = degree 0 = step functions
b1.3 &lt;- create.bspline.basis(nbasis=3, norder=1)
#  smooth the data with smoothing
fd1.3 &lt;- Data2fd(y12, basisobj=b1.3, lambda=0.5)
#  plot the fit along with the points
plot(0:1, c(0, 2), type='n')
points(0:1, y12)
lines(fd1.3)
# Fit = penalized least squares with penalty =
#          = lambda * integral(0:1 of basis^2),
#            which shrinks the points towards 0.
# X1.3 = matrix(c(1,0, 0,0, 0,1), 2)
# XtX = crossprod(X1.3) = diag(c(1, 0, 1))
# penmat = diag(3)/3
#        = 3x3 matrix of integral(over arg=0:1 of basis[i]*basis[j])
# Xt.y = crossprod(X1.3, y12) = c(1, 0, 2)
# XtX + lambda*penmat = diag(c(7, 1, 7)/6
# so coef(fd1.3.5) = solve(XtX + lambda*penmat, Xt.y)
#                  = c(6/7, 0, 12/7)
##
## linear spline fit
##
# 3 bases, order 2 = degree 1
b2.3 &lt;- create.bspline.basis(norder=2, breaks=c(0, .5, 1))
# interpolate the values 0, 2, 1
fd2.3 &lt;- Data2fd(c(0,2,1), basisobj=b2.3, lambda=0)
#  display the coefficients
round(fd2.3$coefs, 4)
# plot the results
op &lt;- par(mfrow=c(2,1))
plot(b2.3, main='bases')
plot(fd2.3, main='fit')
par(op)
# apply some smoothing
fd2.3. &lt;- Data2fd(c(0,2,1), basisobj=b2.3, lambda=1)
op &lt;- par(mfrow=c(2,1))
plot(b2.3, main='bases')
plot(fd2.3., main='fit', ylim=c(0,2))
par(op)
all.equal(
 unclass(fd2.3)[-1], 
 unclass(fd2.3.)[-1])
##** CONCLUSION:  
##** The only differences between fd2.3 and fd2.3.
##** are the coefficients, as we would expect.  

##
## quadratic spline fit
##
# 4 bases, order 3 = degree 2 = continuous, bounded, locally quadratic
b3.4 &lt;- create.bspline.basis(norder=3, breaks=c(0, .5, 1))
# fit values c(0,4,2,3) without interpolation
fd3.4 &lt;- Data2fd(c(0,4,2,3), basisobj=b3.4, lambda=0)
round(fd3.4$coefs, 4)
op &lt;- par(mfrow=c(2,1))
plot(b3.4)
plot(fd3.4)
points(c(0,1/3,2/3,1), c(0,4,2,3))
par(op)
#  try smoothing
fd3.4. &lt;- Data2fd(c(0,4,2,3), basisobj=b3.4, lambda=1)
round(fd3.4.$coef, 4)
op &lt;- par(mfrow=c(2,1))
plot(b3.4)
plot(fd3.4., ylim=c(0,4))
points(seq(0,1,len=4), c(0,4,2,3))
par(op)
##
##  Two simple Fourier examples
##
gaitbasis3 &lt;- create.fourier.basis(nbasis=5)
gaitfd3    &lt;- Data2fd(seq(0,1,len=20), gait, basisobj=gaitbasis3)
# plotfit.fd(gait, seq(0,1,len=20), gaitfd3)
#    set up the fourier basis
daybasis &lt;- create.fourier.basis(c(0, 365), nbasis=65)
#  Make temperature fd object
#  Temperature data are in 12 by 365 matrix tempav
#    See analyses of weather data.
tempfd &lt;- Data2fd(CanadianWeather$dailyAv[,,"Temperature.C"],
                  day.5, daybasis)
#  plot the temperature curves
par(mfrow=c(1,1))
plot(tempfd)
##
## argvals of class Date and POSIXct
##
#  These classes of time can generate very large numbers when converted to 
#  numeric vectors.  For basis systems such as polynomials or splines,
#  severe rounding error issues can arise if the time interval for the 
#  data is very large.  To offset this, it is best to normalize the
#  numeric version of the data before analyzing them.
#  Date class time unit is one day, divide by 365.25.
invasion1 &lt;- as.Date('1775-09-04')
invasion2 &lt;- as.Date('1812-07-12')
earlyUS.Canada &lt;- as.numeric(c(invasion1, invasion2))/365.25
BspInvasion &lt;- create.bspline.basis(earlyUS.Canada)
earlyYears  &lt;- seq(invasion1, invasion2, length.out=7)
earlyQuad   &lt;- (as.numeric(earlyYears-invasion1)/365.25)^2
earlyYears  &lt;- as.numeric(earlyYears)/365.25
fitQuad &lt;- Data2fd(earlyYears, earlyQuad, BspInvasion)
# POSIXct: time unit is one second, divide by 365.25*24*60*60
rescale     &lt;- 365.25*24*60*60
AmRev.ct    &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev.ct   &lt;- create.bspline.basis(as.numeric(AmRev.ct)/rescale)
AmRevYrs.ct &lt;- seq(AmRev.ct[1], AmRev.ct[2], length.out=14)
AmRevLin.ct &lt;- as.numeric(AmRevYrs.ct-AmRev.ct[1])
AmRevYrs.ct &lt;- as.numeric(AmRevYrs.ct)/rescale
AmRevLin.ct &lt;- as.numeric(AmRevLin.ct)/rescale
fitLin.ct   &lt;- Data2fd(AmRevYrs.ct, AmRevLin.ct, BspRev.ct)
par(oldpar)
</code></pre>

<hr>
<h2 id='dateAccessories'>
Numeric and character vectors to facilitate working with dates
</h2><span id='topic+dateAccessories'></span><span id='topic+monthAccessories'></span><span id='topic+dayOfYear'></span><span id='topic+dayOfYearShifted'></span><span id='topic+day.5'></span><span id='topic+daysPerMonth'></span><span id='topic+monthEnd'></span><span id='topic+monthEnd.5'></span><span id='topic+monthBegin.5'></span><span id='topic+monthMid'></span><span id='topic+monthLetters'></span><span id='topic+weeks'></span>

<h3>Description</h3>

<p>Numeric and character vectors to simplify functional data computations
and plotting involving dates.
</p>


<h3>Format</h3>


<dl>
<dt>dayOfYear</dt><dd>
<p>a numeric vector = 1:365 with names 'jan01' to 'dec31'.
</p>
</dd>
<dt>dayOfYearShifted</dt><dd>
<p>a numeric vector = c(182:365, 1:181) with names 'jul01' to
'jun30'.
</p>
</dd>
<dt>day.5 </dt><dd>
<p>a numeric vector = dayOfYear-0.5 = 0.5, 1.5, ..., 364.5
</p>
</dd>
<dt>daysPerMonth</dt><dd>
<p>a numeric vector of the days in each month (ignoring leap years)
with names = month.abb
</p>
</dd>
<dt>monthEnd</dt><dd>
<p>a numeric vector of cumsum(daysPerMonth) with names = month.abb
</p>
</dd>
<dt>monthEnd.5</dt><dd>
<p>a numeric vector of the middle of the last day of each month with
names = month.abb = c(Jan=30.5, Feb=58.5, ..., Dec=364.5)
</p>
</dd>
<dt>monthBegin.5</dt><dd>
<p>a numeric vector of the middle of the first day of each month with
names - month.abb = c(Jan=0.5, Feb=31.5, ..., Dec=334.5)
</p>
</dd>
<dt>monthMid</dt><dd>
<p>a numeric vector of the middle of the month = (monthBegin.5 +
monthEnd.5)/2
</p>
</dd>
<dt>monthLetters</dt><dd>
<p>A character vector of c(&quot;j&quot;, &quot;F&quot;, &quot;m&quot;, &quot;A&quot;, &quot;M&quot;, &quot;J&quot;, &quot;J&quot;, &quot;A&quot;,
&quot;S&quot;, &quot;O&quot;, &quot;N&quot;, &quot;D&quot;), with 'month.abb' as the names.
</p>
</dd>
<dt>weeks</dt><dd>
<p>a numeric vector of length 53 marking 52 periods of approximately 7
days each throughout the year = c(0, 365/52, ..., 365)
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Miscellaneous vectors often used in 'fda' scripts.
</p>


<h3>Source</h3>

<p>Ramsay, James O., and Silverman, Bernard W. (2006), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York, pp. 5, 47-53.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+axisIntervals">axisIntervals</a></code>
<code><a href="base.html#topic+month.abb">month.abb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>daybasis65 &lt;- create.fourier.basis(c(0, 365), 65)
daytempfd &lt;- with(CanadianWeather, smooth.basisPar(day.5,
    dailyAv[,,"Temperature.C"], daybasis65)$fd )
oldpar &lt;- par(axes=FALSE)
plot(daytempfd)
axisIntervals(1)
# axisIntervals by default uses
# monthBegin.5, monthEnd.5, monthMid, and month.abb
axis(2)
par(oldpar)
</code></pre>

<hr>
<h2 id='density.fd'>
Compute a Probability Density Function
</h2><span id='topic+density.fd'></span>

<h3>Description</h3>

<p>Like the regular S-PLUS function <code>density</code>, this function
computes a probability density function for a sample of values of a
random variable.  However, in this case the density function is
defined by a functional parameter object <code>WfdParobj</code> along with a
normalizing constant <code>C</code>.
</p>
<p>The density function $p(x)$ has the form <code>p(x) = C exp[W(x)]</code>
where function $W(x)$ is defined by the functional data object
<code>WfdParobj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
density(x, WfdParobj, conv=0.0001, iterlim=20,
           active=1:nbasis, dbglev=0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="density.fd_+3A_x">x</code></td>
<td>

<p>a set observations, which may be one of two forms:
</p>

<ol>
<li><p> a vector of observations $x_i$
</p>
</li>
<li><p> a two-column matrix, with the observations $x_i$ in the
first column, and frequencies $f_i$ in the second.
</p>
</li></ol>

<p>The first option corresponds to all $f_i = 1$.
</p>
</td></tr>
<tr><td><code id="density.fd_+3A_wfdparobj">WfdParobj</code></td>
<td>

<p>a functional parameter object specifying the initial
value, basis object, roughness penalty and smoothing
parameter defining function $W(t).$
</p>
</td></tr>
<tr><td><code id="density.fd_+3A_conv">conv</code></td>
<td>

<p>a positive constant defining the convergence criterion.
</p>
</td></tr>
<tr><td><code id="density.fd_+3A_iterlim">iterlim</code></td>
<td>

<p>the maximum number of iterations allowed.
</p>
</td></tr>
<tr><td><code id="density.fd_+3A_active">active</code></td>
<td>

<p>a logical vector of length equal to the number of coefficients
defining <code>Wfdobj</code>. If an entry is TRUE, the corresponding
coefficient is estimated, and if FALSE, it is held at the value defining the
argument <code>Wfdobj</code>.  Normally the first coefficient is set to 0
and not estimated, since it is assumed that $W(0) = 0$.
</p>
</td></tr>
<tr><td><code id="density.fd_+3A_dbglev">dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out on
each iteration, with 0 implying no output, 1 intermediate output level,
and 2 full output.  If levels 1 and 2 are used, it is helpful to
turn off the output buffering option in S-PLUS.
</p>
</td></tr>
<tr><td><code id="density.fd_+3A_...">...</code></td>
<td>
<p>Other arguments to match the generic function 'density'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of the function is provide a smooth density function
estimate that approaches some target density by an amount that is
controlled by the linear differential operator <code>Lfdobj</code> and
the penalty parameter. For example, if the second derivative of
$W(t)$ is penalized heavily, this will force the function to
approach a straight line, which in turn will force the density function
itself to be nearly normal or Gaussian.  Similarly, to each textbook
density function there corresponds a $W(t)$, and to each of these
in turn their corresponds a linear differential operator that will, when
apply to $W(t)$, produce zero as a result.
To plot the density function or to evaluate it, evaluate <code>Wfdobj</code>,
exponentiate the resulting vector, and then divide by the normalizing
constant <code>C</code>.
</p>


<h3>Value</h3>

<p>a named list of length 4 containing:
</p>
<table role = "presentation">
<tr><td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the monotone function that it defines.
</p>
</td></tr>
<tr><td><code>C</code></td>
<td>

<p>the normalizing constant.
</p>
</td></tr>
<tr><td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged solution:
(1)
<b>f</b>: the optimal function value being minimized,
(2)
<b>grad</b>: the gradient vector at the optimal solution,   and
(3)
<b>norm</b>: the norm of the gradient vector at the optimal solution.
</p>
</td></tr>
<tr><td><code>iternum</code></td>
<td>

<p>the number of iterations.
</p>
</td></tr>
<tr><td><code>iterhist</code></td>
<td>

<p>a <code>iternum+1</code> by 5 matrix containing the iteration
history.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intensity.fd">intensity.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  set up range for density
rangeval &lt;- c(-3,3)
#  set up some standard normal data
x &lt;- rnorm(50)
#  make sure values within the range
x[x &lt; -3] &lt;- -2.99
x[x &gt;  3] &lt;-  2.99
#  set up basis for W(x)
basisobj &lt;- create.bspline.basis(rangeval, 11)
#  set up initial value for Wfdobj
Wfd0 &lt;- fd(matrix(0,11,1), basisobj)
WfdParobj &lt;- fdPar(Wfd0)
#  estimate density
denslist &lt;- density.fd(x, WfdParobj)
#  plot density
oldpar &lt;- par(no.readonly=TRUE)
xval &lt;- seq(-3,3,.2)
wval &lt;- eval.fd(xval, denslist$Wfdobj)
pval &lt;- exp(wval)/denslist$C
plot(xval, pval, type="l", ylim=c(0,0.4))
points(x,rep(0,50))
par(oldpar)
</code></pre>

<hr>
<h2 id='deriv.fd'>
Compute a Derivative of a Functional Data Object
</h2><span id='topic+deriv.fd'></span>

<h3>Description</h3>

<p>A derivative of a functional data object, or the result of applying
a linear differential operator to a functional data object, is then
converted to a functional data object. This is intended for situations
where a derivative is to be manipulated as a functional data object
rather than simply evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
deriv(expr, Lfdobj=int2Lfd(1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deriv.fd_+3A_expr">expr</code></td>
<td>

<p>a functional data object.  It is assumed that the basis for
representing the object can support the order of derivative
to be computed.  For B-spline bases, this means that the
order of the spline must be at least one larger than the order of
the derivative to be computed.
</p>
</td></tr>
<tr><td><code id="deriv.fd_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a positive integer or a linear differential operator object.
</p>
</td></tr>
<tr><td><code id="deriv.fd_+3A_...">...</code></td>
<td>
<p>Other arguments to match generic for 'deriv'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typically, a derivative has more high frequency variation or detail
than the function itself.  The basis defining the function is used,
and therefore this must have enough basis functions to represent
the variation in the derivative satisfactorily.
</p>


<h3>Value</h3>

<p>a functional data object for the derivative
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getbasismatrix">getbasismatrix</a></code>,
<code><a href="#topic+eval.basis">eval.basis</a></code>
<code><a href="stats.html#topic+deriv">deriv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Estimate the acceleration functions for growth curves
#  See the analyses of the growth data.
#  Set up the ages of height measurements for Berkeley data
age &lt;- c( seq(1, 2, 0.25), seq(3, 8, 1), seq(8.5, 18, 0.5))
#  Range of observations
rng &lt;- c(1,18)
#  Set up a B-spline basis of order 6 with knots at ages
knots  &lt;- age
norder &lt;- 6
nbasis &lt;- length(knots) + norder - 2
hgtbasis &lt;- create.bspline.basis(rng, nbasis, norder, knots)
#  Set up a functional parameter object for estimating
#  growth curves.  The 4th derivative is penalyzed to
#  ensure a smooth 2nd derivative or acceleration.
Lfdobj &lt;- 4
lambda &lt;- 10^(-0.5)   #  This value known in advance.
growfdPar &lt;- fdPar(fd(matrix(0,nbasis,1),hgtbasis), Lfdobj, lambda)
#  Smooth the data.  The data for the boys and girls
#  are in matrices hgtm and hgtf, respectively.
hgtmfd &lt;- smooth.basis(age, growth$hgtm, growfdPar)$fd
hgtffd &lt;- smooth.basis(age, growth$hgtf, growfdPar)$fd
#  Compute the acceleration functions
accmfd &lt;- deriv.fd(hgtmfd, 2)
accffd &lt;- deriv.fd(hgtffd, 2)
#  Plot the two sets of curves
oldpar &lt;- par(mfrow=c(2,1))
plot(accmfd)
plot(accffd)
par(oldpar)
</code></pre>

<hr>
<h2 id='df.residual.fRegress'>
Degrees of Freedom for Residuals from a Functional Regression
</h2><span id='topic+df.residual.fRegress'></span>

<h3>Description</h3>

<p>Effective degrees of freedom for residuals, being the trace of the
idempotent <code>hat</code> matrix transforming observations into residuals
from the fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fRegress'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df.residual.fRegress_+3A_object">object</code></td>
<td>

<p>Object of class inheriting from <code>fRegress</code>
</p>
</td></tr>
<tr><td><code id="df.residual.fRegress_+3A_...">...</code></td>
<td>

<p>additional arguments for other methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Determine N = number of observations
</p>
<p>2.  df.model &lt;- object$df
</p>
<p>3.  df.residual &lt;- (N - df.model)
</p>
<p>4.  Add attributes
</p>


<h3>Value</h3>

<p>The numeric value of the residual degrees-of-freedom extracted from
<code>object</code> with the following attributes:
</p>
<table role = "presentation">
<tr><td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code>df.model</code></td>
<td>

<p>effective degrees of freedom for the model, being the trace of the
idempotent linear projection operator transforming the observations
into their predictions per the model.  This includes the intercept,
so the 'degrees of freedom for the model' for many standard purposes
that compare with a model with an estimated mean will be 1 less than
this number.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Spencer Graves </p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
Hastie, Trevor, Tibshirani, Robert, and Friedman, Jerome (2001)
<em>The Elements of Statistical Learning:  Data Mining, Inference,
and Prediction</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress">fRegress</a></code>
<code><a href="stats.html#topic+df.residual">df.residual</a></code>
</p>

<hr>
<h2 id='df2lambda'>
Convert Degrees of Freedom to a Smoothing Parameter Value
</h2><span id='topic+df2lambda'></span>

<h3>Description</h3>

<p>The degree of roughness of an estimated function is controlled by a
smoothing parameter $lambda$ that directly multiplies the penalty.
However, it can be difficult to interpret or choose this value, and it
is often easier to determine the roughness by choosing a value that is
equivalent of the degrees of freedom used by the smoothing procedure.
This function converts a degrees of freedom value into a multiplier
$lambda$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2lambda(argvals, basisobj, wtvec=rep(1, n), Lfdobj=0,
          df=nbasis)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df2lambda_+3A_argvals">argvals</code></td>
<td>

<p>a vector containing argument values associated with the values to
be smoothed.
</p>
</td></tr>
<tr><td><code id="df2lambda_+3A_basisobj">basisobj</code></td>
<td>

<p>a basis function object.
</p>
</td></tr>
<tr><td><code id="df2lambda_+3A_wtvec">wtvec</code></td>
<td>

<p>a vector of weights for the data to be smoothed.
</p>
</td></tr>
<tr><td><code id="df2lambda_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator object.
</p>
</td></tr>
<tr><td><code id="df2lambda_+3A_df">df</code></td>
<td>

<p>the degrees of freedom to be converted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conversion requires a one-dimensional optimization and may be
therefore computationally intensive.
</p>


<h3>Value</h3>

<p>a positive smoothing parameter value $lambda$
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambda2df">lambda2df</a></code>, 
<code><a href="#topic+lambda2gcv">lambda2gcv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  Smooth growth curves using a specified value of
#  degrees of freedom.
#  Set up the ages of height measurements for Berkeley data
age &lt;- c( seq(1, 2, 0.25), seq(3, 8, 1), seq(8.5, 18, 0.5))
#  Range of observations
rng &lt;- c(1,18)
#  Set up a B-spline basis of order 6 with knots at ages
knots  &lt;- age
norder &lt;- 6
nbasis &lt;- length(knots) + norder - 2
hgtbasis &lt;- create.bspline.basis(rng, nbasis, norder, knots)
#  Find the smoothing parameter equivalent to 12
#  degrees of freedom
lambda &lt;- df2lambda(age, hgtbasis, df=12)
#  Set up a functional parameter object for estimating
#  growth curves.  The 4th derivative is penalyzed to
#  ensure a smooth 2nd derivative or acceleration.
Lfdobj &lt;- 4
growfdPar &lt;- fdPar(fd(matrix(0,nbasis,1),hgtbasis), Lfdobj, lambda)
#  Smooth the data.  The data for the girls are in matrix
#  hgtf.
hgtffd &lt;- smooth.basis(age, growth$hgtf, growfdPar)$fd
#  Plot the curves
oldpar &lt;- par(no.readonly=TRUE)
plot(hgtffd)
par(oldpar)
</code></pre>

<hr>
<h2 id='dirs'>
Get subdirectories 
</h2><span id='topic+dirs'></span>

<h3>Description</h3>

<p>If you want only subfolders and no files, use <code>dirs</code>.  
With <code>recursive</code> = FALSE, <code><a href="base.html#topic+dir">dir</a></code> returns both folders
and files.  With <code>recursive</code> = TRUE, it returns only files.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirs(path='.', pattern=NULL, exclude=NULL, all.files=FALSE,
     full.names=FALSE, recursive=FALSE, ignore.case=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dirs_+3A_path">path</code>, <code id="dirs_+3A_all.files">all.files</code>, <code id="dirs_+3A_full.names">full.names</code>, <code id="dirs_+3A_recursive">recursive</code>, <code id="dirs_+3A_ignore.case">ignore.case</code></td>
<td>

<p>as for <code><a href="base.html#topic+dir">dir</a></code>
</p>
</td></tr>
<tr><td><code id="dirs_+3A_pattern">pattern</code>, <code id="dirs_+3A_exclude">exclude</code></td>
<td>

<p>optional regular expressions of filenames to include or exclude,
respectively.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  mainDir &lt;- dir(...)  without recurse 
</p>
<p>2.  Use <code><a href="base.html#topic+file.info">file.info</a></code> to restrict mainDir to only
directories.
</p>
<p>3.  If !recursive, return the restricted mainDir.  Else, if
length(mainDir) &gt; 0, create dirList to hold the results of the
recursion and call <code>dirs</code> for each component of mainDir.  Then
<code><a href="base.html#topic+unlist">unlist</a></code> and return the result.  
</p>


<h3>Value</h3>

<p>A character vector of the desired subdirectories.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dir">dir</a></code>,
<code><a href="base.html#topic+file.info">file.info</a></code>
</p>

<hr>
<h2 id='Eigen'>
Eigenanalysis preserving dimnames 
</h2><span id='topic+Eigen'></span>

<h3>Description</h3>

<p>Compute eigenvalues and vectors, assigning names to the eigenvalues
and dimnames to the eigenvectors.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Eigen(x, symmetric, only.values = FALSE, valuenames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Eigen_+3A_x">x</code></td>
<td>

<p>a square matrix whose spectral decomposition is to be computed.  
</p>
</td></tr>
<tr><td><code id="Eigen_+3A_symmetric">symmetric</code></td>
<td>

<p>logical:  If TRUE, the matrix is assumed to be symmetric (or 
Hermitian if complex) and only its lower triangle (diagonal
included) is used.  If 'symmetric' is not specified, the
matrix is inspected for symmetry.
</p>
</td></tr>
<tr><td><code id="Eigen_+3A_only.values">only.values</code></td>
<td>

<p>if 'TRUE', only the eigenvalues are computed and returned, otherwise
both eigenvalues and eigenvectors are returned. 
</p>
</td></tr>
<tr><td><code id="Eigen_+3A_valuenames">valuenames</code></td>
<td>

<p>character vector of length nrow(x) or a character string that can be
extended to that length by appending 1:nrow(x).
</p>
<p>The default depends on symmetric and whether
<code><a href="base.html#topic+rownames">rownames</a></code> == <code><a href="base.html#topic+colnames">colnames</a></code>:  If
<code><a href="base.html#topic+rownames">rownames</a></code> == <code><a href="base.html#topic+colnames">colnames</a></code> and
symmetric = TRUE (either specified or determined by
inspection), the default is &quot;paste('ev', 1:nrow(x), sep=&rdquo;)&quot;.
Otherwise, the default is colnames(x) unless this is NULL. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Check 'symmetric'  
</p>
<p>2.  ev &lt;- eigen(x, symmetric, only.values = FALSE, EISPACK = FALSE);
see <code><a href="base.html#topic+eigen">eigen</a></code> for more details.  
</p>
<p>3.  rNames = rownames(x);  if this is NULL, rNames = if(symmetric)
paste('x', 1:nrow(x), sep=&rdquo;) else paste('xcol', 1:nrow(x)).  
</p>
<p>4.  Parse 'valuenames', assign to names(ev[['values']]).  
</p>
<p>5.  dimnames(ev[['vectors']]) &lt;- list(rNames, valuenames) 
</p>
<p>NOTE:  This naming convention is fairly obvious if 'x' is symmetric.
Otherwise, dimensional analysis suggests problems with almost any
naming convention.  To see this, consider the following simple
example:
</p>
<p style="text-align: center;"><code class="reqn">
    X &lt;- matrix(1:4, 2, dimnames=list(LETTERS[1:2], letters[3:4]))
  </code>
</p>


<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> c </td><td style="text-align: right;"> d </td>
</tr>
<tr>
 <td style="text-align: right;">
    A </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> 3 </td>
</tr>
<tr>
 <td style="text-align: right;">
    B </td><td style="text-align: right;"> 2 </td><td style="text-align: right;"> 4 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p style="text-align: center;"><code class="reqn">
    X.inv &lt;- solve(X)
  </code>
</p>


<table>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> A </td><td style="text-align: right;"> B </td>
</tr>
<tr>
 <td style="text-align: right;">
    c </td><td style="text-align: right;"> -2 </td><td style="text-align: right;"> 1.5 </td>
</tr>
<tr>
 <td style="text-align: right;">
    d </td><td style="text-align: right;"> 1 </td><td style="text-align: right;"> -0.5 </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>One way of interpreting this is to assume that colnames are really
reciprocals of the units.  Thus, in this example, X[1,1] is in units
of 'A/c' and X.inv[1,1] is in units of 'c/A'.  This would make any
matrix with the same row and column names potentially dimensionless.
Since eigenvalues are essentially the diagonal of a diagonal matrix,
this would mean that eigenvalues are dimensionless, and their names
are merely placeholders.   
</p>


<h3>Value</h3>

<p>a list with components values and (if only.values = FALSE)
vectors, as described in <code><a href="base.html#topic+eigen">eigen</a></code>.  
</p>


<h3>Author(s)</h3>

<p>Spencer Graves</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code>,
<code><a href="base.html#topic+svd">svd</a></code>
<code><a href="base.html#topic+qr">qr</a></code>
<code><a href="base.html#topic+chol">chol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1:4, 2, dimnames=list(LETTERS[1:2], letters[3:4]))
eigen(X)
Eigen(X)
Eigen(X, valuenames='eigval')

Y &lt;- matrix(1:4, 2, dimnames=list(letters[5:6], letters[5:6]))
Eigen(Y)

Eigen(Y, symmetric=TRUE)
# only the lower triangle is used;
# the upper triangle is ignored.  
</code></pre>

<hr>
<h2 id='eigen.pda'>
Stability Analysis for Principle Differential Analysis
</h2><span id='topic+eigen.pda'></span>

<h3>Description</h3>

<p>Performs a stability analysis of the result of <code>pda.fd</code>, returning
the real and imaginary parts of the eigenfunctions associated with the
linear differential operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen.pda(pdaList,plotresult=TRUE,npts=501,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigen.pda_+3A_pdalist">pdaList</code></td>
<td>

<p>a list object returned by <code>pda.fd</code>.
</p>
</td></tr>
<tr><td><code id="eigen.pda_+3A_plotresult">plotresult</code></td>
<td>

<p>should the result be plotted? Default is TRUE
</p>
</td></tr>
<tr><td><code id="eigen.pda_+3A_npts">npts</code></td>
<td>

<p>number of points to use for plotting.
</p>
</td></tr>
<tr><td><code id="eigen.pda_+3A_...">...</code></td>
<td>

<p>other arguments for 'plot'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conducts an eigen decomposition of the linear differential equation implied
by the result of <code>pda.fd</code>. Imaginary eigenvalues indicate instantaneous
oscillatory behavior. Positive real eigenvalues indicate exponential increase,
negative real eigenvalues correspond to exponential decay. If the principle
differential analysis also included the estimation of a forcing function, the
limiting stable points are also tracked.
</p>


<h3>Value</h3>

<p>Returns a list with elements
</p>
<table role = "presentation">
<tr><td><code>argvals</code></td>
<td>
<p>The evaluation points of the coefficient functions.</p>
</td></tr>
<tr><td><code>eigvals</code></td>
<td>
<p>The corresponding eigenvalues at each time.</p>
</td></tr>
<tr><td><code>limvals</code></td>
<td>
<p>The stable points of the system at each time.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pda.fd">pda.fd</a></code>
<code><a href="#topic+plot.pda.fd">plot.pda.fd</a></code>
<code><a href="#topic+pda.overlay">pda.overlay</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  A pda analysis of the handwriting data

# reduce the size to reduce the compute time for the example
ni &lt;- 281
indx &lt;- seq(1, 1401, length=ni)
fdaarray = handwrit[indx,,]
fdatime  &lt;- seq(0, 2.3, len=ni)

#  basis for coordinates

fdarange &lt;- c(0, 2.3)
breaks = seq(0,2.3,length.out=116)
norder = 6
fdabasis = create.bspline.basis(fdarange,norder=norder,breaks=breaks)
nbasis &lt;- fdabasis$nbasis

#  parameter object for coordinates

fdaPar = fdPar(fd(matrix(0,nbasis,1),fdabasis),int2Lfd(4),1e-8)

#  coordinate functions and a list tontaining them

Xfd = smooth.basis(fdatime, fdaarray[,,1], fdaPar)$fd
Yfd = smooth.basis(fdatime, fdaarray[,,2], fdaPar)$fd

xfdlist = list(Xfd, Yfd)

#  basis and parameter object for weight functions

fdabasis2 = create.bspline.basis(fdarange,norder=norder,nbasis=31)
fdafd2    = fd(matrix(0,31,2),fdabasis2)
pdaPar    = fdPar(fdafd2,1,1e-8)

pdaParlist = list(pdaPar, pdaPar)

bwtlist = list( list(pdaParlist,pdaParlist), list(pdaParlist,pdaParlist) )

</code></pre>

<hr>
<h2 id='ElectricDemand'>
Predicting electricity demand in Adelaide from temperature
</h2><span id='topic+ElectricDemand'></span>

<h3>Description</h3>

<p>The data sets used in this demonstration analysis consist of half-hourly electricity demands from Sunday to Saturday in Adelaide, Australia, between July 6, 1976 and March 31, 2007.  Also provided in the same format and times are the temperatures in degrees Celsius at the Adelaide airport.  The shapes of the demand curves for each day resemble those for temperature, and the goal is to see how well a concurrent functional regress model fit by function <code>fRegress</code> can fit the demand curves.
</p>


<h3>Format</h3>

<p>There is a data object for each day of the week, and in each object, the member y, such as <code>mondaydemand$y</code>, is a 48 by 508 matrix of electricity demand values, one for each of 48 half-hourly points, and for each of 508 weeks.   
</p>


<h3>Details</h3>

<p>The demonstration is designed to show how to use the main functional regression function <code>fRegress</code> in order to fit a functional dependent variable (electricity demand) from an obviously important input or covariate functional variable (temperature).  In the texts cited, this model is referred to as a concurrent functional regression because the model assumes that changes in the input functional variable directly and immediately change the dependent functional variable.  
</p>
<p>Also illustrated is the estimation of pointwise confidence intervals for the regression coefficient functions and for the fitting functions that approximate electricity demand.  These steps involve functons <code>fRegress.stderr</code> and <code>predict.fRegress</code>.
</p>
<p>The data are supplied through the CRAN system by package <code>fds</code>, and further information as well as many other datasets are to be found there.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='eval.basis'>
Values of Basis Functions or their Derivatives
</h2><span id='topic+eval.basis'></span><span id='topic+predict.basisfd'></span>

<h3>Description</h3>

<p>A set of basis functions are evaluated at a vector of argument values.
If a linear differential object is provided, the  values are the
result of applying the the operator to each basis function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.basis(evalarg, basisobj, Lfdobj=0, returnMatrix=FALSE)
## S3 method for class 'basisfd'
predict(object, newdata=NULL, Lfdobj=0,
                          returnMatrix=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.basis_+3A_evalarg">evalarg</code>, <code id="eval.basis_+3A_newdata">newdata</code></td>
<td>

<p>a vector of argument values at which the basis functiona is to be
evaluated.
</p>
</td></tr>
<tr><td><code id="eval.basis_+3A_basisobj">basisobj</code></td>
<td>

<p>a basis object defining basis functions whose values
are to be computed.
</p>
</td></tr>
<tr><td><code id="eval.basis_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential.
operator object.
</p>
</td></tr>
<tr><td><code id="eval.basis_+3A_object">object</code></td>
<td>

<p>an object of class <code>basisfd</code>
</p>
</td></tr>
<tr><td><code id="eval.basis_+3A_...">...</code></td>
<td>

<p>optional arguments for <code>predict</code>, not currently used
</p>
</td></tr>
<tr><td><code id="eval.basis_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a linear differential operator object is supplied, the basis must
be such that the highest order derivative can be computed. If a
B-spline basis is used, for example, its order must be one larger than
the highest order of derivative required.
</p>


<h3>Value</h3>

<p>a matrix of basis function values with rows corresponding
to argument values and columns to basis functions.
</p>
<p><code>predict.basisfd</code> is a convenience wrapper for
<code>eval.basis</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getbasismatrix">getbasismatrix</a></code>,
<code><a href="#topic+eval.fd">eval.fd</a></code>,
<code><a href="#topic+plot.basisfd">plot.basisfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  B-splines
##
# The simplest basis currently available:
# a single step function
bspl1.1 &lt;- create.bspline.basis(norder=1, breaks=0:1)
eval.bspl1.1 &lt;- eval.basis(seq(0, 1, .2), bspl1.1)

# check
eval.bspl1.1. &lt;- matrix(rep(1, 6), 6,
       dimnames=list(NULL, 'bspl') )

all.equal(eval.bspl1.1, eval.bspl1.1.)


# The second simplest basis:
# 2 step functions, [0, .5], [.5, 1]
bspl1.2 &lt;- create.bspline.basis(norder=1, breaks=c(0,.5, 1))
eval.bspl1.2 &lt;- eval.basis(seq(0, 1, .2), bspl1.2)

# Second order B-splines (degree 1:  linear splines)
bspl2.3 &lt;- create.bspline.basis(norder=2, breaks=c(0,.5, 1))
eval.bspl2.3 &lt;- eval.basis(seq(0, 1, .1), bspl2.3)
# 3 bases:  order 2 = degree 1 = linear
# (1) line from (0,1) down to (0.5, 0), 0 after
# (2) line from (0,0) up to (0.5, 1), then down to (1,0)
# (3) 0 to (0.5, 0) then up to (1,1).

##
## 2.  Fourier
##
# The false Fourier series with 1 basis function
falseFourierBasis &lt;- create.fourier.basis(nbasis=1)
eval.fFB &lt;- eval.basis(seq(0, 1, .2), falseFourierBasis)

# Simplest real Fourier basis with 3 basis functions
fourier3 &lt;- create.fourier.basis()
eval.fourier3 &lt;- eval.basis(seq(0, 1, .2), fourier3)

# 3 basis functions on [0, 365]
fourier3.365 &lt;- create.fourier.basis(c(0, 365))
eval.F3.365 &lt;- eval.basis(day.5, fourier3.365)
oldpar &lt;- par(no.readonly=TRUE)
matplot(eval.F3.365, type="l")

# The next simplest Fourier basis (5  basis functions)
fourier5 &lt;- create.fourier.basis(nbasis=5)
eval.F5 &lt;- eval.basis(seq(0, 1, .1), fourier5)
matplot(eval.F5, type="l")

# A more complicated example
dayrng &lt;- c(0, 365)

nbasis &lt;- 51
norder &lt;- 6

weatherBasis &lt;- create.fourier.basis(dayrng, nbasis)
basisMat &lt;- eval.basis(day.5, weatherBasis)

matplot(basisMat[, 1:5], type="l")

##
## 3.  predict.basisfd
##
basisMat. &lt;- predict(weatherBasis, day.5)

all.equal(basisMat, basisMat.)


##
## 4.  Date and POSIXct
##
# Date
July4.1776 &lt;- as.Date('1776-07-04')
Apr30.1789 &lt;- as.Date('1789-04-30')
AmRev &lt;- c(July4.1776, Apr30.1789)
BspRevolution &lt;- create.bspline.basis(AmRev)
AmRevYears &lt;- seq(July4.1776, Apr30.1789, length.out=14)
AmRevBases &lt;- predict(BspRevolution, AmRevYears)
matplot(AmRevYears, AmRevBases, type='b')
# Image is correct, but
# matplot does not recogize the Date class of x

# POSIXct
AmRev.ct &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev.ct &lt;- create.bspline.basis(AmRev.ct)
AmRevYrs.ct &lt;- seq(AmRev.ct[1], AmRev.ct[2], length.out=14)
AmRevBas.ct &lt;- predict(BspRev.ct, AmRevYrs.ct)
matplot(AmRevYrs.ct, AmRevBas.ct, type='b')
# Image is correct, but
# matplot does not recognize the POSIXct class of x
par(oldpar)
</code></pre>

<hr>
<h2 id='eval.bifd'>
Values a Two-argument Functional Data Object
</h2><span id='topic+eval.bifd'></span>

<h3>Description</h3>

<p>A vector of argument values for the first argument <code>s</code> of the
functional data object to be evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.bifd(sevalarg, tevalarg, bifd, sLfdobj=0, tLfdobj=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.bifd_+3A_sevalarg">sevalarg</code></td>
<td>

<p>a vector of argument values for the first argument <code>s</code> of the
functional data object to be evaluated.
</p>
</td></tr>
<tr><td><code id="eval.bifd_+3A_tevalarg">tevalarg</code></td>
<td>

<p>a vector of argument values for the second argument <code>t</code> of the
functional data object to be evaluated.
</p>
</td></tr>
<tr><td><code id="eval.bifd_+3A_bifd">bifd</code></td>
<td>

<p>a two-argument functional data object.
</p>
</td></tr>
<tr><td><code id="eval.bifd_+3A_slfdobj">sLfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.  If present, the derivative or the value of applying the
operator to the object as a function of the first argument <code>s</code>
is evaluated rather than the functions themselves.
</p>
</td></tr>
<tr><td><code id="eval.bifd_+3A_tlfdobj">tLfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.  If present, the derivative or the value of applying the
operator to the object as a function of the second argument <code>t</code>
is evaluated rather than the functions themselves.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array of 2, 3, or 4 dimensions containing the function values.  The
first dimension corresponds to the argument values in sevalarg, the
second to argument values in tevalarg, the third if present to
replications, and the fourth if present to functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># every-other-day basis to save test time
daybasis   &lt;- create.fourier.basis(c(0,365), 183)
harmLcoef  &lt;- c(0,(2*pi/365)^2,0)
harmLfd    &lt;- vec2Lfd(harmLcoef, c(0,365))
templambda &lt;- 1.0
tempfdPar  &lt;- fdPar(fd(matrix(0,daybasis$nbasis,1), daybasis), harmLfd, 
                    lambda=1)
tempfd     &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"], 
                           tempfdPar)$fd
#    define the variance-covariance bivariate fd object
tempvarbifd &lt;- var.fd(tempfd)
#    evaluate the variance-covariance surface and plot
weektime    &lt;- seq(0,365,len=53)
tempvarmat  &lt;- eval.bifd(weektime,weektime,tempvarbifd)
#    make a perspective plot of the variance function
oldpar &lt;- par(no.readonly=TRUE)
persp(tempvarmat)
par(oldpar)
</code></pre>

<hr>
<h2 id='eval.fd'>
Values of a Functional Data Object
</h2><span id='topic+eval.fd'></span><span id='topic+predict.fd'></span><span id='topic+predict.fdPar'></span><span id='topic+predict.fdSmooth'></span><span id='topic+fitted.fdSmooth'></span><span id='topic+residuals.fdSmooth'></span>

<h3>Description</h3>

<p>Evaluate a functional data object at specified argument values, or
evaluate a derivative or the result of applying a linear differential
operator to the functional object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.fd(evalarg, fdobj, Lfdobj=0, returnMatrix=FALSE)
## S3 method for class 'fd'
predict(object, newdata=NULL, Lfdobj=0, returnMatrix=FALSE,
                     ...)
## S3 method for class 'fdPar'
predict(object, newdata=NULL, Lfdobj=0,
                     returnMatrix=FALSE, ...)
## S3 method for class 'fdSmooth'
predict(object, newdata=NULL, Lfdobj=0,
                     returnMatrix=FALSE, ...)
## S3 method for class 'fdSmooth'
fitted(object, returnMatrix=FALSE, ...)
## S3 method for class 'fdSmooth'
residuals(object, returnMatrix=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.fd_+3A_evalarg">evalarg</code>, <code id="eval.fd_+3A_newdata">newdata</code></td>
<td>

<p>a vector or matrix of argument values at which the functional data
object is to be evaluated.  If a matrix with more than one column,
the number of columns must match ncol(dfobj[['coefs']]).
</p>
</td></tr>
<tr><td><code id="eval.fd_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object to be evaluated.
</p>
</td></tr>
<tr><td><code id="eval.fd_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.  If present, the derivative or the value of applying the
operator is evaluated rather than the functions themselves.
</p>
</td></tr>
<tr><td><code id="eval.fd_+3A_object">object</code></td>
<td>

<p>an object of class <code>fd</code>
</p>
</td></tr>
<tr><td><code id="eval.fd_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  Should a 2-dimensional array to be returned using a
special class from the Matrix package if appropriate?
</p>
</td></tr>
<tr><td><code id="eval.fd_+3A_...">...</code></td>
<td>

<p>optional arguments for <code>predict</code>, not currently used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eval.fd</code> evaluates <code>Lfdobj</code> of <code>fdobj</code> at
<code>evalarg</code>.
</p>
<p><code>predict.fd</code> is a convenience wrapper for
<code>eval.fd</code>.  If <code>newdata</code> is NULL and
<code>fdobj[['basis']][['type']]</code> is <code>bspline</code>, <code>newdata</code> =
<code>unique(knots(fdojb,interior=FALSE))</code>;  otherwise, <code>newdata</code>
= <code>fdobj[['basis']][['rangeval']]</code>.
</p>
<p><code>predict.fdSmooth</code>, <code>fitted.fdSmooth</code> and
<code>residuals.fdSmooth</code> are other wrappers for <code>eval.fd</code>.
</p>


<h3>Value</h3>

<p>an array of 2 or 3 dimensions containing the function
values.  The first dimension corresponds to the argument values in
<code>evalarg</code>,
the second to replications, and the third if present to functions.
</p>


<h3>Author(s)</h3>

<p>Soren Hosgaard wrote an initial version of <code>predict.fdSmooth</code>,
<code>fitted.fdSmooth</code>, and <code>residuals.fdSmooth</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getbasismatrix">getbasismatrix</a></code>,
<code><a href="#topic+eval.bifd">eval.bifd</a></code>,
<code><a href="#topic+eval.penalty">eval.penalty</a></code>,
<code><a href="#topic+eval.monfd">eval.monfd</a></code>,
<code><a href="#topic+eval.posfd">eval.posfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## eval.fd
##
#    set up the fourier basis
daybasis &lt;- create.fourier.basis(c(0, 365), nbasis=65)
#  Make temperature fd object
#  Temperature data are in 12 by 365 matrix tempav
#  See analyses of weather data.
#  Set up sampling points at mid days
#  Convert the data to a functional data object
tempfd &lt;- smooth.basis(day.5,  CanadianWeather$dailyAv[,,"Temperature.C"],
                       daybasis)$fd
#   set up the harmonic acceleration operator
Lbasis  &lt;- create.constant.basis(c(0, 365))
Lcoef   &lt;- matrix(c(0,(2*pi/365)^2,0),1,3)
bfdobj  &lt;- fd(Lcoef,Lbasis)
bwtlist &lt;- fd2list(bfdobj)
harmaccelLfd &lt;- Lfd(3, bwtlist)
#   evaluate the value of the harmonic acceleration
#   operator at the sampling points
Ltempmat &lt;- eval.fd(day.5, tempfd, harmaccelLfd)

#  Confirm that it still works with
#  evalarg = a matrix with only one column
#  when fdobj[['coefs']] is a matrix with multiple columns

Ltempmat. &lt;- eval.fd(matrix(day.5, ncol=1), tempfd, harmaccelLfd)
#  confirm that the two answers are the same


all.equal(Ltempmat, Ltempmat.)


#  Plot the values of this operator
matplot(day.5, Ltempmat, type="l")

##
## predict.fd
##
predict(tempfd) # end points only at 35 locations
str(predict(tempfd, day.5)) # 365 x 35 matrix
str(predict(tempfd, day.5, harmaccelLfd))

# cublic splie with knots at 0, .5, 1
bspl3 &lt;- create.bspline.basis(c(0, .5, 1))
plot(bspl3) # 5 bases
fd.bspl3 &lt;- fd(c(0, 0, 1, 0, 0), bspl3)
pred3 &lt;- predict(fd.bspl3)

pred3. &lt;- matrix(c(0, .5, 0), 3)
dimnames(pred3.) &lt;- list(NULL, 'reps 1')

all.equal(pred3, pred3.)


pred.2 &lt;- predict(fd.bspl3, c(.2, .8))

pred.2. &lt;- matrix(.176, 2, 1)
dimnames(pred.2.) &lt;- list(NULL, 'reps 1')

all.equal(pred.2, pred.2.)


##
## predict.fdSmooth
##
lipSm9 &lt;- smooth.basisPar(liptime, lip, lambda=1e-9)$fd
plot(lipSm9)

##
## with evalarg of class Date and POSIXct
##
# Date
July4.1776 &lt;- as.Date('1776-07-04')
Apr30.1789 &lt;- as.Date('1789-04-30')
AmRev &lt;- c(July4.1776, Apr30.1789)
BspRevolution &lt;- create.bspline.basis(AmRev)

AmRevYears &lt;- seq(July4.1776, Apr30.1789, length.out=14)
(AmRevLinear &lt;- as.numeric(AmRevYears-July4.1776))
fitLin &lt;- smooth.basis(AmRevYears, AmRevLinear, BspRevolution)
AmPred &lt;- predict(fitLin, AmRevYears)

# POSIXct
AmRev.ct &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev.ct &lt;- create.bspline.basis(AmRev.ct)
AmRevYrs.ct &lt;- seq(AmRev.ct[1], AmRev.ct[2], length.out=14)
(AmRevLin.ct &lt;- as.numeric(AmRevYrs.ct-AmRev.ct[2]))
fitLin.ct &lt;- smooth.basis(AmRevYrs.ct, AmRevLin.ct, BspRev.ct)
AmPred.ct &lt;- predict(fitLin.ct, AmRevYrs.ct)
par(oldpar)
</code></pre>

<hr>
<h2 id='eval.monfd'>
Values of a Monotone Functional Data Object
</h2><span id='topic+eval.monfd'></span><span id='topic+predict.monfd'></span><span id='topic+fitted.monfd'></span><span id='topic+residuals.monfd'></span>

<h3>Description</h3>

<p>Evaluate a monotone functional data object at specified argument
values, or evaluate a derivative of the functional object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.monfd(evalarg, Wfdobj, Lfdobj=int2Lfd(0), returnMatrix=FALSE)
## S3 method for class 'monfd'
predict(object, newdata=NULL, Lfdobj=0, returnMatrix=FALSE, ...)
## S3 method for class 'monfd'
fitted(object, ...)
## S3 method for class 'monfd'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.monfd_+3A_evalarg">evalarg</code>, <code id="eval.monfd_+3A_newdata">newdata</code></td>
<td>

<p>a vector of argument values at which the functional data object is
to be evaluated.
</p>
</td></tr>
<tr><td><code id="eval.monfd_+3A_wfdobj">Wfdobj</code></td>
<td>

<p>an object of class <code>fd</code> that defines the monotone function
to be evaluated.  Only univariate functions are permitted.
</p>
</td></tr>
<tr><td><code id="eval.monfd_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>a nonnegative integer specifying a derivative to be evaluated.  At
this time of writing, permissible derivative values are 0, 1, 2, or
3.  A linear differential operator is not allowed.
</p>
</td></tr>
<tr><td><code id="eval.monfd_+3A_object">object</code></td>
<td>

<p>an object of class <code>monfd</code> that defines the monotone function
to be evaluated.  Only univariate functions are permitted.
</p>
</td></tr>
<tr><td><code id="eval.monfd_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
<tr><td><code id="eval.monfd_+3A_...">...</code></td>
<td>

<p>optional arguments required by <code>predict</code>;  not currently used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A monotone function data object $h(t)$ is defined by $h(t) = [D^{-1}
exp Wfdobj](t)$.  In this equation, the operator  $D^{-1}$ means
taking the indefinite integral of the function to which it applies.
Note that this equation implies that the monotone function has a value
of zero at the lower limit of the arguments.  To actually fit monotone
data, it will usually be necessary to estimate an intercept and a
regression coefficient to be applied to $h(t)$, usually with the least
squares regression function <code>lsfit</code>.  The function <code>Wfdobj</code>
that defines the monotone function is usually estimated by monotone
smoothing function <code>smooth.monotone.</code>
</p>
<p><code>eval.monfd</code> only computes the standardized monotone form.
<code>predict.monfd</code> computes the scaled version using
<code>with(object, beta[1] + beta[2]*eval.monfd(...))</code> if Lfdobj = 0
or beta[2]*eval.monfd(...) if Lfdobj &gt; 0.
</p>


<h3>Value</h3>

<p>a matrix containing the monotone function values.  The first dimension
corresponds to the argument values in <code>evalarg</code> and the second to
replications.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.fd">eval.fd</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>
<code><a href="#topic+eval.posfd">eval.posfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  Estimate the acceleration functions for growth curves
#  See the analyses of the growth data.
#  Set up the ages of height measurements for Berkeley data
age &lt;- c( seq(1, 2, 0.25), seq(3, 8, 1), seq(8.5, 18, 0.5))
#  Range of observations
rng &lt;- c(1,18)
#  First set up a basis for monotone smooth
#  We use b-spline basis functions of order 6
#  Knots are positioned at the ages of observation.
norder &lt;- 6
nage   &lt;- length(age)
nbasis &lt;- nage + norder - 2
wbasis &lt;- create.bspline.basis(rng, nbasis, norder, age)
#  starting values for coefficient
cvec0 &lt;- matrix(0,nbasis,1)
Wfd0  &lt;- fd(cvec0, wbasis)
#  set up functional parameter object
Lfdobj    &lt;- 3          #  penalize curvature of acceleration
lambda    &lt;- 10^(-0.5)  #  smoothing parameter
growfdPar &lt;- fdPar(Wfd0, Lfdobj, lambda)
#  Smooth the data for the first girl
hgt1 &lt;- growth$hgtf[,1]
#   set conv = 0.1 and iterlim=1 to reduce the compute time
#   required for this test on CRAN;
#   We would not do this normally.
result &lt;- smooth.monotone(age, hgt1, growfdPar, conv=0.1,
                          iterlim=1)
#  Extract the functional data object and regression
#  coefficients
Wfd  &lt;- result$Wfdobj
beta &lt;- result$beta
#  Evaluate the fitted height curve over a fine mesh
agefine &lt;- seq(1,18,len=60)
hgtfine &lt;- beta[1] + beta[2]*eval.monfd(agefine, Wfd)
#  Plot the data and the curve
plot(age, hgt1, type="p")
lines(agefine, hgtfine)
#  Evaluate the acceleration curve
accfine &lt;- beta[2]*eval.monfd(agefine, Wfd, 2)
#  Plot the acceleration curve
plot(agefine, accfine, type="l")
lines(c(1,18),c(0,0),lty=4)

##
## using predict.monfd
##
hgtfit &lt;- with(result, beta[1]+beta[2]*eval.monfd(argvals, Wfdobj))
hgtfit. &lt;- fitted(result)

all.equal(hgtfit, hgtfit.)


accfine. &lt;- predict(result, agefine, Lfdobj=2)

all.equal(accfine, accfine.)


growthResid &lt;- resid(result)

all.equal(growthResid, with(result, y-hgtfit.))

par(oldpar)
</code></pre>

<hr>
<h2 id='eval.penalty'>
Evaluate a Basis Penalty Matrix
</h2><span id='topic+eval.penalty'></span>

<h3>Description</h3>

<p>A basis roughness penalty matrix is the matrix containing
the possible inner products of pairs of basis functions.
These inner products are typically defined in terms of
the value of a derivative or of a linear differential
operator applied to the basis function.  The basis penalty
matrix plays an important role in the computation of
functions whose roughness is controlled by a roughness
penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.penalty(basisobj, Lfdobj=int2Lfd(0), rng=rangeval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.penalty_+3A_basisobj">basisobj</code></td>
<td>
<p>a basis object.</p>
</td></tr>
<tr><td><code id="eval.penalty_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer defining an order of a
derivative or a linear differential operator.
</p>
</td></tr>
<tr><td><code id="eval.penalty_+3A_rng">rng</code></td>
<td>

<p>a vector of length 2 defining a restricted range.
Optionally, the inner products can be computed over
a range of argument values that lies within the
interval covered by the basis function definition.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inner product can be computed exactly for many
types of bases if $m$ is an integer.  These include
B-spline, fourier, exponential, monomial, polynomial and power bases.
In other cases, and for noninteger operators, the
inner products are computed by an iterative numerical
integration method called Richard extrapolation using the
trapezoidal rule.
</p>
<p>If the penalty matrix must be evaluated repeatedly,
computation can be greatly speeded up by avoiding the use
of this function, and instead using quadrature points and
weights defined by Simpson's rule.  
</p>


<h3>Value</h3>

<p>a square symmetric matrix whose order is equal
to the number of basis functions defined by
the basis function object <code> basisobj </code>.
If <code>Lfdobj</code> is $m$ or a linear
differential operator of order $m$, the rank
of the matrix should be at least approximately equal to
its order minus  $m$.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getbasispenalty">getbasispenalty</a></code>, 
<code><a href="#topic+eval.basis">eval.basis</a></code>, 
</p>

<hr>
<h2 id='eval.posfd'>
Evaluate a Positive Functional Data Object
</h2><span id='topic+eval.posfd'></span><span id='topic+predict.posfd'></span><span id='topic+fitted.posfd'></span><span id='topic+residuals.posfd'></span>

<h3>Description</h3>

<p>Evaluate a positive functional data object at specified argument
values, or evaluate a derivative of the functional object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.posfd(evalarg, Wfdobj, Lfdobj=int2Lfd(0))
## S3 method for class 'posfd'
predict(object, newdata=NULL, Lfdobj=0, ...)
## S3 method for class 'posfd'
fitted(object, ...)
## S3 method for class 'posfd'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.posfd_+3A_evalarg">evalarg</code>, <code id="eval.posfd_+3A_newdata">newdata</code></td>
<td>

<p>a vector of argument values at which the functional data object is
to be evaluated.
</p>
</td></tr>
<tr><td><code id="eval.posfd_+3A_wfdobj">Wfdobj</code></td>
<td>

<p>a functional data object that defines the positive function to be
evaluated.  Only univariate functions are permitted.
</p>
</td></tr>
<tr><td><code id="eval.posfd_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>a nonnegative integer specifying a derivative to be evaluated.  At
this time of writing, permissible derivative values are 0, 1 or 2.
A linear differential operator is not allowed.
</p>
</td></tr>
<tr><td><code id="eval.posfd_+3A_object">object</code></td>
<td>

<p>an object of class <code>posfd</code> that defines the positive function
to be evaluated.  Only univariate functions are permitted.
</p>
</td></tr>
<tr><td><code id="eval.posfd_+3A_...">...</code></td>
<td>

<p>optional arguments required by <code>predict</code>;  not currently used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A positive function data object $h(t)$ is defined by $h(t) =[exp
Wfd](t)$.  The function <code>Wfdobj</code> that defines the positive
function is usually estimated by positive smoothing function
<code>smooth.pos</code>
</p>


<h3>Value</h3>

<p>a matrix containing the positive function values.  The first dimension
corresponds to the argument values in <code>evalarg</code> and the second to
replications.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.fd">eval.fd</a></code>,
<code><a href="#topic+eval.monfd">eval.monfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>harmaccelLfd &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))
smallbasis   &lt;- create.fourier.basis(c(0, 365), 65)
index        &lt;- (1:35)[CanadianWeather$place == "Vancouver"]
VanPrec      &lt;- CanadianWeather$dailyAv[,index, "Precipitation.mm"]
lambda       &lt;- 1e4
dayfdPar     &lt;- fdPar(fd(matrix(0,smallbasis$nbasis,1), smallbasis), 
                      harmaccelLfd, lambda)
VanPrecPos   &lt;- smooth.pos(day.5, VanPrec, dayfdPar)
#  compute fitted values using eval.posfd()
VanPrecPosFit1 &lt;- eval.posfd(day.5, VanPrecPos$Wfdobj)
#  compute fitted values using predict()
VanPrecPosFit2 &lt;- predict(VanPrecPos, day.5)

all.equal(VanPrecPosFit1, VanPrecPosFit2)

#  compute fitted values using fitted()
VanPrecPosFit3 &lt;- fitted(VanPrecPos)
#  compute residuals
VanPrecRes &lt;- resid(VanPrecPos)

all.equal(VanPrecRes, VanPrecPos$y-VanPrecPosFit3)


</code></pre>

<hr>
<h2 id='eval.surp'>Values of a Functional Data Object Defining Surprisal Curves.</h2><span id='topic+eval.surp'></span>

<h3>Description</h3>

<p>A surprisal vector of length <code>M</code> is minus the log to a positive integer 
base <code>M</code> of a set of <code>M</code> multinomial probabilities.  Surprisal
curves are functions of a one-dimensional index set, such that at any
value of the index set the values of the curves are a surprisal vector.
See Details below for further explanations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.surp(evalarg, Wfdobj, nderiv = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval.surp_+3A_evalarg">evalarg</code></td>
<td>
<p>a vector or matrix of argument values at which the functional data
object is to be evaluated.</p>
</td></tr>
<tr><td><code id="eval.surp_+3A_wfdobj">Wfdobj</code></td>
<td>
<p>a functional data object of dimension <code>M-1</code> to be evaluated.</p>
</td></tr>
<tr><td><code id="eval.surp_+3A_nderiv">nderiv</code></td>
<td>
<p>An integer defining a derivatve of <code>Wfdobj</code> in
the set <code>c(0,1,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A surprisal <code>M</code>-vector is information measured in <code>M</code>-bits.
Since a multinomial probability vector must sum to one, it follows 
that the surprisal vector <code>S</code> must satisfy the constraint 
<code>log_M(sum(M^(-S)) = 0.</code> That is, surprisal vectors lie within a
curved <code>M-1</code>-dimensional manifold.
</p>
<p>Surprisal curves are defined by a set of unconstrained <code>M-1</code> B-spline 
functional data objects defined over an index set that are transformed into 
surprisal curves defined over the index set.  
</p>
<p>Let <code>C</code> be a <code>K</code> by <code>M-1</code> coefficient matrix defining the 
B-spline curves, where <code>K</code> is the number of B-spline basis functions.  
</p>
<p>Let a <code>M</code> by <code>M-1</code> matrix <code>Z</code> have orthonormal columns.
Matrices satisfying these constraints are generated by function 
<code>zerobasis()</code>.  
</p>
<p>Let <code>N</code> by <code>K</code> matrix be a matrix of B-spline basis values
evaluated at <code>N</code> evaluation points using function 
<code>eval.basis()</code>.
</p>
<p>Let <code>N</code> by <code>M</code> matrix <code>X</code> = <code>B * C * t(Z)</code>. 
</p>
<p>Then the <code>N</code> by <code>M</code> matrix <code>S</code> of surprisal values is
<code>S</code> = <code>-X + outer(log(rowSums(M^X))/log(M),rep(1,M))</code>.
</p>


<h3>Value</h3>

<p>A  <code>N</code> by <code>M</code> matrix <code>S</code> of surprisal values at points
<code>evalarg</code>, or their first or second derivatives.</p>


<h3>Author(s)</h3>

<p>Juan Li and James Ramsay</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.surp">smooth.surp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  see example in man/smooth.surp.Rd
</code></pre>

<hr>
<h2 id='evaldiag.bifd'>
Evaluate the Diagonal of a Bivariate Functional Data Object
</h2><span id='topic+evaldiag.bifd'></span>

<h3>Description</h3>

<p>Bivariate function data objects are functions of
two arguments, $f(s,t)$.  It can be useful to evaluate
the function for argument values satisfying $s=t$, such
as evaluating the univariate variance function given the
bivariate function that defines the variance-covariance
function or surface.  A linear differential operator can
be applied to function $f(s,t)$ considered as a univariate
function of either object holding the other object fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaldiag.bifd(evalarg, bifdobj, sLfd=int2Lfd(0), tLfd=int2Lfd(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaldiag.bifd_+3A_evalarg">evalarg</code></td>
<td>

<p>a vector of values of $s = t$.
</p>
</td></tr>
<tr><td><code id="evaldiag.bifd_+3A_bifdobj">bifdobj</code></td>
<td>

<p>a bivariate functional data object of the <code>bifd</code> class.
</p>
</td></tr>
<tr><td><code id="evaldiag.bifd_+3A_slfd">sLfd</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.
</p>
</td></tr>
<tr><td><code id="evaldiag.bifd_+3A_tlfd">tLfd</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or matrix of diagonal function values.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var.fd">var.fd</a></code>,
<code><a href="#topic+eval.bifd">eval.bifd</a></code>
</p>

<hr>
<h2 id='expon'>
Exponential Basis Function Values
</h2><span id='topic+expon'></span>

<h3>Description</h3>

<p>Evaluates a set of exponential basis functions, or a derivative of these
functions, at a set of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expon(x, ratevec=1, nderiv=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expon_+3A_x">x</code></td>
<td>

<p>a vector of values at which the basis functions are to be evaluated.
</p>
</td></tr>
<tr><td><code id="expon_+3A_ratevec">ratevec</code></td>
<td>

<p>a vector of rate or time constants defining the exponential
functions.  That is, if $a$ is the value of an
element of this vector, then the corresponding basis function
is $exp(at)$. The number of basis functions is equal
to the length of <code>ratevec</code>.
</p>
</td></tr>
<tr><td><code id="expon_+3A_nderiv">nderiv</code></td>
<td>

<p>a nonnegative integer specifying an order of derivative to
be computed.  The default is 0, or the basis function value.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are no restrictions on the rate constants.
</p>


<h3>Value</h3>

<p>a matrix of basis function values with rows corresponding
to argument values and columns to basis functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exponpen">exponpen</a></code>
</p>

<hr>
<h2 id='exponentiate.fd'>
Powers of a functional data ('fd') object
</h2><span id='topic+exponentiate.fd'></span><span id='topic++5E.fd'></span>

<h3>Description</h3>

<p>Exponentiate a functional data object where feasible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
e1 ^ e2
exponentiate.fd(e1, e2, tolint=.Machine$double.eps^0.75,
  basisobj=e1$basis,
  tolfd=sqrt(.Machine$double.eps)*
          sqrt(sum(e1$coefs^2)+.Machine$double.eps)^abs(e2),
  maxbasis=NULL, npoints=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exponentiate.fd_+3A_e1">e1</code></td>
<td>

<p>object of class 'fd'.
</p>
</td></tr>
<tr><td><code id="exponentiate.fd_+3A_e2">e2</code></td>
<td>

<p>a numeric vector of length 1.
</p>
</td></tr>
<tr><td><code id="exponentiate.fd_+3A_basisobj">basisobj</code></td>
<td>
<p>reference basis</p>
</td></tr>
<tr><td><code id="exponentiate.fd_+3A_tolint">tolint</code></td>
<td>

<p>if abs(e2-round(e2))&lt;tolint, we assume e2 is an integer.  This
simplifies the algorithm.
</p>
</td></tr>
<tr><td><code id="exponentiate.fd_+3A_tolfd">tolfd</code></td>
<td>

<p>the maximum error allowed in the difference between the direct
computation <code>eval.fd(e1)^e2</code> and the computed representation.
</p>
</td></tr>
<tr><td><code id="exponentiate.fd_+3A_maxbasis">maxbasis</code></td>
<td>

<p>The maximum number of basis functions in growing
<code>referencebasis</code> to achieve a fit within <code>tolfd</code>.  Default
= 2*nbasis12+1 where nbasis12 =
nbasis of e1^floor(e2).
</p>
</td></tr>
<tr><td><code id="exponentiate.fd_+3A_npoints">npoints</code></td>
<td>

<p>The number of points at which to compute <code>eval.fd(e1)^e2</code> and
the computed representation to evaluate the adequacy of the
representation.  Default =
2*maxbasis-1.  For a max Fourier
basis, this samples the highest
frequency at all its extrema and
zeros.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If e1 has a B-spline basis, this uses the B-spline algorithm.
</p>
<p>Otherwise it throws an error unless it finds one of the following
special cases:
</p>

<dl>
<dt>e2 = 0</dt><dd>
<p>Return an <code>fd</code> object with a constant basis that is
everywhere 1
</p>
</dd>
<dt>e2 is a positive integer to within tolint</dt><dd>
<p>Multiply e1 by itself e2 times
</p>
</dd>
<dt>e2 is positive and e1 has a Fourier basis</dt><dd>
<p>e120 &lt;- e1^floor(e2)
</p>
<p>outBasis &lt;- e120$basis
</p>
<p>rng &lt;- outBasis$rangeval
</p>
<p>Time &lt;- seq(rng[1], rng[2], npoints)
</p>
<p>e1.2 &lt;- predict(e1, Time)^e2
</p>
<p>fd1.2 &lt;- smooth.basis(Time, e1.2, outBasis)$
</p>
<p>d1.2 &lt;- (e1.2 - predict(fd1.2, Time))
</p>
<p>if(all(abs(d1.2)&lt;tolfd))return(fd1.2)
</p>
<p>Else if(outBasis$nbasis&lt;maxbasis) increase the size of outBasis
and try again.
</p>
<p>Else write a warning with the max(abs(d1.2)) and return fd1.2.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A function data object approximating the desired power.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+arithmetic.fd">arithmetic.fd</a></code>
<code><a href="#topic+basisfd">basisfd</a></code>,
<code><a href="#topic+basisfd.product">basisfd.product</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## sin^2
##

basis3 &lt;- create.fourier.basis(nbasis=3)
oldpar &lt;- par(no.readonly=TRUE)
plot(basis3)
# max = sqrt(2), so
# integral of the square of each basis function (from 0 to 1) is 1
integrate(function(x)sin(2*pi*x)^2, 0, 1) # = 0.5

# sin(theta)
fdsin &lt;- fd(c(0,sqrt(0.5),0), basis3)
plot(fdsin)

fdsin2 &lt;- fdsin^2

# check
fdsinsin &lt;- fdsin*fdsin
# sin^2(pi*time) = 0.5*(1-cos(2*pi*theta) basic trig identity
plot(fdsinsin) # good


all.equal(fdsin2, fdsinsin)

par(oldpar)

</code></pre>

<hr>
<h2 id='exponpen'>
Exponential Penalty Matrix
</h2><span id='topic+exponpen'></span>

<h3>Description</h3>

<p>Computes the matrix defining the roughness penalty for functions
expressed in terms of an exponential basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exponpen(basisobj, Lfdobj=int2Lfd(2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exponpen_+3A_basisobj">basisobj</code></td>
<td>

<p>an exponential basis object.
</p>
</td></tr>
<tr><td><code id="exponpen_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A roughness penalty for a function $x(t)$ is defined by
integrating the square of either the derivative of  $ x(t) $ or,
more generally, the result of applying a linear differential operator
$L$ to it.  The most common roughness penalty is the integral of
the square of the second derivative, and
this is the default. To apply this roughness penalty, the matrix of
inner products of the basis functions (possibly after applying the
linear differential operator to them) defining this function
is necessary. This function just calls the roughness penalty evaluation
function specific to the basis involved.
</p>


<h3>Value</h3>

<p>a symmetric matrix of order equal to the number of basis functions
defined by the exponential basis object.  Each element is the inner product
of two exponential basis functions after applying the derivative or linear
differential operator defined by Lfdobj.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expon">expon</a></code>, 
<code><a href="#topic+eval.penalty">eval.penalty</a></code>, 
<code><a href="#topic+getbasispenalty">getbasispenalty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  set up an exponential basis with 3 basis functions
ratevec  &lt;- c(0, -1, -5)
basisobj &lt;- create.exponential.basis(c(0,1),3,ratevec)
#  compute the 3 by 3 matrix of inner products of
#  second derivatives
penmat &lt;- exponpen(basisobj)

</code></pre>

<hr>
<h2 id='fbplot'>
Functional Boxplots
</h2><span id='topic+fbplot'></span><span id='topic+boxplot.fd'></span><span id='topic+boxplot.fdPar'></span><span id='topic+boxplot.fdSmooth'></span>

<h3>Description</h3>

<p>Produces functional boxplots or enhanced functional boxplots of the
given functional data. It can also be used to carry out functional
data ordering based on band depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fbplot(fit, x = NULL, method = "MBD", depth = NULL, plot = TRUE,
	 prob = 0.5, color = 6, outliercol = 2, barcol = 4,
	 fullout=FALSE, factor=1.5,xlim=c(1,nrow(fit)),
	 ylim=c(min(fit)-.5*diff(range(fit)),max(fit)+.5*diff(range(fit))),...)
## S3 method for class 'fd'
boxplot(x, z=NULL, ...)
## S3 method for class 'fdPar'
boxplot(x, z=NULL, ...)
## S3 method for class 'fdSmooth'
boxplot(x, z=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fbplot_+3A_fit">fit</code></td>
<td>

<p>a p-by-n functional data matrix where n is the number of curves, and
p is defined below.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_x">x</code></td>
<td>

<p>For <code>fbplot</code>, <code>x</code> is the x coordinates of curves. Defaults
to 1:p where p is the number of x coordinates.
</p>
<p>For <code>boxplot.fd</code>, <code>boxplot.fdPar</code> and
<code>boxplot.fdSmooth</code>, <code>x</code> is an object of class <code>fd</code>,
<code>fdPar</code> or <code>fdSmooth</code>, respectively.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_z">z</code></td>
<td>

<p>The coordinate of the curves, labeled <code>x</code> for <code>fdplot</code>.
For <code>boxplot.fd</code>, <code>boxplot.fdPar</code> and
<code>boxplot.fdSmooth</code>, this cannot be <code>x</code>, because that would
clash with the generic <code>boxplot(x, ...)</code> standard.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_method">method</code></td>
<td>

<p>the method to be used to compute band depth. Can be one of &quot;BD2&quot;,
&quot;MBD&quot; or &quot;Both&quot; with a default of &quot;MBD&quot;. See also details.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_depth">depth</code></td>
<td>

<p>a vector giving band depths of curves. If missing, band depth
computation is conducted.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_plot">plot</code></td>
<td>

<p>logical. If TRUE (the default) then a functional boxplot is
produced. If not, band depth and outliers are returned.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_prob">prob</code></td>
<td>

<p>a vector giving the probabilities of central regions in a decreasing
order, then an enhanced functional boxplot is produced. Defaults to
be 0.5 and a functional boxplot is plotted.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_color">color</code></td>
<td>

<p>a vector giving the colors of central regions from light to dark for
an enhanced functional boxplot. Defaults to be magenta for a
functional boxplot.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_outliercol">outliercol</code></td>
<td>

<p>color of outlying curves. Defaults to be red.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_barcol">barcol</code></td>
<td>

<p>color of bars in a functional boxplot. Defaults to be blue.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_fullout">fullout</code></td>
<td>

<p>logical for plotting outlying curves. If FALSE (the default) then
only the part outside the box is plotted. If TRUE, complete outlying
curves are plotted.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_factor">factor</code></td>
<td>

<p>the constant factor to inflate the middle box and determine fences
for outliers.  Defaults to be 1.5 as in a classical boxplot.
</p>
</td></tr>
<tr><td><code id="fbplot_+3A_xlim">xlim</code></td>
<td>
<p> x-axis limits </p>
</td></tr>
<tr><td><code id="fbplot_+3A_ylim">ylim</code></td>
<td>
<p> y-axis limits </p>
</td></tr>
<tr><td><code id="fbplot_+3A_...">...</code></td>
<td>

<p>For <code>fbplot</code>, optional arguments for <code>plot</code>.
</p>
<p>For <code>boxplot.fd</code>, <code>boxplot.fdPar</code>, or
<code>boxplot.fdSmooth</code>, optional arguments for <code>fbplot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For functional data, the band depth (BD) or modified band depth (MBD)
allows for ordering a sample of curves from the center outwards and,
thus, introduces a measure to define functional quantiles and the
centrality or outlyingness of an observation. A smaller rank is
associated with a more central position with respect to the sample
curves.  BD usually provides many ties (curves have the same depth
values), but MBD does not.  &quot;BD2&quot; uses two curves to determine a
band. The method &quot;Both&quot; uses &quot;BD2&quot; first  and then uses &quot;MBD&quot; to break
ties.  The method &quot;Both&quot; uses BD2 first and then uses MBD to break
ties.  The computation is carried out by the fast algorithm proposed
by Sun et. al. (2012).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>depth</code></td>
<td>
<p>band depths of given curves.</p>
</td></tr>
<tr><td><code>outpoint</code></td>
<td>
<p>column indices of detected outliers.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ying Sun <a href="mailto:sunwards@stat.osu.edu">sunwards@stat.osu.edu</a>
</p>
<p>Marc G. Genton <a href="mailto:marc.genton@kaust.edu.sa">marc.genton@kaust.edu.sa</a>
</p>


<h3>References</h3>

<p>Sun, Y., Genton, M. G. and Nychka, D. (2012), &quot;Exact fast computation
of band depth for large functional datasets: How quickly can one
million curves be ranked?&quot; Stat, 1, 68-74.
</p>
<p>Sun, Y. and Genton, M. G. (2011), &quot;Functional Boxplots,&quot; Journal of
Computational and Graphical Statistics, 20, 316-334.
</p>
<p>Lopez-Pintado, S. and Romo, J. (2009), &quot;On the concept of depth for
functional data,&quot; Journal of the American Statistical Association,
104, 718-734.
</p>
<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## 1.  generate 50 random curves with some covariance structure
##     model 1 without outliers
##
cov.fun=function(d,k,c,mu){
        k*exp(-c*d^mu)
}
n=50
p=30
t=seq(0,1,len=p)
d=dist(t,upper=TRUE,diag=TRUE)
d.matrix=as.matrix(d)
#covariance function in time
t.cov=cov.fun(d.matrix,1,1,1)
# Cholesky Decomposition
L=chol(t.cov)
mu=4*t
e=matrix(rnorm(n*p),p,n)
ydata  = mu+t(L)%*%e

#functional boxplot
oldpar &lt;- par(no.readonly=TRUE)
fbplot(ydata,method='MBD',ylim=c(-11,15))

# The same using boxplot.fd
boxplot.fd(ydata, method='MBD', ylim=c(-11, 15))

# same with default ylim
boxplot.fd(ydata)

##
## 2.  as an fd object
##
T      = dim(ydata)[1]
time   = seq(0,T,len=T)
ybasis = create.bspline.basis(c(0,T), 23)
Yfd    = smooth.basis(time, ydata, ybasis)$fd
boxplot(Yfd)

##
## 3.  as an fdPar object
##
Ypar &lt;- fdPar(Yfd)
boxplot(Ypar)

##
## 4.  Smoothed version
##
Ysmooth &lt;- smooth.fdPar(Yfd)
boxplot(Ysmooth)

##
## 5.  model 2 with outliers
##
#magnitude
k=6
#randomly introduce outliers
C=rbinom(n,1,0.1)
s=2*rbinom(n,1,0.5)-1
cs.m=matrix(C*s,p,n,byrow=TRUE)

e=matrix(rnorm(n*p),p,n)
y=mu+t(L)%*%e+k*cs.m

#functional boxplot
fbplot(y,method='MBD',ylim=c(-11,15))
par(oldpar)
</code></pre>

<hr>
<h2 id='fd'>
Define a Functional Data Object
</h2><span id='topic+fd'></span><span id='topic++5B.fd'></span>

<h3>Description</h3>

<p>This is the constructor function for objects of the <code>fd</code> class.
Each function that sets up an object of this class must call this
function.  This includes functions  <code><a href="#topic+smooth.basis">smooth.basis</a></code>, <code><a href="#topic+density.fd">density.fd</a></code>, and so forth
that estimate functional data objects that smooth or otherwise
represent data.  Ordinarily, users of the functional data analysis
software will not need to call this function directly, but these notes
are valuable to understanding the components of a <code>list</code> of class
<code>fd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd(coef=NULL, basisobj=NULL, fdnames=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fd_+3A_coef">coef</code></td>
<td>

<p>a vector, matrix, or three-dimensional array of coefficients.
</p>
<p>The first dimension (or elements of a vector) corresponds to basis
functions.
</p>
<p>A second dimension corresponds to the number of functional
observations, curves or replicates.  If <code>coef</code> is a vector, it
represents only a single functional observation.
</p>
<p>If <code>coef</code> is an array, the third dimension corresponds to
variables for multivariate functional data objects.
</p>
<p>A functional data object is &quot;univariate&quot; if <code>coef</code> is a vector
or matrix and &quot;multivariate&quot; if it is a three-dimensional array.
</p>
<p>if(is.null(coef)) coef &lt;- rep(0, basisobj[['nbasis']])
</p>
</td></tr>
<tr><td><code id="fd_+3A_basisobj">basisobj</code></td>
<td>

<p>a functional basis object defining the basis
</p>
<p><code>
      if(is.null(basisobj)){
	if(is.null(coef)) basisobj &lt;- basisfd()
	else {
	  rc &lt;- range(coef)
	  if(diff(rc)==0) rc &lt;- rc+0:1
	  nb &lt;- max(4, nrow(coef))
	  basisobj &lt;- create.bspline.basis(rc, nbasis = nb)
	}
      }
    </code>
</p>
</td></tr>
<tr><td><code id="fd_+3A_fdnames">fdnames</code></td>
<td>

<p>A list of length 3, each member being a string vector containing
labels for the levels of the corresponding dimension of the discrete
data.  The first dimension is for argument values, and is given the
default name &quot;time&quot;, the second is for replications, and is given
the default name &quot;reps&quot;, and the third is for functions, and is
given the default name &quot;values&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To check that an object is of this class, use function
<code>is.fd</code>.
</p>
<p>Normally only developers of new functional data analysis
functions will actually need to use this function.
</p>


<h3>Value</h3>

<p>A functional data object (i.e., having class <code>fd</code>), which is a
list with components named <code>coefs</code>, <code>basis</code>, and
<code>fdnames</code>.
</p>


<h3>Source</h3>

<p>Ramsay, James O., and Silverman, Bernard W. (2006), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis">smooth.basis</a></code>
<code><a href="#topic+smooth.fdPar">smooth.fdPar</a></code>
<code><a href="#topic+smooth.basisPar">smooth.basisPar</a></code>
<code><a href="#topic+density.fd">density.fd</a></code>
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>
<code><a href="#topic+arithmetic.fd">arithmetic.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## default
##
fd()
oldpar &lt;- par(no.readonly=TRUE)
##
## The simplest b-spline basis:  order 1, degree 0, zero interior knots:
##       a single step function
##
bspl1.1    &lt;- create.bspline.basis(norder=1, breaks=0:1)
fd.bspl1.1 &lt;- fd(0, basisobj=bspl1.1)

fd.bspl1.1a &lt;- fd(basisobj=bspl1.1)

all.equal(fd.bspl1.1, fd.bspl1.1a)

# TRUE

# the following three lines shown an error in a non-cran check:
# if(!CRAN()) {
#   fd.bspl1.1b &lt;- fd(0)
# }

##
## Cubic spline:  4  basis functions
##
bspl4 &lt;- create.bspline.basis(nbasis=4)
plot(bspl4)
parab4.5 &lt;- fd(c(3, -1, -1, 3)/3, bspl4)
# = 4*(x-.5)^2
plot(parab4.5)

##
## Fourier basis
##
f3 &lt;- fd(c(0,0,1), create.fourier.basis())
plot(f3)
# range over +/-sqrt(2), because
# integral from 0 to 1 of cos^2 = 1/2
# so multiply by sqrt(2) to get
# its square to integrate to 1.

##
## subset of an fd object
##

gaitbasis3 &lt;- create.fourier.basis(nbasis=5)
gaittime = (1:20)/21
gaitfd3    &lt;- smooth.basis(gaittime, gait, gaitbasis3)$fd
gaitfd3[1]
par(oldpar)
</code></pre>

<hr>
<h2 id='fd2list'>
Convert a univariate functional data object to a list
</h2><span id='topic+fd2list'></span>

<h3>Description</h3>

<p>Convert a univariate functional data object to a list for input to
<code><a href="#topic+Lfd">Lfd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd2list(fdobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fd2list_+3A_fdobj">fdobj</code></td>
<td>

<p>a univariate functional data object.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list as required for the second argument of <code><a href="#topic+Lfd">Lfd</a></code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lfd">Lfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lbasis  = create.constant.basis(c(0,365));  #  create a constant basis
Lcoef   = matrix(c(0,(2*pi/365)^2,0),1,3)   #  set up three coefficients
wfdobj  = fd(Lcoef,Lbasis)      # define an FD object for weight functions
wfdlist = fd2list(wfdobj)       # convert the FD object to a cell object
harmaccelLfd = Lfd(3, wfdlist)  #  define the operator object
</code></pre>

<hr>
<h2 id='fda'>Functions for statistical analyses of functions</h2><span id='topic+fda'></span>

<h3>Description</h3>

<p>The data analyses that we use for data matrices or dataFrames, such as means, covariances, linear regressions, principal and canonical component analyses, can also be applied to samples of functions or curves.  This package provides functional versions of these analyses along with plotting and other assessment tools.  
</p>
<p>The functions themselves are often a consequence of smoothing discrete data values over domains like time, space, and other continuous variables.  Data smoothing tools are also provided.
</p>
<p>But there are transformations of functions that have no meaning for data matrices for which rows may be re-ordered.  Derivatives and integrals are often used to set up dynamic models, and can also play a constructive role in the data smoothing process.  Methods for these and other functional operations are also available in this package.
</p>
<p>There are now many texts and papers on functional data analysis.  The two resources provided by the buildeers of the fda package are:
</p>
<p>James Ramsay and Bernard Silverman (2005) Functional Data Analysis. New York, Springer.
</p>
<p>James Ramsay, Giles Hooker and Spencer Graves (2009) Functional Data Analysis with R and Matlab.  New York: Springer.
</p>
<p>Another relevant package is the package Data2LD that offers ann introduction and methods for constructing linear and nonlinear differential equation models, along with the text: 
</p>
<p>James Ramsay and Giles Hooker, Dynamic Data Analysis, New York: Springer.
</p>

<hr>
<h2 id='fdlabels'>
Extract plot labels and names for replicates and variables 
</h2><span id='topic+fdlabels'></span>

<h3>Description</h3>

<p>Extract plot labels and, if available, names for each replicate and
variable 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdlabels(fdnames, nrep, nvar) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdlabels_+3A_fdnames">fdnames</code></td>
<td>

<p>a list of length 3 with xlabel, casenames, and ylabels.  
</p>
</td></tr>
<tr><td><code id="fdlabels_+3A_nrep">nrep</code></td>
<td>
<p> integer number of cases or observations </p>
</td></tr>
<tr><td><code id="fdlabels_+3A_nvar">nvar</code></td>
<td>
<p>integer number of variables </p>
</td></tr>
</table>


<h3>Details</h3>

<p>xlabel &lt;- if(length(fdnames[[1]])&gt;1) names(fdnames)[1] else 
fdnames[[1]] 
</p>
<p>ylabel &lt;- if(length(fdnames[[3]])&gt;1) names(fdnames)[3] else
fdnames[[3]] 
</p>
<p>casenames &lt;- if(length(fdnames[[2]])== nrep)fdnames[[2]] else NULL
</p>
<p>varnames &lt;- if(length(fdnames[[3]])==nvar)fdnames[[3]] else NULL 
</p>


<h3>Value</h3>

<p>A list of xlabel, ylabel, casenames, and varnames 
</p>


<h3>Author(s)</h3>

<p>Jim Ramsay</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fd">plot.fd</a></code> 
</p>

<hr>
<h2 id='fdPar'>
Define a Functional Parameter Object
</h2><span id='topic+fdPar'></span>

<h3>Description</h3>

<p>Functional parameter objects are used as arguments to functions that
estimate functional parameters, such as smoothing functions like
<code>smooth.basis</code>.  A functional parameter object is a functional
data object with additional slots specifying a roughness penalty, a
smoothing parameter and whether or not the functional parameter is to
be estimated or held fixed.  Functional parameter objects are used as
arguments to functions that estimate functional parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fdPar(fdobj=NULL, Lfdobj=NULL, lambda=0, estimate=TRUE, penmat=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdPar_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object, functional basis object, a functional
parameter object or a matrix.  If it a matrix, it is replaced by
fd(fdobj).  If class(fdobj) == 'basisfd', it is converted to an
object of class <code>fd</code> with a coefficient matrix consisting of a
single column of zeros.
</p>
</td></tr>
<tr><td><code id="fdPar_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.
</p>
<p>If <code>NULL</code>, Lfdobj depends on fdobj[['basis']][['type']]:
</p>

<dl>
<dt>bspline</dt><dd><p>Lfdobj &lt;- int2Lfd(max(0, norder-2)), 
where norder = norder(fdobj).</p>
</dd>
<dt>fourier</dt><dd><p>Lfdobj = a harmonic acceleration operator:
<code>Lfdobj &lt;- vec2Lfd(c(0,(2*pi/diff(rng))^2,0), rng)</code>
where rng = fdobj[['basis']][['rangeval']].</p>
</dd>
<dt>anything else</dt><dd><p>Lfdobj &lt;- int2Lfd(0)</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fdPar_+3A_lambda">lambda</code></td>
<td>

<p>a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter.
</p>
</td></tr>
<tr><td><code id="fdPar_+3A_estimate">estimate</code></td>
<td>
<p>not currently used.</p>
</td></tr>
<tr><td><code id="fdPar_+3A_penmat">penmat</code></td>
<td>

<p>a roughness penalty matrix.  Including this can eliminate the need
to compute this matrix over and over again in some types of
calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functional parameters are often needed to specify initial
values for iteratively refined estimates, as is the case in
functions <code>register.fd</code> and <code>smooth.monotone</code>.
</p>
<p>Often a list of functional parameters must be supplied to a function
as an argument, and it may be that some of these parameters are
considered known and must remain fixed during the analysis.  This is
the case for functions <code>fRegress</code> and  <code>pda.fd</code>, for
example.
</p>


<h3>Value</h3>

<p>a functional parameter object (i.e., an object of class <code>fdPar</code>),
which is a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>fd</code></td>
<td>

<p>a functional data object (i.e., with class <code>fd</code>)
</p>
</td></tr>
<tr><td><code>Lfd</code></td>
<td>

<p>a linear differential operator object (i.e., with class
<code>Lfd</code>)
</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>a nonnegative real number
</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>not currently used</p>
</td></tr>
<tr><td><code>penmat</code></td>
<td>

<p>either NULL or a square, symmetric matrix with penmat[i, j] =
integral over fd[['basis']][['rangeval']] of basis[i]*basis[j]
</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Ramsay, James O., and Silverman, Bernard W. (2006), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cca.fd">cca.fd</a></code>,
<code><a href="#topic+density.fd">density.fd</a></code>,
<code><a href="#topic+fRegress">fRegress</a></code>,
<code><a href="#topic+intensity.fd">intensity.fd</a></code>,
<code><a href="#topic+pca.fd">pca.fd</a></code>,
<code><a href="#topic+smooth.fdPar">smooth.fdPar</a></code>,
<code><a href="#topic+smooth.basis">smooth.basis</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+int2Lfd">int2Lfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## Simple example
##
#  set up range for density
rangeval &lt;- c(-3,3)
#  set up some standard normal data
x &lt;- rnorm(50)
#  make sure values within the range
x[x &lt; -3] &lt;- -2.99
x[x &gt;  3] &lt;-  2.99
#  set up basis for W(x)
basisobj &lt;- create.bspline.basis(rangeval, 11)
#  set up initial value for Wfdobj
Wfd0 &lt;- fd(matrix(0,11,1), basisobj)
WfdParobj &lt;- fdPar(Wfd0)

WfdP3 &lt;- fdPar(seq(-3, 3, length=11))

##
##  smooth the Canadian daily temperature data
##
#    set up the fourier basis
nbasis   &lt;- 365
dayrange &lt;- c(0,365)
daybasis &lt;- create.fourier.basis(dayrange, nbasis)
dayperiod &lt;- 365
harmaccelLfd &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), dayrange)
#  Make temperature fd object
#  Temperature data are in 12 by 365 matrix tempav
#    See analyses of weather data.
#  Set up sampling points at mid days
daytime  &lt;- (1:365)-0.5
#  Convert the data to a functional data object
daybasis65 &lt;- create.fourier.basis(dayrange, nbasis, dayperiod)
templambda &lt;- 1e1
tempfdPar  &lt;- fdPar(fdobj=daybasis65, Lfdobj=harmaccelLfd,
                    lambda=templambda)

#FIXME
#tempfd &lt;- smooth.basis(CanadianWeather$tempav, daytime, tempfdPar)$fd
#  Set up the harmonic acceleration operator
Lbasis  &lt;- create.constant.basis(dayrange);
Lcoef   &lt;- matrix(c(0,(2*pi/365)^2,0),1,3)
bfdobj  &lt;- fd(Lcoef,Lbasis)
bwtlist &lt;- fd2list(bfdobj)
harmaccelLfd &lt;- Lfd(3, bwtlist)
#  Define the functional parameter object for
#  smoothing the temperature data
lambda   &lt;- 0.01  #  minimum GCV estimate
#tempPar &lt;- fdPar(daybasis365, harmaccelLfd, lambda)
#  smooth the data
#tempfd &lt;- smooth.basis(daytime, CanadialWeather$tempav, tempPar)$fd
#  plot the temperature curves
#plot(tempfd)

##
## with rangeval of class Date and POSIXct
##
par(oldpar)

</code></pre>

<hr>
<h2 id='fdParcheck'>
Convert <code>fd</code> or <code>basisfd</code> Objects to <code>fdPar</code> Objects
</h2><span id='topic+fdParcheck'></span>

<h3>Description</h3>

<p>If the input is an <code>fd</code> object, default <code>fdPar</code> parameters are 
added to convert the object to an <code>fdPar</code> object.  
If a <code>basisfd</code> object,  it is first converted to an <code>fd</code> object 
with a <code>nbasis</code> by <code>ncurve</code> coefficient matrix of zeros, 
and then converted to a <code>fdPar</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdParcheck(fdParobj, ncurve=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdParcheck_+3A_fdparobj">fdParobj</code></td>
<td>
<p>A <code>basisfd</code>, <code>fd</code> or a <code>fdPar</code> object.</p>
</td></tr>
<tr><td><code id="fdParcheck_+3A_ncurve">ncurve</code></td>
<td>
<p>The number of curves or functions for which the basis
object is to be used in their representation.  If missing, an error
message is displayed and computation terminated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The previous version of this function did not include the argument
<code>ncurve</code>, and set up an <code>fd</code> object with a square
matrix of zeros.  This could cause an error in many of the 
functions that called it.
</p>


<h3>Value</h3>

<p>Returns a <code>fdPar</code> object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='fourier'>
Fourier Basis Function Values
</h2><span id='topic+fourier'></span>

<h3>Description</h3>

<p>Evaluates a set of Fourier basis functions, or a derivative of these
functions, at a set of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier(x, nbasis=n, period=span, nderiv=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fourier_+3A_x">x</code></td>
<td>

<p>a vector of argument values at which the Fourier basis functions are
to be evaluated.
</p>
</td></tr>
<tr><td><code id="fourier_+3A_nbasis">nbasis</code></td>
<td>

<p>the number of basis functions in the Fourier basis.  The first basis
function is the constant function, followed by sets of  sine/cosine
pairs.  Normally the number of basis functions will be an odd.  The
default number is the number of argument values.
</p>
</td></tr>
<tr><td><code id="fourier_+3A_period">period</code></td>
<td>

<p>the width of an interval over which all sine/cosine basis functions
repeat themselves. The default is the difference between the largest
and smallest argument values.
</p>
</td></tr>
<tr><td><code id="fourier_+3A_nderiv">nderiv</code></td>
<td>

<p>the derivative to be evaluated.  The derivative must not exceed the
order.  The default derivative is 0, meaning that the basis functions
themselves are evaluated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of function values.  The number of rows equals the number of
arguments, and the number of columns equals the number of basis functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fourierpen">fourierpen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  set up a set of 11 argument values
x &lt;- seq(0,1,0.1)
names(x) &lt;- paste("x", 0:10, sep="")
#  compute values for five Fourier basis functions
#  with the default period (1) and derivative (0)
(basismat &lt;- fourier(x, 5))

# Create a false Fourier basis, i.e., nbasis = 1
# = a constant function
fourier(x, 1)

</code></pre>

<hr>
<h2 id='fourierpen'>
Fourier Penalty Matrix
</h2><span id='topic+fourierpen'></span>

<h3>Description</h3>

<p>Computes the matrix defining the roughness penalty for functions
expressed in terms of a Fourier basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourierpen(basisobj, Lfdobj=int2Lfd(2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fourierpen_+3A_basisobj">basisobj</code></td>
<td>

<p>a Fourier basis object.
</p>
</td></tr>
<tr><td><code id="fourierpen_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A roughness penalty for a function $x(t)$ is defined by
integrating the square of either the derivative of  $ x(t) $ or,
more generally, the result of applying a linear differential operator
$L$ to it.  The most common roughness penalty is the integral of
the square of the second derivative, and
this is the default. To apply this roughness penalty, the matrix of
inner products of the basis functions (possibly after applying the
linear differential operator to them) defining this function
is necessary. This function just calls the roughness penalty evaluation
function specific to the basis involved.
</p>


<h3>Value</h3>

<p>a symmetric matrix of order equal to the number of basis functions
defined by the Fourier basis object.  Each element is the inner product
of two Fourier basis functions after applying the derivative or linear
differential operator defined by Lfdobj.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fourier">fourier</a></code>, 
<code><a href="#topic+eval.penalty">eval.penalty</a></code>, 
<code><a href="#topic+getbasispenalty">getbasispenalty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  set up a Fourier basis with 13 basis functions
#  and and period 1.0.
basisobj &lt;- create.fourier.basis(c(0,1),13)
#  compute the 13 by 13 matrix of inner products
#  of second derivatives
penmat &lt;- fourierpen(basisobj)

</code></pre>

<hr>
<h2 id='Fperm.fd'>
Permutation F-test for functional linear regression.
</h2><span id='topic+Fperm.fd'></span>

<h3>Description</h3>

<p><code>Fperm.fd</code> creates a null distribution for a test of no effect in
functional linear regression.  It makes generic use of <code>fRegress</code>
and permutes the <code>yfdPar</code> input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fperm.fd(yfdPar, xfdlist, betalist, wt=NULL, nperm=200,
         argvals=NULL, q=0.05, plotres=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fperm.fd_+3A_yfdpar">yfdPar</code></td>
<td>

<p>the dependent variable object.  It may be an object of three
possible classes:
</p>

<dl>
<dt>vector</dt><dd><p> if the dependent variable is scalar.</p>
</dd>
<dt>fd</dt><dd>
<p>a functional data object if the dependent variable is
functional.
</p>
</dd>
<dt>fdPar</dt><dd>
<p>a functional parameter object if the dependent variable is
functional, and if it is necessary to smooth the prediction of
the dependent variable.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="Fperm.fd_+3A_xfdlist">xfdlist</code></td>
<td>

<p>a list of length equal to the number of independent
variables. Members of this list are the independent variables.  They
be objects of either of these two classes:
</p>

<dl>
<dt>vector:</dt><dd><p>a vector if the independent dependent variable is scalar.</p>
</dd>
<dt>fd:</dt><dd><p>a functional data object if the dependent variable is 
functional.</p>
</dd>
</dl>

<p>In either case, the object must have the same number of replications
as the dependent variable object.  That is, if it is a scalar, it
must be of the same length as the dependent variable, and if it is
functional, it must have the same number of replications as the
dependent variable.
</p>
</td></tr>
<tr><td><code id="Fperm.fd_+3A_betalist">betalist</code></td>
<td>

<p>a list of length equal to the number of independent variables.
Members of this list define the regression functions to be
estimated.  They are functional parameter objects.  Note that even
if corresponding independent variable is scalar, its regression
coefficient will be functional if the dependent variable is
functional.  Each of these functional parameter objects defines a
single functional data object, that is, with only one replication.
</p>
</td></tr>
<tr><td><code id="Fperm.fd_+3A_wt">wt</code></td>
<td>

<p>weights for weighted least squares, defaults to all 1.
</p>
</td></tr>
<tr><td><code id="Fperm.fd_+3A_nperm">nperm</code></td>
<td>

<p>number of permutations to use in creating the null distribution.
</p>
</td></tr>
<tr><td><code id="Fperm.fd_+3A_argvals">argvals</code></td>
<td>

<p>If <code>yfdPar</code> is a <code>fd</code> object, the points at which to
evaluate the point-wise F-statistic.
</p>
</td></tr>
<tr><td><code id="Fperm.fd_+3A_q">q</code></td>
<td>

<p>Critical upper-tail quantile of the null distribution to compare to
the observed F-statistic.
</p>
</td></tr>
<tr><td><code id="Fperm.fd_+3A_plotres">plotres</code></td>
<td>

<p>Argument to plot a visual display of the null distribution
displaying the <code>q</code>th quantile and observed F-statistic.
</p>
</td></tr>
<tr><td><code id="Fperm.fd_+3A_...">...</code></td>
<td>

<p>Additional plotting arguments that can be used with <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An F-statistic is calculated as the ratio of residual variance to
predicted variance. The observed F-statistic is returned along with
the permutation distribution.
</p>
<p>If <code>yfdPar</code> is a <code>fd</code> object, the maximal value of the
pointwise F-statistic is calculated. The pointwise F-statistics are
also returned.
</p>
<p>The default of setting <code>q = 0.95</code> is, by now, fairly
standard. The default <code>nperm = 200</code> may be small, depending on
the amount of computing time available.
</p>
<p>If <code>argvals</code> is not specified and <code>yfdPar</code> is a <code>fd</code>
object, it defaults to 101 equally-spaced points on the range of
<code>yfdPar</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>the observed p-value of the permutation test.</p>
</td></tr>
<tr><td><code>qval</code></td>
<td>
<p>the <code>q</code>th quantile of the null distribution.</p>
</td></tr>
<tr><td><code>Fobs</code></td>
<td>
<p>the observed maximal F-statistic.</p>
</td></tr>
<tr><td><code>Fnull</code></td>
<td>

<p>a vector of length <code>nperm</code> giving the observed values of the
permutation distribution.
</p>
</td></tr>
<tr><td><code>Fvals</code></td>
<td>
<p>the pointwise values of the observed F-statistic.</p>
</td></tr>
<tr><td><code>Fnullvals</code></td>
<td>

<p>the pointwise values of of the permutation observations.
</p>
</td></tr>
<tr><td><code>pvals.pts</code></td>
<td>
<p>pointwise p-values of the F-statistic.</p>
</td></tr>
<tr><td><code>qvals.pts</code></td>
<td>

<p>pointwise <code>q</code>th quantiles of the null distribution
</p>
</td></tr>
<tr><td><code>fRegressList</code></td>
<td>

<p>the result of <code>fRegress</code> on the observed data
</p>
</td></tr>
<tr><td><code>argvals</code></td>
<td>

<p>argument values for evaluating the F-statistic if <code>yfdPar</code> is a
functional data object.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>a plot of the functional observations
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress">fRegress</a></code>,
<code><a href="#topic+Fstat.fd">Fstat.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## 1.  yfdPar = vector
##
annualprec &lt;- log10(apply(
    CanadianWeather$dailyAv[,,"Precipitation.mm"], 2,sum))

#  set up a smaller basis using only 40 Fourier basis functions
#  to save some computation time

smallnbasis &lt;- 40
smallbasis  &lt;- create.fourier.basis(c(0, 365), smallnbasis)
tempfd      &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"],
                            smallbasis)$fd
constantfd &lt;- fd(matrix(1,1,35), create.constant.basis(c(0, 365)))

xfdlist &lt;- vector("list",2)
xfdlist[[1]] &lt;- constantfd
xfdlist[[2]] &lt;- tempfd[1:35]

betalist   &lt;- vector("list",2)
#  set up the first regression function as a constant
betabasis1 &lt;- create.constant.basis(c(0, 365))
betafd1    &lt;- fd(0, betabasis1)
betafdPar1 &lt;- fdPar(betafd1)
betalist[[1]] &lt;- betafdPar1

nbetabasis  &lt;- 35
betabasis2  &lt;- create.fourier.basis(c(0, 365), nbetabasis)
betafd2     &lt;- fd(matrix(0,nbetabasis,1), betabasis2)

lambda          &lt;- 10^12.5
harmaccelLfd365 &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))
betafdPar2      &lt;- fdPar(betafd2, harmaccelLfd365, lambda)
betalist[[2]]   &lt;- betafdPar2

# Should use the default nperm = 200
# but use 10 to save test time for illustration

F.res2 = Fperm.fd(annualprec, xfdlist, betalist, nperm=100)

##
## 2.  yfdpar = Functional data object (class fd)
##
# The very simplest example is the equivalent of the permutation
# t-test on the growth data.

# First set up a basis system to hold the smooths

if (!CRAN()) {

Knots  &lt;- growth$age
norder &lt;- 6
nbasis &lt;- length(Knots) + norder - 2
hgtbasis &lt;- create.bspline.basis(range(Knots), nbasis, norder, Knots)

# Now smooth with a fourth-derivative penalty and a very small smoothing
# parameter

Lfdobj    &lt;- 4
lambda    &lt;- 1e-2
growfd    &lt;- fd(matrix(0,nbasis,1),hgtbasis)
growfdPar &lt;- fdPar(growfd, Lfdobj, lambda)

hgtfd &lt;- smooth.basis(growth$age,
                      cbind(growth$hgtm,growth$hgtf),growfdPar)$fd

# Now set up factors for fRegress:

cbasis = create.constant.basis(range(Knots))

maleind = c(rep(1,ncol(growth$hgtm)),rep(0,ncol(growth$hgtf)))

constfd = fd( matrix(1,1,length(maleind)),cbasis)
maleindfd = fd( matrix(maleind,1,length(maleind)),cbasis)

xfdlist = list(constfd,maleindfd)

# The fdPar object for the coefficients and call Fperm.fd

betalist = list(fdPar(hgtfd,2,1e-6),fdPar(hgtfd,2,1e-6))

# Should use nperm = 200 or so,
# but use 10 to save test time

Fres = Fperm.fd(hgtfd,xfdlist,betalist,nperm=100)

par(oldpar)
}

</code></pre>

<hr>
<h2 id='fRegress'>
Functional Regression Analysis
</h2><span id='topic+fRegress'></span><span id='topic+fRegress.fd'></span><span id='topic+fRegress.double'></span><span id='topic+fRegress.formula'></span><span id='topic+fRegress.character'></span>

<h3>Description</h3>

<p>This function carries out a functional regression analysis, where
either the dependent variable or one or more independent variables are
functional.  Non-functional variables may be used on either side
of the equation.  In a simple problem where there is a single scalar
independent covariate with values <code class="reqn">z_i, i=1,\ldots,N</code> and a single
functional covariate with values <code class="reqn">x_i(t)</code>, the two versions of the
model fit by <code>fRegress</code> are the <em>scalar</em> dependent variable
model
</p>
<p style="text-align: center;"><code class="reqn">y_i = \beta_1 z_i + \int x_i(t) \beta_2(t) \, dt + e_i</code>
</p>

<p>and the <em>concurrent</em> functional dependent variable model
</p>
<p style="text-align: center;"><code class="reqn">y_i(t) = \beta_1(t) z_i + \beta_2(t) x_i(t) + e_i(t).</code>
</p>

<p>In these models, the final term <code class="reqn">e_i</code> or <code class="reqn">e_i(t)</code> is a
residual, lack of fit or error term.
</p>
<p>In the concurrent functional linear model for a functional dependent
variable, all functional   variables are all evaluated at a common
time or argument value <code class="reqn">t</code>.  That is, the fit is defined in terms of
the behavior of all variables at a fixed time, or in terms of &quot;now&quot;
behavior.
</p>
<p>All regression coefficient functions <code class="reqn">\beta_j(t)</code> are considered
to be functional.  In the case of a scalar dependent variable, the
regression coefficient for a scalar covariate is converted to a
functional variable with a constant basis.   All regression
coefficient functions can be forced to be <em>smooth</em> through the
use of roughness penalties, and consequently are specified in the
argument list as functional parameter objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fRegress(y, ...)
## S3 method for class 'fd'
fRegress(y, xfdlist, betalist, wt=NULL,
                     y2cMap=NULL, SigmaE=NULL, returnMatrix=FALSE, 
                        method=c('fRegress', 'model'), sep='.', ...)
## S3 method for class 'double'
fRegress(y, xfdlist, betalist, wt=NULL,
                     y2cMap=NULL, SigmaE=NULL, returnMatrix=FALSE, ...)
## S3 method for class 'formula'
fRegress(y, data=NULL, betalist=NULL, wt=NULL,
                 y2cMap=NULL, SigmaE=NULL,
                 method='fRegress', sep='.', ...)
## S3 method for class 'character'
fRegress(y, data=NULL, betalist=NULL, wt=NULL,
                 y2cMap=NULL, SigmaE=NULL,
                 method='fRegress', sep='.', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fRegress_+3A_y">y</code></td>
<td>

<p>the dependent variable object.  It may be an object of five
possible classes or attributes:
</p>

<dl>
<dt>character or formula</dt><dd>
<p>a <code>formula</code> object or a <code>character</code> object that can be
coerced into a <code>formula</code> providing a symbolic description
of the model to be fitted satisfying the following rules:
</p>
<p>The left hand side, <code>formula</code> <code>y</code>, must be either a
numeric vector or a univariate object of class <code>fd</code>.  
</p>
<p>All objects named on the right hand side must be either
<code>numeric</code> or <code>fd</code> (functional data).
The number of replications of <code>fd</code> 
object(s) must match each other and the number of observations
of <code>numeric</code> objects named, as well as the number of
replications of the dependent variable object.  The right hand
side of this <code>formula</code> is translated into <code>xfdlist</code>,
then passed to another method for fitting (unless <code>method</code>
= 'model'). Multivariate independent variables are allowed in a
<code>formula</code> and are split into univariate independent
variables in the resulting <code>xfdlist</code>.  Similarly,
categorical independent variables with <code class="reqn">k</code> levels are
translated into <code class="reqn">k-1</code> contrasts in <code>xfdlist</code>.  Any
smoothing information is passed to the corresponding component
of <code>betalist</code>.
</p>
</dd>
<dt>numeric</dt><dd>
<p>a numeric vector object or a matrix object if the dependent variable 
is numeric or a matrix.
</p>
</dd>
<dt>fd</dt><dd>
<p>a functional data object or an fdPar object if the dependent variable is
functional.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="fRegress_+3A_data">data</code></td>
<td>

<p>an optional <code>list</code> or <code>data.frame</code> containing names of
objects identified in the <code>formula</code> or <code>character</code>
<code>y</code>.
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_xfdlist">xfdlist</code></td>
<td>

<p>a list of length equal to the number of independent
variables (including any intercept). Members of this list are the
independent variables.  They can be objects of either of these two
classes:
</p>

<dl>
<dt>scalar</dt><dd>
<p>a numeric vector if the independent variable is scalar.
</p>
</dd>
<dt>fd</dt><dd>
<p>a (univariate) functional data object.
</p>
</dd>
</dl>

<p>In either case, the object must have the same number of replications
as the dependent variable object.  That is, if it is a scalar, it
must be of the same length as the dependent variable, and if it is
functional, it must have the same number of replications as the
dependent variable.  (Only univariate independent variables are
currently allowed in <code>xfdlist</code>.)
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_betalist">betalist</code></td>
<td>

<p>For the <code>fd</code>, <code>fdPar</code>, and <code>numeric</code> methods,
<code>betalist</code> must be a list of length equal to
<code>length(xfdlist)</code>.  Members of this list are functional
parameter objects (class <code>fdPar</code>) defining the regression
functions to be estimated.  Even if a corresponding independent
variable is scalar, its regression coefficient must be functional if
the dependent variable is functional.  (If the dependent variable is
a scalar, the coefficients of scalar independent variables,
including the intercept, must be constants, but the coefficients of
functional independent variables must be functional.)  Each of these
functional parameter objects defines a single functional data
object, that is, with only one replication.
</p>
<p>For the <code>formula</code> and <code>character</code> methods, <code>betalist</code>
can be either a <code>list</code>, as for the other methods, or
<code>NULL</code>, in which case a list is created.  If <code>betalist</code> is
created, it will use the bases from the corresponding component of
<code>xfdlist</code> if it is function or from the response variable.
Smoothing information (arguments <code>Lfdobj</code>, <code>lambda</code>,
<code>estimate</code>, and <code>penmat</code> of function <code>fdPar</code>) will
come from the corresponding component of <code>xfdlist</code> if it is of
class <code>fdPar</code> (or for scalar independent variables from the
response variable if it is of class <code>fdPar</code>) or from optional
<code>...</code> arguments if the reference variable is not of class
<code>fdPar</code>.
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_wt">wt</code></td>
<td>

<p>weights for weighted least squares
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_y2cmap">y2cMap</code></td>
<td>

<p>the matrix mapping from the vector of observed values to the
coefficients for the dependent variable.  This is output by function
<code>smooth.basis</code>.  If this is supplied, confidence limits are
computed, otherwise not.
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_sigmae">SigmaE</code></td>
<td>

<p>Estimate of the covariances among the residuals.  This can only be
estimated after a preliminary analysis with <code>fRegress</code>.
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_method">method</code></td>
<td>

<p>a character string matching either <code>fRegress</code> for functional
regression estimation or <code>mode</code> without running it.
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_sep">sep</code></td>
<td>

<p>separator for creating names for multiple variables for
<code>fRegress.fdPar</code> or <code>fRegress.numeric</code> created from single
variables on the right hand side of the <code>formula</code> <code>y</code>.
This happens with multidimensional <code>fd</code> objects as well as with
categorical variables.
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
<tr><td><code id="fRegress_+3A_...">...</code></td>
<td>
<p> optional arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternative forms of functional regression can be categorized with
traditional least squares using the following 2 x 2 table:
</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> </td><td style="text-align: center;"> explanatory </td><td style="text-align: center;"> variable </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    response </td><td style="text-align: center;"> | </td><td style="text-align: center;"> scalar </td><td style="text-align: center;"> | </td><td style="text-align: center;"> function </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> | </td><td style="text-align: center;"> </td><td style="text-align: center;"> | </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    scalar </td><td style="text-align: center;"> | </td><td style="text-align: center;"> lm </td><td style="text-align: center;"> | </td><td style="text-align: center;"> fRegress.numeric </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> | </td><td style="text-align: center;"> </td><td style="text-align: center;"> | </td><td style="text-align: center;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
    function </td><td style="text-align: center;"> | </td><td style="text-align: center;"> fRegress.fd or </td><td style="text-align: center;"> | </td><td style="text-align: center;"> fRegress.fd
    or </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: center;"> | </td><td style="text-align: center;"> fRegress.fdPar </td><td style="text-align: center;"> | </td><td style="text-align: center;"> fRegress.fdPar or linmod </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>For <code>fRegress.numeric</code>, the numeric response is assumed to be the
sum of integrals of xfd * beta for all functional xfd terms.
</p>
<p><code>fRegress.fd or .fdPar</code> produces a concurrent regression with
each <code>beta</code> being also a (univariate) function.
</p>
<p><code>linmod</code> predicts a functional response from a convolution
integral, estimating a bivariate regression function.
</p>
<p>In the computation of regression function estimates in
<code>fRegress</code>, all independent variables are treated as if they are
functional.  If argument <code>xfdlist</code> contains one or more vectors,
these are converted to functional data objects having the constant
basis with coefficients equal to the elements of the vector.
</p>
<p>Needless to say, if all the variables in the model are scalar, do NOT
use this function.  Instead, use either <code>lm</code> or <code>lsfit</code>.
</p>
<p>These functions provide a partial implementation of Ramsay and
Silverman (2005, chapters 12-20).
</p>


<h3>Value</h3>

<p>These functions return either a standard <code>fRegress</code> fit object or
or a model specification:
</p>
<table role = "presentation">
<tr><td><code>The fRegress fit object case:</code></td>
<td>
<p>A list of class 
<code>fRegress</code> with the following components:
</p>

<dl>
<dt>y:</dt><dd><p>The first argument in the call to <code>fRegress</code>. 
This argument is coerced to	<code>class</code> <code>fd</code> in fda version 5.1.9.  
Prior versions of the package converted it to an <code>fdPar</code>, but the 
extra structures in that class were not used in any of the 
<code>fRegress</code> codes.</p>
</dd>
<dt>xfdlist:</dt><dd><p>The second argument in the call to <code>fRegress</code>.</p>
</dd>
<dt>betalist:</dt><dd><p>The third argument in the call to <code>fRegress</code>.</p>
</dd>
<dt>betaestlist:</dt><dd><p>A list of length equal to the number of independent
variables and with members having the same functional parameter 
structure as the corresponding members of <code>betalist</code>.  These are the
estimated regression coefficient functions.</p>
</dd>
<dt>yhatfdobj:</dt><dd><p>A functional parameter object (class <code>fdPar</code>) 
if the dependent variable is functional or a vector if the dependent
variable is scalar.  This is the set of predicted by the
functional regression model for the dependent variable.</p>
</dd>
<dt>Cmatinv:</dt><dd><p>A matrix containing the inverse of the coefficient 
matrix for the  linear equations that define the solution to the 
regression problem.  This matrix is required for function 
<code>fRegress.stderr</code> that estimates confidence regions
for the regression coefficient function estimates.</p>
</dd>
<dt>wt:</dt><dd><p>The vector of weights input or inferred.</p>
</dd>
</dl>

<p>If <code>class(y)</code> is numeric, the <code>fRegress</code> object also includes:
</p>

<dl>
<dt>df:</dt><dd><p>The equivalent degrees of freedom for the fit.</p>
</dd>
<dt>OCV</dt><dd><p>the leave-one-out cross validation score for the model.</p>
</dd>
<dt>gcv:</dt><dd><p>The generalized cross validation score.</p>
</dd>
</dl>

<p>If <code>class(y)</code> is <code>fd</code> or <code>fdPar</code>, the <code>fRegress</code> 
object returned also includes 5 other components:
</p>

<dl>
<dt>y2cMap:</dt><dd><p>An input <code>y2cMap</code>.</p>
</dd>
<dt>SigmaE:</dt><dd><p>An input <code>SigmaE</code>.</p>
</dd>
<dt>betastderrlist:</dt><dd><p>An <code>fd</code> object estimating the standard 
errors of <code>betaestlist</code>.</p>
</dd>
<dt>bvar:</dt><dd><p>A covariance matrix for regression coefficient estimates.</p>
</dd>
<dt>c2bMap:</dt><dd><p>A mapping matrix that maps variation in Cmat to variation 
in regression coefficients.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>The model specification object case:</code></td>
<td>
<p>The 
<code>fRegress.formula</code> and <code>fRegress.character</code> functions translate 
the <code>formula</code> into the argument list required by <code>fRegress.fdPar</code> 
or <code>fRegress.numeric</code>.  With the default value 'fRegress' for the 
argument <code>method</code>, this list is then used to call the appropriate 
other <code>fRegress</code> function.
Alternatively, to see how the <code>formula</code> is translated, use
the alternative 'model' value for the argument <code>method</code>.  In
that case, the function returns a list with the arguments
otherwise passed to these other functions plus the following
additional components:
</p>

<dl>
<dt>xfdlist0:</dt><dd><p>A list of the objects named on the right hand side of
<code>formula</code>.  This will differ from <code>xfdlist</code> for
any categorical or multivariate right hand side object.</p>
</dd>
<dt>type:</dt><dd><p>the <code>type</code> component of any <code>fd</code> object on the 
right hand side of <code>formula</code>.</p>
</dd>
<dt>nbasis:</dt><dd><p>A vector containing the <code>nbasis</code> components of 
variables named in <code>formula</code> having such components.</p>
</dd>
<dt>xVars:</dt><dd><p>An integer vector with all the variable names on the right
hand side of <code>formula</code> containing the corresponding
number of variables in <code>xfdlist</code>.  This can exceed 1 for
any multivariate object on the right hand side of class either
<code>numeric</code> or <code>fd</code> as well as any categorical variable.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. O. Ramsay, Giles Hooker, and Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress.stderr">fRegress.stderr</a></code>,
<code><a href="#topic+fRegress.CV">fRegress.CV</a></code>,
<code><a href="#topic+Fperm.fd">Fperm.fd</a></code>,
<code><a href="#topic+Fstat.fd">Fstat.fd</a></code>,
<code><a href="#topic+linmod">linmod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
oldpar &lt;- par(no.readonly=TRUE)
###
###
###   vector response with functional explanatory variable  
###
###

#  data are in Canadian Weather object
#  print the names of the data
print(names(CanadianWeather))
#  set up log10 of annual precipitation for 35 weather stations
annualprec &lt;- 
    log10(apply(CanadianWeather$dailyAv[,,"Precipitation.mm"], 2,sum))
# The simplest 'fRegress' call is singular with more bases
# than observations, so we use only 25 basis functions, for this example
smallbasis  &lt;- create.fourier.basis(c(0, 365), 25)
# The covariate is the temperature curve for each station.
tempfd &lt;- 
 smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"], smallbasis)$fd
##
## formula interface:  specify the model by a formula, the method
## fRegress.formula automatically sets up the regression coefficient functions,
## a constant function for the intercept, 
## and a higher dimensional function
## for the inner product with temperature
##

precip.Temp1 &lt;- fRegress(annualprec ~ tempfd, method="fRegress")

#  the output is a list with class name fRegress, display names
names(precip.Temp1)
#[c1] "yvec"           "xfdlist"        "betalist"       "betaestlist"    "yhatfdobj"     
# [6] "Cmat"           "Dmat"           "Cmatinv"        "wt"             "df"            
#[11] "GCV"            "OCV"            "y2cMap"         "SigmaE"         "betastderrlist"
#[16] "bvar"           "c2bMap"       

#  the vector of fits to the data is object  precip.Temp1$yfdPar,
#  but since the dependent variable is a vector, so is the fit
annualprec.fit1 &lt;- precip.Temp1$yhatfdobj
#  plot the data and the fit
plot(annualprec.fit1, annualprec, type="p", pch="o")
lines(annualprec.fit1, annualprec.fit1, lty=2)
#  print root mean squared error
RMSE &lt;- round(sqrt(mean((annualprec-annualprec.fit1)^2)),3)
print(paste("RMSE =",RMSE))
#  plot the estimated regression function
plot(precip.Temp1$betaestlist[[2]])
#  This isn't helpful either, the coefficient function is too
#  complicated to interpret.
#  display the number of basis functions used:
print(precip.Temp1$betaestlist[[2]]$fd$basis$nbasis)
#  25 basis functions to fit 35 values, no wonder we over-fit the data

##
## Get the default setup and modify it
## the "model" value of the method argument causes the analysis
## to produce a list vector of arguments for calling the
## fRegress function
##

precip.Temp.mdl1 &lt;- fRegress(annualprec ~ tempfd, method="model")
# First confirm we get the same answer as above by calling
# function fRegress() with these arguments:
precip.Temp.m &lt;- do.call('fRegress', precip.Temp.mdl1)

all.equal(precip.Temp.m, precip.Temp1)


#  set up a smaller basis for beta2 than for temperature so that we
#  get a more parsimonious fit to the data

nbetabasis2 &lt;- 21  #  not much less, but we add some roughness penalization
betabasis2  &lt;- create.fourier.basis(c(0, 365), nbetabasis2)
betafd2     &lt;- fd(rep(0, nbetabasis2), betabasis2)
# add smoothing
betafdPar2  &lt;- fdPar(betafd2, lambda=10)

# replace the regress coefficient function with this fdPar object

precip.Temp.mdl2 &lt;- precip.Temp.mdl1
precip.Temp.mdl2[['betalist']][['tempfd']] &lt;- betafdPar2

# Now do re-fit the data

precip.Temp2 &lt;- do.call('fRegress', precip.Temp.mdl2)

# Compare the two fits:
#  degrees of freedom
precip.Temp1[['df']] # 26
precip.Temp2[['df']] # 22
#  root-mean-squared errors:
RMSE1 &lt;- round(sqrt(mean(with(precip.Temp1, (yhatfdobj-yvec)^2))),3)
RMSE2 &lt;- round(sqrt(mean(with(precip.Temp2, (yhatfdobj-yvec)^2))),3)
print(c(RMSE1, RMSE2))
#  display further results for the more parsimonious model
annualprec.fit2 &lt;- precip.Temp2$yhatfdobj
plot(annualprec.fit2, annualprec, type="p", pch="o")
lines(annualprec.fit2, annualprec.fit2, lty=2)
#  plot the estimated regression function
plot(precip.Temp2$betaestlist[[2]])
#  now we see that it is primarily the temperatures in the
#  early winter that provide the fit to log precipitation by temperature

##
## Manual construction of xfdlist and betalist
##

xfdlist &lt;- list(const=rep(1, 35), tempfd=tempfd)

# The intercept must be constant for a scalar response
betabasis1 &lt;- create.constant.basis(c(0, 365))
betafd1    &lt;- fd(0, betabasis1)
betafdPar1 &lt;- fdPar(betafd1)

betafd2     &lt;- fd(matrix(0,7,1), create.bspline.basis(c(0, 365),7))
# convert to an fdPar object
betafdPar2  &lt;- fdPar(betafd2)

betalist &lt;- list(const=betafdPar1, tempfd=betafdPar2)

precip.Temp3   &lt;- fRegress(annualprec, xfdlist, betalist)
annualprec.fit3 &lt;- precip.Temp3$yhatfdobj
#  plot the data and the fit
plot(annualprec.fit3, annualprec, type="p", pch="o")
lines(annualprec.fit3, annualprec.fit3)
plot(precip.Temp3$betaestlist[[2]])

###
###
###  functional response with vector explanatory variables  
###
###

##
## simplest:  formula interface
##

daybasis65 &lt;- create.fourier.basis(rangeval=c(0, 365), nbasis=65,
                  axes=list('axesIntervals'))
Temp.fd &lt;- with(CanadianWeather, smooth.basisPar(day.5,
                dailyAv[,,'Temperature.C'], daybasis65)$fd)
TempRgn.f &lt;- fRegress(Temp.fd ~ region, CanadianWeather)

##
## Get the default setup and possibly modify it
##

TempRgn.mdl &lt;- fRegress(Temp.fd ~ region, CanadianWeather, method='model')

# make desired modifications here
# then run

TempRgn.m &lt;- do.call('fRegress', TempRgn.mdl)

# no change, so match the first run

all.equal(TempRgn.m, TempRgn.f)


##
## More detailed set up
##

region.contrasts &lt;- model.matrix(~factor(CanadianWeather$region))
rgnContr3 &lt;- region.contrasts
dim(rgnContr3) &lt;- c(1, 35, 4)
dimnames(rgnContr3) &lt;- list('', CanadianWeather$place, c('const',
   paste('region', c('Atlantic', 'Continental', 'Pacific'), sep='.')) )

const365 &lt;- create.constant.basis(c(0, 365))
region.fd.Atlantic &lt;- fd(matrix(rgnContr3[,,2], 1), const365)
# str(region.fd.Atlantic)
region.fd.Continental &lt;- fd(matrix(rgnContr3[,,3], 1), const365)
region.fd.Pacific &lt;- fd(matrix(rgnContr3[,,4], 1), const365)
region.fdlist &lt;- list(const=rep(1, 35),
     region.Atlantic=region.fd.Atlantic,
     region.Continental=region.fd.Continental,
     region.Pacific=region.fd.Pacific)
# str(TempRgn.mdl$betalist)

###
###
###  functional response with functional explanatory variable  
###
###

##
##  predict knee angle from hip angle;  
##     from demo('gait', package='fda')

##
## formula interface
##
gaittime   &lt;- as.matrix((1:20)/21)
gaitrange  &lt;- c(0,20)
gaitbasis  &lt;- create.fourier.basis(gaitrange, nbasis=21)
gaitnbasis &lt;- gaitbasis$nbasis
gaitcoef   &lt;- matrix(0,gaitnbasis,dim(gait)[2])
harmaccelLfd &lt;- vec2Lfd(c(0, (2*pi/20)^2, 0), rangeval=gaitrange)
gaitfd     &lt;- smooth.basisPar(gaittime, gait, gaitbasis, 
                          Lfdobj=harmaccelLfd, lambda=1e-2)$fd
hipfd  &lt;- gaitfd[,1]
kneefd &lt;- gaitfd[,2]

knee.hip.f &lt;- fRegress(kneefd ~ hipfd)

##
## manual set-up
##

#  set up the list of covariate objects
const  &lt;- rep(1, dim(kneefd$coef)[2])
xfdlist  &lt;- list(const=const, hipfd=hipfd)

beta0 &lt;- with(kneefd, fd(gaitcoef, gaitbasis, fdnames))
beta1 &lt;- with(hipfd,  fd(gaitcoef, gaitbasis, fdnames))

betalist  &lt;- list(const=fdPar(beta0), hipfd=fdPar(beta1))

fRegressout &lt;- fRegress(kneefd, xfdlist, betalist)
par(oldpar)
</code></pre>

<hr>
<h2 id='fRegress.CV'>
Computes Cross-validated Error Sum of Integrated Squared Errors for a
Functional Regression Model
</h2><span id='topic+fRegress.CV'></span>

<h3>Description</h3>

<p>For a functional regression model, a cross-validated error sum of
squares is computed.  For a functional dependent variable this is the
sum of integrated squared errors. For a scalar response, this function
has been superseded by the OCV and gcv elements returned by
<code>fRegress</code>. This function aids the choice of smoothing parameters
in this model using the cross-validated error sum of squares
criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>#fRegress.CV(y, xfdlist, betalist, wt=NULL, CVobs=1:N,
#            returnMatrix=FALSE, ...)

#NOTE:  The following is required by CRAN rules that
# function names like "as.numeric" must follow the documentation
# standards for S3 generics, even when they are not.
# Please ignore the following line:
## S3 method for class 'CV'
fRegress(y, xfdlist, betalist, wt=NULL, CVobs=1:N,
            returnMatrix=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fRegress.CV_+3A_y">y</code></td>
<td>

<p>the dependent variable object.
</p>
</td></tr>
<tr><td><code id="fRegress.CV_+3A_xfdlist">xfdlist</code></td>
<td>

<p>a list whose members are functional parameter objects specifying
functional independent variables.  Some of these may also be vectors
specifying scalar independent variables.
</p>
</td></tr>
<tr><td><code id="fRegress.CV_+3A_betalist">betalist</code></td>
<td>

<p>a list containing functional parameter objects specifying the
regression functions and their level of smoothing.
</p>
</td></tr>
<tr><td><code id="fRegress.CV_+3A_wt">wt</code></td>
<td>

<p>weights for weighted least squares.  Defaults to all 1's.
</p>
</td></tr>
<tr><td><code id="fRegress.CV_+3A_cvobs">CVobs</code></td>
<td>

<p>Indices of observations to be deleted.  Defaults to 1:N.
</p>
</td></tr>
<tr><td><code id="fRegress.CV_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
<tr><td><code id="fRegress.CV_+3A_...">...</code></td>
<td>

<p>optional arguments not used by <code>fRegress.CV</code> but needed for
superficial compatibility with <code>fRegress</code> methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing
</p>
<table role = "presentation">
<tr><td><code>SSE.CV</code></td>
<td>
<p> The sum of squared errors, or integrated squared errors</p>
</td></tr>
<tr><td><code>errfd.cv</code></td>
<td>
<p> Either a vector or a functional data object giving the
cross-validated errors </p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress">fRegress</a></code>,
<code><a href="#topic+fRegress.stderr">fRegress.stderr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #. See the analyses of the Canadian daily weather data.
</code></pre>

<hr>
<h2 id='fRegress.stderr'>
Compute Standard errors of Coefficient Functions Estimated by
Functional Regression Analysis
</h2><span id='topic+fRegress.stderr'></span>

<h3>Description</h3>

<p>Function <code>fRegress</code> carries out a functional regression analysis
of the concurrent kind, and estimates a regression coefficient
function corresponding to each independent variable, whether it is
scalar or functional.  This function uses the list that is output by
<code>fRegress</code> to provide standard error functions for each
regression function.  These standard error functions are pointwise,
meaning that sampling standard deviation functions only are computed,
and not sampling covariances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stderr'
fRegress(y, y2cMap, SigmaE, returnMatrix=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fRegress.stderr_+3A_y">y</code></td>
<td>

<p>the named list that is returned from a call to function
<code>fRegress</code>, where it is referred to as fRegressList.  (R syntax
requires that the first argument of any function beginning with
<code>fRegress.</code> must begin with <code>y</code>.)
</p>
</td></tr>
<tr><td><code id="fRegress.stderr_+3A_y2cmap">y2cMap</code></td>
<td>

<p>a matrix that contains the linear transformation that takes the raw
data values into the coefficients defining a smooth functional data
object. Typically, this matrix is returned from a call to function
<code>smooth.basis</code> that generates the dependent variable objects.
If the dependent variable is scalar, this matrix is an identity
matrix of order equal to the length of the vector.
</p>
</td></tr>
<tr><td><code id="fRegress.stderr_+3A_sigmae">SigmaE</code></td>
<td>

<p>either a matrix or a bivariate functional data object according to
whether the dependent variable is scalar or functional,
respectively.  This object has a number of replications equal to the
length of the dependent variable object.  It contains an estimate of
the variance-covariance matrix or function for the residuals.
</p>
</td></tr>
<tr><td><code id="fRegress.stderr_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
<tr><td><code id="fRegress.stderr_+3A_...">...</code></td>
<td>

<p>optional arguments not used by <code>fRegress.stderr</code> but needed for
superficial compatibility with <code>fRegress</code> methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of length 3 containing:
</p>
<table role = "presentation">
<tr><td><code>betastderrlist</code></td>
<td>
<p>a list object of length the number of independent 
variables.  Each member contains a functional parameter object for the
standard error of a regression function.</p>
</td></tr>
<tr><td><code>bvar</code></td>
<td>
<p>a symmetric matrix containing sampling variances and covariances 
for the matrix of regression coefficients for the regression functions.
These are stored column-wise in defining BVARIANCE.</p>
</td></tr>
<tr><td><code>c2bMap</code></td>
<td>
<p>a matrix containing the mapping from response variable 
coefficients to coefficients for regression coefficients.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress">fRegress</a></code>,
<code><a href="#topic+fRegress.CV">fRegress.CV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the weather data analyses in the file daily.ssc for
#examples of the use of function fRegress.stderr.
</code></pre>

<hr>
<h2 id='Fstat.fd'>
F-statistic for functional linear regression.
</h2><span id='topic+Fstat.fd'></span>

<h3>Description</h3>

<p>Fstat.fd calculates a pointwise F-statistic for functional linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> Fstat.fd(y,yhat,argvals=NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Fstat.fd_+3A_y">y</code></td>
<td>

<p>the dependent variable object.  It may be:
</p>

<ul>
<li><p> a vector if the dependent variable is scalar.
</p>
</li>
<li><p> a functional data object if the dependent variable is functional.
</p>
</li></ul>

</td></tr>
<tr><td><code id="Fstat.fd_+3A_yhat">yhat</code></td>
<td>

<p>The predicted values corresponding to <code>y</code>. It must be of the same class.
</p>
</td></tr>
<tr><td><code id="Fstat.fd_+3A_argvals">argvals</code></td>
<td>

<p>If <code>yfdPar</code> is a functional data object, the points at which to evaluate
the pointwise F-statistic.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An F-statistic is calculated as the ratio of residual variance to predicted
variance.
</p>
<p>If <code>argvals</code> is not specified and <code>yfdPar</code> is a <code>fd</code> object,
it defaults to 101 equally-spaced points on the range of <code>yfdPar</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>F</code></td>
<td>
<p>the calculated pointwise F-statistics.</p>
</td></tr>
<tr><td><code>argvals</code></td>
<td>

<p>argument values for evaluating the F-statistic if <code>yfdPar</code> is
a functional data object.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress">fRegress</a></code>
<code><a href="#topic+Fstat.fd">Fstat.fd</a></code>
</p>

<hr>
<h2 id='gait'>
Hip and knee angle while walking
</h2><span id='topic+gait'></span>

<h3>Description</h3>

<p>Hip and knee angle in degrees through a 20 point movement cycle for 39
boys  
</p>


<h3>Format</h3>

<p>An array of dim c(20, 39, 2) giving the &quot;Hip Angle&quot; and &quot;Knee Angle&quot;
for 39 repetitions of a 20 point gait cycle.   
</p>


<h3>Details</h3>

<p>The components of dimnames(gait) are as follows:
</p>
<p>[[1]] standardized gait time = seq(from=0.025, to=0.975, by=0.05) 
</p>
<p>[[2]] subject ID = &quot;boy1&quot;, &quot;boy2&quot;, ..., &quot;boy39&quot;  
</p>
<p>[[3]] gait variable = &quot;Hip Angle&quot; or &quot;Knee Angle&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
plot(gait[,1, 1], gait[, 1, 2], type="b")
par(oldpar)
</code></pre>

<hr>
<h2 id='geigen'>
Generalized eigenanalysis
</h2><span id='topic+geigen'></span>

<h3>Description</h3>

<p>Find matrices L and M to maximize
</p>
<p>tr(L'AM) / sqrt(tr(L'BL) tr(M'CM'))
</p>
<p>where A = a p x q matrix, B = p x p symmetric, positive definite
matrix, B = q x q symmetric positive definite matrix, L = p x s
matrix, and M = q x s matrix, where s = the number of non-zero
generalized eigenvalues of A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geigen(Amat, Bmat, Cmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geigen_+3A_amat">Amat</code></td>
<td>
<p> a numeric matrix </p>
</td></tr>
<tr><td><code id="geigen_+3A_bmat">Bmat</code></td>
<td>

<p>a symmetric, positive definite matrix with dimension = number of
rows of A
</p>
</td></tr>
<tr><td><code id="geigen_+3A_cmat">Cmat</code></td>
<td>

<p>a symmetric, positive definite matrix with dimension = number of
columns of A
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(values, Lmat, Mmat)
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(1:6, 2)
B &lt;- matrix(c(2, 1, 1, 2), 2)
C &lt;- diag(1:3)
ABC &lt;- geigen(A, B, C)
</code></pre>

<hr>
<h2 id='getbasismatrix'>
Values of Basis Functions or their Derivatives
</h2><span id='topic+getbasismatrix'></span>

<h3>Description</h3>

<p>Evaluate a set of basis functions or their derivatives at
a set of argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getbasismatrix(evalarg, basisobj, nderiv=0, returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getbasismatrix_+3A_evalarg">evalarg</code></td>
<td>

<p>a vector of arguments values.
</p>
</td></tr>
<tr><td><code id="getbasismatrix_+3A_basisobj">basisobj</code></td>
<td>

<p>a basis object.
</p>
</td></tr>
<tr><td><code id="getbasismatrix_+3A_nderiv">nderiv</code></td>
<td>

<p>a nonnegative integer specifying the derivative to be evaluated.
</p>
</td></tr>
<tr><td><code id="getbasismatrix_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of basis function or derivative values.  Rows correspond
to argument values and columns to basis functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.fd">eval.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## Minimal example:  a B-spline of order 1, i.e., a step function
## with 0 interior knots:
##
bspl1.1 &lt;- create.bspline.basis(norder=1, breaks=0:1)
m &lt;- getbasismatrix(seq(0, 1, .2), bspl1.1)

# check
m. &lt;- matrix(rep(1, 6), 6,
    dimnames=list(NULL, 'bspl') )

all.equal(m, m.)


##
## Date and POSIXct
##
# Date
July4.1776    &lt;- as.Date('1776-07-04')
Apr30.1789    &lt;- as.Date('1789-04-30')
AmRev         &lt;- c(July4.1776, Apr30.1789)
BspRevolution &lt;- create.bspline.basis(AmRev)
AmRevYears    &lt;- as.numeric(seq(July4.1776, Apr30.1789, length.out=14))
AmRevMatrix   &lt;- getbasismatrix(AmRevYears, BspRevolution)
matplot(AmRevYears, AmRevMatrix, type='b')

# POSIXct
AmRev.ct    &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev.ct   &lt;- create.bspline.basis(AmRev.ct)
AmRevYrs.ct &lt;- as.numeric(seq(AmRev.ct[1], AmRev.ct[2], length.out=14))
AmRevMat.ct &lt;- getbasismatrix(AmRevYrs.ct, BspRev.ct)
matplot(AmRevYrs.ct, AmRevMat.ct, type='b')

</code></pre>

<hr>
<h2 id='getbasispenalty'>
Evaluate a Roughness Penalty Matrix
</h2><span id='topic+getbasispenalty'></span>

<h3>Description</h3>

<p>A basis roughness penalty matrix is the matrix containing
the possible inner products of pairs of basis functions.
These inner products are typically defined in terms of
the value of a derivative or of a linear differential
operator applied to the basis function.  The basis penalty
matrix plays an important role in the computation of
functions whose roughness is controlled by a roughness
penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getbasispenalty(basisobj, Lfdobj=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getbasispenalty_+3A_basisobj">basisobj</code></td>
<td>

<p>a basis object.
</p>
</td></tr>
<tr><td><code id="getbasispenalty_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>an Lfd object
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A roughness penalty for a function $x(t)$ is defined by
integrating the square of either the derivative of  $ x(t) $ or,
more generally, the result of applying a linear differential operator
$L$ to it.  The most common roughness penalty is the integral of
the square of the second derivative, and
this is the default. To apply this roughness penalty, the matrix of
inner products of the basis functions defining this function is
necessary. This function just calls the roughness penalty evaluation
function specific to the basis involved.
</p>


<h3>Value</h3>

<p>a symmetric matrix of order equal to the number of basis functions
defined by the B-spline basis object.  Each element is the inner product
of two B-spline basis functions after taking the derivative.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.penalty">eval.penalty</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  set up a B-spline basis of order 4 with 13 basis functions
#  and knots at 0.0, 0.1,..., 0.9, 1.0.
basisobj &lt;- create.bspline.basis(c(0,1),13)
#  compute the 13 by 13 matrix of inner products of second derivatives
penmat &lt;- getbasispenalty(basisobj)
#  set up a Fourier basis with 13 basis functions
#  and and period 1.0.
basisobj &lt;- create.fourier.basis(c(0,1),13)
#  compute the 13 by 13 matrix of inner products of second derivatives
penmat &lt;- getbasispenalty(basisobj)

</code></pre>

<hr>
<h2 id='getbasisrange'>
Extract the range from a basis object 
</h2><span id='topic+getbasisrange'></span>

<h3>Description</h3>

<p>Extracts the 'range' component from basis object 'basisobj'.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getbasisrange(basisobj) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getbasisrange_+3A_basisobj">basisobj</code></td>
<td>

<p>a functional basis object 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of length 2 
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='growth'>
Berkeley Growth Study data 
</h2><span id='topic+growth'></span>

<h3>Description</h3>

<p>A list containing the heights of 39 boys and 54 girls from age 1 to 18
and the ages at which they were collected.  
</p>


<h3>Format</h3>

<p>This list contains the following components:
</p>

<dl>
<dt>hgtm</dt><dd>
<p>a 31 by 39 numeric matrix giving the heights in centimeters of
39 boys at 31 ages.    
</p>
</dd>
<dt>hgtf</dt><dd>
<p>a 31 by 54 numeric matrix giving the heights in centimeters of
54 girls at 31 ages.  
</p>
</dd>
<dt>age</dt><dd>
<p>a numeric vector of length 31 giving the ages at which the
heights were measured.  
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The ages are not equally spaced.  
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p>Tuddenham, R. D., and Snyder, M. M. (1954) &quot;Physical growth of
California boys and girls from birth to age 18&quot;, <em>University of
California Publications in Child Development</em>, 1, 183-364.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(growth, matplot(age, hgtf[, 1:10], type="b"))
</code></pre>

<hr>
<h2 id='handwrit'>
Cursive handwriting samples
</h2><span id='topic+handwrit'></span><span id='topic+handwritTime'></span>

<h3>Description</h3>

<p>20 cursive samples of 1401 (x, y,) coordinates for writing &quot;fda&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handwrit
handwritTime
</code></pre>


<h3>Format</h3>


<dl>
<dt>handwrit</dt><dd>
<p>An array of dimensions (1401, 20, 2) giving 1401 pairs of (x, y)
coordinates for each of 20 replicates of cursively writing &quot;fda&quot;
</p>
</dd>
<dt>handwritTime</dt><dd>
<p>seq(0, 2300, length=1401) = sampling times
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These data are the X-Y coordinates of 20 replications of writing
the script &quot;fda&quot;.  The subject was Jim Ramsay.  Each replication
is represented by 1401 coordinate values.  The scripts have been
extensively pre-processed.  They have been adjusted to a common
length that corresponds to 2.3 seconds or 2300 milliseconds, and
they have already been registered so that important features in
each script are aligned.
</p>
<p>This analysis is designed to illustrate techniques for working
with functional data having rather high frequency variation and
represented by thousands of data points per record.  Comments
along the way explain the choices of analysis that were made.
</p>
<p>The final result of the analysis is a third order linear
differential equation for each coordinate forced by a
constant and by time.  The equations are able to reconstruct
the scripts to a fairly high level of accuracy, and are also
able to accommodate a substantial amount of the variation in
the observed scripts across replications.  by contrast, a
second order equation was found to be completely inadequate.
</p>
<p>An interesting surprise in the results is the role placed by
a 120 millisecond cycle such that sharp features such as cusps
correspond closely to this period.  This 110-120 msec cycle
seems is usually seen in human movement data involving rapid
movements, such as speech, juggling and so on.
</p>
<p>These 20 records have already been normalized to a common time
interval of 2300 milliseconds and have beeen also registered so that
prominent features occur at the same times across replications.  Time
will be measured in (approximate) milliseconds and space in meters.
The data will require a small amount of smoothing, since an error of
0.5 mm is characteristic of the OPTOTRAK 3D measurement system used to
collect the data.
</p>
<p>Milliseconds were chosen as a time scale in order to make the ratio of
the time unit to the inter-knot interval not too far from one.
Otherwise, smoothing parameter values may be extremely small or
extremely large.
</p>
<p>The basis functions will be B-splines, with a spline placed at each
knot.  One may question whether so many basis functions are required,
but this decision is found to be essential for stable derivative
estimation up to the third order at and near the boundaries.
</p>
<p>Order 7 was used to get a smooth third derivative, which requires
penalizing the size of the 5th derivative, which in turn requires an
order of at least 7.  This implies norder + no. of interior knots =
1399 + 7 = 1406 basis functions.
</p>
<p>The smoothing parameter value 1e8 was chosen to obtain a fitting error
of about 0.5 mm, the known error level in the OPTOTRACK equipment.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
plot(handwrit[, 1, 1], handwrit[, 1, 2], type="l")
par(oldpar)
</code></pre>

<hr>
<h2 id='infantGrowth'>
Tibia Length for One Baby
</h2><span id='topic+infantGrowth'></span>

<h3>Description</h3>

<p>Measurement of the length of the tibia for the first 40 days of life
for one infant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(infantGrowth)</code></pre>


<h3>Format</h3>

<p>A matrix with three columns:
</p>

<dl>
<dt>day</dt><dd><p>age in days</p>
</dd>
<dt>tibiaLength</dt><dd>
<p>The average of five measurements of tibia length in millimeters
</p>
</dd>
<dt>sd.length</dt><dd>
<p>The standard deviation of five measurements of tibia length in
millimeters
</p>
</dd>
</dl>



<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p>Hermanussen, M., Thiel, C., von Bueren, E., de los Angeles Rol. de
Lama, M., Perez Romero, A., Arizonavarreta Ruiz, C., Burmeister, J.,
Tresguerras, J. A. F. (1998) Micro and macro perspectives in auxology:
Findings and considerations upon the variability of short term and
individual growth and the stability of population derived parameters,
<em>Annals of Human Biology</em>, 25:  359-395.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(infantGrowth)
oldpar &lt;- par(no.readonly=TRUE)
plot(tibiaLength~day, infantGrowth)
par(oldpar)
</code></pre>

<hr>
<h2 id='inprod'>
Inner products of Functional Data Objects.
</h2><span id='topic+inprod'></span>

<h3>Description</h3>

<p>Computes a matrix of inner products for each pairing of a
replicate for the first argument with a replicate for the
second argument.  This is perhaps the most important function
in the functional data library.  Hardly any analysis fails
to use inner products in some way, and many employ multiple
inner products.  While in certain cases
these may be computed exactly, this is a more general function that
approximates the inner product approximately when required.
The inner product is defined by two derivatives or linear
differential operators that are applied to the
first two arguments.  The range used to compute the inner
product may be contained within the range over which the
functions are defined.  A weight functional data object may
also be used to define weights for the inner product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inprod(fdobj1, fdobj2,
       Lfdobj1=int2Lfd(0), Lfdobj2=int2Lfd(0), rng = range1, wtfd = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inprod_+3A_fdobj1">fdobj1</code></td>
<td>

<p>a functional data object or a basis object.  If the object is
of the basis class, it is converted to a functional data object
by using the identity matrix as the coefficient matrix.
</p>
</td></tr>
<tr><td><code id="inprod_+3A_fdobj2">fdobj2</code></td>
<td>

<p>a functional data object or a basis object.  If the object is
of the basis class, it is converted to a functional data object
by using the identity matrix as the coefficient matrix.
</p>
</td></tr>
<tr><td><code id="inprod_+3A_lfdobj1">Lfdobj1</code></td>
<td>

<p>either a nonnegative integer specifying the derivative of
the first argument to be used, or a linear differential operator
object to be applied to the first argument.
</p>
</td></tr>
<tr><td><code id="inprod_+3A_lfdobj2">Lfdobj2</code></td>
<td>

<p>either a nonnegative integer specifying the derivative of
the second argument to be used, or a linear differential operator
object to be applied to the second argument.
</p>
</td></tr>
<tr><td><code id="inprod_+3A_rng">rng</code></td>
<td>

<p>a vector of length 2 defining a restricted range contained
within the range over which the arguments are defined.
</p>
</td></tr>
<tr><td><code id="inprod_+3A_wtfd">wtfd</code></td>
<td>

<p>a univariate functional data object with a single replicate
defining weights to be used in computing the inner product.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The approximation method is Richardson extrapolation using numerical
integration by the trapezoidal rule.  At each iteration, the number of
values at which the functions are evaluated is doubled, and a polynomial
extrapolation method is used to estimate the converged integral values
as well as an error tolerance.  Convergence is declared when the
relative error falls below <code>EPS</code> for all products.  The
extrapolation method generally saves at least one and often two
iterations relative to un-extrapolated trapezoidal integration.
Functional data analyses will seldom need to use <code>inprod</code>
directly, but code developers should be aware of its pivotal role.
Future work may require more sophisticated and specialized numerical
integration methods.
<code>inprod</code> computes the definite integral, but some functions
such as <code>smooth.monotone</code> and <code>register.fd</code> also need to
compute indefinite integrals.  These use the same approximation scheme,
but usually require more accuracy, and hence more iterations.
When one or both arguments are basis objects, they are converted to
functional data objects using identity matrices as the coefficient
matrices.
<code>inprod</code> is only called when there is no faster or exact
method available.  In cases where there is, it has been found that the
approximation is good to about four to five significant digits, which is
sufficient for most applications.  Perhaps surprisingly, in the case of
B-splines, the exact method is not appreciably faster, but of course is
more accurate.
<code>inprod</code> calls function <code>eval.fd</code> perhaps thousands
of times, so high efficiency for this function and the functions that
it calls is important.
</p>


<h3>Value</h3>

<p>a matrix of inner products.  The number of rows is the number of
functions or basis functions in argument <code>fd1</code>, and the number of
columns is the same thing for argument <code>fd2</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p>Press, et, al, $Numerical Recipes$.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.penalty">eval.penalty</a></code>,
</p>

<hr>
<h2 id='inprod.bspline'>
Compute Inner Products B-spline Expansions.
</h2><span id='topic+inprod.bspline'></span>

<h3>Description</h3>

<p>Computes the matrix of inner products when both functions
are represented by B-spline expansions and when both
derivatives are integers.  This function is called by function
<code>inprod</code>, and is not normally used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inprod.bspline(fdobj1, fdobj2=fdobj1, nderiv1=0, nderiv2=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inprod.bspline_+3A_fdobj1">fdobj1</code></td>
<td>

<p>a functional data object having a B-spline basis function
expansion.
</p>
</td></tr>
<tr><td><code id="inprod.bspline_+3A_fdobj2">fdobj2</code></td>
<td>

<p>a second functional data object with a B-spline basis
function expansion.  By default, this is the same as
the first argument.
</p>
</td></tr>
<tr><td><code id="inprod.bspline_+3A_nderiv1">nderiv1</code></td>
<td>

<p>a nonnegative integer specifying the derivative for the
first argument.
</p>
</td></tr>
<tr><td><code id="inprod.bspline_+3A_nderiv2">nderiv2</code></td>
<td>

<p>a nonnegative integer specifying the derivative for the
second argument.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of inner products with number of rows equal
to the number of replications of the first argument and
number of columns equal to the number of replications
of the second object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='int2Lfd'>
Convert Integer to Linear Differential Operator
</h2><span id='topic+int2Lfd'></span>

<h3>Description</h3>

<p>This function turns an integer specifying an order of a derivative
into the equivalent linear differential operator object.  It is also
useful for checking that an object is of the &quot;Lfd&quot; class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int2Lfd(m=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="int2Lfd_+3A_m">m</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Smoothing is achieved by penalizing the integral of the square of the
derivative of order <code>m</code> over <code>rangeval</code>:
</p>
<p>m = 0 penalizes the squared difference from 0 of the function
</p>
<p>1 = penalize the square of the slope or velocity
</p>
<p>2 = penalize the squared acceleration
</p>
<p>3 = penalize the squared rate of change of acceleration
</p>
<p>4 = penalize the squared curvature of acceleration?
</p>


<h3>Value</h3>

<p>a linear differential operator object of the &quot;Lfd&quot; class that is
equivalent to the integer argument.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lfd to penalize the squared acceleration
# typical for smoothing a cubic spline (order 4)
int2Lfd(2)

# Lfd to penalize the curvature of acceleration
# used with splines of order 6
# when it is desired to study velocity and acceleration
int2Lfd(4)
</code></pre>

<hr>
<h2 id='intensity.fd'>
Intensity Function for Point Process
</h2><span id='topic+intensity.fd'></span>

<h3>Description</h3>

<p>The intensity $mu$ of a series of event times that obey a
homogeneous Poisson process is the mean number of events per unit time.
When this event rate varies over time, the process is said to be
nonhomogeneous, and $mu(t)$, and is estimated by this function
<code>intensity.fd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intensity.fd(x, WfdParobj, conv=0.0001, iterlim=20,
             dbglev=1, returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intensity.fd_+3A_x">x</code></td>
<td>

<p>a vector containing a strictly increasing series of event times.
These event times assume that the the events begin to be observed
at time 0, and therefore are times since the beginning of
observation.
</p>
</td></tr>
<tr><td><code id="intensity.fd_+3A_wfdparobj">WfdParobj</code></td>
<td>

<p>a functional parameter object estimating the log-intensity function
$W(t) = log[mu(t)]$ .
Because the intensity function $mu(t)$ is necessarily positive,
it is represented by <code>mu(x) = exp[W(x)]</code>.
</p>
</td></tr>
<tr><td><code id="intensity.fd_+3A_conv">conv</code></td>
<td>

<p>a convergence criterion, required because the estimation
process is iterative.
</p>
</td></tr>
<tr><td><code id="intensity.fd_+3A_iterlim">iterlim</code></td>
<td>

<p>maximum number of iterations that are allowed.
</p>
</td></tr>
<tr><td><code id="intensity.fd_+3A_dbglev">dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out on
each iteration, with 0 implying no output, 1 intermediate output level,
and 2 full output.  If levels 1 and 2 are used, turn off the output
buffering option.
</p>
</td></tr>
<tr><td><code id="intensity.fd_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intensity function $I(t)$ is almost the same thing as a
probability density function $p(t)$ estimated by function
<code>densify.fd</code>.  The only difference is the absence of
the normalizing constant $C$ that a density function requires
in order to have a unit integral.
The goal of the function is provide a smooth intensity function
estimate that approaches some target intensity by an amount that is
controlled by the linear differential operator <code>Lfdobj</code> and
the penalty parameter in argument <code>WfdPar</code>.
For example, if the first derivative of
$W(t)$ is penalized heavily, this will force the function to
approach a constant, which in turn will force the estimated Poisson
process itself to be nearly homogeneous.
To plot the intensity function or to evaluate it,
evaluate <code>Wfdobj</code>, exponentiate the resulting vector.
</p>


<h3>Value</h3>

<p>A named list of length 4 containing:
</p>
<table role = "presentation">
<tr><td><code>Wfdobj</code></td>
<td>
<p>a functional data object defining function $W(x)$ that
optimizes the fit to the data of the monotone function that it defines.</p>
</td></tr>
<tr><td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged solution:
(1)
<b>f</b>: the optimal function value being minimized,
(2)
<b>grad</b>: the gradient vector at the optimal solution,   and
(3)
<b>norm</b>: the norm of the gradient vector at the optimal solution.</p>
</td></tr>
<tr><td><code>iternum</code></td>
<td>
<p>the number of iterations.</p>
</td></tr>
<tr><td><code>iterhist</code></td>
<td>
<p>a <code>iternum+1</code> by 5 matrix containing the iteration
history.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+density.fd">density.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  Generate 101 Poisson-distributed event times with
#  intensity or rate two events per unit time
N  &lt;- 101
mu &lt;- 2
#  generate 101 uniform deviates
uvec &lt;- runif(rep(0,N))
#  convert to 101 exponential waiting times
wvec &lt;- -log(1-uvec)/mu
#  accumulate to get event times
tvec &lt;- cumsum(wvec)
tmax &lt;- max(tvec)
#  set up an order 4 B-spline basis over [0,tmax] with
#  21 equally spaced knots
tbasis &lt;- create.bspline.basis(c(0,tmax), 23)
#  set up a functional parameter object for W(t),
#  the log intensity function.  The first derivative
#  is penalized in order to smooth toward a constant
lambda &lt;- 10
Wfd0 &lt;- fd(matrix(0,23,1),tbasis)
WfdParobj &lt;- fdPar(Wfd0, 1, lambda)
#  estimate the intensity function
Wfdobj &lt;- intensity.fd(tvec, WfdParobj)$Wfdobj
#  get intensity function values at 0 and event times
events &lt;- c(0,tvec)
intenvec &lt;- exp(eval.fd(events,Wfdobj))
#  plot intensity function
plot(events, intenvec, type="b")
lines(c(0,tmax),c(mu,mu),lty=4)
par(oldpar)
</code></pre>

<hr>
<h2 id='is.basis'>
Confirm Object is Class &quot;Basisfd&quot;
</h2><span id='topic+is.basis'></span>

<h3>Description</h3>

<p>Check that an argument is a basis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.basis(basisobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.basis_+3A_basisobj">basisobj</code></td>
<td>

<p>an object to be checked.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value:
<code>TRUE</code> if the class is correct, <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.fd">is.fd</a></code>, 
<code><a href="#topic+is.fdPar">is.fdPar</a></code>, 
<code><a href="#topic+is.Lfd">is.Lfd</a></code>
</p>

<hr>
<h2 id='is.eqbasis'>
Confirm that two objects of  class &quot;Basisfd&quot; are identical
</h2><span id='topic+is.eqbasis'></span>

<h3>Description</h3>

<p>Check all the slots of two basis objects to see that they are identical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.eqbasis(basisobj1, basisobj2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.eqbasis_+3A_basisobj1">basisobj1</code></td>
<td>

<p>The first basis object to be checked for being identical to the second.
</p>
</td></tr>
<tr><td><code id="is.eqbasis_+3A_basisobj2">basisobj2</code></td>
<td>

<p>The second basis object to be checked for being identical to the first.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value:
<code>TRUE</code> if the two basis objects are identical, <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basisfd">basisfd</a></code>,
</p>

<hr>
<h2 id='is.fd'>
Confirm Object has Class &quot;fd&quot;
</h2><span id='topic+is.fd'></span>

<h3>Description</h3>

<p>Check that an argument is a functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fd(fdobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.fd_+3A_fdobj">fdobj</code></td>
<td>

<p>an object to be checked.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value:
<code>TRUE</code> if the class is correct, <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.basis">is.basis</a></code>, 
<code><a href="#topic+is.fdPar">is.fdPar</a></code>, 
<code><a href="#topic+is.Lfd">is.Lfd</a></code>
</p>

<hr>
<h2 id='is.fdPar'>
Confirm Object has Class &quot;fdPar&quot;
</h2><span id='topic+is.fdPar'></span>

<h3>Description</h3>

<p>Check that an argument is a functional parameter object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fdPar(fdParobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.fdPar_+3A_fdparobj">fdParobj</code></td>
<td>

<p>an object to be checked.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value:
<code>TRUE</code> if the class is correct, <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.basis">is.basis</a></code>, 
<code><a href="#topic+is.fd">is.fd</a></code>, 
<code><a href="#topic+is.Lfd">is.Lfd</a></code>
</p>

<hr>
<h2 id='is.fdSmooth'>
Confirm Object has Class &quot;fdSmooth&quot;
</h2><span id='topic+is.fdSmooth'></span>

<h3>Description</h3>

<p>Check that an argument is a functional parameter object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.fdSmooth(fdSmoothobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.fdSmooth_+3A_fdsmoothobj">fdSmoothobj</code></td>
<td>

<p>an object to be checked.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value:
<code>TRUE</code> if the class is correct, <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.basis">is.basis</a></code>,
<code><a href="#topic+is.fd">is.fd</a></code>,
<code><a href="#topic+is.Lfd">is.Lfd</a></code>,
<code><a href="#topic+is.fdPar">is.fdPar</a></code>
</p>

<hr>
<h2 id='is.Lfd'>
Confirm Object has Class &quot;Lfd&quot;
</h2><span id='topic+is.Lfd'></span>

<h3>Description</h3>

<p>Check that an argument is a linear differential operator object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.Lfd(Lfdobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.Lfd_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>an object to be checked.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value:
<code>TRUE</code> if the class is correct, <code>FALSE</code> otherwise.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.basis">is.basis</a></code>, 
<code><a href="#topic+is.fd">is.fd</a></code>, 
<code><a href="#topic+is.fdPar">is.fdPar</a></code>
</p>

<hr>
<h2 id='knots.fd'>Extract the knots from a function basis or data object</h2><span id='topic+knots.fd'></span><span id='topic+knots.fdSmooth'></span><span id='topic+knots.basisfd'></span>

<h3>Description</h3>

<p>Extract either all or only the interior knots from an object of class
<code>basisfd</code>, <code>fd</code>, or <code>fdSmooth</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
knots(Fn, interior=TRUE, ...)
## S3 method for class 'fdSmooth'
knots(Fn, interior=TRUE, ...)
## S3 method for class 'basisfd'
knots(Fn, interior=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knots.fd_+3A_fn">Fn</code></td>
<td>

<p>an object of class <code>basisfd</code> or containing such an object
</p>
</td></tr>
<tr><td><code id="knots.fd_+3A_interior">interior</code></td>
<td>

<p>logical:
</p>
<p>if TRUE, Fn[[&quot;params&quot;]] are returned.
</p>
<p>Else, nord &lt;- norder(Fn); rng &lt;- Fn[['rangeval']]; return
c(rep(rng[1], nord), Fn[[&quot;params&quot;]], rep(rng[2], nord))
</p>
</td></tr>
<tr><td><code id="knots.fd_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interior knots of a <code>bspline</code> basis are stored in the
<code>params</code> component.  The remaining knots are in the
<code>rangeval</code> component, with multiplicity norder(Fn).
</p>


<h3>Value</h3>

<p>Numeric vector.  If 'interior' is TRUE, this is the <code>params</code>
component of the <code>bspline</code> basis.  Otherwise, <code>params</code> is
bracketed by rep(rangeval, norder(basisfd).
</p>


<h3>Author(s)</h3>

<p>Spencer Graves </p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fd">fd</a></code>,
<code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>,
</p>

<hr>
<h2 id='lambda2df'>
Convert Smoothing Parameter to Degrees of Freedom
</h2><span id='topic+lambda2df'></span>

<h3>Description</h3>

<p>The degree of roughness of an estimated function is controlled by a
smoothing parameter $lambda$ that directly multiplies the penalty.
However, it can be difficult to interpret or choose this value, and it
is often easier to determine the roughness by choosing a value that is
equivalent of the degrees of freedom used by the smoothing procedure.
This function converts a multipler $lambda$ into a degrees of freedom value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda2df(argvals, basisobj, wtvec=rep(1, n), Lfdobj=NULL, lambda=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambda2df_+3A_argvals">argvals</code></td>
<td>

<p>a vector containing the argument values used in the
smooth of the data.
</p>
</td></tr>
<tr><td><code id="lambda2df_+3A_basisobj">basisobj</code></td>
<td>

<p>the basis object used in the smoothing of the data.
</p>
</td></tr>
<tr><td><code id="lambda2df_+3A_wtvec">wtvec</code></td>
<td>

<p>the weight vector, if any, that was used in the smoothing
of the data.
</p>
</td></tr>
<tr><td><code id="lambda2df_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>the linear differential operator object used to defining
the roughness penalty employed in smoothing the data.
</p>
</td></tr>
<tr><td><code id="lambda2df_+3A_lambda">lambda</code></td>
<td>

<p>the smoothing parameter to be converted.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the equivalent degrees of freedom value.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df2lambda">df2lambda</a></code>
</p>

<hr>
<h2 id='lambda2gcv'>
Compute GCV Criterion
</h2><span id='topic+lambda2gcv'></span>

<h3>Description</h3>

<p>The generalized cross-validation or GCV criterion is often used to
select an appropriate smoothing parameter value, by finding the
smoothing parameter that minimizes GCV.  This function locates that
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lambda2gcv(log10lambda, argvals, y, fdParobj, wtvec=rep(1,length(argvals)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambda2gcv_+3A_log10lambda">log10lambda</code></td>
<td>

<p>the logarithm (base 10) of the smoothing parameter
</p>
</td></tr>
<tr><td><code id="lambda2gcv_+3A_argvals">argvals</code></td>
<td>

<p>a vector of argument values.
</p>
</td></tr>
<tr><td><code id="lambda2gcv_+3A_y">y</code></td>
<td>

<p>the data to be smoothed.
</p>
</td></tr>
<tr><td><code id="lambda2gcv_+3A_fdparobj">fdParobj</code></td>
<td>

<p>a functional parameter object defining the smooth.
</p>
</td></tr>
<tr><td><code id="lambda2gcv_+3A_wtvec">wtvec</code></td>
<td>

<p>a weight vector used in the smoothing.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, <code>lambda2gcv</code>
</p>


<h3>Value</h3>

<p>1.  <code class="reqn">fdParobj[['lambda']] &lt;- 10^log10lambda</code>
</p>
<p>2.  smoothlist &lt;- smooth.basks(argvals, y, fdParobj, wtvec)
</p>
<p>3.  return(smoothlist[['gcv']])
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis">smooth.basis</a></code>
<code><a href="#topic+fdPar">fdPar</a></code>
</p>

<hr>
<h2 id='landmarkreg'>
Landmark Registration of Functional Observations with Differing Ranges
</h2><span id='topic+landmarkreg'></span>

<h3>Description</h3>

<p>It is common to see that among a set of functions certain prominent
features such peaks and valleys, called $landmarks$, do not occur
at the same times, or other argument values.  
This is called $phase variation$, and it can be essential to align 
these features before proceeding with further functional data analyses.  
</p>
<p>This function uses the timings of these
features to align or register the curves.  The registration involves
estimating a nonlinear transformation of the argument continuum for each
functional observation.  This transformation is called a warping
function. It must be strictly increasing and smooth.
</p>
<p>Warning:  As of March 2022, landmark registration cannot be done using
function <code>smooth.basis</code> instead of function <code>smooth.morph</code>.  The 
warping function must be strictly monotonic, and we have found that using 
<code>smooth.basis</code> too often violates this contraint.  Function 
<code>smooth.morph</code> ensures monotonicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landmarkreg(unregfd, ximarks, x0marks, x0lim, 
             WfdPar=NULL, WfdPar0=NULL, ylambda=1e-10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landmarkreg_+3A_unregfd">unregfd</code></td>
<td>

<p>a functional data object containing the curves to be registered.
</p>
</td></tr>
<tr><td><code id="landmarkreg_+3A_ximarks">ximarks</code></td>
<td>

<p>A matrix containing the timings or argument values associated with
the landmarks for the observations in <code>fd</code> to be registered.
The number of rows N equals the number of observations, and the
number of columns NL equals the number of landmarks. These landmark
times must be in the interior of the interval over which the
functions are defined.
Object ximarks may also be a vector or a data.frame.
</p>
</td></tr>
<tr><td><code id="landmarkreg_+3A_x0marks">x0marks</code></td>
<td>

<p>a vector of length NL of times of landmarks for target curve.  If
not supplied, the mean of the landmark times in <code>ximarks</code> is
used.
Object x0marks may also be a vector.
</p>
</td></tr>
<tr><td><code id="landmarkreg_+3A_x0lim">x0lim</code></td>
<td>

<p>A vector of length 2 containing the lower and upper boundary of 
the interval containing <code>x0marks</code>.
</p>
</td></tr>
<tr><td><code id="landmarkreg_+3A_wfdpar">WfdPar</code></td>
<td>

<p>a functional parameter object defining the warping functions that
transform time in order to register the curves.
</p>
</td></tr>
<tr><td><code id="landmarkreg_+3A_wfdpar0">WfdPar0</code></td>
<td>

<p>a functional parameter object defining the inverse warping functions 
that transform time in order to register the curves.
</p>
</td></tr>
<tr><td><code id="landmarkreg_+3A_ylambda">ylambda</code></td>
<td>

<p>Smoothing parameter controlling the smoothness of the registered
functions.  It can happen with high dimensional bases that local
wiggles can appear in the registered curves or their derivatives
that are not seen in the unregistered versions.  In this case,
this parameter should be increased to the point where they
disappear.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A value of an arbitrary strictly monotone function at a point <code>x</code>
can be defined as the indefinite integral from a fixed lower boundary 
to <code>x</code> of the exponential of an unconstrained function value 
<code>W(x)</code>.
</p>
<p>We use B-spline basis functions to define function <code>W</code>, and optimize
the coefficients of its B-spline expansion with respect to the
data we are fitting.  The optimized core function <code>W</code> is output 
along with the registered functions, the warping function qnd the inverse
warping function.
</p>
<p>It is essential that the location of every landmark be clearly defined
in each of the curves as well as the template function.  If this is
not the case, consider using the continuous registration function
<code>register.fd</code>.  
</p>
<p>Not much curvature is usually required in the warping functions, so a
rather lower power basis, usually B-splines, is suitable for defining
the functional parameter argument <code>WfdPar</code>.  A registration with
a few prominent landmarks is often a good preliminary to using the
more sophisticated but more lengthy process in <code>register.fd</code>.
</p>


<h3>Value</h3>

<p>a named list of length 4 with components:
</p>
<table role = "presentation">
<tr><td><code>fdreg</code></td>
<td>

<p>a functional data object for the registered curves.
</p>
</td></tr>
<tr><td><code>warpfd</code></td>
<td>

<p>a functional data object for the warping functions.
</p>
</td></tr>
<tr><td><code>warpinvfd</code></td>
<td>

<p>a functional data object for the inverse warping functions.
</p>
</td></tr>
<tr><td><code>Wfd</code></td>
<td>

<p>a functional data object for the core function defining
the strictly monotone warping function.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+register.fd">register.fd</a></code>,
<code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>

<hr>
<h2 id='Lfd'>
Define a Linear Differential Operator Object
</h2><span id='topic+Lfd'></span>

<h3>Description</h3>

<p>A linear differential operator of order $m$ is defined,
usually to specify a roughness penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lfd(nderiv=0, bwtlist=vector("list", 0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Lfd_+3A_nderiv">nderiv</code></td>
<td>

<p>a nonnegative integer specifying the order $m$ of the
highest order derivative in the operator
</p>
</td></tr>
<tr><td><code id="Lfd_+3A_bwtlist">bwtlist</code></td>
<td>

<p>a list of length $m$.  Each member contains a
functional data object that acts as a weight function for a
derivative.  The first member weights the function, the
second the first derivative, and so on up to order $m-1$.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To check that an object is of this class, use functions <code>is.Lfd</code>
or <code>int2Lfd</code>.
</p>
<p>Linear differential operator objects are often used to define
roughness penalties for smoothing towards a &quot;hypersmooth&quot; function that
is annihilated by the operator.  For example, the harmonic acceleration
operator used in the analysis of the Canadian daily weather data
annihilates linear combinations of $1, sin(2 pi t/365)$ and $cos(2 pi
t/365)$, and the larger the smoothing parameter, the closer the smooth
function will be to a function of this shape.
</p>
<p>Function <code>pda.fd</code> estimates a linear differential operator object
that comes as close as possible to annihilating a functional data
object.
</p>
<p>A linear differential operator of order $m$ is a linear combination of
the derivatives of a functional data object up to order $m$.  The
derivatives of orders 0, 1, ..., $m-1$ can each be multiplied by a
weight function $b(t)$ that may or may not vary with argument $t$.
</p>
<p>If the notation $D^j$ is taken to mean &quot;take the derivative of order
$j$&quot;, then a linear differental operator $L$ applied to function $x$
has the expression
</p>
<p>$Lx(t) = b_0(t) x(t) + b_1(t)Dx(t) + ... + b_{m-1}(t) D^{m-1} x(t)
+ D^mx(t)$
</p>
<p>There are <code>print</code>, <code>summary</code>, and <code>plot</code> methods for
objects of class <code>Lfd</code>.
</p>


<h3>Value</h3>

<p>a linear differential operator object
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int2Lfd">int2Lfd</a></code>,
<code><a href="#topic+vec2Lfd">vec2Lfd</a></code>,
<code><a href="#topic+fdPar">fdPar</a></code>,
<code><a href="#topic+pda.fd">pda.fd</a></code>
<code><a href="#topic+plot.Lfd">plot.Lfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Set up the harmonic acceleration operator
dayrange  &lt;- c(0,365)
Lbasis  &lt;- create.constant.basis(dayrange,
                  axes=list("axesIntervals"))
Lcoef   &lt;- matrix(c(0,(2*pi/365)^2,0),1,3)
bfdobj  &lt;- fd(Lcoef,Lbasis)
bwtlist &lt;- fd2list(bfdobj)
harmaccelLfd &lt;- Lfd(3, bwtlist)
</code></pre>

<hr>
<h2 id='lines.fd'>
Add Lines from Functional Data to a Plot
</h2><span id='topic+lines.fd'></span><span id='topic+lines.fdSmooth'></span>

<h3>Description</h3>

<p>Lines defined by functional observations are added to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
lines(x, Lfdobj=int2Lfd(0), nx=201, ...)
## S3 method for class 'fdSmooth'
lines(x, Lfdobj=int2Lfd(0), nx=201, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines.fd_+3A_x">x</code></td>
<td>

<p>a univariate functional data object to be evaluated at <code>nx</code>
points over <code>xlim</code> and added as a line to an existing plot.  
</p>
</td></tr>
<tr><td><code id="lines.fd_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.  If present, the derivative or the value of applying the
operator is evaluated rather than the functions themselves.
</p>
</td></tr>
<tr><td><code id="lines.fd_+3A_nx">nx</code></td>
<td>

<p>Number of points within <code>xlim</code> at which to evaluate <code>x</code>
for plotting.  
</p>
</td></tr>
<tr><td><code id="lines.fd_+3A_...">...</code></td>
<td>

<p>additional arguments such as axis titles and so forth that can be
used in plotting programs called by <code>lines.fd</code> or
<code>lines.fdSmooth</code>.  
</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>Lines added to an existing plot.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fd">plot.fd</a></code>, 
<code><a href="#topic+plotfit.fd">plotfit.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## plot a fit with 3 levels of smoothing
##
x &lt;- seq(-1,1,0.02)
y &lt;- x + 3*exp(-6*x^2) + sin(1:101)/2
# sin not rnorm to make it easier to compare
# results across platforms 

result4.0  &lt;- smooth.basisPar(argvals=x, y=y, lambda=1)
result4.m4 &lt;- smooth.basisPar(argvals=x, y=y, lambda=1e-4)

plot(x, y)
lines(result4.0$fd)
lines(result4.m4$fd,      col='blue')
lines.fdSmooth(result4.0, col='red') 

plot(x, y, xlim=c(0.5, 1))
lines.fdSmooth(result4.0)
lines.fdSmooth(result4.m4, col='blue')
# no visible difference from the default?  
par(oldpar)
</code></pre>

<hr>
<h2 id='linmod'>
Fit Fully Functional Linear Model
</h2><span id='topic+linmod'></span>

<h3>Description</h3>

<p>A functional dependent variable <code class="reqn">y_i(t)</code> is approximated by a single
functional covariate <code class="reqn">x_i(s)</code> plus an intercept function <code class="reqn">\alpha(t)</code>,
and the covariate can affect the dependent variable for all
values of its argument. The equation for the model is
</p>
<p style="text-align: center;"><code class="reqn">y_i(t) = \beta_0(t) + \int \beta_1(s,t) x_i(s) ds + e_i(t)</code>
</p>

<p>for <code class="reqn">i = 1,...,N</code>. The regression function <code class="reqn">\beta_1(s,t)</code> is a
bivariate function. The final term <code class="reqn">e_i(t)</code> is a residual, lack of
fit or error term.   There is no need for values <code class="reqn">s</code> and <code class="reqn">t</code> to
be on the same continuum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linmod(xfdobj, yfdobj, betaList, wtvec=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linmod_+3A_xfdobj">xfdobj</code></td>
<td>

<p>a functional data object for the covariate
</p>
</td></tr>
<tr><td><code id="linmod_+3A_yfdobj">yfdobj</code></td>
<td>

<p>a functional data object for the dependent variable
</p>
</td></tr>
<tr><td><code id="linmod_+3A_betalist">betaList</code></td>
<td>

<p>a list object of length 2.  The first element is a functional parameter
object specifying a basis and a roughness penalty for the intercept term.
The second element is a bivariate functional parameter object for the
bivariate regression function.</p>
</td></tr>
<tr><td><code id="linmod_+3A_wtvec">wtvec</code></td>
<td>

<p>a vector of weights for each observation.  Its default value is NULL,
in which case the weights are assumed to be 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list of length 3 with the following entries:
</p>
<table role = "presentation">
<tr><td><code>beta0estfd</code></td>
<td>

<p>the intercept functional data object.
</p>
</td></tr>
<tr><td><code>beta1estbifd</code></td>
<td>

<p>a bivariate functional data object for the regression function.
</p>
</td></tr>
<tr><td><code>yhatfdobj</code></td>
<td>

<p>a functional data object for the approximation to the dependent variable
defined by the linear model, if the dependent variable is functional.
Otherwise the matrix of approximate values.
</p>
</td></tr>
</table>


<h3>Source</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009)
<em>Functional Data Analysis in R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bifdPar">bifdPar</a></code>,
<code><a href="#topic+fRegress">fRegress</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the prediction of precipitation using temperature as
#the independent variable in the analysis of the daily weather
#data, and the analysis of the Swedish mortality data.
</code></pre>

<hr>
<h2 id='lip'>
Lip motion
</h2><span id='topic+lip'></span><span id='topic+lipmarks'></span><span id='topic+liptime'></span>

<h3>Description</h3>

<p>51 measurements of the position of the lower lip every 7 milliseconds
for 20 repitions of the syllable 'bob'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lip
lipmarks
liptime
</code></pre>


<h3>Format</h3>


<dl>
<dt>lip</dt><dd>
<p>a matrix of dimension c(51, 20) giving the position of the lower
lip every 7 milliseconds for 350 milliseconds.
</p>
</dd>
<dt>lipmarks</dt><dd>
<p>a matrix of dimension c(20, 2) giving the positions of the
'leftElbow' and 'rightElbow' in each of the 20 repetitions of the
syllable 'bob'.
</p>
</dd>
<dt>liptime</dt><dd>
<p>time in seconds from the start = seq(0, 0.35, 51) = every 7
milliseconds.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>These are rather simple data, involving the movement of the lower lip
while saying &quot;bob&quot;.  There are 20 replications and 51 sampling points.
The data are used to illustrate two techniques:  landmark registration
and principal differental analysis.
Principal differential analysis estimates a linear differential equation
that can be used to describe not only the observed curves, but also a
certain number of their derivatives.
For a rather more elaborate example of principal differential analysis,
see the handwriting data.
</p>
<p>See the <code>lip</code> <code>demo</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  See the lip demo.
</code></pre>

<hr>
<h2 id='lnsrch'>
Search along a line for a minimum within an optimisation algorithm.
</h2><span id='topic+lnsrch'></span>

<h3>Description</h3>

<p>This is a version of the function in Numerical Recipes.  
It is initialized with a function value and gradient, and it does a 
series of quadratic searches until a convergence criterion is reached.
This version includes code for display the progress of iteration for
debugging purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnsrch(xold, fold, g, p, func, dataList, stpmax, itermax=20, TOLX=1e-10, dbglev=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lnsrch_+3A_xold">xold</code></td>
<td>
<p>The current parameter vector value.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_fold">fold</code></td>
<td>
<p>The current function value.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_g">g</code></td>
<td>
<p>The current gradient vector.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_p">p</code></td>
<td>
<p>The current search direction vector.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_func">func</code></td>
<td>
<p>The name of the function being optimized.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_datalist">dataList</code></td>
<td>
<p>A list object containing objects specifying the 
function to be minimized.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_stpmax">stpmax</code></td>
<td>
<p>The maximum step size.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_itermax">itermax</code></td>
<td>
<p>The maximum number of iterations. Default 20</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_tolx">TOLX</code></td>
<td>
<p>Convergence criterion.</p>
</td></tr>
<tr><td><code id="lnsrch_+3A_dbglev">dbglev</code></td>
<td>
<p>The level of output.  0: no output; 1: function and slope
at each iteration.  2 and above: also results within iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing:
</p>
<table role = "presentation">
<tr><td><code>x:</code></td>
<td>
<p>The parameter vector at the final minimum.</p>
</td></tr>
<tr><td><code>check:</code></td>
<td>
<p>A boolean value indicating that problems were encountered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juan Li and James Ramsay</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p>Press, W. H., Taukolsky, S. A., Vetterline, W. T. and Flannery, B. P. (2020) 
<em>Numerical Recipes, Third Edition</em>, Cambridge.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.surp">smooth.surp</a></code>
</p>

<hr>
<h2 id='matplot'>
Plot Columns of Matrices
</h2><span id='topic+matplot'></span><span id='topic+matplot.default'></span><span id='topic+matplot.Date'></span><span id='topic+matplot.POSIXct'></span>

<h3>Description</h3>

<p>Plot the columns of one matrix against the columns of another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matplot(x, ...)
## Default S3 method:
matplot(x, y, type = "p", lty = 1:5, lwd = 1,
    lend = par("lend"), pch = NULL, col = 1:6, cex = NULL, bg = NA,
    xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, ..., add = FALSE,
    verbose = getOption("verbose"))
## S3 method for class 'Date'
matplot(x, y, type = "p", lty = 1:5, lwd = 1,
    lend = par("lend"), pch = NULL, col = 1:6, cex = NULL, bg = NA,
    xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, ..., add = FALSE,
    verbose = getOption("verbose"))
## S3 method for class 'POSIXct'
matplot(x, y, type = "p", lty = 1:5, lwd = 1,
    lend = par("lend"), pch = NULL, col = 1:6, cex = NULL, bg = NA,
    xlab = NULL, ylab = NULL, xlim = NULL, ylim = NULL, ..., add = FALSE,
    verbose = getOption("verbose"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matplot_+3A_x">x</code>, <code id="matplot_+3A_y">y</code></td>
<td>

<p>vectors or matrices of data for plotting.  The number of rows should
match.  If one of them are missing, the other is taken as 'y' and an
'x' vector of '1:n' is used.  Missing values ('NA's) are allowed.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_type">type</code></td>
<td>

<p>character string (length 1 vector) or vector of 1-character strings
indicating the type of plot for each column of 'y', see 'plot' for
all possible 'type's.  The first character of 'type' defines the
first plot, the second character the second, etc.  Characters in
'type' are cycled through; e.g., '&quot;pl&quot;' alternately plots points and
lines.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_lty">lty</code>, <code id="matplot_+3A_lwd">lwd</code>, <code id="matplot_+3A_lend">lend</code></td>
<td>

<p>vector of line types, widths, and end styles.  The first element is
for the first column, the second element for the second column,
etc., even if lines are not plotted for all columns. Line types will
be used cyclically until all plots are drawn.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_pch">pch</code></td>
<td>

<p>character string or vector of 1-characters or integers for plotting
characters, see 'points'.  The first character is the
plotting-character for the first plot, the second for the second,
etc.  The default is the digits (1 through 9, 0) then the lowercase
and uppercase letters.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_col">col</code></td>
<td>

<p>vector of colors.  Colors are used cyclically.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_cex">cex</code></td>
<td>

<p>vector of character expansion sizes, used cyclically.  This works as
a multiple of 'par(&quot;cex&quot;)'.  'NULL' is equivalent to '1.0'.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_bg">bg</code></td>
<td>

<p>vector of background (fill) colors for the open plot symbols given
by 'pch=21:25' as in 'points'.  The default 'NA' corresponds to the
one of the underlying function 'plot.xy'.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_xlab">xlab</code>, <code id="matplot_+3A_ylab">ylab</code></td>
<td>

<p>titles for x and y axes, as in 'plot'.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_xlim">xlim</code>, <code id="matplot_+3A_ylim">ylim</code></td>
<td>

<p>ranges of x and y axes, as in 'plot'.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_...">...</code></td>
<td>

<p>Graphical parameters (see 'par') and any further arguments of
'plot', typically 'plot.default', may also be supplied as arguments
to this function.  Hence, the high-level graphics control arguments
described under 'par' and the arguments to 'title' may be supplied
to this function.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_add">add</code></td>
<td>

<p>logical.  If 'TRUE', plots are added to current one, using 'points'
and 'lines'.
</p>
</td></tr>
<tr><td><code id="matplot_+3A_verbose">verbose</code></td>
<td>

<p>logical.  If 'TRUE', write one line of what is done.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for multivariate data, a suitable array must first be
defined using the <code>par</code> function.
</p>
<p><code>matplot.default</code> calls <code><a href="graphics.html#topic+matplot">matplot</a></code>.  The
other methods are needed, because the default methods ignore the
<code>Date</code> or <code>POSIXct</code> character of <code>x</code>, labeling the
horizontal axis as numbers, thereby placing it on the user to
translate the numbers of days or seconds since the start of the epoch
into dates (and possibly times for <code>POSIXct</code> <code>x</code>).
</p>


<h3>Side Effects</h3>

<p>a plot of the functional observations
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+matplot">matplot</a></code>, <code><a href="base.html#topic+plot">plot</a></code>,
<code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+lines">lines</a></code>, <code><a href="base.html#topic+matrix">matrix</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## matplot.Date, matplot.POSIXct
##
# Date
invasion1 &lt;- as.Date('1775-09-04')
invasion2 &lt;- as.Date('1812-07-12')
earlyUS.Canada &lt;- c(invasion1, invasion2)
Y &lt;- matrix(1:4, 2, 2)
matplot(earlyUS.Canada, Y)

# POSIXct
AmRev.ct &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
matplot(AmRev.ct, Y)

##
## matplot.default (copied from matplot{graphics})
##
matplot((-4:5)^2, main = "Quadratic") # almost identical to plot(*)
sines &lt;- outer(1:20, 1:4, function(x, y) sin(x / 20 * pi * y))
matplot(sines, pch = 1:4, type = "o", col = rainbow(ncol(sines)))
matplot(sines, type = "b", pch = 21:23, col = 2:5, bg = 2:5,
             main = "matplot(...., pch = 21:23, bg = 2:5)")

x &lt;- 0:50/50
matplot(x, outer(x, 1:8, function(x, k) sin(k*pi * x)),
             ylim = c(-2,2), type = "plobcsSh",
             main= "matplot(,type = \"plobcsSh\" )")
## pch &amp; type =  vector of 1-chars :
matplot(x, outer(x, 1:4, function(x, k) sin(k*pi * x)),
             pch = letters[1:4], type = c("b","p","o"))

lends &lt;- c("round","butt","square")
matplot(matrix(1:12, 4), type="c", lty=1, lwd=10, lend=lends)
text(cbind(2.5, 2*c(1,3,5)-.4), lends, col= 1:3, cex = 1.5)

table(iris$Species) # is data.frame with 'Species' factor
iS &lt;- iris$Species == "setosa"
iV &lt;- iris$Species == "versicolor"
op &lt;- par(bg = "bisque")
matplot(c(1, 8), c(0, 4.5), type= "n", xlab = "Length", ylab = "Width",
             main = "Petal and Sepal Dimensions in Iris Blossoms")
matpoints(iris[iS,c(1,3)], iris[iS,c(2,4)], pch = "sS", col = c(2,4))
matpoints(iris[iV,c(1,3)], iris[iV,c(2,4)], pch = "vV", col = c(2,4))
legend(1, 4, c("    Setosa Petals", "    Setosa Sepals",
                    "Versicolor Petals", "Versicolor Sepals"),
            pch = "sSvV", col = rep(c(2,4), 2))

nam.var &lt;- colnames(iris)[-5]
nam.spec &lt;- as.character(iris[1+50*0:2, "Species"])
iris.S &lt;- array(NA, dim = c(50,4,3),
                     dimnames = list(NULL, nam.var, nam.spec))
for(i in 1:3) iris.S[,,i] &lt;- data.matrix(iris[1:50+50*(i-1), -5])

matplot(iris.S[,"Petal.Length",], iris.S[,"Petal.Width",], pch="SCV",
             col = rainbow(3, start = .8, end = .1),
             sub = paste(c("S", "C", "V"), dimnames(iris.S)[[3]],
                         sep = "=", collapse= ",  "),
             main = "Fisher's Iris Data")
par(op)
par(oldpar)
</code></pre>

<hr>
<h2 id='mean.fd'>
Mean of Functional Data
</h2><span id='topic+mean.fd'></span>

<h3>Description</h3>

<p>Evaluate the mean of a set of functions in a functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean.fd_+3A_x">x</code></td>
<td>

<p>a functional data object.
</p>
</td></tr>
<tr><td><code id="mean.fd_+3A_...">...</code></td>
<td>
<p>Other arguments to match the generic function for 'mean'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functional data object with a single replication
that contains the mean of the functions in the object <code>fd</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stddev.fd">stddev.fd</a></code>,
<code><a href="#topic+var.fd">var.fd</a></code>,
<code><a href="#topic+sum.fd">sum.fd</a></code>,
<code><a href="#topic+center.fd">center.fd</a></code>
<code><a href="base.html#topic+mean">mean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## 1.  univeriate:  lip motion
##
liptime  &lt;- seq(0,1,.02)
liprange &lt;- c(0,1)

#  -------------  create the fd object -----------------
#       use 31 order 6 splines so we can look at acceleration

nbasis &lt;- 51
norder &lt;- 6
lipbasis &lt;- create.bspline.basis(liprange, nbasis, norder)

#  ------------  apply some light smoothing to this object  -------

lipLfdobj &lt;- int2Lfd(4)
lipLambda &lt;- 1e-12
lipfdPar  &lt;- fdPar(fd(matrix(0,nbasis,1),lipbasis), lipLfdobj, lipLambda)

lipfd &lt;- smooth.basis(liptime, lip, lipfdPar)$fd
names(lipfd$fdnames) = c("Normalized time", "Replications", "mm")

lipmeanfd &lt;- mean.fd(lipfd)
plot(lipmeanfd)

##
## 2.  Trivariate:  CanadianWeather
##
dayrng &lt;- c(0, 365)

nbasis &lt;- 51
norder &lt;- 6

weatherBasis &lt;- create.fourier.basis(dayrng, nbasis)

weather.fd &lt;- smooth.basis(day.5, CanadianWeather$dailyAv,
                           weatherBasis)$fd

str(weather.fd.mean &lt;- mean.fd(weather.fd))
par(oldpar)
</code></pre>

<hr>
<h2 id='melanoma'>
melanoma 1936-1972
</h2><span id='topic+melanoma'></span>

<h3>Description</h3>

<p>These data from the Connecticut Tumor Registry present
age-adjusted numbers of melanoma skin-cancer incidences per
100,000 people in Connectict for the years from 1936 to 1972.
</p>


<h3>Format</h3>

<p>A data frame with 37 observations on the following 2 variables.
</p>

<dl>
<dt>year</dt><dd>
<p>Years 1936 to 1972.
</p>
</dd>
<dt>incidence</dt><dd>
<p>Rate of melanoma cancer per 100,000 population.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a copy of the 'melanoma' dataset in the 'lattice' package.  It
is unrelated to the object of the same name in the 'boot' package.   
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+melanoma">melanoma</a></code>
<code><a href="boot.html#topic+melanoma">melanoma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
plot(melanoma[, -1], type="b")
par(oldpar)
</code></pre>

<hr>
<h2 id='monfn'>Evaluate the a monotone function</h2><span id='topic+monfn'></span>

<h3>Description</h3>

<p>Evaluate a monotone function defined as the indefinite integral of
$exp(W(t))$ where $W$ is a function defined by a basis expansion.  Function $W$
is the logarithm of the derivative of the monotone function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  monfn(argvals, Wfdobj, basislist=vector("list", JMAX), returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monfn_+3A_argvals">argvals</code></td>
<td>
<p>A numerical vector at which function and derivative are
evaluated.</p>
</td></tr>
<tr><td><code id="monfn_+3A_wfdobj">Wfdobj</code></td>
<td>
<p>A functional data object.</p>
</td></tr>
<tr><td><code id="monfn_+3A_basislist">basislist</code></td>
<td>
<p>A list containing values of basis functions.</p>
</td></tr>
<tr><td><code id="monfn_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates a strictly monotone function of the form
</p>
<p style="text-align: center;"><code class="reqn">h(x) = [D^{-1} exp(Wfdobj)](x),</code>
</p>

<p>where <code class="reqn">D^{-1}</code> means taking the indefinite integral. The interval over
which the integration takes places is defined in the basis object in Wfdobj.
</p>


<h3>Value</h3>

<p>A numerical vector or matrix containing the values the warping function h.
</p>


<h3>Author(s)</h3>

<p>J. O. Ramsay
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, G. and Graves, S. (2009), <em>Functional
Data Analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, 
Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, 
Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mongrad">mongrad</a></code>,
<code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
## basically this example resembles part of landmarkreg.R that uses monfn.R to
## estimate the warping function.

## Specify the curve subject to be registered
n=21
tbreaks = seq(0, 2*pi, len=n)
xval &lt;- sin(tbreaks)
rangeval &lt;- range(tbreaks)

## Establish a B-spline basis for the curve
wbasis &lt;- create.bspline.basis(rangeval=rangeval, breaks=tbreaks)
Wfd0   &lt;- fd(matrix(0,wbasis$nbasis,1),wbasis)
WfdPar &lt;- fdPar(Wfd0, 1, 1e-4)
fdObj  &lt;- smooth.basis(tbreaks, xval, WfdPar)$fd

## Set the mean landmark times. Note that the objective of the warping
## function is to transform the curve such that the landmarks of the curve
## occur at the designated mean landmark times.

## Specify the mean landmark times: tbreak[8]=2.2 and tbreaks[13]=3.76
meanmarks &lt;- c(rangeval[1], tbreaks[8], tbreaks[13], rangeval[2])
## Specify landmark locations of the curve: tbreaks[6] and tbreaks[16]
cmarks &lt;- c(rangeval[1], tbreaks[6], tbreaks[16], rangeval[2])

## Establish a B-basis object for the warping function
Wfd &lt;- smooth.morph(x=meanmarks, y=cmarks, ylim=rangeval, 
                    WfdPar=WfdPar)$Wfdobj

## Estimate the warping function
h = monfn(tbreaks, Wfd)

## scale using a linear equation h such that h(0)=0 and h(END)=END
b &lt;- (rangeval[2]-rangeval[1])/ (h[n]-h[1])
a &lt;- rangeval[1] - b*h[1]
h &lt;- a + b*h
plot(tbreaks, h, xlab="Time", ylab="Transformed time", type="b")
par(oldpar)
</code></pre>

<hr>
<h2 id='mongrad'>
Evaluate the gradient of a monotone function
</h2><span id='topic+mongrad'></span>

<h3>Description</h3>

<p>Evaluates the gradient of a monotone function with respect to the coefficients defining
the log-first derivative $W(t)$ at each of a set of argument values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mongrad(x, Wfdobj, basislist=vector("list",JMAX), 
                    returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mongrad_+3A_x">x</code></td>
<td>
<p>A numerical vector at which function and derivative are
evaluated.</p>
</td></tr>
<tr><td><code id="mongrad_+3A_wfdobj">Wfdobj</code></td>
<td>
<p>A functional data object.</p>
</td></tr>
<tr><td><code id="mongrad_+3A_basislist">basislist</code></td>
<td>
<p>A list containing values of basis functions.</p>
</td></tr>
<tr><td><code id="mongrad_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with as many rows as argument values and as many columns as basis functions
defining $W$.
</p>


<h3>Author(s)</h3>

<p>J. O. Ramsay
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, G. and Graves, S. (2009), <em>Functional
Data Analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, 
Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, 
Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monfn">monfn</a></code>,
<code><a href="#topic+monhess">monhess</a></code>,
<code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>

<hr>
<h2 id='monhess'>
Evaluate the Hessian matrix of a monotone function
</h2><span id='topic+monhess'></span>

<h3>Description</h3>

<p>Evaluates the hessian or second derivative matrix of a monotone function 
with respect to the coefficients definingthe log-first derivative $W(t)$ 
at each of a set of argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monhess(x, Wfd, basislist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monhess_+3A_x">x</code></td>
<td>
<p>A numerical vector at which function and derivative are
evaluated.</p>
</td></tr>
<tr><td><code id="monhess_+3A_wfd">Wfd</code></td>
<td>
<p>A functional data object.</p>
</td></tr>
<tr><td><code id="monhess_+3A_basislist">basislist</code></td>
<td>
<p>A list containing values of basis functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A three dimensional array with first dimension corresponding to argument values 
and second and third dimensions to number of basis functions defining $W$.
</p>


<h3>Author(s)</h3>

<p>J. O. Ramsay
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, G. and Graves, S. (2009), <em>Functional
Data Analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, 
Bernard W. (2005), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, 
Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monfn">monfn</a></code>,
<code><a href="#topic+mongrad">mongrad</a></code>,
<code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>

<hr>
<h2 id='monomial'>
Evaluate Monomial Basis
</h2><span id='topic+monomial'></span>

<h3>Description</h3>

<p>Computes the values of the powers of argument t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monomial(evalarg, exponents=1, nderiv=0, argtrans=c(0,1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monomial_+3A_evalarg">evalarg</code></td>
<td>

<p>a vector of argument values.
</p>
</td></tr>
<tr><td><code id="monomial_+3A_exponents">exponents</code></td>
<td>

<p>a vector of nonnegative integer values specifying the
powers to be computed.
</p>
</td></tr>
<tr><td><code id="monomial_+3A_nderiv">nderiv</code></td>
<td>

<p>a nonnegative integer specifying the order of derivative to be
evaluated.
</p>
</td></tr>
<tr><td><code id="monomial_+3A_argtrans">argtrans</code></td>
<td>

<p>Linearly transform an argument before constructing a basis.
The first element is the shift in value and the second the scale factor.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of values of basis functions.  Rows correspond to
argument values and columns to basis functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+power">power</a></code>, 
<code><a href="#topic+expon">expon</a></code>, 
<code><a href="#topic+fourier">fourier</a></code>, 
<code><a href="#topic+polyg">polyg</a></code>, 
<code><a href="#topic+bsplineS">bsplineS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# set up a monomial basis for the first five powers
nbasis   &lt;- 5
basisobj &lt;- create.monomial.basis(c(-1,1),nbasis)
#  evaluate the basis
tval &lt;- seq(-1,1,0.1)
basismat &lt;- monomial(tval, 1:basisobj$nbasis)

</code></pre>

<hr>
<h2 id='monomialpen'>
Evaluate Monomial Roughness Penalty Matrix
</h2><span id='topic+monomialpen'></span>

<h3>Description</h3>

<p>The roughness penalty matrix is the set of
inner products of all pairs of a derivative of integer powers of the
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monomialpen(basisobj, Lfdobj=int2Lfd(2),
            rng=basisobj$rangeval)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monomialpen_+3A_basisobj">basisobj</code></td>
<td>

<p>a monomial basis object.
</p>
</td></tr>
<tr><td><code id="monomialpen_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer specifying an order of derivative
or a linear differential operator object.
</p>
</td></tr>
<tr><td><code id="monomialpen_+3A_rng">rng</code></td>
<td>

<p>the inner product may be computed over a range that is contained
within the range defined in the basis object.  This is a vector
or length two defining the range.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a symmetric matrix of order equal to the number of
monomial basis functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exponpen">exponpen</a></code>,
<code><a href="#topic+fourierpen">fourierpen</a></code>,
<code><a href="#topic+bsplinepen">bsplinepen</a></code>,
<code><a href="#topic+polygpen">polygpen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## set up a monomial basis for the first five powers
##
nbasis   &lt;- 5
basisobj &lt;- create.monomial.basis(c(-1,1),nbasis)
#  evaluate the rougness penalty matrix for the
#  second derivative.
penmat &lt;- monomialpen(basisobj, 2)

##
## with rng of class Date and POSIXct
##
# Date
invasion1 &lt;- as.Date('1775-09-04')
invasion2 &lt;- as.Date('1812-07-12')
earlyUS.Canada &lt;- c(invasion1, invasion2)
BspInvade1 &lt;- create.monomial.basis(earlyUS.Canada)
invadmat &lt;- monomialpen(BspInvade1)

# POSIXct
AmRev.ct &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
BspRev1.ct &lt;- create.monomial.basis(AmRev.ct)
revmat &lt;- monomialpen(BspRev1.ct)

</code></pre>

<hr>
<h2 id='MontrealTemp'>
Montreal Daily Temperature
</h2><span id='topic+MontrealTemp'></span>

<h3>Description</h3>

<p>Temperature in degrees Celsius in Montreal each day from 1961 through
1994
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MontrealTemp)</code></pre>


<h3>Format</h3>

<p>A numeric array with dimnames = list(1961:1994, names(dayOfYear)).
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CanadianWeather">CanadianWeather</a></code>
<code><a href="#topic+monthAccessories">monthAccessories</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MontrealTemp)

JanuaryThaw &lt;- t(MontrealTemp[, 16:47])

</code></pre>

<hr>
<h2 id='nondurables'>
Nondurable goods index
</h2><span id='topic+nondurables'></span>

<h3>Description</h3>

<p>US nondurable goods index time series, January 1919 to January 2000.  
</p>


<h3>Format</h3>

<p>An object of class 'ts'.  
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
plot(nondurables, log="y")
par(oldpar)
</code></pre>

<hr>
<h2 id='norder'>
Order of a B-spline
</h2><span id='topic+norder'></span><span id='topic+norder.fd'></span><span id='topic+norder.basisfd'></span><span id='topic+norder.default'></span><span id='topic+norder.bspline'></span>

<h3>Description</h3>

<p>norder = number of basis functions minus the number of interior
knots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norder(x, ...)
## S3 method for class 'fd'
norder(x, ...)
## S3 method for class 'basisfd'
norder(x, ...)
## Default S3 method:
norder(x, ...)

#norder.bspline(x, ...)

#NOTE:  The following is required by CRAN rules that
# function names like "as.numeric" must follow the documentation
# standards for S3 generics, even when they are not.
# Please ignore the following line:
## S3 method for class 'bspline'
norder(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norder_+3A_x">x</code></td>
<td>

<p>Either a basisfd object or an object containing a basisfd object as
a component.
</p>
</td></tr>
<tr><td><code id="norder_+3A_...">...</code></td>
<td>
<p>optional arguments currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>norder throws an error of basisfd[['type']] != 'bspline'.
</p>


<h3>Value</h3>

<p>An integer giving the order of the B-spline.
</p>


<h3>Author(s)</h3>

<p>Spencer Graves
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  bspl1.1 &lt;- create.bspline.basis(norder=1, breaks=0:1)

  stopifnot(norder(bspl1.1)==1)

  stopifnot(norder(fd(0, basisobj=bspl1.1))==1)

  stopifnot(norder(fd(rep(0,4)))==4)

  stopifnot(norder(list(fd(rep(0,4))))==4)
  ## Not run: 
    norder(list(list(fd(rep(0,4)))))
    Error in norder.default(list(list(fd(rep(0, 4))))) :
    input is not a 'basisfd' object and does not have a 'basisfd'
    component.
  
## End(Not run)

  stopifnot(norder(create.bspline.basis(norder=1, breaks=c(0,.5, 1))) == 1)

  stopifnot(norder(create.bspline.basis(norder=2, breaks=c(0,.5, 1))) == 2)

  # Default B-spline basis:  Cubic spline:  degree 3, order 4,
  # 21 breaks, 19 interior knots.
  stopifnot(norder(create.bspline.basis()) == 4)

  # these five lines throw an error of for a nocran check 
  # if (!CRAN()) {
  #   norder(create.fourier.basis(c(0,12) ))
    # Error in norder.bspline(x) :
    # object x is of type = fourier;  'norder' is only defined for type = 'bspline'
  # }

</code></pre>

<hr>
<h2 id='objAndNames'>
Add names to an object 
</h2><span id='topic+objAndNames'></span>

<h3>Description</h3>

<p>Add names to an object from 'preferred' if available and 'default' if
not.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objAndNames(object, preferred, default)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="objAndNames_+3A_object">object</code></td>
<td>

<p>an object of some type to which names must be added.  If
length(dim(object))&gt;0 add 'dimnames', else add 'names'.  
</p>
</td></tr>
<tr><td><code id="objAndNames_+3A_preferred">preferred</code></td>
<td>

<p>A list to check first for names to add to 'object'.  
</p>
</td></tr>
<tr><td><code id="objAndNames_+3A_default">default</code></td>
<td>

<p>A list to check for names to add to 'object' if appropriate names
are not found in 'preferred'.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  If length(dim(object))&lt;1, names(object) are taken from 'preferred'
if they are not NULL and have the correct length, else try 'default'.
</p>
<p>2.  Else for(lvl in 1:length(dim(object))) take dimnames[[lvl]] from
'preferred[[i]]' if they are not NULL and have the correct length,
else try 'default[[lvl]].  
</p>


<h3>Value</h3>

<p>An object of the same class and structure as 'object' but with either
names or dimnames added or changed.  
</p>


<h3>Author(s)</h3>

<p> Spencer Graves  </p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bifd">bifd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following should NOT check 'anything' here
tst1 &lt;- objAndNames(1:2, list(letters[1:2], LETTERS[1:2]), anything)
all.equal(tst1, c(a=1, b=2))

# The following should return 'object unchanged
tst2 &lt;- objAndNames(1:2, NULL, list(letters))
all.equal(tst2, 1:2)


tst3 &lt;- objAndNames(1:2, list("a", 2), list(letters[1:2]))
all.equal(tst3, c(a=1, b=2) )

# The following checks a matrix / array
tst4 &lt;- array(1:6, dim=c(2,3))
tst4a &lt;- tst4
dimnames(tst4a) &lt;- list(letters[1:2], LETTERS[1:3])
tst4b &lt;- objAndNames(tst4, 
       list(letters[1:2], LETTERS[1:3]), anything)
all.equal(tst4b, tst4a)

tst4c &lt;- objAndNames(tst4, NULL,        
       list(letters[1:2], LETTERS[1:3]) )
all.equal(tst4c, tst4a)

</code></pre>

<hr>
<h2 id='odesolv'>
Numerical Solution mth Order Differential Equation System
</h2><span id='topic+odesolv'></span>

<h3>Description</h3>

<p>The system of differential equations is linear, with possibly
time-varying coefficient functions.  The numerical solution is
computed with the Runge-Kutta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odesolv(bwtlist, ystart=diag(rep(1,norder)),
        h0=width/100, hmin=width*1e-10, hmax=width*0.5,
        EPS=1e-4, MAXSTP=1000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="odesolv_+3A_bwtlist">bwtlist</code></td>
<td>

<p>a list whose members are functional parameter objects defining the
weight functions for the linear differential equation.
</p>
</td></tr>
<tr><td><code id="odesolv_+3A_ystart">ystart</code></td>
<td>

<p>a vector of initial values for the equations.  These are the values at
time 0 of the solution and its first m - 1 derivatives.
</p>
</td></tr>
<tr><td><code id="odesolv_+3A_h0">h0</code></td>
<td>

<p>a positive initial step size.
</p>
</td></tr>
<tr><td><code id="odesolv_+3A_hmin">hmin</code></td>
<td>

<p>the minimum allowable step size.
</p>
</td></tr>
<tr><td><code id="odesolv_+3A_hmax">hmax</code></td>
<td>

<p>the maximum allowable step size.
</p>
</td></tr>
<tr><td><code id="odesolv_+3A_eps">EPS</code></td>
<td>

<p>a convergence criterion.
</p>
</td></tr>
<tr><td><code id="odesolv_+3A_maxstp">MAXSTP</code></td>
<td>

<p>the maximum number of steps allowed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is required to compute a set of solutions of an
estimated linear differential equation in order compute a fit
to the data that solves the equation.  Such a fit will be a
linear combinations of m independent solutions.
</p>


<h3>Value</h3>

<p>a named list of length 2 containing
</p>
<table role = "presentation">
<tr><td><code>tp</code></td>
<td>

<p>a vector of time values at which the system is evaluated
</p>
</td></tr>
<tr><td><code>yp</code></td>
<td>

<p>a matrix of variable values corresponding to <code>tp</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pda.fd">pda.fd</a></code>.  For new applications, users are encouraged to
consider <code><a href="deSolve.html#topic+deSolve">deSolve</a></code>.  The <code>deSolve</code> package
provides general solvers for ordinary and partial differential
equations, as well as differential algebraic equations and delay
differential equations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#See the analyses of the lip data.
</code></pre>

<hr>
<h2 id='pca.fd'>
Functional Principal Components Analysis
</h2><span id='topic+pca.fd'></span>

<h3>Description</h3>

<p>Functional Principal components analysis aims to display types of
variation across a sample of functions.  Principal components analysis
is an exploratory data analysis that tends to be an early part of many
projects.  These modes of variation are called $principal components$
or $harmonics.$  This function computes these harmonics, the
eigenvalues that indicate how important each mode of variation, and
harmonic scores for individual functions. If the functions are
multivariate, these harmonics are combined into a composite function
that summarizes joint variation among the several functions that make
up a multivariate functional observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca.fd(fdobj, nharm = 2, harmfdPar=fdPar(fdobj),
       centerfns = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pca.fd_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object.
</p>
</td></tr>
<tr><td><code id="pca.fd_+3A_nharm">nharm</code></td>
<td>

<p>the number of harmonics or principal components to compute.
</p>
</td></tr>
<tr><td><code id="pca.fd_+3A_harmfdpar">harmfdPar</code></td>
<td>

<p>a functional parameter object that defines the
harmonic or principal component functions to be estimated.
</p>
</td></tr>
<tr><td><code id="pca.fd_+3A_centerfns">centerfns</code></td>
<td>

<p>a logical value:
if TRUE, subtract the mean function from each function before
computing principal components.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;pca.fd&quot; with these named entries:
</p>
<table role = "presentation">
<tr><td><code>harmonics</code></td>
<td>

<p>a functional data object for the harmonics or eigenfunctions
</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>the complete set of eigenvalues
</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>

<p>s matrix of scores on the principal components or harmonics
</p>
</td></tr>
<tr><td><code>varprop</code></td>
<td>

<p>a vector giving the proportion of variance explained
by each eigenfunction
</p>
</td></tr>
<tr><td><code>meanfd</code></td>
<td>

<p>a functional data object giving the mean function
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cca.fd">cca.fd</a></code>,
<code><a href="#topic+pda.fd">pda.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  carry out a PCA of temperature
#  penalize harmonic acceleration, use varimax rotation

daybasis65 &lt;- create.fourier.basis(c(0, 365), nbasis=65, period=365)
nbasis &lt;-65
harmaccelLfd &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))
harmfdPar    &lt;- fdPar(fd(matrix(0,nbasis,1), daybasis65), harmaccelLfd, 
                      lambda=1e5)
daytempfd &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"],
                   daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd

daytemppcaobj &lt;- pca.fd(daytempfd, nharm=4, harmfdPar)
daytemppcaVarmx &lt;- varmx.pca.fd(daytemppcaobj)
#  plot harmonics
op &lt;- par(mfrow=c(2,2))
plot.pca.fd(daytemppcaobj, cex.main=0.9)

plot.pca.fd(daytemppcaVarmx, cex.main=0.9)
par(op)

plot(daytemppcaobj$harmonics)
plot(daytemppcaVarmx$harmonics)
par(oldpar)
</code></pre>

<hr>
<h2 id='pcaPACE'>
Estimate the functional principal components 
</h2><span id='topic+pcaPACE'></span>

<h3>Description</h3>

<p>Carries out a functional PCA with regularization from the estimate of the covariance surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pcaPACE(covestimate, nharm, harmfdPar, cross)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pcaPACE_+3A_covestimate">covestimate</code></td>
<td>

<p>a list with the two named entries &quot;cov.estimate&quot; and &quot;meanfd&quot;
</p>
</td></tr>
<tr><td><code id="pcaPACE_+3A_nharm">nharm</code></td>
<td>

<p>the number of harmonics or principal components to compute.
</p>
</td></tr>
<tr><td><code id="pcaPACE_+3A_harmfdpar">harmfdPar</code></td>
<td>

<p>a functional parameter object that defines the
harmonic or principal component functions to be estimated.
</p>
</td></tr>
<tr><td><code id="pcaPACE_+3A_cross">cross</code></td>
<td>

<p>a logical value:
if TRUE, take into account the cross covariance for estimating the eigen functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;pca.fd&quot; with these named entries:
</p>
<table role = "presentation">
<tr><td><code>harmonics</code></td>
<td>

<p>a functional data object for the harmonics or eigenfunctions
</p>
</td></tr>
<tr><td><code>values</code></td>
<td>

<p>the complete set of eigenvalues
</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>

<p>NULL. Use &quot;scoresPACE&quot; for estimating the pca scores
</p>
</td></tr>
<tr><td><code>varprop</code></td>
<td>

<p>a vector giving the proportion of variance explained
by each eigenfunction
</p>
</td></tr>
<tr><td><code>meanfd</code></td>
<td>

<p>a functional data object giving the mean function
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p>Yao, F., Mueller, H.G., Wang, J.L. (2005), 
<em>Functional data analysis for sparse longitudinal data</em>,
J. American Statistical Association, 100, 577-590.
</p>

<hr>
<h2 id='pda.fd'>
Principal Differential Analysis
</h2><span id='topic+pda.fd'></span>

<h3>Description</h3>

<p>Principal differential analysis (PDA) estimates a system of <code class="reqn">n</code>
linear differential equations that define functions that fit the data
and their derivatives.  There is an equation in the system for each
variable.
</p>
<p>Each equation has on its right side the highest order derivative that
is used, and the order of this derivative, <code class="reqn">m_j, j=1,...,n</code> can
vary over equations.
</p>
<p>On the left side of equation is a linear combination of all
the  variables and all the derivatives of these variables up to order
one less than the order <code class="reqn">m_j</code> of the highest derivative.
</p>
<p>In addition, the right side may contain linear combinations of forcing
functions as well, with the number of forcing functions varying over
equations.
</p>
<p>The linear combinations are defined by weighting functions multiplying
each variable, derivative, and forcing function in the equation.
These weighting functions may be constant or vary over time.  They are
each represented by a functional parameter object, specifying a basis
for an expansion of a coefficient, a linear differential operator for
smoothing purposes, a smoothing parameter value, and a logical
variable indicating whether the function is to be estimated, or kept
fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pda.fd(xfdlist, bwtlist=NULL,
       awtlist=NULL, ufdlist=NULL, nfine=501)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pda.fd_+3A_xfdlist">xfdlist</code></td>
<td>

<p>a list whose members are functional data objects representing each
variable in the system of differential equations.  Each of these
objects contain one or more curves to be represented by the
corresponding differential equation.  The length of the list is
equal to the number of differential equations. The number <code class="reqn">N</code> of
replications must be the same for each member functional data
object.
</p>
</td></tr>
<tr><td><code id="pda.fd_+3A_bwtlist">bwtlist</code></td>
<td>

<p>this argument contains the weight coefficients that multiply, in the
right side of each equation, all the variables in the system, and
all their derivatives, where the derivatives are used up to one less
than the order of the variable.   This argument has, in general, a
three-level structure, defined by a three-level hierarchy of list
objects.
</p>
<p>At the top level, the argument is a single list of length equal to
the number of variables. Each component of this list is itself a
list
</p>
<p>At the second level, each component of the top level list is itself
a list, also of length equal to the number of variables.
</p>
<p>At the third and bottom level, each component of a second level list
is a list of length equal to the number of orders of derivatives
appearing on the right side of the equation, including  the variable
itself, a derivative of order 0.  If m indicates the order of the
equation, that is the order of the derivative on the left side, then
this list is length m.
</p>
<p>The components in the third level lists are functional parameter
objects defining estimates for weight functions.  For a first order
equation, for example, <code class="reqn">m = 1</code> and the single component in each
list contains a weight function for the variable.  Since each
equation has a term involving each variable in the system, a system
of first order equations will have <code class="reqn">n^2</code> at the third level of
this structure.
</p>
<p>There MUST be a component for each weight function, even if the
corresponding term does not appear in the equation.  In the case of
a missing term, the corresponding component can be <code>NULL</code>, and
it will be treated as a coefficient fixed at 0.
</p>
<p>However, in the case of a single differential equation,
<code>bwtlist</code> can be given a simpler structure, since in this case
only <code class="reqn">m</code> coefficients are required.  Therefore, for a single
equation, <code>bwtlist</code> can be a list of length <code class="reqn">m</code> with each
component containing a functional parameter object for the
corresponding derivative.
</p>
</td></tr>
<tr><td><code id="pda.fd_+3A_awtlist">awtlist</code></td>
<td>

<p>a two-level list containing weight functions for forcing functions.
</p>
<p>In addition to terms in each of the equations involving terms
corresponding to each derivative of each variable in the system,
each equation can also have a contribution from one or more
exogenous variables, often called <em>forcing functions.</em>
</p>
<p>This argument defines the weights multiplying these forcing
functions, and is a list of length <code class="reqn">n</code>, the number of
variables.  Each component of this is is in turn a list, each
component of which contains a functional parameter object defining a
weight function for a forcing function.  If there are no forcing
functions for an equation, this list can be <code>NULL</code>.  If none of
the equations involve forcing functions, <code>awtlist</code> can be
<code>NULL</code>, which is its default value if it is not in the argument
list.
</p>
</td></tr>
<tr><td><code id="pda.fd_+3A_ufdlist">ufdlist</code></td>
<td>

<p>a two-level list containing forcing functions.  This list structure
is identical to that for <code>awtlist</code>, the only difference being
that the components in the second level contain functional data
objects for the forcing functions, rather than functional parameter
objects.
</p>
</td></tr>
<tr><td><code id="pda.fd_+3A_nfine">nfine</code></td>
<td>

<p>a number of values for a fine mesh.  The estimation of the
differential equation involves discrete numerical quadrature
estimates of integrals, and these require that functions be
evaluated at a fine mesh of values of the argument.  This argument
defines the number to use.  The default value of 501 is reset to
five times the largest number of basis functions used to represent
any variable in the system, if this number is larger.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>pda.fd</code>, being a list with the following
components:
</p>
<table role = "presentation">
<tr><td><code>bwtlist</code></td>
<td>

<p>a list array of the same dimensions as the corresponding argument,
containing the estimated or fixed weight functions defining the
system of linear differential equations.
</p>
</td></tr>
<tr><td><code>resfdlist</code></td>
<td>

<p>a list of length equal to the number of variables or equations.
Each members is a functional data object giving the residual
functions or forcing functions defined as the left side of the
equation (the derivative of order m of a variable) minus the linear
fit on the right side.  The number of replicates for each residual
functional data object is the same as that for the variables.
</p>
</td></tr>
<tr><td><code>awtlist</code></td>
<td>

<p>a list of the same dimensions as the corresponding argument.  Each
member is an estimated or fixed weighting function for a forcing
function.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca.fd">pca.fd</a></code>,
<code><a href="#topic+cca.fd">cca.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#See analyses of daily weather data for examples.
##
##  set up objects for examples
##

#  set up basis objects
#  constant basis object  for estimating weight functions
cbasis = create.constant.basis(c(0,1))
#  monomial basis: {1,t}  for estimating weight functions
mbasis = create.monomial.basis(c(0,1),2)
#  quartic spline basis with 54 basis functions for
#    defining functions to be analyzed
xbasis = create.bspline.basis(c(0,1),24,5)
#  set up functional parameter objects for weight bases
cfd0   = fd(0,cbasis)
cfdPar = fdPar(cfd0)
mfd0   = fd(matrix(0,2,1),mbasis)
mfdPar = fdPar(mfd0)

#  fine mesh for plotting functions
#  sampling points over [0,1]
tvec = seq(0,1,len=101)

##
##  Example 1:  a single first order constant coefficient unforced equation
##     Dx = -4*x  for  x(t) = exp(-4t)

beta    = 4
xvec    = exp(-beta*tvec)
xfd     = smooth.basis(tvec, xvec, xbasis)$fd
xfdlist = list(xfd)
bwtlist = list(cfdPar)
#  perform the principal differential analysis
result = pda.fd(xfdlist, bwtlist)
#  display weight coefficient for variable
bwtlistout = result$bwtlist
bwtfd      = bwtlistout[[1]]$fd
par(mfrow=c(1,1))
plot(bwtfd)
title("Weight coefficient for variable")
print(round(bwtfd$coefs,3))
#  display residual functions
reslist    = result$resfdlist
plot(reslist[[1]])
title("Residual function")
##
##  Example 2:  a single first order varying coefficient unforced equation
##     Dx(t) = -t*x(t) or x(t) = exp(-t^2/2)
bvec    = tvec
xvec    = exp(-tvec^2/2)
xfd     = smooth.basis(tvec, xvec, xbasis)$fd
xfdlist = list(xfd)
bwtlist = list(mfdPar)
#  perform the principal differential analysis
result = pda.fd(xfdlist, bwtlist)
#  display weight coefficient for variable
bwtlistout = result$bwtlist
bwtfd      = bwtlistout[[1]]$fd
par(mfrow=c(1,1))
plot(bwtfd)
title("Weight coefficient for variable")
print(round(bwtfd$coefs,3))
#  display residual function
reslist    = result$resfdlist
plot(reslist[[1]])
title("Residual function")
##
##  Example 3:  a single second order constant coefficient unforced equation
##     Dx(t) = -(2*pi)^2*x(t) or x(t) = sin(2*pi*t)
##
xvec    = sin(2*pi*tvec)
xfd     = smooth.basis(tvec, xvec, xbasis)$fd
xfdlist = list(xfd)
bwtlist = list(cfdPar,cfdPar)
#  perform the principal differential analysis
result = pda.fd(xfdlist, bwtlist)
#  display weight coefficients
bwtlistout = result$bwtlist
bwtfd1     = bwtlistout[[1]]$fd
bwtfd2     = bwtlistout[[2]]$fd
par(mfrow=c(2,1))
plot(bwtfd1)
title("Weight coefficient for variable")
plot(bwtfd2)
title("Weight coefficient for derivative of variable")
print(round(c(bwtfd1$coefs, bwtfd2$coefs),3))
print(bwtfd2$coefs)
#  display residual function
reslist    = result$resfdlist
par(mfrow=c(1,1))
plot(reslist[[1]])
title("Residual function")
##
##  Example 4:  two first order constant coefficient unforced equations
##     Dx1(t) = x2(t) and Dx2(t) = -x1(t)
##   equivalent to  x1(t) = sin(2*pi*t)
##
xvec1     = sin(2*pi*tvec)
xvec2     = 2*pi*cos(2*pi*tvec)
xfd1      = smooth.basis(tvec, xvec1, xbasis)$fd
xfd2      = smooth.basis(tvec, xvec2, xbasis)$fd
xfdlist   = list(xfd1,xfd2)
bwtlist   = list(
                 list(
                      list(cfdPar),
                      list(cfdPar)
                     ),
                 list(
                      list(cfdPar),
                      list(cfdPar)
                     )
                )
#  perform the principal differential analysis
result = pda.fd(xfdlist, bwtlist)
#  display weight coefficients
bwtlistout = result$bwtlist
bwtfd11    = bwtlistout[[1]][[1]][[1]]$fd
bwtfd21    = bwtlistout[[2]][[1]][[1]]$fd
bwtfd12    = bwtlistout[[1]][[2]][[1]]$fd
bwtfd22    = bwtlistout[[2]][[2]][[1]]$fd
par(mfrow=c(2,2))
plot(bwtfd11)
title("Weight for variable 1 in equation 1")
plot(bwtfd21)
title("Weight for variable 2 in equation 1")
plot(bwtfd12)
title("Weight for variable 1 in equation 2")
plot(bwtfd22)
title("Weight for variable 2 in equation 2")
print(round(bwtfd11$coefs,3))
print(round(bwtfd21$coefs,3))
print(round(bwtfd12$coefs,3))
print(round(bwtfd22$coefs,3))
#  display residual functions
reslist = result$resfdlist
par(mfrow=c(2,1))
plot(reslist[[1]])
title("Residual function for variable 1")
plot(reslist[[2]])
title("Residual function for variable 2")
##
##  Example 5:  a single first order constant coefficient equation
##     Dx = -4*x  for  x(t) = exp(-4t) forced by u(t) = 2
##
beta    = 4
alpha   = 2
xvec0   = exp(-beta*tvec)
intv    = (exp(beta*tvec) - 1)/beta
xvec    = xvec0*(1 + alpha*intv)
xfd     = smooth.basis(tvec, xvec, xbasis)$fd
xfdlist = list(xfd)
bwtlist = list(cfdPar)
awtlist = list(cfdPar)
ufdlist = list(fd(1,cbasis))
#  perform the principal differential analysis
result = pda.fd(xfdlist, bwtlist, awtlist, ufdlist)
#  display weight coefficients
bwtlistout = result$bwtlist
bwtfd      = bwtlistout[[1]]$fd
awtlistout = result$awtlist
awtfd      = awtlistout[[1]]$fd
par(mfrow=c(2,1))
plot(bwtfd)
title("Weight for variable")
plot(awtfd)
title("Weight for forcing function")
#  display residual function
reslist = result$resfdlist
par(mfrow=c(1,1))
plot(reslist[[1]], ylab="residual")
title("Residual function")
##
##  Example 6:  two first order constant coefficient equations
##     Dx = -4*x    for  x(t) = exp(-4t)     forced by u(t) =  2
##     Dx = -4*t*x  for  x(t) = exp(-4t^2/2) forced by u(t) = -1
##
beta    = 4
xvec10  = exp(-beta*tvec)
alpha1  = 2
alpha2  = -1
xvec1   = xvec0 + alpha1*(1-xvec10)/beta
xvec20  = exp(-beta*tvec^2/2)
vvec    = exp(beta*tvec^2/2);
intv    = 0.01*(cumsum(vvec) - 0.5*vvec)
xvec2   = xvec20*(1 + alpha2*intv)
xfd1    = smooth.basis(tvec, xvec1, xbasis)$fd
xfd2    = smooth.basis(tvec, xvec2, xbasis)$fd
xfdlist = list(xfd1, xfd2)
bwtlist    = list(
                 list(
                      list(cfdPar),
                      list(cfdPar)
                     ),
                 list(
                      list(cfdPar),
                      list(mfdPar)
                     )
                )
awtlist = list(list(cfdPar), list(cfdPar))
ufdlist = list(list(fd(1,cbasis)), list(fd(1,cbasis)))

#  perform the principal differential analysis
result = pda.fd(xfdlist, bwtlist, awtlist, ufdlist)

# display weight functions for variables
bwtlistout = result$bwtlist
bwtfd11    = bwtlistout[[1]][[1]][[1]]$fd
bwtfd21    = bwtlistout[[2]][[1]][[1]]$fd
bwtfd12    = bwtlistout[[1]][[2]][[1]]$fd
bwtfd22    = bwtlistout[[2]][[2]][[1]]$fd
par(mfrow=c(2,2))
plot(bwtfd11)
title("weight on variable 1 in equation 1")
plot(bwtfd21)
title("weight on variable 2 in equation 1")
plot(bwtfd12)
title("weight on variable 1 in equation 2")
plot(bwtfd22)
title("weight on variable 2 in equation 2")
print(round(bwtfd11$coefs,3))
print(round(bwtfd21$coefs,3))
print(round(bwtfd12$coefs,3))
print(round(bwtfd22$coefs,3))
#  display weight functions for forcing functions
awtlistout = result$awtlist
awtfd1     = awtlistout[[1]][[1]]
awtfd2     = awtlistout[[2]][[1]]
par(mfrow=c(2,1))
plot(awtfd1)
title("weight on forcing function in equation 1")
plot(awtfd2)
title("weight on forcing function in equation 2")
#  display residual functions
reslist    = result$resfdlist
par(mfrow=c(2,1))
plot(reslist[[1]])
title("residual function for equation 1")
plot(reslist[[2]])
title("residual function for equation 2")
par(oldpar)
</code></pre>

<hr>
<h2 id='pda.overlay'>
Stability Analysis for Principle Differential Analysis
</h2><span id='topic+pda.overlay'></span>

<h3>Description</h3>

<p>Overlays the results of a univariate, second-order principal differential
analysis on a bifurcation diagram to demonstrate stability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pda.overlay(pdaList,nfine=501,ncoarse=11,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pda.overlay_+3A_pdalist">pdaList</code></td>
<td>

<p>a list object returned by <code>pda.fd</code>.
</p>
</td></tr>
<tr><td><code id="pda.overlay_+3A_nfine">nfine</code></td>
<td>

<p>number of plotting points to use.
</p>
</td></tr>
<tr><td><code id="pda.overlay_+3A_ncoarse">ncoarse</code></td>
<td>

<p>number of time markers to place along the plotted curve.
</p>
</td></tr>
<tr><td><code id="pda.overlay_+3A_...">...</code></td>
<td>

<p>other arguments for 'plot'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overlays a bivariate plot of the functional parameters in a univariate
second-order principal differential analysis on a bifurcation diagram.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pda.fd">pda.fd</a></code>
<code><a href="#topic+plot.pda.fd">plot.pda.fd</a></code>
<code><a href="#topic+eigen.pda">eigen.pda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
# This example looks at a principal differential analysis of the lip data
# in Ramsay and Silverman (2005).

# First smooth the data

lipfd &lt;- smooth.basisPar(liptime, lip, 6, Lfdobj=int2Lfd(4),
                         lambda=1e-12)$fd
names(lipfd$fdnames) &lt;- c("time(seconds)", "replications", "mm")

# Now we'll set up functional parameter objects for the beta coefficients.

lipbasis &lt;- lipfd$basis
lipfd0   &lt;- fd(matrix(0,lipbasis$nbasis,1),lipbasis)
lipfdPar &lt;- fdPar(lipfd0,2,0)
bwtlist  &lt;- list(lipfdPar,lipfdPar)
xfdlist  &lt;- list(lipfd)

# Call pda

pdaList &lt;- pda.fd(xfdlist, bwtlist)

# And plot the overlay

pda.overlay(pdaList,lwd=2,cex.lab=1.5,cex.axis=1.5)
par(oldpar)
</code></pre>

<hr>
<h2 id='phaseplanePlot'>
Phase-plane plot
</h2><span id='topic+phaseplanePlot'></span>

<h3>Description</h3>

<p>Plot acceleration (or Ldfobj2) vs. velocity (or Lfdobj1) of a function
data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phaseplanePlot(evalarg, fdobj, Lfdobj1=1, Lfdobj2=2,
        lty=c("longdash", "solid"),
      labels=list(evalarg=seq(evalarg[1], max(evalarg), length=13),
             labels=fda::monthLetters),
      abline=list(h=0, v=0, lty=2), xlab="Velocity",
      ylab="Acceleration", returnMatrix=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phaseplanePlot_+3A_evalarg">evalarg</code></td>
<td>

<p>a vector of argument values at which the functional data object is
to be evaluated.
</p>
<p>Defaults to a sequence of 181 points in the range
specified by fdobj[[&quot;basis&quot;]][[&quot;rangeval&quot;]].
</p>
<p>If(length(evalarg) == 1)it is replaced by seq(evalarg[1],
evalarg[1]+1, length=181).
</p>
<p>If(length(evalarg) == 2)it is replaced by seq(evalarg[1],
evalarg[2], length=181).
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object to be evaluated.
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_lfdobj1">Lfdobj1</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.  The points plotted on the horizontal axis are
eval.fd(evalarg, fdobj, Lfdobj1).  By default, this is the
velocity.
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_lfdobj2">Lfdobj2</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.  The points plotted on the vertical axis are
eval.fd(evalarg, fdobj, Lfdobj2).  By default, this is the
acceleration.
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_lty">lty</code></td>
<td>

<p>line types for the first and second halves of the plot.
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_labels">labels</code></td>
<td>

<p>a list of length two:
</p>
<p>evalarg = a numeric vector of 'evalarg' values to be labeled.
</p>
<p>labels = a character vector of labels, replicated to the same length
as labels[[&quot;evalarg&quot;]] in case it's not of the same length.
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_abline">abline</code></td>
<td>

<p>arguments to a call to abline.
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_xlab">xlab</code></td>
<td>

<p>x axis label
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_ylab">ylab</code></td>
<td>

<p>y axis label
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
<tr><td><code id="phaseplanePlot_+3A_...">...</code></td>
<td>

<p>optional arguments passed to plot.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a matrix with two columns containg the points
plotted.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>,
<code><a href="#topic+eval.fd">eval.fd</a></code>
<code><a href="#topic+plot.fd">plot.fd</a></code>
<code><a href="#topic+nondurables">nondurables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>goodsbasis &lt;- create.bspline.basis(rangeval=c(1919,2000),
                                   nbasis=161, norder=8)
LfdobjNonDur &lt;- int2Lfd(4)
argvals = seq(1919,2000,len=length(nondurables))
logNondurSm &lt;- smooth.basisPar(argvals,
                y=log10(nondurables), fdobj=goodsbasis,
                Lfdobj=LfdobjNonDur, lambda=1e-11)
oldpar &lt;- par(no.readonly=TRUE)
phaseplanePlot(1964, logNondurSm$fd)
par(oldpar)
</code></pre>

<hr>
<h2 id='pinch'>
pinch force data
</h2><span id='topic+pinch'></span><span id='topic+pinchraw'></span><span id='topic+pinchtime'></span>

<h3>Description</h3>

<p>151 measurements of pinch force during 20 replications with time from
start of measurement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pinch
pinchraw
pinchtime
</code></pre>


<h3>Format</h3>


<dl>
<dt>pinch, pinchraw</dt><dd>
<p>Matrices of dimension c(151, 20) = 20 replications of measuring
pinch force every 2 milliseconds for 300 milliseconds.  The
original data included 300 observations.  <code>pinchraw</code> consists
of the first 151 of the 300 observations.  <code>pinch</code> selected
151 observations so the maximum of each curve occurred at 0.076
seconds.
</p>
</dd>
<dt>pinchtime</dt><dd>
<p>time in seconds from the start = seq(0, 0.3, 151) = every 2
milliseconds.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Measurements every 2 milliseconds.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>matplot (pinchtime, pinchraw, type="l", lty=1, cex=2,
         col=1, lwd=1,  xlab = "Seconds", ylab="Force (N)")
abline(h=2, lty=2)

matplot (pinchtime, pinch, type="l", lty=1, cex=2,
         col=1, lwd=1,  xlab = "Seconds", ylab="Force (N)")
abline(h=2, v=0.075, lty=2)
</code></pre>

<hr>
<h2 id='plot.basisfd'>
Plot a Basis Object
</h2><span id='topic+plot.basisfd'></span>

<h3>Description</h3>

<p>Plots all the basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basisfd'
plot(x, knots=TRUE, axes=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.basisfd_+3A_x">x</code></td>
<td>

<p>a basis object
</p>
</td></tr>
<tr><td><code id="plot.basisfd_+3A_knots">knots</code></td>
<td>

<p>logical:  If TRUE and x[['type']] == 'bspline', the knot locations
are plotted using vertical dotted, red lines.  Ignored otherwise.
</p>
</td></tr>
<tr><td><code id="plot.basisfd_+3A_axes">axes</code></td>
<td>

<p>Either a logical or a list or <code>NULL</code>.
</p>

<dl>
<dt>logical</dt><dd>
<p>whether axes should be drawn on the plot
</p>
</dd>
<dt>list</dt><dd>
<p>a list used to create custom <code>axes</code> used to create axes via
<code>x$axes[[1]]</code> and  <code>x$axes[-1]</code>.  The primary example of
this uses <code>list("axesIntervals", ...)</code>, e.g., with
<code>Fourier</code> bases to create <code>CanadianWeather</code> plots
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plot.basisfd_+3A_...">...</code></td>
<td>

<p>additional plotting parameters passed to <code>matplot</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Side Effects</h3>

<p>a plot of the basis functions
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fd">plot.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## 1.  b-spline
##
# set up the b-spline basis for the lip data, using 23 basis functions,
#   order 4 (cubic), and equally spaced knots.
#  There will be 23 - 4 = 19 interior knots at 0.05, ..., 0.95
lipbasis &lt;- create.bspline.basis(c(0,1), 23)
# plot the basis functions
plot(lipbasis)

##
## 2.  Fourier basis
##
yearbasis3 &lt;- create.fourier.basis(c(0,365),
                    axes=list("axesIntervals") )
#  plot the basis
plot(yearbasis3)

##
## 3.  With Date and POSIXct rangeval
##
# Date
July4.1776 &lt;- as.Date('1776-07-04')
Apr30.1789 &lt;- as.Date('1789-04-30')
AmRev &lt;- c(July4.1776, Apr30.1789)
BspRevolution &lt;- create.bspline.basis(AmRev)
plot(BspRevolution)

# POSIXct
July4.1776ct &lt;- as.POSIXct1970('1776-07-04')
Apr30.1789ct &lt;- as.POSIXct1970('1789-04-30')
AmRev.ct &lt;- c(July4.1776ct, Apr30.1789ct)
BspRev.ct &lt;- create.bspline.basis(AmRev.ct)
plot(BspRev.ct)
par(oldpar)
</code></pre>

<hr>
<h2 id='plot.cca.fd'>
Plot Functional Canonical Correlation Weight Functions
</h2><span id='topic+plot.cca.fd'></span>

<h3>Description</h3>

<p>A canonical correlation analysis produces a series of pairs of functional 
data objects which, when used as weighting functions, successively maximize
the corresponding canonical correlation between two functional data objects.
Like functional principal component weight functions, successive weight
within either side fo the pair are required to be orthogonal to all previous
weight functions.  Consequently, each successive canonical correlation will
no larger than its predecessor, and more likely substantially smaller.
This function plots an object of class <code>cca.fd</code> that results from the
use of function <code>cca.fd</code>.  Each pair of weight functions is plotted
after a left mouse click indicating that you are ready for the next plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cca.fd'
plot(x, cexval = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cca.fd_+3A_x">x</code></td>
<td>

<p>an object of class <code>cca.fd</code> produced by an invocation of function
<code>cca.fd.R</code>.
</p>
</td></tr>
<tr><td><code id="plot.cca.fd_+3A_cexval">cexval</code></td>
<td>

<p>A number used to determine label sizes in the plots.
</p>
</td></tr>
<tr><td><code id="plot.cca.fd_+3A_...">...</code></td>
<td>

<p>other arguments for 'plot'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces a plot of a pair of weight functions corresponding to each
canonical correlation between two functional data objects.
</p>


<h3>Value</h3>

<p>invisible(NULL)
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cca.fd">cca.fd</a></code>,
<code><a href="#topic+pda.fd">pda.fd</a></code>
<code><a href="#topic+plot.pca.fd">plot.pca.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  Canonical correlation analysis of knee-hip curves
oldpar &lt;- par(no.readonly=TRUE)
gaittime   &lt;- (1:20)/21
gaitrange  &lt;- c(0,1)
gaitbasis  &lt;- create.fourier.basis(gaitrange,21)
gaitnbasis &lt;- gaitbasis$nbasis
lambda     &lt;- 10^(-11.5)
harmaccelLfd &lt;- vec2Lfd(c(0, 0, (2*pi)^2, 0))
gaitfdPar &lt;- fdPar(fd(matrix(0,gaitnbasis,1), gaitbasis), harmaccelLfd, 
                   lambda)
gaitfd    &lt;- smooth.basis(gaittime, gait, gaitfdPar)$fd
ccafdPar  &lt;- fdPar(gaitfd, harmaccelLfd, 1e-8)
ccafd0    &lt;- cca.fd(gaitfd[,1], gaitfd[,2], ncan=3, ccafdPar, ccafdPar)
#  display the canonical correlations
round(ccafd0$ccacorr[1:6],3)
#  plot the unrotated canonical weight functions
plot.cca.fd(ccafd0)
#  compute a VARIMAX rotation of the canonical variables
ccafd1 &lt;- varmx.cca.fd(ccafd0)
#  plot the rotated canonical weight functions
plot.cca.fd(ccafd1)
par(oldpar)
</code></pre>

<hr>
<h2 id='plot.fd'>
Plot a Functional Data Object
</h2><span id='topic+plot.fd'></span><span id='topic+plot.fdPar'></span><span id='topic+plot.fdSmooth'></span>

<h3>Description</h3>

<p>Functional data observations, or a derivative of them, are plotted.
These may be either plotted simultaneously, as <code>matplot</code> does for
multivariate data, or one by one with a mouse click to move from one
plot to another.  The function also accepts the other plot
specification arguments that the regular <code>plot</code> does.  Calling
<code>plot</code> with an <code>fdSmooth</code> or an <code>fdPar</code>
object plots its <code>fd</code> component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
  plot(x, y, Lfdobj=0, href=TRUE, titles=NULL,
                    xlim=NULL, ylim=NULL, xlab=NULL,
                    ylab=NULL, ask=FALSE, nx=NULL, axes=NULL, ...)
## S3 method for class 'fdPar'
plot(x, y, Lfdobj=0, href=TRUE, titles=NULL,
                    xlim=NULL, ylim=NULL, xlab=NULL,
                    ylab=NULL, ask=FALSE, nx=NULL, axes=NULL, ...)
## S3 method for class 'fdSmooth'
plot(x, y, Lfdobj=0, href=TRUE, titles=NULL,
                    xlim=NULL, ylim=NULL, xlab=NULL,
                    ylab=NULL, ask=FALSE, nx=NULL, axes=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.fd_+3A_x">x</code></td>
<td>

<p>functional data object(s) to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_y">y</code></td>
<td>

<p>sequence of points at which to evaluate the functions 'x' and plot
on the horizontal axis.  Defaults to seq(rangex[1], rangex[2],
length = nx).
</p>
<p>NOTE:  This will be the values on the horizontal axis, NOT the
vertical axis.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object. If present, the derivative or the value of applying the
operator is plotted rather than the functions themselves.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_href">href</code></td>
<td>

<p>a logical variable:  If <code>TRUE</code>, add a horizontal reference line
at 0.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_titles">titles</code></td>
<td>

<p>a vector of strings for identifying curves
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_xlab">xlab</code></td>
<td>

<p>a label for the horizontal axis.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_ylab">ylab</code></td>
<td>

<p>a label for the vertical axis.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_xlim">xlim</code></td>
<td>

<p>a vector of length 2 containing axis limits for the horizontal axis.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_ylim">ylim</code></td>
<td>

<p>a vector of length 2 containing axis limits for the vertical axis.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_ask">ask</code></td>
<td>

<p>a logical value:  If <code>TRUE</code>, each curve is shown separately, and
the plot advances with a mouse click
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_nx">nx</code></td>
<td>

<p>the number of points to use to define the plot.  The default is
usually enough, but for a highly variable function more may be
required.
</p>
</td></tr>
<tr><td><code id="plot.fd_+3A_axes">axes</code></td>
<td>

<p>Either a logical or a list or <code>NULL</code>.
</p>

<dl>
<dt>logical</dt><dd>
<p>whether axes should be drawn on the plot
</p>
</dd>
<dt>list</dt><dd>
<p>a list used to create custom <code>axes</code> used to create axes via
<code>x$axes[[1]]</code> and <code>x$axes[-1]</code>.  The primary example of
this uses <code>list("axesIntervals", ...)</code>, e.g., with
<code>Fourier</code> bases to create <code>CanadianWeather</code> plots
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plot.fd_+3A_...">...</code></td>
<td>

<p>additional plotting arguments that can be used with function
<code>plot</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for multivariate data, a suitable array must first be
defined using the <code>par</code> function.
</p>


<h3>Value</h3>

<p>'done'




</p>


<h3>Side Effects</h3>

<p>a plot of the functional observations
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lines.fd">lines.fd</a></code>, <code><a href="#topic+plotfit.fd">plotfit.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## plot.fd
##
daybasis65 &lt;- create.fourier.basis(c(0, 365), 65,
                    axes=list("axesIntervals"))
harmaccelLfd &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))
harmfdPar    &lt;- fdPar(fd(matrix(0, daybasis65$nbasis,1), daybasis65), 
                      harmaccelLfd, lambda=1e5)
daytempfd &lt;- with(CanadianWeather, smooth.basis(day.5,
        dailyAv[,,"Temperature.C"], daybasis65)$fd)
#  plot all the temperature functions for the monthly weather data
plot(daytempfd, main="Temperature Functions")
if (!CRAN()) {
  # To plot one at a time:
  # The following pauses to request page changes.
  
  plot(daytempfd, ask=TRUE)
}

##
## plot.fdSmooth
##
b3.4 &lt;- create.bspline.basis(nbasis=4, norder=3, breaks=c(0, .5, 1))
# 4 bases, order 3 = degree 2 =
# continuous, bounded, locally quadratic
fdPar3 &lt;- fdPar(fd(matrix(0,4,1), b3.4), lambda=1)

# Penalize excessive slope Lfdobj=1;
# (Can not smooth on second derivative Lfdobj=2 at it is discontinuous.)
fd3.4s0 &lt;- smooth.basis(0:1, 0:1, fdPar3)

# using plot.fd directly
plot(fd3.4s0$fd)


##
## with Date and POSIXct argvals
##
# Date
invasion1 &lt;- as.Date('1775-09-04')
invasion2 &lt;- as.Date('1812-07-12')
earlyUS.Canada &lt;- as.numeric(c(invasion1, invasion2))
BspInvasion    &lt;- create.bspline.basis(earlyUS.Canada)

earlyUSyears &lt;- seq(invasion1, invasion2, length.out=7)
earlyUScubic &lt;- (as.numeric(earlyUSyears-invasion1)/365.24)^3
earlyUSyears &lt;- as.numeric(earlyUSyears)
fitCubic     &lt;- smooth.basis(earlyUSyears, earlyUScubic, BspInvasion)$fd
plot(fitCubic)

# POSIXct
AmRev.ct    &lt;- as.POSIXct1970(c('1776-07-04', '1789-04-30'))
AmRevYrs.ct &lt;- seq(AmRev.ct[1], AmRev.ct[2], length.out=14)
AmRevLin.ct &lt;- as.numeric(AmRevYrs.ct-AmRev.ct[2])
AmRevYrs.ct &lt;- as.numeric(AmRevYrs.ct)
BspRev.ct   &lt;- create.bspline.basis(AmRev.ct)
fitLin.ct   &lt;- smooth.basis(AmRevYrs.ct, AmRevLin.ct, BspRev.ct)$fd
plot(fitLin.ct)
par(oldpar)
</code></pre>

<hr>
<h2 id='plot.Lfd'>
Plot a Linear Differential Operator Object
</h2><span id='topic+plot.Lfd'></span>

<h3>Description</h3>

<p>Plot the coefficents of the terms of order 0 through <code>m-1</code> of an
object of class <code>Lfd</code> and length <code>m</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lfd'
plot(x, axes=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Lfd_+3A_x">x</code></td>
<td>

<p>a linear differential operator object to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.Lfd_+3A_axes">axes</code></td>
<td>

<p>Either a logical or a list or <code>NULL</code> passed to <code>plot.fd</code>.
</p>

<dl>
<dt>logical</dt><dd>
<p>whether axes should be drawn on the plot
</p>
</dd>
<dt>list</dt><dd>
<p>a list used to create custom <code>axes</code> used to create axes via
<code>x$axes[[1]]</code> and  <code>x$axes[-1]</code>.  The primary example of
this uses <code>list("axesIntervals", ...)</code>, e.g., with
<code>Fourier</code> bases to create <code>CanadianWeather</code> plots
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plot.Lfd_+3A_...">...</code></td>
<td>

<p>additional plotting arguments that can be used with function
<code>plot</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(NULL)
</p>


<h3>Side Effects</h3>

<p>a plot of the linear differential operator object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Lfd">Lfd</a></code>, <code><a href="#topic+plot.fd">plot.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  Set up the harmonic acceleration operator
dayrange  &lt;- c(0,365)
Lbasis  &lt;- create.constant.basis(dayrange,
                  axes=list("axesIntervals"))
Lcoef   &lt;- matrix(c(0,(2*pi/365)^2,0),1,3)
bfdobj  &lt;- fd(Lcoef,Lbasis)
bwtlist &lt;- fd2list(bfdobj)
harmaccelLfd &lt;- Lfd(3, bwtlist)
oldpar &lt;- par(no.readonly=TRUE)
plot(harmaccelLfd)
par(oldpar)
</code></pre>

<hr>
<h2 id='plot.pca.fd'>
Plot Functional Principal Components
</h2><span id='topic+plot.pca.fd'></span>

<h3>Description</h3>

<p>Display the types of variation across a sample of functions.  Label
with the eigenvalues that indicate the relative importance of each
mode of variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'pca.fd'
plot(x, nx = 128, pointplot = TRUE, harm = 0,
                        expand = 0, cycle = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pca.fd_+3A_x">x</code></td>
<td>

<p>a functional data object.
</p>
</td></tr>
<tr><td><code id="plot.pca.fd_+3A_nx">nx</code></td>
<td>

<p>Number of points to plot or vector (if length &gt; 1) to use as
<code>evalarg</code> in evaluating and plotting the functional principal
components.
</p>
</td></tr>
<tr><td><code id="plot.pca.fd_+3A_pointplot">pointplot</code></td>
<td>

<p>logical:  If TRUE, the harmonics / principal components are plotted
as '+' and '-'.   Otherwise lines are used.
</p>
</td></tr>
<tr><td><code id="plot.pca.fd_+3A_harm">harm</code></td>
<td>

<p>Harmonics / principal components to plot.  If 0, plot all.
</p>
<p>If length(harm) &gt; sum(par(&quot;mfrow&quot;)), the user advised, &quot;Waiting to
confirm page change...&quot; and / or 'Click or hit ENTER for next page'
for each page after the first.
</p>
</td></tr>
<tr><td><code id="plot.pca.fd_+3A_expand">expand</code></td>
<td>

<p>nonnegative real:  If expand == 0 then effect of +/- 2 standard
deviations of each pc are given otherwise the factor expand is
used.
</p>
</td></tr>
<tr><td><code id="plot.pca.fd_+3A_cycle">cycle</code></td>
<td>

<p>logical:  If cycle=TRUE and there are 2 variables then a cycle plot
will be drawn If the number of variables is anything else, cycle
will be ignored.
</p>
</td></tr>
<tr><td><code id="plot.pca.fd_+3A_...">...</code></td>
<td>

<p>other arguments for 'plot'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces one plot for each principal component / harmonic to be
plotted.
</p>


<h3>Value</h3>

<p>invisible(NULL)
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cca.fd">cca.fd</a></code>,
<code><a href="#topic+pda.fd">pda.fd</a></code>
<code><a href="#topic+plot.pca.fd">plot.pca.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  carry out a PCA of temperature
#  penalize harmonic acceleration, use varimax rotation

daybasis65 &lt;- create.fourier.basis(c(0, 365), nbasis=65, period=365)

harmaccelLfd &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))
harmfdPar    &lt;- fdPar(fd(matrix(0,65,1), daybasis65), harmaccelLfd, lambda=1e5)
daytempfd    &lt;- smooth.basis(day.5, CanadianWeather$dailyAv[,,"Temperature.C"],
                     daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd

daytemppcaobj &lt;- pca.fd(daytempfd, nharm=4, harmfdPar)
#  plot harmonics, asking before each new page after the first:
plot.pca.fd(daytemppcaobj)

# plot 4 on 1 page
par(mfrow=c(2,2))
plot.pca.fd(daytemppcaobj, cex.main=0.9)
par(oldpar)
</code></pre>

<hr>
<h2 id='plot.pda.fd'>
Plot Principle Differential Analysis Components
</h2><span id='topic+plot.pda.fd'></span>

<h3>Description</h3>

<p>Plots the results of pda.fd, allows the user to group coefficient functions
by variable, equation, derivative or combination of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pda.fd'
plot(x,whichdim=1,npts=501,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.pda.fd_+3A_x">x</code></td>
<td>

<p>an object of class <code>pda.fd</code>.
</p>
</td></tr>
<tr><td><code id="plot.pda.fd_+3A_whichdim">whichdim</code></td>
<td>

<p>which dimension to use as grouping variables
</p>

<dl>
<dt>1</dt><dd><p> coefficients of each variable differential equation</p>
</dd>
<dt>2</dt><dd><p> coefficient functions for each equation</p>
</dd>
<dt>3</dt><dd><p> coefficients of derivatives of each variable</p>
</dd>
</dl>

<p><code>whichdim</code> should be an ordered vector of length between 1 and
3.
</p>
</td></tr>
<tr><td><code id="plot.pda.fd_+3A_npts">npts</code></td>
<td>

<p>number of points to use for plotting.
</p>
</td></tr>
<tr><td><code id="plot.pda.fd_+3A_...">...</code></td>
<td>

<p>other arguments for 'plot'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces one plot for each coefficient function in a principle differential
analysis.
</p>


<h3>Value</h3>

<p>invisible(NULL)
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pda.fd">pda.fd</a></code>
<code><a href="#topic+eigen.pda">eigen.pda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  A pda analysis of the handwriting data

# reduce the size to reduce the compute time for the example
ni &lt;- 281
indx &lt;- seq(1, 1401, length=ni)
fdaarray &lt;- handwrit[indx,,]
fdatime  &lt;- seq(0, 2.3, len=ni)

#  basis for coordinates

fdarange &lt;- c(0, 2.3)
breaks   &lt;- seq(0,2.3,length.out=116)
norder   &lt;- 6
fdabasis &lt;- create.bspline.basis(fdarange,norder=norder,breaks=breaks)

#  parameter object for coordinates

fdafd0 &lt;- fd(matrix(0,fdabasis$nbasis,1), fdabasis)
fdaPar &lt;- fdPar(fdafd0,int2Lfd(4),1e-8)

#  coordinate functions and a list tontaining them

Xfd &lt;- smooth.basis(fdatime, fdaarray[,,1], fdaPar)$fd
Yfd &lt;- smooth.basis(fdatime, fdaarray[,,2], fdaPar)$fd

xfdlist &lt;- list(Xfd, Yfd)

#  basis and parameter object for weight functions

fdabasis2 &lt;- create.bspline.basis(fdarange,norder=norder,nbasis=31)
fdafd0    &lt;- fd(matrix(0,fdabasis2$nbasis,1), fdabasis2)
pdaPar    &lt;- fdPar(fdafd0,1,1e-8)

pdaParlist &lt;- list(pdaPar, pdaPar)

bwtlist &lt;- list( list(pdaParlist,pdaParlist), list(pdaParlist,pdaParlist) )

#  do the second order pda

pdaList &lt;- pda.fd(xfdlist, bwtlist)

# plot the results

plot(pdaList,whichdim=1)
plot(pdaList,whichdim=2)
plot(pdaList,whichdim=3)

plot(pdaList,whichdim=c(1,2))
plot(pdaList,whichdim=c(1,3))
plot(pdaList,whichdim=c(2,3))

plot(pdaList,whichdim=1:3)
par(oldpar)
</code></pre>

<hr>
<h2 id='plotbeta'>
Plot a functional parameter object with confidence limits
</h2><span id='topic+plotbeta'></span>

<h3>Description</h3>

<p>Plot a functional parameter object with confidence limits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotbeta(betaestlist, betastderrlist, argvals=NULL, xlab="", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotbeta_+3A_betaestlist">betaestlist</code></td>
<td>

<p>a list containing one or more functional parameter objects
(class = fdPar) or functional data objects (class = fd).
</p>
</td></tr>
<tr><td><code id="plotbeta_+3A_betastderrlist">betastderrlist</code></td>
<td>

<p>a list containing functional data objects for the standard errors of
the objects in <code>betaestlist</code>.
</p>
</td></tr>
<tr><td><code id="plotbeta_+3A_argvals">argvals</code></td>
<td>

<p>a sequence of values at which to evaluate <code>betaestlist</code> and
<code>betastderrlist</code>.
</p>
</td></tr>
<tr><td><code id="plotbeta_+3A_xlab">xlab</code></td>
<td>
<p> x axis label </p>
</td></tr>
<tr><td><code id="plotbeta_+3A_...">...</code></td>
<td>

<p>additional plotting parameters passed to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Side Effects</h3>

<p>a plot of the basis functions
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fd">plot.fd</a></code>
</p>

<hr>
<h2 id='plotfit'>
Plot a Functional Data Object With Data
</h2><span id='topic+plotfit.fd'></span><span id='topic+plotfit.fdSmooth'></span>

<h3>Description</h3>

<p>Plot either functional data observations 'x' with a fit 'fdobj' or
residuals from the fit.
</p>
<p>This function is useful for assessing how well a functional data
object fits the actual discrete data.
</p>
<p>The default is to make one plot per functional observation with fit
if residual is FALSE and superimposed lines if residual==TRUE.
</p>
<p>With multiple plots, the system waits to confirm a desire to move to
the next page unless ask==FALSE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotfit.fd(y, argvals, fdobj, rng = NULL, index = NULL,
      nfine = 101, residual = FALSE, sortwrd = FALSE, titles=NULL,
      ylim=NULL, ask=TRUE, type=c("p", "l")[1+residual],
      xlab=NULL, ylab=NULL, sub=NULL, col=1:9, lty=1:9, lwd=1,
      cex.pch=1, axes=NULL, ...)
plotfit.fdSmooth(y, argvals, fdSm, rng = NULL, index = NULL,
      nfine = 101, residual = FALSE, sortwrd = FALSE, titles=NULL,
      ylim=NULL, ask=TRUE, type=c("p", "l")[1+residual],
      xlab=NULL, ylab=NULL, sub=NULL, col=1:9, lty=1:9, lwd=1,
      cex.pch=1, axes=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotfit_+3A_y">y</code></td>
<td>

<p>a vector, matrix or array containing the discrete observations used
to estimate the functional data object.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_argvals">argvals</code></td>
<td>

<p>a vector containing the argument values corresponding to the first
dimension of <code>y</code>.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object estimated from the data.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_fdsm">fdSm</code></td>
<td>
<p> an object of class <code>fdSmooth</code> </p>
</td></tr>
<tr><td><code id="plotfit_+3A_rng">rng</code></td>
<td>

<p>a vector of length 2 specifying the limits for the horizontal axis.
This must be a subset of fdobj[['basis']][['rangeval']], which is
the default.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_index">index</code></td>
<td>

<p>a set of indices of functions if only a subset of the observations
are to be plotted.  Subsetting can also be achieved by subsetting
<code>y</code>;  see <code>details</code>, below.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_nfine">nfine</code></td>
<td>

<p>the number of argument values used to define the plot of the
functional data object.  This may need to be increased if the
functions have a great deal of fine detail.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_residual">residual</code></td>
<td>

<p>a logical variable:  if <code>TRUE</code>, the residuals are plotted
rather than the data and functional data object.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_sortwrd">sortwrd</code></td>
<td>

<p>a logical variable:  if <code>TRUE</code>, the observations (i.e., second
dimension of <code>y</code>) are sorted for plotting by the size of the
sum of squared residuals.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_titles">titles</code></td>
<td>

<p>a vector containing strings that are titles for each observation.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_ylim">ylim</code></td>
<td>

<p>a numeric vector of length 2 giving the y axis limits;  see 'par'.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_ask">ask</code></td>
<td>

<p>If TRUE and if 'y' has more levels than the max length of col, lty,
lwd and cex.pch, the user must confirm page change before the next
plot will be created.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_type">type</code></td>
<td>

<p>type of plot desired, as described with <code><a href="base.html#topic+plot">plot</a></code>.  If
residual == FALSE, 'type' controls the representation for 'x', which
will typically be 'p' to plot points but not lines;  'fdobj' will
always plot as a line.  If residual == TRUE, the default type ==
&quot;l&quot;;  an alternative is &quot;b&quot; for both.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_xlab">xlab</code></td>
<td>
<p>x axis label. </p>
</td></tr>
<tr><td><code id="plotfit_+3A_ylab">ylab</code></td>
<td>

<p>Character vector of y axis labels.  If(residual), ylab defaults to
'Residuals', else to varnames derived from names(fdnames[[3]] or
fdnames[[3]] or dimnames(y)[[3]].
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_sub">sub</code></td>
<td>

<p>subtitle under the x axis label.  Defaults to the RMS residual from
the smooth.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_col">col</code>, <code id="plotfit_+3A_lty">lty</code>, <code id="plotfit_+3A_lwd">lwd</code>, <code id="plotfit_+3A_cex.pch">cex.pch</code></td>
<td>

<p>Numeric or character vectors specifying the color (col), line type
(lty), line width (lwd) and size of plotted character symbols
(cex.pch) of the data representation on the plot.
</p>
<p>If ask==TRUE, the length of the longest of these determines the
number of levels of the array 'x' in each plot before asking the
user to acknowledge a desire to change to the next page.  Each of
these is replicated to that length, so col[i] is used for x[,i] (if
x is 2 dimensional), with line type and width controlled by lty[i]
and lwd[i], respectively.
</p>
<p>If ask==FALSE, these are all replicated to length = the number of
plots to be superimposed.
</p>
<p>For more information on alternative values for these paramters, see
'col', 'lty', 'lwd', or 'cex' with <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plotfit_+3A_axes">axes</code></td>
<td>

<p>Either a logical or a list or <code>NULL</code>.
</p>

<dl>
<dt>logical</dt><dd>
<p>whether axes should be drawn on the plot
</p>
</dd>
<dt>list</dt><dd>
<p>a list used to create custom <code>axes</code> used to create axes via
<code>x$axes[[1]]</code> and x$axes[-1])</p>
</dd></dl>
<p>.  The primary example of
this uses <code>list("axesIntervals", ...)</code>, e.g., with
<code>Fourier</code> bases to create <code>CanadianWeather</code> plots

</p>
</td></tr>
<tr><td><code id="plotfit_+3A_...">...</code></td>
<td>

<p>additional arguments such as axis labels that may be used with other
<code>plot</code> functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotfit</code> plots discrete data along with a functional data object
for fitting the data.  It is designed to be used after something like
<code>smooth.fd</code>, <code>smooth.basis</code> or
<code>smooth.fdPar</code> to check the fit of the data offered by the
<code>fd</code> object.
</p>
<p><code>plotfit.fdSmooth</code> calls <code>plotfit</code> for its 'fd' component.
</p>
<p>The plot can be restricted to a subset of observations (i.e., second
dimension of <code>y</code>) or variables (i.e., third dimension of
<code>y</code>) by providing <code>y</code> with the dimnames for its second and
third dimensions matching a subset of the dimnames of fdobj[['coef']]
(for <code>plotfit.fd</code> or fdSm[['fdobj']][['coef']] for
<code>plotfit.fdSmooth</code>).  If only one observation or variable is to
be plotted, <code>y</code> must include 'drop = TRUE', as, e.g., y[, 2, 3,
drop=TRUE].  If <code>y</code> or fdobj[['coef']] does not have dimnames on
its second or third dimension, subsetting is achieved by taking the
first few colums so the second or third dimensions match.  This is
achieved using checkDims3(y, fdobj[['coef']], defaultNames =
fdobj[['fdnames']]]).
</p>


<h3>Value</h3>

<p>A matrix of mean square deviations from predicted is returned
invisibly.  If fdobj[[&quot;coefs&quot;]] is a 3-dimensional array, this is a
matrix of dimensions equal to the last two dimensions of
fdobj[[&quot;coefs&quot;]].  This will typically be the case when x is also a
3-dimensional array with the last two dimensions matching those of
fdobj[[&quot;coefs&quot;]].  The second dimension is typically replications and
the third different variables.
</p>
<p>If x and fobj[[&quot;coefs&quot;]] are vectors or 2-dimensional arrays, they are
padded to three dimensions, and then MSE is computed as a matrix with
the second dimension = 1;  if x and fobj[[&quot;coefs&quot;]] are vectors, the
first dimension of the returned matrix will also be 1.
</p>


<h3>Side Effects</h3>

<p>a plot of the the data 'x' with the function or the deviations between
observed and predicted, depending on whether residual is FALSE or
TRUE.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>,
<code><a href="#topic+plot.fd">plot.fd</a></code>,
<code><a href="#topic+lines.fd">lines.fd</a></code>,
<code><a href="#topic+plot.fdSmooth">plot.fdSmooth</a></code>,
<code><a href="#topic+lines.fdSmooth">lines.fdSmooth</a></code>,
<code><a href="graphics.html#topic+par">par</a></code>,
<code><a href="#topic+smooth.fd">smooth.fd</a></code>,
<code><a href="#topic+smooth.basis">smooth.basis</a></code>,
<code><a href="#topic+smooth.basisPar">smooth.basisPar</a></code>,
<code><a href="#topic+checkDims3">checkDims3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  set up a Fourier basis for smoothing temperature data
daybasis65 &lt;- create.fourier.basis(c(0, 365), 65,
                    axes=list("axesIntervals"))
#  smooth the average temperature data using function smooth.basis
Daytempfd &lt;- with(CanadianWeather, smooth.basis(day.5,
         dailyAv[,,"Temperature.C"], daybasis65)$fd )
daytempfd &lt;- with(CanadianWeather, smooth.basis(day.5,
         dailyAv[,,"Temperature.C"],
         daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd )
#  Plot the temperature data along with the fit to the data for the first
#  station, St. John's Newfoundland
# If you want only the fitted functions, use plot(daytempfd)
# To plot only a single fit vs. observations, use argument index
# to request which one you want.
with(CanadianWeather, plotfit.fd(dailyAv[, , "Temperature.C",
     drop=FALSE], argvals= day.5, daytempfd, index=1, titles=place) )
# Default ylab = daytempfd[['fdnames']]

with(CanadianWeather, plotfit.fd(dailyAv[, , "Temperature.C"],
     argvals= day.5, Daytempfd, index=1, titles=place) )

plot(daytempfd)

if (!CRAN()) {
# plot all the weather stations, one by one after a click on the plot
# in response to a request.
# This example is within the "dontrun" environment to prevent the
# the R package checking process from pausing: without 'dontrun', the package
# build process might encounter problems with the par(ask=TRUE) feature.
with(CanadianWeather, plotfit.fd(dailyAv[,, "Temperature.C"], day.5,
     daytempfd, ask=TRUE) )
}
#  Now plot results for two weather stations.
op &lt;- par(mfrow=c(2,1), xpd=NA, bty="n")
# xpd=NA:  clip lines to the device region,
#       not the plot or figure region
# bty="n":  Do not draw boxes around the plots.
ylim &lt;- range(CanadianWeather$dailyAv[,,"Temperature.C"])
# Force the two plots to have the same scale
with(CanadianWeather, plotfit.fd(dailyAv[,,"Temperature.C"], day.5,
          daytempfd, index=2, titles=place, ylim=ylim) )
with(CanadianWeather, plotfit.fd(dailyAv[,,"Temperature.C"], day.5,
          daytempfd, index=35, titles=place, ylim=ylim) )
## Not run: 
# Plot residuals with interactive display of stations one by one
par(op)
with(CanadianWeather, plotfit.fd(dailyAv[, , "Temperature.C"],
          day.5, daytempfd, residual=TRUE) )

## End(Not run)
#  The gait data are bivariate, and this code illustrates how plotfit.fd
#  deals with the plotting of two variables at the same time
#  First define normalized times and their range
gaittime  &lt;- (0:19) + 0.5
gaitrange &lt;- c(0,20)
#  Define the harmonic acceleration differential operator
harmaccelLfd &lt;- vec2Lfd(c(0, (2*pi/20)^2, 0), rangeval=gaitrange)
#  Set up basis for representing gait data.
gaitbasis &lt;- create.fourier.basis(gaitrange, nbasis=21)
#  Smooth the data
gaitfd &lt;- smooth.basisPar(gaittime, gait, gaitbasis, 
                          Lfdobj=harmaccelLfd, lambda=1e-2)$fd
#  Assign names to the data
names(gaitfd$fdnames) &lt;- c("Normalized time", "Child", "Angle")
gaitfd$fdnames[[3]] &lt;- c("Hip", "Knee")
## Not run: 
#  plot each pair of curves interactively, two plots per page, the top
#  for hip angle, and the bottom for knee angle
plotfit.fd(gait, gaittime, gaitfd)
#  Plot the residuals, sorting cases by residual sum of squares summed over
#  both hip and knee angles.
#  The first series of 39 plots are for hip angle, two plots per page,
#  and the second 39 are for knee angle.  The plots are sorted by the
#  size of the total residual sum of squares, but RMS residual values
#  for specific angles are not all going to be in order.
plotfit.fd(gait, gaittime, gaitfd, residual=TRUE, sort=TRUE)

## End(Not run)
par(oldpar)
</code></pre>

<hr>
<h2 id='plotscores'>
Plot Principal Component Scores
</h2><span id='topic+plotscores'></span>

<h3>Description</h3>

<p>The coefficients multiplying the harmonics or principal component functions
are plotted as points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotscores(pcafd, scores=c(1, 2), xlab=NULL, ylab=NULL,
           loc=1, matplt2=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotscores_+3A_pcafd">pcafd</code></td>
<td>

<p>an object of the &quot;pca.fd&quot; class that is output by function
<code>pca.fd</code>.
</p>
</td></tr>
<tr><td><code id="plotscores_+3A_scores">scores</code></td>
<td>

<p>the indices of the harmonics for which coefficients are
plotted.
</p>
</td></tr>
<tr><td><code id="plotscores_+3A_xlab">xlab</code></td>
<td>

<p>a label for the horizontal axis.
</p>
</td></tr>
<tr><td><code id="plotscores_+3A_ylab">ylab</code></td>
<td>

<p>a label for the vertical axis.
</p>
</td></tr>
<tr><td><code id="plotscores_+3A_loc">loc</code></td>
<td>

<p>an integer:
if loc  &gt;0, you can then click on the plot in loc places and you'll get
plots of the functions with these values of the principal component
coefficients.
</p>
</td></tr>
<tr><td><code id="plotscores_+3A_matplt2">matplt2</code></td>
<td>

<p>a logical value:
if <code>TRUE</code>, the curves are plotted on the same plot;
otherwise, they are plotted separately.
</p>
</td></tr>
<tr><td><code id="plotscores_+3A_...">...</code></td>
<td>

<p>additional plotting arguments used in function <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>a plot of scores
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pca.fd">pca.fd</a></code>
</p>

<hr>
<h2 id='polintmat'>
Polynomial extrapolation for a converging sequence of one or more values</h2><span id='topic+polintmat'></span>

<h3>Description</h3>

<p>For each value in a set <code>xa</code>, estimates the converged value.  The process
is called Richardson extrapolation.  It terminates when all of two successive 
estimates are within a tolerance of each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polintmat(xa, ya, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polintmat_+3A_xa">xa</code></td>
<td>
<p>Vector of length equal to the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="polintmat_+3A_ya">ya</code></td>
<td>
<p>Array with first dimension number of rows equal to length of <code>xa</code>,
second dimension length equal number of basis functions, and 
third dimension of length 1.</p>
</td></tr>
<tr><td><code id="polintmat_+3A_x">x</code></td>
<td>
<p>A scalar value which, in our applications, is always zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called with in functions <code>monfn</code>, <code>mongrad</code> and 
<code>monhess</code>.   This function computes the estimate for a single iteration 
of the convergence iterations.
</p>


<h3>Value</h3>

<p>A un-named list of length two containing these objects:
</p>
<table role = "presentation">
<tr><td><code>y:</code></td>
<td>
<p>Matrix of order number of argument values by number of basis 
functions.</p>
</td></tr>
<tr><td><code>dy:</code></td>
<td>
<p>Array with same dimensions as argument <code>ya</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. O. Ramsay
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monfn">monfn</a></code>,
<code><a href="#topic+mongrad">mongrad</a></code>,
<code><a href="#topic+monhess">monhess</a></code>
</p>

<hr>
<h2 id='polyg'>
Polygonal Basis Function Values
</h2><span id='topic+polyg'></span>

<h3>Description</h3>

<p>Evaluates a set of polygonal basis functions, or a derivative of these
functions, at a set of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyg(x, argvals, nderiv=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyg_+3A_x">x</code></td>
<td>

<p>a vector of argument values at which the polygonal basis functions are to
evaluated.
</p>
</td></tr>
<tr><td><code id="polyg_+3A_argvals">argvals</code></td>
<td>

<p>a strictly increasing set of argument values containing the range of x
within it that defines the polygonal basis.  The default is x itself.
</p>
</td></tr>
<tr><td><code id="polyg_+3A_nderiv">nderiv</code></td>
<td>

<p>the order of derivative to be evaluated.  The derivative must not exceed
one.  The default derivative is 0, meaning that the basis functions
themselves are evaluated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of function values.  The number of rows equals the number of
arguments, and the number of columns equals the number of basis
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>, 
<code><a href="#topic+polygpen">polygpen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  set up a set of 21 argument values
x &lt;- seq(0,1,0.05)
#  set up a set of 11 argument values
argvals &lt;- seq(0,1,0.1)
#  with the default period (1) and derivative (0)
basismat &lt;- polyg(x, argvals)
#  plot the basis functions
matplot(x, basismat, type="l")
par(oldpar)
</code></pre>

<hr>
<h2 id='polygpen'>
Polygonal Penalty Matrix
</h2><span id='topic+polygpen'></span>

<h3>Description</h3>

<p>Computes the matrix defining the roughness penalty for functions
expressed in terms of a polygonal basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polygpen(basisobj, Lfdobj=int2Lfd(1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polygpen_+3A_basisobj">basisobj</code></td>
<td>

<p>a polygonal functional basis object.
</p>
</td></tr>
<tr><td><code id="polygpen_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either an integer that is either 0 or 1, or a
linear differential operator object of degree 0 or 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a roughness penalty for a function $ x(t) $ is defined by
integrating the square of either the derivative of  $ x(t) $ or,
more generally, the result of applying a linear differential operator
$ L $ to it.  The only roughness penalty possible aside from
penalizing the size of the function itself is the integral
of the square of the first derivative, and
this is the default. To apply this roughness penalty, the matrix of
inner products produced by this function is necessary.
</p>


<h3>Value</h3>

<p>a symmetric matrix of order equal to the number of basis functions
defined by the polygonal basis object.  Each element is the inner product
of two polygonal basis functions after applying the derivative or linear
differential operator defined by Lfdobj.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.polygonal.basis">create.polygonal.basis</a></code>,
<code><a href="#topic+polyg">polyg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  set up a sequence of 11 argument values
argvals &lt;- seq(0,1,0.1)
#  set up the polygonal basis
basisobj &lt;- create.polygonal.basis(argvals)
#  compute the 11 by 11 penalty matrix

penmat &lt;- polygpen(basisobj)

</code></pre>

<hr>
<h2 id='powerbasis'>
Power Basis Function Values
</h2><span id='topic+powerbasis'></span>

<h3>Description</h3>

<p>Evaluates a set of power basis functions, or a derivative of these
functions, at a set of arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerbasis(x, exponents, nderiv=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerbasis_+3A_x">x</code></td>
<td>

<p>a vector of argument values at which the power basis functions are to
evaluated. Since exponents may be negative, for example after
differentiation, it is required that all argument values be positive.
</p>
</td></tr>
<tr><td><code id="powerbasis_+3A_exponents">exponents</code></td>
<td>

<p>a vector of exponents defining the power basis functions.  If
$y$ is such a rate value, the corresponding basis function is
$x$ to the power $y$.  The number of basis functions is equal to the
number of exponents.
</p>
</td></tr>
<tr><td><code id="powerbasis_+3A_nderiv">nderiv</code></td>
<td>

<p>the derivative to be evaluated.  The derivative must not exceed the
order.  The default derivative is 0, meaning that the basis functions
themselves are evaluated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of function values.  The number of rows equals the number of
arguments, and the number of columns equals the number of basis
functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.power.basis">create.power.basis</a></code>, 
<code><a href="#topic+powerpen">powerpen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  set up a set of 10 positive argument values.
x &lt;- seq(0.1,1,0.1)
#  compute values for three power basis functions
exponents &lt;- c(0, 1, 2)
#  evaluate the basis matrix
basismat &lt;- powerbasis(x, exponents)

</code></pre>

<hr>
<h2 id='powerpen'>
Power Penalty Matrix
</h2><span id='topic+powerpen'></span>

<h3>Description</h3>

<p>Computes the matrix defining the roughness penalty for functions
expressed in terms of a power basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerpen(basisobj, Lfdobj=int2Lfd(2))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="powerpen_+3A_basisobj">basisobj</code></td>
<td>

<p>a power basis object.
</p>
</td></tr>
<tr><td><code id="powerpen_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A roughness penalty for a function $ x(t) $ is defined by
integrating the square of either the derivative of  $ x(t) $ or,
more generally, the result of applying a linear differential operator
$ L $ to it.  The most common roughness penalty is the integral of
the square of the second derivative, and
this is the default. To apply this roughness penalty, the matrix of
inner products produced by this function is necessary.
</p>


<h3>Value</h3>

<p>a symmetric matrix of order equal to the number of basis functions
defined by the power basis object.  Each element is the inner product
of two power basis functions after applying the derivative or linear
differential operator defined by <code>Lfdobj</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.power.basis">create.power.basis</a></code>, 
<code><a href="#topic+powerbasis">powerbasis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#  set up an power basis with 3 basis functions.
#  the powers are 0, 1, and 2.
basisobj &lt;- create.power.basis(c(0,1),3,c(0,1,2))
#  compute the 3 by 3 matrix of inner products of second derivatives
#FIXME
#penmat &lt;- powerpen(basisobj, 2)

</code></pre>

<hr>
<h2 id='ppBspline'>Convert a B-spline function to piece-wise polynomial form</h2><span id='topic+ppBspline'></span>

<h3>Description</h3>

<p>The B-spline basis functions of order <code>k = length(t) - 1</code>
defined by the knot sequence in argument <code>t</code> each consist of polynomial
segments with the same order joined end-to-end over the successive gaps in the
knot sequence.  This function computes the <code>k</code> coefficients of these polynomial
segments in the rows of the output matrix <code>coeff</code>, with each row corresponding
to a B-spline basis function that is positive over the interval spanned by the
values in <code>t</code>. The elements of the output vector <code>index</code> indicate where
in the sequence <code>t</code> we find the knots.  Note that we assume
<code>t[1] &lt; t[k+1]</code>, i.e. <code>t</code> is not a sequence of the same knot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ppBspline(t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppBspline_+3A_t">t</code></td>
<td>

<p>numeric vector = knot sequence of length norder+1 where norder =
the order of the B-spline.  The knot sequence must contain at least one gap.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list object containing components
</p>
<table role = "presentation">
<tr><td><code>Coeff</code></td>
<td>

<p>a matrix with rows corresponding to B-spline basis functions positive
over the interval spanned by <code>t</code> and columns corresponding to the
terms <code>1, x, x^2, ...</code> in the polynomial representation.
</p>
</td></tr>
<tr><td><code>index</code></td>
<td>

<p>indices indicating where in the sequence <code>t</code> the knots are to be found
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bsplineS">bsplineS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ppBspline(1:5)
</code></pre>

<hr>
<h2 id='predict.fRegress'>
Predict method for Functional Regression
</h2><span id='topic+predict.fRegress'></span>

<h3>Description</h3>

<p>Model predictions for object of class <code>fRegress</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fRegress'
predict(object, newdata=NULL, se.fit = FALSE,
     interval = c("none", "confidence", "prediction"),
     level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.fRegress_+3A_object">object</code></td>
<td>

<p>Object of class inheriting from <code>fRegress</code>
</p>
</td></tr>
<tr><td><code id="predict.fRegress_+3A_newdata">newdata</code></td>
<td>

<p>Either NULL or a list matching object$xfdlist.
</p>
<p>If(is.null(newdata)) predictions &lt;- object$yhatfdobj
</p>
<p>If newdata is a list, predictions = the sum of either 
</p>
<p>newdata[i] * betaestfdlist[i] if object$yfdobj has class <code>fd</code> 
</p>
<p>or 
</p>
<p>inprod(newdata[i], betaestfdlist[i]) if class(object$yfdobj) =
<code>numeric</code>.
</p>
</td></tr>
<tr><td><code id="predict.fRegress_+3A_se.fit">se.fit</code></td>
<td>

<p>a switch indicating if standard errors of predictions are required
</p>
<p>NOTE:  se.fit = TRUE is NOT IMPLEMENTED YET.  
</p>
</td></tr>
<tr><td><code id="predict.fRegress_+3A_interval">interval</code></td>
<td>

<p>type of prediction (response or model term)
</p>
<p>NOTE:  Only &quot;intervale = 'none'&quot; has been implemented so far.  
</p>
</td></tr>
<tr><td><code id="predict.fRegress_+3A_level">level</code></td>
<td>
<p>Tolerance/confidence level</p>
</td></tr>
<tr><td><code id="predict.fRegress_+3A_...">...</code></td>
<td>

<p>additional arguments for other methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  Without <code>newdata</code>, fit &lt;- object$yhatfdobj.
</p>
<p>2.  With <code>newdata</code>, if(class(object$y) == 'numeric'), fit &lt;- sum
over i of inprod(betaestlist[i], newdata[i]).  Otherwise, fit &lt;- sum
over i of betaestlist[i] * newdata[i].
</p>
<p>3.  If(se.fit | (interval != 'none')) compute <code>se.fit</code>, then
return whatever is desired.
</p>


<h3>Value</h3>

<p>The predictions produced by <code>predict.fRegress</code> are either a
vector or a functional parameter (class <code>fdPar</code>) object, matching
the class of <code>object$y</code>.
</p>
<p>If <code>interval</code> is not &quot;none&quot;, the predictions will be
multivariate for <code>object$y</code> and the requested <code>lwr</code> and
<code>upr</code> bounds.  If <code>object$y</code> is a scalar, these predictions
are returned as a matrix;  otherwise, they are a multivariate
functional parameter object (class <code>fdPar</code>).
</p>
<p>If <code>se.fit</code> is <code>TRUE</code>, <code>predict.fRegress</code> returns a
list with the following components:
</p>
<table role = "presentation">
<tr><td><code>fit</code></td>
<td>

<p>vector or matrix or univariate or multivariate functional parameter
object depending on the value of <code>interval</code> and the class of
<code>object$y</code>.
</p>
</td></tr>
<tr><td><code>se.fit</code></td>
<td>
<p>standard error of predicted means</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Spencer Graves </p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress">fRegress</a></code>
<code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## vector response with functional explanatory variable
##
## Not run: 
annualprec &lt;- log10(apply(CanadianWeather$dailyAv[,,
                   "Precipitation.mm"], 2,sum))
smallbasis  &lt;- create.fourier.basis(c(0, 365), 25)
tempfd &lt;- smooth.basis(day.5,
   CanadianWeather$dailyAv[,,"Temperature.C"], smallbasis)$fd
precip.Temp.f &lt;- fRegress(annualprec ~ tempfd)
precip.Temp.p &lt;- predict(precip.Temp.f)
# plot response vs. fitted 
oldpar &lt;- par(no.readonly=TRUE)
plot(annualprec, precip.Temp.p)
par(oldpar)

## End(Not run)
</code></pre>

<hr>
<h2 id='project.basis'>
Approximate Functional Data Using a Basis
</h2><span id='topic+project.basis'></span>

<h3>Description</h3>

<p>A vector or matrix of discrete data is projected into the space
spanned by the values of a set of basis functions.  This amounts to
a least squares regression of the data on to the values of the basis
functions.  A small penalty can be applied to deal with situations in
which the number of basis functions exceeds the number of basis points.
This function is not normally used in a functional data analysis to
smooth data, since function <code>smooth.basis</code> is provided for that job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project.basis(y, argvals, basisobj, penalize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project.basis_+3A_y">y</code></td>
<td>

<p>a vector or matrix of discrete data.
</p>
</td></tr>
<tr><td><code id="project.basis_+3A_argvals">argvals</code></td>
<td>

<p>a vector containing the argument values correspond to the
values in <code>y</code>.
</p>
</td></tr>
<tr><td><code id="project.basis_+3A_basisobj">basisobj</code></td>
<td>

<p>a basis object.
</p>
</td></tr>
<tr><td><code id="project.basis_+3A_penalize">penalize</code></td>
<td>

<p>a logical variable.  If TRUE, a small roughness penalty is applied
to ensure that the linear equations defining the least squares
solution are linearly independent or nonsingular.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix of coefficients defining the least squares approximation.
This matrix has as many rows are there are basis functions, as many
columns as there are curves, and if the data are multivariate, as many
layers as there are functions.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis">smooth.basis</a></code>
</p>

<hr>
<h2 id='quadset'>
Quadrature points and weights for Simpson's rule
</h2><span id='topic+quadset'></span>

<h3>Description</h3>

<p>Set up quadrature points and weights for Simpson's rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadset(nquad=5, basisobj=NULL, breaks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadset_+3A_nquad">nquad</code></td>
<td>

<p>an odd integer at least 5 giving the number of evenly spaced
Simpson's rule quadrature points to use over each interval
(breaks[i], breaks[i+1]).
</p>
</td></tr>
<tr><td><code id="quadset_+3A_basisobj">basisobj</code></td>
<td>

<p>the basis object that will contain the quadrature points and weights
</p>
</td></tr>
<tr><td><code id="quadset_+3A_breaks">breaks</code></td>
<td>

<p>optional interval boundaries.  If this is provided, the first value
must be the initial point of the interval over which the basis is
defined, and the final value must be the end point.  If this is not
supplied, and 'basisobj' is of type 'bspline', the knots are used as
these values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Set up quadrature points and weights for Simpson's rule and store
information in the output 'basisobj'.  Simpson's rule is used to
integrate a function between successive values in vector 'breaks'.
That is, over each interval (breaks[i], breaks[i+1]).  Simpson's rule
uses 'nquad' equally spaced quadrature points over this interval,
starting with the the left boundary and ending with the right
boundary.  The quadrature weights are the values
delta*c(1,4,2,4,2,4,..., 2,4,1) where 'delta' is the difference
between successive quadrature points, that is, delta =
(breaks[i-1]-breaks[i])/(nquad-1).
</p>


<h3>Value</h3>

<p>If is.null(basisobj), quadset returns a 'quadvals' matrix with columns
quadpts and quadwts.  Otherwise, it returns basisobj with the
two components set as follows:
</p>
<table role = "presentation">
<tr><td><code>quadvals</code></td>
<td>

<p>cbind(quadpts=quadpts, quadwts=quadwts)
</p>
</td></tr>
<tr><td><code>value</code></td>
<td>

<p>a list with two components containing eval.basis(quadpts, basisobj,
ival-1) for ival=1, 2.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create.bspline.basis">create.bspline.basis</a></code>
<code><a href="#topic+eval.basis">eval.basis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(qs7.1 &lt;- quadset(nquad=7, breaks=c(0, .3, 1)))
# cbind(quadpts=c(seq(0, 0.3, length=7),
#              seq(0.3, 1, length=7)),
#    quadwts=c((0.3/18)*c(1, 4, 2, 4, 2, 4, 1),
#              (0.7/18)*c(1, 4, 2, 4, 2, 4, 1) ) )

# The simplest basis currently available with this function:
bspl2.2 &lt;- create.bspline.basis(norder=2, breaks=c(0,.5, 1))

bspl2.2a &lt;- quadset(basisobj=bspl2.2)
bspl2.2a$quadvals
# cbind(quadpts=c((0:4)/8, .5+(0:4)/8),
#       quadwts=rep(c(1,4,2,4,1)/24, 2) )
bspl2.2a$values
# a list of length 2
# [[1]] = matrix of dimension c(10, 3) with the 3 basis
#      functions evaluated at the 10 quadrature points:
# values[[1]][, 1] = c(1, .75, .5, .25, rep(0, 6))
# values[[1]][, 2] = c(0, .25, .5, .75, 1, .75, .5, .25, 0)
# values[[1]][, 3] = values[10:1, 1]
#
# values[[2]] = matrix of dimension c(10, 3) with the
#     first derivative of values[[1]], being either
#    -2, 0, or 2.
</code></pre>

<hr>
<h2 id='reconsCurves'>
Reconstruct data curves using functional principal components 
</h2><span id='topic+reconsCurves'></span>

<h3>Description</h3>

<p>Reconstructs data curves as objects of class <code>fd</code> using functional principal   components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  reconsCurves(data, PC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reconsCurves_+3A_data">data</code></td>
<td>

<p>a set of values of curves at discrete sampling points or
argument values. If the set is supplied as a matrix object, the rows must
correspond to argument values and columns to replications, and it will be
assumed that there is only one variable per observation.  If
<code>data</code> is a three-dimensional array, the first dimension
corresponds to argument values, the second to replications, and the
third to variables within replications.
</p>
</td></tr>
<tr><td><code id="reconsCurves_+3A_pc">PC</code></td>
<td>

<p>an object of class <code>pca.fd</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>fd</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='refinery'>
Reflux and tray level in a refinery
</h2><span id='topic+refinery'></span>

<h3>Description</h3>

<p>194 observations on reflux and &quot;tray 47 level&quot; in a distallation
column in an oil refinery.  
</p>


<h3>Format</h3>

<p>A data.frame with the following components:  
</p>

<dl>
<dt>Time</dt><dd>
<p>observation time 0:193 
</p>
</dd>
<dt>Reflux</dt><dd>
<p>reflux flow centered on the mean of the first 60 observations 
</p>
</dd>
<dt>Tray47</dt><dd>
<p>tray 47 level centered on the mean of the first 60
observations 
</p>
</dd>
</dl>



<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    attach(refinery)
# allow space for an axis on the right 
    op &lt;- par(mar=c(5, 4, 4, 5)+0.1)
# plot uval 
    plot(Time, Reflux, type="l", bty="n")
# add yval 
    y.u &lt;- diff(range(Tray47))/diff(range(Reflux))
    u0 &lt;- min(Reflux)
    y0 &lt;- min(Tray47)

    lines(Time, u0+(Tray47-y0)/y.u, lty=3, lwd=1.5, col="red")
    y.tick &lt;- pretty(range(Tray47))
    axis(4, at=u0+(y.tick)/y.u, labels=y.tick, col="red", lty=3,
            lwd=1.5)
# restore previous plot margins
    par(op)
    detach(refinery)
</code></pre>

<hr>
<h2 id='ReginaPrecip'>
Regina Daily Precipitation
</h2><span id='topic+ReginaPrecip'></span>

<h3>Description</h3>

<p>Temperature in millimeters in June in Regina, Saskatchewan, Canada,
1960 - 1993, omitting 16 missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ReginaPrecip)</code></pre>


<h3>Format</h3>

<p>A numeric vector of length 1006.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CanadianWeather">CanadianWeather</a></code>
<code><a href="#topic+MontrealTemp">MontrealTemp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ReginaPrecip)
hist(ReginaPrecip)

</code></pre>

<hr>
<h2 id='register.fd'>
Register Functional Data Objects Using a Continuous Criterion
</h2><span id='topic+register.fd'></span>

<h3>Description</h3>

<p>A function is said to be aligned or registered with a target function
if its  salient features, such as peaks, valleys and crossings of
fixed thresholds,  occur at about the same argument values as those of
the target.  Function <code>register.fd</code> aligns these features by
transforming or warping  the argument domain of each function in a
nonlinear but strictly  order-preserving fashion.  Multivariate
functions may also be registered.  If the domain is time, we say that
this transformation transforms clock time to system time.  The
transformation itself is called a warping function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register.fd(y0fd=NULL, yfd=NULL, WfdParobj=NULL,
            conv=1e-04, iterlim=20, dbglev=1, periodic=FALSE, crit=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register.fd_+3A_y0fd">y0fd</code></td>
<td>

<p>a functional data object defining one or more target functions for
registering the functions in argument <code>yfd</code>. If the functions
to be registered are univariate, then <code>y0fd</code> may contain only a
single function, or it may contain as many functions as are in
<code>yfd</code>.  If <code>yfd</code> contains multivariate functions, then
<code>y0fd</code> may either as many functions as there are variables in
<code>yfd</code>, or it may contain as many functions as are in <code>yfd</code>
and these functions must then be multivariate and be of the same
dimension as those in <code>yfd</code>.
</p>
<p>If <code>yfd</code> is supplied as a named argument and <code>y0fd</code> is
not, then <code>y0fd</code> is computed inside the function to be the mean
of the functions in <code>yfd</code>.
</p>
<p>If the function is called with a single unnamed argument, and there
is no other argument that is named as <code>y0fd</code> then this unnamed
argument is taken to be actually <code>yfd</code> rather than <code>y0fd</code>,
and then also <code>y0fd</code> is computed to be the man of the functions
supplied.
</p>
</td></tr>
<tr><td><code id="register.fd_+3A_yfd">yfd</code></td>
<td>

<p>a functional data object defining the functions to be
registered to target <code>y0fd</code>.  The functions may be either
univariate or multivariate.
</p>
<p>If <code>yfd</code> contains a single multivariate function is to be
registered, it essential that the coefficient array for <code>y0fd</code>
have class <code>array</code>, have three dimensions, and that its second
dimension be of length 1.
</p>
</td></tr>
<tr><td><code id="register.fd_+3A_wfdparobj">WfdParobj</code></td>
<td>

<p>a functional parameter object containing either a single function or
the same number of functions as are contained in <code>yfd</code>.  The
coefficients supply the initial values in the estimation of a
functions $W(t)$ that defines the warping functions $h(t)$ that
register the set of curves.  <code>WfdParobj</code> also defines the
roughness penalty and smoothing parameter used to control the
roughness of $h(t)$.
</p>
<p>The basis used for this object must be a B-spline type, and the
order of the B-spline basis must be at least 2 (piecewise linear).
</p>
<p>If WFDPAROBJ is not supplied, it is constructed from a bspline basis
of order 2 with 2 basis functions; that is, a basis for piecewise
linear functions.  The smoothing parameter lambda for this default
is 0.
</p>
</td></tr>
<tr><td><code id="register.fd_+3A_conv">conv</code></td>
<td>

<p>a criterion for convergence of the iterations.
</p>
</td></tr>
<tr><td><code id="register.fd_+3A_iterlim">iterlim</code></td>
<td>

<p>a limit on the number of iterations.
</p>
</td></tr>
<tr><td><code id="register.fd_+3A_dbglev">dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out
on each iteration, with 0 implying no output, 1 intermediate output
level, and 2 full output.  R normally postpones displaying these
results until the entire computation is computed, an option that it
calls &quot;output buffering.&quot;  Since the total computation time may be
considerable, one may opt for turning this feature off by
un-checking this box in the &quot;Misc&quot; menu item in the R Console.
</p>
</td></tr>
<tr><td><code id="register.fd_+3A_periodic">periodic</code></td>
<td>

<p>a logical variable:  if <code>TRUE</code>, the functions are considered to
be periodic, in which case a constant can be added to all argument
values after they are warped.
</p>
</td></tr>
<tr><td><code id="register.fd_+3A_crit">crit</code></td>
<td>

<p>an integer that is either 1 or 2 that indicates the nature of the
continuous registration criterion that is used.  If 1, the criterion
is least squares, and if 2, the criterion is the minimum eigenvalue
of a cross-product matrix.  In general, criterion 2 is to be
preferred.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The warping function that smoothly and monotonically transforms the
argument is defined by <code>Wfd</code> is the same as that defines the
monotone smoothing function in for function <code>smooth.monotone.</code>
See the help file for that function for further details.
</p>


<h3>Value</h3>

<p>a named list of length 4 containing the following components:
</p>
<table role = "presentation">
<tr><td><code>regfd</code></td>
<td>

<p>A functional data object containing the registered functions.
</p>
</td></tr>
<tr><td><code>warpfd</code></td>
<td>

<p>A functional data object containing the warping functions $h(t)$.
</p>
</td></tr>
<tr><td><code>Wfd</code></td>
<td>

<p>A functional data object containing the functions $h W(t)$
that define the warping functions $h(t)$.
</p>
</td></tr>
<tr><td><code>shift</code></td>
<td>

<p>If the functions are periodic, this is a vector of time shifts.
</p>
</td></tr>
<tr><td><code>y0fd</code></td>
<td>

<p>The target function object y0fd.
</p>
</td></tr>
<tr><td><code>yfd</code></td>
<td>

<p>The function object yfd containing the functions to be registered.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>,
<code><a href="#topic+register.newfd">register.newfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#See the analyses of the growth data for examples.

##
## 1.  smooth the growth data for the Berkeley boys
##
# Specify smoothing weight
lambda.gr2.3 &lt;- .03
# Specify what to smooth, namely the rate of change of curvature
Lfdobj.growth    &lt;- 2
# Set up a B-spline basis for smoothing the discrete data
nage &lt;- length(growth$age)
norder.growth &lt;- 6
nbasis.growth &lt;- nage + norder.growth - 2
rng.growth &lt;- range(growth$age)
wbasis.growth &lt;- create.bspline.basis(rangeval=rng.growth,
                   nbasis=nbasis.growth, norder=norder.growth,
                   breaks=growth$age)
# Smooth the data
# in afda-ch06.R, and register to individual smooths:
cvec0.growth &lt;- matrix(0,nbasis.growth,1)
Wfd0.growth  &lt;- fd(cvec0.growth, wbasis.growth)
growfdPar2.3 &lt;- fdPar(Wfd0.growth, Lfdobj.growth, lambda.gr2.3)
hgtmfd.all   &lt;- with(growth, smooth.basis(age, hgtm, growfdPar2.3)$fd)
# Register the growth velocity rather than the
# growth curves directly
smBv &lt;- deriv.fd(hgtmfd.all, 1)

##
## 2.  Register the first 2 Berkeley boys using the default basis
##     for the warping function
##
# register.fd takes time, so we use only 2 curves as an illustration
# to minimize computing time in these examples
nBoys &lt;- 2
#  Define the target function as the mean of the first nBoys records
smBv0 = mean.fd(smBv[1:nBoys])
#  Register these curves.  The default choice for the functional
#  parameter object WfdParObj is used.
smB.reg.0 &lt;- register.fd(smBv0, smBv[1:nBoys])
#  plot each curve.  Click on the R Graphics window to show each plot.
#  The left panel contains:
#    -- the unregistered curve (dashed blue line)
#    -- the target function (dashed red line)
#    -- the registered curve (solid blue line)
#  The right panel contains:
#    -- the warping function h(t)
#    -- the linear function corresponding to no warping
#  plotreg.fd(smB.reg.0) # this function has been removed
#  Notice that all the warping functions all have simple shapes
#  due to the use of the simplest possible basis

if (!CRAN()) {
##
## 3.  Define a more flexible basis for the warping functions
##
Wnbasis   &lt;- 4
Wbasis    &lt;- create.bspline.basis(rng.growth, Wnbasis)
Wfd0      &lt;- fd(matrix(0,Wnbasis,1),Wbasis)
#  set up the functional parameter object using only
#      a light amount smoothing
WfdParobj &lt;- fdPar(Wfd0, Lfdobj=2, lambda=0.01)
#  register the curves
smB.reg.1 &lt;- register.fd(smBv0, smBv[1:nBoys], WfdParobj)
#. plotreg.fd(smB.reg.1). #. removed
#  Notice that now the warping functions can have more complex shapes

##
## 4.  Change the target to the mean of the registered functions ...
##     this should provide a better target for registration
##
smBv1 &lt;- mean.fd(smB.reg.1$regfd)
#  plot the old and the new targets
par(mfrow=c(1,1),ask=FALSE)
plot(smBv1)
lines(smBv0, lty=2)
#  Notice how the new target (solid line) has sharper features and
#  a stronger pubertal growth spurt relative to the old target
#  (dashed line).  Now register to the new target
smB.reg.2 &lt;- register.fd(smBv1, smBv[1:nBoys], WfdParobj)
#. plotreg.fd(smB.reg.2). #. removed
#  Plot the mean of these curves as well as the first and second targets
par(mfrow=c(1,1),ask=FALSE)
plot(mean.fd(smB.reg.2$regfd))
lines(smBv0, lty=2)
lines(smBv1, lty=3)
#  Notice that there is almost no improvement over the age of the
#  pubertal growth spurt, but some further detail added in the
#  pre-pubertal region.  Now register the previously registered
#  functions to the new target.
smB.reg.3 &lt;- register.fd(smBv1, smB.reg.1$regfd, WfdParobj)
#  plotreg.fd(smB.reg.3). function removed
#  Notice that the warping functions only deviate from the straight line
#  over the pre-pubertal region, and that there are some small adjustments
#  to the registered curves as well over the pre-pubertal region.
}

##
## 5.  register and plot the angular acceleration of the gait data
##
gaittime  &lt;- as.matrix(0:19)+0.5
gaitrange &lt;- c(0,20)
#  set up a fourier basis object
gaitbasis &lt;- create.fourier.basis(gaitrange, nbasis=21)
# set up a functional parameter object penalizing harmonic acceleration
harmaccelLfd &lt;- vec2Lfd(c(0, (2*pi/20)^2, 0), rangeval=gaitrange)
gaitfdPar    &lt;- fdPar(fd(matrix(0,gaitbasis$nbasis,1), gaitbasis), 
                      harmaccelLfd, 1e-2)
#  smooth the data
gaitfd &lt;- smooth.basis(gaittime, gait, gaitfdPar)$fd
#  compute the angular acceleration functional data object
D2gaitfd    &lt;- deriv.fd(gaitfd,2)
names(D2gaitfd$fdnames)[[3]] &lt;- "Angular acceleration"
D2gaitfd$fdnames[[3]] &lt;- c("Hip", "Knee")
#  compute the mean angular acceleration functional data object
D2gaitmeanfd  &lt;- mean.fd(D2gaitfd)
names(D2gaitmeanfd$fdnames)[[3]] &lt;- "Mean angular acceleration"
D2gaitmeanfd$fdnames[[3]] &lt;- c("Hip", "Knee")
#  register the functions for the first 2 boys
#  argument periodic = TRUE causes register.fd to estimate a horizontal shift
#  for each curve, which is a possibility when the data are periodic
#  set up the basis for the warping functions
nwbasis   &lt;- 4
wbasis    &lt;- create.bspline.basis(gaitrange,nwbasis,3)
Warpfd    &lt;- fd(matrix(0,nwbasis,nBoys),wbasis)
WarpfdPar &lt;- fdPar(Warpfd)
#  register the functions
gaitreglist &lt;- register.fd(D2gaitmeanfd, D2gaitfd[1:nBoys], WarpfdPar,
                           periodic=TRUE)
#  plot the results
#. plotreg.fd(gaitreglist). function removed
#  display horizonal shift values
print(round(gaitreglist$shift,1))
par(oldpar)
</code></pre>

<hr>
<h2 id='register.newfd'>
Register Functional Data Objects with Pre-Computed Warping Functions
</h2><span id='topic+register.newfd'></span>

<h3>Description</h3>

<p> This function registers a new functional data object to pre-computed
warping functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register.newfd(yfd, Wfd,type=c('direct','monotone','periodic'))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register.newfd_+3A_yfd">yfd</code></td>
<td>

<p>a multivariate functional data object defining the functions to be
registered with <code>Wfd</code>.
</p>
</td></tr>
<tr><td><code id="register.newfd_+3A_wfd">Wfd</code></td>
<td>

<p>a functional data object defining the registration functions to be used
to register <code>yfd</code>. This can be the result of either <code>landmarkreg</code>
or <code>register.fd</code>.
</p>
</td></tr>
<tr><td><code id="register.newfd_+3A_type">type</code></td>
<td>

<p>indicates the type of registration function.
</p>

<dl>
<dt>direct</dt><dd>
<p>assumes <code>Wfd</code> is a direct definition of the registration
functions. This is produced by <code>landmarkreg</code>.
</p>
</dd>
<dt>monotone</dt><dd>
<p>assumes that <code>Wfd</code> defines a monotone functional data
objected, up to shifting and scaling to make endpoints
agree. This is produced by <code>register.fd</code>.
</p>
</dd>
<dt>periodic</dt><dd>
<p>does shift registration for periodic functions. This is output
from <code>register.fd</code> if <code>periodic=TRUE</code>.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>Only shift registration is considered for the periodic case.
</p>


<h3>Value</h3>

<p>a functional data object defining the registered curves.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+register.fd">register.fd</a></code>
</p>

<hr>
<h2 id='scoresPACE'>Estimates of functional Principal Component scores through PACE</h2><span id='topic+scoresPACE'></span>

<h3>Description</h3>

<p>Function <code>scoresPACE</code> estimates the functional Principal Component 
scores through Conditional Expectation (PACE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  scoresPACE(data, time, covestimate, PC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoresPACE_+3A_data">data</code></td>
<td>

<p>a matrix object or list &ndash; If the set is supplied as a matrix object, 
the rows must correspond to argument values and columns to replications, 
and it will be assumed that there is only one variable per observation.  
If y is a three-dimensional array, the first dimension corresponds to  
argument values, the second to replications, and the third to variables 
within replications. &ndash; If it is a list, each element must be a matrix
object, the rows correspond to argument values per individual. First 
column corresponds to time points and following columns to argument values 
per variable.
</p>
</td></tr>
<tr><td><code id="scoresPACE_+3A_time">time</code></td>
<td>

<p>Array with time points where data was taken. <code>length(time) == dim(data)[1]</code>
</p>
</td></tr>
<tr><td><code id="scoresPACE_+3A_covestimate">covestimate</code></td>
<td>

<p>a list with the two named entries &quot;cov.estimate&quot; and &quot;meanfd&quot;
</p>
</td></tr>
<tr><td><code id="scoresPACE_+3A_pc">PC</code></td>
<td>

<p>an object of class &quot;pca.fd&quot;
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of scores with dimension nrow = nharm and ncol = ncol(data)
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p>Yao, F., Mueller, H.G., Wang, J.L. (2005), 
<em>Functional data analysis for sparse longitudinal data,</em> 
J. American Statistical Association, 100, 577-590.
</p>

<hr>
<h2 id='sd.fd'>
Standard Deviation of Functional Data
</h2><span id='topic+sd.fd'></span><span id='topic+std.fd'></span><span id='topic+stdev.fd'></span><span id='topic+stddev.fd'></span>

<h3>Description</h3>

<p>Evaluate the standard deviation of a set of functions in a functional
data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd.fd(fdobj)
std.fd(fdobj)
stdev.fd(fdobj)
stddev.fd(fdobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sd.fd_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multiple aliases are provided for compatibility with previous
versions and with other languages.  The name for the standard
deviation function in R is 'sd'.  Matlab uses 'std'.  S-Plus and
Microsoft Excal use 'stdev'.  'stddev' was used in a previous version
of the 'fda' package and is retained for compatibility.  
</p>


<h3>Value</h3>

<p>a functional data object with a single replication
that contains the standard deviation of the one or several functions in
the object <code>fdobj</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.fd">mean.fd</a></code>, 
<code><a href="#topic+sum.fd">sum.fd</a></code>, 
<code><a href="#topic+center.fd">center.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>liptime  &lt;- seq(0,1,.02)
liprange &lt;- c(0,1)

#  -------------  create the fd object -----------------
#       use 31 order 6 splines so we can look at acceleration

nbasis &lt;- 51
norder &lt;- 6
lipbasis &lt;- create.bspline.basis(liprange, nbasis, norder)
lipbasis &lt;- create.bspline.basis(liprange, nbasis, norder)

#  ------------  apply some light smoothing to this object  -------

Lfdobj   &lt;- int2Lfd(4)
lambda   &lt;- 1e-12
lipfdPar &lt;- fdPar(fd(matrix(0,nbasis,1), lipbasis), Lfdobj, lambda)

lipfd &lt;- smooth.basis(liptime, lip, lipfdPar)$fd
names(lipfd$fdnames) = c("Normalized time", "Replications", "mm")

lipstdfd &lt;- sd.fd(lipfd)
oldpar &lt;- par(no.readonly=TRUE)
plot(lipstdfd)
par(oldpar)
all.equal(lipstdfd, std.fd(lipfd))
all.equal(lipstdfd, stdev.fd(lipfd))
all.equal(lipstdfd, stddev.fd(lipfd))

</code></pre>

<hr>
<h2 id='seabird'>Sea Bird Counts</h2><span id='topic+seabird'></span>

<h3>Description</h3>

<p>Numbers of sightings of different species of seabirds by year 1986 -
2005 at E. Sitkalidak, Uganik, Uyak, and W. Sitkalidak by people
affiliated with the Kodiak National Wildlife Refuge, Alaska.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seabird)</code></pre>


<h3>Format</h3>

<p>A data frame with 3793 observations on the following 22 variables.
</p>

<dl>
<dt>BAGO, BLSC, COME, COMU, CORM, HADU, HOGR, LOON, MAMU, OLDS, PIGU, RBME, RNGR, SUSC, WWSC</dt><dd>
<p>integer count of the numbers of sightings of each species by
transect by year
</p>
</dd>
<dt>Year</dt><dd><p>integer year, 1986 - 2005</p>
</dd>
<dt>Site</dt><dd>
<p>Integer codes for <code>Bay</code>:  10 = Uyak, 20 = Uganik, 60 =
E. Sitkalidak, 70 = W. Sitkalidak
</p>
</dd>
<dt>Transect</dt><dd>
<p>Integer code (101 - 749) for the specific plot of ground observed
</p>
</dd>
<dt>Temp</dt><dd><p>a numeric vector</p>
</dd>
<dt>ObservCond</dt><dd>
<p>a factor with levels <code>Average</code>, <code>Excellent</code>,
<code>Fair</code>, <code>Good</code>, and <code>Ideal</code>.  
</p>
</dd>
<dt>Bay</dt><dd>
<p>a factor with levels <code>E. Sitkalidak</code> <code>Uganik</code>
<code>Uyak</code> <code>W. Sitkalidak</code>
</p>
</dd>
<dt>ObservCondFactor3</dt><dd>
<p>a factor with levels <code>ExcellentIdeal</code>, 
<code>FairAverage</code>, and <code>Good</code>.  These combine levels 
from <code>ObservCond</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data provided by the Kodiak National Wildlife Refuge
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>
<p>Zwiefelhofer, D., Reynolds, J. H., and Keim, M. (2008) Population
trends and annual density estimates for select wintering seabird
species on Kodiak Island, Alaska, <em>U.S. Fish and Wildlife
Service, Kodiak National Wildlife Refuge</em>, Technical Report,
no. 08-00x
</p>

<hr>
<h2 id='smooth.basis'>
Construct a functional data object by smoothing data using a roughness
penalty
</h2><span id='topic+smooth.basis'></span><span id='topic+smooth.basis1'></span><span id='topic+smooth.basis2'></span><span id='topic+smooth.basis3'></span>

<h3>Description</h3>

<p>Discrete observations on one or more curves and for one more more
variables are fit with a set of smooth curves, each defined by an
expansion in terms of user-selected basis functions.  The fitting
criterion is weighted least squares, and smoothness can be defined in
terms of a roughness penalty that is specified in a variety of ways.
</p>
<p>Data smoothing requires at a bare minimum three elements: (1) a set of
observed noisy values, (b) a set of argument values associated with these
data, and (c) a specification of the basis function system used to
define the curves.  Typical basis functions systems are splines for
nonperiodic curves, and fourier series for periodic curves.
</p>
<p>Optionally, a set covariates may be also used to take account of
various non-smooth contributions to the data.  Smoothing without
covariates is often called nonparametric regression, and with
covariates is termed semiparametric regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.basis(argvals=1:n, y, fdParobj, wtvec=NULL, fdnames=NULL,
             covariates=NULL, method="chol", dfscale=1, returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.basis_+3A_argvals">argvals</code></td>
<td>

<p>a set of argument values corresponding to the observations in array
<code>y</code>.  In most applications these values will be common to all curves
and all variables, and therefore be defined as a vector or as a matrix
with a single column.  But it is possible that these argument values
will vary from one curve to another, and in this case <code>argvals</code> will
be input as a matrix with rows corresponding to observation points and
columns corresponding to curves.  Argument values can even vary from one
variable to another, in which case they are input as an array with
dimensions corresponding to observation points, curves and variables,
respectively.  Note, however, that the number of observation points per
curve and per variable may NOT vary.  If it does, then curves and variables
must be smoothed individually rather than by a single call to this function.
The default value for <code>argvals</code> are the integers 1 to <code>n</code>, where
<code>n</code> is the size of the first dimension in argument <code>y</code>.
</p>
</td></tr>
<tr><td><code id="smooth.basis_+3A_y">y</code></td>
<td>

<p>an set of values of curves at discrete sampling points or
argument values. If the set is supplied as a matrix object, the rows must
correspond to argument values and columns to replications, and it will be
assumed that there is only one variable per observation.  If
<code>y</code> is a three-dimensional array, the first dimension
corresponds to argument values, the second to replications, and the
third to variables within replications.  If <code>y</code> is a vector,
only one replicate and variable are assumed.  If the data
come from a single replication but multiple vectors, such as data
on coordinates for a single space curve, then be sure to coerce
the data into an array object by using the <code>as.array</code> function
with one as the central dimension length.
</p>
</td></tr>
<tr><td><code id="smooth.basis_+3A_fdparobj">fdParobj</code></td>
<td>

<p>a functional parameter object, a functional data object or a
functional basis object.  In the simplest case, <code>fdParobj</code> may
be a functional basis object with class &quot;basisfd&quot; defined
previously by one of the &quot;create&quot; functions, and in this case, no
roughness penalty is used.  No roughness penalty is also the
consequence of supplying a functional data object with class &quot;fd&quot;,
in which case the basis system used for smoothing is that defining
this object.  In these two simple cases, <code>smooth.basis</code> is
essentially the same as function <code>Data2fd</code>, and this type of
elementary smoothing is often called &quot;regression smoothing.&quot;
However, if the object is a functional parameter object with class
&quot;fdPar&quot;, then the linear differential operator object and the
smoothing parameter in this object define the roughness penalty. For
further details on how the roughness penalty is defined, see the help
file for &quot;fdPar&quot;. In general, better results can be obtained using a
good roughness penalty than can be obtained by merely varying the
number of basis functions in the expansion.
</p>
</td></tr>
<tr><td><code id="smooth.basis_+3A_wtvec">wtvec</code></td>
<td>

<p>typically a vector of length <code>n</code> that is the length of <code>argvals</code>
containing weights for the values to be smoothed, However, it may also
be a symmetric matrix of order <code>n</code>.  If <code>wtvec</code> is a vector,
all values must be positive, and if it is a symmetric matrix, this must
be positive definite.  Defaults to all weights equal to 1.
</p>
</td></tr>
<tr><td><code id="smooth.basis_+3A_fdnames">fdnames</code></td>
<td>

<p>a list of length 3 containing character vectors of names for the
following:
</p>

<dl>
<dt>args</dt><dd>
<p>name for each observation or point in time at which data are
collected for each 'rep', unit or subject.
</p>
</dd>
<dt>reps</dt><dd>
<p>name for each 'rep', unit or subject.
</p>
</dd>
<dt>fun</dt><dd>
<p>name for each 'fun' or (response) variable measured repeatedly
(per 'args') for each 'rep'.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="smooth.basis_+3A_covariates">covariates</code></td>
<td>

<p>The observed values in <code>y</code> are assumed to be primarily
determined by the height of the curve being estimates, but from time
to time certain values can also be influenced by other known
variables.  For example, multi-year sets of climate variables may be
also determined by the presence of absence of an El Nino event, or a
volcanic eruption.  One or more of these covariates can be supplied
as an <code>n</code> by <code>p</code> matrix, where <code>p</code> is the number of
such covariates.  When such covariates are available, the smoothing
is called &quot;semi-parametric.&quot;  Matrices or arrays of regression
coefficients are then estimated that define the impacts of each of
these covariates for each curve and each variable.
</p>
</td></tr>
<tr><td><code id="smooth.basis_+3A_method">method</code></td>
<td>

<p>by default the function uses the usual textbook equations for computing
the coefficients of the basis function expansions.  But, as in regression
analysis, a price is paid in terms of rounding error for such
computations since they involved cross-products of  basis function
values.  Optionally, if <code>method</code> is set equal to the string &quot;qr&quot;,
the computation uses an algorithm based on the qr-decomposition which
is more accurate, but will require substantially more computing time
when <code>n</code> is large, meaning more than 500 or so.  The default
is &quot;chol&quot;, referring the Choleski decomposition of a symmetric positive
definite matrix.
</p>
</td></tr>
<tr><td><code id="smooth.basis_+3A_dfscale">dfscale</code></td>
<td>

<p>the generalized cross-validation or &quot;gcv&quot; criterion that is often used
to determine the size of the smoothing parameter involves the
subtraction of an measue of degrees of freedom from <code>n</code>.  Chong
Gu has argued that multiplying this degrees of freedom measure by
a constant slightly greater than 1, such as 1.2, can produce better
decisions about the level of smoothing to be used.  The default value
is, however, 1.0.
</p>
</td></tr>
<tr><td><code id="smooth.basis_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A roughness penalty is a quantitative measure of the roughness of a
curve that is designed to fit the data.  For this function, this penalty
consists of the product of two parts.  The first is an approximate integral
over the argument range of the square of a derivative of the curve.  A
typical choice of derivative order is 2, whose square is often called
the local curvature of the function.  Since a rough function has high
curvature over most of the function's range, the integrated square of
of the second derivative quantifies the total curvature of the function,
and hence its roughness.  The second factor is a positive constant called
the bandwidth of smoothing parameter, and given the variable name
<code>lambda</code> here.
</p>
<p>In more sophisticated uses of <code>smooth.basis</code>, a derivative may be
replaced by a linear combination of two or more order of derivative,
with the coefficients of this combination themselves possibly varying
over the argument range.  Such a structure is called a &quot;linear
differential operator&quot;, and a clever choice of operator can result
in much improved smoothing.
</p>
<p>The rougnhness penalty is added to the weighted error sum of squares
and the composite is minimized, usually in conjunction with a
high dimensional basis expansion such as a spline function defined by
placing a knot at every observation point.  Consequently, the
smoothing parameter controls the relative emphasis placed on fitting
the data versus smoothness; when large, the fitted curve is more smooth,
but the data fit worse, and when small, the fitted curve is more rough,
but the data fit much better. Typically smoothing parameter <code>lambda</code>
is manipulated on a logarithmic scale by, for example, defining it
as a power of 10.
</p>
<p>A good compromise <code>lambda</code> value can be difficult to
define, and minimizing the generalized cross-validation or &quot;gcv&quot;
criterion that is output by <code>smooth.basis</code> is a popular strategy
for making this choice, although by no means foolproof.  One may also
explore <code>lambda</code> values for a few log units up and down from this
minimizing value to see what the smoothing function and its derivatives
look like.  The function <code>plotfit.fd</code> was designed for this purpose.
</p>
<p>The size of common logarithm of the minimizing value of <code>lambda</code>
can vary widely, and spline functions depends critically on the typical
spacing between knots.  While there is typically a &quot;natural&quot; measurement
scale for the argument, such as time in milliseconds, seconds, and so
forth, it is better from a computational perspective to choose an
argument scaling that gives knot spacings not too different from one.
</p>
<p>An alternative to using <code>smooth.basis</code> is to first represent
the data in a basis system with reasonably high resolution using
<code>Data2fd</code>, and then smooth the resulting functional data object
using function <code>smooth.fd</code>.
</p>
<p>In warning and error messages, you may see reference to functions
<code>smooth.basis1, smooth.basis2</code>, and <code>smooth.basis3</code>. These
functions are defined within <code>smooth.basis</code>, and are not
normally to be called by users.
</p>
<p>The &quot;qr&quot; algorithm option defined by the &quot;method&quot; parameter will
not normally be needed, but if a warning of a near singularity in
the coefficient calculations appears, this choice may be a cure.
</p>


<h3>Value</h3>

<p>an object of class <code>fdSmooth</code>, which is a named list of length 8
with the following components:
</p>
<table role = "presentation">
<tr><td><code>fd</code></td>
<td>
<p>a functional data object containing a smooth of the data.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>a degrees of freedom measure of the smooth</p>
</td></tr>
<tr><td><code>gcv</code></td>
<td>
<p>the value of the generalized cross-validation or GCV criterion.  
Ifthere are multiple curves, this is a vector of values, one per
curve.  If the smooth is multivariate, the result is a matrix of gcv
values, with columns corresponding to variables.
</p>
<p style="text-align: center;"><code class="reqn">gcv &lt;- n*SSE/((n-df)^2)</code>
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>the regression coefficients associated with covariate variables.
These are vector, matrix or array objects depending on whether
there is a single curve, multiple curves or multiple curves and
variables, respectively.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>the error sums of squares.  SSE is a vector or a matrix of the 
same size as GCV.</p>
</td></tr>
<tr><td><code>penmat</code></td>
<td>
<p>the penalty matrix.</p>
</td></tr>
<tr><td><code>y2cMap</code></td>
<td>
<p>the matrix mapping the data to the coefficients.</p>
</td></tr>
<tr><td><code>argvals</code>, <code>y</code></td>
<td>
<p>input arguments</p>
</td></tr></table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambda2df">lambda2df</a></code>,
<code><a href="#topic+lambda2gcv">lambda2gcv</a></code>,
<code><a href="#topic+df2lambda">df2lambda</a></code>,
<code><a href="#topic+plot.fd">plot.fd</a></code>,
<code><a href="#topic+project.basis">project.basis</a></code>,
<code><a href="#topic+smooth.fd">smooth.fd</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+smooth.pos">smooth.pos</a></code>,
<code><a href="#topic+smooth.basisPar">smooth.basisPar</a></code>
<code><a href="#topic+Data2fd">Data2fd</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
######## Simulated data example 1: a simple regression smooth  ########
##
#  Warning:  In this and all simulated data examples, your results
#  probably won't be the same as we saw when we ran the example because
#  random numbers depend on the seed value in effect at the time of the
#  analysis.
#
#  Set up 51 observation points equally spaced between 0 and 1
n &lt;- 51
argvals &lt;- seq(0,1,len=n)
#  The true curve values are sine function values with period 1/2
x &lt;- sin(4*pi*argvals)
#  Add independent Gaussian errors with std. dev. 0.2 to the true values
sigerr &lt;- 0.2
y &lt;- x + rnorm(x)*sigerr
#  When we ran this code, we got these values of y (rounded to two
#  decimals):
y &lt;- c(0.27,  0.05,  0.58,  0.91,  1.07,  0.98,  0.54,  0.94,  1.13,  0.64,
      0.64,  0.60,  0.24,  0.15, -0.20, -0.63, -0.40, -1.22, -1.11, -0.76,
     -1.11, -0.69, -0.54, -0.50, -0.35, -0.15,  0.27,  0.35,  0.65,  0.75,
      0.75,  0.91,  1.04,  1.04,  1.04,  0.46,  0.30, -0.01, -0.19, -0.42,
     -0.63, -0.78, -1.01, -1.08, -0.91, -0.92, -0.72, -0.84, -0.38, -0.23,
      0.02)
#  Set up a B-spline basis system of order 4 (piecewise cubic) and with
#  knots at 0, 0.1, ..., 0.9 and 1.0, and plot the basis functions
nbasis &lt;- 13
basisobj &lt;- create.bspline.basis(c(0,1),nbasis)
plot(basisobj)
#  Smooth the data, outputting only the functional data object for the
#  fitted curve.  Note that in this simple case we can supply the basis
#  object as the "fdParobj" parameter
ys &lt;- smooth.basis(argvals=argvals, y=y, basisobj)
Ys &lt;- smooth.basis(argvals=argvals, y=y, basisobj,
                  returnMatrix=TRUE)
# Ys[[7]] &lt;- Ys$y2cMap is sparse;  everything else is the same


all.equal(ys[-7], Ys[-7])


xfd &lt;- ys$fd
Xfd &lt;- Ys$fd

#  Plot the curve along with the data
plotfit.fd(y, argvals, xfd)
#  Compute the root-mean-squared-error (RMSE) of the fit relative to the
#  truth
RMSE &lt;- sqrt(mean((eval.fd(argvals, xfd) - x)^2))
print(RMSE)  #  We obtained 0.069
#  RMSE &lt;- 0.069 seems good relative to the standard error of 0.2.
#  Range through numbers of basis functions from 4 to 12 to see if we
#  can do better.  We want the best RMSE, but we also want the smallest
#  number of basis functions, which in this case is the degrees of
#  freedom for error (df).  Small df implies a stable estimate.
#  Note: 4 basis functions is as small as we can use without changing the
#  order of the spline.  Also display the gcv statistic to see what it
#  likes.
for (nbasis in 4:12) {
  basisobj &lt;- create.bspline.basis(c(0,1),nbasis)
  ys &lt;- smooth.basis(argvals, y, basisobj)
  xfd &lt;- ys$fd
  gcv &lt;- ys$gcv
  RMSE &lt;- sqrt(mean((eval.fd(argvals, xfd) - x)^2))
# progress report:
#  cat(paste(nbasis,round(RMSE,3),round(gcv,3),"\n"))
}
#  We got RMSE &lt;- 0.062 for 10 basis functions as optimal, but gcv liked
#  almost the same thing, namely 9 basis functions.  Both RMSE and gcv
#  agreed emphatically that 7 or fewer basis functions was not enough.
#  Unlike RMSE, however, gcv does not depend on knowing the truth.
#  Plot the result for 10 basis functions along with "*" at the true
#  values
nbasis &lt;- 10
basisobj &lt;- create.bspline.basis(c(0,1),10)
xfd &lt;- smooth.basis(argvals, y, basisobj)$fd
plotfit.fd(y, argvals, xfd)
points(argvals,x, pch="*")
#  Homework:
#  Repeat all this with various values of sigerr and various values of n

##
####### Simulated data example 2: a roughness-penalized smooth  ########
##

#  A roughness penalty approach is more flexible, allowing continuous
#  control over smoothness and degrees of freedom, can be adapted to
#  known features in the curve, and will generally provide better RMSE
#  for given degrees of freedom.

#  It does require a bit more effort, though.
#  First, we define a little display function for showing how
#  df, gcv and RMSE depend on the log10 smoothing parameter
plotGCVRMSE.fd &lt;- function(lamlow, lamhi, lamdel, x, argvals, y,
            fdParobj, wtvec=NULL, fdnames=NULL, covariates=NULL)  {
  loglamvec &lt;- seq(lamlow, lamhi, lamdel)
  loglamout &lt;- matrix(0,length(loglamvec),4)
  m &lt;- 0
  for (loglambda in loglamvec) {
    m &lt;- m + 1
    loglamout[m,1] &lt;- loglambda
    fdParobj$lambda &lt;- 10^(loglambda)
    smoothlist &lt;- smooth.basis(argvals, y, fdParobj, wtvec=wtvec,
             fdnames=fdnames, covariates=covariates)
    xfd &lt;- smoothlist$fd   #  the curve smoothing the data
    loglamout[m,2] &lt;- smoothlist$df
    #  degrees of freedom in the smoothing curve
    loglamout[m,3] &lt;- sqrt(mean((eval.fd(argvals, xfd) - x)^2))
    loglamout[m,4] &lt;- mean(smoothlist$gcv)  #  the mean of the N gcv values
  }
  cat("log10 lambda, deg. freedom, RMSE, gcv\n")
  for (i in 1:m) {
    cat(format(round(loglamout[i,],3)))
    cat("\n")
  }
  par(mfrow=c(3,1))
  plot(loglamvec, loglamout[,2], type="b")
  title("Degrees of freedom")
  plot(loglamvec, loglamout[,3], type="b")
  title("RMSE")
  plot(loglamvec, loglamout[,4], type="b")
  title("Mean gcv")
  return(loglamout)
}

#  Use the data that you used in Example 1, or run the following code:
n &lt;- 51
argvals &lt;- seq(0,1,len=n)
x &lt;- sin(4*pi*argvals)
sigerr &lt;- 0.2
err &lt;- matrix(rnorm(x),n,1)*sigerr
y &lt;- x + err
#  We now set up a basis system with a knot at every data point.
#  The number of basis functions will equal the number of interior knots
#  plus the order, which in this case is still 4.
#  49 interior knots + order 4 &lt;- 53 basis functions
nbasis   &lt;- n + 2
basisobj &lt;- create.bspline.basis(c(0,1),nbasis)
fdobj    &lt;- fd(matrix(0,nbasis,1),basisobj)
#  Note that there are more basis functions than observed values.  A
#  basis like this is called "super-saturated."  We have to use a
#  positive smoothing parameter for it to work.  Set up an object of
#  class "fdPar" that penalizes the total squared second derivative,
#  using a smoothing parameter that is set here to 10^(-4.5).
lambda &lt;- 10^(-4.5)
fdParobj &lt;- fdPar(fdobj, Lfdobj=2, lambda=lambda)
#  Smooth the data, outputting a list containing various quantities
smoothlist &lt;- smooth.basis(argvals, y, fdParobj)
xfd &lt;- smoothlist$fd   #  the curve smoothing the data
df  &lt;- smoothlist$df   #  the degrees of freedom in the smoothing curve
gcv &lt;- smoothlist$gcv  #  the value of the gcv statistic
RMSE &lt;- sqrt(mean((eval.fd(argvals, xfd) - x)^2))
cat(round(c(df,RMSE,gcv),3),"\n")
plotfit.fd(y, argvals, xfd)
points(argvals,x, pch="*")
#  Repeat these analyses for a range of log10(lambda) values by running
#  the function plotGCVRMSE that we defined above.

loglamout &lt;- plotGCVRMSE.fd(-6, -3, 0.25, x, argvals, y, fdParobj)

#  When we ran this example, the optimal RMSE was 0.073, and was achieved
#  for log10(lambda) &lt;- -4.25 or lambda &lt;- 0.000056.  At this level of
#  smoothing, the degrees of freedom index was 10.6, a value close to
#  the 10 degrees of freedom that we saw for regression smoothing.  The
#  RMSE value is slightly higher than the regression analysis result, as
#  is the degrees of freedom associated with the optimal value.
#  Roughness penalty will, as we will see later, do better than
#  regression smoothing; but with slightly red faces we say, "That's
#  life with random data!"  The gcv statistic agreed with RMSE on the
#  optimal smoothing level, which is great because it does not need to
#  know the true values.  Note that gcv is emphatic about when there is
#  too much smoothing, but rather vague about when we have
#  under-smoothed the data.
#  Homework:
#  Compute average results taken across 100 sets of random data for each
#  level of smoothing parameter lambda, and for each number of basis
#  functions for regression smoothing.

##
##                       Simulated data example 3:
##           a roughness-penalized smooth of a sample of curves
##
n &lt;-  51   #  number of observations per curve
N &lt;- 100   #  number of curves
argvals &lt;- seq(0,1,len=n)
#  The true curve values are linear combinations of fourier function
#  values.
#  Set up the fourier basis
nfourierbasis &lt;- 13
fourierbasis &lt;- create.fourier.basis(c(0,1),nfourierbasis)
fourierbasismat &lt;- eval.basis(argvals,fourierbasis)
#  Set up some random coefficients, with declining contributions from
#  higher order basis functions
basiswt &lt;- matrix(exp(-(1:nfourierbasis)/3),nfourierbasis,N)
xcoef &lt;- matrix(rnorm(nfourierbasis*N),nfourierbasis,N)*basiswt
xfd &lt;- fd(xcoef, fourierbasis)
x   &lt;- eval.fd(argvals, xfd)
#  Add independent Gaussian noise to the data with std. dev. 0.2
sigerr &lt;- 0.2
y &lt;- x + matrix(rnorm(c(x)),n,N)*sigerr
#  Set up spline basis system
nbasis   &lt;- n + 2
basisobj &lt;- create.bspline.basis(c(0,1),nbasis)
fdobj    &lt;- fd(matrix(0,nbasis,1),basisobj)
#  Set up roughness penalty with smoothing parameter 10^(-5)
lambda &lt;- 10^(-5)
fdParobj &lt;- fdPar(fdobj, Lfdobj=2, lambda=lambda)
#  Smooth the data, outputting a list containing various quantities
smoothlist &lt;- smooth.basis(argvals, y, fdParobj)
xfd &lt;- smoothlist$fd   #  the curve smoothing the data
df  &lt;- smoothlist$df   #  the degrees of freedom in the smoothing curve
gcv &lt;- smoothlist$gcv  #  the value of the gcv statistic
RMSE &lt;- sqrt(mean((eval.fd(argvals, xfd) - x)^2))
#  Display the results, note that a gcv value is returned for EACH curve,
#  and therefore that a mean gcv result is reported
cat(round(c(df,RMSE,mean(gcv)),3),"\n")
#  the fits are plotted interactively by plotfit.fd ... click to advance
#  plot
plotfit.fd(y, argvals, xfd)
#  Repeat these results for a range of log10(lambda) values
loglamout &lt;- plotGCVRMSE.fd(-6, -3, 0.25, x, argvals, y, fdParobj)
#  Our results were:
# log10 lambda, deg. freedom, RMSE, GCV
# -6.000 30.385  0.140  0.071
# -5.750 26.750  0.131  0.066
# -5.500 23.451  0.123  0.062
# -5.250 20.519  0.116  0.059
# -5.000 17.943  0.109  0.056
# -4.750 15.694  0.104  0.054
# -4.500 13.738  0.101  0.053
# -4.250 12.038  0.102  0.054
# -4.000 10.564  0.108  0.055
# -3.750  9.286  0.120  0.059
# -3.500  8.177  0.139  0.065
# -3.250  7.217  0.164  0.075
# -3.000  6.385  0.196  0.088
#  RMSE and gcv both indicate an optimal smoothing level of
#  log10(lambda) &lt;- -4.5 corresponding to 13.7 df.  When we repeated the
#  analysis using regression smoothing with 14 basis functions, we
#  obtained RMSE &lt;- 0.110, about 10 percent larger than the value of
#  0.101 in the roughness penalty result.  Smooth the data, outputting a
#  list containing various quantities
#  Homework:
#  Sine functions have a curvature that doesn't vary a great deal over
#  the range the curve.  Devise some test functions with sharp local
#  curvature, such as Gaussian densities with standard deviations that
#  are small relative to the range of the observations.  Compare
#  regression and roughness penalty smoothing in these situations.

if(!CRAN()){
##
####### Simulated data example 4: a roughness-penalized smooth  ########
##                           with correlated error
##
#  These three examples make GCV look pretty good as a basis for
#  selecting the smoothing parameter lambda.  BUT GCV is based an
#  assumption of independent errors, and in reality, functional data
#  often have autocorrelated errors, with an autocorrelation that is
#  usually positive among neighboring observations.  Positively
#  correlated random values tend to exhibit slowly varying values that
#  have long runs on one side or the other of their baseline, and
#  therefore can look like trend in the data that needs to be reflected
#  in the smooth curve.  This code sets up the error correlation matrix
#  for first-order autoregressive errors, or AR(1).
rho &lt;- 0.9
n &lt;- 51
argvals &lt;- seq(0,1,len=n)
x &lt;- sin(4*pi*argvals)
Rerr &lt;- matrix(0,n,n)
for (i in 1:n) {
  for (j in 1:n) Rerr[i,j] &lt;-  rho^abs(i-j)
}
#  Compute the Choleski factor of the correlation matrix
Lerr &lt;- chol(Rerr)
#  set up some data
#  Generate auto-correlated errors by multipling independent errors by
#  the transpose of the Choleski factor
sigerr &lt;- 0.2
err &lt;- as.vector(crossprod(Lerr,matrix(rnorm(x),n,1))*sigerr)
#  See the long-run errors that are genrated
plot(argvals, err)
y &lt;- x + err
#  Our values of y were:
y &lt;- c(-0.03, 0.36, 0.59, 0.71, 0.97,  1.2,  1.1, 0.96, 0.79, 0.68,
       0.56, 0.25, 0.01,-0.43,-0.69, -1,  -1.09,-1.29,-1.16,-1.09,
      -0.93, -0.9,-0.78,-0.47, -0.3,-0.01, 0.29, 0.47, 0.77, 0.85,
       0.87, 0.97,  0.9, 0.72, 0.48, 0.25,-0.17,-0.39,-0.47,-0.71,
      -1.07,-1.28,-1.33,-1.39,-1.45, -1.3,-1.25,-1.04,-0.82,-0.55, -0.2)
#  Retaining the above data, now set up a basis system with a knot at
#  every data point:  the number of basis functions will equal the
#  number of interior knots plus the order, which in this case is still
#  4.
#   19 interior knots + order 4 &lt;- 23 basis functions
nbasis   &lt;- n + 2
basisobj &lt;- create.bspline.basis(c(0,1),nbasis)
fdobj    &lt;- fd(matrix(0,nbasis,1), basisobj)
fdParobj &lt;- fdPar(fdobj)
#  Smooth these results for a range of log10(lambda) values
loglamout &lt;- plotGCVRMSE.fd(-6, -3, 0.25, x, argvals, y, fdParobj)
#  Our results without weighting were:
# -6.000 30.385  0.261  0.004
# -5.750 26.750  0.260  0.005
# -5.500 23.451  0.259  0.005
# -5.250 20.519  0.258  0.005
# -5.000 17.943  0.256  0.005
# -4.750 15.694  0.255  0.006
# -4.500 13.738  0.252  0.006
# -4.250 12.038  0.249  0.007
# -4.000 10.564  0.246  0.010
# -3.750  9.286  0.244  0.015
# -3.500  8.177  0.248  0.028
# -3.250  7.217  0.267  0.055
# -3.000  6.385  0.310  0.102
#  Now GCV still is firm on the fact that log10(lambda) over -4 is
#  over-smoothing, but is quite unhelpful about what constitutes
#  undersmoothing.  In real data applications you will have to make the
#  final call.  Now set up a weight matrix equal to the inverse of the
#  correlation matrix
wtmat &lt;- solve(Rerr)
#  Smooth these results for a range of log10(lambda) values using the
#  weight matrix
loglamout &lt;- plotGCVRMSE.fd(-6, -3, 0.25, x, argvals, y, fdParobj,
                         wtvec=wtmat)
#  Our results with weighting were:
# -6.000 46.347  0.263  0.005
# -5.750 43.656  0.262  0.005
# -5.500 40.042  0.261  0.005
# -5.250 35.667  0.259  0.005
# -5.000 30.892  0.256  0.005
# -4.750 26.126  0.251  0.006
# -4.500 21.691  0.245  0.008
# -4.250 17.776  0.237  0.012
# -4.000 14.449  0.229  0.023
# -3.750 11.703  0.231  0.045
# -3.500  9.488  0.257  0.088
# -3.250  7.731  0.316  0.161
# -3.000  6.356  0.397  0.260
#  GCV is still not clear about what the right smoothing level is.
#  But, comparing the two results, we see an optimal RMSE without
#  smoothing of 0.244 at log10(lambda) &lt;- -3.75, and with smoothing 0.229
#  at log10(lambda) &lt;- -4.  Weighting improved the RMSE.  At
#  log10(lambda) &lt;- -4 the improvement is 9 percent.
#  Smooth the data with and without the weight matrix at log10(lambda) =
#  -4
fdParobj &lt;- fdPar(fdobj, 2, 10^(-4))
smoothlistnowt &lt;- smooth.basis(argvals, y, fdParobj)
fdobjnowt &lt;- smoothlistnowt$fd   #  the curve smoothing the data
df  &lt;- smoothlistnowt$df  # the degrees of freedom in the smoothing curve
GCV &lt;- smoothlistnowt$gcv  #  the value of the GCV statistic
RMSE &lt;- sqrt(mean((eval.fd(argvals, fdobjnowt) - x)^2))
cat(round(c(df,RMSE,GCV),3),"\n")
smoothlistwt &lt;- smooth.basis(argvals, y, fdParobj, wtvec=wtmat)
fdobjwt &lt;- smoothlistwt$fd   #  the curve smoothing the data
df  &lt;- smoothlistwt$df   #  the degrees of freedom in the smoothing curve
GCV &lt;- smoothlistwt$gcv  #  the value of the GCV statistic
RMSE &lt;- sqrt(mean((eval.fd(argvals, fdobjwt) - x)^2))
cat(round(c(df,RMSE,GCV),3),"\n")
par(mfrow=c(2,1))
plotfit.fd(y, argvals, fdobjnowt)
plotfit.fd(y, argvals, fdobjwt)
par(mfrow=c(1,1))
plot(fdobjnowt)
lines(fdobjwt,lty=2)
points(argvals, y)
#  Homework:
#  Repeat these analyses with various values of rho, perhaps using
#  multiple curves to get more stable indications of relative
#  performance.  Be sure to include some negative rho's.

##
######## Simulated data example 5: derivative estimation  ########
##
#  Functional data analyses often involve estimating derivatives.  Here
#  we repeat the analyses of Example 2, but this time focussing our
#  attention on the estimation of the first and second derivative.
n &lt;- 51
argvals &lt;- seq(0,1,len=n)
x   &lt;- sin(4*pi*argvals)
Dx  &lt;- 4*pi*cos(4*pi*argvals)
D2x &lt;- -(4*pi)^2*sin(4*pi*argvals)
sigerr &lt;- 0.2
y &lt;- x + rnorm(x)*sigerr
#  We now use order 6 splines so that we can control the curvature of
#  the second derivative, which therefore involves penalizing the
#  derivative of order four.
norder   &lt;- 6
nbasis   &lt;- n + norder - 2
basisobj &lt;- create.bspline.basis(c(0,1),nbasis,norder)
fdobj    &lt;- fd(matrix(0,nbasis,1),basisobj)
#  Note that there are more basis functions than observed values.  A
#  basis like this is called "super-saturated."  We have to use a
#  positive smoothing parameter for it to work.  Set up an object of
#  class "fdPar" that penalizes the total squared fourth derivative. The
#  smoothing parameter that is set here to 10^(-10), because the squared
#  fourth derivative is a much larger number than the squared second
#  derivative.
lambda &lt;- 10^(-10)
fdParobj &lt;- fdPar(fdobj, Lfdobj=4, lambda=lambda)
#  Smooth the data, outputting a list containing various quantities
smoothlist &lt;- smooth.basis(argvals, y, fdParobj)
xfd &lt;- smoothlist$fd   #  the curve smoothing the data
df  &lt;- smoothlist$df   #  the degrees of freedom in the smoothing curve
gcv &lt;- smoothlist$gcv  #  the value of the gcv statistic
Dxhat  &lt;- eval.fd(argvals, xfd, Lfd=1)
D2xhat &lt;- eval.fd(argvals, xfd, Lfd=2)
RMSED  &lt;- sqrt(mean((Dxhat  - Dx )^2))
RMSED2 &lt;- sqrt(mean((D2xhat - D2x)^2))
cat(round(c(df,RMSED,RMSED2,gcv),3),"\n")
#  Four plots of the results row-wise: data fit, first derivative fit,
#  second derivative fit, second vs. first derivative fit
#  (phase-plane plot)
par(mfrow=c(2,2))
plotfit.fd(y, argvals, xfd)
plot(argvals, Dxhat, type="p", pch="o")
points(argvals, Dx, pch="*")
title("first derivative approximation")
plot(argvals, D2xhat, type="p", pch="o")
points(argvals, D2x, pch="*")
title("second derivative approximation")
plot(Dxhat, D2xhat, type="p", pch="o")
points(Dx, D2x, pch="*")
title("second against first derivative")
#  This illustrates an inevitable problem with spline basis functions;
#  because they are not periodic, they fail to capture derivative
#  information well at the ends of the interval.  The true phase-plane
#  plot is an ellipse, but the phase-plane plot of the estimated
#  derivatives here is only a rough approximtion, and breaks down at the
#  left boundary.
#  Homework:
#  Repeat these results with smaller standard errors.
#  Repeat these results, but this time use a fourier basis with no
#  roughness penalty, and find the number of basis functions that gives
#  the best result.  The right answer to this question is, of course, 3,
#  if we retain the constant term, even though it is here not needed.
#  Compare the smoothing parameter preferred by RMSE for a derivative to
#  that preferred by the RMSE for the function itself, and to that
#  preferred by gcv.

##                  Simulated data example 6:
##           a better roughness penalty for derivative estimation
##
#  We want to see if we can improve the spline fit.
#  We know from elementary calculus as well as the code above that
#  (4*pi)^2 sine(2*p*x) &lt;- -D2 sine(2*p*x), so that
#  Lx &lt;- D2x + (4*pi)^2 x is zero for a sine or a cosine curve.
#  We now penalize roughness using this "smart" roughness penalty
#  Here we set up a linear differential operator object that defines
#  this penalty
constbasis &lt;- create.constant.basis(c(0,1))
xcoef.fd  &lt;- fd((4*pi)^2, constbasis)
Dxcoef.fd &lt;- fd(0, constbasis)
bwtlist &lt;- vector("list", 2)
bwtlist[[1]] &lt;- xcoef.fd
bwtlist[[2]] &lt;- Dxcoef.fd
Lfdobj &lt;- Lfd(nderiv=2, bwtlist=bwtlist)
#  Now we use a much larger value of lambda to reflect our confidence
#  in power of calculus to solve problems!
lambda &lt;- 10^(0)
fdParobj &lt;- fdPar(fdobj, Lfdobj=Lfdobj, lambda=lambda)
smoothlist &lt;- smooth.basis(argvals, y, fdParobj)
xfd &lt;- smoothlist$fd   #  the curve smoothing the data
df  &lt;- smoothlist$df   #  the degrees of freedom in the smoothing curve
gcv &lt;- smoothlist$gcv  #  the value of the gcv statistic
Dxhat  &lt;- eval.fd(argvals, xfd, Lfd=1)
D2xhat &lt;- eval.fd(argvals, xfd, Lfd=2)
RMSED  &lt;- sqrt(mean((Dxhat  - Dx )^2))
RMSED2 &lt;- sqrt(mean((D2xhat - D2x)^2))
cat(round(c(df,RMSED,RMSED2,gcv),3),"\n")
#  Four plots of the results row-wise: data fit, first derivative fit,
#  second derivative fit, second versus first derivative fit
#  (phase-plane plot)
par(mfrow=c(2,2))
plotfit.fd(y, argvals, xfd)
plot(argvals, Dxhat, type="p", pch="o")
points(argvals, Dx, pch="*")
title("first derivative approximation")
plot(argvals, D2xhat, type="p", pch="o")
points(argvals, D2x, pch="*")
title("second derivative approximation")
plot(Dxhat, D2xhat, type="p", pch="o")
points(Dx, D2x, pch="*")
title("second against first derivative")
#  The results are nearly perfect in spite of the fact that we are not using
#  periodic basis functions.  Notice, too, that we have used 2.03
#  degrees of freedom, which is close to what we would use for the ideal
#  fourier series basis with the constant term dropped.
#  Homework:
#  These results depended on us knowing the right period, of course.
#  The data would certainly allow us to estimate the period 1/2 closely,
#  but try various  other periods by replacing 1/2 by other values.
#  Alternatively, change x by adding a small amount of, say, linear trend.
#  How much trend do you have to add to seriously handicap the results?

##
######## Simulated data example 7: Using covariates  ########
##
#  Now we simulate data that are defined by a sine curve, but where the
#  the first 20 observed values are shifted upwards by 0.5, and the
#  second shifted downwards by -0.2.  The two covariates are indicator
#  or dummy variables, and the estimated regression coefficients will
#  indicate the shifts as estimated from the data.
n &lt;- 51
argvals &lt;- seq(0,1,len=n)
x &lt;- sin(4*pi*argvals)
sigerr &lt;- 0.2
y &lt;- x + rnorm(x)*sigerr
#  the n by p matrix of covariate values, p being here 2
p &lt;- 2
zmat &lt;- matrix(0,n,p)
zmat[ 1:11,1] &lt;- 1
zmat[11:20,2] &lt;- 1
#  The true values of the regression coefficients
beta0 &lt;- matrix(c(0.5,-0.2),p,1)
y &lt;- y + zmat 
#  The same basis system and smoothing process as used in Example 2
nbasis &lt;- n + 2
basisobj &lt;- create.bspline.basis(c(0,1),nbasis)
fdobj    &lt;- fd(matrix(0,nbasis,1), basisobj)
fdParobj &lt;- fdPar(fdobj, 2, lambda)
#  Smooth the data, outputting a list containing various quantities
smoothlist &lt;- smooth.basis(argvals, y, fdParobj, covariates=zmat)
xfd  &lt;- smoothlist$fd   #  the curve smoothing the data
df   &lt;- smoothlist$df   #  the degrees of freedom in the smoothing curve
gcv  &lt;- smoothlist$gcv  #  the value of the gcv statistic
beta &lt;- smoothlist$beta  #  the regression coefficients
RMSE &lt;- sqrt(mean((eval.fd(argvals, xfd) - x)^2))
cat(round(c(beta,df,RMSE,gcv),3),"\n")
par(mfrow=c(1,1))
plotfit.fd(y, argvals, xfd)
points(argvals,x, pch="*")
print(beta)
#  The recovery of the smooth curve is fine, as in Example 2.  The
#  shift of the first 10 observations was estimated to be 0.62 in our run,
#  and the shift of the second 20 was estimated to be -0.42.  These
#  estimates are based on only 10 observations, and these estimates are
#  therefore quite reasonable.
#  Repeat these analyses for a range of log10(lambda) values
loglamout &lt;- plotGCVRMSE.fd(-6, -3, 0.25, x, argvals, y, fdParobj,
                           covariates=zmat)
#  Homework:
#  Try an example where the covariate values are themselves are
#  generated by a smooth known curve.

##
##                     Simulated data example 8:
##          a roughness-penalized smooth of a sample of curves and
##                    variable observation points
##
n &lt;- 51   #  number of observations per curve
N &lt;- 100   #  number of curves
argvals &lt;- matrix(0,n,N)
for (i in 1:N) argvals[,i] &lt;- sort(runif(1:n))
#  The true curve values are linear combinations of fourier function
#  values.
#  Set up the fourier basis
nfourierbasis &lt;- 13
fourierbasis &lt;- create.fourier.basis(c(0,1),nfourierbasis)
#  Set up some random coefficients, with declining contributions from
#  higher order basis functions
basiswt &lt;- matrix(exp(-(1:nfourierbasis)/3),nfourierbasis,N)
xcoef &lt;- matrix(rnorm(nfourierbasis*N),nfourierbasis,N)*basiswt
xfd &lt;- fd(xcoef, fourierbasis)
x &lt;- matrix(0,n,N)
for (i in 1:N) x[,i] &lt;- eval.fd(argvals[,i], xfd[i])
#  Add independent Gaussian noise to the data with std. dev. 0.2
sigerr &lt;- 0.2
y &lt;- x + matrix(rnorm(c(x)),n,N)*sigerr
#  Set up spline basis system
nbasis   &lt;- n + 2
basisobj &lt;- create.bspline.basis(c(0,1),nbasis)
fdobj    &lt;- fd(matrix(0,nbasis,1), basisobj)
#  Set up roughness penalty with smoothing parameter 10^(-5)
lambda &lt;- 10^(-5)
fdParobj &lt;- fdPar(fdobj, Lfdobj=2, lambda=lambda)
#  Smooth the data, outputting a list containing various quantities
smoothlist &lt;- smooth.basis(argvals, y, fdParobj)
xfd &lt;- smoothlist$fd   #  the curve smoothing the data
df  &lt;- smoothlist$df   #  the degrees of freedom in the smoothing curve
gcv &lt;- smoothlist$gcv  #  the value of the gcv statistic
#RMSE &lt;- sqrt(mean((eval.fd(argvals, xfd) - x)^2))
eval.x &lt;- eval.fd(argvals, xfd)
e.xfd &lt;- (eval.x-x)
mean.e2 &lt;- mean(e.xfd^2)

RMSE &lt;- sqrt(mean.e2)
#  Display the results, note that a gcv value is returned for EACH
#  curve, and therefore that a mean gcv result is reported
cat(round(c(df,RMSE,mean(gcv)),3),"\n")
#  Function plotfit.fd is not equipped to handle a matrix of argvals,
#  but can always be called within a loop to plot each curve in turn.
#  Although a call to function plotGCVRMSE.fd works, the computational
#  overhead is substantial, and we omit this here.

##
## Real data example 9.  gait
##
#  These data involve two variables in addition to multiple curves
gaitnbasis   &lt;- 21
gaittime     &lt;- (1:20)/21
gaitrange    &lt;- c(0,1)
gaitbasis    &lt;- create.fourier.basis(gaitrange, gaitnbasis)
gaitfd       &lt;- fd(matrix(0,gaitnbasis,1), gaitbasis)
lambda       &lt;- 10^(-11.5)
harmaccelLfd &lt;- vec2Lfd(c(0, 0, (2*pi)^2, 0))
gaitfdPar    &lt;- fdPar(gaitfd, harmaccelLfd, lambda)
gaitSmooth &lt;- smooth.basis(gaittime, gait, gaitfdPar)
gaitfd &lt;- gaitSmooth$fd
if (!CRAN()){
  # by default creates multiple plots, asking for a click between plots
 plotfit.fd(gait, gaittime, gaitfd)
}



}
#  end of if (!CRAN)
par(oldpar)
</code></pre>

<hr>
<h2 id='smooth.basis.sparse'>
Construct a functional data object by smoothing data using a roughness
penalty
</h2><span id='topic+smooth.basis.sparse'></span>

<h3>Description</h3>

<p>Makes it possible to perform smoothing with <code>smooth.basis</code> when the 
data has NAs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  smooth.basis.sparse(argvals, y, fdParobj, fdnames=NULL, covariates=NULL, 
                      method="chol", dfscale=1 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.basis.sparse_+3A_argvals">argvals</code></td>
<td>

<p>a set of argument values corresponding to the observations in array
<code>y</code>.  In most applications these values will be common to all curves
and all variables, and therefore be defined as a vector or as a matrix
with a single column.  But it is possible that these argument values
will vary from one curve to another, and in this case <code>argvals</code> will
be input as a matrix with rows corresponding to observation points and
columns corresponding to curves.  Argument values can even vary from one
variable to another, in which case they are input as an array with
dimensions corresponding to observation points, curves and variables,
respectively.  Note, however, that the number of observation points per
curve and per variable may NOT vary.  If it does, then curves and variables
must be smoothed individually rather than by a single call to this function.
The default value for <code>argvals</code> are the integers 1 to <code>n</code>, where
<code>n</code> is the size of the first dimension in argument <code>y</code>.
</p>
</td></tr>
<tr><td><code id="smooth.basis.sparse_+3A_y">y</code></td>
<td>

<p>an set of values of curves at discrete sampling points or
argument values. If the set is supplied as a matrix object, the rows must
correspond to argument values and columns to replications, and it will be
assumed that there is only one variable per observation.  If
<code>y</code> is a three-dimensional array, the first dimension
corresponds to argument values, the second to replications, and the
third to variables within replications.  If <code>y</code> is a vector,
only one replicate and variable are assumed.  If the data
come from a single replication but multiple vectors, such as data
on coordinates for a single space curve, then be sure to coerce
the data into an array object by using the <code>as.array</code> function
with one as the central dimension length.
</p>
</td></tr>
<tr><td><code id="smooth.basis.sparse_+3A_fdparobj">fdParobj</code></td>
<td>

<p>a functional parameter object, a functional data object or a
functional basis object.  In the simplest case, <code>fdParobj</code> may
be a functional basis object with class &quot;basisfd&quot; defined
previously by one of the &quot;create&quot; functions, and in this case, no
roughness penalty is used.  No roughness penalty is also the
consequence of supplying a functional data object with class &quot;fd&quot;,
in which case the basis system used for smoothing is that defining
this object.  
However, if the object is a functional parameter object with class
&quot;fdPar&quot;, then the linear differential operator object and the
smoothing parameter in this object define the roughness penalty. For
further details on how the roughness penalty is defined, see the help
file for &quot;fdPar&quot;. In general, better results can be obtained using a
good roughness penalty than can be obtained by merely varying the
number of basis functions in the expansion.
</p>
</td></tr>
<tr><td><code id="smooth.basis.sparse_+3A_fdnames">fdnames</code></td>
<td>

<p>a list of length 3 containing character vectors of names for the
following:
</p>

<dl>
<dt>args</dt><dd>
<p>name for each observation or point in time at which data are
collected for each 'rep', unit or subject.
</p>
</dd>
<dt>reps</dt><dd>
<p>name for each 'rep', unit or subject.
</p>
</dd>
<dt>fun</dt><dd>
<p>name for each 'fun' or (response) variable measured repeatedly
(per 'args') for each 'rep'.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="smooth.basis.sparse_+3A_covariates">covariates</code></td>
<td>

<p>The observed values in <code>y</code> are assumed to be primarily
determined by the height of the curve being estimates, but from time
to time certain values can also be influenced by other known
variables.  For example, multi-year sets of climate variables may be
also determined by the presence of absence of an El Nino event, or a
volcanic eruption.  One or more of these covariates can be supplied
as an <code>n</code> by <code>p</code> matrix, where <code>p</code> is the number of
such covariates.  When such covariates are available, the smoothing
is called &quot;semi-parametric.&quot;  Matrices or arrays of regression
coefficients are then estimated that define the impacts of each of
these covariates for each curve and each variable.
</p>
</td></tr>
<tr><td><code id="smooth.basis.sparse_+3A_method">method</code></td>
<td>

<p>by default the function uses the usual textbook equations for computing
the coefficients of the basis function expansions.  But, as in regression
analysis, a price is paid in terms of rounding error for such
computations since they involved cross-products of  basis function
values.  Optionally, if <code>method</code> is set equal to the string &quot;qr&quot;,
the computation uses an algorithm based on the qr-decomposition which
is more accurate, but will require substantially more computing time
when <code>n</code> is large, meaning more than 500 or so.  The default
is &quot;chol&quot;, referring the Choleski decomposition of a symmetric positive
definite matrix.
</p>
</td></tr>
<tr><td><code id="smooth.basis.sparse_+3A_dfscale">dfscale</code></td>
<td>

<p>the generalized cross-validation or &quot;gcv&quot; criterion that is often used
to determine the size of the smoothing parameter involves the
subtraction of an measue of degrees of freedom from <code>n</code>.  Chong
Gu has argued that multiplying this degrees of freedom measure by
a constant slightly greater than 1, such as 1.2, can produce better
decisions about the level of smoothing to be used.  The default value
is, however, 1.0.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>fd</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis">smooth.basis</a></code>
</p>

<hr>
<h2 id='smooth.basisPar'>
Smooth Data Using a Directly Specified Roughness Penalty
</h2><span id='topic+smooth.basisPar'></span>

<h3>Description</h3>

<p>Smooth (argvals, y) data with roughness penalty defined by the
remaining arguments.  This function acts as a wrapper for those who want 
to bypass the step of setting up a functional parameter object before invoking 
function <code>smooth.basis</code>.  This function simply does this setup for the 
user.   See the help file for functions <code>smooth.basis</code> and <code>fdPar</code> 
for further details, and more complete descriptions of the arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.basisPar(argvals, y, fdobj=NULL, Lfdobj=NULL,
      lambda=0, estimate=TRUE, penmat=NULL,
      wtvec=NULL, fdnames=NULL, covariates=NULL, 
                         method="chol", dfscale=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.basisPar_+3A_argvals">argvals</code></td>
<td>

<p>a set of argument values corresponding to the observations in array
<code>y</code>.  In most applications these values will be common to all curves
and all variables, and therefore be defined as a vector or as a matrix
with a single column.  But it is possible that these argument values
will vary from one curve to another, and in this case <code>argvals</code> will
be input as a matrix with rows corresponding to observation points and
columns corresponding to curves.  Argument values can even vary from one
variable to another, in which case they are input as an array with
dimensions corresponding to observation points, curves and variables,
respectively.  Note, however, that the number of observation points per
curve and per variable may NOT vary.  If it does, then curves and variables
must be smoothed individually rather than by a single call to this function.
The default value for <code>argvals</code> are the integers 1 to <code>n</code>, where
<code>n</code> is the size of the first dimension in argument <code>y</code>.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_y">y</code></td>
<td>

<p>an set of values of curves at discrete sampling points or
argument values. If the set is supplied as a matrix object, the rows must
correspond to argument values and columns to replications, and it will be
assumed that there is only one variable per observation.  If
<code>y</code> is a three-dimensional array, the first dimension
corresponds to argument values, the second to replications, and the
third to variables within replications.  If <code>y</code> is a vector,
only one replicate and variable are assumed.  If the data
come from a single replication but multiple vectors, such as data
on coordinates for a single space curve, then be sure to coerce
the data into an array object by using the <code>as.array</code> function
with one as the central dimension length.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_fdobj">fdobj</code></td>
<td>

<p>One of the following:
</p>

<dl>
<dt>fd</dt><dd>
<p>a functional data object (class <code>fd</code>)
</p>
</dd>
<dt>basisfd</dt><dd>
<p>a functional basis object (class <code>basisfd</code>), which is
converted to a functional data object with the identity matrix
as the coefficient matrix.
</p>
</dd>
<dt>fdPar</dt><dd>
<p>a functional parameter object (class <code>fdPar</code>)
</p>
</dd>
<dt>integer</dt><dd>
<p>a positive integer giving the order of a B-spline basis, which is
further converted to a functional data object with the identity
matrix as the coefficient matrix.
</p>
</dd>
<dt>matrix or array</dt><dd><p>replaced by fd(fdobj)</p>
</dd>
<dt>NULL</dt><dd>
<p>Defaults to fdobj = create.bspline.basis(argvals).
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="smooth.basisPar_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.
</p>
<p>If <code>NULL</code>, Lfdobj depends on fdobj[['basis']][['type']]:
</p>

<dl>
<dt>bspline</dt><dd>
<p>Lfdobj &lt;- int2Lfd(max(0, norder-2)), where norder =
norder(fdobj).
</p>
</dd>
<dt>fourier</dt><dd>
<p>Lfdobj = a harmonic acceleration operator:
</p>
<p><code>Lfdobj &lt;- vec2Lfd(c(0,(2*pi/diff(rng))^2,0), rng)</code>
</p>
<p>where rng = fdobj[['basis']][['rangeval']].
</p>
</dd>
<dt>anything else</dt><dd><p>Lfdobj &lt;- int2Lfd(0)</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="smooth.basisPar_+3A_lambda">lambda</code></td>
<td>

<p>a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_estimate">estimate</code></td>
<td>

<p>a logical value:  if <code>TRUE</code>, the functional parameter is
estimated, otherwise, it is held fixed.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_penmat">penmat</code></td>
<td>

<p>a roughness penalty matrix.  Including this can eliminate the need
to compute this matrix over and over again in some types of
calculations.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_wtvec">wtvec</code></td>
<td>

<p>typically a vector of length <code>n</code> that is the length of <code>argvals</code>
containing weights for the values to be smoothed, However, it may also
be a symmetric matrix of order <code>n</code>.  If <code>wtvec</code> is a vector,
all values must be positive, and if it is a symmetric matrix, this must
be positive definite.  Defaults to all weights equal to 1.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_fdnames">fdnames</code></td>
<td>

<p>a list of length 3 containing character vectors of names for the
following:
</p>

<dl>
<dt>args</dt><dd>
<p>name for each observation or point in time at which data are
collected for each 'rep', unit or subject.
</p>
</dd>
<dt>reps</dt><dd>
<p>name for each 'rep', unit or subject.
</p>
</dd>
<dt>fun</dt><dd>
<p>name for each 'fun' or (response) variable measured repeatedly
(per 'args') for each 'rep'.
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="smooth.basisPar_+3A_covariates">covariates</code></td>
<td>

<p>the observed values in <code>y</code> are assumed to be primarily determined
the the height of the curve being estimates, but from time to time
certain values can also be influenced by other known variables.  For
example, multi-year sets of climate variables may be also determined by
the presence of absence of an El Nino event, or a volcanic eruption.
One or more of these covariates can be supplied as an <code>n</code> by
<code>p</code> matrix, where <code>p</code> is the number of such covariates.  When
such covariates are available, the smoothing is called &quot;semi-parametric.&quot;
Matrices or arrays of regression coefficients are then estimated that
define the impacts of each of these covariates for each cueve and each
variable.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_method">method</code></td>
<td>

<p>by default the function uses the usual textbook equations for computing
the coefficients of the basis function expansions.  But, as in regression
analysis, a price is paid in terms of rounding error for such
computations since they involved cross-products of  basis function
values.  Optionally, if <code>method</code> is set equal to the string &quot;qr&quot;,
the computation uses an algorithm based on the qr-decomposition which
is more accurate, but will require substantially more computing time
when <code>n</code> is large, meaning more than 500 or so.  The default
is &quot;chol&quot;, referring the Choleski decomposition of a symmetric positive
definite matrix.
</p>
</td></tr>
<tr><td><code id="smooth.basisPar_+3A_dfscale">dfscale</code></td>
<td>

<p>the generalized cross-validation or &quot;gcv&quot; criterion that is often used
to determine the size of the smoothing parameter involves the
subtraction of an measue of degrees of freedom from <code>n</code>.  Chong
Gu has argued that multiplying this degrees of freedom measure by
a constant slightly greater than 1, such as 1.2, can produce better
decisions about the level of smoothing to be used.  The default value
is, however, 1.0.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  if(is.null(fdobj))fdobj &lt;- create.bspline.basis(argvals).  Else
if(is.integer(fdobj)) fdobj &lt;- create.bspline.basis(argvals, norder =
fdobj)
</p>
<p>2.  fdPar
</p>
<p>3.  smooth.basis
</p>


<h3>Value</h3>

<p>The output of a call to <code>smooth.basis</code>, which is an object of
class <code>fdSmooth</code>, being a list of length 8 with the following
components:
</p>
<table role = "presentation">
<tr><td><code>fd</code></td>
<td>

<p>a functional data object that smooths the data.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>a degrees of freedom measure of the smooth
</p>
</td></tr>
<tr><td><code>gcv</code></td>
<td>

<p>the value of the generalized cross-validation or GCV criterion.  If
there are multiple curves, this is a vector of values, one per
curve.  If the smooth is multivariate, the result is a matrix of gcv
values, with columns corresponding to variables.
</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>

<p>the error sums of squares.  SSE is a vector or a matrix of the same
size as 'gcv'.
</p>
</td></tr>
<tr><td><code>penmat</code></td>
<td>

<p>the penalty matrix.
</p>
</td></tr>
<tr><td><code>y2cMap</code></td>
<td>

<p>the matrix mapping the data to the coefficients.
</p>
</td></tr>
<tr><td><code>argvals</code>, <code>y</code></td>
<td>
<p>input arguments</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., and Silverman, Bernard W. (2006), <em>Functional
Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), <em>Applied
Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+df2lambda">df2lambda</a></code>,
<code><a href="#topic+fdPar">fdPar</a></code>,
<code><a href="#topic+lambda2df">lambda2df</a></code>,
<code><a href="#topic+lambda2gcv">lambda2gcv</a></code>,
<code><a href="#topic+plot.fd">plot.fd</a></code>,
<code><a href="#topic+project.basis">project.basis</a></code>,
<code><a href="#topic+smooth.basis">smooth.basis</a></code>,
<code><a href="#topic+smooth.fd">smooth.fd</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+smooth.pos">smooth.pos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#  see smooth.basis
</code></pre>

<hr>
<h2 id='smooth.bibasis'>
Smooth a discrete surface over a rectangular lattice
</h2><span id='topic+smooth.bibasis'></span>

<h3>Description</h3>

<p>Estimate a smoothing function f(s, t) over a rectangular lattice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.bibasis(sarg, targ, y, fdPars, fdPart, fdnames=NULL, returnMatrix=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.bibasis_+3A_sarg">sarg</code>, <code id="smooth.bibasis_+3A_targ">targ</code></td>
<td>

<p>vectors of argument values for the first and second dimensions,
respectively, of the surface function.
</p>
</td></tr>
<tr><td><code id="smooth.bibasis_+3A_y">y</code></td>
<td>

<p>an array containing surface values measured with noise
</p>
</td></tr>
<tr><td><code id="smooth.bibasis_+3A_fdpars">fdPars</code>, <code id="smooth.bibasis_+3A_fdpart">fdPart</code></td>
<td>

<p>functional parameter objects for <code>sarg</code> and <code>targ</code>,
respectively
</p>
</td></tr>
<tr><td><code id="smooth.bibasis_+3A_fdnames">fdnames</code></td>
<td>

<p>a list of length 3 containing character vectors of names for
<code>sarg</code>, <code>targ</code>, and the surface function f(s, t).
</p>
</td></tr>
<tr><td><code id="smooth.bibasis_+3A_returnmatrix">returnMatrix</code></td>
<td>

<p>logical:  If TRUE,  a two-dimensional is returned using a
special class from the Matrix package.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following components:
</p>
<table role = "presentation">
<tr><td><code>fdobj</code></td>
<td>

<p>a functional data object containing a smooth of the data.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>a degrees of freedom measure of the smooth
</p>
</td></tr>
<tr><td><code>gcv</code></td>
<td>

<p>the value of the generalized cross-validation or GCV criterion.  If
the function is univariate, GCV is a vector containing the error
sum of squares for each function, and if the function is
multivariate, GCV is a NVAR by NCURVES matrix.
</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>

<p>the coefficient matrix for the basis function expansion of
the smoothing function
</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>

<p>the error sums of squares.  SSE is a vector or a matrix of the same
size as GCV.
</p>
</td></tr>
<tr><td><code>penmat</code></td>
<td>

<p>the penalty matrix.
</p>
</td></tr>
<tr><td><code>y2cMap</code></td>
<td>

<p>the matrix mapping the data to the coefficients.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis">smooth.basis</a></code>
</p>

<hr>
<h2 id='smooth.fd'>
Smooth a Functional Data Object Using an Indirectly Specified
Roughness Penalty
</h2><span id='topic+smooth.fd'></span>

<h3>Description</h3>

<p>Smooth data already converted to a functional data object, fdobj,
using criteria consolidated in a functional data parameter object,
fdParobj.  For example, data may have been converted to a functional
data object using function <code>smooth.basis</code> using a fairly large set of
basis functions.  This 'fdobj' is then smoothed as specified in
'fdParobj'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.fd(fdobj, fdParobj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.fd_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object to be smoothed.
</p>
</td></tr>
<tr><td><code id="smooth.fd_+3A_fdparobj">fdParobj</code></td>
<td>

<p>a functional parameter object. This object is defined by a roughness
penalty in slot <code>Lfd</code> and a smoothing parameter lambda in slot
<code>lambda</code>, and this information is used to further smooth argument <code>fdobj</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functional data object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis">smooth.basis</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  Shows the effects of two levels of smoothing
#  where the size of the third derivative is penalized.
#  The null space contains quadratic functions.
x &lt;- seq(-1,1,0.02)
y &lt;- x + 3*exp(-6*x^2) + rnorm(rep(1,101))*0.2
#  set up a saturated B-spline basis
basisobj &lt;- create.bspline.basis(c(-1,1),81)
#  convert to a functional data object that interpolates the data.
result &lt;- smooth.basis(x, y, basisobj)
yfd  &lt;- result$fd

#  set up a functional parameter object with smoothing
#  parameter 1e-6 and a penalty on the 3rd derivative.
yfdPar &lt;- fdPar(yfd, 2, 1e-6)
yfd1 &lt;- smooth.fd(yfd, yfdPar)

#. this code throws an error for. non-cran check
# if (!CRAN()) {
# FIXME: using 3rd derivative here gave error?????
# yfdPar3 &lt;- fdPar(yfd, 3, 1e-6)
# yfd1.3 &lt;- smooth.fd(yfd, yfdPar3)
# Error in bsplinepen(basisobj, Lfdobj, rng) :
#	Penalty matrix cannot be evaluated
#  for derivative of order 3 for B-splines of order 4
# }

#  set up a functional parameter object with smoothing
#  parameter 1 and a penalty on the 3rd derivative.
yfdPar &lt;- fdPar(yfd, 2, 1)
yfd2 &lt;- smooth.fd(yfd, yfdPar)
#  plot the data and smooth
plot(x,y)           # plot the data
lines(yfd1, lty=1)  #  add moderately penalized smooth
lines(yfd2, lty=3)  #  add heavily  penalized smooth
legend(-1,3,c("0.000001","1"),lty=c(1,3))
#  plot the data and smoothing using function plotfit.fd
plotfit.fd(y, x, yfd1)  # plot data and smooth
par(oldpar)
</code></pre>

<hr>
<h2 id='smooth.fdPar'>
Smooth a functional data object using a directly specified roughness
penalty
</h2><span id='topic+smooth.fdPar'></span>

<h3>Description</h3>

<p>Smooth data already converted to a functional data object, fdobj,
using directly specified criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.fdPar(fdobj, Lfdobj=NULL, lambda=1e-4,
             estimate=TRUE, penmat=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.fdPar_+3A_fdobj">fdobj</code></td>
<td>

<p>a functional data object to be smoothed.
</p>
</td></tr>
<tr><td><code id="smooth.fdPar_+3A_lfdobj">Lfdobj</code></td>
<td>

<p>either a nonnegative integer or a linear differential operator
object.
</p>
<p>If <code>NULL</code>, Lfdobj depends on fdobj[['basis']][['type']]:
</p>

<dl>
<dt>bspline</dt><dd>
<p>Lfdobj &lt;- int2Lfd(max(0, norder-2)), where norder =
norder(fdobj).
</p>
</dd>
<dt>fourier</dt><dd>
<p>Lfdobj = a harmonic acceleration operator:
</p>
<p><code>Lfdobj &lt;- vec2Lfd(c(0,(2*pi/diff(rng))^2,0), rng)</code>
</p>
<p>where rng = fdobj[['basis']][['rangeval']].
</p>
</dd>
<dt>anything else</dt><dd><p>Lfdobj &lt;- int2Lfd(0)</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="smooth.fdPar_+3A_lambda">lambda</code></td>
<td>

<p>a nonnegative real number specifying the amount of smoothing
to be applied to the estimated functional parameter.
</p>
</td></tr>
<tr><td><code id="smooth.fdPar_+3A_estimate">estimate</code></td>
<td>

<p>a logical value:  if <code>TRUE</code>, the functional parameter is
estimated, otherwise, it is held fixed.
</p>
</td></tr>
<tr><td><code id="smooth.fdPar_+3A_penmat">penmat</code></td>
<td>

<p>a roughness penalty matrix.  Including this can eliminate the need
to compute this matrix over and over again in some types of
calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1.  fdPar
</p>
<p>2.  smooth.fd
</p>


<h3>Value</h3>

<p>a functional data object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.fd">smooth.fd</a></code>,
<code><a href="#topic+fdPar">fdPar</a></code>,
<code><a href="#topic+smooth.basis">smooth.basis</a></code>,
<code><a href="#topic+smooth.pos">smooth.pos</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#  see smooth.basis
</code></pre>

<hr>
<h2 id='smooth.monotone'>
Monotone Smoothing of Data
</h2><span id='topic+smooth.monotone'></span>

<h3>Description</h3>

<p>When the discrete data that are observed reflect a smooth strictly
increasing or strictly decreasing function, it is often desirable to
smooth the data with a strictly monotone function, even though the
data themselves may not be monotone due to observational error.  An
example is when data are collected on the size of a growing organism
over time.  This function computes such a smoothing function, but,
unlike other smoothing functions, for only for one curve at a time.
The smoothing function minimizes a weighted error sum of squares
criterion.  This minimization requires iteration, and therefore is
more computationally intensive than normal smoothing.
</p>
<p>The monotone smooth is beta[1]+beta[2]*integral(exp(Wfdobj)), where
Wfdobj is a functional data object.  Since exp(Wfdobj)&gt;0, its integral
is monotonically increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.monotone(argvals, y, WfdParobj, wtvec=rep(1,n),
                zmat=NULL, conv=.0001, iterlim=50,
                active=rep(TRUE,nbasis), dbglev=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.monotone_+3A_argvals">argvals</code></td>
<td>

<p>Argument value array of length N, where N is the number of observed
curve values for each curve.  It is assumed that that these argument
values are common to all observed curves.  If this is not the case,
you will need to run this function inside one or more loops,
smoothing each curve separately.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_y">y</code></td>
<td>

<p>a vector of data values.  This function can only smooth one set of
data at a time.
</p>
<p>Function value array (the values to be fit).  If the functional data
are univariate, this array will be an N by NCURVE matrix, where N is
the number of observed curve values for each curve and NCURVE is the
number of curves observed.  If the functional data are multivariate,
this array will be an N by NCURVE by NVAR matrix, where NVAR the
number of functions observed per case.  For example, for the gait
data, NVAR = 2, since we observe knee and hip angles.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_wfdparobj">WfdParobj</code></td>
<td>

<p>A functional parameter or fdPar object.  This object contains the
specifications for the functional data object to be estimated by
smoothing the data.  See comment lines in function fdPar for
details.  The functional data object WFD in WFDPAROBJ is used to
initialize the optimization process.  Its coefficient array contains
the starting values for the iterative minimization of mean squared
error.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_wtvec">wtvec</code></td>
<td>

<p>a vector of weights to be used in the smoothing.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_zmat">zmat</code></td>
<td>

<p>a design matrix or a matrix of covariate values that also define the
smooth of the data.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_conv">conv</code></td>
<td>

<p>a convergence criterion.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_iterlim">iterlim</code></td>
<td>

<p>the maximum number of iterations allowed in the minimization of
error sum of squares.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_active">active</code></td>
<td>

<p>a logical vector specifying which coefficients defining W(t) are
estimated.  Normally, the first coefficient is fixed.
</p>
</td></tr>
<tr><td><code id="smooth.monotone_+3A_dbglev">dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out
on each iteration, with 0 implying no output, 1 intermediate output
level, and 2 full output.  If either level 1 or 2 is specified, it
can be helpful to turn off the output buffering feature of S-PLUS.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The smoothing function  f(argvals) is determined by three objects
that need to be estimated from the data:
</p>

<ul>
<li><p> W(argvals), a functional data object that is first
exponentiated and then the result integrated.  This is the heart
of the monotone smooth.  The closer W(argvals) is to zero, the
closer the monotone smooth becomes a straight line.  The closer
W(argvals) becomes a constant, the more the monotone smoother
becomes an exponential function.  It is assumed that W(0) = 0.
</p>
</li>
<li><p> b0, an intercept term that determines the value of the
smoothing function at argvals = 0.
</p>
</li>
<li><p> b1, a regression coefficient that determines the slope
of the smoothing function at argvals = 0.
</p>
</li></ul>

<p>In addition, it is possible to have the intercept b0
depend in turn on the values of one or more covariates through the
design matrix <code>Zmat</code> as follows:
b0 = Z c. In this case, the single
intercept coefficient is replaced by the regression coefficients
in vector c multiplying the design matrix.
</p>


<h3>Value</h3>

<p>an object of class <code>monfd</code>, which is a list with the following 5
components:
</p>
<table role = "presentation">
<tr><td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function W(argvals) that
optimizes the fit to the data of the monotone function that it
defines.
</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>

<p>The regression coefficients b_0 and b_1 for each smoothed
curve.
</p>
<p>If the curves are univariate and
... ZMAT is NULL,       BETA is 2   by NCURVE.
... ZMAT has P columns, BETA is P+1 by NCURVE.
</p>
<p>If the curves are multivariate and
... ZMAT is NULL,       BETA is 2   by NCURVE by NVAR.
... ZMAT has P columns, BETA is P+1 by NCURVE by NVAR.
</p>
</td></tr>
<tr><td><code>yhatfd</code></td>
<td>

<p>A functional data object for the monotone curves that smooth the
data.  This object is constructed using the basis for WFDOBJ, and
this basis may  well be too simple to accommodate the curvature
in the monotone function that Wfdobjnes.  It may be
necessary to discard this object and use a richer basis
externally to smooth the values defined by
beta[1] + beta[2]*eval.monfd(evalarg, Wfdobj).
</p>
</td></tr>
<tr><td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged
solution:  (1) <b>f</b>: the optimal function value being minimized,
(2) <b>grad</b>: the gradient vector at the optimal solution, and
(3) <b>norm</b>: the norm of the gradient vector at the optimal
solution.
</p>
</td></tr>
<tr><td><code>y2cMap</code></td>
<td>

<p>For each estimated curve (and variable if functions are
multivariate, this is an N by NBASIS matrix containing a linear
mapping from data to coefficients that can be used for computing
point-wise confidence intervals.  If NCURVE = NVAR = 1, a matrix is
returned.  Otherwise an NCURVE by NVAR list is returned, with each
slot containing this mapping.
</p>
</td></tr>
<tr><td><code>argvals</code></td>
<td>

<p>input <code>argvals</code>, possibly modified / clarified by
<code>argcheck</code>.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>input argument <code>y</code>, possibly modified / clarified by
<code>ycheck</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis">smooth.basis</a></code>,
<code><a href="#topic+smooth.pos">smooth.pos</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  Estimate the acceleration functions for growth curves
#  See the analyses of the growth data.
#  Set up the ages of height measurements for Berkeley data

age &lt;- c( seq(1, 2, 0.25), seq(3, 8, 1), seq(8.5, 18, 0.5))
#  Range of observations
rng &lt;- c(1,18)
#  First set up a basis for monotone smooth
#  We use b-spline basis functions of order 6
#  Knots are positioned at the ages of observation.
norder &lt;- 6
nage   &lt;- length(age)
nbasis &lt;- nage + norder - 2
wbasis &lt;- create.bspline.basis(rng, nbasis, norder, age)
#  starting values for coefficient
cvec0 &lt;- matrix(0,nbasis,1)
Wfd0  &lt;- fd(cvec0, wbasis)
#  set up functional parameter object
Lfdobj    &lt;- 3          #  penalize curvature of acceleration
lambda    &lt;- 10^(-0.5)  #  smoothing parameter
growfdPar &lt;- fdPar(Wfd0, Lfdobj, lambda)
#  Set up wgt vector
wgt   &lt;- rep(1,nage)
#  Smooth the data for the first girl
hgt1 = growth$hgtf[,1]

# conv=0.1 to reduce the compute time,
# required to reduce the test time on CRAN

# delete the test on CRAN because it takes too long

if (!CRAN()) {
result &lt;- smooth.monotone(age, hgt1, growfdPar, wgt,
                          conv=0.1)
#  Extract the functional data object and regression
#  coefficients
Wfd  &lt;- result$Wfdobj
beta &lt;- result$beta
#  Evaluate the fitted height curve over a fine mesh
agefine &lt;- seq(1,18,len=73)
hgtfine &lt;- beta[1] + beta[2]*eval.monfd(agefine, Wfd)
#  Plot the data and the curve
plot(age, hgt1, type="p")
lines(agefine, hgtfine)
#  Evaluate the acceleration curve
accfine &lt;- beta[2]*eval.monfd(agefine, Wfd, 2)
#  Plot the acceleration curve
plot(agefine, accfine, type="l")
lines(c(1,18),c(0,0),lty=4)
}
par(oldpar)
</code></pre>

<hr>
<h2 id='smooth.morph'>
Estimates a Smooth Warping Function Mapping an Interval into Another
</h2><span id='topic+smooth.morph'></span>

<h3>Description</h3>

<p>This function computes a smooth monotone transformation $h(t)$ of
argument $t$ such that $h(0) = 0$ and $h(TRUE) = TRUE$, where $t$ is
the upper limit of a range interval.  This function is used to 
morph one probability density function into another having a 
possibly different domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.morph(x, y, ylim, WfdPar, conv=1e-4, iterlim=20, dbglev=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.morph_+3A_x">x</code></td>
<td>

<p>a vector of argument values.
</p>
</td></tr>
<tr><td><code id="smooth.morph_+3A_y">y</code></td>
<td>

<p>a vector of data values.  This function can only smooth one set of
data at a time.
</p>
</td></tr>
<tr><td><code id="smooth.morph_+3A_ylim">ylim</code></td>
<td>

<p>a vector of length two containing the lower and upper limits of
the target interval.
</p>
</td></tr>
<tr><td><code id="smooth.morph_+3A_wfdpar">WfdPar</code></td>
<td>

<p>a functional parameter object that provides an initial value for the
coefficients defining function $W(t)$, and a roughness penalty on
this function.
</p>
</td></tr>
<tr><td><code id="smooth.morph_+3A_conv">conv</code></td>
<td>

<p>a convergence criterion.
</p>
</td></tr>
<tr><td><code id="smooth.morph_+3A_iterlim">iterlim</code></td>
<td>

<p>the maximum number of iterations allowed in the minimization of
error sum of squares.
</p>
</td></tr>
<tr><td><code id="smooth.morph_+3A_dbglev">dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out
on each iteration, with 0 implying no output, 1 intermediate output
level, and 2 full output.  If either level 1 or 2 is specified, it
can be helpful to turn off the output buffering feature of S-PLUS.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes a increasing function mapping one closed into interval 
(defined in <code>WfdPar</code> into another (the two-value numeric vector argument
<code>ylim</code>).  
The function immediately checks that the data do not fall outside of the 
first interval, which is located in <code>WfdPar$fd$basis$rangeval</code> and 
named <code>xlim</code> in its code.
</p>
<p>A frequent problem is that the data points in argument <code>x</code> are 
outside of this origin interval.  Small escapes less than 1e-7 are 
automatically converted to the correct the right limit. But the
user should check that this constraint is met  before invoking the 
function, and especially when the function is used iteratively.
</p>


<h3>Value</h3>

<p>A named list of length eight containing:
</p>
<table role = "presentation">
<tr><td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the monotone function that it
defines.
</p>
</td></tr>
<tr><td><code>f</code></td>
<td>

<p>the optimal function value being minimized.
</p>
</td></tr>
<tr><td><code>grad</code></td>
<td>

<p>the gradient vector at the optimal solution
</p>
</td></tr>
<tr><td><code>hmat</code></td>
<td>

<p>the Hessian matrix at the optimal solution
</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>

<p>the norm of the gradient vector at the optimal solution.
</p>
</td></tr>
<tr><td><code>hfine</code></td>
<td>

<p>a fine mesh of values of the estimated monotone function.
</p>
</td></tr>
<tr><td><code>iternum</code></td>
<td>

<p>the number of iterations.
</p>
</td></tr>
<tr><td><code>iterhist</code></td>
<td>

<p>the iteration history.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cumfd">cumfd</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+landmarkreg">landmarkreg</a></code>,
<code><a href="#topic+register.fd">register.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  see the use of smooth.morph in cumfd.R and landmarkreg.R
</code></pre>

<hr>
<h2 id='smooth.pos'>
Smooth Data with a Positive Function
</h2><span id='topic+smooth.pos'></span>

<h3>Description</h3>

<p>A set of data is smoothed with a functional data object that only
takes positive values.  For example, this function can be used to
estimate a smooth variance function from a set of squared residuals.
A function $W(t)$ is estimated such that that the smoothing function
is $exp[W(t)]$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.pos(argvals, y, WfdParobj, wtvec=rep(1,n),conv=.0001, iterlim=50, dbglev=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.pos_+3A_argvals">argvals</code></td>
<td>

<p>Argument value array of length N, where N is the number of observed
curve values for each curve.  It is assumed that that these argument
values are common to all observed curves.  If this is not the case,
you will need to run this function inside one or more loops,
smoothing each curve separately.
</p>
</td></tr>
<tr><td><code id="smooth.pos_+3A_y">y</code></td>
<td>

<p>Function value array (the values to be fit).  If the functional data
are univariate, this array will be an N by NCURVE matrix, where N is
the number of observed curve values for each curve and NCURVE is the
number of curves observed.  If the functional data are multivariate,
this array will be an N by NCURVE by NVAR matrix, where NVAR the
number of functions observed per case.  For example, for the gait
data, NVAR = 2, since we observe knee and hip angles.
</p>
</td></tr>
<tr><td><code id="smooth.pos_+3A_wfdparobj">WfdParobj</code></td>
<td>

<p>A functional parameter or fdPar object.  This object contains the
specifications for the functional data object to be estimated by
smoothing the data.  See comment lines in function fdPar for
details.  The functional data object WFD in WFDPAROBJ is used to
initialize the optimization process.  Its coefficient array contains
the starting values for the iterative minimization of mean squared
error.
The coefficient array contains the starting values for the iterative 
minimization of mean squared error, and this coefficient array must 
be either a K by NCURVE matrix or a K by NUCRVE by NVAR array,  
where K is the number of basis functions.
</p>
</td></tr>
<tr><td><code id="smooth.pos_+3A_wtvec">wtvec</code></td>
<td>

<p>a vector of weights to be used in the smoothing.
</p>
</td></tr>
<tr><td><code id="smooth.pos_+3A_conv">conv</code></td>
<td>

<p>a convergence criterion.
</p>
</td></tr>
<tr><td><code id="smooth.pos_+3A_iterlim">iterlim</code></td>
<td>

<p>the maximum number of iterations allowed in the minimization of
error sum of squares.
</p>
</td></tr>
<tr><td><code id="smooth.pos_+3A_dbglev">dbglev</code></td>
<td>

<p>either 0, 1, or 2.  This controls the amount information printed out
on each iteration, with 0 implying no output, 1 intermediate output
level, and 2 full output.  If either level 1 or 2 is specified, it
can be helpful to turn off the output buffering feature of S-PLUS.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>posfd</code>, being a list with 4 components:
</p>
<table role = "presentation">
<tr><td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the positive function that it
defines.
</p>
</td></tr>
<tr><td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged
solution: (1) <b>f</b>: the optimal function value being minimized,
(2) <b>grad</b>: the gradient vector at the optimal solution, and
(3) <b>norm</b>: the norm of the gradient vector at the optimal
solution.
</p>
</td></tr>
<tr><td><code>argvals</code></td>
<td>
<p>the corresponding input arguments</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the corresponding input arguments</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.surp">smooth.surp</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+smooth.morph">smooth.morph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smallbasis  &lt;- create.fourier.basis(c(0, 365), 65)
harmaccelLfd365 &lt;- vec2Lfd(c(0,(2*pi/365)^2,0), c(0, 365))

index   &lt;- (1:35)[CanadianWeather$place == "Vancouver"]
VanPrec &lt;- CanadianWeather$dailyAv[,index, "Precipitation.mm"]

lambda    &lt;- 1e4
dayfdPar &lt;- fdPar(fd(matrix(0,smallbasis$nbasis,1), smallbasis), 
                  harmaccelLfd365, lambda)
smooth.pos(day.5, VanPrec, dayfdPar)

</code></pre>

<hr>
<h2 id='smooth.sparse.mean'>
Smooth the mean function of sparse data 
</h2><span id='topic+smooth.sparse.mean'></span>

<h3>Description</h3>

<p>Do a smoothing of the mean function for sparse data that is either given 
as a list or as a matrix with NAs. The smooth is done by basis expansion 
with the functional basis &quot;type&quot;; if !(lambda == 0) then the second 
derivative is penalized (int2Lfd(2)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.sparse.mean(data, time ,rng = c(0, 1), type = "", nbasis = NULL, 
                  knots = NULL, norder = NULL, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.sparse.mean_+3A_data">data</code></td>
<td>

<p>a matrix object or list &ndash; If the set is supplied as a matrix object, 
the rows must correspond to argument values and columns to replications, 
and it will be assumed that there is only one variable per observation.  
If y is a three-dimensional array, the first dimension corresponds to  
argument values, the second to replications, and the third to variables 
within replications. &ndash; If it is a list, each element must be a matrix
object, the rows correspond to argument values per individual. First 
column corresponds to time points and followins columns to argument values 
per variable.
</p>
</td></tr>
<tr><td><code id="smooth.sparse.mean_+3A_time">time</code></td>
<td>

<p>Array with time points where data was taken. length(time) == ncol(data)
</p>
</td></tr>
<tr><td><code id="smooth.sparse.mean_+3A_rng">rng</code></td>
<td>

<p>an array of length 2 containing the lower and upper boundaries for the 
rangeval of argument values
</p>
</td></tr>
<tr><td><code id="smooth.sparse.mean_+3A_type">type</code></td>
<td>

<p>Type of basisfd for smoothing the mean estimate function.
&quot;bspline&quot;, &quot;fourier&quot;, &quot;exp&quot;, &quot;const&quot; or &quot;mon&quot;
</p>
</td></tr>
<tr><td><code id="smooth.sparse.mean_+3A_nbasis">nbasis</code></td>
<td>

<p>An integer variable specifying the number of basis functions
</p>
</td></tr>
<tr><td><code id="smooth.sparse.mean_+3A_knots">knots</code></td>
<td>

<p>a vector specifying the break points if type == &quot;bspline&quot;
</p>
</td></tr>
<tr><td><code id="smooth.sparse.mean_+3A_norder">norder</code></td>
<td>

<p>an integer specifying the order of b-splines if type == &quot;bspline&quot;
</p>
</td></tr>
<tr><td><code id="smooth.sparse.mean_+3A_lambda">lambda</code></td>
<td>

<p>a nonnegative real number specifying the amount of smoothing to be applied to 
the estimated functional parameter
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functional data object containing a smooth of the mean.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='smooth.surp'>
Fit data with surprisal smoothing.
</h2><span id='topic+smooth.surp'></span>

<h3>Description</h3>

<p>Surprisal is -log(probability) where the logarithm is to the base being the dimension 
<code>M</code>of the multinomial observation vector.  The surprisal curves for each question are estimated
by fitting the surprisal values of binned data using curves whose values are within the
M-1 dimensional surprisal subspace that is within the space of non-negative M-dimensional vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.surp(argvals, y, Bmat0, WfdPar, wtvec=NULL, conv=1e-4,
            iterlim=50, dbglev=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.surp_+3A_argvals">argvals</code></td>
<td>

<p>Argument value array of length N, where N is the number of observed
curve values for each curve.  It is assumed that that these argument
values are common to all observed curves.  If this is not the case,
you will need to run this function inside one or more loops,
smoothing each curve separately.
</p>
</td></tr>
<tr><td><code id="smooth.surp_+3A_y">y</code></td>
<td>

<p>A <code>nbin</code> by <code>M_i</code> matrix of surprisal values to be fit.  
</p>
</td></tr>
<tr><td><code id="smooth.surp_+3A_bmat0">Bmat0</code></td>
<td>
<p>A <code>Wnbasis</code> by <code>M_i - 1</code> matrix containing starting
values for the iterative optimization of the least squares fit of the 
surprisal curves to the surprisal data.
</p>
</td></tr>
<tr><td><code id="smooth.surp_+3A_wfdpar">WfdPar</code></td>
<td>

<p>A functional parameter or fdPar object.  This object contains the
specifications for the functional data object to be estimated by
smoothing the data.  See comment lines in function fdPar for
details.  The functional data object WFD in WFDPAROBJ is used to
initialize the optimization process.  Its coefficient array contains
the starting values for the iterative minimization of mean squared
error.
</p>
</td></tr>
<tr><td><code id="smooth.surp_+3A_wtvec">wtvec</code></td>
<td>

<p>A vector of weights to be used in the smoothing.
</p>
</td></tr>
<tr><td><code id="smooth.surp_+3A_conv">conv</code></td>
<td>

<p>A convergence criterion.
</p>
</td></tr>
<tr><td><code id="smooth.surp_+3A_iterlim">iterlim</code></td>
<td>

<p>the maximum number of iterations allowed in the minimization of
error sum of squares.
</p>
</td></tr>
<tr><td><code id="smooth.surp_+3A_dbglev">dbglev</code></td>
<td>

<p>Either 0, 1, or 2.  This controls the amount information printed out
on each iteration, with 0 implying no output, 1 intermediate output
level, and 2 full output.  If either level 1 or 2 is specified, it
can be helpful to turn off the output buffering feature of S-PLUS.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list <code>surpFd</code> with these members:
</p>
<table role = "presentation">
<tr><td><code>Wfdobj</code></td>
<td>

<p>a functional data object defining function $W(x)$ that that
optimizes the fit to the data of the positive function that it
defines.
</p>
</td></tr>
<tr><td><code>Flist</code></td>
<td>

<p>a named list containing three results for the final converged
solution: (1) <b>f</b>: the optimal function value being minimized,
(2) <b>grad</b>: the gradient vector at the optimal solution, and
(3) <b>norm</b>: the norm of the gradient vector at the optimal
solution.
</p>
</td></tr>
<tr><td><code>argvals</code></td>
<td>

<p>the corresponding input arguments
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>the corresponding input arguments
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juan Li and James Ramsay</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eval.surp">eval.surp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
#  evaluation points
x = seq(-2,2,len=11)
#  evaluate a standard normal distribution function
p = pnorm(x)
#  combine with 1-p
mnormp = cbind(p,1-p)
#  convert to surprisal values
mnorms = -log2(mnormp)
#  plot the surprisal values
matplot(x, mnorms, type="l", lty=c(1,1), col=c(1,1), 
        ylab="Surprisal (2-bits)")
# add some log-normal error
mnormdata = exp(log(mnorms) + rnorm(11)*0.1)
#  set up a b-spline basis object
nbasis = 7
sbasis = create.bspline.basis(c(-2,2),nbasis)
#  define an initial coefficient matrix
cmat = matrix(0,7,1)
#  set up a fdPar object for suprisal smoothing
sfd = fd(cmat, sbasis)
sfdPar = fdPar(sfd, Lfd=2, lambda=0)
#  smooth the noisy data
result = smooth.surp(x, mnormdata, cmat, sfdPar)
#  plot the data and the fits of the two surprisal curves
xfine = seq(-2,2,len=51)
sfine = eval.surp(xfine, result$Wfd)
matplot(xfine, sfine, type="l", lty=c(1,1), col=c(1,1))
points(x, mnormdata[,1])
points(x, mnormdata[,2])
#  convert the surprisal fit values to probabilities
pfine = 2^(-sfine)
#  check that they sum to one
apply(pfine,1,sum)
par(oldpar)
</code></pre>

<hr>
<h2 id='sparse.list'>Creates a list of sparse data from a matrix</h2><span id='topic+sparse.list'></span>

<h3>Description</h3>

<p>Creates a list with sparse data from a matrix that has NAs. The length of 
the list will be equal to the number of columns in the data matrix (replications)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sparse.list(data,time)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse.list_+3A_data">data</code></td>
<td>

<p>If the set is supplied as a matrix object, the rows must correspond to argument
values and columns to replications, and it will be assumed that there is only 
one variable per observation.  If y is a three-dimensional array, the first
dimension corresponds to argument values, the second to replications, and the
third to variables within replications.
</p>
</td></tr>
<tr><td><code id="sparse.list_+3A_time">time</code></td>
<td>
<p>Time points where the observations where taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with <code>length dim(data)[2]</code>. Each element of the list is a matrix with <code>ncol &gt; 1</code>. The first column of each element corresponds to the point index per observation.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cca.fd">cca.fd</a></code>,
<code><a href="#topic+pda.fd">pda.fd</a></code>
</p>

<hr>
<h2 id='sparse.mat'>Creates a matrix of sparse data with NAs out of a list</h2><span id='topic+sparse.mat'></span>

<h3>Description</h3>

<p>Creates a matrix or three dimensional array of sparse data with NAs from a list of
sparse data. The number of columns of the matrix will be equal to the length of the
list (replications)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sparse.mat(datalist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sparse.mat_+3A_datalist">datalist</code></td>
<td>

<p>A list object. Each element must be a matrix object where the rows correspond to 
argument values per individual. First column corresponds to time points and the 
following columns to argument values per variable.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix or array with ncol = length(datalist). First dimension corresponds to point
observations, second dimension corresponds to replications and third dimension
corresponds to variables.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='stepchk'>
Check a step size value for being within parameter limits.
</h2><span id='topic+stepchk'></span>

<h3>Description</h3>

<p>Parameter values are check for a proposed stepsize to ensure that they
remain within limits.  If not, the stepsize is adjusted to keep within
the limits.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepchk(oldstep, cvec, deltac, limwrd, ind, climit = 50 * c(-rep(1, ncvec), 
        rep(1, ncvec)), active = 1:ncvec, dbgwrd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepchk_+3A_oldstep">oldstep</code></td>
<td>

<p>A positive or zero step size for a line search</p>
</td></tr>
<tr><td><code id="stepchk_+3A_cvec">cvec</code></td>
<td>
<p>A numeric or matrix parameter vector.
</p>
</td></tr>
<tr><td><code id="stepchk_+3A_deltac">deltac</code></td>
<td>

<p>A vector defining a research direction of the same length as <code>cvec</code>.</p>
</td></tr>
<tr><td><code id="stepchk_+3A_limwrd">limwrd</code></td>
<td>

<p>A logical vector of length 2 indicating whether a lower and/or upper boundary is
rached by a step.</p>
</td></tr>
<tr><td><code id="stepchk_+3A_ind">ind</code></td>
<td>

<p>An integer that is normally 0 but is 1 if an upper boundary has been reached 
twice.</p>
</td></tr>
<tr><td><code id="stepchk_+3A_climit">climit</code></td>
<td>

<p>A two-column matrix with first dimension that of <code>cvec</code> indicating the lower   and upper boundaries for parameter vector values.</p>
</td></tr>
<tr><td><code id="stepchk_+3A_active">active</code></td>
<td>

<p>A logical vector with length that of <code>cvec</code> indicating which parmeter values   are fixed (FALSE) or free to be changed (TRUE).</p>
</td></tr>
<tr><td><code id="stepchk_+3A_dbgwrd">dbgwrd</code></td>
<td>
<p>An integer controlling the amount of information to display for
each step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nonnegative step size for a linear search.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='stepit'>
Compute a new step size for a linear search within an optimization algorithm.</h2><span id='topic+stepit'></span>

<h3>Description</h3>

<p>Using cubic interpolation, a new step size is computed for minimizing a 
function value.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stepit(linemat, ips, dblwrd, MAXSTEP)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepit_+3A_linemat">linemat</code></td>
<td>

<p>A 3 by 5 matrix containing step sizes, function values and slopes at
multiple values.</p>
</td></tr>
<tr><td><code id="stepit_+3A_ips">ips</code></td>
<td>
<p>If 1, previous slope was positive.</p>
</td></tr>
<tr><td><code id="stepit_+3A_dblwrd">dblwrd</code></td>
<td>
<p>Vector of length 2:  dblwrd[1] TRUE means step halved
dblwrd[2] TRUE means step doubled.</p>
</td></tr>
<tr><td><code id="stepit_+3A_maxstep">MAXSTEP</code></td>
<td>
<p>maximum allowed size of a step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A positive step size.</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='sum.fd'>
Sum of Functional Data
</h2><span id='topic+sum.fd'></span>

<h3>Description</h3>

<p>Evaluate the sum of a set of functions in a functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
sum(..., na.rm)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum.fd_+3A_...">...</code></td>
<td>

<p>a functional data object to sum.
</p>
</td></tr>
<tr><td><code id="sum.fd_+3A_na.rm">na.rm</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a functional data object with a single replication
that contains the sum of the functions in the object <code>fd</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.fd">mean.fd</a></code>,
<code><a href="#topic+std.fd">std.fd</a></code>,
<code><a href="#topic+stddev.fd">stddev.fd</a></code>,
<code><a href="#topic+center.fd">center.fd</a></code>
</p>

<hr>
<h2 id='summary.basisfd'>
Summarize a Functional Data Object
</h2><span id='topic+summary.basisfd'></span>

<h3>Description</h3>

<p>Provide a compact summary of the characteristics of a
functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basisfd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.basisfd_+3A_object">object</code></td>
<td>

<p>a functional data object (i.e., of class 'basisfd').
</p>
</td></tr>
<tr><td><code id="summary.basisfd_+3A_...">...</code></td>
<td>
<p>Other arguments to match generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a displayed summary of the bivariate functional data object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>

<hr>
<h2 id='summary.bifd'>
Summarize a Bivariate Functional Data Object
</h2><span id='topic+summary.bifd'></span>

<h3>Description</h3>

<p>Provide a compact summary of the characteristics of a
bivariate functional data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bifd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bifd_+3A_object">object</code></td>
<td>

<p>a bivariate functional data object.
</p>
</td></tr>
<tr><td><code id="summary.bifd_+3A_...">...</code></td>
<td>
<p>Other arguments to match the generic function for 'summary'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a displayed summary of the bivariate functional data object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
</p>

<hr>
<h2 id='summary.fd'>
Summarize a Functional Data Object
</h2><span id='topic+summary.fd'></span>

<h3>Description</h3>

<p>Provide a compact summary of the characteristics of a functional
data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fd'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fd_+3A_object">object</code></td>
<td>

<p>a functional data object.
</p>
</td></tr>
<tr><td><code id="summary.fd_+3A_...">...</code></td>
<td>
<p>Other arguments to match the generic for 'summary'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a displayed summary of the functional data object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
</p>

<hr>
<h2 id='summary.fdPar'>
Summarize a Functional Parameter Object
</h2><span id='topic+summary.fdPar'></span>

<h3>Description</h3>

<p>Provide a compact summary of the characteristics of a functional
parameter object (i.e., class 'fdPar').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fdPar'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.fdPar_+3A_object">object</code></td>
<td>

<p>a functional parameter object.
</p>
</td></tr>
<tr><td><code id="summary.fdPar_+3A_...">...</code></td>
<td>
<p>Other arguments to match the generic 'summary' function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a displayed summary of the functional parameter object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
</p>

<hr>
<h2 id='summary.Lfd'>
Summarize a Linear Differential Operator Object
</h2><span id='topic+summary.Lfd'></span>

<h3>Description</h3>

<p>Provide a compact summary of the characteristics of a
linear differential operator object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Lfd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Lfd_+3A_object">object</code></td>
<td>

<p>a linear differential operator object.
</p>
</td></tr>
<tr><td><code id="summary.Lfd_+3A_...">...</code></td>
<td>
<p>Other arguments to match the generic 'summary' function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a displayed summary of the linear differential operator object.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>,
</p>

<hr>
<h2 id='surp.fit'>
Evaluate the fit of surprisal curves to binned psychometric data.
</h2><span id='topic+surp.fit'></span>

<h3>Description</h3>

<p>Evaluate the error sum of squares, its gradient and its hessian for the fit of 
surprisal curves to binned psychometric data.  The function value is optimized
by function <code>smooth.surp</code> in package <code>TestGardener.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surp.fit(x, surpList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surp.fit_+3A_x">x</code></td>
<td>
<p>The parameter vector, which is the vectorized form of the K by M-1   coefficient matrix for the functional data object.</p>
</td></tr>
<tr><td><code id="surp.fit_+3A_surplist">surpList</code></td>
<td>

<p>A named list object containing objects essential to evaluating the fitting 
criterion.  See <code>smooth.surp.R</code> for the composition of this list.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list object for the returned objects with these names:
</p>
<table role = "presentation">
<tr><td><code>PENSSE:</code></td>
<td>
<p>The error sum of squares associated with parameter value <code>x</code>.</p>
</td></tr>
<tr><td><code>DPENSSE:</code></td>
<td>
<p>A column vector containing gradient of the error sum of squares.</p>
</td></tr>
<tr><td><code>D2PENSSE:</code></td>
<td>
<p>A square matrix of hessian values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Juan Li and James Ramsay</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.surp">smooth.surp</a></code>
</p>

<hr>
<h2 id='symsolve'>
solve(A, B) where A is symmetric
</h2><span id='topic+symsolve'></span>

<h3>Description</h3>

<p>Solve A X = B for X where A is symmetric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symsolve(Asym, Bmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symsolve_+3A_asym">Asym</code></td>
<td>
<p> a symmetric matrix </p>
</td></tr>
<tr><td><code id="symsolve_+3A_bmat">Bmat</code></td>
<td>
<p> a square matrix of dimensions matching Asym </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix of the same dimenions as Asym and Bmat
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+solve">solve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(2,1,1,2), 2)
Ainv &lt;- symsolve(A, diag(2))
</code></pre>

<hr>
<h2 id='tperm.fd'>
Permutation t-test for two groups of functional data objects.
</h2><span id='topic+tperm.fd'></span>

<h3>Description</h3>

<p>tperm.fd creates a null distribution for a test of no difference
between two groups of functional data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tperm.fd(x1fd, x2fd, nperm=200, q=0.05, argvals=NULL, plotres=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tperm.fd_+3A_x1fd">x1fd</code></td>
<td>

<p>a functional data object giving the first group of functional
observations.
</p>
</td></tr>
<tr><td><code id="tperm.fd_+3A_x2fd">x2fd</code></td>
<td>

<p>a functional data object giving the second group of functional
observations.
</p>
</td></tr>
<tr><td><code id="tperm.fd_+3A_nperm">nperm</code></td>
<td>

<p>number of permutations to use in creating the null distribution.
</p>
</td></tr>
<tr><td><code id="tperm.fd_+3A_q">q</code></td>
<td>

<p>Critical upper-tail quantile of the null distribution to compare to
the observed t-statistic.
</p>
</td></tr>
<tr><td><code id="tperm.fd_+3A_argvals">argvals</code></td>
<td>

<p>If <code>yfdPar</code> is a <code>fd</code> object, the points at which to
evaluate the point-wise t-statistic.
</p>
</td></tr>
<tr><td><code id="tperm.fd_+3A_plotres">plotres</code></td>
<td>

<p>Argument to plot a visual display of the null distribution
displaying the <code>1-q</code>th quantile and observed t-statistic.
</p>
</td></tr>
<tr><td><code id="tperm.fd_+3A_...">...</code></td>
<td>

<p>Additional plotting arguments that can be used with <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The usual t-statistic is calculated pointwise and the test based on
the maximal value.  If <code>argvals</code> is not specified, it defaults
to 101 equally-spaced points on the range of <code>yfdPar</code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>pval</code></td>
<td>
<p>the observed p-value of the permutation test.</p>
</td></tr>
<tr><td><code>qval</code></td>
<td>
<p>the <code>q</code>th quantile of the null distribution.</p>
</td></tr>
<tr><td><code>Tobs</code></td>
<td>
<p>the observed maximal t-statistic.</p>
</td></tr>
<tr><td><code>Tnull</code></td>
<td>

<p>a vector of length <code>nperm</code> giving the observed values of the
permutation distribution.
</p>
</td></tr>
<tr><td><code>Tvals</code></td>
<td>
<p>the pointwise values of the observed t-statistic.</p>
</td></tr>
<tr><td><code>Tnullvals</code></td>
<td>

<p>the pointwise values of of the permutation observations.
</p>
</td></tr>
<tr><td><code>pvals.pts</code></td>
<td>
<p>pointwise p-values of the t-statistic.</p>
</td></tr>
<tr><td><code>qvals.pts</code></td>
<td>

<p>pointwise <code>q</code>th quantiles of the null distribution
</p>
</td></tr>
<tr><td><code>argvals</code></td>
<td>

<p>argument values for evaluating the F-statistic if <code>yfdPar</code>is
a functional data object.
</p>
</td></tr>
</table>


<h3>Side Effects</h3>

<p>a plot of the functional observations
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fRegress">fRegress</a></code>
<code><a href="#topic+Fstat.fd">Fstat.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
# This tests the difference between boys and girls heights in the
# Berkeley growth data.

# First set up a basis system to hold the smooths

knots    &lt;- growth$age
norder   &lt;- 6
nbasis   &lt;- length(knots) + norder - 2
hgtbasis &lt;- create.bspline.basis(range(knots), nbasis, norder, knots)

# Now smooth with a fourth-derivative penalty and a very small smoothing
# parameter

Lfdobj &lt;- 4
lambda &lt;- 1e-2
growfdPar &lt;- fdPar(fd(matrix(0,nbasis,1), hgtbasis), Lfdobj, lambda)

hgtmfd &lt;- smooth.basis(growth$age, growth$hgtm, growfdPar)$fd
hgtffd &lt;- smooth.basis(growth$age, growth$hgtf, growfdPar)$fd

# Call tperm.fd

tres &lt;- tperm.fd(hgtmfd,hgtffd)
par(oldpar)
</code></pre>

<hr>
<h2 id='trapzmat'>
Approximate the functional inner product of two functional data objects using the 
trapezpoidal rule over a fine mesh of value.
</h2><span id='topic+trapzmat'></span>

<h3>Description</h3>

<p>The first two arguments are matrices of values of two functional data objects
of the same fine mesh of argument values.  The mesh is assumed to be equally spaced.</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapzmat(X,Y,delta=1,wt=rep(1,n))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trapzmat_+3A_x">X</code></td>
<td>
<p>The first matrix of functional data object values over a fine mesh.</p>
</td></tr>
<tr><td><code id="trapzmat_+3A_y">Y</code></td>
<td>
<p>The second matrix of functional data object values over the same fine mesh.</p>
</td></tr>
<tr><td><code id="trapzmat_+3A_delta">delta</code></td>
<td>
<p>The difference between adjacent argument values, assumed to 
be a constant.</p>
</td></tr>
<tr><td><code id="trapzmat_+3A_wt">wt</code></td>
<td>
<p>An optional vector of weights for the products of pairs of argument 
values, otherwise assumed to be all ones.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of approximate inner products.  The number of rows the number of 
columns of <code>X</code> and the number of columns is the number of columns of 
<code>Y</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inprod">inprod</a></code>,
<code><a href="#topic+inprod.bspline">inprod.bspline</a></code>
</p>

<hr>
<h2 id='var.fd'>
Variance, Covariance, and Correlation Surfaces for
Functional Data Object(s)   
</h2><span id='topic+var.fd'></span>

<h3>Description</h3>

<p>Compute variance, covariance, and / or correlation functions for
functional data.  
</p>
<p>These are two-argument functions and therefore define surfaces. If
only one functional data object is supplied, its variance or
correlation function is computed.  If two are supplied, the covariance
or correlation function between them is 
computed.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.fd(fdobj1, fdobj2=fdobj1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.fd_+3A_fdobj1">fdobj1</code>, <code id="var.fd_+3A_fdobj2">fdobj2</code></td>
<td>

<p>a functional data object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a two-argument or bivariate functional data object representing the
variance, covariance or correlation surface for a single functional
data object or the covariance between two functional data objects or
between different variables in a multivariate functional data object.
</p>


<h3>Value</h3>

<p>An list object of class <code>bifd</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>coefs</code></td>
<td>

<p>the coefficient array with dimensions fdobj1[[&quot;basis&quot;]][[&quot;nbasis&quot;]]
by fdobj2[[&quot;basis&quot;]][[&quot;nbasis&quot;]] giving the coefficients of the 
covariance matrix in terms of the bases used by fdobj1 and
fdobj2.  
</p>
</td></tr>
<tr><td><code>sbasis</code></td>
<td>

<p>fdobj1[[&quot;basis&quot;]]
</p>
</td></tr>
<tr><td><code>tbasis</code></td>
<td>

<p>fdobj2[[&quot;basis&quot;]]
</p>
</td></tr>
<tr><td><code>bifdnames</code></td>
<td>

<p>dimnames list for a 4-dimensional 'coefs' array.  If
length(dim(coefs)) is only 2 or 3, the last 2 or 1 component of
bifdnames is not used with dimnames(coefs).  
</p>
</td></tr>
</table>
<p>Examples below illustrate this structure in simple
cases.  
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.fd">mean.fd</a></code>, 
<code><a href="#topic+sd.fd">sd.fd</a></code>, 
<code><a href="#topic+std.fd">std.fd</a></code>
<code><a href="#topic+stdev.fd">stdev.fd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldpar &lt;- par(no.readonly=TRUE)
##
## Example with 2 different bases 
##
daybasis3 &lt;- create.fourier.basis(c(0, 365))
daybasis5 &lt;- create.fourier.basis(c(0, 365), 5)
tempfd3 &lt;- with(CanadianWeather, smooth.basis(day.5, 
       dailyAv[,,"Temperature.C"], 
       daybasis3, fdnames=list("Day", "Station", "Deg C"))$fd )
precfd5 &lt;- with(CanadianWeather, smooth.basis(day.5, 
       dailyAv[,,"log10precip"],
       daybasis5, fdnames=list("Day", "Station", "Deg C"))$fd )

# Compare with structure described above under 'value':
str(tempPrecVar3.5 &lt;- var.fd(tempfd3, precfd5))

##
## The following produces contour and perspective plots
##

# Evaluate at a 53 by 53 grid for plotting

daybasis65 &lt;- create.fourier.basis(rangeval=c(0, 365), nbasis=65)

daytempfd &lt;- with(CanadianWeather, smooth.basis(day.5, 
       dailyAv[,,"Temperature.C"],
       daybasis65, fdnames=list("Day", "Station", "Deg C"))$fd )
str(tempvarbifd &lt;- var.fd(daytempfd))

str(tempvarmat  &lt;- eval.bifd(weeks,weeks,tempvarbifd))
# dim(tempvarmat)= c(53, 53)

par(mfrow=c(1,2), pty="s")
#contour(tempvarmat, xlab="Days", ylab="Days")
contour(weeks, weeks, tempvarmat, 
        xlab="Daily Average Temperature",
        ylab="Daily Average Temperature",
        main=paste("Variance function across locations\n",
          "for Canadian Anual Temperature Cycle"),
        cex.main=0.8, axes=FALSE)
axisIntervals(1, atTick1=seq(0, 365, length=5), atTick2=NA, 
            atLabels=seq(1/8, 1, 1/4)*365,
            labels=paste("Q", 1:4) )
axisIntervals(2, atTick1=seq(0, 365, length=5), atTick2=NA, 
            atLabels=seq(1/8, 1, 1/4)*365,
            labels=paste("Q", 1:4) )
persp(weeks, weeks, tempvarmat,
      xlab="Days", ylab="Days", zlab="Covariance")
mtext("Temperature Covariance", line=-4, outer=TRUE)
par(oldpar)

</code></pre>

<hr>
<h2 id='varmx'>
Rotate a Matrix of Component Loadings using the VARIMAX Criterion
</h2><span id='topic+varmx'></span>

<h3>Description</h3>

<p>The matrix being rotated contains the values of the component
functional data objects computed in either a principal
components analysis or a canonical correlation analysis.
The values are computed over a fine mesh of argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varmx(amat, normalize=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varmx_+3A_amat">amat</code></td>
<td>

<p>the matrix to be rotated.  The number of rows is
equal to the number of argument values <code>nx</code> used
in a fine mesh.  The number of columns is the number of
components to be rotated.
</p>
</td></tr>
<tr><td><code id="varmx_+3A_normalize">normalize</code></td>
<td>

<p>either <code>TRUE</code> or <code>FALSE</code>.  If <code>TRUE</code>, the columns of
<code>amat</code> are normalized prior to computing the rotation
matrix.  However, this is seldom needed for functional data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The VARIMAX criterion is the variance of the squared component values.
As this criterion is maximized with respect to a rotation of the
space spanned by the columns of the matrix, the squared loadings
tend more and more to be either near 0 or near 1, and this tends to
help with the process of labelling or interpreting the rotated matrix.
</p>


<h3>Value</h3>

<p>a square rotation matrix of order equal to the number
of components that are rotated.  A rotation matrix
$T$ has that property that $T'T = TT' = I$.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varmx.pca.fd">varmx.pca.fd</a></code>,
<code><a href="#topic+varmx.cca.fd">varmx.cca.fd</a></code>
</p>

<hr>
<h2 id='varmx.cca.fd'>
Rotation of Functional Canonical Components with VARIMAX
</h2><span id='topic+varmx.cca.fd'></span>

<h3>Description</h3>

<p>Results of canonical correlation analysis are often easier to interpret if
they are rotated.  Among the many possible ways in which this rotation can be
defined, the VARIMAX criterion seems to give satisfactory results most
of the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varmx.cca.fd(ccafd, nx=201)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varmx.cca.fd_+3A_ccafd">ccafd</code></td>
<td>

<p>an object of class &quot;cca.fd&quot; that is produced by function
<code>cca.fd</code>.
</p>
</td></tr>
<tr><td><code id="varmx.cca.fd_+3A_nx">nx</code></td>
<td>

<p>the number of points in a fine mesh of points that is
required to approximate canonical variable functional
data objects.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rotated version of argument <code>cca.fd</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varmx">varmx</a></code>, 
<code><a href="#topic+varmx.pca.fd">varmx.pca.fd</a></code>
</p>

<hr>
<h2 id='varmx.pca.fd'>
Rotation of Functional Principal Components with VARIMAX
Criterion
</h2><span id='topic+varmx.pca.fd'></span>

<h3>Description</h3>

<p>Principal components are often easier to interpret if they are
rotated.  Among the many possible ways in which this rotation can be
defined, the VARIMAX criterion seems to give satisfactory results most
of the time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varmx.pca.fd(pcafd, nharm=scoresd[2], nx=501)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varmx.pca.fd_+3A_pcafd">pcafd</code></td>
<td>

<p>an object of class <code>pca.fd</code> that is produced by function
<code>pca.fd</code>.
</p>
</td></tr>
<tr><td><code id="varmx.pca.fd_+3A_nharm">nharm</code></td>
<td>

<p>the number of harmonics or principal components to be
rotated.
</p>
</td></tr>
<tr><td><code id="varmx.pca.fd_+3A_nx">nx</code></td>
<td>

<p>the number of argument values in a fine mesh
used to define the harmonics to be
rotated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rotated principal components analysis object of class <code>pca.fd</code>.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varmx">varmx</a></code>, 
<code><a href="#topic+varmx.cca.fd">varmx.cca.fd</a></code>
</p>

<hr>
<h2 id='vec2Lfd'>
Make a Linear Differential Operator Object from a Vector
</h2><span id='topic+vec2Lfd'></span>

<h3>Description</h3>

<p>A linear differential operator object of order $m$ is
constructed from the number in a vector of length $m$.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2Lfd(bwtvec, rangeval=c(0,1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec2Lfd_+3A_bwtvec">bwtvec</code></td>
<td>

<p>a vector of coefficients to define the linear differential
operator object
</p>
</td></tr>
<tr><td><code id="vec2Lfd_+3A_rangeval">rangeval</code></td>
<td>

<p>a vector of length 2 specifying the range over which the
operator is defined
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a linear differential operator object
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+int2Lfd">int2Lfd</a></code>,
<code><a href="#topic+Lfd">Lfd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#  define the harmonic acceleration operator used in the
#  analysis of the daily temperature data
Lcoef &lt;- c(0,(2*pi/365)^2,0)
harmaccelLfd &lt;- vec2Lfd(Lcoef, c(0,365))

hmat &lt;- vec2Lfd(matrix(Lcoef, 1), c(0, 365))


all.equal(harmaccelLfd, hmat)


</code></pre>

<hr>
<h2 id='wtcheck'>
Check a vector of weights
</h2><span id='topic+wtcheck'></span>

<h3>Description</h3>

<p>Throws an error if <code>wtvec</code> is not <code>n</code> positive numbers, and
return <code>wtvec</code> (stripped of any <code>dim</code> atrribute)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtcheck(n, wtvec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wtcheck_+3A_n">n</code></td>
<td>
<p> the required length of <code>wtvec</code> </p>
</td></tr>
<tr><td><code id="wtcheck_+3A_wtvec">wtvec</code></td>
<td>
<p> an object to be checked </p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of <code>n</code> positive numbers
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wtcheck(3, 1:3)
wtcheck(2, matrix(1:2, 2))
</code></pre>

<hr>
<h2 id='ycheck'>
Check Data Arrays for Smoothing Functions
</h2><span id='topic+ycheck'></span>

<h3>Description</h3>

<p>Check a numeric vector, a matrix or an array of data values for consistency
with the number of argument values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ycheck(y, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ycheck_+3A_y">y</code></td>
<td>
<p>A numeric vector, matrix, or 3D array, with first dimension size 
<code>n</code>.</p>
</td></tr>
<tr><td><code id="ycheck_+3A_n">n</code></td>
<td>
<p>The number of argument values for smoothing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Argument <code>y</code> is returned if it checks out, converted to a one-column
matrix if the input was a numeric vector.</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.basis1">smooth.basis1</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+smooth.pos">smooth.pos</a></code>,
<code><a href="#topic+smooth.monotone">smooth.monotone</a></code>,
<code><a href="#topic+smooth.surp">smooth.surp</a></code>
</p>

<hr>
<h2 id='zerobasis'>
Orthonormal Matrix with Columns Summing to Zero</h2><span id='topic+zerobasis'></span>

<h3>Description</h3>

<p>The matrix is k by k-1, columns are orthonormal and sum to zero. This matrix
is used when quantities are unchanged to adding a constant, such as in
multinomial data modelling.</p>


<h3>Usage</h3>

<pre><code class='language-R'>zerobasis(k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zerobasis_+3A_k">k</code></td>
<td>
<p>A positive integer greater than one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are many ways of generating these matrix. This functions uses
the discrete Fourier series less the constant vector.</p>


<h3>Value</h3>

<p>A <code>k</code> by <code>k-1</code> matrix with orthonormal columns that sum to zero.
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smooth.surp">smooth.surp</a></code>,
<code><a href="#topic+eval.surp">eval.surp</a></code>
</p>

<hr>
<h2 id='zerofind'>
Does the range of the input contain 0?  
</h2><span id='topic+zerofind'></span>

<h3>Description</h3>

<p>Returns TRUE if range of the argument includes 0 and FALSE if not.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  zerofind(fmat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zerofind_+3A_fmat">fmat</code></td>
<td>

<p>An object from which 'range' returns two numbers.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value TRUE or FALSE.  
</p>


<h3>References</h3>

<p>Ramsay, James O., Hooker, Giles, and Graves, Spencer (2009),
<em>Functional data analysis with R and Matlab</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2005), 
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Ramsay, James O., and Silverman, Bernard W. (2002), 
<em>Applied Functional Data Analysis</em>, Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+range">range</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zerofind(1:5)
# FALSE
zerofind(0:3)
# TRUE 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
