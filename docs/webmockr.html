<!DOCTYPE html><html><head><title>Help for package webmockr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {webmockr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#webmockr-package'><p>webmockr</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#BodyPattern'><p>BodyPattern</p></a></li>
<li><a href='#build_crul_request'><p>Build a crul request</p></a></li>
<li><a href='#build_crul_response'><p>Build a crul response</p></a></li>
<li><a href='#build_httr_request'><p>Build a httr request</p></a></li>
<li><a href='#build_httr_response'><p>Build a httr response</p></a></li>
<li><a href='#CrulAdapter'><p>Adapters for Modifying HTTP Requests</p></a></li>
<li><a href='#enable'><p>Enable or disable webmockr</p></a></li>
<li><a href='#HashCounter'><p>HashCounter</p></a></li>
<li><a href='#HeadersPattern'><p>HeadersPattern</p></a></li>
<li><a href='#HttpLibAdapaterRegistry'><p>HttpLibAdapaterRegistry</p></a></li>
<li><a href='#httr_mock'><p>Turn on httr mocking</p>
Sets a callback that routes httr request through webmockr</a></li>
<li><a href='#MethodPattern'><p>MethodPattern</p></a></li>
<li><a href='#mock_file'><p>Mock file</p></a></li>
<li><a href='#mocking-disk-writing'><p>Mocking writing to disk</p></a></li>
<li><a href='#pluck_body'><p>Extract the body from an HTTP request</p></a></li>
<li><a href='#remove_request_stub'><p>Remove a request stub</p></a></li>
<li><a href='#request_registry'><p>List or clear requests in the request registry</p></a></li>
<li><a href='#RequestPattern'><p>RequestPattern class</p></a></li>
<li><a href='#RequestRegistry'><p>RequestRegistry</p></a></li>
<li><a href='#RequestSignature'><p>RequestSignature</p></a></li>
<li><a href='#Response'><p>Response</p></a></li>
<li><a href='#stub_registry'><p>List stubs in the stub registry</p></a></li>
<li><a href='#stub_registry_clear'><p>stub_registry_clear</p></a></li>
<li><a href='#stub_request'><p>Stub an http request</p></a></li>
<li><a href='#StubbedRequest'><p>StubbedRequest</p></a></li>
<li><a href='#StubCounter'><p>StubCounter</p></a></li>
<li><a href='#StubRegistry'><p>StubRegistry</p></a></li>
<li><a href='#to_raise'><p>Set raise error condition</p></a></li>
<li><a href='#to_return'><p>Expectation for what's returned from a stubbed request</p></a></li>
<li><a href='#to_return_'><p>This function is defunct.</p></a></li>
<li><a href='#to_timeout'><p>Set timeout as an expected return on a match</p></a></li>
<li><a href='#UriPattern'><p>UriPattern</p></a></li>
<li><a href='#webmockr_configure'><p>webmockr configuration</p></a></li>
<li><a href='#webmockr_crul_fetch'><p>execute a curl request</p></a></li>
<li><a href='#webmockr_disable'><p>This function is defunct.</p></a></li>
<li><a href='#webmockr_enable'><p>This function is defunct.</p></a></li>
<li><a href='#webmockr_reset'><p>webmockr_reset</p></a></li>
<li><a href='#webmockr-defunct'><p>Defunct functions in <span class="pkg">webmockr</span></p></a></li>
<li><a href='#wi_th'><p>Set additional parts of a stubbed request</p></a></li>
<li><a href='#wi_th_'><p>This function is defunct.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stubbing and Setting Expectations on 'HTTP' Requests</td>
</tr>
<tr>
<td>Description:</td>
<td>Stubbing and setting expectations on 'HTTP' requests.
    Includes tools for stubbing 'HTTP' requests, including expected
    request conditions and response conditions. Match on
    'HTTP' method, query parameters, request body, headers and
    more. Can be used for unit tests or outside of a testing 
    context.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/webmockr">https://github.com/ropensci/webmockr</a> (devel)
<a href="https://books.ropensci.org/http-testing/">https://books.ropensci.org/http-testing/</a> (user manual)
<a href="https://docs.ropensci.org/webmockr/">https://docs.ropensci.org/webmockr/</a> (documentation)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/webmockr/issues">https://github.com/ropensci/webmockr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>curl, jsonlite, magrittr (&ge; 1.5), R6 (&ge; 2.1.3), urltools (&ge;
1.6.0), fauxpas, crul (&ge; 0.7.0), base64enc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, xml2, vcr, httr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Web</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>http, https, API, web-services, curl, mock,
mocking, fakeweb, http-mocking, testing, testing-tools, tdd</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-28 14:32:51 UTC; sckott</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Aaron Wolen <a href="https://orcid.org/0000-0003-2542-2202"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  rOpenSci [fnd] (https://ropensci.org)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Chamberlain &lt;myrmecocystus+r@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-28 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='webmockr-package'>webmockr</h2><span id='topic+webmockr-package'></span><span id='topic+webmockr'></span>

<h3>Description</h3>

<p>Stubbing and setting expectations on HTTP requests
</p>


<h3>Features</h3>


<ul>
<li><p> Stubbing HTTP requests at low http client lib level
</p>
</li>
<li><p> Setting and verifying expectations on HTTP requests
</p>
</li>
<li><p> Matching requests based on method, URI, headers and body
</p>
</li>
<li><p> Supports multiple HTTP libraries, including <span class="pkg">crul</span> and
<span class="pkg">httr</span>
</p>
</li>
<li><p> Integration with HTTP test caching library <span class="pkg">vcr</span>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Scott Chamberlain <a href="mailto:myrmecocystus+r@gmail.com">myrmecocystus+r@gmail.com</a>
</p>
<p>Aaron Wolen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(webmockr)
stub_request("get", "https://httpbin.org/get")
stub_request("post", "https://httpbin.org/post")
stub_registry()
</code></pre>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='BodyPattern'>BodyPattern</h2><span id='topic+BodyPattern'></span>

<h3>Description</h3>

<p>body matcher
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>pattern</code></dt><dd><p>a list</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-BodyPattern-new"><code>BodyPattern$new()</code></a>
</p>
</li>
<li> <p><a href="#method-BodyPattern-matches"><code>BodyPattern$matches()</code></a>
</p>
</li>
<li> <p><a href="#method-BodyPattern-to_s"><code>BodyPattern$to_s()</code></a>
</p>
</li>
<li> <p><a href="#method-BodyPattern-clone"><code>BodyPattern$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-BodyPattern-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>BodyPattern</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>BodyPattern$new(pattern)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern</code></dt><dd><p>(list) a body object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>BodyPattern</code> object
</p>


<hr>
<a id="method-BodyPattern-matches"></a>



<h4>Method <code>matches()</code></h4>

<p>Match a request body pattern against a pattern
</p>


<h5>Usage</h5>

<div class="r"><pre>BodyPattern$matches(body, content_type = "")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>body</code></dt><dd><p>(list) the body</p>
</dd>
<dt><code>content_type</code></dt><dd><p>(character) content type</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-BodyPattern-to_s"></a>



<h4>Method <code>to_s()</code></h4>

<p>Print pattern for easy human consumption
</p>


<h5>Usage</h5>

<div class="r"><pre>BodyPattern$to_s()</pre></div>



<h5>Returns</h5>

<p>a string
</p>


<hr>
<a id="method-BodyPattern-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>BodyPattern$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># make a request signature
bb &lt;- RequestSignature$new(
  method = "get",
  uri = "https:/httpbin.org/get",
  options = list(
    body = list(foo = "bar", a = 5)
  )
)

# make body pattern object
## FALSE
z &lt;- BodyPattern$new(pattern = list(foo = "bar"))
z$pattern
z$matches(bb$body)
## TRUE
z &lt;- BodyPattern$new(pattern = list(foo = "bar", a = 5))
z$pattern
z$matches(bb$body)

# uploads in bodies
## upload NOT in a list
bb &lt;- RequestSignature$new(
  method = "post", uri = "https:/httpbin.org/post",
  options = list(body = crul::upload(system.file("CITATION"))))
bb$body
z &lt;- BodyPattern$new(pattern = 
  crul::upload(system.file("CITATION")))
z$pattern
z$matches(bb$body)

## upload in a list
bb &lt;- RequestSignature$new(
  method = "post", uri = "https:/httpbin.org/post",
  options = list(body = list(y = crul::upload(system.file("CITATION")))))
bb$body
z &lt;- BodyPattern$new(pattern =
  list(y = crul::upload(system.file("CITATION"))))
z$pattern
z$matches(bb$body)
</code></pre>

<hr>
<h2 id='build_crul_request'>Build a crul request</h2><span id='topic+build_crul_request'></span>

<h3>Description</h3>

<p>Build a crul request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_crul_request(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_crul_request_+3A_x">x</code></td>
<td>
<p>an unexecuted crul request object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a crul request
</p>

<hr>
<h2 id='build_crul_response'>Build a crul response</h2><span id='topic+build_crul_response'></span>

<h3>Description</h3>

<p>Build a crul response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_crul_response(req, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_crul_response_+3A_req">req</code></td>
<td>
<p>a request</p>
</td></tr>
<tr><td><code id="build_crul_response_+3A_resp">resp</code></td>
<td>
<p>a response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a crul response
</p>

<hr>
<h2 id='build_httr_request'>Build a httr request</h2><span id='topic+build_httr_request'></span>

<h3>Description</h3>

<p>Build a httr request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_httr_request(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_httr_request_+3A_x">x</code></td>
<td>
<p>an unexecuted httr request object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a httr request
</p>

<hr>
<h2 id='build_httr_response'>Build a httr response</h2><span id='topic+build_httr_response'></span>

<h3>Description</h3>

<p>Build a httr response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_httr_response(req, resp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_httr_response_+3A_req">req</code></td>
<td>
<p>a request</p>
</td></tr>
<tr><td><code id="build_httr_response_+3A_resp">resp</code></td>
<td>
<p>a response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a httr response
</p>

<hr>
<h2 id='CrulAdapter'>Adapters for Modifying HTTP Requests</h2><span id='topic+CrulAdapter'></span><span id='topic+HttrAdapter'></span><span id='topic+Adapter'></span>

<h3>Description</h3>

<p><code>Adapter</code> is the base parent class used to implement
<span class="pkg">webmockr</span> support for different HTTP clients. It should not be used
directly. Instead, use one of the client-specific adapters that webmockr
currently provides:
</p>

<ul>
<li> <p><code>CrulAdapter</code> for <span class="pkg">crul</span>
</p>
</li>
<li> <p><code>HttrAdapter</code> for <span class="pkg">httr</span>
</p>
</li></ul>



<h3>Details</h3>

<p>Note that the documented fields and methods are the same across all
client-specific adapters.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+Adapter">webmockr::Adapter</a></code> -&gt; <code>CrulAdapter</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>client</code></dt><dd><p>HTTP client package name</p>
</dd>
<dt><code>name</code></dt><dd><p>adapter name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CrulAdapter-clone"><code>CrulAdapter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="disable"><a href='../../webmockr/html/Adapter.html#method-Adapter-disable'><code>webmockr::Adapter$disable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="enable"><a href='../../webmockr/html/Adapter.html#method-Adapter-enable'><code>webmockr::Adapter$enable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="handle_request"><a href='../../webmockr/html/Adapter.html#method-Adapter-handle_request'><code>webmockr::Adapter$handle_request()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="initialize"><a href='../../webmockr/html/Adapter.html#method-Adapter-initialize'><code>webmockr::Adapter$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="remove_stubs"><a href='../../webmockr/html/Adapter.html#method-Adapter-remove_stubs'><code>webmockr::Adapter$remove_stubs()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CrulAdapter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CrulAdapter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Super class</h3>

<p><code><a href="#topic+Adapter">webmockr::Adapter</a></code> -&gt; <code>HttrAdapter</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>client</code></dt><dd><p>HTTP client package name</p>
</dd>
<dt><code>name</code></dt><dd><p>adapter name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HttrAdapter-clone"><code>HttrAdapter$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="disable"><a href='../../webmockr/html/Adapter.html#method-Adapter-disable'><code>webmockr::Adapter$disable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="enable"><a href='../../webmockr/html/Adapter.html#method-Adapter-enable'><code>webmockr::Adapter$enable()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="handle_request"><a href='../../webmockr/html/Adapter.html#method-Adapter-handle_request'><code>webmockr::Adapter$handle_request()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="initialize"><a href='../../webmockr/html/Adapter.html#method-Adapter-initialize'><code>webmockr::Adapter$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="webmockr" data-topic="Adapter" data-id="remove_stubs"><a href='../../webmockr/html/Adapter.html#method-Adapter-remove_stubs'><code>webmockr::Adapter$remove_stubs()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-HttrAdapter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HttrAdapter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>client</code></dt><dd><p>HTTP client package name</p>
</dd>
<dt><code>name</code></dt><dd><p>adapter name</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Adapter-new"><code>Adapter$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Adapter-enable"><code>Adapter$enable()</code></a>
</p>
</li>
<li> <p><a href="#method-Adapter-disable"><code>Adapter$disable()</code></a>
</p>
</li>
<li> <p><a href="#method-Adapter-handle_request"><code>Adapter$handle_request()</code></a>
</p>
</li>
<li> <p><a href="#method-Adapter-remove_stubs"><code>Adapter$remove_stubs()</code></a>
</p>
</li>
<li> <p><a href="#method-Adapter-clone"><code>Adapter$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Adapter-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new Adapter object
</p>


<h5>Usage</h5>

<div class="r"><pre>Adapter$new()</pre></div>


<hr>
<a id="method-Adapter-enable"></a>



<h4>Method <code>enable()</code></h4>

<p>Enable the adapter
</p>


<h5>Usage</h5>

<div class="r"><pre>Adapter$enable(quiet = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quiet</code></dt><dd><p>(logical) suppress messages? default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>TRUE</code>, invisibly
</p>


<hr>
<a id="method-Adapter-disable"></a>



<h4>Method <code>disable()</code></h4>

<p>Disable the adapter
</p>


<h5>Usage</h5>

<div class="r"><pre>Adapter$disable(quiet = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>quiet</code></dt><dd><p>(logical) suppress messages? default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code>FALSE</code>, invisibly
</p>


<hr>
<a id="method-Adapter-handle_request"></a>



<h4>Method <code>handle_request()</code></h4>

<p>All logic for handling a request
</p>


<h5>Usage</h5>

<div class="r"><pre>Adapter$handle_request(req)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt><dd><p>a request</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>various outcomes
</p>


<hr>
<a id="method-Adapter-remove_stubs"></a>



<h4>Method <code>remove_stubs()</code></h4>

<p>Remove all stubs
</p>


<h5>Usage</h5>

<div class="r"><pre>Adapter$remove_stubs()</pre></div>



<h5>Returns</h5>

<p>nothing returned; removes all request stubs
</p>


<hr>
<a id="method-Adapter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Adapter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("httr", quietly = TRUE)) {
# library(httr)

# normal httr request, works fine
# real &lt;- GET("https://httpbin.org/get")
# real

# with webmockr
# library(webmockr)
## turn on httr mocking
# httr_mock()
## now this request isn't allowed
# GET("https://httpbin.org/get")
## stub the request
# stub_request('get', uri = 'https://httpbin.org/get') %&gt;%
#   wi_th(
#     headers = list('Accept' = 'application/json, text/xml, application/xml, */*')
#   ) %&gt;%
#   to_return(status = 418, body = "I'm a teapot!", headers = list(a = 5))
## now the request succeeds and returns a mocked response
# (res &lt;- GET("https://httpbin.org/get"))
# res$status_code
# rawToChar(res$content)

# allow real requests while webmockr is loaded
# webmockr_allow_net_connect()
# webmockr_net_connect_allowed()
# GET("https://httpbin.org/get?animal=chicken")
# webmockr_disable_net_connect()
# webmockr_net_connect_allowed()
# GET("https://httpbin.org/get?animal=chicken")

# httr_mock(FALSE)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='enable'>Enable or disable webmockr</h2><span id='topic+enable'></span><span id='topic+enabled'></span><span id='topic+disable'></span>

<h3>Description</h3>

<p>Enable or disable webmockr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enable(adapter = NULL, options = list(), quiet = FALSE)

enabled(adapter = "crul")

disable(adapter = NULL, options = list(), quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enable_+3A_adapter">adapter</code></td>
<td>
<p>(character) the adapter name, 'crul' or 'httr'.
one or the other. if none given, we attempt to enable both
adapters</p>
</td></tr>
<tr><td><code id="enable_+3A_options">options</code></td>
<td>
<p>list of options - ignored for now.</p>
</td></tr>
<tr><td><code id="enable_+3A_quiet">quiet</code></td>
<td>
<p>(logical) suppress messages? default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>enable()</code> enables <span class="pkg">webmockr</span> for all adapters.
<code>disable()</code> disables <span class="pkg">webmockr</span> for all adapters.  <code>enabled()</code>
answers whether <span class="pkg">webmockr</span> is enabled for a given adapter
</p>


<h3>Value</h3>

<p><code>enable()</code> and <code>disable()</code> invisibly returns booleans for
each adapter, as a result of running enable or disable, respectively,
on each <a href="#topic+HttpLibAdapaterRegistry">HttpLibAdapaterRegistry</a> object. <code>enabled</code> returns a
single boolean
</p>

<hr>
<h2 id='HashCounter'>HashCounter</h2><span id='topic+HashCounter'></span>

<h3>Description</h3>

<p>hash with counter, to store requests, and count each time
it is used
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>hash</code></dt><dd><p>(list) a list for internal use only, with elements
<code>key</code>, <code>sig</code>, and <code>count</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HashCounter-put"><code>HashCounter$put()</code></a>
</p>
</li>
<li> <p><a href="#method-HashCounter-get"><code>HashCounter$get()</code></a>
</p>
</li>
<li> <p><a href="#method-HashCounter-clone"><code>HashCounter$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HashCounter-put"></a>



<h4>Method <code>put()</code></h4>

<p>Register a request by it's key
</p>


<h5>Usage</h5>

<div class="r"><pre>HashCounter$put(req_sig)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req_sig</code></dt><dd><p>an object of class <code>RequestSignature</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; registers request and iterates
internal counter
</p>


<hr>
<a id="method-HashCounter-get"></a>



<h4>Method <code>get()</code></h4>

<p>Get a request by key
</p>


<h5>Usage</h5>

<div class="r"><pre>HashCounter$get(req_sig)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req_sig</code></dt><dd><p>an object of class <code>RequestSignature</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>(integer) the count of how many times the request has been made
</p>


<hr>
<a id="method-HashCounter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HashCounter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other request-registry: 
<code><a href="#topic+RequestRegistry">RequestRegistry</a></code>,
<code><a href="#topic+request_registry">request_registry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- HashCounter$new()
x$hash
z &lt;- RequestSignature$new(method = "get", uri = "https:/httpbin.org/get")
x$put(z)
x$hash
x$get(z)
x$put(z)
x$get(z)
</code></pre>

<hr>
<h2 id='HeadersPattern'>HeadersPattern</h2><span id='topic+HeadersPattern'></span>

<h3>Description</h3>

<p>headers matcher
</p>


<h3>Details</h3>

<p><code>webmockr</code> normalises headers and treats all forms of same headers as equal:
i.e the following two sets of headers are equal:
<code>list(Header1 = "value1", content_length = 123, X_CuStOm_hEAder = "foo")</code>
and
<code>list(header1 = "value1", "Content-Length" = 123, "x-cuSTOM-HeAder" = "foo")</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>pattern</code></dt><dd><p>a list</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HeadersPattern-new"><code>HeadersPattern$new()</code></a>
</p>
</li>
<li> <p><a href="#method-HeadersPattern-matches"><code>HeadersPattern$matches()</code></a>
</p>
</li>
<li> <p><a href="#method-HeadersPattern-empty_headers"><code>HeadersPattern$empty_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-HeadersPattern-to_s"><code>HeadersPattern$to_s()</code></a>
</p>
</li>
<li> <p><a href="#method-HeadersPattern-clone"><code>HeadersPattern$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HeadersPattern-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>HeadersPattern</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>HeadersPattern$new(pattern)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern</code></dt><dd><p>(list) a pattern, as a named list, must be named,
e.g,. <code>list(a = 5, b = 6)</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>HeadersPattern</code> object
</p>


<hr>
<a id="method-HeadersPattern-matches"></a>



<h4>Method <code>matches()</code></h4>

<p>Match a list of headers against that stored
</p>


<h5>Usage</h5>

<div class="r"><pre>HeadersPattern$matches(headers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>headers</code></dt><dd><p>(list) named list of headers, e.g,. <code>list(a = 5, b = 6)</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-HeadersPattern-empty_headers"></a>



<h4>Method <code>empty_headers()</code></h4>

<p>Are headers empty? tests if null or length==0
</p>


<h5>Usage</h5>

<div class="r"><pre>HeadersPattern$empty_headers(headers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>headers</code></dt><dd><p>named list of headers</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-HeadersPattern-to_s"></a>



<h4>Method <code>to_s()</code></h4>

<p>Print pattern for easy human consumption
</p>


<h5>Usage</h5>

<div class="r"><pre>HeadersPattern$to_s()</pre></div>



<h5>Returns</h5>

<p>a string
</p>


<hr>
<a id="method-HeadersPattern-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HeadersPattern$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- HeadersPattern$new(pattern = list(a = 5)))
x$pattern
x$matches(list(a = 5))

# different cases
(x &lt;- HeadersPattern$new(pattern = list(Header1 = "value1")))
x$pattern
x$matches(list(header1 = "value1"))
x$matches(list(header1 = "value2"))

# different symbols
(x &lt;- HeadersPattern$new(pattern = list(`Hello_World` = "yep")))
x$pattern
x$matches(list(`hello-world` = "yep"))
x$matches(list(`hello-worlds` = "yep"))

headers &lt;- list(
  'User-Agent' = 'Apple',
  'Accept-Encoding' = 'gzip, deflate', 
  'Accept' = 'application/json, text/xml, application/xml, */*')
(x &lt;- HeadersPattern$new(pattern = headers))
x$to_s()
x$pattern
x$matches(headers)
</code></pre>

<hr>
<h2 id='HttpLibAdapaterRegistry'>HttpLibAdapaterRegistry</h2><span id='topic+HttpLibAdapaterRegistry'></span>

<h3>Description</h3>

<p>http lib adapter registry
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>adapters</code></dt><dd><p>list</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-HttpLibAdapaterRegistry-print"><code>HttpLibAdapaterRegistry$print()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpLibAdapaterRegistry-register"><code>HttpLibAdapaterRegistry$register()</code></a>
</p>
</li>
<li> <p><a href="#method-HttpLibAdapaterRegistry-clone"><code>HttpLibAdapaterRegistry$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-HttpLibAdapaterRegistry-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>HttpLibAdapaterRegistry</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpLibAdapaterRegistry$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-HttpLibAdapaterRegistry-register"></a>



<h4>Method <code>register()</code></h4>

<p>Register an http library adapter
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpLibAdapaterRegistry$register(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an http lib adapter, e.g., <a href="#topic+CrulAdapter">CrulAdapter</a></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing, registers the library adapter
</p>


<hr>
<a id="method-HttpLibAdapaterRegistry-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>HttpLibAdapaterRegistry$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- HttpLibAdapaterRegistry$new()
x$register(CrulAdapter$new())
x
x$adapters
x$adapters[[1]]$name
</code></pre>

<hr>
<h2 id='httr_mock'>Turn on httr mocking
Sets a callback that routes httr request through webmockr</h2><span id='topic+httr_mock'></span>

<h3>Description</h3>

<p>Turn on httr mocking
Sets a callback that routes httr request through webmockr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httr_mock(on = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httr_mock_+3A_on">on</code></td>
<td>
<p>(logical) set to <code>TRUE</code> to turn on, and <code>FALSE</code>
to turn off. default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Silently returns <code>TRUE</code> when enabled and <code>FALSE</code> when disabled.
</p>

<hr>
<h2 id='MethodPattern'>MethodPattern</h2><span id='topic+MethodPattern'></span>

<h3>Description</h3>

<p>method matcher
</p>


<h3>Details</h3>

<p>Matches regardless of case. e.g., POST will match to post
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>pattern</code></dt><dd><p>(character) an http method</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-MethodPattern-new"><code>MethodPattern$new()</code></a>
</p>
</li>
<li> <p><a href="#method-MethodPattern-matches"><code>MethodPattern$matches()</code></a>
</p>
</li>
<li> <p><a href="#method-MethodPattern-to_s"><code>MethodPattern$to_s()</code></a>
</p>
</li>
<li> <p><a href="#method-MethodPattern-clone"><code>MethodPattern$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-MethodPattern-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>MethodPattern</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>MethodPattern$new(pattern)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern</code></dt><dd><p>(character) a HTTP method, lowercase</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>MethodPattern</code> object
</p>


<hr>
<a id="method-MethodPattern-matches"></a>



<h4>Method <code>matches()</code></h4>

<p>test if the pattern matches a given http method
</p>


<h5>Usage</h5>

<div class="r"><pre>MethodPattern$matches(method)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>(character) a HTTP method, lowercase</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-MethodPattern-to_s"></a>



<h4>Method <code>to_s()</code></h4>

<p>Print pattern for easy human consumption
</p>


<h5>Usage</h5>

<div class="r"><pre>MethodPattern$to_s()</pre></div>



<h5>Returns</h5>

<p>a string
</p>


<hr>
<a id="method-MethodPattern-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>MethodPattern$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- MethodPattern$new(pattern = "post"))
x$pattern
x$matches(method = "post")
x$matches(method = "POST")

# all matches() calls should be TRUE
(x &lt;- MethodPattern$new(pattern = "any"))
x$pattern
x$matches(method = "post")
x$matches(method = "GET")
x$matches(method = "HEAD")
</code></pre>

<hr>
<h2 id='mock_file'>Mock file</h2><span id='topic+mock_file'></span>

<h3>Description</h3>

<p>Mock file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mock_file(path, payload)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mock_file_+3A_path">path</code></td>
<td>
<p>(character) a file path. required</p>
</td></tr>
<tr><td><code id="mock_file_+3A_payload">payload</code></td>
<td>
<p>(character) string to be written to the file given
at <code>path</code> parameter. required</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with S3 class <code>mock_file</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mock_file(path = tempfile(), payload = "{\"foo\": \"bar\"}")
</code></pre>

<hr>
<h2 id='mocking-disk-writing'>Mocking writing to disk</h2><span id='topic+mocking-disk-writing'></span>

<h3>Description</h3>

<p>Mocking writing to disk
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# enable mocking
enable()

# Write to a file before mocked request

# crul
library(crul)
## make a temp file
f &lt;- tempfile(fileext = ".json")
## write something to the file
cat("{\"hello\":\"world\"}\n", file = f)
readLines(f)
## make the stub
stub_request("get", "https://httpbin.org/get") %&gt;% 
  to_return(body = file(f))
## make a request
(out &lt;- HttpClient$new("https://httpbin.org/get")$get(disk = f))
out$content
readLines(out$content)

# httr
library(httr)
## make a temp file
f &lt;- tempfile(fileext = ".json")
## write something to the file
cat("{\"hello\":\"world\"}\n", file = f)
readLines(f)
## make the stub
stub_request("get", "https://httpbin.org/get") %&gt;% 
  to_return(body = file(f), 
   headers = list('content-type' = "application/json"))
## make a request
## with httr, you must set overwrite=TRUE or you'll get an errror
out &lt;- GET("https://httpbin.org/get", write_disk(f, overwrite=TRUE))
out
out$content
content(out, "text", encoding = "UTF-8")


# Use mock_file to have webmockr handle file and contents

# crul
library(crul)
f &lt;- tempfile(fileext = ".json")
## make the stub
stub_request("get", "https://httpbin.org/get") %&gt;% 
  to_return(body = mock_file(f, "{\"hello\":\"mars\"}\n"))
## make a request
(out &lt;- crul::HttpClient$new("https://httpbin.org/get")$get(disk = f))
out$content
readLines(out$content)

# httr
library(httr)
## make a temp file
f &lt;- tempfile(fileext = ".json")
## make the stub
stub_request("get", "https://httpbin.org/get") %&gt;% 
  to_return(
    body = mock_file(path = f, payload = "{\"foo\": \"bar\"}"),
    headers = list('content-type' = "application/json")
  )
## make a request
out &lt;- GET("https://httpbin.org/get", write_disk(f))
out
## view stubbed file content
out$content
readLines(out$content)
content(out, "text", encoding = "UTF-8")

# disable mocking
disable()

## End(Not run)
</code></pre>

<hr>
<h2 id='pluck_body'>Extract the body from an HTTP request</h2><span id='topic+pluck_body'></span>

<h3>Description</h3>

<p>Returns an appropriate representation of the data contained within a request
body based on its encoding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pluck_body(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pluck_body_+3A_x">x</code></td>
<td>
<p>an unexecuted crul <em>or</em> httr request object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>one of the following:
</p>

<ul>
<li> <p><code>NULL</code> if the request is not associated with a body
</p>
</li>
<li> <p><code>NULL</code> if an upload is used not in a list
</p>
</li>
<li><p> list containing the multipart-encoded body
</p>
</li>
<li><p> character vector with the JSON- or raw-encoded body, or upload form file
</p>
</li></ul>


<hr>
<h2 id='remove_request_stub'>Remove a request stub</h2><span id='topic+remove_request_stub'></span>

<h3>Description</h3>

<p>Remove a request stub
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_request_stub(stub)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_request_stub_+3A_stub">stub</code></td>
<td>
<p>a request stub, of class <code>StubbedRequest</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical, <code>TRUE</code> if removed, <code>FALSE</code> if not removed
</p>


<h3>See Also</h3>

<p>Other stub-registry: 
<code><a href="#topic+StubRegistry">StubRegistry</a></code>,
<code><a href="#topic+stub_registry_clear">stub_registry_clear</a>()</code>,
<code><a href="#topic+stub_registry">stub_registry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- stub_request("get", "https://httpbin.org/get"))
stub_registry()
remove_request_stub(x)
stub_registry()
</code></pre>

<hr>
<h2 id='request_registry'>List or clear requests in the request registry</h2><span id='topic+request_registry'></span><span id='topic+request_registry_clear'></span>

<h3>Description</h3>

<p>List or clear requests in the request registry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>request_registry()

request_registry_clear()
</code></pre>


<h3>Details</h3>

<p><code>request_registry()</code> lists the requests that have been made
that webmockr knows about; <code>request_registry_clear()</code> resets the
request registry (removes all recorded requests)
</p>


<h3>Value</h3>

<p>an object of class <code>RequestRegistry</code>, print method gives the
requests in the registry and the number of times each one has been
performed
</p>


<h3>See Also</h3>

<p>Other request-registry: 
<code><a href="#topic+HashCounter">HashCounter</a></code>,
<code><a href="#topic+RequestRegistry">RequestRegistry</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>webmockr::enable()
stub_request("get", "https://httpbin.org/get") %&gt;%
  to_return(body = "success!", status = 200)

# nothing in the request registry
request_registry()

# make the request
z &lt;- crul::HttpClient$new(url = "https://httpbin.org")$get("get")

# check the request registry - the request was made 1 time
request_registry()

# do the request again
z &lt;- crul::HttpClient$new(url = "https://httpbin.org")$get("get")

# check the request registry - now it's been made 2 times, yay!
request_registry()

# clear the request registry
request_registry_clear()
webmockr::disable()
</code></pre>

<hr>
<h2 id='RequestPattern'>RequestPattern class</h2><span id='topic+RequestPattern'></span>

<h3>Description</h3>

<p>class handling all request matchers
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>method_pattern</code></dt><dd><p>xxx</p>
</dd>
<dt><code>uri_pattern</code></dt><dd><p>xxx</p>
</dd>
<dt><code>body_pattern</code></dt><dd><p>xxx</p>
</dd>
<dt><code>headers_pattern</code></dt><dd><p>xxx</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestPattern-new"><code>RequestPattern$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestPattern-matches"><code>RequestPattern$matches()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestPattern-to_s"><code>RequestPattern$to_s()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestPattern-clone"><code>RequestPattern$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RequestPattern-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>RequestPattern</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestPattern$new(
  method,
  uri = NULL,
  uri_regex = NULL,
  query = NULL,
  body = NULL,
  headers = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>the HTTP method (any, head, options, get, post, put,
patch, trace, or delete). &quot;any&quot; matches any HTTP method. required.</p>
</dd>
<dt><code>uri</code></dt><dd><p>(character) request URI. required or uri_regex</p>
</dd>
<dt><code>uri_regex</code></dt><dd><p>(character) request URI as regex. required or uri</p>
</dd>
<dt><code>query</code></dt><dd><p>(list) query parameters, optional</p>
</dd>
<dt><code>body</code></dt><dd><p>(list) body request, optional</p>
</dd>
<dt><code>headers</code></dt><dd><p>(list) headers, optional</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>RequestPattern</code> object
</p>


<hr>
<a id="method-RequestPattern-matches"></a>



<h4>Method <code>matches()</code></h4>

<p>does a request signature match the selected matchers?
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestPattern$matches(request_signature)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request_signature</code></dt><dd><p>a <a href="#topic+RequestSignature">RequestSignature</a> object</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-RequestPattern-to_s"></a>



<h4>Method <code>to_s()</code></h4>

<p>Print pattern for easy human consumption
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestPattern$to_s()</pre></div>



<h5>Returns</h5>

<p>a string
</p>


<hr>
<a id="method-RequestPattern-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestPattern$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>pattern classes for HTTP method <a href="#topic+MethodPattern">MethodPattern</a>, headers
<a href="#topic+HeadersPattern">HeadersPattern</a>, body <a href="#topic+BodyPattern">BodyPattern</a>, and URI/URL <a href="#topic+UriPattern">UriPattern</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- RequestPattern$new(method = "get", uri = "httpbin.org/get"))
x$body_pattern
x$headers_pattern
x$method_pattern
x$uri_pattern
x$to_s()

# make a request signature
rs &lt;- RequestSignature$new(method = "get", uri = "http://httpbin.org/get")

# check if it matches
x$matches(rs)

# regex uri
(x &lt;- RequestPattern$new(method = "get", uri_regex = ".+ossref.org"))
x$uri_pattern
x$uri_pattern$to_s()
x$to_s()

# uri with query parameters
(x &lt;- RequestPattern$new(
    method = "get", uri = "https://httpbin.org/get",
    query = list(foo = "bar")
))
x$to_s()
## query params included in url, not separately
(x &lt;- RequestPattern$new(
  method = "get", uri = "https://httpbin.org/get?stuff=things"
))
x$to_s()
x$query_params

# just headers (via setting method=any &amp; uri_regex=.+)
headers &lt;- list(
  'User-Agent' = 'Apple',
  'Accept-Encoding' = 'gzip, deflate', 
  'Accept' = 'application/json, text/xml, application/xml, */*')
x &lt;- RequestPattern$new(
   method = "any",
   uri_regex = ".+",
   headers = headers)
x$to_s()
rs &lt;- RequestSignature$new(method = "any", uri = "http://foo.bar", 
  options = list(headers = headers))
rs
x$matches(rs)

# body
x &lt;- RequestPattern$new(method = "post", uri = "httpbin.org/post",
  body = list(y = crul::upload(system.file("CITATION"))))
x$to_s()
rs &lt;- RequestSignature$new(method = "post", uri = "http://httpbin.org/post",
  options = list(
     body = list(y = crul::upload(system.file("CITATION")))))
rs
x$matches(rs)

## End(Not run)
</code></pre>

<hr>
<h2 id='RequestRegistry'>RequestRegistry</h2><span id='topic+RequestRegistry'></span>

<h3>Description</h3>

<p>keeps track of HTTP requests
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>request_signatures</code></dt><dd><p>a HashCounter object</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestRegistry-print"><code>RequestRegistry$print()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestRegistry-reset"><code>RequestRegistry$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestRegistry-register_request"><code>RequestRegistry$register_request()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestRegistry-times_executed"><code>RequestRegistry$times_executed()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestRegistry-clone"><code>RequestRegistry$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RequestRegistry-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>RequestRegistry</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestRegistry$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RequestRegistry-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the registry to no registered requests
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestRegistry$reset()</pre></div>



<h5>Returns</h5>

<p>nothing returned; ressets registry to no requests
</p>


<hr>
<a id="method-RequestRegistry-register_request"></a>



<h4>Method <code>register_request()</code></h4>

<p>Register a request
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestRegistry$register_request(request)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request</code></dt><dd><p>a character string of the request, serialized from
a <code>RequestSignature$new(...)$to_s()</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; registers the request
</p>


<hr>
<a id="method-RequestRegistry-times_executed"></a>



<h4>Method <code>times_executed()</code></h4>

<p>How many times has a request been made
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestRegistry$times_executed(request_pattern)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request_pattern</code></dt><dd><p>an object of class <code>RequestPattern</code></p>
</dd>
</dl>

</div>



<h5>Details</h5>

<p>if no match is found for the request pattern, 0 is returned
</p>



<h5>Returns</h5>

<p>integer, the number of times the request has been made
</p>


<hr>
<a id="method-RequestRegistry-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestRegistry$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+stub_registry">stub_registry()</a></code> and <a href="#topic+StubRegistry">StubRegistry</a>
</p>
<p>Other request-registry: 
<code><a href="#topic+HashCounter">HashCounter</a></code>,
<code><a href="#topic+request_registry">request_registry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- RequestRegistry$new()
z1 &lt;- RequestSignature$new("get", "http://scottchamberlain.info")
z2 &lt;- RequestSignature$new("post", "https://httpbin.org/post")
x$register_request(request = z1)
x$register_request(request = z1)
x$register_request(request = z2)
# print method to list requests
x

# more complex requests
w &lt;- RequestSignature$new(
  method = "get",
  uri = "https:/httpbin.org/get",
  options = list(headers = list(`User-Agent` = "foobar", stuff = "things"))
)
w$to_s()
x$register_request(request = w)
x


# hashes, and number of times each requested
x$request_signatures$hash

# times_executed method
pat &lt;- RequestPattern$new(
  method = "get",
  uri = "https:/httpbin.org/get",
  headers = list(`User-Agent` = "foobar", stuff = "things")
)
pat$to_s()
x$times_executed(pat)
z &lt;- RequestPattern$new(method = "get", uri = "http://scottchamberlain.info")
x$times_executed(z)
w &lt;- RequestPattern$new(method = "post", uri = "https://httpbin.org/post")
x$times_executed(w)

## pattern with no matches - returns 0 (zero)
pat &lt;- RequestPattern$new(
  method = "get",
  uri = "http://recology.info/"
)
pat$to_s()
x$times_executed(pat)

# reset the request registry
x$reset()
</code></pre>

<hr>
<h2 id='RequestSignature'>RequestSignature</h2><span id='topic+RequestSignature'></span>

<h3>Description</h3>

<p>General purpose request signature builder
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>method</code></dt><dd><p>(character) an http method</p>
</dd>
<dt><code>uri</code></dt><dd><p>(character) a uri</p>
</dd>
<dt><code>body</code></dt><dd><p>(various) request body</p>
</dd>
<dt><code>headers</code></dt><dd><p>(list) named list of headers</p>
</dd>
<dt><code>proxies</code></dt><dd><p>(list) proxies as a named list</p>
</dd>
<dt><code>auth</code></dt><dd><p>(list) authentication details, as a named list</p>
</dd>
<dt><code>url</code></dt><dd><p>internal use</p>
</dd>
<dt><code>disk</code></dt><dd><p>(character) if writing to disk, the path</p>
</dd>
<dt><code>fields</code></dt><dd><p>(various) request body details</p>
</dd>
<dt><code>output</code></dt><dd><p>(various) request output details, disk, memory, etc</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-RequestSignature-new"><code>RequestSignature$new()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestSignature-print"><code>RequestSignature$print()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestSignature-to_s"><code>RequestSignature$to_s()</code></a>
</p>
</li>
<li> <p><a href="#method-RequestSignature-clone"><code>RequestSignature$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-RequestSignature-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>RequestSignature</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestSignature$new(method, uri, options = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>the HTTP method (any, head, options, get, post, put,
patch, trace, or delete). &quot;any&quot; matches any HTTP method. required.</p>
</dd>
<dt><code>uri</code></dt><dd><p>(character) request URI. required.</p>
</dd>
<dt><code>options</code></dt><dd><p>(list) options. optional. See Details.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>RequestSignature</code> object
</p>


<hr>
<a id="method-RequestSignature-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>RequestSignature</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestSignature$print()</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-RequestSignature-to_s"></a>



<h4>Method <code>to_s()</code></h4>

<p>Request signature to a string
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestSignature$to_s()</pre></div>



<h5>Returns</h5>

<p>a character string representation of the request signature
</p>


<hr>
<a id="method-RequestSignature-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RequestSignature$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># make request signature
x &lt;- RequestSignature$new(method = "get", uri = "https:/httpbin.org/get")
# method
x$method
# uri
x$uri
# request signature to string
x$to_s()

# headers
w &lt;- RequestSignature$new(
  method = "get",
  uri = "https:/httpbin.org/get",
  options = list(headers = list(`User-Agent` = "foobar", stuff = "things"))
)
w
w$headers
w$to_s()

# headers and body
bb &lt;- RequestSignature$new(
  method = "get",
  uri = "https:/httpbin.org/get",
  options = list(
    headers = list(`User-Agent` = "foobar", stuff = "things"),
    body = list(a = "tables")
  )
)
bb
bb$headers
bb$body
bb$to_s()

# with disk path
f &lt;- tempfile()
bb &lt;- RequestSignature$new(
  method = "get",
  uri = "https:/httpbin.org/get",
  options = list(disk = f)
)
bb
bb$disk
bb$to_s()
</code></pre>

<hr>
<h2 id='Response'>Response</h2><span id='topic+Response'></span>

<h3>Description</h3>

<p>custom webmockr http response class
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>url</code></dt><dd><p>(character) a url</p>
</dd>
<dt><code>body</code></dt><dd><p>(various) list, character, etc</p>
</dd>
<dt><code>content</code></dt><dd><p>(various) response content/body</p>
</dd>
<dt><code>request_headers</code></dt><dd><p>(list) a named list</p>
</dd>
<dt><code>response_headers</code></dt><dd><p>(list) a named list</p>
</dd>
<dt><code>options</code></dt><dd><p>(character) list</p>
</dd>
<dt><code>status_code</code></dt><dd><p>(integer) an http status code</p>
</dd>
<dt><code>exception</code></dt><dd><p>(character) an exception message</p>
</dd>
<dt><code>should_timeout</code></dt><dd><p>(logical) should the response timeout?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-Response-new"><code>Response$new()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-print"><code>Response$print()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_url"><code>Response$set_url()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_url"><code>Response$get_url()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_request_headers"><code>Response$set_request_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_request_headers"><code>Response$get_request_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_response_headers"><code>Response$set_response_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_respone_headers"><code>Response$get_respone_headers()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_body"><code>Response$set_body()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_body"><code>Response$get_body()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_status"><code>Response$set_status()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_status"><code>Response$get_status()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-set_exception"><code>Response$set_exception()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-get_exception"><code>Response$get_exception()</code></a>
</p>
</li>
<li> <p><a href="#method-Response-clone"><code>Response$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-Response-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>Response</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$new(options = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>options</code></dt><dd><p>(list) a list of options</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>Response</code> object
</p>


<hr>
<a id="method-Response-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>Response</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-Response-set_url"></a>



<h4>Method <code>set_url()</code></h4>

<p>set the url for the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$set_url(url)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>url</code></dt><dd><p>(character) a url</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets url
</p>


<hr>
<a id="method-Response-get_url"></a>



<h4>Method <code>get_url()</code></h4>

<p>get the url for the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$get_url()</pre></div>



<h5>Returns</h5>

<p>(character) a url
</p>


<hr>
<a id="method-Response-set_request_headers"></a>



<h4>Method <code>set_request_headers()</code></h4>

<p>set the request headers for the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$set_request_headers(headers, capitalize = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>headers</code></dt><dd><p>(list) named list</p>
</dd>
<dt><code>capitalize</code></dt><dd><p>(logical) whether to capitalize first letters of
each header; default: <code>TRUE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets request headers on the response
</p>


<hr>
<a id="method-Response-get_request_headers"></a>



<h4>Method <code>get_request_headers()</code></h4>

<p>get the request headers for the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$get_request_headers()</pre></div>



<h5>Returns</h5>

<p>(list) request headers, a named list
</p>


<hr>
<a id="method-Response-set_response_headers"></a>



<h4>Method <code>set_response_headers()</code></h4>

<p>set the response headers for the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$set_response_headers(headers, capitalize = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>headers</code></dt><dd><p>(list) named list</p>
</dd>
<dt><code>capitalize</code></dt><dd><p>(logical) whether to capitalize first letters of
each header; default: <code>TRUE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets response headers on the response
</p>


<hr>
<a id="method-Response-get_respone_headers"></a>



<h4>Method <code>get_respone_headers()</code></h4>

<p>get the response headers for the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$get_respone_headers()</pre></div>



<h5>Returns</h5>

<p>(list) response headers, a named list
</p>


<hr>
<a id="method-Response-set_body"></a>



<h4>Method <code>set_body()</code></h4>

<p>set the body of the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$set_body(body, disk = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>body</code></dt><dd><p>(various types)</p>
</dd>
<dt><code>disk</code></dt><dd><p>(logical) whether its on disk; default: <code>FALSE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets body on the response
</p>


<hr>
<a id="method-Response-get_body"></a>



<h4>Method <code>get_body()</code></h4>

<p>get the body of the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$get_body()</pre></div>



<h5>Returns</h5>

<p>various
</p>


<hr>
<a id="method-Response-set_status"></a>



<h4>Method <code>set_status()</code></h4>

<p>set the http status of the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$set_status(status)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status</code></dt><dd><p>(integer) the http status</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets the http status of the response
</p>


<hr>
<a id="method-Response-get_status"></a>



<h4>Method <code>get_status()</code></h4>

<p>get the http status of the response
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$get_status()</pre></div>



<h5>Returns</h5>

<p>(integer) the http status
</p>


<hr>
<a id="method-Response-set_exception"></a>



<h4>Method <code>set_exception()</code></h4>

<p>set an exception
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$set_exception(exception)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>exception</code></dt><dd><p>(character) an exception string</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets an exception
</p>


<hr>
<a id="method-Response-get_exception"></a>



<h4>Method <code>get_exception()</code></h4>

<p>get the exception, if set
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$get_exception()</pre></div>



<h5>Returns</h5>

<p>(character) an exception
</p>


<hr>
<a id="method-Response-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(x &lt;- Response$new())

x$set_url("https://httpbin.org/get")
x

x$set_request_headers(list('Content-Type' = "application/json"))
x
x$request_headers

x$set_response_headers(list('Host' = "httpbin.org"))
x
x$response_headers

x$set_status(404)
x
x$get_status()

x$set_body("hello world")
x
x$get_body()
# raw body
x$set_body(charToRaw("hello world"))
x
x$get_body()

x$set_exception("exception")
x
x$get_exception()

## End(Not run)
</code></pre>

<hr>
<h2 id='stub_registry'>List stubs in the stub registry</h2><span id='topic+stub_registry'></span>

<h3>Description</h3>

<p>List stubs in the stub registry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stub_registry()
</code></pre>


<h3>Value</h3>

<p>an object of class <code>StubRegistry</code>, print method gives the
stubs in the registry
</p>


<h3>See Also</h3>

<p>Other stub-registry: 
<code><a href="#topic+StubRegistry">StubRegistry</a></code>,
<code><a href="#topic+remove_request_stub">remove_request_stub</a>()</code>,
<code><a href="#topic+stub_registry_clear">stub_registry_clear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a stub
stub_request("get", "https://httpbin.org/get") %&gt;%
  to_return(body = "success!", status = 200)

# check the stub registry, there should be one in there
stub_registry()

# make another stub
stub_request("get", "https://httpbin.org/get") %&gt;%
  to_return(body = "woopsy", status = 404)

# check the stub registry, now there are two there
stub_registry()

# to clear the stub registry
stub_registry_clear()
</code></pre>

<hr>
<h2 id='stub_registry_clear'>stub_registry_clear</h2><span id='topic+stub_registry_clear'></span>

<h3>Description</h3>

<p>Clear all stubs in the stub registry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stub_registry_clear()
</code></pre>


<h3>Value</h3>

<p>an empty list invisibly
</p>


<h3>See Also</h3>

<p>Other stub-registry: 
<code><a href="#topic+StubRegistry">StubRegistry</a></code>,
<code><a href="#topic+remove_request_stub">remove_request_stub</a>()</code>,
<code><a href="#topic+stub_registry">stub_registry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(x &lt;- stub_request("get", "https://httpbin.org/get"))
stub_registry()
stub_registry_clear()
stub_registry()
</code></pre>

<hr>
<h2 id='stub_request'>Stub an http request</h2><span id='topic+stub_request'></span>

<h3>Description</h3>

<p>Stub an http request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stub_request(method = "get", uri = NULL, uri_regex = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stub_request_+3A_method">method</code></td>
<td>
<p>(character) HTTP method, one of &quot;get&quot;, &quot;post&quot;, &quot;put&quot;, &quot;patch&quot;,
&quot;head&quot;, &quot;delete&quot;, &quot;options&quot; - or the special &quot;any&quot; (for any method)</p>
</td></tr>
<tr><td><code id="stub_request_+3A_uri">uri</code></td>
<td>
<p>(character) The request uri. Can be a full or partial uri.
<span class="pkg">webmockr</span> can match uri's without the &quot;http&quot; scheme, but does
not match if the scheme is &quot;https&quot;. required, unless <code>uri_regex</code> given.
See <a href="#topic+UriPattern">UriPattern</a> for more. See the &quot;uri vs. uri_regex&quot; section</p>
</td></tr>
<tr><td><code id="stub_request_+3A_uri_regex">uri_regex</code></td>
<td>
<p>(character) A URI represented as regex. required, if <code>uri</code>
not given. See examples and the &quot;uri vs. uri_regex&quot; section</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internally, this calls <a href="#topic+StubbedRequest">StubbedRequest</a> which handles the logic
</p>
<p>See <code><a href="#topic+stub_registry">stub_registry()</a></code> for listing stubs, <code><a href="#topic+stub_registry_clear">stub_registry_clear()</a></code>
for removing all stubs and <code><a href="#topic+remove_request_stub">remove_request_stub()</a></code> for removing specific
stubs
</p>
<p>If multiple stubs match the same request, we use the first stub. So if you
want to use a stub that was created after an earlier one that matches,
remove the earlier one(s).
</p>
<p>Note on <code>wi_th()</code>: If you pass <code>query</code> values are coerced to character
class in the recorded stub. You can pass numeric, integer, etc., but
all will be coerced to character.
</p>
<p>See <code><a href="#topic+wi_th">wi_th()</a></code> for details on request body/query/headers and
<code><a href="#topic+to_return">to_return()</a></code> for details on how response status/body/headers
are handled
</p>


<h3>Value</h3>

<p>an object of class <code>StubbedRequest</code>, with print method describing
the stub.
</p>


<h3>uri vs. uri_regex</h3>

<p>When you use <code>uri</code>, we compare the URIs without query params AND
also the query params themselves without the URIs.
</p>
<p>When you use <code>uri_regex</code> we don't compare URIs and query params;
we just use your regex string defined in <code>uri_regex</code> as the pattern
for a call to <a href="base.html#topic+grepl">grepl</a>
</p>


<h3>Mocking writing to disk</h3>

<p>See <a href="#topic+mocking-disk-writing">mocking-disk-writing</a>
</p>


<h3>Note</h3>

<p>Trailing slashes are dropped from stub URIs before matching
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wi_th">wi_th()</a></code>, <code><a href="#topic+to_return">to_return()</a></code>, <code><a href="#topic+to_timeout">to_timeout()</a></code>, <code><a href="#topic+to_raise">to_raise()</a></code>,
<code><a href="#topic+mock_file">mock_file()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# basic stubbing
stub_request("get", "https://httpbin.org/get")
stub_request("post", "https://httpbin.org/post")

# any method, use "any"
stub_request("any", "https://httpbin.org/get")

# list stubs
stub_registry()

# request headers
stub_request("get", "https://httpbin.org/get") %&gt;%
   wi_th(headers = list('User-Agent' = 'R'))

# request body
stub_request("post", "https://httpbin.org/post") %&gt;%
   wi_th(body = list(foo = 'bar'))
stub_registry()
library(crul)
x &lt;- crul::HttpClient$new(url = "https://httpbin.org")
crul::mock()
x$post('post', body = list(foo = 'bar'))

# add expectation with to_return
stub_request("get", "https://httpbin.org/get") %&gt;%
  wi_th(
    query = list(hello = "world"),
    headers = list('User-Agent' = 'R')) %&gt;%
  to_return(status = 200, body = "stuff", headers = list(a = 5))

# list stubs again
stub_registry()

# regex
stub_request("get", uri_regex = ".+ample\\..")

# set stub an expectation to timeout
stub_request("get", "https://httpbin.org/get") %&gt;% to_timeout()
x &lt;- crul::HttpClient$new(url = "https://httpbin.org")
res &lt;- x$get('get')

# raise exception
library(fauxpas)
stub_request("get", "https://httpbin.org/get") %&gt;% to_raise(HTTPAccepted)
stub_request("get", "https://httpbin.org/get") %&gt;% to_raise(HTTPAccepted, HTTPGone)

x &lt;- crul::HttpClient$new(url = "https://httpbin.org")
stub_request("get", "https://httpbin.org/get") %&gt;% to_raise(HTTPBadGateway)
crul::mock()
x$get('get')

# pass a list to .list
z &lt;- stub_request("get", "https://httpbin.org/get")
wi_th(z, .list = list(query = list(foo = "bar")))

# just body
stub_request("any", uri_regex = ".+") %&gt;%
   wi_th(body = list(foo = 'bar'))
## with crul
library(crul)
x &lt;- crul::HttpClient$new(url = "https://httpbin.org")
crul::mock()
x$post('post', body = list(foo = 'bar'))
x$put('put', body = list(foo = 'bar'))
## with httr
library(httr)
httr_mock()
POST('https://example.com', body = list(foo = 'bar'))
PUT('https://google.com', body = list(foo = 'bar'))


# just headers
headers &lt;- list(
  'Accept-Encoding' = 'gzip, deflate', 
  'Accept' = 'application/json, text/xml, application/xml, */*')
stub_request("any", uri_regex = ".+") %&gt;% wi_th(headers = headers)
library(crul)
x &lt;- crul::HttpClient$new(url = "https://httpbin.org", headers = headers)
crul::mock()
x$post('post')
x$put('put', body = list(foo = 'bar'))
x$get('put', query = list(stuff = 3423234L))

# many responses
## the first response matches the first to_return call, and so on
stub_request("get", "https://httpbin.org/get") %&gt;% 
  to_return(status = 200, body = "foobar", headers = list(a = 5)) %&gt;% 
  to_return(status = 200, body = "bears", headers = list(b = 6))
con &lt;- crul::HttpClient$new(url = "https://httpbin.org")
con$get("get")$parse("UTF-8")
con$get("get")$parse("UTF-8")

## OR, use times with to_return() to repeat the same response many times
library(fauxpas)
stub_request("get", "https://httpbin.org/get") %&gt;% 
  to_return(status = 200, body = "apple-pie", times = 2) %&gt;% 
  to_raise(HTTPUnauthorized)
con &lt;- crul::HttpClient$new(url = "https://httpbin.org")
con$get("get")$parse("UTF-8")
con$get("get")$parse("UTF-8")
con$get("get")$parse("UTF-8")

# clear all stubs
stub_registry()
stub_registry_clear()

## End(Not run)
</code></pre>

<hr>
<h2 id='StubbedRequest'>StubbedRequest</h2><span id='topic+StubbedRequest'></span>

<h3>Description</h3>

<p>stubbed request class underlying <code><a href="#topic+stub_request">stub_request()</a></code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>method</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>uri</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>uri_regex</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>uri_parts</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>host</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>query</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>body</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>basic_auth</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>request_headers</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>response_headers</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>responses_sequences</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>status_code</code></dt><dd><p>(xx) xx</p>
</dd>
<dt><code>counter</code></dt><dd><p>a StubCounter object</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StubbedRequest-new"><code>StubbedRequest$new()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-print"><code>StubbedRequest$print()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-with"><code>StubbedRequest$with()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-to_return"><code>StubbedRequest$to_return()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-to_timeout"><code>StubbedRequest$to_timeout()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-to_raise"><code>StubbedRequest$to_raise()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-to_s"><code>StubbedRequest$to_s()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-reset"><code>StubbedRequest$reset()</code></a>
</p>
</li>
<li> <p><a href="#method-StubbedRequest-clone"><code>StubbedRequest$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StubbedRequest-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>StubbedRequest</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$new(method, uri = NULL, uri_regex = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>method</code></dt><dd><p>the HTTP method (any, head, get, post, put,
patch, or delete). &quot;any&quot; matches any HTTP method. required.</p>
</dd>
<dt><code>uri</code></dt><dd><p>(character) request URI. either this or <code>uri_regex</code>
required. <span class="pkg">webmockr</span> can match uri's without the &quot;http&quot; scheme,
but does not match if the scheme is &quot;https&quot;. required, unless
<code>uri_regex</code> given. See <a href="#topic+UriPattern">UriPattern</a> for more.</p>
</dd>
<dt><code>uri_regex</code></dt><dd><p>(character) request URI as regex. either this or <code>uri</code>
required</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>StubbedRequest</code> object
</p>


<hr>
<a id="method-StubbedRequest-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>StubbedRequest</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-StubbedRequest-with"></a>



<h4>Method <code>with()</code></h4>

<p>Set expectations for what's given in HTTP request
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$with(
  query = NULL,
  body = NULL,
  headers = NULL,
  basic_auth = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query</code></dt><dd><p>(list) request query params, as a named list. optional</p>
</dd>
<dt><code>body</code></dt><dd><p>(list) request body, as a named list. optional</p>
</dd>
<dt><code>headers</code></dt><dd><p>(list) request headers as a named list. optional.</p>
</dd>
<dt><code>basic_auth</code></dt><dd><p>(character) basic authentication. optional.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets only
</p>


<hr>
<a id="method-StubbedRequest-to_return"></a>



<h4>Method <code>to_return()</code></h4>

<p>Set expectations for what's returned in HTTP response
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$to_return(status, body, headers)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>status</code></dt><dd><p>(numeric) an HTTP status code</p>
</dd>
<dt><code>body</code></dt><dd><p>(list) response body, one of: <code>character</code>, <code>json</code>,
<code>list</code>, <code>raw</code>, <code>numeric</code>, <code>NULL</code>, <code>FALSE</code>, or a file connection
(other connetion types not supported)</p>
</dd>
<dt><code>headers</code></dt><dd><p>(list) named list, response headers. optional.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; sets whats to be returned
</p>


<hr>
<a id="method-StubbedRequest-to_timeout"></a>



<h4>Method <code>to_timeout()</code></h4>

<p>Response should time out
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$to_timeout()</pre></div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-StubbedRequest-to_raise"></a>



<h4>Method <code>to_raise()</code></h4>

<p>Response should raise an exception <code>x</code>
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$to_raise(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>(character) an exception message</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned
</p>


<hr>
<a id="method-StubbedRequest-to_s"></a>



<h4>Method <code>to_s()</code></h4>

<p>Response as a character string
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$to_s()</pre></div>



<h5>Returns</h5>

<p>(character) the response as a string
</p>


<hr>
<a id="method-StubbedRequest-reset"></a>



<h4>Method <code>reset()</code></h4>

<p>Reset the counter for the stub
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$reset()</pre></div>



<h5>Returns</h5>

<p>nothing returned; resets stub counter to no requests
</p>


<hr>
<a id="method-StubbedRequest-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StubbedRequest$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+stub_request">stub_request()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
x$method
x$uri
x$with(headers = list('User-Agent' = 'R', apple = "good"))
x$to_return(status = 200, body = "foobar", headers = list(a = 5))
x
x$to_s()

# many to_return's
x &lt;- StubbedRequest$new(method = "get", uri = "httpbin.org")
x$to_return(status = 200, body = "foobar", headers = list(a = 5))
x$to_return(status = 200, body = "bears", headers = list(b = 6))
x
x$to_s()

# raw body
x &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
x$to_return(status = 200, body = raw(0), headers = list(a = 5))
x$to_s()
x

x &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
x$to_return(status = 200, body = charToRaw("foo bar"),
  headers = list(a = 5))
x$to_s()
x

# basic auth
x &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
x$with(basic_auth = c("foo", "bar"))
x$to_s()
x

# file path
x &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
f &lt;- tempfile()
x$to_return(status = 200, body = file(f), headers = list(a = 5))
x
x$to_s()
unlink(f)

# to_file(): file path and payload to go into the file
#   payload written to file during mocked response creation
x &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
f &lt;- tempfile()
x$to_return(status = 200, body = mock_file(f, "{\"foo\": \"bar\"}"),
  headers = list(a = 5))
x
x$to_s()
unlink(f)

# uri_regex
(x &lt;- StubbedRequest$new(method = "get", uri_regex = ".+ossref.org"))
x$method
x$uri_regex
x$to_s()

# to timeout
(x &lt;- StubbedRequest$new(method = "get", uri_regex = ".+ossref.org"))
x$to_s()
x$to_timeout()
x$to_s()
x

# to raise
library(fauxpas)
(x &lt;- StubbedRequest$new(method = "get", uri_regex = ".+ossref.org"))
x$to_s()
x$to_raise(HTTPBadGateway)
x$to_s()
x

## End(Not run)
</code></pre>

<hr>
<h2 id='StubCounter'>StubCounter</h2><span id='topic+StubCounter'></span>

<h3>Description</h3>

<p>hash with counter to store requests and count number
of requests made against the stub
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>hash</code></dt><dd><p>(list) a list for internal use only, with elements
<code>key</code>, <code>sig</code>, and <code>count</code></p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StubCounter-put"><code>StubCounter$put()</code></a>
</p>
</li>
<li> <p><a href="#method-StubCounter-count"><code>StubCounter$count()</code></a>
</p>
</li>
<li> <p><a href="#method-StubCounter-clone"><code>StubCounter$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StubCounter-put"></a>



<h4>Method <code>put()</code></h4>

<p>Register a request by it's key
</p>


<h5>Usage</h5>

<div class="r"><pre>StubCounter$put(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an object of class <code>RequestSignature</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; registers request &amp; iterates internal counter
</p>


<hr>
<a id="method-StubCounter-count"></a>



<h4>Method <code>count()</code></h4>

<p>Get the count of number of times any matching request has
been made against this stub
</p>


<h5>Usage</h5>

<div class="r"><pre>StubCounter$count()</pre></div>


<hr>
<a id="method-StubCounter-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StubCounter$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- StubCounter$new()
x
x$hash
x$count()
z &lt;- RequestSignature$new(method = "get", uri = "https:/httpbin.org/get")
x$put(z)
x$count()
x$put(z)
x$count()
</code></pre>

<hr>
<h2 id='StubRegistry'>StubRegistry</h2><span id='topic+StubRegistry'></span>

<h3>Description</h3>

<p>stub registry to keep track of <a href="#topic+StubbedRequest">StubbedRequest</a> stubs
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>request_stubs</code></dt><dd><p>(list) list of request stubs</p>
</dd>
<dt><code>global_stubs</code></dt><dd><p>(list) list of global stubs</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-StubRegistry-print"><code>StubRegistry$print()</code></a>
</p>
</li>
<li> <p><a href="#method-StubRegistry-register_stub"><code>StubRegistry$register_stub()</code></a>
</p>
</li>
<li> <p><a href="#method-StubRegistry-find_stubbed_request"><code>StubRegistry$find_stubbed_request()</code></a>
</p>
</li>
<li> <p><a href="#method-StubRegistry-request_stub_for"><code>StubRegistry$request_stub_for()</code></a>
</p>
</li>
<li> <p><a href="#method-StubRegistry-remove_request_stub"><code>StubRegistry$remove_request_stub()</code></a>
</p>
</li>
<li> <p><a href="#method-StubRegistry-remove_all_request_stubs"><code>StubRegistry$remove_all_request_stubs()</code></a>
</p>
</li>
<li> <p><a href="#method-StubRegistry-is_registered"><code>StubRegistry$is_registered()</code></a>
</p>
</li>
<li> <p><a href="#method-StubRegistry-clone"><code>StubRegistry$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-StubRegistry-print"></a>



<h4>Method <code>print()</code></h4>

<p>print method for the <code>StubRegistry</code> class
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$print(x, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>self</p>
</dd>
<dt><code>...</code></dt><dd><p>ignored</p>
</dd>
</dl>

</div>


<hr>
<a id="method-StubRegistry-register_stub"></a>



<h4>Method <code>register_stub()</code></h4>

<p>Register a stub
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$register_stub(stub)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stub</code></dt><dd><p>an object of type <a href="#topic+StubbedRequest">StubbedRequest</a></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; registers the stub
</p>


<hr>
<a id="method-StubRegistry-find_stubbed_request"></a>



<h4>Method <code>find_stubbed_request()</code></h4>

<p>Find a stubbed request
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$find_stubbed_request(req)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>req</code></dt><dd><p>an object of class <a href="#topic+RequestSignature">RequestSignature</a></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>an object of type <a href="#topic+StubbedRequest">StubbedRequest</a>, if matched
</p>


<hr>
<a id="method-StubRegistry-request_stub_for"></a>



<h4>Method <code>request_stub_for()</code></h4>

<p>Find a stubbed request
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$request_stub_for(request_signature, count = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>request_signature</code></dt><dd><p>an object of class <a href="#topic+RequestSignature">RequestSignature</a></p>
</dd>
<dt><code>count</code></dt><dd><p>(bool) iterate counter or not. default: <code>TRUE</code></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>logical, 1 or more
</p>


<hr>
<a id="method-StubRegistry-remove_request_stub"></a>



<h4>Method <code>remove_request_stub()</code></h4>

<p>Remove a stubbed request by matching request signature
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$remove_request_stub(stub)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>stub</code></dt><dd><p>an object of type <a href="#topic+StubbedRequest">StubbedRequest</a></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; removes the stub from the registry
</p>


<hr>
<a id="method-StubRegistry-remove_all_request_stubs"></a>



<h4>Method <code>remove_all_request_stubs()</code></h4>

<p>Remove all request stubs
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$remove_all_request_stubs()</pre></div>



<h5>Returns</h5>

<p>nothing returned; removes all request stubs
</p>


<hr>
<a id="method-StubRegistry-is_registered"></a>



<h4>Method <code>is_registered()</code></h4>

<p>Find a stubbed request
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$is_registered(x)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>an object of class <a href="#topic+RequestSignature">RequestSignature</a></p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned; registers the stub
</p>


<hr>
<a id="method-StubRegistry-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>StubRegistry$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other stub-registry: 
<code><a href="#topic+remove_request_stub">remove_request_stub</a>()</code>,
<code><a href="#topic+stub_registry_clear">stub_registry_clear</a>()</code>,
<code><a href="#topic+stub_registry">stub_registry</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Make a stub
stub1 &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
stub1$with(headers = list('User-Agent' = 'R'))
stub1$to_return(status = 200, body = "foobar", headers = list())
stub1

# Make another stub
stub2 &lt;- StubbedRequest$new(method = "get", uri = "api.crossref.org")
stub2

# Put both stubs in the stub registry
reg &lt;- StubRegistry$new()
reg$register_stub(stub = stub1)
reg$register_stub(stub = stub2)
reg
reg$request_stubs

## End(Not run)
</code></pre>

<hr>
<h2 id='to_raise'>Set raise error condition</h2><span id='topic+to_raise'></span>

<h3>Description</h3>

<p>Set raise error condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_raise(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_raise_+3A_.data">.data</code></td>
<td>
<p>input. Anything that can be coerced to a <code>StubbedRequest</code>
class object</p>
</td></tr>
<tr><td><code id="to_raise_+3A_...">...</code></td>
<td>
<p>One or more HTTP exceptions from the <span class="pkg">fauxpas</span> package. Run
<code>grep("HTTP*", getNamespaceExports("fauxpas"), value = TRUE)</code> for a list of
possible exceptions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The behavior in the future will be:
</p>
<p>When multiple exceptions are passed, the first is used on the first
mock, the second on the second mock, and so on. Subsequent mocks use the
last exception
</p>
<p>But for now, only the first exception is used until we get that fixed
</p>


<h3>Value</h3>

<p>an object of class <code>StubbedRequest</code>, with print method describing
the stub
</p>


<h3>Raise vs. Return</h3>

<p><code>to_raise()</code> always raises a stop condition, while <code>to_return(status=xyz)</code> only
sets the status code on the returned HTTP response object. So if you want to
raise a stop condition then <code>to_raise()</code> is what you want. But if you
don't want to raise a stop condition use <code>to_return()</code>. Use cases for each
vary. For example, in a unit test you may have a test expecting a 503 error;
in this case <code>to_raise()</code> makes sense. In another case, if a unit test
expects to test some aspect of an HTTP response object that httr or crul
typically returns, then you'll want <code>to_return()</code>.
</p>


<h3>Note</h3>

<p>see examples in <code><a href="#topic+stub_request">stub_request()</a></code>
</p>

<hr>
<h2 id='to_return'>Expectation for what's returned from a stubbed request</h2><span id='topic+to_return'></span>

<h3>Description</h3>

<p>Set response status code, response body, and/or response headers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_return(.data, ..., .list = list(), times = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_return_+3A_.data">.data</code></td>
<td>
<p>input. Anything that can be coerced to a <code>StubbedRequest</code> class
object</p>
</td></tr>
<tr><td><code id="to_return_+3A_...">...</code></td>
<td>
<p>Comma separated list of named variables. accepts the following:
<code>status</code>, <code>body</code>, <code>headers</code>. See Details for more.</p>
</td></tr>
<tr><td><code id="to_return_+3A_.list">.list</code></td>
<td>
<p>named list, has to be one of 'status', 'body',
and/or 'headers'. An alternative to passing in via <code>...</code>. Don't pass the
same thing to both, e.g. don't pass 'status' to <code>...</code>, and also 'status' to
this parameter</p>
</td></tr>
<tr><td><code id="to_return_+3A_times">times</code></td>
<td>
<p>(integer) number of times the given response should be
returned; default: 1. value must be greater than or equal to 1. Very large
values probably don't make sense, but there's no maximum value. See
Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Values for status, body, and headers:
</p>

<ul>
<li><p> status: (numeric/integer) three digit status code
</p>
</li>
<li><p> body: various: <code>character</code>, <code>json</code>, <code>list</code>, <code>raw</code>, <code>numeric</code>,
<code>NULL</code>, <code>FALSE</code>, a file connection (other connetion types
not supported), or a <code>mock_file</code> function call (see <code><a href="#topic+mock_file">mock_file()</a></code>)
</p>
</li>
<li><p> headers: (list) a named list, must be named
</p>
</li></ul>

<p>response headers are returned with all lowercase names and the values
are all of type character. if numeric/integer values are given
(e.g., <code>to_return(headers = list(a = 10))</code>), we'll coerce any
numeric/integer values to character.
</p>


<h3>Value</h3>

<p>an object of class <code>StubbedRequest</code>, with print method describing
the stub
</p>


<h3>multiple <code>to_return()</code></h3>

<p>You can add more than one <code>to_return()</code> to a webmockr stub (including
<code><a href="#topic+to_raise">to_raise()</a></code>, <code><a href="#topic+to_timeout">to_timeout()</a></code>). Each one is a HTTP response returned.
That is, you'll match to an HTTP request based on <code>stub_request()</code> and
<code>wi_th()</code>; the first time the request is made, the first response
is returned; the second time the reqeust is made, the second response
is returned; and so on.
</p>
<p>Be aware that webmockr has to track number of requests
(see <code><a href="#topic+request_registry">request_registry()</a></code>), and so if you use multiple <code>to_return()</code>
or the <code>times</code> parameter, you must clear the request registry
in order to go back to mocking responses from the start again.
<code><a href="#topic+webmockr_reset">webmockr_reset()</a></code> clears the stub registry and  the request registry,
after which you can use multiple responses again (after creating
your stub(s) again of course)
</p>


<h3>Raise vs. Return</h3>

<p><code>to_raise()</code> always raises a stop condition, while <code>to_return(status=xyz)</code> only
sets the status code on the returned HTTP response object. So if you want to
raise a stop condition then <code>to_raise()</code> is what you want. But if you
don't want to raise a stop condition use <code>to_return()</code>. Use cases for each
vary. For example, in a unit test you may have a test expecting a 503 error;
in this case <code>to_raise()</code> makes sense. In another case, if a unit test
expects to test some aspect of an HTTP response object that httr or crul
typically returns, then you'll want <code>to_return()</code>.
</p>


<h3>Note</h3>

<p>see more examples in <code><a href="#topic+stub_request">stub_request()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first, make a stub object
foo &lt;- function() {
  stub_request("post", "https://httpbin.org/post")
}

# add status, body and/or headers
foo() %&gt;% to_return(status = 200)
foo() %&gt;% to_return(body = "stuff")
foo() %&gt;% to_return(body = list(a = list(b = "world")))
foo() %&gt;% to_return(headers = list(a = 5))
foo() %&gt;% 
  to_return(status = 200, body = "stuff", headers = list(a = 5))

# .list - pass in a named list instead
foo() %&gt;% to_return(.list = list(body = list(foo = "bar")))

# multiple responses using chained `to_return()`
foo() %&gt;% to_return(body = "stuff") %&gt;% to_return(body = "things")

# many of the same response using the times parameter
foo() %&gt;% to_return(body = "stuff", times = 3)
</code></pre>

<hr>
<h2 id='to_return_'>This function is defunct.</h2><span id='topic+to_return_'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_return_(...)
</code></pre>

<hr>
<h2 id='to_timeout'>Set timeout as an expected return on a match</h2><span id='topic+to_timeout'></span>

<h3>Description</h3>

<p>Set timeout as an expected return on a match
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_timeout(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_timeout_+3A_.data">.data</code></td>
<td>
<p>input. Anything that can be coerced to a <code>StubbedRequest</code> class
object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>StubbedRequest</code>, with print method describing
the stub
</p>


<h3>Note</h3>

<p>see examples in <code><a href="#topic+stub_request">stub_request()</a></code>
</p>

<hr>
<h2 id='UriPattern'>UriPattern</h2><span id='topic+UriPattern'></span>

<h3>Description</h3>

<p>uri matcher
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>pattern</code></dt><dd><p>(character) pattern holder</p>
</dd>
<dt><code>regex</code></dt><dd><p>a logical</p>
</dd>
<dt><code>query_params</code></dt><dd><p>a list, or <code>NULL</code> if empty</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-UriPattern-new"><code>UriPattern$new()</code></a>
</p>
</li>
<li> <p><a href="#method-UriPattern-matches"><code>UriPattern$matches()</code></a>
</p>
</li>
<li> <p><a href="#method-UriPattern-pattern_matches"><code>UriPattern$pattern_matches()</code></a>
</p>
</li>
<li> <p><a href="#method-UriPattern-query_params_matches"><code>UriPattern$query_params_matches()</code></a>
</p>
</li>
<li> <p><a href="#method-UriPattern-extract_query"><code>UriPattern$extract_query()</code></a>
</p>
</li>
<li> <p><a href="#method-UriPattern-add_query_params"><code>UriPattern$add_query_params()</code></a>
</p>
</li>
<li> <p><a href="#method-UriPattern-to_s"><code>UriPattern$to_s()</code></a>
</p>
</li>
<li> <p><a href="#method-UriPattern-clone"><code>UriPattern$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-UriPattern-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new <code>UriPattern</code> object
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$new(pattern = NULL, regex_pattern = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>pattern</code></dt><dd><p>(character) a uri, as a character string. if scheme
is missing, it is added (we assume http)</p>
</dd>
<dt><code>regex_pattern</code></dt><dd><p>(character) a uri as a regex character string,
see <a href="base.html#topic+regex">base::regex</a>. if scheme is missing, it is added (we assume
http)</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>A new <code>UriPattern</code> object
</p>


<hr>
<a id="method-UriPattern-matches"></a>



<h4>Method <code>matches()</code></h4>

<p>Match a uri against a pattern
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$matches(uri)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uri</code></dt><dd><p>(character) a uri</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-UriPattern-pattern_matches"></a>



<h4>Method <code>pattern_matches()</code></h4>

<p>Match a URI
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$pattern_matches(uri)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uri</code></dt><dd><p>(character) a uri</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-UriPattern-query_params_matches"></a>



<h4>Method <code>query_params_matches()</code></h4>

<p>Match query parameters of a URI
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$query_params_matches(uri)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uri</code></dt><dd><p>(character) a uri</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>a boolean
</p>


<hr>
<a id="method-UriPattern-extract_query"></a>



<h4>Method <code>extract_query()</code></h4>

<p>Extract query parameters as a named list
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$extract_query(uri)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>uri</code></dt><dd><p>(character) a uri</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>named list, or <code>NULL</code> if no query parameters
</p>


<hr>
<a id="method-UriPattern-add_query_params"></a>



<h4>Method <code>add_query_params()</code></h4>

<p>Add query parameters to the URI
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$add_query_params(query_params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>query_params</code></dt><dd><p>(list|character) list or character</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>nothing returned, updates uri pattern
</p>


<hr>
<a id="method-UriPattern-to_s"></a>



<h4>Method <code>to_s()</code></h4>

<p>Print pattern for easy human consumption
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$to_s()</pre></div>



<h5>Returns</h5>

<p>a string
</p>


<hr>
<a id="method-UriPattern-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>UriPattern$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'># trailing slash
(z &lt;- UriPattern$new(pattern = "http://foobar.com"))
z$matches("http://foobar.com") # TRUE
z$matches("http://foobar.com/") # TRUE

# without scheme
## matches http by default: does not match https by default
(z &lt;- UriPattern$new(pattern = "foobar.com"))
z$matches("http://foobar.com") # TRUE
z$matches("http://foobar.com/") # TRUE
z$matches("https://foobar.com") # FALSE
z$matches("https://foobar.com/") # FALSE
## to match https, you'll have to give the complete url
(z &lt;- UriPattern$new(pattern = "https://foobar.com"))
z$matches("https://foobar.com/") # TRUE
z$matches("http://foobar.com/") # FALSE

# default ports
(z &lt;- UriPattern$new(pattern = "http://foobar.com"))
z$matches("http://foobar.com:80") # TRUE
z$matches("http://foobar.com:80/") # TRUE
z$matches("http://foobar.com:443") # TRUE
z$matches("http://foobar.com:443/") # TRUE

# user info - FIXME, not sure we support this yet
(z &lt;- UriPattern$new(pattern = "http://foobar.com"))
z$matches("http://user:pass@foobar.com")

# regex
(z &lt;- UriPattern$new(regex_pattern = ".+ample\\.."))
z$matches("http://sample.org") # TRUE
z$matches("http://example.com") # TRUE
z$matches("http://tramples.net") # FALSE

# add query parameters
(z &lt;- UriPattern$new(pattern = "http://foobar.com"))
z$add_query_params(list(pizza = "cheese", cheese = "cheddar"))
z
z$pattern
z$matches("http://foobar.com?pizza=cheese&amp;cheese=cheddar") # TRUE
z$matches("http://foobar.com?pizza=cheese&amp;cheese=swiss") # FALSE

# query parameters in the uri
(z &lt;- UriPattern$new(pattern = "https://httpbin.org/get?stuff=things"))
z$add_query_params() # have to run this method to gather query params
z$matches("https://httpbin.org/get?stuff=things") # TRUE
z$matches("https://httpbin.org/get?stuff2=things") # FALSE

# regex add query parameters
(z &lt;- UriPattern$new(regex_pattern = "https://foobar.com/.+/order"))
z$add_query_params(list(pizza = "cheese"))
z
z$pattern
z$matches("https://foobar.com/pizzas/order?pizza=cheese") # TRUE
z$matches("https://foobar.com/pizzas?pizza=cheese") # FALSE

# query parameters in the regex uri
(z &lt;- UriPattern$new(regex_pattern = "https://x.com/.+/order\\?fruit=apple"))
z$add_query_params() # have to run this method to gather query params
z$matches("https://x.com/a/order?fruit=apple") # TRUE
z$matches("https://x.com/a?fruit=apple") # FALSE

# any pattern
(z &lt;- UriPattern$new(regex_pattern = "stuff\\.com.+"))
z$regex
z$pattern
z$matches("http://stuff.com") # FALSE
z$matches("https://stuff.com/stff") # TRUE
z$matches("https://stuff.com/apple?bears=brown&amp;bats=grey") # TRUE
</code></pre>

<hr>
<h2 id='webmockr_configure'>webmockr configuration</h2><span id='topic+webmockr_configure'></span><span id='topic+webmockr_configure_reset'></span><span id='topic+webmockr_configuration'></span><span id='topic+webmockr_allow_net_connect'></span><span id='topic+webmockr_disable_net_connect'></span><span id='topic+webmockr_net_connect_allowed'></span>

<h3>Description</h3>

<p>webmockr configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>webmockr_configure(
  allow_net_connect = FALSE,
  allow_localhost = FALSE,
  allow = NULL,
  show_stubbing_instructions = TRUE
)

webmockr_configure_reset()

webmockr_configuration()

webmockr_allow_net_connect()

webmockr_disable_net_connect(allow = NULL)

webmockr_net_connect_allowed(uri = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="webmockr_configure_+3A_allow_net_connect">allow_net_connect</code></td>
<td>
<p>(logical) Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="webmockr_configure_+3A_allow_localhost">allow_localhost</code></td>
<td>
<p>(logical) Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="webmockr_configure_+3A_allow">allow</code></td>
<td>
<p>(character) one or more URI/URL to allow (and by extension
all others are not allowed)</p>
</td></tr>
<tr><td><code id="webmockr_configure_+3A_show_stubbing_instructions">show_stubbing_instructions</code></td>
<td>
<p>(logical) Default: <code>TRUE</code>. If <code>FALSE</code>,
stubbing instructions are not shown</p>
</td></tr>
<tr><td><code id="webmockr_configure_+3A_uri">uri</code></td>
<td>
<p>(character) a URI/URL as a character string - to determine
whether or not it is allowed</p>
</td></tr>
</table>


<h3>webmockr_allow_net_connect</h3>

<p>If there are stubs found for a request, even if net connections are
allowed (by running <code>webmockr_allow_net_connect()</code>) the stubbed
response will be returned. If no stub is found, and net connections
are allowed, then a real HTTP request can be made.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
webmockr_configure()
webmockr_configure(
 allow_localhost = TRUE
)
webmockr_configuration()
webmockr_configure_reset()

webmockr_allow_net_connect()
webmockr_net_connect_allowed()

# disable net connect for any URIs
webmockr_disable_net_connect()
### gives NULL with no URI passed
webmockr_net_connect_allowed()
# disable net connect EXCEPT FOR given URIs
webmockr_disable_net_connect(allow = "google.com")
### is a specific URI allowed?
webmockr_net_connect_allowed("google.com")

## End(Not run)
</code></pre>

<hr>
<h2 id='webmockr_crul_fetch'>execute a curl request</h2><span id='topic+webmockr_crul_fetch'></span>

<h3>Description</h3>

<p>execute a curl request
</p>


<h3>Usage</h3>

<pre><code class='language-R'>webmockr_crul_fetch(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="webmockr_crul_fetch_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a curl response
</p>

<hr>
<h2 id='webmockr_disable'>This function is defunct.</h2><span id='topic+webmockr_disable'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>webmockr_disable(...)
</code></pre>

<hr>
<h2 id='webmockr_enable'>This function is defunct.</h2><span id='topic+webmockr_enable'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>webmockr_enable(...)
</code></pre>

<hr>
<h2 id='webmockr_reset'>webmockr_reset</h2><span id='topic+webmockr_reset'></span>

<h3>Description</h3>

<p>Clear all stubs and the request counter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>webmockr_reset()
</code></pre>


<h3>Details</h3>

<p>this function runs <code><a href="#topic+stub_registry_clear">stub_registry_clear()</a></code> and
<code><a href="#topic+request_registry_clear">request_registry_clear()</a></code> - so you can run those two yourself
to achieve the same thing
</p>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stub_registry_clear">stub_registry_clear()</a></code> <code><a href="#topic+request_registry_clear">request_registry_clear()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># webmockr_reset()
</code></pre>

<hr>
<h2 id='webmockr-defunct'>Defunct functions in <span class="pkg">webmockr</span></h2><span id='topic+webmockr-defunct'></span>

<h3>Description</h3>


<ul>
<li> <p><code><a href="#topic+webmockr_enable">webmockr_enable()</a></code>: Function removed, see <code><a href="#topic+enable">enable()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+webmockr_disable">webmockr_disable()</a></code>: Function removed, see <code><a href="#topic+disable">disable()</a></code>
</p>
</li>
<li> <p><a href="#topic+to_return_">to_return_</a>: Only <code><a href="#topic+to_return">to_return()</a></code> is available now
</p>
</li>
<li> <p><a href="#topic+wi_th_">wi_th_</a>: Only <code><a href="#topic+wi_th">wi_th()</a></code> is available now
</p>
</li></ul>


<hr>
<h2 id='wi_th'>Set additional parts of a stubbed request</h2><span id='topic+wi_th'></span>

<h3>Description</h3>

<p>Set query params, request body, request headers and/or basic_auth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wi_th(.data, ..., .list = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wi_th_+3A_.data">.data</code></td>
<td>
<p>input. Anything that can be coerced to a <code>StubbedRequest</code> class
object</p>
</td></tr>
<tr><td><code id="wi_th_+3A_...">...</code></td>
<td>
<p>Comma separated list of named variables. accepts the following:
<code>query</code>, <code>body</code>, <code>headers</code>, <code>basic_auth</code>. See Details.</p>
</td></tr>
<tr><td><code id="wi_th_+3A_.list">.list</code></td>
<td>
<p>named list, has to be one of <code>query</code>, <code>body</code>,
<code>headers</code> and/or <code>basic_auth</code>. An alternative to passing in via <code>...</code>.
Don't pass the same thing to both, e.g. don't pass 'query' to <code>...</code>, and
also 'query' to this parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>with</code> is a function in the <code>base</code> package, so we went with
<code>wi_th</code>
</p>
<p>Values for query, body, headers, and basic_auth:
</p>

<ul>
<li><p> query: (list) a named list. values are coerced to character
class in the recorded stub. You can pass numeric, integer, etc., but
all will be coerced to character.
</p>
</li>
<li><p> body: various, including character string, list, raw, numeric,
upload (<code>crul::upload</code> or <code>httr::upload_file</code>, they both create the
same object in the end)
</p>
</li>
<li><p> headers: (list) a named list
</p>
</li>
<li><p> basic_auth: (character) a length two vector, username and password.
authentication type (basic/digest/ntlm/etc.) is ignored. that is,
mocking authenciation right now does not take into account the
authentication type. We don't do any checking of the username/password
except to detect edge cases where for example, the username/password
were probably not set by the user on purpose (e.g., a URL is
picked up by an environment variable)
</p>
</li></ul>

<p>Note that there is no regex matching on query, body, or headers. They
are tested for matches in the following ways:
</p>

<ul>
<li><p> query: compare stubs and requests with <code>identical()</code>. this compares
named lists, so both list names and values are compared
</p>
</li>
<li><p> body: varies depending on the body format (list vs. character, etc.)
</p>
</li>
<li><p> headers: compare stub and request values with <code>==</code>. list names are
compared with <code>%in%</code>. <code>basic_auth</code> is included in headers (with the name
Authorization)
</p>
</li></ul>



<h3>Value</h3>

<p>an object of class <code>StubbedRequest</code>, with print method describing
the stub
</p>


<h3>Note</h3>

<p>see more examples in <code><a href="#topic+stub_request">stub_request()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first, make a stub object
req &lt;- stub_request("post", "https://httpbin.org/post")

# add body
# list
wi_th(req, body = list(foo = "bar"))
# string
wi_th(req, body = '{"foo": "bar"}')
# raw
wi_th(req, body = charToRaw('{"foo": "bar"}'))
# numeric
wi_th(req, body = 5)
# an upload
wi_th(req, body = crul::upload(system.file("CITATION")))
# wi_th(req, body = httr::upload_file(system.file("CITATION")))

# add query - has to be a named list
wi_th(req, query = list(foo = "bar"))

# add headers - has to be a named list
wi_th(req, headers = list(foo = "bar"))
wi_th(req, headers = list(`User-Agent` = "webmockr/v1", hello="world"))

# .list - pass in a named list instead
wi_th(req, .list = list(body = list(foo = "bar")))

# basic authentication
wi_th(req, basic_auth = c("user", "pass"))
wi_th(req, basic_auth = c("user", "pass"), headers = list(foo = "bar"))
</code></pre>

<hr>
<h2 id='wi_th_'>This function is defunct.</h2><span id='topic+wi_th_'></span>

<h3>Description</h3>

<p>This function is defunct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wi_th_(...)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
