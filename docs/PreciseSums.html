<!DOCTYPE html><html><head><title>Help for package PreciseSums</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PreciseSums}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fsum'><p>Return an accurate floating point sum of values</p></a></li>
<li><a href='#kahanSum'><p>Using the Kahan method, take a more accurate sum</p></a></li>
<li><a href='#neumaierSum'><p>Using the Neumaier method, take a more accurate sum</p></a></li>
<li><a href='#pairwiseSum'><p>Return an accurate floating point sum of values</p></a></li>
<li><a href='#psProd'><p>Using PreciceSums's default method, take a product</p></a></li>
<li><a href='#psSetProd'><p>Choose the type of product to use in PreciceSums.  These are used in the</p>
PreciceSums <code>prod</code> blocks</a></li>
<li><a href='#psSetSum'><p>Choose the type of sums to use for PreciceSums.</p></a></li>
<li><a href='#psSum'><p>Using PreciceSums's default method, take a sum</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Accurate Floating Point Sums and Products</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Most of the time floating point arithmetic does
  approximately the right thing.  When adding sums or having products
  of numbers that greatly differ in magnitude, the floating point
  arithmetic may be incorrect.  This package implements the Kahan
  (1965) sum &lt;<a href="https://doi.org/10.1145%2F363707.363723">doi:10.1145/363707.363723</a>&gt;, Neumaier (1974) sum
  &lt;<a href="https://doi.org/10.1002%2Fzamm.19740540106">doi:10.1002/zamm.19740540106</a>&gt;, pairwise-sum (adapted from 'NumPy',
  See Castaldo (2008) &lt;<a href="https://doi.org/10.1137%2F070679946">doi:10.1137/070679946</a>&gt; for a discussion of
  accuracy), and arbitrary precision sum (adapted from the fsum in
  'Python' ; Shewchuk (1997)
  <a href="https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf">https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf</a>).  In addition,
  products are changed to long double precision for accuracy, or
  changed into a log-sum for accuracy.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nlmixr2/PreciseSums/issues/">https://github.com/nlmixr2/PreciseSums/issues/</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nlmixr2/PreciseSums">https://github.com/nlmixr2/PreciseSums</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-21 18:00:53 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Fidler [aut, cre, cph],
  Raymond Hettinger [cph, aut],
  Jonathan Shewchuk [cph, aut],
  Julian Taylor [cph, aut],
  Nathaniel Smith [cph, aut],
  NumPy Team [cph],
  Python Team [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-22 00:52:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='fsum'>Return an accurate floating point sum of values</h2><span id='topic+fsum'></span>

<h3>Description</h3>

<p>This method avoids loss of precision by tracking multiple
intermediate partial sums. Based on python's math.fsum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fsum(numbers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fsum_+3A_numbers">numbers</code></td>
<td>
<p>A vector of numbers to sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of numbers without loss of precision
</p>
<p>The algorithm's accuracy depends on IEEE-754 arithmetic guarantees
and the typical case where the rounding mode is half-even. On some
non-Windows builds, the underlying C library uses extended
precision addition and may occasionally double-round an
intermediate sum causing it to be off in its least significant bit.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler (R implementation), Raymond Hettinger,
Jonathan Shewchuk, Python Team
</p>


<h3>References</h3>

<p><a href="https://docs.python.org/2/library/math.html">https://docs.python.org/2/library/math.html</a>
</p>
<p><a href="https://code.activestate.com/recipes/393090/">https://code.activestate.com/recipes/393090/</a>
</p>
<p><a href="https://github.com/python/cpython/blob/a0ce375e10b50f7606cb86b072fed7d8cd574fe7/Modules/mathmodule.c">https://github.com/python/cpython/blob/a0ce375e10b50f7606cb86b072fed7d8cd574fe7/Modules/mathmodule.c</a>
</p>
<p>Shewchuk, JR. (1996)
<em>Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric Predicates.</em>
<a href="http://www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps">http://www-2.cs.cmu.edu/afs/cs/project/quake/public/papers/robust-arithmetic.ps</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum(c(1,1e100,1,-1e100)) ## Should be 2, gives 0
fsum(c(1,1e100,1,-1e100)) ## Gives 2.

</code></pre>

<hr>
<h2 id='kahanSum'>Using the Kahan method, take a more accurate sum</h2><span id='topic+kahanSum'></span>

<h3>Description</h3>

<p>Using the Kahan method, take a more accurate sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kahanSum(numbers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kahanSum_+3A_numbers">numbers</code></td>
<td>
<p>A vector of numbers to sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of numbers
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">https://en.wikipedia.org/wiki/Kahan_summation_algorithm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum(c(1,1e100,1,-1e100)) ## Should be 2, gives 0
kahanSum(c(1,1e100,1,-1e100)) ## Not accurate enough for the correct result. (still = 0)
</code></pre>

<hr>
<h2 id='neumaierSum'>Using the Neumaier method, take a more accurate sum</h2><span id='topic+neumaierSum'></span>

<h3>Description</h3>

<p>Using the Neumaier method, take a more accurate sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neumaierSum(numbers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neumaierSum_+3A_numbers">numbers</code></td>
<td>
<p>A vector of numbers to sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of numbers, a bit more accurate than kahanSum
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">https://en.wikipedia.org/wiki/Kahan_summation_algorithm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sum(c(1,1e100,1,-1e100)) ## Should be 2, gives 0
neumaierSum(c(1,1e100,1,-1e100)) ## Gives 2
</code></pre>

<hr>
<h2 id='pairwiseSum'>Return an accurate floating point sum of values</h2><span id='topic+pairwiseSum'></span>

<h3>Description</h3>

<p>This was taken by NumPy and adapted for use here.  It is more
accurate than a standard sum, but still has numerical issues.  Its
main benefit is that it is about the same amount of time as a
standard time with the added accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwiseSum(numbers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwiseSum_+3A_numbers">numbers</code></td>
<td>
<p>A vector of numbers to sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sum of numbers with a rounding error of O(lg n) instead
of O(n).
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler (R implementation), Julian Taylor, Nathaniel
J Smith, and  NumPy team.
#' @examples
sum(c(1,1e100,1,-1e100)) ## Should be 2, gives 0
pairwiseSum(c(1,1e100,1,-1e100)) ## Should be 2, still 0
</p>


<h3>References</h3>

<p><a href="https://github.com/juliantaylor/numpy/blob/b0bc01275cac04483e6df021211c1fa2ba65eaa3/numpy/core/src/umath/loops.c.src">https://github.com/juliantaylor/numpy/blob/b0bc01275cac04483e6df021211c1fa2ba65eaa3/numpy/core/src/umath/loops.c.src</a>
</p>
<p><a href="https://github.com/numpy/numpy/pull/3685">https://github.com/numpy/numpy/pull/3685</a>
</p>

<hr>
<h2 id='psProd'>Using PreciceSums's default method, take a product</h2><span id='topic+psProd'></span>

<h3>Description</h3>

<p>Using PreciceSums's default method, take a product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psProd(numbers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psProd_+3A_numbers">numbers</code></td>
<td>
<p>A vector of numbers to sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Product of numbers
</p>

<hr>
<h2 id='psSetProd'>Choose the type of product to use in PreciceSums.  These are used in the
PreciceSums <code>prod</code> blocks</h2><span id='topic+psSetProd'></span>

<h3>Description</h3>

<p>Choose the type of product to use in PreciceSums.  These are used in the
PreciceSums <code>prod</code> blocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psSetProd(type = c("long double", "double", "logify"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psSetProd_+3A_type">type</code></td>
<td>
<p>Product to use for <code>prod()</code> in PreciceSums blocks
</p>
<p><code>long double</code> converts to long double, performs the
multiplication and then converts back.
</p>
<p><code>double</code> uses the standard double scale for multiplication.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='psSetSum'>Choose the type of sums to use for PreciceSums.</h2><span id='topic+psSetSum'></span>

<h3>Description</h3>

<p>Choose the types of sums to use in PreciceSums.  These are used in the
PreciceSums <code>sum</code> blocks and the <code>psSum</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psSetSum(type = c("pairwise", "fsum", "kahan", "neumaier", "klein", "c"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psSetSum_+3A_type">type</code></td>
<td>
<p>Sum type to use for <code>psSum</code> and <code>sum()</code> in
PreciceSums code blocks.
</p>
<p><code>pairwise</code> uses the pairwise sum (fast, default)
</p>
<p><code>fsum</code> uses Python's fsum function (most accurate)
</p>
<p><code>kahan</code> uses kahan correction
</p>
<p><code>neumaier</code> uses Neumaier correction
</p>
<p><code>klein</code> uses Klien correction
</p>
<p><code>c</code> uses no correction, bud default/native summing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='psSum'>Using PreciceSums's default method, take a sum</h2><span id='topic+psSum'></span>

<h3>Description</h3>

<p>Using PreciceSums's default method, take a sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psSum(numbers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psSum_+3A_numbers">numbers</code></td>
<td>
<p>A vector of numbers to sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum of numbers
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
