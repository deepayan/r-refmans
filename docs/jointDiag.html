<!DOCTYPE html><html lang="en"><head><title>Help for package jointDiag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {jointDiag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ajd'><p>Wrapper: Joint approximate diagonalization of a set of matrices</p></a></li>
<li><a href='#ffdiag'><p>Joint Approximate Diagonalization of a set of square, symmetric</p>
and real-valued matrices</a></li>
<li><a href='#jadiag'><p>Joint Approximate Diagonalization of a set of square, symmetric</p>
and real-valued matrices</a></li>
<li><a href='#jedi'><p>Approximate non-orthogonal joint diagonalization of a set of square</p>
real-valued matrices</a></li>
<li><a href='#qdiag'><p>Joint Approximate Diagonalization of a set of square, symmetric</p>
and real-valued matrices</a></li>
<li><a href='#uwedge'><p>Joint Approximate Diagonalization of a set of square, symmetric</p>
and real-valued matrices</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-10-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Joint Approximate Diagonalization of a Set of Square Matrices</td>
</tr>
<tr>
<td>Author:</td>
<td>Cedric Gouy-Pailler &lt;cedric.gouypailler@gmail.com&gt; </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cedric Gouy-Pailler &lt;cedric.gouypailler@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Different algorithms to perform approximate joint diagonalization
	of a finite set of square matrices. Depending on the algorithm,
	orthogonal or non-orthogonal diagonalizer is found. These algorithms
	are particularly useful in the context of blind source separation. 
	Original publications of the algorithms can be found in 
	Ziehe et al. (2004), Pham and Cardoso (2001) &lt;<a href="https://doi.org/10.1109%2F78.942614">doi:10.1109/78.942614</a>&gt;, 
	Souloumiac (2009) &lt;<a href="https://doi.org/10.1109%2FTSP.2009.2016997">doi:10.1109/TSP.2009.2016997</a>&gt;, 
	Vollgraff and Obermayer &lt;<a href="https://doi.org/10.1109%2FTSP.2006.877673">doi:10.1109/TSP.2006.877673</a>&gt;. An example of 
	application in the context of Brain-Computer Interfaces EEG denoising
	can be found in Gouy-Pailler et al (2010) &lt;<a href="https://doi.org/10.1109%2FTBME.2009.2032162">doi:10.1109/TBME.2009.2032162</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gouypailler/jointDiag">https://github.com/gouypailler/jointDiag</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-27 12:00:51 UTC; cg228481</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-27 14:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ajd'>Wrapper: Joint approximate diagonalization of a set of matrices</h2><span id='topic+ajd'></span>

<h3>Description</h3>

<p>This function is mainly a wrapper to the different algorithms provided in the
package. So see the help of the different algorithms for the details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ajd(M, A0 = NULL, B0 = NULL, eps = .Machine$double.eps, 
	itermax = 200, keepTrace = FALSE, methods = c("jedi"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ajd_+3A_m">M</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td></tr>
<tr><td><code id="ajd_+3A_a0">A0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of the inverse of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td></tr>
<tr><td><code id="ajd_+3A_b0">B0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td></tr>
<tr><td><code id="ajd_+3A_eps">eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterion difference 
between two
iterations is less than eps.</p>
</td></tr>
<tr><td><code id="ajd_+3A_itermax">itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td></tr>
<tr><td><code id="ajd_+3A_keeptrace">keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td></tr>
<tr><td><code id="ajd_+3A_methods">methods</code></td>
<td>
<p>STRING. One or more methods, choosen among the set of available
algorithms. Possible values are: jedi, ffdiag, jadiag, uwedge, qdiag</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly a wrapper to use the different algorithms provided
in the package (see help of the different functions).
</p>


<h3>Value</h3>

<p>If the number of methods is one, the result is the structure provided by
the algorithm used.
</p>
<p>If the number of methods is more than one, a list of results provided by
each algorithm is given. Names of the list correspond to methods.
</p>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com)</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
ajd(C,method=c("jedi","ffdiag"))
</code></pre>

<hr>
<h2 id='ffdiag'>Joint Approximate Diagonalization of a set of square, symmetric
and real-valued matrices</h2><span id='topic+ffdiag'></span>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square and real-valued matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ffdiag(C0, V0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ffdiag_+3A_c0">C0</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td></tr>
<tr><td><code id="ffdiag_+3A_v0">V0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td></tr>
<tr><td><code id="ffdiag_+3A_eps">eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td></tr>
<tr><td><code id="ffdiag_+3A_itermax">itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td></tr>
<tr><td><code id="ffdiag_+3A_keeptrace">keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set <code class="reqn">C_i</code> of N KxK real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">B</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">B C_i B^T</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td></tr>
<tr><td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td></tr>
<tr><td><code>B_trace</code></td>
<td>
<p>Array of the successive estimates of B across iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com), 
from the initial matlab code by A. Ziehe.</p>


<h3>References</h3>

<p>A. Ziehe, P. Laskov, G. Nolte and K.-R. Mueller;
A Fast Algorithm for Joint Diagonalization with Non-orthogonal
Transformations and its Application to Blind Source Separation;
Journal of Machine Learning Research vol 5, pages 777-800, 2004</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
B_est &lt;- ffdiag(C)$B
# B_est should be an approximate of B=solve(A)
B_est %*% A
# close to a permutation matrix (with random scales)
</code></pre>

<hr>
<h2 id='jadiag'>Joint Approximate Diagonalization of a set of square, symmetric
and real-valued matrices</h2><span id='topic+jadiag'></span>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square, symmetric and real-valued matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jadiag(M, W_est0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jadiag_+3A_m">M</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square, symmetric and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td></tr>
<tr><td><code id="jadiag_+3A_w_est0">W_est0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td></tr>
<tr><td><code id="jadiag_+3A_eps">eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td></tr>
<tr><td><code id="jadiag_+3A_itermax">itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximumu number of
iteration is performed, a warning appears.</p>
</td></tr>
<tr><td><code id="jadiag_+3A_keeptrace">keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set <code class="reqn">C_i</code> of N KxK symmetric and real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">B</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">B C_i B^T</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td></tr>
<tr><td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td></tr>
<tr><td><code>B_trace</code></td>
<td>
<p>Array of the successive estimates of B across iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com), 
from the initial C code by Dinh-Tuan Pham.</p>


<h3>References</h3>

<p>Pham, D. &amp; Cardoso, J.; Blind separation of instantaneous mixtures
of nonstationary sources; IEEE Trans. Signal Process., 2001, 49, 1837-1848</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
B_est &lt;- jadiag(C)$B
# B_est should be an approximate of B=solve(A)
B_est %*% A
# close to a permutation matrix (with random scales)
</code></pre>

<hr>
<h2 id='jedi'>Approximate non-orthogonal joint diagonalization of a set of square
real-valued matrices</h2><span id='topic+jedi'></span>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square and real-valued matrices (not necessarily symmetric). 
The algorithm seeks the inverse of the joint
diagonalizer (the mixing matrix in terms of source separation).
</p>
<p>The algorithm uses Givens and hyperbolic rotations to find the inverse of 
a non-orthogonal joint diagonalizer. It is an extension of the
JADE method (orthogonal joint diagonalization). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jedi(M, A0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jedi_+3A_m">M</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td></tr>
<tr><td><code id="jedi_+3A_a0">A0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of the inverse of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td></tr>
<tr><td><code id="jedi_+3A_eps">eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td></tr>
<tr><td><code id="jedi_+3A_itermax">itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td></tr>
<tr><td><code id="jedi_+3A_keeptrace">keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set <code class="reqn">M_i</code> of <code>N</code> <code>K</code> <code class="reqn">\times</code> <code>K</code> square and
real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">A</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">A^{-1} C_i A^{-T}</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td></tr>
<tr><td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td></tr>
<tr><td><code>A_trace</code></td>
<td>
<p>Array of the successive estimates of A across iterations.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>This algorithm based on a combination of givens and hyperbolic rotations is
covered by a patent (see A. Souloumiac, CEA Saclay).
</p>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com),
with help from Antoine Souloumiac.</p>


<h3>References</h3>

<p>Souloumiac, A.; Non-Orthogonal Joint Diagonalization by Combining
Givens and Hyperbolic Rotations; IEEE Trans. Signal Process., 2009</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
A_est &lt;- jedi(C)$A
# A_est should be an approximate of A
B %*% A_est
# close to a permutation matrix (with random scales)
</code></pre>

<hr>
<h2 id='qdiag'>Joint Approximate Diagonalization of a set of square, symmetric
and real-valued matrices</h2><span id='topic+qdiag'></span>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square, symmetric and real-valued matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdiag(C, W0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qdiag_+3A_c">C</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square, symmetric and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td></tr>
<tr><td><code id="qdiag_+3A_w0">W0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td></tr>
<tr><td><code id="qdiag_+3A_eps">eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td></tr>
<tr><td><code id="qdiag_+3A_itermax">itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td></tr>
<tr><td><code id="qdiag_+3A_keeptrace">keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set <code class="reqn">C_i</code> of N KxK symmetric and real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">B</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">B C_i B^T</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td></tr>
<tr><td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td></tr>
<tr><td><code>B_trace</code></td>
<td>
<p>Array of the successive estimates of B across iterations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Two versions of the quadratic optimization are present in the paper
referenced below. These two
versions have different complexities, <code>O(N K^3)</code> and <code>O(K^5)</code>.
Currently only the version with <code>O(N K^3)</code> is implemented.
</p>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com), 
from the initial matlab code by R. Vollgraf.</p>


<h3>References</h3>

<p>R. Vollgraf and K. Obermayer; Quadratic Optimization for
Approximate Matrix Diagonalization; IEEE Transaction on Signal Processing, 
2006</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
B_est &lt;- qdiag(C)$B
# B_est should be an approximate of B=solve(A)
B_est %*% A
# close to a permutation matrix (with random scales)
</code></pre>

<hr>
<h2 id='uwedge'>Joint Approximate Diagonalization of a set of square, symmetric
and real-valued matrices</h2><span id='topic+uwedge'></span>

<h3>Description</h3>

<p>This function performs a Joint Approximate Diagonalization of a set of
square, symmetric and real-valued matrices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uwedge(M, W_est0 = NULL, eps = .Machine$double.eps, itermax = 200, 
		keepTrace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uwedge_+3A_m">M</code></td>
<td>
<p>DOUBLE ARRAY (KxKxN). Three-dimensional array with dimensions 
KxKxN representing the set
of square, symmetric and real-valued matrices to be jointly diagonalized. 
N is the number of matrices. Matrices
are KxK square matrices.</p>
</td></tr>
<tr><td><code id="uwedge_+3A_w_est0">W_est0</code></td>
<td>
<p>DOUBLE MATRIX (KxK). The initial guess of a joint 
diagonalizer. If NULL, an initial
guess is automatically generated by the algorithm.</p>
</td></tr>
<tr><td><code id="uwedge_+3A_eps">eps</code></td>
<td>
<p>DOUBLE. The algorithm stops when the criterium difference 
between two
iterations is less than eps.</p>
</td></tr>
<tr><td><code id="uwedge_+3A_itermax">itermax</code></td>
<td>
<p>INTEGER. Alternatively, the algorithm stops when itermax 
sweeps have
been performed without reaching convergence. If the maximum number of
iteration is performed, a warning appears.</p>
</td></tr>
<tr><td><code id="uwedge_+3A_keeptrace">keepTrace</code></td>
<td>
<p>BOOLEAN. Do we want to keep the successive estimations of 
the joint diagonalizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a set <code class="reqn">C_i</code> of N KxK symmetric and real-valued matrices, the
algorithm is looking for a matrix <code class="reqn">B</code> such that
<code class="reqn">\forall i \in [1,N]</code>, <code class="reqn">B C_i B^T</code> is as close as possible of a
diagonal matrix. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>Estimation of the Joint Diagonalizer.</p>
</td></tr>
<tr><td><code>criter</code></td>
<td>
<p>Successive estimates of the cost function across sweeps.</p>
</td></tr>
<tr><td><code>B_trace</code></td>
<td>
<p>Array of the successive estimates of B across iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cedric Gouy-Pailler (cedric.gouypailler@gmail.com), 
from the initial matlab code by P. Tichavsky.</p>


<h3>References</h3>

<p>Tichavsky, P. &amp; Yeredor, A.; Fast Approximate Joint Diagonalization
Incorporating Weight Matrices; IEEE Trans. Signal Process., 2009, 57, 878-891</p>


<h3>Examples</h3>

<pre><code class='language-R'># generating diagonal matrices
D &lt;- replicate(30, diag(rchisq(df=1,n=10)), simplify=FALSE)
# Mixing and demixing matrices
B &lt;- matrix(rnorm(100),10,10)
A &lt;- solve(B)
C &lt;- array(NA,dim=c(10,10,30))
for (i in 1:30) C[,,i] &lt;- A %*% D[[i]] %*% t(A)
B_est &lt;- uwedge(C)$B
# B_est should be an approximate of B=solve(A)
B_est %*% A
# close to a permutation matrix (with random scales)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
