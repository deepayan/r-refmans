<!DOCTYPE html><html><head><title>Help for package OOS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OOS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#chart_forecast'><p>Chart forecasts</p></a></li>
<li><a href='#chart_forecast_error'><p>Chart forecast errors</p></a></li>
<li><a href='#data_impute'><p>Impute missing values</p></a></li>
<li><a href='#data_outliers'><p>Clean outliers</p></a></li>
<li><a href='#data_reduction'><p>Dimension reduction via principal components</p></a></li>
<li><a href='#data_subset'><p>Create information set</p></a></li>
<li><a href='#forecast_accuracy'><p>Calculate forecast accuracy</p></a></li>
<li><a href='#forecast_combine'><p>Forecast with forecast combinations</p></a></li>
<li><a href='#forecast_comparison'><p>Compare forecast accuracy</p></a></li>
<li><a href='#forecast_date'><p>Set forecasted date</p></a></li>
<li><a href='#forecast_multivariate'><p>Forecast with multivariate models</p></a></li>
<li><a href='#forecast_univariate'><p>Forecast with univariate models</p></a></li>
<li><a href='#instantiate.data_impute.control_panel'><p>Create interface to control <code>data_impute</code> model estimation</p></a></li>
<li><a href='#instantiate.forecast_combinations.control_panel'><p>Create interface to control <code>forecast_combine</code> model estimation</p></a></li>
<li><a href='#instantiate.forecast_multivariate.ml.control_panel'><p>Create interface to control <code>forecast_multivariate</code> ML estimation</p></a></li>
<li><a href='#instantiate.forecast_multivariate.var.control_panel'><p>Create interface to control <code>forecast_multivariate</code> VAR estimation</p></a></li>
<li><a href='#instantiate.forecast_univariate.control_panel'><p>Create interface to control <code>forecast_univariate</code> model estimation</p></a></li>
<li><a href='#loss_function'><p>Calculate error via loss functions</p></a></li>
<li><a href='#n.lag'><p>Create n lags</p></a></li>
<li><a href='#NBest'><p>Select N-best forecasts</p></a></li>
<li><a href='#standardize'><p>Standardize variables (mean 0, variance 1)</p></a></li>
<li><a href='#winsorize'><p>Winsorize or trim variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Out-of-Sample Time Series Forecasting</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A comprehensive and cohesive API for the out-of-sample forecasting workflow: 
             data preparation, forecasting - including both traditional econometric time series models and 
             modern machine learning techniques - forecast combination, model and error analysis, and 
             forecast visualization. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/tylerJPike/OOS">https://github.com/tylerJPike/OOS</a>,
<a href="https://tylerjpike.github.io/OOS/">https://tylerjpike.github.io/OOS/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tylerJPike/OOS/issues">https://github.com/tylerJPike/OOS/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, dplyr, forecast, furrr, future, ggplot2, glmnet,
imputeTS, lmtest, lubridate, magrittr, purrr, sandwich, stats,
tidyr, vars, xts, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown, quantmod</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-15 12:01:58 UTC; tjpik</td>
</tr>
<tr>
<td>Author:</td>
<td>Tyler J. Pike [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tyler J. Pike &lt;tjpike7@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-17 13:20:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>magrittr pipe operator %&gt;%
</p>

<hr>
<h2 id='chart_forecast'>Chart forecasts</h2><span id='topic+chart_forecast'></span>

<h3>Description</h3>

<p>Chart forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart_forecast(Data, Title, Ylab, Freq, zeroline = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chart_forecast_+3A_data">Data</code></td>
<td>
<p>data.frame: oos.forecast object</p>
</td></tr>
<tr><td><code id="chart_forecast_+3A_title">Title</code></td>
<td>
<p>string: chart title</p>
</td></tr>
<tr><td><code id="chart_forecast_+3A_ylab">Ylab</code></td>
<td>
<p>string: y-axis label</p>
</td></tr>
<tr><td><code id="chart_forecast_+3A_freq">Freq</code></td>
<td>
<p>string: frequency (acts as sub-title)</p>
</td></tr>
<tr><td><code id="chart_forecast_+3A_zeroline">zeroline</code></td>
<td>
<p>boolean: if TRUE then add a horizontal line at zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 chart
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 A = c(1:100) + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, A)

 # run forecast_univariate
 forecast.uni =
   forecast_univariate(
     Data = Data,
     forecast.dates = tail(Data$date,10),
     method = c('naive','auto.arima', 'ets'),
     horizon = 1,
     recursive = FALSE,
     freq = 'month')

 forecasts =
   dplyr::left_join(
     forecast.uni,
     data.frame(date, observed = A),
     by = 'date'
   )

 # chart forecasts
 chart.forecast =
   chart_forecast(
     forecasts,
     Title = 'test',
     Ylab = 'Index',
     Freq = 'Monthly',
     zeroline = TRUE)



</code></pre>

<hr>
<h2 id='chart_forecast_error'>Chart forecast errors</h2><span id='topic+chart_forecast_error'></span>

<h3>Description</h3>

<p>Chart forecast errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chart_forecast_error(Data, Title, Ylab, Freq, zeroline = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chart_forecast_error_+3A_data">Data</code></td>
<td>
<p>data.frame: oos.forecast object</p>
</td></tr>
<tr><td><code id="chart_forecast_error_+3A_title">Title</code></td>
<td>
<p>string: chart title</p>
</td></tr>
<tr><td><code id="chart_forecast_error_+3A_ylab">Ylab</code></td>
<td>
<p>string: y-axis label</p>
</td></tr>
<tr><td><code id="chart_forecast_error_+3A_freq">Freq</code></td>
<td>
<p>string: frequency (acts as sub-title)</p>
</td></tr>
<tr><td><code id="chart_forecast_error_+3A_zeroline">zeroline</code></td>
<td>
<p>boolean: if TRUE then add a horizontal line at zero</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 chart
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 A = c(1:100) + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, A)

 # run forecast_univariate
 forecast.uni =
   forecast_univariate(
     Data = Data,
     forecast.dates = tail(Data$date,10),
     method = c('naive','auto.arima', 'ets'),
     horizon = 1,
     recursive = FALSE,
     freq = 'month')

 forecasts =
   dplyr::left_join(
     forecast.uni,
     data.frame(date, observed = A),
     by = 'date'
   )

 # chart forecast errors
 chart.errors =
   chart_forecast_error(
     forecasts,
     Title = 'test',
     Ylab = 'Index',
     Freq = 'Monthly',
     zeroline = TRUE)



</code></pre>

<hr>
<h2 id='data_impute'>Impute missing values</h2><span id='topic+data_impute'></span>

<h3>Description</h3>

<p>A function to impute missing values. Is used as a data preparation helper function and is called internally
by forecast_univariate, forecast_multivariate, and forecast_combine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_impute(Data, method = "kalman", variables = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_impute_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of target variable, exogenous variables, and observed date (named 'date')</p>
</td></tr>
<tr><td><code id="data_impute_+3A_method">method</code></td>
<td>
<p>string: select which method to use from the imputeTS package; 'interpolation', 'kalman', 'locf', 'ma', 'mean', 'random', 'remove','replace', 'seadec', 'seasplit'</p>
</td></tr>
<tr><td><code id="data_impute_+3A_variables">variables</code></td>
<td>
<p>string: vector of variables to standardize, default is all but 'date' column</p>
</td></tr>
<tr><td><code id="data_impute_+3A_verbose">verbose</code></td>
<td>
<p>boolean: show start-up status of impute.missing.routine</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with missing data imputed
</p>

<hr>
<h2 id='data_outliers'>Clean outliers</h2><span id='topic+data_outliers'></span>

<h3>Description</h3>

<p>A function to clean outliers. Is used as a data preparation helper function and is called internally
by forecast_univariate, forecast_multivariate, and forecast_combine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_outliers(
  Data,
  variables = NULL,
  w.bounds = c(0.05, 0.95),
  trim = FALSE,
  cross_section = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_outliers_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of target variable, exogenous variables, and observed date (named 'date')</p>
</td></tr>
<tr><td><code id="data_outliers_+3A_variables">variables</code></td>
<td>
<p>string: vector of variables to standardize, default is all but 'date' column</p>
</td></tr>
<tr><td><code id="data_outliers_+3A_w.bounds">w.bounds</code></td>
<td>
<p>double: vector of winsorizing minimum and maximum bounds, c(min percentile, max percentile)</p>
</td></tr>
<tr><td><code id="data_outliers_+3A_trim">trim</code></td>
<td>
<p>boolean: if TRUE then replace outliers with NA instead of winsorizing bound</p>
</td></tr>
<tr><td><code id="data_outliers_+3A_cross_section">cross_section</code></td>
<td>
<p>boolean: if TRUE then remove outliers based on cross-section (row-wise) instead of historical data (column-wise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with a date column and one column per forecast method selected
</p>

<hr>
<h2 id='data_reduction'>Dimension reduction via principal components</h2><span id='topic+data_reduction'></span>

<h3>Description</h3>

<p>A function to estimate principal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_reduction(Data, variables = NULL, ncomp, standardize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_reduction_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of target variable, exogenous variables, and observed date (named 'date')</p>
</td></tr>
<tr><td><code id="data_reduction_+3A_variables">variables</code></td>
<td>
<p>string: vector of variables to standardize, default is all but 'date' column</p>
</td></tr>
<tr><td><code id="data_reduction_+3A_ncomp">ncomp</code></td>
<td>
<p>int: number of factors to create</p>
</td></tr>
<tr><td><code id="data_reduction_+3A_standardize">standardize</code></td>
<td>
<p>boolean: normalize variables (mean zero, variance one) before estimating factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with a date column and one column per forecast method selected
</p>

<hr>
<h2 id='data_subset'>Create information set</h2><span id='topic+data_subset'></span>

<h3>Description</h3>

<p>A function to subset data recursively or with a rolling window to create a valid information set. Is used as a data preparation
helper function and is called internally by forecast_univariate, forecast_multivariate, and forecast_combine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_subset(Data, forecast.date, rolling.window, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_subset_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of target variable, exogenous variables, and observed date (named 'date')</p>
</td></tr>
<tr><td><code id="data_subset_+3A_forecast.date">forecast.date</code></td>
<td>
<p>date: upper bound of information set</p>
</td></tr>
<tr><td><code id="data_subset_+3A_rolling.window">rolling.window</code></td>
<td>
<p>int: size of rolling window, NA if expanding window is used</p>
</td></tr>
<tr><td><code id="data_subset_+3A_freq">freq</code></td>
<td>
<p>string: time series frequency; day, week, month, quarter, year; only needed for rolling window factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame bounded by the given date range
</p>

<hr>
<h2 id='forecast_accuracy'>Calculate forecast accuracy</h2><span id='topic+forecast_accuracy'></span>

<h3>Description</h3>

<p>A function to calculate various loss functions, including
MSE, RMSE, MAE, and  MAPE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_accuracy(Data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_accuracy_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of forecasts, model names, and dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame of numeric error results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 A = c(1:100) + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, A)

 # run forecast_univariate
 forecast.uni =
   forecast_univariate(
     Data = Data,
     forecast.dates = tail(Data$date,10),
     method = c('naive','auto.arima', 'ets'),
     horizon = 1,
     recursive = FALSE,
     freq = 'month')

 forecasts =
   dplyr::left_join(
     forecast.uni,
     data.frame(date, observed = A),
     by = 'date'
   )

 # forecast accuracy
 forecast.accuracy = forecast_accuracy(forecasts)



</code></pre>

<hr>
<h2 id='forecast_combine'>Forecast with forecast combinations</h2><span id='topic+forecast_combine'></span>

<h3>Description</h3>

<p>A function to combine forecasts out-of-sample. Methods available include:
uniform weights, median forecast, trimmed (winsorized) mean, n-best,
ridge regression, lasso regression, elastic net, peLASSO,
random forest, tree-based gradient boosting machine, and single-layer neural network.
See package website for most up-to-date list of available models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_combine(
  Data,
  method = "unform",
  n.max = NULL,
  rolling.window = NA,
  trim = c(0.5, 0.95),
  burn.in = 1,
  parallel.dates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_combine_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of forecasted values to combine, assumes 'date' and 'observed' columns, but &lsquo;observed&rsquo; is not necessary for all methods</p>
</td></tr>
<tr><td><code id="forecast_combine_+3A_method">method</code></td>
<td>
<p>string: the method to use; 'uniform', 'median', 'trimmed.mean', 'n.best', 'peLasso', 'lasso', 'ridge', 'elastic', 'RF', 'GBM', 'NN'</p>
</td></tr>
<tr><td><code id="forecast_combine_+3A_n.max">n.max</code></td>
<td>
<p>int: maximum number of forecasts to select in n.best method</p>
</td></tr>
<tr><td><code id="forecast_combine_+3A_rolling.window">rolling.window</code></td>
<td>
<p>int: size of rolling window to evaluate forecast error over, use entire period if NA</p>
</td></tr>
<tr><td><code id="forecast_combine_+3A_trim">trim</code></td>
<td>
<p>numeric: a two element vector with the winsorizing bounds for the trimmed mean method; c(min, max)</p>
</td></tr>
<tr><td><code id="forecast_combine_+3A_burn.in">burn.in</code></td>
<td>
<p>int: the number of periods to use in the first model estimation</p>
</td></tr>
<tr><td><code id="forecast_combine_+3A_parallel.dates">parallel.dates</code></td>
<td>
<p>int: the number of cores available for parallel estimation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with a row for each combination method and forecasted date
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # simple time series
 A = c(1:100) + rnorm(100)
 B = c(1:100) + rnorm(100)
 C = c(1:100) + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, A, B, C)

 # run forecast_univariate
 forecast.multi =
     forecast_multivariate(
       Data = Data,
       target = 'A',
       forecast.dates = tail(Data$date,5),
       method = c('ols','var'),
       horizon = 1,
       freq = 'month')
 # include observed valuesd
 forecasts =
   dplyr::left_join(
     forecast.multi,
     data.frame(date, observed = A),
     by = 'date'
   )

 # combine forecasts
 combinations =
   forecast_combine(
     forecasts,
     method = c('uniform','median','trimmed.mean',
                'n.best','lasso','peLasso'),
     burn.in = 5,
     n.max = 2)



</code></pre>

<hr>
<h2 id='forecast_comparison'>Compare forecast accuracy</h2><span id='topic+forecast_comparison'></span>

<h3>Description</h3>

<p>A function to compare forecasts. Options include: simple forecast error ratios,
<a href="https://www.sas.upenn.edu/~fdiebold/papers/paper68/pa.dm.pdf">Diebold-Mariano test</a>, and <a href="https://www.nber.org/papers/t0326">Clark and West test</a> for nested models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_comparison(
  Data,
  baseline.forecast,
  test = "ER",
  loss = "MSE",
  horizon = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_comparison_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of forecasts, model names, and dates</p>
</td></tr>
<tr><td><code id="forecast_comparison_+3A_baseline.forecast">baseline.forecast</code></td>
<td>
<p>string: column name of baseline (null hypothesis) forecasts</p>
</td></tr>
<tr><td><code id="forecast_comparison_+3A_test">test</code></td>
<td>
<p>string: which test to use; ER = error ratio, DM = Diebold-Mariano, CM = Clark and West</p>
</td></tr>
<tr><td><code id="forecast_comparison_+3A_loss">loss</code></td>
<td>
<p>string: error loss function to use if creating forecast error ratio</p>
</td></tr>
<tr><td><code id="forecast_comparison_+3A_horizon">horizon</code></td>
<td>
<p>int: horizon of forecasts being compared in DM and CW tests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric test result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 # simple time series
 A = c(1:100) + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, A)

 # run forecast_univariate
 forecast.uni =
   forecast_univariate(
     Data = Data,
     forecast.dates = tail(Data$date,10),
     method = c('naive','auto.arima', 'ets'),
     horizon = 1,
     recursive = FALSE,
     freq = 'month')

 forecasts =
   dplyr::left_join(
     forecast.uni,
     data.frame(date, observed = A),
     by = 'date'
   )

 # run ER (MSE)
 er.ratio.mse =
   forecast_comparison(
     forecasts,
     baseline.forecast = 'naive',
     test = 'ER',
     loss = 'MSE')


</code></pre>

<hr>
<h2 id='forecast_date'>Set forecasted date</h2><span id='topic+forecast_date'></span>

<h3>Description</h3>

<p>A function to subset data recursively or with a rolling window to create a valid information set. Is used as a data preparation
helper function and is called internally by forecast_univariate, forecast_multivariate, and forecast_combine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_date(forecast.date, horizon, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_date_+3A_forecast.date">forecast.date</code></td>
<td>
<p>date: date forecast was made</p>
</td></tr>
<tr><td><code id="forecast_date_+3A_horizon">horizon</code></td>
<td>
<p>int: periods ahead of forecast</p>
</td></tr>
<tr><td><code id="forecast_date_+3A_freq">freq</code></td>
<td>
<p>string: time series frequency; day, week, month, quarter, year; only needed for rolling window factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>date vector
</p>

<hr>
<h2 id='forecast_multivariate'>Forecast with multivariate models</h2><span id='topic+forecast_multivariate'></span>

<h3>Description</h3>

<p>A function to estimate multivariate forecasts out-of-sample. Methods available include:
vector auto-regression, linear regression, lasso regression, ridge regression, elastic net,
random forest, tree-based gradient boosting machine, and single-layer neural network.
See package website for most up-to-date list of available models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_multivariate(
  Data,
  forecast.dates,
  target,
  horizon,
  method,
  rolling.window = NA,
  freq,
  lag.variables = NULL,
  lag.n = NULL,
  outlier.clean = FALSE,
  outlier.variables = NULL,
  outlier.bounds = c(0.05, 0.95),
  outlier.trim = FALSE,
  outlier.cross_section = FALSE,
  impute.missing = FALSE,
  impute.method = "kalman",
  impute.variables = NULL,
  impute.verbose = FALSE,
  reduce.data = FALSE,
  reduce.variables = NULL,
  reduce.ncomp = NULL,
  reduce.standardize = TRUE,
  parallel.dates = NULL,
  return.models = FALSE,
  return.data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_multivariate_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of target variable, exogenous variables, and observed date (named 'date'); may alternatively be a <code>ts</code>, <code>xts</code>, or <code>zoo</code> object to forecast</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_forecast.dates">forecast.dates</code></td>
<td>
<p>date: dates forecasts are created</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_target">target</code></td>
<td>
<p>string: column name in Data of variable to forecast</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods into the future to forecast</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_method">method</code></td>
<td>
<p>string: methods to use</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_rolling.window">rolling.window</code></td>
<td>
<p>int: size of rolling window, NA if expanding window is used</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_freq">freq</code></td>
<td>
<p>string: time series frequency; day, week, month, quarter, year</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_lag.variables">lag.variables</code></td>
<td>
<p>string: vector of variables to lag each time step, if lag.n is not null then the default is all non-date variables</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_lag.n">lag.n</code></td>
<td>
<p>int: number of lags to create</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_outlier.clean">outlier.clean</code></td>
<td>
<p>boolean: if TRUE then clean outliers</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_outlier.variables">outlier.variables</code></td>
<td>
<p>string: vector of variables to purge of outlier, default is all but 'date' column</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_outlier.bounds">outlier.bounds</code></td>
<td>
<p>double: vector of winsorizing minimum and maximum bounds, c(min percentile, max percentile)</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_outlier.trim">outlier.trim</code></td>
<td>
<p>boolean: if TRUE then replace outliers with NA instead of winsorizing bound</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_outlier.cross_section">outlier.cross_section</code></td>
<td>
<p>boolean: if TRUE then remove outliers based on cross-section (row-wise) instead of historical data (column-wise)</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_impute.missing">impute.missing</code></td>
<td>
<p>boolean: if TRUE then impute missing values</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_impute.method">impute.method</code></td>
<td>
<p>string: select which method to use from the imputeTS package; 'interpolation', 'kalman', 'locf', 'ma', 'mean', 'random', 'remove','replace', 'seadec', 'seasplit'</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_impute.variables">impute.variables</code></td>
<td>
<p>string: vector of variables to impute missing values, default is all numeric columns</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_impute.verbose">impute.verbose</code></td>
<td>
<p>boolean: show start-up status of impute.missing.routine</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_reduce.data">reduce.data</code></td>
<td>
<p>boolean: if TRUE then reduce dimension</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_reduce.variables">reduce.variables</code></td>
<td>
<p>string: vector of variables to impute missing values, default is all numeric columns</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_reduce.ncomp">reduce.ncomp</code></td>
<td>
<p>int: number of factors to create</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_reduce.standardize">reduce.standardize</code></td>
<td>
<p>boolean: normalize variables (mean zero, variance one) before estimating factors</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_parallel.dates">parallel.dates</code></td>
<td>
<p>int: the number of cores available for parallel estimation</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_return.models">return.models</code></td>
<td>
<p>boolean: if TRUE then return list of models estimated each forecast.date</p>
</td></tr>
<tr><td><code id="forecast_multivariate_+3A_return.data">return.data</code></td>
<td>
<p>boolean: if True then return list of information.set for each forecast.date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with a row for each forecast by model and forecasted date
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # simple time series
 A = c(1:100) + rnorm(100)
 B = c(1:100) + rnorm(100)
 C = c(1:100) + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, A, B, C)

 # run forecast_univariate
 forecast.multi =
     forecast_multivariate(
       Data = Data,
       target = 'A',
       forecast.dates = tail(Data$date,5),
       method = c('ols','var'),
       horizon = 1,
       # information set
       rolling.window = NA,
       freq = 'month',
       # data prep
       lag.n = 4,
       outlier.clean = TRUE,
       impute.missing = TRUE)



</code></pre>

<hr>
<h2 id='forecast_univariate'>Forecast with univariate models</h2><span id='topic+forecast_univariate'></span>

<h3>Description</h3>

<p>A function to estimate univariate forecasts out-of-sample. Methods available include all forecast
methods from the <code>forecast</code> package. See package website for most up-to-date list of available models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_univariate(
  Data,
  forecast.dates,
  methods,
  horizon,
  recursive = TRUE,
  rolling.window = NA,
  freq,
  outlier.clean = FALSE,
  outlier.variables = NULL,
  outlier.bounds = c(0.05, 0.95),
  outlier.trim = FALSE,
  outlier.cross_section = FALSE,
  impute.missing = FALSE,
  impute.method = "kalman",
  impute.variables = NULL,
  impute.verbose = FALSE,
  parallel.dates = NULL,
  return.models = FALSE,
  return.data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forecast_univariate_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of variable to forecast and a date column; may alternatively be a <code>ts</code>, <code>xts</code>, or <code>zoo</code> object to forecast</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_forecast.dates">forecast.dates</code></td>
<td>
<p>date: dates forecasts are created</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_methods">methods</code></td>
<td>
<p>string: models to estimate forecasts</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods to forecast</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_recursive">recursive</code></td>
<td>
<p>boolean: use sequential one-step-ahead forecast if TRUE, use direct projections if FALSE</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_rolling.window">rolling.window</code></td>
<td>
<p>int: size of rolling window, NA if expanding window is used</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_freq">freq</code></td>
<td>
<p>string: time series frequency; day, week, month, quarter, year</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_outlier.clean">outlier.clean</code></td>
<td>
<p>boolean: if TRUE then clean outliers</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_outlier.variables">outlier.variables</code></td>
<td>
<p>string: vector of variables to purge of outliers, default is all but 'date' column</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_outlier.bounds">outlier.bounds</code></td>
<td>
<p>double: vector of winsorizing minimum and maximum bounds, c(min percentile, max percentile)</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_outlier.trim">outlier.trim</code></td>
<td>
<p>boolean: if TRUE then replace outliers with NA instead of winsorizing bound</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_outlier.cross_section">outlier.cross_section</code></td>
<td>
<p>boolean: if TRUE then remove outliers based on cross-section (row-wise) instead of historical data (column-wise)</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_impute.missing">impute.missing</code></td>
<td>
<p>boolean: if TRUE then impute missing values</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_impute.method">impute.method</code></td>
<td>
<p>string: select which method to use from the imputeTS package; 'interpolation', 'kalman', 'locf', 'ma', 'mean', 'random', 'remove','replace', 'seadec', 'seasplit'</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_impute.variables">impute.variables</code></td>
<td>
<p>string: vector of variables to impute missing values, default is all numeric columns</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_impute.verbose">impute.verbose</code></td>
<td>
<p>boolean: show start-up status of impute.missing.routine</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_parallel.dates">parallel.dates</code></td>
<td>
<p>int: the number of cores available for parallel estimation</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_return.models">return.models</code></td>
<td>
<p>boolean: if TRUE then return list of models estimated each forecast.date</p>
</td></tr>
<tr><td><code id="forecast_univariate_+3A_return.data">return.data</code></td>
<td>
<p>boolean: if True then return list of information.set for each forecast.date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with a row for each forecast by model and forecasted date
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # simple time series
 A = c(1:100) + rnorm(100)
 date = seq.Date(from = as.Date('2000-01-01'), by = 'month', length.out = 100)
 Data = data.frame(date = date, A)

 # estiamte univariate forecasts
 forecast.uni =
     forecast_univariate(
       Data = Data,
       forecast.dates = tail(Data$date,5),
       method = c('naive','auto.arima', 'ets'),
       horizon = 1,
       recursive = FALSE,
       # information set
       rolling.window = NA,
       freq = 'month',
       # data prep
       outlier.clean = TRUE,
       impute.missing = TRUE)


</code></pre>

<hr>
<h2 id='instantiate.data_impute.control_panel'>Create interface to control <code>data_impute</code> model estimation</h2><span id='topic+instantiate.data_impute.control_panel'></span>

<h3>Description</h3>

<p>A function to create the data imputation method
arguments list for user manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instantiate.data_impute.control_panel()
</code></pre>


<h3>Value</h3>

<p>data_impute.control_panel
</p>

<hr>
<h2 id='instantiate.forecast_combinations.control_panel'>Create interface to control <code>forecast_combine</code> model estimation</h2><span id='topic+instantiate.forecast_combinations.control_panel'></span>

<h3>Description</h3>

<p>A function to create the forecast combination technique arguments list
for user manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instantiate.forecast_combinations.control_panel(covariates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="instantiate.forecast_combinations.control_panel_+3A_covariates">covariates</code></td>
<td>
<p>int: the number of features that will go into the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>forecast_combinations.control_panel
</p>

<hr>
<h2 id='instantiate.forecast_multivariate.ml.control_panel'>Create interface to control <code>forecast_multivariate</code> ML estimation</h2><span id='topic+instantiate.forecast_multivariate.ml.control_panel'></span>

<h3>Description</h3>

<p>A function to create the multivariate forecast methods
arguments list for user manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instantiate.forecast_multivariate.ml.control_panel(
  covariates = NULL,
  rolling.window = NULL,
  horizon = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="instantiate.forecast_multivariate.ml.control_panel_+3A_covariates">covariates</code></td>
<td>
<p>int: the number of features that will go into the model</p>
</td></tr>
<tr><td><code id="instantiate.forecast_multivariate.ml.control_panel_+3A_rolling.window">rolling.window</code></td>
<td>
<p>int: size of rolling window, NA if expanding window is used</p>
</td></tr>
<tr><td><code id="instantiate.forecast_multivariate.ml.control_panel_+3A_horizon">horizon</code></td>
<td>
<p>int: number of periods into the future to forecast</p>
</td></tr>
</table>


<h3>Value</h3>

<p>forecast_multivariate.ml.control_panel
</p>

<hr>
<h2 id='instantiate.forecast_multivariate.var.control_panel'>Create interface to control <code>forecast_multivariate</code> VAR estimation</h2><span id='topic+instantiate.forecast_multivariate.var.control_panel'></span>

<h3>Description</h3>

<p>A function to create the multivariate forecast methods
arguments list for user manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instantiate.forecast_multivariate.var.control_panel()
</code></pre>


<h3>Value</h3>

<p>forecast_multivariate.var.control_panel
</p>

<hr>
<h2 id='instantiate.forecast_univariate.control_panel'>Create interface to control <code>forecast_univariate</code> model estimation</h2><span id='topic+instantiate.forecast_univariate.control_panel'></span>

<h3>Description</h3>

<p>A function to create the univariate forecast method arguments list
for user manipulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instantiate.forecast_univariate.control_panel()
</code></pre>


<h3>Value</h3>

<p>forecast_univariate.control_panel
</p>

<hr>
<h2 id='loss_function'>Calculate error via loss functions</h2><span id='topic+loss_function'></span>

<h3>Description</h3>

<p>A function to calculate various error loss functions. Options include:
MSE, RMSE, MAE, and  MAPE. The default is MSE loss.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss_function(forecast, observed, metric = "MSE")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loss_function_+3A_forecast">forecast</code></td>
<td>
<p>numeric: vector of forecasted values</p>
</td></tr>
<tr><td><code id="loss_function_+3A_observed">observed</code></td>
<td>
<p>numeric: vector of observed values</p>
</td></tr>
<tr><td><code id="loss_function_+3A_metric">metric</code></td>
<td>
<p>string: loss function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric test result
</p>

<hr>
<h2 id='n.lag'>Create n lags</h2><span id='topic+n.lag'></span>

<h3>Description</h3>

<p>A function to create 1 through n lags of a set of variables. Is used as a data preparation
helper function and is called internally by forecast_univariate, forecast_multivariate, and forecast_combine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n.lag(Data, lags, variables = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n.lag_+3A_data">Data</code></td>
<td>
<p>data.frame: data frame of variables to lag and a 'date' column</p>
</td></tr>
<tr><td><code id="n.lag_+3A_lags">lags</code></td>
<td>
<p>int: number of lags to create</p>
</td></tr>
<tr><td><code id="n.lag_+3A_variables">variables</code></td>
<td>
<p>string: vector of variable names to lag, default is all non-date variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='NBest'>Select N-best forecasts</h2><span id='topic+NBest'></span>

<h3>Description</h3>

<p>A function to subset the n-best forecasts;
assumes column named observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NBest(forecasts, n.max, window = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NBest_+3A_forecasts">forecasts</code></td>
<td>
<p>data.frame: a data frame of forecasts to combine, assumes one column named &quot;observed&quot;</p>
</td></tr>
<tr><td><code id="NBest_+3A_n.max">n.max</code></td>
<td>
<p>int: maximum number of forecasts to select</p>
</td></tr>
<tr><td><code id="NBest_+3A_window">window</code></td>
<td>
<p>int: size of rolling window to evaluate forecast error over, use entire period if NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with n columns of the historically best forecasts
</p>

<hr>
<h2 id='standardize'>Standardize variables (mean 0, variance 1)</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Standardize variables (mean 0, variance 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_x">X</code></td>
<td>
<p>numeric: vector to be standardized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of standardized values
</p>

<hr>
<h2 id='winsorize'>Winsorize or trim variables</h2><span id='topic+winsorize'></span>

<h3>Description</h3>

<p>Winsorize or trim variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>winsorize(X, bounds, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="winsorize_+3A_x">X</code></td>
<td>
<p>numeric: vector to be winsorized or trimmed</p>
</td></tr>
<tr><td><code id="winsorize_+3A_bounds">bounds</code></td>
<td>
<p>double: vector of winsorizing minimum and maximum bounds, c(min percentile, max percentile)</p>
</td></tr>
<tr><td><code id="winsorize_+3A_trim">trim</code></td>
<td>
<p>boolean: if TRUE then replace outliers with NA instead of winsorizing bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of winsorized or trimmed values
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
