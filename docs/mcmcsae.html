<!DOCTYPE html><html><head><title>Help for package mcmcsae</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcmcsae}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ac_fft'><p>Compute autocovariance or autocorrelation function via Wiener-Khinchin theorem</p>
using Fast Fourier Transform</a></li>
<li><a href='#acceptance_rates'><p>Return Metropolis-Hastings acceptance rates</p></a></li>
<li><a href='#aggrMatrix'><p>Utility function to construct a sparse aggregation matrix from a factor</p></a></li>
<li><a href='#anyNA,tabMatrix-method'><p>S4 method for generic 'anyNA' and signature 'tabMatrix'</p></a></li>
<li><a href='#brt'><p>Create a model component object for a BART (Bayesian Additive Regression Trees)</p>
component in the linear predictor</a></li>
<li><a href='#CG'><p>Solve Ax=b by preconditioned conjugate gradients</p></a></li>
<li><a href='#CG_control'><p>Set options for the conjugate gradient (CG) sampler</p></a></li>
<li><a href='#chol_control'><p>Set options for Cholesky decomposition</p></a></li>
<li><a href='#combine_chains'><p>Combine multiple mcdraws objects into a single one by combining their chains</p></a></li>
<li><a href='#combine_iters'><p>Combine multiple mcdraws objects into a single one by combining their draws</p></a></li>
<li><a href='#compute_GMRF_matrices'><p>Compute (I)GMRF incidence, precision and restriction matrices corresponding to a generic model component</p></a></li>
<li><a href='#computeDesignMatrix'><p>Compute a list of design matrices for all terms in a model formula,</p>
or based on a sampler environment</a></li>
<li><a href='#correlation'><p>Correlation factor structures in generic model components</p></a></li>
<li><a href='#create_cMVN_sampler'><p>Set up a a function for direct sampling from a constrained multivariate normal distribution</p></a></li>
<li><a href='#create_sampler'><p>Create a sampler object</p></a></li>
<li><a href='#create_TMVN_sampler'><p>Set up a sampler object for sampling from a possibly truncated and degenerate multivariate normal distribution</p></a></li>
<li><a href='#gen'><p>Create a model component object for a generic random effects component in the linear predictor</p></a></li>
<li><a href='#gen_control'><p>Set computational options for the sampling algorithms used for a 'gen' model component</p></a></li>
<li><a href='#generate_data'><p>Generate a data vector according to a model</p></a></li>
<li><a href='#get_draw'><p>Extract a list of parameter values for a single draw</p></a></li>
<li><a href='#glreg'><p>Create a model object for group-level regression effects within a</p>
generic random effects component.</a></li>
<li><a href='#labels'><p>Get and set the variable labels of a draws component object for a vector-valued parameter</p></a></li>
<li><a href='#Matrix-methods'><p>S4 methods for products of matrix objects</p></a></li>
<li><a href='#matrix-vector'><p>Fast matrix-vector multiplications</p></a></li>
<li><a href='#maximize_log_lh_p'><p>Maximize the log-likelihood or log-posterior as defined by a sampler closure</p></a></li>
<li><a href='#MCMC-diagnostics'><p>Compute MCMC diagnostic measures</p></a></li>
<li><a href='#MCMC-object-conversion'><p>Convert a draws component object to another format</p></a></li>
<li><a href='#mcmcsae_example'><p>Generate artificial data according to an additive spatio-temporal model</p></a></li>
<li><a href='#mcmcsae-family'><p>Functions for specifying a sampling distribution and link function</p></a></li>
<li><a href='#mcmcsae-package'><p>Markov Chain Monte Carlo Small Area Estimation</p></a></li>
<li><a href='#MCMCsim'><p>Run a Markov Chain Monte Carlo simulation</p></a></li>
<li><a href='#mec'><p>Create a model component object for a regression (fixed effects) component</p>
in the linear predictor with measurement errors in quantitative covariates</a></li>
<li><a href='#model_matrix'><p>Compute possibly sparse model matrix</p></a></li>
<li><a href='#model-information-criteria'><p>Compute DIC, WAIC and leave-one-out cross-validation model measures</p></a></li>
<li><a href='#nchains-ndraws-nvars'><p>Get the number of chains, samples per chain or the number of variables in a simulation object</p></a></li>
<li><a href='#par_names'><p>Get the parameter names from an mcdraws object</p></a></li>
<li><a href='#plot_coef'><p>Plot a set of model coefficients or predictions with uncertainty intervals</p>
based on summaries of simulation results or other objects.</a></li>
<li><a href='#plot.dc'><p>Trace, density and autocorrelation plots for (parameters of a) draws</p>
component (dc) object</a></li>
<li><a href='#plot.mcdraws'><p>Trace, density and autocorrelation plots</p></a></li>
<li><a href='#posterior-moments'><p>Get means or standard deviations of parameters from the MCMC output in an mcdraws object</p></a></li>
<li><a href='#pr_exp'><p>Create an object representing exponential prior distributions</p></a></li>
<li><a href='#pr_fixed'><p>Create an object representing a degenerate prior fixing a</p>
parameter (vector) to a fixed value</a></li>
<li><a href='#pr_gamma'><p>Create an object representing gamma prior distributions</p></a></li>
<li><a href='#pr_gig'><p>Create an object representing Generalized Inverse Gaussian (GIG) prior distributions</p></a></li>
<li><a href='#pr_invchisq'><p>Create an object representing inverse chi-squared priors</p>
with possibly modeled degrees of freedom and scale parameters</a></li>
<li><a href='#pr_invwishart'><p>Create an object representing an inverse Wishart prior,</p>
possibly with modeled scale matrix</a></li>
<li><a href='#pr_MLiG'><p>Create an object representing a Multivariate Log inverse Gamma (MLiG) prior distribution</p></a></li>
<li><a href='#pr_normal'><p>Create an object representing a possibly multivariate normal prior distribution</p></a></li>
<li><a href='#predict.mcdraws'><p>Generate draws from the predictive distribution</p></a></li>
<li><a href='#print.dc_summary'><p>Display a summary of a <code>dc</code> object</p></a></li>
<li><a href='#print.mcdraws_summary'><p>Print a summary of MCMC simulation results</p></a></li>
<li><a href='#read_draws'><p>Read MCMC draws from a file</p></a></li>
<li><a href='#reg'><p>Create a model component object for a regression (fixed effects) component</p>
in the linear predictor</a></li>
<li><a href='#residuals-fitted-values'><p>Extract draws of fitted values or residuals from an mcdraws object</p></a></li>
<li><a href='#sampler_control'><p>Set computational options for the sampling algorithms</p></a></li>
<li><a href='#SBC_test'><p>Simulation based calibration</p></a></li>
<li><a href='#setup_CG_sampler'><p>Set up conjugate gradient sampler</p></a></li>
<li><a href='#setup_cluster'><p>Set up a cluster for parallel computing</p></a></li>
<li><a href='#stop_cluster'><p>Stop a cluster</p></a></li>
<li><a href='#subset.dc'><p>Select a subset of chains, samples and parameters from a draws component (dc) object</p></a></li>
<li><a href='#summary.dc'><p>Summarize a draws component (dc) object</p></a></li>
<li><a href='#summary.mcdraws'><p>Summarize an mcdraws object</p></a></li>
<li><a href='#tabMatrix-indexing'><p>S4 method for row and column subsetting a 'tabMatrix'</p></a></li>
<li><a href='#TMVN-methods'><p>Functions for specifying the method and corresponding options for sampling</p>
from a possibly truncated and degenerate multivariate normal distribution</a></li>
<li><a href='#transform_dc'><p>Transform one or more draws component objects into a new one by applying a function</p></a></li>
<li><a href='#vfac'><p>Create a model component object for a variance factor component in the variance function of a</p>
gaussian sampling distribution</a></li>
<li><a href='#vreg'><p>Create a model component object for a regression component in the variance function of a</p>
gaussian sampling distribution</a></li>
<li><a href='#weights.mcdraws'><p>Extract weights from an mcdraws object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.7.7</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Markov Chain Monte Carlo Small Area Estimation</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit multi-level models with possibly correlated
    random effects using Markov Chain Monte Carlo simulation.
    Such models allow smoothing over space and time and are useful in,
    for example, small area estimation.</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-26</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.5.0), Rcpp (&ge; 0.11.0), methods, GIGrvg (&ge; 0.7),
loo (&ge; 2.0.0), matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dbarts, BayesLogit, lintools, splines, spdep, sf, bayesplot,
coda, posterior, parallel, testthat, roxygen2, knitr,
rmarkdown, survey</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen, Matrix, GIGrvg</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'MCMCsim.R' 'MH.R' 'tabMatrix.R' 'MatrixUtils.R'
'RcppExports.R' 'TMVN_methods.R' 'TMVN_sampler.R'
'aux_closures.R' 'cMVN_sampler.R' 'cholesky.R'
'conjugate_gradients.R' 'family.R' 'formulas.R' 'kronprod.R'
'mc_bart.R' 'mc_block.R' 'mc_gen.R' 'mc_gl.R' 'mc_mec.R'
'mc_reg.R' 'mc_vfac.R' 'mc_vreg.R' 'mcmcsae.R' 'model_eval.R'
'modelmatrix.R' 'models.R' 'opts.R' 'parallel.R' 'plots.R'
'prediction.R' 'priors.R' 'random.R' 'samplers.R' 'sbc.R'
'sparse_template.R' 'utils.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-26 20:58:14 UTC; hbta</td>
</tr>
<tr>
<td>Author:</td>
<td>Harm Jan Boonstra [aut, cre],
  Grzegorz Baltissen [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Harm Jan Boonstra &lt;hjboonstra@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-27 03:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ac_fft'>Compute autocovariance or autocorrelation function via Wiener-Khinchin theorem
using Fast Fourier Transform</h2><span id='topic+ac_fft'></span>

<h3>Description</h3>

<p>Compute autocovariance or autocorrelation function via Wiener-Khinchin theorem
using Fast Fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ac_fft(x, demean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ac_fft_+3A_x">x</code></td>
<td>
<p>matrix with time (iteration number) along the rows and variables along the columns.</p>
</td></tr>
<tr><td><code id="ac_fft_+3A_demean">demean</code></td>
<td>
<p>whether to subtract from each column its mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same size as x with autocovariances at all lags from 1 to the number of rows.
</p>

<hr>
<h2 id='acceptance_rates'>Return Metropolis-Hastings acceptance rates</h2><span id='topic+acceptance_rates'></span>

<h3>Description</h3>

<p>Return Metropolis-Hastings acceptance rates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acceptance_rates(obj, aggregate.chains = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acceptance_rates_+3A_obj">obj</code></td>
<td>
<p>an mcdraws object, i.e. the output of function <code><a href="#topic+MCMCsim">MCMCsim</a></code>.</p>
</td></tr>
<tr><td><code id="acceptance_rates_+3A_aggregate.chains">aggregate.chains</code></td>
<td>
<p>whether to return averages over chains or results per chain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of acceptance rates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
# specify a model that requires MH sampling (in this case for a modeled
#   degrees of freedom parameter in the variance part of the model)
sampler &lt;- create_sampler(ex$model, data=ex$dat, formula.V=~vfac(factor="fA",
  prior=pr_invchisq(df="modeled")))
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, n.chain=4, store.all=TRUE)
(summary(sim))
acceptance_rates(sim)


</code></pre>

<hr>
<h2 id='aggrMatrix'>Utility function to construct a sparse aggregation matrix from a factor</h2><span id='topic+aggrMatrix'></span>

<h3>Description</h3>

<p>Utility function to construct a sparse aggregation matrix from a factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggrMatrix(fac, w = 1, mean = FALSE, facnames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggrMatrix_+3A_fac">fac</code></td>
<td>
<p>factor variable.</p>
</td></tr>
<tr><td><code id="aggrMatrix_+3A_w">w</code></td>
<td>
<p>vector of weights associated with the levels of <code>fac</code>.</p>
</td></tr>
<tr><td><code id="aggrMatrix_+3A_mean">mean</code></td>
<td>
<p>if <code>TRUE</code>, aggregation will produce (weighted) means instead of sums.</p>
</td></tr>
<tr><td><code id="aggrMatrix_+3A_facnames">facnames</code></td>
<td>
<p>whether the factor levels should be used as column names for the aggregation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse aggregation matrix of class <code>tabMatrix</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
f &lt;- sample(1:100, n, replace=TRUE)
x &lt;- runif(n)
M &lt;- aggrMatrix(f)
all.equal(crossprod_mv(M, x), as.vector(tapply(x, f, sum)))

</code></pre>

<hr>
<h2 id='anyNA+2CtabMatrix-method'>S4 method for generic 'anyNA' and signature 'tabMatrix'</h2><span id='topic+anyNA+2CtabMatrix-method'></span>

<h3>Description</h3>

<p>S4 method for generic 'anyNA' and signature 'tabMatrix'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tabMatrix'
anyNA(x, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anyNA+2B2CtabMatrix-method_+3A_x">x</code></td>
<td>
<p>a tabMatrix object.</p>
</td></tr>
<tr><td><code id="anyNA+2B2CtabMatrix-method_+3A_recursive">recursive</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Whether the tabMatrix object contains missings or not.
</p>

<hr>
<h2 id='brt'>Create a model component object for a BART (Bayesian Additive Regression Trees)
component in the linear predictor</h2><span id='topic+brt'></span>

<h3>Description</h3>

<p>This function is intended to be used on the right hand side of the
<code>formula</code> argument to <code><a href="#topic+create_sampler">create_sampler</a></code> or
<code><a href="#topic+generate_data">generate_data</a></code>. It creates a BART term in the
model's linear predictor. To use this model component one needs
to have R package <span class="pkg">dbarts</span> installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brt(
  formula,
  X = NULL,
  n.trees = 75L,
  name = "",
  debug = FALSE,
  keepTrees = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="brt_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the predictors to be used in the BART
model component. Variable names are looked up in the data frame
passed as <code>data</code> argument to <code><a href="#topic+create_sampler">create_sampler</a></code> or
<code><a href="#topic+generate_data">generate_data</a></code>, or in <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="brt_+3A_x">X</code></td>
<td>
<p>a design matrix can be specified directly, as an alternative
to the creation of one based on <code>formula</code>. If <code>X</code> is
specified <code>formula</code> is ignored.</p>
</td></tr>
<tr><td><code id="brt_+3A_n.trees">n.trees</code></td>
<td>
<p>number of trees used in the BART ensemble.</p>
</td></tr>
<tr><td><code id="brt_+3A_name">name</code></td>
<td>
<p>the name of the model component. This name is used in the output of the
MCMC simulation function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. By default the name will be 'bart'
with the number of the model term attached.</p>
</td></tr>
<tr><td><code id="brt_+3A_debug">debug</code></td>
<td>
<p>if <code>TRUE</code> a breakpoint is set at the beginning of the posterior
draw function associated with this model component. Mainly intended for developers.</p>
</td></tr>
<tr><td><code id="brt_+3A_keeptrees">keepTrees</code></td>
<td>
<p>whether to store the trees ensemble for each Monte Carlo draw. This
is required for prediction based on new data. The default is <code>FALSE</code> to save
memory.</p>
</td></tr>
<tr><td><code id="brt_+3A_...">...</code></td>
<td>
<p>parameters passed to <code><a href="dbarts.html#topic+dbarts">dbarts</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with precomputed quantities and functions for sampling from
prior or conditional posterior distributions for this model component. Intended
for internal use by other package functions.
</p>


<h3>References</h3>

<p>H.A. Chipman, E.I. Georgea and R.E. McCulloch (2010).
BART: Bayesian additive regression trees.
The Annals of Applied Statistics 4(1), 266-298.
</p>
<p>J.H. Friedman (1991).
Multivariate adaptive regression splines.
The Annals of Statistics 19, 1-67.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate data, based on an example in Friedman (1991)
gendat &lt;- function(n=200L, p=10L, sigma=1) {
  x &lt;- matrix(runif(n * p), n, p)
  mu &lt;- 10*sin(pi*x[, 1] * x[, 2]) + 20*(x[, 3] - 0.5)^2 + 10*x[, 4] + 5*x[, 5]
  y &lt;- mu + sigma * rnorm(n)
  data.frame(x=x, mu=mu, y=y)
}

train &lt;- gendat()
test &lt;- gendat(n=25)

# keep trees for later prediction based on new data
sampler &lt;- create_sampler(
  y ~ brt(~ . - y, name="bart", keepTrees=TRUE),
  sigma.mod=pr_invchisq(df=3,  scale=var(train$y)),
  data = train
)
sim &lt;- MCMCsim(sampler, n.chain=2, n.iter=700, thin=2,
  store.all=TRUE, verbose=FALSE)
(summ &lt;- summary(sim))
plot(train$mu, summ$bart[, "Mean"]); abline(0, 1)
# NB prediction is currently slow

pred &lt;- predict(sim, newdata=test,
  iters=sample(seq_len(ndraws(sim)), 100),
  show.progress=FALSE
)
(summpred &lt;- summary(pred))
plot(test$mu, summpred[, "Mean"]); abline(0, 1)


</code></pre>

<hr>
<h2 id='CG'>Solve Ax=b by preconditioned conjugate gradients</h2><span id='topic+CG'></span>

<h3>Description</h3>

<p>Solve Ax=b by preconditioned conjugate gradients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CG(b, env, x = NULL, max.it = NULL, e = NULL, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CG_+3A_b">b</code></td>
<td>
<p>right hand side vector.</p>
</td></tr>
<tr><td><code id="CG_+3A_env">env</code></td>
<td>
<p>environment containing at least a function <code>A_times</code> that computes
the matrix-vector product Ax for some input vector x, and a function <code>M_solve</code>
that computes M^-1 x for some preconditioner matrix M.</p>
</td></tr>
<tr><td><code id="CG_+3A_x">x</code></td>
<td>
<p>start value for the conjugate gradient algorithm.</p>
</td></tr>
<tr><td><code id="CG_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="CG_+3A_e">e</code></td>
<td>
<p>total squared error stop criterion.</p>
</td></tr>
<tr><td><code id="CG_+3A_verbose">verbose</code></td>
<td>
<p>whether progress information is shown.</p>
</td></tr>
<tr><td><code id="CG_+3A_...">...</code></td>
<td>
<p>any parameters passed to <code>A_times</code> and <code>M_solve</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (approximated) solution to Ax=b.
</p>


<h3>References</h3>

<p>M.R. Hestenes and E. Stiefel (1952).
Methods of conjugate gradients for solving linear systems.
Journal of Research of the National Bureau of Standards 49(6), 409-436.
</p>

<hr>
<h2 id='CG_control'>Set options for the conjugate gradient (CG) sampler</h2><span id='topic+CG_control'></span>

<h3>Description</h3>

<p>Set options for the conjugate gradient (CG) sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CG_control(
  max.it = NULL,
  stop.criterion = NULL,
  preconditioner = c("GMRF", "GMRF2", "GMRF3", "identity"),
  scale = 1,
  chol.control = chol_control(),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CG_control_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of CG iterations.</p>
</td></tr>
<tr><td><code id="CG_control_+3A_stop.criterion">stop.criterion</code></td>
<td>
<p>total squared error stop criterion for the CG algorithm.</p>
</td></tr>
<tr><td><code id="CG_control_+3A_preconditioner">preconditioner</code></td>
<td>
<p>one of  &quot;GMRF&quot;, &quot;GMRF2&quot;, &quot;GMRF3&quot; and &quot;identity&quot;.</p>
</td></tr>
<tr><td><code id="CG_control_+3A_scale">scale</code></td>
<td>
<p>scale parameter; only used by the &quot;GMRF3&quot; preconditioner.</p>
</td></tr>
<tr><td><code id="CG_control_+3A_chol.control">chol.control</code></td>
<td>
<p>options for Cholesky decomposition, see <code><a href="#topic+chol_control">chol_control</a></code>.</p>
</td></tr>
<tr><td><code id="CG_control_+3A_verbose">verbose</code></td>
<td>
<p>whether diagnostic information about the CG sampler is shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of options used by the conjugate gradients algorithm.
</p>

<hr>
<h2 id='chol_control'>Set options for Cholesky decomposition</h2><span id='topic+chol_control'></span>

<h3>Description</h3>

<p>These options are only effective in case the matrix to be decomposed is sparse, i.p.
of class <code><a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol_control(perm = NULL, super = NA, ordering = 0L, inplace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol_control_+3A_perm">perm</code></td>
<td>
<p>logical scalar, see <code><a href="Matrix.html#topic+Cholesky">Cholesky</a></code>. If <code>NULL</code>, the default,
the choice is left to a simple heuristic.</p>
</td></tr>
<tr><td><code id="chol_control_+3A_super">super</code></td>
<td>
<p>logical scalar, see <code><a href="Matrix.html#topic+Cholesky">Cholesky</a></code>.</p>
</td></tr>
<tr><td><code id="chol_control_+3A_ordering">ordering</code></td>
<td>
<p>an integer scalar passed to CHOLMOD routines determining which reordering
schemes are tried to limit sparse Cholesky fill-in.</p>
</td></tr>
<tr><td><code id="chol_control_+3A_inplace">inplace</code></td>
<td>
<p>whether sparse Cholesky updates should re-use the same memory location.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with specified options used for Cholesky decomposition.
</p>

<hr>
<h2 id='combine_chains'>Combine multiple mcdraws objects into a single one by combining their chains</h2><span id='topic+combine_chains'></span>

<h3>Description</h3>

<p>This function can be used to combine the results of parallel simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_chains(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_chains_+3A_...">...</code></td>
<td>
<p>objects of class <code>mcdraws</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined object of class <code>mcdraws</code> where the number of stored
chains equals the sum of the numbers of chains in the input objects.
</p>

<hr>
<h2 id='combine_iters'>Combine multiple mcdraws objects into a single one by combining their draws</h2><span id='topic+combine_iters'></span>

<h3>Description</h3>

<p>This function is used to combine the results of parallel posterior predictive simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_iters(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_iters_+3A_...">...</code></td>
<td>
<p>objects of class <code>mcdraws</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A combined object of class <code>mcdraws</code> where the number of stored
draws equals the sum of the numbers of draws in the input objects.
</p>

<hr>
<h2 id='compute_GMRF_matrices'>Compute (I)GMRF incidence, precision and restriction matrices corresponding to a generic model component</h2><span id='topic+compute_GMRF_matrices'></span>

<h3>Description</h3>

<p>This function computes incidence, precision and restriction matrices, or
a subset thereof, for a Gaussian Markov Random Field (GMRF).
A GMRF is specified by a formula passed to the <code>factor</code> argument,
in the same way as for the <code>factor</code> argument of <code><a href="#topic+gen">gen</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_GMRF_matrices(
  factor,
  data,
  D = TRUE,
  Q = TRUE,
  R = TRUE,
  cols2remove = NULL,
  remove.redundant.R.cols = TRUE,
  enclos = .GlobalEnv,
  n.parent = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_GMRF_matrices_+3A_factor">factor</code></td>
<td>
<p>factor formula of a generic model component,
see <code><a href="#topic+gen">gen</a></code>.</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_data">data</code></td>
<td>
<p>data frame to be used in deriving the matrices.</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_d">D</code></td>
<td>
<p>if <code>TRUE</code> compute the incidence matrix.</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_q">Q</code></td>
<td>
<p>if <code>TRUE</code> compute the precision matrix.</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_r">R</code></td>
<td>
<p>if <code>TRUE</code> compute the restriction matrix.</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_cols2remove">cols2remove</code></td>
<td>
<p>if an integer vector is passed, the dimensions (columns of D,
rows and columns of Q and rows of R) that are removed. This can be useful in the
case of empty domains.</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_remove.redundant.r.cols">remove.redundant.R.cols</code></td>
<td>
<p>whether to test for and remove redundant restrictions from restriction matrix R</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_enclos">enclos</code></td>
<td>
<p>enclosure to look for objects not found in <code>data</code>.</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_n.parent">n.parent</code></td>
<td>
<p>for internal use; in case of custom factor, the number of frames up
the calling stack in which to evaluate any custom matrices</p>
</td></tr>
<tr><td><code id="compute_GMRF_matrices_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>economizeMatrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing some or all of the components <code>D</code> (incidence matrix),
<code>Q</code> (precision matrix) and <code>R</code> (restriction matrix).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
dat &lt;- data.frame(
  x = rnorm(n),
  f1 = factor(sample(1:50, n, replace=TRUE)),
  f2 = factor(sample(1:10, n, replace=TRUE))
)
mats &lt;- compute_GMRF_matrices(~ f1 * RW1(f2), dat)
str(mats)

</code></pre>

<hr>
<h2 id='computeDesignMatrix'>Compute a list of design matrices for all terms in a model formula,
or based on a sampler environment</h2><span id='topic+computeDesignMatrix'></span>

<h3>Description</h3>

<p>If <code>sampler</code> is provided instead of <code>formula</code>, the design matrices
are based on the model used to create the sampler environment. In that case, if
<code>data</code> is <code>NULL</code>, the design matrices stored in <code>sampler</code> are returned,
otherwise the design matrices are computed for the provided data based on the sampler's model.
The output is a list of dense or sparse design matrices for the model components
with respect to <code>data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeDesignMatrix(formula = NULL, data = NULL, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeDesignMatrix_+3A_formula">formula</code></td>
<td>
<p>model formula.</p>
</td></tr>
<tr><td><code id="computeDesignMatrix_+3A_data">data</code></td>
<td>
<p>data frame to be used in deriving the design matrices.</p>
</td></tr>
<tr><td><code id="computeDesignMatrix_+3A_labels">labels</code></td>
<td>
<p>if <code>TRUE</code>, column names are assigned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of design matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
dat &lt;- data.frame(
  x = rnorm(n),
  f = factor(sample(1:50, n, replace=TRUE))
)
str(computeDesignMatrix(~ x, dat)[[1]])
model &lt;- ~ reg(~x, name="beta") + gen(~x, factor=~f, name="v")
X &lt;- computeDesignMatrix(model, dat)
str(X)

</code></pre>

<hr>
<h2 id='correlation'>Correlation factor structures in generic model components</h2><span id='topic+correlation'></span><span id='topic+iid'></span><span id='topic+RW1'></span><span id='topic+RW2'></span><span id='topic+AR1'></span><span id='topic+season'></span><span id='topic+spatial'></span><span id='topic+spline'></span><span id='topic+custom'></span>

<h3>Description</h3>

<p>Element 'factor' of a model component created using function
<code><a href="#topic+gen">gen</a></code> is a formula composed of several possible terms described
below. It is used to derive a (typically sparse) precision matrix for a set of
coefficients, and possibly a matrix representing a set of linear constraints
to be imposed on the coefficient vector.
</p>

<dl>
<dt>iid(f)</dt><dd><p>Independent effects corresponding to the levels of factor <code>f</code>.</p>
</dd>
<dt>RW1(f, circular=FALSE, w=NULL)</dt><dd><p>First-order random walk over the levels of factor <code>f</code>.
The random walk can be made circular and different (fixed) weights can be attached to the innovations.
If specified, <code>w</code> must be a positive numeric vector of length one less than the number of
factor levels. For example, if the levels correspond to different times, it would often be
reasonable to choose <code>w</code> proportional to the reciprocal time differences. For equidistant
times there is generally no need to specify <code>w</code>.</p>
</dd>
<dt>RW2(f)</dt><dd><p>Second-order random walk.</p>
</dd>
<dt>AR1(f, phi, w=NULL)</dt><dd><p>First-order autoregressive correlation structure among
the levels of <code>f</code>. Required argument is the (fixed) autoregressive parameter <code>phi</code>.
For irregularly spaced AR(1) processes weights can be specified, in the same way as for
<code>RW1</code>.</p>
</dd>
<dt>season(f, period)</dt><dd><p>Dummy seasonal with period <code>period</code>.</p>
</dd>
<dt>spatial(f, poly.df, snap, queen, derive.constraints=FALSE)</dt><dd><p>CAR spatial correlation.
Argument <code>poly.df</code> can either be an object of (S4) class <code>SpatialPolygonsDataFrame</code>
or an object of (S3) class <code>sf</code>. The latter can be obtained, e.g., from reading in a
shape file using function <code><a href="sf.html#topic+st_read">st_read</a></code>. Arguments <code>snap</code> and <code>queen</code>
are passed to <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>.
If <code>derive.constraints=TRUE</code> the constraint matrix for an IGMRF model component
is formed by computing the singular vectors of the precision matrix.</p>
</dd>
<dt>spline(f, knots, degree)</dt><dd><p>P-splines, i.e. penalized B-splines structure over
the domain of a quantitative variable f. Arguments knots and degree are passed to
<code><a href="splines.html#topic+splineDesign">splineDesign</a></code>. If <code>knots</code> is a single value it is interpreted as
the number of knots, otherwise as a vector of knot positions. By default 40 equally spaced
knots are used, and a degree of 3.</p>
</dd>
<dt>custom(f, D=NULL, Q=NULL, R=NULL, derive.constraints=NULL)</dt><dd><p>Either a custom precision or incidence
matrix associated with factor f can be passed to argument <code>Q</code> or <code>D</code>. Optionally a
constraint matrix can be supplied as <code>R</code>, or constraints can be derived from the null space
of the precision matrix by setting <code>derive.constraints=TRUE</code>.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>iid(name)

RW1(name, circular = FALSE, w = NULL)

RW2(name)

AR1(name, phi, w = NULL)

season(name, period)

spatial(name, poly.df, snap = sqrt(.Machine$double.eps), queen = TRUE)

spline(name, knots, degree)

custom(name, D = NULL, Q = NULL, R = NULL, derive.constraints = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_+3A_name">name</code></td>
<td>
<p>name of a variable, unquoted.</p>
</td></tr>
<tr><td><code id="correlation_+3A_circular">circular</code></td>
<td>
<p>whether the random walk is circular.</p>
</td></tr>
<tr><td><code id="correlation_+3A_w">w</code></td>
<td>
<p>a vector of weights.</p>
</td></tr>
<tr><td><code id="correlation_+3A_phi">phi</code></td>
<td>
<p>value of an autoregressive parameter.</p>
</td></tr>
<tr><td><code id="correlation_+3A_period">period</code></td>
<td>
<p>a positive integer specifying the seasonal period.</p>
</td></tr>
<tr><td><code id="correlation_+3A_poly.df">poly.df</code></td>
<td>
<p>a spatial data frame.</p>
</td></tr>
<tr><td><code id="correlation_+3A_snap">snap</code></td>
<td>
<p>passed to <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>.</p>
</td></tr>
<tr><td><code id="correlation_+3A_queen">queen</code></td>
<td>
<p>passed to <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>.</p>
</td></tr>
<tr><td><code id="correlation_+3A_knots">knots</code></td>
<td>
<p>passed to <code><a href="splines.html#topic+splineDesign">splineDesign</a></code>.</p>
</td></tr>
<tr><td><code id="correlation_+3A_degree">degree</code></td>
<td>
<p>passed to <code><a href="splines.html#topic+splineDesign">splineDesign</a></code>.</p>
</td></tr>
<tr><td><code id="correlation_+3A_d">D</code></td>
<td>
<p>custom incidence matrix.</p>
</td></tr>
<tr><td><code id="correlation_+3A_q">Q</code></td>
<td>
<p>custom precision matrix.</p>
</td></tr>
<tr><td><code id="correlation_+3A_r">R</code></td>
<td>
<p>custom restriction matrix.</p>
</td></tr>
<tr><td><code id="correlation_+3A_derive.constraints">derive.constraints</code></td>
<td>
<p>whether to derive the constraint matrix for an
IGMRF model component numerically from the precision matrix.</p>
</td></tr>
</table>


<h3>References</h3>

<p>B. Allevius (2018).
On the precision matrix of an irregularly sampled AR(1) process.
arXiv:1801.03791.
</p>
<p>H. Rue and L. Held (2005).
Gaussian Markov Random Fields.
Chapman &amp; Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example of CAR spatial random effects
if (requireNamespace("sf")) {
  # 1. load a shape file of counties in North Carolina
  nc &lt;- sf::st_read(system.file("shape/nc.shp", package="sf"))
  # 2. generate some data according to a model with a few regression
  # effects, as well as spatial random effects
  gd &lt;- generate_data(
    ~ reg(~ AREA + BIR74, prior=pr_normal(precision=1), name="beta") +
      gen(factor = ~ spatial(NAME, poly.df=nc), name="vs"),
    sigma.mod = pr_invchisq(df=10, scale=1),
    data = nc
  )
  # add the generated target variable and the spatial random effects to the
  # spatial dataframe object
  nc$y &lt;- gd$y
  nc$vs_true &lt;- gd$pars$vs
  # 3. fit a model to the generated data, and see to what extent the
  #    parameters used to generate the data, gd$pars, are reproduced
  sampler &lt;- create_sampler(
    y ~ reg(~ AREA + BIR74, prior=pr_normal(precision=1), name="beta") +
    gen(factor = ~ spatial(NAME, poly.df=nc), name="vs"),
    block=TRUE, data=nc
  )
  sim &lt;- MCMCsim(sampler, store.all=TRUE, n.iter=600, n.chain=2, verbose=FALSE)
  (summ &lt;- summary(sim))
  nc$vs &lt;- summ$vs[, "Mean"]
  plot(nc[c("vs_true", "vs")])
  plot(gd$pars$vs, summ$vs[, "Mean"]); abline(0, 1, col="red")
}


</code></pre>

<hr>
<h2 id='create_cMVN_sampler'>Set up a a function for direct sampling from a constrained multivariate normal distribution</h2><span id='topic+create_cMVN_sampler'></span>

<h3>Description</h3>

<p>Set up a a function for direct sampling from a constrained multivariate normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_cMVN_sampler(
  mbs,
  X,
  Q,
  R = NULL,
  r = NULL,
  sampler,
  name = "x",
  chol.control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_cMVN_sampler_+3A_mbs">mbs</code></td>
<td>
<p>block component containing several model components.</p>
</td></tr>
<tr><td><code id="create_cMVN_sampler_+3A_x">X</code></td>
<td>
<p>design matrix.</p>
</td></tr>
<tr><td><code id="create_cMVN_sampler_+3A_q">Q</code></td>
<td>
<p>(structured) precision matrix.</p>
</td></tr>
<tr><td><code id="create_cMVN_sampler_+3A_r">R</code></td>
<td>
<p>equality restriction matrix.</p>
</td></tr>
<tr><td><code id="create_cMVN_sampler_+3A_r">r</code></td>
<td>
<p>rhs vector for equality constraints <code class="reqn">R'x = r</code>, where <code class="reqn">R'</code> denotes the transpose of R.</p>
</td></tr>
<tr><td><code id="create_cMVN_sampler_+3A_sampler">sampler</code></td>
<td>
<p>sampler object as created by <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="create_cMVN_sampler_+3A_name">name</code></td>
<td>
<p>name of the cMVN vector parameter.</p>
</td></tr>
<tr><td><code id="create_cMVN_sampler_+3A_chol.control">chol.control</code></td>
<td>
<p>options for Cholesky decomposition, see <code><a href="#topic+chol_control">chol_control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment with precomputed quantities and functions for sampling
from a multivariate normal distribution subject to equality constraints.
</p>

<hr>
<h2 id='create_sampler'>Create a sampler object</h2><span id='topic+create_sampler'></span>

<h3>Description</h3>

<p>This function sets up a sampler object, based on the specification of a model. The object contains functions to
draw a set of model parameters from their prior and conditional posterior distributions, and
to generate starting values for the MCMC simulation. The functions share a common environment
containing precomputed quantities such as design matrices based on the model and the data.
The sampler object is the main input for the MCMC simulation function <code><a href="#topic+MCMCsim">MCMCsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_sampler(
  formula,
  data = NULL,
  family = "gaussian",
  ny = NULL,
  ry = NULL,
  r.mod,
  sigma.fixed = NULL,
  sigma.mod = NULL,
  Q0 = NULL,
  formula.V = NULL,
  logJacobian = NULL,
  linpred = NULL,
  compute.weights = FALSE,
  block = NULL,
  prior.only = FALSE,
  control = sampler_control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_sampler_+3A_formula">formula</code></td>
<td>
<p>formula to specify the response variable and additive model components. The model components
form the linear predictor part of the model. A model component on the right hand side can be either
a regression term specified by <code><a href="#topic+reg">reg</a>(...)</code>, a covariates subject to error term specified
by <code><a href="#topic+mec">mec</a>(...)</code>, or a generic random effect term specified by <code><a href="#topic+gen">gen</a>(...)</code>.
See for details the help pages for these model component creation functions.
An offset can be specified as <code>offset(...)</code>.
Other terms in the formula are collectively interpreted as ordinary regression effects,
treated in the same way as a <code>reg(...)</code> term, but without the option to change the prior.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_data">data</code></td>
<td>
<p>data frame with n rows in which the variables specified in model components can be found.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_family">family</code></td>
<td>
<p>character string describing the data distribution. The default is 'gaussian'.
Other options are 'binomial', 'multinomial', 'negbinomial' for the negative binomial distribution,
'poisson', and 'gamma'. See <a href="#topic+mcmcsae-family">mcmcsae-family</a> for the related functions
that can be used to specify <code>family</code> and associated parameters and controls.
For the binomial distribution logistic and probit link functions are supported, the latter only
for binary data. For the negative binomial, Poisson and gamma sampling distributions
a log link function is assumed.
Note that currently <code>family = 'poisson'</code> is implemented using the negative
binomial distribution with its (reciprocal) overdispersion parameter set
to a very large value.
For categorical or multinomial data, <code>family = "multinomial"</code> can be used. The implementation
is based on a stick-breaking representation of the multinomial distribution, and the logistic link
function relates each category except the last to a linear predictor. The categories can be
referenced in the model specification formula by 'cat_'.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_ny">ny</code></td>
<td>
<p>in case <code>family="binomial"</code> the (vector of) numbers of trials.
It can be either a numeric vector or the name of a variable in <code>data</code>.
Defaults to a vector of 1s.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_ry">ry</code></td>
<td>
<p>in case <code>family="negbinomial"</code> the known, i.e. fixed part of the (reciprocal)
dispersion parameter. It can be specified either as a numeric vector or the name of a
numeric variable in <code>data</code>. The overall dispersion parameter is the product of <code>ry</code>
with a positive scalar factor modelled as specified by argument <code>r.mod</code>. By default
<code>ry</code> is taken to be 1. For <code>family = "poisson"</code> a single value can be specified,
determining how well the Poisson distribution is approximated by the negative binomial distribution.
The value should be large enough such that the negative binomial's overdispersion
becomes negligible, but not too large as this might result in slow MCMC mixing. The default is
<code>ry=100</code> in this case.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_r.mod">r.mod</code></td>
<td>
<p>prior specification for a scalar (reciprocal) dispersion parameter
of the negative binomial distribution. The prior can be specified by a call to a prior
specification function. Currently <code><a href="#topic+pr_invchisq">pr_invchisq</a></code>, <code><a href="#topic+pr_gig">pr_gig</a></code> and
<code><a href="#topic+pr_fixed">pr_fixed</a></code> are supported. The default is a chi-squared prior with 1 degree
of freedom. To set the overall dispersion parameter to the value(s) specified by <code>ry</code>,
use <code>r.mod = pr_fixed(value=1)</code>.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_sigma.fixed">sigma.fixed</code></td>
<td>
<p>for Gaussian models, if <code>TRUE</code> the residual standard deviation parameter 'sigma_' is fixed at 1. In that case
argument <code>sigma.mod</code> is ignored. This is convenient for Fay-Herriot type models with (sampling) variances assumed to be known.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_sigma.mod">sigma.mod</code></td>
<td>
<p>prior for the variance parameter of a gaussian sampling distribution.
This can be specified by a call to one of the prior specification functions
<code><a href="#topic+pr_invchisq">pr_invchisq</a></code>, <code><a href="#topic+pr_exp">pr_exp</a></code>, <code><a href="#topic+pr_gig">pr_gig</a></code> or <code><a href="#topic+pr_fixed">pr_fixed</a></code> for
inverse chi-squared, exponential, generalized inverse gaussian or degenerate prior distribution,
respectively. The default is an improper prior <code>pr_invchisq(df=0, scale=1)</code>. A half-t prior on the
standard deviation can be specified using <code><a href="#topic+pr_invchisq">pr_invchisq</a></code> with a chi-squared distributed scale
parameter.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_q0">Q0</code></td>
<td>
<p>n x n data-level precision matrix for a Gaussian model. It defaults to the unit matrix.
If an n-vector is provided it will be expanded to a (sparse) diagonal matrix with Q0 on its diagonal.
If a name is supplied it will be looked up in <code>data</code> and subsequently expanded to a diagonal matrix.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_formula.v">formula.V</code></td>
<td>
<p>a formula specifying the terms of a variance model in the case of a Gaussian likelihood.
Currently two types of terms are supported: a regression term for the log-variance
specified with <code><a href="#topic+vreg">vreg</a>(...)</code>, and a term <code><a href="#topic+vfac">vfac</a>(...)</code> for multiplicative modeled factors
at a certain level specified by a factor variable. By using unit-level inverse-chi-squared factors the marginal
sampling distribution becomes a Student-t distribution, and by using unit-level exponential factors it becomes
a Laplace or double exponential distribution.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_logjacobian">logJacobian</code></td>
<td>
<p>if the data are transformed the logarithm of the Jacobian can be supplied so that it
is incorporated in all log-likelihood computations. This can be useful for comparing information criteria
for different transformations. It should be supplied as a vector of the same size as the response variable,
and is currently only supported if <code>family="gaussian"</code>.
For example, when a log-transformation is used on response vector <code>y</code>, the vector <code>-log(y)</code>
should be supplied.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_linpred">linpred</code></td>
<td>
<p>a list of matrices defining (possibly out-of-sample) linear predictors to be simulated.
This allows inference on e.g. (sub)population totals or means. The list must be of the form
<code>list(name_1=X_1, ...)</code> where the names refer to the model component names and predictions are
computed by summing <code>X_i %*% p[[name_i]]</code>. Alternatively, <code>linpred="fitted"</code> can be used
as a short-cut for simulations of the full in-sample linear predictor.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_compute.weights">compute.weights</code></td>
<td>
<p>if <code>TRUE</code> weights are computed for each element of <code>linpred</code>. Note that for
a large dataset in combination with vector-valued linear predictors the weights can take up a lot of memory.
By default only means are stored in the simulation carried out using <code><a href="#topic+MCMCsim">MCMCsim</a></code>.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_block">block</code></td>
<td>
<p>DEPRECATED, please use argument <code>control</code> instead, see also <code><a href="#topic+sampler_control">sampler_control</a></code>.
Note that this parameter is now by default set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_prior.only">prior.only</code></td>
<td>
<p>whether a sampler is set up only for sampling from the prior or for sampling from both prior
and posterior distributions. Default <code>FALSE</code>. If <code>TRUE</code> there is no need to specify a response in
<code>formula</code>. This is used by <code><a href="#topic+generate_data">generate_data</a></code>, which samples from the prior predictive
distribution.</p>
</td></tr>
<tr><td><code id="create_sampler_+3A_control">control</code></td>
<td>
<p>a list with further computational options. These options can
be specified using function <code><a href="#topic+sampler_control">sampler_control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The right hand side of the <code>formula</code> argument to <code>create_sampler</code> can be used to specify
additive model components. Currently four model components are supported: <code><a href="#topic+reg">reg</a>(...)</code>
for regression or 'fixed' effects, <code><a href="#topic+gen">gen</a>(...)</code> for generic random effects,
<code><a href="#topic+mec">mec</a>(...)</code> for measurement in covariates effects, and <code><a href="#topic+brt">brt</a>(...)</code>
for a Bayesian additive regression trees component. Note that an offset can be added
separately, in the usual way using <code><a href="stats.html#topic+offset">offset</a>(...)</code>.
</p>
<p>For gaussian models, <code>formula.V</code> can be used to specify the variance structure of the model.
Currently two specialized variance model components are supported, <code><a href="#topic+vreg">vreg</a>(...)</code> for regression
effects predicting the log-variance and <code><a href="#topic+vfac">vfac</a>(...)</code> for modeled variance factors.
</p>


<h3>Value</h3>

<p>A sampler object, which is the main input for the MCMC simulation
function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. The sampler object is an environment with
precomputed quantities and functions. The main functions are <code>rprior</code>,
which returns a sample from the prior distributions, <code>draw</code>,
which returns a sample from the full conditional posterior distributions,
and <code>start</code>, which returns a list with starting values for the Gibbs
sampler. If <code>prior.only</code> is <code>TRUE</code>, functions <code>draw</code> and
<code>start</code> are not created.
</p>


<h3>References</h3>

<p>J.H. Albert and S. Chib (1993).
Bayesian analysis of binary and polychotomous response data.
Journal of the American statistical Association 88(422), 669-679.
</p>
<p>D. Bates, M. Maechler, B. Bolker and S.C. Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4.
Journal of Statistical Software 67(1), 1-48.
</p>
<p>S.W. Linderman, M.J. Johnson and R.P. Adams (2015).
Dependent multinomial models made easy: Stick-breaking with the Polya-Gamma augmentation.
Advances in Neural Information Processing Systems, 3456-3464.
</p>
<p>P.A. Parker, S.H. Holan and R. Janicki (2023).
Conjugate Modeling Approaches for Small Area Estimation with Heteroscedastic Structure.
Journal of Survey Statistics and Methodology, smad002.
</p>
<p>N. Polson, J.G. Scott and J. Windle (2013).
Bayesian Inference for Logistic Models Using Polya-Gamma Latent Variables.
Journal of the American Statistical Association 108(504), 1339-1349.
</p>
<p>H. Rue and L. Held (2005).
Gaussian Markov Random Fields.
Chapman &amp; Hall/CRC.
</p>
<p>M. Zhou and L. Carin (2015).
Negative Binomial Process Count and Mixture Modeling.
IEEE Transactions on Pattern Analysis and Machine Intelligence 37(2), 307-320.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some data
n &lt;- 200
x &lt;- rnorm(n)
y &lt;- 0.5 + 2*x + 0.3*rnorm(n)
# create a sampler for a simple linear regression model
sampler &lt;- create_sampler(y ~ x)
sim &lt;- MCMCsim(sampler)
(summary(sim))

y &lt;- rbinom(n, 1, 1 / (1 + exp(-(0.5 + 2*x))))
# create a sampler for a binary logistic regression model
sampler &lt;- create_sampler(y ~ x, family="binomial")
sim &lt;- MCMCsim(sampler)
(summary(sim))

</code></pre>

<hr>
<h2 id='create_TMVN_sampler'>Set up a sampler object for sampling from a possibly truncated and degenerate multivariate normal distribution</h2><span id='topic+create_TMVN_sampler'></span>

<h3>Description</h3>

<p>This function sets up an object for multivariate normal sampling based on a specified precision matrix.
Linear equality and inequality restrictions are supported.
For sampling under inequality restrictions four algorithms are available. The default in that case is
an exact Hamiltonian Monte Carlo algorithm (Pakman and Paninski, 2014). A related algorithm is the zig-zag
Hamiltonian Monte Carlo method (Nishimura et al., 2021) in which momentum is sampled from a Laplace instead
of normal distribution. Alternatively, a Gibbs sampling algorithm can be used (Rodriguez-Yam et al., 2004).
The fourth option is a data augmentation method that samples from a smooth approximation to the truncated
multivariate normal distribution (Souris et al., 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_TMVN_sampler(
  Q,
  mu = NULL,
  Xy = NULL,
  update.Q = FALSE,
  update.mu = update.Q,
  name = "x",
  coef.names = NULL,
  R = NULL,
  r = NULL,
  S = NULL,
  s = NULL,
  lower = NULL,
  upper = NULL,
  check.constraints = FALSE,
  method = NULL,
  reduce = NULL,
  chol.control = chol_control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_TMVN_sampler_+3A_q">Q</code></td>
<td>
<p>precision matrix of the (unconstrained) multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_mu">mu</code></td>
<td>
<p>mean of the (unconstrained) multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_xy">Xy</code></td>
<td>
<p>alternative to specifying mu; in this case <code>mu</code> is computed as <code class="reqn">Q^{-1}\code{Xy}</code>.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_update.q">update.Q</code></td>
<td>
<p>whether <code>Q</code> is updated for each draw.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_update.mu">update.mu</code></td>
<td>
<p>whether <code>mu</code> is updated for each draw. By default equal to <code>update.Q</code>.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_name">name</code></td>
<td>
<p>name of the TMVN vector parameter.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_coef.names">coef.names</code></td>
<td>
<p>optional labels for the components of the vector parameter.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_r">R</code></td>
<td>
<p>equality restriction matrix.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_r">r</code></td>
<td>
<p>rhs vector for equality constraints <code class="reqn">R'x = r</code>, where <code class="reqn">R'</code> denotes the transpose of R.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_s">S</code></td>
<td>
<p>inequality restriction matrix.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_s">s</code></td>
<td>
<p>rhs vector for inequality constraints <code class="reqn">S'x &gt;= s</code>, where <code class="reqn">S'</code> denotes the transpose of S.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_lower">lower</code></td>
<td>
<p>alternative to <code>s</code> for two-sided inequality restrictions <code class="reqn">\code{lower} &lt;= S'x &lt;= \code{upper}</code>.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_upper">upper</code></td>
<td>
<p>alternative to <code>s</code> for two-sided inequality restrictions <code class="reqn">\code{lower} &lt;= S'x &lt;= \code{upper}</code>.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_check.constraints">check.constraints</code></td>
<td>
<p>if <code>TRUE</code> check whether the starting values satisfy all constraints.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_method">method</code></td>
<td>
<p>sampling method. The options are &quot;direct&quot; for direct sampling from the
unconstrained or equality constrained multivariate normal (MVN). For inequality constrained
MVN sampling three methods are supported: &quot;HMC&quot; for (exact) Hamiltonian Monte Carlo,
&quot;HMCZigZag&quot; for (exact) Hamiltonian Monte Carlo with Laplace momentum, &quot;Gibbs&quot; for a
component-wise Gibbs sampling approach, and &quot;softTMVN&quot; for a data augmentation method that samples
from a smooth approximation to the truncated MVN. Alternatively, the method setting
functions <code>m_direct</code>, <code>m_HMC</code>, <code>m_HMC_ZigZag</code>, <code>m_Gibbs</code> or
<code>m_softTMVN</code> can be used to select the method and possibly set some of its
options to non-default values, see <code><a href="#topic+TMVN-methods">TMVN-methods</a></code>.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_reduce">reduce</code></td>
<td>
<p>whether to a priori restrict the simulation to the subspace defined by the
equality constraints.</p>
</td></tr>
<tr><td><code id="create_TMVN_sampler_+3A_chol.control">chol.control</code></td>
<td>
<p>options for Cholesky decomposition, see <code><a href="#topic+chol_control">chol_control</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The componentwise Gibbs sampler uses univariate truncated normal samplers as described
in Botev and L'Ecuyer (2016). These samplers are implemented in R package <span class="pkg">TruncatedNormal</span>,
but here translated to C++ for an additional speed-up.
</p>


<h3>Value</h3>

<p>An environment for sampling from a possibly degenerate and truncated multivariate normal
distribution.
</p>


<h3>Author(s)</h3>

<p>Harm Jan Boonstra, with help from Grzegorz Baltissen
</p>


<h3>References</h3>

<p>Z.I. Botev and P. L'Ecuyer (2016).
Simulation from the Normal Distribution Truncated to an Interval in the Tail.
in VALUETOOLS.
</p>
<p>Y. Cong, B. Chen and M. Zhou (2017).
Fast simulation of hyperplane-truncated multivariate normal distributions.
Bayesian Analysis 12(4), 1017-1037.
</p>
<p>Y. Li and S.K. Ghosh (2015). Efficient sampling methods for truncated multivariate normal
and student-t distributions subject to linear inequality constraints.
Journal of Statistical Theory and Practice 9(4), 712-732.
</p>
<p>A. Nishimura, Z. Zhang and M.A. Suchard (2021). Hamiltonian zigzag sampler got more momentum
than its Markovian counterpart: Equivalence of two zigzags under a momentum refreshment limit.
arXiv:2104.07694.
</p>
<p>A. Pakman and L. Paninski (2014).
Exact Hamiltonian Monte Carlo for truncated multivariate gaussians.
Journal of Computational and Graphical Statistics 23(2), 518-542.
</p>
<p>G. Rodriguez-Yam, R.A. Davis and L.L. Scharf (2004).
Efficient Gibbs sampling of truncated multivariate normal with application to constrained linear regression.
Unpublished manuscript.
</p>
<p>H. Rue and L. Held (2005).
Gaussian Markov Random Fields.
Chapman &amp; Hall/CRC.
</p>
<p>A. Souris, A. Bhattacharya and P. Debdeep (2018).
The Soft Multivariate Truncated Normal Distribution.
arXiv:1807.09155.
</p>
<p>K.A. Valeriano, C.E. Galarza and L.A. Matos (2023).
Moments and random number generation for the truncated elliptical family of distributions.
Statistics and Computing 33(1), 1-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
S &lt;- cbind(diag(2), c(-1, 1), c(1.1, -1))  # inequality matrix
# S'x &gt;= 0 represents the wedge x1 &lt;= x2 &lt;= 1.1 x1
# example taken from Pakman and Paninski (2014)
# 1. exact Hamiltonian Monte Carlo (Pakman and Paninski, 2014)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="HMC")
sim &lt;- MCMCsim(sampler, n.iter=600, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")
# 2. exact Hamiltonian Monte Carlo with Laplace momentum (Nishimura et al., 2021)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="HMCZigZag")
sim &lt;- MCMCsim(sampler, n.iter=600, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")
# 3. Gibbs sampling approach (Rodriguez-Yam et al., 2004)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="Gibbs")
sim &lt;- MCMCsim(sampler, burnin=500, n.iter=2000, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")
# 4. soft TMVN approximation (Souris et al., 2018)
sampler &lt;- create_TMVN_sampler(Q=diag(2), mu=c(4, 4), S=S, method="softTMVN")
sim &lt;- MCMCsim(sampler, n.iter=600, verbose=FALSE)
summary(sim)
plot(as.matrix(sim$x), pch=".")


</code></pre>

<hr>
<h2 id='gen'>Create a model component object for a generic random effects component in the linear predictor</h2><span id='topic+gen'></span>

<h3>Description</h3>

<p>This function is intended to be used on the right hand side of the <code>formula</code> argument to
<code><a href="#topic+create_sampler">create_sampler</a></code> or <code><a href="#topic+generate_data">generate_data</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen(
  formula = ~1,
  factor = NULL,
  remove.redundant = FALSE,
  drop.empty.levels = FALSE,
  X = NULL,
  var = NULL,
  prior = NULL,
  Q0 = NULL,
  PX = NULL,
  GMRFmats = NULL,
  priorA = NULL,
  Leroux = FALSE,
  R0 = NULL,
  RA = NULL,
  constr = NULL,
  S0 = NULL,
  SA = NULL,
  formula.gl = NULL,
  a = 1000,
  name = "",
  sparse = NULL,
  control = gen_control(),
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_+3A_formula">formula</code></td>
<td>
<p>a model formula specifying the effects that vary over the levels of
the factor variable(s) specified by argument <code>factor</code>. Defaults to <code>~1</code>,
corresponding to random intercepts. If <code>X</code> is specified <code>formula</code> is ignored.
Variable names are looked up in the data frame passed as <code>data</code> argument to
<code><a href="#topic+create_sampler">create_sampler</a></code> or <code><a href="#topic+generate_data">generate_data</a></code>, or in <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_factor">factor</code></td>
<td>
<p>a formula with factors by which the effects specified in the <code>formula</code>
argument vary. Often only one such factor is needed but multiple factors are allowed so that
interaction terms can be modeled conveniently. The formula must take the form
<code> ~ f1(fac1, ...) * f2(fac2, ...) ...</code>, where
<code>fac1, fac2</code> are factor variables and <code>f1, f2</code> determine the
correlation structure assumed between levels of each factor, and the <code>...</code> indicate
that for some correlation types further arguments can be passed. Correlation structures
currently supported include <code>iid</code> for independent identically distributed effects,
<code>RW1</code> and <code>RW2</code> for random walks of first or second order over the factor levels,
<code>AR1</code> for first-order autoregressive effects, <code>season</code> for seasonal effects,
<code>spatial</code> for spatial (CAR) effects and <code>custom</code> for supplying a custom
precision matrix corresponding to the levels of the factor. For further details about
the correlation structures, and further arguments that can be passed, see
<code><a href="#topic+correlation">correlation</a></code>. Argument <code>factor</code> is ignored if <code>X</code> is specified.
The factor variables are looked up in the data frame passed as <code>data</code> argument to
<code><a href="#topic+create_sampler">create_sampler</a></code> or <code><a href="#topic+generate_data">generate_data</a></code>, or in <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_remove.redundant">remove.redundant</code></td>
<td>
<p>whether redundant columns should be removed from the model matrix
associated with <code>formula</code>. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_drop.empty.levels">drop.empty.levels</code></td>
<td>
<p>whether to remove factor levels without observations.</p>
</td></tr>
<tr><td><code id="gen_+3A_x">X</code></td>
<td>
<p>A (possibly sparse) design matrix. This can be used instead of <code>formula</code> and <code>factor</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_var">var</code></td>
<td>
<p>the (co)variance structure among the varying effects defined by <code>formula</code>
over the levels of the factors defined by <code>factor</code>.
The default is <code>"unstructured"</code>, meaning that a full covariance matrix
parameterization is used. For uncorrelated effects with unequal variances use
<code>var="diagonal"</code>. For uncorrelated effects with equal variances use <code>var="scalar"</code>.
In the case of a single varying effect there is no difference between these choices.</p>
</td></tr>
<tr><td><code id="gen_+3A_prior">prior</code></td>
<td>
<p>the prior specification for the variance parameters of the random effects.
These can currently be specified by a call to <code><a href="#topic+pr_invwishart">pr_invwishart</a></code> in case
<code>var="unstructured"</code> or by a call to <code><a href="#topic+pr_invchisq">pr_invchisq</a></code> otherwise.
See the documentation of those prior specification functions for more details.</p>
</td></tr>
<tr><td><code id="gen_+3A_q0">Q0</code></td>
<td>
<p>precision matrix associated with <code>formula</code>. This can only be used in
combination with <code>var="scalar"</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_px">PX</code></td>
<td>
<p>whether parameter expansion should be used. Default is <code>TRUE</code>, which
applies parameter expansion with default options. The only exception is that for
gamma sampling distributions the default is <code>FALSE</code>, i.e. no parameter expansion.
Alternative options can be specified
by supplying a list with one or more of the following components:
</p>

<dl>
<dt>prior</dt><dd><p>prior for the multiplicative expansion parameter. Defaults to a
normal prior with mean 0 and standard deviation 1, unless the sampling
distribution is gamma in which case the default is a Multivariate Log
inverse Gamma prior. The default parameters can be changed using functions
<code><a href="#topic+pr_normal">pr_normal</a></code> or <code><a href="#topic+pr_MLiG">pr_MLiG</a></code>.</p>
</dd>
<dt>vector</dt><dd><p>whether a redundant multiplicative expansion parameter is used for each varying effect
specified by <code>formula</code>. The default is <code>TRUE</code> except when <code>var="scalar"</code>.
If <code>FALSE</code> a single redundant multiplicative parameter is used.</p>
</dd>
<dt>data.scale</dt><dd><p>whether the data level scale is used as a variance factor for the expansion
parameters. Default is <code>TRUE</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="gen_+3A_gmrfmats">GMRFmats</code></td>
<td>
<p>list of incidence/precision/constraint matrices. This can be specified
as an alternative to <code>factor</code>. It should be a list such as that returned
by <code><a href="#topic+compute_GMRF_matrices">compute_GMRF_matrices</a></code>. Can be used together with argument <code>X</code>
as a flexible alternative to <code>formula</code> and <code>factor</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_priora">priorA</code></td>
<td>
<p>prior distribution for scale factors at the variance scale associated with <code>QA</code>.
In case of IGMRF models the scale factors correspond to the innovations.
The default <code>NULL</code> means not to use any local scale factors.
A prior can currently be specified using <code><a href="#topic+pr_invchisq">pr_invchisq</a></code> or <code><a href="#topic+pr_exp">pr_exp</a></code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_leroux">Leroux</code></td>
<td>
<p>this option alters the precision matrix determined by <code>factor</code> by taking a
weighted average of it with the identity matrix. If <code>TRUE</code> the model gains an additional parameter,
the 'Leroux' parameter, being the weight of the original, structured, precision matrix in the weighted
average. By default a uniform prior for the weight and a uniform Metropolis-Hastings proposal density
are employed. This default can be changed by supplying a list with elements a, b, and a.star, b.star,
implying a beta(a, b) prior and a beta(a.star, b.star) independence proposal density. A third option is
to supply a single number between 0 and 1, which is then used as a fixed value for the Leroux parameter.</p>
</td></tr>
<tr><td><code id="gen_+3A_r0">R0</code></td>
<td>
<p>an optional equality restriction matrix acting on the coefficients defined by <code>formula</code>, for each
level defined by <code>factor</code>. If c is the number of restrictions, <code>R0</code> is a
q0 x c matrix where q0 is the number of columns of the design matrix derived
from <code>formula</code>. Together with <code>RA</code> it defines the set of equality constraints
to be imposed on the vector of coefficients. Only allowed in combination with <code>var="scalar"</code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_ra">RA</code></td>
<td>
<p>an optional equality restriction matrix acting on the coefficients defined by <code>factor</code>,
for each effect defined by <code>formula</code>. If c is the number of restrictions, <code>RA</code> is a
l x c matrix where l is the number of levels defined by <code>factor</code>.
Together with <code>R0</code> this defines the set of equality constraints to be imposed on the vector
of coefficients.
If <code>constr=TRUE</code>, additional constraints are imposed, corresponding to the
null-vectors of the singular precision matrix in case of an intrinsic Gaussian Markov Random Field.</p>
</td></tr>
<tr><td><code id="gen_+3A_constr">constr</code></td>
<td>
<p>whether constraints corresponding to the null-vectors of the precision matrix
are to be imposed on the vector of coefficients. By default this is <code>TRUE</code> for
improper or intrinsic GMRF model components, i.e. components with a singular precision matrix
such as random walks or CAR spatial components.</p>
</td></tr>
<tr><td><code id="gen_+3A_s0">S0</code></td>
<td>
<p>an optional inequality restriction matrix acting on the coefficients defined by <code>formula</code>, for each
level defined by <code>factor</code>. If c is the number of restrictions, <code>S0</code> is a
q0 x c matrix where q0 is the number of columns of the design matrix derived
from <code>formula</code>. Together with <code>SA</code> it defines the set of inequality constraints
to be imposed on the vector of coefficients.</p>
</td></tr>
<tr><td><code id="gen_+3A_sa">SA</code></td>
<td>
<p>an optional inequality restriction matrix acting on the coefficients defined by <code>factor</code>,
for each effect defined by <code>formula</code>. If c is the number of restrictions, <code>SA</code> is a
l x c matrix where l is the number of levels defined by <code>factor</code>.
Together with <code>S0</code> this defines the set of constraints to be imposed on the vector
of coefficients.</p>
</td></tr>
<tr><td><code id="gen_+3A_formula.gl">formula.gl</code></td>
<td>
<p>a formula of the form <code>~ glreg(...)</code> for group-level predictors
around which the random effect component is hierarchically centered.
See <code><a href="#topic+glreg">glreg</a></code> for details.</p>
</td></tr>
<tr><td><code id="gen_+3A_a">a</code></td>
<td>
<p>only used in case the effects are MLiG distributed, such as is
assumed in case of a gamma sampling distribution, or for
gaussian variance modelling. In those cases <code>a</code> controls how close
the effects' prior is to a normal prior, see <code><a href="#topic+pr_MLiG">pr_MLiG</a></code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_name">name</code></td>
<td>
<p>the name of the model component. This name is used in the output of the MCMC simulation
function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. By default the name will be 'gen' with the number of the model term attached.</p>
</td></tr>
<tr><td><code id="gen_+3A_sparse">sparse</code></td>
<td>
<p>whether the model matrix associated with <code>formula</code> should be sparse.
The default is based on a simple heuristic based on storage size.</p>
</td></tr>
<tr><td><code id="gen_+3A_control">control</code></td>
<td>
<p>a list with further computational options. These options can
be specified using function <code><a href="#topic+gen_control">gen_control</a></code>.</p>
</td></tr>
<tr><td><code id="gen_+3A_debug">debug</code></td>
<td>
<p>if <code>TRUE</code> a breakpoint is set at the beginning of the posterior
draw function associated with this model component. Mainly intended for developers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with precomputed quantities and functions for sampling from
prior or conditional posterior distributions for this model component. Intended
for internal use by other package functions.
</p>


<h3>References</h3>

<p>J. Besag and C. Kooperberg (1995).
On Conditional and Intrinsic Autoregression.
Biometrika 82(4), 733-746.
</p>
<p>C.M. Carvalho, N.G. Polson and J.G. Scott (2010).
The horseshoe estimator for sparse signals.
Biometrika 97(2), 465-480.
</p>
<p>L. Fahrmeir, T. Kneib and S. Lang (2004).
Penalized Structured Additive Regression for Space-Time Data:
a Bayesian Perspective.
Statistica Sinica 14, 731-761.
</p>
<p>A. Gelman (2006).
Prior distributions for variance parameters in hierarchical models.
Bayesian Analysis 1(3), 515-533.
</p>
<p>A. Gelman, D.A. Van Dyk, Z. Huang and W.J. Boscardin (2008).
Using Redundant Parameterizations to Fit Hierarchical Models.
Journal of Computational and Graphical Statistics 17(1), 95-122.
</p>
<p>B. Leroux, X. Lei and N. Breslow (1999).
Estimation of Disease Rates in Small Areas: A New Mixed Model for Spatial Dependence.
In M. Halloran and D. Berry (Eds.), Statistical Models in Epidemiology,
the Environment and Clinical Trials, 135-178.
</p>
<p>T. Park and G. Casella (2008).
The Bayesian Lasso.
Journal of the American Statistical Association 103(482), 681-686.
</p>
<p>H. Rue and L. Held (2005).
Gaussian Markov Random Fields.
Chapman &amp; Hall/CRC.
</p>

<hr>
<h2 id='gen_control'>Set computational options for the sampling algorithms used for a 'gen' model component</h2><span id='topic+gen_control'></span>

<h3>Description</h3>

<p>Set computational options for the sampling algorithms used for a 'gen' model component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_control(MHprop = c("GiG", "LNRW"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_control_+3A_mhprop">MHprop</code></td>
<td>
<p>MH proposal for the variance component in case of a MLiG prior
on the coefficients. The two options are &quot;GiG&quot; for a generalized inverse gamma
proposal, and &quot;LNRW&quot; for a log_normal random walk proposal. The former should
approximate the conditional posterior quite well provided MLiG parameter <code>a</code>
is large, such that the coefficients' prior is approximately normal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with computational options regarding a 'gen' model component.
</p>

<hr>
<h2 id='generate_data'>Generate a data vector according to a model</h2><span id='topic+generate_data'></span>

<h3>Description</h3>

<p>This function generates draws from the prior predictive distribution.
Parameter values are drawn from their priors, and consequently data is
generated from the sampling distribution given these parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_data(
  formula,
  data = NULL,
  family = "gaussian",
  ny = NULL,
  ry = NULL,
  r.mod,
  sigma.fixed = NULL,
  sigma.mod = NULL,
  Q0 = NULL,
  formula.V = NULL,
  linpred = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_data_+3A_formula">formula</code></td>
<td>
<p>A model formula, see <code><a href="#topic+create_sampler">create_sampler</a></code>.
Any left-hand-side of the formula is ignored.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_data">data</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_family">family</code></td>
<td>
<p>sampling distribution family, see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_ny">ny</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_ry">ry</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_r.mod">r.mod</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sigma.fixed">sigma.fixed</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_sigma.mod">sigma.mod</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_q0">Q0</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_formula.v">formula.V</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="generate_data_+3A_linpred">linpred</code></td>
<td>
<p>see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a generated data vector and a list of prior means of the
parameters. The parameters are drawn from their priors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 250
dat &lt;- data.frame(
  x = rnorm(n),
  g = factor(sample(1:10, n, replace=TRUE)),
  ny = 10
)
gd &lt;- generate_data(
  ~ reg(~ 1 + x, Q0=10, b0=c(0, 1), name="beta") + gen(factor = ~ g, name="v"),
  family="binomial", ny="ny", data=dat
)
gd
plot(dat$x, gd$y)


</code></pre>

<hr>
<h2 id='get_draw'>Extract a list of parameter values for a single draw</h2><span id='topic+get_draw'></span>

<h3>Description</h3>

<p>Extract a list of parameter values for a single draw
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_draw(obj, iter, chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_draw_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>mcdraws</code>.</p>
</td></tr>
<tr><td><code id="get_draw_+3A_iter">iter</code></td>
<td>
<p>iteration number.</p>
</td></tr>
<tr><td><code id="get_draw_+3A_chain">chain</code></td>
<td>
<p>chain number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with all parameter values of draw <code>iter</code> from chain <code>chain</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=50)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, n.chain=4, store.all=TRUE)
get_draw(sim, iter=20, chain=3)


</code></pre>

<hr>
<h2 id='glreg'>Create a model object for group-level regression effects within a
generic random effects component.</h2><span id='topic+glreg'></span>

<h3>Description</h3>

<p>This function is intended to be used to specify the <code>formula.gl</code> argument to
the <code><a href="#topic+gen">gen</a></code> model component specification function.
Group-level predictors and hierarchical centering are
not used by default, and they currently cannot be used in a model component that is sampled
together with another model component in the same Gibbs block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glreg(
  formula = NULL,
  remove.redundant = FALSE,
  prior = NULL,
  Q0 = NULL,
  data = NULL,
  name = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glreg_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the group-level predictors to be used within a model
component. If no <code>data</code> is supplied the group-level predictors are derived as
group-level means from the unit-level data passed as <code>data</code> argument to
<code><a href="#topic+create_sampler">create_sampler</a></code> or <code><a href="#topic+generate_data">generate_data</a></code>.</p>
</td></tr>
<tr><td><code id="glreg_+3A_remove.redundant">remove.redundant</code></td>
<td>
<p>whether redundant columns should be removed from the design matrix.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="glreg_+3A_prior">prior</code></td>
<td>
<p>prior specification for the group-level effects. Currently only
normal priors with mean 0 can be specified, using function <code><a href="#topic+pr_normal">pr_normal</a></code>.</p>
</td></tr>
<tr><td><code id="glreg_+3A_q0">Q0</code></td>
<td>
<p>prior precision matrix for the group-level effects. The default is a
zero matrix corresponding to a noninformative improper prior.
DEPRECATED, please use argument <code>prior</code> instead, i.e.
<code>prior = pr_normal(precision = Q0.value)</code>.</p>
</td></tr>
<tr><td><code id="glreg_+3A_data">data</code></td>
<td>
<p>group-level data frame in which the group-level variables specified in
<code>formula</code> are looked up.</p>
</td></tr>
<tr><td><code id="glreg_+3A_name">name</code></td>
<td>
<p>the name of the model component. This name is used in the output of the
MCMC simulation function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. By default this name will be
the name of the corresponding generic random effects component appended by '_gl'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with precomputed quantities for sampling from
prior or conditional posterior distributions for this model component. Only intended
for internal use by other package functions.
</p>

<hr>
<h2 id='labels'>Get and set the variable labels of a draws component object for a vector-valued parameter</h2><span id='topic+labels'></span><span id='topic+labels.dc'></span><span id='topic+labels+3C-'></span>

<h3>Description</h3>

<p>Get and set the variable labels of a draws component object for a vector-valued parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dc'
labels(object, ...)

labels(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels_+3A_object">object</code></td>
<td>
<p>a draws component object.</p>
</td></tr>
<tr><td><code id="labels_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
<tr><td><code id="labels_+3A_value">value</code></td>
<td>
<p>a vector of labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The extractor function returns the variable labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=50, n.iter=100, n.chain=1, store.all=TRUE)
labels(sim$beta)
labels(sim$v)
labels(sim$beta) &lt;- c("a", "b")
labels(sim$beta)


</code></pre>

<hr>
<h2 id='Matrix-methods'>S4 methods for products of matrix objects</h2><span id='topic+Matrix-methods'></span><span id='topic++25+2A+25+2CddiMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CdgCMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CdsCMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2CtabMatrix+2Cmatrix-method'></span><span id='topic++25+2A+25+2Cmatrix+2CtabMatrix-method'></span><span id='topic++25+2A+25+2CtabMatrix+2CnumLike-method'></span><span id='topic++25+2A+25+2CddiMatrix+2CdgCMatrix-method'></span><span id='topic++25+2A+25+2CddiMatrix+2CtabMatrix-method'></span><span id='topic++25+2A+25+2CCsparseMatrix+2CtabMatrix-method'></span><span id='topic++25+2A+25+2CtabMatrix+2CCsparseMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CdgCMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CtabMatrix-method'></span><span id='topic+tcrossprod+2Cmatrix+2CddiMatrix-method'></span><span id='topic+crossprod+2CtabMatrix+2Cmissing-method'></span><span id='topic+crossprod+2CtabMatrix+2Cmatrix-method'></span><span id='topic+crossprod+2CtabMatrix+2CdgCMatrix-method'></span><span id='topic+crossprod+2CtabMatrix+2CtabMatrix-method'></span><span id='topic+crossprod+2CdgCMatrix+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Several methods for products of matrix objects. Here a matrix object can be
an ordinary (dense) <code>matrix</code> or a (sparse) <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> of class
<code><a href="Matrix.html#topic+ddiMatrix-class">ddiMatrix-class</a></code>, <code>tabMatrix</code>,
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>, or <code><a href="Matrix.html#topic+dsCMatrix-class">dsCMatrix-class</a></code>.
The return types are restricted to <code>matrix</code> or <code>numeric</code> in case of dense objects, and
<code>dgCMatrix</code>, <code>dsCMatrix</code>, <code>ddiMatrix</code> or <code>tabMatrix</code> in case of sparse objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ddiMatrix,matrix'
x %*% y

## S4 method for signature 'dgCMatrix,matrix'
x %*% y

## S4 method for signature 'dsCMatrix,matrix'
x %*% y

## S4 method for signature 'tabMatrix,matrix'
x %*% y

## S4 method for signature 'matrix,tabMatrix'
x %*% y

## S4 method for signature 'tabMatrix,numLike'
x %*% y

## S4 method for signature 'ddiMatrix,dgCMatrix'
x %*% y

## S4 method for signature 'ddiMatrix,tabMatrix'
x %*% y

## S4 method for signature 'CsparseMatrix,tabMatrix'
x %*% y

## S4 method for signature 'tabMatrix,CsparseMatrix'
x %*% y

## S4 method for signature 'matrix,dgCMatrix'
tcrossprod(x, y)

## S4 method for signature 'matrix,tabMatrix'
tcrossprod(x, y)

## S4 method for signature 'matrix,ddiMatrix'
tcrossprod(x, y)

## S4 method for signature 'tabMatrix,missing'
crossprod(x, y)

## S4 method for signature 'tabMatrix,matrix'
crossprod(x, y)

## S4 method for signature 'tabMatrix,dgCMatrix'
crossprod(x, y)

## S4 method for signature 'tabMatrix,tabMatrix'
crossprod(x, y)

## S4 method for signature 'dgCMatrix,matrix'
crossprod(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Matrix-methods_+3A_x">x</code></td>
<td>
<p>a matrix object.</p>
</td></tr>
<tr><td><code id="Matrix-methods_+3A_y">y</code></td>
<td>
<p>a matrix object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object. In case one of the arguments is a regular (dense) <code>matrix</code>
the result is a <code>matrix</code> as well.
</p>

<hr>
<h2 id='matrix-vector'>Fast matrix-vector multiplications</h2><span id='topic+matrix-vector'></span><span id='topic++25m+2Av+25'></span><span id='topic+crossprod_mv'></span>

<h3>Description</h3>

<p>Functions for matrix-vector multiplies like <code>%*%</code> and <code>crossprod</code>,
but often faster for the matrix types supported. The return value is always a
numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M %m*v% v

crossprod_mv(M, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix-vector_+3A_m">M</code></td>
<td>
<p>a matrix of class 'matrix', 'dgCMatrix', 'dsCMatrix', 'tabMatrix', or 'ddiMatrix'.</p>
</td></tr>
<tr><td><code id="matrix-vector_+3A_v">v</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>%m*v%</code> the vector <code class="reqn">Mv</code> and for <code>crossprod_mv</code> the vector
<code class="reqn">M'v</code> where <code class="reqn">M'</code> denotes the transpose of <code class="reqn">M</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(rnorm(10*10), 10, 10)
x &lt;- rnorm(10)
M %m*v% x
crossprod_mv(M, x)
M &lt;- Matrix::rsparsematrix(100, 100, nnz=100)
x &lt;- rnorm(100)
M %m*v% x
crossprod_mv(M, x)

</code></pre>

<hr>
<h2 id='maximize_log_lh_p'>Maximize the log-likelihood or log-posterior as defined by a sampler closure</h2><span id='topic+maximize_log_lh_p'></span>

<h3>Description</h3>

<p>Maximize the log-likelihood or log-posterior as defined by a sampler closure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximize_log_lh_p(
  sampler,
  type = c("llh", "lpost"),
  method = "BFGS",
  control = list(fnscale = -1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximize_log_lh_p_+3A_sampler">sampler</code></td>
<td>
<p>sampler function closure, i.e. the return value of a call to <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="maximize_log_lh_p_+3A_type">type</code></td>
<td>
<p>either &quot;llh&quot; (default) or &quot;lpost&quot;, for optimization of the log-likelihood,
or the log-posterior, respectively.</p>
</td></tr>
<tr><td><code id="maximize_log_lh_p_+3A_method">method</code></td>
<td>
<p>optimization method, passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="maximize_log_lh_p_+3A_control">control</code></td>
<td>
<p>control parameters, passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="maximize_log_lh_p_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameter values that, provided the optimization was successful, maximize the (log-)likelihood
or (log-)posterior.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 1000
dat &lt;- data.frame(
  x = rnorm(n),
  f = factor(sample(1:50, n, replace=TRUE))
)
df &lt;- generate_data(
  ~ reg(~x, name="beta", prior=pr_normal(precision=1)) + gen(~x, factor=~f, name="v"),
  sigma.fixed=TRUE, data=dat
)
dat$y &lt;- df$y
sampler &lt;- create_sampler(y ~ x + gen(~x, factor=~f, name="v"), data=dat)
opt &lt;- maximize_log_lh_p(sampler)
str(opt)
plot(df$par$v, opt$par$v); abline(0, 1, col="red")


</code></pre>

<hr>
<h2 id='MCMC-diagnostics'>Compute MCMC diagnostic measures</h2><span id='topic+MCMC-diagnostics'></span><span id='topic+R_hat'></span><span id='topic+n_eff'></span>

<h3>Description</h3>

<p><code>R_hat</code> computes Gelman-Rubin convergence diagnostics based on the MCMC output
in a model component, and <code>n_eff</code> computes the effective sample sizes, .i.e.
estimates for the number of independent samples from the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_hat(dc)

n_eff(dc, useFFT = TRUE, lag.max, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMC-diagnostics_+3A_dc">dc</code></td>
<td>
<p>a draws component (dc) object corresponding to a model parameter.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_usefft">useFFT</code></td>
<td>
<p>whether to use the Fast Fourier Transform algorithm. Default is <code>TRUE</code> as this is typically faster.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_lag.max">lag.max</code></td>
<td>
<p>the lag up to which autocorrelations are computed in case <code>useFFT=FALSE</code>.</p>
</td></tr>
<tr><td><code id="MCMC-diagnostics_+3A_cl">cl</code></td>
<td>
<p>a cluster for parallel computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of <code>R_hat</code> the split-R-hat convergence diagnostic for each
component of the vector parameter, and in case of <code>n_eff</code> the effective
number of independent samples for each component of the vector parameter.
</p>


<h3>References</h3>

<p>A. Gelman and D. B. Rubin (1992).
Inference from Iterative Simulation Using Multiple Sequences.
Statistical Science 7, 457-511.
</p>
<p>A. Gelman, J.B. Carlin, H.S. Stern, D.B. Dunson, A. Vehtari and D.B. Rubin (2013).
Bayesian Data Analysis, 3rd edition.
Chapman &amp; Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, n.chain=4, store.all=TRUE)
n_eff(sim$beta)
n_eff(sim$v_sigma)
n_eff(sim$v_rho)
R_hat(sim$beta)
R_hat(sim$llh_)
R_hat(sim$v_sigma)


</code></pre>

<hr>
<h2 id='MCMC-object-conversion'>Convert a draws component object to another format</h2><span id='topic+MCMC-object-conversion'></span><span id='topic+to_mcmc'></span><span id='topic+to_draws_array'></span><span id='topic+as.array.dc'></span><span id='topic+as.matrix.dc'></span>

<h3>Description</h3>

<p>Use <code>to_mcmc</code> to convert a draws component to class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>,
allowing one to use MCMC diagnostic functions provided by package <span class="pkg">coda</span>.
Use <code>as.array</code> to convert to an array of dimension <code>(draws, chains, parameters)</code>.
The array format is supported by some packages for analysis or visualisation of MCMC
simulation results, e.g. <span class="pkg">bayesplot</span>.
Use <code>as.matrix</code> to convert to a matrix, concatenating the chains.
Finally, use <code>to_draws_array</code> to convert either a draws component or
(a subset of components of) an mcdraws object to a <code>draws_array</code> object
as defined in package <span class="pkg">posterior</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_mcmc(x)

to_draws_array(x, components = NULL)

## S3 method for class 'dc'
as.array(x, ...)

## S3 method for class 'dc'
as.matrix(x, colnames = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMC-object-conversion_+3A_x">x</code></td>
<td>
<p>a component of an mcdraws object corresponding to a scalar or vector model parameter.</p>
</td></tr>
<tr><td><code id="MCMC-object-conversion_+3A_components">components</code></td>
<td>
<p>optional character vector of names of draws components in an mcdraws object.
This can be used to select a subset of components to convert to
<code><a href="posterior.html#topic+draws_array">draws_array</a></code> format.</p>
</td></tr>
<tr><td><code id="MCMC-object-conversion_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="MCMC-object-conversion_+3A_colnames">colnames</code></td>
<td>
<p>whether column names should be set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The draws component(s) coerced to an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object,
a <code><a href="posterior.html#topic+draws_array">draws_array</a></code> object, an array, or a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
sampler &lt;- create_sampler(Sepal.Length ~ reg(~ Petal.Length + Species, name="beta"), data=iris)
sim &lt;- MCMCsim(sampler, burnin=100, n.chain=2, n.iter=400)
summary(sim)
if (require("coda", quietly=TRUE)) {
  mcbeta &lt;- to_mcmc(sim$beta)
  geweke.diag(mcbeta)
}
if (require("posterior", quietly=TRUE)) {
  mcbeta &lt;- to_draws_array(sim$beta)
  mcbeta
  draws &lt;- to_draws_array(sim)
  str(draws)
}
str(as.array(sim$beta))
str(as.matrix(sim$beta))

# generate some example data
n &lt;- 250
dat &lt;- data.frame(x=runif(n), f=as.factor(sample(1:5, n, replace=TRUE)))
gd &lt;- generate_data(~ reg(~ x + f, prior=pr_normal(precision=1), name="beta"), data=dat)
dat$y &lt;- gd$y
sampler &lt;- create_sampler(y ~ reg(~ x + f, name="beta"), data=dat)
sim &lt;- MCMCsim(sampler, n.chain=2, n.iter=400)
str(sim$beta)
str(as.array(sim$beta))
bayesplot::mcmc_hist(as.array(sim$beta))
bayesplot::mcmc_dens_overlay(as.array(sim$beta))
# fake data simulation check:
bayesplot::mcmc_recover_intervals(as.array(sim$beta), gd$pars$beta)
bayesplot::mcmc_recover_hist(as.array(sim$beta), gd$pars$beta)

ex &lt;- mcmcsae_example()
plot(ex$dat$fT, ex$dat$y)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, n.chain=2, n.iter=400, store.all=TRUE)
str(sim$beta)
str(as.matrix(sim$beta))
# fake data simulation check:
bayesplot::mcmc_recover_intervals(as.matrix(sim$beta), ex$pars$beta)
bayesplot::mcmc_recover_intervals(as.matrix(sim$u), ex$pars$u)


</code></pre>

<hr>
<h2 id='mcmcsae_example'>Generate artificial data according to an additive spatio-temporal model</h2><span id='topic+mcmcsae_example'></span>

<h3>Description</h3>

<p>This function is used to generate data for several examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcsae_example(n = 100L, family = "gaussian")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcsae_example_+3A_n">n</code></td>
<td>
<p>the size of the generated dataset.</p>
</td></tr>
<tr><td><code id="mcmcsae_example_+3A_family">family</code></td>
<td>
<p>sampling distribution family, see <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing the generated dataset, the values of the model
parameters, and the model specification as a formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
str(ex)


</code></pre>

<hr>
<h2 id='mcmcsae-family'>Functions for specifying a sampling distribution and link function</h2><span id='topic+mcmcsae-family'></span><span id='topic+f_gaussian'></span><span id='topic+f_binomial'></span><span id='topic+f_negbinomial'></span><span id='topic+f_poisson'></span><span id='topic+f_multinomial'></span><span id='topic+f_gamma'></span><span id='topic+f_gaussian_gamma'></span>

<h3>Description</h3>

<p>These functions are intended for use in the <code>family</code> argument of <code><a href="#topic+create_sampler">create_sampler</a></code>.
In future versions these functions may gain additional arguments, but currently the corresponding
functions <code>gaussian</code> and <code>binomial</code> can be used as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_gaussian(link = "identity")

f_binomial(link = c("logit", "probit"))

f_negbinomial(link = "logit")

f_poisson(link = "log")

f_multinomial(link = "logit", K = NULL)

f_gamma(
  link = "log",
  shape.vec = ~1,
  shape.prior = pr_gamma(0.1, 0.1),
  shape.MH.type = c("RW", "gamma")
)

f_gaussian_gamma(link = "identity", var.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmcsae-family_+3A_link">link</code></td>
<td>
<p>the name of a link function. Currently the only allowed link functions are:
<code>"identity"</code> for (log-)Gaussian sampling distributions, <code>"logit"</code> (default) and <code>"probit"</code>
for binomial distributions and <code>"log"</code> for negative binomial sampling distributions.</p>
</td></tr>
<tr><td><code id="mcmcsae-family_+3A_k">K</code></td>
<td>
<p>number of categories for multinomial model; this must be specified for prior predictive sampling.</p>
</td></tr>
<tr><td><code id="mcmcsae-family_+3A_shape.vec">shape.vec</code></td>
<td>
<p>optional formula specification of unequal shape parameter for gamma family</p>
</td></tr>
<tr><td><code id="mcmcsae-family_+3A_shape.prior">shape.prior</code></td>
<td>
<p>prior for gamma shape parameter. Supported prior distributions:
<code><a href="#topic+pr_fixed">pr_fixed</a></code> with a default value of 1, <code><a href="#topic+pr_exp">pr_exp</a></code> and
<code><a href="#topic+pr_gamma">pr_gamma</a></code>. The current default is that of a fixed shape
equal to 1, i.e. <code>pr_fixed(value=1)</code>.</p>
</td></tr>
<tr><td><code id="mcmcsae-family_+3A_shape.mh.type">shape.MH.type</code></td>
<td>
<p>the type of Metropolis-Hastings algorithm employed
in case the shape parameter is to be inferred. The two choices currently
supported are &quot;RW&quot; for a random walk proposal on the log-shape scale
and &quot;gamma&quot; for an approximating gamma proposal, found using an iterative
algorithm. In the latter case, a Metropolis-Hastings accept-reject step is
currently omitted, so the sampling algorithm is an approximate one,
though one that is usually quite accurate and efficient.</p>
</td></tr>
<tr><td><code id="mcmcsae-family_+3A_var.data">var.data</code></td>
<td>
<p>the (variance) data for the gamma part of family <code>gaussian_gamma</code>.</p>
</td></tr>
<tr><td><code id="mcmcsae-family_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>f_gamma</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A family object.
</p>


<h3>References</h3>

<p>J.W. Miller (2019).
Fast and Accurate Approximation of the Full Conditional for Gamma Shape Parameters.
Journal of Computational and Graphical Statistics 28(2), 476-480.
</p>

<hr>
<h2 id='mcmcsae-package'>Markov Chain Monte Carlo Small Area Estimation</h2><span id='topic+mcmcsae-package'></span><span id='topic+mcmcsae'></span>

<h3>Description</h3>

<p>Fit multi-level models with possibly correlated random effects using MCMC.
</p>


<h3>Details</h3>

<p>Functions to fit multi-level models with Gaussian, binomial, multinomial,
negative binomial or Poisson likelihoods using MCMC. Models with a linear predictor
consisting of various possibly correlated random effects are supported, allowing
flexible modeling of temporal, spatial or other kinds of dependence structures.
For Gaussian models the variance can be modeled too. By modeling variances
at the unit level the marginal distribution can be changed to a Student-t or Laplace
distribution, which may account better for outliers.
The package has been developed with applications to small area estimation
in official statistics in mind. The posterior samples for the model
parameters can be passed to a prediction function to generate samples from
the posterior predictive distribution for user-defined quantities such as
finite population domain means. For model assessment, posterior predictive
checks and DIC/WAIC criteria can easily be computed.
</p>

<hr>
<h2 id='MCMCsim'>Run a Markov Chain Monte Carlo simulation</h2><span id='topic+MCMCsim'></span>

<h3>Description</h3>

<p>Given a sampler object this function runs a MCMC simulation and stores the
posterior draws. A sampler object for a wide class of multilevel models
can be created using <code><a href="#topic+create_sampler">create_sampler</a></code>, but users can also define
their own sampler functions, see below.
<code>MCMCsim</code> allows to choose the parameters for which simulation results
must be stored. It is possible to define derived quantities that will also
be stored. To save memory, it is also possible to only store Monte Carlo
means/standard errors for some large vector parameters, say. Another
way to use less memory is to save the simulation results of large vector
parameters to file.
For parameters specified in <code>plot.trace</code> trace plots or pair plots of
multiple parameters are displayed during the simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMCsim(
  sampler,
  from.prior = FALSE,
  n.iter = 1000L,
  n.chain = 3L,
  thin = 1L,
  burnin = if (from.prior) 0L else 250L,
  start = NULL,
  store,
  store.all = FALSE,
  pred = NULL,
  store.mean,
  store.sds = FALSE,
  to.file = NULL,
  filename = "MCdraws_",
  write.single.prec = FALSE,
  verbose = TRUE,
  n.progress = n.iter%/%10L,
  trace.convergence = NULL,
  stop.on.convergence = FALSE,
  convergence.bound = 1.05,
  plot.trace = NULL,
  add.to.plot = TRUE,
  plot.type = "l",
  n.cores = 1L,
  cl = NULL,
  seed = NULL,
  export = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMCsim_+3A_sampler">sampler</code></td>
<td>
<p>sampler object created by <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_from.prior">from.prior</code></td>
<td>
<p>whether to sample from the prior. By default <code>from.prior=FALSE</code>
and samples are taken from the posterior.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_n.iter">n.iter</code></td>
<td>
<p>number of draws after burnin.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_n.chain">n.chain</code></td>
<td>
<p>number of independent chains.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_thin">thin</code></td>
<td>
<p>only every <code>thin</code>'th draw is kept.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_burnin">burnin</code></td>
<td>
<p>number of draws to discard at the beginning of each chain.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_start">start</code></td>
<td>
<p>an optional function to generate starting values or a list containing for each chain
a named list of starting values. It may be used to provide starting values for some or all parameters.
The sampler object's own start function, if it exists, is called to generate any starting values not
provided by the user.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_store">store</code></td>
<td>
<p>vector of names of parameters to store MCMC draws for. By default, simulations are
stored for all parameters returned by <code>sampler$store_default</code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_store.all">store.all</code></td>
<td>
<p>if <code>TRUE</code> simulation vectors of all parameters returned by the sampling
function of <code>sampler</code> will be stored. The default is <code>FALSE</code>, and in that case
only simulations for the parameters named in <code>store</code> are stored.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_pred">pred</code></td>
<td>
<p>list of character strings defining derived quantities to be computed (and stored) for each draw.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_store.mean">store.mean</code></td>
<td>
<p>vector of names of parameters for which only the mean (per chain) is to be stored.
This may be useful for large vector parameters (e.g. regression residuals) for which storing complete
MCMC output would use too much memory. The function <code>sampler$store_mean_default</code>
exists it provides the default.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_store.sds">store.sds</code></td>
<td>
<p>if <code>TRUE</code> store for all parameters in <code>store.mean</code>, besides the mean, also
the standard deviation. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_to.file">to.file</code></td>
<td>
<p>vector of names of parameters to write to file.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_filename">filename</code></td>
<td>
<p>name of file to write parameter draws to.
Each named parameter is written to a separate file, named <code>filename_parametername</code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_write.single.prec">write.single.prec</code></td>
<td>
<p>Whether to write to file in single precision. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_verbose">verbose</code></td>
<td>
<p>if <code>FALSE</code> no output is sent to the screen during the simulation. <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_n.progress">n.progress</code></td>
<td>
<p>update diagnostics and plots after so many iterations.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_trace.convergence">trace.convergence</code></td>
<td>
<p>vector of names of parameters for which Gelman-Rubin R-hat diagnostics are printed to the screen every <code>n.progress</code> iterations.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_stop.on.convergence">stop.on.convergence</code></td>
<td>
<p>if <code>TRUE</code> stop the simulation if the R-hat diagnostics for all parameters in <code>trace.convergence</code> are less than <code>convergence.bound</code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_convergence.bound">convergence.bound</code></td>
<td>
<p>threshold used with <code>stop.on.convergence</code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_plot.trace">plot.trace</code></td>
<td>
<p>character vector of parameter names for which to plot draws
during the simulation. For one or two parameters trace plots will be shown,
and if more parameters are specified the results will be displayed in a pairs
plot. For vector parameters a specific component can be selected using brackets,
e.g. <code>"beta[2]"</code>.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_add.to.plot">add.to.plot</code></td>
<td>
<p>if <code>TRUE</code> the plot is updated every <code>n.progress</code> iterations,
otherwise a new plot (with new scales) is created after every <code>n.progress</code> iterations.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_plot.type">plot.type</code></td>
<td>
<p>default is &quot;l&quot; (lines).</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_n.cores">n.cores</code></td>
<td>
<p>the number of cpu cores to use. Default is 1, i.e. no parallel computation.
If an existing cluster <code>cl</code> is provided, <code>n.cores</code> will be set to the number
of workers in that cluster.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_cl">cl</code></td>
<td>
<p>an existing cluster can be passed for parallel computation. If <code>NULL</code> and
<code>n.cores &gt; 1</code>, a new cluster is created.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_seed">seed</code></td>
<td>
<p>a random seed (integer). For parallel computation it is used to independently
seed RNG streams for all workers.</p>
</td></tr>
<tr><td><code id="MCMCsim_+3A_export">export</code></td>
<td>
<p>a character vector with names of objects to export to the workers. This may
be needed for parallel execution if expressions in <code>pred</code> depend on global variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sampler object is an environment containing data and functions to use
for sampling. The following elements of the sampler object are used by
<code>MCMCsim</code>:
</p>

<dl>
<dt>start</dt><dd><p>function to generate starting values.</p>
</dd>
<dt>draw</dt><dd><p>function to draw samples, typically from a full conditional
posterior distribution.</p>
</dd>
<dt>rprior</dt><dd><p>function to draw from a prior distribution.</p>
</dd>
<dt>coef.names</dt><dd><p>list of vectors of parameter coefficient names, for
vector parameters.</p>
</dd>
<dt>MHpars</dt><dd><p>vector of names of parameters that are sampled using a
Metropolis-Hastings (MH) sampler; acceptance rates are kept for these
parameters.</p>
</dd>
<dt>adapt</dt><dd><p>function of acceptance rates of <code>MHpars</code> to adapt
MH-kernel, called every 100 iterations during the burn-in period.</p>
</dd>
</dl>



<h3>Value</h3>

<p>An object of class <code>mcdraws</code> containing posterior draws as well as some meta information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. create a sampler function
sampler &lt;- new.env()
sampler$draw &lt;- function(p) list(x=rnorm(1L), y=runif(1L))
# 2. do the simulation
sim &lt;- MCMCsim(sampler, store=c("x", "y"))
str(sim)
summary(sim)

# example that requires start values or a start function
sampler$draw &lt;- function(p) list(x=rnorm(1L), y=p$x * runif(1L))
sampler$start &lt;- function(p) list(x=rnorm(1L), y=runif(1L))
sim &lt;- MCMCsim(sampler, store=c("x", "y"))
summary(sim)
plot(sim, c("x", "y"))

# example using create_sampler; first generate some data
n &lt;- 100
dat &lt;- data.frame(x=runif(n), f=as.factor(sample(1:4, n, replace=TRUE)))
gd &lt;- generate_data(~ reg(~ x + f, prior=pr_normal(precision=1), name="beta"), data=dat)
dat$y &lt;- gd$y
sampler &lt;- create_sampler(y ~ x + f, data=dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=400, n.chain=2)
(summary(sim))
gd$pars

</code></pre>

<hr>
<h2 id='mec'>Create a model component object for a regression (fixed effects) component
in the linear predictor with measurement errors in quantitative covariates</h2><span id='topic+mec'></span>

<h3>Description</h3>

<p>This function is intended to be used on the right hand side of the
<code>formula</code> argument to <code><a href="#topic+create_sampler">create_sampler</a></code> or
<code><a href="#topic+generate_data">generate_data</a></code>. It creates an additive regression term in the
model's linear predictor. Covariates are assumed to be measured subject
to normally distributed errors with zero mean and variance specified using
the <code>formula</code> or <code>V</code> arguments. Note that this means that <code>formula</code>
should only contain quantitative variables, and no intercept.
By default, the prior for the regression
coefficients is improper uniform. A proper normal prior can be set up
using function <code><a href="#topic+pr_normal">pr_normal</a></code>, and passed to argument <code>prior</code>.
It should be noted that <code><a href="#topic+pr_normal">pr_normal</a></code> expects a precision matrix
as input for its second argument, and that the prior variance (matrix) is
taken to be the inverse of this precision matrix, where in case the
model's family is <code>"gaussian"</code> this matrix is additionally
multiplied by the residual scalar variance parameter <code>sigma_^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mec(
  formula = ~1,
  sparse = NULL,
  X = NULL,
  V = NULL,
  prior = NULL,
  Q0 = NULL,
  b0 = NULL,
  R = NULL,
  r = NULL,
  S = NULL,
  s = NULL,
  lower = NULL,
  upper = NULL,
  name = "",
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mec_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the predictors subject to measurement error
and possibly their variances as well. In the latter case the formula syntax
<code>~ (x1 | V.x1) + (x2 | V.x2) + ...</code> should be used where <code>x1, x2, ...</code>
are the names of (quantitative) predictors and <code>V.x1, V.x2, ...</code> are the names
of the variables holding the corresponding measurement error variances.
If only the predictors are specified
the formula has the usual form <code>~ x1 + x2 + ...</code>. In that case variances
should be specified using argument <code>V</code>.
All variable names are looked up in the data frame
passed as <code>data</code> argument to <code><a href="#topic+create_sampler">create_sampler</a></code> or
<code><a href="#topic+generate_data">generate_data</a></code>, or in <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="mec_+3A_sparse">sparse</code></td>
<td>
<p>whether the model matrix associated with <code>formula</code> should
be sparse. The default is to base this on a simple heuristic.</p>
</td></tr>
<tr><td><code id="mec_+3A_x">X</code></td>
<td>
<p>a (possibly sparse) design matrix can be specified directly, as an
alternative to the creation of one based on <code>formula</code>. If <code>X</code> is
specified <code>formula</code> is ignored.</p>
</td></tr>
<tr><td><code id="mec_+3A_v">V</code></td>
<td>
<p>measurement error variance; can contain zeros</p>
</td></tr>
<tr><td><code id="mec_+3A_prior">prior</code></td>
<td>
<p>prior specification for the regression coefficients. Currently only
normal priors are supported, specified using function <code><a href="#topic+pr_normal">pr_normal</a></code>.</p>
</td></tr>
<tr><td><code id="mec_+3A_q0">Q0</code></td>
<td>
<p>prior precision matrix for the regression effects. The default is a
zero matrix corresponding to a noninformative improper prior.
It can be specified as a scalar value, as a numeric vector of appropriate
length, or as a matrix object. DEPRECATED, please use argument <code>prior</code>
instead, i.e. <code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td></tr>
<tr><td><code id="mec_+3A_b0">b0</code></td>
<td>
<p>prior mean for the regression effect. Defaults to a zero vector.
It can be specified as a scalar value or as a numeric vector of
appropriate length. DEPRECATED, please use argument <code>prior</code>
instead, i.e. <code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td></tr>
<tr><td><code id="mec_+3A_r">R</code></td>
<td>
<p>optional constraint matrix for equality restrictions R'x = r where
<code>x</code> is the vector of regression effects.</p>
</td></tr>
<tr><td><code id="mec_+3A_r">r</code></td>
<td>
<p>right hand side for the equality constraints.</p>
</td></tr>
<tr><td><code id="mec_+3A_s">S</code></td>
<td>
<p>optional constraint matrix for inequality constraints S'x &gt;= s where
x is the vector of regression effects.</p>
</td></tr>
<tr><td><code id="mec_+3A_s">s</code></td>
<td>
<p>right hand side for the inequality constraints.</p>
</td></tr>
<tr><td><code id="mec_+3A_lower">lower</code></td>
<td>
<p>as an alternative to <code>s</code>, <code>lower</code> and <code>upper</code> may be specified
for two-sided constraints lower &lt;= S'x &lt;= upper.</p>
</td></tr>
<tr><td><code id="mec_+3A_upper">upper</code></td>
<td>
<p>as an alternative to <code>s</code>, <code>lower</code> and <code>upper</code> may be specified
for two-sided constraints lower &lt;= S'x &lt;= upper.</p>
</td></tr>
<tr><td><code id="mec_+3A_name">name</code></td>
<td>
<p>the name of the model component. This name is used in the output of the
MCMC simulation function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. By default the name will be 'reg'
with the number of the model term attached.</p>
</td></tr>
<tr><td><code id="mec_+3A_debug">debug</code></td>
<td>
<p>if <code>TRUE</code> a breakpoint is set at the beginning of the posterior
draw function associated with this model component. Mainly intended for developers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with precomputed quantities and functions for sampling from
prior or conditional posterior distributions for this model component. Intended
for internal use by other package functions.
</p>


<h3>References</h3>

<p>L.M. Ybarra and S.L. Lohr (2008).
Small area estimation when auxiliary information is measured with error.
Biometrika 95(4), 919-931.
</p>
<p>S. Arima, G.S. Datta and B. Liseo (2015).
Bayesian estimators for small area models when auxiliary information is measured with error.
Scandinavian Journal of Statistics 42(2), 518-529.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example of Ybarra and Lohr (2008)
m &lt;- 50
X &lt;- rnorm(m, mean=5, sd=3)  # true covariate values
v &lt;- rnorm(m, sd=2)
theta &lt;- 1 + 3*X + v  # true values
psi &lt;- rgamma(m, shape=4.5, scale=2)
e &lt;- rnorm(m, sd=sqrt(psi))  # sampling error
y &lt;- theta + e  # direct estimates
C &lt;- c(rep(3, 10), rep(0, 40))  # measurement error for first 10 values
W &lt;- X + rnorm(m, sd=sqrt(C))  # covariate subject to measurement error

# fit Ybarra-Lohr model
sampler &lt;- create_sampler(
  y ~ 1 + mec(~ 0 + W, V=C) + gen(factor=~local_),
  Q0=1/psi, sigma.fixed=TRUE, linpred="fitted"
)
sim &lt;- MCMCsim(sampler, n.iter=800, n.chain=2, store.all=TRUE, verbose=FALSE)
(summ &lt;- summary(sim))
plot(X, W, xlab="true X", ylab="inferred X")
points(X, summ$mec2_X[, "Mean"], col="green")
abline(0, 1, col="red")
legend("topleft", legend=c("prior mean", "posterior mean"), col=c("black", "green"), pch=c(1,1))


</code></pre>

<hr>
<h2 id='model_matrix'>Compute possibly sparse model matrix</h2><span id='topic+model_matrix'></span>

<h3>Description</h3>

<p>Compute possibly sparse model matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_matrix(
  formula,
  data = NULL,
  contrasts.arg = NULL,
  drop.unused.levels = FALSE,
  sparse = NULL,
  drop0 = TRUE,
  catsep = "",
  by = NULL,
  tabM = FALSE,
  enclos = .GlobalEnv
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_matrix_+3A_formula">formula</code></td>
<td>
<p>model formula.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_data">data</code></td>
<td>
<p>data frame containing all variables used in <code>formula</code>.
These variables should not contain missing values. An error is raised in case any of them does.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>specification of contrasts for factor variables. Currently supported are
&quot;contr.none&quot; (no contrasts applied), &quot;contr.treatment&quot; (first level removed) and &quot;contr.SAS&quot; (last level removed).
Alternatively, a named list specifying a single level per factor variable can be passed.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>whether empty levels of individual factor variables should be removed.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_sparse">sparse</code></td>
<td>
<p>if <code>TRUE</code> a sparse matrix of class <code>dgCMatrix</code> is returned. This can be efficient
for large datasets and a model containing categorical variables with many categories. If <code>sparse=NULL</code>, the default,
whether a sparse or dense model matrix is returned is based on a simple heuristic.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_drop0">drop0</code></td>
<td>
<p>whether to drop any remaining explicit zeros in resulting sparse matrix.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_catsep">catsep</code></td>
<td>
<p>separator for concatenating factor variable names and level names.
By default it is the empty string, reproducing the labels of <code>model.matrix</code>.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_by">by</code></td>
<td>
<p>a vector by which to aggregate the result.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_tabm">tabM</code></td>
<td>
<p>if <code>TRUE</code> return a list of tabMatrix objects.</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_enclos">enclos</code></td>
<td>
<p>enclosure to look for objects not found in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Design matrix X, either an ordinary matrix or a sparse <code>dgCMatrix</code>.
</p>

<hr>
<h2 id='model-information-criteria'>Compute DIC, WAIC and leave-one-out cross-validation model measures</h2><span id='topic+model-information-criteria'></span><span id='topic+compute_DIC'></span><span id='topic+compute_WAIC'></span><span id='topic+waic.mcdraws'></span><span id='topic+loo.mcdraws'></span>

<h3>Description</h3>

<p>Compute the Deviance Information Criterion (DIC) or
Watanabe-Akaike Information Criterion (WAIC) from an
object of class <code>mcdraws</code> output by <code><a href="#topic+MCMCsim">MCMCsim</a></code>.
Method <code>waic.mcdraws</code> computes WAIC using package <span class="pkg">loo</span>.
Method <code>loo.mcdraws</code> also depends on package <span class="pkg">loo</span> to compute
a Pareto-smoothed importance sampling (PSIS) approximation
to leave-one-out cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_DIC(x, use.pV = FALSE)

compute_WAIC(
  x,
  diagnostic = FALSE,
  batch.size = NULL,
  show.progress = TRUE,
  cl = NULL,
  n.cores = 1L
)

## S3 method for class 'mcdraws'
waic(x, by.unit = FALSE, ...)

## S3 method for class 'mcdraws'
loo(x, by.unit = FALSE, r_eff = FALSE, n.cores = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model-information-criteria_+3A_x">x</code></td>
<td>
<p>an object of class <code>mcdraws</code>.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_use.pv">use.pV</code></td>
<td>
<p>whether half the posterior variance of the deviance should be used
as an alternative estimate of the effective number of model parameters for DIC.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_diagnostic">diagnostic</code></td>
<td>
<p>whether vectors of log-pointwise-predictive-densities and pointwise
contributions to the WAIC effective number of model parameters should be returned.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_batch.size">batch.size</code></td>
<td>
<p>number of data units to process per batch.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_show.progress">show.progress</code></td>
<td>
<p>whether to show a progress bar.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_cl">cl</code></td>
<td>
<p>an existing cluster can be passed for parallel computation. If <code>cl</code> is provided,
<code>n.cores</code> will be set to the number of workers in that cluster. If <code>NULL</code> and
<code>n.cores &gt; 1</code>, a new cluster is created.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_n.cores">n.cores</code></td>
<td>
<p>the number of cpu cores to use. Default is one, i.e. no parallel computation.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_by.unit">by.unit</code></td>
<td>
<p>if <code>TRUE</code> the computation is carried out unit-by-unit, which is
slower but uses much less memory.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_...">...</code></td>
<td>
<p>Other arguments, passed to <code><a href="loo.html#topic+loo">loo</a></code>. Not currently
used by <code>waic.mcdraws</code>.</p>
</td></tr>
<tr><td><code id="model-information-criteria_+3A_r_eff">r_eff</code></td>
<td>
<p>whether to compute relative effective sample size estimates
for the likelihood of each observation. This takes more time, but should
result in a better PSIS approximation. See <code><a href="loo.html#topic+loo">loo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>compute_DIC</code> a vector with the deviance information criterion and
effective number of model parameters. For <code>compute_WAIC</code> a vector with the
WAIC model selection criterion and WAIC effective number of model parameters.
Method <code>waic</code> returns an object of class <code>waic, loo</code>, see the
documentation for <code><a href="loo.html#topic+waic">waic</a></code> in package <span class="pkg">loo</span>. 
Method <code>loo</code> returns an object of class <code>psis_loo</code>, see
<code><a href="loo.html#topic+loo">loo</a></code>.
</p>


<h3>References</h3>

<p>D. Spiegelhalter, N. Best, B. Carlin and A. van der Linde (2002).
Bayesian Measures of Model Complexity and Fit.
Journal of the Royal Statistical Society B 64 (4), 583-639.
</p>
<p>S. Watanabe (2010).
Asymptotic equivalence of Bayes cross validation and widely applicable
information criterion in singular learning theory.
Journal of Machine Learning 11, 3571-3594.
</p>
<p>A. Gelman, J. Hwang and A. Vehtari (2014).
Understanding predictive information criteria for Bayesian models.
Statistics and Computing 24, 997-1016.
</p>
<p>A. Vehtari, D. Simpson, A. Gelman, Y. Yao and J. Gabry (2015).
Pareto smoothed importance sampling.
arXiv:1507.02646.
</p>
<p>A. Vehtari, A. Gelman and J. Gabry (2017).
Practical Bayesian model evaluation using leave-one-out cross-validation
and WAIC.
Statistics and Computing 27, 1413-1432.
</p>
<p>P.-C. Buerkner, J. Gabry and A. Vehtari (2021).
Efficient leave-one-out cross-validation for Bayesian non-factorized
normal and Student-t models.
Computational Statistics 36, 1243-1261.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=100)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, n.chain=4, store.all=TRUE)
compute_DIC(sim)
compute_WAIC(sim)
if (require(loo)) {
  waic(sim)
  loo(sim, r_eff=TRUE)
}


</code></pre>

<hr>
<h2 id='nchains-ndraws-nvars'>Get the number of chains, samples per chain or the number of variables in a simulation object</h2><span id='topic+nchains-ndraws-nvars'></span><span id='topic+nchains'></span><span id='topic+ndraws'></span><span id='topic+nvars'></span>

<h3>Description</h3>

<p>Get the number of chains, samples per chain or the number of variables in a simulation object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchains(obj)

ndraws(obj)

nvars(dc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchains-ndraws-nvars_+3A_obj">obj</code></td>
<td>
<p>an mcdraws object or a draws component (dc) object.</p>
</td></tr>
<tr><td><code id="nchains-ndraws-nvars_+3A_dc">dc</code></td>
<td>
<p>a draws component object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of chains or retained samples per chain or
the number of variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=50)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, n.chain=5, store.all=TRUE)
# resolve possible conflict with posterior package:
nchains &lt;- mcmcsae::nchains; ndraws &lt;- mcmcsae::ndraws
nchains(sim); nchains(sim$beta)
ndraws(sim); ndraws(sim$beta)
nvars(sim$beta); nvars(sim$sigma_); nvars(sim$llh_); nvars(sim$v)
plot(sim, "beta")
nchains(subset(sim$beta, chains=1:2))
ndraws(subset(sim$beta, draws=sample(1:ndraws(sim), 100)))
nvars(subset(sim$u, vars=1:2))


</code></pre>

<hr>
<h2 id='par_names'>Get the parameter names from an mcdraws object</h2><span id='topic+par_names'></span>

<h3>Description</h3>

<p>Get the parameter names from an mcdraws object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>par_names(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="par_names_+3A_obj">obj</code></td>
<td>
<p>an mcdraws object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The names of the parameters whose MCMC simulations are stored in <code>obj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
sampler &lt;- create_sampler(Sepal.Length ~ 
    reg(~ Petal.Length + Species, name="beta"), data=iris)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=400)
(summary(sim))
par_names(sim)

</code></pre>

<hr>
<h2 id='plot_coef'>Plot a set of model coefficients or predictions with uncertainty intervals
based on summaries of simulation results or other objects.</h2><span id='topic+plot_coef'></span>

<h3>Description</h3>

<p>This function plots estimates with error bars. Multiple sets of
estimates can be compared. The error bars can either be based on
standard errors or on explicitly specified lower and upper bounds.
The function is adapted from function <code>plot.sae</code> in package
<span class="pkg">hbsae</span>, which in turn was adapted from function
<code>coefplot.default</code> from package <span class="pkg">arm</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_coef(
  ...,
  n.se = 1,
  est.names,
  sort.by = NULL,
  decreasing = FALSE,
  index = NULL,
  maxrows = 50L,
  maxcols = 6L,
  offset = 0.1,
  cex.var = 0.8,
  mar = c(0.1, 2.1, 5.1, 0.1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_coef_+3A_...">...</code></td>
<td>
<p><code>dc_summary</code> objects (output by the <code>summary</code> method for
simulation objects of class <code>dc</code>), <code>sae</code> objects (output by the
functions of package <span class="pkg">hbsae</span>), or lists. In case of a list the components
used are those with name <code>est</code> for point estimates, <code>se</code>
for standard error based intervals or <code>lower</code> and <code>upper</code> for
custom intervals. Instead of <code>dc_summary</code> objects matrix objects are
also supported as long as they contain columns named &quot;Mean&quot; and &quot;SD&quot; as do
<code>dc_summary</code> objects. Named parameters of other types that do not match any
other argument names are passed to lower-level plot functions.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_n.se">n.se</code></td>
<td>
<p>number of standard errors below and above the point estimates
to use for error bars. By default equal to 1. This only refers to the
objects of class <code>dc_summary</code> and <code>sae</code>.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_est.names">est.names</code></td>
<td>
<p>labels to use in the legend for the components of the <code>...</code> argument</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_sort.by">sort.by</code></td>
<td>
<p>vector by which to sort the coefficients, referring to the first object passed.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_decreasing">decreasing</code></td>
<td>
<p>if <code>TRUE</code>, sort in decreasing order (default).</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_index">index</code></td>
<td>
<p>vector of names or indices of the selected areas to be plotted.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_maxrows">maxrows</code></td>
<td>
<p>maximum number of rows in a column.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_maxcols">maxcols</code></td>
<td>
<p>maximum number of columns of estimates on a page.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_offset">offset</code></td>
<td>
<p>space used between plots of multiple estimates for the same area.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_cex.var">cex.var</code></td>
<td>
<p>the font size for the variable names, default=0.8.</p>
</td></tr>
<tr><td><code id="plot_coef_+3A_mar">mar</code></td>
<td>
<p>a numerical vector of the form <code>c(bottom, left, top, right)</code>,
specifying the number of lines of margin on each of the four sides of the plot.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# create artificial data
set.seed(21)
n &lt;- 100
dat &lt;- data.frame(
  x=runif(n),
  f=factor(sample(1:20, n, replace=TRUE))
)
model &lt;- ~ reg(~ x, prior=pr_normal(precision=1), name="beta") + gen(factor=~f, name="v")
gd &lt;- generate_data(model, data=dat)
dat$y &lt;- gd$y
# fit a base model
model0 &lt;- y ~ reg(~ 1, name="beta") + gen(factor=~f, name="v")
sampler &lt;- create_sampler(model0, data=dat, block=TRUE)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
(summ0 &lt;- summary(sim))
# fit 'true' model
model &lt;- y ~ reg(~ x, name="beta") + gen(factor=~f, name="v")
sampler &lt;- create_sampler(model, data=dat, block=TRUE)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
(summ &lt;- summary(sim))
# compare random effect estimates against true parameter values
plot_coef(summ0$v, summ$v, list(est=gd$pars$v), n.se=2, offset=0.2,
  maxrows=10, est.names=c("base model", "true model", "true"))


</code></pre>

<hr>
<h2 id='plot.dc'>Trace, density and autocorrelation plots for (parameters of a) draws
component (dc) object</h2><span id='topic+plot.dc'></span>

<h3>Description</h3>

<p>Trace, density and autocorrelation plots for (parameters of a) draws
component (dc) object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dc'
plot(x, nrows, ncols, ask = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dc_+3A_x">x</code></td>
<td>
<p>a draws component object.</p>
</td></tr>
<tr><td><code id="plot.dc_+3A_nrows">nrows</code></td>
<td>
<p>number of rows in plot layout.</p>
</td></tr>
<tr><td><code id="plot.dc_+3A_ncols">ncols</code></td>
<td>
<p>number of columns in plot layout.</p>
</td></tr>
<tr><td><code id="plot.dc_+3A_ask">ask</code></td>
<td>
<p>ask before plotting the next page; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.dc_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=50)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
plot(sim$u)


</code></pre>

<hr>
<h2 id='plot.mcdraws'>Trace, density and autocorrelation plots</h2><span id='topic+plot.mcdraws'></span>

<h3>Description</h3>

<p>Trace, density and autocorrelation plots for selected components of an <code>mcdraws</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcdraws'
plot(x, vnames, nrows, ncols, ask = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mcdraws_+3A_x">x</code></td>
<td>
<p>an object of class <code>mcdraws</code>.</p>
</td></tr>
<tr><td><code id="plot.mcdraws_+3A_vnames">vnames</code></td>
<td>
<p>optional character vector to select a subset of parameters.</p>
</td></tr>
<tr><td><code id="plot.mcdraws_+3A_nrows">nrows</code></td>
<td>
<p>number of rows in plot layout.</p>
</td></tr>
<tr><td><code id="plot.mcdraws_+3A_ncols">ncols</code></td>
<td>
<p>number of columns in plot layout.</p>
</td></tr>
<tr><td><code id="plot.mcdraws_+3A_ask">ask</code></td>
<td>
<p>ask before plotting the next page; default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.mcdraws_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=50)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
plot(sim, c("beta", "u", "u_sigma", "v_sigma"), ask=TRUE)


</code></pre>

<hr>
<h2 id='posterior-moments'>Get means or standard deviations of parameters from the MCMC output in an mcdraws object</h2><span id='topic+posterior-moments'></span><span id='topic+get_means'></span><span id='topic+get_sds'></span>

<h3>Description</h3>

<p>Get means or standard deviations of parameters from the MCMC output in an mcdraws object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_means(obj, vnames = NULL)

get_sds(obj, vnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posterior-moments_+3A_obj">obj</code></td>
<td>
<p>an object of class <code>mcdraws</code>.</p>
</td></tr>
<tr><td><code id="posterior-moments_+3A_vnames">vnames</code></td>
<td>
<p>optional character vector to select a subset of parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with simulation means or standard deviations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=50)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, n.chain=4)
get_means(sim)
get_means(sim, "e_")
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, n.chain=4,
  store.mean=c("beta", "u"), store.sds=TRUE)
summary(sim, "beta")
get_means(sim, "beta")
get_sds(sim, "beta")
get_means(sim, "u")
get_sds(sim, "u")


</code></pre>

<hr>
<h2 id='pr_exp'>Create an object representing exponential prior distributions</h2><span id='topic+pr_exp'></span>

<h3>Description</h3>

<p>Create an object representing exponential prior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_exp(scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_exp_+3A_scale">scale</code></td>
<td>
<p>scalar or vector scale parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>

<hr>
<h2 id='pr_fixed'>Create an object representing a degenerate prior fixing a
parameter (vector) to a fixed value</h2><span id='topic+pr_fixed'></span>

<h3>Description</h3>

<p>Create an object representing a degenerate prior fixing a
parameter (vector) to a fixed value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_fixed(value = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_fixed_+3A_value">value</code></td>
<td>
<p>scalar or vector value parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>

<hr>
<h2 id='pr_gamma'>Create an object representing gamma prior distributions</h2><span id='topic+pr_gamma'></span>

<h3>Description</h3>

<p>Create an object representing gamma prior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_gamma(shape = 1, rate = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_gamma_+3A_shape">shape</code></td>
<td>
<p>scalar or vector shape parameter.</p>
</td></tr>
<tr><td><code id="pr_gamma_+3A_rate">rate</code></td>
<td>
<p>scalar or vector rate, i.e. inverse scale, parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>

<hr>
<h2 id='pr_gig'>Create an object representing Generalized Inverse Gaussian (GIG) prior distributions</h2><span id='topic+pr_gig'></span>

<h3>Description</h3>

<p>Create an object representing Generalized Inverse Gaussian (GIG) prior distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_gig(a, b, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_gig_+3A_a">a</code></td>
<td>
<p>scalar or vector parameter.</p>
</td></tr>
<tr><td><code id="pr_gig_+3A_b">b</code></td>
<td>
<p>scalar or vector parameter.</p>
</td></tr>
<tr><td><code id="pr_gig_+3A_p">p</code></td>
<td>
<p>scalar or vector parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>

<hr>
<h2 id='pr_invchisq'>Create an object representing inverse chi-squared priors
with possibly modeled degrees of freedom and scale parameters</h2><span id='topic+pr_invchisq'></span>

<h3>Description</h3>

<p>Create an object representing inverse chi-squared priors
with possibly modeled degrees of freedom and scale parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_invchisq(df = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_invchisq_+3A_df">df</code></td>
<td>
<p>degrees of freedom parameter. This can be a numeric scalar or
vector of length <code>n</code>, the dimension of the parameter vector.
Alternatively, for a scalar degrees of freedom parameter,
<code>df="modeled"</code> or <code>df="modelled"</code> assign a default (gamma) prior
to the degrees of freedom parameter. For more control of this gamma prior a
list can be passed with some of the following components:
</p>

<dl>
<dt>alpha0</dt><dd><p>shape parameter of the gamma distribution</p>
</dd>
<dt>beta0</dt><dd><p>rate parameter of the gamma distribution</p>
</dd>
<dt>proposal</dt><dd><p>&quot;RW&quot; for random walk Metropolis-Hastings
or &quot;mala&quot; for Metropolis-adjusted Langevin</p>
</dd>
<dt>tau</dt><dd><p>(starting) scale of Metropolis-Hastings update</p>
</dd>
<dt>adapt</dt><dd><p>whether to adapt the scale of the proposal distribution
during burnin to achieve better acceptance rates.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pr_invchisq_+3A_scale">scale</code></td>
<td>
<p>scalar or vector scale parameter. Alternatively,
<code>scale="modeled"</code> or <code>scale="modelled"</code> puts a default
chi-squared prior on the scale parameter. For more control on this
chi-squared prior a list can be passed with some of the following components:
</p>

<dl>
<dt>df</dt><dd><p>degrees of freedom (scalar or vector)</p>
</dd>
<dt>scale</dt><dd><p>scale (scalar or vector)</p>
</dd>
<dt>common</dt><dd><p>whether the modeled scale parameter of the inverse chi-squared
distribution is (a scalar parameter) common to all <code>n</code> parameters.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>

<hr>
<h2 id='pr_invwishart'>Create an object representing an inverse Wishart prior,
possibly with modeled scale matrix</h2><span id='topic+pr_invwishart'></span>

<h3>Description</h3>

<p>Create an object representing an inverse Wishart prior,
possibly with modeled scale matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_invwishart(df = NULL, scale = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_invwishart_+3A_df">df</code></td>
<td>
<p>Degrees of freedom parameter. This should be a scalar numeric value.
Default value is the dimension plus one.</p>
</td></tr>
<tr><td><code id="pr_invwishart_+3A_scale">scale</code></td>
<td>
<p>Either a (known) scale matrix, or
<code>scale="modeled"</code> or <code>scale="modelled"</code>, which puts default
chi-squared priors on the diagonal elements of the inverse Wishart scale matrix.
For more control on these chi-squared priors a list can be passed with some of the
following components:
</p>

<dl>
<dt>df</dt><dd><p>degrees of freedom (scalar or vector) of the chi-squared distribution(s)</p>
</dd>
<dt>scale</dt><dd><p>scale parameter(s) of the chi-squared distribution(s)</p>
</dd>
<dt>common</dt><dd><p>whether the modeled scale parameter of the inverse chi-squared
distribution is (a scalar parameter) common to all <code>n</code> diagonal elements.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>


<h3>References</h3>

<p>A. Huang and M.P. Wand (2013).
Simple marginally noninformative prior
distributions for covariance matrices.
Bayesian Analysis 8, 439-452.
</p>

<hr>
<h2 id='pr_MLiG'>Create an object representing a Multivariate Log inverse Gamma (MLiG) prior distribution</h2><span id='topic+pr_MLiG'></span>

<h3>Description</h3>

<p>Create an object representing a Multivariate Log inverse Gamma (MLiG) prior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_MLiG(mean = 0, precision = 0, labels = NULL, a = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_MLiG_+3A_mean">mean</code></td>
<td>
<p>scalar or vector parameter for the mean in the large
<code>a</code> limit, when the distribution approaches a normal distribution.</p>
</td></tr>
<tr><td><code id="pr_MLiG_+3A_precision">precision</code></td>
<td>
<p>scalar or vector parameter for the precision in the
large <code>a</code> limit, when the distribution approaches a normal
distribution.</p>
</td></tr>
<tr><td><code id="pr_MLiG_+3A_labels">labels</code></td>
<td>
<p>optional character vector with coefficient labels. If specified,
it should have the same length as at least one of <code>mean</code> and <code>precision</code>,
and in that case the MLiG prior with these parameters is assigned to these coefficients,
while any coefficients not present in labels will be assigned a non-informative
prior with mean 0 and precision 0.</p>
</td></tr>
<tr><td><code id="pr_MLiG_+3A_a">a</code></td>
<td>
<p>scalar parameter that controls how close the prior is to independent
normal priors with <code>mean</code> and <code>precision</code> parameters. The larger
this value (default is 1000), the closer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>


<h3>References</h3>

<p>J.R. Bradley, S.H. Holan and C.K. Wikle (2018).
Computationally efficient multivariate spatio-temporal models for
high-dimensional count-valued data (with discussion).
Bayesian Analysis 13(1), 253-310.
</p>

<hr>
<h2 id='pr_normal'>Create an object representing a possibly multivariate normal prior distribution</h2><span id='topic+pr_normal'></span>

<h3>Description</h3>

<p>Create an object representing a possibly multivariate normal prior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pr_normal(mean = 0, precision = 0, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pr_normal_+3A_mean">mean</code></td>
<td>
<p>scalar or vector mean parameter.</p>
</td></tr>
<tr><td><code id="pr_normal_+3A_precision">precision</code></td>
<td>
<p>scalar, vector or matrix precision parameter.</p>
</td></tr>
<tr><td><code id="pr_normal_+3A_labels">labels</code></td>
<td>
<p>optional character vector with coefficient labels. If specified,
it should have the same length as at least one of <code>mean</code> and <code>precision</code>,
and in that case the normal prior with these parameters is assigned to these coefficients,
while any coefficients not present in labels will be assigned a non-informative
prior with mean 0 and precision 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment representing the specified prior, for internal use.
</p>

<hr>
<h2 id='predict.mcdraws'>Generate draws from the predictive distribution</h2><span id='topic+predict.mcdraws'></span>

<h3>Description</h3>

<p>Generate draws from the predictive distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcdraws'
predict(
  object,
  newdata = NULL,
  X. = if (is.null(newdata)) "in-sample" else NULL,
  type = c("data", "link", "response", "data_cat"),
  var = NULL,
  ny = NULL,
  ry = NULL,
  fun. = identity,
  labels = NULL,
  ppcheck = FALSE,
  iters = NULL,
  to.file = FALSE,
  filename,
  write.single.prec = FALSE,
  show.progress = TRUE,
  verbose = TRUE,
  n.cores = 1L,
  cl = NULL,
  seed = NULL,
  export = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.mcdraws_+3A_object">object</code></td>
<td>
<p>an object of class <code>mcdraws</code>, as output by <code><a href="#topic+MCMCsim">MCMCsim</a></code>.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_newdata">newdata</code></td>
<td>
<p>data frame with auxiliary information to be used for prediction.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_x.">X.</code></td>
<td>
<p>a list of design matrices; alternatively, <code>X.</code> equals 'in-sample' or 'linpred'.
If 'in-sample' (the default if newdata is not supplied), the design matrices for in-sample
prediction are used. If 'linpred' the 'linpred_' component of <code>object</code> is used.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_type">type</code></td>
<td>
<p>the type of predictions. The default is <code>"data"</code>, meaning that
new data is generated according to the predictive distribution.
If <code>type="link"</code> only the linear predictor for the mean is generated, and
in case <code>type="response"</code> the linear predictor is transformed to the response scale.
For Gaussian models <code>type="link"</code> and <code>type="response"</code> are equivalent.
For binomial and negative binomial models <code>type="response"</code> returns the simulations
of the latent probabilities. For multinomial models <code>type="link"</code> generates
the linear predictor for all categories except the last, and <code>type="response"</code> transforms
this vector to the probability scale, and <code>type="data"</code> generates the multinomial data,
all in long vector format, where the output for all categories (except the last) are stacked.
For multinomial models and single trials, a further option is <code>type="data_cat"</code>,
which generates the data as a categorical vector, with integer coded levels.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_var">var</code></td>
<td>
<p>variance(s) used for out-of-sample prediction. By default 1.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_ny">ny</code></td>
<td>
<p>number of trials used for out-of-sample prediction in case of a binomial model. By default 1.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_ry">ry</code></td>
<td>
<p>fixed part of the (reciprocal) dispersion parameter in case of a negative binomial model.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_fun.">fun.</code></td>
<td>
<p>function applied to the vector of posterior predictions to compute one or multiple summaries
or test statistics. The function can have one or two arguments. The first argument is always the vector
of posterior predictions. The optional second argument represents a list of model parameters, needed only
when a test statistic depends on them. The function must return an integer or numeric vector.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_labels">labels</code></td>
<td>
<p>optional names for the output object. Must be a vector of the same length as the result of <code>fun.</code>.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_ppcheck">ppcheck</code></td>
<td>
<p>if <code>TRUE</code>, function <code>fun.</code> is also applied to the observed data and
an MCMC approximation is computed of the posterior predictive probability that the test statistic for
predicted data is greater than the test statistic for the observed data.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_iters">iters</code></td>
<td>
<p>iterations in <code>object</code> to use for prediction.
Default <code>NULL</code> means that all draws from <code>object</code> are used.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_to.file">to.file</code></td>
<td>
<p>if <code>TRUE</code> the predictions are streamed to file.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_filename">filename</code></td>
<td>
<p>name of the file to write predictions to in case <code>to.file=TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_write.single.prec">write.single.prec</code></td>
<td>
<p>Whether to write to file in single precision. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_show.progress">show.progress</code></td>
<td>
<p>whether to show a progress bar.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_verbose">verbose</code></td>
<td>
<p>whether to show informative messages.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_n.cores">n.cores</code></td>
<td>
<p>the number of cpu cores to use. Default is one, i.e. no parallel computation.
If an existing cluster <code>cl</code> is provided, <code>n.cores</code> will be set to the number
of workers in that cluster.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_cl">cl</code></td>
<td>
<p>an existing cluster can be passed for parallel computation. If <code>NULL</code> and
<code>n.cores &gt; 1</code>, a new cluster is created.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_seed">seed</code></td>
<td>
<p>a random seed (integer). For parallel computation it is used to independently
seed RNG streams for all workers.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_export">export</code></td>
<td>
<p>a character vector with names of objects to export to the workers. This may
be needed for parallel execution if expressions in <code>fun.</code> depend on global variables.</p>
</td></tr>
<tr><td><code id="predict.mcdraws_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dc</code>, containing draws from the posterior (or prior) predictive distribution.
If <code>ppcheck=TRUE</code> posterior predictive p-values are returned as an additional attribute.
In case <code>to.file=TRUE</code> the file name used is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
n &lt;- 250
dat &lt;- data.frame(x=runif(n))
dat$y &lt;- 1 + dat$x + rnorm(n)
sampler &lt;- create_sampler(y ~ x, data=dat)
sim &lt;- MCMCsim(sampler)
summary(sim)
# in-sample prediction
pred &lt;- predict(sim, ppcheck=TRUE)
hist(attr(pred, "ppp"))
# out-of-sample prediction
pred &lt;- predict(sim, newdata=data.frame(x=seq(0, 1, by=0.1)))
summary(pred)


</code></pre>

<hr>
<h2 id='print.dc_summary'>Display a summary of a <code>dc</code> object</h2><span id='topic+print.dc_summary'></span>

<h3>Description</h3>

<p>Display a summary of a <code>dc</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dc_summary'
print(
  x,
  digits = 3L,
  max.lines = 1000L,
  tail = FALSE,
  sort = NULL,
  max.label.length = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dc_summary_+3A_x">x</code></td>
<td>
<p>an object of class <code>dc_summary</code>.</p>
</td></tr>
<tr><td><code id="print.dc_summary_+3A_digits">digits</code></td>
<td>
<p>number of digits to use, defaults to 3.</p>
</td></tr>
<tr><td><code id="print.dc_summary_+3A_max.lines">max.lines</code></td>
<td>
<p>maximum number of lines to display.
If <code>NULL</code>, all elements are displayed.</p>
</td></tr>
<tr><td><code id="print.dc_summary_+3A_tail">tail</code></td>
<td>
<p>if <code>TRUE</code> the last instead of first at most <code>max.lines</code> are displayed.</p>
</td></tr>
<tr><td><code id="print.dc_summary_+3A_sort">sort</code></td>
<td>
<p>column name on which to sort the output.</p>
</td></tr>
<tr><td><code id="print.dc_summary_+3A_max.label.length">max.label.length</code></td>
<td>
<p>if specified, printed row labels will be abbreviated to at most this length.</p>
</td></tr>
<tr><td><code id="print.dc_summary_+3A_...">...</code></td>
<td>
<p>passed on to <code>print.default</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
print(summary(sim$u), sort="n_eff")


</code></pre>

<hr>
<h2 id='print.mcdraws_summary'>Print a summary of MCMC simulation results</h2><span id='topic+print.mcdraws_summary'></span>

<h3>Description</h3>

<p>Display a summary of an <code>mcdraws</code> object, as output by <code><a href="#topic+MCMCsim">MCMCsim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcdraws_summary'
print(x, digits = 3L, max.lines = 10L, tail = FALSE, sort = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcdraws_summary_+3A_x">x</code></td>
<td>
<p>an object of class <code>mcdraws_summary</code> as output by <code><a href="#topic+summary.mcdraws">summary.mcdraws</a></code>.</p>
</td></tr>
<tr><td><code id="print.mcdraws_summary_+3A_digits">digits</code></td>
<td>
<p>number of digits to use, defaults to 3.</p>
</td></tr>
<tr><td><code id="print.mcdraws_summary_+3A_max.lines">max.lines</code></td>
<td>
<p>maximum number of elements per vector parameter to display.
If <code>NULL</code>, all elements are displayed.</p>
</td></tr>
<tr><td><code id="print.mcdraws_summary_+3A_tail">tail</code></td>
<td>
<p>if <code>TRUE</code> the last instead of first <code>max.lines</code> of each component
are displayed.</p>
</td></tr>
<tr><td><code id="print.mcdraws_summary_+3A_sort">sort</code></td>
<td>
<p>column name on which to sort the output.</p>
</td></tr>
<tr><td><code id="print.mcdraws_summary_+3A_...">...</code></td>
<td>
<p>passed on to <code>print.default</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
print(summary(sim), sort="n_eff")


</code></pre>

<hr>
<h2 id='read_draws'>Read MCMC draws from a file</h2><span id='topic+read_draws'></span>

<h3>Description</h3>

<p>Read draws written to file by <code><a href="#topic+MCMCsim">MCMCsim</a></code> used with argument <code>to.file</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_draws(name, filename = paste0("MCdraws_", name, ".dat"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_draws_+3A_name">name</code></td>
<td>
<p>name of the parameter to load the corresponding file with posterior draws for.</p>
</td></tr>
<tr><td><code id="read_draws_+3A_filename">filename</code></td>
<td>
<p>name of the file in which the draws are stored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>dc</code> containing MCMC draws for a (vector) parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# NB this example creates a file "MCdraws_e_.dat" in the working directory
n &lt;- 100
dat &lt;- data.frame(x=runif(n), f=as.factor(sample(1:5, n, replace=TRUE)))
gd &lt;- generate_data(~ reg(~ x + f, prior=pr_normal(precision=1), name="beta"), data=dat)
dat$y &lt;- gd$y
sampler &lt;- create_sampler(y ~ reg(~ x + f, name="beta"), data=dat)
# run the MCMC simulation and write draws of residuals to file:
sim &lt;- MCMCsim(sampler, n.iter=500, to.file="e_")
summary(sim)
mcres &lt;- read_draws("e_")
summary(mcres)

## End(Not run)

</code></pre>

<hr>
<h2 id='reg'>Create a model component object for a regression (fixed effects) component
in the linear predictor</h2><span id='topic+reg'></span>

<h3>Description</h3>

<p>This function is intended to be used on the right hand side of the
<code>formula</code> argument to <code><a href="#topic+create_sampler">create_sampler</a></code> or
<code><a href="#topic+generate_data">generate_data</a></code>. It creates an additive regression term in the
model's linear predictor. By default, the prior for the regression
coefficients is improper uniform. A proper normal prior can be set up
using function <code><a href="#topic+pr_normal">pr_normal</a></code>, and passed to argument <code>prior</code>.
It should be noted that <code><a href="#topic+pr_normal">pr_normal</a></code> expects a precision matrix
as input for its second argument, and that the prior variance (matrix) is
taken to be the inverse of this precision matrix, where in case the
model's family is <code>"gaussian"</code> this matrix is additionally
multiplied by the residual scalar variance parameter <code>sigma_^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg(
  formula = ~1,
  remove.redundant = FALSE,
  sparse = NULL,
  X = NULL,
  prior = NULL,
  Q0 = NULL,
  b0 = NULL,
  R = NULL,
  r = NULL,
  S = NULL,
  s = NULL,
  lower = NULL,
  upper = NULL,
  name = "",
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the predictors to be used in the model,
in the same way as the right hand side of the <code>formula</code> argument of
R's <code>lm</code> function. Variable names are looked up in the data frame
passed as <code>data</code> argument to <code><a href="#topic+create_sampler">create_sampler</a></code> or
<code><a href="#topic+generate_data">generate_data</a></code>, or in <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="reg_+3A_remove.redundant">remove.redundant</code></td>
<td>
<p>whether redundant columns should be removed from the
design matrix. Default is <code>FALSE</code>. But note that treatment contrasts are
automatically applied to all factor variables in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="reg_+3A_sparse">sparse</code></td>
<td>
<p>whether the model matrix associated with <code>formula</code> should
be sparse. The default is to base this on a simple heuristic.</p>
</td></tr>
<tr><td><code id="reg_+3A_x">X</code></td>
<td>
<p>a (possibly sparse) design matrix can be specified directly, as an
alternative to the creation of one based on <code>formula</code>. If <code>X</code> is
specified <code>formula</code> is ignored.</p>
</td></tr>
<tr><td><code id="reg_+3A_prior">prior</code></td>
<td>
<p>prior specification for the regression coefficients. Supported
priors can be specified using functions <code><a href="#topic+pr_normal">pr_normal</a></code>,
<code><a href="#topic+pr_fixed">pr_fixed</a></code>, or <code><a href="#topic+pr_MLiG">pr_MLiG</a></code>. The latter prior is only
available in conjunction with a gamma family sampling distribution.</p>
</td></tr>
<tr><td><code id="reg_+3A_q0">Q0</code></td>
<td>
<p>prior precision matrix for the regression effects. The default is a
zero matrix corresponding to a noninformative improper prior.
It can be specified as a scalar value, as a numeric vector of appropriate
length, or as a matrix object. DEPRECATED, please use argument <code>prior</code>
instead, i.e. <code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td></tr>
<tr><td><code id="reg_+3A_b0">b0</code></td>
<td>
<p>prior mean for the regression effect. Defaults to a zero vector.
It can be specified as a scalar value or as a numeric vector of
appropriate length. DEPRECATED, please use argument <code>prior</code>
instead, i.e. <code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td></tr>
<tr><td><code id="reg_+3A_r">R</code></td>
<td>
<p>optional constraint matrix for equality restrictions R'x = r where
<code>x</code> is the vector of regression effects.</p>
</td></tr>
<tr><td><code id="reg_+3A_r">r</code></td>
<td>
<p>right hand side for the equality constraints.</p>
</td></tr>
<tr><td><code id="reg_+3A_s">S</code></td>
<td>
<p>optional constraint matrix for inequality constraints S'x &gt;= s where
<code>x</code> is the vector of regression effects.</p>
</td></tr>
<tr><td><code id="reg_+3A_s">s</code></td>
<td>
<p>right hand side for the inequality constraints.</p>
</td></tr>
<tr><td><code id="reg_+3A_lower">lower</code></td>
<td>
<p>as an alternative to <code>s</code>, <code>lower</code> and <code>upper</code> may be specified
for two-sided constraints lower &lt;= S'x &lt;= upper.</p>
</td></tr>
<tr><td><code id="reg_+3A_upper">upper</code></td>
<td>
<p>as an alternative to <code>s</code>, <code>lower</code> and <code>upper</code> may be specified
for two-sided constraints lower &lt;= S'x &lt;= upper.</p>
</td></tr>
<tr><td><code id="reg_+3A_name">name</code></td>
<td>
<p>the name of the model component. This name is used in the output of the
MCMC simulation function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. By default the name will be 'reg'
with the number of the model term attached.</p>
</td></tr>
<tr><td><code id="reg_+3A_debug">debug</code></td>
<td>
<p>if <code>TRUE</code> a breakpoint is set at the beginning of the posterior
draw function associated with this model component. Mainly intended for developers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with precomputed quantities and functions for sampling from
prior or conditional posterior distributions for this model component. Intended
for internal use by other package functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iris)
# default: flat priors on regression coefficients
sampler &lt;- create_sampler(Sepal.Length ~
    reg(~ Petal.Length + Species, name="beta"),
  data=iris
)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=400)
summary(sim)
# (weakly) informative normal priors on regression coefficients
sampler &lt;- create_sampler(Sepal.Length ~
    reg(~ Petal.Length + Species, prior=pr_normal(precision=1e-2), name="beta"),
  data=iris
)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=400)
summary(sim)
# binary regression
sampler &lt;- create_sampler(Species == "setosa" ~
    reg(~ Sepal.Length, prior=pr_normal(precision=0.1), name="beta"),
  family="binomial", data=iris)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=400)
summary(sim)
pred &lt;- predict(sim)
str(pred)
# example with equality constrained regression effects
n &lt;- 500
df &lt;- data.frame(x=runif(n))
df$y &lt;- rnorm(n, 1 + 2*df$x)
R &lt;- matrix(1, 2, 1)
r &lt;- 3
sampler &lt;- create_sampler(y ~ reg(~ 1 + x, R=R, r=r, name="beta"), data=df)
sim &lt;- MCMCsim(sampler)
summary(sim)
plot(sim, "beta")
summary(transform_dc(sim$beta, fun=function(x) crossprod_mv(R, x) - r))


</code></pre>

<hr>
<h2 id='residuals-fitted-values'>Extract draws of fitted values or residuals from an mcdraws object</h2><span id='topic+residuals-fitted-values'></span><span id='topic+fitted.mcdraws'></span><span id='topic+residuals.mcdraws'></span>

<h3>Description</h3>

<p>For a model created with <code><a href="#topic+create_sampler">create_sampler</a></code> and estimated using <code><a href="#topic+MCMCsim">MCMCsim</a></code>,
these functions return the posterior draws of fitted values or residuals.
In the current implementation the fitted values correspond to the linear predictor
and the residuals are computed as the data vector minus the fitted values,
regardless of the model's distribution family.
For large datasets the returned object can become very large. One may therefore
select a subset of draws or chains or use <code>mean.only=TRUE</code> to
return a vector of posterior means only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcdraws'
fitted(
  object,
  mean.only = FALSE,
  units = NULL,
  chains = seq_len(nchains(object)),
  draws = seq_len(ndraws(object)),
  matrix = FALSE,
  type = c("link", "response"),
  ...
)

## S3 method for class 'mcdraws'
residuals(
  object,
  mean.only = FALSE,
  units = NULL,
  chains = seq_len(nchains(object)),
  draws = seq_len(ndraws(object)),
  matrix = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals-fitted-values_+3A_object">object</code></td>
<td>
<p>an object of class <code>mcdraws</code>.</p>
</td></tr>
<tr><td><code id="residuals-fitted-values_+3A_mean.only">mean.only</code></td>
<td>
<p>if <code>TRUE</code> only the vector of posterior means is returned. In that case
the subsequent arguments are ignored. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="residuals-fitted-values_+3A_units">units</code></td>
<td>
<p>the data units (by default all) for which fitted values or residuals should be
computed.</p>
</td></tr>
<tr><td><code id="residuals-fitted-values_+3A_chains">chains</code></td>
<td>
<p>optionally, a selection of chains.</p>
</td></tr>
<tr><td><code id="residuals-fitted-values_+3A_draws">draws</code></td>
<td>
<p>optionally, a selection of draws per chain.</p>
</td></tr>
<tr><td><code id="residuals-fitted-values_+3A_matrix">matrix</code></td>
<td>
<p>whether a matrix should be returned instead of a dc object.</p>
</td></tr>
<tr><td><code id="residuals-fitted-values_+3A_type">type</code></td>
<td>
<p>the type of fitted values: &quot;link&quot; for fitted values on the linear predictor scale
(the default), and &quot;response&quot; for fitted values on the response scale. Returned residuals are
always on the response scale.</p>
</td></tr>
<tr><td><code id="residuals-fitted-values_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a draws component object or a matrix with draws of fitted values or residuals.
The residuals are always on the response scale, whereas fitted values can
be on the scale of the linear predictor or the response depending on <code>type</code>.
If <code>mean.only=TRUE</code>, a vector of posterior means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=50)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, store.all=TRUE)
fitted(sim, mean.only=TRUE)
summary(fitted(sim))
residuals(sim, mean.only=TRUE)
summary(residuals(sim))
bayesplot::mcmc_intervals(as.matrix(subset(residuals(sim), vars=1:20)))


</code></pre>

<hr>
<h2 id='sampler_control'>Set computational options for the sampling algorithms</h2><span id='topic+sampler_control'></span>

<h3>Description</h3>

<p>Set computational options for the sampling algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampler_control(
  add.outer.R = TRUE,
  recompute.e = TRUE,
  expanded.cMVN.sampler = FALSE,
  CG = NULL,
  block = TRUE,
  block.V = TRUE,
  auto.order.block = TRUE,
  chol.control = chol_control(),
  max.size.cps.template = 100,
  PG.approx = TRUE,
  PG.approx.m = -2L,
  CRT.approx.m = 20L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampler_control_+3A_add.outer.r">add.outer.R</code></td>
<td>
<p>whether to add the outer product of a constraint matrix for a better conditioned 
linear system of equations, typically for coefficients sampled in a Gibbs-block. Default is <code>TRUE</code>.
If <code>NULL</code>, a simple heuristic is used to decide whether to add the outer product
of possibly a submatrix of the constraint matrix.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_recompute.e">recompute.e</code></td>
<td>
<p>when <code>FALSE</code>, residuals or linear predictors are only computed at the start of the simulation.
This may give a modest speedup but in some cases may be less accurate due to round-off error accumulation.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_expanded.cmvn.sampler">expanded.cMVN.sampler</code></td>
<td>
<p>whether an expanded linear system including dual variables is used
for equality constrained multivariate normal sampling. If set to <code>TRUE</code> this may
improve the performance of the blocked Gibbs sampler in case of a large number of equality
constraints, typically identifiability constraints for GMRFs.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_cg">CG</code></td>
<td>
<p>use a conjugate gradient iterative algorithm instead of Cholesky updates for sampling
the model's coefficients. This must be a list with possible components <code>max.it</code>,
<code>stop.criterion</code>, <code>verbose</code>, <code>preconditioner</code> and <code>scale</code>.
See the help for function <code><a href="#topic+CG_control">CG_control</a></code>, which can be used to specify these options.
Conjugate gradient sampling is currently an experimental feature that can be used for
blocked Gibbs sampling but with some limitations.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_block">block</code></td>
<td>
<p>if <code>TRUE</code>, the default, all coefficients are sampled in a single block. Alternatively, a list of
character vectors with names of model components whose coefficients should be sampled together in blocks.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_block.v">block.V</code></td>
<td>
<p>if <code>TRUE</code>, the default, all coefficients of <code>reg</code> and <code>gen</code> components
in a variance model formula are sampled in a single block. Alternatively, a list of
character vectors with names of model components whose coefficients should be sampled together in blocks.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_auto.order.block">auto.order.block</code></td>
<td>
<p>whether Gibbs blocks should be ordered automatically in such a
way that those with the most sparse design matrices come first. This way of ordering
can make Cholesky updates more efficient.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_chol.control">chol.control</code></td>
<td>
<p>options for Cholesky decomposition, see <code><a href="#topic+chol_control">chol_control</a></code>.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_max.size.cps.template">max.size.cps.template</code></td>
<td>
<p>maximum allowed size in MB of the sparse matrix serving as a 
template for the sparse symmetric crossproduct X'QX of a dgCMatrix X, where Q is a diagonal
matrix subject to change.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_pg.approx">PG.approx</code></td>
<td>
<p>whether Polya-Gamma draws for logistic binomial models are
approximated by a hybrid gamma convolution approach. If not, <code>BayesLogit::rpg</code>
is used, which is exact for some values of the shape parameter.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_pg.approx.m">PG.approx.m</code></td>
<td>
<p>if <code>PG.approx=TRUE</code>, the number of explicit gamma draws in the
sum-of-gammas representation of the Polya-Gamma distribution. The remainder (infinite)
convolution is approximated by a single moment-matching gamma draw. Special values are:
<code>-2L</code> for a default choice depending on the value of the shape parameter
balancing performance and accuracy, <code>-1L</code> for a moment-matching normal approximation,
and <code>0L</code> for a moment-matching gamma approximation.</p>
</td></tr>
<tr><td><code id="sampler_control_+3A_crt.approx.m">CRT.approx.m</code></td>
<td>
<p>scalar integer specifying the degree of approximation to sampling
from a Chinese Restaurant Table distribution. The approximation is based on Le Cam's theorem.
Larger values yield a slower but more accurate sampler.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with specified computational options used by various sampling functions.
</p>


<h3>References</h3>

<p>D. Bates, M. Maechler, B. Bolker and S.C. Walker (2015).
Fitting Linear Mixed-Effects Models Using lme4.
Journal of Statistical Software 67(1), 1-48.
</p>
<p>Y. Chen, T.A. Davis, W.W. Hager and S. Rajamanickam (2008).
Algorithm 887: CHOLMOD, supernodal sparse Cholesky factorization and update/downdate.
ACM Transactions on Mathematical Software 35(3), 1-14.
</p>

<hr>
<h2 id='SBC_test'>Simulation based calibration</h2><span id='topic+SBC_test'></span>

<h3>Description</h3>

<p>Simulation based calibration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SBC_test(
  ...,
  pars,
  n.draws = 25L,
  n.sim = 20L * n.draws,
  burnin = 25L,
  thin = 2L,
  show.progress = TRUE,
  verbose = TRUE,
  n.cores = 1L,
  cl = NULL,
  seed = NULL,
  export = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SBC_test_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+create_sampler">create_sampler</a></code> (can be all parameters except <code>prior.only</code>)</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_pars">pars</code></td>
<td>
<p>named list with univariate functions of the parameters to use in test. This list
is passed to argument <code>pred</code> of <code><a href="#topic+MCMCsim">MCMCsim</a></code>.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_n.draws">n.draws</code></td>
<td>
<p>number of posterior draws to retain in posterior simulations.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_n.sim">n.sim</code></td>
<td>
<p>number of simulation iterations.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_burnin">burnin</code></td>
<td>
<p>burnin to use in posterior simulations, passed to <code><a href="#topic+MCMCsim">MCMCsim</a></code>.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_thin">thin</code></td>
<td>
<p>thinning to use in posterior simulations, passed to <code><a href="#topic+MCMCsim">MCMCsim</a></code>.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_show.progress">show.progress</code></td>
<td>
<p>whether a progress bar should be shown.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_verbose">verbose</code></td>
<td>
<p>set to <code>FALSE</code> to suppress messages.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_n.cores">n.cores</code></td>
<td>
<p>the number of cpu cores to use. Default is one, i.e. no parallel computation.
If an existing cluster <code>cl</code> is provided, <code>n.cores</code> will be set to the number
of workers in that cluster.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_cl">cl</code></td>
<td>
<p>an existing cluster can be passed for parallel computation. If <code>NULL</code> and
<code>n.cores &gt; 1</code>, a new cluster is created.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_seed">seed</code></td>
<td>
<p>a random seed (integer). For parallel computation it is used to independently
seed RNG streams for all workers.</p>
</td></tr>
<tr><td><code id="SBC_test_+3A_export">export</code></td>
<td>
<p>a character vector with names of objects to export to the workers. This may
be needed for parallel execution if expressions in the model formulae depend on global variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with ranks.
</p>


<h3>References</h3>

<p>M. Modrak, A.H. Moon, S. Kim, P. Buerkner, N. Huurre, K. Faltejskova,
A. Gelman and A. Vehtari (2023).
Simulation-based calibration checking for Bayesian computation:
The choice of test quantities shapes sensitivity.
Bayesian Analysis, 1(1), 1-28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# this example may take a long time
n &lt;- 10L
dat &lt;- data.frame(x=runif(n))
ranks &lt;- SBC_test(~ reg(~ 1 + x, prior=pr_normal(mean=c(0.25, 1), precision=1), name="beta"),
  sigma.mod=pr_invchisq(df=1, scale=list(df=1, scale=1)), data=dat,
  pars=list(mu="beta[1]", beta_x="beta[2]", sigma="sigma_"),
  n.draws=9L, n.sim=10L*20L, thin=2L, burnin=20L
)
ranks

## End(Not run)

</code></pre>

<hr>
<h2 id='setup_CG_sampler'>Set up conjugate gradient sampler</h2><span id='topic+setup_CG_sampler'></span>

<h3>Description</h3>

<p>Set up conjugate gradient sampler
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_CG_sampler(mbs, X, sampler, control = CG_control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_CG_sampler_+3A_mbs">mbs</code></td>
<td>
<p>block component containing several model components.</p>
</td></tr>
<tr><td><code id="setup_CG_sampler_+3A_x">X</code></td>
<td>
<p>design matrix.</p>
</td></tr>
<tr><td><code id="setup_CG_sampler_+3A_sampler">sampler</code></td>
<td>
<p>sampler object as created by <code><a href="#topic+create_sampler">create_sampler</a></code>.</p>
</td></tr>
<tr><td><code id="setup_CG_sampler_+3A_control">control</code></td>
<td>
<p>a list of options for the conjugate gradient algorithm that can be passed
using function <code><a href="#topic+CG_control">CG_control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An environment with precomputed quantities and functions for multiplication
by A and by an (inverse) preconditioning matrix.
</p>


<h3>References</h3>

<p>A. Nishimura and M.A. Suchard (2022).
Prior-preconditioned conjugate gradient method for accelerated Gibbs sampling in
&quot;large n, large p&quot; Bayesian sparse regression.
Journal of the American Statistical Association, 1-14.
</p>

<hr>
<h2 id='setup_cluster'>Set up a cluster for parallel computing</h2><span id='topic+setup_cluster'></span>

<h3>Description</h3>

<p>The cluster is set up for a number of workers by loading the <span class="pkg">mcmcsae</span>
package and setting up independent RNG streams.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_cluster(n.cores = NULL, seed = NULL, export = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_cluster_+3A_n.cores">n.cores</code></td>
<td>
<p>the number of cpu cores to use.</p>
</td></tr>
<tr><td><code id="setup_cluster_+3A_seed">seed</code></td>
<td>
<p>optional random seed for reproducibility.</p>
</td></tr>
<tr><td><code id="setup_cluster_+3A_export">export</code></td>
<td>
<p>a character vector with names of objects to export to the workers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object representing the cluster.
</p>

<hr>
<h2 id='stop_cluster'>Stop a cluster</h2><span id='topic+stop_cluster'></span>

<h3>Description</h3>

<p>Stop a cluster set up by <code><a href="#topic+setup_cluster">setup_cluster</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_cluster(cl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_cluster_+3A_cl">cl</code></td>
<td>
<p>the cluster object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>.
</p>

<hr>
<h2 id='subset.dc'>Select a subset of chains, samples and parameters from a draws component (dc) object</h2><span id='topic+subset.dc'></span>

<h3>Description</h3>

<p>Select a subset of chains, samples and parameters from a draws component (dc) object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dc'
subset(
  x,
  chains = seq_len(nchains(x)),
  draws = seq_len(ndraws(x)),
  vars = seq_len(nvars(x)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.dc_+3A_x">x</code></td>
<td>
<p>a draws component (dc) object.</p>
</td></tr>
<tr><td><code id="subset.dc_+3A_chains">chains</code></td>
<td>
<p>an integer vector indicating which chains to select.</p>
</td></tr>
<tr><td><code id="subset.dc_+3A_draws">draws</code></td>
<td>
<p>an integer vector indicating which samples to select.</p>
</td></tr>
<tr><td><code id="subset.dc_+3A_vars">vars</code></td>
<td>
<p>an integer vector indicating which parameters to select.</p>
</td></tr>
<tr><td><code id="subset.dc_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The selected part of the draws component as an object of class <code>dc</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 300
dat &lt;- data.frame(x=runif(n), f=as.factor(sample(1:7, n, replace=TRUE)))
gd &lt;- generate_data(~ reg(~ x + f, prior=pr_normal(precision=1), name="beta"), data=dat)
dat$y &lt;- gd$y
sampler &lt;- create_sampler(y ~ reg(~ x + f, name="beta"), data=dat)
sim &lt;- MCMCsim(sampler)
(summary(sim$beta))
(summary(subset(sim$beta, chains=1)))
(summary(subset(sim$beta, chains=1, draws=sample(1:ndraws(sim), 100))))
(summary(subset(sim$beta, vars=1:2)))

</code></pre>

<hr>
<h2 id='summary.dc'>Summarize a draws component (dc) object</h2><span id='topic+summary.dc'></span>

<h3>Description</h3>

<p>Summarize a draws component (dc) object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dc'
summary(
  object,
  probs = c(0.05, 0.5, 0.95),
  na.rm = FALSE,
  time = NULL,
  abbr = FALSE,
  batch.size = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dc_+3A_object">object</code></td>
<td>
<p>an object of class <code>dc</code>.</p>
</td></tr>
<tr><td><code id="summary.dc_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities at which to evaluate quantiles.</p>
</td></tr>
<tr><td><code id="summary.dc_+3A_na.rm">na.rm</code></td>
<td>
<p>whether to remove NA/NaN draws in computing the summaries.</p>
</td></tr>
<tr><td><code id="summary.dc_+3A_time">time</code></td>
<td>
<p>MCMC computation time; if specified the effective sample size per unit of time
is returned in an extra column labeled 'efficiency'.</p>
</td></tr>
<tr><td><code id="summary.dc_+3A_abbr">abbr</code></td>
<td>
<p>if <code>TRUE</code> abbreviate the labels in the output.</p>
</td></tr>
<tr><td><code id="summary.dc_+3A_batch.size">batch.size</code></td>
<td>
<p>number of parameter columns to process simultaneously. A larger batch size may speed things up a little,
but if an out of memory error occurs it may be a good idea to use a smaller number and try again. The default is 100.</p>
</td></tr>
<tr><td><code id="summary.dc_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+n_eff">n_eff</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with summaries of class <code>dc_summary</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
summary(sim$u)


</code></pre>

<hr>
<h2 id='summary.mcdraws'>Summarize an mcdraws object</h2><span id='topic+summary.mcdraws'></span>

<h3>Description</h3>

<p>Summarize an mcdraws object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcdraws'
summary(
  object,
  vnames = NULL,
  probs = c(0.05, 0.5, 0.95),
  na.rm = FALSE,
  efficiency = FALSE,
  abbr = FALSE,
  batch.size = 100L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcdraws_+3A_object">object</code></td>
<td>
<p>an object of class <code>mcdraws</code>, typically generated by function <code><a href="#topic+MCMCsim">MCMCsim</a></code>.</p>
</td></tr>
<tr><td><code id="summary.mcdraws_+3A_vnames">vnames</code></td>
<td>
<p>optional character vector to select a subset of parameters.</p>
</td></tr>
<tr><td><code id="summary.mcdraws_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities at which to evaluate quantiles.</p>
</td></tr>
<tr><td><code id="summary.mcdraws_+3A_na.rm">na.rm</code></td>
<td>
<p>whether to remove NA/NaN draws in computing the summaries.</p>
</td></tr>
<tr><td><code id="summary.mcdraws_+3A_efficiency">efficiency</code></td>
<td>
<p>if <code>TRUE</code> the effective sample size per second of computation time is returned as well.</p>
</td></tr>
<tr><td><code id="summary.mcdraws_+3A_abbr">abbr</code></td>
<td>
<p>if <code>TRUE</code> abbreviate the labels in the output.</p>
</td></tr>
<tr><td><code id="summary.mcdraws_+3A_batch.size">batch.size</code></td>
<td>
<p>number of parameter columns to process simultaneously for vector parameters. A larger batch size
may speed things up a little, but if an out of memory error occurs it may be a good idea to use a smaller number
and try again. The default is 100.</p>
</td></tr>
<tr><td><code id="summary.mcdraws_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+n_eff">n_eff</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>mcdraws_summary</code> summarizing <code>object</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example()
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, store.all=TRUE)
summary(sim)
par_names(sim)
summary(sim, c("beta", "v_sigma", "u_sigma"))


</code></pre>

<hr>
<h2 id='tabMatrix-indexing'>S4 method for row and column subsetting a 'tabMatrix'</h2><span id='topic+tabMatrix-indexing'></span><span id='topic++5B+2CtabMatrix+2Cindex+2Cmissing+2Clogical-method'></span><span id='topic++5B+2CtabMatrix+2Cindex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CtabMatrix+2Cmissing+2Cindex+2Clogical-method'></span><span id='topic++5B+2CtabMatrix+2Cmissing+2Cindex+2Cmissing-method'></span>

<h3>Description</h3>

<p>S4 method for row and column subsetting a 'tabMatrix'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'tabMatrix,index,missing,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'tabMatrix,index,missing,missing'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'tabMatrix,missing,index,logical'
x[i, j, ..., drop = TRUE]

## S4 method for signature 'tabMatrix,missing,index,missing'
x[i, j, ..., drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabMatrix-indexing_+3A_x">x</code></td>
<td>
<p>a tabMatrix object.</p>
</td></tr>
<tr><td><code id="tabMatrix-indexing_+3A_i">i</code></td>
<td>
<p>integer vector indicating the rows to select. Not used for column subsetting.</p>
</td></tr>
<tr><td><code id="tabMatrix-indexing_+3A_j">j</code></td>
<td>
<p>integer vector indicating the columns to select. Not used for row subsetting.</p>
</td></tr>
<tr><td><code id="tabMatrix-indexing_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="tabMatrix-indexing_+3A_drop">drop</code></td>
<td>
<p>whether to return a vector in case of a single selected row or column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The selected rows/columns as a tabMatrix or a vector.
</p>

<hr>
<h2 id='TMVN-methods'>Functions for specifying the method and corresponding options for sampling
from a possibly truncated and degenerate multivariate normal distribution</h2><span id='topic+TMVN-methods'></span><span id='topic+m_direct'></span><span id='topic+m_Gibbs'></span><span id='topic+m_HMC'></span><span id='topic+m_HMCZigZag'></span><span id='topic+m_softTMVN'></span>

<h3>Description</h3>

<p>These functions are intended for use in the <code>method</code> argument of <code><a href="#topic+create_TMVN_sampler">create_TMVN_sampler</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_direct()

m_Gibbs(slice = FALSE, diagnostic = FALSE, debug = FALSE)

m_HMC(
  Tsim = pi/2,
  max.events = .Machine$integer.max,
  diagnostic = FALSE,
  debug = FALSE
)

m_HMCZigZag(
  Tsim = 1,
  rate = 1,
  prec.eq = NULL,
  diagnostic = FALSE,
  max.events = .Machine$integer.max,
  adapt = FALSE,
  debug = FALSE
)

m_softTMVN(
  sharpness = 100,
  useV = FALSE,
  CG = NULL,
  PG.approx = TRUE,
  PG.approx.m = -2L,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TMVN-methods_+3A_slice">slice</code></td>
<td>
<p>if <code>TRUE</code>, a Gibbs within slice sampler is used.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_diagnostic">diagnostic</code></td>
<td>
<p>whether information about violations of inequalities, bounces
off inequality walls (for 'HMC' and 'HMCZigZag' methods) or gradient events
(for 'HMCZigZag') is printed to the screen.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_debug">debug</code></td>
<td>
<p>if <code>TRUE</code> a breakpoint is set at the beginning of the TMVN sampling
function. Mainly intended for developers.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_tsim">Tsim</code></td>
<td>
<p>the duration of a Hamiltonian Monte Carlo simulated particle trajectory.
This can be specified as either a single positive numeric value for a fixed
simulation time, or as a function that is applied in each MCMC iteration to
generates a simulation time.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_max.events">max.events</code></td>
<td>
<p>maximum number of events (reflections off inequality walls
and for method 'HMCZigZag' also gradient events). Default is unlimited.
Specifying a finite number may speed up the sampling but may also result
in a biased sampling algorithm.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_rate">rate</code></td>
<td>
<p>vector of Laplace rate parameters for method 'HMCZigZag'. It must be
a positive numeric vector of length one or the number of variables.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_prec.eq">prec.eq</code></td>
<td>
<p>positive numeric vector of length 1 or the number of equality restrictions,
to control the precision with which the equality restrictions are imposed; the larger
<code>prec.eq</code> the more precisely they will be imposed.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_adapt">adapt</code></td>
<td>
<p>experimental feature: if <code>TRUE</code> the rate parameter will be adapted
in an attempt to make the sampling algorithm more efficient.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_sharpness">sharpness</code></td>
<td>
<p>for method 'softTMVN', the sharpness of the soft inequalities; the larger the better
the approximation of exact inequalities. It must a positive numeric vector of length
one or the number of inequality restrictions.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_usev">useV</code></td>
<td>
<p>for method 'softTMVN' whether to base computations on variance instead of precision
matrices.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_cg">CG</code></td>
<td>
<p>use a conjugate gradient iterative algorithm instead of Cholesky updates for sampling
the model's coefficients. This must be a list with possible components <code>max.it</code>,
<code>stop.criterion</code>, <code>verbose</code>. See the help for function <code><a href="#topic+CG_control">CG_control</a></code>,
which can be used to specify these options. Currently the preconditioner and scale
options cannot be set for this use case.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_pg.approx">PG.approx</code></td>
<td>
<p>see <code><a href="#topic+sampler_control">sampler_control</a></code>.</p>
</td></tr>
<tr><td><code id="TMVN-methods_+3A_pg.approx.m">PG.approx.m</code></td>
<td>
<p>see <code><a href="#topic+sampler_control">sampler_control</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A method object, for internal use only.
</p>

<hr>
<h2 id='transform_dc'>Transform one or more draws component objects into a new one by applying a function</h2><span id='topic+transform_dc'></span>

<h3>Description</h3>

<p>Transform one or more draws component objects into a new one by applying a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_dc(..., fun, to.matrix = FALSE, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_dc_+3A_...">...</code></td>
<td>
<p>draws component object(s) of class <code>dc</code>.</p>
</td></tr>
<tr><td><code id="transform_dc_+3A_fun">fun</code></td>
<td>
<p>a function to apply. This function should take as many arguments as there are input objects.
The arguments can be arbitrarily named, but they are assumed to be in the same order as the input objects.
The function should return a vector.</p>
</td></tr>
<tr><td><code id="transform_dc_+3A_to.matrix">to.matrix</code></td>
<td>
<p>if <code>TRUE</code> the output is in matrix format; otherwise it is a draws component object.</p>
</td></tr>
<tr><td><code id="transform_dc_+3A_labels">labels</code></td>
<td>
<p>optional labels for the output object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a matrix or a draws component object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ex &lt;- mcmcsae_example(n=50)
sampler &lt;- create_sampler(ex$model, data=ex$dat)
sim &lt;- MCMCsim(sampler, burnin=100, n.iter=300, thin=2, n.chain=4, store.all=TRUE)
summary(sim$v_sigma)
summary(transform_dc(sim$v_sigma, fun=function(x) x^2))
summary(transform_dc(sim$u, sim$u_sigma, fun=function(x1, x2) abs(x1)/x2))


</code></pre>

<hr>
<h2 id='vfac'>Create a model component object for a variance factor component in the variance function of a
gaussian sampling distribution</h2><span id='topic+vfac'></span>

<h3>Description</h3>

<p>This function is intended to be used on the right hand side of the <code>formula.V</code> argument to
<code><a href="#topic+create_sampler">create_sampler</a></code> or <code><a href="#topic+generate_data">generate_data</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vfac(
  factor = "local_",
  prior = pr_invchisq(df = 1, scale = 1),
  name = "",
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vfac_+3A_factor">factor</code></td>
<td>
<p>The name of a factor variable. The name <code>"local_"</code> has a special meaning,
and assigns a different variance scale parameter to each data unit.
In case of inverse chi-squared priors this implies that the marginal sampling distribution
is a t distribution. In case of exponential priors the marginal sampling distribution
is a Laplace or double exponential distribution.</p>
</td></tr>
<tr><td><code id="vfac_+3A_prior">prior</code></td>
<td>
<p>the prior assigned to the variance factors. Currently the prior can be inverse chi-squared
or exponential, specified by a call to <code><a href="#topic+pr_invchisq">pr_invchisq</a></code> or <code><a href="#topic+pr_exp">pr_exp</a></code>, respectively.
The default priors are inverse chi-squared with 1 degree of freedom. See the help pages of the
prior specification functions for details on how to set non-default priors.</p>
</td></tr>
<tr><td><code id="vfac_+3A_name">name</code></td>
<td>
<p>The name of the variance model component. This name is used in the output of the MCMC simulation
function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. By default the name will be 'vfac' with the number of the variance model
term attached.</p>
</td></tr>
<tr><td><code id="vfac_+3A_debug">debug</code></td>
<td>
<p>If <code>TRUE</code> a breakpoint is set at the beginning of the posterior
draw function associated with this model component. Mainly intended for developers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with precomputed quantities and functions for sampling from
prior or conditional posterior distributions for this model component. Intended
for internal use by other package functions.
</p>

<hr>
<h2 id='vreg'>Create a model component object for a regression component in the variance function of a
gaussian sampling distribution</h2><span id='topic+vreg'></span>

<h3>Description</h3>

<p>This function is intended to be used on the right hand side of the <code>formula.V</code> argument to
<code><a href="#topic+create_sampler">create_sampler</a></code> or <code><a href="#topic+generate_data">generate_data</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vreg(
  formula = NULL,
  remove.redundant = FALSE,
  sparse = NULL,
  X = NULL,
  prior = NULL,
  Q0 = NULL,
  b0 = NULL,
  name = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vreg_+3A_formula">formula</code></td>
<td>
<p>a formula for the regression effects explaining the log-variance.
Variable names are looked up in the data frame passed as <code>data</code> argument to
<code><a href="#topic+create_sampler">create_sampler</a></code> or <code><a href="#topic+generate_data">generate_data</a></code>, or in <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="vreg_+3A_remove.redundant">remove.redundant</code></td>
<td>
<p>whether redundant columns should be removed from the design matrix.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vreg_+3A_sparse">sparse</code></td>
<td>
<p>whether the model matrix associated with <code>formula</code> should be sparse.
The default is determined by a simple heuristic based on storage size.</p>
</td></tr>
<tr><td><code id="vreg_+3A_x">X</code></td>
<td>
<p>a (possibly sparse) design matrix can be specified directly, as an alternative to the
creation of one based on <code>formula</code>. If <code>X</code> is specified <code>formula</code> is ignored.</p>
</td></tr>
<tr><td><code id="vreg_+3A_prior">prior</code></td>
<td>
<p>prior specification for the coefficients. Currently only
normal priors are supported, specified using function <code><a href="#topic+pr_normal">pr_normal</a></code>.</p>
</td></tr>
<tr><td><code id="vreg_+3A_q0">Q0</code></td>
<td>
<p>prior precision matrix for the regression effects. The default is a
zero matrix corresponding to a noninformative improper prior.
DEPRECATED, please use argument <code>prior</code> instead, i.e.
<code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td></tr>
<tr><td><code id="vreg_+3A_b0">b0</code></td>
<td>
<p>prior mean for the regression effect. Defaults to a zero vector.
DEPRECATED, please use argument <code>prior</code> instead, i.e.
<code>prior = pr_normal(mean = b0.value, precision = Q0.value)</code>.</p>
</td></tr>
<tr><td><code id="vreg_+3A_name">name</code></td>
<td>
<p>the name of the model component. This name is used in the output of the
MCMC simulation function <code><a href="#topic+MCMCsim">MCMCsim</a></code>. By default the name will be 'vreg'
with the number of the variance model term attached.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with precomputed quantities and functions for sampling from
prior or conditional posterior distributions for this model component. Intended
for internal use by other package functions.
</p>


<h3>References</h3>

<p>E. Cepeda and D. Gamerman (2000).
Bayesian modeling of variance heterogeneity in normal regression models.
Brazilian Journal of Probability and Statistics, 207-221.
</p>
<p>T.I. Lin and W.L. Wang (2011).
Bayesian inference in joint modelling of location and scale parameters
of the t distribution for longitudinal data.
Journal of Statistical Planning and Inference 141(4), 1543-1553.
</p>

<hr>
<h2 id='weights.mcdraws'>Extract weights from an mcdraws object</h2><span id='topic+weights.mcdraws'></span>

<h3>Description</h3>

<p>Extract weights from an mcdraws object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcdraws'
weights(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.mcdraws_+3A_object">object</code></td>
<td>
<p>an object of class <code>mcdraws</code>.</p>
</td></tr>
<tr><td><code id="weights.mcdraws_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with (simulation means of) weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# first create a population data frame
N &lt;- 1000  # population size
pop &lt;- data.frame(x=rnorm(N), area=factor(sample(1:10, N, replace=TRUE)))
pop$y &lt;- 1 + 2*pop$x + seq(-1, to=1, length.out=10)[pop$area] + 0.5*rnorm(N)
pop$sample &lt;- FALSE
pop$sample[sample(seq_len(N), 100)] &lt;- TRUE
# a simple linear regression model:
sampler &lt;- create_sampler(
  y ~ reg(~ x, name="beta"),
  linpred=list(beta=rowsum(model.matrix(~ x, pop), pop$area)), compute.weights=TRUE,
  data=pop[pop$sample, ]
)
sim &lt;- MCMCsim(sampler)
(summary(sim))
str(weights(sim))
crossprod_mv(weights(sim), pop$y[pop$sample])
summary(sim$linpred_)
# a multilevel model:
sampler &lt;- create_sampler(
  y ~ reg(~ x, name="beta") + gen(factor = ~ area, name="v"),
  linpred=list(beta=rowsum(model.matrix(~ x, pop), pop$area), v=diag(10)), compute.weights=TRUE,
  data=pop[pop$sample, ]
)
sim &lt;- MCMCsim(sampler)
(summary(sim))
str(weights(sim))
crossprod_mv(weights(sim), pop$y[pop$sample])
summary(sim$linpred_)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
