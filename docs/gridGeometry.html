<!DOCTYPE html><html lang="en"><head><title>Help for package gridGeometry</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gridGeometry}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grid.minkowski'>
<p>Generate Minkowski Sums of Grobs</p></a></li>
<li><a href='#grid.polyclip'>
<p>Perform Geometric Operations on Grobs</p></a></li>
<li><a href='#grid.polylineoffset'>
<p>Perform Line offset region on Grobs</p></a></li>
<li><a href='#grid.polyoffset'>
<p>Perform offset region on Grobs</p></a></li>
<li><a href='#grid.reduce'>
<p>Reduce Multiple Shapes to a Single Shape</p></a></li>
<li><a href='#grid.trim'>
<p>Subset a Line</p></a></li>
<li><a href='#polyclip'>
<p>Perform Geometric Operations on Coordinates</p></a></li>
<li><a href='#polylineoffset'>
<p>Perform Line offset region on Grobs</p></a></li>
<li><a href='#polyminkowski'>
<p>Generate Minkowski Sums on Coordinates</p></a></li>
<li><a href='#polyoffset'>
<p>Perform offset region on Grobs</p></a></li>
<li><a href='#trim'>
<p>Generate Subsets of Coordinates</p></a></li>
<li><a href='#xyListFromGrob'>
<p>Generate Coordinates from Grobs</p></a></li>
<li><a href='#xyListPath'>
<p>Generate Grobs from Coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Polygon Geometry in 'grid'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-0</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for performing polygon geometry with 'grid' grobs.
             This allows complex shapes to be defined by combining simpler
             shapes.  </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pmur002/gridgeometry">https://github.com/pmur002/gridgeometry</a>,
<a href="https://stattech.wordpress.fos.auckland.ac.nz/2019/03/04/2019-01-a-geometry-engine-interface-for-grid/">https://stattech.wordpress.fos.auckland.ac.nz/2019/03/04/2019-01-a-geometry-engine-interface-for-grid/</a>,
<a href="https://stattech.blogs.auckland.ac.nz/2022/06/01/2022-02-constructive-geometry-for-complex-grobs/">https://stattech.blogs.auckland.ac.nz/2022/06/01/2022-02-constructive-geometry-for-complex-grobs/</a>,
<a href="https://stattech.wordpress.fos.auckland.ac.nz/2022/12/14/2022-03-offsetting-lines-and-polygons-in-grid/">https://stattech.wordpress.fos.auckland.ac.nz/2022/12/14/2022-03-offsetting-lines-and-polygons-in-grid/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), grid</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, polyclip (&ge; 1.10-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graphics, lattice</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-22 03:26:24 UTC; pmur002</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Murrell [aut, cre],
  Jack Wong [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Murrell &lt;paul@stat.auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-22 10:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='grid.minkowski'>
Generate Minkowski Sums of Grobs
</h2><span id='topic+grid.minkowski'></span><span id='topic+minkowskiGrob'></span>

<h3>Description</h3>

<p>Given a polygonal <dfn>pattern</dfn> and a polygonal <dfn>path</dfn>,
generate the Minkowski Sum by adding the pattern to the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minkowskiGrob(A, B, 
              grobFn=xyListToPath,
              name=NULL, gp=gpar(), ...) 
grid.minkowski(A, B, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.minkowski_+3A_a">A</code></td>
<td>

<p>A grob, gList, or gTree, or a gPath or a character value
identifying a grob that has already been drawn.  This is known as the
<dfn>pattern</dfn> grob.
</p>
</td></tr>
<tr><td><code id="grid.minkowski_+3A_b">B</code></td>
<td>

<p>A grob, gList, or gTree, or a gPath or a character value
identifying a grob that has already been drawn.  This is known as the
<dfn>path</dfn> grob.
</p>
</td></tr>
<tr><td><code id="grid.minkowski_+3A_grobfn">grobFn</code></td>
<td>

<p>The function that is used to create the final grob result.
Predefined options are:  <code><a href="#topic+xyListToPath">xyListToPath</a></code>,
<code><a href="#topic+xyListToPolygon">xyListToPolygon</a></code>, and
<code><a href="#topic+xyListToLine">xyListToLine</a></code>.
</p>
</td></tr>
<tr><td><code id="grid.minkowski_+3A_name">name</code></td>
<td>

<p>A name for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.minkowski_+3A_gp">gp</code></td>
<td>

<p>Graphical parameter settings for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.minkowski_+3A_...">...</code></td>
<td>

<p>For <code>minkowskiGrob</code>, arguments passed on to
<code>polyclip::polyminkowski</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>A</code> and <code>B</code> should not contain self-intersections,
though they can be non-convex.
</p>


<h3>Value</h3>

<p><code>minkowskiGrob</code> returns a gTree.
</p>
<p><code>grid.minkowski</code> is only used for its side-effect of drawing
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Jack Wong
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyListToPath">xyListToPath</a></code>,
<code><a href="#topic+xyListToPolygon">xyListToPolygon</a></code>,
<code><a href="#topic+xyListToLine">xyListToLine</a></code>,
<code><a href="#topic+polyminkowski">polyminkowski</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pattern &lt;- circleGrob(x = 0, y = 0, r = .1)
path &lt;- rectGrob(width = 0.5, height = 0.5)
minkowski &lt;- minkowskiGrob(pattern, path)
grid.draw(minkowski)
</code></pre>

<hr>
<h2 id='grid.polyclip'>
Perform Geometric Operations on Grobs
</h2><span id='topic+grid.polyclip'></span><span id='topic+polyclipGrob'></span>

<h3>Description</h3>

<p>These functions allow two or more grobs to be combined
using one of the following operations: intersection, union,
minus, and xor.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyclipGrob(A, B, op="intersection",
             openFn=xyListToLine, closedFn=xyListToPath,
             name=NULL, gp=gpar(),  ...) 
grid.polyclip(A, B, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.polyclip_+3A_a">A</code></td>
<td>

<p>A grob, gList, or gTree, or a gPath or a character value
identifying a grob that has already been drawn.  This is known as the
<dfn>subject</dfn> grob.
</p>
</td></tr>
<tr><td><code id="grid.polyclip_+3A_b">B</code></td>
<td>

<p>A grob, gList, or gTree, or a gPath or a character value
identifying a grob that has already been drawn.  This is known as the
<dfn>clip</dfn> grob.
</p>
</td></tr>
<tr><td><code id="grid.polyclip_+3A_op">op</code></td>
<td>

<p>A character value describing the operation.  One of
<code>"intersection"</code>, <code>"minus"</code>, <code>"union"</code>, or
<code>"xor"</code>.
</p>
</td></tr>
<tr><td><code id="grid.polyclip_+3A_openfn">openFn</code></td>
<td>

<p>The function used to create grobs from the open shapes in the result.
</p>
</td></tr>
<tr><td><code id="grid.polyclip_+3A_closedfn">closedFn</code></td>
<td>

<p>The function used to create grobs from the closed shapes in the
result.
</p>
</td></tr>
<tr><td><code id="grid.polyclip_+3A_name">name</code></td>
<td>

<p>A name for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.polyclip_+3A_gp">gp</code></td>
<td>

<p>Graphical parameter settings for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.polyclip_+3A_...">...</code></td>
<td>

<p>For <code>polyclipGrob</code>, arguments passed on to <code>polyclip</code>.
For <code>grid.polyclip</code>, arguments used by methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subject grob is combined with the clip grob using the <code>op</code>
operation.
</p>
<p>The grobs are converted to coordinates by calling <code>grid::grobCoords</code>
and then the operation is performed by calling <code>polyclip</code>.
</p>
<p>The result is a new grob.  In the case of <code>grid.polyclip</code>,
this new grob will be drawn on the current device.  In the special
case that <code>A</code> is a gPath, by default, the new grob will
<em>replace</em> the old grob (the original grob identified by <code>A</code>)
in the current scene
(and the new grob will use the same <code>gp</code> settings as the
old grob).
</p>
<p>The subject grob can be any combination of open or closed shapes
(e.g., a combination of lines and polygons), but the clip grob
must only consist of closed shapes.
</p>


<h3>Value</h3>

<p><code>polyclipGrob</code> returns a gTree with two children, one
representing the open shapes within the result and one representing the
closed shapes within the result.
</p>
<p><code>grid.polyclip</code> is only used for its side-effect of drawing
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polyclip">polyclip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rectGrob(x=1/3, y=1/3, width=.4, height=.4)
c &lt;- circleGrob(x=2/3, y=2/3, r=.2)
grid.draw(r)
grid.draw(c)
grid.polyclip(r, c, gp=gpar(fill="grey"))
</code></pre>

<hr>
<h2 id='grid.polylineoffset'>
Perform Line offset region on Grobs
</h2><span id='topic+grid.polylineoffset'></span><span id='topic+polylineoffsetGrob'></span>

<h3>Description</h3>

<p>Given a polygonal lines or open grob, Generate the offset region (guard region, buffer region, morphological dilation) formed by shifting the boundary outwards by a specific distance.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polylineoffsetGrob(A, delta, rule = "winding",
             name=NULL, gp=gpar(),  ...) 
grid.polylineoffset(A, delta, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.polylineoffset_+3A_a">A</code></td>
<td>

<p>A grob, gList, or gTree, or a gPath or a character value
identifying a grob that has already been drawn.  This is known as the
<dfn>subject</dfn> grob.
</p>
</td></tr>
<tr><td><code id="grid.polylineoffset_+3A_delta">delta</code></td>
<td>

<p>Distance over which the boundary should be shifted.
</p>
</td></tr>
<tr><td><code id="grid.polylineoffset_+3A_rule">rule</code></td>
<td>

<p>A character value describing the fill rule to be used. One of <code>"winding"</code>, <code>"evenodd"</code>
</p>
</td></tr>
<tr><td><code id="grid.polylineoffset_+3A_name">name</code></td>
<td>

<p>A name for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.polylineoffset_+3A_gp">gp</code></td>
<td>

<p>Graphical parameter settings for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.polylineoffset_+3A_...">...</code></td>
<td>

<p>For <code>polylineoffsetGrob</code>, arguments passed on to <code>polyclip::polylineoffset</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The grobs are converted to coordinates by calling <code>grid::xyListFromGrob</code>.
</p>
<p>The result is a new grob.  In the case of <code>grid.polylineoffset</code>,
this new grob will be drawn on the current device.  In the special
case that <code>A</code> is a gPath, by default, the new grob will
<em>replace</em> the old grob (the original grob identified by <code>A</code>)
in the current scene
(and the new grob will use the same <code>gp</code> settings as the
old grob).
</p>
<p>The argument <code>jointype</code> determines what happens at the vertices of each line at <code>polyclip::polylineoffset</code>. See code link <code>polylineoffset</code>.
</p>
<p>The argument <code>endtype</code> determines what happens at the beginning and end of each line at <code>polyclip::polylineoffset</code>. See code link <code>polylineoffset</code>.
</p>
<p>The argument <code>rule</code> is a character value describing the fill rule to be used. One of <code>"winding"</code>, <code>"evenodd"</code>
</p>


<h3>Value</h3>

<p><code>polylineoffsetGrob</code> returns a gTree with offset grob coordinate.
</p>
<p><code>grid.polylineoffset</code> is only used for its side-effect of drawing
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Jack Wong
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polylineoffset">polylineoffset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grobLine = linesGrob(x = c(.4, .8, .8, .2, .6), y = c(.3, .3, .8, .8, .6), name = "Line 1")
grid.polylineoffset(grobLine, delta = unit(0.1, "cm"), jointype="square", endtype = "opensquare")
</code></pre>

<hr>
<h2 id='grid.polyoffset'>
Perform offset region on Grobs
</h2><span id='topic+grid.polyoffset'></span><span id='topic+polyoffsetGrob'></span>

<h3>Description</h3>

<p>Given a polygonal region or closed grob, generate the offset region (guard region, buffer region, morphological dilation) formed by shifting the boundary outwards by a specific distance.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyoffsetGrob(A, delta, reduce = "union", rule = "winding",
             name=NULL, gp=gpar(),  ...) 
grid.polyoffset(A, delta, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.polyoffset_+3A_a">A</code></td>
<td>

<p>A grob, gList, or gTree, or a gPath or a character value
identifying a grob that has already been drawn.  This is known as the
<dfn>subject</dfn> grob.
</p>
</td></tr>
<tr><td><code id="grid.polyoffset_+3A_delta">delta</code></td>
<td>

<p>Distance over which the boundary should be shifted.
</p>
</td></tr>
<tr><td><code id="grid.polyoffset_+3A_rule">rule</code></td>
<td>

<p>A character value describing the fill rule to be used. One of <code>"winding"</code>, <code>"evenodd"</code>
</p>
</td></tr>
<tr><td><code id="grid.polyoffset_+3A_reduce">reduce</code></td>
<td>

<p>A character value describing the operation to be used if 
<code>x</code> needs to be collapsed to a single shape.  One of
<code>"intersection"</code>, <code>"flatten"</code>, <code>"minus"</code>, <code>"union"</code>, or
<code>"xor"</code>.
</p>
</td></tr>
<tr><td><code id="grid.polyoffset_+3A_name">name</code></td>
<td>

<p>A name for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.polyoffset_+3A_gp">gp</code></td>
<td>

<p>Graphical parameter settings for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.polyoffset_+3A_...">...</code></td>
<td>

<p>For <code>polyoffsetGrob</code>, arguments passed on to <code>polyclip::polyoffset</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The grobs are converted to coordinates by calling <code>grid::xyListFromGrob</code>.
</p>
<p>The result is a new grob.  In the case of <code>grid.polyoffset</code>,
this new grob will be drawn on the current device.  In the special
case that <code>A</code> is a gPath, by default, the new grob will
<em>replace</em> the old grob (the original grob identified by <code>A</code>)
in the current scene
(and the new grob will use the same <code>gp</code> settings as the
old grob).
</p>
<p>Examples of useful arguments that will be passed on to polyclip::polyoffset() are <code>jointype</code>.
</p>
<p>The argument <code>jointype</code> determines what happens at the vertices of each line at <code>polyclip::polyoffset</code>. See code link <code>polyoffset</code>.
</p>
<p>The argument <code>rule</code> is a character value describing the fill rule to be used. One of <code>"winding"</code>, <code>"evenodd"</code>
</p>


<h3>Value</h3>

<p><code>polyoffsetGrob</code> returns a gTree with offset grob coordinate.
</p>
<p><code>grid.polyoffset</code> is only used for its side-effect of drawing
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Jack Wong
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polyoffset">polyoffset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grob &lt;- rectGrob(width = 0.5, height = 0.5)
offset &lt;- polyoffsetGrob(grob, 0.2)
grid.draw(offset)
</code></pre>

<hr>
<h2 id='grid.reduce'>
Reduce Multiple Shapes to a Single Shape
</h2><span id='topic+grid.reduce'></span><span id='topic+reduceGrob'></span>

<h3>Description</h3>

<p>This function takes a grob (or gTree) that draws multiple shapes
and reduces it to a grob that only draws one shape.
</p>
<p>More accurately, the result only draws at most one closed shape and
at most one open shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceGrob(x, op=if (isClosedShape(x)) "union" else "flatten",
           openFn=xyListToLine, closedFn=xyListToPath,
           name=NULL, gp=gpar()) 
grid.reduce(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.reduce_+3A_x">x</code></td>
<td>

<p>A grob, gList, or gTree, or a gPath or a character value
identifying a grob that has already been drawn.  
</p>
</td></tr>
<tr><td><code id="grid.reduce_+3A_op">op</code></td>
<td>

<p>A character value describing the operation.  One of
<code>"intersection"</code>, <code>"minus"</code>, <code>"union"</code>,
<code>"xor"</code>, or <code>"flatten"</code>.
</p>
</td></tr>
<tr><td><code id="grid.reduce_+3A_openfn">openFn</code></td>
<td>

<p>The function used to create grobs from the open shapes in the result.
</p>
</td></tr>
<tr><td><code id="grid.reduce_+3A_closedfn">closedFn</code></td>
<td>

<p>The function used to create grobs from the closed shapes in the
result.
</p>
</td></tr>
<tr><td><code id="grid.reduce_+3A_name">name</code></td>
<td>

<p>A name for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.reduce_+3A_gp">gp</code></td>
<td>

<p>Graphical parameter settings for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.reduce_+3A_...">...</code></td>
<td>

<p>For <code>reduceGrob</code>, arguments passed on to <code>polyclip</code>.
For <code>grid.reduce</code>, arguments used by methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple shapes are combined using <code>polyclip()</code> and the
specified operator <code>op</code>.
</p>


<h3>Value</h3>

<p><code>reduceGrob</code> returns a gTree with two children, one
representing the open shapes within the result and one representing the
closed shapes within the result.
</p>
<p><code>grid.reduce</code> is only used for its side-effect of drawing
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.polyclip">grid.polyclip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rectGrob(x=1/3, y=1/3, width=.4, height=.4)
c &lt;- circleGrob(x=2/3, y=2/3, r=.3)
grid.reduce(grobTree(r, c), gp=gpar(fill="grey"))
</code></pre>

<hr>
<h2 id='grid.trim'>
Subset a Line
</h2><span id='topic+grid.trim'></span><span id='topic+trimGrob'></span>

<h3>Description</h3>

<p>These functions generate one or more lines
by subsetting a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimGrob(x, from, to, rep=FALSE, name=NULL, gp=gpar(), ...) 
grid.trim(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grid.trim_+3A_x">x</code></td>
<td>

<p>A grob, or a gPath (or a character value)
identifying a grob that has already been drawn.  
</p>
</td></tr>
<tr><td><code id="grid.trim_+3A_from">from</code></td>
<td>

<p>A numeric vector or a unit object describing the start
point of each subset.
</p>
</td></tr>
<tr><td><code id="grid.trim_+3A_to">to</code></td>
<td>

<p>A numeric vector or a unit object describing the end
point of each subset.
</p>
</td></tr>
<tr><td><code id="grid.trim_+3A_rep">rep</code></td>
<td>

<p>A logical value indicating whether the <code>from</code> and
<code>to</code> values should be repeated to consume the
entire line.
</p>
</td></tr>
<tr><td><code id="grid.trim_+3A_name">name</code></td>
<td>

<p>A name for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.trim_+3A_gp">gp</code></td>
<td>

<p>Graphical parameter settings for the resulting grob.
</p>
</td></tr>
<tr><td><code id="grid.trim_+3A_...">...</code></td>
<td>

<p>For <code>trimGrob</code>, arguments passed on to <code>trim</code>.
For <code>grid.trim</code>, arguments used by methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>from</code> and <code>to</code> should be either numeric values
between 0 and 1, expressing a proportion of the line length,
or unit objects.  In the latter case, the unit
is converted to a proportion of the line length, with <code>"npc"</code>
units treated as proportions of the line length.
</p>
<p>Both <code>from</code> and <code>to</code> can be vectors (and they
are recycled) so that multiple subsets can be obtained in
a single call.
</p>
<p>Both <code>from</code> and <code>to</code>
can be negative, in which case the value is treated as distance
backwards along the line from its end.
</p>
<p>The result is a new grob.  In the case of <code>grid.trim</code>,
this new grob will be drawn on the current device.  In the special
case that <code>x</code> is a gPath, by default, the new grob will
<em>replace</em> the old grob (the original grob identified by <code>x</code>)
in the current scene
(and the new grob will use the same <code>gp</code> settings as the
old grob).
</p>


<h3>Value</h3>

<p><code>trimGrob</code> returns a polyline grob.
</p>
<p><code>grid.trim</code> is only used for its side-effect of drawing
on the current graphics device.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim">trim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- xsplineGrob(c(.2, .5, .8), c(.2, .8, .2))
grid.draw(g)
grid.trim(g, from=.1, to=.2, gp=gpar(lwd=5))
grid.trim(g, from=.1, to=.2, rep=TRUE, gp=gpar(lwd=3))
</code></pre>

<hr>
<h2 id='polyclip'>
Perform Geometric Operations on Coordinates
</h2><span id='topic+polyclip'></span><span id='topic+polyclip.grob'></span><span id='topic+polyclip.gList'></span><span id='topic+polyclip.gPath'></span><span id='topic+polyclip.character'></span>

<h3>Description</h3>

<p>This function combines two sets of coordinates
using one of the following operations: intersection, union,
minus, and xor.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyclip(A, B, ...)
## S3 method for class 'grob'
polyclip(A, B, op="intersection", closed=isClosedShape(A),
         reduceA = if (closed) "union" else "flatten",
         reduceB = "union",
         fillA = NULL, fillB = NULL,
         ...)
## S3 method for class 'gList'
polyclip(A, B, op="intersection", closed=isClosedShape(A),
         reduceA = if (closed) "union" else "flatten",
         reduceB = "union",
         fillA = NULL, fillB = NULL,
         ...)
## S3 method for class 'gPath'
polyclip(A, B, op="intersection", closed,
                         strict=FALSE, grep=FALSE, global=FALSE,
         reduceA = if (closed) "union" else "flatten",
         reduceB = "union",
         fillA = NULL, fillB = NULL,
         ...)
## S3 method for class 'character'
polyclip(A, B, op="intersection", closed,
                             strict=FALSE, grep=FALSE, global=FALSE,
         reduceA = if (closed) "union" else "flatten",
         reduceB = "union",
         fillA = NULL, fillB = NULL,
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyclip_+3A_a">A</code></td>
<td>

<p>A set of coordinates describing the
<dfn>subject</dfn> shape.
Or a grob, gList, or a gPath (or a character value)
identifying a grob that has already been drawn from which
coordinates are generated.  
</p>
</td></tr>
<tr><td><code id="polyclip_+3A_b">B</code></td>
<td>

<p>A set of coordinates describing the
<dfn>clip</dfn> shape.
Or a grob, gList, or a gPath (or a character value)
identifying a grob that has already been drawn from which
coordinates are generated.  
</p>
</td></tr>
<tr><td><code id="polyclip_+3A_op">op</code></td>
<td>

<p>A character value describing the operation.  One of
<code>"intersection"</code>, <code>"minus"</code>, <code>"union"</code>, or
<code>"xor"</code>.
</p>
</td></tr>
<tr><td><code id="polyclip_+3A_closed">closed</code></td>
<td>

<p>A logical value indicating whether the <code>A</code> coordinates describe
a closed shape or an open shape.
</p>
</td></tr>
<tr><td><code id="polyclip_+3A_reducea">reduceA</code>, <code id="polyclip_+3A_reduceb">reduceB</code></td>
<td>

<p>A character value describing the operation to be used if either
<code>A</code> or <code>B</code> need to be reduced to a single set of
coordinates.   One of
<code>"intersection"</code>, <code>"minus"</code>, <code>"union"</code>, or
<code>"xor"</code>, in which case <code>polyclip</code> is used to
reduce multiple shapes, or <code>"flatten"</code>, in which case
coordinates for all shapes are returned.  
</p>
</td></tr>
<tr><td><code id="polyclip_+3A_filla">fillA</code>, <code id="polyclip_+3A_fillb">fillB</code></td>
<td>

<p>A character value describing the fill rule.  Possible values are
<code>"winding"</code> or <code>"evenodd"</code> or <code>NULL</code>.
In the latter case (the default), the fill rule will be taken
from the coordinates if the coordinates  have a <code>"rule"</code>
attribute.  Otherwise, the default is <code>"winding"</code>.
</p>
</td></tr>
<tr><td><code id="polyclip_+3A_strict">strict</code>, <code id="polyclip_+3A_grep">grep</code>, <code id="polyclip_+3A_global">global</code></td>
<td>

<p>Arguments controlling the interpretation of the gPath
(passed to <code>grid.get</code>).
</p>
</td></tr>
<tr><td><code id="polyclip_+3A_...">...</code></td>
<td>

<p>Arguments used by methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subject coordinates are combined with the clip coordinates
using the <code>op</code> operation.
</p>


<h3>Value</h3>

<p>The result is a new set of coordinates.  
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polyclip">polyclip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rectGrob(x=1/3, y=1/3, width=.4, height=.4)
c &lt;- circleGrob(x=2/3, y=2/3, r=.2)
polyclip(r, c)
</code></pre>

<hr>
<h2 id='polylineoffset'>
Perform Line offset region on Grobs
</h2><span id='topic+polylineoffset'></span><span id='topic+polylineoffset.list'></span><span id='topic+polylineoffset.grob'></span><span id='topic+polylineoffset.gList'></span><span id='topic+polylineoffset.gPath'></span><span id='topic+polylineoffset.character'></span>

<h3>Description</h3>

<p>Given a list of polygonal lines or open grob object, generate the offset region (guard region, buffer region, morphological dilation) formed by shifting the boundary outwards by a specific distance.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polylineoffset(A, delta, ...)
## S3 method for class 'grob'
polylineoffset(A, delta, 
         ...)
## S3 method for class 'gList'
polylineoffset(A, delta,
         ...)
## S3 method for class 'gPath'
polylineoffset(A, delta,
                         ..., strict=FALSE, grep=FALSE, global=FALSE)
## S3 method for class 'character'
polylineoffset(A, delta,
                             ..., strict=FALSE, grep=FALSE, global=FALSE)
## S3 method for class 'list'
polylineoffset(A, delta,
                             ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polylineoffset_+3A_a">A</code></td>
<td>

<p>A set of coordinates describing the
<dfn>subject</dfn> shape.
Or a grob, gList, or a gPath (or a character value)
identifying a grob that has already been drawn from which
coordinates are generated.  
</p>
</td></tr>
<tr><td><code id="polylineoffset_+3A_delta">delta</code></td>
<td>

<p>Distance over which the boundary should be shifted.
</p>
</td></tr>
<tr><td><code id="polylineoffset_+3A_strict">strict</code>, <code id="polylineoffset_+3A_grep">grep</code>, <code id="polylineoffset_+3A_global">global</code></td>
<td>

<p>Arguments controlling the interpretation of the gPath
(passed to <code>grid.get</code>).
</p>
</td></tr>
<tr><td><code id="polylineoffset_+3A_...">...</code></td>
<td>

<p>For <code>polylineoffsetGrob</code>, arguments passed on to <code>polyclip::polylineoffset</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the offset region by using the subject coordinates shift by a delta distance.
</p>
<p>The argument <code>jointype</code> determines what happens at the vertices of each line.
</p>

<ul>
<li><p><code>jointype = "round"</code>: a circular arc is generated.
</p>
</li>
<li><p><code>jointype = "square"</code>: circular arc is replaced by a single straight line.
</p>
</li>
<li><p><code>jointype = "miter"</code>: circular arc is omitted entirely and replaced by a single straight line.
</p>
</li></ul>

<p>The argument <code>endtype</code> determines what happens at the beginning and end of each line.
</p>

<ul>
<li><p><code>endtype = "closedpolygon"</code>: ends are joined together (using the <code>jointype value</code>) and the path filled as a polygon.
</p>
</li>
<li><p><code>endtype = "closedline"</code>: nds are joined together (using the <code>jointype value</code>) and the path filled as a polyline.
</p>
</li>
<li><p><code>endtype = "openbutt"</code>: ends are squared off abruptly.
</p>
</li>
<li><p><code>endtype = "opensquare"</code>: ends are squared off at distance <code>delta</code>.
</p>
</li>
<li><p><code>endtype = "openround"</code>: ends are replaced by a semicircular arc.
</p>
</li></ul>



<h3>Value</h3>

<p>The result is a new set of coordinates for the outline of the offset region.  
</p>


<h3>Author(s)</h3>

<p>Jack Wong
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polylineoffset">polylineoffset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grobLine = linesGrob(x = c(.4, .8, .8, .2, .6), y = c(.3, .3, .8, .8, .6), name = "Line 1")
offset &lt;- polylineoffset(grobLine, delta = unit(0.1, "cm"), 
                        jointype="square", endtype = "opensquare")
</code></pre>

<hr>
<h2 id='polyminkowski'>
Generate Minkowski Sums on Coordinates
</h2><span id='topic+polyminkowski'></span><span id='topic+polyminkowski.grob'></span><span id='topic+polyminkowski.gList'></span><span id='topic+polyminkowski.gPath'></span><span id='topic+polyminkowski.character'></span>

<h3>Description</h3>

<p>This function generates the Minkowski Sum of two sets of coordinates.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyminkowski(A, B, ...)
## S3 method for class 'grob'
polyminkowski(A, B, closed=isClosedShape(B),
         reduceA = "union",
         reduceB = "union",
         ...)
## S3 method for class 'gList'
polyminkowski(A, B, closed=isClosedShape(B),
         reduceA = "union",
         reduceB = "union",
         ...)
## S3 method for class 'gPath'
polyminkowski(A, B, closed,
                         strict=FALSE, grep=FALSE, global=FALSE,
         reduceA = "union",
         reduceB = "union",
         ...)
## S3 method for class 'character'
polyminkowski(A, B, closed,
                             strict=FALSE, grep=FALSE, global=FALSE,
         reduceA = "union",
         reduceB = "union",
         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyminkowski_+3A_a">A</code></td>
<td>

<p>A set of coordinates describing a
<dfn>pattern</dfn> shape.
Or a grob, gList, or a gPath (or a character value)
identifying a grob that has already been drawn from which
coordinates are generated.  
</p>
</td></tr>
<tr><td><code id="polyminkowski_+3A_b">B</code></td>
<td>

<p>A set of coordinates describing a
<dfn>path</dfn> shape.
Or a grob, gList, or a gPath (or a character value)
identifying a grob that has already been drawn from which
coordinates are generated.  
</p>
</td></tr>
<tr><td><code id="polyminkowski_+3A_closed">closed</code></td>
<td>

<p>A logical value indicating whether the <code>B</code> coordinates describe
a closed shape or an open shape.
</p>
</td></tr>
<tr><td><code id="polyminkowski_+3A_reducea">reduceA</code>, <code id="polyminkowski_+3A_reduceb">reduceB</code></td>
<td>

<p>A character value describing the operation to be used if either
<code>A</code> or <code>B</code> need to be reduced to a single set of
coordinates.   One of
<code>"intersection"</code>, <code>"minus"</code>, <code>"union"</code>, or
<code>"xor"</code>, in which case <code>polyminkowski</code> is used to
reduce multiple shapes, or <code>"flatten"</code>, in which case
coordinates for all shapes are returned.  
</p>
</td></tr>
<tr><td><code id="polyminkowski_+3A_strict">strict</code>, <code id="polyminkowski_+3A_grep">grep</code>, <code id="polyminkowski_+3A_global">global</code></td>
<td>

<p>Arguments controlling the interpretation of the gPath
(passed to <code>grid.get</code>).
</p>
</td></tr>
<tr><td><code id="polyminkowski_+3A_...">...</code></td>
<td>

<p>Arguments used by methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shape described by the pattern coordinates is added
to the shape described by the path coordinates.
</p>


<h3>Value</h3>

<p>The result is a new set of coordinates.  
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.minkowski">grid.minkowski</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c &lt;- circleGrob(x=0, y=0, r=.1)
r &lt;- rectGrob(width=.5, height=.5)
polyminkowski(c, r)
</code></pre>

<hr>
<h2 id='polyoffset'>
Perform offset region on Grobs
</h2><span id='topic+polyoffset'></span><span id='topic+polyoffset.list'></span><span id='topic+polyoffset.grob'></span><span id='topic+polyoffset.gList'></span><span id='topic+polyoffset.gPath'></span><span id='topic+polyoffset.character'></span>

<h3>Description</h3>

<p>Given a polygonal region or closed grob, generate the offset region (guard region, buffer region, morphological dilation) formed by shifting the boundary outwards by a specific distance.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyoffset(A, delta, reduce = "union", ...)
## S3 method for class 'grob'
polyoffset(A, delta, reduce = "union",
         ...)
## S3 method for class 'gList'
polyoffset(A, delta, reduce = "union",
         ...)
## S3 method for class 'gPath'
polyoffset(A, delta, reduce = "union",
                         ..., strict=FALSE, grep=FALSE, global=FALSE)
## S3 method for class 'character'
polyoffset(A, delta, reduce = "union",
                             ..., strict=FALSE, grep=FALSE, global=FALSE)
## S3 method for class 'list'
polyoffset(A, delta, reduce = "union",
                             ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyoffset_+3A_a">A</code></td>
<td>

<p>A set of coordinates describing the
<dfn>subject</dfn> shape.
Or a grob, gList, or a gPath (or a character value)
identifying a grob that has already been drawn from which
coordinates are generated.  
</p>
</td></tr>
<tr><td><code id="polyoffset_+3A_delta">delta</code></td>
<td>

<p>Distance over which the boundary should be shifted.
</p>
</td></tr>
<tr><td><code id="polyoffset_+3A_reduce">reduce</code></td>
<td>

<p>A character value describing the operation to be used if 
<code>A</code> needs to be collapsed to a single shape.  One of
<code>"intersection"</code>, <code>"flatten"</code>, <code>"minus"</code>, <code>"union"</code>, or
<code>"xor"</code>.
</p>
</td></tr>
<tr><td><code id="polyoffset_+3A_strict">strict</code>, <code id="polyoffset_+3A_grep">grep</code>, <code id="polyoffset_+3A_global">global</code></td>
<td>

<p>Arguments controlling the interpretation of the gPath
(passed to <code>grid.get</code>).
</p>
</td></tr>
<tr><td><code id="polyoffset_+3A_...">...</code></td>
<td>

<p>For <code>polyoffsetGrob</code>, arguments passed on to <code>polyclip::polyoffset</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the offset region by using the subject coordinates shift by a delta distance.
</p>
<p>Examples of useful arguments that will be passed on to polyclip::polyoffset() are <code>jointype</code>.
</p>
<p>The argument <code>jointype</code> determines what happens at the vertices of each line.
</p>

<ul>
<li><p><code>jointype = "round"</code>: a circular arc is generated.
</p>
</li>
<li><p><code>jointype = "square"</code>: circular arc is replaced by a single straight line.
</p>
</li>
<li><p><code>jointype = "miter"</code>: circular arc is omitted entirely and replaced by a single straight line.
</p>
</li></ul>



<h3>Value</h3>

<p>The result is a new set of coordinates for the outline of the offset region.  
</p>


<h3>Author(s)</h3>

<p>Jack Wong
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polyoffset">polyoffset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grob &lt;- rectGrob(width = 0.5, height = 0.5)
offset &lt;- polyoffset(grob, 0.2)
</code></pre>

<hr>
<h2 id='trim'>
Generate Subsets of Coordinates
</h2><span id='topic+trim'></span><span id='topic+trim.grob'></span><span id='topic+trim.gPath'></span><span id='topic+trim.character'></span>

<h3>Description</h3>

<p>This functions generates a new set of coordinates 
by subsetting a set of coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(x, from, to, ...)
## S3 method for class 'grob'
trim(x, from, to, rep=FALSE, ...)
## S3 method for class 'gPath'
trim(x, from, to, rep=FALSE,
                     strict=FALSE, grep=FALSE, global=FALSE, ...)
## S3 method for class 'character'
trim(x, from, to, rep=FALSE,
                         strict=FALSE, grep=FALSE, global=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_+3A_x">x</code></td>
<td>

<p>A set of coordinates.  Or a grob, or a gPath (or a character value)
identifying a grob that has already been drawn from which
coordinates are generated.  
</p>
</td></tr>
<tr><td><code id="trim_+3A_from">from</code></td>
<td>

<p>A numeric vector or a unit object describing the start
point of each subset.
</p>
</td></tr>
<tr><td><code id="trim_+3A_to">to</code></td>
<td>

<p>A numeric vector or a unit object describing the end
point of each subset.
</p>
</td></tr>
<tr><td><code id="trim_+3A_rep">rep</code></td>
<td>

<p>A logical value indicating whether the <code>from</code> and
<code>to</code> values should be repeated to consume the
entire line.
</p>
</td></tr>
<tr><td><code id="trim_+3A_strict">strict</code>, <code id="trim_+3A_grep">grep</code>, <code id="trim_+3A_global">global</code></td>
<td>

<p>Arguments controlling the interpretation of the gPath
(passed to <code>grid.get</code>).
</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>

<p>Arguments used by methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new set of coordinates.
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trim">trim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- segmentsGrob(0, .5, 1, .5)
trim(g, from=.1, to=.2)
trim(g, from=.1, to=.2, rep=TRUE)
</code></pre>

<hr>
<h2 id='xyListFromGrob'>
Generate Coordinates from Grobs
</h2><span id='topic+xyListFromGrob'></span>

<h3>Description</h3>

<p>This function generates a set of coordinates 
(a list of (x,y) lists) from a grob.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyListFromGrob(x, op = if (closed) "union" else "flatten",
               closed = isClosedShape(x), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xyListFromGrob_+3A_x">x</code></td>
<td>

<p>A grob.
</p>
</td></tr>
<tr><td><code id="xyListFromGrob_+3A_op">op</code></td>
<td>

<p>A character value describing the operation to be used if 
<code>x</code> needs to be collapsed to a single shape.  One of
<code>"intersection"</code>, <code>"minus"</code>, <code>"union"</code>, or
<code>"xor"</code>.
</p>
<p>Can also be <code>"flatten"</code>, which just
returns an (x, y) list for each shape the grob draws.
This is usually the best choice when <code>closed = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="xyListFromGrob_+3A_closed">closed</code></td>
<td>

<p>A logical value indicating whether we coordinates describing
a closed shape or an open shape from.
</p>
</td></tr>
<tr><td><code id="xyListFromGrob_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code>polyclip</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result is a list of lists, each with components <code>x</code> and <code>y</code>.  
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polyclip">polyclip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rectGrob(x=1/3, y=1/3, width=.4, height=.4)
xyListFromGrob(r)
</code></pre>

<hr>
<h2 id='xyListPath'>
Generate Grobs from Coordinates
</h2><span id='topic+xyListPath'></span><span id='topic+xyListPolygon'></span><span id='topic+xyListLine'></span><span id='topic+xyListToPath'></span><span id='topic+xyListToPolygon'></span><span id='topic+xyListToLine'></span>

<h3>Description</h3>

<p>This function generates a grob from a set of coordinates
(a list of (x,y) lists).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyListToPath(x, rule=, name=NULL, gp=gpar())
xyListToPolygon(x, name=NULL, gp=gpar())
xyListToLine(x, name=NULL, gp=gpar()) 

xyListPath(x, rule, name=NULL, gp=gpar())
xyListPolygon(x, name=NULL, gp=gpar())
xyListLine(x, name=NULL, gp=gpar()) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xyListPath_+3A_x">x</code></td>
<td>

<p>A set of coordinates (e.g., from <code>polyclip</code> or <code>trim</code>).
</p>
</td></tr>
<tr><td><code id="xyListPath_+3A_rule">rule</code></td>
<td>

<p>A fill rule: <code>"winding"</code> or <code>"evenodd"</code>.
</p>
</td></tr>
<tr><td><code id="xyListPath_+3A_name">name</code></td>
<td>

<p>A name for the resulting grob.
</p>
</td></tr>
<tr><td><code id="xyListPath_+3A_gp">gp</code></td>
<td>

<p>Graphical parameter settings for the resulting grob.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following the addition of the <code><a href="#topic+xyListFromGrob">xyListFromGrob</a></code> function,
the <code>*To*()</code> forms are preferred.
</p>


<h3>Value</h3>

<p>The result is a grob.  
</p>


<h3>Author(s)</h3>

<p>Paul Murrell
</p>


<h3>See Also</h3>

<p><code><a href="#topic+polyclip">polyclip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rectGrob(x=1/3, y=1/3, width=.4, height=.4)
c &lt;- circleGrob(x=2/3, y=2/3, r=.2)
coords &lt;- polyclip(r, c)
xyListPath(coords)
xyListLine(coords)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
