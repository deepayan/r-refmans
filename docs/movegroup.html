<!DOCTYPE html><html><head><title>Help for package movegroup</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {movegroup}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alignraster'><p>Combines region-specific group-level UD rasters into a single raster.</p></a></li>
<li><a href='#argosFiltered'><p>Data: Tracks of two great hammerhead sharks with position confidence intervals</p></a></li>
<li><a href='#movegroup'><p>Automates dynamic Brownian bridge movement model construction across individuals</p></a></li>
<li><a href='#movegroup-package'><p>movegroup: Visualizing and Quantifying Space Use Data for Groups of Animals</p></a></li>
<li><a href='#moveLocErrorCalc'><p>moveLocError calculator for ARGOS or state space models resulting in 95percent latlon confidence intervals</p></a></li>
<li><a href='#plotraster'><p>Plots a group-level utilization distribution</p></a></li>
<li><a href='#scaleraster'><p>Scales individual utilization distribution rasters and volume area estimates</p></a></li>
<li><a href='#TracksCleaned'><p>Data: Tracks of lemon sharks off Bimini, Bahamas</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Visualizing and Quantifying Space Use Data for Groups of Animals</td>
</tr>
<tr>
<td>Version:</td>
<td>2024.03.05</td>
</tr>
<tr>
<td>Description:</td>
<td>Offers an easy and automated way to scale up individual-level space use analysis to 
    that of groups. Contains a function from the 'move' package to calculate a dynamic Brownian 
    bridge movement model from movement data for individual animals, as well as functions to 
    visualize and quantify space use for individuals aggregated in groups. Originally written with 
    passive acoustic telemetry in mind, this package also provides functionality to account for
    unbalanced acoustic receiver array designs, and satellite tag data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.3.5), utils, beepr (&ge; 1.3), dplyr (&ge; 1.0.8),
ggmap (&ge; 3.0.0), knitr (&ge; 1.45), lubridate (&ge; 1.8.0), magick
(&ge; 2.8.2), methods, move (&ge; 4.1.6), purrr (&ge; 1.0.2), raster
(&ge; 3.5-15), rlang (&ge; 1.0.2), sf (&ge; 1.0-7), sp (&ge; 1.4-6),
stars (&ge; 0.5-5), starsExtra (&ge; 0.2.7), stringr (&ge; 1.4.0),
terra (&ge; 1.7-39), tidyr (&ge; 1.2.0), tidyselect (&ge; 1.2.0),
viridis (&ge; 0.6.4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 17:31:10 UTC; simon</td>
</tr>
<tr>
<td>Author:</td>
<td>Simon Dedman <a href="https://orcid.org/0000-0002-9108-972X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Maurits van Zinnicq Bergmann
    <a href="https://orcid.org/0000-0002-8414-5025"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simon Dedman &lt;simondedman@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-07 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alignraster'>Combines region-specific group-level UD rasters into a single raster.</h2><span id='topic+alignraster'></span>

<h3>Description</h3>

<p>Extends the spatial extent of each area-specific group-level raster to the spatial extent shared by all rasters.
This will only be required if you have multiple individuals (e.g. different sharks) divided amongst a few discrete areas
(e.g. around different islands) and the effort (e.g. receiver coverage) is different among islands.
Not required for multiple individuals all within the same region or sampling regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignraster(
  folderroots = c("/myfolder/H", "/myfolder/L", "/myfolder/M"),
  foldernames = c("H", "L", "M"),
  pattern = ".asc",
  scalefolder = "Scaled",
  scaledweightedname = "All_Rasters_Scaled_Weighted",
  savefolder = tempdir(),
  format = "ascii",
  datatype = "FLT4S",
  bylayer = TRUE,
  overwrite = TRUE,
  returnObj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignraster_+3A_folderroots">folderroots</code></td>
<td>
<p>Character vector of locations of folder roots output by movegroup. Function
expects CRS.Rds file and a subfolder with the scaled raster.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_foldernames">foldernames</code></td>
<td>
<p>Character vector names of folders corresponding to files in folderroots, i.e.
the names of the objects, arrays, regions, etc.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_pattern">pattern</code></td>
<td>
<p>For input rasters from scaleraster. Default &quot;.asc&quot;.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_scalefolder">scalefolder</code></td>
<td>
<p>For input rasters from scaleraster. Default &quot;Scaled&quot;.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_scaledweightedname">scaledweightedname</code></td>
<td>
<p>For input rasters from scaleraster. Default &quot;All_Rasters_Scaled&quot;.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_savefolder">savefolder</code></td>
<td>
<p>E.g. &quot;/myfolder/Aligned&quot;. Single character entry of folder to save outputs, no trailing slash.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_format">format</code></td>
<td>
<p>Character. Output file type for raster::writeRaster param format. Default ascii,
other options have generally not worked well in SD's experience.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_datatype">datatype</code></td>
<td>
<p>Character. Data type for writing values to disk for raster::writeRaster param
datatype. Default FLT4S.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_bylayer">bylayer</code></td>
<td>
<p>For raster::writeRaster param bylayer. Default TRUE.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_overwrite">overwrite</code></td>
<td>
<p>For raster::writeRaster param overwrite. Default TRUE.</p>
</td></tr>
<tr><td><code id="alignraster_+3A_returnobj">returnObj</code></td>
<td>
<p>Logical. Return the scaled object to the parent environment to be assigned as an
object? Default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When used in a movegroup pipeline, the order would be: movegroup.R, scaleraster.R,
alignraster.R if required, plotraster.R.
</p>


<h3>Value</h3>

<p>Region-specific group-level UD rasters that share the same spatial extent.
</p>


<h3>Author(s)</h3>

<p>Simon Dedman, <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a>
</p>
<p>Maurits van Zinnicq Bergmann, <a href="mailto:mauritsvzb@gmail.com">mauritsvzb@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data("TracksCleaned")
# loop movegroup and scaleraster through tide subsets
tide &lt;- c("H", "M", "L")
for (i in tide) {
dir.create(file.path(tempdir(), i))
  movegroup(
    data = TracksCleaned[TracksCleaned$T.Ph == i, ],
    ID = "Shark",
    Datetime = "Datetime",
    Lat = "Lat",
    Lon = "Lon",
    savedir = file.path(tempdir(), i, "/"))
  
  scaleraster(path = file.path(tempdir(), i),
              crsloc = file.path(tempdir(), i))
}

alignraster(folderroots = file.path(tempdir(), tide),
            foldernames = tide,
            savefolder = file.path(tempdir(), "Aligned"))


</code></pre>

<hr>
<h2 id='argosFiltered'>Data: Tracks of two great hammerhead sharks with position confidence intervals</h2><span id='topic+argosFiltered'></span>

<h3>Description</h3>

<p>Tracks of 2 great hammerhead sharks tagged in Jupiter, and The Keys, Florida, USA, in 2022 and
2023 respectively, by Saving The Blue (savingtheblue.org), filtered by argosfilter::sdafilter and
with state space model applied using aniMotum package, using scripts by Vital Heim, see
https://github.com/SimonDedman/SavingTheBlue/blob/main/R/06A_Filter_SPOT_data.R and
https://github.com/SimonDedman/SavingTheBlue/blob/main/R/06B_CTCRW_SPOT_data_usin_animotum.R .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(argosFiltered)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1492 rows and 8 variables:
</p>

<dl>
<dt>id</dt><dd><p>Character, shark ID.</p>
</dd>
<dt>date</dt><dd><p>POSIXct datetime, format YYYY-MM-DD HH:MM:SS.</p>
</dd>
<dt>lon</dt><dd><p>Decimal longitudes.</p>
</dd>
<dt>lon025</dt><dd><p>Decimal longitudes, lower 95% confidence interval bound.</p>
</dd>
<dt>lon975</dt><dd><p>Decimal longitudes, upper 95% confidence interval bound.</p>
</dd>
<dt>lat</dt><dd><p>Decimal latitudes.</p>
</dd>
<dt>lat025</dt><dd><p>Decimal latitudes, lower 95% confidence interval bound.</p>
</dd>
<dt>lat975</dt><dd><p>Decimal latitudes, upper 95% confidence interval bound.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Simon Dedman, <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a>
</p>
<p>Vital Heim, <a href="mailto:vital.heim@gmail.com">vital.heim@gmail.com</a>
</p>


<h3>Source</h3>

<p><a href="https://www.savingtheblue.org">https://www.savingtheblue.org</a>
</p>

<hr>
<h2 id='movegroup'>Automates dynamic Brownian bridge movement model construction across individuals</h2><span id='topic+movegroup'></span>

<h3>Description</h3>

<p>Automates dynamic Brownian bridge movement model calculation for utilization distribution (UD)
estimation for multiple individuals simultaneously, using functions in the 'move' package. The
authors are indebted to the move package authors Bart Kraunstauber, Marco Smolla, and Anne K
Scharf, and to Sarah Becker for seed code which inspired the development of the
movegroup::movegroup function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movegroup(
  data = NULL,
  ID = NULL,
  Datetime = NULL,
  Lat = NULL,
  Lon = NULL,
  dat.TZ = "US/Eastern",
  proj = sp::CRS("+proj=longlat +datum=WGS84"),
  sensor = "VR2W",
  moveLocError = 1,
  timeDiffLong = 2,
  timeDiffUnits = "hours",
  center = TRUE,
  centre = NULL,
  buffpct = 0.3,
  rasterExtent = NULL,
  rasterCRS = sp::CRS("+proj=utm +zone=17 +datum=WGS84"),
  rasterResolution = 50,
  movemargin = 11,
  dbbext = 3,
  dbbwindowsize = 23,
  writeRasterFormat = "ascii",
  writeRasterExtension = ".asc",
  writeRasterDatatype = "FLT4S",
  absVolumeAreaSaveName = "VolumeArea_AbsoluteScale.csv",
  savedir = tempdir(),
  alerts = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movegroup_+3A_data">data</code></td>
<td>
<p>Data frame object containing the data. Requires columns Lat Lon DateTime ID and
potentially a grouping column (not currently implemented, email to request). Column names
specified in later parameters.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_id">ID</code></td>
<td>
<p>Name of animal tag ID column in data. &quot;Character&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_datetime">Datetime</code></td>
<td>
<p>Column name in data that contains date/time stamps for each recorded detection.
Must be in POSIXct format. &quot;Character&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_lat">Lat</code></td>
<td>
<p>Name of latitude column in data. &quot;Character&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_lon">Lon</code></td>
<td>
<p>Name of longitude column in data. &quot;Character&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_dat.tz">dat.TZ</code></td>
<td>
<p>Timezone of data for as.POSIXct. Default &quot;US/Eastern&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_proj">proj</code></td>
<td>
<p>CRS for move function. Default sp::CRS(&quot;+proj=longlat +datum=WGS84&quot;).</p>
</td></tr>
<tr><td><code id="movegroup_+3A_sensor">sensor</code></td>
<td>
<p>Sensor for move function. Single character or vector with length of the number of
coordinates. Optional. Default &quot;VR2W&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_movelocerror">moveLocError</code></td>
<td>
<p>Location error (m) in the 'brownian.bridge.dyn' function in the 'move'
package. Numeric. Either single or a vector of length nrow data. If using passive acoustic data
this is the detection range of the receiver(s). Default 1. See MoveLocErrorCalc function for
satellite data with state space modelled locations with 95% confidence intervals for latlon i.e.
lat and lon025 and 975.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_timedifflong">timeDiffLong</code></td>
<td>
<p>Single numeric value. Threshold value in timeDiffUnits designating the length
of long breaks in re-locations. Used for bursting a movement track into segments, thereby
removing long breaks from the movement track. See ?move::bursted for details. Default 2 hours is
arbitrary, looping through 18, 24, and 36 hours for satellite data on great hammerhead sharks
revealed volume areas for core and general use gradually rise with timeDiffLong increases,
multiple small dots of presence get blobbed together, and therefore sometimes this covers land.
Ideally one would not discard any data, in which case one should choose a value higher than the
largest between-detections gap in their dataset (or just pick a very large number). This
parameter is useful when the model would otherwise get stuck trying to calculate a UD for an
individual with a very large home range that is inadequately captured by a receiver array.
Default 2.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_timediffunits">timeDiffUnits</code></td>
<td>
<p>Character. Unit for timeDiffLong. Default &quot;hours&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_center">center</code></td>
<td>
<p>US English alternate to centre. Do you want to center the move object within
extent? See spTransform. Default TRUE.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_centre">centre</code></td>
<td>
<p>British English alternate to center. Do you want to centre the move object within
extent? See spTransform. Default NULL.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_buffpct">buffpct</code></td>
<td>
<p>Buffer extent for raster creation, proportion of 1. Default 0.3, can try e.g. 3
for a large buffer to avoid clipping, at the cost of file size, but later cropping in
plotraster.R will remove extraneous blank space.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_rasterextent">rasterExtent</code></td>
<td>
<p>Extent of raster created around data. If NULL (default), calculated from
data, buffpct, rasterResolution. Else length 4 vector, c(xmn, xmx, ymn, ymx) decimal latlon
degrees. Don't go to 90 (degrees) north or south for ymax or ymin. Doesn't prevent constraint to
data limits (in plot anyway), but prevents raster clipping crash.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_rastercrs">rasterCRS</code></td>
<td>
<p>CRS for raster creation. Default sp::CRS(&quot;+proj=utm +zone=17 +datum=WGS84&quot;).</p>
</td></tr>
<tr><td><code id="movegroup_+3A_rasterresolution">rasterResolution</code></td>
<td>
<p>Single numeric value to set raster resolution - cell size (width and
height) in metres. 111000: 1 degree lat = 111km. Trade-off between small res = big file &amp; processing
time. Should be a function of the spatial resolution of your receivers or positioning tags.
Higher resolution will lead to more precision in the volume areas calculations. Try using
2*dbblocationerror, if dbblocationerror is a single value. Default 50 = 50m = 50m² = 0.00005 km²
(divide by 1000000). Try around the median of your moveLocError.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_movemargin">movemargin</code></td>
<td>
<p>Margin size for variance calc in move::brownian.motion.variance.dyn and
behavioural change point analysis in move::brownian.bridge.dyn. Must be an odd number. Default 11.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_dbbext">dbbext</code></td>
<td>
<p>Ext param in the 'brownian.bridge.dyn' function in the 'move' package. Extends
bounding box around track. Numeric single (all edges), double (x &amp; y), or 4 (xmin xmax ymin ymax)
. Default 3. Excessive buffering will get cropped automatically.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_dbbwindowsize">dbbwindowsize</code></td>
<td>
<p>The window.size param in the 'brownian.bridge.dyn' function
in the 'move' package. The size of the moving window along the track. Larger windows provide more
stable/accurate estimates of the brownian motion variance but are less well able to capture more
frequent changes in behaviour. Number must be odd. Code will not run if total detections of
individual &lt; window size (default 23), which must be &gt;= 2*movemargin (default 11).</p>
</td></tr>
<tr><td><code id="movegroup_+3A_writerasterformat">writeRasterFormat</code></td>
<td>
<p>Character. Output file type for raster::writeRaster param format.
Default &quot;ascii&quot;. TO DEPRECIATE.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_writerasterextension">writeRasterExtension</code></td>
<td>
<p>Character. Output file extension for raster::writeRaster param
extension. Default &quot;.asc&quot;. TO DEPRECIATE.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_writerasterdatatype">writeRasterDatatype</code></td>
<td>
<p>Character. Data type for writing values to disk for
raster::writeRaster param Datatype. Default &quot;FLT4S&quot;. TO DEPRECIATE.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_absvolumeareasavename">absVolumeAreaSaveName</code></td>
<td>
<p>File name plus extension where UD estimates are saved. Default
&quot;VolumeArea_AbsoluteScale.csv&quot;.</p>
</td></tr>
<tr><td><code id="movegroup_+3A_savedir">savedir</code></td>
<td>
<p>Save outputs to a temporary directory (default) else change
to desired directory e.g. &quot;/home/me/folder&quot;. Do not use getwd() for this.
Do NOT include terminal slash. Directory must exist. Default tempdir().</p>
</td></tr>
<tr><td><code id="movegroup_+3A_alerts">alerts</code></td>
<td>
<p>Audio warning for failures. Default TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Step 1. Filter individuals.
Remove those individuals for which there are insufficient data i.e. number of re-locations is
smaller than the window size parameter value (default = 31).
Step 2. Generate universal raster.
Based on all remaining data, a universal raster is generated where the calculated UDs are plotted
into.
</p>
<p>Step 3. Loop through individuals.
Individuals are looped through to construct individual-level movement models (on an absolute
scale).
</p>
<p>See www.GitHub.com/SimonDedman/movegroup for issues, feedback, and development
suggestions.
</p>
<p>install_git('https://gitlab.com/bartk/move.git') #Installs 'move' development version
</p>
<p>When used together, the order of functions would be: movegroup, scaleraster, alignraster if
required, plotraster.
</p>


<h4>Errors and their origins:</h4>


<ol>
<li><p> Error in .local(object, raster, location.error = location.error, ext = ext: Higher y grid not
large enough, consider extending the raster in that direction or enlarging the ext argument.
Increase buffpct, e.g. to 3.
</p>
</li>
<li><p> Error in .data[[dttm]]: Must subset the data pronoun with a string, not a &lt;POSIXct/POSIXt&gt;
object. Use &quot;ColName&quot; not dataframe$ColName syntax for Datetime, ID, Lat, Lon.
</p>
</li>
<li><p> Error in splice(dot_call(capture_dots, frame_env = frame_env, named = named,: object
'DateTime' not found. Use &quot;ColName&quot; not ColName syntax for Datetime, ID, Lat, Lon.
</p>
</li>
<li><p> Error in .local(object, raster, location.error = location.error, ext = ext: Higher x grid not
large enough, consider extending the raster in that direction or enlarging the ext argument. Try
&quot;buffpct = 1,&quot; , then larger e.g. 3, if still getting the error.
</p>
</li>
<li><p> cannot allocate vector of size (BIG) Gb: Increase rasterResolution value.
</p>
</li>
<li><p> In min/max: No non-missing arguments to min; returning Inf: likely not enough memory, increase
rasterResolution value.
</p>
</li>
<li><p> Error in tmp[[i]]: subscript out of bounds. dbbmmwindowsize may be too large relative to nrow
of that individual. Try lowering movemargin (default 11, has to be odd) and then lowering
dbbmmwindowsize (default 23, has to be &gt;=2*movemargin, has to be odd).
</p>
</li></ol>




<h3>Value</h3>

<p>Individual-level utilization distributions, saved as rasters, as well
as calculated volume area estimates for 50 and 95pct contours, saved in a
.csv file. Motion variance csvs per individual (&quot;MotionVariance.csv&quot;), see
move::brownian.motion.variance.dyn. No processed object is returned, i.e. bad: &quot;objectname &lt;-
movegroup()&quot;, good: &quot;movegroup()&quot;.
</p>


<h3>Author(s)</h3>

<p>Simon Dedman, <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a>
</p>
<p>Maurits van Zinnicq Bergmann, <a href="mailto:mauritsvzb@gmail.com">mauritsvzb@gmail.com</a>
</p>


<h3>References</h3>

<p>Kranstauber, B., Kays, R., LaPoint, S. D., Wikelski, M. and Safi, K. (2012), A
dynamic Brownian bridge movement model to estimate utilization distributions for heterogeneous
animal movement. Journal of Animal Ecology. doi: 10.1111/j.1365-2656.2012.01955.x
</p>
<p>Kranstauber, B., M. Smolla &amp; A. K. Scharf. 2019. Move: visualizing and analyzing animal track
data. R package version 4.2.4 (at 2023-08-15). https://CRAN.R-project.org/package=move.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load data
data("TracksCleaned")
# run function
movegroup(
 data = TracksCleaned,
 ID = "Shark",
 Datetime = "Datetime",
 Lat = "Lat",
 Lon = "Lon",
 savedir = tempdir())
 

</code></pre>

<hr>
<h2 id='movegroup-package'>movegroup: Visualizing and Quantifying Space Use Data for Groups of Animals</h2><span id='topic+movegroup-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Offers an easy and automated way to scale up individual-level space use analysis to that of groups. Contains a function from the 'move' package to calculate a dynamic Brownian bridge movement model from movement data for individual animals, as well as functions to visualize and quantify space use for individuals aggregated in groups. Originally written with passive acoustic telemetry in mind, this package also provides functionality to account for unbalanced acoustic receiver array designs, and satellite tag data.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Simon Dedman <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a> (<a href="https://orcid.org/0000-0002-9108-972X">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Maurits van Zinnicq Bergmann <a href="mailto:mauritsvzb@gmail.com">mauritsvzb@gmail.com</a> (<a href="https://orcid.org/0000-0002-8414-5025">ORCID</a>)
</p>
</li></ul>


<hr>
<h2 id='moveLocErrorCalc'>moveLocError calculator for ARGOS or state space models resulting in 95percent latlon confidence intervals</h2><span id='topic+moveLocErrorCalc'></span>

<h3>Description</h3>

<p>Builds a dataframe of original locations plus rowmeans of mean distance of location extremities
lon975, lat; lon025, lat; lon, lat975; lon, lat025 from the centre point lon, lat.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moveLocErrorCalc(
  x,
  loncol = "lon",
  latcol = "lat",
  latloncrs = 4326,
  projectedcrs = 32617,
  lon025 = "lon025",
  lon975 = "lon975",
  lat025 = "lat025",
  lat975 = "lat975"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moveLocErrorCalc_+3A_x">x</code></td>
<td>
<p>Data frame or tibble with lats and lons and their high and low confidence interval
counterparts.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_loncol">loncol</code></td>
<td>
<p>Name of longitude column in x, character. Default &quot;lon&quot;.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_latcol">latcol</code></td>
<td>
<p>Name of latitude column in x, character. Default &quot;lat&quot;.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_latloncrs">latloncrs</code></td>
<td>
<p>CRS of x, default 4326, numeric.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_projectedcrs">projectedcrs</code></td>
<td>
<p>CRS to project to, should match your region, default 32617, numeric. See
movegroup projectedCRS.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_lon025">lon025</code></td>
<td>
<p>Name of low 2.5% confidence interval longitude column in x, character. Default
&quot;lon025&quot;.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_lon975">lon975</code></td>
<td>
<p>Name of high 2.5% confidence interval longitude column in x, character. Default
&quot;lon975&quot;.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_lat025">lat025</code></td>
<td>
<p>Name of low 2.5% confidence interval latitude column in x, character. Default
&quot;lat025&quot;.</p>
</td></tr>
<tr><td><code id="moveLocErrorCalc_+3A_lat975">lat975</code></td>
<td>
<p>Name of high 2.5% confidence interval latitude column in x, character. Default
&quot;lat975&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use on your data object from movegroup::movegroup(data).
</p>


<h3>Value</h3>

<p>Dataframe of original locations plus rowmeans of mean distance of location extremities,
for use in movegroup::movegroup(moveLocError).
</p>


<h3>Author(s)</h3>

<p>Simon Dedman, <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(argosFiltered)
myMoveLocError &lt;- moveLocErrorCalc(argosFiltered)

</code></pre>

<hr>
<h2 id='plotraster'>Plots a group-level utilization distribution</h2><span id='topic+plotraster'></span>

<h3>Description</h3>

<p>Plots 50 and 95pct contours of a group-level utilization distribution raster on a spatial map
background. Contains functionality to also visualize geographic locations of individual listening
stations (e.g., acoustic receivers) as well as the entire surface UD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotraster(
  x = file.path("Scaled", "All_Rasters_Scaled_Weighted_UDScaled.asc"),
  crsloc = NULL,
  xlatlon = NULL,
  locationpoints = NULL,
  calcCOA = FALSE,
  pointsincontourssave = NULL,
  trim = TRUE,
  myLocation = NULL,
  googlemap = FALSE,
  gmapsAPI = NULL,
  expandfactor = 1.6,
  mapzoom = NULL,
  mapsource = "google",
  maptype = "satellite",
  contour1colour = "red",
  contour2colour = "orange",
  positionscolour = "white",
  positionsalpha = 0.33,
  positionssize = 0.1,
  COAcolour = "black",
  COAalpha = 1,
  COAshape = 4,
  COAsize = 1,
  plottitle = "Aggregated 95% and 50% UD contours",
  plotsubtitle = "Scaled contours",
  legendtitle = "Percent UD Contours",
  plotcaption = paste0("movegroup, ", lubridate::today()),
  axisxlabel = "Longitude",
  axisylabel = "Latitude",
  legendposition = c(0.105, 0.8),
  fontsize = 12,
  fontfamily = "Times New Roman",
  filesavename = paste0(lubridate::today(), "_dBBMM-contours.png"),
  savedir = tempdir(),
  receiverlats = NULL,
  receiverlons = NULL,
  receivernames = NULL,
  receiverrange = NULL,
  recpointscol = "black",
  recpointsfill = "white",
  recpointsalpha = 0.5,
  recpointssize = 1,
  recpointsshape = 21,
  recbufcol = "grey75",
  recbuffill = "grey",
  recbufalpha = 0.5,
  reclabcol = "black",
  reclabfill = NA,
  reclabnudgex = 0,
  reclabnudgey = -200,
  reclabpad = 0,
  reclabrad = 0.15,
  reclabbord = 0,
  surface = TRUE,
  cropsavedimage = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotraster_+3A_x">x</code></td>
<td>
<p>Path to scaled raster generated by movegroup (/scaleraster/alignraster). Likely
file.path(movegroupsavedir, &quot;Scaled&quot;, &quot;All_Rasters_Scaled_Weighted_UDScaled.asc&quot;).</p>
</td></tr>
<tr><td><code id="plotraster_+3A_crsloc">crsloc</code></td>
<td>
<p>Location of saved CRS Rds file from movegroup.R. Likely the same as path. Likely
movegroup's savedir.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_xlatlon">xlatlon</code></td>
<td>
<p>If you want to also return a csv of your original locations labelled with which UD
contours they fall within, include the location of the LatLon raster here. Try
file.path(crsloc, &quot;Scaled&quot;, &quot;All_Rasters_Scaled_Weighted_LatLon.asc&quot;) . Default NULL will not produce
the csv output.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_locationpoints">locationpoints</code></td>
<td>
<p>If you want to also return a csv of your original locations labelled with which UD
contours they fall within, include the original input location points of animals, for xlatlon.
This should be a data frame which MUST have columns labelled &quot;lat&quot; and &quot;lon&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_calccoa">calcCOA</code></td>
<td>
<p>Calculate the centre of activity i.e. mean lat &amp; lon point. Requires
locationpoints. Default FALSE.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_pointsincontourssave">pointsincontourssave</code></td>
<td>
<p>Location and name to save the 'location in contours' csv related to
xlatlon and locationpoints, including the &quot;.csv&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_trim">trim</code></td>
<td>
<p>Remove NA &amp; 0 UD values and crop the plot to remaining date extents? Shrinks lots of
dead space at the edges of the raster. Default TRUE.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_mylocation">myLocation</code></td>
<td>
<p>Location for extents, format c(xmin, ymin, xmax, ymax). Default NULL, extents
auto-created from data. Set this if you want to expand or crop your map to cover a specific area.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_googlemap">googlemap</code></td>
<td>
<p>If pulling basemap from Google maps, this sets expansion factors since Google
Maps tiling zoom setup doesn't align to myLocation extents. Default FALSE.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_gmapsapi">gmapsAPI</code></td>
<td>
<p>Enter your google maps API here, quoted character string. Can leave NULL if
already registered with ggmap::register_google(). See Details for instructions. If you don't have
an API or don't want to get one, leave NULL, ensure mapsource is stamen, and maptype is
stamen-compatible.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_expandfactor">expandfactor</code></td>
<td>
<p>Extents expansion factor for basemap. 1.3 to 1.5 are the same zoom as 1. 1.6
is a big leap up in zoom out. 1.9 &amp; maybe 1.7 or 1.8 is another step out. Ignored if not using
Google Maps.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_mapzoom">mapzoom</code></td>
<td>
<p>Highest number = zoomed in. Google: 3 (continent) - 21 (building). stamen: 0-18.
Default NULL is calculated based on your data.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_mapsource">mapsource</code></td>
<td>
<p>Source for ggmap::get_map; google needs Google Maps API present. Options
“google”, “osm”, “stadia”.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_maptype">maptype</code></td>
<td>
<p>Type of map for ggmap::get_map param maptype. Options: Google mapsource: &quot;terrain&quot;,
&quot;terrain-background&quot;, &quot;satellite&quot;, &quot;roadmap&quot;, &quot;hybrid&quot;. Stadia mapsource: &quot;stamen_terrain&quot;,
&quot;stamen_toner&quot;, &quot;stamen_toner_lite&quot;, &quot;stamen_watercolor&quot;, &quot;stamen_terrain_background&quot;,
&quot;stamen_toner_background&quot;, &quot;stamen_terrain_lines&quot;, &quot;stamen_terrain_labels&quot;, &quot;stamen_toner_lines&quot;,
&quot;stamen_toner_labels&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_contour1colour">contour1colour</code></td>
<td>
<p>Colour for contour 1, typically 95pct, default &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_contour2colour">contour2colour</code></td>
<td>
<p>Colour for contour 2, typically 50pct, default &quot;orange&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_positionscolour">positionscolour</code></td>
<td>
<p>Colour for original animal locations, if xlatlon not NULL. Default &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_positionsalpha">positionsalpha</code></td>
<td>
<p>Alpha value for positions, default 0.33, values from 0 (fully transparent)
to 1 (fully parent).</p>
</td></tr>
<tr><td><code id="plotraster_+3A_positionssize">positionssize</code></td>
<td>
<p>Point size for positions, default 0.1.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_coacolour">COAcolour</code></td>
<td>
<p>Colour for Centre of Activity marker, if plotted. Default &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_coaalpha">COAalpha</code></td>
<td>
<p>Alpha value for Centre of Activity point, default 1, values from 0 (fully transparent)
to 1 (fully parent).</p>
</td></tr>
<tr><td><code id="plotraster_+3A_coashape">COAshape</code></td>
<td>
<p>Shape of Centre of Activity marker, default 4, an X. Permissible values 0 to 25.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_coasize">COAsize</code></td>
<td>
<p>Size of COA point, default 1.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_plottitle">plottitle</code></td>
<td>
<p>Title of the resultant plot, default &quot;Aggregated 95pct and 50pct UD contours&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_plotsubtitle">plotsubtitle</code></td>
<td>
<p>Plot subtitle, default &quot;Scaled contours&quot;. Can add the n of your individuals.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_legendtitle">legendtitle</code></td>
<td>
<p>Legend title, default &quot;Percent UD Contours&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_plotcaption">plotcaption</code></td>
<td>
<p>Plot caption, default &quot;movegroup&quot; + today's date.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_axisxlabel">axisxlabel</code></td>
<td>
<p>Default &quot;Longitude&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_axisylabel">axisylabel</code></td>
<td>
<p>Default &quot;Latitude&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_legendposition">legendposition</code></td>
<td>
<p>Vector of 2, format c(1,2), Proportional distance of (middle?) of legend
box from L to R, percent distance from Bottom to Top. Values 0 to 1. Default c(0.11, 0.85).</p>
</td></tr>
<tr><td><code id="plotraster_+3A_fontsize">fontsize</code></td>
<td>
<p>Font size, default 12.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_fontfamily">fontfamily</code></td>
<td>
<p>= Font family, default &quot;Times New Roman&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_filesavename">filesavename</code></td>
<td>
<p>File savename, default today's date + &quot;_dBBMM-contours.png&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_savedir">savedir</code></td>
<td>
<p>Save outputs to a temporary directory (default) else change to current directory
e.g. &quot;/home/me/folder&quot;. Do not use getwd() here. No terminal slash. E.g.
file.path(movegroupsavedir, &quot;Plot&quot;) . Auto-created if it doesn't exist.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_receiverlats">receiverlats</code></td>
<td>
<p>Vector of latitudes for receivers to be plotted.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_receiverlons">receiverlons</code></td>
<td>
<p>Vector of longitudes for receivers to be plotted. Same length as receiverlats.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_receivernames">receivernames</code></td>
<td>
<p>Vector of names for receivers to be plotted. Same length as receiverlats.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_receiverrange">receiverrange</code></td>
<td>
<p>Single (will be recycled), or vector (same length as receiverlats) of
detection ranges in metres for receivers to be plotted. If you have a max and a (e.g.) 90 percent
detection range, probably use max.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recpointscol">recpointscol</code></td>
<td>
<p>Colour of receiver centrepoint outlines. Default &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recpointsfill">recpointsfill</code></td>
<td>
<p>Colour of receiver centrepoint fills. Default &quot;white&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recpointsalpha">recpointsalpha</code></td>
<td>
<p>Alpha value of receiver centrepoint fills, 0 (invisible) to 1 (fully
visible). Default 0.5.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recpointssize">recpointssize</code></td>
<td>
<p>Size of receiver points. Default 1.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recpointsshape">recpointsshape</code></td>
<td>
<p>Shape of receiver points, default 21, circle with outline and fill.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recbufcol">recbufcol</code></td>
<td>
<p>Colour of the receiver buffer circle outlines. Default &quot;grey75&quot;</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recbuffill">recbuffill</code></td>
<td>
<p>Colour of the receiver buffer circle fills. Default &quot;grey&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_recbufalpha">recbufalpha</code></td>
<td>
<p>Alpha value of receiver buffer fills, 0 (invisible) to 1 (fully visible).
Default 0.5.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_reclabcol">reclabcol</code></td>
<td>
<p>Receiver label text colour. Default &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_reclabfill">reclabfill</code></td>
<td>
<p>Receiver label fill colour, NA for no fill. Default NA.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_reclabnudgex">reclabnudgex</code></td>
<td>
<p>Receiver label offset nudge in X dimension. Default 0.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_reclabnudgey">reclabnudgey</code></td>
<td>
<p>Receiver label offset nudge in Y dimension. Default -200.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_reclabpad">reclabpad</code></td>
<td>
<p>Receiver label padding in lines. Default 0.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_reclabrad">reclabrad</code></td>
<td>
<p>Receiver label radius in lines. Default 0.15.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_reclabbord">reclabbord</code></td>
<td>
<p>Receiver label border in mm. Default 0.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_surface">surface</code></td>
<td>
<p>Plot complete UD surface along with contours. Default TRUE.</p>
</td></tr>
<tr><td><code id="plotraster_+3A_cropsavedimage">cropsavedimage</code></td>
<td>
<p>Crop the output image with knitr::plot_crop which uses pdfcrop on PDFs,
otherwise magick::image_trim. magick requires system pre-install. deb: libmagick++-dev (Debian,
Ubuntu), rpm: ImageMagick-c++-devel (Fedora, CentOS, RHEL), csw: imagemagick_dev (Solaris), brew:
imagemagick@6 (MacOS). Default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For plottitle, you can use the term 'home range' when an animal can be detected wherever it goes
i.e. using GPS, satellite or acoustic telemetry whereby it is known that acoustic receivers cover
the entire home range of the study species. This term is problematic when applied to a passive
acoustic telemetry setting where an array of non-overlapping receivers are used to assess local
space use patterns i.e. the home range is bigger than the coverage by the acoustic array.
</p>
<p>Errors and their origins:
</p>

<ol>
<li><p> Error in gzfile(file, &quot;rb&quot;) : cannot open the connection. In addition: Warning message: In
gzfile(file, &quot;rb&quot;): cannot open compressed file '/var/folders/dl/etc/ggmap/index.rds',
probable reason 'No such file or directory'. Cause: index.rds may not have been created, due to a
problem with ggmap::get_map, likely due to your API key failing silently.
Filename too long - solve with filename = &quot;whatever&quot; but doesn't do anything. Added issue in
github: https://github.com/dkahle/ggmap/issues/346 .
API key help: https://github.com/dkahle/ggmap/issues/235 .
</p>
</li>
<li><p> trying to read file: All_Rasters_Scaled_Weighted_UDScaled.asc: Error in CPL_read_gdal(
as.character(x), as.character(options), as.character(driver),: file not found. Check x is correct.
</p>
</li>
<li><p> Error in grid.Call.graphics...: Empty raster: mapzoom likely set too low, returning no tiles.
Increase mapzoom number.
</p>
</li>
<li><p> Not Found (HTTP 404). Failed to acquire tile /...png: Tiles are unavailable for ocean, and may
be unavailable at the chosen zoom level for the specific region of interest. Inspect the output
map and try a lower level (number) of mapzoom.
</p>
</li></ol>



<h4>How to get Google map basemaps</h4>

<p>(from https://www.youtube.com/watch?v=O5cUoVpVUjU):
</p>

<ol>
<li><p> Sign up with dev console: a. You must enter credit card details, but won’t be charged if your
daily API requests stay under the limit. b. Follow the link:
https://console.cloud.google.com/projectselector2/apis/dashboard?supportedpurview=project c.
Sign up for Google cloud account (it may auto populate your current gmail), click agree and
continue. d. Click the navigation email in the top left corner and click on Billing. e. Create a
billing account – they will NOT auto charge after trial ends. f. Enter information, click on
'start my free trial'. They may offer a free credit for trying out their service. More pricing
details: https://mapsplatform.google.com/pricing/ . g. Click “Select a Project” then
“New project” in the top right corner. h. Enter Project Name, leave Location as is, click
“Create”. i. You should now see your project name at the top, where the drop-down menu is.
</p>
</li>
<li><p> Enable Maps and Places API: a. Click 'Library' on the left. b. In the search field type “Maps”
. c. Scroll down, click “Maps Java Script API”. d. Click Enable. e. Click 'Library' again, search
“Places”, click on “Places API”. f. Click Enable.
</p>
</li>
<li><p> Create Credentials for API  Key: a. Return to 'APIs &amp; Services' page. b. Click on Credentials.
c. At the top click 'Create Credentials &gt; API Key'. d. API key should pop up with option to copy
it. e. You can restrict the key if you want by following steps 4 &amp; 5 here:
https://www.youtube.com/watch?v=O5cUoVpVUjU&amp;t=232s
</p>
</li></ol>




<h3>Value</h3>

<p>Individual-level utilization distributions, saved as rasters, as well as calculated
volume area estimates for 50 and 95pct contours, saved in a .csv file.
</p>


<h3>Author(s)</h3>

<p>Simon Dedman, <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a>
</p>
<p>Maurits van Zinnicq Bergmann, <a href="mailto:mauritsvzb@gmail.com">mauritsvzb@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Having run the movegroup and scaleraster function examples:
plotraster(
  x = file.path(tempdir(), "Scaled", "All_Rasters_Scaled_Weighted_UDScaled.asc"),
  mapzoom = 14,
  mapsource = "stamen",
  maptype = "terrain",
  savedir = file.path(tempdir(), "Plot"),
  xlatlon = file.path(tempdir(), "Scaled", "All_Rasters_Scaled_Weighted_LatLon.asc"),
  locationpoints = TracksCleaned |&gt; dplyr::rename(lat = "Lat", lon = "Lon"),
  pointsincontourssave = file.path(tempdir(), "Scaled", "pointsincontours.csv"))

</code></pre>

<hr>
<h2 id='scaleraster'>Scales individual utilization distribution rasters and volume area estimates</h2><span id='topic+scaleraster'></span>

<h3>Description</h3>

<p>Scales individual-level utilization distribution (UD) rasters from 0 to 1 to facilitate interpretation as relative
intensity of utilization (as opposed to absolute), making comparisons across individuals and interpretations at
the group level more straightforward. Subsequently, scaled individual-level rasters are aggregated to create a
single group-level UD raster. See www.GitHub.com/SimonDedman/movegroup for issues, feedback, and development
suggestions. There is an option to account for bias in acoustic receiver array spatial representation (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleraster(
  path = NULL,
  pathsubsets = NULL,
  pattern = ".asc",
  weighting = 1,
  format = "ascii",
  datatype = "FLT4S",
  bylayer = TRUE,
  overwrite = TRUE,
  scalefolder = "Scaled",
  scaledweightedname = "All_Rasters_Scaled_Weighted",
  crsloc = NULL,
  returnObj = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleraster_+3A_path">path</code></td>
<td>
<p>Path to directory where the individual-level UDs are saved. Likely the same as
savedir from movegroup. Default NULL.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_pathsubsets">pathsubsets</code></td>
<td>
<p>Path to parent directory that contains all UDs across spatial groups or
subsets, i.e. if you ran movegroup multiple times for different areas in a connected system, this
would be the parent folder within which all the movegroup savedir's are located. Default NULL.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_pattern">pattern</code></td>
<td>
<p>Extension pattern used to read in all UDs in directory and pathsubsets directory.
Default &quot;.asc&quot;.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_weighting">weighting</code></td>
<td>
<p>Addresses unbalanced receiver array design after receivers have first been
partitioned into regions, and group-level UDs estimated per region. Numeric. Weights
area-specific scaled group-level UD raster by value. This then means that estimated scaled
individual-level volume areas also become weighted. Default is 1 for no weighting.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_format">format</code></td>
<td>
<p>Character. Output file type for raster::writeRaster param format. Default &quot;ascii&quot;.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_datatype">datatype</code></td>
<td>
<p>Character. Data type for writing values to disk for raster::writeRaster param
Datatype. Default &quot;FLT4S&quot;.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_bylayer">bylayer</code></td>
<td>
<p>For raster::writeRaster param bylayer. Default TRUE.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_overwrite">overwrite</code></td>
<td>
<p>For raster::writeRaster param overwrite. Default TRUE.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_scalefolder">scalefolder</code></td>
<td>
<p>Folder to save outputs to. Default &quot;Scaled&quot;.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_scaledweightedname">scaledweightedname</code></td>
<td>
<p>Name of chunk for scaled and weighted output rasters. Default
&quot;All_Rasters_Scaled_Weighted&quot;.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_crsloc">crsloc</code></td>
<td>
<p>Location of saved CRS Rds file from movegroup.R. Should be same as path. Default
NULL.</p>
</td></tr>
<tr><td><code id="scaleraster_+3A_returnobj">returnObj</code></td>
<td>
<p>Logical. Return the scaled object to the parent environment? Default FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Step 1. Scale rasters.
Individual-level UD rasters are scaled from 0 to 1 by dividing each raster by the maximum probability density value
occurring within the raster set.
</p>
<p>Step 2. Aggregate into a group-level raster.
Scaled individual-level rasters are summed to create a single group-level UD raster.
</p>
<p>Step 3. Re-scale to 0 to 1.
The group-level raster is divided by its own maximum value.
</p>
<p>Step 4. Weight raster (optional).
The scaled group-level UD raster is divided by the specified weighting factor(s). Note that this is only useful if you
want to account for an unbalanced listening station (e.g., acoustic receivers) array and have split up the study site and receivers in regions, and have
run the movegroup() for each regional data set separately. See van Zinnicq Bergmann et al. 2022
(https://doi.org/10.1016/j.biocon.2022.109469) for example. If not applicable, choose a value of &quot;1&quot;.
</p>
<p>Step 5. Standardize raster.
Standardize the potentially weighted and scaled group-level UD raster so that its values sum to 1.
</p>
<p>Step 6. Export as latlon CRS.
Change crs to latlon for plotting and calculation purposes, save file, continue.
</p>
<p>Step 7. Estimate 50 and 95pct contour volume areas.
For each scaled individual-level UD raster, estimate 50 and 95pct contour volume areas, as well as their mean and standard
deviation. Additionally, the 50 and 95pct volume area is estimated for the group-level UD raster.
</p>
<p>Step 8. Export the projected-CRS group-level raster.
</p>
<p>Errors and their origins:
</p>

<ol>
<li><p> Error in (function (cond): error in evaluating the argument 'x' in selecting a method for
function 'res': subscript out of bounds. Probably path can't find any files of type=pattern:
check you used a terminal slash in savedir in movegroup, and that path has files of type=pattern.
</p>
</li>
<li><p> Error in if (substr(x = pathsubsets, start = nchar(pathsubsets), stop = nchar(pathsubsets))==:
argument is of length zero: pathsubsets is wrong. Try setting to same as path. NULL does this.
</p>
</li>
<li><p> Error in gzfile(file, &quot;rb&quot;): cannot open compressed file 'CRS.Rds', probable reason 'No such
file or directory': crsloc is wrong. Try setting to same as path. NULL does this.
</p>
</li>
<li><p> In min/max: No non-missing arguments to min; returning Inf: likely not enough memory, increase
rasterResolution value.
</p>
</li></ol>



<h3>Value</h3>

<p>Scaled and weighted individual-level and group-level utilization distributions saved as
rasters. Scaled 50 and 95pct contour volume area estimates (in km2) for individuals and the group
, saved in .csv format. Latlon raster.
</p>


<h3>Author(s)</h3>

<p>Simon Dedman, <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a>
</p>
<p>Maurits van Zinnicq Bergmann, <a href="mailto:mauritsvzb@gmail.com">mauritsvzb@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Having run the movegroup function example:
scaleraster(path = tempdir())

# Weighted by number of positions per ID, fewer locations = lower Weighting value = higher final 
# UD values after dividing by Weighting. This scales all IDs up to match the group max.
Weighting &lt;- TracksCleaned |&gt;
 dplyr::group_by(Shark) |&gt;
 dplyr::summarise(N = n()) |&gt; 
 dplyr::filter(N &gt; 23) |&gt; 
 dplyr::mutate(N = N / max(N, na.rm = TRUE)) |&gt; 
 dplyr::pull(N)
 
 scaleraster(path = tempdir(), weighting = Weighting)


</code></pre>

<hr>
<h2 id='TracksCleaned'>Data: Tracks of lemon sharks off Bimini, Bahamas</h2><span id='topic+TracksCleaned'></span>

<h3>Description</h3>

<p>Tracks of 17 lemon sharks (Negaprion brevirostris) tagged off Bimini, Bahamas, 2012:2014, by
Bimini Biological Field Station employees and volunteers, with accompanying tidal phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TracksCleaned)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1308 rows and 5 variables:
</p>

<dl>
<dt>Datetime</dt><dd><p>POSIXct datetime, format YYYY-MM-DD HH:MM:SS.</p>
</dd>
<dt>Shark</dt><dd><p>Individual shark ID code.</p>
</dd>
<dt>T.Ph</dt><dd><p>Tidal phase, H M L High Medium Low.</p>
</dd>
<dt>Lat</dt><dd><p>Decimal latitudes.</p>
</dd>
<dt>Lon</dt><dd><p>Decimal longitudes.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Simon Dedman, <a href="mailto:simondedman@gmail.com">simondedman@gmail.com</a>
</p>
<p>Maurits van Zinnicq Bergmann, <a href="mailto:mauritsvzb@gmail.com">mauritsvzb@gmail.com</a>
</p>


<h3>Source</h3>

<p><a href="https://www.biminisharklab.com">https://www.biminisharklab.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
