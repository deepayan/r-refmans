<!DOCTYPE html><html lang="en"><head><title>Help for package densitr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {densitr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#combine_data'><p>Combines density measurement from a dp object list into a single</p>
data frame</a></li>
<li><a href='#combine_footers'><p>Combines footer data from a dp object list into a single data</p>
frame</a></li>
<li><a href='#correct_failures'><p>Manually correct failures after automatic trim detection</p></a></li>
<li><a href='#dpdetect_e'><p>Detect measurement ending point automatically using changepoint</p>
segmentation</a></li>
<li><a href='#dpdetect_s'><p>Detect measurement starting point automatically using changepoint</p>
segmentation</a></li>
<li><a href='#dpdetrend'><p>Detrend (remove a trend) a density profile either using linear or</p>
GAM regression</a></li>
<li><a href='#dpload'><p>Load a single density profile measurement file (*.dpa) or a directory</p>
of *.dpa files.</a></li>
<li><a href='#dprings'><p>Automatically identify tree rings in a density profile</p></a></li>
<li><a href='#dptrim'><p>Automatically trim an individual density profile on both sides</p></a></li>
<li><a href='#dptrim_s'><p>Automatically trim an individual density profile on the starting side</p></a></li>
<li><a href='#dptriml'><p>Automatically trim a list of density profiles on both sides</p></a></li>
<li><a href='#dptriml_s'><p>Automatically trim a list of density profiles on the starting side</p></a></li>
<li><a href='#extract_dpa_name'><p>Extract a file name from a full path</p></a></li>
<li><a href='#get_RW'><p>Get ring widths from identified tree rings</p></a></li>
<li><a href='#manual_trim_detect'><p>Manually select a starting or ending location of a density profile</p></a></li>
<li><a href='#plot_all'><p>Plot a list of dp objects, one by one</p></a></li>
<li><a href='#plot_end_detection'><p>Display end detection on a list of dp objects</p></a></li>
<li><a href='#plot_failures'><p>Plot trimming failures one by one</p></a></li>
<li><a href='#plot_start_detection'><p>Display start detection on a list of dp objects</p></a></li>
<li><a href='#plot_trimming'><p>Display automatic trimming on a list of dp objects</p></a></li>
<li><a href='#read_dpa'><p>Read a single resistance-drilling density profile measurement file (*.dpa)</p></a></li>
<li><a href='#remove_trim_failures'><p>Remove automatic trim failures from a list of trimmed dp objects</p>
and return only non-failed trimmed objects</a></li>
<li><a href='#separate_trim_failures'><p>Remove automatic trim failures from a list of trimmed dp objects</p>
and return ONLY failures</a></li>
<li><a href='#trim_manually'><p>Manually trim a list of density profiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Analysing Density Profiles from Resistance Drilling of Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides various tools for analysing density profiles
    obtained by resistance drilling. It can load individual or
    multiple files and trim the starting and ending part of each
    density profile. Tools are also provided to trim profiles
    manually, to remove the trend from measurements using several
    methods, to plot the profiles and to detect tree rings
    automatically. Written with a focus on forestry use of resistance
    drilling in standing trees.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/krajnc/densitr">https://github.com/krajnc/densitr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/krajnc/densitr/issues">https://github.com/krajnc/densitr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, changepoint (&ge; 2.2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pbapply, mgcv, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-03-22 08:20:21 UTC; luka</td>
</tr>
<tr>
<td>Author:</td>
<td>Luka Krajnc <a href="https://orcid.org/0000-0002-3120-559X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Stasia Grinberg [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luka Krajnc &lt;luka.krajnc@gozdis.si&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-03-22 09:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='combine_data'>Combines density measurement from a dp object list into a single
data frame</h2><span id='topic+combine_data'></span>

<h3>Description</h3>

<p>Given a dp object list, this function will extract all density
measurement data from all dp objects in a given list and combine
them in a single data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_data(dp.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_data_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, either from loading several
files using dpload or combined manually. Note: the list should
include only dp objects!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, combining all density data from dp.list
</p>


<h3>See Also</h3>

<p>dpload, combine_footer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load all files in directory
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
combine_data(dp.list)
</code></pre>

<hr>
<h2 id='combine_footers'>Combines footer data from a dp object list into a single data
frame</h2><span id='topic+combine_footers'></span>

<h3>Description</h3>

<p>Given a dp object list, this function will extract all footers
(the additional measurement data) from all dp objects in a given
list and combine them in a single data frame. Will not work if
trying to combine footer from newer and older format of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_footers(dp.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_footers_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, either from loading several
files using dpload or combined manually. Note: the list should
include only dp objects!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, combining all footer data from dp.list
</p>


<h3>See Also</h3>

<p>dpload, combine_data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load all files in directory
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
combine_footers(dp.list)
</code></pre>

<hr>
<h2 id='correct_failures'>Manually correct failures after automatic trim detection</h2><span id='topic+correct_failures'></span>

<h3>Description</h3>

<p>This function will take a list of trimmed dp objects (a result of
dptriml or dptriml_s function) and interactively ask the user to
assign starting/ending points manually. Follow-up to automatic
trim functions or to be used manually, will display a plot with the
density profiles for each failure in trim detection sequentially.
The plot title will display whether you are selection start or end
positions. Use your mouse to select starting/ending point on the
plot, your selection will then be displayed on the plot. Will
return a complete list, both with the non-failed automatically
trimmed dp objects and those corrected manually. The automatic
trim functions should be called with the option
&quot;rreport = TRUE&quot;, which embeds a trimming report when
returning the list of trimmed dp objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_failures(dp.trimmed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correct_failures_+3A_dp.trimmed">dp.trimmed</code></td>
<td>
<p>A list of dp objects, trimmed, with the report
embedded (&quot;rreport = TRUE&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of trimmed profiles, including both automatic and
manual trimming.
</p>


<h3>See Also</h3>

<p>dptrim, dptriml, manual_trim_detect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load all dp files

dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the list
dp.trimmed &lt;- dptriml(dp.list, rreport = TRUE)
## manually correct the failures
dp.corrected &lt;- correct_failures(dp.trimmed)

</code></pre>

<hr>
<h2 id='dpdetect_e'>Detect measurement ending point automatically using changepoint
segmentation</h2><span id='topic+dpdetect_e'></span>

<h3>Description</h3>

<p>The opposite of the dpdetect_s, it will check the mean values
of the last four segments and compare them to the cutoff limit.
Will give a warning if end not detected, which is expected on
measurements where the needle did not exit the tree on the opposite
side of the tree. See <code>return.plot = TRUE</code> to display the
actual process. The function is called on a dp object and returns
either a row number of the measurement ending or a plot displaying
the segmentation and detection. The sensitivity can be adjusted
using the cutoff.sd parameter, which is an indicator on how many
standard deviations the segment mean value can be before cutting it
off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpdetect_e(
  dp,
  cutoff.sd = 1,
  return.plot = FALSE,
  minseglen = 250,
  span = 0.1,
  nroll = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpdetect_e_+3A_dp">dp</code></td>
<td>
<p>A dp object, see dpload.</p>
</td></tr>
<tr><td><code id="dpdetect_e_+3A_cutoff.sd">cutoff.sd</code></td>
<td>
<p>How many standard deviations for the cutoff limit?</p>
</td></tr>
<tr><td><code id="dpdetect_e_+3A_return.plot">return.plot</code></td>
<td>
<p>If true, will return a plot displaying segment
detection for the current dp file.</p>
</td></tr>
<tr><td><code id="dpdetect_e_+3A_minseglen">minseglen</code></td>
<td>
<p>Minimum segment length for segment detection,
default setting of 250 points is for data resolution of 1/100 mm,
test a few options with return.plot = TRUE to find the right value</p>
</td></tr>
<tr><td><code id="dpdetect_e_+3A_span">span</code></td>
<td>
<p>Span for loess regression, use to adjust sensitivity
of detection detection for the current dp file.</p>
</td></tr>
<tr><td><code id="dpdetect_e_+3A_nroll">nroll</code></td>
<td>
<p>Number of points for rolling mean, use to adjust
sensitivity of detection for the current dp file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a row number where the actual measurement ends or
a plot, displaying changepoint segmentation and set limits.
</p>


<h3>See Also</h3>

<p>dpdetect_s, dptrim, dptriml, dptrim_s, dptriml_s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a single file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## get ending point
start &lt;- dpdetect_e(dp)
## plot the end detection

dpdetect_e(dp, return.plot = TRUE)

</code></pre>

<hr>
<h2 id='dpdetect_s'>Detect measurement starting point automatically using changepoint
segmentation</h2><span id='topic+dpdetect_s'></span>

<h3>Description</h3>

<p>A typical resistance drilling measurement starts with an increase
in resistance values in between the measurement start and the
immersion of the needle in the wood. These values are not useful
when estimating density and should be removed before further
analysis. This function will detect the starting point
automatically using binary segmentation from the package
<code>changepoint</code>, which separates the measurement in segments
based on their mean and variance. Start is detected, when the
segment mean is outside of the cutoff limit, see <code>return.plot
= TRUE</code> to display the diagnostic plot. This function will only
check the mean values of the first four (4) segments and compare
them to the cutoff value. The function is called on a dp object
and returns either a row number of the starting point or a plot
displaying the segmentation and detection. The sensitivity can be
adjusted using the cutoff.sd parameter, which is an indicator on
how many standard deviations the segment mean value can be before
cutting it off. Will return a warning if start not detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpdetect_s(
  dp,
  cutoff.sd = 1,
  return.plot = FALSE,
  minseglen = 250,
  span = 0.1,
  nroll = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpdetect_s_+3A_dp">dp</code></td>
<td>
<p>A dp object, see dpload.</p>
</td></tr>
<tr><td><code id="dpdetect_s_+3A_cutoff.sd">cutoff.sd</code></td>
<td>
<p>How many standard deviations for the cutoff limit?</p>
</td></tr>
<tr><td><code id="dpdetect_s_+3A_return.plot">return.plot</code></td>
<td>
<p>If true, will return a plot displaying segment
detection for the current dp file.</p>
</td></tr>
<tr><td><code id="dpdetect_s_+3A_minseglen">minseglen</code></td>
<td>
<p>Minimum segment length for segment detection,
default setting of 250 points is for data resolution of 1/100 mm,
test a few options with return.plot = TRUE to find the right value</p>
</td></tr>
<tr><td><code id="dpdetect_s_+3A_span">span</code></td>
<td>
<p>Span for loess regression, use to adjust sensitivity
of detection detection for the current dp file.</p>
</td></tr>
<tr><td><code id="dpdetect_s_+3A_nroll">nroll</code></td>
<td>
<p>Number of points for rolling mean, use to adjust
sensitivity of detection for the current dp file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a row number where the actual measurement starts or
a plot, displaying changepoint segmentation and set limits.
</p>


<h3>See Also</h3>

<p>dpdetect_e, dptrim, dptriml, dptrim_s, dptriml_s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a single file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## get starting point
start &lt;- dpdetect_s(dp)
## plot the start detection

dpdetect_s(dp, return.plot = TRUE)

</code></pre>

<hr>
<h2 id='dpdetrend'>Detrend (remove a trend) a density profile either using linear or
GAM regression</h2><span id='topic+dpdetrend'></span>

<h3>Description</h3>

<p>This function will take a dp object and remove the trend from the
measurement either by fitting a linear regression or by fitting a
GAM regression using REML. The trend is then subtracted from the
actual data and a detrended dp object is returned. Be advised
detrending should be done on measurements without the starting or
ending point, e.g. they should be trimmed. GAM is more useful in
tree ring detection, while linear regression is more commonly used
for further analysis of the density data. GAM requires <code>mcgv</code>
package to run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpdetrend(dp, type = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpdetrend_+3A_dp">dp</code></td>
<td>
<p>A dp object, see dpload.</p>
</td></tr>
<tr><td><code id="dpdetrend_+3A_type">type</code></td>
<td>
<p>Either &quot;linear&quot; for a fitting linear regression or
&quot;gam&quot; for a GAM fit using REML.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dp object without the trend.
</p>


<h3>See Also</h3>

<p>dptrim, dptriml, dptrim_s, dptriml_s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a single file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## load several dp objects
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurement
dp.trimmed &lt;- dptrim(dp)
## detrend the measurement
dp.detrended &lt;- dpdetrend(dp, type = "linear")
## detrend a list without displaying progress
dp.list.detrended &lt;- lapply(dp.list, dpdetrend, type = "linear")
## detrend a list with displaying progress and run in parallel to
## speed things up - requires pbapply library, adjust the cl argument to
## desired number of cores

dp.list.detrended &lt;- pbapply::pblapply(dp.list, dpdetrend, type = "linear", cl = 1)

</code></pre>

<hr>
<h2 id='dpload'>Load a single density profile measurement file (*.dpa) or a directory
of *.dpa files.</h2><span id='topic+dpload'></span>

<h3>Description</h3>

<p>Loads either a single .dpa file or a list of .dpa files. If
dpa.file is specified, it will load a single file. If dp.directory
is specified, it will search for all dpa files in that directory
(recursively in all subfolders, can be turned off) and return a
list of dp files. It will use pbapply to display progress, if
loading a directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpload(dp.file = NULL, dp.directory = "", recursive = TRUE, name = "file")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dpload_+3A_dp.file">dp.file</code></td>
<td>
<p>A path to a single file, including file name.</p>
</td></tr>
<tr><td><code id="dpload_+3A_dp.directory">dp.directory</code></td>
<td>
<p>A directory with .dpa files.</p>
</td></tr>
<tr><td><code id="dpload_+3A_recursive">recursive</code></td>
<td>
<p>Also look for density profiles files in subfolders?</p>
</td></tr>
<tr><td><code id="dpload_+3A_name">name</code></td>
<td>
<p>Either <code>c("file", "folder")</code>, used for naming of
list items. If &quot;file&quot;, only file name without the complete path
will be used for naming (&quot;00050060&quot;). If &quot;folder&quot;, the complete
path along with file name will be used to name the dpa objects
(&quot;data/0005/00/00050060&quot;). *.dpa ending is removed from the name
in both cases.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: for now this function only supports loading density profiles
created by the Rinntech Resistograph® resistance drilling device
(*.dpa). It was tested to work on files produced by R650-RC drill.
</p>


<h3>Value</h3>

<p>A <code>dp</code> object or a list of <code>dp</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a single file
dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## load all files in directory
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
</code></pre>

<hr>
<h2 id='dprings'>Automatically identify tree rings in a density profile</h2><span id='topic+dprings'></span>

<h3>Description</h3>

<p>Called on a density profile it will return tree rings, which were
automatically detected in the density profile. For best results,
run on a trimmed and detrended density profile (use GAM for best
results, see <code>dpdetrend</code>). The function will then search for
local peaks and valleys within the profile. Normally works well in
softwood species, where density increases in late wood and
decreases in nearly wood. It will return a data frame containing
peaks and valleys, along with their horizontal position. A
diagnostic plot will be returned instead when return.plot = TRUE.
Green points are valleys, blue points are peaks and red points were
automatically excluded. The algorithm will search for peaks and
valleys, after which it will automatically exclude all repeated
points. Each peak should be followed by a valley and vice versa,
when peak-peak situation is found, it will always take the higher
peak and the opposite in valleys (keeps the lowest values). Adjust
sensitivity by either adjusting <code>pps</code>, which dictates how many
points on each side of the identified peak are the minimum.
Essentially this dictates the minimum width of detected rings, try
adjusting it and display the plot. Minimum peak value can also be
adjusted with the parameter threshold, which dictates how many
stand deviations from the mean amplitude of the profile is the
lowest minimum peak value. Before ring detection the profile can
also be denoised by setting <code>smooth = TRUE</code>, which applies a
loess regression to smooth the data using the span parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dprings(
  dp,
  pps = 200,
  threshold.sd = 0,
  return.plot = FALSE,
  smooth = FALSE,
  span = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dprings_+3A_dp">dp</code></td>
<td>
<p>An dp object, see <code>dpload</code></p>
</td></tr>
<tr><td><code id="dprings_+3A_pps">pps</code></td>
<td>
<p>Points per peak, the minimum width of a peak, half on
each side. A local peak is identified when half of those points
are lower on each side of the potential peak. The inverse is true
in valleys.</p>
</td></tr>
<tr><td><code id="dprings_+3A_threshold.sd">threshold.sd</code></td>
<td>
<p>Minimum peak value in standard deviations away
from the overall mean of the signal. By default no peaks are
allowed to be beneath the overall mean, can be adjusted to
negative to lower the minimum peak allowed.</p>
</td></tr>
<tr><td><code id="dprings_+3A_return.plot">return.plot</code></td>
<td>
<p>If TRUE, the function will return a diagnostic
plot. Green points are valleys, blue points are peaks and red
points were automatically excluded.</p>
</td></tr>
<tr><td><code id="dprings_+3A_smooth">smooth</code></td>
<td>
<p>Set to TRUE, the profile will be denoised using a
LOESS regression.</p>
</td></tr>
<tr><td><code id="dprings_+3A_span">span</code></td>
<td>
<p>Span of the LOESS regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame including the values and positions for all
peaks and values. Usually piped into <code>get_RW</code> to get ring
widths.
</p>


<h3>See Also</h3>

<p>get_RW
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a single file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## trim and detrend the measurement
dp.trimmed &lt;- dptrim(dp)
dp.detrended &lt;- dpdetrend(dp.trimmed, type = "gam")
## identify rings
rings &lt;- dprings(dp.detrended)
## plot a diagnostic
dprings(dp.detrended, return.plot = TRUE)
## get tree ring widths:
get_RW(rings)

</code></pre>

<hr>
<h2 id='dptrim'>Automatically trim an individual density profile on both sides</h2><span id='topic+dptrim'></span>

<h3>Description</h3>

<p>Calls dpdetect_s and dpdetect_e on a given dp object and
returns a trimmed dp object with the the row before the starting
point and after the ending removed. If <code>return.plot = TRUE</code>,
it will return a plot displaying the dp object with detected
starting and ending point. If called with the option
<code>return.fail = FALSE</code> and <code>return.plot = FALSE</code>, the
returned object will also include information on whether both
cutoff points were detected. If starting/ending point not detected,
dp object is returned with no changes. When running on a list of
dp objects, use <code>dptriml</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dptrim(dp, return.plot = FALSE, return.fail = FALSE, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dptrim_+3A_dp">dp</code></td>
<td>
<p>An dp object, see <code>dpload</code></p>
</td></tr>
<tr><td><code id="dptrim_+3A_return.plot">return.plot</code></td>
<td>
<p>Return a plot instead of dp object? If TRUE,
returns a plot instead of a dp object. When return.fail = TRUE,
it returns a list of three: dp object, start trimming success
and end trimming success.</p>
</td></tr>
<tr><td><code id="dptrim_+3A_return.fail">return.fail</code></td>
<td>
<p>Should information on the success of trimming be
included when returning a dp object?</p>
</td></tr>
<tr><td><code id="dptrim_+3A_silent">silent</code></td>
<td>
<p>Mute detection warnings, used when calling on list. A
list of trimmed dp objects, a result of calling dtriml or
dptriml_s on a dp list with return.fail = FALSE.</p>
</td></tr>
<tr><td><code id="dptrim_+3A_...">...</code></td>
<td>
<p>Parameters minseglen, span and nroll, will get passed through
to dpdetect_s, adjust when profile resolution is not 1/100 of a millimeter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trimmed dp object, with the beginning and ending
removed, if they were detected. When return.plot = TRUE, it
returns a plot displaying the process.
</p>


<h3>See Also</h3>

<p>dptriml, dptrim_s, dptriml_s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a single dp file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## trim the measurements
dp.trimmed &lt;- dptrim(dp)
## plot trimming
dptrim(dp, return.plot = TRUE)

</code></pre>

<hr>
<h2 id='dptrim_s'>Automatically trim an individual density profile on the starting side</h2><span id='topic+dptrim_s'></span>

<h3>Description</h3>

<p>Calls dpdetect_s on a given dpa object and returns a trimmed
dpa object with the the rows before the starting point removed. If
return.plot = TRUE, it will return a plot displaying the dp object
with detected starting point. If called with the option
return.fail = FALSE and return.plot = FALSE, the returned
object will also include information on whether starting cutoff
point was detected. If starting point not detected, dp object is
returned with no changes. When running on a list of dp objects,
use <code>dtriml_s</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dptrim_s(dp, return.plot = FALSE, return.fail = FALSE, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dptrim_s_+3A_dp">dp</code></td>
<td>
<p>An dp object, see <code>dpload</code></p>
</td></tr>
<tr><td><code id="dptrim_s_+3A_return.plot">return.plot</code></td>
<td>
<p>Return a plot instead of dp object? If TRUE,
returns a plot instead of a dp object. When return.fail = TRUE,
it returns a list of three: dp object, start trimming success
and end trimming success.</p>
</td></tr>
<tr><td><code id="dptrim_s_+3A_return.fail">return.fail</code></td>
<td>
<p>Should information on the success of trimming be
included when returning a dp object?</p>
</td></tr>
<tr><td><code id="dptrim_s_+3A_silent">silent</code></td>
<td>
<p>Mute detection warnings, used when calling on list. A
list of trimmed dp objects, a result of calling dptriml or
dptriml_s on a dp list with rreport = FALSE.</p>
</td></tr>
<tr><td><code id="dptrim_s_+3A_...">...</code></td>
<td>
<p>Parameters minseglen, span and nroll, will get passed through
to dpdetect_s, adjust when profile resolution is not 1/100 of a millimeter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trimmed dp object, with the beginning and ending
removed, if they were detected. When return.plot = TRUE, it
returns a plot displaying the process.
</p>


<h3>See Also</h3>

<p>dptrim, dptriml, dptriml_s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load a single file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## trim the measurement at start
dp.trimmed &lt;- dptrim_s(dp)
## plot trimming
dptrim_s(dp, return.plot = TRUE)

</code></pre>

<hr>
<h2 id='dptriml'>Automatically trim a list of density profiles on both sides</h2><span id='topic+dptriml'></span>

<h3>Description</h3>

<p>Calls <code>dptrim</code> on a list of dp objects and return a list of
trimmed objects. If automatic detection fails, the dp objects are
not trimmed. Can be run in parallel on multiple cores, this speeds
up the trimming process significantly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dptriml(dp.list, rreport = FALSE, cl = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dptriml_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, see <code>dpload</code></p>
</td></tr>
<tr><td><code id="dptriml_+3A_rreport">rreport</code></td>
<td>
<p>Return an embedded report on automatic trim success,
mandatory when using <code>correct_failures</code> to manually pick
starting/ending.</p>
</td></tr>
<tr><td><code id="dptriml_+3A_cl">cl</code></td>
<td>
<p>Number of cores to run the trimming in parallel, passed through to <code>pbapply</code>.</p>
</td></tr>
<tr><td><code id="dptriml_+3A_...">...</code></td>
<td>
<p>Parameters minseglen, span and nroll, will get passed through
to dpdetect_s, adjust when profile resolution is not 1/100 of a millimeter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of trimmed dp objects. When rreport = TRUE, it return a two-item list of (i) trimmed dp objects and (ii) trimming report data frame.
</p>


<h3>See Also</h3>

<p>dptrim, dptrim_s, dptriml_s,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load several dpa files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements
dp.trimmed &lt;- dptriml(dp.list)

</code></pre>

<hr>
<h2 id='dptriml_s'>Automatically trim a list of density profiles on the starting side</h2><span id='topic+dptriml_s'></span>

<h3>Description</h3>

<p>Calls <code>dptrim</code> on a list of dp objects and returns a list of
trimmed objects. If automatic detection fails, the dp objects are
not trimmed. Can be run in parallel on multiple cores, this speeds
up the trimming process significantly. Only trims the starting
side, see <code>dptriml</code> for trimming both side simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dptriml_s(dp.list, rreport = FALSE, cl = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dptriml_s_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, see <code>dpload</code></p>
</td></tr>
<tr><td><code id="dptriml_s_+3A_rreport">rreport</code></td>
<td>
<p>Return an embedded report on automatic trim success,
mandatory when using <code>correct_failures</code> to manually pick
starting/ending.</p>
</td></tr>
<tr><td><code id="dptriml_s_+3A_cl">cl</code></td>
<td>
<p>Number of cores to run the trimming in parallel, passed
through to <code>pbapply</code>.</p>
</td></tr>
<tr><td><code id="dptriml_s_+3A_...">...</code></td>
<td>
<p>Parameters minseglen, span and nroll, will get passed through
to dpdetect_s, adjust when profile resolution is not 1/100 of a millimeter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of trimmed dp objects. When rreport = TRUE, it
return a two-item list of (i) trimmed dp objects and (ii)
trimming report data frame.
</p>


<h3>See Also</h3>

<p>dptrim, dptrim_s, dptriml_s,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements
dp.trimmed &lt;- dptriml_s(dp.list)

</code></pre>

<hr>
<h2 id='extract_dpa_name'>Extract a file name from a full path</h2><span id='topic+extract_dpa_name'></span>

<h3>Description</h3>

<p>A wrapper function for regex extraction of filename. Given a
character string (&quot;data/0005/00/00050060.dpa&quot;), it will return only
the file name without the extension (&quot;00050060&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_dpa_name(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_dpa_name_+3A_string">string</code></td>
<td>
<p>A path to file, including file name. Can be nested in
many directories or in none.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An extracted filename, a character string.
</p>


<h3>References</h3>

<p>https://stackoverflow.com/questions/47678725/how-to-do-str-extract-with-base-r
</p>

<hr>
<h2 id='get_RW'>Get ring widths from identified tree rings</h2><span id='topic+get_RW'></span>

<h3>Description</h3>

<p>Called on an object returned by <code>dprings</code>, it will return ring
widths for all detected rings. The units are determined by the
xUnit from the footer of density profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_RW(rings)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_RW_+3A_rings">rings</code></td>
<td>
<p>A data frame with the identified rings, a result of
the dprings() call on an individual profile</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of ring widths, which are peak-to-peak differences.
</p>


<h3>See Also</h3>

<p>dprings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a single file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## trim and detrend the measurement
dp.trimmed &lt;- dptrim(dp)
dp.detrended &lt;- dpdetrend(dp.trimmed, type = "gam")
## identify rings
rings &lt;- dprings(dp.detrended)
## get tree ring widths:
get_RW(rings)
</code></pre>

<hr>
<h2 id='manual_trim_detect'>Manually select a starting or ending location of a density profile</h2><span id='topic+manual_trim_detect'></span>

<h3>Description</h3>

<p>Follow-up to automatic trim functions or to be used manually, will
display a plot with the density profiles. Most commonly used in
automatic failure corrections by the function correct_failures. Use
your mouse to select starting/ending point on the plot, your
selection will then be displayed on the plot. Either returns a
numeric value or NA in case of errors. There are two special cases:
when encountering an error with a label = &quot; - PICK START&quot; it will
return the starting position, and with label &quot; - PICK STOP&quot; it will
return the ending position. These labels are used when correcting
several density profiles at once using <code>correct_failures</code>.
This function uses <code>graphics::locator</code>, which only works on
screen devices X11, windows and quartz. It will not work on other
devices, returning NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manual_trim_detect(failure, label = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="manual_trim_detect_+3A_failure">failure</code></td>
<td>
<p>A dp object, usually see dpload.</p>
</td></tr>
<tr><td><code id="manual_trim_detect_+3A_label">label</code></td>
<td>
<p>Optional label to be displayed on the plot after the
file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The x position selected on the graph, row number in the dp$data data frame.
</p>


<h3>See Also</h3>

<p>dptrim, dptriml
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load a single file
dp &lt;- dpload(system.file("extdata", "00010001.dpa", package = "densitr"))
## get a starting point on the plot

manual_trim_detect(dp)

</code></pre>

<hr>
<h2 id='plot_all'>Plot a list of dp objects, one by one</h2><span id='topic+plot_all'></span>

<h3>Description</h3>

<p>Plot a list of dp objects, one by one. Press any key to move to
the next dp object. Returns nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all(dp.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_all_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, see <code>dpload</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dptrim, dptrim_s, dptriml_s,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements

if(interactive()){
plot_all(dp.list)
}
</code></pre>

<hr>
<h2 id='plot_end_detection'>Display end detection on a list of dp objects</h2><span id='topic+plot_end_detection'></span>

<h3>Description</h3>

<p>Display an automatic end detection of dp list, each dp object
individually. Press any key to move to the next dp object. Returns
nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_end_detection(dp.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_end_detection_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, see <code>dpload</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dptrim, dptrim_s, dptriml_s,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements

if(interactive()){
plot_end_detection(dp.list)
}
</code></pre>

<hr>
<h2 id='plot_failures'>Plot trimming failures one by one</h2><span id='topic+plot_failures'></span>

<h3>Description</h3>

<p>Plot each failed trimming detection, one by one. Press any key to
move to the next dp object. Returns nothing. The entry list of dp
trimmed objects must include the trimming report (rreport = TRUE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_failures(dp.trimmed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_failures_+3A_dp.trimmed">dp.trimmed</code></td>
<td>
<p>A list of trimmed dp objects, see <code>dpload</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dptrim, dptrim_s, dptriml_s,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements
## Not run: 
plot_failures(dp.list)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_start_detection'>Display start detection on a list of dp objects</h2><span id='topic+plot_start_detection'></span>

<h3>Description</h3>

<p>Display an automatic start detection of dp list, each dp object
individually. Press any key to move to the next dp object. Returns
nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_start_detection(dp.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_start_detection_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, see <code>dpload</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dptrim, dptrim_s, dptriml_s,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements

if(interactive()){
plot_start_detection(dp.list)
}
</code></pre>

<hr>
<h2 id='plot_trimming'>Display automatic trimming on a list of dp objects</h2><span id='topic+plot_trimming'></span>

<h3>Description</h3>

<p>Display an automatic trimming of dp list, each dp object
individually. Press any key to move to the next dp object. Returns
nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trimming(dp.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_trimming_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects, see <code>dpload</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dptrim, dptrim_s, dptriml_s,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## plot trimming the measurements

if(interactive()){
plot_trimming(dp.list)
}
</code></pre>

<hr>
<h2 id='read_dpa'>Read a single resistance-drilling density profile measurement file (*.dpa)</h2><span id='topic+read_dpa'></span>

<h3>Description</h3>

<p>Reads a single *.dpa file and returns a <code>dp</code> object,
constructed from two lists: <code>data</code> and <code>footer</code>. The
former one contains actual measurement values, the latter includes
supplementary data recorded by the Resistograph® device, such as
time, firmware number...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dpa(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_dpa_+3A_file">file</code></td>
<td>
<p>A path to file, including file name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>dp</code> object.
</p>


<h3>See Also</h3>

<p>dpload
</p>

<hr>
<h2 id='remove_trim_failures'>Remove automatic trim failures from a list of trimmed dp objects
and return only non-failed trimmed objects</h2><span id='topic+remove_trim_failures'></span>

<h3>Description</h3>

<p>Returns a dp list of trimmed dp objects without the failed trim
objects. Trimmed dp list should be a result of either calling
dtriml on a list of dp objects or calling dtriml_s to remove the
starting portions of the measurement. Both functions should be
called with the option &quot;return.fail = FALSE&quot;, which embeds a
trimming report when returning the list of trimmed dp objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_trim_failures(dp.trimmed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_trim_failures_+3A_dp.trimmed">dp.trimmed</code></td>
<td>
<p>A list of trimmed dp objects, a result of
calling dtriml or dtriml_s on a dp list with
&quot;return.fail = FALSE&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dp list of trimmed objects with failures removed.
</p>


<h3>See Also</h3>

<p>dptriml, dptriml_s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements
dp.trimmed &lt;- dptriml(dp.list, rreport = TRUE)
## remove trimming failures
dp.nofailures &lt;- remove_trim_failures(dp.trimmed)

</code></pre>

<hr>
<h2 id='separate_trim_failures'>Remove automatic trim failures from a list of trimmed dp objects
and return ONLY failures</h2><span id='topic+separate_trim_failures'></span>

<h3>Description</h3>

<p>An inverse of remove_trim_failures, return a list of failed trimming
objects from a trimmed dp list. Trimmed dp list should be a
result of either calling dtriml on a list of dp objects or calling
dtriml_s to remove the starting portions of the measurement. Both
functions should be called with the option &quot;rreport = FALSE&quot;, which
embeds a trimming report when returning the list of trimmed dp
objects. If no failures found, it will return a list of trimmed
profiles without the report attached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_trim_failures(dp.trimmed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="separate_trim_failures_+3A_dp.trimmed">dp.trimmed</code></td>
<td>
<p>A list of trimmed dp objects, a result of
calling dptriml or dptriml_s on a dp list with
&quot;rreport = FALSE&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two lists, one with start failures and one with end failures.
</p>


<h3>See Also</h3>

<p>dptriml, dptriml_s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## load several dp files
dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## trim the measurements
dp.trimmed &lt;- dptriml(dp.list, rreport = TRUE)
## separate trimming failures
dp.nofailures &lt;- separate_trim_failures(dp.trimmed)

</code></pre>

<hr>
<h2 id='trim_manually'>Manually trim a list of density profiles</h2><span id='topic+trim_manually'></span>

<h3>Description</h3>

<p>This function will take a list of dp objects and interactively ask
the user to assign starting/ending points manually for all density
profiles in sequentially. Used as alternative to automatic trim
functions. The plot title will display whether you are selecting
start or end position. Use your mouse to select starting/ending
points on the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_manually(dp.list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_manually_+3A_dp.list">dp.list</code></td>
<td>
<p>A list of dp objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of trimmed density profiles.
</p>


<h3>See Also</h3>

<p>dptrim, dptriml, manual_trim_detect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load all dp files

dp.list &lt;- dpload(dp.directory = system.file("extdata", package = "densitr"))
## manually trim the list
dp.trimmed &lt;- trim_manually(dp.list)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
