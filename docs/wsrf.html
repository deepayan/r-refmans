<!DOCTYPE html><html><head><title>Help for package wsrf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wsrf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#combine.wsrf'><p>Combine Ensembles of Trees</p></a></li>
<li><a href='#correlation.wsrf'>
<p>Correlation</p></a></li>
<li><a href='#importance.wsrf'><p>Extract Variable Importance Measure</p></a></li>
<li><a href='#oob.error.rate.wsrf'>
<p>Out-of-Bag Error Rate</p></a></li>
<li><a href='#predict.wsrf'><p> Predict Method for <code>wsrf</code> Model</p></a></li>
<li><a href='#print.wsrf'><p>Print Method for <code>wsrf</code> Model</p></a></li>
<li><a href='#strength.wsrf'>
<p>Strength</p></a></li>
<li><a href='#subset.wsrf'><p>Subset of a Forest</p></a></li>
<li><a href='#varCounts.wsrf'>
<p>Number of Times of Variables Selected as Split Condition</p></a></li>
<li><a href='#wsrf'>
<p>Build a Forest of Weighted Subspace Decision Trees</p>
</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Weighted Subspace Random Forest for Classification</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.30</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-27</td>
</tr>
<tr>
<td>Description:</td>
<td>
    A parallel implementation of Weighted Subspace Random Forest.  The
    Weighted Subspace Random Forest algorithm was proposed in the
    International Journal of Data Warehousing and Mining by Baoxun Xu,
    Joshua Zhexue Huang, Graham Williams, Qiang Wang, and Yunming Ye
    (2012) &lt;<a href="https://doi.org/10.4018%2Fjdwm.2012040103">doi:10.4018/jdwm.2012040103</a>&gt;.  The algorithm can classify
    very high-dimensional data with random forests built using small
    subspaces.  A novel variable weighting method is used for variable
    subspace selection in place of the traditional random variable
    sampling.This new approach is particularly useful in building
    models from high-dimensional data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SimonYansenZhao/wsrf">https://github.com/SimonYansenZhao/wsrf</a>, <a href="https://togaware.com">https://togaware.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SimonYansenZhao/wsrf/issues">https://github.com/SimonYansenZhao/wsrf/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>parallel, R (&ge; 3.3.0), Rcpp (&ge; 0.10.2), stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.5), randomForest (&ge; 4.6.7), stringr (&ge; 0.6.2),
rmarkdown (&ge; 1.6)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Classification/ACM-2012:</td>
<td>Computing methodologies ~ Classification and
regression trees, Computing methodologies ~ Supervised learning
by classification, Computing methodologies ~ Massively parallel
and high-performance simulations, Computing methodologies ~
Distributed simulation</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-27 08:28:17 UTC; simon</td>
</tr>
<tr>
<td>Author:</td>
<td>Qinghan Meng [aut],
  He Zhao <a href="https://orcid.org/0000-0001-5763-9743"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Graham J. Williams
    <a href="https://orcid.org/0000-0001-7041-4127"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Junchao Lv [aut],
  Baoxun Xu [aut],
  Joshua Zhexue Huang
    <a href="https://orcid.org/0000-0002-6797-2571"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>He Zhao &lt;Simon.Yansen.Zhao@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-06 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='combine.wsrf'>Combine Ensembles of Trees</h2><span id='topic+combine'></span><span id='topic+combine.wsrf'></span>

<h3>Description</h3>

<p>Combine two more more ensembles of trees into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine.wsrf_+3A_...">...</code></td>
<td>
<p>two or more objects of class <code>randomForest</code>, to be
combined into one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>wsrf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subset">subset</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("wsrf")

  # Prepare parameters.
  ds     &lt;- iris
  target &lt;- "Species"
  vars   &lt;- names(ds)
  if (sum(is.na(ds[vars]))) ds[vars] &lt;- randomForest::na.roughfix(ds[vars])
  ds[target] &lt;- as.factor(ds[[target]])
  form &lt;- as.formula(paste(target, "~ ."))
  set.seed(42)
  train.1 &lt;- sample(nrow(ds), 0.7*nrow(ds))
  test.1  &lt;- setdiff(seq_len(nrow(ds)), train.1)

  set.seed(49)
  train.2 &lt;- sample(nrow(ds), 0.7*nrow(ds))
  test.2  &lt;- setdiff(seq_len(nrow(ds)), train.2)
  
  # Build model.  We disable parallelism here, since CRAN Repository
  # Policy (https://cran.r-project.org/web/packages/policies.html)
  # limits the usage of multiple cores to save the limited resource of
  # the check farm.

  model.wsrf.1 &lt;- wsrf(form, data=ds[train.1, vars], parallel=FALSE)
  model.wsrf.2 &lt;- wsrf(form, data=ds[train.2, vars], parallel=FALSE)

  
  # Merge two models.
  model.wsrf.big &lt;- combine.wsrf(model.wsrf.1, model.wsrf.2)
  print(model.wsrf.big)
  cl &lt;- predict(model.wsrf.big, newdata=ds[test.1, vars], type="response")$response
  actual &lt;- ds[test.1, target]
  (accuracy.wsrf &lt;- mean(cl==actual))

</code></pre>

<hr>
<h2 id='correlation.wsrf'>
Correlation
</h2><span id='topic+correlation'></span><span id='topic+correlation.wsrf'></span>

<h3>Description</h3>

<p> Give the measure for the diversity of the trees in the
forest model built from <code>wsrf</code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wsrf'
correlation(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation.wsrf_+3A_object">object</code></td>
<td>
<p>object of class <code>wsrf</code>.</p>
</td></tr>
<tr><td><code id="correlation.wsrf_+3A_...">...</code></td>
<td>
<p>optional additional arguments. At present no additional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure was introduced in Breiman (2001).
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>He Zhao and Graham Williams (SIAT, CAS)
</p>


<h3>References</h3>

<p>Breiman, L.  2001 &quot;Random forests&quot;.  <em>Machine learning</em>,
<b>45(1)</b>, 5&ndash;32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wsrf">wsrf</a></code>
</p>

<hr>
<h2 id='importance.wsrf'>Extract Variable Importance Measure</h2><span id='topic+importance'></span><span id='topic+importance.wsrf'></span>

<h3>Description</h3>

<p>This is the extractor function for variable importance measures as
produced by <code>wsrf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wsrf'
importance(x, type=NULL, class=NULL, scale=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importance.wsrf_+3A_x">x</code></td>
<td>
<p>an object of class <code>wsrf</code>.</p>
</td></tr>
<tr><td><code id="importance.wsrf_+3A_type">type</code></td>
<td>
<p>either 1 or 2, specifying the type of importance measure
(1=mean decrease in accuracy, 2=mean decrease in node impurity).</p>
</td></tr>
<tr><td><code id="importance.wsrf_+3A_class">class</code></td>
<td>
<p>for classification problem, which class-specific measure
to return.</p>
</td></tr>
<tr><td><code id="importance.wsrf_+3A_scale">scale</code></td>
<td>
<p>for permutation based measures, should the measures be
divided their &ldquo;standard errors&rdquo;?</p>
</td></tr>
<tr><td><code id="importance.wsrf_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here are the definitions of the variable importance measures.  The
first measure is computed from permuting OOB data:  For
each tree, the prediction error on the out-of-bag portion of the
data is recorded.
Then the same is done after permuting each predictor variable.  The
difference between the two are then averaged over all trees, and
normalized by the standard deviation of the differences.
</p>
<p>The second measure is the total decrease in node impurities from
splitting on the variable, averaged over all trees.  The node 
impurity is measured by the Information Gain Ratio index.
</p>


<h3>Value</h3>

<p>A matrix of importance measure, one row for each predictor variable.
The column(s) are different importance measures.
</p>


<h3>See Also</h3>

<p><code>randomForest</code>
</p>

<hr>
<h2 id='oob.error.rate.wsrf'>
Out-of-Bag Error Rate
</h2><span id='topic+oob.error.rate'></span><span id='topic+oob.error.rate.wsrf'></span>

<h3>Description</h3>

<p>Return out-of-bag error rate for &quot;<code>wsrf</code>&quot; model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wsrf'
oob.error.rate(object, tree, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oob.error.rate.wsrf_+3A_object">object</code></td>
<td>
<p>object of class <code>wsrf</code>.</p>
</td></tr>
<tr><td><code id="oob.error.rate.wsrf_+3A_tree">tree</code></td>
<td>
<p>logical or an integer vector for the index of a specific
tree in the forest model.  If provided as an integer vector,
<code>oobErrorRate.wsrf</code> will give the corresponding out-of-bag
error rates of the exact trees specified by <code>tree</code>.  If TRUE,
all error rates will be presented.  If FALSE or missing, the gross
error rate for the forest will be given.</p>
</td></tr>
<tr><td><code id="oob.error.rate.wsrf_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a vector of error rates.
</p>


<h3>Author(s)</h3>

<p>He Zhao and Graham Williams (SIAT, CAS)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wsrf">wsrf</a></code>
</p>

<hr>
<h2 id='predict.wsrf'> Predict Method for <code>wsrf</code> Model </h2><span id='topic+predict'></span><span id='topic+predict.wsrf'></span>

<h3>Description</h3>

<p> Give the predictions for the new data by the forest
model built from <code>wsrf</code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'wsrf'
predict(object, newdata, type=c("response",
  "class", "vote", "prob", "aprob", "waprob"), ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.wsrf_+3A_object">object</code></td>
<td>
<p>object of class <code>wsrf</code>.</p>
</td></tr>
<tr><td><code id="predict.wsrf_+3A_newdata">newdata</code></td>
<td>
<p>the data that needs to be predicted.  Its format
should be the same as that for <code><a href="#topic+wsrf">wsrf</a></code>.</p>
</td></tr>
<tr><td><code id="predict.wsrf_+3A_type">type</code></td>
<td>
<p>the type of prediction required, a character vector indicating
the types of output, and can be one of the values below:
</p>

<dl>
<dt>vote</dt><dd><p>matrix of vote counts</p>
</dd>
<dt>response</dt><dd><p>predicted values.</p>
</dd>
<dt>class</dt><dd><p>the same as response.</p>
</dd>
<dt>prob</dt><dd><p>matrix of class probabilities.  The probability is the
proportion of trees in the forest voting for the particular
outcome (prob = votes / ntree)</p>
</dd>
<dt>aprob</dt><dd><p>the average score from the decision trees for each
class rather than the proportion of decision trees for each
class (aprob = scores / ntree)</p>
</dd>
<dt>waprob</dt><dd><p>the weighted average, weighted by the accuracy of
the tree (waprob = scores * accuracy / sum(accuracy))</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="predict.wsrf_+3A_...">...</code></td>
<td>
<p>optional additional arguments. At present no additional
arguments are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of predictions for the new data with corresponding components for 
each type of predictions.  For <code>type=class</code> or <code>type=class</code>, a 
vector of length <code>nrow(newdata)</code>, otherwise, a matrix of
<code>nrow(newdata) * (number of class label)</code>.  For example, if given 
<code>type=c("class", "prob")</code> and the return value is <code>res</code>, then 
<code>res$class</code> is a vector of predicted class labels of length 
<code>nrow(newdata)</code>, and <code>res$prob</code> is a matrix of class probabilities.</p>


<h3>Author(s)</h3>

<p>He Zhao and Graham Williams (SIAT, CAS)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wsrf">wsrf</a></code>
</p>

<hr>
<h2 id='print.wsrf'>Print Method for <code>wsrf</code> Model</h2><span id='topic+print'></span><span id='topic+print.wsrf'></span>

<h3>Description</h3>

<p>Print a summary of the forest model or one specific tree in the forest
model built from <code>wsrf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wsrf'
print(x, trees, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.wsrf_+3A_x">x</code></td>
<td>
<p>object of class <code>wsrf</code>.</p>
</td></tr>
<tr><td><code id="print.wsrf_+3A_trees">trees</code></td>
<td>
<p>the index of a specific tree.  If missing, <code>print</code>
will print a summary of the model.</p>
</td></tr>
<tr><td><code id="print.wsrf_+3A_...">...</code></td>
<td>
<p>optional additional arguments. At present no additional
arguments are used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>He Zhao and Graham Williams (SIAT, CAS)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wsrf">wsrf</a></code>
</p>

<hr>
<h2 id='strength.wsrf'>
Strength
</h2><span id='topic+strength'></span><span id='topic+strength.wsrf'></span>

<h3>Description</h3>

<p> Give the measure for the collective performance of
individual trees in the forest model built from <code>wsrf</code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wsrf'
strength(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strength.wsrf_+3A_object">object</code></td>
<td>
<p>object of class <code>wsrf</code>.</p>
</td></tr>
<tr><td><code id="strength.wsrf_+3A_...">...</code></td>
<td>
<p>optional additional arguments. At present no additional
arguments are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The measure was introduced in Breiman (2001).
</p>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>He Zhao and Graham Williams (SIAT, CAS)
</p>


<h3>References</h3>

<p>Breiman, L.  2001 &quot;Random forests&quot;.  <em>Machine learning</em>,
<b>45(1)</b>, 5&ndash;32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wsrf">wsrf</a></code>
</p>

<hr>
<h2 id='subset.wsrf'>Subset of a Forest</h2><span id='topic+subset'></span><span id='topic+subset.wsrf'></span>

<h3>Description</h3>

<p>Obtain a subset of a forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wsrf'
subset(x, trees, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.wsrf_+3A_x">x</code></td>
<td>
<p>an object of class <code>wsrf</code>.</p>
</td></tr>
<tr><td><code id="subset.wsrf_+3A_trees">trees</code></td>
<td>
<p>which trees should be included in the sub-forest.  An
integer vector, which indicates the index of the trees.</p>
</td></tr>
<tr><td><code id="subset.wsrf_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>wsrf</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+combine">combine</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("wsrf")

  # Prepare parameters.
  ds     &lt;- iris
  target &lt;- "Species"
  vars   &lt;- names(ds)
  if (sum(is.na(ds[vars]))) ds[vars] &lt;- randomForest::na.roughfix(ds[vars])
  ds[target] &lt;- as.factor(ds[[target]])
  form &lt;- as.formula(paste(target, "~ ."))
  set.seed(42)
  train &lt;- sample(nrow(ds), 0.7*nrow(ds))
  test  &lt;- setdiff(seq_len(nrow(ds)), train)
  
  # Build model.  We disable parallelism here, since CRAN Repository
  # Policy (https://cran.r-project.org/web/packages/policies.html)
  # limits the usage of multiple cores to save the limited resource of
  # the check farm.

  model.wsrf &lt;- wsrf(form, data=ds[train, vars], parallel=FALSE)
  print(model.wsrf)
  
  # Subset.
  submodel.wsrf &lt;- subset.wsrf(model.wsrf, 1:200)
  print(submodel.wsrf)
  cl &lt;- predict(submodel.wsrf, newdata=ds[test, vars], type="response")$response
  actual &lt;- ds[test, target]
  (accuracy.wsrf &lt;- mean(cl==actual))
</code></pre>

<hr>
<h2 id='varCounts.wsrf'>
Number of Times of Variables Selected as Split Condition
</h2><span id='topic+varCounts.wsrf'></span>

<h3>Description</h3>

<p>Return the times of each variable being selected as split condition.
For evaluating the bias of wsrf towards attribute types (categorical and
numerical) and the number of values each attribute has.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wsrf'
varCounts(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varCounts.wsrf_+3A_object">object</code></td>
<td>
<p>object of class <code>wsrf</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A vector of integer.  The length is the same as the training
data for building that <code>wsrf</code> model. </p>


<h3>Author(s)</h3>

<p>He Zhao and Graham Williams (SIAT, CAS)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wsrf">wsrf</a></code>
</p>

<hr>
<h2 id='wsrf'>
Build a Forest of Weighted Subspace Decision Trees
</h2><span id='topic+wsrf'></span><span id='topic+wsrf.formula'></span><span id='topic+wsrf.default'></span>

<h3>Description</h3>

<p>Build weighted subspace C4.5-based decision trees to construct a
forest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'formula'
wsrf(formula, data, ...)
## Default S3 method:
wsrf(x, y, mtry=floor(log2(length(x))+1), ntree=500,
                       weights=TRUE, parallel=TRUE, na.action=na.fail,
                       importance=FALSE, nodesize=2, clusterlogfile, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wsrf_+3A_x">x</code>, <code id="wsrf_+3A_formula">formula</code></td>
<td>
<p>a data frame or a matrix of predictors, or a formula
with a response but no interaction terms.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_y">y</code></td>
<td>
<p>a response vector.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_data">data</code></td>
<td>
<p>a data frame in which to interpret the variables named in
the formula.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to grow.  By default, 500</p>
</td></tr>
<tr><td><code id="wsrf_+3A_mtry">mtry</code></td>
<td>
<p>number of variables to choose as candidates at each node
split, by default, <code>floor(log2(length(x))+1)</code>.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_weights">weights</code></td>
<td>
<p>logical.  <code>TRUE</code> for weighted subspace selection,
which is the default; <code>FALSE</code> for random selection, and the
trees are based on C4.5.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_na.action">na.action</code></td>
<td>
<p>a function indicate the behaviour when encountering
NA values in <code>data</code>.  By default, <code>na.fail</code>.  If
<code>NULL</code>, do nothing.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_parallel">parallel</code></td>
<td>
<p>whether to run multiple cores (TRUE), nodes, or
sequentially (FALSE).</p>
</td></tr>
<tr><td><code id="wsrf_+3A_importance">importance</code></td>
<td>
<p>should importance of predictors be assessed? </p>
</td></tr>
<tr><td><code id="wsrf_+3A_nodesize">nodesize</code></td>
<td>
<p>minimum size of leaf node, i.e., minimum number of
observations a leaf node represents.  By default, 2.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_clusterlogfile">clusterlogfile</code></td>
<td>
<p>character.  The pathname of the log file when
building model in a cluster.  For debug.</p>
</td></tr>
<tr><td><code id="wsrf_+3A_...">...</code></td>
<td>
<p>optional parameters to be passed to the low level function
<code>wsrf.default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Xu, Huang, Williams, Wang, and Ye (2012) for more details of the
algorithm, and Zhao, Williams, Huang (2017) for more details of the
package.
</p>
<p>Currently, <span class="pkg">wsrf</span> can only be used for classification.  When
<code>weights=FALSE</code>, C4.5-based trees (Quinlan (1993)) are grown by
<code>wsrf</code>, where binary split is used for continuous predictors
(variables) and <em>k</em>-way split for categorical ones.  For
continuous predictors, each of the values themselves is used as split
points, no discretization used.  The only stopping condition for split
is the minimum node size must not less than <code>nodesize</code>.
</p>


<h3>Value</h3>

<p>An object of class <span class="pkg">wsrf</span>, which is a list with the following
components:
</p>
<table>
<tr><td><code>confusion</code></td>
<td>
<p>the confusion matrix of the prediction (based on OOB
data).</p>
</td></tr>
<tr><td><code>oob.times</code></td>
<td>
<p>number of times cases are &lsquo;out-of-bag&rsquo; (and thus used
in computing OOB error estimate)</p>
</td></tr>
<tr><td><code>predicted</code></td>
<td>
<p>the predicted values of the input data based on
out-of-bag samples.</p>
</td></tr>
<tr><td><code>useweights</code></td>
<td>
<p>logical.  Whether weighted subspace selection is
used?  NULL if the model is obtained by combining multiple <span class="pkg">wsrf</span>
model and one of them has different value of 'useweights'.</p>
</td></tr>
<tr><td><code>mtry</code></td>
<td>
<p>integer.  The number of variables to be chosen when
splitting a node.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>He Zhao and Graham Williams (SIAT, CAS)
</p>


<h3>References</h3>

<p>Xu, B. and Huang, J. Z. and Williams, G. J. and Wang, Q. and Ye, Y.
2012
&quot;Classifying very high-dimensional data with random forests built from small subspaces&quot;.
<em>International Journal of Data Warehousing and Mining (IJDWM)</em>,
<b>8(2)</b>, 44&ndash;63.
</p>
<p>Quinlan, J. R.  1993 <em>C4.5: Programs for Machine Learning</em>.
Morgan Kaufmann.
</p>
<p>Zhao, H. and Williams, G. J. and Huang, J. Z.  2017
&quot;wsrf: An R Package for Classification with Scalable Weighted Subspace Random Forests&quot;.
<em>Journal of Statistical Software</em>, <b>77(3)</b>, 1&ndash;30.
doi:10.18637/jss.v077.i03
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library("wsrf")

  # Prepare parameters.
  ds &lt;- iris
  dim(ds)
  names(ds)
  target &lt;- "Species"
  vars   &lt;- names(ds)
  if (sum(is.na(ds[vars]))) ds[vars] &lt;- randomForest::na.roughfix(ds[vars])
  ds[target] &lt;- as.factor(ds[[target]])
  (tt  &lt;- table(ds[target]))
  form &lt;- as.formula(paste(target, "~ ."))
  set.seed(42)
  train &lt;- sample(nrow(ds), 0.7*nrow(ds))
  test  &lt;- setdiff(seq_len(nrow(ds)), train)

  # Build model.  We disable parallelism here, since CRAN Repository
  # Policy (https://cran.r-project.org/web/packages/policies.html)
  # limits the usage of multiple cores to save the limited resource of
  # the check farm.

  model.wsrf &lt;- wsrf(form, data=ds[train, vars], parallel=FALSE)
  
  # View model.
  print(model.wsrf)
  print(model.wsrf, tree=1)

  # Evaluate.
  strength(model.wsrf)
  correlation(model.wsrf)
  res &lt;- predict(model.wsrf, newdata=ds[test, vars], type=c("response", "waprob"))
  actual &lt;- ds[test, target]
  (accuracy.wsrf &lt;- mean(res$response==actual))
  
  # Different type of prediction.
  cl &lt;- apply(res$waprob, 1, which.max)
  cl &lt;- factor(cl, levels=1:ncol(res$waprob), labels=levels(actual))
  (accuracy2.wsrf &lt;- mean(cl==actual))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
