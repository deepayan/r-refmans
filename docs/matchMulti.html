<!DOCTYPE html><html><head><title>Help for package matchMulti</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matchMulti}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#matchMulti-package'><p>matchMulti Package</p></a></li>
<li><a href='#agg'><p>Extract School-Level Covariates</p></a></li>
<li><a href='#assembleMatch'><p>Collect Matched Samples</p></a></li>
<li><a href='#balanceMulti'><p>Performs balance checking after multilevel matching.</p></a></li>
<li><a href='#balanceTable'><p>Create Balance Table</p></a></li>
<li><a href='#buildCaliper'><p>Construct propensity score caliper</p></a></li>
<li><a href='#catholic_schools'><p>1980 and 1982 High School and Beyond Data</p></a></li>
<li><a href='#ci_func'><p>Outcome analysis.</p></a></li>
<li><a href='#describe_data_counts'><p>Print out summary of student and school counts</p></a></li>
<li><a href='#elastic'><p>Optimal Subset Matching without Balance Constraints</p></a></li>
<li><a href='#handleNA'><p>Handle Missing Values</p></a></li>
<li><a href='#is.binary'><p>Check if a variable is binary</p></a></li>
<li><a href='#match2distance'><p>Compute School Distance from a Student Match</p></a></li>
<li><a href='#matchMulti'><p>A function that performs multilevel matching.</p></a></li>
<li><a href='#matchMultioutcome'><p>Performs an outcome analysis after multilevel matching.</p></a></li>
<li><a href='#matchMultiResult'><p>matchMultiResult object for results of power calculations</p></a></li>
<li><a href='#matchMultisens'><p>Rosenbaum Bounds after Multilevel Matching</p></a></li>
<li><a href='#matchSchools'><p>Match Schools on Student-based Distance</p></a></li>
<li><a href='#matchStudents'><p>Compute Student Matches for all Pairs of Schools</p></a></li>
<li><a href='#minischool'><p>Mini-data set for illustration</p></a></li>
<li><a href='#pe_func'><p>Outcome analysis.</p></a></li>
<li><a href='#pval_func'><p>Outcome analysis.</p></a></li>
<li><a href='#rematchSchools'><p>Repeat School Match Only</p></a></li>
<li><a href='#resolve.cols'><p>Ensure Dataframes Share Same Set Columns</p></a></li>
<li><a href='#sdiff'><p>Balance Measures</p></a></li>
<li><a href='#smahal'><p>Robust Mahalanobis Distance</p></a></li>
<li><a href='#students2schools'><p>Aggregate Student Data into School Data</p></a></li>
<li><a href='#tally_schools'><p>Tally schools and students in a given dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Multilevel Matching using a Network Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.12.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Pimentel &lt;spi@berkeley.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs multilevel matches for data with cluster-
	level treatments and individual-level outcomes using a network 
	optimization algorithm.  Functions for checking balance at the 
	cluster and individual levels are also provided, as are methods 
	for permutation-inference-based outcome analysis.  Details in 
	Pimentel et al. (2018) &lt;<a href="https://doi.org/10.1214%2F17-AOAS1118">doi:10.1214/17-AOAS1118</a>&gt;.  The optmatch 
	package, which is useful for running many of the provided 
	functions, may be downloaded from Github at 
	<a href="https://github.com/markmfredrickson/optmatch">https://github.com/markmfredrickson/optmatch</a> if not available on 
	CRAN.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.3), rlang, dplyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>rcbsubset (&ge; 1.1.4), plyr, coin, weights, mvtnorm, MASS,
sandwich, magrittr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>optmatch, testthat, knitr, rrelaxiv</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://errickson.net/rrelaxiv/">https://errickson.net/rrelaxiv/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-01 09:24:03 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Keele [aut],
  Luke Miratrix [aut],
  Sam Pimentel [aut, cre],
  Paul Rosenbaum [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-01 09:33:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='matchMulti-package'>matchMulti Package</h2><span id='topic+matchMulti-package'></span>

<h3>Description</h3>

<p><code>matchMulti</code> provides and easy to use set of functions to do matching
with multilevel data.  It is designed for use with grouped data such as
students in schools, where the user wishes to match a set of treated groups
to control groups to make the two groups more comparable.
</p>


<h3>Details</h3>

<p>This package will match treated groups to control groups, but allows for
trimming of both units and groups to increase balance.  There are also
functions for assessing balance after matching, estimating treatment effects
and performing sensitivity analysis for hidden confounders.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Sam Pimentel <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Luke Keele <a href="mailto:luke.keele@gmail.com">luke.keele@gmail.com</a>
</p>
</li>
<li><p> Luke Miratrix <a href="mailto:luke_miratrix@gse.harvard.edu">luke_miratrix@gse.harvard.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Paul Rosenbaum [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>See also <code><a href="#topic+matchMulti">matchMulti</a></code>, <code><a href="#topic+matchMultisens">matchMultisens</a></code>,
<code><a href="#topic+balanceMulti">balanceMulti</a></code>, <code><a href="#topic+matchMultioutcome">matchMultioutcome</a></code>,
<code><a href="#topic+rematchSchools">rematchSchools</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Load Catholic school data
data(catholic_schools)

student.cov &lt;- c('minority','female','ses','mathach')

# Check balance student balance before matching
balanceTable(catholic_schools[c(student.cov,'sector')],  treatment = 'sector')

#Match schools but not students within schools
match.simple &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = FALSE)

#Check balance after matching - this checks both student and school balance
balanceMulti(match.simple, student.cov = student.cov)

#Estimate treatment effect
output &lt;- matchMultioutcome(match.simple, out.name = "mathach",
schl_id_name = "school",  treat.name = "sector")

# Perform sensitivity analysis using Rosenbaum bound -- increase Gamma to increase effect of
# possible hidden confounder 
         
matchMultisens(match.simple, out.name = "mathach",
          schl_id_name = "school", 
          treat.name = "sector", Gamma=1.3)
          
# Now match both schools and students within schools          
match.out &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = TRUE, student.vars = student.cov)

# Check balance again
bal.tab &lt;- balanceMulti(match.out, student.cov = student.cov)

# Now match with fine balance constraints on whether the school is large 
# or has a high percentage of minority students
match.fb &lt;- matchMulti(catholic_schools, treatment = 'sector', school.id = 'school', 
match.students = TRUE, student.vars = student.cov, 
school.fb = list(c('size_large'),c('size_large','minority_mean_large')))

# Estimate treatment effects
matchMultioutcome(match.fb, out.name = "mathach", schl_id_name = "school",  treat.name = "sector")

#Check Balance
balanceMulti(match.fb, student.cov = student.cov)

## End(Not run)

</code></pre>

<hr>
<h2 id='agg'>Extract School-Level Covariates</h2><span id='topic+agg'></span>

<h3>Description</h3>

<p>Given a vector of variables of interest for students in a single school,
extracts a single value for the school
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agg_+3A_x">x</code></td>
<td>
<p>a vector containing student-level observations for a school. If it
is a factor it must contain only a single level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input is numeric, <code>agg</code> returns the mean; if the input is not
numeric, an error will be thrown unless all values are the same, in which
case the single unique value will be returned.
</p>


<h3>Value</h3>

<p>A single value of the same type as the input vector.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='assembleMatch'>Collect Matched Samples</h2><span id='topic+assembleMatch'></span>

<h3>Description</h3>

<p>After students and schools have both been matched separately, assembles the
matched student samples corresponding to the school match into a single
dataframe of student-level data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assembleMatch(student.matches, school.match, school.id, treatment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assembleMatch_+3A_student.matches">student.matches</code></td>
<td>
<p>a list of lists object produced by
<code>matchStudents</code>, with each element of the second list containing a
dataframe composed of a matched sample for a different treated-control
school pairing.</p>
</td></tr>
<tr><td><code id="assembleMatch_+3A_school.match">school.match</code></td>
<td>
<p>a dataframe, produced by <code>matchSchools</code>, with two
columns, one containing treated school IDs and the other containing matched
control school IDs.</p>
</td></tr>
<tr><td><code id="assembleMatch_+3A_school.id">school.id</code></td>
<td>
<p>the name of the column storing the unique school identifier
(in the dataframes stored in <code>student.matches</code>)</p>
</td></tr>
<tr><td><code id="assembleMatch_+3A_treatment">treatment</code></td>
<td>
<p>the name of the column storing the binary treatment status
indicator (in the dataframes stored in <code>student.matches</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe containing the full set of matched samples for the
multilevel match.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='balanceMulti'>Performs balance checking after multilevel matching.</h2><span id='topic+balanceMulti'></span>

<h3>Description</h3>

<p>This function checks balance after multilevel balance. It checks balance on
both level-one (student) and level-two (school) covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceMulti(
  match.obj,
  student.cov = NULL,
  school.cov = NULL,
  include.tests = TRUE,
  single.table = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceMulti_+3A_match.obj">match.obj</code></td>
<td>
<p>A multilevel match object</p>
</td></tr>
<tr><td><code id="balanceMulti_+3A_student.cov">student.cov</code></td>
<td>
<p>Names of student level covariates that you want to check
balance</p>
</td></tr>
<tr><td><code id="balanceMulti_+3A_school.cov">school.cov</code></td>
<td>
<p>Names of school level covariates for which you want to
check balance, if any.</p>
</td></tr>
<tr><td><code id="balanceMulti_+3A_include.tests">include.tests</code></td>
<td>
<p>If TRUE include tests for balance.  FALSE just report
the means and differences.</p>
</td></tr>
<tr><td><code id="balanceMulti_+3A_single.table">single.table</code></td>
<td>
<p>If FALSE include a list of student and school covariates
separately.  TRUE means single balance table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a list which include balance checks for before and
after matching for both level-one and level-two covariates. Balance
statistics include treated and control means, standardized differences, which
is the difference in means divided by the pooled standard deviation before
matching, and p-values for mean differences. It extracts the matched data and
calls 'balanceTable' for student and school level covariates.
</p>


<h3>Value</h3>

<table>
<tr><td><code>students</code></td>
<td>
<p>Balance table for student level covariates, as a
dataframe.</p>
</td></tr> <tr><td><code>schools</code></td>
<td>
<p>Balance table for school level covariates, as a
dataframe.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a> Sam
Pimentel, University of Pennsylvania, <a href="mailto:spi@wharton.upenn.edu">spi@wharton.upenn.edu</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+matchMulti">matchMulti</a></code>, <code><a href="#topic+matchMultisens">matchMultisens</a></code>,
<code><a href="#topic+matchMultioutcome">matchMultioutcome</a></code>, <code><a href="#topic+rematchSchools">rematchSchools</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	## Not run: 
# Load Catholic school data
data(catholic_schools)

student.cov &lt;- c('minority','female','ses','mathach')

# Check balance student balance before matching
balanceTable(catholic_schools[c(student.cov,'sector')],  treatment = 'sector')

#Match schools but not students within schools
match.simple &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = FALSE)

#Check balance after matching - this checks both student and school balance
balanceMulti(match.simple, student.cov = student.cov)

## End(Not run)

</code></pre>

<hr>
<h2 id='balanceTable'>Create Balance Table</h2><span id='topic+balanceTable'></span>

<h3>Description</h3>

<p>Given an unmatched sample of treated and control units and (optionally) a
matched sample from the same data, produces a table with pre- and post-match
measures of covariate balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceTable(
  df.orig,
  df.match = NULL,
  treatment,
  school.id = NULL,
  var.names = NULL,
  include.tests = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceTable_+3A_df.orig">df.orig</code></td>
<td>
<p>a data frame containing the data before matching</p>
</td></tr>
<tr><td><code id="balanceTable_+3A_df.match">df.match</code></td>
<td>
<p>an optional data frame containing the matched sample. Must
have all variable names to be balanced.</p>
</td></tr>
<tr><td><code id="balanceTable_+3A_treatment">treatment</code></td>
<td>
<p>name of the binary indicator for treatment status</p>
</td></tr>
<tr><td><code id="balanceTable_+3A_school.id">school.id</code></td>
<td>
<p>Identifier for groups (for example schools); need to pass if
p-values for balance statistics are desired.</p>
</td></tr>
<tr><td><code id="balanceTable_+3A_var.names">var.names</code></td>
<td>
<p>List of variable names to calculate balance for.  If NULL,
use all variables found in the df.orig data.frame.</p>
</td></tr>
<tr><td><code id="balanceTable_+3A_include.tests">include.tests</code></td>
<td>
<p>Include tests of imbalance on covariates (TRUE/FALSE).</p>
</td></tr>
<tr><td><code id="balanceTable_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether detailed output should be
printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This table can also include p-values for tests of whether the balance is
statistically significant.  These tests assume randomization at the cluster
level.  We recommend looking at the standardized differences rather than
p-values to assess severity of imbalance, however.
</p>
<p>The two tests, for each covariate are (1) Aggregation, where the covariates
are averaged by each cluster, followed by a heteroskedastic robust t-test on
the coefficient of a regression of these averages onto treatment (and
intercept) and (2) cluster robust standard errors for the coefficient of
treatment on a regression of covariate onto treatment (and intercept).
</p>


<h3>Value</h3>

<p>A data.frame of balance measures, with one row for each covariate in
<code>df.orig</code> except <code>treatment</code>, and columns for treated and control
means, standardized differences in means, p-values from two types of
regression for difference in the groups.  See description for further
details. If <code>df.match</code> is specified there are twice as many columns,
one set for the pre-match samples and one set for the post-match samples.
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002). <em>Observational Studies</em>.
Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2010). <em>Design of Observational Studies</em>.
Springer-Verlag.
</p>

<hr>
<h2 id='buildCaliper'>Construct propensity score caliper</h2><span id='topic+buildCaliper'></span>

<h3>Description</h3>

<p>Fits a propensity score for an individual-level or group-level treatment,
computes a caliper for the propensity score (based on a fractional number of
standard deviations provided by the user), and creates a matrix containing
information about which treated-control pairings are excluded by the
caliper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildCaliper(data, treatment, ps.vars, group.id = NULL, caliper = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildCaliper_+3A_data">data</code></td>
<td>
<p>A data frame containing the treatment variable, the variables to
be used in fitting the propensity score and (if treatment is at the group
level) a group ID.</p>
</td></tr>
<tr><td><code id="buildCaliper_+3A_treatment">treatment</code></td>
<td>
<p>Name of the treatment indicator.</p>
</td></tr>
<tr><td><code id="buildCaliper_+3A_ps.vars">ps.vars</code></td>
<td>
<p>Vector of names of variables to use in fitting the propensity
score.</p>
</td></tr>
<tr><td><code id="buildCaliper_+3A_group.id">group.id</code></td>
<td>
<p>Name of group ID variable, if applicable.</p>
</td></tr>
<tr><td><code id="buildCaliper_+3A_caliper">caliper</code></td>
<td>
<p>Desired size of caliper, in number of standard deviations of
the fitted propensity score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>treatment</code> variable should be binary with 1 indicating treated
units and 0 indicating controls.  When <code>group.id</code> is <code>NULL</code>,
treatment is assumed to be at the individual level and the propensity score
is fitted using the matrix <code>data</code>.  When a group ID is specified, data
frame <code>data</code> is first aggregated into groups, with variables in
<code>ps.vars</code> replaced by their within-group means, and the propensity
score is fitted on the group matrix.
</p>


<h3>Value</h3>

<p>A matrix with <code>nrow</code> equal to the number of treated individuals
or groups and <code>ncol</code> equal to the number of control individuals, with
<code>0</code> entries indicating pairings permitted by the caliper and <code>Inf</code>
entries indicating forbidden pairings.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	## Not run: 
# Load Catholic school data
data(catholic_schools)

student.cov &lt;- c('minority','female','ses','mathach')

# Check balance student balance before matching
balanceTable(catholic_schools[c(student.cov,'sector')],  treatment = 'sector')

#fit a propensity score caliper on mean values of student covariates within schools
school.caliper &lt;- buildCaliper(data = catholic_schools, treatment = 'sector',
	ps.vars = student.cov, group.id = 'school')

#Match schools but not students within schools
match.simple &lt;- matchMulti(catholic_schools, treatment = 'sector', 
	school.caliper = school.caliper, school.id = 'school', match.students = FALSE)

#Check balance after matching - this checks both student and school balance
balanceMulti(match.simple, student.cov = student.cov)

## End(Not run)

</code></pre>

<hr>
<h2 id='catholic_schools'>1980 and 1982 High School and Beyond Data</h2><span id='topic+catholic_schools'></span>

<h3>Description</h3>

<p>These data are a subset of the data used in Raudenbush and Bryk (1999) for
multilevel modeling.
</p>


<h3>Format</h3>

<p>A <code>data.frame</code> with 1595 observations on the following
variables.
</p>
<p>school: unique school level identifier
</p>
<p>ses: student level socio-economic status scale ranges from approx. -3.578
to 2.692
</p>
<p>mathach: senior year mathematics test score, outcome measure
</p>
<p>female: student level indicator for sex
</p>
<p>minority: student level indicator for minority
</p>
<p>minority_mean: school level measure of percentage of student body that is
minority
</p>
<p>female_mean: school level measure of percentage of student body that is
female
</p>
<p>ses_mean: school level measure of average level of student socio-economic
status
</p>
<p>sector: treatment indicator 1 if catholic 0 if public
</p>
<p>size: school level measure of total number of enrolled students
</p>
<p>acad: school level measure of the percentage of students on the academic
track
</p>
<p>discrm: school level measure of disciplinary climate ranges from approx.
-2.4 to 2.7
</p>
<p>size_large: school level indicator for schools with more than 1000 students
</p>
<p>minority_mean_large: school level indicator for schools with more than ten
percent minority
</p>


<h3>Source</h3>

<p>Raudenbush, S. W. and Bryk, A. (2002).  <em>Hierarchical Linear
Models: Applications and Data Analysis Methods</em>.  Thousand Oaks, CA: Sage.
</p>


<h3>References</h3>

<p>United States Department of Education. National Center for
Education Statistics.  High School and Beyond, 1980: Sophomore and Senior
Cohort First Follow-Up (1982).
</p>

<hr>
<h2 id='ci_func'>Outcome analysis.</h2><span id='topic+ci_func'></span>

<h3>Description</h3>

<p>Calculates confidence interval via grid search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_func(
  beta,
  obj,
  out.name = NULL,
  schl_id_name = NULL,
  treat.name = NULL,
  alpha,
  alternative = "less"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_func_+3A_beta">beta</code></td>
<td>
<p>Confidence interval value</p>
</td></tr>
<tr><td><code id="ci_func_+3A_obj">obj</code></td>
<td>
<p>a multiMatch object</p>
</td></tr>
<tr><td><code id="ci_func_+3A_out.name">out.name</code></td>
<td>
<p>Name of outcome covariate</p>
</td></tr>
<tr><td><code id="ci_func_+3A_schl_id_name">schl_id_name</code></td>
<td>
<p>Name of school (group) identifier</p>
</td></tr>
<tr><td><code id="ci_func_+3A_treat.name">treat.name</code></td>
<td>
<p>Name of treatment indicator</p>
</td></tr>
<tr><td><code id="ci_func_+3A_alpha">alpha</code></td>
<td>
<p>Level of test for confidence interval, default is .05 for 95%
CI.</p>
</td></tr>
<tr><td><code id="ci_func_+3A_alternative">alternative</code></td>
<td>
<p>Direction of test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The endpoint of an estimated confidence interval.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002). <em>Observational Studies</em>.
Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2010). <em>Design of Observational Studies</em>.
Springer-Verlag.
</p>

<hr>
<h2 id='describe_data_counts'>Print out summary of student and school counts</h2><span id='topic+describe_data_counts'></span>

<h3>Description</h3>

<p>Given a school ID and treatment variable, count up number of schools and
students, print out a summary of the counts of students and
schools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>describe_data_counts(data, school.id, treatment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="describe_data_counts_+3A_data">data</code></td>
<td>
<p>Dataset (student level)</p>
</td></tr>
<tr><td><code id="describe_data_counts_+3A_school.id">school.id</code></td>
<td>
<p>String name of ID column in data (the grouping variable)</p>
</td></tr>
<tr><td><code id="describe_data_counts_+3A_treatment">treatment</code></td>
<td>
<p>String name of the treatment variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of three numbers, # control, # Tx, # Total
</p>


<h3>See Also</h3>

<p>tally_schools
</p>

<hr>
<h2 id='elastic'>Optimal Subset Matching without Balance Constraints</h2><span id='topic+elastic'></span><span id='topic+pairmatchelastic'></span>

<h3>Description</h3>

<p>Conducts optimal subset matching as described in the reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elastic(mdist, n = 0, val = 0)

pairmatchelastic(mdist, n = 0, val = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elastic_+3A_mdist">mdist</code></td>
<td>
<p>distance matrix with rows corresponding to treated units and
columns corresponding to controls.</p>
</td></tr>
<tr><td><code id="elastic_+3A_n">n</code></td>
<td>
<p>maximum number of treated units that can be excluded.</p>
</td></tr>
<tr><td><code id="elastic_+3A_val">val</code></td>
<td>
<p>cost of excluding a treated unit (i.e. we prefer to exclude a
treated unit if it increases the total matched distance by more than
<code>val</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pairmatchelastic</code> is the main function, which conducts an entire match.
<code>elastic</code> is a helper function which augments the original distance
matrix as described in the reference. 
</p>
<p>The original versions of these functions were written by Paul Rosenbaum and
distributed in the supplemental material to the paper: &quot;Optimal Matching of
an Optimally Chosen Subset in Observational Studies,&quot; Paul R. Rosenbaum,
Journal of Computational and Graphical Statistics, Vol. 21, Iss. 1, 2012.
</p>


<h3>Value</h3>

<p><code>elastic</code> returns an augmented version of the input matrix
<code>mdist</code>.  <code>pairmatchelastic</code> returns a matrix of 1 column whose
values are the column numbers of matched controls and whose rownames are
the row numbers of matched treated units.
</p>


<h3>Author(s)</h3>

<p>Paul R. Rosenbaum (original forms), modifications by Luke Keele and
Sam Pimentel
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2012) &quot;Optimal Matching of an Optimally
Chosen Subset in Observational Studies.&quot;  Journal of Computational and
Graphical Statistics, 21.1, 57-71.
</p>

<hr>
<h2 id='handleNA'>Handle Missing Values</h2><span id='topic+handleNA'></span>

<h3>Description</h3>

<p>Preprocesses a dataframe of matching covariates so the Mahalanobis distance
can be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleNA(X, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleNA_+3A_x">X</code></td>
<td>
<p>a matrix or dataframe of covariates to be used for matching</p>
</td></tr>
<tr><td><code id="handleNA_+3A_verbose">verbose</code></td>
<td>
<p>logical value indicating whether detailed output should be
provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Preprocessing involves three main steps: (1) converting factors to matrices
of dummy variables (2) for any variable with NAs, adding an additional
binary variable indicating whether it is missing (3) imputing all NAs with
the column mean.  This follows the recommendations of Rosenbaum in section
9.4 of the referenced text.
</p>


<h3>Value</h3>

<p>a matrix containing the preprocessed data.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2010). <em>Design of Observational
Studies</em>.  Springer-Verlag.
</p>

<hr>
<h2 id='is.binary'>Check if a variable is binary</h2><span id='topic+is.binary'></span>

<h3>Description</h3>

<p>Examines a vector that is not coded as a logical to see if it contains only
0s and 1s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.binary(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.binary_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value, <code>TRUE</code> if the vector contains only 0s and 1s
and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='match2distance'>Compute School Distance from a Student Match</h2><span id='topic+match2distance'></span>

<h3>Description</h3>

<p>Defines a distance between two schools whose students have been matched
based on the size of the resulting matched sample and on the student-level
covariate balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match2distance(
  matchFrame,
  treatFrame,
  ctrlFrame,
  student.vars,
  treatment,
  largeval
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match2distance_+3A_matchframe">matchFrame</code></td>
<td>
<p>dataframe containing all matched students.</p>
</td></tr>
<tr><td><code id="match2distance_+3A_treatframe">treatFrame</code></td>
<td>
<p>dataframe containing all students from the treated school.</p>
</td></tr>
<tr><td><code id="match2distance_+3A_ctrlframe">ctrlFrame</code></td>
<td>
<p>dataframe containing all students from the control school.</p>
</td></tr>
<tr><td><code id="match2distance_+3A_student.vars">student.vars</code></td>
<td>
<p>names of variables on which to evaluate balance in the
matched sample.  Must be present in the column names of each of
<code>matchFrame</code>, <code>treatFrame</code> and <code>ctrlFrame</code>.</p>
</td></tr>
<tr><td><code id="match2distance_+3A_treatment">treatment</code></td>
<td>
<p>name of the treatment variable. Must be present in the
column names of each of <code>matchFrame</code>, <code>treatFrame</code> and
<code>ctrlFrame</code>.</p>
</td></tr>
<tr><td><code id="match2distance_+3A_largeval">largeval</code></td>
<td>
<p>a large penalty value to be added to the distance for each
student-level imbalance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distance is computed by (1) subtracting the harmonic mean of the treated
and control counts in the matched sample from <code>largeval</code> (2) adding
<code>largeval</code> for each covariate among <code>studentvars</code> that has an
absolute standardized difference exceeding 0.2.  This encourages the school
match to choose larger schools with better balance.
</p>


<h3>Value</h3>

<p>a numeric distance.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='matchMulti'>A function that performs multilevel matching.</h2><span id='topic+matchMulti'></span>

<h3>Description</h3>

<p>This is the workhorse function in the package which matches groups and units
within groups. For example, it will match both schools and students in
schools, where the goal is to make units more comparable to estimate
treatment effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchMulti(
  data,
  treatment,
  school.id,
  match.students = TRUE,
  student.vars = NULL,
  school.caliper = NULL,
  school.fb = NULL,
  verbose = FALSE,
  keep.target = NULL,
  student.penalty.qtile = 0.05,
  min.keep.pctg = 0.8,
  school.penalty = NULL,
  save.first.stage = TRUE,
  tol = 10,
  solver = "rlemon"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchMulti_+3A_data">data</code></td>
<td>
<p>A data frame for use in matching.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_treatment">treatment</code></td>
<td>
<p>Name of covariate that defines treated and control groups.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_school.id">school.id</code></td>
<td>
<p>Identifier for groups (for example schools)</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_match.students">match.students</code></td>
<td>
<p>Logical flag for whether units within groups should
also be matched.  If set to <code>FALSE</code>, all units will be retained in
both groups.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_student.vars">student.vars</code></td>
<td>
<p>Names of student level covariates on which to measure
balance.  School-level distances will be penalized when student mathces are
imbalanced on these variables. In addition, when <code>match.students</code> is
<code>TRUE</code>, students are matched on a distance computed from these
covariates.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_school.caliper">school.caliper</code></td>
<td>
<p>matrix with one row for each treated school and one
column for each control school, containing zeroes for pairings allowed by
the caliper and <code>Inf</code> values for forbidden pairings.  When <code>NULL</code>
no caliper is imposed.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_school.fb">school.fb</code></td>
<td>
<p>A list of discrete group-level covariates on which to
enforce fine balance, i.e., ensure marginal distributions are balanced.
First group is most important, second is second most, etc.  If a simple
list of variable names, one group is assumed.  A list of list will give
this hierarchy.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_verbose">verbose</code></td>
<td>
<p>Logical flag for whether to give detailed output.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_keep.target">keep.target</code></td>
<td>
<p>an optional numeric value specifying the number of treated
schools desired in the final match.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_student.penalty.qtile">student.penalty.qtile</code></td>
<td>
<p>This helps exclude students if they are
difficult to match. Default is 0.05, which implies that in the match we
would prefer to exclude students rather than match them at distances larger
than this quantile of the overall student-student robust Mahalanobis
distance distribution</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_min.keep.pctg">min.keep.pctg</code></td>
<td>
<p>Minimum percentage of students (from smaller school) to
keep when matching students in each school pair.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_school.penalty">school.penalty</code></td>
<td>
<p>A penalty to remove groups (schools) in the group
(school) match</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_save.first.stage">save.first.stage</code></td>
<td>
<p>Should first stage matches be saved.</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_tol">tol</code></td>
<td>
<p>a numeric tolerance value for comparing distances, used in the
school match.  It may need to be raised above the default when matching 
with many levels of refined balance or in very large problems (when these
distances will often be  at least on the order of the tens of 
thousands).</p>
</td></tr>
<tr><td><code id="matchMulti_+3A_solver">solver</code></td>
<td>
<p>Name of package used to solve underlying network flow problem
for the school match, one of 'rlemon' and 'rrelaxiv'.  rrelaxiv carries an 
academic license and is not hosted on CRAN so it must be installed 
separately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>matchMulti</code> first matches students (or other individual units) within
each pairwise combination of schools (or other groups); based on these
matches a distance matrix is generated for the schools.  Then schools are
matched on this distance matrix and the student matches for the selected
school pairs are combined into a single matched sample.
</p>
<p>School covariates are not used to compute the distance matrix for schools
(since it is generated from the student match).  Instead imbalances in school
covariates should be addressed through the<code>school.fb</code> argument, which
encodes a refined covariate balance constraint. School covariates in
<code>school.fb</code> should be given in order of priority for balance, since the
matching algorithm optimally balances the variables in the first list
element, then attempts to further balance the those in the second element,
and so on.
</p>


<h3>Value</h3>

<table>
<tr><td><code>raw</code></td>
<td>
<p>The unmatched data before matching.</p>
</td></tr> <tr><td><code>matched</code></td>
<td>
<p>The
matched dataset of both units and groups. Outcome analysis and balance
checks are peformed on this item.</p>
</td></tr> <tr><td><code>school.match</code></td>
<td>
<p>Object with two
parts. The first lists which treated groups (schools) are matched to which
control groups. The second lists the population of groups used in the
match.</p>
</td></tr> <tr><td><code>school.id</code></td>
<td>
<p>Name of school identifier</p>
</td></tr> <tr><td><code>treatment</code></td>
<td>
<p>Name
of treatment variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+matchMulti">matchMulti</a></code>, <code><a href="#topic+matchMultisens">matchMultisens</a></code>,
<code><a href="#topic+balanceMulti">balanceMulti</a></code>, <code><a href="#topic+matchMultioutcome">matchMultioutcome</a></code>,
<code><a href="#topic+rematchSchools">rematchSchools</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#toy example with short runtime
library(matchMulti)

#Load Catholic school data
data(catholic_schools)

# Trim data to speed up example
catholic_schools &lt;- catholic_schools[catholic_schools$female_mean &gt;.45 &amp;
 catholic_schools$female_mean &lt; .60,]

#match on a single covariate
student.cov &lt;- c('minority')

 match.simple &lt;- 
matchMulti(catholic_schools, treatment = 'sector',
                             school.id = 'school', match.students = FALSE,
                             student.vars = student.cov, verbose=TRUE, tol=.01)

#Check balance after matching - this checks both student and school balance
  balanceMulti(match.simple, student.cov = student.cov)


## Not run: 
#larger example
data(catholic_schools)

student.cov &lt;- c('minority','female','ses')

# Check balance student balance before matching
balanceTable(catholic_schools[c(student.cov,'sector')],  treatment = 'sector')

#Match schools but not students within schools
match.simple &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = FALSE)

#Check balance after matching - this checks both student and school balance
balanceMulti(match.simple, student.cov = student.cov)

#Estimate treatment effect
output &lt;- matchMultioutcome(match.simple, out.name = "mathach",
schl_id_name = "school",  treat.name = "sector")

# Perform sensitivity analysis using Rosenbaum bound -- increase Gamma to increase effect of
# possible hidden confounder
matchMultisens(match.simple, out.name = "mathach",
          schl_id_name = "school",
          treat.name = "sector", Gamma = 1.3)


# Now match both schools and students within schools
match.out &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = TRUE, student.vars = student.cov)

# Check balance again
bal.tab &lt;- balanceMulti(match.out, student.cov = student.cov)

# Now match with fine balance constraints on whether the school is large
# or has a high percentage of minority students
match.fb &lt;- matchMulti(catholic_schools, treatment = 'sector', school.id = 'school',
match.students = TRUE, student.vars = student.cov,
school.fb = list( c('size_large'), c('minority_mean_large') )

# Estimate treatment effects
matchMultioutcome(match.fb, out.name = "mathach", schl_id_name = "school",  treat.name = "sector")

#Check Balance
balanceMulti(match.fb, student.cov = student.cov)


## End(Not run)


</code></pre>

<hr>
<h2 id='matchMultioutcome'>Performs an outcome analysis after multilevel matching.</h2><span id='topic+matchMultioutcome'></span>

<h3>Description</h3>

<p>This function returns a point estimate, 95% confidence interval, and
p-values for the matched multilevel data. All results are based on
randomization inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchMultioutcome(
  obj,
  out.name = NULL,
  schl_id_name = NULL,
  treat.name = NULL,
  end.1 = -1000,
  end.2 = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchMultioutcome_+3A_obj">obj</code></td>
<td>
<p>A multilevel match object.</p>
</td></tr>
<tr><td><code id="matchMultioutcome_+3A_out.name">out.name</code></td>
<td>
<p>Outcome variable name</p>
</td></tr>
<tr><td><code id="matchMultioutcome_+3A_schl_id_name">schl_id_name</code></td>
<td>
<p>Level 2 ID variabel name. This variable identifies the
clusters in the data that you want to match.</p>
</td></tr>
<tr><td><code id="matchMultioutcome_+3A_treat.name">treat.name</code></td>
<td>
<p>Treatment variable name, must be zero or one.</p>
</td></tr>
<tr><td><code id="matchMultioutcome_+3A_end.1">end.1</code></td>
<td>
<p>Lower bound for point estimate search, default is -1000.</p>
</td></tr>
<tr><td><code id="matchMultioutcome_+3A_end.2">end.2</code></td>
<td>
<p>Upper bound for point estimate search, default is 1000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It may be necessary to adjust the lower and upper bounds if one expects the
treatment effect confidence interval to be outside the range of -1000 or
1000.
</p>


<h3>Value</h3>

<table>
<tr><td><code>pval.c</code></td>
<td>
<p>One-sided approximate p-value for test of the sharp
null.</p>
</td></tr> <tr><td><code>pval.p</code></td>
<td>
<p>One-sided approximate p-value for test of the sharp
null assuming treatment effects vary with cluster size</p>
</td></tr> <tr><td><code>ci1</code></td>
<td>
<p>Lower
bound for 95% confidence interval.</p>
</td></tr> <tr><td><code>ci2</code></td>
<td>
<p>Upper bound for 95%
confidence interval.</p>
</td></tr> <tr><td><code>p.est</code></td>
<td>
<p>Point estimate for the group level
treatment effect.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, ljk20@psu.edu
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002) Observational Studies.
Springer-Verlag.
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+matchMulti">matchMulti</a></code>, <code><a href="#topic+matchMultisens">matchMultisens</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
	## Not run: 
# Load Catholic school data
data(catholic_schools)

student.cov &lt;- c('minority','female','ses','mathach')

# Check balance student balance before matching
balanceTable(catholic_schools[c(student.cov,'sector')],  treatment = 'sector')

#Match schools but not students within schools
match.simple &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = FALSE)

#Check balance after matching - this checks both student and school balance
balanceMulti(match.simple, student.cov = student.cov)

#Estimate treatment effect
output &lt;- matchMultioutcome(match.simple, out.name = "mathach",
schl_id_name = "school",  treat.name = "sector")

  
## End(Not run)

</code></pre>

<hr>
<h2 id='matchMultiResult'>matchMultiResult object for results of power calculations</h2><span id='topic+matchMultiResult'></span><span id='topic+is.matchMultiResult'></span><span id='topic+print.matchMultiResult'></span><span id='topic+summary.matchMultiResult'></span>

<h3>Description</h3>

<p>The matchMultiResult object is an S3 class that holds the results from the matchMulti call.
</p>
<p>matchMulti result objects have the matched datasets inside of them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.matchMultiResult(x)

## S3 method for class 'matchMultiResult'
print(x, ...)

## S3 method for class 'matchMultiResult'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchMultiResult_+3A_x">x</code></td>
<td>
<p>a matchMultiResult object (except for is.matchMultiResult, where it is a generic
object to check).</p>
</td></tr>
<tr><td><code id="matchMultiResult_+3A_...">...</code></td>
<td>
<p>Extra options passed to print.matchMultiResult</p>
</td></tr>
<tr><td><code id="matchMultiResult_+3A_object">object</code></td>
<td>
<p>Object to summarize.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is.matchMultiResult: TRUE if object is a matchMultiResult object.
</p>

<hr>
<h2 id='matchMultisens'>Rosenbaum Bounds after Multilevel Matching</h2><span id='topic+matchMultisens'></span>

<h3>Description</h3>

<p>Function to calculate Rosenbaum bounds for continuous outcomes after
multilevel matching.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchMultisens(
  obj,
  out.name = NULL,
  schl_id_name = NULL,
  treat.name = NULL,
  Gamma = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchMultisens_+3A_obj">obj</code></td>
<td>
<p>A multilevel match object</p>
</td></tr>
<tr><td><code id="matchMultisens_+3A_out.name">out.name</code></td>
<td>
<p>Outcome variable name</p>
</td></tr>
<tr><td><code id="matchMultisens_+3A_schl_id_name">schl_id_name</code></td>
<td>
<p>Level 2 ID variable name, that is this variable
identifies clusters matched in the data.</p>
</td></tr>
<tr><td><code id="matchMultisens_+3A_treat.name">treat.name</code></td>
<td>
<p>Treatment indicator name</p>
</td></tr>
<tr><td><code id="matchMultisens_+3A_gamma">Gamma</code></td>
<td>
<p>Sensitivity analysis parameter value. Default is one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a single p-value, but actually conducts two tests.
The first assumes that the treatment effect does not vary with cluster size.
The second allows the treatment effect to vary with cluster size.  The
function returns a single p-value that is corrected for multiple testing.
This p-value is the upper bound for a single Gamma value
</p>


<h3>Value</h3>

<table>
<tr><td><code>pval</code></td>
<td>
<p>Upper bound on one-sided approximate p-value for test of the
sharp null.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luke Keele, University of Pennsylvania, <a href="mailto:luke.keele@gmail.com">luke.keele@gmail.com</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002) Observational Studies.
Springer-Verlag.
</p>


<h3>See Also</h3>

<p>See Also as <code><a href="#topic+matchMulti">matchMulti</a></code>,
<code><a href="#topic+matchMultioutcome">matchMultioutcome</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Load Catholic school data
data(catholic_schools)

student.cov &lt;- c('minority','female','ses','mathach')

# Check balance student balance before matching
balanceTable(catholic_schools[c(student.cov,'sector')],  treatment = 'sector')

#Match schools but not students within schools
match.simple &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = FALSE)

#Check balance after matching - this checks both student and school balance
balanceMulti(match.simple, student.cov = student.cov)

#Estimate treatment effect
output &lt;- matchMultioutcome(match.simple, out.name = "mathach",
schl_id_name = "school",  treat.name = "sector")

# Perform sensitivity analysis using Rosenbaum bound -- increase Gamma to increase effect of
# possible hidden confounder 
         
matchMultisens(match.simple, out.name = "mathach",
          schl_id_name = "school", 
          treat.name = "sector", Gamma=1.3)
          
          
## End(Not run)

</code></pre>

<hr>
<h2 id='matchSchools'>Match Schools on Student-based Distance</h2><span id='topic+matchSchools'></span>

<h3>Description</h3>

<p>Takes in a school distance matrix created using information from the
first-stage student match and matches schools optimally, potentially
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchSchools(
  dmat,
  students,
  treatment,
  school.id,
  school.fb,
  penalty,
  verbose,
  tol,
  solver = "rlemon"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchSchools_+3A_dmat">dmat</code></td>
<td>
<p>a distance matrix for schools, with a row for each treated
school and a column for each control school.</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_students">students</code></td>
<td>
<p>a dataframe containing student and school covariates, with a
different row for each student.</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_treatment">treatment</code></td>
<td>
<p>the column name of the binary treatment status indicator in
the <code>students</code> dataframe.</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_school.id">school.id</code></td>
<td>
<p>the column name of the unique school ID in the
<code>students</code> dataframe.</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_school.fb">school.fb</code></td>
<td>
<p>an optional list of character vectors, each containing a
subset of the column names of <code>students</code>.  Each element of the list
should contain all the names in previous elements (producing a nested
structure).</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_penalty">penalty</code></td>
<td>
<p>a numeric value, treated as the cost to the objective
function of excluding a treated school.  If it is set lower, more schools
will be excluded.</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether detailed output should be
printed.</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_tol">tol</code></td>
<td>
<p>a numeric tolerance value for comparing distances.  It may need
to be raised above the default when matching with many levels of refined
balance.</p>
</td></tr>
<tr><td><code id="matchSchools_+3A_solver">solver</code></td>
<td>
<p>Name of package used to solve underlying network flow problem, 
one of 'rlemon' and 'rrelaxiv'.  rrelaxiv carries an 
academic license and is not hosted on CRAN so it must be installed 
separately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>school.fb</code> argument encodes a refined covariate balance
constraint: the matching algorithm optimally balances the interaction of the
variables in the first list element, then attempts to further balance the
interaction in the second element, and so on.  As such variables should be
added in order of priority for balance.
</p>


<h3>Value</h3>

<p>a dataframe with two columns, one containing treated school IDs and
the other containing matched control school IDs.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='matchStudents'>Compute Student Matches for all Pairs of Schools</h2><span id='topic+matchStudents'></span>

<h3>Description</h3>

<p>Iterates over all possible treated-control school pairs, optionally computes
and stores an optimal student match for each one, and generates a distance
matrix for schools based on the quality of each student match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchStudents(
  students,
  treatment,
  school.id,
  match.students,
  student.vars,
  school.caliper = NULL,
  verbose,
  penalty.qtile,
  min.keep.pctg
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchStudents_+3A_students">students</code></td>
<td>
<p>a dataframe containing student covariates, with a different
row for each student.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_treatment">treatment</code></td>
<td>
<p>the column name of the binary treatment status indicator in
the <code>students</code> dataframe.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_school.id">school.id</code></td>
<td>
<p>the column name of the unique school ID in the
<code>students</code> dataframe.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_match.students">match.students</code></td>
<td>
<p>logical value.  If <code>TRUE</code>, students are matched
within school pairs and some students will be excluded.  If <code>FALSE</code>,
all students will be retained in the matched sample for each school pair.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_student.vars">student.vars</code></td>
<td>
<p>column names of variables in <code>students</code> on which to
match students and assess balance of student matches in evaluating match
quality.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_school.caliper">school.caliper</code></td>
<td>
<p>matrix with one row for each treated school and one
column for each control school, containing zeroes for pairings allowed by
the caliper and <code>Inf</code> values for forbidden pairings.  When <code>NULL</code>
no caliper is imposed.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether detailed output should be
printed.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_penalty.qtile">penalty.qtile</code></td>
<td>
<p>a numeric value between 0 and 1 specifying a quantile
of the distribution of all student-student matching distances.  The
algorithm will prefer to exclude treated students rather than form pairs
with distances exceeding this quantile.</p>
</td></tr>
<tr><td><code id="matchStudents_+3A_min.keep.pctg">min.keep.pctg</code></td>
<td>
<p>a minimum percentage of students in the smaller school
in a pair which must be retained, even when treated students are excluded.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>penalty.qtile</code> and <code>min.keep.pctg</code> control the rate at which
students are trimmed from the match.  If the quantile is high enough no
students should be excluded in any match; if the quantile is very low the
<code>min.keep.pctg</code> can still ensure a minimal sample size in each match.
</p>


<h3>Value</h3>

<p>A list with two elements: </p>
<table>
<tr><td><code>student.matches</code></td>
<td>
<p> a list with one
element for each treated school.  Each element is a list with one element
for each control school, and each element of these secondary lists is a
dataframe containing the matched sample for the corresponding
treated-control pairing. </p>
</td></tr> <tr><td><code>schools.matrix</code></td>
<td>
<p> a matrix with one row for
each treated school and one column for each control school, giving matching
distances based on the student match. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='minischool'>Mini-data set for illustration</h2><span id='topic+minischool'></span>

<h3>Description</h3>

<p>The Catholic schools dataset subset to a smaller number of
schools (with only 6 Catholic schools).  See full dataset documentation for
more information.
</p>


<h3>Format</h3>

<p>A data frame with 1500 rows and 12 variables, as described in the
'catholic_schools' dataset.
</p>


<h3>Source</h3>

<p>See documentation page for 'catholic_schools' dataset.
</p>


<h3>See Also</h3>

<p>catholic_schools
</p>

<hr>
<h2 id='pe_func'>Outcome analysis.</h2><span id='topic+pe_func'></span>

<h3>Description</h3>

<p>Calculates Hodges-Lehmann point estimate for treatment effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pe_func(beta, obj, out.name = NULL, schl_id_name = NULL, treat.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pe_func_+3A_beta">beta</code></td>
<td>
<p>Point estimate value</p>
</td></tr>
<tr><td><code id="pe_func_+3A_obj">obj</code></td>
<td>
<p>A multiMatch object</p>
</td></tr>
<tr><td><code id="pe_func_+3A_out.name">out.name</code></td>
<td>
<p>Name of outcome covariate</p>
</td></tr>
<tr><td><code id="pe_func_+3A_schl_id_name">schl_id_name</code></td>
<td>
<p>Name of school (group) identifier</p>
</td></tr>
<tr><td><code id="pe_func_+3A_treat.name">treat.name</code></td>
<td>
<p>Name of treatment indicator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A point estimate for constant-additive treatment effect.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002). <em>Observational Studies</em>.
Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2010). <em>Design of Observational Studies</em>.
Springer-Verlag.
</p>

<hr>
<h2 id='pval_func'>Outcome analysis.</h2><span id='topic+pval_func'></span>

<h3>Description</h3>

<p>Calcualtes p-values for test of sharp null for treatment effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pval_func(
  obj,
  out.name = NULL,
  schl_id_name = NULL,
  treat.name = NULL,
  wt = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pval_func_+3A_obj">obj</code></td>
<td>
<p>A multiMatch object</p>
</td></tr>
<tr><td><code id="pval_func_+3A_out.name">out.name</code></td>
<td>
<p>Name of outcome covariate</p>
</td></tr>
<tr><td><code id="pval_func_+3A_schl_id_name">schl_id_name</code></td>
<td>
<p>Name of school (group) identifier</p>
</td></tr>
<tr><td><code id="pval_func_+3A_treat.name">treat.name</code></td>
<td>
<p>Name of treatment indicator</p>
</td></tr>
<tr><td><code id="pval_func_+3A_wt">wt</code></td>
<td>
<p>Logical flag for whether p-value should weight strata by size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A p-value for constant-additive treatment effect.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002). <em>Observational Studies</em>.
Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2010). <em>Design of Observational Studies</em>.
Springer-Verlag.
</p>

<hr>
<h2 id='rematchSchools'>Repeat School Match Only</h2><span id='topic+rematchSchools'></span>

<h3>Description</h3>

<p>After <code>matchMulti</code> has been called, repeats the school match (with
possibly different parameters) without repeating the more computationally
intensive student match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rematchSchools(
  match.out,
  students,
  school.fb = NULL,
  verbose = FALSE,
  keep.target = NULL,
  school.penalty = NULL,
  tol = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rematchSchools_+3A_match.out">match.out</code></td>
<td>
<p>an object returned by a call to <code>matchMulti</code>.</p>
</td></tr>
<tr><td><code id="rematchSchools_+3A_students">students</code></td>
<td>
<p>a dataframe containing student and school covariates, with a
different row for each student.</p>
</td></tr>
<tr><td><code id="rematchSchools_+3A_school.fb">school.fb</code></td>
<td>
<p>an optional list of character vectors, each containing a
subset of the column names of <code>students</code>.  Each element of the list
should contain all the names in previous elements (producing a nested
structure).</p>
</td></tr>
<tr><td><code id="rematchSchools_+3A_verbose">verbose</code></td>
<td>
<p>a logical value indicating whether detailed output should be
printed.</p>
</td></tr>
<tr><td><code id="rematchSchools_+3A_keep.target">keep.target</code></td>
<td>
<p>an optional numeric value specifying the number of
treated schools desired in the final match.</p>
</td></tr>
<tr><td><code id="rematchSchools_+3A_school.penalty">school.penalty</code></td>
<td>
<p>an optional numeric value, treated as the cost (to the
objective function in the underlying optimization problem) of excluding a
treated school.  If it is set lower, more schools will be excluded.</p>
</td></tr>
<tr><td><code id="rematchSchools_+3A_tol">tol</code></td>
<td>
<p>a numeric tolerance value for comparing distances.  It may need
to be raised above the default when matching with many levels of refined
balance.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>school.fb</code> argument encodes a refined covariate balance
constraint: the matching algorithm optimally balances the interaction of the
variables in the first list element, then attempts to further balance the
interaction in the second element, and so on.  As such variables should be
added in order of priority for balance.
</p>
<p>The <code>keep.target</code> and <code>school.penalty</code> parameters allow optimal
subset matching within the school match. When the <code>keep.target</code>
argument is specified, the school match is repeated for different values of
the <code>school.penalty</code> parameter in a form of binary search until an
optimal match is obtained with the desired number of treated schools or a
stopping rule is reached.  The <code>tol</code> parameter controls the stopping
rule; smaller values provide a stronger guarantee of obtaining the exact
number of treated schools desired but may lead to greater computational
costs.
</p>
<p>It is not recommended that users specify the <code>school.penalty</code> parameter
directly in most cases.  Instead the <code>keep.target</code> parameter provides
an easier way to consider excluding schools.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002). <em>Observational Studies</em>.
Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2010). <em>Design of Observational Studies</em>.
Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2012) &quot;Optimal Matching of an Optimally Chosen Subset in
Observational Studies.&quot;  Journal of Computational and Graphical Statistics,
21.1, 57-71.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+matchMulti">matchMulti</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Load Catholic school data
data(catholic_schools)

student.cov &lt;- c('minority','female','ses')
school.cov &lt;- c('minority_mean','female_mean', 'ses_mean', 'size', 'acad')

#Match schools but not students within schools
match.simple &lt;- matchMulti(catholic_schools, treatment = 'sector',
school.id = 'school', match.students = FALSE)

#Check balance after matching - this checks both student and school balance
balanceMulti(match.simple, student.cov = student.cov, school.cov = school.cov)

#now rematch excluding 2 schools
match.trimmed &lt;- rematchSchools(match.simple, catholic_schools, keep.target = 13)
match.trimmed$dropped$schools.t

## End(Not run)

</code></pre>

<hr>
<h2 id='resolve.cols'>Ensure Dataframes Share Same Set Columns</h2><span id='topic+resolve.cols'></span>

<h3>Description</h3>

<p>Takes in two dataframes.  For each column name that is in the second frame
but not in the first frame, a new column of zeroes is added to the first
frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve.cols(df1, df2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve.cols_+3A_df1">df1</code></td>
<td>
<p>a dataframe.</p>
</td></tr>
<tr><td><code id="resolve.cols_+3A_df2">df2</code></td>
<td>
<p>a dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='sdiff'>Balance Measures</h2><span id='topic+sdiff'></span><span id='topic+ttest.balance'></span><span id='topic+fisher.balance'></span><span id='topic+wilc.balance'></span>

<h3>Description</h3>

<p>Balance assessment for individual variables, before and after matching
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdiff(varname, treatment, orig.data, match.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdiff_+3A_varname">varname</code></td>
<td>
<p>name of the variable on which to test balance</p>
</td></tr>
<tr><td><code id="sdiff_+3A_treatment">treatment</code></td>
<td>
<p>name of the binary indicator for treatment status</p>
</td></tr>
<tr><td><code id="sdiff_+3A_orig.data">orig.data</code></td>
<td>
<p>a data frame containing the data before matching</p>
</td></tr>
<tr><td><code id="sdiff_+3A_match.data">match.data</code></td>
<td>
<p>an optional data frame containing the matched sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sdiff</code> function computes the standardized difference in means. The
other functions perform different kinds of balance tests: <code>t.balance</code>
does the 2-sample t-test, <code>fisher.balance</code> does Fisher's exact test for
binary variable, and <code>wilc.balance</code> does Wilcoxon's signed rank test.
</p>


<h3>Value</h3>

<p>a labeled vector.  For <code>sdiff</code>, the vector has six elements if
<code>match.data</code> is provided: treated and control means and standardized
differences before and after matching.  If <code>match.data</code> is not
provided, the vector has only the three elements corresponding to the
pre-match case.
</p>
<p>For the other functions, if <code>match.data</code> is provided, the vector
contains p-values for the test before and after matching. Otherwise a
single p-value is given for the pre-match data.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2002). <em>Observational Studies</em>.
Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2010). <em>Design of Observational Studies</em>.
Springer-Verlag.
</p>

<hr>
<h2 id='smahal'>Robust Mahalanobis Distance</h2><span id='topic+smahal'></span>

<h3>Description</h3>

<p>Computes robust Mahalanobis distance between treated and control units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smahal(z, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smahal_+3A_z">z</code></td>
<td>
<p>vector of treatment indicators (1 for treated, 0 for controls).</p>
</td></tr>
<tr><td><code id="smahal_+3A_x">X</code></td>
<td>
<p>matrix of numeric variables to be used for computing the
Mahalanobis distance.  Row count must match length of <code>z</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an explanation of the robust Mahalanobis distance, see section 8.3 of
the first reference.  This function was written by Paul Rosenbaum and
distributed in the supplemental material to the second reference.
</p>


<h3>Value</h3>

<p>a matrix of robust Mahalanobis distances, with a row for each
treated unit and a column for each control.
</p>


<h3>Author(s)</h3>

<p>Paul R. Rosenbaum.
</p>


<h3>References</h3>

<p>Rosenbaum, Paul R. (2010). <em>Design of Observational
Studies</em>.  Springer-Verlag.
</p>
<p>Rosenbaum, Paul R. (2012) &quot;Optimal Matching of an Optimally Chosen Subset in
Observational Studies.&quot;  Journal of Computational and Graphical Statistics,
21.1, 57-71.
</p>

<hr>
<h2 id='students2schools'>Aggregate Student Data into School Data</h2><span id='topic+students2schools'></span>

<h3>Description</h3>

<p>Takes a dataframe of student-level covariates and aggregates selected
columns into a dataframe of school covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>students2schools(students, school.cov, school.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="students2schools_+3A_students">students</code></td>
<td>
<p>a dataframe of students.</p>
</td></tr>
<tr><td><code id="students2schools_+3A_school.cov">school.cov</code></td>
<td>
<p>a character vector of column names in <code>students</code> that
should be aggregated by school.</p>
</td></tr>
<tr><td><code id="students2schools_+3A_school.id">school.id</code></td>
<td>
<p>the name of the column in <code>students</code> containing the
unique school identifier.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Aggregation is either done by taking averages or by selecting the unique
factor value when a school has only one value for a factor.  As a result,
<code>school.covs</code> should only include variables that are numeric or do not
vary within schools.
</p>


<h3>Value</h3>

<p>a dataframe of aggregated data, with one row for each school and
columns in <code>school.covs</code> and <code>school.id</code>.
</p>


<h3>Author(s)</h3>

<p>Luke Keele, Penn State University, <a href="mailto:ljk20@psu.edu">ljk20@psu.edu</a>
</p>
<p>Sam Pimentel, University of California, Berkeley, <a href="mailto:spi@berkeley.edu">spi@berkeley.edu</a>
</p>

<hr>
<h2 id='tally_schools'>Tally schools and students in a given dataset</h2><span id='topic+tally_schools'></span>

<h3>Description</h3>

<p>Returns a count of schools, without printing
anything.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tally_schools(data, school.id, treatment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tally_schools_+3A_data">data</code></td>
<td>
<p>Dataset (student level)</p>
</td></tr>
<tr><td><code id="tally_schools_+3A_school.id">school.id</code></td>
<td>
<p>String name of ID column in data (the grouping variable)</p>
</td></tr>
<tr><td><code id="tally_schools_+3A_treatment">treatment</code></td>
<td>
<p>String name of the treatment variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of two things: school and student counts (invisible).
</p>


<h3>Author(s)</h3>

<p>Luke Miratrix
</p>


<h3>See Also</h3>

<p>describe_data_counts
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
