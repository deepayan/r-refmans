<!DOCTYPE html><html lang="en"><head><title>Help for package mosum</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mosum}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bandwidths.default'><p>Default choice for the set of multiple bandwidths</p></a></li>
<li><a href='#bootstrapped_timeSeries'><p>Obtain bootstrap replicate of time series</p></a></li>
<li><a href='#comb_contains_cpt'><p>Does the combination comb of changepoints contain the changepoint k_ind?</p></a></li>
<li><a href='#confint.mosum.cpts'><p>Confidence intervals for change points</p></a></li>
<li><a href='#confint.multiscale.cpts'><p>Confidence intervals for change points</p></a></li>
<li><a href='#cpts_bootstrap'><p>Helping/wrapper fuction for C++ calls</p></a></li>
<li><a href='#cpts_bootstrap_help'><p>Helping function to get bootstrap replicates of change point estimates</p></a></li>
<li><a href='#detect.interval'><p>Final detection interval</p></a></li>
<li><a href='#dup.merge'><p>Remove duplicated from all.cpts data frame:</p>
In case one change being added multiple times, choose the one
with smallest p-value</a></li>
<li><a href='#eta_criterion_help'><p>extract changepoints from candidates with eta criterion</p></a></li>
<li><a href='#exhaust_sc'><p>Algorithm II (Local change-point search with SC)</p></a></li>
<li><a href='#extract_sub'><p>Helping function for algorithm 2: Pre-compute the partial sums</p>
S_i = sumj=k_i+1^k_i+1x_i and the partial sums of squared
T_i = sumj=k_i+1^k_i+1x_i^2
between the (sorted) candidates k_i and k_i+1 in cand.
Output: data frame with 4 columns k_i | k_i+1 | S_i | T_i</a></li>
<li><a href='#get_comb_ind'><p>Get integer vector of changepoint indices,</p>
based on bool-field representation of combinations.
E.g. for combination index 11 [=1011]: get_comb_ind(c(T,F,T,T))=11</a></li>
<li><a href='#get_k_star'><p>Compute bootstrapped mosum statistic and return maximum position thereof</p></a></li>
<li><a href='#get_local_costs'><p>Compute the Local cost terms of combination icomb (for RSS resp. sBIC).</p>
Use pre-computed partial sum matrix sub_sums (see extract_sub) for speedup</a></li>
<li><a href='#is_child'><p>Is index i_child a child of index i_parent?</p>
ASSERT: i_child is of the form (i_parent XOR i_help),
with i_help having exactly one non-zero bit</a></li>
<li><a href='#local.env'><p>Identify the local environment for exhaustive search</p></a></li>
<li><a href='#local.prune'><p>Localised pruning algorithm</p></a></li>
<li><a href='#mean_help'><p>helping function for bootstrap (compute local means)</p></a></li>
<li><a href='#modelSignal.blocks'><p>Creating Time-Series according to example model</p></a></li>
<li><a href='#modelSignal.fms'><p>Creating Time-Series according to example model</p></a></li>
<li><a href='#modelSignal.mix'><p>Creating Time-Series according to example model</p></a></li>
<li><a href='#modelSignal.stairs10'><p>Creating Time-Series according to example model</p></a></li>
<li><a href='#modelSignal.teeth10'><p>Creating Time-Series according to example model</p></a></li>
<li><a href='#mosum'><p>MOSUM procedure for multiple change point estimation</p></a></li>
<li><a href='#mosum.asymptoticA'><p>Help function: asymptotic scaling.</p></a></li>
<li><a href='#mosum.asymptoticB'><p>Help function: asymptotic shift</p></a></li>
<li><a href='#mosum.criticalValue'><p>MOSUM asymptotic critical value</p></a></li>
<li><a href='#mosum.pValue'><p>MOSUM asymptotic p-value</p></a></li>
<li><a href='#mosum.stat'><p>MOSUM statistic</p></a></li>
<li><a href='#multiscale.bottomUp'><p>Multiscale MOSUM algorithm with bottom-up merging</p></a></li>
<li><a href='#multiscale.grid'><p>Multiscale bandwidth grids</p></a></li>
<li><a href='#multiscale.localPrune'><p>Multiscale MOSUM algorithm with localised pruning</p></a></li>
<li><a href='#next_bit_permutation'><p>Next value to iterate (in lexicographical order) over all bit</p>
permutaions having l bits set to 1.
Example sequence (2 bits): 0011, 0101, 0110, 1001, 1010, 1100.
Source: https://stackoverflow.com/questions/1851134/generate-all-binary-strings-of-length-n-with-k-bits-set</a></li>
<li><a href='#numberOfSetBits'><p>Get number of non-zero bits of a 32bit integer</p>
Source: https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer</a></li>
<li><a href='#persp3D.multiscaleMosum'><p>3D Visualisation of multiscale MOSUM statistics</p></a></li>
<li><a href='#plot.mosum.cpts'><p>Plotting the output from MOSUM procedure</p></a></li>
<li><a href='#plot.mosum.stat'><p>Plotting MOSUM statistics</p></a></li>
<li><a href='#plot.multiscale.cpts'><p>Plotting the output from multiscale MOSUM procedure</p></a></li>
<li><a href='#print.mosum.cpts'><p>Change points estimated by MOSUM procedure</p></a></li>
<li><a href='#print.multiscale.cpts'><p>Change points estimated by multiscale MOSUM procedure</p></a></li>
<li><a href='#rolling_sum'><p>equivalent to rollsum(x, k=G, fill=NA, align=&quot;left&quot;) in the package zoo,</p>
but optimized for speed</a></li>
<li><a href='#setBitNumber'><p>where is leftmost one?</p>
https://www.geeksforgeeks.org/find-significant-set-bit-number/</a></li>
<li><a href='#start_bit_permutations'><p>Starting value to iterate (in lexicographical order)</p>
over all bit permutaions having l bits set to 1.
E.g.: start_bit_permutations(2) = 3 [=0..011].</a></li>
<li><a href='#summary.mosum.cpts'><p>Summary of change points estimated by MOSUM procedure</p></a></li>
<li><a href='#summary.multiscale.cpts'><p>Summary of change points estimated by multiscale MOSUM procedure</p></a></li>
<li><a href='#testData'><p>Test data with piecewise constant mean</p></a></li>
<li><a href='#testSignal'><p>Piecewise constant test signal</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Moving Sum Based Procedures for Changes in the Mean</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of MOSUM-based statistical procedures and algorithms for detecting multiple changes in the mean. This comprises the MOSUM procedure for estimating multiple mean changes from Eichinger and Kirch (2018) &lt;<a href="https://doi.org/10.3150%2F16-BEJ887">doi:10.3150/16-BEJ887</a>&gt; and the multiscale algorithmic extension from Cho and Kirch (2022) &lt;<a href="https://doi.org/10.1007%2Fs10463-021-00811-5">doi:10.1007/s10463-021-00811-5</a>&gt;, as well as the bootstrap procedure for generating confidence intervals about the locations of change points as proposed in Cho and Kirch (2022) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2022.107552">doi:10.1016/j.csda.2022.107552</a>&gt;. See also Meier, Kirch and Cho (2021) &lt;<a href="https://doi.org/10.18637%2Fjss.v097.i08">doi:10.18637/jss.v097.i08</a>&gt; which accompanies the R package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, RColorBrewer, plot3D, Rcpp (&ge; 0.12.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haeran Cho &lt;haeran.cho@bristol.ac.uk&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-20 20:42:44 UTC; mahrc</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Meier [aut],
  Haeran Cho [aut, cre],
  Claudia Kirch [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-22 12:52:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='bandwidths.default'>Default choice for the set of multiple bandwidths</h2><span id='topic+bandwidths.default'></span>

<h3>Description</h3>

<p>Create bandwidths according to a default function of the sample size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidths.default(n, d.min = 10, G.min = 10, G.max = min(n/2, n^(2/3)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bandwidths.default_+3A_n">n</code></td>
<td>
<p>integer representing the sample size</p>
</td></tr>
<tr><td><code id="bandwidths.default_+3A_d.min">d.min</code></td>
<td>
<p>integer for the minimal mutual distance of change points that can be expected</p>
</td></tr>
<tr><td><code id="bandwidths.default_+3A_g.min">G.min</code></td>
<td>
<p>integer for the minimal allowed bandwidth</p>
</td></tr>
<tr><td><code id="bandwidths.default_+3A_g.max">G.max</code></td>
<td>
<p>integer for the maximal allowed bandwidth</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an integer vector of bandwidths (G_1,...,G_m), 
with G_0 = G_1 = max(<code>G.min</code>, 2/3*<code>d.min</code>), G_j+1 = G_j-1 + G_j (for j = 1, ..., m-1)
and m satisfying G_m &lt;= <code>G.max</code> while G_m+1 &gt; <code>G.max</code>.
</p>


<h3>Value</h3>

<p>an integer vector of bandwidths
</p>


<h3>References</h3>

<p>A. Meier, C. Kirch and H. Cho (2021)
mosum: A Package for Moving Sums in Change-point Analysis.
<em>Journal of Statistical Software</em>, Volume 97, Number 8, pp. 1-42.
&lt;doi:10.18637/jss.v097.i08&gt;.
</p>
<p>H. Cho and C. Kirch (2022) Two-stage data segmentation permitting multiscale change points, heavy tails and dependence. <em>Annals of the Institute of Statistical Mathematics</em>, Volume 74, Number 4, pp. 653-684.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bandwidths.default(1000, 10, 10, 200)
</code></pre>

<hr>
<h2 id='bootstrapped_timeSeries'>Obtain bootstrap replicate of time series</h2><span id='topic+bootstrapped_timeSeries'></span>

<h3>Description</h3>

<p>Obtain bootstrap replicate of time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrapped_timeSeries(cpts, x)
</code></pre>

<hr>
<h2 id='comb_contains_cpt'>Does the combination comb of changepoints contain the changepoint k_ind?</h2><span id='topic+comb_contains_cpt'></span>

<h3>Description</h3>

<p>Does the combination comb of changepoints contain the changepoint k_ind?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_contains_cpt(comb, k_ind)
</code></pre>

<hr>
<h2 id='confint.mosum.cpts'>Confidence intervals for change points</h2><span id='topic+confint.mosum.cpts'></span>

<h3>Description</h3>

<p>Generate bootstrap confidence intervals for change points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mosum.cpts'
confint(object, parm = "cpts", level = 0.05, N_reps = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.mosum.cpts_+3A_object">object</code></td>
<td>
<p>an object of class <code>mosum.cpts</code></p>
</td></tr>
<tr><td><code id="confint.mosum.cpts_+3A_parm">parm</code></td>
<td>
<p>specification of which parameters are to be given confidence intervals; <code>parm = "cpts"</code> is supported</p>
</td></tr>
<tr><td><code id="confint.mosum.cpts_+3A_level">level</code></td>
<td>
<p>numeric value in (0, 1), such that the <code>100(1-level)%</code> confidence bootstrap intervals are computed</p>
</td></tr>
<tr><td><code id="confint.mosum.cpts_+3A_n_reps">N_reps</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="confint.mosum.cpts_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the referenced literature for further details
</p>


<h3>Value</h3>

<p>S3 object of class <code>cpts.ci</code>, containing the following fields:
</p>
<table role = "presentation">
<tr><td><code>level</code>, <code>N_reps</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>data frame of five columns, 
containing the estimated change points (column <code>cpts</code>),
the pointwise confidence intervals 
(columns <code>pw.left</code> and <code>pw.right</code>)
and the uniform confidence intervals 
(columns <code>unif.left</code> and <code>unif.right</code>) for the corresponding change points</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Meier, C. Kirch and H. Cho (2021)
mosum: A Package for Moving Sums in Change-point Analysis.
<em>Journal of Statistical Software</em>, Volume 97, Number 8, pp. 1-42.
&lt;doi:10.18637/jss.v097.i08&gt;.
</p>
<p>H. Cho and C. Kirch (2022) Bootstrap confidence intervals for multiple change points based on moving sum procedures. <em>Computational Statistics &amp; Data Analysis</em>, Volume 175, pp. 107552.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(lengths = rep(100, 3), means = c(0, 3, 1), sds = rep(1, 3), seed = 1337)$x
m &lt;- mosum(x, G = 40)
ci &lt;- confint(m, N_reps = 5000)
print(ci$CI)
</code></pre>

<hr>
<h2 id='confint.multiscale.cpts'>Confidence intervals for change points</h2><span id='topic+confint.multiscale.cpts'></span>

<h3>Description</h3>

<p>Generate bootstrap confidence intervals for change points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiscale.cpts'
confint(object, parm = "cpts", level = 0.05, N_reps = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.multiscale.cpts_+3A_object">object</code></td>
<td>
<p>an object of class <code>multiscale.cpts</code></p>
</td></tr>
<tr><td><code id="confint.multiscale.cpts_+3A_parm">parm</code></td>
<td>
<p>specification of which parameters are to be given confidence intervals; <code>parm = "cpts"</code> is supported</p>
</td></tr>
<tr><td><code id="confint.multiscale.cpts_+3A_level">level</code></td>
<td>
<p>numeric value in (0, 1), such that the <code>100(1-level)%</code> confidence bootstrap intervals are computed</p>
</td></tr>
<tr><td><code id="confint.multiscale.cpts_+3A_n_reps">N_reps</code></td>
<td>
<p>number of bootstrap replications</p>
</td></tr>
<tr><td><code id="confint.multiscale.cpts_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the referenced literature for further details
</p>


<h3>Value</h3>

<p>S3 object of class <code>cpts.ci</code>, containing the following fields:
</p>
<table role = "presentation">
<tr><td><code>level</code>, <code>N_reps</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>CI</code></td>
<td>
<p>data frame of five columns, 
containing the estimated change points (column <code>cpts</code>),
the pointwise confidence intervals 
(columns <code>pw.left</code> and <code>pw.right</code>)
and the uniform confidence intervals 
(columns <code>unif.left</code> and <code>unif.right</code>) for the corresponding change points</p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Meier, C. Kirch and H. Cho (2021)
mosum: A Package for Moving Sums in Change-point Analysis.
<em>Journal of Statistical Software</em>, Volume 97, Number 8, pp. 1-42.
&lt;doi:10.18637/jss.v097.i08&gt;.
</p>
<p>H. Cho and C. Kirch (2022) Bootstrap confidence intervals for multiple change points based on moving sum procedures. <em>Computational Statistics &amp; Data Analysis</em>, Volume 175, pp. 107552.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(lengths = rep(100, 3), means = c(0, 3, 1), sds = rep(1, 3), seed = 1337)$x
mlp &lt;-  multiscale.localPrune(x, G = c(8, 15, 30, 70))
ci &lt;- confint(mlp, N_reps = 5000)
print(ci$CI)
</code></pre>

<hr>
<h2 id='cpts_bootstrap'>Helping/wrapper fuction for C++ calls</h2><span id='topic+cpts_bootstrap'></span>

<h3>Description</h3>

<p>Helping/wrapper fuction for C++ calls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts_bootstrap(mcpts, N_reps, level)
</code></pre>

<hr>
<h2 id='cpts_bootstrap_help'>Helping function to get bootstrap replicates of change point estimates</h2><span id='topic+cpts_bootstrap_help'></span>

<h3>Description</h3>

<p>Helping function to get bootstrap replicates of change point estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpts_bootstrap_help(cpts_info, x, N_reps)
</code></pre>

<hr>
<h2 id='detect.interval'>Final detection interval</h2><span id='topic+detect.interval'></span>

<h3>Description</h3>

<p>Final detection interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.interval(all.cpts, est.cpts)
</code></pre>

<hr>
<h2 id='dup.merge'>Remove duplicated from all.cpts data frame:
In case one change being added multiple times, choose the one
with smallest p-value</h2><span id='topic+dup.merge'></span>

<h3>Description</h3>

<p>Remove duplicated from all.cpts data frame:
In case one change being added multiple times, choose the one
with smallest p-value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dup.merge(all.cpts)
</code></pre>

<hr>
<h2 id='eta_criterion_help'>extract changepoints from candidates with eta criterion</h2><span id='topic+eta_criterion_help'></span>

<h3>Description</h3>

<p>extract changepoints from candidates with eta criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eta_criterion_help(candidates, m_values, eta, G_left, G_right)
</code></pre>

<hr>
<h2 id='exhaust_sc'>Algorithm II (Local change-point search with SC)</h2><span id='topic+exhaust_sc'></span>

<h3>Description</h3>

<p>Input cand: =mathcal D, conflicting changepoints candidate set
Input sub_sums: Pre-computed partial sums, as obtained by extract_sub
Input strength: Exponent for penalty
Input log_penalty: log (or polynomial) penalty term?
Input n: Overall length of data
Input auc: =|mathcal C|, total number of currently active changepoints 
(+candidates)
Input min_cost: Minimal RSS with all the candidates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exhaust_sc(cand, sub_sums, strength, log_penalty, n, auc, min_cost)
</code></pre>


<h3>Details</h3>

<p>Output sc: (Mx2) matrix (M=2^m with m=|cand|) containing RSS/cost and SC
terms for all combinations within cand. Combinations are indexed
by their implicit integer representation, i.e. sc[0,] corresponds
to the empty set, sc[3,] to k_1,k_2 [0..011], etc.
Note: Row May be Inf, if combination was not visited in algorithm.
Output est_cpts: Integer Vector of estimated changepoints
Output final: Bool Vector indicating if combinations are final states
Output num_cpts: For debugging purposes
</p>

<hr>
<h2 id='extract_sub'>Helping function for algorithm 2: Pre-compute the partial sums
S_i = sumj=k_i+1^k_i+1x_i and the partial sums of squared
T_i = sumj=k_i+1^k_i+1x_i^2
between the (sorted) candidates k_i and k_i+1 in cand.
Output: data frame with 4 columns k_i | k_i+1 | S_i | T_i</h2><span id='topic+extract_sub'></span>

<h3>Description</h3>

<p>Helping function for algorithm 2: Pre-compute the partial sums
S_i = sumj=k_i+1^k_i+1x_i and the partial sums of squared
T_i = sumj=k_i+1^k_i+1x_i^2
between the (sorted) candidates k_i and k_i+1 in cand.
Output: data frame with 4 columns k_i | k_i+1 | S_i | T_i
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_sub(cand, x)
</code></pre>

<hr>
<h2 id='get_comb_ind'>Get integer vector of changepoint indices,
based on bool-field representation of combinations.
E.g. for combination index 11 [=1011]: get_comb_ind(c(T,F,T,T))=11</h2><span id='topic+get_comb_ind'></span>

<h3>Description</h3>

<p>Get integer vector of changepoint indices,
based on bool-field representation of combinations.
E.g. for combination index 11 [=1011]: get_comb_ind(c(T,F,T,T))=11
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_comb_ind(active)
</code></pre>

<hr>
<h2 id='get_k_star'>Compute bootstrapped mosum statistic and return maximum position thereof</h2><span id='topic+get_k_star'></span>

<h3>Description</h3>

<p>Compute bootstrapped mosum statistic and return maximum position thereof
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_k_star(x_star, k_hat, G_l, G_r, G_ll, G_rr)
</code></pre>

<hr>
<h2 id='get_local_costs'>Compute the Local cost terms of combination icomb (for RSS resp. sBIC).
Use pre-computed partial sum matrix sub_sums (see extract_sub) for speedup</h2><span id='topic+get_local_costs'></span>

<h3>Description</h3>

<p>Compute the Local cost terms of combination icomb (for RSS resp. sBIC).
Use pre-computed partial sum matrix sub_sums (see extract_sub) for speedup
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_local_costs(icomb, sub_sums)
</code></pre>

<hr>
<h2 id='is_child'>Is index i_child a child of index i_parent?
ASSERT: i_child is of the form (i_parent XOR i_help),
with i_help having exactly one non-zero bit</h2><span id='topic+is_child'></span>

<h3>Description</h3>

<p>Is index i_child a child of index i_parent?
ASSERT: i_child is of the form (i_parent XOR i_help),
with i_help having exactly one non-zero bit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_child(i_child, i_parent)
</code></pre>

<hr>
<h2 id='local.env'>Identify the local environment for exhaustive search</h2><span id='topic+local.env'></span>

<h3>Description</h3>

<p>Identify the local environment for exhaustive search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local.env(j, est.cpts.ind, all.cpts, current, ac)
</code></pre>

<hr>
<h2 id='local.prune'>Localised pruning algorithm</h2><span id='topic+local.prune'></span>

<h3>Description</h3>

<p>Localised pruning algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local.prune(x, all.cpts, rule, log.penalty, pen.exp)
</code></pre>

<hr>
<h2 id='mean_help'>helping function for bootstrap (compute local means)</h2><span id='topic+mean_help'></span>

<h3>Description</h3>

<p>helping function for bootstrap (compute local means)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_help(x, l, r)
</code></pre>

<hr>
<h2 id='modelSignal.blocks'>Creating Time-Series according to example model</h2><span id='topic+modelSignal.blocks'></span>

<h3>Description</h3>

<p>Creates a time series according to the block model with independent innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSignal.blocks(rand.gen = rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSignal.blocks_+3A_rand.gen">rand.gen</code></td>
<td>
<p>optional: a function to generate the innovations</p>
</td></tr>
<tr><td><code id="modelSignal.blocks_+3A_...">...</code></td>
<td>
<p>further arguments to be parsed to <code>rand.gen</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Appendix B in the reference for details about the signal model.
</p>


<h3>Value</h3>

<p>a vector consisting of a realization of the signal model
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2014)
Wild Binary Segmentation for Multiple Change-Point Detection.
<em>The Annals of Statistics</em>, Volume 42, Number 6, pp. 2243-2281.
</p>

<hr>
<h2 id='modelSignal.fms'>Creating Time-Series according to example model</h2><span id='topic+modelSignal.fms'></span>

<h3>Description</h3>

<p>Creates a time series according to the block model with independent innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSignal.fms(rand.gen = rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSignal.fms_+3A_rand.gen">rand.gen</code></td>
<td>
<p>optional: a function to generate the innovations</p>
</td></tr>
<tr><td><code id="modelSignal.fms_+3A_...">...</code></td>
<td>
<p>further arguments to be parsed to <code>rand.gen</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Appendix B in the reference for details about the signal model.
</p>


<h3>Value</h3>

<p>a vector consisting of a realization of the signal model
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2014)
Wild Binary Segmentation for Multiple Change-Point Detection.
<em>The Annals of Statistics</em>, Volume 42, Number 6, pp. 2243-2281.
</p>

<hr>
<h2 id='modelSignal.mix'>Creating Time-Series according to example model</h2><span id='topic+modelSignal.mix'></span>

<h3>Description</h3>

<p>Creates a time series according to the block model with independent innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSignal.mix(rand.gen = rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSignal.mix_+3A_rand.gen">rand.gen</code></td>
<td>
<p>optional: a function to generate the innovations</p>
</td></tr>
<tr><td><code id="modelSignal.mix_+3A_...">...</code></td>
<td>
<p>further arguments to be parsed to <code>rand.gen</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Appendix B in the reference for details about the signal model.
</p>


<h3>Value</h3>

<p>a vector consisting of a realization of the signal model
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2014)
Wild Binary Segmentation for Multiple Change-Point Detection.
<em>The Annals of Statistics</em>, Volume 42, Number 6, pp. 2243-2281.
</p>

<hr>
<h2 id='modelSignal.stairs10'>Creating Time-Series according to example model</h2><span id='topic+modelSignal.stairs10'></span>

<h3>Description</h3>

<p>Creates a time series according to the block model with independent innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSignal.stairs10(rand.gen = rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSignal.stairs10_+3A_rand.gen">rand.gen</code></td>
<td>
<p>optional: a function to generate the innovations</p>
</td></tr>
<tr><td><code id="modelSignal.stairs10_+3A_...">...</code></td>
<td>
<p>further arguments to be parsed to <code>rand.gen</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Appendix B in the reference for details about the signal model.
</p>


<h3>Value</h3>

<p>a vector consisting of a realization of the signal model
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2014)
Wild Binary Segmentation for Multiple Change-Point Detection.
<em>The Annals of Statistics</em>, Volume 42, Number 6, pp. 2243-2281.
</p>

<hr>
<h2 id='modelSignal.teeth10'>Creating Time-Series according to example model</h2><span id='topic+modelSignal.teeth10'></span>

<h3>Description</h3>

<p>Creates a time series according to the block model with independent innovations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelSignal.teeth10(rand.gen = rnorm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelSignal.teeth10_+3A_rand.gen">rand.gen</code></td>
<td>
<p>optional: a function to generate the innovations</p>
</td></tr>
<tr><td><code id="modelSignal.teeth10_+3A_...">...</code></td>
<td>
<p>further arguments to be parsed to <code>rand.gen</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Appendix B in the reference for details about the signal model.
</p>


<h3>Value</h3>

<p>a vector consisting of a realization of the signal model
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2014)
Wild Binary Segmentation for Multiple Change-Point Detection.
<em>The Annals of Statistics</em>, Volume 42, Number 6, pp. 2243-2281.
</p>

<hr>
<h2 id='mosum'>MOSUM procedure for multiple change point estimation</h2><span id='topic+mosum'></span>

<h3>Description</h3>

<p>Computes the MOSUM detector, detects (multiple) change points and estimates their locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosum(
  x,
  G,
  G.right = G,
  var.est.method = c("mosum", "mosum.min", "mosum.max", "custom")[1],
  var.custom = NULL,
  boundary.extension = TRUE,
  threshold = c("critical.value", "custom")[1],
  alpha = 0.1,
  threshold.custom = NULL,
  criterion = c("eta", "epsilon")[1],
  eta = 0.4,
  epsilon = 0.2,
  do.confint = FALSE,
  level = 0.05,
  N_reps = 1000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosum_+3A_x">x</code></td>
<td>
<p>input data (a <code>numeric</code> vector or an object of classes <code>ts</code> and <code>timeSeries</code>)</p>
</td></tr>
<tr><td><code id="mosum_+3A_g">G</code></td>
<td>
<p>an integer value for the moving sum bandwidth;
<code>G</code> should be less than <code>length(n)/2</code>.
Alternatively, a number between <code>0</code> and <code>0.5</code> describing the moving sum bandwidth
relative to <code>length(x)</code> can be given</p>
</td></tr>
<tr><td><code id="mosum_+3A_g.right">G.right</code></td>
<td>
<p>if <code>G.right != G</code>, the asymmetric bandwidth <code>(G, G.right)</code> will be used;
if <code>max(G, G.right)/min(G, G.right) &gt; 4</code>, a warning message is generated</p>
</td></tr>
<tr><td><code id="mosum_+3A_var.est.method">var.est.method</code></td>
<td>
<p>how the variance is estimated;
possible values are
</p>

<ul>
<li><p><code>"mosum"</code>both-sided MOSUM variance estimator
</p>
</li>
<li><p><code>"mosum.min"</code>minimum of the sample variance estimates from the left and right summation windows
</p>
</li>
<li><p><code>"mosum.max"</code>maximum of the sample variance estimates from the left and right summation windows
</p>
</li>
<li><p><code>"custom"</code>a vector of <code>length(x)</code> is to be parsed by the user; use <code>var.custom</code> in this case to do so
</p>
</li></ul>
</td></tr>
<tr><td><code id="mosum_+3A_var.custom">var.custom</code></td>
<td>
<p>a numeric vector (of the same length as <code>x</code>) containing
local estimates of the variance or long run variance; use iff <code>var.est.method = "custom"</code></p>
</td></tr>
<tr><td><code id="mosum_+3A_boundary.extension">boundary.extension</code></td>
<td>
<p>a logical value indicating whether the boundary
values should be filled-up with CUSUM values</p>
</td></tr>
<tr><td><code id="mosum_+3A_threshold">threshold</code></td>
<td>
<p>string indicating which threshold should be used to determine significance.
By default, it is chosen from the asymptotic distribution at the given significance level <code>alpha</code>.
Alternatively it is possible to parse a user-defined numerical value with <code>threshold.custom</code></p>
</td></tr>
<tr><td><code id="mosum_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code>; use iff <code>threshold = "critical.value"</code></p>
</td></tr>
<tr><td><code id="mosum_+3A_threshold.custom">threshold.custom</code></td>
<td>
<p>a numeric value greater than 0 for the threshold of significance;
use iff <code>threshold = "custom"</code></p>
</td></tr>
<tr><td><code id="mosum_+3A_criterion">criterion</code></td>
<td>
<p>string indicating how to determine whether each point <code>k</code> at which MOSUM statistic 
exceeds the threshold is a change point; possible values are
</p>

<ul>
<li><p><code>"eta"</code>there is no larger exceeding in an <code>eta*G</code> environment of <code>k</code>
</p>
</li>
<li><p><code>"epsilon"</code><code>k</code> is the maximum of its local exceeding environment, which has at least size <code>epsilon*G</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="mosum_+3A_eta">eta</code></td>
<td>
<p>a positive numeric value for the minimal mutual distance of 
changes, relative to moving sum bandwidth (iff <code>criterion = "eta"</code>)</p>
</td></tr>
<tr><td><code id="mosum_+3A_epsilon">epsilon</code></td>
<td>
<p>a numeric value in (0,1] for the minimal size of exceeding
environments, relative to moving sum bandwidth (iff <code>criterion = "epsilon"</code>)</p>
</td></tr>
<tr><td><code id="mosum_+3A_do.confint">do.confint</code></td>
<td>
<p>flag indicating whether to compute the confidence intervals for change points</p>
</td></tr>
<tr><td><code id="mosum_+3A_level">level</code></td>
<td>
<p>use iff <code>do.confint = TRUE</code>; a numeric value (<code>0 &lt;= level &lt;= 1</code>) with which
<code>100(1-level)%</code> confidence interval is generated</p>
</td></tr>
<tr><td><code id="mosum_+3A_n_reps">N_reps</code></td>
<td>
<p>use iff <code>do.confint = TRUE</code>; number of bootstrap replicates to be generated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 object of class <code>mosum.cpts</code>, which contains the following fields:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code>G.left</code>, <code>G.right</code></td>
<td>
<p>left and right summation bandwidths</p>
</td></tr>
<tr><td><code>var.est.method</code>, <code>var.custom</code>, <code>boundary.extension</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a series of MOSUM statistic values; the first <code>G</code> and last <code>G.right</code> values are <code>NA</code> iff <code>boundary.extension = FALSE</code></p>
</td></tr>
<tr><td><code>rollsums</code></td>
<td>
<p>a series of MOSUM detector values; equals <code>stat*sqrt(var.estimation)</code></p>
</td></tr>
<tr><td><code>var.estimation</code></td>
<td>
<p>the local variance estimated according to <code>var.est.method</code></p>
</td></tr>
<tr><td><code>threshold</code>, <code>alpha</code>, <code>threshold.custom</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>threshold.value</code></td>
<td>
<p>threshold value of the corresponding MOSUM test</p>
</td></tr>
<tr><td><code>criterion</code>, <code>eta</code>, <code>epsilon</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>a vector containing the estimated change point locations</p>
</td></tr>
<tr><td><code>cpts.info</code></td>
<td>
<p>data frame containing information about change point estimators including detection bandwidths, asymptotic p-values for the corresponding MOSUM statistics and (scaled) size of jumps</p>
</td></tr>
<tr><td><code>do.confint</code></td>
<td>
<p>input parameter</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>S3 object of class <code>cpts.ci</code> containing confidence intervals for change points iff <code>do.confint=TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Meier, C. Kirch and H. Cho (2021)
mosum: A Package for Moving Sums in Change-point Analysis.
<em>Journal of Statistical Software</em>, Volume 97, Number 8, pp. 1-42.
&lt;doi:10.18637/jss.v097.i08&gt;.
</p>
<p>B. Eichinger and C. Kirch (2018)
A MOSUM procedure for the estimation of multiple random change-points.
<em>Bernoulli</em>, Volume 24, Number 1, pp. 526-564.
</p>
<p>H. Cho and C. Kirch (2022) Bootstrap confidence intervals for multiple change points based on moving sum procedures. <em>Computational Statistics &amp; Data Analysis</em>, Volume 175, pp. 107552.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(lengths = rep(100, 3), means = c(0, 5, -2), sds = rep(1, 3), seed = 1234)$x
m &lt;- mosum(x, G = 40)
plot(m)
summary(m)
</code></pre>

<hr>
<h2 id='mosum.asymptoticA'>Help function: asymptotic scaling.</h2><span id='topic+mosum.asymptoticA'></span>

<h3>Description</h3>

<p>Help function: asymptotic scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosum.asymptoticA(x)
</code></pre>

<hr>
<h2 id='mosum.asymptoticB'>Help function: asymptotic shift</h2><span id='topic+mosum.asymptoticB'></span>

<h3>Description</h3>

<p>Help function: asymptotic shift
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosum.asymptoticB(x, K)
</code></pre>

<hr>
<h2 id='mosum.criticalValue'>MOSUM asymptotic critical value</h2><span id='topic+mosum.criticalValue'></span>

<h3>Description</h3>

<p>Computes the asymptotic critical value for the MOSUM test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosum.criticalValue(n, G.left, G.right, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosum.criticalValue_+3A_n">n</code></td>
<td>
<p>an integer value for the length of the input data</p>
</td></tr>
<tr><td><code id="mosum.criticalValue_+3A_g.left">G.left</code>, <code id="mosum.criticalValue_+3A_g.right">G.right</code></td>
<td>
<p>integer values for the left and right moving sum bandwidth (G.left, G.right)</p>
</td></tr>
<tr><td><code id="mosum.criticalValue_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value for the asymptotic critical value for the MOSUM test
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(lengths = rep(100, 3), means = c(0, 5, -2), sds = rep(1, 3), seed = 1234)$x
m &lt;- mosum(x, G = 40)
par(mfrow = c(2, 1))
plot(m$stat, type = "l", xlab = "Time", ylab = "", main = "mosum")
abline(h = mosum.criticalValue(300, 40, 40, .1), col = 4)
abline(v = m$cpts, col = 2)
plot(m, display = "mosum") # identical plot is produced 
</code></pre>

<hr>
<h2 id='mosum.pValue'>MOSUM asymptotic p-value</h2><span id='topic+mosum.pValue'></span>

<h3>Description</h3>

<p>Computes the asymptotic p-value for the MOSUM test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosum.pValue(z, n, G.left, G.right = G.left)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosum.pValue_+3A_z">z</code></td>
<td>
<p>a numeric value for the observation</p>
</td></tr>
<tr><td><code id="mosum.pValue_+3A_n">n</code></td>
<td>
<p>an integer value for the length of the input data</p>
</td></tr>
<tr><td><code id="mosum.pValue_+3A_g.left">G.left</code>, <code id="mosum.pValue_+3A_g.right">G.right</code></td>
<td>
<p>integer values for the left moving sum bandwidth (G.left,G.right)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric value for the asymptotic p-value for the asymmetric MOSUM test
</p>

<hr>
<h2 id='mosum.stat'>MOSUM statistic</h2><span id='topic+mosum.stat'></span>

<h3>Description</h3>

<p>Computes the statistical values for the MOSUM test for changes in the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosum.stat(
  x,
  G,
  G.right = NA,
  var.est.method = "mosum",
  var.custom = NULL,
  boundary.extension = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mosum.stat_+3A_x">x</code></td>
<td>
<p>input data (<code>numeric</code> vector or object of class <code>ts</code>)</p>
</td></tr>
<tr><td><code id="mosum.stat_+3A_g">G</code></td>
<td>
<p>an integer value for the length of the moving sum window; 
<code>G</code> should be less than <code>length(n)/2</code>.
Alternatively a number between <code>0</code> and <code>0.5</code> describing the moving sum bandwidth
relative to <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="mosum.stat_+3A_g.right">G.right</code></td>
<td>
<p>iff <code>!is.na(G.right)</code>, the asymmetric bandwidth (G,G.right) will be used</p>
</td></tr>
<tr><td><code id="mosum.stat_+3A_var.est.method">var.est.method</code></td>
<td>
<p>how the variance is estimated;
possible values are
</p>

<ul>
<li><p><code>'custom'</code>a vector of <code>length(x)</code> is to be parsed by the user; use <code>var.custom</code> in this case to to so
</p>
</li>
<li><p><code>'mosum'</code>both-sided MOSUM variance estimator
</p>
</li>
<li><p><code>'mosum.min'</code>minimum of the sample variance estimates from the left and right summation windows
</p>
</li>
<li><p><code>'mosum.max'</code>maximum of the sample variance estimates from the left and right summation windows   
</p>
</li></ul>
</td></tr>
<tr><td><code id="mosum.stat_+3A_var.custom">var.custom</code></td>
<td>
<p>a numeric vector (of the same length as <code>x</code>) containing
local estimates of the variance or long run variance; use iff <code>var.est.method=custom</code></p>
</td></tr>
<tr><td><code id="mosum.stat_+3A_boundary.extension">boundary.extension</code></td>
<td>
<p>a logical value indicating whether the boundary
values should be filled-up with CUSUM values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This class only contains the values for the MOSUM statistic.
For statistical evaluation and change point extraction, use <a href="#topic+mosum">mosum</a>.
See also <a href="#topic+multiscale.bottomUp">multiscale.bottomUp</a> and <a href="#topic+multiscale.localPrune">multiscale.localPrune</a>.
</p>


<h3>Value</h3>

<p>S3 <code>mosum.stat</code> object, which contains the following fields:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>the numeric input vector provided</p>
</td></tr>
<tr><td><code>G.left</code>, <code>G.right</code></td>
<td>
<p>left and right bandwidths</p>
</td></tr>
<tr><td><code>var.est.method</code>, <code>var.custom</code>, <code>boundary.extension</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>stat</code></td>
<td>
<p>a series of MOSUM statistic values; the first <code>G</code> and last <code>G.right</code> values are <code>NA</code> iff <code>boundary.extension=FALSE</code></p>
</td></tr>
<tr><td><code>rollsums</code></td>
<td>
<p>a series of MOSUM detector values; equals <code>stat*sqrt(var.estimation)</code></p>
</td></tr>
<tr><td><code>var.estimation</code></td>
<td>
<p>the local variance estimated according to <code>var.est.method</code></p>
</td></tr>
</table>

<hr>
<h2 id='multiscale.bottomUp'>Multiscale MOSUM algorithm with bottom-up merging</h2><span id='topic+multiscale.bottomUp'></span>

<h3>Description</h3>

<p>Multiscale MOSUM procedure with symmetric bandwidths combined with
bottom-up bandwidth-based merging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale.bottomUp(
  x,
  G = bandwidths.default(length(x), G.min = max(20, ceiling(0.05 * length(x)))),
  threshold = c("critical.value", "custom")[1],
  alpha = 0.1,
  threshold.function = NULL,
  eta = 0.4,
  do.confint = FALSE,
  level = 0.05,
  N_reps = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiscale.bottomUp_+3A_x">x</code></td>
<td>
<p>input data (a <code>numeric</code> vector or an object of classes <code>ts</code> and <code>timeSeries</code>)</p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_g">G</code></td>
<td>
<p>a vector of (symmetric) bandwidths, given as either integers less than <code>length(x)/2</code>,
or numbers between <code>0</code> and <code>0.5</code> describing the moving sum bandwidths relative to <code>length(x)</code>.
If the smallest bandwidth is smaller than <code>min(20, 0.05*length(x))</code> 
(<code>0.05</code> if relative bandwidths are given) and <code>threshold = "critical.value"</code>,
it generates a warning message</p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_threshold">threshold</code></td>
<td>
<p>string indicating which threshold should be used to determine significance.
By default, it is chosen from the asymptotic distribution at the given significance level <code>alpha</code>.
Alternatively, it is possible to parse a user-defined function with <code>threshold.function</code></p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code>; use iff <code>threshold = "critical.value"</code></p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_threshold.function">threshold.function</code></td>
<td>
<p>function object of form <code>function(G, length(x), alpha)</code>, to compute a
threshold of significance for different bandwidths G; use iff <code>threshold = "custom"</code></p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_eta">eta</code></td>
<td>
<p>see <a href="#topic+mosum">mosum</a></p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_do.confint">do.confint</code></td>
<td>
<p>flag indicating whether to compute the confidence intervals for change points</p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_level">level</code></td>
<td>
<p>use iff <code>do.confint = TRUE</code>; a numeric value (<code>0 &lt;= level &lt;= 1</code>) with which
<code>100(1-level)%</code> confidence interval is generated</p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_n_reps">N_reps</code></td>
<td>
<p>use iff <code>do.confint = TRUE</code>; number of bootstrap replicates to be generated</p>
</td></tr>
<tr><td><code id="multiscale.bottomUp_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the <a href="#topic+mosum">mosum</a> calls</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Algorithm 1 in the first referenced paper for a comprehensive
description of the procedure and further details.
</p>


<h3>Value</h3>

<p>S3 object of class <code>multiscale.cpts</code>, which contains the following fields:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>estimated change points</p>
</td></tr>
<tr><td><code>cpts.info</code></td>
<td>
<p>data frame containing information about estimated change points</p>
</td></tr>
<tr><td><code>pooled.cpts</code></td>
<td>
<p>set of change point candidates that have been considered by the algorithm</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>bandwidths</p>
</td></tr>
<tr><td><code>threshold</code>, <code>alpha</code>, <code>threshold.function</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>do.confint</code></td>
<td>
<p>input parameter</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>object of class <code>cpts.ci</code> containing confidence intervals for change points iff <code>do.confint = TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Meier, C. Kirch and H. Cho (2021)
mosum: A Package for Moving Sums in Change-point Analysis.
<em>Journal of Statistical Software</em>, Volume 97, Number 8, pp. 1-42.
&lt;doi:10.18637/jss.v097.i08&gt;.
</p>
<p>M. Messer et al. (2014)
A multiple filter test for the detection of rate changes in renewal processes with varying variance.
<em>The Annals of Applied Statistics</em>, Volume 8, Number 4, pp. 2027-2067.
</p>
<p>H. Cho and C. Kirch (2022) Bootstrap confidence intervals for multiple change points based on moving sum procedures. <em>Computational Statistics &amp; Data Analysis</em>, Volume 175, pp. 107552.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- testData(lengths = c(100, 200, 300, 300), 
means = c(0, 1, 2, 2.7), sds = rep(1, 4), seed = 123)$x
mbu1 &lt;- multiscale.bottomUp(x1)
plot(mbu1)
summary(mbu1)

x2 &lt;- testData(model = "mix", seed = 1234)$x
threshold.custom &lt;- function(G, n, alpha) {
mosum.criticalValue(n, G, G, alpha) * log(n/G)^0.1
}
mbu2 &lt;- multiscale.bottomUp(x2, G = 10:40, threshold = "custom",
threshold.function = threshold.custom)
plot(mbu2)
summary(mbu2)

</code></pre>

<hr>
<h2 id='multiscale.grid'>Multiscale bandwidth grids</h2><span id='topic+multiscale.grid'></span>

<h3>Description</h3>

<p>Create asymmetric bandwidth grids to be used with <code>multiscale.localPrune</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale.grid(
  bandwidths.left,
  bandwidths.right = bandwidths.left,
  method = "cartesian",
  max.unbalance = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiscale.grid_+3A_bandwidths.left">bandwidths.left</code></td>
<td>
<p>left parts of the bandwidths</p>
</td></tr>
<tr><td><code id="multiscale.grid_+3A_bandwidths.right">bandwidths.right</code></td>
<td>
<p>right parts of the bandwidths</p>
</td></tr>
<tr><td><code id="multiscale.grid_+3A_method">method</code></td>
<td>
<p>how the asymmetric bandwidths are created;
possible values are
</p>

<ul>
<li><p><code>'cartesian'</code>create all bandwidths in the Cartesian product of 
bandwidths.left and bandwidths.right
</p>
</li>
<li><p><code>'concatenate'</code>join bandwidths.left and bandwidths.right element-wise 
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiscale.grid_+3A_max.unbalance">max.unbalance</code></td>
<td>
<p>a numeric value for the maximal ratio between maximal and minimal bandwidth,
<code>1 &lt;= max.unbalance &lt;= Inf</code>; use iff <code>method='cartesian'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 <code>multiscale.grid</code> object to be used in the <code>multiscale.grid</code> function
</p>

<hr>
<h2 id='multiscale.localPrune'>Multiscale MOSUM algorithm with localised pruning</h2><span id='topic+multiscale.localPrune'></span>

<h3>Description</h3>

<p>Multiscale MOSUM procedure with (possibly) assymetric bandwidths and localised pruning based on Schwarz criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiscale.localPrune(
  x,
  G = bandwidths.default(length(x)),
  max.unbalance = 4,
  threshold = c("critical.value", "custom")[1],
  alpha = 0.1,
  threshold.function = NULL,
  criterion = c("eta", "epsilon")[1],
  eta = 0.4,
  epsilon = 0.2,
  rule = c("pval", "jump")[1],
  penalty = c("log", "polynomial")[1],
  pen.exp = 1.01,
  do.confint = FALSE,
  level = 0.05,
  N_reps = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiscale.localPrune_+3A_x">x</code></td>
<td>
<p>input data (a <code>numeric</code> vector or an object of classes <code>ts</code> and <code>timeSeries</code>)</p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_g">G</code></td>
<td>
<p>a vector of bandwidths, given as either integers less than <code>length(x)/2</code>, 
or numbers between <code>0</code> and <code>0.5</code> describing the moving sum bandwidths relative to <code>length(x)</code>.
Asymmetric bandwidths obtained as the Cartesian product of the set <code>G</code> with itself are used for change point analysis</p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_max.unbalance">max.unbalance</code></td>
<td>
<p>a numeric value for the maximal ratio between maximal and minimal bandwidths to be used for candidate generation,
<code>1 &lt;= max.unbalance &lt;= Inf</code></p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_threshold">threshold</code></td>
<td>
<p>string indicating which threshold should be used to determine significance.
By default, it is chosen from the asymptotic distribution at the significance level <code>alpha</code>.
Alternatively, it is possible to parse a user-defined function with <code>threshold.function</code></p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code>. Use iff <code>threshold = "critical.value"</code></p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_threshold.function">threshold.function</code></td>
<td>
<p>function object of form <code>function(G_l, G_r, length(x), alpha)</code>, to compute a
threshold of significance for different bandwidths <code>(G_l, G_r)</code>; use iff <code>threshold = "custom"</code></p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_criterion">criterion</code></td>
<td>
<p>how to determine whether an exceeding point is a change point; to be parsed to <a href="#topic+mosum">mosum</a></p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_eta">eta</code>, <code id="multiscale.localPrune_+3A_epsilon">epsilon</code></td>
<td>
<p>see <a href="#topic+mosum">mosum</a></p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_rule">rule</code></td>
<td>
<p>string for the choice of sorting criterion for change point candidates in merging step. 
Possible values are: 
</p>

<ul>
<li><p><code>"pval"</code>smallest p-value
</p>
</li>
<li><p><code>"jump"</code>largest (rescaled) jump size
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_penalty">penalty</code></td>
<td>
<p>string specifying the type of penalty term to be used in Schwarz criterion; possible values are:
</p>

<ul>
<li><p><code>"log"</code>use <code>penalty = log(length(x))^pen.exp</code>
</p>
</li>
<li><p><code>"polynomial"</code>use <code>penalty = length(x)^pen.exp</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_pen.exp">pen.exp</code></td>
<td>
<p>exponent for the penalty term (see <code>penalty</code>);</p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_do.confint">do.confint</code></td>
<td>
<p>flag indicating whether confidence intervals for change points should be computed</p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_level">level</code></td>
<td>
<p>use iff <code>do.confint = TRUE</code>; a numeric value (<code>0 &lt;= level &lt;= 1</code>) with which
<code>100(1-level)%</code> confidence interval is generated</p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_n_reps">N_reps</code></td>
<td>
<p>use iff <code>do.confint = TRUE</code>; number of bootstrap replicates to be generated</p>
</td></tr>
<tr><td><code id="multiscale.localPrune_+3A_...">...</code></td>
<td>
<p>further arguments to be parsed to <a href="#topic+mosum">mosum</a> calls</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Algorithm 2 in the first referenced paper for a comprehensive
description of the procedure and further details.
</p>


<h3>Value</h3>

<p>S3 object of class <code>multiscale.cpts</code>, which contains the following fields:
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code>cpts</code></td>
<td>
<p>estimated change points</p>
</td></tr>
<tr><td><code>cpts.info</code></td>
<td>
<p>data frame containing information about estimated change points</p>
</td></tr>
<tr><td><code>sc</code></td>
<td>
<p>Schwarz criterion values of the estimated change point set</p>
</td></tr>
<tr><td><code>pooled.cpts</code></td>
<td>
<p>set of change point candidates that have been considered by the algorithm</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>input parameter</p>
</td></tr>
<tr><td><code>threshold</code>, <code>alpha</code>, <code>threshold.function</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>criterion</code>, <code>eta</code>, <code>epsilon</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>rule</code>, <code>penalty</code>, <code>pen.exp</code></td>
<td>
<p>input parameters</p>
</td></tr>
<tr><td><code>do.confint</code></td>
<td>
<p>input parameter</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>object of class <code>cpts.ci</code> containing confidence intervals for change points iff <code>do.confint = TRUE</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>A. Meier, C. Kirch and H. Cho (2021)
mosum: A Package for Moving Sums in Change-point Analysis.
<em>Journal of Statistical Software</em>, Volume 97, Number 8, pp. 1-42.
&lt;doi:10.18637/jss.v097.i08&gt;.
</p>
<p>H. Cho and C. Kirch (2022) Two-stage data segmentation permitting multiscale change points, heavy tails and dependence. <em>Annals of the Institute of Statistical Mathematics</em>, Volume 74, Number 4, pp. 653-684.
</p>
<p>H. Cho and C. Kirch (2022) Bootstrap confidence intervals for multiple change points based on moving sum procedures. <em>Computational Statistics &amp; Data Analysis</em>, Volume 175, pp. 107552.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(model = "mix", seed = 123)$x
mlp &lt;- multiscale.localPrune(x, G = c(8, 15, 30, 70), do.confint = TRUE)
print(mlp)
summary(mlp)
par(mfcol=c(2, 1), mar = c(2, 4, 2, 2))
plot(mlp, display = "data", shaded = "none")
plot(mlp, display = "significance", shaded = "CI", CI = "unif")
</code></pre>

<hr>
<h2 id='next_bit_permutation'>Next value to iterate (in lexicographical order) over all bit 
permutaions having l bits set to 1.
Example sequence (2 bits): 0011, 0101, 0110, 1001, 1010, 1100.
Source: https://stackoverflow.com/questions/1851134/generate-all-binary-strings-of-length-n-with-k-bits-set</h2><span id='topic+next_bit_permutation'></span>

<h3>Description</h3>

<p>Next value to iterate (in lexicographical order) over all bit 
permutaions having l bits set to 1.
Example sequence (2 bits): 0011, 0101, 0110, 1001, 1010, 1100.
Source: https://stackoverflow.com/questions/1851134/generate-all-binary-strings-of-length-n-with-k-bits-set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_bit_permutation(v)
</code></pre>

<hr>
<h2 id='numberOfSetBits'>Get number of non-zero bits of a 32bit integer
Source: https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer</h2><span id='topic+numberOfSetBits'></span>

<h3>Description</h3>

<p>Get number of non-zero bits of a 32bit integer
Source: https://stackoverflow.com/questions/109023/how-to-count-the-number-of-set-bits-in-a-32-bit-integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numberOfSetBits(i)
</code></pre>

<hr>
<h2 id='persp3D.multiscaleMosum'>3D Visualisation of multiscale MOSUM statistics</h2><span id='topic+persp3D.multiscaleMosum'></span>

<h3>Description</h3>

<p>3D Visualisation of multiscale MOSUM statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>persp3D.multiscaleMosum(
  x,
  mosum.args = list(),
  threshold = c("critical.value", "custom")[1],
  alpha = 0.1,
  threshold.function = NULL,
  pal.name = "YlOrRd",
  expand = 0.2,
  theta = 120,
  phi = 20,
  xlab = "G",
  ylab = "time",
  zlab = "MOSUM",
  ticktype = "detailed",
  NAcol = "#800000FF",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="persp3D.multiscaleMosum_+3A_x">x</code></td>
<td>
<p>a numeric input data vector</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_mosum.args">mosum.args</code></td>
<td>
<p>a named list containing further arguments
to be parsed to the respective <code>mosum</code> function calls, see <a href="#topic+mosum">mosum</a>;
the bandwidths are chosen by the function and should not be given as an argument in <code>mosum.args</code></p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_threshold">threshold</code></td>
<td>
<p>string indicating which threshold should be used for normalisation of
MOSUM statistics computed with different bandwidths.
By default, it is chosen from the asymptotic distribution at the given significance level <code>alpha</code>.
Alternatively it is possible to parse a user-defined numerical value with <code>threshold.custom</code>; see also Details.</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code>; use iff <code>threshold = "critical.value"</code></p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_threshold.function">threshold.function</code></td>
<td>
<p>function object of form <code>function(G)</code>, to compute a
threshold of significance for different bandwidths G; use iff <code>threshold='custom'</code></p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_pal.name">pal.name</code></td>
<td>
<p>a string containing the name of the ColorBrewer palette to be used; 
sequential palettes are recommended.
See <code>RColorBrewer::brewer.pal.info</code> for details</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_expand">expand</code></td>
<td>
<p>expansion factor applied to the z coordinates</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_theta">theta</code></td>
<td>
<p>azimuthal angle defining the viewing direction</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_phi">phi</code></td>
<td>
<p>colatitude angle defining the viewing direction</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_xlab">xlab</code>, <code id="persp3D.multiscaleMosum_+3A_ylab">ylab</code>, <code id="persp3D.multiscaleMosum_+3A_zlab">zlab</code>, <code id="persp3D.multiscaleMosum_+3A_ticktype">ticktype</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_nacol">NAcol</code></td>
<td>
<p>coloring parameter</p>
</td></tr>
<tr><td><code id="persp3D.multiscaleMosum_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to function call of <a href="plot3D.html#topic+persp3D">persp3D</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The visualisation is based on <a href="plot3D.html#topic+persp3D">persp3D</a>.
MOSUM statistics computed with different bandwidths are rescaled
for making them visually comparable.
Rescaling is done either by dividing by their respective critical value at the significance level <code>alpha</code>
(iff <code>threshold = "critical.value"</code>) or by a custom value given by <code>threshold.function</code>
(iff <code>threshold = "custom"</code>).
By default, <code>clim</code> argument of <a href="plot3D.html#topic+persp3D">persp3D</a> is given so that the three lightest 
(for sequential palettes) hues indicate insignificance of the corresponding MOSUM statistics,
while darker hues indicate the presence of significant changes.
</p>


<h3>Value</h3>

<p>see <a href="plot3D.html#topic+persp3D">persp3D</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# If you run the example be aware that this may take some time
print("example may take some time to run")

x &lt;- testData(model = "blocks", seed = 1234)$x
persp3D.multiscaleMosum(x, mosum.args = list(boundary.extension = FALSE))

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.mosum.cpts'>Plotting the output from MOSUM procedure</h2><span id='topic+plot.mosum.cpts'></span>

<h3>Description</h3>

<p>Plotting method for S3 objects of class <code>mosum.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mosum.cpts'
plot(
  x,
  display = c("data", "mosum")[1],
  cpts.col = "red",
  critical.value.col = "blue",
  xlab = "Time",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mosum.cpts_+3A_x">x</code></td>
<td>
<p>a <code>mosum.cpts</code> object</p>
</td></tr>
<tr><td><code id="plot.mosum.cpts_+3A_display">display</code></td>
<td>
<p>which to be plotted against the change point estimators; possible values are
</p>

<ul>
<li><p><code>"data"</code>input time series is plotted along with the estimated piecewise constant signal
</p>
</li>
<li><p><code>"mosum"</code>scaled MOSUM detector values are plotted
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.mosum.cpts_+3A_cpts.col">cpts.col</code></td>
<td>
<p>a specification for the color of the vertical lines at
the change point estimators, see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="plot.mosum.cpts_+3A_critical.value.col">critical.value.col</code></td>
<td>
<p>a specification for the color of the horizontal line
indicating the critical value, see <a href="graphics.html#topic+par">par</a>; use iff <code>display = "mosum"</code></p>
</td></tr>
<tr><td><code id="plot.mosum.cpts_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="plot.mosum.cpts_+3A_...">...</code></td>
<td>
<p>additional graphical arguments, see <a href="graphics.html#topic+plot">plot</a>
and <a href="graphics.html#topic+abline">abline</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location of each change point estimator is plotted as a vertical line
against the input time series and the estimated piecewise constant signal (<code>display = "data"</code>)
or MOSUM detector values (<code>display = "mosum"</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(lengths = rep(100, 3), means = c(0, 5, -2), sds = rep(1, 3), seed = 1234)$x
m &lt;- mosum(x, G = 40)
par(mfrow = c(2, 1), mar = c(2.5, 2.5, 2.5, .5))
plot(m, display = "data")
plot(m, display = "mosum")
</code></pre>

<hr>
<h2 id='plot.mosum.stat'>Plotting MOSUM statistics</h2><span id='topic+plot.mosum.stat'></span>

<h3>Description</h3>

<p>Plotting method for objects of class 'mosum.stat'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mosum.stat'
plot(m, alpha = 0.05, critical.value.col = "blue", xlab = "Time", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mosum.stat_+3A_m">m</code></td>
<td>
<p>a <code>mosum.stat</code> object</p>
</td></tr>
<tr><td><code id="plot.mosum.stat_+3A_alpha">alpha</code></td>
<td>
<p>a numeric value for the significance level with
<code>0 &lt;= alpha &lt;= 1</code></p>
</td></tr>
<tr><td><code id="plot.mosum.stat_+3A_critical.value.col">critical.value.col</code></td>
<td>
<p>a specification for the color of the
critical value, see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="plot.mosum.stat_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="plot.mosum.stat_+3A_...">...</code></td>
<td>
<p>additional graphical arguments, see <a href="graphics.html#topic+plot">plot</a></p>
</td></tr>
</table>

<hr>
<h2 id='plot.multiscale.cpts'>Plotting the output from multiscale MOSUM procedure</h2><span id='topic+plot.multiscale.cpts'></span>

<h3>Description</h3>

<p>Plotting method for S3 objects of class &quot;multiscale.cpts&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiscale.cpts'
plot(
  x,
  display = c("data", "significance")[1],
  shaded = c("CI", "bandwidth", "none")[1],
  level = 0.05,
  N_reps = 1000,
  CI = c("pw", "unif")[1],
  xlab = "Time",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.multiscale.cpts_+3A_x">x</code></td>
<td>
<p>a <code>multiscale.cpts</code> object</p>
</td></tr>
<tr><td><code id="plot.multiscale.cpts_+3A_display">display</code></td>
<td>
<p>which to be plotted against the estimated change point locations; possible values are
</p>

<ul>
<li><p><code>"data"</code>input time series is plotted along with the estimated piecewise constant signal
</p>
</li>
<li><p><code>"significance"</code>one minus the p-values associated with the detection of change point estimators
are represented as the height of vertical lines indicating their locations
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.multiscale.cpts_+3A_shaded">shaded</code></td>
<td>
<p>string indicating which to display as shaded areas surrounding the estimated change point locations.
Poissble values are 
</p>

<ul>
<li><p><code>"bandwidth"</code>respective detection intervals are plotted 
</p>
</li>
<li><p><code>"CI"</code>bootstrap confidence intervals are plotted
</p>
</li>
<li><p><code>"none"</code>none is plotted
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.multiscale.cpts_+3A_level">level</code>, <code id="plot.multiscale.cpts_+3A_n_reps">N_reps</code></td>
<td>
<p>argument to be parsed to <a href="#topic+confint.multiscale.cpts">confint.multiscale.cpts</a>; use iff <code>shaded = "CI"</code>.</p>
</td></tr>
<tr><td><code id="plot.multiscale.cpts_+3A_ci">CI</code></td>
<td>
<p>string indicating whether pointwise (<code>CI = "pw"</code>) or uniform (<code>CI = "unif"</code>) confidence intervals
are to be plotted; use iff <code>shaded = "CI"</code></p>
</td></tr>
<tr><td><code id="plot.multiscale.cpts_+3A_xlab">xlab</code></td>
<td>
<p>graphical parameter</p>
</td></tr>
<tr><td><code id="plot.multiscale.cpts_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The locations of change point estimators are plotted 
against the input time series and the estimated piecewise constant signal (<code>display = "data"</code>), or 
the significance of each estimator is represented by the corresponding
<code>1-p.value</code> derived from the asymptotic distribution of MOSUM test statistic (<code>display = "significance"</code>).
It also produces the rectangles representing the 
detection intervals (if <code>shaded = "bandwidth"</code>) or 
bootstrap confidence intervals of the corresponding change points (if <code>shaded = "CI"</code>)
around their locations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(model = "blocks", seed = 1234)$x
mlp &lt;- multiscale.localPrune(x)
par(mfrow = c(2, 1))
plot(mlp, display = "data", shaded = "bandwidth")
plot(mlp, display = "significance", shaded = "CI")
</code></pre>

<hr>
<h2 id='print.mosum.cpts'>Change points estimated by MOSUM procedure</h2><span id='topic+print.mosum.cpts'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>mosum.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mosum.cpts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mosum.cpts_+3A_x">x</code></td>
<td>
<p>a <code>mosum.cpts</code> object</p>
</td></tr>
<tr><td><code id="print.mosum.cpts_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(lengths = rep(100, 3), means = c(0, 5, -2), sds = rep(1, 3), seed = 1234)$x
m &lt;- mosum(x, G = 40)
print(m)
</code></pre>

<hr>
<h2 id='print.multiscale.cpts'>Change points estimated by multiscale MOSUM procedure</h2><span id='topic+print.multiscale.cpts'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>multiscale.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiscale.cpts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.multiscale.cpts_+3A_x">x</code></td>
<td>
<p>a <code>multiscale.cpts</code> object</p>
</td></tr>
<tr><td><code id="print.multiscale.cpts_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(model = "mix", seed = 12345)$x
mlp &lt;- multiscale.localPrune(x)
print(mlp)
</code></pre>

<hr>
<h2 id='rolling_sum'>equivalent to rollsum(x, k=G, fill=NA, align=&quot;left&quot;) in the package zoo, 
but optimized for speed</h2><span id='topic+rolling_sum'></span>

<h3>Description</h3>

<p>equivalent to rollsum(x, k=G, fill=NA, align=&quot;left&quot;) in the package zoo, 
but optimized for speed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_sum(x, G)
</code></pre>

<hr>
<h2 id='setBitNumber'>where is leftmost one?
https://www.geeksforgeeks.org/find-significant-set-bit-number/</h2><span id='topic+setBitNumber'></span>

<h3>Description</h3>

<p>where is leftmost one?
https://www.geeksforgeeks.org/find-significant-set-bit-number/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setBitNumber(n)
</code></pre>

<hr>
<h2 id='start_bit_permutations'>Starting value to iterate (in lexicographical order) 
over all bit permutaions having l bits set to 1.
E.g.: start_bit_permutations(2) = 3 [=0..011].</h2><span id='topic+start_bit_permutations'></span>

<h3>Description</h3>

<p>Starting value to iterate (in lexicographical order) 
over all bit permutaions having l bits set to 1.
E.g.: start_bit_permutations(2) = 3 [=0..011].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_bit_permutations(l)
</code></pre>

<hr>
<h2 id='summary.mosum.cpts'>Summary of change points estimated by MOSUM procedure</h2><span id='topic+summary.mosum.cpts'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>mosum.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mosum.cpts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mosum.cpts_+3A_object">object</code></td>
<td>
<p>a <code>mosum.cpts</code> object</p>
</td></tr>
<tr><td><code id="summary.mosum.cpts_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide information about each estimated change point, 
including the bandwidths used for its estimation, associated p-value and (scaled) jump size;
if <code>object$do.confint=TRUE</code>, end points of the pointwise and uniform confidence intervals
are also provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(lengths = rep(100, 3), means = c(0, 5, -2), sds = rep(1, 3), seed = 1234)$x
m &lt;- mosum(x, G = 40, do.confint = TRUE)
summary(m)
</code></pre>

<hr>
<h2 id='summary.multiscale.cpts'>Summary of change points estimated by multiscale MOSUM procedure</h2><span id='topic+summary.multiscale.cpts'></span>

<h3>Description</h3>

<p>Summary method for objects of class <code>multiscale.cpts</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiscale.cpts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.multiscale.cpts_+3A_object">object</code></td>
<td>
<p>a <code>multiscale.cpts</code> object</p>
</td></tr>
<tr><td><code id="summary.multiscale.cpts_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provide information about each estimated change point, 
including the bandwidths used for its detection, associated p-value and (scaled) jump size;
if <code>object$do.confint=TRUE</code>, end points of the pointwise and uniform confidence intervals
are also provided.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- testData(model = "mix", seed = 12345)$x
mlp &lt;- multiscale.localPrune(x, do.confint = TRUE)
summary(mlp)
</code></pre>

<hr>
<h2 id='testData'>Test data with piecewise constant mean</h2><span id='topic+testData'></span>

<h3>Description</h3>

<p>Generate piecewise stationary time series with independent innovations and change points in the mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testData(
  model = c("custom", "blocks", "fms", "mix", "stairs10", "teeth10")[1],
  lengths = NULL,
  means = NULL,
  sds = NULL,
  rand.gen = rnorm,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testData_+3A_model">model</code></td>
<td>
<p>a string indicating from which model a realisation is to be generated;
possible values are &quot;custom&quot; (for user-specified model
using <code>lengths</code>, <code>means</code> and <code>sds</code>), and
&quot;blocks&quot;, &quot;fms&quot;, &quot;mix&quot;, &quot;stairs10&quot;, &quot;teeth10&quot; (for the referenced test signals)</p>
</td></tr>
<tr><td><code id="testData_+3A_lengths">lengths</code></td>
<td>
<p>use iff <code>model = "custom"</code>; an integer vector for the lengths of the piecewise stationary segments</p>
</td></tr>
<tr><td><code id="testData_+3A_means">means</code></td>
<td>
<p>use iff <code>model = "custom"</code>; a numeric vector for the means of the piecewise stationary segments</p>
</td></tr>
<tr><td><code id="testData_+3A_sds">sds</code></td>
<td>
<p>use iff <code>model = "custom"</code>; a numeric vector for the deviation scaling of the piecewise stationary segments.
The values are multiplied to the outcome of <code>rand.gen</code>, coinciding with the standard
deviation in the case of standard normal innovations (<code>rand.gen = rnorm</code>)</p>
</td></tr>
<tr><td><code id="testData_+3A_rand.gen">rand.gen</code></td>
<td>
<p>optional; a function to generate the noise/innovations</p>
</td></tr>
<tr><td><code id="testData_+3A_seed">seed</code></td>
<td>
<p>optional; if a seed value is provided (<code>!is.null(seed)</code>), 
then <code>set.seed(seed)</code> is called beforehand)</p>
</td></tr>
<tr><td><code id="testData_+3A_...">...</code></td>
<td>
<p>further arguments to be parsed to <code>rand.gen</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Appendix B in the reference for details about the test signals.
</p>


<h3>Value</h3>

<p>a list containing the following entries:
</p>

<ul>
<li><p>x a numeric vector containing a realisation of the piecewise time series model, 
given as signal + noise
</p>
</li>
<li><p>mu mean vector of piecewise stationary time series model 
</p>
</li>
<li><p>sigma scaling vector of piecewise stationary time series model 
</p>
</li>
<li><p>cpts a vector of change points in the piecewise stationary time series model 
</p>
</li></ul>



<h3>References</h3>

<p>P. Fryzlewicz (2014)
Wild Binary Segmentation for Multiple Change-Point Detection.
<em>The Annals of Statistics</em>, Volume 42, Number 6, pp. 2243-2281.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># visualise estimated changepoints by solid vertical lines
# and true changepoints by broken vertical lines
td &lt;- testData(lengths = c(50, 50, 200, 300, 300), means = c(0, 1, 2, 3, 2.3), 
sds = rep(1, 5), seed = 123)
mbu &lt;- multiscale.bottomUp(td$x)
plot(mbu, display = "data")
abline(v = td$cpts, col = 2, lwd = 2, lty = 2)

# visualise estimated piecewise constant signal by solid line
# and true signal by broken line
td &lt;- testData("blocks", seed = 123)
mlp &lt;- multiscale.localPrune(td$x)
plot(mlp, display = "data")
lines(td$mu, col = 2, lwd = 2, lty = 2)
</code></pre>

<hr>
<h2 id='testSignal'>Piecewise constant test signal</h2><span id='topic+testSignal'></span>

<h3>Description</h3>

<p>Produce vectors of mean and dispersion values for generating piecewise stationary time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testSignal(
  model = c("custom", "blocks", "fms", "mix", "stairs10", "teeth10")[1],
  lengths = NULL,
  means = NULL,
  sds = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testSignal_+3A_model">model</code></td>
<td>
<p>a string indicating from which model a realisation is to be generated;
possible values are &quot;custom&quot; (for user-specified model
using <code>lengths</code>, <code>means</code> and <code>sds</code>), and
&quot;blocks&quot;, &quot;fms&quot;, &quot;mix&quot;, &quot;stairs10&quot;, &quot;teeth10&quot; (for the referenced test signals)</p>
</td></tr>
<tr><td><code id="testSignal_+3A_lengths">lengths</code></td>
<td>
<p>use iff <code>model = "custom"</code>; an integer vector for the lengths of the piecewise stationary segments</p>
</td></tr>
<tr><td><code id="testSignal_+3A_means">means</code></td>
<td>
<p>use iff <code>model = "custom"</code>; a numeric vector for the means of the piecewise stationary segments</p>
</td></tr>
<tr><td><code id="testSignal_+3A_sds">sds</code></td>
<td>
<p>use iff <code>model = "custom"</code>; a numeric vector for the deviation scaling of the piecewise stationary segments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Appendix B in the reference for details about the test signals.
</p>


<h3>Value</h3>

<p>a list containing the following entries:
</p>

<ul>
<li><p>mu_t mean vector of piecewise stationary model time series
</p>
</li>
<li><p>sigma_t deviation scaling vector of piecewise stationary model time series
</p>
</li></ul>



<h3>References</h3>

<p>P. Fryzlewicz (2014)
Wild Binary Segmentation for Multiple Change-Point Detection.
<em>The Annals of Statistics</em>, Volume 42, Number 6, pp. 2243-2281.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
