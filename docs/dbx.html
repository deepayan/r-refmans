<!DOCTYPE html><html><head><title>Help for package dbx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dbx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dbxConnect'><p>Create a database connection</p></a></li>
<li><a href='#dbxDelete'><p>Delete records</p></a></li>
<li><a href='#dbxDisconnect'><p>Close a database connection</p></a></li>
<li><a href='#dbxExecute'><p>Execute a statement</p></a></li>
<li><a href='#dbxInsert'><p>Insert records</p></a></li>
<li><a href='#dbxSelect'><p>Select records</p></a></li>
<li><a href='#dbxUpdate'><p>Update records</p></a></li>
<li><a href='#dbxUpsert'><p>Upsert records</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Fast, Easy-to-Use Database Interface</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides select, insert, update, upsert, and delete database operations. Supports 'PostgreSQL', 'MySQL', 'SQLite', and more, and plays nicely with the 'DBI' package.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ankane/dbx">https://github.com/ankane/dbx</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ankane/dbx/issues">https://github.com/ankane/dbx/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>DBI (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 1.0.2), urltools (&ge; 1.7.0), RSQLite (&ge; 2.1.2),
RMariaDB, RMySQL (&ge; 0.10.20), RPostgres, RPostgreSQL, hms,
jsonlite, blob, odbc</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 20:39:25 UTC; andrew</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Kane [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Kane &lt;andrew@chartkick.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dbxConnect'>Create a database connection</h2><span id='topic+dbxConnect'></span>

<h3>Description</h3>

<p>Create a database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxConnect(
  url = NULL,
  adapter = NULL,
  storage_tz = NULL,
  variables = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxConnect_+3A_url">url</code></td>
<td>
<p>A database URL</p>
</td></tr>
<tr><td><code id="dbxConnect_+3A_adapter">adapter</code></td>
<td>
<p>The database adapter to use</p>
</td></tr>
<tr><td><code id="dbxConnect_+3A_storage_tz">storage_tz</code></td>
<td>
<p>The time zone timestamps are stored in</p>
</td></tr>
<tr><td><code id="dbxConnect_+3A_variables">variables</code></td>
<td>
<p>Session variables</p>
</td></tr>
<tr><td><code id="dbxConnect_+3A_...">...</code></td>
<td>
<p>Arguments to pass to dbConnect</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># SQLite
db &lt;- dbxConnect(adapter="sqlite", dbname=":memory:")

## Not run: 

# Postgres
db &lt;- dbxConnect(adapter="postgres", dbname="mydb")

# MySQL
db &lt;- dbxConnect(adapter="mysql", dbname="mydb")

# Others
db &lt;- dbxConnect(adapter=odbc(), database="mydb")

## End(Not run)
</code></pre>

<hr>
<h2 id='dbxDelete'>Delete records</h2><span id='topic+dbxDelete'></span>

<h3>Description</h3>

<p>Delete records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxDelete(conn, table, where = NULL, batch_size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxDelete_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object</p>
</td></tr>
<tr><td><code id="dbxDelete_+3A_table">table</code></td>
<td>
<p>The table name to delete records from</p>
</td></tr>
<tr><td><code id="dbxDelete_+3A_where">where</code></td>
<td>
<p>A data frame of records to delete</p>
</td></tr>
<tr><td><code id="dbxDelete_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of records to delete in a single statement (defaults to all)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- dbxConnect(adapter="sqlite", dbname=":memory:")
table &lt;- "forecasts"
DBI::dbCreateTable(db, table, data.frame(id=1:3, temperature=20:22))

# Delete specific records
bad_records &lt;- data.frame(id=c(1, 2))
dbxDelete(db, table, where=bad_records)

# Delete all records
dbxDelete(db, table)
</code></pre>

<hr>
<h2 id='dbxDisconnect'>Close a database connection</h2><span id='topic+dbxDisconnect'></span>

<h3>Description</h3>

<p>Close a database connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxDisconnect(conn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxDisconnect_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- dbxConnect(adapter="sqlite", dbname=":memory:")

dbxDisconnect(db)
</code></pre>

<hr>
<h2 id='dbxExecute'>Execute a statement</h2><span id='topic+dbxExecute'></span>

<h3>Description</h3>

<p>Execute a statement
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxExecute(conn, statement, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxExecute_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object</p>
</td></tr>
<tr><td><code id="dbxExecute_+3A_statement">statement</code></td>
<td>
<p>The SQL statement to use</p>
</td></tr>
<tr><td><code id="dbxExecute_+3A_params">params</code></td>
<td>
<p>Parameters to bind</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- dbxConnect(adapter="sqlite", dbname=":memory:")
DBI::dbCreateTable(db, "forecasts", data.frame(id=1:3, temperature=20:22))

dbxExecute(db, "UPDATE forecasts SET temperature = 20")

dbxExecute(db, "UPDATE forecasts SET temperature = ?", params=list(20))

dbxExecute(db, "UPDATE forecasts SET temperature = ? WHERE id IN (?)", params=list(20, 1:3))
</code></pre>

<hr>
<h2 id='dbxInsert'>Insert records</h2><span id='topic+dbxInsert'></span>

<h3>Description</h3>

<p>Insert records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxInsert(conn, table, records, batch_size = NULL, returning = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxInsert_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object</p>
</td></tr>
<tr><td><code id="dbxInsert_+3A_table">table</code></td>
<td>
<p>The table name to insert</p>
</td></tr>
<tr><td><code id="dbxInsert_+3A_records">records</code></td>
<td>
<p>A data frame of records to insert</p>
</td></tr>
<tr><td><code id="dbxInsert_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of records to insert in a single statement (defaults to all)</p>
</td></tr>
<tr><td><code id="dbxInsert_+3A_returning">returning</code></td>
<td>
<p>Columns to return</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- dbxConnect(adapter="sqlite", dbname=":memory:")
table &lt;- "forecasts"
DBI::dbCreateTable(db, table, data.frame(id=1:3, temperature=20:22))

records &lt;- data.frame(temperature=c(32, 25))
dbxInsert(db, table, records)
</code></pre>

<hr>
<h2 id='dbxSelect'>Select records</h2><span id='topic+dbxSelect'></span>

<h3>Description</h3>

<p>Select records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxSelect(conn, statement, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxSelect_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object</p>
</td></tr>
<tr><td><code id="dbxSelect_+3A_statement">statement</code></td>
<td>
<p>The SQL statement to use</p>
</td></tr>
<tr><td><code id="dbxSelect_+3A_params">params</code></td>
<td>
<p>Parameters to bind</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- dbxConnect(adapter="sqlite", dbname=":memory:")
DBI::dbCreateTable(db, "forecasts", data.frame(id=1:3, temperature=20:22))

dbxSelect(db, "SELECT * FROM forecasts")

dbxSelect(db, "SELECT * FROM forecasts WHERE id = ?", params=list(1))

dbxSelect(db, "SELECT * FROM forecasts WHERE id IN (?)", params=list(1:3))
</code></pre>

<hr>
<h2 id='dbxUpdate'>Update records</h2><span id='topic+dbxUpdate'></span>

<h3>Description</h3>

<p>Update records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxUpdate(
  conn,
  table,
  records,
  where_cols,
  batch_size = NULL,
  transaction = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxUpdate_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object</p>
</td></tr>
<tr><td><code id="dbxUpdate_+3A_table">table</code></td>
<td>
<p>The table name to update</p>
</td></tr>
<tr><td><code id="dbxUpdate_+3A_records">records</code></td>
<td>
<p>A data frame of records to insert</p>
</td></tr>
<tr><td><code id="dbxUpdate_+3A_where_cols">where_cols</code></td>
<td>
<p>The columns to use for WHERE clause</p>
</td></tr>
<tr><td><code id="dbxUpdate_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of records to update in a single transaction (defaults to all)</p>
</td></tr>
<tr><td><code id="dbxUpdate_+3A_transaction">transaction</code></td>
<td>
<p>Wrap the update in a transaction (defaults to true)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>db &lt;- dbxConnect(adapter="sqlite", dbname=":memory:")
table &lt;- "forecasts"
DBI::dbCreateTable(db, table, data.frame(id=1:3, temperature=20:22))

records &lt;- data.frame(id=c(1, 2), temperature=c(16, 13))
dbxUpdate(db, table, records, where_cols=c("id"))
</code></pre>

<hr>
<h2 id='dbxUpsert'>Upsert records</h2><span id='topic+dbxUpsert'></span>

<h3>Description</h3>

<p>Upsert records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbxUpsert(
  conn,
  table,
  records,
  where_cols,
  batch_size = NULL,
  returning = NULL,
  skip_existing = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbxUpsert_+3A_conn">conn</code></td>
<td>
<p>A DBIConnection object</p>
</td></tr>
<tr><td><code id="dbxUpsert_+3A_table">table</code></td>
<td>
<p>The table name to upsert</p>
</td></tr>
<tr><td><code id="dbxUpsert_+3A_records">records</code></td>
<td>
<p>A data frame of records to upsert</p>
</td></tr>
<tr><td><code id="dbxUpsert_+3A_where_cols">where_cols</code></td>
<td>
<p>The columns to use for WHERE clause</p>
</td></tr>
<tr><td><code id="dbxUpsert_+3A_batch_size">batch_size</code></td>
<td>
<p>The number of records to upsert in a single statement (defaults to all)</p>
</td></tr>
<tr><td><code id="dbxUpsert_+3A_returning">returning</code></td>
<td>
<p>Columns to return</p>
</td></tr>
<tr><td><code id="dbxUpsert_+3A_skip_existing">skip_existing</code></td>
<td>
<p>Skip existing rows</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

db &lt;- dbxConnect(adapter="postgres", dbname="dbx")
table &lt;- "forecasts"
DBI::dbCreateTable(db, table, data.frame(id=1:3, temperature=20:22))

records &lt;- data.frame(id=c(3, 4), temperature=c(20, 25))
dbxUpsert(db, table, records, where_cols=c("id"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
