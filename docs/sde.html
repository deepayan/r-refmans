<!DOCTYPE html><html><head><title>Help for package sde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BM'><p>Brownian motion, Brownian bridge, and geometric Brownian motion simulators</p></a></li>
<li><a href='#cpoint'><p>Volatility change-point estimator for diffusion processes</p></a></li>
<li><a href='#DBridge'><p>Simulation of diffusion bridge</p></a></li>
<li><a href='#dcElerian'><p>Approximated conditional law of a diffusion process by Elerian's method</p></a></li>
<li><a href='#dcEuler'><p>Approximated conditional law of a diffusion process</p></a></li>
<li><a href='#dcKessler'><p>Approximated conditional law of a diffusion process by Kessler's method</p></a></li>
<li><a href='#dcOzaki'><p>Approximated conditional law of a diffusion process by Ozaki's method</p></a></li>
<li><a href='#dcShoji'><p>Approximated conditional law of a diffusion process by the Shoji-Ozaki method</p></a></li>
<li><a href='#dcSim'><p>Pedersen's simulated transition density</p></a></li>
<li><a href='#DWJ'><p>Weekly closings of the Dow-Jones industrial average</p></a></li>
<li><a href='#EULERloglik'><p>Euler approximation of the likelihood</p></a></li>
<li><a href='#gmm'><p>Generalized method of moments estimator</p></a></li>
<li><a href='#HPloglik'><p>Ait-Sahalia  Hermite polynomial expansion  approximation</p>
of the likelihood</a></li>
<li><a href='#ksmooth'><p>Nonparametric invariant density, drift, and diffusion coefficient estimation</p></a></li>
<li><a href='#linear.mart.ef'><p>Linear martingale estimating function</p></a></li>
<li><a href='#MOdist'><p>Markov Operator distance for clustering diffusion processes.</p></a></li>
<li><a href='#quotes'><p>Daily closings of 20 financial time series from 2006-01-03 to 2007-12-31</p></a></li>
<li><a href='#rcBS'><p>Black-Scholes-Merton or geometric Brownian motion process conditional law</p></a></li>
<li><a href='#rcCIR'><p>Conditional law of the Cox-Ingersoll-Ross process</p></a></li>
<li><a href='#rcOU'><p>Ornstein-Uhlenbeck or Vasicek process conditional law</p></a></li>
<li><a href='#rsCIR'><p>Cox-Ingersoll-Ross process stationary law</p></a></li>
<li><a href='#rsOU'><p>Ornstein-Uhlenbeck or Vasicek process stationary law</p></a></li>
<li><a href='#sde.sim'><p>Simulation of stochastic differential equation</p></a></li>
<li><a href='#sdeAIC'><p>Akaike's information criterion for diffusion processes</p></a></li>
<li><a href='#sdeDiv'><p>Phi-Divergences test for diffusion processes</p></a></li>
<li><a href='#SIMloglik'><p>Pedersen's approximation of the likelihood</p></a></li>
<li><a href='#simple.ef'><p>Simple estimating functions of types I and II</p></a></li>
<li><a href='#simple.ef2'><p>Simple estimating function based on the infinitesimal generator a the diffusion process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Inference for Stochastic Differential Equations</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.18</td>
</tr>
<tr>
<td>Author:</td>
<td>Stefano Maria Iacus</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS, stats4, fda, zoo</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stefano Maria Iacus &lt;siacus@iq.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Companion package to the book Simulation and Inference for
        Stochastic Differential Equations With R Examples, ISBN
        978-0-387-75838-1, Springer, NY.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-08 20:16:00 UTC; jago</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-09 07:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='BM'>Brownian motion, Brownian bridge, and geometric Brownian motion simulators</h2><span id='topic+BM'></span><span id='topic+BBridge'></span><span id='topic+GBM'></span>

<h3>Description</h3>

<p>Brownian motion, Brownian bridge, and geometric Brownian motion simulators.</p>


<h3>Usage</h3>

<pre><code class='language-R'>BBridge(x=0, y=0, t0=0, T=1, N=100)
BM(x=0, t0=0, T=1, N=100)
GBM(x=1, r=0, sigma=1, T=1, N=100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BM_+3A_x">x</code></td>
<td>
<p>initial value of the process at time <code>t0</code>.</p>
</td></tr>
<tr><td><code id="BM_+3A_y">y</code></td>
<td>
<p>terminal value of the process at time <code>T</code>.</p>
</td></tr>
<tr><td><code id="BM_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="BM_+3A_r">r</code></td>
<td>
<p>the interest rate of the GBM.</p>
</td></tr>
<tr><td><code id="BM_+3A_sigma">sigma</code></td>
<td>
<p>the volatility of the GBM.</p>
</td></tr>
<tr><td><code id="BM_+3A_t">T</code></td>
<td>
<p>final time.</p>
</td></tr>
<tr><td><code id="BM_+3A_n">N</code></td>
<td>
<p>number of intervals in which to split <code>[t0,T]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return an invisible <code>ts</code> object containing
a trajectory of the process calculated on a grid of <code>N+1</code>
equidistant points between <code>t0</code> and <code>T</code>; i.e., 
<code>t[i] = t0 + (T-t0)*i/N</code>, <code>i in 0:N</code>.	<code>t0=0</code> for the
geometric Brownian motion.
</p>
<p>The function <code>BBridge</code> returns a trajectory of the Brownian bridge 
starting at <code>x</code> at time <code>t0</code> and
ending at <code>y</code> at time <code>T</code>; i.e., 
</p>
<p style="text-align: center;"><code class="reqn">\{B(t), t_0 \leq t \leq T | B(t_0)=x, B(T)=y\}.</code>
</p>

<p>The function <code>BM</code> returns 
a trajectory of the translated 
Brownian motion <code class="reqn">B(t), t \geq 0 | B(t_0)=x</code>; 
i.e., <code class="reqn">x+B(t-t_0)</code> for <code>t &gt;= t0</code>. 
The standard Brownian motion is obtained
choosing <code>x=0</code> and <code>t0=0</code> (the default values).
</p>
<p>The function <code>GBM</code> returns a trajectory of the geometric Brownian motion
starting at <code>x</code> at time <code>t0=0</code>; i.e., the process
</p>
<p style="text-align: center;"><code class="reqn">S(t) = x  \exp\{(r-\sigma^2/2)t + \sigma B(t)\}.</code>
</p>



<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>an invisible <code>ts</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(BM())
plot(BBridge())
plot(GBM())
</code></pre>

<hr>
<h2 id='cpoint'>Volatility change-point estimator for diffusion processes</h2><span id='topic+cpoint'></span>

<h3>Description</h3>

<p>Volatility change-point estimator for diffusion processes based on least squares.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpoint(x, mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpoint_+3A_x">x</code></td>
<td>
<p>a <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="cpoint_+3A_mu">mu</code></td>
<td>
<p>a function of <code>x</code> describing the drift coefficient.</p>
</td></tr>
<tr><td><code id="cpoint_+3A_sigma">sigma</code></td>
<td>
<p>a function of <code>x</code> describing the diffusion coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a list of  elements containing the discrete <code>k0</code> and continuous <code>tau0</code>
change-point instant, the estimated volatilities before (<code>theta1</code>) and after (<code>theta2</code>) the time change.
The model is assumed to be of the  form
</p>
<p style="text-align: center;"><code class="reqn">{\rm d}X_t = b(X_t){\rm d}t + \theta \sigma(X_t){\rm d}W_t</code>
</p>

<p>where <code>theta</code> = <code>theta1</code> for <code>t&lt;=tau0</code> and <code>theta</code> = <code>theta2</code> otherwise.
</p>
<p>If the drift coefficient is unknown, the  model
</p>
<p style="text-align: center;"><code class="reqn">{\rm d}X_t = b(X_t){\rm d}t + \theta {\rm d}W_t</code>
</p>

<p>is considered and <code>b</code> is estimated nonparametrically.
</p>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>Examples</h3>

<pre><code class='language-R'>tau0 &lt;- 0.6
k0 &lt;- ceiling(1000*tau0)
set.seed(123)
X1 &lt;- sde.sim(X0=1, N=2*k0, t0=0, T=tau0, model="CIR", 
              theta=c(6,2,1))
X2 &lt;- sde.sim(X0=X1[2*k0+1], N=2*(1000-k0), t0=tau0, 
   T=1, model="CIR", theta=c(6,2,3))

Y &lt;- ts(c(X1,X2[-1]), start=0, deltat=deltat(X1))
X &lt;- window(Y,deltat=0.01) 
DELTA &lt;- deltat(X)
n &lt;- length(X)

mu &lt;- function(x) 6-2*x
sigma &lt;- function(x) sqrt(x)

cp &lt;- cpoint(X,mu,sigma)
cp
plot(X)
abline(v=tau0,lty=3)
abline(v=cp$tau0,col="red")

# nonparametric estimation
cpoint(X)
</code></pre>

<hr>
<h2 id='DBridge'>Simulation of diffusion bridge</h2><span id='topic+DBridge'></span>

<h3>Description</h3>

<p>Simulation of diffusion bridge.</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBridge(x=0, y=0, t0=0, T=1, delta, drift, sigma, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBridge_+3A_x">x</code></td>
<td>
<p>initial value of the process at time <code>t0</code>.</p>
</td></tr>
<tr><td><code id="DBridge_+3A_y">y</code></td>
<td>
<p>terminal value of the process at time <code>T</code>.</p>
</td></tr>
<tr><td><code id="DBridge_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="DBridge_+3A_delta">delta</code></td>
<td>
<p>time step of the simulation.</p>
</td></tr>
<tr><td><code id="DBridge_+3A_drift">drift</code></td>
<td>
<p>drift coefficient: an expression of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="DBridge_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient: an expression of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="DBridge_+3A_t">T</code></td>
<td>
<p>final time.</p>
</td></tr>
<tr><td><code id="DBridge_+3A_...">...</code></td>
<td>
<p>passed to the <code>sde.sim</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a trajectory of the diffusion bridge 
starting at <code>x</code> at time <code>t0</code> and
ending at <code>y</code> at time <code>T</code>.
</p>
<p>The function uses the <code>sde.sim</code> function to simulate the paths internally.
Refer to the <code>sde.sim</code> documentation for further information about the
argument &ldquo;<code>...</code>&rdquo;
</p>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>an invisible <code>ts</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Bladt, M., Soerensen, M. (2007) Simple simulation of diffusion bridges 
with application to likelihood inference for diffusions, mimeo.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sde.sim">sde.sim</a></code>, <code><a href="#topic+BBridge">BBridge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- expression((3-x))
s &lt;- expression(1.2*sqrt(x))
par(mar=c(3,3,1,1))
par(mfrow=c(2,1)) 
set.seed(123)
X &lt;- DBridge(x=1.7,y=0.5, delta=0.01, drift=d, sigma=s)
plot(X)
X &lt;- DBridge(x=1,y=5, delta=0.01, drift=d, sigma=s)
plot(X)
</code></pre>

<hr>
<h2 id='dcElerian'>Approximated conditional law of a diffusion process by Elerian's method</h2><span id='topic+dcElerian'></span>

<h3>Description</h3>

<p>Approximated conditional densities for <code class="reqn">X(t) | X(t_0) = x_0</code> of a diffusion process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcElerian(x, t, x0, t0, theta, d, s, sx, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcElerian_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_t">t</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t0</code>; see details.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_theta">theta</code></td>
<td>
<p>parameter of the process; see details.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_d">d</code></td>
<td>
<p>drift coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_s">s</code></td>
<td>
<p>diffusion coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcElerian_+3A_sx">sx</code></td>
<td>
<p>partial derivative w.r.t. <code>x</code> of the
diffusion coefficient; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of the conditional density of
<code class="reqn">X(t) | X(t_0) = x_0</code> at point <code>x</code>. 
</p>
<p>All the functions <code>d</code>, <code>s</code>,
and <code>sx</code> must be functions of <code>t</code>, <code>x</code>, and <code>theta</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Elerian, O. (1998) A note on the existence of a closed form conditional 
density for the Milstein scheme, <em>Working Paper, Nuffield College, 
Oxford University</em>. Available at <a href="http://www.nuff.ox.ac.uk/economics/papers/">http://www.nuff.ox.ac.uk/economics/papers/</a>
</p>

<hr>
<h2 id='dcEuler'>Approximated conditional law of a diffusion process</h2><span id='topic+dcEuler'></span>

<h3>Description</h3>

<p>Approximated conditional densities for <code class="reqn">X(t) | X(t_0) = x_0</code> of a diffusion process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcEuler(x, t, x0, t0, theta, d, s, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcEuler_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcEuler_+3A_t">t</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="dcEuler_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t0</code>; see details.</p>
</td></tr>
<tr><td><code id="dcEuler_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="dcEuler_+3A_theta">theta</code></td>
<td>
<p>parameter of the process; see details.</p>
</td></tr>
<tr><td><code id="dcEuler_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="dcEuler_+3A_d">d</code></td>
<td>
<p>drift coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcEuler_+3A_s">s</code></td>
<td>
<p>diffusion coefficient as a function; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of the conditional density of
<code class="reqn">X(t) | X(t_0) = x_0</code> at point <code>x</code>. 
</p>
<p>The functions <code>d</code> and <code>s</code> must be functions of <code>t</code>, 
<code>x</code>, and <code>theta</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>

<hr>
<h2 id='dcKessler'>Approximated conditional law of a diffusion process by Kessler's method</h2><span id='topic+dcKessler'></span>

<h3>Description</h3>

<p>Approximated conditional densities for <code class="reqn">X(t) | X(t_0) = x_0</code> of a diffusion process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcKessler(x, t, x0, t0, theta, d, dx, dxx, s, sx, sxx, 
          log=FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcKessler_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_t">t</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t0</code>; see details.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_theta">theta</code></td>
<td>
<p>parameter of the process; see details.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_d">d</code></td>
<td>
<p>drift coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_dx">dx</code></td>
<td>
<p>partial derivative w.r.t. <code>x</code> of the
drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_dxx">dxx</code></td>
<td>
<p>second partial derivative wrt <code>x^2</code> of the
drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_s">s</code></td>
<td>
<p>diffusion coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_sx">sx</code></td>
<td>
<p>partial derivative w.r.t. <code>x</code> of the
diffusion coefficient; see details.</p>
</td></tr>
<tr><td><code id="dcKessler_+3A_sxx">sxx</code></td>
<td>
<p>second partial derivative w.r.t. <code>x^2</code> of the
diffusion coefficient; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of the conditional density of
<code class="reqn">X(t) | X(t_0) = x_0</code> at point <code>x</code>. 
</p>
<p>All the functions <code>d</code>, <code>dx</code>, <code>dxx</code>, <code>dt</code>, <code>s</code>, <code>sx</code>, 
and <code>sxx</code> must be functions of <code>t</code>, <code>x</code>, and <code>theta</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Kessler, M. (1997)  Estimation of an ergodic diffusion from discrete observations, 
<em>Scand. J. Statist.</em>, 24, 211-229.
</p>

<hr>
<h2 id='dcOzaki'>Approximated conditional law of a diffusion process by Ozaki's method</h2><span id='topic+dcOzaki'></span>

<h3>Description</h3>

<p>Approximated conditional densities for <code class="reqn">X(t) | X(t_0) = x_0</code> of a diffusion process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcOzaki(x, t, x0, t0, theta, d, dx, s, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcOzaki_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_t">t</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t0</code>; see details.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_theta">theta</code></td>
<td>
<p>parameter of the process; see details.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_d">d</code></td>
<td>
<p>drift coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_dx">dx</code></td>
<td>
<p>partial derivative w.r.t. <code>x</code> of the
drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="dcOzaki_+3A_s">s</code></td>
<td>
<p>diffusion coefficient as a function; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of the conditional density of
<code class="reqn">X(t) | X(t_0) = x_0</code> at point <code>x</code>. 
</p>
<p>All the functions <code>d</code>, <code>dx</code>, and <code>s</code> must be functions of <code>t</code>, <code>x</code>, and <code>theta</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Ozaki, T. (1992) A bridge between nonlinear time series models and 
nonlinear stochastic dynamical systems: A local linearization approach, 
<em>Statistica Sinica</em>, 2, 25-83.
</p>

<hr>
<h2 id='dcShoji'>Approximated conditional law of a diffusion process by the Shoji-Ozaki method</h2><span id='topic+dcShoji'></span>

<h3>Description</h3>

<p>Approximated conditional densities for <code class="reqn">X(t) | X(t_0) = x_0</code> of a diffusion process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcShoji(x, t, x0, t0, theta, d, dx, dxx, dt, s, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcShoji_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_t">t</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t0</code>; see details.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_t0">t0</code></td>
<td>
<p>initial time.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_theta">theta</code></td>
<td>
<p>parameter of the process; see details.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_d">d</code></td>
<td>
<p>drift coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_dx">dx</code></td>
<td>
<p>partial derivative w.r.t. <code>x</code> of the
drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_dxx">dxx</code></td>
<td>
<p>second partial derivative w.r.t. <code>x^2</code> of the
drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_dt">dt</code></td>
<td>
<p>partial derivative w.r.t. <code>t</code> of the
drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="dcShoji_+3A_s">s</code></td>
<td>
<p>diffusion coefficient as a function; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of the conditional density of
<code class="reqn">X(t) | X(t_0) = x_0</code> at point <code>x</code>. 
</p>
<p>All the functions <code>d</code>, <code>dx</code>, <code>dxx</code>, <code>dt</code>, and <code>s</code> 
must be functions of <code>t</code>, <code>x</code>, and <code>theta</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Shoji, L., Ozaki, T. (1998) Estimation for nonlinear stochastic differential
equations by a local linearization method, 
<em>Stochastic Analysis and Applications</em>, 16, 733-752.
</p>

<hr>
<h2 id='dcSim'>Pedersen's simulated transition density</h2><span id='topic+dcSim'></span>

<h3>Description</h3>

<p>Simulated transition density <code class="reqn">X(t) | X(t_0) = x_0</code>X(t) | X(t0) = x0 of a diffusion process based on
Pedersen's method.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcSim(x0, x, t, d, s, theta, M=10000, N=10, log=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcSim_+3A_x0">x0</code></td>
<td>
<p>the value of the  process at time <code>0</code>.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_x">x</code></td>
<td>
<p>value in which to evaluate the conditional density.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_t">t</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_theta">theta</code></td>
<td>
<p>parameter of the process; see details.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_d">d</code></td>
<td>
<p>drift coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_s">s</code></td>
<td>
<p>diffusion coefficient as a function; see details.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_n">N</code></td>
<td>
<p>number of subintervals; see details.</p>
</td></tr>
<tr><td><code id="dcSim_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo simulations, which should be an even number; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns the value of the conditional density of
<code class="reqn">X(t) | X(0) = x_0</code> at point <code>x</code>. 
</p>
<p>The functions <code>d</code> and <code>s</code>, must be functions of <code>t</code>, 
<code>x</code>, and <code>theta</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Pedersen, A. R. (1995) A new approach to maximum likelihood estimation for 
stochastic differential equations based on discrete observations,
<em>Scand. J. Statist.</em>, 22, 55-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d1 &lt;- function(t,x,theta) theta[1]*(theta[2]-x)
s1 &lt;- function(t,x,theta) theta[3]*sqrt(x)

from &lt;- 0.08
x &lt;- seq(0,0.2, length=100)
sle10 &lt;- NULL
sle2 &lt;- NULL
sle5 &lt;- NULL
true &lt;- NULL
set.seed(123)
for(to in x){
 sle2 &lt;- c(sle2, dcSim(from, to, 0.5, d1, s1, 
    theta=c(2,0.02,0.15), M=50000,N=2))
 sle5 &lt;- c(sle5, dcSim(from, to, 0.5, d1, s1, 
    theta=c(2,0.02,0.15), M=50000,N=5))
 sle10 &lt;- c(sle10, dcSim(from, to, 0.5, d1, s1, 
    theta=c(2,0.02,0.15), M=50000,N=10))
 true &lt;- c(true, dcCIR(to, 0.5, from, c(2*0.02,2,0.15)))
}

par(mar=c(5,5,1,1))
plot(x, true, type="l", ylab="conditional density")
lines(x, sle2, lty=4)
lines(x, sle5, lty=2)
lines(x, sle10, lty=3)
legend(0.15,20, legend=c("exact","N=2", "N=5", "N=10"), 
   lty=c(1,2,4,3))

## End(Not run)</code></pre>

<hr>
<h2 id='DWJ'>Weekly closings of the Dow-Jones industrial average</h2><span id='topic+DWJ'></span>

<h3>Description</h3>

<p>This dataset contains the
weekly closings of the Dow-Jones industrial average in the period July 1971&ndash;August 1974.
These data were proposed to test
change-point estimators. There are 162 data, and the main evidence found by several authors 
is that a change in the variance occurred around the
third week of March 1973. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DWJ)</code></pre>


<h3>References</h3>

<p>Hsu, D.A. (1977) Tests for variance shift at an unknown time point, <em>Appl. Statist.</em>, 26(3), 279-284.
</p>
<p>Hsu, D.A. (1979) Detecting shifts of parameter in gamma sequences with applications to stock price
and air traffic flow analysis, <em>Journal American Stat. Ass.</em>, 74(365), 31-40.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DWJ)
ret &lt;- diff(DWJ)/DWJ[-length(DWJ)]

par(mfrow=c(2,1))
par(mar=c(3,3,2,1))
plot(DWJ,main="Dow-Jones closings",ylab="",type="p")
plot(ret,main="Dow-Jones returns",ylab="",type="p")

cp &lt;- cpoint(ret)
cp
abline(v=cp$tau0,lty=3)

cp &lt;- cpoint(window(ret,end=cp$tau0))
cp
abline(v=cp$tau0,lty=3)
</code></pre>

<hr>
<h2 id='EULERloglik'>Euler approximation of the likelihood</h2><span id='topic+EULERloglik'></span>

<h3>Description</h3>

<p>Euler approximation 
of the likelihood of a process solution of a stochastic differential equation.
These functions are useful to calculate approximated maximum likelihood estimators
when the transition density of the process is not known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EULERloglik(X, theta, d, s, log = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EULERloglik_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="EULERloglik_+3A_theta">theta</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="EULERloglik_+3A_d">d</code>, <code id="EULERloglik_+3A_s">s</code></td>
<td>
<p>drift and diffusion coefficients; see details.</p>
</td></tr>
<tr><td><code id="EULERloglik_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, the log-likelihood is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>EULERloglik</code> returns the Euler approximation of the
log-likelihood. The functions <code>s</code> and <code>d</code> are the drift and diffusion
coefficients with arguments <code>(t,x,theta)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d &lt;- expression(-1*x)
s &lt;- expression(2) 
sde.sim(drift=d, sigma=s) -&gt; X

S &lt;- function(t, x, theta) sqrt(theta[2])
B &lt;- function(t, x, theta) -theta[1]*x

true.loglik &lt;- function(theta){
 DELTA &lt;- deltat(X)
 lik &lt;- 0
 for(i in 2:length(X))
  lik &lt;- lik + dnorm(X[i], mean=X[i-1]*exp(-theta[1]*DELTA), 
  sd = sqrt((1-exp(-2*theta[1]*DELTA))*
            theta[2]/(2*theta[1])),TRUE)
 lik  
}

xx &lt;- seq(-3,3,length=100)
sapply(xx, function(x) true.loglik(c(x,4))) -&gt; py
sapply(xx, function(x) EULERloglik(X,c(x,4),B,S)) -&gt; pz

# true likelihood
plot(xx,py,type="l",xlab=expression(beta),ylab="log-likelihood") 
lines(xx,pz, lty=2) # Euler
</code></pre>

<hr>
<h2 id='gmm'>Generalized method of moments estimator</h2><span id='topic+gmm'></span>

<h3>Description</h3>

<p>Implementation of the estimator of the generalized method of moments by Hansen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmm(X, u, dim, guess, lower, upper, maxiter=30, tol1=1e-3, 
   tol2=1e-3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmm_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="gmm_+3A_u">u</code></td>
<td>
<p>a function of <code>x</code>, <code>y</code>, and <code>theta</code> and <code>DELTA</code>; see details.</p>
</td></tr>
<tr><td><code id="gmm_+3A_dim">dim</code></td>
<td>
<p>dimension of parameter space; see details.</p>
</td></tr>
<tr><td><code id="gmm_+3A_guess">guess</code></td>
<td>
<p>initial value of the parameters; see details.</p>
</td></tr>
<tr><td><code id="gmm_+3A_lower">lower</code></td>
<td>
<p>lower bounds for the parameters; see details.</p>
</td></tr>
<tr><td><code id="gmm_+3A_upper">upper</code></td>
<td>
<p>upper bounds for the parameters; see details.</p>
</td></tr>
<tr><td><code id="gmm_+3A_tol1">tol1</code></td>
<td>
<p>tolerance for parameters; see details.</p>
</td></tr>
<tr><td><code id="gmm_+3A_tol2">tol2</code></td>
<td>
<p>tolerance for Q1; see details.</p>
</td></tr>
<tr><td><code id="gmm_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations at the second stage; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>gmm</code> minimizes at the first stage
the  function <code>Q(theta) = t(Gn(theta)) * Gn(theta)</code> with respect to
<code>theta</code>, where <code>Gn(theta) =  mean(u(X[i+1], X[i], theta))</code>.
Then a  matrix of weights <code>W</code> is obtained by inverting an estimate
of the long-run covariance and the quadratic function 
<code>Q1(theta) = t(Gn(theta)) * W *  Gn(theta)</code> with starting value <code>theta1</code> (the solution
at the first stage).  The second stage is iterated until the first of these
conditions verifies: (1) that the number of iterations reaches <code>maxiter</code>; (2) that the Euclidean
distance between <code>theta1</code> and <code>theta2 &lt; tol1</code>; (3) that <code>Q1 &lt; tol2</code>. 
</p>
<p>The function <code>u</code> must be a function of <code>(u,y,theta,DELTA)</code> and should
return a vector of the same length as the dimension of the parameter space. The sanity checks
are left to the user.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a list with parameter estimates, the value of <code>Q1</code> at the minimum, and the Hessian</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Hansen, L.P. (1982) Large Sample Properties of Generalized Method of Moments Estimators, 
<em>Econometrica</em>, 50(4),  1029-1054.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
alpha &lt;- 0.5
beta &lt;- 0.2
sigma &lt;- sqrt(0.05)
true &lt;- c(alpha, beta, sigma)
names(true) &lt;- c("alpha", "beta", "sigma")

x0 &lt;- rsCIR(1,theta=true)
set.seed(123)
sde.sim(X0=x0,model="CIR",theta=true,N=500000,delta=0.001) -&gt; X
X &lt;- window(X, deltat=0.1)
DELTA = deltat(X)
n &lt;- length(X) 
X &lt;- window(X, start=n*DELTA*0.5)
plot(X)

u &lt;- function(x, y, theta, DELTA){
  c.mean &lt;- theta[1]/theta[2] + 
             (y-theta[1]/theta[2])*exp(-theta[2]*DELTA)
  c.var &lt;- ((y*theta[3]^2 * 
     (exp(-theta[2]*DELTA)-exp(-2*theta[2]*DELTA))/theta[2] +  
	  theta[1]*theta[3]^2*
	  (1-exp(-2*theta[2]*DELTA))/(2*theta[2]^2)))  
  cbind(x-c.mean,y*(x-c.mean), c.var-(x-c.mean)^2, 
        y*(c.var-(x-c.mean)^2))  
}

CIR.lik &lt;- function(theta1,theta2,theta3) {
 n &lt;- length(X)
 dt &lt;- deltat(X)
 -sum(dcCIR(x=X[2:n], Dt=dt, x0=X[1:(n-1)], 
   theta=c(theta1,theta2,theta3), log=TRUE))
}

fit &lt;- mle(CIR.lik, start=list(theta1=.1,  theta2=.1,theta3=.3), 
    method="L-BFGS-B",lower=c(0.001,0.001,0.001), upper=c(1,1,1))
# maximum likelihood estimates
coef(fit)


gmm(X,u, guess=as.numeric(coef(fit)), lower=c(0,0,0), 
    upper=c(1,1,1))

true

## End(Not run)</code></pre>

<hr>
<h2 id='HPloglik'>Ait-Sahalia  Hermite polynomial expansion  approximation 
of the likelihood</h2><span id='topic+HPloglik'></span>

<h3>Description</h3>

<p>Ait-Sahalia Hermite polynomial expansion and Euler approximation 
of the likelihood of a process solution of a stochastic differential equation.
These functions are useful to calculate approximated maximum likelihood estimators
when the transition density of the process is not known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HPloglik(X, theta, M, F, s, log=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HPloglik_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="HPloglik_+3A_theta">theta</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="HPloglik_+3A_m">M</code></td>
<td>
<p>list of derivatives; see details.</p>
</td></tr>
<tr><td><code id="HPloglik_+3A_f">F</code></td>
<td>
<p>the transform function; see details.</p>
</td></tr>
<tr><td><code id="HPloglik_+3A_s">s</code></td>
<td>
<p>drift and diffusion coefficient; see details.</p>
</td></tr>
<tr><td><code id="HPloglik_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, the log-likelihood is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>HPloglik</code> returns the Hermite polynomial approximation of the
likelihood of a diffusion process transformed to have a unitary diffusion
coefficient. The function <code>F</code> is the transform function, and
<code>s</code> is the original diffusion coefficient. The list of functions
<code>M</code> contains the transformed drift in <code>M[[1]]</code> and the
subsequent six derivatives in <code>x</code> of <code>M[[1]]</code>. The functions
<code>F</code>, <code>s</code>, and <code>M</code> have arguments <code>(t,x,theta)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

 
<p>Ait-Sahalia, Y. (1996) Testing Continuous-Time Models of the Spot Interest Rate,  
<em>Review of Financial Studies</em>, 9(2), 385-426.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d &lt;- expression(-1*x)
s &lt;- expression(2) 
sde.sim(drift=d, sigma=s) -&gt; X

M0 &lt;- function(t, x, theta) -theta[1]*x
M1 &lt;- function(t, x, theta) -theta[1]
M2 &lt;- function(t, x, theta) 0
M3 &lt;- function(t, x, theta) 0
M4 &lt;- function(t, x, theta) 0
M5 &lt;- function(t, x, theta) 0
M6 &lt;- function(t, x, theta) 0
mu &lt;- list(M0, M1, M2, M3, M4, M5, M6)

F &lt;- function(t, x, theta) x/sqrt(theta[2])
S &lt;- function(t, x, theta) sqrt(theta[2])

true.loglik &lt;- function(theta) {
 DELTA &lt;- deltat(X)
 lik &lt;- 0
 for(i in 2:length(X))
  lik &lt;- lik + dnorm(X[i], mean=X[i-1]*exp(-theta[1]*DELTA), 
   sd = sqrt((1-exp(-2*theta[1]*DELTA))*theta[2]/
             (2*theta[1])),TRUE)
 lik  
}

xx &lt;- seq(-3,3,length=100)
sapply(xx, function(x) HPloglik(X,c(x,4),mu,F,S)) -&gt; px
sapply(xx, function(x) true.loglik(c(x,4))) -&gt; py

plot(xx,px,type="l",xlab=expression(beta),ylab="log-likelihood")
lines(xx,py, lty=3) # true
</code></pre>

<hr>
<h2 id='ksmooth'>Nonparametric invariant density, drift, and diffusion coefficient estimation</h2><span id='topic+ksdrift'></span><span id='topic+ksdiff'></span><span id='topic+ksdens'></span>

<h3>Description</h3>

<p>Implementation of simple Nadaraya-Watson nonparametric 
estimation of drift and diffusion
coefficient, and plain kernel density estimation of the invariant density
for a  one-dimensional diffusion process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksdrift(x, bw, n = 512)
ksdiff(x, bw, n = 512)
ksdens(x, bw, n = 512)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksmooth_+3A_x">x</code></td>
<td>
<p>a <code>ts</code> object.</p>
</td></tr>
<tr><td><code id="ksmooth_+3A_bw">bw</code></td>
<td>
<p>bandwidth.</p>
</td></tr>
<tr><td><code id="ksmooth_+3A_n">n</code></td>
<td>
<p>number of points in which to calculate the estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions return the nonparametric estimate of the drift or
diffusion coefficients for data <code>x</code> using the Nadaraya-Watson estimator 
for diffusion processes.
</p>
<p><code>ksdens</code> returns the density estimates of the invariant density.
</p>
<p>If not provided, the bandwidth <code>bw</code>
is calculated using Scott's rule (i.e., 
<code>bw = len^(-1/5)*sd(x)</code>) where <code>len=length(x)</code> 
is the number of observed points of the diffusion path.
</p>


<h3>Value</h3>

<table>
<tr><td><code>val</code></td>
<td>
<p>an invisible list of <code>x</code> and <code>y</code> coordinates 
and an object of class <code>density</code> in the case of invariant
density estimation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Ait-Sahalia, Y. (1996) Nonparametric pricing of interest rate 
derivative securities, <em>Econometrica</em>, 64, 527-560.
</p>
<p>Bandi, F., Phillips, P. (2003) Fully nonparametric estimation of  
scalar diffusion models, <em>Econometrica</em>, 71, 241-283.
</p>
<p>Florens-Zmirou, D. (1993) On estimating the diffusion coefficient 
from discrete observations,  <em>Journal of Applied Probability</em>, 30, 790-804.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
theta &lt;- c(6,2,1)
X &lt;- sde.sim(X0 = rsCIR(1, theta), model="CIR", theta=theta,
     N=1000,delta=0.1)

b &lt;- function(x)
 theta[1]-theta[2]*x

sigma &lt;- function(x)
 theta[3]*sqrt(x)
  
minX &lt;- min(X)
maxX &lt;- max(X)

par(mfrow=c(3,1))
curve(b,minX,maxX)
lines(ksdrift(X),lty=3)

curve(sigma,minX, maxX)
lines(ksdiff(X),lty=3)

f &lt;-function(x) dsCIR(x, theta)
curve(f,minX,maxX)
lines(ksdens(X),lty=3)
</code></pre>

<hr>
<h2 id='linear.mart.ef'>Linear martingale estimating function</h2><span id='topic+linear.mart.ef'></span>

<h3>Description</h3>

<p>Apply a linear martingale estimating function to find estimates of the
parameters of a process solution of a stochastic differential equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear.mart.ef(X, drift, sigma, a1, a2, guess, lower, upper, 
      c.mean, c.var) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear.mart.ef_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_drift">drift</code></td>
<td>
<p>an expression for the drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_sigma">sigma</code></td>
<td>
<p>an expression for the diffusion coefficient; see details.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_a1">a1</code>, <code id="linear.mart.ef_+3A_a2">a2</code></td>
<td>
<p>weights or instruments.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_c.mean">c.mean</code></td>
<td>
<p>expressions for the conditional mean.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_c.var">c.var</code></td>
<td>
<p>expressions for the conditional variance.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_guess">guess</code></td>
<td>
<p>initial value of the parameters; see details.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_lower">lower</code></td>
<td>
<p>lower bounds for the parameters; see details.</p>
</td></tr>
<tr><td><code id="linear.mart.ef_+3A_upper">upper</code></td>
<td>
<p>upper bounds for the parameters; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>linear.mart.ef</code> minimizes a linear martingale
estimating function that is a particular case of the polynomial
martingale estimating functions.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a vector of estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Bibby, B., Soerensen, M. (1995)  Martingale estimating functions for discretely 
observed diffusion processes,  <em>Bernoulli</em>, 1, 17-39.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
d &lt;- expression(-1 * x)
s &lt;- expression(1) 
x0 &lt;- rnorm(1,sd=sqrt(1/2))
sde.sim(X0=x0,drift=d, sigma=s,N=1000,delta=0.1) -&gt; X
 
d &lt;- expression(-theta * x)
  
linear.mart.ef(X, d, s, a1=expression(-x), lower=0, upper=Inf,
  c.mean=expression(x*exp(-theta*0.1)), 
  c.var=expression((1-exp(-2*theta*0.1))/(2*theta)))
</code></pre>

<hr>
<h2 id='MOdist'>Markov Operator distance for clustering diffusion processes.</h2><span id='topic+MOdist'></span>

<h3>Description</h3>

<p>Markov Operator distance for clustering diffusion processes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MOdist(x, M=50, rangeval=range(x, na.rm=TRUE, finite = TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MOdist_+3A_x">x</code></td>
<td>
<p>one or multi-dimensional time series.</p>
</td></tr>
<tr><td><code id="MOdist_+3A_m">M</code></td>
<td>
<p>number of splines bases used to approximate the Markov Operator.</p>
</td></tr>
<tr><td><code id="MOdist_+3A_rangeval">rangeval</code></td>
<td>
<p>a vector containing lower and upper limit. Default is the range of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function return a lower triangular dist object to be further used 
in cluster analysis (see examples below).
</p>
<p>If <code>x</code> is a one-dimensional time series, the output is the scalar 0, not a <code>dist</code> object.
</p>
<p>If <code>x</code> has less than 2 observations, <code>NA</code> is returned.
</p>
<p>If time series <code>x</code> contains missing data, then <code>x</code> is converted to a <code>zoo</code> object and
missing data are imputed by interpolation.
</p>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>a <code>dist</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>De Gregorio, A. Iacus, S.M. (2008) Clustering of discretely observed diffusion processes, Computational Statistics and Data Analysis, 54(12), 598-606, <a href="https://doi.org/10.1016/j.csda.2009.10.005">doi:10.1016/j.csda.2009.10.005</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(quotes)

plot(quotes)

d &lt;- MOdist(quotes)
cl &lt;- hclust( d )
groups &lt;- cutree(cl, k=4)

cmd &lt;- cmdscale(d)
plot( cmd, col=groups)
text( cmd, labels(d) , col=groups)

plot(quotes, col=groups)

plot(quotes, col=groups,ylim=range(quotes))

## End(Not run)
</code></pre>

<hr>
<h2 id='quotes'>Daily closings of 20 financial time series from 2006-01-03 to 2007-12-31</h2><span id='topic+quotes'></span>

<h3>Description</h3>

<p>This dataset contains the
daily closings of 20 assets from NYSE/NASDAQ. Quotes from 2006-01-03 to 2007-12-31.
</p>
<p>It is an object of class <code>zoo</code>. Original data contained missing data and interpolated.
Used as example data to test the Markov Operator
distance for discretely observed diffusion processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(quotes)</code></pre>


<h3>References</h3>

<p>De Gregorio, A. Iacus, S.M. (2008) Clustering of discretely observed diffusion processes, Computational Statistics and Data Analysis, 54(12), 598-606, <a href="https://doi.org/10.1016/j.csda.2009.10.005">doi:10.1016/j.csda.2009.10.005</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quotes)

plot(quotes)

d &lt;- MOdist(quotes)
cl &lt;- hclust( d )
groups &lt;- cutree(cl, k=4)

cmd &lt;- cmdscale(d)
plot( cmd, col=groups)
text( cmd, labels(d) , col=groups)

plot(quotes, col=groups)

plot(quotes, col=groups,ylim=range(quotes))
</code></pre>

<hr>
<h2 id='rcBS'>Black-Scholes-Merton or geometric Brownian motion process conditional law</h2><span id='topic+rcBS'></span><span id='topic+dcBS'></span><span id='topic+pcBS'></span><span id='topic+qcBS'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and 
random generation for the conditional law <code class="reqn">X(t) | X(0) = x_0</code> 
of the Black-Scholes-Merton process
also known as the geometric Brownian motion process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcBS(x, Dt, x0, theta, log = FALSE)
pcBS(x, Dt, x0, theta, lower.tail = TRUE, log.p = FALSE) 
qcBS(p, Dt, x0, theta, lower.tail = TRUE, log.p = FALSE)
rcBS(n=1, Dt, x0, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcBS_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="rcBS_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="rcBS_+3A_dt">Dt</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="rcBS_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t</code>; see details.</p>
</td></tr>
<tr><td><code id="rcBS_+3A_theta">theta</code></td>
<td>
<p>parameter of the Black-Scholes-Merton process; see details.</p>
</td></tr>
<tr><td><code id="rcBS_+3A_n">n</code></td>
<td>
<p>number of random numbers to generate from the conditional distribution.</p>
</td></tr>
<tr><td><code id="rcBS_+3A_log">log</code>, <code id="rcBS_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="rcBS_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code>P[X &lt;= x]</code>; 
otherwise, <code>P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns quantities related to the conditional law
of the process solution of
</p>
<p style="text-align: center;"><code class="reqn">{\rm d}X_t = \theta_1 X_t {\rm d}t + \theta_2 X_t {\rm d}W_t.</code>
</p>

<p>Constraints: <code class="reqn">\theta_3&gt;0</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p> Black, F.,  Scholes, M.S. (1973) The pricing of options 
and corporate liabilities, <em>Journal of Political Economy</em>, 81, 637-654.
</p>
<p>Merton, R. C. (1973) Theory of rational option pricing, 
<em>Bell Journal of Economics and Management Science</em>, 4(1), 141-183.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcBS(n=1, Dt=0.1, x0=1, theta=c(2,1))
</code></pre>

<hr>
<h2 id='rcCIR'>Conditional law of the Cox-Ingersoll-Ross process</h2><span id='topic+dcCIR'></span><span id='topic+pcCIR'></span><span id='topic+qcCIR'></span><span id='topic+rcCIR'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and 
random generation for the conditional law <code class="reqn">X(t+D_t) | X(t)=x_0</code> of the Cox-Ingersoll-Ross
process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcCIR(x, Dt, x0, theta, log = FALSE)
pcCIR(x, Dt, x0, theta, lower.tail = TRUE, log.p = FALSE) 
qcCIR(p, Dt, x0, theta, lower.tail = TRUE, log.p = FALSE)
rcCIR(n=1, Dt, x0, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcCIR_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="rcCIR_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="rcCIR_+3A_dt">Dt</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="rcCIR_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t</code>; see details.</p>
</td></tr>
<tr><td><code id="rcCIR_+3A_theta">theta</code></td>
<td>
<p>parameter of the Ornstein-Uhlenbeck process; see details.</p>
</td></tr>
<tr><td><code id="rcCIR_+3A_n">n</code></td>
<td>
<p>number of random numbers to generate from the conditional distribution.</p>
</td></tr>
<tr><td><code id="rcCIR_+3A_log">log</code>, <code id="rcCIR_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="rcCIR_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code>P[X &lt;= x]</code>; 
otherwise <code>P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns quantities related to the conditional law
of the process solution of
</p>
<p style="text-align: center;"><code class="reqn">{\rm d}X_t = (\theta_1-\theta_2 X_t){\rm d}t + \theta_3\sqrt{X_t}{\rm d}W_t.</code>
</p>

<p>Constraints: <code class="reqn">2\theta_1&gt; \theta_3^2</code>, all <code class="reqn">\theta</code> positive.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Cox, J.C., Ingersoll, J.E., Ross, S.A. (1985) A theory 
of the term structure of interest rates,  <em>Econometrica</em>, 53, 385-408.</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsCIR">rsCIR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rcCIR(n=1, Dt=0.1, x0=1, theta=c(6,2,2))
</code></pre>

<hr>
<h2 id='rcOU'>Ornstein-Uhlenbeck or Vasicek process conditional law</h2><span id='topic+rcOU'></span><span id='topic+dcOU'></span><span id='topic+pcOU'></span><span id='topic+qcOU'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and 
random generation for the conditional law <code class="reqn">X(t+D_t) | X(t)=x_0</code> of the Ornstein-Uhlenbeck process,
also known as the Vasicek process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcOU(x, Dt, x0, theta, log = FALSE)
pcOU(x, Dt, x0, theta, lower.tail = TRUE, log.p = FALSE) 
qcOU(p, Dt, x0, theta, lower.tail = TRUE, log.p = FALSE)
rcOU(n=1, Dt, x0, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcOU_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="rcOU_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="rcOU_+3A_dt">Dt</code></td>
<td>
<p>lag or time.</p>
</td></tr>
<tr><td><code id="rcOU_+3A_x0">x0</code></td>
<td>
<p>the value of the process at time <code>t</code>; see details.</p>
</td></tr>
<tr><td><code id="rcOU_+3A_theta">theta</code></td>
<td>
<p>parameter of the Ornstein-Uhlenbeck process; see details.</p>
</td></tr>
<tr><td><code id="rcOU_+3A_n">n</code></td>
<td>
<p>number of random numbers to generate from the conditional distribution.</p>
</td></tr>
<tr><td><code id="rcOU_+3A_log">log</code>, <code id="rcOU_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="rcOU_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code>P[X &lt;= x]</code>; 
otherwise <code>P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns quantities related to the conditional law
of the process solution of
</p>
<p style="text-align: center;"><code class="reqn">{\rm d}X_t = (\theta_1 - \theta_2 X_t){\rm d}t + \theta_3 {\rm d}W_t.</code>
</p>

<p>Constraints: <code class="reqn">\theta_2&gt;0, \theta_3&gt;0</code>.
</p>
<p>Please note that the process is stationary only if <code class="reqn">\theta_2&gt;0</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Uhlenbeck, G. E.,  Ornstein, L. S. (1930) On the theory of Brownian motion, 
<em>Phys. Rev.</em>, 36, 823-841.
</p>
<p>Vasicek, O. (1977) An Equilibrium Characterization of the Term 
Structure, <em>Journal of Financial Economics</em>,  5, 177-188. </p>


<h3>See Also</h3>

<p><code><a href="#topic+rsOU">rsOU</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rcOU(n=1, Dt=0.1, x0=1, theta=c(0,2,1))
</code></pre>

<hr>
<h2 id='rsCIR'>Cox-Ingersoll-Ross process stationary law</h2><span id='topic+rsCIR'></span><span id='topic+dsCIR'></span><span id='topic+psCIR'></span><span id='topic+qsCIR'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and 
random generation of the stationary law  for the Cox-Ingersoll-Ross process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsCIR(x, theta, log = FALSE)
psCIR(x, theta, lower.tail = TRUE, log.p = FALSE) 
qsCIR(p, theta, lower.tail = TRUE, log.p = FALSE)
rsCIR(n=1, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsCIR_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="rsCIR_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="rsCIR_+3A_theta">theta</code></td>
<td>
<p>parameter of the Cox-Ingersoll-Ross process; see details.</p>
</td></tr>
<tr><td><code id="rsCIR_+3A_n">n</code></td>
<td>
<p>number of random numbers to generate from the conditional distribution.</p>
</td></tr>
<tr><td><code id="rsCIR_+3A_log">log</code>, <code id="rsCIR_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="rsCIR_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code>P[X &lt;= x]</code>; 
otherwise <code>P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns quantities related to the stationary law
of the process solution of
</p>
<p style="text-align: center;"><code class="reqn">{\rm d}X_t = (\theta_1 - \theta_2 X_t){\rm d}t + \theta_3\sqrt{X_t} {\rm d}W_t.</code>
</p>

<p>Constraints: <code class="reqn">2\theta_1 &gt; \theta_3^2</code>, all <code class="reqn">\theta</code> positive.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Cox, J.C., Ingersoll, J.E., Ross, S.A. (1985) A theory 
of the term structure of interest rates,  <em>Econometrica</em>, 53, 385-408.</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsCIR">rsCIR</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rsCIR(n=1, theta=c(6,2,1))
</code></pre>

<hr>
<h2 id='rsOU'>Ornstein-Uhlenbeck or Vasicek process stationary law</h2><span id='topic+rsOU'></span><span id='topic+dsOU'></span><span id='topic+psOU'></span><span id='topic+qsOU'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and 
random generation for the stationary law of the Ornstein-Uhlenbeck process
also known as the Vasicek process.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsOU(x, theta, log = FALSE)
psOU(x, theta, lower.tail = TRUE, log.p = FALSE) 
qsOU(p, theta, lower.tail = TRUE, log.p = FALSE)
rsOU(n=1, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsOU_+3A_x">x</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="rsOU_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="rsOU_+3A_theta">theta</code></td>
<td>
<p>parameter of the Ornstein-Uhlenbeck process; see details.</p>
</td></tr>
<tr><td><code id="rsOU_+3A_n">n</code></td>
<td>
<p>number of random numbers to generate from the conditional distribution.</p>
</td></tr>
<tr><td><code id="rsOU_+3A_log">log</code>, <code id="rsOU_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities <code class="reqn">p</code> are given as <code class="reqn">\log(p)</code>.</p>
</td></tr>
<tr><td><code id="rsOU_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are <code>P[X &lt;= x]</code>; 
otherwise <code>P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns quantities related to the stationary law
of the process solution of
</p>
<p style="text-align: center;"><code class="reqn">{\rm d}X_t = (\theta_1-\theta_2 X_t){\rm d}t + \theta_3 {\rm d}W_t.</code>
</p>

<p>Contraints: <code class="reqn">theta_2&gt;0, \theta_3&gt;0</code>.
</p>
<p>Please note that the process is stationary only if <code class="reqn">\theta_2&gt;0</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Uhlenbeck, G. E.,  Ornstein, L. S. (1930) On the theory of Brownian motion, 
<em>Phys. Rev.</em>, 36, 823-841.
</p>
<p>Vasicek, O. (1977) An Equilibrium Characterization of the Term 
Structure, <em>Journal of Financial Economics</em>,  5, 177-188. </p>


<h3>See Also</h3>

<p><code><a href="#topic+rcOU">rcOU</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>rsOU(n=1, theta=c(0,2,1))
</code></pre>

<hr>
<h2 id='sde.sim'>Simulation of stochastic differential equation</h2><span id='topic+sde.sim'></span>

<h3>Description</h3>

<p>Generic interface to different methods of simulation of solutions to stochastic
differential equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sde.sim(t0 = 0, T = 1, X0 = 1, N = 100, delta, drift, sigma, 
   drift.x, sigma.x, drift.xx, sigma.xx, drift.t, 
   method = c("euler", "milstein", "KPS", "milstein2", 
   "cdist","ozaki","shoji","EA"), 
   alpha = 0.5, eta = 0.5, pred.corr = T, rcdist = NULL, 
   theta = NULL, model = c("CIR", "VAS", "OU", "BS"),
   k1, k2, phi, max.psi = 1000, rh, A, M=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sde.sim_+3A_t0">t0</code></td>
<td>
<p>time origin.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_t">T</code></td>
<td>
<p>horizon of simulation.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_x0">X0</code></td>
<td>
<p>initial value of the process.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_n">N</code></td>
<td>
<p>number of simulation steps.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_m">M</code></td>
<td>
<p>number of trajectories.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_delta">delta</code></td>
<td>
<p>time step of the simulation.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_drift">drift</code></td>
<td>
<p>drift coefficient: an expression of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_sigma">sigma</code></td>
<td>
<p>diffusion coefficient: an expression of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_drift.x">drift.x</code></td>
<td>
<p>partial derivative of the drift coefficient w.r.t. <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_sigma.x">sigma.x</code></td>
<td>
<p>partial derivative of the diffusion coefficient w.r.t.  <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_drift.xx">drift.xx</code></td>
<td>
<p>second partial derivative of the drift coefficient w.r.t.  <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_sigma.xx">sigma.xx</code></td>
<td>
<p>second partial derivative of the diffusion coefficient w.r.t. <code>x</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_drift.t">drift.t</code></td>
<td>
<p>partial derivative of the drift coefficient w.r.t.  <code>t</code>: a function of two variables <code>t</code> and <code>x</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_method">method</code></td>
<td>
<p>method of simulation; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_alpha">alpha</code></td>
<td>
<p>weight <code>alpha</code> of the predictor-corrector scheme.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_eta">eta</code></td>
<td>
<p>weight <code>eta</code> of the predictor-corrector scheme.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_pred.corr">pred.corr</code></td>
<td>
<p>boolean: whether to apply the predictor-correct adjustment; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_rcdist">rcdist</code></td>
<td>
<p>a function that is a random number generator from the conditional distribution of the process; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_theta">theta</code></td>
<td>
<p>vector of parameters for <code>cdist</code>; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_model">model</code></td>
<td>
<p>model from which to simulate; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_k1">k1</code></td>
<td>
<p>lower bound for <code>psi(x)</code>; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_k2">k2</code></td>
<td>
<p>upper bound for <code>psi(x)</code>; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_phi">phi</code></td>
<td>
<p>the function <code>psi(x) - k1</code>.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_max.psi">max.psi</code></td>
<td>
<p>upper value of the support of <code>psi</code> to search for its maximum.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_rh">rh</code></td>
<td>
<p>the rejection function; see details.</p>
</td></tr>
<tr><td><code id="sde.sim_+3A_a">A</code></td>
<td>
<p><code>A(x)</code> is the integral of the <code>drift</code> between <code>0</code> and <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a <code>ts</code> object of length <code>N+1</code>; i.e., <code>X0</code> and
the new <code>N</code> simulated values if <code>M=1</code>.
For <code>M&gt;1</code>, an <code>mts</code> (multidimensional <code>ts</code> object) is returned, which
means that <code>M</code> independent trajectories are simulated. 
If the initial value <code>X0</code> is not of the length <code>M</code>, the values are recycled
in order to have an initial vector of the correct length. 
If <code>delta</code> is not specified, then <code>delta = (T-t0)/N</code>.
If <code>delta</code> is specified, then <code>N</code>  values of the solution of the sde are generated and
the time horizon <code>T</code> is adjusted to be <code>N * delta</code>.
</p>
<p>The function <code>psi</code> is <code>psi(x) = 0.5*drift(x)^2 + 0.5*drift.x(x)</code>.
</p>
<p>If any of <code>drift.x</code>, <code>drift.xx</code>, <code>drift.t</code>,
<code>sigma.x</code>, and <code>sigma.xx</code> are not specified,
then numerical derivation is attempted when needed.
</p>
<p>If <code>sigma</code> is not specified, it is assumed to be the constant function <code>1</code>.
</p>
<p>The <code>method</code> of simulation can be one among: <code>euler</code>, <code>KPS</code>, <code>milstein</code>,
<code>milstein2</code>,  <code>cdist</code>, <code>EA</code>, <code>ozaki</code>, and <code>shoji</code>. 
No assumption on the coefficients or on <code>cdist</code> is checked: the user is 
responsible for using the right method for the process object of simulation.
</p>
<p>The <code>model</code> is one among: <code>CIR</code>: Cox-Ingersoll-Ross, <code>VAS</code>: Vasicek,
<code>OU</code> Ornstein-Uhlenbeck, <code>BS</code>: Black and Scholes. 
No assumption on the coefficient <code>theta</code> is checked: the user is responsible 
for using the right ones.
</p>
<p>If the <code>method</code> is <code>cdist</code>, then the process is simulated according to its
known conditional distribution. The random generator <code>rcdist</code> must be a 
function of <code>n</code>, the number of random numbers; <code>dt</code>, the time lag; 
<code>x</code>, the value of the process at time <code>t</code> - <code>dt</code>; and the
vector of parameters <code>theta</code>.
</p>
<p>For the exact algorithm method <code>EA</code>: if missing <code>k1</code> and <code>k2</code> as well 
as <code>A</code>, <code>rh</code> and <code>phi</code> are calculated numerically by the function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>returns an invisible <code>ts</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>See Chapter 2 of the text.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ornstein-Uhlenbeck process
set.seed(123)
d &lt;- expression(-5 * x)
s &lt;- expression(3.5) 
sde.sim(X0=10,drift=d, sigma=s) -&gt; X
plot(X,main="Ornstein-Uhlenbeck")

# Multiple trajectories of the O-U process
set.seed(123)
sde.sim(X0=10,drift=d, sigma=s, M=3) -&gt; X
plot(X,main="Multiple trajectories of O-U")

# Cox-Ingersoll-Ross process
# dXt = (6-3*Xt)*dt + 2*sqrt(Xt)*dWt
set.seed(123)
d &lt;- expression( 6-3*x ) 
s &lt;- expression( 2*sqrt(x) ) 
sde.sim(X0=10,drift=d, sigma=s) -&gt; X
plot(X,main="Cox-Ingersoll-Ross")

# Cox-Ingersoll-Ross using the conditional distribution "rcCIR"

set.seed(123)
sde.sim(X0=10, theta=c(6, 3, 2), rcdist=rcCIR, 
        method="cdist") -&gt; X
plot(X, main="Cox-Ingersoll-Ross")

set.seed(123)
sde.sim(X0=10, theta=c(6, 3, 2), model="CIR") -&gt; X
plot(X, main="Cox-Ingersoll-Ross")

# Exact simulation
set.seed(123)
d &lt;- expression(sin(x))
d.x &lt;- expression(cos(x)) 
A &lt;- function(x) 1-cos(x)
sde.sim(method="EA", delta=1/20, X0=0, N=500, 
        drift=d, drift.x = d.x, A=A) -&gt; X
plot(X, main="Periodic drift")
</code></pre>

<hr>
<h2 id='sdeAIC'>Akaike's information criterion for diffusion processes</h2><span id='topic+sdeAIC'></span>

<h3>Description</h3>

<p>Implementation of the AIC statistics for diffusion processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdeAIC(X, theta, b, s, b.x, s.x, s.xx, B, B.x, H, S, guess, 
       ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdeAIC_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_theta">theta</code></td>
<td>
<p>a vector or estimates of the parameters.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_b">b</code></td>
<td>
<p>drift coefficient of the model as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_s">s</code></td>
<td>
<p>diffusion coefficient of the model as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_b.x">b.x</code></td>
<td>
<p>partial derivative of <code>b</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_s.x">s.x</code></td>
<td>
<p>partial derivative of <code>s</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_s.xx">s.xx</code></td>
<td>
<p>second-order partial derivative of <code>s</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_b">B</code></td>
<td>
<p>initial value of the parameters; see details.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_b.x">B.x</code></td>
<td>
<p>partial derivative of <code>B</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_h">H</code></td>
<td>
<p>function of <code>(x,y)</code>,  the integral of <code>B/s</code>; optional.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_s">S</code></td>
<td>
<p>function of <code>(x,y)</code>, the integral of <code>1/s</code>; optional.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_guess">guess</code></td>
<td>
<p>initial value for the parameters to be estimated; optional.</p>
</td></tr>
<tr><td><code id="sdeAIC_+3A_...">...</code></td>
<td>
<p>passed to the <code>optim</code> function; optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sdeAIC</code> evaluates the AIC statistics for diffusion processes using
Dacunha-Castelle and Florens-Zmirou approximations of the likelihood.
</p>
<p>The parameter <code>theta</code> is supposed to be the value of the true MLE estimator 
or the minimum contrast estimator of the parameters in the model. If missing
or <code>NULL</code> and <code>guess</code> is specified, <code>theta</code> is estimated using the 
minimum contrast estimator derived from the locally Gaussian approximation
of the density. If both <code>theta</code> and <code>guess</code> are missing, nothing can
be calculated.
</p>
<p>If missing, <code>B</code> is calculated as <code>b/s - 0.5*s.x</code> provided that <code>s.x</code>
is not missing.
</p>
<p>If missing, <code>B.x</code> is calculated as <code>b.x/s - b*s.x/(s^2)-0.5*s.xx</code>, provided
that <code>b.x</code>, <code>s.x</code>, and <code>s.xx</code> are not missing.
</p>
<p>If missing, both <code>H</code> and <code>S</code> are evaluated numerically.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>the value of the AIC statistics</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Dacunha-Castelle, D., Florens-Zmirou, D. (1986) Estimation of the coefficients 
of a diffusion from discrete observations,  <em>Stochastics</em>, 19, 263-284.
</p>
<p>Uchida, M., Yoshida, N.  (2005) AIC for ergodic diffusion processes from 
discrete observations, preprint MHF 2005-12, march 2005, <em>Faculty of 
Mathematics, Kyushu University, Fukuoka, Japan</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
# true model generating data
dri &lt;- expression(-(x-10))
dif &lt;- expression(2*sqrt(x)) 
sde.sim(X0=10,drift=dri, sigma=dif,N=1000,delta=0.1) -&gt; X

# we test the true model against two competing models
b &lt;- function(x,theta) -theta[1]*(x-theta[2])
b.x &lt;- function(x,theta)  -theta[1]+0*x

s &lt;- function(x,theta) theta[3]*sqrt(x)
s.x &lt;- function(x,theta) theta[3]/(2*sqrt(x))
s.xx &lt;- function(x,theta) -theta[3]/(4*x^1.5)
# AIC for the true model
sdeAIC(X, NULL, b, s, b.x, s.x, s.xx, guess=c(1,1,1),
       lower=rep(1e-3,3), method="L-BFGS-B")

s &lt;- function(x,theta) sqrt(theta[3]*+theta[4]*x)
s.x &lt;- function(x,theta) theta[4]/(2*sqrt(theta[3]+theta[4]*x))
s.xx &lt;- function(x,theta) -theta[4]^2/(4*(theta[3]+theta[4]*x)^1.5)
# AIC for competing model 1
sdeAIC(X, NULL, b, s, b.x, s.x, s.xx, guess=c(1,1,1,1),
       lower=rep(1e-3,4), method="L-BFGS-B")

s &lt;- function(x,theta) (theta[3]+theta[4]*x)^theta[5]
s.x &lt;- function(x,theta) 
           theta[4]*theta[5]*(theta[3]+theta[4]*x)^(-1+theta[5])
s.xx &lt;- function(x,theta) (theta[4]^2*theta[5]*(theta[5]-1)
                 *(theta[3]+theta[4]*x)^(-2+theta[5]))
# AIC for competing model 2
sdeAIC(X, NULL, b, s, b.x, s.x, s.xx, guess=c(1,1,1,1,1),
       lower=rep(1e-3,5), method="L-BFGS-B")

## End(Not run)
</code></pre>

<hr>
<h2 id='sdeDiv'>Phi-Divergences test for diffusion processes</h2><span id='topic+sdeDiv'></span>

<h3>Description</h3>

<p>Phi-Divergences test for diffusion processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdeDiv(X, theta1, theta0, phi= expression( -log(x) ), C.phi, K.phi, 
       b, s, b.x, s.x, s.xx, B, B.x, H, S, guess, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdeDiv_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_theta1">theta1</code></td>
<td>
<p>a vector parameters for the hypothesis H1. If not given, <code>theta1</code> is estimated from the data.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_theta0">theta0</code></td>
<td>
<p>a vector parameters for the hypothesis H0.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_phi">phi</code></td>
<td>
<p>an expression containing the phi function of the phi-divergence.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_c.phi">C.phi</code></td>
<td>
<p>the value of first derivtive of <code>phi</code> at point 1. If not given, it is calculated within this function.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_k.phi">K.phi</code></td>
<td>
<p>the value of second derivative of <code>phi</code> at point 1. If not given, it is calculated within this function.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_b">b</code></td>
<td>
<p>drift coefficient of the model as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_s">s</code></td>
<td>
<p>diffusion coefficient of the model as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_b.x">b.x</code></td>
<td>
<p>partial derivative of <code>b</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_s.x">s.x</code></td>
<td>
<p>partial derivative of <code>s</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_s.xx">s.xx</code></td>
<td>
<p>second-order partial derivative of <code>s</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_b">B</code></td>
<td>
<p>initial value of the parameters; see details.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_b.x">B.x</code></td>
<td>
<p>partial derivative of <code>B</code> as a function of <code>x</code> and <code>theta</code>.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_h">H</code></td>
<td>
<p>function of <code>(x,y)</code>,  the integral of <code>B/s</code>; optional.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_s">S</code></td>
<td>
<p>function of <code>(x,y)</code>, the integral of <code>1/s</code>; optional.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_guess">guess</code></td>
<td>
<p>initial value for the parameters to be estimated; optional.</p>
</td></tr>
<tr><td><code id="sdeDiv_+3A_...">...</code></td>
<td>
<p>passed to the <code>optim</code> function; optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sdeDiv</code> estimate the phi-divergence for diffusion processes defined as
<code>D(theta1, theta0) = phi( f(theta1)/f(theta0) )</code> where <code>f</code> is the
likelihood function of the process. This function uses the Dacunha-Castelle 
and Florens-Zmirou approximation of the likelihood for <code>f</code>.
</p>
<p>The parameter <code>theta1</code> is supposed to be the value of the true MLE estimator 
or the minimum contrast estimator of the parameters in the model. If missing
or <code>NULL</code> and <code>guess</code> is specified, <code>theta1</code> is estimated using the 
minimum contrast estimator derived from the locally Gaussian approximation
of the density. If both <code>theta1</code> and <code>guess</code> are missing, nothing can
be calculated.
</p>
<p>The function always calculates the likelihood ratio test and the p-value of the
test statistics.
In some cases, the p-value of the phi-divergence test statistics is obtained by simulation. In such
a case, the <code>out$est.pval</code> is set to <code>TRUE</code>
</p>
<p>Dy default <code>phi</code> is set to <code>-log(x)</code>. In this case the phi-divergence and the
likelihood ratio test are equivalent (e.g. phi-Div = LRT/2)
</p>
<p>For more informations on phi-divergences for discretely observed diffusion processes
see the references.
</p>
<p>If missing, <code>B</code> is calculated as <code>b/s - 0.5*s.x</code> provided that <code>s.x</code>
is not missing.
</p>
<p>If missing, <code>B.x</code> is calculated as <code>b.x/s - b*s.x/(s^2)-0.5*s.xx</code>, provided
that <code>b.x</code>, <code>s.x</code>, and <code>s.xx</code> are not missing.
</p>
<p>If missing, both <code>H</code> and <code>S</code> are evaluated numerically.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a list containing the value of the divergence, its pvalue, the likelihood ratio test
statistics and its p-value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Dacunha-Castelle, D., Florens-Zmirou, D. (1986) Estimation of the coefficients 
of a diffusion from discrete observations,  <em>Stochastics</em>, 19, 263-284.
</p>
<p>De Gregorio, A., Iacus, S.M. (2008) Divergences Test Statistics for 
Discretely Observed Diffusion Processes, Journal of Statistical Planning and Inference, 140(7), 1744-1753, <a href="https://doi.org/10.1016/j.jspi.2009.12.029">doi:10.1016/j.jspi.2009.12.029</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
theta0 &lt;- c(0.89218*0.09045,0.89218,sqrt(0.032742))
theta1 &lt;- c(0.89218*0.09045/2,0.89218,sqrt(0.032742/2))

# we test the true model against two competing models
b &lt;- function(x,theta) theta[1]-theta[2]*x
b.x &lt;- function(x,theta)  -theta[2]

s &lt;- function(x,theta) theta[3]*sqrt(x)
s.x &lt;- function(x,theta) theta[3]/(2*sqrt(x))
s.xx &lt;- function(x,theta) -theta[3]/(4*x^1.5)


X &lt;- sde.sim(X0=rsCIR(1, theta1), N=1000, delta=1e-3, model="CIR", 
 theta=theta1)

sdeDiv(X=X, theta0 = theta0,   b=b, s=s, b.x=b.x, s.x=s.x, 
 s.xx=s.xx, method="L-BFGS-B", 
 lower=rep(1e-3,3), guess=c(1,1,1))

sdeDiv(X=X, theta0 = theta1,   b=b, s=s, b.x=b.x, s.x=s.x, 
 s.xx=s.xx, method="L-BFGS-B", 
 lower=rep(1e-3,3), guess=c(1,1,1))

lambda &lt;- -1.75
myphi &lt;-  expression( (x^(lambda+1) -x - lambda*(x-1))/(lambda*(lambda+1)) )

sdeDiv(X=X, theta0 = theta0,   phi = myphi, b=b, s=s, b.x=b.x, 
 s.x=s.x, s.xx=s.xx, method="L-BFGS-B", 
 lower=rep(1e-3,3), guess=c(1,1,1))

sdeDiv(X=X, theta0 = theta1,   phi = myphi, b=b, s=s, b.x=b.x, 
 s.x=s.x, s.xx=s.xx, method="L-BFGS-B", 
 lower=rep(1e-3,3), guess=c(1,1,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='SIMloglik'>Pedersen's approximation of the likelihood</h2><span id='topic+SIMloglik'></span>

<h3>Description</h3>

<p>Pedersen's approximation 
of the likelihood of a process solution of a stochastic differential equation.
This function is useful to calculate approximated maximum likelihood estimators
when the transition density of the process is not known. It is computationally
intensive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SIMloglik(X, theta, d, s,  M=10000, N=2, log=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SIMloglik_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="SIMloglik_+3A_theta">theta</code></td>
<td>
<p>vector of parameters.</p>
</td></tr>
<tr><td><code id="SIMloglik_+3A_d">d</code>, <code id="SIMloglik_+3A_s">s</code></td>
<td>
<p>drift and diffusion coefficients; see details.</p>
</td></tr>
<tr><td><code id="SIMloglik_+3A_log">log</code></td>
<td>
<p>logical; if TRUE, the log-likelihood is returned.</p>
</td></tr>
<tr><td><code id="SIMloglik_+3A_n">N</code></td>
<td>
<p>number of subintervals; see details.</p>
</td></tr>
<tr><td><code id="SIMloglik_+3A_m">M</code></td>
<td>
<p>number of Monte Carlo simulations, which should be an even number; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>SIMloglik</code> returns the simulated log-likelihood obtained by 
Pedersen's method.
The functions <code>s</code> and <code>d</code> are the drift and diffusion
coefficients with arguments <code>(t,x,theta)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a number</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Pedersen, A. R. (1995) A new approach to maximum likelihood estimation for 
stochastic differential equations based on discrete observations,
<em>Scand. J. Statist.</em>, 22, 55-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(123)
d &lt;- expression(-1*x)
s &lt;- expression(2) 
sde.sim(drift=d, sigma=s,N=50,delta=0.01) -&gt; X

S &lt;- function(t, x, theta) sqrt(theta[2])
B &lt;- function(t, x, theta) -theta[1]*x

true.loglik &lt;- function(theta) {
 DELTA &lt;- deltat(X)
 lik &lt;- 0
 for(i in 2:length(X))
  lik &lt;- lik + dnorm(X[i], mean=X[i-1]*exp(-theta[1]*DELTA), 
   sd = sqrt((1-exp(-2*theta[1]*DELTA))*
              theta[2]/(2*theta[1])),TRUE)
 lik  
}

xx &lt;- seq(-10,10,length=20)
sapply(xx, function(x) true.loglik(c(x,4))) -&gt; py
sapply(xx, function(x) EULERloglik(X,c(x,4),B,S)) -&gt; pz
sapply(xx, function(x) SIMloglik(X,c(x,4),B,S,M=10000,N=5)) -&gt; pw

plot(xx,py,type="l",xlab=expression(beta),
   ylab="log-likelihood",ylim=c(0,15)) # true
lines(xx,pz, lty=2) # Euler
lines(xx,pw, lty=3) # Simulated

## End(Not run)</code></pre>

<hr>
<h2 id='simple.ef'>Simple estimating functions of types I and II</h2><span id='topic+simple.ef'></span>

<h3>Description</h3>

<p>Apply a simple estimating function to find estimates of the
parameters of a process solution of a stochastic differential equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple.ef(X, f, guess, lower, upper) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple.ef_+3A_x">X</code></td>
<td>
<p>a ts object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="simple.ef_+3A_f">f</code></td>
<td>
<p>a list of expressions of <code>x</code> and/or <code>y</code> and the parameters to be estimated; see details.</p>
</td></tr>
<tr><td><code id="simple.ef_+3A_guess">guess</code></td>
<td>
<p>initial value of the parameters; see details.</p>
</td></tr>
<tr><td><code id="simple.ef_+3A_lower">lower</code></td>
<td>
<p>lower bounds for the parameters; see details.</p>
</td></tr>
<tr><td><code id="simple.ef_+3A_upper">upper</code></td>
<td>
<p>upper bounds for the parameters; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simple.ef</code> minimizes a simple estimating function
of the form <code>sum_i f_i(x,y;theta) = 0</code> or <code>sum_i f_i(x;theta)</code>
as a function of <code>theta</code>. The index <code>i</code> varies in <code>1:length(theta)</code>.
</p>
<p>The list <code>f</code> is a list of expressions in <code>x</code> or <code>(x,y)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a vector of estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Kessler, M. (1997)  Estimation of an ergodic diffusion from discrete observations,
<em>Scand. J. Statist.</em>, 24, 211-229.
</p>
<p>Kessler, M. (2000) Simple and Explicit Estimating Functions for a Discretely Observed 
Diffusion Process, <em>Scand. J. Statist.</em>, 27, 65-82. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123); 
# Kessler's estimator for O-H process
K.est &lt;- function(x) {
  n.obs &lt;- length(x)
  n.obs/(2*(sum(x^2)))
}

# Least squares estimators for the O-H process
LS.est &lt;- function(x) {
  n &lt;- length(x) -1
  k.sum &lt;- sum(x[1:n]*x[2:(n+1)])
  dt &lt;- deltat(x)
  ifelse(k.sum&gt;0, -log(k.sum/sum(x[1:n]^2))/dt, NA)
}

d &lt;- expression(-1 * x)
s &lt;- expression(1) 
x0 &lt;- rnorm(1,sd=sqrt(1/2))
sde.sim(X0=x0,drift=d, sigma=s,N=2500,delta=0.1) -&gt; X
 
# Kessler's estimator as estimating function
f &lt;- list(expression(2*theta*x^2-1))
simple.ef(X, f, lower=0, upper=Inf)
K.est(X)

# Least Squares estimator as estimating function
f &lt;- list(expression(x*(y-x*exp(-0.1*theta))))
simple.ef(X, f, lower=0, upper=Inf)
LS.est(X)
</code></pre>

<hr>
<h2 id='simple.ef2'>Simple estimating function based on the infinitesimal generator a the diffusion process</h2><span id='topic+simple.ef2'></span>

<h3>Description</h3>

<p>Apply a simple estimating function based on the infinitesimal
generator of a diffusion to find estimates of the
parameters of a process solution of that particular stochastic differential equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple.ef2(X, drift, sigma, h, h.x, h.xx, guess, lower, 
           upper) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple.ef2_+3A_x">X</code></td>
<td>
<p>a <code>ts</code> object containing a sample path of an sde.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_drift">drift</code></td>
<td>
<p>an expression for the drift coefficient; see details.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_sigma">sigma</code></td>
<td>
<p>an expression for the diffusion coefficient; see details.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_h">h</code></td>
<td>
<p>an expression of <code>x</code> and the parameters to be estimated; see details.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_h.x">h.x</code></td>
<td>
<p>an expression of <code>x</code> containing the first derivative of <code>h</code>; see details.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_h.xx">h.xx</code></td>
<td>
<p>an expression of <code>x</code> containing the second derivative of <code>h</code>; see details.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_guess">guess</code></td>
<td>
<p>initial value of the parameters; see details.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_lower">lower</code></td>
<td>
<p>lower bounds for the parameters; see details.</p>
</td></tr>
<tr><td><code id="simple.ef2_+3A_upper">upper</code></td>
<td>
<p>upper bounds for the parameters; see details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>simple.ef2</code> minimizes the simple estimating function
of the form <code>sum_i f_i(x;theta) = 0</code>, where <code>f</code> is the result of
applying  the infinitesimal generator of the diffusion to the
function <code>h</code>. This involves the drift and diffusion coefficients plus
the first two derivatives of <code>h</code>. If not provided by the user, the derivatives
are calculated by the function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>a vector of estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Stefano Maria Iacus</p>


<h3>References</h3>

<p>Kessler, M. (1997)  Estimation of an ergodic diffusion from discrete observations,
<em>Scand. J. Statist.</em>, 24, 211-229.
</p>
<p>Kessler, M. (2000) Simple and Explicit Estimating Functions for a Discretely Observed 
Diffusion Process, <em>Scand. J. Statist.</em>, 27, 65-82. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) 
d &lt;- expression(10 - x)
s &lt;- expression(sqrt(x)) 
x0 &lt;- 10
sde.sim(X0=x0,drift=d, sigma=s,N=1500,delta=0.1) -&gt; X

# rather difficult problem unless a good initial guess is given
d &lt;- expression(alpha + theta*x)
s &lt;- expression(x^gamma) 
h &lt;- list(expression(x), expression(x^2), expression(x^2))
simple.ef2(X, d, s, h, lower=c(0,-Inf,0), upper=c(Inf,0,1))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
