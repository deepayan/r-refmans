<!DOCTYPE html><html><head><title>Help for package InterpretMSSpectrum</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {InterpretMSSpectrum}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Adducts'><p>Default adduct lists used by <code>findMAIN</code>.</p></a></li>
<li><a href='#apci_spectrum'><p>APCI spectrum</p></a></li>
<li><a href='#chemical_elements'><p>List of chemical elements.</p></a></li>
<li><a href='#CountChemicalElements'><p>CountChemicalElements.</p></a></li>
<li><a href='#esi_spectrum'><p>ESI spectrum</p></a></li>
<li><a href='#findMAIN'><p>findMAIN.</p></a></li>
<li><a href='#GenerateMetaboliteSQLiteDB'><p>GenerateMetaboliteSQLiteDB.</p></a></li>
<li><a href='#get_exactmass'><p>get_exactmass.</p></a></li>
<li><a href='#GetGroupFactor'><p>GetGroupFactor.</p></a></li>
<li><a href='#IMS_parallel'><p>IMS_parallel.</p></a></li>
<li><a href='#InterpretMSSpectrum'><p>Interpreting High-Res-MS spectra.</p></a></li>
<li><a href='#InterpretTP'><p>InterpretTP.</p></a></li>
<li><a href='#mScore'><p>mScore.</p></a></li>
<li><a href='#neutral_losses_APCI'><p>A data table defining typical neutral losses in GC-APCI-MS for silylated compounds.</p></a></li>
<li><a href='#neutral_losses_ESI'><p>A data table defining neutral losses in LC-ESI-MS (positive mode).</p></a></li>
<li><a href='#OrbiMS1'><p>Orbitrap spectra</p></a></li>
<li><a href='#param.default'><p>Default parameter list for <code>InterpretMSSpectrum</code>.</p></a></li>
<li><a href='#PlotSpec'><p>Plot Mass Spectrum.</p></a></li>
<li><a href='#ReadSpecClipboard'><p>ReadSpecClipboard.</p></a></li>
<li><a href='#sendToMSF'><p>Exporting spectra to MSFinder.</p></a></li>
<li><a href='#writeMSF'><p>writeMSF.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interpreting High Resolution Mass Spectra</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Lisec &lt;jan.lisec@bam.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>High resolution mass spectrometry yields often large data sets of 
    spectra from compounds which are not present in available libraries. These 
    spectra need to be annotated and interpreted.
    'InterpretMSSpectrum' provides a set of functions to perform such tasks for 
    Electrospray-Ionization and Atmospheric-Pressure-Chemical-Ionization derived 
    data in positive and negative ionization mode.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/janlisec/InterpretMSSpectrum">https://github.com/janlisec/InterpretMSSpectrum</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>enviPat, plyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI, doParallel, foreach, parallel, Rdisop, RSQLite, testthat
(&ge; 3.0.0), vdiffr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-31 11:57:51 UTC; jlisec</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Lisec <a href="https://orcid.org/0000-0003-1220-2286"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Jaeger Carsten [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-31 13:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='Adducts'>Default adduct lists used by <code>findMAIN</code>.</h2><span id='topic+Adducts'></span>

<h3>Description</h3>

<p>Default adduct lists used by <code>findMAIN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Adducts)
</code></pre>


<h3>Format</h3>

<p>A list of two character vectors:
</p>

<dl>
<dt>Positive</dt><dd><p>default adducts used in ESI(+) mode</p>
</dd>
<dt>Negative</dt><dd><p>default adducts used in ESI(-) mode</p>
</dd>
</dl>



<h3>Source</h3>

<p>A reasonable selection of frequent adducts based on the list in R-package CAMERA
</p>

<hr>
<h2 id='apci_spectrum'>APCI spectrum</h2><span id='topic+apci_spectrum'></span>

<h3>Description</h3>

<p>Example spectrum of Glutamic acid (3TMS) measured on a Bruker impact II.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(apci_spectrum)
</code></pre>


<h3>Format</h3>

<p>A data frame with 47 observations on the following 2 variables: 
</p>

<dl>
<dt>mz</dt><dd><p>a numeric vector ion masses</p>
</dd>
<dt>int</dt><dd><p>a numeric vector of intensities</p>
</dd>
</dl>


<hr>
<h2 id='chemical_elements'>List of chemical elements.</h2><span id='topic+chemical_elements'></span>

<h3>Description</h3>

<p>List of chemical elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(chemical_elements)
</code></pre>


<h3>Format</h3>

<p>A data frame with 103 observations on the following 2 variables:
</p>

<dl>
<dt>name</dt><dd><p>a character vector of elemental abbreviations</p>
</dd>
<dt>mass</dt><dd><p>a numeric vector of exact masses of the elements main isotope</p>
</dd>
</dl>


<hr>
<h2 id='CountChemicalElements'>CountChemicalElements.</h2><span id='topic+CountChemicalElements'></span>

<h3>Description</h3>

<p><code>CountChemicalElements</code> will split a character (chemical formula) 
into its elements and count their occurrence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountChemicalElements(x = NULL, ele = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountChemicalElements_+3A_x">x</code></td>
<td>
<p>Chemical formula.</p>
</td></tr>
<tr><td><code id="CountChemicalElements_+3A_ele">ele</code></td>
<td>
<p>Character vector of elements to count particularly or counting all contained if NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No testing for any chemical alphabet is performed. Elements may occur 
several times and will be summed up in this case without a warning.
</p>


<h3>Value</h3>

<p>A named numeric with counts for all contained or specified elements.
</p>

<hr>
<h2 id='esi_spectrum'>ESI spectrum</h2><span id='topic+esi_spectrum'></span>

<h3>Description</h3>

<p>Example spectrum of Sedoheptulose 7-phosphate measured on a Bruker impact II.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(esi_spectrum)
</code></pre>


<h3>Format</h3>

<p>A data frame with 42 observations on the following 2 variables: 
</p>

<dl>
<dt>mz</dt><dd><p>a numeric vector ion masses</p>
</dd>
<dt>int</dt><dd><p>a numeric vector of intensities</p>
</dd>
</dl>


<hr>
<h2 id='findMAIN'>findMAIN.</h2><span id='topic+findMAIN'></span><span id='topic+plot.findMAIN'></span><span id='topic+print.findMAIN'></span>

<h3>Description</h3>

<p><code>findMAIN</code> will evaluate an ESI spectrum for the potential main adducts, 
rank obtained suggestions and allow the deduction of the neutral mass of the measured 
molecule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMAIN(
  spec,
  adductmz = NULL,
  ionmode = c("positive", "negative")[1],
  adducthyp = NULL,
  ms2spec = NULL,
  rules = NULL,
  mzabs = 0.01,
  ppm = 5,
  mainpkthr = 0.005,
  collapseResults = TRUE
)

## S3 method for class 'findMAIN'
plot(x, rank = 1, correct_mass = NULL, ...)

## S3 method for class 'findMAIN'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMAIN_+3A_spec">spec</code></td>
<td>
<p>A mass spectrum. Either a matrix or data frame, the first two columns of which 
are assumed to contain the 'mz' and 'intensity' values, respectively.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_adductmz">adductmz</code></td>
<td>
<p>Manually specified peak for which <code>adducthyp</code> should be tested, 
or 'NULL' (default), to test all main peaks. What is a main peak, is governed by 
<code>mainpkthr</code>.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_ionmode">ionmode</code></td>
<td>
<p>Ionization mode, either &quot;positive&quot; or &quot;negative&quot;. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_adducthyp">adducthyp</code></td>
<td>
<p>Adduct hypotheses to test for each main peak. Defaults to 
<code>c("[M+H]+","[M+Na]+","[M+K]+")</code> for positive mode and 
<code>c("[M-H]-","[M+Cl]-","[M+HCOOH-H]-")</code> for negative mode.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_ms2spec">ms2spec</code></td>
<td>
<p>Second spectrum limiting main peak selection. If available, MS^E or bbCID 
spectra may allow further exclusion of false positive adduct ions, as ions of the intact 
molecule (protonated molecule, adduct ions) should have lower intensity in the high-energy 
trace than in low-energy trace.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_rules">rules</code></td>
<td>
<p>Adduct/fragment relationships to test, e.g. <code>c("[M+Na]+", "[M+H-H2O]+")</code>, 
or 'NULL' for default set (see <code><a href="#topic+Adducts">Adducts</a></code>)</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_mzabs">mzabs</code></td>
<td>
<p>Allowed mass error, absolute (Da).</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_ppm">ppm</code></td>
<td>
<p>Allowed mass error, relative (ppm), which is _added_ to 'mzabs'.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_mainpkthr">mainpkthr</code></td>
<td>
<p>Intensity threshold for main peak selection, relative to base peak.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_collapseresults">collapseResults</code></td>
<td>
<p>If a neutral mass hypothesis was found more than once (due to multiple 
adducts suggesting the same neutral mass), return only the one with the highest adduct peak. 
Should normally kept at <code>TRUE</code>, the default.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_x">x</code></td>
<td>
<p>Object of class findMAIN.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_rank">rank</code></td>
<td>
<p>Rank of the suggestion to plot (can be a numeric vector).</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_correct_mass">correct_mass</code></td>
<td>
<p>If provided will indicate correct suggestion by green color.</p>
</td></tr>
<tr><td><code id="findMAIN_+3A_...">...</code></td>
<td>
<p>Further parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Electrospray ionization (ESI) mass spectra frequently contain a number of different 
adduct ions, multimers and in-source fragments <code>[M+H]+, [M+Na]+, [2M+H]+, [M+H-H2O]+</code>, 
making it difficult to decide on the compound's neutral mass. This functions aims 
at determining the main adduct ion and its type (protonated, sodiated etc.) of a spectrum, 
allowing subsequent database searches e.g. using MS-FINDER, SIRIUS or similar.
</p>


<h3>Value</h3>

<p>A list-like 'findMAIN' object for which 'print', 'summary' and 'plot' methods are available.
Each list element represents a potential spectra annotation, ranked according to 
a combined score. The spectrum is annotated with columns indicating the determined
isotopic groups (isogr) and their likely charge. Further, information on the potential 
set of adducts and their ppm error is attached.
The score aims to integrate all this information using formula S=sum(w_i x s_i).
In short, we sum up i weighted score components (currently i=4). Currently these
components are calculated based on the explained intensity (adduct sets which
annotate a higher amount of the total spectrum intensity are better), the mass error
(adduct sets with lower mass error are better), the support by isotopic peaks
(adduct sets with fitting isotopes are better) and the number of adducts (adduct 
sets with a larger number of adducts are better).
The individual scores for each adduct set are attached as an attribute to the
respective list element and can be easily observed by applying the 'summary' or 
the 'plot' function on the 'findMAIN' object.
</p>


<h3>References</h3>

<p>Jaeger C, Meret M, Schmitt CA, Lisec J (2017), &lt;doi:10.1002/rcm.7905&gt;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
utils::data(esi_spectrum, package = "InterpretMSSpectrum")
fmr &lt;- InterpretMSSpectrum::findMAIN(esi_spectrum)
plot(fmr)
head(summary(fmr))
InterpretMSSpectrum::InterpretMSSpectrum(fmr[[1]], precursor=263, param="ESIpos")
fmr &lt;- InterpretMSSpectrum::findMAIN(esi_spectrum[6:9,], adducthyp = "[M+H]+")
plot(fmr)

# set up a spectrum containing a double charged peak
spec &lt;- data.frame(mz = c(372.1894, 372.6907, 373.1931, 380), int = c(100, 40, 8, 2))
InterpretMSSpectrum:::findiso(spec)
# allow a double charged adduct hypothesis (not standard)
fmr &lt;- InterpretMSSpectrum::findMAIN(spec, adducthyp = c("[M+H]+", "[M+2H]2+"))
summary(fmr)
attr(fmr[[1]],"scores")
plot(fmr, rank = 1:4)
plot(fmr, rank = 2)

# add the correct M+H to this spectrum as a minor peak
spec &lt;- rbind(spec, c(742.3648+1.007, 10))
(fmr &lt;- InterpretMSSpectrum::findMAIN(spec, adducthyp = c("[M+H]+", "[M+2H]2+")))
summary(fmr)
plot(fmr, rank = 1)
plot(fmr, rank = 2)

# compare specific hypotheses manually
# get correct result
InterpretMSSpectrum::findMAIN(spec, adductmz = 743.3718, adducthyp = "[M+H]+")
# enforce wrong result
InterpretMSSpectrum::findMAIN(spec, adductmz = 743.3718, adducthyp = "[M+2H]2+")


</code></pre>

<hr>
<h2 id='GenerateMetaboliteSQLiteDB'>GenerateMetaboliteSQLiteDB.</h2><span id='topic+GenerateMetaboliteSQLiteDB'></span>

<h3>Description</h3>

<p><code>GenerateMetaboliteSQLiteDB</code> will set up a SQLite data base containing
potential metabolite formulas, their masses and isotopic distribution for use with
<a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateMetaboliteSQLiteDB(
  dbfile = "SQLite_APCI.db",
  ionization = c("APCI", "ESI")[1],
  mass_range = c(100, 105),
  ncores = 1,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateMetaboliteSQLiteDB_+3A_dbfile">dbfile</code></td>
<td>
<p>Path and file name of the final SQLiteDB or NULL to return the data frame.</p>
</td></tr>
<tr><td><code id="GenerateMetaboliteSQLiteDB_+3A_ionization">ionization</code></td>
<td>
<p>Has to be specified to account for different plausibility rules and
elemental composition.</p>
</td></tr>
<tr><td><code id="GenerateMetaboliteSQLiteDB_+3A_mass_range">mass_range</code></td>
<td>
<p>For testing use default range, otherwise use your measurement range.</p>
</td></tr>
<tr><td><code id="GenerateMetaboliteSQLiteDB_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores. Use as many as possible.</p>
</td></tr>
<tr><td><code id="GenerateMetaboliteSQLiteDB_+3A_silent">silent</code></td>
<td>
<p>Set to FALSE to get progress messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The process takes a long time for larger masses (&gt;400 Da). Parallel processing
with 8 cores is highly recommended. Alternatively pre-processed versions can be downloaded
on request to <a href="mailto:jan.lisec@bam.de">jan.lisec@bam.de</a>. To process a 1 Da range (from 900 to 901) for
ESI does take approximately 5 minutes on 8 cores.
</p>


<h3>Value</h3>

<p>Returns the resulting data frame invisible. Will write an SQL_DB if 'dbfile'
provides a valid path and file name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using the default values will compute be relatively fast, but for higher masses it 
# is getting much slower
db &lt;- GenerateMetaboliteSQLiteDB(dbfile = NULL)

</code></pre>

<hr>
<h2 id='get_exactmass'>get_exactmass.</h2><span id='topic+get_exactmass'></span>

<h3>Description</h3>

<p>Get the exact mass for chemical formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_exactmass(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_exactmass_+3A_x">x</code></td>
<td>
<p>Vector of chemical formulas.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of exact masses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>InterpretMSSpectrum::get_exactmass(c("C6H12O6", "Na", "H1"))

</code></pre>

<hr>
<h2 id='GetGroupFactor'>GetGroupFactor.</h2><span id='topic+GetGroupFactor'></span>

<h3>Description</h3>

<p><code>GetGroupFactor</code> will split a numeric vector according to a specified gap value. This is often a useful tool and therefore exported to the namespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetGroupFactor(x, gap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetGroupFactor_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="GetGroupFactor_+3A_gap">gap</code></td>
<td>
<p>Difference between two consecutive values at which a split is generated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor vector of length(x) indicating the different groups in x.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1:3,14:12,6:9)
GetGroupFactor(x=x, gap=2)
split(x, GetGroupFactor(x=x, gap=2))

</code></pre>

<hr>
<h2 id='IMS_parallel'>IMS_parallel.</h2><span id='topic+IMS_parallel'></span>

<h3>Description</h3>

<p><code>IMS_parallel</code> is a parallel implementation of <code><a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMS_parallel(
  spectra = NULL,
  ncores = 8,
  precursor = NULL,
  correct_peak = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IMS_parallel_+3A_spectra">spectra</code></td>
<td>
<p>List of spectra.</p>
</td></tr>
<tr><td><code id="IMS_parallel_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores available.</p>
</td></tr>
<tr><td><code id="IMS_parallel_+3A_precursor">precursor</code></td>
<td>
<p>vector of precursor masses of length(spectra).</p>
</td></tr>
<tr><td><code id="IMS_parallel_+3A_correct_peak">correct_peak</code></td>
<td>
<p>Potentially a vector of correct Peaks, see <code>InterpretMSSpectrum</code> for details.</p>
</td></tr>
<tr><td><code id="IMS_parallel_+3A_...">...</code></td>
<td>
<p>Further parameters passed directly to <code>InterpretMSSpectrum</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mass processing and testing it may be sufficient to use <code>InterpretMSSpectrum</code> 
without plotting functionality. However, function is likely to be deprecated or integrated 
as an option into the main function in the future.
</p>


<h3>Value</h3>

<p>A list of <code>InterpretMSSpectrum</code> result objects which can be systematically evaluated. 
However, note that plotting is unfortunately not enabled for parallel processing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a></code>
</p>

<hr>
<h2 id='InterpretMSSpectrum'>Interpreting High-Res-MS spectra.</h2><span id='topic+InterpretMSSpectrum'></span>

<h3>Description</h3>

<p><code>InterpretMSSpectrum</code> will read, evaluate and plot a deconvoluted
mass spectrum (mass*intensity pairs) from either TMS-derivatized GC-APCI-MS data
or ESI+/- data. The main purpose is to identify the causal metabolite or more
precisely the sum formula of the molecular peak by annotating and interpreting
all visible fragments and isotopes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InterpretMSSpectrum(
  spec = NULL,
  precursor = NULL,
  correct_peak = NULL,
  met_db = NULL,
  typical_losses_definition = NULL,
  silent = FALSE,
  dppm = 3,
  param = "APCIpos",
  formula_db = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InterpretMSSpectrum_+3A_spec">spec</code></td>
<td>
<p>A 2-column matrix of mz/int pairs. If spec=NULL then <code>InterpretMSSpectrum</code>
tries to read data from clipboard (i.e. two columns copied from an Excel spreadsheet).</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_precursor">precursor</code></td>
<td>
<p>The ion (m/z) from spec closest to this mass will be considered as
precursor (can be nominal, i.e. if precursor=364 then 364.1234 would be selected from
spectrum if it is closest).</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_correct_peak">correct_peak</code></td>
<td>
<p>For testing purposes. A character in the form of &quot;name, formula, mz&quot;
to evaluate spectra against. Note! Separating character is ', '.</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_met_db">met_db</code></td>
<td>
<p>A metabolite DB (e.g. GMD or internal) can be provided to search for
candidates comparing M+H ions (cf. Examples).</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_typical_losses_definition">typical_losses_definition</code></td>
<td>
<p>A file name (e.g. D:/BuildingBlocks_GCAPCI.txt) from
where to load relevant neutral losses (cf. Details). Alternatively an data frame with
columns 'Name', 'Formula' and 'Mass'.</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_silent">silent</code></td>
<td>
<p>Logical. If TRUE no plot is generated and no output except final candidate
list is returned.</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_dppm">dppm</code></td>
<td>
<p>Specifies ppm error for Rdisop formula calculation.</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_param">param</code></td>
<td>
<p>Either a list of parameters or a character shortcut indicating a predefined
set. Currently 'APCIpos', 'ESIpos' and 'ESIneg' are supported as shortcuts. If a list
is provided, list elements will overwrite similar named entries from the list that
can be accessed using utils::data(param.default, package = &quot;InterpretMSSpectrum&quot;).</p>
</td></tr>
<tr><td><code id="InterpretMSSpectrum_+3A_formula_db">formula_db</code></td>
<td>
<p>A pre calculated database of sum formulas and their isotopic fine
structures can be used to extremely speed up the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details refer to and if using please cite
Jaeger et al. (2016, &lt;doi:10.1021/acs.analchem.6b02743&gt;) in case of GC-APCI and
Jaeger et al. (2017, &lt;doi:10.1002/rcm.7905&gt;) for ESI data. The Interpretation is
extremely speed up if 'formula_db' (a predetermined database of potential sum
formulas) is provided within the function call. Within the package you may use
<a href="#topic+GenerateMetaboliteSQLiteDB">GenerateMetaboliteSQLiteDB</a> to prepare one for yourself or request
a download link from <a href="mailto:jan.lisec@bam.de">jan.lisec@bam.de</a> as de-novo calculation for a wide
mass range may take several days.
</p>


<h3>Value</h3>

<p>An annotated plot of the mass spectrum and detailed information within the
console. Main result, list of final candidate formulas and their putative fragments,
will be returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load APCI test data
apci_spectrum &lt;- InterpretMSSpectrum::apci_spectrum

# (otional) provide information of a correct peak as a character containing
# name, formula and ion mass -- separated by ',' as shown below
cp &lt;- "Glutamic acid (3TMS), C14H33NO4Si3, 364.1790"

# (otional) provide a database of known peaks
mdb &lt;- data.frame(
  "Name" = c("Glutamic acid (3TMS)", "other peak with same sum formula"),
  "Formula" = c("C14H33NO4Si3", "C14H33NO4Si3"),
  "M+H" = c(364.179, 364.179), stringsAsFactors = FALSE, check.names = FALSE
)

# (otional) provide a database of precalculated formulas to speed up the process
fdb &lt;- system.file("extdata", "APCI_min.db", package = "InterpretMSSpectrum")

# apply function providing above arguments which will print to the console
# and open a new plot
InterpretMSSpectrum(spec = apci_spectrum, correct_peak = cp, met_db = mdb, formula_db = fdb)

</code></pre>

<hr>
<h2 id='InterpretTP'>InterpretTP.</h2><span id='topic+InterpretTP'></span>

<h3>Description</h3>

<p><code>InterpretTP</code> is a wrapper function around 
<a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a> which will read, evaluate and plot 
a deconvoluted mass spectrum (mass*intensity pairs) from either 
TMS-derivatized GC-APCI-MS data or ESI+/- data. 
It allows to provide a chemical formula as a potential precursor of the 
spectrum. This formula will be used to set the parameters 
'allowed_elements' and 'maxElements' during de-novo formula generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>InterpretTP(fml = NULL, param = "APCIpos", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="InterpretTP_+3A_fml">fml</code></td>
<td>
<p>A chemical formula of the standard used for transformation product generation.</p>
</td></tr>
<tr><td><code id="InterpretTP_+3A_param">param</code></td>
<td>
<p>Keyword or parameter list, similar as in <a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a>.</p>
</td></tr>
<tr><td><code id="InterpretTP_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a></code>
</p>

<dl>
<dt><code>spec</code></dt><dd><p>A 2-column matrix of mz/int pairs. If spec=NULL then <code>InterpretMSSpectrum</code>
tries to read data from clipboard (i.e. two columns copied from an Excel spreadsheet).</p>
</dd>
<dt><code>precursor</code></dt><dd><p>The ion (m/z) from spec closest to this mass will be considered as
precursor (can be nominal, i.e. if precursor=364 then 364.1234 would be selected from
spectrum if it is closest).</p>
</dd>
<dt><code>correct_peak</code></dt><dd><p>For testing purposes. A character in the form of &quot;name, formula, mz&quot;
to evaluate spectra against. Note! Separating character is ', '.</p>
</dd>
<dt><code>met_db</code></dt><dd><p>A metabolite DB (e.g. GMD or internal) can be provided to search for
candidates comparing M+H ions (cf. Examples).</p>
</dd>
<dt><code>typical_losses_definition</code></dt><dd><p>A file name (e.g. D:/BuildingBlocks_GCAPCI.txt) from
where to load relevant neutral losses (cf. Details). Alternatively an data frame with
columns 'Name', 'Formula' and 'Mass'.</p>
</dd>
<dt><code>silent</code></dt><dd><p>Logical. If TRUE no plot is generated and no output except final candidate
list is returned.</p>
</dd>
<dt><code>dppm</code></dt><dd><p>Specifies ppm error for Rdisop formula calculation.</p>
</dd>
<dt><code>formula_db</code></dt><dd><p>A pre calculated database of sum formulas and their isotopic fine
structures can be used to extremely speed up the function.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details refer to <a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a>.
</p>


<h3>Value</h3>

<p>An annotated plot of the mass spectrum and detailed information 
within the console. Main result, list of final candidate formulas and 
their putative fragments, will be returned invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load test data
utils::data(apci_spectrum)

# provide information of a correct peak (if you know) as character
cp &lt;- "Glutamic acid (3TMS), C14H33NO4Si3, 364.1790"

# provide database of known peaks and correct peak
mdb &lt;- data.frame(
  "Name" = c("Glutamic acid (3TMS)", "other peak with same sum formula"),
  "Formula" = c("C14H33NO4Si3", "C14H33NO4Si3"),
  "M+H" = c(364.179, 364.179), stringsAsFactors = FALSE, check.names = FALSE
)

# provide a database of precalculated formulas to speed up the process
fdb &lt;- system.file("extdata", "APCI_min.db", package = "InterpretMSSpectrum")

# apply function providing above arguments (dppm is set to 0.5 to reduce run time)
InterpretTP(fml = "C14H33NO4Si3", spec=apci_spectrum, param="APCIpos")

</code></pre>

<hr>
<h2 id='mScore'>mScore.</h2><span id='topic+mScore'></span>

<h3>Description</h3>

<p><code>mScore</code> will calculate a mass defect weighted score for an mz/int values measure for an isotopic cluster in comparison to the theoretically expected pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mScore(
  obs = NULL,
  the = NULL,
  dabs = 5e-04,
  dppm = 2,
  int_prec = 0.02,
  limit = 0,
  rnd_prec = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mScore_+3A_obs">obs</code></td>
<td>
<p>Observed (measured) values, a matrix with two rows (mz/int).</p>
</td></tr>
<tr><td><code id="mScore_+3A_the">the</code></td>
<td>
<p>Theoretical (estimated from sum formula) values, a matrix with two rows (mz/int).</p>
</td></tr>
<tr><td><code id="mScore_+3A_dabs">dabs</code></td>
<td>
<p>Absolute allowed mass deviation (the expected mass precision will influence mScore &ndash; see Details).</p>
</td></tr>
<tr><td><code id="mScore_+3A_dppm">dppm</code></td>
<td>
<p>Relative allowed mass deviation (the expected mass precision will influence mScore &ndash; see Details).</p>
</td></tr>
<tr><td><code id="mScore_+3A_int_prec">int_prec</code></td>
<td>
<p>The expected intensity precision will influence mScore (see Details).</p>
</td></tr>
<tr><td><code id="mScore_+3A_limit">limit</code></td>
<td>
<p>minimal value of mScore. Should be left on zero.</p>
</td></tr>
<tr><td><code id="mScore_+3A_rnd_prec">rnd_prec</code></td>
<td>
<p>Rounding precision of mScore.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The maximum expected average mass error should be specified in ppm. A observed pattern deviating
that much from the theoretical pattern would still receive a reasonable (average) mScore while
observations deviating stronger or less strong will reach lower or higher mScores respectively.
Likewise the intensity precision should specify the average quality of your device to maintain
stable isotopic ratios.
</p>


<h3>Value</h3>

<p>Scalar mScore giving the quality of the observed data if theoretical data are true.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get theoretical isotopic pattern of Glucose
glc &lt;- c(180.063388, 0.920845, 181.066845, 0.065214, 182.068041, 0.013043)
glc &lt;- matrix(glc, nrow=2)
mScore(obs=glc, the=glc)
# modify pattern by maximum allowable error (2ppm mass error, 2% int error)
glc_theoretic &lt;- glc
glc[1,] &lt;- glc[1,]+2*glc[1,]/10^6
glc[2,1:2] &lt;- c(-0.02,0.02)+glc[2,1:2]
mScore(obs=glc, the=glc_theoretic)

# simulate mass and int defects
ef &lt;- function(x, e) {runif(1,x-x*e,x+x*e)}
glc_obs &lt;- glc
glc_obs[1,] &lt;- sapply(glc[1,], ef, e=2*10^-6)
glc_obs[2,] &lt;- sapply(glc[2,], ef, e=0.02)
mScore(obs=glc_obs, the=glc)
# simulate mass and int defects systematically
ef &lt;- function(x, e) {runif(1,x-x*e,x+x*e)}
n &lt;- 11
mz_err &lt;- round(seq(0,5,length.out=n),3)
int_err &lt;- round(seq(0,0.1,length.out=n),3)
mat &lt;- matrix(NA, ncol=n, nrow=n, dimnames=list(mz_err, 100*int_err))
glc_obs &lt;- glc
for (i in 1:n) {
 glc_obs[1,] &lt;- sapply(glc[1,], ef, e=mz_err[i]*10^-6)
 for (j in 1:n) {
   glc_obs[2,] &lt;- sapply(glc[2,], ef, e=int_err[j])
   mat[i,j] &lt;- mScore(obs=glc_obs, the=glc)
 }
}
plot(x=1:n, y=1:n, type="n",axes=FALSE, xlab="mass error [ppm]", ylab="isoratio error [%]")
axis(3,at=1:n,rownames(mat),las=2); axis(4,at=1:n,colnames(mat),las=2); box()
cols &lt;- grDevices::colorRampPalette(colors=c(2,6,3))(diff(range(mat))+1)
cols &lt;- cols[mat-min(mat)+1]
text(x=rep(1:n,each=n), y=rep(1:n,times=n), labels=as.vector(mat), col=cols)

</code></pre>

<hr>
<h2 id='neutral_losses_APCI'>A data table defining typical neutral losses in GC-APCI-MS for silylated compounds.</h2><span id='topic+neutral_losses_APCI'></span>

<h3>Description</h3>

<p>A data table defining typical neutral losses in GC-APCI-MS for silylated compounds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neutral_losses_ESI)
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 observations on the following 3 variables:
</p>

<dl>
<dt><code>Name</code></dt><dd><p>a character vector containing the fragment name used for plot annnotation</p>
</dd>
<dt><code>Formula</code></dt><dd><p>a character vector containing chemical formulas</p>
</dd>
<dt><code>Mass</code></dt><dd><p>a numeric vector containing the mass according to Formula</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data frame consists of two character columns ('Name' and 'Formula') and the numeric column 'Mass'.
In a mass spectrum peak pairs are analyzed for mass differences similar to the ones defined in neutral_losses.
If such a mass difference is observed, we can assume that the according 'Formula' is the true neutral loss
observed in this spectrum. In a plot this peak pair would be connected by a grey line and annotated with
the information from 'Name'. In formula evaluation this peak pair would be used to limit formula suggestions
with respect to plausibility, i.e. if mass fragments A and B exist with mass difference 16.0313 than we can
assume that the respective sum formulas have to be different by CH4. In consequence we can exclude sum formula
suggestions for B which do not have a valid corresponding sum formula in A and vice versa.
</p>


<h3>Source</h3>

<p>This list has been put together manually by Jan Lisec analyzing multiple GC-APCI-MS data sets.
</p>

<hr>
<h2 id='neutral_losses_ESI'>A data table defining neutral losses in LC-ESI-MS (positive mode).</h2><span id='topic+neutral_losses_ESI'></span>

<h3>Description</h3>

<p>A data table defining neutral losses in LC-ESI-MS (positive mode).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(neutral_losses_ESI)
</code></pre>


<h3>Format</h3>

<p>A data frame with 45 observations on the following 3 variables:
</p>

<dl>
<dt><code>Name</code></dt><dd><p>a character vector containing the fragment name used for plot annnotation</p>
</dd>
<dt><code>Formula</code></dt><dd><p>a character vector containing chemical formulas</p>
</dd>
<dt><code>Mass</code></dt><dd><p>a numeric vector containing the mass according to Formula</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data frame consists of two character columns ('Name' and 'Formula') and the numeric column 'Mass'.
In a mass spectrum peak pairs are analyzed for mass differences similar to the ones defined in neutral_losses.
If such a mass difference is observed, we can assume that the according 'Formula' is the true neutral loss
observed in this spectrum. In a plot this peak pair would be connected by a grey line and annotated with
the information from 'Name'. In formula evaluation this peak pair would be used to limit formula suggestions
with respect to plausibility, i.e. if mass fragments A and B exist with mass difference 16.0313 than we can
assume that the respective sum formulas have to be different by CH4. In consequence we can exclude sum formula
suggestions for B which do not have a valid corresponding sum formula in A and vice versa.
</p>


<h3>Source</h3>

<p>This list has been put together manually by Jan Lisec analyzing multiple LC-ESI-MS (positive mode) data sets.
</p>

<hr>
<h2 id='OrbiMS1'>Orbitrap spectra</h2><span id='topic+OrbiMS1'></span>

<h3>Description</h3>

<p>A set of 550 MS1 pseudo-spectra of metabolite standards, acquired on an 
Orbitrap-type mass analyzer (Q Exactive, Thermo-Fisher) in electrospray ionization (ESI) 
positive mode. Spectra were generated from Thermo raw files using xcms/CAMERA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(OrbiMS1)
</code></pre>


<h3>Format</h3>

<p>A list with 550 matrices (spectra). Two attributes are attached to 
each spectrum: 
</p>

<dl>
<dt>Formula</dt><dd><p>sum formula of (neutral) compound</p>
</dd>
<dt>ExactMass</dt><dd><p>exact mass of (neutral) compound</p>
</dd>
</dl>


<hr>
<h2 id='param.default'>Default parameter list for <code>InterpretMSSpectrum</code>.</h2><span id='topic+param.default'></span>

<h3>Description</h3>

<p>Default parameter list for <code>InterpretMSSpectrum</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(param.default)
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 observations on the following 3 variables:
</p>

<dl>
<dt><code>ionization</code></dt><dd><p>ESI or APCI &ndash; will influence expected peak width and precision as well as adducts.</p>
</dd>
<dt><code>ionmode</code></dt><dd><p>positive or negative &ndash; will influence expected adducts.</p>
</dd>
<dt><code>allowed_elements</code></dt><dd><p>Passed to Rdisop in formula generation.</p>
</dd>
<dt><code>maxElements</code></dt><dd><p>Passed to Rdisop in formula generation.</p>
</dd>
<dt><code>minElements</code></dt><dd><p>Passed to Rdisop in formula generation.</p>
</dd>
<dt><code>substitutions</code></dt><dd><p>Will be deprecated in the future.</p>
</dd>
<dt><code>quick_isos</code></dt><dd><p>TRUE = via Rdisop, FALSE = via enviPat (often more correct)</p>
</dd>
<dt><code>score_cutoff</code></dt><dd><p>Specifies initial filtering step threshold per fragment. Sum Formulas with score_i &lt; score_cutoff*max(score) will be removed.</p>
</dd>
<dt><code>neutral_loss_cutoff</code></dt><dd><p>Specifies the allowed deviation in mDa for neutral losses to be accepted from the provided neutral loss list.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Default parameter list used by <code><a href="#topic+InterpretMSSpectrum">InterpretMSSpectrum</a></code>, serving also as a template 
for custom lists. Basically every option which needs to be modified rarely went in here. Specific 
parameter set modifications (i.e. for 'APCIpos') are provided and can be called using the character 
string as a shortcut. Alternatively, a named list can be provided where all contained parameters 
will receive the new specified values.
</p>

<hr>
<h2 id='PlotSpec'>Plot Mass Spectrum.</h2><span id='topic+PlotSpec'></span>

<h3>Description</h3>

<p><code>PlotSpec</code> will read, evaluate and plot a deconvoluted mass spectrum (mass*intensity pairs) from TMS-derivatized GC-APCI-MS data.
The main purpose is to visualize the relation between deconvoluted masses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotSpec(
  x = NULL,
  masslab = 0.1,
  rellab = FALSE,
  cutoff = 0.01,
  cols = NULL,
  txt = NULL,
  mz_prec = 4,
  ionization = NULL,
  neutral_losses = NULL,
  neutral_loss_cutoff = NULL,
  substitutions = NULL,
  precursor = NULL,
  xlim = NULL,
  ylim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotSpec_+3A_x">x</code></td>
<td>
<p>A two-column matrix with (&quot;mz&quot;, &quot;int&quot;) information.</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_masslab">masslab</code></td>
<td>
<p>The cutoff value  (relative to basepeak) for text annotation of peaks.</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_rellab">rellab</code></td>
<td>
<p>TRUE/FALSE. Label masses relative to largest mass in plot (if TRUE), 
absolute (if FALSE) or to specified mass (if numeric).</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_cutoff">cutoff</code></td>
<td>
<p>Show only peaks with intensity higher than cutoff*I(base peak). 
This will limit the x-axis accordingly.</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_cols">cols</code></td>
<td>
<p>Color vector for peaks with length(cols)==nrow(x).</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_txt">txt</code></td>
<td>
<p>Label peaks with specified text (column 1 specifies x-axis value, 
column 2 specifies label).</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_mz_prec">mz_prec</code></td>
<td>
<p>Numeric precision of m/z (=number of digits to plot).</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_ionization">ionization</code></td>
<td>
<p>Either APCI or ESI (important for main peak determination).</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_neutral_losses">neutral_losses</code></td>
<td>
<p>Data frame of defined building blocks (Name, Formula, Mass). 
If not provided data(&quot;neutral_losses&quot;) will be used.</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_neutral_loss_cutoff">neutral_loss_cutoff</code></td>
<td>
<p>Specifies the allowed deviation in mDa for neutral 
losses to be accepted from the provided neutral loss list.</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_substitutions">substitutions</code></td>
<td>
<p>May provide a two column table of potential substitutions 
(for adducts in ESI-MS).</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_precursor">precursor</code></td>
<td>
<p>Internally main peaks will be determined up to a supposed 
precursor obtained by 'DetermineIsomainPeaks' and annotations will only be 
plotted up to this mass. To plot annotations for the full mass range, set 
'precursor' to a higher mass.</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_xlim">xlim</code></td>
<td>
<p>To specify xlim explicitly (for comparative plotting).</p>
</td></tr>
<tr><td><code id="PlotSpec_+3A_ylim">ylim</code></td>
<td>
<p>To specify ylim explicitly (for comparative plotting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An annotated plot of the mass spectrum.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load test data and apply function
utils::data(apci_spectrum, package = "InterpretMSSpectrum")
PlotSpec(x=apci_spectrum, ionization="APCI")

# normalize test data by intensity
s &lt;- apci_spectrum
s[,2] &lt;- s[,2]/max(s[,2])
PlotSpec(x=s)

# use relative labelling
PlotSpec(x=s, rellab=364.1789)

# avoid annotation of masses and fragments
PlotSpec(x=s, masslab=NULL, neutral_losses=NA)

# provide individual neutral loss set
tmp &lt;- data.frame("Name"=c("Loss1","Loss2"),"Formula"=c("",""),"Mass"=c(90.05,27.995))
PlotSpec(x=s, neutral_losses=tmp)

# provide additional color and annotation information per peak
PlotSpec(x=s, cols=1+(s[,2]&gt;0.1), txt=data.frame("x"=s[s[,2]&gt;0.1,1],"txt"="txt"))

# annotate a sum formula
PlotSpec(x=s, txt=data.frame("x"=s[which.max(s[,2]),1],"txt"="C[6]~H[12]~O[6]","expr"=TRUE))

# simulate a Sodium adduct to the spectrum (and annotate using substitutions)
p &lt;- which.max(s[,2])
s &lt;- rbind(s, c(21.98194+s[p,1], 0.6*s[p,2]))
PlotSpec(x=s, substitutions=matrix(c("H","Na"),ncol=2,byrow=TRUE))

#load ESI test data and apply function
utils::data(esi_spectrum)
PlotSpec(x=esi_spectrum, ionization="ESI")
</code></pre>

<hr>
<h2 id='ReadSpecClipboard'>ReadSpecClipboard.</h2><span id='topic+ReadSpecClipboard'></span>

<h3>Description</h3>

<p>Read a mass spectrum from the windows clipboard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadSpecClipboard(con = "clipboard")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadSpecClipboard_+3A_con">con</code></td>
<td>
<p>A connection other than 'clipboard' can be provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spectrum as two-column matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  if (length(grep("Windows", utils::sessionInfo()$running))==1) {
    x &lt;- InterpretMSSpectrum::apci_spectrum
    write.table(x, "clipboard", sep="\t", row.names=FALSE)
    InterpretMSSpectrum::ReadSpecClipboard()
  }

## End(Not run)
</code></pre>

<hr>
<h2 id='sendToMSF'>Exporting spectra to MSFinder.</h2><span id='topic+sendToMSF'></span><span id='topic+sendToMSF.default'></span><span id='topic+sendToMSF.findMAIN'></span>

<h3>Description</h3>

<p>Send spectrum to MSFinder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sendToMSF(x, ...)

## Default S3 method:
sendToMSF(
  x,
  precursormz,
  precursortype = "[M+H]+",
  outfile = NULL,
  MSFexe = NULL,
  ...
)

## S3 method for class 'findMAIN'
sendToMSF(x, rank = 1, ms2spec = NULL, outfile = NULL, MSFexe = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sendToMSF_+3A_x">x</code></td>
<td>
<p>A matrix or 'findMAIN' object</p>
</td></tr>
<tr><td><code id="sendToMSF_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods of <code><a href="#topic+writeMSF">writeMSF</a></code>.</p>
</td></tr>
<tr><td><code id="sendToMSF_+3A_precursormz">precursormz</code></td>
<td>
<p>m/z of (de)protonated molecule or adduct ion</p>
</td></tr>
<tr><td><code id="sendToMSF_+3A_precursortype">precursortype</code></td>
<td>
<p>adduct type, e.g. <code>[M+H]+</code> or <code>[M+Na]+</code>. Accepted values are all adduct ions supported by MSFINDER.</p>
</td></tr>
<tr><td><code id="sendToMSF_+3A_outfile">outfile</code></td>
<td>
<p>Name of MAT file. If NULL, a temporary file is created in the  per-session temporary directory (see <code><a href="base.html#topic+tempdir">tempdir</a></code>).</p>
</td></tr>
<tr><td><code id="sendToMSF_+3A_msfexe">MSFexe</code></td>
<td>
<p>Full path of MS-FINDER executable. This needs to be set  according to your system. If <code>NULL</code>, MAT files are written but the program is not opened.</p>
</td></tr>
<tr><td><code id="sendToMSF_+3A_rank">rank</code></td>
<td>
<p>Which rank from 'findMAIN' should be exported.</p>
</td></tr>
<tr><td><code id="sendToMSF_+3A_ms2spec">ms2spec</code></td>
<td>
<p>An (optional) MS2 spectrum to be passed to MSFINDER. If <code>NULL</code>, the MS1 spectrum used by 'findMAIN' is used. If dedicated MS2 spectra are available, this option should be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the default case 'x' can be a matrix or data frame, where the first two columns 
are assumed to contain the 'mz' and 'intensity' values, respectively. Further arguments 
'precursormz' and 'precursortype' are required in this case. Otherwise 'x' can be of 
class <code>findMAIN</code>.
</p>


<h3>Value</h3>

<p>Full path of generated MAT file (invisibly).
</p>


<h3>References</h3>

<p>H.Tsugawa et al (2016) Hydrogen rearrangement rules: computational MS/MS fragmentation and structure elucidation using MS-FINDER software. Analytical Chemistry, 88, 7946-7958
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
utils::data(esi_spectrum, package = "InterpretMSSpectrum")
fmr &lt;- findMAIN(esi_spectrum)
sendToMSF(fmr, outfile="tmp.mat")
sendToMSF(fmr, outfile="tmp.mat", rank=1:3)

## End(Not run)

</code></pre>

<hr>
<h2 id='writeMSF'>writeMSF.</h2><span id='topic+writeMSF'></span><span id='topic+writeMSF.default'></span><span id='topic+writeMSF.findMAIN'></span>

<h3>Description</h3>

<p>Write a spectrum file in MSFinder format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeMSF(x, ...)

## Default S3 method:
writeMSF(
  x,
  precursormz,
  precursortype = "[M+H]+",
  name = "unknown",
  ionmode = "Positive",
  ms1spec = NULL,
  retentiontime = NULL,
  outfile = NULL,
  ...
)

## S3 method for class 'findMAIN'
writeMSF(x, rank = 1, ms2spec = NULL, outfile = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMSF_+3A_x">x</code></td>
<td>
<p>A matrix, 'findMAIN' or other object for which methods are defined.</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_...">...</code></td>
<td>
<p>Arguments passed to method writeMSF.findMAIN.</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_precursormz">precursormz</code></td>
<td>
<p>Precursor m/z</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_precursortype">precursortype</code></td>
<td>
<p>Precursor type</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_name">name</code></td>
<td>
<p>Give the spectrum a name</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_ionmode">ionmode</code></td>
<td>
<p>&quot;Positive&quot; or &quot;Negative&quot;</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_ms1spec">ms1spec</code></td>
<td>
<p>(Optional) MS1 spectrum.</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_retentiontime">retentiontime</code></td>
<td>
<p>(Optional) retention time of the spectrum that will be used by MSFinder for refined prediction.</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_outfile">outfile</code></td>
<td>
<p>Name of MAT file, or <code>NULL</code> for 'stdout'.</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_rank">rank</code></td>
<td>
<p>Which rank from 'findMAIN' should be exported</p>
</td></tr>
<tr><td><code id="writeMSF_+3A_ms2spec">ms2spec</code></td>
<td>
<p>If available you may provide the according MS2 spectrum</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the default case 'x' can be a matrix or data frame, where the first two columns are assumed to contain the 'mz' and 'intensity' values, respectively. Further arguments 'precursormz' and 'precursortype' are required in this case. Otherwise 'x' can be of class <code>findMAIN</code>.
</p>


<h3>Value</h3>

<p>Write spectrum to MAT file for evaluation in MSFinder
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
