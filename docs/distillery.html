<!DOCTYPE html><html><head><title>Help for package distillery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {distillery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#booter'>
<p>Bootstrap Resampling</p></a></li>
<li><a href='#ci'>
<p>Find Confidence Intervals</p></a></li>
<li><a href='#ci.booted'>
<p>Bootstrap Confidence Intervals</p></a></li>
<li><a href='#datagrabber'>
<p>Get Original Data from an R Object</p></a></li>
<li><a href='#distill'>
<p>Distill An Object</p></a></li>
<li><a href='#distillery internal'>
<p>distillery Internal and Secondary Functions</p></a></li>
<li><a href='#distillery-package'>
<p>distillery: Methods to Distill Information from R Objects</p></a></li>
<li><a href='#is.even'>
<p>Identify Even or Odd Numbers</p></a></li>
<li><a href='#is.formula'>
<p>Is the R Object a Formula</p></a></li>
<li><a href='#MatrixSqrt'>
<p>Square-Root of a Square Matrix</p></a></li>
<li><a href='#pbooter'>
<p>Parametric Bootstrap Resampling</p></a></li>
<li><a href='#tibber'>
<p>Test-Inversion Bootstrap</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Method Functions for Confidence Intervals and to Distill
Information from an Object</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric Gilleland</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric Gilleland &lt;ericg@ucar.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Some very simple method functions for confidence interval calculation, bootstrap resampling aimed at atmospheric science applications, and to distill pertinent information from a potentially complex object; primarily used in common with packages extRemes and SpatialVx.  To reference this package and for a tutorial on the bootstrap functions, please see Gilleland (2020) &lt;<a href="https://doi.org/10.1175%2FJTECH-D-20-0069.1">doi:10.1175/JTECH-D-20-0069.1</a>&gt; and Gilleland (2020) &lt;<a href="https://doi.org/10.1175%2FJTECH-D-20-0070.1">doi:10.1175/JTECH-D-20-0070.1</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ral.ucar.edu/staff/ericg/">https://ral.ucar.edu/staff/ericg/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-18 16:39:29 UTC; eric</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-19 07:10:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='booter'>
Bootstrap Resampling
</h2><span id='topic+booter'></span>

<h3>Description</h3>

<p>Generate B bootstrap replicates of size rsize and apply a statistic to them.  Can do IID or Circular Block Bootstrap (CBB) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booter(x, statistic, B, rsize, block.length = 1, v.terms, shuffle = NULL,
    replace = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="booter_+3A_x">x</code></td>
<td>

<p>Original data series.  May be a vector, matrix or data frame object.
</p>
</td></tr>
<tr><td><code id="booter_+3A_statistic">statistic</code></td>
<td>

<p>Function that minimally takes arguments: <code>data</code> and <code>...</code>.  The argument <code>data</code> must be the input data for which resamples are taken.  Must return a vector of all desired statistics.
</p>
</td></tr>
<tr><td><code id="booter_+3A_b">B</code></td>
<td>

<p>number of bootstrap resamples to make.
</p>
</td></tr>
<tr><td><code id="booter_+3A_rsize">rsize</code></td>
<td>

<p>Number giving the resample size for each bootstrap sample.  Must be between 1 and the length of <code>x</code>, if <code>x</code> is a vector, else the number of rows of <code>x</code>.  Default is to use the size of the original data.
</p>
</td></tr>
<tr><td><code id="booter_+3A_block.length">block.length</code></td>
<td>

<p>Number giving the desired block lengths.  Default (<code>block.length</code> = 1) is to do IID resamples.  Should be longer than the length of dependence in the data, but much shorter than the size of the data.
</p>
</td></tr>
<tr><td><code id="booter_+3A_replace">replace</code></td>
<td>

<p>logical, should the resamples be taken with replacement?
</p>
</td></tr>
<tr><td><code id="booter_+3A_v.terms">v.terms</code></td>
<td>

<p>If <code>statistic</code> returns variance estimates for other parameters, then use this argument to specify the indices returned that give the variance estimates.  There must be a component for every other parameter returned, and they must be in the same order as the other parameters (see examples below).  If an estimate does not exist, an NA should be returned for that spot.
</p>
</td></tr>
<tr><td><code id="booter_+3A_shuffle">shuffle</code></td>
<td>
 <p><code>rsize</code> by <code>B</code> matrix giving the indices for each bootstrap replication.  If provided, <code>B</code> may be missing.</p>
</td></tr>
<tr><td><code id="booter_+3A_...">...</code></td>
<td>

<p>Optional arguments passed to <code>statistic</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar functionality to <code>boot</code> from package <span class="pkg">boot</span>, but allows for easier implementation of certain other approaches.  For example, m-out-of-n bootstrap resampling (appropriate for heavy-tail distributed data) can be performed via the <code>rsize</code> argument.  The <code>ci</code> function is used to obtain subsequent confidence limits.  For parameteric bootstrap resampling, see <code>pbooter</code>.
</p>
<p>For more complicated bootstrap resampling, e.g., Bayesian bootstrap sampling, the <code>shuffle</code> argument may prove useful.  That is, no weighting is allowed with this function through the standard mechanism, but the same result may be obtained by supplying your own indices through the <code>shuffle</code> argument.  For parametric bootstrap resampling, see the <code>pbooter</code> function, but for certain types of parametric resampling, the <code>shuffle</code> argument could prove useful.
</p>
<p>If the block length is &gt; 1, then <code>rsize</code> overlapping blocks of this length are sampled from the data.  In order to minimize over or under sampling of the end points, the blocks are circular (cf. Lahiri 2003).
</p>
<p>Many good books and other materials are available about bootstrap resampling.  One good text on IID bootstrap resampling is Efron and Tibshirani (1998) and for the block bootstrap, Lahiri (2003).
</p>


<h3>Value</h3>

<p>A list object of class &ldquo;booted&rdquo; is returned with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function call</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data series</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>statistic argument passed in</p>
</td></tr>
<tr><td><code>statistic.args</code></td>
<td>
<p>all other arguments passed by ...</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p> Number of bootstrap replicate samples</p>
</td></tr>
<tr><td><code>block.length</code></td>
<td>
<p> The block length used</p>
</td></tr>
<tr><td><code>replace</code></td>
<td>
<p>logical stating whether the samples are taken with replacement or not. </p>
</td></tr>
<tr><td><code>v.terms</code></td>
<td>
<p>if variance terms are returned by statistic, the argument is repeated in the returned object.</p>
</td></tr>
<tr><td><code>rsize</code></td>
<td>
<p>the size of the bootstrap resamples.</p>
</td></tr>
<tr><td><code>indices</code></td>
<td>
<p>rsize by B matrix giving the resample indices used (rows) for each bootstrap resample (columns).</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>B length vector or B column matrix (if statistic returns a vector) giving the estimated parameter variances for each bootstrap replicate.</p>
</td></tr>
<tr><td><code>orig.v</code></td>
<td>
<p>vector giving the parameter variances (i.e. se^2) of statistic when applied to the original data.</p>
</td></tr>
<tr><td><code>original.est</code></td>
<td>
<p>vector giving the estimated parameter values when statistic is applied to the original data.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>B length vector or B column matrix giving the parameter estimates for each bootstrap resample.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>character stating whether the resample method is iid or cbb.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Efron, B. and Tibshirani, R. J. (1998) <em>An Introduction to the Bootstrap</em>.  Chapman \&amp; Hall, Boca Raton, Florida, 436 pp.
</p>
<p>Lahiri, S. N. (2003) <em>Resampling Methods for Dependent Data</em>.  Springer-Verlag, New York, New York, 374 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pbooter">pbooter</a></code>, <code><a href="#topic+ci.booted">ci.booted</a></code>
<code>tibber</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z &lt;- rnorm( 100 )

zfun &lt;- function( data, ... ) {

    return( c( mean( data ), var( data ), mean( data^2 ), var( data^2 ) ) )

} # end of 'zfun' function.

res &lt;- booter( x = z, statistic = zfun, B = 500, v.terms = c(2, 4) )

print( res )

## Not run:  ci( res ) 
</code></pre>

<hr>
<h2 id='ci'>
Find Confidence Intervals
</h2><span id='topic+ci'></span><span id='topic+ci.matrix'></span><span id='topic+ci.numeric'></span><span id='topic+print.ci'></span>

<h3>Description</h3>

<p>Method function for finding confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci(x, alpha = 0.05, ...)

## S3 method for class 'matrix'
ci(x, alpha = 0.05, ...)

## S3 method for class 'numeric'
ci(x, alpha = 0.05, ...)

## S3 method for class 'ci'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci_+3A_x">x</code></td>
<td>

<p><code>ci</code>: an R object that has a <code>ci</code> method function for it.
</p>
<p><code>print</code>: output from <code>ci</code>.
</p>
</td></tr>
<tr><td><code id="ci_+3A_alpha">alpha</code></td>
<td>

<p>number between zero and one giving the 1 - <code>alpha</code> confidence level.
</p>
</td></tr>
<tr><td><code id="ci_+3A_...">...</code></td>
<td>

<p>Optional arguments depending on the specific method function.  In the case of those for <code>ci.matrix</code> and <code>ci.numeric</code>, these are any optional arguments to <code>mean</code> and <code>var</code>.
</p>
<p>Not used by <code>print</code> method function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ci.numeric</code>: Calculates the mean and normal approximation CIs for the mean.
</p>
<p><code>ci.matrix</code>: Does the same as <code>ci.numeric</code>, but applies to each column of <code>x</code>.
</p>


<h3>Value</h3>

<p><code>ci.numeric</code>: a numeric vector giving the CI bounds and mean value.
</p>
<p><code>ci.matrix</code>: a matrix giving the mean and CI bounds for each column of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ci(rnorm(100, mean=10, sd=2))

ci(matrix(rnorm(10000, mean=40, sd=10), 100, 100))
</code></pre>

<hr>
<h2 id='ci.booted'>
Bootstrap Confidence Intervals
</h2><span id='topic+ci.booted'></span>

<h3>Description</h3>

<p>Calculate confidence intervals for objects output from the booter and pbooter functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'booted'
ci(x, alpha = 0.05, ..., type = c("perc", "basic", "stud", "bca", "norm"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.booted_+3A_x">x</code></td>
<td>

<p>object of class &ldquo;booted&rdquo; as returned by the <code>booter</code> or <code>pbooter</code> function.
</p>
</td></tr>
<tr><td><code id="ci.booted_+3A_alpha">alpha</code></td>
<td>

<p>Significance level for which the (1 - alpha) * 100 percent confidence intervals are determined.
</p>
</td></tr>
<tr><td><code id="ci.booted_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="ci.booted_+3A_type">type</code></td>
<td>

<p>character stating which intervals are to be reutrned.  Default will do them all.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many methods exist for sampling parameters associated with a data set, and many methods for calculating confidence intervals from those resamples are also available.  Some points to consider when using these methods are the accuracy of the intervals, and whether or not they are range-preserving and/or transformation-respecting.  An interval that is range-preserving means that if a parameter can only take on values within a specified range, then the end points of the interval will also fall within this range.  Transformation-respecting means that if a parameter, say phi, is transformed by a monotone function, say m(phi), then the (1 - alpha) * 100 percent confidence interval for m(phi) can be derived by applying m() to the limits of the (1 - alpha) * 100 percent interval for phi.  That is [L(phi), U(phi)] = [m(L(phi)), m(U(phi))].
</p>
<p>For accuracy, a (1 - 2 * alpha) * 100 percent confidence interval, (L, U), is presumed to have probability alpha of not covering the true value of the parameter from above or below.  That is, if theta is the true value of the parameter, then Pr( theta &lt; L ) = alpha, and Pr( theta &gt; U ) = alpha.  A second-order accurate interval means that the error in these probabilities tends to zero at a rate that is inversely proportional to the sample size.  On the other hand, first-order accuracy means that the error tends to zero more slowly, at a rate inversely proportional to the square root of the sample size.
</p>
<p>the types of intervals available, here, are described below along with some considerations for their use.
</p>
<p>Percentile intervals (<code>type</code> = &ldquo;perc&rdquo;) are 1st order accurate, range-preserving, and transformation-respecting.  However, they may have poor coverage in some situations.  They are given by (L, U) where L and U are the 1 - alpha / 2 and alpha / 2 quantiles of the non-parametric distribution obtained through bootstrap resampling.
</p>
<p>The basic interval (<code>type</code> = &ldquo;basic&rdquo;) is the originally proposed interval and is given by (2 * theta - U, 2 * theta - L ), where U and L are as for the percentile interval.  This interval is 1st order accurate, but is not range-preserving or transformation-respecting.
</p>
<p>Studentized (or Bootstrap-t) intervals (<code>type</code> = &ldquo;stud&rdquo;) are 2nd order accurate, but not range-preserving or transformation-respecting, and they can be erratic for small samples, as well as sensitive to outliers.  They are obtained by the basic bootstrap, but where U and L are taken from the studentized version of the resampled parameter estimates.  That is, T' is taken for each bootstrap replicate, b, to be:
</p>
<p>T'(b) = (theta'(b) - theta) / (se'(b)), where theta'(b) and se'(b) are the estimated value of the parameter and its estimated standard error, resp., for bootstrap replicate b, and theta is the estimated parameter value using the original data.
</p>
<p>The bias-corrected and accelerated (BCa, <code>type</code> = &ldquo;bca&rdquo;) method applies a bias correction and adjustment to the percentile intervals.  The intervals are 2nd order accurate, range-preserving and transformation-respecting.  However, the estimation performed, here (Eq 14.15 in Efron and Tibshirani 1998), requires a further jacknife resampling estimation, so the computational burden can be more expensive.  The estimates for the bias-correction and acceleration adjustment can be found in Efron and Tibshirani (1998) p. 178 to 201.  The bias-correction factor includes an adjustment for ties.  
</p>
<p>Finally, the normal approximation interval (<code>type</code> = &ldquo;norm&rdquo;) uses the average of the estimated parameters from the bootstrap replicates, call it m, and their standard deviation, call is s, to make the usual normal approximation interval.  An assumption of normality for the parameter estimates is assumed, which means that they will be symmetric.  This method yields 1st order accurate intervals that are not range-preserving or transformation-respecting.
</p>


<h3>Value</h3>

<p>A list object of class &ldquo;ci.booted&rdquo; is returned with components depending on which types of intervals are calculated.
</p>
<table>
<tr><td><code>booted.object</code></td>
<td>
<p>The object passed through the x argument.</p>
</td></tr>
<tr><td><code>perc</code>, <code>basic</code>, <code>stud</code>, <code>bca</code>, <code>norm</code></td>
<td>
<p>vectors of length 3 or 3-column matrices giving the intervals and original parameter estimates for each CI method.</p>
</td></tr>
<tr><td><code>bias.correction</code>, <code>accelerated</code></td>
<td>
<p>If type includes &ldquo;bca&rdquo;, then the estiamted bias correction factor and acceleration are given in these components. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Efron, B. and Tibshirani, R. J. (1998) <em>An Introduction to the Bootstrap</em>.  Chapman \&amp; Hall, Boca Raton, Florida, 436 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+booter">booter</a></code>, <code><a href="#topic+pbooter">pbooter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## See the help file for booter and/or pbooter for examples.
##
</code></pre>

<hr>
<h2 id='datagrabber'>
Get Original Data from an R Object
</h2><span id='topic+datagrabber'></span>

<h3>Description</h3>

<p>Get the original data set used to obtain the resulting R object for which a method function exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datagrabber(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="datagrabber_+3A_x">x</code></td>
<td>

<p>An R object that has a method function for <code>datagrabber</code>.
</p>
</td></tr>
<tr><td><code id="datagrabber_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Often when applying functions to data, it is handy to be able to grab the original data for subsequent routines (e.g., plotting, etc.).  In some cases, information about where to obtain the original data might be available (more difficult) and in other cases, the data may simply be contained within a fitted object.  This method function is generic, but some packages (e.g., <span class="pkg">extRemes</span> &gt;= 2.0, <span class="pkg">SpatialVx</span> &gt;= 1.0) have datagrabber functions specific to particular object types.
</p>


<h3>Value</h3>

<p>The original pertinent data in whatever form it takes.
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## From the extRemes (&gt;= 2.0) package.
y &lt;- rnorm(100, mean=40, sd=20)
y &lt;- apply(cbind(y[1:99], y[2:100]), 1, max)
bl &lt;- rep(1:3, each=33)

ydc &lt;- decluster(y, quantile(y, probs=c(0.95)), r=1, blocks=bl)

yorig &lt;- datagrabber(ydc)
all(y - yorig == 0)


## End(Not run)

</code></pre>

<hr>
<h2 id='distill'>
Distill An Object
</h2><span id='topic+distill'></span><span id='topic+distill.list'></span><span id='topic+distill.matrix'></span><span id='topic+distill.data.frame'></span>

<h3>Description</h3>

<p>Distill a complex object to something easier to manage, like a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distill(x, ...)

## S3 method for class 'list'
distill(x, ...)

## S3 method for class 'matrix'
distill(x, ...)

## S3 method for class 'data.frame'
distill(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distill_+3A_x">x</code></td>
<td>

<p>A list, vector, matrix or data frame, or other object that has a <code>distill</code> method, e.g., <code>fevd</code> objects.
</p>
</td></tr>
<tr><td><code id="distill_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Perhaps a fine line exists between functions such as <code>c</code>, <code>print</code>, <code>str</code>, <code>summary</code>, etc.  The idea behind the <code>distill</code> method is to have a function that &ldquo;distills&rdquo; out the most pertinent information from a more complex object.  For example, when fitting a model to a number of spatial locations, it can be useful to pull out only certain information into a vector for ease of analysis.  With many models, it might not be feasible to store (or analyze) large complicated data objects.  In such a case, it may be useful to keep only a vector with the most pertinent information (e.g., parameter estimates, their standard errors, the likelihood value, AIC, BIC, etc.).  For example, this is used within <span class="pkg">extRemes</span> &gt;= 2.0 on the &ldquo;fevd&rdquo; class objects with the aim at fitting models to numerous locations within an <code>apply</code> call so that something easily handled is returned, but with enough information as to be useful.
</p>
<p>The data frame and matrix methods attempt to name each component of the vector.  The list method simply does <code>c(unlist(x))</code>.
</p>


<h3>Value</h3>

<p>numeric vector, possibly named.
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+c">c</a></code>, <code><a href="base.html#topic+unlist">unlist</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>, <code><a href="utils.html#topic+str">str</a></code>, <code><a href="base.html#topic+args">args</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- cbind(1:3, 4:6, 7:9)
distill(x)

x &lt;- data.frame(x=1:3, y=4:6, z=7:9)
distill(x)
</code></pre>

<hr>
<h2 id='distillery+20internal'>
distillery Internal and Secondary Functions
</h2><span id='topic+print.booted'></span><span id='topic+summary.booted'></span><span id='topic+print.ci.booted'></span><span id='topic+print.tibbed'></span><span id='topic+print.tibRMed'></span><span id='topic+plot.tibbed'></span><span id='topic+plot.tibRMed'></span><span id='topic+plot.booted'></span><span id='topic+plotBootBox'></span><span id='topic+plotBootECDF'></span><span id='topic+plotBootHist'></span><span id='topic+plotBootQQ'></span><span id='topic+plotBootQQ2'></span>

<h3>Description</h3>

<p>Listed below are supporting functions for the major methods in distillery.
</p>

<hr>
<h2 id='distillery-package'>
distillery: Methods to Distill Information from R Objects
</h2><span id='topic+distillery-package'></span><span id='topic+distillery'></span>

<h3>Description</h3>

<p><span class="pkg">distillery</span> contains primarily method functions to distill out pertinent information from R objects, as well as to compute confidence intervals.  It now also contains new fairly general bootstrap functions.
</p>


<h3>Details</h3>

<p>Primary functions include:
</p>
<p><code>distill</code>: Typically, to distill pertinent information from a complicated (usually a list) object and return a named vector.
</p>
<p><code>ci</code>: Calculate confidence intervals.  This is a method function for calculating confidence intervals.  Includes methods for numeric vectors and matrices, whereby the mean is taken (column-wise for matrices) and normal approximation confidence intervals for the mean are calculated and returned.
</p>
<p><code>booter</code>, <code>pbooter</code> and <code>tibber</code>: Functions to perform bootstrap resampling that work with <code>ci</code> (<code>booter</code> and <code>pbooter</code>).  Allows for m &lt; n bootstrap resampling, circular block bootstrapping, parametric bootstrap resampling (<code>pbooter</code>), and the test-inversion bootstrap approach (<code>tibber</code>).
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See help files for above named functions and datasets
## for specific examples.
</code></pre>

<hr>
<h2 id='is.even'>
Identify Even or Odd Numbers
</h2><span id='topic+is.even'></span><span id='topic+is.odd'></span><span id='topic+even'></span><span id='topic+odd'></span>

<h3>Description</h3>

<p>Simple functions to test for or return the even or odd numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.even(x)
is.odd(x)
even(x)
odd(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.even_+3A_x">x</code></td>
<td>
<p> any numeric, but maybe makes the most sense with integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return a logical vector/matrix of the same dimension as the argument <code>x</code> telling whether each component is odd (<code>is.odd</code>) or even (<code>is.even</code>), or return just the even (<code>even</code>) or odd (<code>odd</code>) numbers from the vector/matrix.  Uses <code>%%</code>.
</p>


<h3>Value</h3>

<p>Returns a logical vector/matrix/array of the same dimension as x in the case of is.even and is.odd, and returns a vector of length less than or equal to x in the case of even and odd; or if no even/odd values, returns integer(0).
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>See Also</h3>

<p><code>%%</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.even( 1:7 )
is.odd( 1:7 )
even( 1:7 )
odd( 1:7 )
</code></pre>

<hr>
<h2 id='is.formula'>
Is the R Object a Formula
</h2><span id='topic+is.formula'></span>

<h3>Description</h3>

<p>Tests to see if an object is a formula or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.formula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.formula_+3A_x">x</code></td>
<td>

<p>An R object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a very simple one that simplifies checking whether or not the class of an object is a formula or not.
</p>


<h3>Value</h3>

<p>single logical
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.formula(~1)
is.formula(1:3)
</code></pre>

<hr>
<h2 id='MatrixSqrt'>
Square-Root of a Square Matrix
</h2><span id='topic+MatrixSqrt'></span>

<h3>Description</h3>

<p>Find the (approximate ) square-root of a square matrix that is possibly not positive definite using the singular-value decomposition. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatrixSqrt( Sigma, verbose = getOption("verbose") )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatrixSqrt_+3A_sigma">Sigma</code></td>
<td>

<p>matrix for which the square root is to be taken.
</p>
</td></tr>
<tr><td><code id="MatrixSqrt_+3A_verbose">verbose</code></td>
<td>

<p>logical, should progress information be printed to the screen.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>eigen</code> function is first called in order to obtain the eigen values and vectors.  If any are complex then a symmetry transformation is applied (i.e., Sigma = 0.5 * ( Sigma + t( Sigma ) ) ) and then the <code>eigen</code> function is called again.  Eigen values that are less than zero, but close to zero, are set to zero.  If the matrix is positive definite, then the <code>chol</code> function is called in order to return the Cholesky decomposition.  Otherwise, U sqrt( D ) U' is returned, where U is the matrix of eigen vectors and D a diagonal matrix whose diagonal contains the eigen values.  The function will try to find the square root even if it is not positive definite, but it may fail.
</p>


<h3>Value</h3>

<p>A matrix is returned.
</p>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Hocking, R. R. (1996) <em>Methods and Applications of Linear Models</em>.  Wiley Series in Probability and Statistics, New York, NY, 731 pp.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+eigen">eigen</a></code>, <code><a href="Matrix.html#topic+chol">chol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 3 random variables, Y, X1 and X2, such that
# Y is correlated with both X1 and X2, but X1 and X2
# are uncorrelated.

set.seed( 2421 );

Z &lt;- matrix( rnorm( 300 ), 100, 3 );
R1 &lt;- cbind( c( 1, 0.8, 0.6 ), c( 0.8, 1, 0 ), c( 0.6, 0, 1 ) );
R2 &lt;- MatrixSqrt( R1 );

# R1;
# R2 %*% t( R2 );
# zapsmall( R2 %*% t( R2 ) );

Z &lt;- Z 
Y &lt;- Z[,1];
X1 &lt;- Z[,2];
X2 &lt;- Z[,3];
cor( Y, X1 );
cor( Y, X2 );
cor( X1, X2 );
plot( Y, X1, pch = 20, col = "darkblue",
     bg = "darkblue", cex = 1.5 );
points( Y, X2, col = "darkgray", pch = "+", cex = 1.5 );
plot( X1, X2 );

## Not run: 
# The following line will give an error message.
# chol( R1 );

## End(Not run)

</code></pre>

<hr>
<h2 id='pbooter'>
Parametric Bootstrap Resampling
</h2><span id='topic+pbooter'></span>

<h3>Description</h3>

<p>Creates sample statistics for several replicated samples derived by sampling from a parametric distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbooter(x, statistic, B, rmodel, rsize, v.terms, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pbooter_+3A_x">x</code></td>
<td>

<p>Original data set.  If it is a vector, then it is assumed to be univariate.  If it is a matrix, it is assumed to be multivariate where each column is a variate.
</p>
</td></tr>
<tr><td><code id="pbooter_+3A_statistic">statistic</code></td>
<td>

<p>Function that minimally takes arguments: <code>data</code> and <code>...</code>.  The argument <code>data</code> must be the input data for which resamples are taken.  Must return a vector of all desired statistics.
</p>
</td></tr>
<tr><td><code id="pbooter_+3A_b">B</code></td>
<td>

<p>number of bootstrap resamples to make.
</p>
</td></tr>
<tr><td><code id="pbooter_+3A_rmodel">rmodel</code></td>
<td>

<p>Function that generates the data to be applied to statistic.  Must have arguments <code>size</code>, giving the size of the data to be returned, and <code>...</code>.
</p>
</td></tr>
<tr><td><code id="pbooter_+3A_rsize">rsize</code></td>
<td>

<p>Number giving the resample size for each bootstrap sample.  If missing and <code>x</code> is a vector, it will be the length of <code>x</code>, and if it is a matrix, it will be the number of rows of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="pbooter_+3A_v.terms">v.terms</code></td>
<td>

<p>If <code>statistic</code> returns variance estimates for other parameters, then use this argument to specify the indices returned that give the variance estimates.  There must be a component for every other parameter returned, and they must be in the same order as the other parameters (see examples below).  If an estimate does not exist, an NA should be returned for that spot.
</p>
</td></tr>
<tr><td><code id="pbooter_+3A_verbose">verbose</code></td>
<td>
<p>logical, should progress information be printed to the screen?</p>
</td></tr>
<tr><td><code id="pbooter_+3A_...">...</code></td>
<td>

<p>Optional arguments to <code>statistic</code> or <code>rmodel</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar functionality to <code>boot</code> from <span class="pkg">boot</span> when <code>sim</code> = &ldquo;parametric&rdquo;.  In this case, the function is a little simpler, and is intended for use with <code>ci.booted</code>, or just <code>ci</code>.  It is similar to <code>booter</code>, but uses parametric sampling instead of resampling from the original data.
</p>


<h3>Value</h3>

<p>A list object of class &ldquo;booted&rdquo; is returned with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the function call</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>original data series</p>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
<p>statistic argument passed in</p>
</td></tr>
<tr><td><code>statistic.args</code></td>
<td>
<p>all other arguments passed by ...</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p> Number of bootstrap replicate samples</p>
</td></tr>
<tr><td><code>v.terms</code></td>
<td>
<p>if variance terms are returned by statistic, the argument is repeated in the returned object.</p>
</td></tr>
<tr><td><code>rsize</code></td>
<td>
<p>the size of the bootstrap resamples.</p>
</td></tr>
<tr><td><code>rdata</code></td>
<td>
<p>rsize by B matrix giving the rmodel generated data.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>B length vector or B column matrix (if statistic returns a vector) giving the estimated parameter variances for each bootstrap replicate.</p>
</td></tr>
<tr><td><code>orig.v</code></td>
<td>
<p>vector giving the parameter variances (i.e. se^2) of statistic when applied to the original data.</p>
</td></tr>
<tr><td><code>original.est</code></td>
<td>
<p>vector giving the estimated parameter values when statistic is applied to the original data.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>B length vector or B column matrix giving the parameter estimates for each bootstrap resample.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>character stating whether the resample method is iid or cbb.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Efron, B. and Tibshirani, R. J. (1998) <em>An Introduction to the Bootstrap</em>.  Chapman \&amp; Hall, Boca Raton, Florida, 436 pp.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+booter">booter</a></code>, <code><a href="#topic+ci.booted">ci.booted</a></code>
<code><a href="#topic+tibber">tibber</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- rnorm( 100 )

zfun &lt;- function( data, ... ) {

    return( c( mean( data ), var( data ), mean( data^2 ), var( data^2 ) ) )

} # end of 'zfun' function.

rfun &lt;- function( size, ... ) rnorm( size, ... )

res &lt;- pbooter( x = z, statistic = zfun, rmodel = rfun, B = 500,
    rsize = 100, v.terms = c(2, 4) )

print( res )

## Not run: ci( res )

</code></pre>

<hr>
<h2 id='tibber'>
Test-Inversion Bootstrap
</h2><span id='topic+tibber'></span><span id='topic+tibberRM'></span>

<h3>Description</h3>

<p>Calculate (1 - alpha) * 100 percent confidence intervals for an estimated parameter using the test-inversion bootstrap method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tibber(x, statistic, B, rmodel, test.pars, rsize, block.length = 1, v.terms,
    shuffle = NULL, replace = TRUE, alpha = 0.05, verbose = FALSE, ...)

tibberRM(x, statistic, B, rmodel, startval, rsize, block.length = 1, 
    v.terms, shuffle = NULL, replace = TRUE, alpha = 0.05, step.size, 
    tol = 1e-04, max.iter = 1000, keep.iters = TRUE, verbose = FALSE, 
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tibber_+3A_x">x</code></td>
<td>

<p>numeric vector or data frame giving the original data series.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_statistic">statistic</code></td>
<td>

<p>function giving the estimated parameter value.  Must minimally contain arguments <code>data</code> and <code>...</code>.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_b">B</code></td>
<td>

<p>number of replicated bootstrap samples to use.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_rmodel">rmodel</code></td>
<td>

<p>function that simulates data based on the nuisance parameter provided by <code>test.pars</code>.  Must minimally take arguments: <code>data</code>, <code>par</code>, <code>n</code>, and <code>...</code>.  The first, <code>data</code>, is the data series (it need not be used by the function, but it must have this argument, and the original data are passed to it via this argument), <code>par</code> is the nuisance parameter, <code>n</code> is the sample size, and <code>...</code> are any additional arguments that might be needed.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_test.pars">test.pars</code></td>
<td>

<p>single number or vector giving the nuisance parameter value.  If a vector of length greater than one, then the interpolation method will be applied to estimate the confidence bounds.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_startval">startval</code></td>
<td>
<p>one or two numbers giving the starting value for the nuisance parameter in the Robbins-Monro algorithm.  If two numbers are given, the first is used as the starting value for the lower bound, and the second for the upper.</p>
</td></tr>
<tr><td><code id="tibber_+3A_rsize">rsize</code></td>
<td>

<p>(optional) numeric less than the length of the series given by <code>x</code>, used if an m-out-of-n bootstrap sampling procedure should be used.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_block.length">block.length</code></td>
<td>

<p>(optional) length of blocks to use if the circular block bootstrap resampling scheme is to be used (default is iid sampling).
</p>
</td></tr>
<tr><td><code id="tibber_+3A_v.terms">v.terms</code></td>
<td>

<p>(optional) gives the positions of the variance estimate in the output from <code>statistic</code>.  If supplied, then Studentized intervals are returned instead of (<code>tibberRM</code>) of in addition to (<code>tibber</code>) the regular intervals.  Generally, such intervals are not ideal for the test-inversion method.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_shuffle">shuffle</code></td>
<td>

<p><code>n</code> (or <code>rsize</code>) by <code>B</code> matrix giving the indices for the resampling procedure (obviates arguments <code>block.length</code> and <code>B</code>).
</p>
</td></tr>
<tr><td><code id="tibber_+3A_replace">replace</code></td>
<td>

<p>logical stating whether or not to sample with replacement.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_alpha">alpha</code></td>
<td>

<p>significance level for the test.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_step.size">step.size</code></td>
<td>
<p> Step size for the Robbins-Monro algorithm.</p>
</td></tr>
<tr><td><code id="tibber_+3A_tol">tol</code></td>
<td>
<p> tolerance giving the value for how close the estimated p-value needs to be to <code>alpha</code> before stopping the Robbins-Monro algorithm.</p>
</td></tr>
<tr><td><code id="tibber_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations to perform before stopping the Robbins-Monro algorithm.</p>
</td></tr>
<tr><td><code id="tibber_+3A_keep.iters">keep.iters</code></td>
<td>
<p>logical, should information from each iteration of the Robbins-Monro algorithm be saved?</p>
</td></tr>
<tr><td><code id="tibber_+3A_verbose">verbose</code></td>
<td>

<p>logical should progress information be printed to the screen.
</p>
</td></tr>
<tr><td><code id="tibber_+3A_...">...</code></td>
<td>

<p>Optional arguments to <code>booter</code>, <code>statistic</code> and <code>rmodel</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test-inversion bootstrap (Carpenter 1999; Carpenter and Bithell 2000; Kabaila 1993) is a parametric bootstrap procedure that attempts to take advantage of the duality between confidence intervals and hypothesis tests in order to create bootstrap confidence intervals.  Let X = X_1,...,X_n be a series of random variables, T, is a parameter of interest, and R(X) is an estimator for T.  Further, let x = x_1,...,x_n be an observed realization of X, and r(x) an estimate for R(X), and let x* be a bootstrap resample of x, etc.  Suppose that X is distributed according to a distribution, F, with parameter T and nuisance parameter V.
</p>
<p>The procedure is carried out by estimating the p-value, say p*, from r*_1, ..., r*_B estimated from a simulated sample from <code>rmodel</code> assuming a specific value of V by way of finding the sum of r*_i &lt; r(x) (with an additional correction for the ties r*_i = r(x)).  The procedure is repeated for each of k values of V to form a sample of p-values, p*_1, ..., p*_k.  Finally, some form of root-finding algorithm must be employed to find the values r*_L and r*_U that estimate the lower and upper values, resp., for R(X) associated with (1 - alpha) * 100 percent confidence limits.  For <code>tibber</code>, the routine can be executed one time if <code>test.pars</code> is of length one, which will enable a user to employ their own root-finding algorithm.  If <code>test.pars</code> is a vector, then an interpolation estimate is found for the confidence end points.  <code>tibberRM</code> makes successive calls to <code>tibber</code> and uses the Robbins-Monro algorithm (Robbins and Monro 1951) to try to find the appropriate bounds, as suggested by Garthwaite and Buckland (1992).
</p>


<h3>Value</h3>

<p>For tibber, if test.pars is of length one, then a 3 by 1 matrix is returned (or, if <code>v.terms</code> is supplied, then a 4 by 1 matrix) where the first two rows give estimates for R(X) based on the original simulated series and the median from the bootstrap samples, respectively.  the last row gives the estimated p-value.  If <code>v.terms</code> is supplied, then the fourth row gives the p-value associated with the Studentized p-value.
</p>
<p>If test.pars is a vector with length k &gt; 1, then a list object of class &ldquo;tibbed&rdquo; is returned, which has components:
</p>
<table>
<tr><td><code>results</code></td>
<td>
<p>3 by k matrix (or 4 by k, if <code>v.terms</code> is not missing) giving two estimates for R(X) (one from the simulated series and one of the median of the bootstrap resamples, resp.) and the third row giving the estimated p-value for each value of V. </p>
</td></tr>
<tr><td><code>TIB.interpolated</code>, <code>STIB.interpolated</code></td>
<td>
<p>numeric vector of length 3 giving the lower bound estimate, the estimate from the original data (i.e., r(x)), and the estimated upper bound as obtained from interpolating over the vector of possible values for V given by test.pars.  The Studentized TIB interval, <code>STIB.interpolated</code>, is only returned if <code>v.terms</code> is provided.</p>
</td></tr>
<tr><td><code>Plow</code>, <code>Pup</code>, <code>PstudLow</code>, <code>PstudUp</code></td>
<td>
<p>Estimated p-values used for interpolation of p-value. </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the original function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the original data passed by the x argument.</p>
</td></tr>
<tr><td><code>statistic</code>, <code>B</code>, <code>rmodel</code>, <code>test.pars</code>, <code>rsize</code>, <code>block.length</code>, <code>alpha</code>, <code>replace</code></td>
<td>
<p>arguments passed into the orignal function call.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>original sample size.</p>
</td></tr>
<tr><td><code>total.time</code></td>
<td>
<p>Total time it took for the function to run.</p>
</td></tr>
</table>
<p>For tibberRM, a list of class &ldquo;tibRMed&rdquo; is returned with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the original function call.</p>
</td></tr>
<tr><td><code>x</code>, <code>statistic</code>, <code>B</code>, <code>rmodel</code>, <code>rsize</code>, <code>block.length</code>, <code>alpha</code>, <code>replace</code></td>
<td>
<p>arguments passed into the orignal function call.</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>vector of length 3 giving the estimated confidence interval with the original parameter estimate in the second component.</p>
</td></tr>
<tr><td><code>lower.p.value</code>, <code>upper.p.value</code></td>
<td>
<p>Estimated achieved p-values for the lower and upper bounds.</p>
</td></tr>
<tr><td><code>lower.nuisance.par</code>, <code>upper.nuisance.par</code></td>
<td>
<p> nuisance parameter values associated with the lower and upper bounds. </p>
</td></tr>
<tr><td><code>lower.iterations</code>, <code>upper.iterations</code></td>
<td>
<p> number of iterations of the Robbins-Monro algorithm it took to find the lower and upper bounds.</p>
</td></tr>
<tr><td><code>total.time</code></td>
<td>
<p>Total time it took for the function to run.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Gilleland
</p>


<h3>References</h3>

<p>Carpenter, James (1999) Test inversion bootstrap confidence intervals.  <em>J. R. Statist. Soc. B</em>, <b>61</b> (1), 159&ndash;172.
</p>
<p>Carpenter, James and Bithell, John (2000) Bootstrap confidence intervals: when, which, what?  A practical guide for medical statisticians.  <em>Statist. Med.</em>, <b>19</b>, 1141&ndash;1164.
</p>
<p>Garthwaite, P. H. and Buckland, S. T. (1992) Generating Monte Carlo confidence intervals by the Robbins-Monro process.  <em>Appl. Statist.</em>, <b>41</b>, 159&ndash;171.
</p>
<p>Kabaila, Paul (1993) Some properties of profile bootstrap confidence intervals.  <em>Austral. J. Statist.</em>, <b>35</b> (2), 205&ndash;214.
</p>
<p>Robbins, Herbert and Monro, Sutton (1951) A stochastic approximation method.  <em>Ann. Math Statist.</em>, <b>22</b> (3), 400&ndash;407.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+booter">booter</a></code>, <code><a href="#topic+pbooter">pbooter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following example follows the example provided at:
#
# http://influentialpoints.com/Training/bootstrap_confidence_intervals.htm
#
# which is provided with a creative commons license:
#
# https://creativecommons.org/licenses/by/3.0/ 
#
y &lt;- c( 7, 7, 6, 9, 8, 7, 8, 7, 7, 7, 6, 6, 6, 8, 7, 7, 7, 7, 6, 7,
        8, 7, 7, 6, 8, 7, 8, 7, 8, 7, 7, 7, 5, 7, 7, 7, 6, 7, 8, 7, 7,
        8, 6, 9, 7, 14, 12, 10, 13, 15 )

trm &lt;- function( data, ... ) {

    res &lt;- try( mean( data, trim = 0.1, ... ) )
    if( class( res ) == "try-error" ) return( NA )
    else return( res )

} # end of 'trm' function.

genf &lt;- function( data, par, n, ... ) {

    y &lt;- data * par
    h &lt;- 1.06 * sd( y ) / ( n^( 1 / 5 ) )
    y &lt;- y + rnorm( rnorm( n, 0, h ) )
    y &lt;- round( y * ( y &gt; 0 ) )

    return( y )

} # end of 'genf' function.

look &lt;- tibber( x = y, statistic = trm, B = 500, rmodel = genf,
    test.pars = seq( 0.85, 1.15, length.out = 100 ) )

look

plot( look )
# outer vertical blue lines should cross horizontal blue lines
# near where an estimated p-value is located.

tibber( x = y, statistic = trm, B = 500, rmodel = genf, test.pars = 1 )


## Not run: 
look2 &lt;- tibberRM(x = y, statistic = trm, B = 500, rmodel = genf, startval = 1,
    step.size = 0.03, verbose = TRUE )

look2
# lower achieved est. p-value should be close to 0.025
# upper should be close to 0.975.

plot( look2 )

trm2 &lt;- function( data, par, n, ... ) {

    a &lt;- list( ... )
    res &lt;- try( mean( data, trim = a$trim ) )
    if( class( res ) == "try-error" ) return( NA )
    else return( res )

} # end of 'trm2' function.

tibber( x = y, statistic = trm2, B = 500, rmodel = genf,
    test.pars = seq( 0.85, 1.15, length.out = 100 ), trim = 0.1 )

# Try getting the STIB interval.  v.terms = 2 below because mfun
# returns the variance of the estimated parameter in the 2nd position.
#
# Note: the STIB interval can be a bit unstable.

mfun &lt;- function( data, ... ) return( c( mean( data ), var( data ) ) )

gennorm &lt;- function( data, par, n, ... ) {

    return( rnorm( n = n, mean = mean( data ), sd = sqrt( par ) ) )

} # end of 'gennorm' function.

set.seed( 1544 )
z &lt;- rnorm( 50 )
mean( z )
var( z )

# Trial-and-error is necessary to get a good result with interpolation method.
res &lt;- tibber( x = z, statistic = mfun, B = 500, rmodel = gennorm,
    test.pars = seq( 0.95, 1.10, length.out = 100 ), v.terms = 2 )

res

plot( res )

# Much trial-and-error is necessary to get a good result with RM method.
# If it fails to converge, try increasing the tolerance.
res2 &lt;- tibberRM( x = z, statistic = mfun, B = 500, rmodel = gennorm,
    startval = c( 0.95, 1.1 ), step.size = 0.003, tol = 0.001, v.terms = 2,
    verbose = TRUE )
# Note that it only gives the STIB interval.

res2

plot( res2 )


## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
