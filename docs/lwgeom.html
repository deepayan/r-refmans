<!DOCTYPE html><html><head><title>Help for package lwgeom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lwgeom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bounding_circle'><p>Generate the minimum bounding circle</p></a></li>
<li><a href='#geod'><p>liblwgeom geodetic functions</p></a></li>
<li><a href='#lwgeom_extSoftVersion'><p>Provide the external dependencies versions of the libraries linked to sf</p></a></li>
<li><a href='#lwgeom_make_valid'><p>Make an invalid geometry valid</p></a></li>
<li><a href='#perimeter'><p>compute perimeter from polygons or other geometries</p></a></li>
<li><a href='#st_as_sfc.TWKB'><p>create sfc object from tiny well-known binary (twkb)</p></a></li>
<li><a href='#st_astext'><p>Return Well-known Text representation of simple feature geometry</p></a></li>
<li><a href='#st_force_polygon_cw'><p>Force a POLYGON or MULTIPOLYGON to be clockwise</p></a></li>
<li><a href='#st_geod_azimuth'><p>compute azimuth between sequence of points</p></a></li>
<li><a href='#st_geohash'><p>compute geohash from (average) coordinates</p></a></li>
<li><a href='#st_is_polygon_cw'><p>Check if a POLYGON or MULTIPOLYGON is clockwise</p></a></li>
<li><a href='#st_linesubstring'><p>get substring from linestring</p></a></li>
<li><a href='#st_snap_to_grid'><p>Snap geometries to a grid</p></a></li>
<li><a href='#st_split'><p>Return a collection of geometries resulting by splitting a geometry</p></a></li>
<li><a href='#st_startpoint'><p>Return the start and end points from lines</p></a></li>
<li><a href='#st_subdivide'><p>Return a collection of geometries resulting by subdividing a geometry</p></a></li>
<li><a href='#st_transform_proj'><p>Transform or convert coordinates of simple features directly with Proj.4 (bypassing GDAL)</p></a></li>
<li><a href='#st_wrap_x'><p>Splits input geometries by a vertical line and moves components falling on</p>
one side of that line by a fixed amount</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2-14</td>
</tr>
<tr>
<td>Title:</td>
<td>Bindings to Selected 'liblwgeom' Functions for Simple Features</td>
</tr>
<tr>
<td>Description:</td>
<td>Access to selected functions found in 'liblwgeom' <a href="https://github.com/postgis/postgis/tree/master/liblwgeom">https://github.com/postgis/postgis/tree/master/liblwgeom</a>, the light-weight geometry library used by 'PostGIS' <a href="http://postgis.net/">http://postgis.net/</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, units, sf (&ge; 1.0-15)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, sp, geosphere, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, sf (&ge; 0.6-0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GEOS (&gt;= 3.5.0), PROJ (&gt;= 4.8.0), sqlite3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>file COPYRIGHTS</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-spatial.github.io/lwgeom/">https://r-spatial.github.io/lwgeom/</a>,
<a href="https://github.com/r-spatial/lwgeom">https://github.com/r-spatial/lwgeom</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/lwgeom/issues">https://github.com/r-spatial/lwgeom/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>init.R RcppExports.R geohash.R split.R subdivide.R valid.R
transform.R bounding_circle.R bearing.R snap_to_grid.R
startpoint.R twkb.R perimeter.R clockwise.R geod.R wkt.R
wrap_x.R</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 14:39:21 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Colin Rundel [ctb],
  Andy Teucher [ctb],
  liblwgeom developers [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bounding_circle'>Generate the minimum bounding circle</h2><span id='topic+bounding_circle'></span><span id='topic+st_minimum_bounding_circle'></span>

<h3>Description</h3>

<p>Generate the minimum bounding circle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_minimum_bounding_circle(x, nQuadSegs = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounding_circle_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfg</code> or <code>sf</code></p>
</td></tr>
<tr><td><code id="bounding_circle_+3A_nquadsegs">nQuadSegs</code></td>
<td>
<p>number of segments per quadrant (passed to <code>st_buffer</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_minimum_bounding_circle</code> uses the <code>lwgeom_calculate_mbc</code> method also used by the PostGIS command <code>ST_MinimumBoundingCircle</code>.
</p>


<h3>Value</h3>

<p>Object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)

x = st_multipoint(matrix(c(0,1,0,1),2,2))
y = st_multipoint(matrix(c(0,0,1,0,1,1),3,2))

mbcx = st_minimum_bounding_circle(x)
mbcy = st_minimum_bounding_circle(y)

if (.Platform$OS.type != "windows") {
  plot(mbcx, axes=TRUE); plot(x, add=TRUE)
  plot(mbcy, axes=TRUE); plot(y, add=TRUE)
}

nc = st_read(system.file("gpkg/nc.gpkg", package="sf"))
state = st_union(st_geometry(nc))

if (.Platform$OS.type != "windows") {
  plot(st_minimum_bounding_circle(state), asp=1)
  plot(state, add=TRUE)
}

</code></pre>

<hr>
<h2 id='geod'>liblwgeom geodetic functions</h2><span id='topic+geod'></span><span id='topic+st_geod_area'></span><span id='topic+st_geod_length'></span><span id='topic+st_geod_segmentize'></span><span id='topic+st_geod_covers'></span><span id='topic+st_geod_covered_by'></span><span id='topic+st_geod_distance'></span>

<h3>Description</h3>

<p>liblwgeom geodetic functions for length, area, segmentizing, covers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_geod_area(x)

st_geod_length(x)

st_geod_segmentize(x, max_seg_length)

st_geod_covers(x, y, sparse = TRUE)

st_geod_covered_by(x, y, sparse = TRUE)

st_geod_distance(x, y, tolerance = 0, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geod_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geod_+3A_max_seg_length">max_seg_length</code></td>
<td>
<p>segment length in degree, radians, or as a length unit (e.g., m)</p>
</td></tr>
<tr><td><code id="geod_+3A_y">y</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="geod_+3A_sparse">sparse</code></td>
<td>
<p>logical; if <code>TRUE</code>, return a sparse matrix (object of class <code>sgbp</code>), otherwise, return a dense logical matrix.</p>
</td></tr>
<tr><td><code id="geod_+3A_tolerance">tolerance</code></td>
<td>
<p>double or length <code>units</code> value: if positive, the first distance less than <code>tolerance</code> is returned, rather than the true distance</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>st_area</code> will give an error message when the area spans the equator and <code>lwgeom</code> is linked to a proj.4 version older than 4.9.0 (see <a href="#topic+lwgeom_extSoftVersion">lwgeom_extSoftVersion</a>)
</p>
<p>longitude coordinates returned are rescaled to [-180,180)
</p>


<h3>Note</h3>

<p>this function should is used by <a href="sf.html#topic+geos_measures">st_distance</a>, do not use it directly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
nc = st_read(system.file("gpkg/nc.gpkg", package="sf"))
st_geod_area(nc[1:3,])
# st_area(nc[1:3,])
l = st_sfc(st_linestring(rbind(c(7,52), c(8,53))), crs = 4326)
st_geod_length(l)
library(units)
pol = st_polygon(list(rbind(c(0,0), c(0,60), c(60,60), c(0,0))))
x = st_sfc(pol, crs = 4326)
seg = st_geod_segmentize(x[1], set_units(10, km))
plot(seg, graticule = TRUE, axes = TRUE)
pole = st_polygon(list(rbind(c(0,80), c(120,80), c(240,80), c(0,80))))
pt = st_point(c(0,90))
x = st_sfc(pole, pt, crs = 4326)
st_geod_covers(x[c(1,1,1)], x[c(2,2,2,2)])
pole = st_polygon(list(rbind(c(0,80), c(120,80), c(240,80), c(0,80))))
pt = st_point(c(30,70))
x = st_sfc(pole, pt, crs = 4326)
st_geod_distance(x, x)
</code></pre>

<hr>
<h2 id='lwgeom_extSoftVersion'>Provide the external dependencies versions of the libraries linked to sf</h2><span id='topic+lwgeom_extSoftVersion'></span>

<h3>Description</h3>

<p>Provide the external dependencies versions of the libraries linked to sf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lwgeom_extSoftVersion()
</code></pre>

<hr>
<h2 id='lwgeom_make_valid'>Make an invalid geometry valid</h2><span id='topic+lwgeom_make_valid'></span>

<h3>Description</h3>

<p>Make an invalid geometry valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lwgeom_make_valid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lwgeom_make_valid_+3A_x">x</code></td>
<td>
<p>object of class <code>sfc</code></p>
</td></tr>
</table>

<hr>
<h2 id='perimeter'>compute perimeter from polygons or other geometries</h2><span id='topic+perimeter'></span><span id='topic+st_perimeter_lwgeom'></span><span id='topic+st_perimeter'></span><span id='topic+st_perimeter_2d'></span>

<h3>Description</h3>

<p>compute perimeter from polygons or other geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_perimeter_lwgeom(x)

st_perimeter(x)

st_perimeter_2d(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perimeter_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numerical vector with perimeter for each feature (geometry), with unit of measure when possible
</p>

<hr>
<h2 id='st_as_sfc.TWKB'>create sfc object from tiny well-known binary (twkb)</h2><span id='topic+st_as_sfc.TWKB'></span>

<h3>Description</h3>

<p>create sfc object from tiny well-known binary (twkb)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TWKB'
st_as_sfc(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_as_sfc.TWKB_+3A_x">x</code></td>
<td>
<p>list with raw vectors, of class <code>TWKB</code></p>
</td></tr>
<tr><td><code id="st_as_sfc.TWKB_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>https://github.com/TWKB/Specification/blob/master/twkb.md
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l = structure(list(as.raw(c(0x02, 0x00, 0x02, 0x02, 0x02, 0x08, 0x08))), class = "TWKB")
library(sf) # load generic
st_as_sfc(l)
</code></pre>

<hr>
<h2 id='st_astext'>Return Well-known Text representation of simple feature geometry</h2><span id='topic+st_astext'></span><span id='topic+st_asewkt'></span>

<h3>Description</h3>

<p>Return Well-known Text representation of simple feature geometry or coordinate reference system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_astext(x, digits = options("digits"), ..., EWKT = FALSE)

st_asewkt(x, digits = options("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_astext_+3A_x">x</code></td>
<td>
<p>object of class <code>sfg</code>, <code>sfc</code>, or <code>sf</code></p>
</td></tr>
<tr><td><code id="st_astext_+3A_digits">digits</code></td>
<td>
<p>integer; number of decimal digits to print</p>
</td></tr>
<tr><td><code id="st_astext_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="st_astext_+3A_ewkt">EWKT</code></td>
<td>
<p>logical; use PostGIS Enhanced WKT (includes srid)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned WKT representation of simple feature geometry conforms to the
<a href="https://www.ogc.org/standard/sfa/">simple features access</a> specification and extensions (if <code>EWKT = TRUE</code>),
<a href="http://postgis.net/docs/using_postgis_dbmanagement.html#EWKB_EWKT">known as EWKT</a>, supported by
PostGIS and other simple features implementations for addition of SRID to a WKT string.
</p>
<p><code>st_asewkt()</code> returns the Well-Known Text (WKT) representation of
the geometry with SRID meta data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
pt &lt;- st_sfc(st_point(c(1.0002,2.3030303)), crs = 4326)
st_astext(pt, 3)
st_asewkt(pt, 3)
</code></pre>

<hr>
<h2 id='st_force_polygon_cw'>Force a POLYGON or MULTIPOLYGON to be clockwise</h2><span id='topic+st_force_polygon_cw'></span>

<h3>Description</h3>

<p>Check if a POLYGON or MULTIPOLYGON is clockwise, and if not make it so. 
According to the 'Right-hand-rule', outer rings should be clockwise, and 
inner holes should be counter-clockwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_force_polygon_cw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_force_polygon_cw_+3A_x">x</code></td>
<td>
<p>object with polygon geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
polys &lt;- st_sf(cw = c(FALSE, TRUE), 
               st_as_sfc(c('POLYGON ((0 0, 1 0, 1 1, 0 0))', 
                           'POLYGON ((1 1, 2 2, 2 1, 1 1))')))

st_force_polygon_cw(polys)
st_force_polygon_cw(st_geometry(polys))
st_force_polygon_cw(st_geometry(polys)[[1]])
</code></pre>

<hr>
<h2 id='st_geod_azimuth'>compute azimuth between sequence of points</h2><span id='topic+st_geod_azimuth'></span>

<h3>Description</h3>

<p>compute azimuth between sequence of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_geod_azimuth(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_geod_azimuth_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
p = st_sfc(st_point(c(7,52)), st_point(c(8,53)), crs = 4326)
st_geod_azimuth(p)
</code></pre>

<hr>
<h2 id='st_geohash'>compute geohash from (average) coordinates</h2><span id='topic+st_geohash'></span>

<h3>Description</h3>

<p>compute geohash from (average) coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_geohash(x, precision = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_geohash_+3A_x">x</code></td>
<td>
<p>object of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="st_geohash_+3A_precision">precision</code></td>
<td>
<p>integer; precision (length) of geohash returned. From the liblwgeom source: &ldquo;where the precision is non-positive, a precision based on the bounds of the feature. Big features have loose precision. Small features have tight precision.&rdquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <a href="http://geohash.org/">http://geohash.org/</a> or <a href="https://en.wikipedia.org/wiki/Geohash">https://en.wikipedia.org/wiki/Geohash</a>.
</p>


<h3>Value</h3>

<p>character vector with geohashes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
lwgeom::st_geohash(st_sfc(st_point(c(1.5,3.5)), st_point(c(0,90))), 2)
lwgeom::st_geohash(st_sfc(st_point(c(1.5,3.5)), st_point(c(0,90))), 10)
</code></pre>

<hr>
<h2 id='st_is_polygon_cw'>Check if a POLYGON or MULTIPOLYGON is clockwise</h2><span id='topic+st_is_polygon_cw'></span>

<h3>Description</h3>

<p>Check if a POLYGON or MULTIPOLYGON is clockwise. According to the 
'Right-hand-rule', outer rings should be clockwise, and inner holes
should be counter-clockwise
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_is_polygon_cw(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_is_polygon_cw_+3A_x">x</code></td>
<td>
<p>object with polygon geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical with length the same number of features in 'x'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
polys &lt;- st_sf(cw = c(FALSE, TRUE), 
               st_as_sfc(c('POLYGON ((0 0, 1 0, 1 1, 0 0))', 
                           'POLYGON ((1 1, 2 2, 2 1, 1 1))')))

st_is_polygon_cw(polys)
st_is_polygon_cw(st_geometry(polys))
st_is_polygon_cw(st_geometry(polys)[[1]])
</code></pre>

<hr>
<h2 id='st_linesubstring'>get substring from linestring</h2><span id='topic+st_linesubstring'></span>

<h3>Description</h3>

<p>get substring from linestring
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_linesubstring(x, from, to, tolerance, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_linesubstring_+3A_x">x</code></td>
<td>
<p>object of class <code>sfc</code>, <code>sf</code> or <code>sfg</code></p>
</td></tr>
<tr><td><code id="st_linesubstring_+3A_from">from</code></td>
<td>
<p>relative distance from origin (in [0,1])</p>
</td></tr>
<tr><td><code id="st_linesubstring_+3A_to">to</code></td>
<td>
<p>relative distance from origin (in [0,1])</p>
</td></tr>
<tr><td><code id="st_linesubstring_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance parameter, when to snap to line node node</p>
</td></tr>
<tr><td><code id="st_linesubstring_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class <code>sfc</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
lines = st_sfc(st_linestring(rbind(c(0,0), c(1,2), c(2,0))), crs = 4326)
spl = st_linesubstring(lines, 0.2, 0.8) # should warn
plot(st_geometry(lines), col = 'red', lwd = 3)
plot(spl, col = 'black', lwd = 3, add = TRUE)
st_linesubstring(lines, 0.49999, 0.8) # three points
st_linesubstring(lines, 0.49999, 0.8, 0.001) # two points: snap start to second node
</code></pre>

<hr>
<h2 id='st_snap_to_grid'>Snap geometries to a grid</h2><span id='topic+st_snap_to_grid'></span>

<h3>Description</h3>

<p>Snap geometries to a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_snap_to_grid(x, size, origin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_snap_to_grid_+3A_x">x</code></td>
<td>
<p>object with geometries to be snapped</p>
</td></tr>
<tr><td><code id="st_snap_to_grid_+3A_size">size</code></td>
<td>
<p>numeric or (length) units object; grid cell size in x-, y- (and possibly z- and m-) directions</p>
</td></tr>
<tr><td><code id="st_snap_to_grid_+3A_origin">origin</code></td>
<td>
<p>numeric; origin of the grid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># obtain data
library(sf)
x = st_read(system.file("gpkg/nc.gpkg", package="sf"), quiet = TRUE)[1, ] %&gt;%
    st_geometry %&gt;%
    st_transform(3395)

# snap to a grid of 5000 m
err = try(y &lt;- st_snap_to_grid(x, 5000))

# plot data for visual comparison
if (!inherits(err, "try-error")) {
 opar = par(mfrow = c(1, 2))
 plot(x, main = "orginal data")
 plot(y, main = "snapped to 5000 m")
 par(opar)
}
</code></pre>

<hr>
<h2 id='st_split'>Return a collection of geometries resulting by splitting a geometry</h2><span id='topic+st_split'></span>

<h3>Description</h3>

<p>Return a collection of geometries resulting by splitting a geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_split(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_split_+3A_x">x</code></td>
<td>
<p>object with geometries to be splitted</p>
</td></tr>
<tr><td><code id="st_split_+3A_y">y</code></td>
<td>
<p>object split with (blade); if <code>y</code> contains more than one feature geometry, the geometries are <a href="sf.html#topic+geos_combine">st_combine</a> 'd</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
l = st_as_sfc('MULTILINESTRING((10 10, 190 190), (15 15, 30 30, 100 90))')
pt = st_sfc(st_point(c(30,30)))
st_split(l, pt)
</code></pre>

<hr>
<h2 id='st_startpoint'>Return the start and end points from lines</h2><span id='topic+st_startpoint'></span><span id='topic+st_endpoint'></span>

<h3>Description</h3>

<p>Return the start and end points from lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_startpoint(x)

st_endpoint(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_startpoint_+3A_x">x</code></td>
<td>
<p>line of class <code>sf</code>, <code>sfc</code> or <code>sfg</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <a href="https://postgis.net/docs/ST_StartPoint.html">https://postgis.net/docs/ST_StartPoint.html</a> and <a href="https://postgis.net/docs/ST_EndPoint.html">https://postgis.net/docs/ST_EndPoint.html</a>.
</p>


<h3>Value</h3>

<p><code>sf</code> object representing start and end points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
m = matrix(c(0, 1, 2, 0, 1, 4), ncol = 2)
l = st_sfc(st_linestring(m))
lwgeom::st_startpoint(l)
lwgeom::st_endpoint(l)
l2 = st_sfc(st_linestring(m), st_linestring(m[3:1, ]))
lwgeom::st_startpoint(l2)
lwgeom::st_endpoint(l2)
</code></pre>

<hr>
<h2 id='st_subdivide'>Return a collection of geometries resulting by subdividing a geometry</h2><span id='topic+st_subdivide'></span>

<h3>Description</h3>

<p>Return a collection of geometries resulting by subdividing a geometry
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_subdivide(x, max_vertices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_subdivide_+3A_x">x</code></td>
<td>
<p>object with geometries to be subdivided</p>
</td></tr>
<tr><td><code id="st_subdivide_+3A_max_vertices">max_vertices</code></td>
<td>
<p>integer; maximum size of the subgeometries (at least 8)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
demo(nc, ask = FALSE, echo = FALSE)
x = st_subdivide(nc, 10)
plot(x[1])
</code></pre>

<hr>
<h2 id='st_transform_proj'>Transform or convert coordinates of simple features directly with Proj.4 (bypassing GDAL)</h2><span id='topic+st_transform_proj'></span><span id='topic+st_transform_proj.sfc'></span><span id='topic+st_transform_proj.sf'></span><span id='topic+st_transform_proj.sfg'></span>

<h3>Description</h3>

<p>Transform or convert coordinates of simple features directly with Proj.4 (bypassing GDAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_transform_proj(x, crs, ...)

## S3 method for class 'sfc'
st_transform_proj(x, crs, ...)

## S3 method for class 'sf'
st_transform_proj(x, crs, ...)

## S3 method for class 'sfg'
st_transform_proj(x, crs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_transform_proj_+3A_x">x</code></td>
<td>
<p>object of class sf, sfc or sfg</p>
</td></tr>
<tr><td><code id="st_transform_proj_+3A_crs">crs</code></td>
<td>
<p>character; target CRS, or, in case of a length 2 character vector, source and target CRS</p>
</td></tr>
<tr><td><code id="st_transform_proj_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Transforms coordinates of object to new projection, using PROJ directly rather than the GDAL API used by <a href="sf.html#topic+st_transform">st_transform</a>.
</p>
<p>If <code>crs</code> is a single CRS, it forms the target CRS, and in that case the source CRS is obtained as <code>st_crs(x)</code>. Since this presumes that the source CRS is accepted by GDAL (which is not always the case), a second option is to specify the source and target CRS as two proj4strings in argument <code>crs</code>. In the latter case, <code>st_crs(x)</code> is ignored and may well be <code>NA</code>.
</p>
<p>The <code>st_transform_proj</code> method for <code>sfg</code> objects assumes that the CRS of the object is available as an attribute of that name.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
p1 = st_point(c(7,52))
p2 = st_point(c(-30,20))
sfc = st_sfc(p1, p2, crs = 4326)
sfc
st_transform_proj(sfc, "+proj=wintri")
library(sf)
nc = st_read(system.file("shape/nc.shp", package="sf"))
st_transform_proj(nc[1,], "+proj=wintri +over")
st_transform_proj(structure(p1, proj4string = "+init=epsg:4326"), "+init=epsg:3857")
</code></pre>

<hr>
<h2 id='st_wrap_x'>Splits input geometries by a vertical line and moves components falling on
one side of that line by a fixed amount</h2><span id='topic+st_wrap_x'></span>

<h3>Description</h3>

<p>Splits input geometries by a vertical line and moves components falling on
one side of that line by a fixed amount
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_wrap_x(x, wrap, move)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_wrap_x_+3A_x">x</code></td>
<td>
<p>object with geometries to be split</p>
</td></tr>
<tr><td><code id="st_wrap_x_+3A_wrap">wrap</code></td>
<td>
<p>x value of split line</p>
</td></tr>
<tr><td><code id="st_wrap_x_+3A_move">move</code></td>
<td>
<p>amount by which geometries falling to the left of the line
should be translated to the right</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of the same class as <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
demo(nc, ask = FALSE, echo = FALSE)
x = st_wrap_x(nc, -78, 10)
plot(x[1])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
