<!DOCTYPE html><html><head><title>Help for package RSiena</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSiena}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RSiena-package'>
<p>Simulation Investigation for Empirical Network Analysis</p></a></li>
<li><a href='#allEffects'>
<p>Internal data frame used to construct effect objects.</p></a></li>
<li><a href='#coCovar'><p>Function to create a constant covariate object</p></a></li>
<li><a href='#coDyadCovar'><p>Function to create a constant dyadic covariate object.</p></a></li>
<li><a href='#edit.sienaEffects'>
<p>Allow editing of a sienaEffects object if a gui is available.</p></a></li>
<li><a href='#effectsDocumentation'>
<p>Function to create a table of documentation of effect names, short names etc.</p></a></li>
<li><a href='#funnelPlot'><p>Plot function for a list of sienaFit objects</p></a></li>
<li><a href='#getEffects'><p>Function to create a Siena effects object</p></a></li>
<li><a href='#hn3401'><p>Network data: excerpt from &quot;Dutch Social Behavior Data Set&quot;</p>
of Chris Baerveldt.</a></li>
<li><a href='#includeEffects'>
<p>Function to include effects in a Siena model</p></a></li>
<li><a href='#includeGMoMStatistics'>
<p>Function to include GMoM statistics in a Siena model</p></a></li>
<li><a href='#includeInteraction'>
<p>Function to create user-specified interactions for a Siena model.</p></a></li>
<li><a href='#includeTimeDummy'><p>Function to include time dummy effects in a Siena model</p></a></li>
<li><a href='#iwlsm'>
<p>Function to fit an iterated weighted least squares model.</p></a></li>
<li><a href='#n3401'><p>Network data: excerpt from &quot;Dutch Social Behavior Data Set&quot;</p>
of Chris Baerveldt.</a></li>
<li><a href='#plot.sienaTimeTest'><p>Functions to plot assessment of time heterogeneity of parameters</p></a></li>
<li><a href='#print.sienaEffects'>
<p>Print methods for Siena effects objects</p></a></li>
<li><a href='#print.sienaMeta'><p>Methods for processing sienaMeta objects</p></a></li>
<li><a href='#print.sienaTest'>
<p>Print method for Wald and score tests for RSiena results</p></a></li>
<li><a href='#print01Report'>
<p>Function to produce the Siena01 report from R objects</p></a></li>
<li><a href='#s50'><p>Network data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.</p></a></li>
<li><a href='#s501'><p>Network 1 data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.</p></a></li>
<li><a href='#s502'><p>Network 2 data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.</p></a></li>
<li><a href='#s503'><p>Network 3 data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.</p></a></li>
<li><a href='#s50a'><p>Alcohol use data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data</p></a></li>
<li><a href='#s50s'><p>Smoking data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data</p></a></li>
<li><a href='#setEffect'>
<p>Function to set various columns in an effects object in a Siena model.</p></a></li>
<li><a href='#siena07'><p>Function to estimate parameters in a Siena model</p></a></li>
<li><a href='#siena08'>
<p>Function to perform a meta analysis of a collection of Siena fits.</p></a></li>
<li><a href='#sienaAlgorithmCreate'><p>Function to create an object containing the algorithm</p>
specifications for parameter estimation in RSiena</a></li>
<li><a href='#sienaCompositionChange'>
<p>Functions to create a Siena composition change object</p></a></li>
<li><a href='#sienaDataConstraint'>
<p>Function to change the values of the constraints between networks.</p></a></li>
<li><a href='#sienaDataCreate'><p>Function to create a Siena data object</p></a></li>
<li><a href='#sienaDependent'><p>Function to create a dependent variable for a Siena model</p></a></li>
<li><a href='#sienaFit.methods'><p>Methods for processing sienaFit objects, produced by <code>siena07</code>.</p></a></li>
<li><a href='#sienaGOF'><p>Functions to assess goodness of fit for SAOMs</p></a></li>
<li><a href='#sienaGOF-auxiliary'><p>Auxiliary functions for goodness of fit assessment by <code>sienaGOF</code></p></a></li>
<li><a href='#sienaGroupCreate'><p>Function to group together several Siena data objects</p></a></li>
<li><a href='#sienaNodeSet'><p>Function to create a node set</p></a></li>
<li><a href='#sienaTimeTest'><p>Functions to assess and account for time heterogeneity of parameters</p></a></li>
<li><a href='#simstats0c'><p>Versions of FRAN</p></a></li>
<li><a href='#summary.iwlsm'>
<p>Summary method for Iterative Weighted Least Squares Models</p></a></li>
<li><a href='#tmp3'><p>van de Bunt's Freshman dataset, time point 3</p></a></li>
<li><a href='#tmp4'><p>van de Bunt's Freshman dataset, time point 4</p></a></li>
<li><a href='#updateTheta'>
<p>A function to update the initial values of theta, and a function</p>
to update an effects object.</a></li>
<li><a href='#varCovar'><p>Function to create a changing covariate object.</p></a></li>
<li><a href='#varDyadCovar'><p>Function to create a changing dyadic covariate object.</p></a></li>
<li><a href='#Wald'><p>  Wald and score tests for RSiena results</p></a></li>
<li><a href='#xtable'>
<p>Access xtable in package xtable</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Siena - Simulation Investigation for Empirical Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-20</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tom A.B. Snijders &lt;tom.snijders@nuffield.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, lattice, parallel, MASS, methods, xtable</td>
</tr>
<tr>
<td>Suggests:</td>
<td>network, tools, codetools, tcltk</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Description:</td>
<td>The main purpose of this package is to perform simulation-based
   estimation of stochastic actor-oriented models for longitudinal network
   data collected as panel data. Dependent variables can be single or
   multivariate networks, which can be directed, non-directed, or two-mode;
   and associated actor variables.
   There are also functions for testing parameters and checking goodness of fit.
   An overview of these models is given in Snijders (2017),
   &lt;<a href="https://doi.org/10.1146%2Fannurev-statistics-060116-054035">doi:10.1146/annurev-statistics-060116-054035</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Biarch:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>BuildResaveData:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stocnet/rsiena/issues">https://github.com/stocnet/rsiena/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-20 10:31:56 UTC; TomSnijders</td>
</tr>
<tr>
<td>Author:</td>
<td>Tom A.B. Snijders <a href="https://orcid.org/0000-0003-3157-4157"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Ruth M. Ripley [aut],
  Krists Boitmanis [aut, ctb],
  Christian Steglich
    <a href="https://orcid.org/0000-0002-9097-0873"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb],
  Johan Koskinen <a href="https://orcid.org/0000-0002-6860-325X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Nynke M.D. Niezink
    <a href="https://orcid.org/0000-0003-4199-4841"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, ctb],
  Viviana Amati <a href="https://orcid.org/0000-0003-1190-1237"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Christoph Stadtfeld
    <a href="https://orcid.org/0000-0002-2704-2134"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  James Hollway <a href="https://orcid.org/0000-0002-8361-9647"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (IHEID),
  Per Block <a href="https://orcid.org/0000-0002-7583-2392"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Robert Krause <a href="https://orcid.org/0000-0003-4288-4732"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Charlotte Greenan [ctb],
  Josh Lospinoso [ctb],
  Michael Schweinberger
    <a href="https://orcid.org/0000-0003-3649-5386"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Mark Huisman <a href="https://orcid.org/0000-0002-9009-7859"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Felix Schoenenberger [aut, ctb],
  Mark Ortmann [ctb],
  Marion Hoffman <a href="https://orcid.org/0000-0002-0741-7760"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Robert Hellpap [ctb],
  Alvaro Uzaheta <a href="https://orcid.org/0000-0003-4367-3670"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Steffen Triebel [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RSiena-package'>
Simulation Investigation for Empirical Network Analysis
</h2><span id='topic+RSiena-package'></span><span id='topic+RSiena'></span>

<h3>Description</h3>

<p>Fits statistical models to longitudinal sets of networks, and to   
longitudinal sets of networks and behavioral variables.   
Not only one-mode networks but also two-mode networks   
and multivariate networks are allowed.   
The models are stochastic actor-oriented models,   
described in Snijders (2017).
</p>
<p>Recent versions of the package are distributed through GitHub,   
see <a href="https://github.com/stocnet/rsiena/">https://github.com/stocnet/rsiena/</a>.
</p>
<p>Bug reports can be submitted at 
<a href="https://github.com/stocnet/rsiena/issues">https://github.com/stocnet/rsiena/issues</a>.
</p>


<h3>Details</h3>

<p>The main flow of operations of this package is as follows.
</p>
<p>Data objects can be created from matrices and
vectors using <code><a href="#topic+sienaDependent">sienaDependent</a></code>, <code><a href="#topic+coCovar">coCovar</a></code>,
<code><a href="#topic+varCovar">varCovar</a></code>, <code><a href="#topic+coDyadCovar">coDyadCovar</a></code>, etc.,
and finally <code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>.
</p>
<p>Effects are selected using an <code><a href="#topic+sienaEffects">sienaEffects</a></code> object,
which can be created using <code><a href="#topic+getEffects">getEffects</a></code>
and may be further specified by <code><a href="#topic+includeEffects">includeEffects</a></code>,
<code><a href="#topic+setEffect">setEffect</a></code>, and <code><a href="#topic+includeInteraction">includeInteraction</a></code>.
</p>
<p>Control of the estimation algorithm requires a
<code><a href="#topic+sienaAlgorithm">sienaAlgorithm</a></code> object that
defines the settings (parameters) of the algorithm,
and which can be created by <code><a href="#topic+sienaAlgorithmCreate">sienaAlgorithmCreate</a></code>.
</p>
<p>Function <code><a href="#topic+siena07">siena07</a></code> is used to fit a model.
Function <code><a href="#topic+sienaGOF">sienaGOF</a></code> can be used for studying goodness of fit.
</p>
<p>A general introduction to the method is available in the tutorial paper
Snijders, van de Bunt, and Steglich (2010).
Next to the help pages, more detailed help is available in the manual
(see below) and a lot of information is at the website (also see below).
</p>

<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> RSiena</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 1.4.7</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2024-02-20</td>
</tr>
<tr>
 <td style="text-align: left;">
    Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
    Imports: </td><td style="text-align: left;"> Matrix, lattice, parallel, MASS, methods, xtable</td>
</tr>
<tr>
 <td style="text-align: left;">
    Suggests: </td><td style="text-align: left;"> network, tools, codetools, tcltk</td>
</tr>
<tr>
 <td style="text-align: left;">
    SystemRequirements: </td><td style="text-align: left;"> GNU make</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL-2 | GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
    LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
    NeedsCompilation: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
    BuildResaveData: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Ruth Ripley, Krists Boitmanis, Tom Snijders, Felix Schoenenberger,
Nynke Niezink, Christian Steglich, Viviana Amati.
Contributions by Josh Lospinoso, Charlotte Greenan,
Johan Koskinen, Mark Ortmann, Natalie Indlekofer, Mark Huisman,
Christoph Stadtfeld, Per Block, Marion Hoffman, Michael Schweinberger,
Robert Hellpap, Alvaro Uzaheta, Robert Krause, James Hollway, and Steffen Triebel.
</p>
<p>Maintainer: Tom A.B. Snijders &lt;tom.snijders@nuffield.ox.ac.uk&gt;
</p>


<h3>References</h3>

<p>Amati, V., Schoenenberger, F., and Snijders, T.A.B. (2015),
Estimation of stochastic actor-oriented models for the evolution of 
networks by generalized method of moments.
<em>Journal de la Societe Francaise de Statistique</em> <b>156</b>, 140&ndash;165.
</p>
<p>Amati, V., Schoenenberger, F., and Snijders, T.A.B. (2019),
Contemporaneous statistics for estimation in stochastic actor-oriented
co-evolution models. <em>Psychometrika</em> <b>84</b>, 1068&ndash;1096.
</p>
<p>Greenan, C. (2015),
<em>Evolving Social Network Analysis: developments in statistical
methodology for dynamic stochastic actor-oriented models</em>.
DPhil dissertation, University of Oxford.
</p>
<p>Niezink, N.M.D., and Snijders, T.A.B. (2017),
Co-evolution of Social Networks and Continuous Actor Attributes.
<em>The Annals of Applied Statistics</em> <b>11</b>, 1948&ndash;1973.
</p>
<p>Schweinberger, M., and Snijders, T.A.B. (2007),
Markov models for digraph panel data:
Monte Carlo based derivative estimation.
<em>Computational Statistics and Data Analysis</em> <b>51</b>, 4465&ndash;4483.
</p>
<p>Snijders, T.A.B. (2001),
The statistical evaluation of social network dynamics.
<em>Sociological Methodology</em> <b>31</b>, 361&ndash;395.
</p>
<p>Snijders, T.A.B. (2017), Stochastic Actor-Oriented Models for Network
Dynamics. <em>Annual Review of Statistics and Its Application</em>
<b>4</b>, 343&ndash;363.
</p>
<p>Snijders, T.A.B., Koskinen, J., and Schweinberger, M. (2010).
Maximum likelihood estimation for social network dynamics.
<em>Annals of Applied Statistics</em> <b>4</b>, 567&ndash;588.
</p>
<p>Snijders, T.A.B., Steglich, C.E.G., and Schweinberger, Michael (2007), 
Modeling the co-evolution of networks and behavior.
Pp. 41&ndash;71 in <em>Longitudinal models in the behavioral
and related sciences</em>,
edited by van Montfort, K., Oud, H., and Satorra, A.; Lawrence Erlbaum.
</p>
<p>Steglich, C.E.G., Snijders, T.A.B., and Pearson, M.A. (2010),
Dynamic networks and behavior:     Separating selection from influence.
<em>Sociological Methodology</em> <b>40</b>, 329&ndash;393.
Information about the implementation of the algorithm is in
<a href="https://www.stats.ox.ac.uk/~snijders/siena/Siena_algorithms.pdf">https://www.stats.ox.ac.uk/~snijders/siena/Siena_algorithms.pdf</a>.
</p>
<p>Further see <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a> and
<a href="https://github.com/stocnet/rsiena/wiki">https://github.com/stocnet/rsiena/wiki</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet1 &lt;- sienaDependent(array(c(tmp3, tmp4), dim=c(32, 32, 2)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip)
myeff
myalgorithm &lt;- sienaAlgorithmCreate(nsub=3, n3=200)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE)
summary(ans)
</code></pre>

<hr>
<h2 id='allEffects'>
Internal data frame used to construct effect objects.
</h2><span id='topic+allEffects'></span>

<h3>Description</h3>

<p>This data frame is used internally to construct effect objects.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(allEffects)</code></pre>


<h3>Format</h3>

<p>A data frame with values for the following 23 variables.
</p>

<dl>
<dt><code>effectGroup</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>effectName</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>functionName</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>shortName</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>endowment</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>interaction1</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>interaction2</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>type</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>basicRate</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>include</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>randomEffects</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>fix</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>test</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>timeDummy</code></dt><dd><p>a character vector, default &quot;,&quot;</p>
</dd>
<dt><code>initialValue</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>parm</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>functionType</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>period</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>rateType</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>untrimmedValue</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>effect1</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>effect2</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>effect3</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>interactionType</code></dt><dd><p>a character vector</p>
</dd>
<dt><code>local</code></dt><dd><p>a logical vector</p>
</dd>
<dt><code>setting</code></dt><dd><p>Settings name: &rdquo; (no settings), 'primary', 'universal' or the name of the defining covariate.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Used to define effects. Not for general user use.</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>

<hr>
<h2 id='coCovar'>Function to create a constant covariate object</h2><span id='topic+coCovar'></span>

<h3>Description</h3>

<p>This function creates a constant covariate object from a vector.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coCovar(val, centered=TRUE, nodeSet="Actors", warn=TRUE, imputationValues=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coCovar_+3A_val">val</code></td>
<td>
<p>Vector of covariate values</p>
</td></tr>
<tr><td><code id="coCovar_+3A_centered">centered</code></td>
<td>
<p>Boolean: if TRUE, then the mean value is subtracted.</p>
</td></tr>
<tr><td><code id="coCovar_+3A_nodeset">nodeSet</code></td>
<td>
<p>Name of node set: character string.
If the entire data set contains more than one node set,
then the node sets must be specified in all data objects.</p>
</td></tr>
<tr><td><code id="coCovar_+3A_warn">warn</code></td>
<td>
<p>Logical: is a warning given if all values are <code>NA</code>,
or all non-missing values are the same.</p>
</td></tr>
<tr><td><code id="coCovar_+3A_imputationvalues">imputationValues</code></td>
<td>
<p>Vector of covariate values of same
length as <code>val</code>, to be used for imputation of
<code>NA</code> values (if any) in <code>val</code>. Must not contain
any <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When part of a Siena data object,
the covariate is associated with the node set
<code>nodeSet</code> of the Siena data object.
In practice, the node set needs to be specified only in the case of
the use of the covariate with a two-mode network.<br />
If there are any <code>NA</code> values in <code>val</code>, and
<code>imputationValues</code> is given, then the corresponding elements
of <code>imputationValues</code> are used for imputation.
If <code>imputationValues</code> is <code>NULL</code>, imputation
is by the mean value. In both cases, cases with imputed values
are not used for calculating target statistics (see the manual).
</p>


<h3>Value</h3>

<p>Returns the covariate as an object of class &quot;coCovar&quot;, in which
form it can be used as an argument to <code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+varCovar">varCovar</a></code>,
<code><a href="#topic+coDyadCovar">coDyadCovar</a></code>, <code><a href="#topic+varDyadCovar">varDyadCovar</a></code>,
<code><a href="#topic+sienaNodeSet">sienaNodeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
myconstCovar &lt;- coCovar(s50a[,1])
senders &lt;- sienaNodeSet(50, nodeSetName="senders")
receivers &lt;- sienaNodeSet(30, nodeSetName="receivers")
senders.attribute &lt;- coCovar(rep(1:10, each=5), nodeSet="senders")
receivers.attribute &lt;- coCovar(rep(1:5, each=6), nodeSet="receivers")
</code></pre>

<hr>
<h2 id='coDyadCovar'>Function to create a constant dyadic covariate object.</h2><span id='topic+coDyadCovar'></span>

<h3>Description</h3>

<p>This function creates a constant dyadic covariate object from a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coDyadCovar(val, centered=TRUE, nodeSets=c("Actors", "Actors"),
     warn=TRUE, sparse=inherits(val,"TsparseMatrix"), type=c("oneMode", "bipartite"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coDyadCovar_+3A_val">val</code></td>
<td>
<p>Matrix of covariate values. May be sparse, of type
<code>"TsparseMatrix"</code>. </p>
</td></tr>
<tr><td><code id="coDyadCovar_+3A_centered">centered</code></td>
<td>
<p>Boolean: if TRUE, then the mean value is subtracted.</p>
</td></tr>
<tr><td><code id="coDyadCovar_+3A_nodesets">nodeSets</code></td>
<td>
<p>The name of the node sets with which this
covariate is associated. If the entire data set contains more than
one node set, then the node sets must be specified in all data objects.</p>
</td></tr>
<tr><td><code id="coDyadCovar_+3A_warn">warn</code></td>
<td>
<p>Logical: is a warning given if all values are <code>NA</code>,
or all non-missing values are the same.</p>
</td></tr>
<tr><td><code id="coDyadCovar_+3A_sparse">sparse</code></td>
<td>
<p>Boolean: whether a sparse matrix or not.</p>
</td></tr>
<tr><td><code id="coDyadCovar_+3A_type">type</code></td>
<td>
<p>oneMode or bipartite: whether the matrix refers to a one-mode
or a bipartite (two-mode) network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When part of a Siena data object, the covariate is assumed to be
associated with the node sets named in nodeSets
of the Siena data object. The name of the associated node sets will only
be checked when the Siena data object is created.
</p>


<h3>Value</h3>

<p>Returns the covariate as an object of class &quot;coDyadCovar&quot;, in which
form it can be used as an argument to <code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+varDyadCovar">varDyadCovar</a></code>,
<code><a href="#topic+coCovar">coCovar</a></code>, <code><a href="#topic+varCovar">varCovar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mydyadvar &lt;- coDyadCovar(s503)
</code></pre>

<hr>
<h2 id='edit.sienaEffects'>
Allow editing of a sienaEffects object if a gui is available.
</h2><span id='topic+edit.sienaEffects'></span>

<h3>Description</h3>

<p>Interactive editor for an effects object. A wrapper to edit.data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sienaEffects'
edit(name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edit.sienaEffects_+3A_name">name</code></td>
<td>
<p>An object of class <code>sienaEffects</code></p>
</td></tr>
<tr><td><code id="edit.sienaEffects_+3A_...">...</code></td>
<td>
<p>For extra arguments (none used at present)
</p>
</td></tr></table>


<h3>Details</h3>

<p>Will be invoked by <code>fix(name)</code> for an object of class
<code>sienaEffects</code>.
</p>


<h3>Value</h3>

<p>The updated object. There is no backup copy, and the edits cannot be undone.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley
</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getEffects">getEffects</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mycovar &lt;- coCovar(rnorm(50))
mydyadcovar &lt;- coDyadCovar(matrix(as.numeric(rnorm(2500) &gt; 2), nrow=50))
mydata &lt;- sienaDataCreate(mynet1, mybeh, mycovar, mydyadcovar)
myeff &lt;- getEffects(mydata)
## Not run: 
fix(myeff)

## End(Not run)
</code></pre>

<hr>
<h2 id='effectsDocumentation'>
Function to create a table of documentation of effect names, short names etc.
</h2><span id='topic+effectsDocumentation'></span>

<h3>Description</h3>

<p>Produces a table of the shortnames and other information for effects,  
either in html or latex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectsDocumentation(effects = NULL, type = "html", display = (type=="html"),
     filename = ifelse(is.null(effects), "effects", deparse(substitute(effects))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectsDocumentation_+3A_effects">effects</code></td>
<td>

<p>A Siena effects object, or NULL.
</p>
</td></tr>
<tr><td><code id="effectsDocumentation_+3A_type">type</code></td>
<td>

<p>Type of output required. Valid options are &quot;html&quot; or &quot;latex&quot;.
</p>
</td></tr>
<tr><td><code id="effectsDocumentation_+3A_display">display</code></td>
<td>

<p>Boolean: should the output be displayed after creation. Only
applicable to html output.
</p>
</td></tr>
<tr><td><code id="effectsDocumentation_+3A_filename">filename</code></td>
<td>

<p>Character string denoting file name.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>effects=NULL</code>, the <code>allEffects</code> object is written to
a table, either latex or html. This table presents all the available
effects present in this version of RSiena, not delimited
by a particular data set. The default file name is &quot;effects.tex&quot; or
&quot;effects.html&quot;, respectively.
</p>
<p>The table lists all effects, with their name,
shortName, whether an endowment (and creation) effect exists,
the value of an effect parameter - if any -,
and the interactionType (which can be empty or: &quot;ego&quot; or &quot;dyadic&quot; for
dependent network variables; &quot;OK&quot; for dependent behavior variables).
The latter is important for knowing how the effects can be used
in interaction effects. (See <code><a href="#topic+includeInteraction">includeInteraction</a></code>).
</p>
<p>If an existing effects object is specified for <code>effects</code>, then all
available effects in this effects object are listed.
This table lists the name (i.e., dependent variable), effect name,
shortName, type (rate/evaluation/endowment/creation),
the variables defined as <code>interaction1</code> and <code>interaction2</code>
(see <code><a href="#topic+includeEffects">includeEffects</a></code>) that specify this effect,
the value of an effect parameter - if any -, and the interactionType.<br />
The GMoM effects, which are those with <code>type=gmm</code>, are listed at the end.
For these, the distinction between the fields <code>name</code> and
<code>interaction1</code>, referring to the dependent and the explanatory roles
of the variables, has no meaning.<br />
The default root file name is the name of the input effects object.
</p>


<h3>Value</h3>

<p>Nothing returned. Output files are created in the current working directory.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley, Tom A.B. Snijders</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getEffects">getEffects</a></code>, <code><a href="#topic+includeEffects">includeEffects</a></code>,
<code><a href="#topic+summary.sienaEffects">summary.sienaEffects</a></code>, <code><a href="#topic+includeInteraction">includeInteraction</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: effectsDocumentation()
</code></pre>

<hr>
<h2 id='funnelPlot'>Plot function for a list of sienaFit objects</h2><span id='topic+funnelPlot'></span>

<h3>Description</h3>

<p>Draws a funnel plot for a list of sienaFit objects that all  
have estimated the same parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funnelPlot(anslist, k, threshold=NULL, origin=TRUE,
           plotAboveThreshold=TRUE, verbose=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funnelPlot_+3A_anslist">anslist</code></td>
<td>
<p>A list of object of class <code>sienaFit</code>.</p>
</td></tr>
<tr><td><code id="funnelPlot_+3A_k">k</code></td>
<td>
<p>The number of the parameter to be plotted.</p>
</td></tr>
<tr><td><code id="funnelPlot_+3A_threshold">threshold</code></td>
<td>
<p>threshold for standard errors:
all estimations where the standard error for parameter
<code>k</code> is larger than this threshold will be disregarded.</p>
</td></tr>
<tr><td><code id="funnelPlot_+3A_origin">origin</code></td>
<td>
<p>Boolean: whether to include the origin in the plot,
if all estimates have the same sign.</p>
</td></tr>
<tr><td><code id="funnelPlot_+3A_plotabovethreshold">plotAboveThreshold</code></td>
<td>
<p>Boolean: whether to include the estimates
for which the standard error is larger than <code>threshold</code>,
and plot them with an asterisk at <code>se=threshold</code>.</p>
</td></tr>
<tr><td><code id="funnelPlot_+3A_verbose">verbose</code></td>
<td>
<p>Boolean: whether to report in the console all estimates
omitted, because either their standard error is larger than
<code>threshold</code>, or they were fixed.</p>
</td></tr>
<tr><td><code id="funnelPlot_+3A_...">...</code></td>
<td>
<p>For extra arguments (passed to <code>plot</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>funnelPlot</code> plots estimates against standard
errors for a given effect <code>k</code>, with red
reference lines added at the two-sided
significance threshold 0.05. Effects for which a score test
was requested are not plotted (and reported to the console
if <code>verbose</code>).<br />
If not all effects with number <code>k</code> are the same
in all <code>sienaFit</code> objects, a warning is given.
The effect name for the first object is used as the plot title.<br />
Another funnel plot is available as <code><a href="#topic+print.sienaMeta">print.sienaMeta</a></code>.
</p>


<h3>Value</h3>

<p>The two-column matrix of
values of the plotted points is invisibly returned.<br />
</p>


<h3>Author(s)</h3>

<p>Tom Snijders
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena08">siena08</a></code>, <code><a href="#topic+print.sienaMeta">print.sienaMeta</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># A meta-analysis for three groups does not make much sense.
# But using three groups shows the idea.

Group1 &lt;- sienaDependent(array(c(N3401, HN3401), dim=c(45, 45, 2)))
Group3 &lt;- sienaDependent(array(c(N3403, HN3403), dim=c(37, 37, 2)))
Group4 &lt;- sienaDependent(array(c(N3404, HN3404), dim=c(33, 33, 2)))
dataset.1 &lt;- sienaDataCreate(Friends = Group1)
dataset.3 &lt;- sienaDataCreate(Friends = Group3)
dataset.4 &lt;- sienaDataCreate(Friends = Group4)
OneAlgorithm &lt;- sienaAlgorithmCreate(projname = NULL, nsub=1, n3=50, seed=123)
effects.1 &lt;- getEffects(dataset.1)
effects.3 &lt;- getEffects(dataset.3)
effects.4 &lt;- getEffects(dataset.4)
ans.1 &lt;- siena07(OneAlgorithm, data=dataset.1, effects=effects.1, batch=TRUE)
ans.3 &lt;- siena07(OneAlgorithm, data=dataset.3, effects=effects.3, batch=TRUE)
ans.4 &lt;- siena07(OneAlgorithm, data=dataset.4, effects=effects.4, batch=TRUE)
funnelPlot(list(ans.1, ans.3, ans.4), k=2)
funnelPlot(list(ans.1, ans.3, ans.4), k=2, origin=FALSE)
</code></pre>

<hr>
<h2 id='getEffects'>Function to create a Siena effects object</h2><span id='topic+getEffects'></span><span id='topic+sienaEffects'></span><span id='topic+sienaGroupEffects'></span>

<h3>Description</h3>

<p>Creates a basic list of effects for all dependent  
variables in the input siena object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEffects(x, nintn = 10, behNintn=4, getDocumentation=FALSE, onePeriodSde=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEffects_+3A_x">x</code></td>
<td>
<p>an object of class 'siena&quot; or 'sienaGroup&quot;</p>
</td></tr>
<tr><td><code id="getEffects_+3A_nintn">nintn</code></td>
<td>
<p>Number of user-defined network interactions
that can later be created.</p>
</td></tr>
<tr><td><code id="getEffects_+3A_behnintn">behNintn</code></td>
<td>
<p>Number of user-defined behavior interactions
that can later be created.</p>
</td></tr>
<tr><td><code id="getEffects_+3A_getdocumentation">getDocumentation</code></td>
<td>
<p>Flag to allow documentation of internal
functions, not for use by users.</p>
</td></tr>
<tr><td><code id="getEffects_+3A_oneperiodsde">onePeriodSde</code></td>
<td>
<p>Flag to indicate that the stochastic
differential equation (SDE) model dZ(t) = [aZ(t) + b] dt + g dW(t)
should be used, instead of the regular SDE with a scale parameter.
This is only relevant in case the model includes a continuous
dependent variable and one period is studied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a data frame of effects for use in siena model estimation.
The regular way of changing this object is by the functions 
<code><a href="#topic+includeEffects">includeEffects</a></code>, <code><a href="#topic+setEffect">setEffect</a></code>,
and <code><a href="#topic+includeInteraction">includeInteraction</a></code>.
</p>
<p>Note that the class of the return object may be lost if the data.frame
is edited using <code>fix</code>.
See <code><a href="utils.html#topic+fix">fix</a></code> and <code><a href="utils.html#topic+edit.data.frame">edit.data.frame</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>sienaEffects</code> or <code>sienaGroupEffects</code>:
this is a data frame of which the rows are the effects available
for data set <code>x</code>.<br />
The effects object consists of consecutive parts, each of which relates
to one dependent variable in the input object.
The columns are:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>name of the dependent variable</p>
</td></tr>
<tr><td><code>effectName</code></td>
<td>
<p>name of the effect</p>
</td></tr>
<tr><td><code>functionName</code></td>
<td>
<p>name of the function</p>
</td></tr>
<tr><td><code>shortName</code></td>
<td>
<p>short name for the effect</p>
</td></tr>
<tr><td><code>interaction1</code></td>
<td>
<p>second variable to define the effect, if any</p>
</td></tr>
<tr><td><code>interaction2</code></td>
<td>
<p>third variable to define the effect, if any</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>&quot;eval&quot;, &quot;endow&quot;, &quot;creation&quot;, &quot;rate&quot;, or &quot;gmm&quot;</p>
</td></tr>
<tr><td><code>basicRate</code></td>
<td>
<p>boolean: whether a basic rate parameter</p>
</td></tr>
<tr><td><code>include</code></td>
<td>
<p>boolean: include in the model to be fitted or not</p>
</td></tr>
<tr><td><code>randomEffects</code></td>
<td>
<p>boolean: random or fixed effect. Currently not used.</p>
</td></tr>
<tr><td><code>fix</code></td>
<td>
<p>boolean: fix parameter value or not</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>boolean: test parameter value or not</p>
</td></tr>
<tr><td><code>timeDummy</code></td>
<td>
<p>comma separated list of periods, or &quot;all&quot;,
or &quot;,&quot; for none &ndash;
which time dummy interacted parameters should be included?</p>
</td></tr>
<tr><td><code>initialValue</code></td>
<td>
<p>starting value for estimation, also used for
<code>fix</code> and <code>test</code>.</p>
</td></tr>
<tr><td><code>parm</code></td>
<td>
<p>internal effect parameter values</p>
</td></tr>
<tr><td><code>functionType</code></td>
<td>
<p>&quot;objective&quot; or &quot;rate&quot;</p>
</td></tr>
<tr><td><code>period</code></td>
<td>
<p>period for basic rate parameters</p>
</td></tr>
<tr><td><code>rateType</code></td>
<td>
<p>&quot;Structural&quot;, &quot;covariate&quot;, &quot;diffusion&quot;</p>
</td></tr>
<tr><td><code>untrimmedValue</code></td>
<td>
<p>Used to store initial values which could be
trimmed</p>
</td></tr>
<tr><td><code>effect1</code></td>
<td>
<p>Used to indicate effect number in user-specified interactions</p>
</td></tr>
<tr><td><code>effect2</code></td>
<td>
<p>Used to indicate effect number in user-specified interactions</p>
</td></tr>
<tr><td><code>effect3</code></td>
<td>
<p>Used to indicate effect number in user-specified interactions</p>
</td></tr>
<tr><td><code>interactionType</code></td>
<td>
<p>Defines &quot;dyadic&quot; or &quot;ego&quot; or &quot;OK&quot; effects, used in
<code><a href="#topic+includeInteraction">includeInteraction</a></code></p>
</td></tr>
<tr><td><code>local</code></td>
<td>
<p>whether a local effect; used for the option <code>localML</code>
in <code><a href="#topic+sienaAlgorithmCreate">sienaAlgorithmCreate</a></code></p>
</td></tr>
<tr><td><code>effectFn</code></td>
<td>
<p>here NULL, but could be replaced by a function later</p>
</td></tr>
<tr><td><code>statisticFn</code></td>
<td>
<p>here NULL, but could be replaced by a function
later</p>
</td></tr>
<tr><td><code>netType</code></td>
<td>
<p>Type of dependent variable:
&quot;oneMode&quot;, &quot;behavior&quot;, or &quot;bipartite&quot;</p>
</td></tr>
<tr><td><code>groupName</code></td>
<td>
<p>name of relevant group data object</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>sequential number of relevant group data object in total</p>
</td></tr>
<tr><td><code>effectNumber</code></td>
<td>
<p>a unique identifier of the row</p>
</td></tr>
</table>
<p>The combination of <code>name</code>, <code>shortName</code>, <code>interaction1</code>,
<code>interaction2</code>, and <code>type</code> uniquely identifies any effect
other than basic rate effects and user-specified interaction effects.
For the latter, <code>effect1</code>, <code>effect2</code> and <code>effect3</code>
are also required for the identification. The combination <code>name</code>,
<code>shortName</code>, <code>period</code> and <code>group</code> uniquely identifies a
basic rate effect.
</p>
<p>The columns not used for identifying the effect define how the effect is used
for the estimation.
</p>
<p>The columns <code>initialValue</code> and <code>parm</code> should not be confused:
<code>initialValue</code> gives the initial value for the parameter to be estimated,
indicated in the manual by <code>theta</code>;
<code>parm</code> gives the internal value of the parameter defining the effect,
indicated in the manual (Chapter 12) by <code>p</code>, and is fixed
during the estimation.
</p>
<p>A list of all effects in a given effects object (e.g., <code>myeff</code>),
including their names of dependent variables, effect names, short names,
and values of interaction1 and interaction2 (if any),
is obtained by executing <code><a href="#topic+effectsDocumentation">effectsDocumentation</a>(myeff)</code>.  
</p>
<p>As from version 1.3.24, effects object have a &quot;version&quot; attribute.
Effects objects including interaction effects created by 
<code><a href="#topic+includeInteraction">includeInteraction</a></code> are not necessarily compatible
between versions of <code>RSiena</code>. Therefore it is recommended,
for effects objects including any interaction effects,
to create them again when changing to a new version of <code>RSiena</code>.
If an effects object including any interaction effects is used from an
old version of <code>RSiena</code>, this will lead to a warning when running
<code><a href="#topic+siena07">siena07</a></code>. <br />
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+sienaGroupCreate">sienaGroupCreate</a></code>,
<code><a href="#topic+includeEffects">includeEffects</a></code>, <code><a href="#topic+setEffect">setEffect</a></code>,
<code><a href="#topic+includeGMoMStatistics">includeGMoMStatistics</a></code>,
<code><a href="#topic+updateSpecification">updateSpecification</a></code>,
<code><a href="#topic+print.sienaEffects">print.sienaEffects</a></code>,<code><a href="#topic+effectsDocumentation">effectsDocumentation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mycovar &lt;- coCovar(rnorm(50))
mydyadcovar &lt;- coDyadCovar(matrix(as.numeric(rnorm(2500) &gt; 2), nrow=50))
mydata &lt;- sienaDataCreate(mynet1, mybeh, mycovar, mydyadcovar)
myeff &lt;- getEffects(mydata)
myeff
</code></pre>

<hr>
<h2 id='hn3401'>Network data: excerpt from &quot;Dutch Social Behavior Data Set&quot;
of Chris Baerveldt.
</h2><span id='topic+hn3401'></span><span id='topic+HN3401'></span><span id='topic+HN3403'></span><span id='topic+HN3404'></span><span id='topic+HN3406'></span>

<h3>Description</h3>

<p>Matrices N3401, N3403, N3404, N3406, and HN3401, HN3403, HN3404,  
HN3406 are two waves of networks for four schools 
(numbered 1, 3, 4, 6).    
</p>


<h3>Format</h3>

<p>Adjacency matrices for the network at two time points.
The matrices with name N... are the first wave,
those with name HN... are the second wave.
</p>
<p>There is a tie from pupil i to pupil j if i says that he/she   
receives and/or gives emotional support from/to pupil j.  
The data are part of a larger data set (see source below)  
and were collected under the direction of Chris Baerveldt.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/CB_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/CB_data.zip</a>
</p>


<h3>References</h3>

<p>Houtzager, B. and Baerveldt, C. (1999), Just like Normal.
A Social Network Study of the Relation between Petty Crime
and the Intimacy of Adolescent Friendships.
<em>Social Behavior and Personality</em> <b>27</b>, 177&ndash;192.
</p>
<p>Snijders, T.A.B., and Baerveldt, C. (2003),
A Multilevel Network Study of the Effects of Delinquent Behavior
on Friendship Evolution.
<em>Journal of Mathematical Sociology</em> <b>27</b>, 123&ndash;151.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/BaerveldtData.html">https://www.stats.ox.ac.uk/~snijders/siena/BaerveldtData.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(N3401, HN3401), dim=c(45, 45, 2)))
mydata &lt;- sienaDataCreate(mynet)
</code></pre>

<hr>
<h2 id='includeEffects'>
Function to include effects in a Siena model
</h2><span id='topic+includeEffects'></span>

<h3>Description</h3>

<p>This function can be used for model specification  
by modifying a Siena effects object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>includeEffects(myeff, ..., include = TRUE, name = myeff$name[1], type = "eval",
 interaction1 = "", interaction2 = "", fix=FALSE, test=FALSE, character=FALSE,
 verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="includeEffects_+3A_myeff">myeff</code></td>
<td>
<p>a Siena effects object as created by <code><a href="#topic+getEffects">getEffects</a></code>
</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_...">...</code></td>
<td>

<p>short names to identify the effects which should be included or excluded.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_include">include</code></td>
<td>
<p>Boolean. default TRUE, but can be switched to FALSE to
turn off an effect.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_name">name</code></td>
<td>
<p>Name of dependent variable (network or behavior) for which effects
are being included. Defaults to the first in the effects object.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_type">type</code></td>
<td>

<p>Type of effects to be included: &quot;eval&quot;, &quot;endow&quot;, &quot;creation&quot;, or &quot;rate&quot;.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_interaction1">interaction1</code></td>
<td>

<p>Name of siena object where needed to completely identify the
effects e.g. covariate name or behavior variable name.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_interaction2">interaction2</code></td>
<td>

<p>Name of siena object where needed to completely identify the
effects e.g. covariate name or behavior variable name.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_fix">fix</code></td>
<td>

<p>Boolean. Are the effects to be fixed at the value stored in
<code>myeff$initialValue</code> or not.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_test">test</code></td>
<td>

<p>Boolean. Are the effects to be tested or not (requires <code>fix</code>).</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_character">character</code></td>
<td>
<p>Boolean: are the effect names character strings or not.</p>
</td></tr>
<tr><td><code id="includeEffects_+3A_verbose">verbose</code></td>
<td>
<p>Boolean: should the print of altered effects be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recall from the help page for <code><a href="#topic+getEffects">getEffects</a></code>
that a Siena effects object (class <code>sienaEffects</code> or
<code>sienaGroupEffects</code>) is a <code><a href="base.html#topic+data.frame">data.frame</a></code>;
the rows in the data frame are the effects for this data set;
some of the columns/variables of the data frame
are used to identify the effect, other columns/variables define how this
effect is used in the estimation. <br />   
</p>
<p>The function <code>includeEffects</code> operates as an interface
setting the &quot;include&quot; column on selected rows of the effects object,
to the value requested (<code>TRUE</code> or <code>FALSE</code>).
The selected effects must be indicated by the arguments ..., <code>type</code>,
and (if necessary) <code>interaction1</code> and <code>interaction2</code>.
The names <code>interaction1</code> and <code>interaction2</code> do not refer
to interactions between effects, but to dependence of effects on
other variables in the data set.
The arguments should identify the effects completely.<br />
The short names must not be set between quotes,
unless you use <code>character=TRUE</code>.
</p>
<p>Note that the internal effect parameter has a default value which differs
between effects. This can be set by function <code><a href="#topic+setEffect">setEffect</a></code>.
Also the value of <code>myeff$initialValue</code> can be set by this function.
The function <code><a href="#topic+setEffect">setEffect</a></code> operates on the effects object
in a more detailed way, but applies to one effect at the time.
</p>
<p>Further information about Siena effects objects is given
in the help page for <code><a href="#topic+getEffects">getEffects</a></code>.
</p>
<p>A list of all effects available in a given effects object (e.g.,
<code>myeff</code>), including their names of dependent variables,
effect names, short names,
and values of <code>interaction1</code> and <code>interaction2</code> (if any),
is obtained by executing <code><a href="#topic+effectsDocumentation">effectsDocumentation</a>(myeff)</code>.
</p>
<p>The input names <code>interaction1</code> and <code>interaction2</code> do not themselves
refer to created interactions, but to dependence of the base effects on
other variables in the data set.
They are used to completely identify the effects.
</p>


<h3>Value</h3>

<p>An updated version of the input effects object, with the
<code>include</code>, <code>test</code>, and <code>fix</code>
columns for one or more rows updated.
Details of the rows altered will be printed.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley </p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getEffects">getEffects</a></code>, <code><a href="#topic+setEffect">setEffect</a></code>,
<code><a href="#topic+includeInteraction">includeInteraction</a></code>,
<code><a href="#topic+includeGMoMStatistics">includeGMoMStatistics</a></code>,
<code><a href="#topic+updateSpecification">updateSpecification</a></code>,
<code><a href="#topic+print.sienaEffects">print.sienaEffects</a></code>, <code><a href="#topic+effectsDocumentation">effectsDocumentation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh  &lt;- sienaDependent(s50a, type="behavior")
mydata &lt;- sienaDataCreate(mynet1, mybeh)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip, balance)
myeff &lt;- includeEffects(myeff, avAlt, name="mybeh", interaction1="mynet1")
myeff
</code></pre>

<hr>
<h2 id='includeGMoMStatistics'>
Function to include GMoM statistics in a Siena model
</h2><span id='topic+includeGMoMStatistics'></span>

<h3>Description</h3>

<p>This function can be used for including one or more GMoM statistics   
by modifying a Siena effects object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  includeGMoMStatistics(myeff, ..., include=TRUE, name=myeff$name[1],
                        interaction1="", interaction2="",
                        character=FALSE, verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="includeGMoMStatistics_+3A_myeff">myeff</code></td>
<td>
<p>a Siena effects object as created by <code><a href="#topic+getEffects">getEffects</a></code>
</p>
</td></tr>
<tr><td><code id="includeGMoMStatistics_+3A_...">...</code></td>
<td>

<p>short names to identify the GMoM statistics which should be included or
excluded.</p>
</td></tr>
<tr><td><code id="includeGMoMStatistics_+3A_include">include</code></td>
<td>
<p>Boolean; default TRUE, but can be switched to FALSE to
turn off an effect.</p>
</td></tr>
<tr><td><code id="includeGMoMStatistics_+3A_name">name</code></td>
<td>
<p>Name of dependent variable (network or behavior) for which
statistics are being included. Defaults to the first in the effects object.</p>
</td></tr>
<tr><td><code id="includeGMoMStatistics_+3A_interaction1">interaction1</code></td>
<td>

<p>Name of siena object where needed to completely identify the
effects e.g. covariate name or behavior variable name.</p>
</td></tr>
<tr><td><code id="includeGMoMStatistics_+3A_interaction2">interaction2</code></td>
<td>

<p>Name of siena object where needed to completely identify the
effects e.g. covariate name or behavior variable name.</p>
</td></tr>
<tr><td><code id="includeGMoMStatistics_+3A_character">character</code></td>
<td>
<p>Boolean: are the statistic names character strings or not.</p>
</td></tr>
<tr><td><code id="includeGMoMStatistics_+3A_verbose">verbose</code></td>
<td>
<p>Boolean: should the print of altered statistic be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names <code>interaction1</code> and <code>interaction2</code> refer to
the dependence of the GMoM statistics on other variables in the data set.
The arguments should identify the GMoM statistic completely.
The type does not have to be specified, as it is <code>gmm</code> for all
GMoM statistiscs in the effects object. <br />
The short names must not be set between quotes,
unless you use <code>character=TRUE</code>.
</p>
<p>The function <code>includeGMoMStatistics</code> operates as an interface
setting the &quot;include&quot; column on selected rows of the effects object,
to the value requested (<code>TRUE</code> or <code>FALSE</code>).
</p>


<h3>Value</h3>

<p>An updated version of the input effects object, with the <code>include</code>
column for one or more rows updated.
Details of the rows altered will be printed.
</p>


<h3>Author(s)</h3>

<p>Viviana Amati.
</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getEffects">getEffects</a></code>,
<code><a href="#topic+includeEffects">includeEffects</a></code>,
<code><a href="#topic+setEffect">setEffect</a></code>,
<code><a href="#topic+includeInteraction">includeInteraction</a></code>,
<code><a href="#topic+print.sienaEffects">print.sienaEffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
  mybeh  &lt;- sienaDependent(s50a, type="behavior")
  mydata &lt;- sienaDataCreate(mynet1, mybeh)
  myeff &lt;- getEffects(mydata)
  myeff &lt;- includeGMoMStatistics(myeff, egoX_gmm, interaction1="mybeh")
  myeff
</code></pre>

<hr>
<h2 id='includeInteraction'>
Function to create user-specified interactions for a Siena model.
</h2><span id='topic+includeInteraction'></span>

<h3>Description</h3>

<p>This function allows the user to include or exclude   
an interaction effect in a Siena effects object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>includeInteraction(myeff, ..., include = TRUE, name = myeff$name[1],
    type = "eval", interaction1 = rep("", 3), interaction2 = rep("", 3),
    fix=FALSE, test=FALSE, random=FALSE,
    initialValue=0,
    character = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="includeInteraction_+3A_myeff">myeff</code></td>
<td>
<p>a Siena effects object as created by <code><a href="#topic+getEffects">getEffects</a></code></p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_...">...</code></td>
<td>
<p>2 or 3 short names to identify the effects
which should be interacted.</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_include">include</code></td>
<td>
<p>Boolean. default TRUE, but can be switched to FALSE to
turn off an interaction.
</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_name">name</code></td>
<td>
<p>Name of dependent variable (network or behavior)
for which interactions are being defined.
Defaults to the first in the effects object.
</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_type">type</code></td>
<td>

<p>Type of effects to be interacted.
</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_interaction1">interaction1</code></td>
<td>

<p>Vector of Siena objects where needed to completely identify the
effect e.g. covariate name or behavior variable name.
Trailing blanks may be omitted.
</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_interaction2">interaction2</code></td>
<td>

<p>Vector of siena objects where needed to completely identify the
effect e.g. covariate name or behavior variable name.
Trailing blanks may be omitted.
</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_fix">fix</code></td>
<td>

<p>Boolean. Are the effects to be fixed at the value stored in
<code>myeff$initialValue</code> or not.</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_test">test</code></td>
<td>

<p>Boolean. Are the effects to be tested or not (requires <code>fix</code>).</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_random">random</code></td>
<td>
<p>For specifying that the interaction effect will vary randomly;
not relevant for <code>RSiena</code> at this moment.
Boolean required. Default FALSE.</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_initialvalue">initialValue</code></td>
<td>
<p>Initial value for estimation. Default 0.</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_character">character</code></td>
<td>
<p>Boolean: are the effect names character strings or not.</p>
</td></tr>
<tr><td><code id="includeInteraction_+3A_verbose">verbose</code></td>
<td>
<p>Boolean: should the print of altered effects be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details provided should uniquely identify up to three
effects. If so, an interaction effect will be created and included or
not in the model. <br />
Whether interactions between two or three given effects
can be created depends on their <code>interactionType</code> (which can be, for
dependent network variables, empty, ego, or dyadic; and for dependent
behavioral variables, empty or OK). Consult the section on Interaction
Effects in the manual for this. The <code>interactionType</code> is shown
in the list of effects obtained from the function
<code><a href="#topic+effectsDocumentation">effectsDocumentation</a></code>.<br />
The short names must not be set between quotes,
unless you use <code>character=TRUE</code>.<br />
From the point of view of model building it is usually advisable, when
including an interaction effect in a model, also to include the
corresponding main effects. This is however not enforced
by <code>includeInteraction()</code>.<br />
</p>
<p>As from version 1.3.24, effects object have a &quot;version&quot; attribute.
Effects objects including interaction effects are not necessarily compatible
between versions of <code>RSiena</code>. Therefore it is recommended to create
such effects objects again when changing to a new version of <code>RSiena</code>.
If an effects object including any interaction effects is used from an
old version of <code>RSiena</code>, this will lead to a warning when running
<code><a href="#topic+siena07">siena07</a></code>. <br />
</p>
<p>An interaction effect does not have its own internal effect parameter.
The internal effect parameters of the interacting main effects are used,
whether or not these are included in the model. This implies that if an
interaction effect is included but not the corresponding main effects,
or not all of them, then nevertheless the internal effect parameters as
specified in the effects object are used for the interaction.
These can be set using function <code>setEffect</code> with the desired value
of <code>parameter</code> and (in this case) <code>include=FALSE</code>. <br />
The values of the internal effect parameters can be checked for a
<code><a href="#topic+sienaFit">sienaFit</a></code> object <code>ans</code> produced by <code><a href="#topic+siena07">siena07</a></code>
by looking at <code>ans$effects</code>, which is the requested effects object
to which the main effects of the user-defined interactions were added,
if they were not yet included.
</p>
<p>Interaction effects are constructed from effects with shortName
<code>unspInt</code> (for networks) and <code>behUnspInt</code> (for behavior)
by specifying their elements <code>effect1</code> and <code>effect2</code>,
and possibly <code>effect3</code>. The shortName is not altered by this function.
</p>
<p>The number of possible user-specified interaction effects is limited
by the parameters <code>nintn</code> (for dependent network variables)
and <code>behNintn</code> (for dependent behavior variables)
in the call of <code><a href="#topic+getEffects">getEffects</a></code>, which determine the numbers of
effects with shortNames <code>unspInt</code> and <code>behUnspInt</code>.
</p>
<p>The input names <code>interaction1</code> and <code>interaction2</code> do not themselves
refer to created interactions, but to dependence of the base effects on
other variables in the data set.
They are used to completely identify the effects.
</p>
<p>Further information about Siena effects objects is given
in the help page for <code><a href="#topic+getEffects">getEffects</a></code>.
</p>
<p>A list of all effects in a given effects object (e.g., <code>myeff</code>),
including their names of dependent variables, effect names, short names,
and values of interaction1 and interaction2 (if any),
is obtained by executing <code><a href="#topic+effectsDocumentation">effectsDocumentation</a>(myeff)</code>.
</p>


<h3>Value</h3>

<p>An updated version of the input effects object; if <code>include</code>,
containing the interaction effect between &quot;effect1&quot; and &quot;effect2&quot; and
possibly &quot;effect3&quot;; if not, without this interaction effect.
The shortName of the interaction effect is &quot;unspInt&quot; for network effects
and &quot;behUnspInt&quot; for behavior effects. <br />
If <code>verbose=TRUE</code>, details of the fields altered will be printed.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley, Tom Snijders</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getEffects">getEffects</a></code>, <code><a href="#topic+setEffect">setEffect</a></code>,
<code><a href="#topic+includeEffects">includeEffects</a></code>, <code><a href="#topic+effectsDocumentation">effectsDocumentation</a>
</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
alc &lt;- varCovar(s50a)
mydata &lt;- sienaDataCreate(mynet, alc)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip)
myeff &lt;- includeInteraction(myeff, recip, inPop)
myeff &lt;- includeEffects(myeff, egoX, altX, simX, interaction1="alc")
myeff &lt;- includeInteraction(myeff, recip, simX, interaction1=c("", "alc"))
myeff
</code></pre>

<hr>
<h2 id='includeTimeDummy'>Function to include time dummy effects in a Siena model</h2><span id='topic+includeTimeDummy'></span>

<h3>Description</h3>

<p>This function specifies time heterogeneity for selected effects   
in a Siena model, by interacting them with time dummies,   
without explicitly using time-dependent covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>includeTimeDummy(myeff, ..., timeDummy="all", name=myeff$name[1], type="eval",
              interaction1="", interaction2="", include=TRUE, character=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="includeTimeDummy_+3A_myeff">myeff</code></td>
<td>
<p>A Siena effects object as created by <code><a href="#topic+getEffects">getEffects</a></code>.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_...">...</code></td>
<td>

<p>Short names to identify the effects for which interactions with time dummies
should be included or excluded.
This function cannot be used for regular interaction effects.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_timedummy">timeDummy</code></td>
<td>
<p>Character string. Either &quot;all&quot; or the periods for which
to create dummies (from 1 to (number of waves - 1)), space delimited.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_include">include</code></td>
<td>
<p>Boolean. default TRUE, but can be switched to FALSE to
turn off an effect.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_name">name</code></td>
<td>
<p>Name of dependent network or behavioral variable for which
effects are being included. Defaults to the first in the effects object.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_type">type</code></td>
<td>
<p>Type of dummy effects to be interacted.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_interaction1">interaction1</code></td>
<td>

<p>Name of variable where needed to completely identify the
effects e.g. covariate name or behavior variable name.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_interaction2">interaction2</code></td>
<td>

<p>Name of variable where needed to completely identify the
effects e.g. covariate name or behavior variable name.</p>
</td></tr>
<tr><td><code id="includeTimeDummy_+3A_character">character</code></td>
<td>
<p>Boolean: are the effect names character strings or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments (..., <code>name, interaction1, interaction2</code>)
should identify the effects completely.
See <code><a href="#topic+includeEffects">includeEffects</a></code> and <code><a href="#topic+effectsDocumentation">effectsDocumentation</a></code>
for more information about this.
</p>
<p>This function operates by setting the <code>timeDummy</code> column
on selected rows of a Siena effects object, thereby specifying
interactions of the specified effect or effects with dummy variables
for the specified periods.
The <code>timeDummy</code> column of <code>myeff</code> will be set to include the
values requested if <code>include=TRUE</code>, and to exclude them for
<code>include=FALSE</code>.
</p>
<p>For an effects object in which the <code>timeDummy</code> column
of some of the included effects includes some or all period numbers,
interactions of those effects with ego effects of time dummies for the
indicated periods will also be estimated by <code><a href="#topic+siena07">siena07</a></code>.
For the outdegree effect this is just the ego effect of the time dummies.
If ... does not include the outdegree effect, then still this
ego effect will be created, but its parameter will be fixed to 0.
</p>
<p>An alternative to the use of <code><a href="#topic+includeTimeDummy">includeTimeDummy</a></code>
is to define time-dependent actor covariates (dummy variables or other
functions of wave number that are the same for all actors),
include these in the data set through <code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>,
and include interactions of other effects with ego effects of these
time-dependent actor covariates by <code><a href="#topic+includeInteraction">includeInteraction</a></code>.
This is illustrated in an example in the help file for
<code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code>.
Using <code><a href="#topic+includeTimeDummy">includeTimeDummy</a></code> is easier; on the other hand,
using self-defined interactions with time-dependent variables
gives more control (e.g., it will allow to specify linear time dependence
and test time heterogeneity for interaction effects).
</p>


<h3>Value</h3>

<p>An updated version of <code>myeff</code>, with the <code>timeDummy</code>
column for one or more rows updated.
Details of the rows altered will be printed.
</p>


<h3>Author(s)</h3>

<p>Josh Lospinoso</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
for general information on RSiena.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code>, <code><a href="#topic+getEffects">getEffects</a></code>,
<code><a href="#topic+includeEffects">includeEffects</a></code>, <code><a href="#topic+effectsDocumentation">effectsDocumentation</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Estimate a restricted model
myalgorithm &lt;- sienaAlgorithmCreate(nsub=4, n3=1000)
mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip, balance)
myeff
(ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff))

## Conduct the score type test to assess whether heterogeneity is present.
tt &lt;- sienaTimeTest(ans)
summary(tt)

## Suppose that we wish to include a time dummy.
## Since there are three waves, the number of periods is two.
## This means that only one time dummy can be included for
## the interactions. The default is for period 2;
## an equivalent model, but with different parameters
## (that can be transformed into each other) is obtained
## when the dummies are defined for period 1.
myeff &lt;- includeTimeDummy(myeff, density, recip, timeDummy="2")
myeff       # Note the \code{timeDummy} column.
(ans2 &lt;- siena07(myalgorithm, data=mydata, effects=myeff))

## Re-assess the time heterogeneity
tt2 &lt;- sienaTimeTest(ans2)
summary(tt2)

## And so on..

## End(Not run)

## A demonstration of RateX heterogeneity.
## Note that rate interactions are not implemented in general,
## but they are for Rate x coCovar.
## Not run: 
myalgorithm &lt;- sienaAlgorithmCreate(nsub=4, n3=1000)
mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
myccov &lt;- coCovar(s50a[,1])
mydata &lt;- sienaDataCreate(mynet1, myccov)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip, balance)
myeff &lt;- includeTimeDummy(myeff, RateX, type="rate",
            interaction1="myccov")
myeff
(ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff))

## End(Not run)
</code></pre>

<hr>
<h2 id='iwlsm'>
Function to fit an iterated weighted least squares model.
</h2><span id='topic+iwlsm'></span><span id='topic+iwlsm.default'></span><span id='topic+iwlsm.formula'></span><span id='topic+print.iwlsm'></span><span id='topic+predict.iwlsm'></span><span id='topic+psi.iwlsm'></span>

<h3>Description</h3>

<p>Fits an iterated weighted least squares model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iwlsm(x, ...)

## S3 method for class 'formula'
iwlsm(formula, data, weights, ses, ..., subset, na.action,
    method = c("M", "MM", "model.frame"),
    wt.method = c("inv.var", "case"),
    model = TRUE, x.ret = TRUE, y.ret = FALSE, contrasts = NULL)

## Default S3 method:
iwlsm(x, y, weights, ses, ..., w = rep(1/nrow(x), nrow(x)),
    init = "ls", psi = psi.iwlsm,
    scale.est = c("MAD", "Huber", "proposal 2"), k2 = 1.345,
    method = c("M", "MM"), wt.method = c("inv.var", "case"),
    maxit = 20, acc = 1e-4, test.vec = "resid", lqs.control = NULL)

psi.iwlsm(u, k, deriv = 0, w, sj2, hh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iwlsm_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x1 + x2 + ...</code>.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_data">data</code></td>
<td>

<p>data frame from which variables specified in <code>formula</code> are
preferentially to be taken.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_weights">weights</code></td>
<td>

<p>a vector of prior weights for each case.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_subset">subset</code></td>
<td>

<p>An index vector specifying the cases to be used in fitting.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_ses">ses</code></td>
<td>
<p>Estimated variance of the responses. Will be paseed to
<code>psi</code> as sj2
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_na.action">na.action</code></td>
<td>

<p>A function to specify the action to be taken if <code>NA</code>s are found.
The &lsquo;factory-fresh&rsquo; default action in <span class="rlang"><b>R</b></span> is
<code><a href="stats.html#topic+na.omit">na.omit</a></code>, and can be changed by
<code><a href="base.html#topic+options">options</a>(na.action=)</code>.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_x">x</code></td>
<td>

<p>a matrix or data frame containing the explanatory variables.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_y">y</code></td>
<td>

<p>the response: a vector of length the number of rows of <code>x</code>.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_method">method</code></td>
<td>
<p>Must be &quot;M&quot;. (argument not used here).
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_wt.method">wt.method</code></td>
<td>

<p>are the weights case weights (giving the relative importance of case,
so a weight of 2 means there are two of these) or the inverse of the
variances, so a weight of two means this error is half as variable?
This will not work at present.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_model">model</code></td>
<td>

<p>should the model frame be returned in the object?
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_x.ret">x.ret</code></td>
<td>

<p>should the model matrix be returned in the object?
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_y.ret">y.ret</code></td>
<td>

<p>should the response be returned in the object?
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_contrasts">contrasts</code></td>
<td>

<p>optional contrast specifications: se <code><a href="stats.html#topic+lm">lm</a></code>.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_w">w</code></td>
<td>

<p>(optional) initial down-weighting for each case. Will not work at present.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_init">init</code></td>
<td>

<p>(optional) initial values for the coefficients OR a method to find
initial values OR the result of a fit with a <code>coef</code> component.  Known
methods are <code>"ls"</code> (the default) for an initial least-squares fit
using weights <code>w*weights</code>, and <code>"lts"</code> for an unweighted
least-trimmed squares fit with 200 samples. Probably not functioning.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_psi">psi</code></td>
<td>

<p>the psi function is specified by this argument.  It must give
(possibly by name) a function <code>g(x, ..., deriv, w)</code> that for
<code>deriv=0</code> returns psi(x)/x and for <code>deriv=1</code> returns
some value.  Extra arguments may be passed in via <code>...</code>.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_scale.est">scale.est</code></td>
<td>

<p>method of scale estimation: re-scaled MAD of the residuals (default)
or Huber&quot;s proposal 2 (which can be selected by either <code>"Huber"</code>
or <code>"proposal 2"</code>).
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_k2">k2</code></td>
<td>

<p>tuning constant used for Huber proposal 2 scale estimation.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_maxit">maxit</code></td>
<td>

<p>the limit on the number of IWLS iterations.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_acc">acc</code></td>
<td>

<p>the accuracy for the stopping criterion.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_test.vec">test.vec</code></td>
<td>

<p>the stopping criterion is based on changes in this vector.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <code>iwlsm.default</code> or to the <code>psi</code>
function.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_lqs.control">lqs.control</code></td>
<td>

<p>An optional list of control values for <code><a href="MASS.html#topic+lqs">lqs</a></code>.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_u">u</code></td>
<td>

<p>numeric vector of evaluation points.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_k">k</code></td>
<td>
<p>    tuning constant. Not used.
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_deriv">deriv</code></td>
<td>

<p><code>0</code> or <code>1</code>: compute values of the psi function or of its
first derivative. (Latter not used).
</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_sj2">sj2</code></td>
<td>
<p>Estimated variance of the responses</p>
</td></tr>
<tr><td><code id="iwlsm_+3A_hh">hh</code></td>
<td>
<p>Diagonal values of the hat matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very slightly adapted from <code>rlm</code> in
packages <code>MASS</code>. It alternates between weighted
least squares and estimation of variance on the basis of a common
variance. The function <code>psi.iwlsm</code> calculates the weights
for the next iteration. Used by <code>siena08</code> to combine estimates
from different <code>sienaFits</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"iwlsm"</code> inheriting from <code>"lm"</code>.
Note that the <code>df.residual</code> component is deliberately set to
<code>NA</code> to avoid inappropriate estimation of the residual scale from
the residual mean square by <code>"lm"</code> methods.
</p>
<p>The additional components not in an <code>lm</code> object are
</p>
<table>
<tr><td><code>s</code></td>
<td>

<p>the robust scale estimate used
</p>
</td></tr>
<tr><td><code>w</code></td>
<td>

<p>the weights used in the IWLS process
</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>

<p>the psi function with parameters substituted
</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>

<p>the convergence criteria at each iteration
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>did the IWLS converge?
</p>
</td></tr>
<tr><td><code>wresid</code></td>
<td>

<p>a working residual, weighted for <code>"inv.var"</code> weights only.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function has been changed as little as possible, but
has only been used with default arguments. The other options have
been retained just in
case they may prove useful.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S.</em>  Fourth edition.  Springer.
See also <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena08">siena08</a></code>, <code><a href="#topic+sienaMeta">sienaMeta</a></code>, <code><a href="#topic+sienaFit">sienaFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##not enough data here for a sensible example, but shows the idea.
myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=100)
mynet1 &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mynet2 &lt;- sienaDependent(array(c(s502, s503), dim=c(50, 50, 2)))
mydata1 &lt;- sienaDataCreate(mynet1)
mydata2 &lt;- sienaDataCreate(mynet2)
myeff1 &lt;- getEffects(mydata1)
myeff2 &lt;- getEffects(mydata2)
myeff1 &lt;- setEffect(myeff1, transTrip, fix=TRUE, test=TRUE)
myeff2 &lt;- setEffect(myeff2, transTrip, fix=TRUE, test=TRUE)
myeff1 &lt;- setEffect(myeff1, cycle3, fix=TRUE, test=TRUE)
myeff2 &lt;- setEffect(myeff2, cycle3, fix=TRUE, test=TRUE)
ans1 &lt;- siena07(myalgorithm, data=mydata1, effects=myeff1, batch=TRUE)
ans2 &lt;- siena07(myalgorithm, data=mydata2, effects=myeff2, batch=TRUE)
meta &lt;- siena08(ans1, ans2)
metadf &lt;- split(meta$thetadf, meta$thetadf$effects)[[1]]
metalm &lt;- iwlsm(theta ~ tconv, metadf, ses=se^2)

## End(Not run)
</code></pre>

<hr>
<h2 id='n3401'>Network data: excerpt from &quot;Dutch Social Behavior Data Set&quot;
of Chris Baerveldt.
</h2><span id='topic+n3401'></span><span id='topic+N3401'></span><span id='topic+N3403'></span><span id='topic+N3404'></span><span id='topic+N3406'></span>

<h3>Description</h3>

<p>Matrices N3401, N3403, N3404, N3406, and HN3401, HN3403, HN3404,  
HN3406 are two waves of networks for four schools 
(numbered 1, 3, 4, 6).  
</p>


<h3>Format</h3>

<p>Adjacency matrices for the network at two time points.
The matrices with name N... are the first wave,
those with name HN... are the second wave.
</p>
<p>There is a tie from pupil i to pupil j if i says that he/she   
receives and/or gives emotional support from/to pupil j.  
The data are part of a larger data set (see source below)  
and were collected under the direction of Chris Baerveldt.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/CB_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/CB_data.zip</a>
</p>


<h3>References</h3>

<p>Houtzager, B. and Baerveldt, C. (1999), Just like Normal.
A Social Network Study of the Relation between Petty Crime
and the Intimacy of Adolescent Friendships.
<em>Social Behavior and Personality</em> <b>27</b>, 177&ndash;192.
</p>
<p>Snijders, Tom A.B, and Baerveldt, C. (2003),
A Multilevel Network Study of the Effects of Delinquent Behavior
on Friendship Evolution.
<em>Journal of Mathematical Sociology</em> <b>27</b>, 123&ndash;151.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/BaerveldtData.html">https://www.stats.ox.ac.uk/~snijders/siena/BaerveldtData.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(N3401, HN3401), dim=c(45, 45, 2)))
mydata &lt;- sienaDataCreate(mynet)
</code></pre>

<hr>
<h2 id='plot.sienaTimeTest'>Functions to plot assessment of time heterogeneity of parameters</h2><span id='topic+plot.sienaTimeTest'></span>

<h3>Description</h3>

<p>Plot method for <code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sienaTimeTest'
plot(x, pairwise=FALSE, effects,
     scale=.2, plevels=c(.1, .05, .025), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sienaTimeTest_+3A_x">x</code></td>
<td>
<p> A sienaTimeTest object returned by <code>sienaTimeTest</code>. </p>
</td></tr>
<tr><td><code id="plot.sienaTimeTest_+3A_pairwise">pairwise</code></td>
<td>
<p> A Boolean value corresponding to whether the user
would like a pairwise plot of the simulated statistics to assess
correlation among the effects (<code>pairwise=TRUE</code>), or a plot of the
estimates across waves in order to assess graphically the results of
the score type test. </p>
</td></tr>
<tr><td><code id="plot.sienaTimeTest_+3A_effects">effects</code></td>
<td>
<p> A vector of integers corresponding to the indices given
in the <code>sienaTimeTest</code> output for effects which are to be
plotted.</p>
</td></tr>
<tr><td><code id="plot.sienaTimeTest_+3A_scale">scale</code></td>
<td>
<p> A positive number corresponding to the number of standard
deviations on one step estimates to use for computing the maximum and
minimum of the plotting range. We recommend experimenting with this
number when the y-axes of the plots are not satisfactory. Smaller
numbers shrink the axes.</p>
</td></tr>
<tr><td><code id="plot.sienaTimeTest_+3A_plevels">plevels</code></td>
<td>
<p> A list of three decimals indicating the gradients at
which to draw the confidence interval bars.</p>
</td></tr>
<tr><td><code id="plot.sienaTimeTest_+3A_...">...</code></td>
<td>
<p>For extra arguments. The Lattice parameter <code>layout</code>
can be used to control the layout of the graphs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>pairwise=TRUE</code> plot may be used to assess whether effects are
highly correlated. This information may be important when considering
forward-model selection, since highly correlated effects may have
highly correlated one-step estimates, particularly since the individual
score type tests are not orthogonalized against the scores and
deviations of yet-unestimated dummies.  For example, reciprocity and
outdegree may have highly correlated statistics as indicated by a
strong, positive correlation coefficient.  When considering whether to
include dummy terms, it may be a good idea to include, e.g., outdegree,
estimate the parameter, and see whether reciprocity dummies remain
significant after method of moments estimation of the updated model&ndash;as
opposed to including both outdegree and reciprocity.
</p>
<p>The <code>pairwise=FALSE</code> plot displays the most of the information
garnered from <code>sienaTimeTest</code> in a graphical fashion.  For each
effect, the method of moments parameter estimate for the base period
(i.e. wave 1) is given as a blue, horizontal reference line. One step
estimates are given for all of the parameters by dots at each wave. The
dots are colored black if the parameter has been included in the model
already (i.e. has been estimated via method of moments), or red if they
have not been included. Confidence intervals are given based on pivots
given at <code>pvalues</code>. Evidence of time heterogeneity is suggested by
points with confidence intervals not overlapping with the base period.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Josh Lospinoso</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
for general information on RSiena.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code>,
<code><a href="lattice.html#topic+xyplot">xyplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=500)
# It makes no sense to put together the following data set,
# but just for demonstration:
mynet1 &lt;- sienaDependent(array(c(s501, s502, s503, s501, s503, s502), dim=c(50, 50, 6)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip)
myeff &lt;- includeTimeDummy(myeff, density, timeDummy="all")
myeff &lt;- includeTimeDummy(myeff, recip, timeDummy="2,3,5")
myeff &lt;- includeTimeDummy(myeff, transTrip, timeDummy="2,3")
(ansp &lt;- siena07(myalgorithm, data=mydata, effects=myeff))
ttp &lt;- sienaTimeTest(ansp)
summary(ttp)

## Pairwise plots show
plot(ttp, pairwise=TRUE)

## Time test plots show
plot(ttp, effects=1:3) ## default layout
plot(ttp, effects=1:3, layout=c(3,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='print.sienaEffects'>
Print methods for Siena effects objects
</h2><span id='topic+print.sienaEffects'></span><span id='topic+summary.sienaEffects'></span><span id='topic+print.summary.sienaEffects'></span>

<h3>Description</h3>

<p>Prints the major columns of the effects object.   
Or all, with any non-atomic columns listed separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sienaEffects'
print(x, fileName = NULL, includeOnly=TRUE,
expandDummies = FALSE, includeRandoms = FALSE, dropRates=FALSE, ...)
## S3 method for class 'sienaEffects'
summary(object, fileName = NULL,
includeOnly=TRUE, expandDummies = FALSE, ...)
## S3 method for class 'summary.sienaEffects'
print(x, fileName = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sienaEffects_+3A_object">object</code></td>
<td>
<p>An object of class <code>sienaEffects</code>.</p>
</td></tr>
<tr><td><code id="print.sienaEffects_+3A_x">x</code></td>
<td>
<p>An object of class <code>sienaEffects</code> or
<code>summary.sienaEffects</code> as appropriate.
</p>
</td></tr>
<tr><td><code id="print.sienaEffects_+3A_filename">fileName</code></td>
<td>
<p>Character string denoting file name if file output desired.</p>
</td></tr>
<tr><td><code id="print.sienaEffects_+3A_includeonly">includeOnly</code></td>
<td>
<p>Boolean. If TRUE, only effects with the include
flag TRUE will be printed.</p>
</td></tr>
<tr><td><code id="print.sienaEffects_+3A_expanddummies">expandDummies</code></td>
<td>
<p>Interpret the <code>timeDummy</code> column and show
any effects which would be added by <code>sienaTimeFix</code>.</p>
</td></tr>
<tr><td><code id="print.sienaEffects_+3A_includerandoms">includeRandoms</code></td>
<td>
<p>Boolean. If TRUE, also the
<code>randomEffects</code> column will be printed.</p>
</td></tr>
<tr><td><code id="print.sienaEffects_+3A_droprates">dropRates</code></td>
<td>
<p>Boolean. If TRUE, do not print the rows for basic rate
effects.</p>
</td></tr>
<tr><td><code id="print.sienaEffects_+3A_...">...</code></td>
<td>
<p>For extra arguments (none used at present).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>print.sienaEffects</code> prints details of the main
columns of the selected rows of the effects object.<br />
If the effects object includes statistics for the
Generalized Method of Moments (GMoM), as included by function
<code><a href="#topic+includeGMoMStatistics">includeGMoMStatistics</a></code> and for which <code>type=gmm</code>,
the print consists of two parts: the first consists of the
included effects for the probability model, the second
of the statistics used for GMoM estimation.
</p>
<p>The function <code>summary.sienaEffects</code> checks the rows for valid
printing via <code>print.data.frame</code> and excludes any that will
fail. The OK columns are printed first, followed by any others.
</p>
<p>Output from either can be directed to a file by using the argument
<code>filename</code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley, modifications by Tom Snijders and Viviana Amati.
</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaEffects">sienaEffects</a></code>,
<code><a href="#topic+getEffects">getEffects</a></code>, <code><a href="#topic+includeEffects">includeEffects</a></code>,
<code><a href="#topic+includeGMoMStatistics">includeGMoMStatistics</a></code>,
<code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code>,
<code><a href="#topic+effectsDocumentation">effectsDocumentation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mycovar &lt;- coCovar(rnorm(50))
mydyadcovar &lt;- coDyadCovar(matrix(as.numeric(rnorm(2500) &gt; 2), nrow=50))
mydata &lt;- sienaDataCreate(mynet1, mybeh, mycovar, mydyadcovar)
myeff &lt;- getEffects(mydata)
myeff
summary(myeff)
</code></pre>

<hr>
<h2 id='print.sienaMeta'>Methods for processing sienaMeta objects</h2><span id='topic+print.sienaMeta'></span><span id='topic+summary.sienaMeta'></span><span id='topic+plot.sienaMeta'></span><span id='topic+print.summary.sienaMeta'></span><span id='topic+meta.table'></span>

<h3>Description</h3>

<p><code>print</code>, <code>summary</code>, and <code>plot</code> methods for   
<code>sienaMeta</code> objects; and a function to write a LaTeX table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sienaMeta'
print(x, file=FALSE, reportEstimates=FALSE, ...)

## S3 method for class 'sienaMeta'
summary(object, file=FALSE, extra=TRUE, ...)

## S3 method for class 'summary.sienaMeta'
print(x, file=FALSE, extra=TRUE, ...)

## S3 method for class 'sienaMeta'
plot(x, ..., which = 1:length(x$theta),
                         useBound=TRUE, layout = c(2,2))
meta.table(x, d=3, option=2,
    filename=paste(deparse(substitute(x)),'_global.tex',sep=""), align=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sienaMeta_+3A_object">object</code></td>
<td>
<p>An object of class <code>sienaMeta</code>.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_x">x</code></td>
<td>
<p>An object of class <code>sienaMeta</code>, or
<code>summary.sienaMeta</code> as appropriate.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_file">file</code></td>
<td>
<p>Boolean: if TRUE, sends output to file named
<code>x$projname.txt</code>. If FALSE, output is to the terminal.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_reportestimates">reportEstimates</code></td>
<td>
<p>Boolean: whether to report all estimates
and standard errors.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_extra">extra</code></td>
<td>
<p>Boolean: if TRUE, prints more information.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_which">which</code></td>
<td>
<p>Set of effects contained in the plot
(given by sequence numbers).</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_usebound">useBound</code></td>
<td>
<p>Boolean: whether to restict plotted symbols to the bound
used in the call of <code>sienaMeta</code>.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_layout">layout</code></td>
<td>
<p>Vector giving number of rows and columns
in the arrangement of the several panels in a
rectangular array, possibly spanning multiple pages.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_d">d</code></td>
<td>
<p>Number of decimals to be used in table.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_option">option</code></td>
<td>
<p>1: results without normality assumptions;
2: results with normality assumptions, with confidence intervals;
3: results with normality assumptions, with standard errors.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_filename">filename</code></td>
<td>
<p>filename for output; if &quot;&quot;, printed to the console.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_align">align</code></td>
<td>
<p>Whether to align numbers at the decimal point.</p>
</td></tr>
<tr><td><code id="print.sienaMeta_+3A_...">...</code></td>
<td>
<p>For extra arguments (none used at present).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>print.sienaMeta</code> prints details of the merged
estimates of the meta-analysis carried out by <code><a href="#topic+siena08">siena08</a></code>,
with test statistics. See the help page for <code><a href="#topic+siena08">siena08</a></code>
for what is produced by this function.
</p>
<p>The function <code>summary.sienaMeta</code> prints details as for the
<code>print</code> method, but also details of the <code>sienaFit</code> objects
included.
</p>
<p>Output from either can be directed to a file by using the argument
<code>file</code>. It will be appended to any existing file of the same
name: <code>projname.txt</code>  where <code>projname</code> is the value of the
argument to <code>siena08</code>.
</p>
<p>The function <code>meta.table</code> writes a combined table of results
for all parameters to a LaTeX file in (as default) the current working
directory. This table is a more compact version of
the results presented by <code>print.sienaMeta</code>.
</p>
<p>The function <code>plot.sienaMeta</code> plots estimates against standard
errors for each effect, with reference lines added at the two-sided
significance threshold 0.05. It returns an object of class <code>trellis</code>,
of the <span class="pkg">lattice</span> package. Effects for which a score test
was requested are not plotted.<br />
Another funnel plot, not using <code><a href="#topic+siena08">siena08</a></code>,
is available as <code><a href="#topic+funnelPlot">funnelPlot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley, Tom Snijders
</p>


<h3>References</h3>

 
<p>Snijders, T.A.B, and Baerveldt, C. (2003),
A Multilevel Network Study of the Effects of Delinquent Behavior
on Friendship Evolution.
<em>Journal of Mathematical Sociology</em> <b>27</b>, 123&ndash;151.
</p>
<p>See also the Siena manual and
<a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena08">siena08</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A meta-analysis for three groups does not make much sense
# for generalizing to a population of networks,
# but it the Fisher combinations of p-values are meaningful.
# But using three groups shows the idea.

Group1 &lt;- sienaDependent(array(c(N3401, HN3401), dim=c(45, 45, 2)))
Group3 &lt;- sienaDependent(array(c(N3403, HN3403), dim=c(37, 37, 2)))
Group4 &lt;- sienaDependent(array(c(N3404, HN3404), dim=c(33, 33, 2)))
dataset.1 &lt;- sienaDataCreate(Friends = Group1)
dataset.3 &lt;- sienaDataCreate(Friends = Group3)
dataset.4 &lt;- sienaDataCreate(Friends = Group4)
OneAlgorithm &lt;- sienaAlgorithmCreate(projname = "SingleGroups")
effects.1 &lt;- getEffects(dataset.1)
effects.3 &lt;- getEffects(dataset.3)
effects.4 &lt;- getEffects(dataset.4)
effects.1 &lt;- includeEffects(effects.1, transTrip)
effects.1 &lt;- setEffect(effects.1, transRecTrip, fix=TRUE, test=TRUE)
effects.3 &lt;- includeEffects(effects.3, transTrip)
effects.3 &lt;- setEffect(effects.3, transRecTrip, fix=TRUE, test=TRUE)
effects.4 &lt;- includeEffects(effects.4, transTrip)
effects.4 &lt;- setEffect(effects.4, transRecTrip, fix=TRUE, test=TRUE)
ans.1 &lt;- siena07(OneAlgorithm, data=dataset.1, effects=effects.1, batch=TRUE)
ans.3 &lt;- siena07(OneAlgorithm, data=dataset.3, effects=effects.3, batch=TRUE)
ans.4 &lt;- siena07(OneAlgorithm, data=dataset.4, effects=effects.4, batch=TRUE)
ans.1
ans.3
ans.4
meta &lt;- siena08(ans.1, ans.3, ans.4)
print(meta, reportEstimates=FALSE)
print(meta)
summary(meta)
# For specifically presenting the Fisher combinations:
# First determine the number of estimated effects:
(neff &lt;- sum(sapply(meta, function(x){ifelse(is.list(x),
        !is.null(x$cjplus),FALSE)})))
Fishers &lt;- t(sapply(1:neff,
        function(i){c(meta[[i]]$cjplus, meta[[i]]$cjminus,
                        meta[[i]]$cjplusp, meta[[i]]$cjminusp, 2*meta[[i]]$n1 )}))
Fishers &lt;- as.data.frame(Fishers, row.names=names(meta)[1:neff])
names(Fishers) &lt;- c('Fplus', 'Fminus', 'pplus', 'pminus', 'df')
Fishers
# For plotting:
plo &lt;- plot(meta, layout = c(3,1))
plo
plo[3]
# Show effects of bound (bounding at 0.4 is not reasonable, just for example)
meta &lt;- siena08(ans.1, ans.3, ans.4, bound=0.4)
plot(meta, which=c(2,3), layout=c(2,1))
plot(meta, which=c(2,3), layout=c(2,1), useBound=FALSE)
meta.table(meta, option=3, file='')

## End(Not run)</code></pre>

<hr>
<h2 id='print.sienaTest'>
Print method for Wald and score tests for RSiena results
</h2><span id='topic+print.sienaTest'></span><span id='topic+sienaTest.methods'></span>

<h3>Description</h3>

<p>This method prints Wald-type and score-type tests for results   
estimated by <code><a href="#topic+siena07">siena07</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sienaTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sienaTest_+3A_x">x</code></td>
<td>
<p>An object of type <code>sienaTest</code>, produced by
<code><a href="#topic+Wald.RSiena">Wald.RSiena</a></code>, <code><a href="#topic+Multipar.RSiena">Multipar.RSiena</a></code>,
or <code><a href="#topic+score.Test">score.Test</a></code>.</p>
</td></tr>
<tr><td><code id="print.sienaTest_+3A_...">...</code></td>
<td>
<p>Extra arguments (not used at present).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code><a href="#topic+Wald.RSiena">Wald.RSiena</a></code>, <code><a href="#topic+Multipar.RSiena">Multipar.RSiena</a></code>,
and <code><a href="#topic+score.Test">score.Test</a></code> produce an object of type <code><a href="#topic+sienaTest">sienaTest</a></code>.
These can be printed by this method.</p>


<h3>Value</h3>

<p>An object of type  <code><a href="#topic+sienaTest">sienaTest</a></code>.
</p>


<h3>Author(s)</h3>

<p>Tom Snijders</p>


<h3>See Also</h3>

 <p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+Wald.RSiena">Wald.RSiena</a></code>,
<code><a href="#topic+Multipar.RSiena">Multipar.RSiena</a></code>, <code><a href="#topic+score.Test">score.Test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata &lt;- sienaDataCreate(mynet)
myeff &lt;- getEffects(mydata)
myalgorithm &lt;- sienaAlgorithmCreate(nsub=1, n3=40, seed=123, projname=NULL)
# nsub=1 and n3=40 is used here for having a brief computation,
# not for practice.
myeff &lt;- includeEffects(myeff, transTrip, transTies)
myeff &lt;- includeEffects(myeff, outAct, outPop, fix=TRUE, test=TRUE)
(ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE))
mprs &lt;- Multipar.RSiena(ans, 3, 4)
print(mprs)
</code></pre>

<hr>
<h2 id='print01Report'>
Function to produce the Siena01 report from R objects</h2><span id='topic+print01Report'></span>

<h3>Description</h3>

<p>Prints a report of a Siena data object and its default effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print01Report(data, modelname = "Siena", getDocumentation=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print01Report_+3A_data">data</code></td>
<td>
<p>a Siena data object
</p>
</td></tr>
<tr><td><code id="print01Report_+3A_modelname">modelname</code></td>
<td>

<p>Character string used to name the output file &quot;modelname.txt&quot;
</p>
</td></tr>
<tr><td><code id="print01Report_+3A_getdocumentation">getDocumentation</code></td>
<td>
<p>Flag to allow documentation of internal
functions, not for use by users.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First deletes any file of the name &quot;modelname.txt&quot;, then prints a new one.
</p>


<h3>Value</h3>

<p>No value returned.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley </p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mydata &lt;- sienaDataCreate(mynet1)
## Not run: 
print01Report(mydata, modelname="mydescription")

## End(Not run)
</code></pre>

<hr>
<h2 id='s50'>Network data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.
</h2><span id='topic+s50'></span>

<h3>Description</h3>

<p>An excerpt of the network, alcohol consumption, and smoking data     
for 50 randomly chosen girls from the
Teenage Friends and Lifestyle Study data set. Useful as a small    
example of network and behaviour, for which models can be    
fitted quickly, and for which there are no missing values.
</p>


<h3>Format</h3>

<p>Adjacency matrix for the network at time points 1, 2, 3; 50 by 3 matrices
of alcohol consumption and smoking data for the three time points.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip</a>
</p>


<h3>References</h3>

<p>West, P. and Sweeting, H. (1995), <em>Background Rationale and Design of the
West of Scotland 11-16 Study</em>.
Working Paper No. 52. MRC Medical Sociology Unit Glasgow.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s501">s501</a></code>, <code><a href="#topic+s502">s502</a></code>, <code><a href="#topic+s503">s503</a></code>,
<code><a href="#topic+s50a">s50a</a></code>, <code><a href="#topic+s50s">s50s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mydata &lt;- sienaDataCreate(mynet, mybeh)
mydata
</code></pre>

<hr>
<h2 id='s501'>Network 1 data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.
</h2><span id='topic+s501'></span>

<h3>Description</h3>

<p>First timepoint network data from   
an excerpt of the network, alcohol consumption, and smoking data     
for 50 randomly chosen girls from the
Teenage Friends and Lifestyle Study data set. Useful as a small    
example of network and behaviour, for which models can be    
fitted quickly, and for which there are no missing values.
</p>


<h3>Format</h3>

<p>The adjacency matrix for the network at time point 1.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip</a>
</p>


<h3>References</h3>

<p>West, P. and Sweeting, H. (1995), <em>Background Rationale and Design of the
West of Scotland 11-16 Study</em>.
Working Paper No. 52. MRC Medical Sociology Unit Glasgow.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s502">s502</a></code>, <code><a href="#topic+s503">s503</a></code>, <code><a href="#topic+s50a">s50a</a></code>, <code><a href="#topic+s50s">s50s</a></code></p>

<hr>
<h2 id='s502'>Network 2 data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.
</h2><span id='topic+s502'></span>

<h3>Description</h3>

<p>Second timepoint network data from   
an excerpt of the network, alcohol consumption, and smoking data     
for 50 randomly chosen girls from the
Teenage Friends and Lifestyle Study data set. Useful as a small    
example of network and behaviour, for which models can be    
fitted quickly, and for which there are no missing values.
</p>


<h3>Format</h3>

<p>The adjacency matrix for the network at time point 2.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip</a>
</p>


<h3>References</h3>

<p>West, P. and Sweeting, H. (1995), <em>Background Rationale and Design of the
West of Scotland 11-16 Study</em>.
Working Paper No. 52. MRC Medical Sociology Unit Glasgow.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s501">s501</a></code>, <code><a href="#topic+s503">s503</a></code>, <code><a href="#topic+s50a">s50a</a></code>, 
<code><a href="#topic+s50s">s50s</a></code>, <code><a href="#topic+s50">s50</a></code></p>

<hr>
<h2 id='s503'>Network 3 data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data.</h2><span id='topic+s503'></span>

<h3>Description</h3>

<p>Second timepoint network data from   
an excerpt of the network, alcohol consumption, and smoking data     
for 50 randomly chosen girls from the
Teenage Friends and Lifestyle Study data set. Useful as a small    
example of network and behaviour, for which models can be    
fitted quickly, and for which there are no missing values.
</p>


<h3>Format</h3>

<p>Adjacency matrix for the network at time point 3.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip</a>
</p>


<h3>References</h3>

<p>West, P. and Sweeting, H. (1995), <em>Background Rationale and Design of the
West of Scotland 11-16 Study</em>.
Working Paper No. 52. MRC Medical Sociology Unit Glasgow.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s501">s501</a></code>, <code><a href="#topic+s502">s502</a></code>, <code><a href="#topic+s50a">s50a</a></code>, <code><a href="#topic+s50s">s50s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mydata &lt;- sienaDataCreate(mynet, mybeh)
</code></pre>

<hr>
<h2 id='s50a'>Alcohol use data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data</h2><span id='topic+s50a'></span>

<h3>Description</h3>

<p>Alcohol use data from an excerpt of 50 girls from    
an excerpt of the network, alcohol consumption, and smoking data     
for 50 randomly chosen girls from the
Teenage Friends and Lifestyle Study data set. Useful as a small    
example of network and behaviour, for which models can be    
fitted quickly, and for which there are no missing values.
</p>


<h3>Format</h3>

<p>A matrix of variables relating to the use of alcohol for the actors in
the network. Three columns, one for each time point. Coding is 1&ndash;5, high
values indicating higher consumption.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip</a>
</p>


<h3>References</h3>

<p>West, P. and Sweeting, H. (1995), <em>Background Rationale and Design of the
West of Scotland 11-16 Study</em>.
Working Paper No. 52. MRC Medical Sociology Unit Glasgow.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s501">s501</a></code>, <code><a href="#topic+s502">s502</a></code>, <code><a href="#topic+s503">s503</a></code>, <code><a href="#topic+s50s">s50s</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mydata &lt;- sienaDataCreate(mynet, mybeh)
mydata
</code></pre>

<hr>
<h2 id='s50s'>Smoking data: excerpt from &quot;Teenage Friends and Lifestyle Study&quot; data</h2><span id='topic+s50s'></span>

<h3>Description</h3>

<p>Smoking data from    
an excerpt of the network, alcohol consumption, and smoking data     
for 50 randomly chosen girls from the
Teenage Friends and Lifestyle Study data set. Useful as a small    
example of network and behaviour, for which models can be    
fitted quickly, and for which there are no missing values.
</p>


<h3>Format</h3>

<p>A matrix of variables relating to the smoking habits for the actors in
the network. Three columns, one for each time point. Coding is 1&ndash;3:
1 = no smoking, 2 = moderate smoking, 3 = serious smoking.
</p>


<h3>Source</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.zip</a>
</p>


<h3>References</h3>

<p>West, P. and Sweeting, H. (1995), <em>Background Rationale and Design of the
West of Scotland 11-16 Study</em>.
Working Paper No. 52. MRC Medical Sociology Unit Glasgow.
</p>
<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/s50_data.htm</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+s501">s501</a></code>, <code><a href="#topic+s502">s502</a></code>, <code><a href="#topic+s503">s503</a></code>, <code><a href="#topic+s50a">s50a</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
myvar &lt;- varCovar(s50s)
mydata &lt;- sienaDataCreate(mynet, myvar)
mydata
</code></pre>

<hr>
<h2 id='setEffect'>
Function to set various columns in an effects object in a Siena model.
</h2><span id='topic+setEffect'></span>

<h3>Description</h3>

<p>This function provides an interface to change various columns of   
a selected row of a Siena effects object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setEffect(myeff, shortName, parameter = NULL, fix = FALSE,
test = FALSE, random=FALSE, initialValue = 0, timeDummy = ",", include = TRUE,
name = myeff$name[1], type = "eval", interaction1 = "",
interaction2 = "", effect1=0, effect2=0, effect3=0,
period=1, group=1, character=FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setEffect_+3A_myeff">myeff</code></td>
<td>
<p>a Siena effects object as created by <code><a href="#topic+getEffects">getEffects</a></code>
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_shortname">shortName</code></td>
<td>
<p>A short name (all with or all without quotes)
to identify the effect which should be changed.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_parameter">parameter</code></td>
<td>
<p>Value of internal effect parameter. If NULL, no change is made.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_fix">fix</code></td>
<td>
<p>For fixing effects. Boolean required. Default FALSE.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_test">test</code></td>
<td>
<p>For testing effects by score-type tests. Boolean required.
Default FALSE.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_random">random</code></td>
<td>
<p>For specifying that effects will vary randomly;
not relevant for <code>RSiena</code> at this moment.
Boolean required. Default FALSE.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_initialvalue">initialValue</code></td>
<td>
<p>Initial value for estimation. Default 0.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_timedummy">timeDummy</code></td>
<td>
<p>string: Comma delimited string of which periods to
dummy. Alternatively, use <code><a href="#topic+includeTimeDummy">includeTimeDummy</a></code>.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_include">include</code></td>
<td>
<p>Boolean. default TRUE, but can be switched to FALSE to
turn off an effect.</p>
</td></tr>
<tr><td><code id="setEffect_+3A_name">name</code></td>
<td>
<p>Name of dependent variable (network or behavior)
for which effects are being modified.
Defaults to the first in the effects object.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_type">type</code></td>
<td>
<p>Character string indicating the
type of the effect to be changed : currently &quot;rate&quot;, &quot;eval&quot;,
&quot;endow&quot;, or &quot;creation&quot;. Default &quot;eval&quot;.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_interaction1">interaction1</code></td>
<td>

<p>Name of siena object where needed to completely identify the
effect e.g. covariate name or behavior variable name.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_interaction2">interaction2</code></td>
<td>

<p>Name of siena object where needed to completely identify the
effect e.g. covariate name or behavior variable name.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_effect1">effect1</code></td>
<td>

<p>Only for <code>shortName=unspInt</code>, which means this is a
user-defined interaction effect: <code>effect1</code> is
a natural number indicating the first component of the interaction effect;
the number is the one listed when applying <code>print()</code> to <code>myeff</code>.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_effect2">effect2</code></td>
<td>

<p>Only for <code>shortName=unspInt</code>: second component of interaction effect
(see <code>effect1</code>).
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_effect3">effect3</code></td>
<td>

<p>Only for <code>shortName=unspInt</code>: third component of interaction effect,
if any (see <code>effect1</code>).
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_period">period</code></td>
<td>

<p>Number of period if basic rate. Use numbering within groups.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_group">group</code></td>
<td>

<p>Number of group if basic rate.
Only relevant for <code><a href="#topic+sienaGroup">sienaGroup</a></code> data sets.
</p>
</td></tr>
<tr><td><code id="setEffect_+3A_character">character</code></td>
<td>
<p>Boolean: whether the short name is a character string.</p>
</td></tr>
<tr><td><code id="setEffect_+3A_verbose">verbose</code></td>
<td>
<p>Boolean: should the print of altered effects be produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recall from the help page for <code><a href="#topic+getEffects">getEffects</a></code>
that a Siena effects object (class <code>sienaEffects</code> or
<code>sienaGroupEffects</code>) is a <code><a href="base.html#topic+data.frame">data.frame</a></code>;
the rows in the data frame are the effects for this data set;
some of the columns/variables of the data frame
are used to identify the effect, other columns/variables define how this
effect is used in the estimation. <br />
The function <code><a href="#topic+includeEffects">includeEffects</a></code> can operate on several
effects simultaneously, but in a less detailed way.
The main use of <code>setEffect</code> is that it can change not only the
value of the column <code>include</code>, but also
those of <code>initialValue</code> and <code>parm</code>.
The arguments <code>shortName</code>, <code>name</code>, <code>type</code>,
<code>interaction1</code>, <code>interaction2</code>, <code>effect1</code>, <code>effect2</code>,
<code>effect3</code>, <code>period</code>, and <code>group</code> should identify one
effect completely. (Not all of them are needed;
see <code><a href="#topic+getEffects">getEffects</a></code>.)<br />
The call of <code>setEffect</code> will set, for this effect,
the column elements of the resulting effects object for <code>parm</code>,
<code>fix</code>, <code>test</code>, <code>randomEffects</code>, <code>initialValue</code>,
<code>timeDummy</code>, and <code>include</code> to the values requested.<br />
The <code>shortName</code> must not be set between quotes,
unless you use <code>character=TRUE</code>.   
</p>
<p>The input names <code>interaction1</code> and <code>interaction2</code> do not themselves
refer to created interactions, but to dependence of the base effects on
other variables in the data set.
They are used to completely identify the effects.</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+sienaEffects">sienaEffects</a></code> or
<code><a href="#topic+sienaGroupEffects">sienaGroupEffects</a></code>. This will be an updated version of the
input effects object, with one row updated.
Details of the row altered will be printed, unless <code>verbose=FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley </p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+getEffects">getEffects</a></code>, <code><a href="#topic+includeEffects">includeEffects</a></code>,
<code><a href="#topic+includeInteraction">includeInteraction</a></code>, <code><a href="#topic+includeGMoMStatistics">includeGMoMStatistics</a></code>,
<code><a href="#topic+updateSpecification">updateSpecification</a></code>,
<code><a href="#topic+print.sienaEffects">print.sienaEffects</a></code>,<code><a href="#topic+effectsDocumentation">effectsDocumentation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mydata &lt;- sienaDataCreate(mynet, mybeh)
myeff &lt;- getEffects(mydata)
# Specify an effect parameter:
myeff &lt;- setEffect(myeff, outTrunc, parameter=1)
myeff
# Set the initial rate parameter for one period:
myeff &lt;- setEffect(myeff, Rate, initialValue=1.5, name="mybeh",
                   type="rate", period=2)
</code></pre>

<hr>
<h2 id='siena07'>Function to estimate parameters in a Siena model</h2><span id='topic+siena07'></span>

<h3>Description</h3>

<p>Estimates parameters in a Siena model using Method of Moments,
based on direct simulation, conditional or otherwise;
or using Generalized Method of Moments;
or using Maximum Likelihood by MCMC simulation.
Estimation is done using a Robbins-Monro algorithm.
Note that the data and particular model to be used
must be passed in using named arguments as the <code>...</code>,
and the specification for the algorithm must be passed on
as <code>x</code>,
which is a <code><a href="#topic+sienaAlgorithm">sienaAlgorithm</a></code> object as produced by
<code><a href="#topic+sienaAlgorithmCreate">sienaAlgorithmCreate</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siena07(x, batch=FALSE, verbose=FALSE, silent=FALSE,
        useCluster=FALSE, nbrNodes=2,
        thetaValues = NULL,
        returnThetas = FALSE,
        targets = NULL,
        initC=TRUE,
        clusterString=rep("localhost", nbrNodes), tt=NULL,
        parallelTesting=FALSE, clusterIter=!x$maxlike,
        clusterType=c("PSOCK", "FORK"), cl=NULL, ...)
      </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siena07_+3A_x">x</code></td>
<td>
<p>A control object, of class <code><a href="#topic+sienaAlgorithm">sienaAlgorithm</a>. </code></p>
</td></tr>
<tr><td><code id="siena07_+3A_batch">batch</code></td>
<td>
<p> Desired interface: <code>FALSE</code> gives a gui
(graphical user interface implemented as a tcl/tk screen),
<code>TRUE</code> gives a small (if <code>verbose=FALSE</code>) amount of printout
to the console.</p>
</td></tr>
<tr><td><code id="siena07_+3A_verbose">verbose</code></td>
<td>
<p>Produces various output to the console if <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="siena07_+3A_silent">silent</code></td>
<td>
<p>Produces no output to the console if <code>TRUE</code>,
even if batch mode.</p>
</td></tr>
<tr><td><code id="siena07_+3A_usecluster">useCluster</code></td>
<td>
<p>Boolean: whether to use a cluster of processes (useful if
multiple processors are available).</p>
</td></tr>
<tr><td><code id="siena07_+3A_nbrnodes">nbrNodes</code></td>
<td>
<p>Number of processes to use if useCluster is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="siena07_+3A_thetavalues">thetaValues</code></td>
<td>
<p>If not <code>NULL</code>, this should be a matrix with parameter
values to be used in Phase 3. The number of columns must be equal to the
number of estimated parameters in the effects object (if conditional
estimation is used, without the rate parameters for the conditioning
dependent variable). Can only be used if <code>x$simOnly=TRUE</code>.</p>
</td></tr>
<tr><td><code id="siena07_+3A_returnthetas">returnThetas</code></td>
<td>
<p>Boolean: whether to return theta values
and generated estimation statistics of Phase 2 runs.</p>
</td></tr>
<tr><td><code id="siena07_+3A_targets">targets</code></td>
<td>
<p>Numeric vector of length equal to the number of estimated
parameters, meant to supersede the targets calculated from the data set;
see &quot;Details&quot;. Not for regular use.</p>
</td></tr>
<tr><td><code id="siena07_+3A_initc">initC</code></td>
<td>
<p>Boolean: set to <code>TRUE</code> if the simulation will use C
routines (currently always needed). Only for use if using
multiple processors, to ensure all copies are initialised
correctly. Ignored otherwise, so is set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="siena07_+3A_clusterstring">clusterString</code></td>
<td>
<p>Definitions of clusters. Default set up to use
the local machine only.</p>
</td></tr>
<tr><td><code id="siena07_+3A_tt">tt</code></td>
<td>
<p>A <code>tcltk</code> toplevel window. Used if called from the
model options screen, if <code>tcltk</code> is available.</p>
</td></tr>
<tr><td><code id="siena07_+3A_paralleltesting">parallelTesting</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, sets up random numbers to
parallel those in Siena 3.</p>
</td></tr>
<tr><td><code id="siena07_+3A_clusteriter">clusterIter</code></td>
<td>
<p>Boolean. If <code>TRUE</code>, multiple processes execute
complete iterations at each call.
If <code>FALSE</code>, multiple processes execute a single wave at each call.</p>
</td></tr>
<tr><td><code id="siena07_+3A_clustertype">clusterType</code></td>
<td>
<p>Either &quot;PSOCK&quot; or &quot;FORK&quot;. On Windows, must be
&quot;PSOCK&quot;. On a single non-Windows machine may be &quot;FORK&quot;, and
subprocesses will be formed by forking. If &quot;PSOCK&quot;, subprocesses are
formed using <span class="rlang"><b>R</b></span> scripts.</p>
</td></tr>
<tr><td><code id="siena07_+3A_cl">cl</code></td>
<td>
<p>An object of class c(&quot;SOCKcluster&quot;, &quot;cluster&quot;) (see Details).</p>
</td></tr>
<tr><td><code id="siena07_+3A_...">...</code></td>
<td>
<p>Arguments for the simulation function, see
<code><a href="#topic+simstats0c">simstats0c</a></code>:
in any case, <code>data</code> and <code>effects</code>, as in the examples below;<br />
possibly also <code>prevAns</code> if a previous reasonable
provisional estimate was obtained for a similar model;<br />
possibly also <code>returnDeps</code> if the simulated dependent variables
(networks, behaviour) should be returned;<br />
possibly also <code>returnChains</code> if the simulated sequences (chains)
of ministeps should be returned; this may produce a very big file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the main function and workhorse of RSiena.
</p>
<p>For use of <code>siena07</code>, it is necessary to specify parameters <code>data</code>
(RSiena data set) and <code>effects</code> (effects object), which are
required parameters in function <code><a href="#topic+simstats0c">simstats0c</a></code>.
(These parameters are inserted through '...'.) See the examples.
</p>
<p><code>siena07</code> runs a Robbins-Monro algorithm for parameter estimation
using the three-phase implementation described in Snijders (2001, 2017),
with (if <code>x$findiff=FALSE</code>)
derivative estimation as in Schweinberger and Snijders (2007).
The default is estimation according to the Method of Moments
as in Snijders, Steglich and Schweinberger (2007).<br />
If  <code>x$gmm=TRUE</code> and <code>myeff</code> contains one or more
<code>gmm</code> statistics as included by function
<code><a href="#topic+includeGMoMStatistics">includeGMoMStatistics</a></code>, the algorithm employs the
Generalized Method of Moments as defined in Amati, Schoenenberger, and
Snijders (2015, 2019).<br />
For continuous behavior variables defined with <code>type="continuous"</code> in
<code><a href="#topic+sienaDependent">sienaDependent</a></code>, estimation is done as
described in Niezink and Snijders (2017).<br />
If  <code>x$maxlike=TRUE</code>, estimation is done by Maximum Likelihood
implemented as in Snijders, Koskinen and Schweinberger (2010).<br />
Phase 1 does a few iterations to
estimate the derivative matrix of the targets with respect to the
parameter vector. Phase 2 does the estimation. Phase 3 runs a
simulation to estimate standard errors and check convergence of the model.
The simulation function is called once for each iteration in these phases
and also once to initialise the model fitting and once to complete it.
Unless in batch mode, a tcl/tk screen is displayed to allow interruption
and to show progress.
</p>
<p>If <code>targets</code> is specified (which should be done only in special cases),
and provided that estimation is by the Method of Moments, the data
is not a multi-group data set and has exactly 2 waves,
and if the length of the vector <code>targets</code> is equal to the number
of estimated parameters (not counting the rate parameters estimated
by conditional estimation), then the vector <code>targets</code> supersedes the
targets calculated from the data set.
</p>
<p>It is necessary to check that convergence has been achieved.
The rule of thumb is that the all t-ratios for convergence should be
in absolute value less than 0.1 and
the overall maximum convergence ratio should be less than 0.25.
If this was not achieved, the result can be used to start
another estimation run from the estimate obtained, using
the parameter <code>prevAns</code> as illustrated in the example below.
(This parameter is inserted through '...' into the function
<code><a href="#topic+initializeFRAN">initializeFRAN</a></code>.)
</p>
<p>For good estimation of standard errors, it is necessary that <code>x$n3</code> is
large enough. More about this is in the manual. The default value <code>x$n3</code>
set in <code><a href="#topic+sienaAlgorithmCreate">sienaAlgorithmCreate</a></code> is adequate for most explorative use,
but for presentation in publications larger values are necessary, depending
on the data set and model; e.g., <code>x$n3=3000</code> or larger.
</p>
<p>Parameters can be tested against zero by dividing the estimate by its
standard error and using an approximate standard normal null distribution.
Further, functions <code><a href="#topic+Wald.RSiena">Wald.RSiena</a></code> and
<code><a href="#topic+Multipar.RSiena">Multipar.RSiena</a></code> are available for multi-parameter testing.<br />
Parameters specified in <code><a href="#topic+includeEffects">includeEffects</a></code> or
<code><a href="#topic+setEffect">setEffect</a></code> with <code>fix=TRUE, test=TRUE</code> will not be estimated;
score tests of their hypothesized values are reported in the output file
specified in the control (algorithm) object.
These tests can be obtained also using <code><a href="#topic+score.Test">score.Test</a></code>.
</p>
<p>If <code>x$simOnly</code> is <code>TRUE</code>, which is meant to go together with
<code>x$nsub=0</code>, the calculation of the standard errors and covariance
matrix at the end of Pase 3 is skipped. No estimation is performed.
If <code>thetaValues</code> is not <code>NULL</code>, the parameter values in
the rows of this matrix will be used in the consecutive runs of Phase 3.
If <code>x$n3</code> is larger than the number of rows times <code>nbrNodes</code>
(see below), the last row of <code>thetaValues</code> will continue to be used.
The parameter values actually used will be stored in the
output matrix <code>thetaUsed</code>.
</p>
<p>Multiple processors are used for estimation by MoM to distribute each iteration
in each subphase over the cluster of nodes. The number of iterations
accordingly will be divided (approximately) by the number of nodes;
for phase 2, unless <code>n2start</code> is specified.
This implies that if multiple processors are used, think of dividing
<code>n2start</code> by <code>nbrNodes</code>.<br />
For estimation by ML, multiple processing is done per period. Therefore,
for one period (two waves) and one group, this will have no effect.
</p>
<p>In the case of using multiple processors, there are two options for telling
<code>siena07</code> to use them. By specifying the options <code>useCluster</code>,
<code>nbrNodes</code>, <code>clusterString</code> and <code>initC</code>, <code>siena07</code>
will create a <code>cluster object</code> that will be used by the
<code>parallel</code> package. After finishing the estimation procedure,
<code>siena07</code> will automatically stop the cluster. Alternatively, instead of
having the function to create a cluster, the user may provide its own by
specifying the option <code>cl</code>, similar to what the boot function does in
the <a href="https://CRAN.R-project.org/package=boot"><span class="pkg">boot</span></a> package. By using the option <code>cl</code> the user may be
able to create more complex clusters (see examples below).
</p>
<p>If <code>thetaValues</code> is not <code>NULL</code> and <code>nbrNodes &gt;= 2</code>, parameters
in Phase 3 will be constant for each set of <code>nbrNodes</code> consecutive
simulations. This must be noted in the interpretation, and will be visible
in <code>thetaUsed</code> (see below).
</p>


<h3>Value</h3>

<p>Returns an object of class <code><a href="#topic+sienaFit">sienaFit</a></code>, some parts of which are:
</p>
<table>
<tr><td><code>OK</code></td>
<td>
<p>Boolean indicating successful termination</p>
</td></tr>
<tr><td><code>termination</code></td>
<td>
<p>Character string, values: &quot;OK&quot;, &quot;Error&quot;, or
&quot;UserInterrupt&quot;. &quot;UserInterrupt&quot; indicates that the user asked for early
termination before phase 3. </p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>Various characteristics of the data and model definition.</p>
</td></tr>
<tr><td><code>requestedEffects</code></td>
<td>
<p>The included effects in the effects object.</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>The included effects in the effects object to which are added
the main effects of the requested interaction effects, if any.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Estimated value of theta, if <code>x$simOnly=FALSE</code>.</p>
</td></tr>
<tr><td><code>thetas</code></td>
<td>
<p>Matrix, returned if <code>returnThetas</code> and <code>x$nsub &gt;= 1</code>.
First column is subphase; further columns are values of theta as generated
during this subphase of Phase 2.</p>
</td></tr>
<tr><td><code>sfs</code></td>
<td>
<p>Matrix, returned if <code>returnThetas</code> and <code>x$nsub &gt;= 1</code>.
First column is subphase; further columns are deviations from targets
generated during this subphase of Phase 2.</p>
</td></tr>
<tr><td><code>covtheta</code></td>
<td>
<p>Estimated covariance matrix of theta; this is not available
if <code>x$simOnly=TRUE</code>.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>Vector of standard errors of estimated theta,
if <code>x$simOnly=FALSE</code>.</p>
</td></tr>
<tr><td><code>dfra</code></td>
<td>
<p>Matrix of estimated derivatives.</p>
</td></tr>
<tr><td><code>sf</code></td>
<td>
<p>Matrix of simulated deviations from targets in phase 3.</p>
</td></tr>
<tr><td><code>sf2</code></td>
<td>
<p>Array of periodwise deviations from simulations in phase 3.
Not included if <code>x$lessMem=TRUE</code>.</p>
</td></tr>
<tr><td><code>tconv</code></td>
<td>
<p>t-statistics for convergence.</p>
</td></tr>
<tr><td><code>tmax</code></td>
<td>
<p>maximum absolute t-statistic for convergence for
non-fixed parameters.</p>
</td></tr>
<tr><td><code>tconv.max</code></td>
<td>
<p>overall maximum convergence ratio.</p>
</td></tr>
<tr><td><code>ac3</code></td>
<td>
<p>If <code>x$maxlike=TRUE</code>:
autocorrelations of statistics in Phase 3.</p>
</td></tr>
<tr><td><code>targets</code></td>
<td>
<p>Observed statistics; for ML, zero vector.</p>
</td></tr>
<tr><td><code>targets2</code></td>
<td>
<p>Observed statistics by wave,
starting with second wave; for ML, zero matrix.</p>
</td></tr>
<tr><td><code>ssc</code></td>
<td>
<p>Score function contributions for each wave for each
simulation in phase 3. Not included if finite difference method is used
or if <code>x$lessMem=TRUE</code>.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>Score functions, added over waves, for each
simulation in phase 3. Only included
if <code>x$lessMem=FALSE</code>.</p>
</td></tr>
<tr><td><code>regrCoef</code></td>
<td>
<p>If <code>x$dolby</code> and not <code>x$maxlike</code>:
regression coefficients of estimation statistics on score functions.</p>
</td></tr>
<tr><td><code>regrCor</code></td>
<td>
<p>If <code>x$dolby</code> and not <code>x$maxlike</code>:
correlations between estimation statistics and score functions.</p>
</td></tr>
<tr><td><code>estMeans</code></td>
<td>
<p>Estimated means of estimation statistics.</p>
</td></tr>
<tr><td><code>estMeans.sem</code></td>
<td>
<p>If <code>x$simOnly</code>: Standard errors of the
estimated means of estimation statistics.</p>
</td></tr>
<tr><td><code>sims</code></td>
<td>
<p>If <code>returnDeps=TRUE</code>:
list of simulated dependent variables (networks, behaviour).
Networks are given as a list of edgelists, one for each period.<br />
The structure of sims is a nested list:
<code>sims[[run]][[group]][[dependent variable]][[period]]</code>.
If <code>x$maxlike=TRUE</code> and there is only one group and one period,
the structure is <code>[[run]][[dependent variable]]</code>.</p>
</td></tr>
<tr><td><code>chain</code></td>
<td>
<p>If <code>returnChains = TRUE</code>:
list, or data frame, of simulated chains of ministeps.
The chain has the structure
<code>chain[[run]][[depvar]][[period]][[ministep]]</code>.
</p>
</td></tr>
<tr><td><code>Phase3nits</code></td>
<td>
<p>Number of iterations actually performed in phase 3.</p>
</td></tr>
<tr><td><code>thetaUsed</code></td>
<td>
<p>If <code>thetaValues</code> is not <code>NULL</code>, the matrix
of parameter values actually used in the simulations of Phase 3.</p>
</td></tr>
</table>
<p>Writes text output to the file named &quot;projname.txt&quot;, where projname
is defined in the <code><a href="#topic+sienaAlgorithm">sienaAlgorithm</a></code> object <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley, Tom Snijders, Viviana Amati, Felix Schoenenberger,
Nynke Niezink</p>


<h3>References</h3>

<p>Amati, V., Schoenenberger, F., and Snijders, T.A.B. (2015),
Estimation of stochastic actor-oriented models for the evolution of
networks by generalized method of moments.
<em>Journal de la Societe Francaise de Statistique</em> <b>156</b>, 140&ndash;165.
</p>
<p>Amati, V., Schoenenberger, F., and Snijders, T.A.B. (2019),
Contemporaneous statistics for estimation in stochastic actor-oriented
co-evolution models. <em>Psychometrika</em> <b>84</b>, 1068&ndash;1096.
</p>
<p>Greenan, C. (2015),
<em>Evolving Social Network Analysis: developments in statistical
methodology for dynamic stochastic actor-oriented models</em>.
DPhil dissertation, University of Oxford.
</p>
<p>Niezink, N.M.D., and Snijders, T.A.B. (2017),
Co-evolution of Social Networks and Continuous Actor Attributes.
<em>The Annals of Applied Statistics</em> <b>11</b>, 1948&ndash;1973.
</p>
<p>Schweinberger, M., and Snijders, T.A.B. (2007),
Markov models for digraph panel data:
Monte Carlo based derivative estimation.
<em>Computational Statistics and Data Analysis</em> <b>51</b>, 4465&ndash;4483.
</p>
<p>Snijders, T.A.B. (2001),
The statistical evaluation of social network dynamics.
<em>Sociological Methodology</em> <b>31</b>, 361&ndash;395.
</p>
<p>Snijders, T.A.B. (2017), Stochastic Actor-Oriented Models for Network
Dynamics. <em>Annual Review of Statistics and Its Application</em>
<b>4</b>, 343&ndash;363.
</p>
<p>Snijders, T.A.B., Koskinen, J., and Schweinberger, M. (2010).
Maximum likelihood estimation for social network dynamics.
<em>Annals of Applied Statistics</em> <b>4</b>, 567&ndash;588.
</p>
<p>Snijders, T.A.B., Steglich, C.E.G., and Schweinberger, Michael (2007),
Modeling the co-evolution of networks and behavior.
Pp. 41&ndash;71 in <em>Longitudinal models in the behavioral
and related sciences</em>,
edited by van Montfort, K., Oud, H., and Satorra, A.; Lawrence Erlbaum.
</p>
<p>Steglich, C.E.G., Snijders, T.A.B., and Pearson, M.A. (2010),
Dynamic networks and behavior:     Separating selection from influence.
<em>Sociological Methodology</em> <b>40</b>, 329&ndash;393.
Information about the implementation of the algorithm is in
<a href="https://www.stats.ox.ac.uk/~snijders/siena/Siena_algorithms.pdf">https://www.stats.ox.ac.uk/~snijders/siena/Siena_algorithms.pdf</a>.
Further see <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a> .
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena">siena</a></code>, <code><a href="#topic+sienaAlgorithmCreate">sienaAlgorithmCreate</a></code>,
<code><a href="#topic+sienaEffects">sienaEffects</a></code>,
<code><a href="#topic+Wald.RSiena">Wald.RSiena</a></code>, <code><a href="#topic+Multipar.RSiena">Multipar.RSiena</a></code>,
<code><a href="#topic+score.Test">score.Test</a></code>.
</p>
<p>There are print, summary and xtable methods for <code><a href="#topic+sienaFit">sienaFit</a></code>
objects: <code><a href="#topic+xtable">xtable</a></code>, <code><a href="#topic+print.sienaFit">print.sienaFit</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=100, seed=1293)
# nsub=2, n3=100 is used here for having a brief computation, not for practice.
mynet1 &lt;- sienaDependent(array(c(tmp3, tmp4), dim=c(32, 32, 2)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE)

# or for non-conditional estimation --------------------------------------------
## Not run: 
model &lt;- sienaAlgorithmCreate(nsub=2, n3=100, cond=FALSE, seed=1283)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE)
        
## End(Not run)

# or if a previous "on track" result ans was obtained --------------------------
## Not run: 
ans1 &lt;- siena07(myalgorithm, data=mydata, effects=myeff, prevAns=ans)
         
## End(Not run)

# Running in multiple processors -----------------------------------------------
## Not run: 
# Not tested because dependent on presence of processors
# Find out how many processors there are
library(parallel)
(n.clus &lt;- detectCores() - 1)
n.clus &lt;- min(n.clus, 4)  # keep time for other processes
ans2 &lt;- siena07(myalgorithm, data=mydata, effects=myeff,
                useCluster=TRUE, nbrNodes=n.clus, initC=TRUE)

# Suppose 8 processors are going to be used.
# Loading the parallel package and creating a cluster
# with 8 processors (this should be equivalent)

library(parallel)
cl &lt;- makeCluster(n.clus)

ans3 &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, cl = cl)

# Notice that now -siena07- perhaps won't stop the cluster for you.
# stopCluster(cl)

# You can create even more complex clusters using several computers. In this
# example we are creating a cluster with 3*8 = 24 processors on three
# different machines.
#cl &lt;- makePSOCKcluster(
#    rep(c('localhost', 'machine2.website.com' , 'machine3.website.com'), 8),
#    user='myusername', rshcmd='ssh -p PORTNUMBER')

#ans4 &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, cl = cl)
#stopCluster(cl)

## End(Not run)

# for a continuous behavior variable -------------------------------------------
# simulate behavior data according to dZ(t) = [-0.1 Z + 1] dt + 1 dW(t)
set.seed(123)
y1 &lt;- rnorm(50, 0,3)
y2 &lt;- exp(-0.1) * y1 + (1-exp(-0.1)) * 1/ -0.1 + rnorm(50, 0, (exp(-0.2)- 1) / -0.2 * 1^2)
friend &lt;- sienaDependent(array(c(s501, s502), dim = c(50,50,2)))
behavior &lt;- sienaDependent(matrix(c(y1,y2), 50,2), type = "continuous")
(mydata &lt;- sienaDataCreate(friend, behavior))
(myeff &lt;- getEffects(mydata, onePeriodSde = TRUE))
algorithmMoM &lt;- sienaAlgorithmCreate(nsub=1, n3=20, seed=321)
(ans &lt;- siena07(myalgorithm, data = mydata, effects = myeff, batch=TRUE))

# Accessing simulated networks for ML ------------------------------------------
# The following is an example for accessing the simulated networks for ML,
# which makes sense only if there are some missing tie variables;
# observed tie variables are identically simulated
# at the moment of observation,
# missing tie variable are imputed in a model-based way.
mat1 &lt;- matrix(c(0,0,1,1,
                 1,0,0,0,
                 0,0,0,1,
                 0,1,0,0),4,4, byrow=TRUE)
mat2 &lt;- matrix(c(0,1,1,1,
                 1,0,0,0,
                 0,0,0,1,
                 0,0,1,0),4,4, byrow=TRUE)
mat3 &lt;- matrix(c(0,1,0,1,
                 1,0,0,0,
                 0,0,0,0,
                 NA,1,1,0),4,4, byrow=TRUE)
mats &lt;- array(c(mat1,mat2,mat3), dim=c(4,4,3))
net &lt;- sienaDependent(mats, allowOnly=FALSE)
sdat &lt;- sienaDataCreate(net)
alg &lt;- sienaAlgorithmCreate(maxlike=TRUE, nsub=3, n3=100, seed=12534)
effs &lt;- getEffects(sdat)
(ans &lt;- siena07(alg, data=sdat, effects=effs, returnDeps=TRUE, batch=TRUE))
# See manual Section 9.1 for information about the following functions
edges.to.adj &lt;- function(x,n){
# create empty adjacency matrix
    adj &lt;- matrix(0, n, n)
# put edge values in desired places
    adj[x[, 1:2]] &lt;- x[, 3]
    adj
}
the.edge &lt;- function(x,n,h,k){
    edges.to.adj(x,n)[h,k]
}
# Now show the results
n &lt;- 4
ego &lt;- rep.int(1:n,n)
alter &lt;- rep(1:n, each=n)
# Get the average simulated adjacency matrices for wave 3 (period 2):
ones &lt;- sapply(1:n^2, function(i)
    {mean(sapply(ans$sims,
           function(x){the.edge(x[[1]][[2]][[1]],n,ego[i],alter[i])}))})
# Note that for maximum likelihood estimation,
# if there is one group and one period,
# the nesting levels for group and period are dropped from ans$sims.
cbind(ego,alter,ones)
matrix(ones,n,n)
</code></pre>

<hr>
<h2 id='siena08'>
Function to perform a meta analysis of a collection of Siena fits.
</h2><span id='topic+siena08'></span><span id='topic+sienaMeta'></span>

<h3>Description</h3>

<p>Estimates a meta analysis based on a collection of Siena fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>siena08(..., projname = "sienaMeta", bound = 5, alpha = 0.05, maxit=20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="siena08_+3A_...">...</code></td>
<td>
<p>names of <code><a href="#topic+sienaFit">sienaFit</a></code> objects, returned from
<code><a href="#topic+siena07">siena07</a></code>.
They will be renamed if entered in format <code>newname=oldname</code>.
It is also allowed to give for ... a list of <code><a href="#topic+sienaFit">sienaFit</a></code>
objects.
</p>
</td></tr>
<tr><td><code id="siena08_+3A_projname">projname</code></td>
<td>

<p>Base name of report file if required
</p>
</td></tr>
<tr><td><code id="siena08_+3A_bound">bound</code></td>
<td>

<p>Upper limit of standard error for inclusion in the meta analysis.
</p>
</td></tr>
<tr><td><code id="siena08_+3A_alpha">alpha</code></td>
<td>

<p>1 minus confidence level of confidence intervals.
</p>
</td></tr>
<tr><td><code id="siena08_+3A_maxit">maxit</code></td>
<td>

<p>Number of iterations of iterated least squares procedure.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A meta analysis is performed as described
in the Siena manual, section &quot;Meta-analysis of Siena results&quot;. This
consists of three parts: an iterated weighted least squares (IWLS)
modification of the method described in the reference below;
maximum likelihood estimates and confidence intervals based on
profile likelihoods under normality assumptions;
and Fisher combinations of left-sided and right-sided <code class="reqn">p</code>-values.
These are produced for all effects separately.
</p>
<p>Note that the corresponding effects must have the same effect name in each
model fit. This implies that at least covariates and behavior variables must
have the same name in each model fit.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+sienaMeta">sienaMeta</a></code>.  There are <code>print</code>,
<code>summary</code> and <code>plot</code> methods for this class.
This object contains at least the following.
</p>
<table>
<tr><td><code>thetadf</code></td>
<td>
<p>Data frame containing the coefficients, standard errors
and score test results</p>
</td></tr>
<tr><td><code>projname</code></td>
<td>
<p>Root name for any output file to be produced by the print method</p>
</td></tr>
<tr><td><code>bound</code></td>
<td>
<p>Estimates with standard error above this value were
excluded from the calculations</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>Object of class <code>by</code> indicating, for each effect in
the models, whether score test  information was present.</p>
</td></tr>
<tr><td><code>requestedEffects</code></td>
<td>
<p>The <code>requestedEffects</code> component of the first
<code>sienaFit</code> object in ....</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>The vector of IWLS estimates.</p>
</td></tr>
<tr><td><code>se.muhat</code></td>
<td>
<p>The vector of standard errors of the IWLS estimates.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>The vector of ML estimates <code>mu.ml</code> (see below).</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>The vector of standard errors of the ML estimates <code>mu.ml.se</code>
(see below).</p>
</td></tr>
</table>
<p>Then for each effect, there is a list with at least the following.
</p>
<table>
<tr><td><code>cor.est</code></td>
<td>
<p>Spearman rank correlation coefficient between estimates
and their standard errors.</p>
</td></tr>
<tr><td><code>cor.pval</code></td>
<td>
<p>p-value for above</p>
</td></tr>
<tr><td><code>regfit</code></td>
<td>
<p>Part of the result of the fit of <code><a href="#topic+iwlsm">iwlsm</a></code>.</p>
</td></tr>
<tr><td><code>regsummary</code></td>
<td>
<p>The summary of the fit, which includes the
coefficient table.</p>
</td></tr>
<tr><td><code>Tsq</code></td>
<td>
<p>test statistic for effect zero in every model</p>
</td></tr>
<tr><td><code>pTsq</code></td>
<td>
<p>p-value for above</p>
</td></tr>
<tr><td><code>tratio</code></td>
<td>
<p>test statistics that mean effect is 0</p>
</td></tr>
<tr><td><code>ptratio</code></td>
<td>
<p>p-value for above</p>
</td></tr>
<tr><td><code>Qstat</code></td>
<td>
<p>Test statistic for variance of effects is zero</p>
</td></tr>
<tr><td><code>pttilde</code></td>
<td>
<p>p-value for above</p>
</td></tr>
<tr><td><code>cjplus</code></td>
<td>
<p>Test statistic for at least one theta strictly greater than 0</p>
</td></tr>
<tr><td><code>cjminus</code></td>
<td>
<p>Test statistic for at least one theta strictly less than 0</p>
</td></tr>
<tr><td><code>cjplusp</code></td>
<td>
<p>p-value for <code>cjplus</code></p>
</td></tr>
<tr><td><code>cjminusp</code></td>
<td>
<p>p-value for <code>cjminus</code></p>
</td></tr>
<tr><td><code>mu.ml</code></td>
<td>
<p>ML estimate of population mean</p>
</td></tr>
<tr><td><code>mu.ml.se</code></td>
<td>
<p>standard error of ML estimate of population mean</p>
</td></tr>
<tr><td><code>sigma.ml</code></td>
<td>
<p>ML estimate of population standard deviation</p>
</td></tr>
<tr><td><code>mu.confint</code></td>
<td>
<p>confidence interval for population mean
based on profile likelihood</p>
</td></tr>
<tr><td><code>sigma.confint</code></td>
<td>
<p>confidence interval for population standard deviation
based on profile likelihood</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>Number of fits on which the meta analysis is based</p>
</td></tr>
<tr><td><code>cjplus</code></td>
<td>
<p>Test statistic for combination of right one-sided
Fisher combination tests</p>
</td></tr>
<tr><td><code>cjminus</code></td>
<td>
<p>Test statistic for combination of left one-sided
Fisher combination tests</p>
</td></tr>
<tr><td><code>cjplusp</code></td>
<td>
<p>p-value for <code>cjplus</code></p>
</td></tr>
<tr><td><code>cjminusp</code></td>
<td>
<p>p-value for <code>cjminus</code></p>
</td></tr>
<tr><td><code>scoreplus</code></td>
<td>
<p>Test statistic for combination of right one-sided
<code class="reqn">p</code>-values from score tests</p>
</td></tr>
<tr><td><code>scoreminus</code></td>
<td>
<p>Test statistic for combination of left one-sided
<code class="reqn">p</code>-values from score tests</p>
</td></tr>
<tr><td><code>scoreplusp</code></td>
<td>
<p>p-value for <code>scoreplus</code></p>
</td></tr>
<tr><td><code>scoreminusp</code></td>
<td>
<p>p-value for <code>scoreminus</code></p>
</td></tr>
<tr><td><code>ns</code></td>
<td>
<p>Number of fits on which the score test analysis is based</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruth Ripley, Tom Snijders</p>


<h3>References</h3>

<p>Snijders, T.A.B, and Baerveldt, C. (2003),
A Multilevel Network Study of the Effects of Delinquent Behavior
on Friendship Evolution.
<em>Journal of Mathematical Sociology</em> <b>27</b>, 123&ndash;151.
</p>
<p>See also the manual (Section 11.2)
and <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.sienaMeta">print.sienaMeta</a></code>, <code><a href="#topic+funnelPlot">funnelPlot</a></code>,
<code><a href="#topic+meta.table">meta.table</a></code>, <code><a href="#topic+iwlsm">iwlsm</a></code>, <code><a href="#topic+siena07">siena07</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A meta-analysis for three groups does not make much sense
# for generalizing to a population of networks,
# but the Fisher combinations of p-values are meaningful.
# However, using three groups does show the idea.

Group1 &lt;- sienaDependent(array(c(N3401, HN3401), dim=c(45, 45, 2)))
Group3 &lt;- sienaDependent(array(c(N3403, HN3403), dim=c(37, 37, 2)))
Group4 &lt;- sienaDependent(array(c(N3404, HN3404), dim=c(33, 33, 2)))
dataset.1 &lt;- sienaDataCreate(Friends = Group1)
dataset.3 &lt;- sienaDataCreate(Friends = Group3)
dataset.4 &lt;- sienaDataCreate(Friends = Group4)
OneAlgorithm &lt;- sienaAlgorithmCreate(projname = "SingleGroups", seed=128)
effects.1 &lt;- getEffects(dataset.1)
effects.3 &lt;- getEffects(dataset.3)
effects.4 &lt;- getEffects(dataset.4)
effects.1 &lt;- includeEffects(effects.1, transTrip)
effects.1 &lt;- setEffect(effects.1, transRecTrip, fix=TRUE, test=TRUE)
effects.3 &lt;- includeEffects(effects.3, transTrip)
effects.3 &lt;- setEffect(effects.3, transRecTrip, fix=TRUE, test=TRUE)
effects.4 &lt;- includeEffects(effects.4, transTrip)
effects.4 &lt;- setEffect(effects.4, transRecTrip, fix=TRUE, test=TRUE)
ans.1 &lt;- siena07(OneAlgorithm, data=dataset.1, effects=effects.1, batch=TRUE)
ans.3 &lt;- siena07(OneAlgorithm, data=dataset.3, effects=effects.3, batch=TRUE)
ans.4 &lt;- siena07(OneAlgorithm, data=dataset.4, effects=effects.4, batch=TRUE)
ans.1
ans.3
ans.4
(meta &lt;- siena08(ans.1, ans.3, ans.4))
plot(meta, which=2:3, layout = c(2,1))
# For specifically presenting the Fisher combinations:
# First determine the components of meta with estimated effects:
which.est &lt;- sapply(meta, function(x){ifelse(is.list(x),!is.null(x$cjplus),FALSE)})
Fishers &lt;- t(sapply(1:sum(which.est),
        function(i){c(meta[[i]]$cjplus, meta[[i]]$cjminus,
                        meta[[i]]$cjplusp, meta[[i]]$cjminusp, 2*meta[[i]]$n1 )}))
Fishers &lt;- as.data.frame(Fishers, row.names=names(meta)[which.est])
names(Fishers) &lt;- c('Fplus', 'Fminus', 'pplus', 'pminus', 'df')
Fishers
round(Fishers,4)

## End(Not run)
</code></pre>

<hr>
<h2 id='sienaAlgorithmCreate'>Function to create an object containing the algorithm
specifications for parameter estimation in RSiena</h2><span id='topic+sienaModelCreate'></span><span id='topic+sienaAlgorithmCreate'></span><span id='topic+sienaModel'></span><span id='topic+sienaAlgorithm'></span><span id='topic+model.create'></span>

<h3>Description</h3>

<p>Creates an object with specifications for the algorithm for  
parameter estimation in RSiena.   
</p>
<p><code>sienaAlgorithmCreate()</code> and <code>sienaModelCreate()</code>   
are identical functions; the second name was   
used from the start of the <code>RSiena</code> package, but the first name   
indicates more precisely the purpose of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaAlgorithmCreate(fn, projname = "Siena", MaxDegree = NULL, Offset = NULL,
     useStdInits = FALSE, n3 = 1000, nsub = 4, n2start = NULL,
     dolby=TRUE, maxlike = FALSE, gmm = FALSE, diagonalize=0.2*!maxlike,
     condvarno = 0, condname = "", firstg = 0.2, reduceg = 0.5,
     cond = NA, findiff = FALSE, seed = NULL,
     prML=1,
     maximumPermutationLength=40,
     minimumPermutationLength=2, initialPermutationLength=20,
     modelType=NULL, behModelType=NULL, mult=5, simOnly=FALSE, localML=FALSE,
     truncation=5, doubleAveraging=0, standardizeVar=(diagonalize&lt;1),
     lessMem=FALSE)

sienaModelCreate(fn, projname = "Siena", MaxDegree = NULL, Offset = NULL,
     useStdInits = FALSE, n3 = 1000, nsub = 4, n2start = NULL,
     dolby=TRUE, maxlike = FALSE, gmm = FALSE, diagonalize=0.2*!maxlike,
     condvarno = 0, condname = "", firstg = 0.2, reduceg = 0.5,
     cond = NA, findiff = FALSE, seed = NULL,
     prML=1,
     maximumPermutationLength=40,
     minimumPermutationLength=2, initialPermutationLength=20,
     modelType=NULL, behModelType=NULL, mult=5, simOnly=FALSE, localML=FALSE,
     truncation=5, doubleAveraging=0, standardizeVar=(diagonalize&lt;1),
     lessMem=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaAlgorithmCreate_+3A_fn">fn</code></td>
<td>
<p>Function to do one simulation in the Robbins-Monro
algorithm. Not to be touched.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_projname">projname</code></td>
<td>
<p>Character string name of project; the output file will be
called projname.txt. No embedded spaces!!!<br />
If <code>projname=NULL</code>, output will be written to a file in the temporary
session directory, created as <code><a href="base.html#topic+tempfile">tempfile</a>(Siena)</code>.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_maxdegree">MaxDegree</code></td>
<td>
<p>Named vector of maximum degree values for
corresponding networks. Allows to restrict the model to networks
with degrees not higher than this maximum.
Names should be the names of all dependent network variables,
in the same order as in the Siena data set.<br />
Default as well as value 0 imply no restrictions.<br />
This option is not available for maximum likelihood estimation.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_offset">Offset</code></td>
<td>
<p>Named vector of offset values for symmetric networks with
<code>modelType = 3</code> (M.1), and for universal setting in Settings model.
Names should be the names of all dependent network variables,
in the same order as in the Siena data set.
Default <code>NULL</code> implies values 0.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_usestdinits">useStdInits</code></td>
<td>
<p>Boolean. If TRUE, the initial values in the effects
object will be ignored and default values used instead.
If FALSE, the initial values in the effects object will be used.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_n3">n3</code></td>
<td>
<p>Number of iterations in phase 3. For regular use with the
Method of Moments, n3=1000 mostly suffices.
For use in publications and for Maximum Likelihood,
at least n3=3000 is advised. Sometimes much higher values are required
for stable estimation of standard errors.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_nsub">nsub</code></td>
<td>
<p>Number of subphases in phase 2.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_n2start">n2start</code></td>
<td>
<p>Minimum number of iterations in subphase 1 of phase 2;
default is <code>2.52*(p+7)</code>, where <code>p</code> = number of estimated
parameters; if <code>useCluster=TRUE</code> in the call of
<code><a href="#topic+siena07">siena07</a></code>, this is divided by <code>nbrNodes</code>.
</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_dolby">dolby</code></td>
<td>
<p>Boolean. Should there be noise reduction by regression
on augmented data score. In most cases dolby=TRUE yields better
convergence, but takes some extra computing time;
if convergence is problematic, however, dolby=FALSE may be tried.
Just use whatever works best.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_maxlike">maxlike</code></td>
<td>
<p>Whether to use maximum likelihood method or
Method of Moments estimation.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_gmm">gmm</code></td>
<td>
<p>Whether to use the Generalized Method of Moments or the regular
Method of Moments estimation.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_diagonalize">diagonalize</code></td>
<td>
<p>Number between 0 and 1 (bounds included),
values outside this interval will be truncated;
for diagonalize=0 the complete estimated derivative matrix will be used
for updates in the Robbins-Monro procedure;
for diagonalize=1 only the diagonal entries will be used;
for values between 0 and 1, the weighted average will be used
with weight diagonalize for the diagonalized matrix.
Has no effect for ML estimation.<br />
Higher values are more stable, lower values potentially more efficient.
Default: for ML estimation, diagonalize=0; for MoM estimation,
diagonalize = 0.2.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_condvarno">condvarno</code></td>
<td>
<p>If <code>cond</code> (conditional simulation), the
sequential number of the network
or behavior variable on which to condition.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_condname">condname</code></td>
<td>
<p>If conditional, the name of the dependent variable on
which to condition. Use one or other of <code>condname</code> or
<code>condvarno</code> to specify the variable.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_firstg">firstg</code></td>
<td>
<p>Initial value of scaling (&quot;gain&quot;) parameter for updates
in the Robbins-Monro procedure.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_reduceg">reduceg</code></td>
<td>
<p>Reduction factor for scaling (&quot;gain&quot;) parameter for updates
in the Robbins-Monro procedure (MoM only).</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_cond">cond</code></td>
<td>
<p>Boolean. Only relevant for Method of Moments
simulation/estimation.
If TRUE, use conditional simulation; if FALSE, unconditional simulation.
If missing, decision is deferred until <code><a href="#topic+siena07">siena07</a></code>,
when it is set to TRUE if there is only one dependent variable,
FALSE otherwise.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_findiff">findiff</code></td>
<td>
<p> Boolean: If TRUE, estimate derivatives using finite
differences. If FALSE, use scores.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_seed">seed</code></td>
<td>
<p>Integer. Starting value of random seed. Not used if
parallel testing.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_prml">prML</code></td>
<td>
<p>Either one real number, or a vector of 7 numbers.
Determines update probabilities used in Metropolis-Hastings
routine in ML estimation. Should be nonnegative; if a vector,
the sum should be &lt;= 1. See <code>Details</code>.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_maximumpermutationlength">maximumPermutationLength</code></td>
<td>
<p>Maximum length of permutation in steps in ML
estimation.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_minimumpermutationlength">minimumPermutationLength</code></td>
<td>
<p>Minimum length of permutation in steps in ML
estimation.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_initialpermutationlength">initialPermutationLength</code></td>
<td>
<p>Initial length of permutation in steps in ML
estimation.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_modeltype">modelType</code></td>
<td>
<p>Named vector indicating the type of model to be fitted for
dependent network variables.
(See the examples below for how to specify a named vector.)<br />
Possible values are:<br />
1=directed standard,
<br />
2:6 for symmetric networks only: 2=dictatorial forcing (D.1),
3=Initiative model with reciprocal confirmation (M.1),
4=Pairwise dictatorial forcing model (D.2),
5=Pairwise mutual model (M.2), 6=Pairwise joint model (C.2),<br />
7:10 for directed one-mode only:
7=Double Step model with double step probability 0.25,
8=Double Step model with double step probability 0.50,
9=Double Step model with double step probability 0.75,
10=Double Step model with double step probability 1.00.
<br />
Names should be the names of all dependent network variables,
in the same order as in the Siena data set.<br />
See Snijders and Pickup (2016) for the meanings of the various models
for symmetric networks.<br />
Default <code>NULL</code> implies 1 for directed or two-mode, 2 for symmetric.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_behmodeltype">behModelType</code></td>
<td>
<p>Named vector indicating the type of model to be fitted for
behavioral dependent variables.
(See the examples below for how to specify a named vector.)<br />
Possible values are:<br />
1=standard (restricted), 2=absorbing.<br />
Names should be the names of all dependent behavioral variables,
in the same order as in the Siena data set.<br />
Default <code>NULL</code> implies values 1.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_mult">mult</code></td>
<td>
<p>Multiplication factor for maximum likelihood and Bayes. Number of
steps per iteration is set to this multiple of the total distance
between the observations at start and finish of the wave (and rounded).
Decreasing <code>mult</code> below a certain value has no further effect.<br />
<code>mult</code> can be either a number (which needs to be positive) or a vector
of numbers, of length equal to the total number of periods. Note that for
multi-group data, the total number of periods is equal to the number
of groups times the number of periods per group
(if the latter is constant).</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_simonly">simOnly</code></td>
<td>
<p>Logical: If TRUE, then the calculation of the covariance
matrix and standard errors of the estimates at the end of
Phase 3 of the estimation algorithm in function siena07 is skipped.
This is suitable if nsub=0 and <code><a href="#topic+siena07">siena07</a></code> is used only for the
purpose of simulation.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_localml">localML</code></td>
<td>
<p>Logical: If TRUE, and <code>maxlike</code>, then calculations are
sped up for models with all local effects.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_truncation">truncation</code></td>
<td>
<p>Used for step truncation in the Robbins Monro algorithm
(applied to deviate/(standard deviation)).</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_doubleaveraging">doubleAveraging</code></td>
<td>
<p>subphase after which double averaging is used
in the Robbins Monro algorithm,
which probably increases algorithm efficiency.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_standardizevar">standardizeVar</code></td>
<td>
<p>Logical: whether to limit deviations used in
Robbins-Monro updates to unit variances.</p>
</td></tr>
<tr><td><code id="sienaAlgorithmCreate_+3A_lessmem">lessMem</code></td>
<td>
<p>Logical: whether to reduce storage during operation of
<code><a href="#topic+siena07">siena07</a></code>, and of the object produced, by leaving out arrays
by iteration and by period of simulated statistics <code>sf2</code> and scores
<code>ssc</code>.<br />
if <code>lessMem=TRUE</code>, it will be impossible to run
<code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code> or <code><a href="#topic+sienaGOF">sienaGOF</a></code> on
the object produced by <code><a href="#topic+siena07">siena07</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model specification is done via this object for
<code><a href="#topic+siena07">siena07</a></code>.
This function creates an object with the elements required to control the
Robbins-Monro algorithm. Those not
available as arguments can be changed manually when desired.<br />
The value <code>prML=1</code> defines the defaults valid in RSiena up to version
1.3.16. <br />
If <code>prML</code> is given as a vector of 7 probabilities, these are,
consecutively: the probabilities of inserting a diagonal step, deleting a
diagonal step, permuting, inserting a CCP, deleting a CCP, inserting random
missing, deleting random missing; the residual (1 minus the sum)
is the probability of a move step.<br />
Further information about the implementation of the algorithm is in <br />
<a href="https://www.stats.ox.ac.uk/~snijders/siena/Siena_algorithms.pdf">https://www.stats.ox.ac.uk/~snijders/siena/Siena_algorithms.pdf</a>.<br />
Some of the examples use <code>projname=NULL</code>; this is just for the sake of
checking the examples, not necessarily intended for normal use.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>sienaAlgorithm</code> containing
values implied by the parameters.</p>


<h3>Author(s)</h3>

<p>Ruth Ripley and Tom A.B. Snijders</p>


<h3>References</h3>

<p>For <code>modelType</code>:<br />
Snijders, T.A.B., and Pickup, M. (2016),
Stochastic Actor-Oriented Models for Network Dynamics.
In: Victor, J.N., Lubell, M., and Montgomery, A.H.,
<em>Oxford Handbook of Political Networks</em>. Oxford University Press.
</p>
<p>Also see <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+simstats0c">simstats0c</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>myAlgorithm &lt;- sienaAlgorithmCreate(projname="NetworkDyn")
StdAlgorithm &lt;- sienaAlgorithmCreate(projname="NetworkDyn", useStdInits=TRUE)
CondAlgorithm &lt;- sienaAlgorithmCreate(projname="NetworkDyn", condvarno=1, cond=TRUE)
Max10Algorithm &lt;- sienaAlgorithmCreate(projname="NetworkDyn", MaxDegree=c(mynet=10),
     modelType=c(mynet=1))
Beh2Algorithm &lt;- sienaAlgorithmCreate(projname="NetBehDyn", behModelType=c(mybeh=2))
# where mynet is the name of the network object created by sienaDependent(),
# and mybeh the name of the behavior object created by the same function.
</code></pre>

<hr>
<h2 id='sienaCompositionChange'>
Functions to create a Siena composition change object
</h2><span id='topic+sienaCompositionChange'></span><span id='topic+sienaCompositionChangeFromFile'></span>

<h3>Description</h3>

<p>Used to create a list of events describing the changes    
over time of a Siena actor set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaCompositionChange(changelist, nodeSet = "Actors", option = 1)
sienaCompositionChangeFromFile(filename, nodeSet = "Actors",
    fileobj=NULL, option = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaCompositionChange_+3A_changelist">changelist</code></td>
<td>

<p>A list with an entry for each actor in the node set. Each entry a
vector of numbers (may be as characters) indicating intervals during
which the corresponding actor was present.
Each entry must have an even number of digits.
The actor is assumed to be present from the first to the second,
third to fourth, etc., time points.
</p>
</td></tr>
<tr><td><code id="sienaCompositionChange_+3A_filename">filename</code></td>
<td>

<p>Name of file containing change information. One line per actor, each
line a series
of space delimited numbers indicating intervals.
</p>
</td></tr>
<tr><td><code id="sienaCompositionChange_+3A_fileobj">fileobj</code></td>
<td>

<p>The result of <code>readLines</code> on filename.
</p>
</td></tr>
<tr><td><code id="sienaCompositionChange_+3A_nodeset">nodeSet</code></td>
<td>

<p>Character string containing the name of a Siena node set.
If the entire data set contains more than one node set,
then the node sets must be specified in all data objects.
</p>
</td></tr>
<tr><td><code id="sienaCompositionChange_+3A_option">option</code></td>
<td>

<p>Integer controlling the processing of the tie variables for the
actors not currently present. Values (default is 1)
</p>

<table>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: left;">  0 before entry, final value carried forward after leaving,</td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;">  and used for calculating statistics in Method of Moments estimation</td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: left;">  0 before entry, missing after (final value carried forward, but
          treated as missing) </td>
</tr>
<tr>
 <td style="text-align: right;">
3 </td><td style="text-align: left;">  missing whenever not in the network. Previous values will be used
        where available, </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td><td style="text-align: left;">  but always treated as missing values.</td>
</tr>
<tr>
 <td style="text-align: right;">
4 </td><td style="text-align: left;">  Convert to structural zeros (not available at present).
</td>
</tr>

</table>

</td></tr>
</table>


<h3>Details</h3>

<p>If there is a composition change object for the first node set in the
data object, then this will be used in estimation by the Method of Moments
to make actors active
(able to send and receive ties) only for the time intervals
when this is indicated in the composition change object.
This is done according to the procedure of Huisman and Snijders (2003).
See the manual for further details.<br />
For bipartite networks, composition change objects for the second node set
have no effect and will lead to an error message.<br />
For <code>M</code> waves, time starts at 1 and ends at <code>M</code>;
so all numbers must be between 1 and the number of waves (bounds included).
Intervals are treated as closed at each end.
For example, an entry <code>(2, 4)</code> means that the actor corresponding
to this entry arrived at wave 2 and left at wave 4, but did give
valid date for both of these waves. An entry <code>(1.01, 2.99)</code> means that
the actor arrived just after wave 1 and left just before wave 3, and gave
valid data only for wave 2. An entry <code>(1, 2), (3.5, 4)</code> means that the
actor was there at the start and left at wave 2 (giving valid data for wave 2),
came back halfway between waves 3 and 4, and gave valid data still at wave 4;
if there would be more than 4 waves in the data set, this entry would also
mean that the actor left at wave 4.
<br />
For data sets including a composition change object, estimation
by Method of Moments is forced to be unconditional, overriding
the specification in the <code><a href="#topic+sienaAlgorithm">sienaAlgorithm</a></code> object.
</p>


<h3>Value</h3>

<p>An object of class &quot;compositionChange&quot;, a list of numeric vectors,
with attributes:
</p>
<table>
<tr><td><code>NodeSet</code></td>
<td>
<p>Name of node set</p>
</td></tr>
<tr><td><code>Option</code></td>
<td>
<p>Option</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruth Ripley </p>


<h3>References</h3>

<p>Huisman, M.E. and Snijders, T.A.B. (2003),
Statistical analysis of longitudinal network data with changing composition.
<em>Sociological Methods &amp; Research</em>, <b>32</b>, 253&ndash;287.
</p>
<p>See also <a href="https://www.stats.ox.ac.uk/~snijders/siena/RSiena_Manual.pdf">https://www.stats.ox.ac.uk/~snijders/siena/RSiena_Manual.pdf</a>
</p>
<p>Further see <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaNodeSet">sienaNodeSet</a></code>,
<code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  clist &lt;- list(c(1, 3), c(1.4, 2.5))
  #or
  clist &lt;- list(c("1", "3"), c("1.4", "2.5"))

  compChange &lt;- sienaCompositionChange(clist)

  s50net &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
  s50list &lt;- rep(list(c(1,3)), 50)
  # This is a trivial composition change: all actors are present in all waves.
  compChange &lt;- sienaCompositionChange(s50list)
  s50data &lt;- sienaDataCreate(s50net, compChange)
  s50data

  ## Not run: 
  filedata &lt;- c("1 3", "1.4 2.5")
  write.table(filedata, "cc.dat",row.names=FALSE, col.names=FALSE,
          quote=FALSE)
  ## file will be
  ## 1 3
  ## 1.4 2.5
  compChange &lt;- sienaCompositionChangeFromFile("cc.dat")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='sienaDataConstraint'>
Function to change the values of the constraints between networks.
</h2><span id='topic+sienaDataConstraint'></span>

<h3>Description</h3>

<p>This function allows the user to change the constraints   
of &quot;higher&quot;, &quot;disjoint&quot; and &quot;atLeastOne&quot; for a specified pair of  
networks in a Siena data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaDataConstraint(x, net1, net2,
          type = c("higher", "disjoint", "atLeastOne"), value = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaDataConstraint_+3A_x">x</code></td>
<td>
<p>Siena data object; maybe a group object?</p>
</td></tr>
<tr><td><code id="sienaDataConstraint_+3A_net1">net1</code></td>
<td>
<p>name of first network</p>
</td></tr>
<tr><td><code id="sienaDataConstraint_+3A_net2">net2</code></td>
<td>
<p>name of second network</p>
</td></tr>
<tr><td><code id="sienaDataConstraint_+3A_type">type</code></td>
<td>
<p>one of &quot;higher&quot;, &quot;disjoint&quot;, &quot;atleastOne&quot;. Default is &quot;higher&quot;.</p>
</td></tr>
<tr><td><code id="sienaDataConstraint_+3A_value">value</code></td>
<td>
<p>Boolean giving the value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of the appropriate attribute is set to the value requested.
Note that, for <code>value=TRUE</code>, the correspondence of this value 
to the data is not checked.
</p>


<h3>Value</h3>

<p>Updated Siena data object.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+sienaGroupCreate">sienaGroupCreate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>nowFriends &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
ever &lt;- array(c(s501, s502, s503), dim=c(50, 50, 3))
ever[,,2] &lt;- pmax(ever[,,1], ever[,,2])
ever[,,3] &lt;- pmax(ever[,,2], ever[,,3])
everFriends &lt;- sienaDependent(ever)
# Note: this data set serves to illustrate this function,
# but it is not an appropriate data set for estimation by siena07,
# because everFriends (for the three waves together) depends deterministically
# on nowFriends (for the three waves together).
nowOrEver &lt;- sienaDataCreate(nowFriends, everFriends)
attr(nowOrEver, "higher")
nowOrEver
nowOrEver.unconstrained &lt;-
   sienaDataConstraint(nowOrEver, everFriends, nowFriends, "higher", FALSE)
nowOrEver.unconstrained
attr(nowOrEver.unconstrained, "higher")
</code></pre>

<hr>
<h2 id='sienaDataCreate'>Function to create a Siena data object</h2><span id='topic+sienaDataCreate'></span><span id='topic+siena'></span>

<h3>Description</h3>

<p>Creates a Siena data object from input dependent variables   
(networks and possibly behavioural variables), covariates,
and composition change objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaDataCreate(..., nodeSets=NULL, getDocumentation=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaDataCreate_+3A_...">...</code></td>
<td>
<p>objects of class <code><a href="#topic+sienaDependent">sienaDependent</a></code>,
<code><a href="#topic+coCovar">coCovar</a></code>, <code><a href="#topic+varCovar">varCovar</a></code>, <code><a href="#topic+coDyadCovar">coDyadCovar</a></code>,
<code><a href="#topic+varDyadCovar">varDyadCovar</a></code>, and/or <code><a href="#topic+sienaCompositionChange">sienaCompositionChange</a></code>;
or a list of such objects, of which the first element must not be
a <code><a href="#topic+sienaCompositionChange">sienaCompositionChange</a></code> object.
There should be at least one <code><a href="#topic+sienaDependent">sienaDependent</a></code> object.<br />
If there are one-mode as well as two-mode dependent networks,
the one-mode networks should be mentioned first.</p>
</td></tr>
<tr><td><code id="sienaDataCreate_+3A_nodesets">nodeSets</code></td>
<td>
<p>list of Siena node sets. Default is the single node
set named &quot;Actors&quot;, length equal to the number of rows in the first
object of class &quot;sienaDependent&quot;. If the entire data set contains more than
one node set, then the node sets must have been specified in
the creation of all data objects mentioned in ....</p>
</td></tr>
<tr><td><code id="sienaDataCreate_+3A_getdocumentation">getDocumentation</code></td>
<td>
<p>Flag to allow documentation of internal
functions, not for use by users.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function checks that the objects fit, that there is at least one dependent
variable, and adds various attributes to each dependent variable describing the
data. If there is more than one nodeSet they must all be specified.<br />
Function <code><a href="#topic+print01Report">print01Report</a></code> will give a basic description of the data
object and is a check useful, e.g., for diagnosing problems.
</p>


<h3>Value</h3>

<p>An object of class &quot;siena&quot; which is designed to be used in a siena
model fit by <code><a href="#topic+siena07">siena07</a></code>. The components of the object are:
</p>
<table>
<tr><td><code>nodeSets</code></td>
<td>
<p>List of node sets involved</p>
</td></tr>
<tr><td><code>observations</code></td>
<td>
<p>Integer indicating number of waves of data</p>
</td></tr>
<tr><td><code>depvars</code></td>
<td>
<p>List of networks and behavior variables</p>
</td></tr>
<tr><td><code>cCovars</code></td>
<td>
<p>List of constant covariates</p>
</td></tr>
<tr><td><code>vCovars</code></td>
<td>
<p>List of changing covariates</p>
</td></tr>
<tr><td><code>dycCovars</code></td>
<td>
<p>List of constant dyadic covariates</p>
</td></tr>
<tr><td><code>dyvCovars</code></td>
<td>
<p>List of changing dyadic covariates</p>
</td></tr>
<tr><td><code>compositionChange</code></td>
<td>
<p>List of composition change objects
corresponding to the node sets</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDependent">sienaDependent</a></code>, <code><a href="#topic+coCovar">coCovar</a></code>, <code><a href="#topic+varCovar">varCovar</a></code>,
<code><a href="#topic+coDyadCovar">coDyadCovar</a></code>, <code><a href="#topic+varDyadCovar">varDyadCovar</a></code>,
<code><a href="#topic+sienaNodeSet">sienaNodeSet</a></code>, <code><a href="#topic+sienaCompositionChange">sienaCompositionChange</a></code>,
<code><a href="#topic+sienaGroupCreate">sienaGroupCreate</a></code>,
<code><a href="#topic+sienaDataConstraint">sienaDataConstraint</a></code>, <code><a href="#topic+sienaNodeSet">sienaNodeSet</a></code>,
<code><a href="#topic+print01Report">print01Report</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mydata &lt;- sienaDataCreate(mynet, mybeh)
# This gives the same result as
mydata &lt;- sienaDataCreate(list(mynet, mybeh))
## And for a two-mode network
mynet1 &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)), nodeSet="senders")
senders &lt;- sienaNodeSet(50, nodeSetName="senders")
receivers &lt;- sienaNodeSet(30, nodeSetName="receivers")
mynet2 &lt;- sienaDependent(array(c(s501[,1:30], s502[,1:30]), dim=c(50, 30, 2)),
      nodeSet=c("senders", "receivers"))
(mydata &lt;- sienaDataCreate(mynet1, mynet2, nodeSets=list(senders, receivers)))
## Not run: 
print01Report(mydata, modelname = "mydescription")

## End(Not run)
</code></pre>

<hr>
<h2 id='sienaDependent'>Function to create a dependent variable for a Siena model</h2><span id='topic+sienaDependent'></span><span id='topic+sienaNet'></span>

<h3>Description</h3>

<p>Creates a Siena dependent variable: either a network,  
created from a matrix or array or list of sparse matrix of triples;   
or a behavior variable, created from a matrix.<br />   
<code>sienaDependent()</code> and <code>sienaNet()</code> are identical   
functions; the second name was used from the start of the   
<code>RSiena</code> package, but the first name    
indicates more precisely the purpose of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaDependent(netarray, type=c("oneMode", "bipartite", "behavior", "continuous"),
nodeSet="Actors", sparse=is.list(netarray), allowOnly=TRUE, imputationValues=NULL)

sienaNet(netarray, type=c("oneMode", "bipartite", "behavior", "continuous"),
nodeSet="Actors", sparse=is.list(netarray), allowOnly=TRUE, imputationValues=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaDependent_+3A_netarray">netarray</code></td>
<td>
<p><code>type="behavior"</code> or <code>"continuous"</code>: matrix
(actors <code class="reqn">\times</code> waves).<br />
<code>type="oneMode"</code> or <code>"bipartite"</code>: array of values or list of
sparse matrices of type <code>"TsparseMatrix"</code>,
see the <code><a href="Matrix.html#topic+Matrix">Matrix</a></code> package;
if an array is used, it should have dimensions:
for a one-mode network, <code class="reqn">n \times n \times M</code>,
and for a two-mode network <code class="reqn">n \times m \times M</code>,
where <code class="reqn">n</code> is the number of actors, <code class="reqn">m</code> is the number
of nodes in the second mode, and <code class="reqn">M</code> is the number of waves.</p>
</td></tr>
<tr><td><code id="sienaDependent_+3A_type">type</code></td>
<td>
<p>type of dependent variable, default <code>oneMode</code>.</p>
</td></tr>
<tr><td><code id="sienaDependent_+3A_nodeset">nodeSet</code></td>
<td>
<p>character string naming the appropriate node set.
For a bipartite network, a vector containing 2 character strings:
&quot;rows&quot; first, then &quot;columns&quot;.</p>
</td></tr>
<tr><td><code id="sienaDependent_+3A_sparse">sparse</code></td>
<td>
<p>logical: TRUE indicates the data is in sparse matrix
format, FALSE otherwise.</p>
</td></tr>
<tr><td><code id="sienaDependent_+3A_allowonly">allowOnly</code></td>
<td>
<p>logical: If TRUE, it will be detected when between any
two consecutive waves the changes are non-decreasing or non-increasing,
and if this is the case, this will also be a constraint for the
simulations between these two waves.
This is done by means of the internal parameters <code>uponly</code> and
<code>downonly</code>.
If FALSE, the parameters <code>uponly</code> and <code>downonly</code> always are
set to FALSE, and changes in dependent variables will not be constrained
to be non-decreasing or non-increasing.
This also will imply that some effects are excluded because they are
superfluous in such constrained situations.
This will be reported in the output of <code><a href="#topic+print01Report">print01Report</a></code>.
</p>
<p>For normal operation when this is the case for all periods, usually
TRUE is the appropriate option. When it is only the case for some of the
periods, and for data sets that will be part of a multi-group object
created by <code><a href="#topic+sienaGroupCreate">sienaGroupCreate</a></code>, FALSE usually is preferable.</p>
</td></tr>
<tr><td><code id="sienaDependent_+3A_imputationvalues">imputationValues</code></td>
<td>
<p>for <code>behavior</code> or <code>continuous</code> dependent variables,
a matrix with imputation values can be included that will be used instead
of the default imputation values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds attributes so that the array or list of matrices can be used in a
Siena model fit.
</p>


<h3>Value</h3>

<p>An object of class <code>sienaDependent</code>. An array or (networks only) a list of
sparse matrices with attributes:
</p>
<table>
<tr><td><code>netdims</code></td>
<td>
<p>Dimensions of the network or behavior
variable: senders, receivers (1 for behavior), periods</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>oneMode, bipartite or behavior</p>
</td></tr>
<tr><td><code>sparse</code></td>
<td>
<p>Boolean: whether the network is given as a list of sparse
matrices or not</p>
</td></tr>
<tr><td><code>nodeSet</code></td>
<td>
<p>Character string with name(s) of node set(s)</p>
</td></tr>
<tr><td><code>allowOnly</code></td>
<td>
<p>The value of the <code>allowOnly</code> parameter</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruth Ripley and Tom A.B. Snijders</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a> .</p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+sienaNodeSet">sienaNodeSet</a></code>,
<code><a href="#topic+sienaDataConstraint">sienaDataConstraint</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
## note that the following example works although the node sets do not yet exist!
mynet3 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)),
       type="bipartite", nodeSet=c("senders", "receivers"))
## sparse matrix input
## To show this, we first go back from the adjacency matrices to edgelists.
## The manual shows one way to do this.
## Another way is to use the sparse matrix representation which internally
## indeed is an edge list:
library(Matrix)
sp501 &lt;- as(Matrix(s501), "TsparseMatrix")
sp502 &lt;- as(Matrix(s502), "TsparseMatrix")
sp503 &lt;- as(Matrix(s503), "TsparseMatrix")
## If you are interested in the internal structure of these sparse matrices,
## you can request
str(sp501)
## Slot @i is the row, @j is the column, and @x the value;
## here the values all are 1.
## Slots @i and @j do not contain information about the number of nodes,
## so that is supplied additionally by @Dim.
mymatlist &lt;- list(sp501, sp502, sp503)
mynet.sp &lt;- sienaDependent(mymatlist)
</code></pre>

<hr>
<h2 id='sienaFit.methods'>Methods for processing sienaFit objects, produced by <code><a href="#topic+siena07">siena07</a></code>.
</h2><span id='topic+sienaFit.methods'></span><span id='topic+print.summary.sienaFit'></span><span id='topic+sienaFit'></span><span id='topic+xtable.sienaFit'></span><span id='topic+print.xtable.sienaFit'></span><span id='topic+siena.table'></span><span id='topic+print.sienaFit'></span><span id='topic+summary.sienaFit'></span>

<h3>Description</h3>

<p><code>print</code>, <code>summary</code>, and <code>xtable</code> methods for
<code>sienaFit</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sienaFit'
print(x, tstat=TRUE, ...)

## S3 method for class 'sienaFit'
summary(object, ...)

## S3 method for class 'summary.sienaFit'
print(x, matrices=TRUE, ...)

## S3 method for class 'sienaFit'
xtable(x, caption = NULL, label = NULL, align = NULL,
                digits = NULL, display = NULL, ...)

siena.table(x, type="tex", file=paste(deparse(substitute(x)), ".", type,sep=""),
            vertLine=TRUE, tstatPrint=FALSE, sig=FALSE, d=3, nfirst=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaFit.methods_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+sienaFit">sienaFit</a></code>, produced by
<code><a href="#topic+siena07">siena07</a></code>. For <code>siena.table</code>, objects of class
<code>sienaBayes</code> are also permitted.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>sienaFit</code>, or
<code>summary.sienaFit</code> as appropriate. For <code>siena.table</code>,
objects of class <code>sienaBayes</code> are also permitted.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_matrices">matrices</code></td>
<td>
<p>Boolean: whether also to print in the summary the
covariance matrix of the estimates, the derivative matrix of expected
statistics X by parameters, and the covariance matrix of the statistics.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_tstat">tstat</code></td>
<td>
<p>Boolean: if this is NULL, the t-statistics for convergence
will not be added to the report.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_type">type</code></td>
<td>
<p>Type of output to produce; must be either <code>"tex"</code> or
<code>"html"</code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_file">file</code></td>
<td>
<p>Name of the file; defaults to the name of the <code>sienaFit</code>
object. &quot;&quot; indicates output to the console.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_vertline">vertLine</code></td>
<td>
<p>Boolean: add vertical lines separating the columns in
<code>siena.table</code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_tstatprint">tstatPrint</code></td>
<td>
<p>Boolean: add a column of significance t values (parameter
estimate/standard error estimate) to <code>siena.table</code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_sig">sig</code></td>
<td>
<p>Boolean: adds symbols (daggers and asterisks) indicating
significance levels for the parameter estimates to <code>siena.table</code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_d">d</code></td>
<td>
<p>The number of decimals places used in <code>siena.table</code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_caption">caption</code></td>
<td>

<p>See documentation for <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_label">label</code></td>
<td>

<p>See documentation for <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_align">align</code></td>
<td>

<p>See documentation for <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_digits">digits</code></td>
<td>

<p>See documentation for <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_display">display</code></td>
<td>

<p>See documentation for <code><a href="xtable.html#topic+xtable">xtable</a></code></p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_nfirst">nfirst</code></td>
<td>
<p>Only relevant for the <code>multiSiena</code> package.</p>
</td></tr>
<tr><td><code id="sienaFit.methods_+3A_...">...</code></td>
<td>

<p>Add extra parameters for  <code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>
here. e.g.
<code>type</code>, <code>file</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>print.sienaFit</code> prints a table containing estimated
parameter values, standard errors and (optionally)
t-statistics for convergence.
</p>
<p>The function <code>summary.sienaFit</code> prints a table containing
estimated parameter values, standard errors and t-statistics for
convergence together with the covariance matrix of the estimates, the
derivative matrix of expected statistics <code>X</code> by parameters, and the
covariance matrix of the expected statistics <code>X</code>.
</p>
<p>The function <code>xtable.sienaFit</code> creates an object of class
<code>xtable.sienaFit</code> which inherits from class <code>xtable</code> and
passes an extra arguments to the <code>print.xtable</code>.
</p>
<p>The function <code>siena.table</code> outputs a latex or html table of
the estimates and standards errors of a <code><a href="#topic+sienaFit">sienaFit</a></code> object.
The table will be written to a file in the current directory and
has a footnote reporting the maximum of the convergence t-ratios.
Endowment or creation effects will be denoted, respectively,
by 'maintenance' or 'creation'.
</p>
<p>See the manual for how to import the html tables easily into MS-Word.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley, Charlotte Greenan, Tom Snijders</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="xtable.html#topic+xtable">xtable</a></code>, <code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>,
<code><a href="#topic+siena07">siena07</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=100, projname=NULL)
mynet1 &lt;- sienaDependent(array(c(tmp3, tmp4), dim=c(32, 32, 2)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE)
ans
summary(ans)
## Not run: 
xtable(ans, type="html", file="ans.html")
siena.table(ans, type="html", tstat=TRUE, d=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='sienaGOF'>Functions to assess goodness of fit for SAOMs</h2><span id='topic+sienaGOF'></span><span id='topic+plot.sienaGOF'></span><span id='topic+descriptives.sienaGOF'></span>

<h3>Description</h3>

<p>The function <code>sienaGOF</code> assesses goodness of fit
for a model specification as represented by an estimated
<code>sienaFit</code> object created by <code><a href="#topic+siena07">siena07</a></code>.
This is done by simulations of auxiliary
statistics, that differ from the statistics used for estimating
the parameters. The auxiliary statistics must be given explicitly.
</p>
<p>The fit is good if the average values
of the auxiliary statistics over many simulation runs are close
to the values observed in the data.
A Monte Carlo test based on the Mahalanobis
distance is used to calculate frequentist <code class="reqn">p</code>-values.
</p>
<p>Plotting functions can be used to diagnose bad fit. There are basic
functions for calculating auxiliary statistics available out of the
box, and the user is invited to create additional ones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaGOF(sienaFitObject, auxiliaryFunction,
        period=NULL, verbose=FALSE, join=TRUE, twoTailed=FALSE,
        cluster=NULL, robust=FALSE, groupName="Data1",
        varName, tested=NULL, iterations=NULL, giveNAWarning=TRUE, ...)
## S3 method for class 'sienaGOF'
plot(x, center=FALSE, scale=FALSE, violin=TRUE, key=NULL,
        perc=.05, period=1, position=4, fontsize=12, ...)
descriptives.sienaGOF(x, center=FALSE, scale=FALSE, perc=.05, key=NULL,
        period=1, showAll=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaGOF_+3A_sienafitobject">sienaFitObject</code></td>
<td>
<p>An object of class <code><a href="#topic+sienaFit">sienaFit</a></code>, produced by a
call to <code><a href="#topic+siena07">siena07</a></code> with <code>returnDeps = TRUE</code> and
<code>maxlike=FALSE</code> (the latter is the default, the former is not);
or a list of such objects; if a list, then the first period
of each <code><a href="#topic+sienaFit">sienaFit</a></code> object will be used.<br />
If this is a list of <code><a href="#topic+sienaFit">sienaFit</a></code> objects,
where <code>sienaFitObject</code> is mentioned below, it refers to the first
element of this list.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_auxiliaryfunction">auxiliaryFunction</code></td>
<td>
<p>Function to be used to calculate
the auxiliary statistics;
this can be a user-defined function, e.g. depending on the <code>sna</code>
or <code>igraph</code> packages.
</p>
<p>See <code>Examples</code> and <code><a href="#topic+sienaGOF-auxiliary">sienaGOF-auxiliary</a></code>
for more information on the signature of this function.
The basic signature is<br />
<code>function(index, data, sims, period, groupName, varName, ...)</code>,
where <code>index</code> is the index of the simulated network,
or <code>NULL</code> if the observed variable is needed;
<code>data</code> is the observed data object from which
the relevant variables are extracted; <code>sims</code> is the list of simulations
returned from <code>siena07</code>; <code>period</code> is the index of the period;
and ... are further arguments (like <code>levls</code> in the examples below
and in <code><a href="#topic+sienaGOF-auxiliary">sienaGOF-auxiliary</a></code>).</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_period">period</code></td>
<td>
<p>Vector of period(s) to be used (may run from 1 to
number of waves - 1). Has an effect only if <code>join=FALSE</code>.<br />
May be only a single number if <code>sienaFitObject</code> is a list of
<code><a href="#topic+sienaFit">sienaFit</a></code> objects.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_verbose">verbose</code></td>
<td>
<p>Whether to print intermediate results. This may give some
peace of mind to the user because calculations can take some time.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_join">join</code></td>
<td>
<p>Boolean: should sienaGOF do tests on all of the periods
individually (<code>FALSE</code>), or sum across periods (<code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_twotailed">twoTailed</code></td>
<td>
<p>Whether to use two tails for calculating <code class="reqn">p</code>-values on
the Monte Carlo test. Recommended for advanced users only,
as it is probably only applicable in rare cases.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_cluster">cluster</code></td>
<td>
<p>Optionally, a <code>parallel</code> or <code>snow</code> cluster to execute
the auxiliary function calculations on.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_robust">robust</code></td>
<td>
<p> Whether to use robust estimation of the covariance matrix.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_groupname">groupName</code></td>
<td>
<p> Name of group; relevant for multi-group data sets.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_varname">varName</code></td>
<td>
<p> Name of dependent variable.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_tested">tested</code></td>
<td>
<p> A logical vector of length <code>sienaFitObject$pp</code>
(number of parameters), indicating a subset of tested parameters;
or <code>NULL</code>, indicating all tested parameters (see below);
or <code>FALSE</code>, indicating nothing is to be tested.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_iterations">iterations</code></td>
<td>
<p> Number of iterations for the goodness of fit calculations.
If <code>NULL</code>, the number of simulated data sets in
<code>sienaFitObject</code>.  </p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_givenawarning">giveNAWarning</code></td>
<td>
<p>If <code>TRUE</code>, a warning is given if any simulated
values are missing.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_x">x</code></td>
<td>
<p> Result from a call to sienaGOF. </p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_center">center</code></td>
<td>
<p> Whether to center the statistics by median during plotting.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_scale">scale</code></td>
<td>
<p> Whether to scale the statistics by range during plotting.
scale=<code>TRUE</code> makes little sense without also
center=<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_violin">violin</code></td>
<td>
<p> Use violin plots (vs. box plots only)? </p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_key">key</code></td>
<td>
<p> Keys in the plot for the levels of the auxiliary statistic
(as given by parameter <code>levls</code> in the examples). </p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_perc">perc</code></td>
<td>
<p> 1 minus confidence level for the confidence bands (two sided). </p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_position">position</code></td>
<td>
<p> Position where the observed value is plotted: 1=under,
2=to the left, 3=above, 4=to the right of the red dot. Can be a single
number from 1 to 4, or a vector with positions for each statistic
(possibly recycled).</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_fontsize">fontsize</code></td>
<td>
<p> Font size for the observed values plotted.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_...">...</code></td>
<td>
<p>Other arguments; for <code>sienaGOF()</code>, e.g., <code>levls</code> as a
parameter for the auxiliary statistic in
<code><a href="#topic+sienaGOF-auxiliary">sienaGOF-auxiliary</a></code>;<br />
for <code>plot.sienaGOF()</code>, e.g., the usual plotting parameters
<code>main</code>, <code>xlab</code>, <code>ylab</code>, <code>cex</code>, <code>cex.main</code>,
<code>cex.lab</code>, and <code>cex.axis</code>.</p>
</td></tr>
<tr><td><code id="sienaGOF_+3A_showall">showAll</code></td>
<td>
<p>If <code>FALSE</code>, drops statistics with variance 0,
like in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to assess the goodness of fit of an estimated stochastic
actor-oriented model for an arbitrarily defined multidimensional auxiliary
statistic. It operates basically by comparing the observed values, at the ends
of the periods, with the simulated values for the ends of the periods.
The differences are assessed by combining the components of the auxiliary
statistic using the Mahalanobis distance.
</p>
<p>For <code>sienaFitObject</code>s that were made for a multi-group data set,
if you are not sure about the <code>groupName</code>s to use, these can be retrieved
by the command <code>"names(dataObject)"</code> (where <code>dataObject</code> is
the data used to produce the <code>sienaFitObject</code>).
Mostly they are <code>"Data1", "Data2"</code>, etc.
</p>
<p>To save computation time, <code>iterations</code> can be set to a lower number
than what is available in <code>sienaFitObject</code>; this will yield
a less precise result.
</p>
<p>The function does not work properly for data sets that include a
<code><a href="#topic+sienaCompositionChange">sienaCompositionChange</a></code> object. If you wish to test the
fit for such a data set, you need (for the purpose of fit assessment only)
to replace the data set by a data set where absent actors are represented
by structural zeros, and estimate the same model for this data set with the
corresponding effects object, and use <code>sienaGOF</code> for this
<code><a href="#topic+sienaFit">sienaFit</a></code> object.
</p>
<p>To achieve comparability between simulated and observed dependent variables,
variables that are missing in the data at the start or end of a period
are replaced by 0 (for tie variables) or NA (for behavior variables).<br />
If there are any differences between structural values at the beginning and
at the end of a period, these are dealt with as follows.
For tie variables that have a structural value at the start of the period,
this value is used to replace the observed value at the end of the period
(for the goodness of fit assessment only).
For tie variables that have a structural value at the end of the period but a
free value value at the start of the period, the reference value for the
simulated values is lacking; therefore, the simulated values at the end of
the period then are replaced by the structural value at the end of the period
(again, for the goodness of fit assessment only).
</p>
<p>The auxiliary statistics documented in <code><a href="#topic+sienaGOF-auxiliary">sienaGOF-auxiliary</a></code>
are calculated for the simulated dependent
variables in Phase 3 of the estimation algorithm,
returned in <code>sienaFitObject</code> because of having used
<code>returnDeps = TRUE</code> in the call to <code><a href="#topic+siena07">siena07</a></code>.
These statistics should be chosen to represent features of the network
that are not explicitly fit by the estimation procedure but can be
considered important properties that the model at hand should represent well.
Some examples are:
</p>

<ul>
<li><p> Outdegree distribution
</p>
</li>
<li><p> Indegree distribution
</p>
</li>
<li><p> Distribution of the dependent behavior variable (if any).
</p>
</li>
<li><p> Distribution of geodesic distances
</p>
</li>
<li><p> Triad census
</p>
</li>
<li><p> Edgewise homophily counts
</p>
</li>
<li><p> Edgewise shared partner counts
</p>
</li>
<li><p> Statistics depending on the combination of network
and behavioral variables.
</p>
</li></ul>

<p>The function is written so that the user can easily define other functions to
capture some other relevant aspects of the network, behaviors, etc.
This is further illustrated in the help page
<code><a href="#topic+sienaGOF-auxiliary">sienaGOF-auxiliary</a></code>.
</p>
<p>We recommend the following heuristic approach to model checking:
</p>

<ol>
<li><p> Check convergence of the estimation.
</p>
</li>
<li><p> Assess goodness of fit (primarily using <code>join=TRUE</code>) on
auxiliary statistics, and if necessary refine the model.
</p>
</li>
<li><p> Assess time heterogeneity by <code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code>
and if there is evidence for time heterogeneity
either modify the base effects or include time dummy terms.
</p>
</li></ol>

<p>No general rules can be given about whether time heterogeneity
(<code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code>) or goodness of fit using <code>sienaGOF</code>
have precedence. This is an explorative issue.
</p>
<p>The <code>summary</code> function will display some useful information
to help with model selection if some effects are set in the effects object
to be fixed and tested. In that case, for all parameters indicated
in the vector <code>tested</code>, a rough estimator is computed for the Mahalanobis
distance that would be obtained at each proposed specification.
This is then given in the <code>summary</code>. This can help guide model selection.
This estimator is called the modified Mahalanobis distance (MMD).
See Lospinoso and Snijders (2019) or the manual for more information.
</p>
<p>The following functions are pre-fabricated for ease of use, and can
be passed in as the <code>auxiliaryFunction</code> with no extra effort;
see <code><a href="#topic+sienaGOF-auxiliary">sienaGOF-auxiliary</a></code> and the examples below.
</p>

<ul>
<li> <p><code><a href="#topic+IndegreeDistribution">IndegreeDistribution</a></code>
</p>
</li>
<li> <p><code><a href="#topic+OutdegreeDistribution">OutdegreeDistribution</a></code>
</p>
</li>
<li> <p><code><a href="#topic+BehaviorDistribution">BehaviorDistribution</a></code>
</p>
</li>
<li> <p><code><a href="#topic+TriadCensus">TriadCensus</a></code>
</p>
</li>
<li> <p><code><a href="#topic+mixedTriadCensus">mixedTriadCensus</a></code>
</p>
</li>
<li> <p><code><a href="#topic+dyadicCov">dyadicCov</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p><code>sienaGOF</code> returns a result of class <code>sienaGOF</code>;
this is a list of elements of class <code>sienaGofTest</code>;
if <code>join=TRUE</code>, the list has length 1; if <code>join=FALSE</code>,
each list element corresponds to a period analyzed;
the list elements are themselves lists again, including the
following elements:
</p>
<table>
<tr><td><code>- sienaFitName</code></td>
<td>
<p>The name of sienaFitObject.</p>
</td></tr>
<tr><td><code>- auxiliaryStatisticName</code></td>
<td>
<p>The name of auxiliaryFunction.</p>
</td></tr>
<tr><td><code>- Observations</code></td>
<td>
<p>The observed values for the auxiliary statistics.</p>
</td></tr>
<tr><td><code>- Simulations</code></td>
<td>
<p>The simulated auxiliary statistics.</p>
</td></tr>
<tr><td><code>- ObservedTestStat</code></td>
<td>
<p>The observed Mahalanobis distance in the data.</p>
</td></tr>
<tr><td><code>- SimulatedTestStat</code></td>
<td>
<p>The Mahalanobis distance for the simulations.</p>
</td></tr>
<tr><td><code>- TwoTailed</code></td>
<td>
<p>Whether the <code class="reqn">p</code>-value corresponds to a one- or
two-tailed Monte Carlo test.</p>
</td></tr>
<tr><td><code>- p</code></td>
<td>
<p>The <code class="reqn">p</code>-value for the observed Mahalanobis distance in the
permutation distribution of the
simulated Mahalanobis distances.</p>
</td></tr>
<tr><td><code>- Rank</code></td>
<td>
<p> Rank of the covariance matrix of the simulated auxiliary
statistics.</p>
</td></tr>
</table>
<p>In addition there are several attributes which give, for model
specifications with fixed-and-tested effects, approximations
to the expected Mahalanobis distance for model specifications where
each of these effects would be added. This is reported
in the <code>summary</code> method. <br />
The <code>plot</code> method makes violin plots or box plots, with superimposed
confidence bands, for the simulated distributions of all elements
of the <code>auxiliaryFunction</code>,
with the observed values indicated by red dots;
but statistics with variance 0 are dropped.
</p>
<p><code>descriptives.sienaGOF</code> returns a matrix giving numerical
information about what is plotted in the <code>plot</code> method:
maximum, upper percentile, mean, median, lower percentile, minimum,
and standard deviation
of the simulated distributions of the auxiliary statistics, the
observed values, and the proportions of simulated values greater
and greater-or-equal than the observed values.
If <code>center=TRUE</code> the median is subtracted
from mean, median, and percentiles; if <code>scale=TRUE</code>
these numbers and the standard deviation
are divided by (maximum - minimum). <br />
If <code>showAll=FALSE</code>, statistics with variance 0 will be dropped.
</p>


<h3>Author(s)</h3>

<p>Josh Lospinoso, modifications by Ruth Ripley and Tom Snijders</p>


<h3>References</h3>

<p>Lospinoso, J.A. and Snijders, T.A.B. (2019,
Goodness of fit for stochastic actor-oriented models.
<em>Methodological Innovations</em>, <b>12</b>:2059799119884282.
</p>
<p>Also see <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+sienaGOF-auxiliary">sienaGOF-auxiliary</a></code>,
<code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mybeh &lt;- sienaDependent(s50a[,1:2], type="behavior")
mydata &lt;- sienaDataCreate(mynet, mybeh)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip)
myeff &lt;- setEffect(myeff, cycle3, fix=TRUE, test=TRUE)
myeff &lt;- setEffect(myeff, transTies, fix=TRUE, test=TRUE)
myalgorithm &lt;- sienaAlgorithmCreate(nsub=1, n3=10, projname=NULL)
# Shorter phases 2 and 3, just for example.
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps=TRUE)
gofi &lt;- sienaGOF(ans, IndegreeDistribution, verbose=TRUE, join=TRUE,
  varName="mynet")
summary(gofi)
plot(gofi)

# Illustration just for showing a case with two dependent networks;
# running time backwards is not meaningful!
mynet1 &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mynet2 &lt;- sienaDependent(array(c(s503, s501), dim=c(50, 50, 2)))
mybeh &lt;- sienaDependent(s50a[,1:2], type="behavior")
mydata &lt;- sienaDataCreate(mynet1, mynet2, mybeh)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip)
myeff &lt;- includeEffects(myeff, recip, name="mynet2")
# Shorter phases 2 and 3, just for example.
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE, returnDeps=TRUE)
gofi &lt;- sienaGOF(ans, IndegreeDistribution, verbose=TRUE, join=TRUE,
  varName="mynet1")
summary(gofi)
plot(gofi)

## Not run: 
(gofi.nc &lt;- sienaGOF(ans, IndegreeDistribution, cumulative=FALSE,
    varName="mynet1"))
# cumulative is an example of "...".
plot(gofi.nc)
descriptives.sienaGOF(gofi.nc)

(gofi2 &lt;- sienaGOF(ans, IndegreeDistribution, varName="mynet2"))
plot(gofi2)

(gofb &lt;- sienaGOF(ans, BehaviorDistribution, varName = "mybeh"))
plot(gofb)

(gofo &lt;- sienaGOF(ans, OutdegreeDistribution, varName="mynet1",
    levls=0:6, cumulative=FALSE))
# levls is another example of "...".
plot(gofo)

## End(Not run)

## A demonstration of using multiple processes
## Not run: 
library(parallel)
(n.clus &lt;- detectCores() - 1)
n.clus &lt;- min(n.clus, 4)  # keep time for other processes
myalgorithm.c &lt;- sienaAlgorithmCreate(nsub=4, n3=1000, seed=1265)
(ans.c &lt;- siena07(myalgorithm.c, data=mydata, effects=myeff, batch=TRUE,
    returnDeps=TRUE, useCluster=TRUE, nbrNodes=n.clus))
gofi.1 &lt;- sienaGOF(ans.c, TriadCensus, verbose=TRUE, varName="mynet1")
cl &lt;- makeCluster(n.clus)
gofi.cl &lt;- sienaGOF(ans.c, TriadCensus, varName="mynet1", cluster=cl)
cl2 &lt;- makeCluster(2)
gofi.cl2 &lt;- sienaGOF(ans.c, TriadCensus, varName="mynet1", cluster=cl2)
# compare simulation times
attr(gofi.1,"simTime")
attr(gofi.cl,"simTime")
attr(gofi.cl2,"simTime")

## End(Not run)

</code></pre>

<hr>
<h2 id='sienaGOF-auxiliary'>Auxiliary functions for goodness of fit assessment by <code><a href="#topic+sienaGOF">sienaGOF</a></code></h2><span id='topic+sienaGOF-auxiliary'></span><span id='topic+sparseMatrixExtraction'></span><span id='topic+networkExtraction'></span><span id='topic+behaviorExtraction'></span><span id='topic+OutdegreeDistribution'></span><span id='topic+IndegreeDistribution'></span><span id='topic+BehaviorDistribution'></span><span id='topic+TriadCensus'></span><span id='topic+mixedTriadCensus'></span><span id='topic+dyadicCov'></span>

<h3>Description</h3>

<p>The functions given here are auxiliary to function <code><a href="#topic+sienaGOF">sienaGOF</a></code>  
which assesses goodness of fit for actor-oriented models.
</p>
<p>The auxiliary functions are, first, some functions of networks or behaviour  
(i.e., statistics) for which the simulated values for the fitted model  
are compared to the observed value; second, some extraction functions  
to extract the observed and simulated networks and/or behaviour  
from the <code><a href="#topic+sienaFit">sienaFit</a></code> object produced by <code><a href="#topic+siena07">siena07</a></code>  
with <code>returnDeps=TRUE</code>.
</p>
<p>These functions are exported here mainly to enable users to write  
their own versions. At the end of this help page some non-exported functions  
are listed. These are not exported because they depend on packages that  
are not in the R base distribution; and to show templates for readers  
wishing to contruct their own functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OutdegreeDistribution(i, obsData, sims, period, groupName, varName,
         levls=0:8, cumulative=TRUE)

IndegreeDistribution(i, obsData, sims, period, groupName, varName,
         levls=0:8, cumulative=TRUE)

BehaviorDistribution(i, obsData, sims, period, groupName, varName,
         levls=NULL, cumulative=TRUE)

TriadCensus(i, obsData, sims, period, groupName, varName, levls=1:16)

mixedTriadCensus(i, obsData, sims, period, groupName, varName)

dyadicCov(i, obsData, sims, period, groupName, varName, dc)

sparseMatrixExtraction(i, obsData, sims, period, groupName, varName)

networkExtraction(i, obsData, sims, period, groupName, varName)

behaviorExtraction(i, obsData, sims, period, groupName, varName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaGOF-auxiliary_+3A_i">i</code></td>
<td>
<p> Index number of simulation to be extracted, ranging from 1 to
<code>length(sims)</code>; if NULL, the data observation will be extracted.</p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_obsdata">obsData</code></td>
<td>
<p> The observed data set to which the model was fitted; normally
this is <code>x$f</code> where <code>x</code> is the <code><a href="#topic+sienaFit">sienaFit</a></code>
object for which the fit is being assessed.</p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_sims">sims</code></td>
<td>
<p> The simulated data sets to be compared with the observed data;
normally this is
<code>x$sims</code> where <code>x</code> is the <code><a href="#topic+sienaFit">sienaFit</a></code>
object for which the fit is being assessed.</p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_period">period</code></td>
<td>
<p> Period for which data and simulations are used (may run from
1 to number of waves - 1).</p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_groupname">groupName</code></td>
<td>
<p> Name of group; relevant for multi-group data sets;
defaults in <code><a href="#topic+sienaGOF">sienaGOF</a></code> to &quot;<code>Data1</code>&quot;.</p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_varname">varName</code></td>
<td>
<p> Name of dependent variable. </p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_levls">levls</code></td>
<td>
<p> Levels used as values of the auxiliary statistic.
For <code>BehaviorDistribution</code>, this defaults to the observed
range of values.</p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_cumulative">cumulative</code></td>
<td>
<p> Are the distributions to be considered as raw or
cumulative (&lt;=) distributions?</p>
</td></tr>
<tr><td><code id="sienaGOF-auxiliary_+3A_dc">dc</code></td>
<td>
<p>Dyadic covariate: either a matrix with dimensions
<code class="reqn">n \times n</code>; or, as period-dependent values,
an array with dimensions <code class="reqn">n \times n \times (M-1)</code>;
where <code class="reqn">n</code> is the number of actors and <code class="reqn">M</code> is the number of waves.
There may be more time points, but those after <code class="reqn">(M-1)</code> will not be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The statistics should be chosen to represent features of the network
that are not explicitly fit by the estimation procedure but can be
considered important properties that the model at hand should represent well.
The three given here are far from a complete set;
they will be supplemented in due time by statistics depending on networks and
behavior jointly.
The examples below give a number of other statistics, using the packages
<code>sna</code> and <code>igraph</code>.
</p>
<p>The <code>levls</code> parameter must be adapted to the range of values that is
considered important. For indegrees and outdegrees, the whole range should
usually be covered. If the range is large, which could be the case, e.g.,
for indegrees of two-mode networks where the second mode has few nodes,
think about the possibility of making a selection such as
<code>levls=5*(0:20)</code> or <code>levls=c(0:4,5*(1:20))</code>;
which in most cases will make sense only if <code>cumulative=TRUE</code>.
</p>
<p>The method signature for the auxiliary statistics generally is<br />
<code>function(i, obsData, sims, period, groupName, varName, ...)</code>.
For constructing new auxiliary statistics, it is helpful to
study the code of <code>OutdegreeDistribution</code>, <code>IndegreeDistribution</code>,
and <code>BehaviorDistribution</code> and of the example functions below.
</p>
<p><code>TriadCensus</code> returns the distribution of the Holland-Leinhardt triad
census according to the algorithm by Batagelj and Mrvar
(implementation by Parimalarangan, Slota, and Madduri). An alternative is the
<code>TriadCensus.sna</code> function mentioned below, from package <code>sna</code>, which
gives the same results. Here the <code>levls</code> parameter can be used to exclude
some triads, e.g., for non-directed networks.<br />
The Batagelj-Mrvar algorithm is optimized for sparse, large graphs and may be
much faster than the procedure implemented in <code>sna</code>. For dense graphs
the <code>sna</code> procedure may be faster.
</p>
<p><code>dyadicCov</code> assumes that <code>dc</code> is a categorical dyadic variable,
and returns the frequencies of the non-zero values for realized ties.
Since zero values of dc are not counted, it may be advisable
to code dc so that all non-diagonal values are non-zero,
and all diagonal values are zero.
</p>


<h3>Value</h3>

<p><code>OutdegreeDistribution</code> returns a named vector, the distribution
of the observed or simulated outdegrees for the values in <code>levls</code>.
</p>
<p><code>IndegreeDistribution</code> returns a named vector, the distribution
of the observed or simulated indegrees for the values in <code>levls</code>.
</p>
<p><code>BehaviorDistribution</code> returns a named vector, the distribution of the
observed or simulated behavioral variable for the values in <code>levls</code>.
</p>
<p><code>TriadCensus</code> returns a named vector, the distribution of the
Holland-Leinhardt triad census according to the algorithm by
Batagelj and Mrvar.
</p>
<p><code>mixedTriadCensus</code> returns a named vector, the distribution of the
mixed triad census of Hollway, Lomi, Pallotti, and Stadtfeld (2017).
See their Figure 1 for the meaning of the codes.
In this figure, ties between the bottom nodes are for the first network,
ties from the bottom to the top nodes are for the second network.
The mixed triad census can be used for pairs of dependent networks of which
the first must be one-mode and the second can be one-mode or two-mode.
If the second is one-mode, the set of triads considered is only a subset
of all mixed triads, and ties in the figure are directed upward;
existence of other ties is not considered.
</p>
<p><code>dyadicCov</code> returns a named vector, the frequencies of the non-missing
non-zero values dc(ego,alter) of the observed or simulated (ego,alter) ties.
</p>
<p><code>sparseMatrixExtraction</code> returns the simulated network as a
<code>"TsparseMatrix"</code>;
this is the virtual class for sparse numeric matrices
represented by triplets in the <code>Matrix</code> package.<br />
Tie variables for ordered pairs with a missing value for wave=period or
period+1 are zeroed; note that this also is done
in <code>RSiena</code> for calculation of target statistics.
Tie variables that are structurally determined at the beginning of a period
are used to replace observed values at the end of the period;
tie variables that are structurally determined at the end, but not
the beginning, of a period are used to replace
simulated values at the end of the period.
<br />
To treat the objects returned by this function as regular matrices,
it is necessary to attach the <code>Matrix</code> package in your session.
</p>
<p><code>networkExtraction</code> returns the network as an edge list of class
<code>network</code> according to the <code>network</code> package
(used for package <code>sna</code>).
Missing values and structural values are treated as in
<code>sparseMatrixExtraction</code>, see above.
</p>
<p><code>behaviorExtraction</code> returns the dependent behavior
variable as an integer vector.
Values for actors with a missing value for wave=period or period+1 are
transformed to <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Josh Lospinoso, Tom Snijders</p>


<h3>References</h3>

<p>Batagelj, V., and Mrvar, A. (2001),
A subquadratic triad census algorithm for large sparse networks with small
maximum degree. <em>Social Networks</em>, <b>23</b>, 237&ndash;243.
</p>
<p>Holland, P.W., and Leinhardt, S. (1976),
Local structure in social networks. <em>Sociological Methodology</em>, <b>6</b>, 1&ndash;45.
</p>
<p>Hollway, J., Lomi, A., Pallotti, F., and Stadtfeld, C. (2017),
Multilevel social spaces: The network dynamics of organizational fields.
<em>Network Science</em>, <b>5</b>, 187&ndash;212.
</p>
<p>Lospinoso, J.A. and Snijders, T.A.B. (2019),
Goodness of fit for stochastic actor-oriented models.
<em>Methodological Innovations</em>, <b>12</b>:2059799119884282.
</p>
<p>Parimalarangan S., Slota, G.M., and Madduri, K. (2017),
Fast parallel graph triad census and triangle counting on shared-memory
platforms, <em>2017 IEEE International Parallel and Distributed Processing
Symposium Workshops (IPDPSW)</em>, Lake Buena Vista, FL, pp. 1500-1509.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+sienaGOF">sienaGOF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>### For use out of the box:

mynet1 &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mybeh &lt;- sienaDependent(s50a[,1:2], type="behavior")
mycov &lt;- c(rep(1:3,16),1,2) # artificial, just for trying
mydycov &lt;- matrix(rep(1:5, 500), 50, 50) # also artificial, just for trying
mydata &lt;- sienaDataCreate(mynet1, mybeh)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTies, cycle3)
# Shorter phases 2 and 3, just for example:
myalgorithm &lt;- sienaAlgorithmCreate(nsub=1, n3=50, seed=122, projname=NULL)
(ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, returnDeps=TRUE,
   batch=TRUE))

# NULL for the observations:
OutdegreeDistribution(NULL, ans$f, ans$sims, period=1, groupName="Data1",
  levls=0:7, varName="mynet1")
dyadicCov(NULL, ans$f, ans$sims, period=1, groupName="Data1",
  dc=mydycov, varName="mynet1")
# An arbitrary selection for simulation run i:
IndegreeDistribution(5, ans$f, ans$sims, period=1, groupName="Data1",
  varName="mynet1")
BehaviorDistribution(20, ans$f, ans$sims, period=1, groupName="Data1",
  varName="mybeh")
sparseMatrixExtraction(50, ans$f, ans$sims, period=1, groupName="Data1",
  varName="mynet1")
networkExtraction(40, ans$f, ans$sims, period=1, groupName="Data1",
  varName="mynet1")
behaviorExtraction(50, ans$f, ans$sims, period=1, groupName="Data1",
  varName="mybeh")

gofi &lt;- sienaGOF(ans, IndegreeDistribution, verbose=TRUE, join=TRUE,
  varName="mynet1")
gofi
plot(gofi)

(gofo &lt;- sienaGOF(ans, OutdegreeDistribution, verbose=TRUE, join=TRUE,
    varName="mynet1", cumulative=FALSE))
# cumulative is an example of "\dots".
plot(gofo)

(gofdc &lt;- sienaGOF(ans, dyadicCov, verbose=TRUE, join=TRUE,
    dc=mydycov, varName="mynet1"))
plot(gofdc)

# How to use dyadicCov for ego-alter combinations of a monadic variable:
mycov.egoalter &lt;- outer(10*mycov, mycov ,'+')
diag(mycov.egoalter) &lt;- 0
dim(mycov.egoalter) # 50 * 50 matrix
# This is a dyadic variable indicating ego-alter combinations of mycov.
# This construction works since mycov has integer values
# not outside the interval from 1 to 9 (actually, only 1 to 3).
# All cells of this matrix contain a two-digit number,
# left digit is row (ego) value, right digit is column (alter) value.
# See the top left part of the matrix:
mycov.egoalter[1:10,1:12]
# The number of values is the square of the number of values of mycov;
# therefore, unwise to do this for a monadic covariate with more than 5 values.
gof.mycov &lt;- sienaGOF(ans, dyadicCov, verbose=TRUE, varName="mynet1",
    dc=mycov.egoalter)
plot(gof.mycov)
descriptives.sienaGOF(gof.mycov, showAll=TRUE)

(gofb &lt;- sienaGOF(ans, BehaviorDistribution, varName = "mybeh",
    verbose=TRUE, join=TRUE, cumulative=FALSE))
plot(gofb)

(goftc &lt;- sienaGOF(ans, TriadCensus, verbose=TRUE, join=TRUE,
    varName="mynet1"))
plot(goftc, center=TRUE, scale=TRUE)
# For this type of auxiliary statistics
# it is advisable in the plot to center and scale.
# note the keys at the x-axis (widen the plot if they are not clear).
descriptives.sienaGOF(goftc)

### The mixed triad census for co-evolution of one-mode and two-mode networks:
actors &lt;- sienaNodeSet(50, nodeSetName="actors")
activities &lt;- sienaNodeSet(20, nodeSetName="activities")
onemodenet &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)),
                            nodeSet="actors")
# Not meaningful, just for example:
twomodenet &lt;- sienaDependent(array(c(s502[1:50, 1:20], s503[1:50, 1:20]),
                                                        dim=c(50, 20, 2)),
                            type= "bipartite", nodeSet=c("actors", "activities"))
twodata &lt;- sienaDataCreate(onemodenet, twomodenet,
                        nodeSets=list(actors, activities))
twoeff &lt;- getEffects(twodata)
twoeff &lt;- includeEffects(twoeff, outActIntn, name="onemodenet",
                            interaction1="twomodenet")
twoeff &lt;- includeEffects(twoeff, outActIntn, name="twomodenet",
                            interaction1="onemodenet")
twoeff &lt;- includeEffects(twoeff, from, name="onemodenet",
                            interaction1="twomodenet")
twoeff &lt;- includeEffects(twoeff, to, name="twomodenet",
                            interaction1="onemodenet")
twoeff
# Shorter phases 2 and 3, just for example:
twoalgorithm &lt;- sienaAlgorithmCreate(projname=NULL, nsub=1, n3=50,
                                     seed=5634)
(ans &lt;- siena07(twoalgorithm, data=twodata, effects=twoeff, returnDeps=TRUE,
   batch=TRUE))
(gof.two &lt;- sienaGOF(ans, mixedTriadCensus,
                        varName=c("onemodenet", "twomodenet"), verbose=TRUE))
plot(gof.two, center=TRUE, scale=TRUE)

## Not run: 
### Here come some useful functions for building your own auxiliary statistics:
### First an extraction function.

# igraphNetworkExtraction extracts simulated and observed networks
# from the results of a siena07 run.
# It returns the network as an edge list of class "graph"
# according to the igraph package.
# Ties for ordered pairs with a missing value for wave=period or period+1
# are zeroed;
# note that this also is done in RSiena for calculation of target statistics.
# However, changing structurally fixed values are not taken into account.
igraphNetworkExtraction &lt;- function(i, data, sims, period, groupName, varName) {
  require(igraph)
  dimsOfDepVar &lt;- attr(data[[groupName]]$depvars[[varName]], "netdims")[1]
  missings &lt;- is.na(data[[groupName]]$depvars[[varName]][,,period]) |
    is.na(data[[groupName]]$depvars[[varName]][,,period+1])
  if (is.null(i)) {
    # sienaGOF wants the observation:
    original &lt;- data[[groupName]]$depvars[[varName]][,,period+1]
    original[missings] &lt;- 0
    returnValue &lt;- graph.adjacency(original)
  }
  else
  {
    missings &lt;- graph.adjacency(missings)
    #sienaGOF wants the i-th simulation:
    returnValue &lt;- graph.difference(
      graph.empty(dimsOfDepVar) +
        edges(t(sims[[i]][[groupName]][[varName]][[period]][,1:2])),
      missings)
  }
  returnValue
}

### Then some auxiliary statistics.

# GeodesicDistribution calculates the distribution of non-directed
# geodesic distances; see ?sna::geodist
# The default for \code{levls} reflects that geodesic distances larger than 5
# do not differ appreciably with respect to interpretation.
# Note that the levels of the result are named;
# these names are used in the \code{plot} method.
GeodesicDistribution &lt;- function (i, data, sims, period, groupName,
  varName, levls=c(1:5,Inf), cumulative=TRUE, ...) {
  x &lt;- networkExtraction(i, data, sims, period, groupName, varName)
  require(network)
  require(sna)
  a &lt;- sna::geodist(symmetrize(x))$gdist
  if (cumulative)
  {
    gdi &lt;- sapply(levls, function(i){ sum(a&lt;=i) })
  }
  else
  {
    gdi &lt;- sapply(levls, function(i){ sum(a==i) })
  }
  names(gdi) &lt;- as.character(levls)
  gdi
}

# Holland and Leinhardt Triad Census from sna; see ?sna::triad.census.
# For undirected networks, call this with levls=1:4
TriadCensus.sna &lt;- function(i, data, sims, period, groupName, varName, levls=1:16){
  unloadNamespace("igraph") # to avoid package clashes
  require(network)
  require(sna)
  x &lt;- networkExtraction(i, data, sims, period, groupName, varName)
  if (network.edgecount(x) &lt;= 0){x &lt;- symmetrize(x)}
  # because else triad.census(x) will lead to an error
  tc &lt;- sna::triad.census(x)[levls]
  # names are transferred automatically
  tc
}

# Holland and Leinhardt Triad Census from igraph; see ?igraph::triad_census.
TriadCensus.i &lt;- function(i, data, sims, period, groupName, varName){
  unloadNamespace("sna") # to avoid package clashes
  require(igraph)
  x &lt;- igraphNetworkExtraction(i, data, sims, period, groupName, varName)
# suppressWarnings is used because else warnings will be generated
# when a generated network happens to be symmetric.
  setNames(suppressWarnings(triad_census(x)),
            c("003", "012", "102", "021D","021U", "021C", "111D", "111U",
            "030T", "030C", "201",  "120D", "120U", "120C", "210", "300"))
}

# CliqueCensus calculates the distribution of the clique census
# of the symmetrized network; see ?sna::clique.census.
CliqueCensus&lt;-function (i, obsData, sims, period, groupName, varName, levls = 1:5){
  require(sna)
  x &lt;- networkExtraction(i, obsData, sims, period, groupName, varName)
  cc0 &lt;- sna::clique.census(x, mode='graph', tabulate.by.vertex = FALSE,
    enumerate=FALSE)[[1]]
  cc &lt;- 0*levls
  names(cc) &lt;- as.character(levls)
  levels.used &lt;- as.numeric(intersect(names(cc0), names(cc)))
  cc[levels.used] &lt;- cc0[levels.used]
  cc
}

# Distribution of Bonacich eigenvalue centrality; see ?igraph::evcent.
EigenvalueDistribution &lt;- function (i, data, sims, period, groupName, varName,
  levls=c(seq(0,1,by=0.125)), cumulative=TRUE){
  require(igraph)
  x &lt;- igraphNetworkExtraction(i, data, sims, period, groupName, varName)
  a &lt;- igraph::evcent(x)$vector
  a[is.na(a)] &lt;- Inf
  lel &lt;- length(levls)
  if (cumulative)
  {
    cdi &lt;- sapply(2:lel, function(i){sum(a&lt;=levls[i])})
  }
  else
  {
    cdi &lt;- sapply(2:lel, function(i){
      sum(a&lt;=levls[i]) - sum(a &lt;= levls[i-1])})
  }
  names(cdi) &lt;- as.character(levls[2:lel])
  cdi
}

## Finally some examples of the three auxiliary statistics constructed above.
mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mybeh &lt;- sienaDependent(s50a, type="behavior")
mydata &lt;- sienaDataCreate(mynet1, mybeh)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip, cycle3)
myeff &lt;- includeEffects(myeff, outdeg, name="mybeh", interaction1="mynet1")
myeff &lt;- includeEffects(myeff,  outdeg, name="mybeh", interaction1="mynet1")
# Shorter phases 2 and 3, just for example:
myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=200, seed=765, projname=NULL)
(ans2 &lt;- siena07(myalgorithm, data=mydata, effects=myeff, returnDeps=TRUE,
   batch=TRUE))
gofc &lt;- sienaGOF(ans2, EigenvalueDistribution, varName="mynet1",
  verbose=TRUE, join=TRUE)
plot(gofc)
descriptives.sienaGOF(gofc, showAll=TRUE)

goftc &lt;- sienaGOF(ans2, TriadCensus, varName="mynet1", verbose=TRUE, join=TRUE)
plot(goftc, center=TRUE, scale=TRUE)
# For this type of auxiliary statistics
# it is advisable in the plot to center and scale.
# note the keys at the x-axis; these names are given by sna::triad.census
descriptives.sienaGOF(goftc)
round(descriptives.sienaGOF(goftc))

gofgd &lt;- sienaGOF(ans2, GeodesicDistribution, varName="mynet1",
  verbose=TRUE, join=TRUE, cumulative=FALSE)
plot(gofgd)
# and without infinite distances:
gofgdd &lt;- sienaGOF(ans2, GeodesicDistribution, varName="mynet1",
  verbose=TRUE, join=TRUE, levls=1:7, cumulative=FALSE)
plot(gofgdd)

## End(Not run)
</code></pre>

<hr>
<h2 id='sienaGroupCreate'>Function to group together several Siena data objects </h2><span id='topic+sienaGroupCreate'></span><span id='topic+sienaGroup'></span>

<h3>Description</h3>

<p>Creates an object of class &quot;sienaGroup&quot; from a list of  
Siena data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaGroupCreate(objlist, singleOK = FALSE, getDocumentation=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaGroupCreate_+3A_objlist">objlist</code></td>
<td>
<p> List of objects of class <code>siena</code>. </p>
</td></tr>
<tr><td><code id="sienaGroupCreate_+3A_singleok">singleOK</code></td>
<td>
<p> Boolean: is it OK to only have one object?</p>
</td></tr>
<tr><td><code id="sienaGroupCreate_+3A_getdocumentation">getDocumentation</code></td>
<td>
<p>Flag to allow documentation of internal
functions, not for use by users.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a Siena group object from several Siena data
objects ('groups'), all of which use networks, covariates and actor sets
with the same names. The variables must correspond exactly
between all data objects; the numbers of waves may differ.
It can be used as data input to <code><a href="#topic+siena07">siena07</a></code> for the
multigroup option.
Also used internally for convenience with a single Siena data object.
</p>
<p>Each covariate should either be centered in all groups, or non-centered
in all groups.
Centered actor covariates are re-centered at the overall mean.
This means that the original values are used, and the overall
mean of all non-missing observations is subtracted. Note that this implies
that group-dependent variables that are constant for all actors in each
group, can be used as centered actor covariates.
</p>
<p>For combining two-wave with more-wave groups in one group object,
covariates that are changing covariates for the more-wave groups have to
be specified as changing covariates also for the two-wave groups.
This can be done by specifying them with values for the two waves;
for actor covariates this will be by using an <code class="reqn">n \times 2</code> matrix,
for dyadic covariates an <code class="reqn">n \times n \times 2</code> array
(or <code class="reqn">n \times m \times 2</code> for the two-mode case).
The values for the second wave should be identical to those for the
first wave (they will be used only for centering operations).
</p>
<p>For later use in <code><a href="#topic+siena07">siena07</a></code>,
it will often (but not always...) be helpful when creating the
Siena data objects in <code>objlist</code>
to use <code>allowOnly=FALSE</code> in the call of
<code><a href="#topic+sienaDependent">sienaDependent</a></code>; see the help page for this function.
</p>
<p>If there are multiple dependent networks, it may be necessary to run
<code><a href="#topic+sienaDataConstraint">sienaDataConstraint</a></code> before <code>sienaGroupCreate</code>
to ensure that these constraints are equal for all groups.
</p>


<h3>Value</h3>

<p>An object of class <code>sienaGroup</code>; this is a list
containing the input objects, with attributes:
</p>
<table>
<tr><td><code>netnames</code></td>
<td>
<p>names of the dependent variables in each set</p>
</td></tr>
<tr><td><code>symmetric</code></td>
<td>
<p>vector of booleans, one for each dependent
variable. TRUE if all occurrences of the network are symmetric.</p>
</td></tr>
<tr><td><code>structural</code></td>
<td>
<p>vector of booleans, indicating whether structurally
fixed values occur in this network</p>
</td></tr>
<tr><td><code>allUpOnly</code></td>
<td>
<p>vector of booleans, indicating whether changes are
all upwards in all the occurrences of this network</p>
</td></tr>
<tr><td><code>allDownOnly</code></td>
<td>
<p>similar to previous, but for downward changes</p>
</td></tr>
<tr><td><code>anyUpOnly</code></td>
<td>
<p>vector of booleans, indicating whether changes are
all upwards in any of the occurrences of this network</p>
</td></tr>
<tr><td><code>anyDownOnly</code></td>
<td>
<p>similar to previous, but for downward changes</p>
</td></tr>
<tr><td><code>types</code></td>
<td>
<p>vector of network types of the dependent variables</p>
</td></tr>
<tr><td><code>observations</code></td>
<td>
<p>Total number of periods to process</p>
</td></tr>
<tr><td><code>periodNos</code></td>
<td>
<p>Sequence of numbers of periods which are not skipped
in multigroup processing</p>
</td></tr>
<tr><td><code>netnodeSets</code></td>
<td>
<p>list of names of the node sets corresponding to the
dependent variables</p>
</td></tr>
<tr><td><code>cCovars</code></td>
<td>
<p>names of the constant covariates, if any</p>
</td></tr>
<tr><td><code>vCovars</code></td>
<td>
<p>names of the changing  covariates, if any</p>
</td></tr>
<tr><td><code>dycCovars</code></td>
<td>
<p>names of the constant dyadic covariates, if any</p>
</td></tr>
<tr><td><code>dyvCovars</code></td>
<td>
<p>names of the changing dyadic covariates, if any</p>
</td></tr>
<tr><td><code>ccnodeSets</code></td>
<td>
<p>list of the names of the node sets corresponding to
the constant covariates</p>
</td></tr>
<tr><td><code>cvnodeSets</code></td>
<td>
<p>list of the names of the node sets corresponding to
the changing covariates</p>
</td></tr>
<tr><td><code>dycnodeSets</code></td>
<td>
<p>list of the names of the node sets corresponding to
the constant dyadic covariates</p>
</td></tr>
<tr><td><code>dyvcnodeSets</code></td>
<td>
<p>list of the names of the node sets corresponding to
the changing dyadic covariates</p>
</td></tr>
<tr><td><code>compositionChange</code></td>
<td>
<p>boolean: any composition change at all?</p>
</td></tr>
<tr><td><code>exooptions</code></td>
<td>
<p>named vector of composition change options for the
node sets</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>Either from the input objects or &quot;Data1&quot;, &quot;Data2&quot; etc</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>&quot;sienaGroup&quot; inheriting from &quot;siena&quot;</p>
</td></tr>
<tr><td><code>balmean</code></td>
<td>
<p>vector of means for balance calculations</p>
</td></tr>
<tr><td><code>bRange</code></td>
<td>
<p>vector of difference between maximum and minimum values
for behavior variables, NA for other dependent variables</p>
</td></tr>
<tr><td><code>behRange</code></td>
<td>
<p>matrix of  maximum and minimum values
for behavior variables, NA for other dependent variables</p>
</td></tr>
<tr><td><code>bSim</code></td>
<td>
<p>vector of similarity means for behavior variables, NA for
other dependent variables</p>
</td></tr>
<tr><td><code>bPoszvar</code></td>
<td>
<p>vector of booleans indicating positive variance for
behavior variables. NA for other dependent variables</p>
</td></tr>
<tr><td><code>bMoreThan2</code></td>
<td>
<p>vector of booleans indicating whether the behavior
variables take more than 2 distinct values</p>
</td></tr>
<tr><td><code>cCovarPoszvar</code></td>
<td>
<p>vector of booleans indicating positive variance for
constant covariates</p>
</td></tr>
<tr><td><code>cCovarMoreThan2</code></td>
<td>
<p>vector of booleans indicating whether the
constant covariates take more than 2 distinct values</p>
</td></tr>
<tr><td><code>cCovarRange</code></td>
<td>
<p>vector of difference between maximum and minimum
values for constant covariates</p>
</td></tr>
<tr><td><code>cCovarRange2</code></td>
<td>
<p>matrix of maximum and minimum values for constant
covariates</p>
</td></tr>
<tr><td><code>cCovarSim</code></td>
<td>
<p>vector of similarity means for constant covariates</p>
</td></tr>
<tr><td><code>cCovarMean</code></td>
<td>
<p>vector of means for constant covariates</p>
</td></tr>
<tr><td><code>vCovarRange</code></td>
<td>
<p>vector of difference between maximum and minimum
values for changing covariates</p>
</td></tr>
<tr><td><code>vCovarSim</code></td>
<td>
<p>vector of similarity means for changing covariates</p>
</td></tr>
<tr><td><code>vCovarMoreThan2</code></td>
<td>
<p>vector of booleans indicating whether the
changing covariates take more than 2 distinct values</p>
</td></tr>
<tr><td><code>vCovarPoszvar</code></td>
<td>
<p>vector of booleans indicating positive variance for
changing covariates</p>
</td></tr>
<tr><td><code>vCovarMean</code></td>
<td>
<p>vector of means for changing covariates</p>
</td></tr>
<tr><td><code>dycCovarMean</code></td>
<td>
<p>vector of means for constant dyadic covariates</p>
</td></tr>
<tr><td><code>dycCovarRange</code></td>
<td>
<p>vector of ranges for constant dyadic covariates</p>
</td></tr>
<tr><td><code>dycCovarRange2</code></td>
<td>
<p>matrix of maximum and minimum values
for constant dyadic covariates</p>
</td></tr>
<tr><td><code>dyvCovarRange</code></td>
<td>
<p>vector of ranges for changing dyadic covariates</p>
</td></tr>
<tr><td><code>dyvCovarMean</code></td>
<td>
<p>vector of means for changing dyadic covariates</p>
</td></tr>
<tr><td><code>anyMissing</code></td>
<td>
<p>vector of booleans, one for each dependent variable,
indicating the presence of any missing values</p>
</td></tr>
<tr><td><code>netRanges</code></td>
<td>
<p>matrix of maximum and minimum values for dependent
networks, NA for behavior variables</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Ruth Ripley, Modification by Tom Snijders </p>


<h3>References</h3>

<p>See the Section on Multi-group Siena analysis in the manual
available from <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>.</p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+sienaDataConstraint">sienaDataConstraint</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>Group1 &lt;- sienaDependent(array(c(N3401, HN3401), dim=c(45, 45, 2)))
Group3 &lt;- sienaDependent(array(c(N3403, HN3403), dim=c(37, 37, 2)))
Group4 &lt;- sienaDependent(array(c(N3404, HN3404), dim=c(33, 33, 2)))
Group6 &lt;- sienaDependent(array(c(N3406, HN3406), dim=c(36, 36, 2)))
# Illustration of the use of group-level variables:
# dum1 is a dummy variable for group 1,
# having constant value 1 in group 1, and constant value 0 in the other groups.
dum1.1  &lt;- coCovar(c(rep(1,45)), warn = FALSE)
dum1.3  &lt;- coCovar(c(rep(0,37)), warn = FALSE)
dum1.4  &lt;- coCovar(c(rep(0,33)), warn = FALSE)
dum1.6  &lt;- coCovar(c(rep(0,36)), warn = FALSE)
# In a similar way, dummies for the other groups can be defined.
dataset.1 &lt;- sienaDataCreate(Friends = Group1, dum1 = dum1.1)
dataset.3 &lt;- sienaDataCreate(Friends = Group3, dum1 = dum1.3)
dataset.4 &lt;- sienaDataCreate(Friends = Group4, dum1 = dum1.4)
dataset.6 &lt;- sienaDataCreate(Friends = Group6, dum1 = dum1.6)
(FourGroups &lt;- sienaGroupCreate(list(dataset.1, dataset.3, dataset.4,
                                     dataset.6)))
class(FourGroups)
# The main effect of the group-level variable is the \code{egoX} effect:
myeff &lt;- getEffects(FourGroups)
(myeff &lt;- includeEffects(myeff, egoX, interaction1 = "dum1"))
</code></pre>

<hr>
<h2 id='sienaNodeSet'>Function to create a node set </h2><span id='topic+sienaNodeSet'></span>

<h3>Description</h3>

<p>Creates a Siena node set which can be used as the nodes in a  
Siena network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaNodeSet(n, nodeSetName="Actors", names=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaNodeSet_+3A_n">n</code></td>
<td>
<p>integer, size of set.</p>
</td></tr>
<tr><td><code id="sienaNodeSet_+3A_nodesetname">nodeSetName</code></td>
<td>
<p>character string naming the node set.</p>
</td></tr>
<tr><td><code id="sienaNodeSet_+3A_names">names</code></td>
<td>
<p>optional character string vector of length n of the names of the
nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is important for data sets having more than one node set,
but not otherwise.
</p>


<h3>Value</h3>

<p>Returns a Siena node set, an integer vector, possibly with names, plus the
attributes, class equal to &quot;sienaNodeSet&quot;, and nodeSetName equal to
the argument nodeSetName.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley </p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDependent">sienaDependent</a></code>, <code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>senders &lt;- sienaNodeSet(50, nodeSetName="senders")
receivers &lt;- sienaNodeSet(30, nodeSetName="receivers")
senders.attribute &lt;- coCovar(rep(1:10, each=5), nodeSet="senders")
receivers.attribute &lt;- coCovar(rep(1:5, each=6), nodeSet="receivers")
mynet &lt;- sienaDependent(array(c(s501[,1:30], s502[,1:30]), dim=c(50, 30, 2)),
      nodeSet=c("senders", "receivers"))
(mydata &lt;- sienaDataCreate(mynet, senders.attribute, receivers.attribute,
      nodeSets=list(senders, receivers)))
</code></pre>

<hr>
<h2 id='sienaTimeTest'>Functions to assess and account for time heterogeneity of parameters</h2><span id='topic+sienaTimeTest'></span>

<h3>Description</h3>

<p>Takes a <code>sienaFit</code> object estimated by Method of Moments,  
and tests for time heterogeneity by the addition of interactions with  
time dummy variables at waves <code>m=2...(M-1)</code>.  
The test used is the score-type test of Schweinberger (2012).
</p>
<p>Tests for joint significance, parameter-wise significance,  
period-wise significance, individual significance, and one-step   
estimates of the unrestricted model parameters are returned in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sienaTimeTest(sienaFit, effects=NULL, excludedEffects=NULL, condition=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sienaTimeTest_+3A_sienafit">sienaFit</code></td>
<td>
<p> A <code>sienaFit</code> object returned by <code>siena07</code>. </p>
</td></tr>
<tr><td><code id="sienaTimeTest_+3A_effects">effects</code></td>
<td>
<p>Optional vector of effect numbers to test. Use the
numbering on the print of the sienaFit object.</p>
</td></tr>
<tr><td><code id="sienaTimeTest_+3A_excludedeffects">excludedEffects</code></td>
<td>
<p>Optional vector of effect numbers
for which time heterogeneity is not to be tested. Use the
numbering on the print of the sienaFit object.</p>
</td></tr>
<tr><td><code id="sienaTimeTest_+3A_condition">condition</code></td>
<td>
<p> Whether to orthogonalize effect-wise score-type tests
and individual significance tests against estimated effects
and un-estimated dummy terms, or just against estimated effects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test follows the score type test of Schweinberger (2012) as
elaborated by Lospinoso et al. (2011) by using statistics already
calculated at each wave to obtain vectors of partitioned moment
functions corresponding to a restricted model (the model in the
<code>sienaFit</code> object; used as null hypothesis) and an
unrestricted model (which contains dummies for waves
<code>m=2...(M-1)</code>; used as alternative hypothesis).
</p>
<p><code>condition=TRUE</code> leads to a rough-and-easy approximation to
controlling the mentioned tests also for the unestimated effects.
</p>
<p>After assessing time heterogeneity, effects objects can be modified by
adding numbers of all or some periods to the <code>timeDummy</code> column.
This is facilitated by the <code><a href="#topic+includeTimeDummy">includeTimeDummy</a></code> function.
For an effects object in which the <code>timeDummy</code> column
of some of the included effects includes some or all period numbers,
interactions of those effects  with time dummies for the indicated
periods will also be estimated.
</p>
<p>An alternative to the use of <code><a href="#topic+includeTimeDummy">includeTimeDummy</a></code>
is to define time-dependent actor covariates (dummy variables or other
functions of wave number that are the same for all actors),
include these in the data set through <code><a href="#topic+sienaAlgorithmCreate">sienaAlgorithmCreate</a></code>,
and include interactions of other effects with ego effects of these
time-dependent actor covariates by <code><a href="#topic+includeInteraction">includeInteraction</a></code>.
This is illustrated in an example below.
Using <code><a href="#topic+includeTimeDummy">includeTimeDummy</a></code> is easier;
using self-defined interactions with time-dependent variables
gives more control.
</p>
<p>If you wish to use this function with <code>sienaFit</code> objects that use the
finite differences method of derivative estimation, or which use maximum
likelihood estimation, you must request the derivatives to be returned
by wave using the <code>byWave=TRUE</code> option for <code><a href="#topic+siena07">siena07</a></code>.
</p>
<p>Effects leading to dummy interactions that are collinear with the
model originally fitted, after excluding the effects mentioned,
will be automatically excluded from the time heterogeneity testing.
</p>
<p>If <code>sienaTimeTest</code> gives errors that there are too
many collinear effects, run it with a smaller set of effects as specified
by the <code>effects</code> parameter.
For example, if the model has 40 effects of which the
first 8 are rate parameters and therefore uninteresting,
and there is such an error message, try <code>effects=9:30</code>;
if that still does not work, decrease the upper limit of 30, if it does work
increase it, to find the largest possible set of effects for which
heterogeneity assessment still is possible; then as a next step
try the remaining effects in a similar way.
</p>
<p>Also if the execution is time-consuming, e.g., for a multi-group
<code>sienaFit</code> object with many groups and many effects,
it can be helpful to carry out the function in smaller subsets of effects.
</p>


<h3>Value</h3>

<p><code>sienaTimeTest</code> returns a list containing many items,
including the following:
</p>
<table>
<tr><td><code>JointTest</code></td>
<td>
<p>A chi-squared test for joint significance of the dummies.</p>
</td></tr>
<tr><td><code>EffectTest</code></td>
<td>
<p>A chi-squared test for joint significance
across dummies for each separate effect.</p>
</td></tr>
<tr><td><code>GroupTest</code></td>
<td>
<p>A chi-squared test for joint significance
across dummies; if <code>sienaFit</code> is a fit for a multi-group object
then these refer to each group; else they refer to ecah period.</p>
</td></tr>
<tr><td><code>IndividualTest</code></td>
<td>
<p>A matrix displaying initial estimates, one-step
estimates, and <code class="reqn">p</code>-values for the individual interactions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Josh Lospinoso, Tom Snijders</p>


<h3>References</h3>

<p>J.A. Lospinoso, M. Schweinberger, T.A.B. Snijders, and R.M. Ripley
(2011), Assessing and Accounting for Time Heterogeneity in Stochastic
Actor Oriented Models. <em>Advances in Data Analysis and Computation</em>,
<b>5</b>, 147&ndash;176.
</p>
<p>M. Schweinberger (2012), Statistical modeling of network panel data:
Goodness-of-fit. <em>British Journal of Statistical
and Mathematical Psychology</em> <b>65</b>, 263&ndash;281.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+plot.sienaTimeTest">plot.sienaTimeTest</a></code>,
<code><a href="#topic+includeTimeDummy">includeTimeDummy</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Estimate a restricted model
myalgorithm &lt;- sienaAlgorithmCreate(nsub=1, n3=50, projname=NULL)
# Short estimation not for practice, just for having a quick demonstration
mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE)

## Conduct the score-type test to assess whether heterogeneity is present.
tt &lt;- sienaTimeTest(ans)
summary(tt)

## Suppose that we wish to include time dummies.
## Add them in the following way:
myeff &lt;- includeTimeDummy(myeff, recip, transTrip, timeDummy="2")
ans2 &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE)

## Re-assess the time heterogeneity
(tt2 &lt;- sienaTimeTest(ans2))

## And so on..

## A demonstration of the plotting facilities, on a larger dataset:
## (Of course pasting these identical sets of three waves after each other
##  in a sequence of six is not really meaningful. It's just a demonstration.)

myalgorithm &lt;- sienaAlgorithmCreate(nsub=1, n3=50, seed=654, projname=NULL)
mynet1 &lt;- sienaDependent(array(c(s501, s502, s503, s501, s503, s502),
                               dim=c(50, 50, 6)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip, balance)
myeff &lt;- includeTimeDummy(myeff, density, timeDummy="all")
myeff &lt;- includeTimeDummy(myeff, recip, timeDummy="2,3,5")
myeff &lt;- includeTimeDummy(myeff, balance, timeDummy="4")
## Not run: 
(ansp &lt;- siena07(myalgorithm, data=mydata, effects=myeff))
ttp &lt;- sienaTimeTest(ansp, effects=1:4)

## Pairwise plots show
plot(ttp, pairwise=TRUE)

## Time test plots show
plot(ttp, effects=1:4, dims=c(2,2))

## End(Not run)

## Instead of working with includeTimeDummy,
## you can also define time dummies explicitly;
## this may give more control and more clarity:
dum2 &lt;- matrix(c(0,1,0,0,0), nrow=50, ncol=5, byrow=TRUE)
dum3 &lt;- matrix(c(0,0,1,0,0), nrow=50, ncol=5, byrow=TRUE)
dum4 &lt;- matrix(c(0,0,0,1,0), nrow=50, ncol=5, byrow=TRUE)
dum5 &lt;- matrix(c(0,0,0,0,1), nrow=50, ncol=5, byrow=TRUE)
time2 &lt;- varCovar(dum2)
time3 &lt;- varCovar(dum3)
time4 &lt;- varCovar(dum4)
time5 &lt;- varCovar(dum5)
mydata &lt;- sienaDataCreate(mynet1, time2, time3, time4, time5)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip, balance)
## corresponding to includeTimeDummy(myeff, density, timeDummy="all"):
myeff &lt;- includeEffects(myeff, egoX, interaction1='time2')
myeff &lt;- includeEffects(myeff, egoX, interaction1='time3')
myeff &lt;- includeEffects(myeff, egoX, interaction1='time4')
myeff &lt;- includeEffects(myeff, egoX, interaction1='time5')
## corresponding to myeff &lt;- includeTimeDummy(myeff, recip, timeDummy="2,3,5"):
myeff &lt;- includeInteraction(myeff, egoX, recip, interaction1=c('time2', ''))
myeff &lt;- includeInteraction(myeff, egoX, recip, interaction1=c('time3', ''))
myeff &lt;- includeInteraction(myeff, egoX, recip, interaction1=c('time5', ''))
## corresponding to myeff &lt;- includeTimeDummy(myeff, balance, timeDummy="4"):
myeff &lt;- includeInteraction(myeff, egoX, balance, interaction1=c('time4', ''))
## Not run: 
(anspp &lt;- siena07(myalgorithm, data=mydata, effects=myeff))
## anspp contains identical results as ansp above.

## End(Not run)

## A demonstration of RateX heterogeneity.
## Not run: 
mynet1 &lt;- sienaDependent(array(c(s501, s502, s503), dim=c(50, 50, 3)))
myccov &lt;- coCovar(s50a[,1])
mydata &lt;- sienaDataCreate(mynet1, myccov)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip, balance)
myeff &lt;- includeTimeDummy(myeff, RateX, type="rate", interaction1="myccov")
(ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff))

## End(Not run)
</code></pre>

<hr>
<h2 id='simstats0c'>Versions of FRAN</h2><span id='topic+simstats0c'></span><span id='topic+maxlikec'></span><span id='topic+initializeFRAN'></span><span id='topic+terminateFRAN'></span>

<h3>Description</h3>

<p>The functions to be called as &quot;FRAN&quot; by <code><a href="#topic+siena07">siena07</a></code>.   
They call compiled C++. Not for general users' use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simstats0c(z, x, data=NULL, effects=NULL, fromFiniteDiff=FALSE,
           returnDeps=FALSE, returnChains=FALSE, byWave=FALSE,
           returnDataFrame=FALSE, returnLoglik=FALSE)
maxlikec(z, x, data=NULL, effects=NULL,
           returnChains=FALSE, byGroup = FALSE, byWave=FALSE,
           returnDataFrame=FALSE, returnLoglik=FALSE,
           onlyLoglik=FALSE)
initializeFRAN(z, x, data, effects, prevAns = NULL, initC,
           profileData = FALSE, returnDeps = FALSE, returnChains =
           FALSE, byGroup = FALSE, returnDataFrame = FALSE,
           byWave = FALSE, returnLoglik = FALSE,  onlyLoglik = FALSE)
terminateFRAN(z, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simstats0c_+3A_z">z</code></td>
<td>
<p>Control object, passed in automatically in  <code><a href="#topic+siena07">siena07</a></code>.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_x">x</code></td>
<td>
<p>A sienaAlgorithm object, passed in automatically in  <code><a href="#topic+siena07">siena07</a></code>.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_data">data</code></td>
<td>
<p>A sienaData object as returned by <code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_effects">effects</code></td>
<td>
<p>A sienaEffects object as
returned by <code><a href="#topic+getEffects">getEffects</a></code>.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_fromfinitediff">fromFiniteDiff</code></td>
<td>
<p>Boolean used during calculation of derivatives
by finite differences. Not for user use.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_returndeps">returnDeps</code></td>
<td>
<p>Boolean. Whether to return the simulated networks in
Phase 3.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_returnchains">returnChains</code></td>
<td>
<p>Boolean. Whether to return the chains.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_bywave">byWave</code></td>
<td>
<p>Boolean. Whether to return the finite difference or
maximum likelihood
derivatives by wave (uses a great deal of memory). Only necessary
for <code><a href="#topic+sienaTimeTest">sienaTimeTest</a></code></p>
</td></tr>
<tr><td><code id="simstats0c_+3A_bygroup">byGroup</code></td>
<td>
<p>Boolean. For internal use: allows different thetas for each
group to be used in <code>sienaBayes</code>.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_returndataframe">returnDataFrame</code></td>
<td>
<p>Boolean. Whether to return the chains as
lists or data frames.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_returnloglik">returnLoglik</code></td>
<td>
<p>Boolean. Whether to return the log likelihood of
the simulated chain.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_onlyloglik">onlyLoglik</code></td>
<td>
<p>Boolean: whether to return just the likelihood for
the simulated chain, plus details of steps accepted and rejected. </p>
</td></tr>
<tr><td><code id="simstats0c_+3A_prevans">prevAns</code></td>
<td>
<p>An object of class &quot;sienaFit&quot; as returned by
<code><a href="#topic+siena07">siena07</a></code>, from which scaling
information (derivative matrix and standard deviation of the
deviations) will be extracted along with the latest version of the
parameters which will be used as the initial values, unless the
model requests the use of standard initial values. If the previous
model is exactly the same as the current one, Phase 1 will be omitted. If
not, any parameter estimates for effects which are included in
the new model will be used as initial
values, but phase 1 will still be carried out.
If the results used as <code>prevAns</code> are a reasonable starting point,
this will increase the efficiency of the algorithm. </p>
</td></tr>
<tr><td><code id="simstats0c_+3A_initc">initC</code></td>
<td>
<p>If TRUE, call is to setup the data and model in C++. For
use with multiple processes only.</p>
</td></tr>
<tr><td><code id="simstats0c_+3A_profiledata">profileData</code></td>
<td>
<p>Boolean to force dumping of the data for profiling
with <code>sienaProfile.exe</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not for general users' use.<br />
The name of <code>simstats0c</code> or <code>maxlikec</code>
should be used for the element FRAN of the model object, the former when using
estimation by forward simulation, the latter for maximum likelihood estimation.
The arguments with no defaults must be passed in on the call to
<code><a href="#topic+siena07">siena07</a></code>.
<code>initializeFRAN</code> and <code>terminateFRAN</code> are called in both cases.
</p>


<h3>Value</h3>

<p><code>simstats0c</code> returns a list containing:
</p>
<table>
<tr><td><code>fra</code></td>
<td>
<p>Simulated statistics.</p>
</td></tr>
<tr><td><code>sc</code></td>
<td>
<p>Scores with which to calculate the derivative (not phase 2
or if using finite differences or maximum likelihood).</p>
</td></tr>
<tr><td><code>dff</code></td>
<td>
<p>Contributions to the derivative if finite differences</p>
</td></tr>
<tr><td><code>ntim</code></td>
<td>
<p>For conditional processing, time taken.</p>
</td></tr>
<tr><td><code>feasible</code></td>
<td>
<p>Currently set to TRUE.</p>
</td></tr>
<tr><td><code>OK</code></td>
<td>
<p>Could be set to FALSE if serious error has occurred.</p>
</td></tr>
<tr><td><code>sims</code></td>
<td>
<p>A list of simulation results, one for each period. Each
list consists of a list for each data object, each of which consists of
a list for each network, each of which consists of a list for each period,
each component of which is an edgelist in matrix form (the columns
are from, to, value) (or vector for behavior variables).
Only if <code>returnDeps</code> is TRUE.</p>
</td></tr>
</table>
<p><code>maxlikec</code> returns a list containing:
</p>
<table>
<tr><td><code>fra</code></td>
<td>
<p>Simulated scores.</p>
</td></tr>
<tr><td><code>dff</code></td>
<td>
<p>Simulated Hessians: stored as lower triangular matrices</p>
</td></tr>
<tr><td><code>ntim</code></td>
<td>
<p>NULL, compatibility only</p>
</td></tr>
<tr><td><code>feasible</code></td>
<td>
<p>Currently set to TRUE.</p>
</td></tr>
<tr><td><code>OK</code></td>
<td>
<p>Could be set to FALSE if serious error has occurred.</p>
</td></tr>
<tr><td><code>dff</code></td>
<td>
<p>Simulated Hessian</p>
</td></tr>
<tr><td><code>sims</code></td>
<td>
<p>NULL, for compatibility only</p>
</td></tr>
<tr><td><code>chain</code></td>
<td>
<p>A list of sampled chains, one for each period. Each
list consists of a list for each data object, each of which consists of
a list for each network, each of which consists of a list for each period,
each component of which is a list or a data frame depending on the
value of <code>returnDataFrame</code>.
Only if <code>returnChainss</code> is TRUE.</p>
</td></tr>
<tr><td><code>accepts</code></td>
<td>
<p>Number of accepted MH steps by dependent variable
(permute steps are counted under first dependent variable)</p>
</td></tr>
<tr><td><code>rejects</code></td>
<td>
<p>Number of rejected MH steps by dependent variable
(permute steps are counted under first dependent variable)</p>
</td></tr>
<tr><td><code>aborts</code></td>
<td>
<p>Number of aborted MH steps counted under first dependent
variable.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Loglikelihood of the simulations. Only if
<code>returnLoglik</code> is TRUE. If <code>onlyLoglik</code> is TRUE, only
<code>loglik</code>, <code>accepts</code>,<code>rejects</code> and <code>aborts</code> are
returned.</p>
</td></tr>
</table>
<p><code>initializeFRAN</code> and <code>terminateFRAN</code> return the control
object <code>z</code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley </p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
mynet1 &lt;- sienaNet(array(c(tmp3, tmp4), dim=c(32, 32, 2)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
myeff &lt;- includeEffects(myeff, transTrip)
myalgorithm &lt;- sienaAlgorithmCreate(fn=simstats0c, nsub=2, n3=100, projname=NULL)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff,  batch=TRUE)
</code></pre>

<hr>
<h2 id='summary.iwlsm'>
Summary method for Iterative Weighted Least Squares Models
</h2><span id='topic+summary.iwlsm'></span><span id='topic+print.summary.iwlsm'></span>

<h3>Description</h3>

<p><code>summary</code> method for objects of class <code>"iwlsm"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'iwlsm'
summary(object, method = c("XtX", "XtWX"),
 correlation = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.iwlsm_+3A_object">object</code></td>
<td>

<p>the fitted model.
This is assumed to be the result of some fit that produces
an object inheriting from the class <code>iwlsm</code>, in the sense that
the components returned by the <code>iwlsm</code> function will be available.
</p>
</td></tr>
<tr><td><code id="summary.iwlsm_+3A_method">method</code></td>
<td>

<p>Should the weighted (by the IWLS weights) or unweighted cross-products
matrix be used?
</p>
</td></tr>
<tr><td><code id="summary.iwlsm_+3A_correlation">correlation</code></td>
<td>

<p>logical. Should correlations be computed (and printed)?
</p>
</td></tr>
<tr><td><code id="summary.iwlsm_+3A_...">...</code></td>
<td>

<p>arguments passed to or from other methods.
</p>
</td></tr></table>


<h3>Details</h3>

<p>This function is a method for the generic function
<code>summary()</code> for class <code>"iwlsm"</code>.
It can be invoked by calling <code>summary(x)</code> for an
object <code>x</code> of the appropriate class, or directly by
calling <code>summary.iwlsm(x)</code> regardless of the
class of the object.
</p>


<h3>Value</h3>

<p>If printing takes place, only a null value is returned.
Otherwise, a list is returned with the following components.
Printing always takes place if this function is invoked automatically
as a method for the <code>summary</code> function.
</p>
<table>
<tr><td><code>correlation</code></td>
<td>

<p>The computed correlation coefficient matrix for the coefficients in the model.
</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>

<p>The unscaled covariance matrix; i.e, a matrix such that multiplying it by
an estimate of the error variance produces an estimated covariance matrix
for the coefficients.
</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>

<p>The scale estimate.
</p>
</td></tr>
<tr><td><code>stddev</code></td>
<td>

<p>A scale estimate used for the standard errors.
</p>
</td></tr>
<tr><td><code>df</code></td>
<td>

<p>The number of degrees of freedom for the model and for residuals.
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>A matrix with three columns, containing the coefficients, their standard errors
and the corresponding t statistic.
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>The terms object used in fitting this model.
</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Adapted by Ruth Ripley</p>


<h3>References</h3>

<p>Venables, W. N. and Ripley, B. D. (2002),
<em>Modern Applied Statistics with S.</em> Fourth edition.  Springer.
See also  <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
##not enough data here for a sensible example, but shows the idea.
myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=100)
mynet1 &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mynet2 &lt;- sienaDependent(array(c(s502, s503), dim=c(50, 50, 2)))
mydata1 &lt;- sienaDataCreate(mynet1)
mydata2 &lt;- sienaDataCreate(mynet2)
myeff1 &lt;- getEffects(mydata1)
myeff2 &lt;- getEffects(mydata2)
myeff1 &lt;- setEffect(myeff1, transTrip, fix=TRUE, test=TRUE)
myeff2 &lt;- setEffect(myeff2, transTrip, fix=TRUE, test=TRUE)
myeff1 &lt;- setEffect(myeff1, cycle3, fix=TRUE, test=TRUE)
myeff2 &lt;- setEffect(myeff2, cycle3, fix=TRUE, test=TRUE)
ans1 &lt;- siena07(myalgorithm, data=mydata1, effects=myeff1, batch=TRUE)
ans2 &lt;- siena07(myalgorithm, data=mydata2, effects=myeff2, batch=TRUE)
meta &lt;- siena08(ans1, ans2)
metadf &lt;- split(meta$thetadf, meta$thetadf$effects)[[1]]
metalm &lt;- iwlsm(theta ~ tconv, metadf, ses=se^2)
summary(metalm)

## End(Not run)
</code></pre>

<hr>
<h2 id='tmp3'>van de Bunt's Freshman dataset, time point 3</h2><span id='topic+tmp3'></span>

<h3>Description</h3>

<p>Third timepoint of van de Bunt's freshman dataset.<br />
</p>
<p>Codes: 1 = best friendship; 2 = friendship; 3 = friendly relationship;   
4 = neutral relationship; 5 = troubled relationship; 0 = unknown person.
</p>


<h3>Format</h3>

<p>Adjacency matrix for the &quot;at least friendly relationship&quot;
network at time point 3.
</p>


<h3>Source</h3>

<p>vrnd32t3.dat from
<a href="https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.zip</a>
</p>


<h3>References</h3>

<p>Van de Bunt, G.G., van Duijn, M.A.J., and Snijders, T.A.B.  (1999),
Friendship networks through time: An actor-oriented statistical network model.
<em>Computational and Mathematical Organization Theory</em>, <b>5</b>, 167&ndash;192.
</p>
<p>Also see <a href="https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.htm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tmp4">tmp4</a></code></p>

<hr>
<h2 id='tmp4'>van de Bunt's Freshman dataset, time point 4</h2><span id='topic+tmp4'></span>

<h3>Description</h3>

<p>Fourth timepoint of van de Bunt's freshman dataset.<br />
</p>
<p>Codes: 1 = best friendship; 2 = friendship; 3 = friendly relationship;  
4 = neutral relationship; 5 = troubled relationship; 0 = unknown person.
</p>


<h3>Format</h3>

<p>Adjacency matrix for the &quot;at least friendly relationship&quot;
network at time point 4.
</p>


<h3>Source</h3>

<p>vrnd32t4.dat from
<a href="https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.zip">https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.zip</a>
</p>


<h3>References</h3>

<p>Van de Bunt, G.G., van Duijn, M.A.J., and Snijders, T.A.B.  (1999),
Friendship networks through time: An actor-oriented statistical network model.
<em>Computational and Mathematical Organization Theory</em>, 5, 167&ndash;192. 
</p>
<p>Also see <a href="https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.htm">https://www.stats.ox.ac.uk/~snijders/siena/vdBunt_data.htm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tmp3">tmp3</a></code></p>

<hr>
<h2 id='updateTheta'>
A function to update the initial values of theta, and a function
to update an effects object.
</h2><span id='topic+updateTheta'></span><span id='topic+updateSpecification'></span>

<h3>Description</h3>

<p><code>updateTheta</code> copies the final values of any matching selected effects   
from a <code><a href="#topic+sienaFit">sienaFit</a></code> object to a Siena effects object.<br />   
<code>updateSpecification</code> includes in a Siena effects object   
a set of effects that are included in another effects object.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateTheta(effects, prevAns, varName=NULL)
updateSpecification(effects.to, effects.from, name.to=NULL, name.from=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateTheta_+3A_effects">effects</code></td>
<td>
<p>Object of class <code><a href="#topic+sienaEffects">sienaEffects</a></code>.</p>
</td></tr>
<tr><td><code id="updateTheta_+3A_prevans">prevAns</code></td>
<td>
<p>Object of class <code><a href="#topic+sienaFit">sienaFit</a></code>
as returned by <code><a href="#topic+siena07">siena07</a></code>.</p>
</td></tr>
<tr><td><code id="updateTheta_+3A_varname">varName</code></td>
<td>
<p>Character string or vector of character strings;
is this is not <code>NULL</code>, the update will only applied to this
dependent variable / these dependent variables.</p>
</td></tr>
<tr><td><code id="updateTheta_+3A_effects.to">effects.to</code></td>
<td>
<p>Object of class <code><a href="#topic+sienaEffects">sienaEffects</a></code>.</p>
</td></tr>
<tr><td><code id="updateTheta_+3A_effects.from">effects.from</code></td>
<td>
<p>Object of class <code><a href="#topic+sienaEffects">sienaEffects</a></code>.</p>
</td></tr>
<tr><td><code id="updateTheta_+3A_name.to">name.to</code></td>
<td>
<p>Character string, name of dependent variable in <code>object.to</code>.</p>
</td></tr>
<tr><td><code id="updateTheta_+3A_name.from">name.from</code></td>
<td>
<p>Character string, name of dependent variable in
<code>object.from</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial values of any selected effects
in the input effects object which match an effect estimated in
<code>prevAns</code> will be updated by <code>updateTheta</code>.
If the previous run was conditional, the estimated rate parameters for
the dependent variable on which the run was conditioned are added to
the final value of theta. If <code>varName</code> is not <code>NULL</code>,
this update is restricted to effects for the dependent variable/s
specified by <code>varName</code>.
<br />
By <code>updateSpecification</code>, the effects included in <code>effects.from</code>
are also included in <code>effects.to</code>; if <code>name.to</code> and/or
<code>name.from</code> is specified, this is restricted to effects
for those dependent variables.
If <code>name.to = "all"</code> (should then not be used as variable name!),
the effects for all dependent variables will be updated. <br />
Correspondence between effects is defined by <code>"name", "shortName"
  "type", "groupName", "interaction1", "interaction2", "period", "effect1",
  "effect2",</code> and <code>"effect3"</code>. This means that inclusion of user-defined
interactions will be updated only if they were available (i.e., defined)
already in <code>effects.to</code>.
</p>


<h3>Value</h3>

<p>Updated effects object.
</p>


<h3>Note</h3>

<p>Using <code>updateTheta</code> explicitly before calling <code><a href="#topic+siena07">siena07</a></code>
rather than using it via the argument
<code>prevAns</code> of <code><a href="#topic+siena07">siena07</a></code> will not permit the use of
the previous derivative matrix.
In most cases, using <code><a href="#topic+siena07">siena07</a></code> with <code>prevAns</code> will be more
efficient.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley, Tom A.B. Snijders</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+getEffects">getEffects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For updateTheta:
mynet1 &lt;- sienaDependent(array(c(tmp3, tmp4), dim=c(32, 32, 2)))
mydata &lt;- sienaDataCreate(mynet1)
myeff1 &lt;- getEffects(mydata)
myeff1 &lt;- includeEffects(myeff1, transTrip)
myalgorithm &lt;- sienaAlgorithmCreate(nsub=1, n3=100, projname=NULL)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff1, batch=TRUE)
ans$theta
(myeff &lt;- updateTheta(myeff1, ans))
##
## For updateSpecification:
myeff2 &lt;- getEffects(mydata)
myeff2 &lt;- includeEffects(myeff2, inPop)
updateSpecification(myeff2, myeff1)
# Create (meaningless) two-dimensional dependent network
mynet1 &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mynet2 &lt;- sienaDependent(array(c(s503, s501), dim=c(50, 50, 2)))
mydata12 &lt;- sienaDataCreate(mynet1, mynet2)
myeff12 &lt;- getEffects(mydata12)
myeff.new &lt;- getEffects(mydata12)
(myeff12 &lt;- includeEffects(myeff12, inPop, outPop, outAct))
# update myeff.new only for mynet1:
updateSpecification(myeff.new, myeff12)
# update myeff.new for all dependent networks:
(myeff.updated &lt;- updateSpecification(myeff.new, myeff12, "all"))
# use multivariate effects object to update univariate effects object:
myeff1 &lt;- getEffects(sienaDataCreate(mynet1))
updateSpecification(myeff1, myeff.updated)
</code></pre>

<hr>
<h2 id='varCovar'>Function to create a changing covariate object.</h2><span id='topic+varCovar'></span>

<h3>Description</h3>

<p>This function creates a changing covariate object from a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varCovar(val, centered=TRUE, nodeSet="Actors",  warn=TRUE,
  imputationValues=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varCovar_+3A_val">val</code></td>
<td>
<p> Matrix of covariate values, one row for each actor, one
column for each period. </p>
</td></tr>
<tr><td><code id="varCovar_+3A_centered">centered</code></td>
<td>
<p>Boolean: if TRUE, then the overall mean value is subtracted.</p>
</td></tr>
<tr><td><code id="varCovar_+3A_nodeset">nodeSet</code></td>
<td>
<p>Character string containing the name of the associated
node set. If the entire data set contains more than one node set,
then the node sets must be specified in all data objects.</p>
</td></tr>
<tr><td><code id="varCovar_+3A_warn">warn</code></td>
<td>
<p>Logical: is a warning given if all values are <code>NA</code>,
or all non-missing values are the same.</p>
</td></tr>
<tr><td><code id="varCovar_+3A_imputationvalues">imputationValues</code></td>
<td>
<p>Matrix of covariate values of same
dimensions as <code>val</code>a, to be used for imputation of
<code>NA</code> values (if any) in <code>val</code>. Must not contain
any <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When part of a Siena data object, the covariate is assumed to be
associated with node set <code>nodeSet</code> of the Siena data object.
In practice, the node set needs to be specified only in the case of
the use of the covariate with a two-mode network.<br />
If there are any <code>NA</code> values in <code>val</code>, and
<code>imputationValues</code> is given, then the corresponding elements
of <code>imputationValues</code> are used for imputation.
If <code>imputationValues</code> is <code>NULL</code>, imputation
is by the overall mean value. In both cases, cases with imputed values
are not used for calculating target statistics (see the manual).<br />
The value of the changing covariate for wave <code>m</code> is supposed
in the simulations to be valid in the whole period from wave <code>m</code>
to wave <code>m+1</code>.
If the data set has <code>M</code> waves, this means that the values,
if any, for wave <code>M</code> will not be used. Therefore, the number of columns
can be <code>M</code> or <code>M-1</code>; if the former, the values in the last
column will not be used.
</p>


<h3>Value</h3>

<p>Returns the covariate as an object of class &quot;varCovar&quot;, in which
form it can be used as an argument to <code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+coCovar">coCovar</a></code>,
<code><a href="#topic+coDyadCovar">coDyadCovar</a></code>, <code><a href="#topic+varDyadCovar">varDyadCovar</a></code>,
<code><a href="#topic+sienaNodeSet">sienaNodeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
myvarCovar &lt;- varCovar(s50a)
senders &lt;- sienaNodeSet(50, nodeSetName="senders")
receivers &lt;- sienaNodeSet(30, nodeSetName="receivers")
senders.covariate &lt;- varCovar(s50a, nodeSet="senders")
receivers.covariate &lt;- varCovar(s50s[1:30,], nodeSet="receivers")
</code></pre>

<hr>
<h2 id='varDyadCovar'>Function to create a changing dyadic covariate object.</h2><span id='topic+varDyadCovar'></span>

<h3>Description</h3>

<p>This function creates a changing dyadic covariate object from an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varDyadCovar(val, centered=TRUE, nodeSets=c("Actors", "Actors"),
     warn=TRUE, sparse=is.list(val), type=c("oneMode", "bipartite"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varDyadCovar_+3A_val">val</code></td>
<td>
<p>Array of covariate values, third dimension is the
time. Alternatively, a list of sparse matrices of type <code>"TsparseMatrix"</code>.</p>
</td></tr>
<tr><td><code id="varDyadCovar_+3A_centered">centered</code></td>
<td>
<p>Boolean: if TRUE, then the overall mean value is subtracted.</p>
</td></tr>
<tr><td><code id="varDyadCovar_+3A_nodesets">nodeSets</code></td>
<td>
<p>Names (character string) of the associated node sets.
If the entire data set contains more than one node set,
then the node sets must be specified in all data objects.</p>
</td></tr>
<tr><td><code id="varDyadCovar_+3A_warn">warn</code></td>
<td>
<p>Logical: is a warning given if, for non-sparse input,
all values are <code>NA</code>, or all non-missing values are the same.</p>
</td></tr>
<tr><td><code id="varDyadCovar_+3A_sparse">sparse</code></td>
<td>
<p>Boolean: whether sparse matrices or not.</p>
</td></tr>
<tr><td><code id="varDyadCovar_+3A_type">type</code></td>
<td>
<p>oneMode or bipartite: whether the matrix refers to a one-mode
or a bipartite (two-mode) network.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When part of a Siena data object, the covariate is assumed to be
associated with the node sets named <code>NodeSets</code>
of the Siena data object. The names of the associated node sets will only
be checked when the Siena data object is created.
In practice, the node set needs to be specified only in the case of
the use of the covariate with a two-mode network.<br />
The value of the changing covariate for wave <code>m</code> is supposed
in the simulations to be valid in the whole period from wave <code>m</code>
to wave <code>m+1</code>.
If the data set has <code>M</code> waves, this means that the values,
if any, for wave <code>M</code> will not be used. Therefore, the number of columns
can be <code>M</code> or <code>M-1</code>; if the former, the values in the last
column will not be used.
</p>


<h3>Value</h3>

<p>Returns the covariate as an object of class &quot;varDyadCovar&quot;, in which
form it can be used as an argument to <code>SienaDataCreate</code>.
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p>See <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+sienaDataCreate">sienaDataCreate</a></code>, <code><a href="#topic+coDyadCovar">coDyadCovar</a></code>,
<code><a href="#topic+coCovar">coCovar</a></code>, <code><a href="#topic+varCovar">varCovar</a></code>,
<code><a href="#topic+sienaNodeSet">sienaNodeSet</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
mydyadvar &lt;- varDyadCovar(array(c(s501, s502), dim=c(50, 50, 2)))

</code></pre>

<hr>
<h2 id='Wald'>  Wald and score tests for RSiena results </h2><span id='topic+Wald.RSiena'></span><span id='topic+Multipar.RSiena'></span><span id='topic+score.Test'></span><span id='topic+scoreTest'></span><span id='topic+sienaTest'></span><span id='topic+testSame.RSiena'></span>

<h3>Description</h3>

<p>These functions test parameters in RSiena results
estimated by <code><a href="#topic+siena07">siena07</a></code>.
Tests can be Wald-type (if the parameters were estimated)
or score-type tests (if the parameters were fixed and tested).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wald.RSiena(A, ans)

Multipar.RSiena(ans, ...)

score.Test(ans, test=ans$test)

testSame.RSiena(ans, e1, e2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wald_+3A_a">A</code></td>
<td>
<p>A <code>k</code> * <code>p</code> matrix, where <code>p = ans$pp</code>,
the number of parameters in <code>ans</code> excluding the basic rate parameters
used for conditional estimation.</p>
</td></tr>
<tr><td><code id="Wald_+3A_ans">ans</code></td>
<td>
<p>An object of class <code><a href="#topic+sienaFit">sienaFit</a></code>,
resulting from a call to <code><a href="#topic+siena07">siena07</a>.</code></p>
</td></tr>
<tr><td><code id="Wald_+3A_...">...</code></td>
<td>
<p>One or more integer numbers between 1 and <code>p</code>, specifying
the tested effects
(numbered as in <code>print(ans)</code>; if conditional estimation was used, numbered
as the 'Other parameters').</p>
</td></tr>
<tr><td><code id="Wald_+3A_test">test</code></td>
<td>
<p>One or more integer numbers between 1 and <code>p</code>,
or a logical vector of length <code>p</code>; these should specify the tested
effects (numbered as described for the ...).</p>
</td></tr>
<tr><td><code id="Wald_+3A_e1">e1</code>, <code id="Wald_+3A_e2">e2</code></td>
<td>
<p>Each an integer number between 1 and <code>p</code>, or a vector
of such numbers; the hypothesis tested is that the parameters for effects
with number/s <code>e1</code> are equal to those in <code>e2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Wald.RSiena</code> produces a Wald-type test,
applicable to estimated parameters. <code>Multipar.RSiena</code> and
<code>testSame.RSiena</code> are special cases of <code>Wald.RSiena</code>.
The hypothesis tested by <code>Wald.RSiena</code>
is <code class="reqn">A\theta = 0</code>, where <code class="reqn">\theta</code> is
the parameter estimated in the process leading to <code>ans</code>.
</p>
<p>The hypothesis tested by <code>Multipar.RSiena</code> is that all
parameters given in <code class="reqn">\ldots</code> are 0.
</p>
<p>The hypothesis tested by <code>testSame.RSiena</code> is that all
parameters given in <code>e1</code> are equal to those in <code>e2</code>.
</p>
<p><code>score.Test</code> produces a score-type test.
The tested effects for <code>score.Test</code> should have been specified
in <code><a href="#topic+includeEffects">includeEffects</a></code> or <code><a href="#topic+setEffect">setEffect</a></code> with
<code>fix=TRUE, test=TRUE</code>, i.e., they should not have been estimated.
The hypothesis tested by <code>score.Test</code> is that the tested parameters have
the value indicated in the effects object used for obtaining <code>ans</code>.
</p>
<p>These tests should be carried out only when convergence is adequate
(overall maximum convergence ratio less than 0.25
and all <em>t</em>-ratios for convergence less than 0.1 in absolute value).
</p>
<p>These functions have their own print method, see <code><a href="#topic+print.sienaTest">print.sienaTest</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>sienaTest</code>, which is a list with elements:
</p>
<table>
<tr><td><code>chisquare:</code></td>
<td>
<p> The test statistic, assumed to have a chi-squared null
distribution.</p>
</td></tr>
<tr><td><code>df:</code></td>
<td>
<p> The degrees of freedom.</p>
</td></tr>
<tr><td><code>pvalue:</code></td>
<td>
<p> The associated <em>p</em>-value.</p>
</td></tr>
<tr><td><code>onesided:</code></td>
<td>
<p>For <code>df</code>=1, the onesided test statistic.</p>
</td></tr>
<tr><td><code>efnames:</code></td>
<td>
<p>For <code>Multipar.RSiena</code> and <code>score.Test</code>, the names
of the tested effects.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tom Snijders</p>


<h3>References</h3>

<p>See the manual and <a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a>
</p>
<p>M. Schweinberger (2012). Statistical modeling of network panel data:
Goodness-of-fit. <em>British Journal of Statistical
and Mathematical Psychology</em> <b>65</b>, 263&ndash;281.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+siena07">siena07</a></code>, <code><a href="#topic+print.sienaTest">print.sienaTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>mynet &lt;- sienaDependent(array(c(s501, s502), dim=c(50, 50, 2)))
mydata &lt;- sienaDataCreate(mynet)
myeff &lt;- getEffects(mydata)
myalgorithm &lt;- sienaAlgorithmCreate(nsub=1, n3=40, seed=1777, projname=NULL)
# nsub=1 and n3=40 is used here for having a brief computation,
# not for practice.
myeff &lt;- includeEffects(myeff, transTrip, transTies)
myeff &lt;- includeEffects(myeff, outAct, outPop, fix=TRUE, test=TRUE)
(ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE))
A &lt;- matrix(0, 2, 6)
A[1, 3] &lt;- 1
A[2, 4] &lt;- 1
wa &lt;- Wald.RSiena(A, ans)
wa
# A shortcut for the above is:
Multipar.RSiena(ans, 3, 4)
# The following two are equivalent:
sct &lt;- score.Test(ans, c(FALSE, FALSE, FALSE, FALSE, FALSE, TRUE))
sct &lt;- score.Test(ans,6)
print(sct)
# Getting all 1-df score tests separately:
for (i in which(ans$test)){
   sct &lt;- score.Test(ans,i)
   print(sct)}
# Testing that endowment and creation effects are identical:
myeff1 &lt;- getEffects(mydata)
myeff1 &lt;- includeEffects(myeff1, recip, include=FALSE)
myeff1 &lt;- includeEffects(myeff1, recip, type='creation')
(myeff1 &lt;- includeEffects(myeff1, recip, type='endow'))
(ans1 &lt;- siena07(myalgorithm, data=mydata, effects=myeff1, batch=TRUE))
testSame.RSiena(ans1, 2, 3)
</code></pre>

<hr>
<h2 id='xtable'>
Access xtable in package xtable</h2><span id='topic+xtable'></span>

<h3>Description</h3>

<p>Dummy function to allow access to xtable in package xtable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xtable(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtable_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+sienaFit">sienaFit</a></code> object
</p>
</td></tr>
<tr><td><code id="xtable_+3A_...">...</code></td>
<td>

<p>Other arguments for <code><a href="#topic+xtable.sienaFit">xtable.sienaFit</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value returned from <code><a href="#topic+xtable.sienaFit">xtable.sienaFit</a></code>
</p>


<h3>Author(s)</h3>

<p>Ruth Ripley</p>


<h3>References</h3>

<p><a href="https://www.stats.ox.ac.uk/~snijders/siena/">https://www.stats.ox.ac.uk/~snijders/siena/</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+xtable.sienaFit">xtable.sienaFit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The function is currently defined as
function (x, ...)
{
    xtable::xtable(x, ...)
  }
## Not run: 
myalgorithm &lt;- sienaAlgorithmCreate(nsub=2, n3=100)
mynet1 &lt;- sienaDependent(array(c(tmp3, tmp4), dim=c(32, 32, 2)))
mydata &lt;- sienaDataCreate(mynet1)
myeff &lt;- getEffects(mydata)
ans &lt;- siena07(myalgorithm, data=mydata, effects=myeff, batch=TRUE)
ans
summary(ans)
xtable(ans, type="html", file="ans.html")
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
