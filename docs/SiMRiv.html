<!DOCTYPE html><html><head><title>Help for package SiMRiv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SiMRiv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjustModel'><p>Finds (&quot;estimates&quot;) simulation input parameters able to replicate a given (real) trajectory, assuming the given species model</p></a></li>
<li><a href='#Arith-methods'><p>Shortcuts for defining species movement states</p></a></li>
<li><a href='#binCounts'><p>Count values in given bins</p></a></li>
<li><a href='#generationPlot'><p>Plots input parameter optimization results</p></a></li>
<li><a href='#perceptualRange'><p>Define a perceptual range</p></a></li>
<li><a href='#resistanceFromShape'><p>Build resistance raster by combining shapefiles</p></a></li>
<li><a href='#river'><p>Sample River Network in Raster Format</p></a></li>
<li><a href='#sampleMovement'><p>Resample a simulated movement and compute step-wise statistics</p></a></li>
<li><a href='#SiMRiv-package'>
<p>Simulating Multistate Movements in River/Heterogeneous Landscapes</p></a></li>
<li><a href='#simulate'><p>Simulate movements in river networks, homogeneous, or heterogeneous landscapes</p></a></li>
<li><a href='#species'><p>Create a species</p></a></li>
<li><a href='#speciesModel'><p>Defines a species model to adjust to a real trajectory</p></a></li>
<li><a href='#state'><p>Define a movement state</p></a></li>
<li><a href='#transitionMatrix'><p>Define a state transition matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-15</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating Multistate Movements in River/Heterogeneous
Landscapes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), raster</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats, mco, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adehabitatLT, moveHMM, testthat, sf</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to generate and analyze spatially-explicit individual-based multistate movements in rivers,
  heterogeneous and homogeneous spaces. This is done by incorporating landscape bias on local behaviour, based on
  resistance rasters. Although originally conceived and designed to simulate trajectories of species constrained to
  linear habitats/dendritic ecological networks (e.g. river networks), the simulation algorithm is built to be
  highly flexible and can be applied to any (aquatic, semi-aquatic or terrestrial) organism, independently on the
  landscape in which it moves. Thus, the user will be able to use the package to simulate movements either in
  homogeneous landscapes, heterogeneous landscapes (e.g. semi-aquatic animal moving mainly along rivers but also using
  the matrix), or even in highly contrasted landscapes (e.g. fish in a river network). The algorithm and its input
  parameters are the same for all cases, so that results are comparable. Simulated trajectories can then be used as
  mechanistic null models (Potts &amp; Lewis 2014, &lt;<a href="https://doi.org/10.1098%2Frspb.2014.0231">doi:10.1098/rspb.2014.0231</a>&gt;) to test a variety of 'Movement Ecology'
  hypotheses (Nathan et al. 2008, &lt;<a href="https://doi.org/10.1073%2Fpnas.0800375105">doi:10.1073/pnas.0800375105</a>&gt;), including landscape effects (e.g. resources, 
  infrastructures) on animal movement and species site fidelity, or for predictive purposes (e.g. road mortality risk,
  dispersal/connectivity). The package should be relevant to explore a broad spectrum of ecological phenomena, such as
  those at the interface of animal behaviour, management, landscape and movement ecology, disease and invasive species
  spread, and population dynamics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>, <a href="https://github.com/miguel-porto/SiMRiv">https://github.com/miguel-porto/SiMRiv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/miguel-porto/SiMRiv">https://github.com/miguel-porto/SiMRiv</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-15 11:09:28 UTC; miguel</td>
</tr>
<tr>
<td>Author:</td>
<td>Lorenzo Quaglietta [aut],
  Miguel Porto [aut, cre],
  Erida Gjini [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Miguel Porto &lt;mpbertolo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-15 11:42:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjustModel'>Finds (&quot;estimates&quot;) simulation input parameters able to replicate a given (real) trajectory, assuming the given species model</h2><span id='topic+adjustModel'></span>

<h3>Description</h3>

<p>Given a trajectory, a type of movement and the time resolution at which the user wants to simulate, 
this function approximates the values for the simulation input parameters so that the simulated movement is maximally
similar to the given trajectory, in terms of general non-spatial patterns. If the user wants to simulate at a higher frequency 
than real data (which is the norm), the function maximizes the similarity between the real trajectory and 
the simulated trajectories (at a higher frequency) after downsampled to the same frequency as the real.
It does so by running a genetic optimization algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  adjustModel(realData, species.model, resolution = 10
    , resistance = NULL, coords = NULL, angles = NULL
    , nrepetitions = 6
    , nbins.hist = if(aggregate.obj.hist) c(7, 7, 0) else c(3, 3, 0)
    , step.hist.log = TRUE, nlags = 100
    , window.size = dim(reference$stats)[1]%/%nlags
    , aggregate.obj.hist = TRUE, step.hist.range = c(0, 1)
    , popsize = 100, generations = seq(5, 1000, by=5), mprob = 0.2
    , parallel = is.null(resistance), trace = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjustModel_+3A_realdata">realData</code></td>
<td>
<p>the given trajectory for which the simulation input parameters are to be &quot;estimated&quot;, given as a matrix with two columns (coordinates) and assuming that relocations are equally spaced in time.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_species.model">species.model</code></td>
<td>
<p>the species model to adjust, created with <code><a href="#topic+speciesModel">speciesModel</a></code>. This defines the type of movement that is to be adjusted (e.g. how many, and which type of, behavioral states, see details).</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_resolution">resolution</code></td>
<td>
<p>the desired time frequency of the simulations for which parameters will be approximated, as a fraction of the real data, i.e. a value of 20 will simulate movements at a 20-fold higher frequency than real data.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_resistance">resistance</code></td>
<td>
<p>the resistance raster to use in simulations during parameter approximation.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_coords">coords</code></td>
<td>
<p>the initial coordinates of the simulated individuals (only relevant if <code>resistance</code> is provided because the metrics used in optimization are spatially-agnostic).</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_angles">angles</code></td>
<td>
<p>the initial angle to which the individual is facing in that start of all simulations (only relevant if <code>resistance</code> is provided because the metrics used in optimization are spatially-agnostic).</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_nrepetitions">nrepetitions</code></td>
<td>
<p>the number of simulations conducted for each solution evaluation during optimization. If &gt;1, the quality of the solutions is computed by comparing the averaged histograms across repetitions, with the real histograms.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_nbins.hist">nbins.hist</code></td>
<td>
<p>a vector with three positive integers defining the number of histogram bins for turning angle histograms, step length histograms and turning angle variation histograms. These bins will be used during optimization to compare simulated trajectories with the real trajectory to infer the quality of the &quot;fit&quot;.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_step.hist.log">step.hist.log</code></td>
<td>
<p>set to <code>TRUE</code> to use the histogram of the logarithm of the step lengths rather than of the raw values in the comparisons. Setting to <code>TRUE</code> usually results in more detail in the comparisons.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_nlags">nlags</code></td>
<td>
<p>the number of time lags within which the standard deviation of the turning angles will be computed during optimization, if <code>nbins.hist[3] &gt; 0</code>. Ignored if <code>nbins.hist[3] == 0</code> or if <code>window.size</code> is provided.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_window.size">window.size</code></td>
<td>
<p>the size (in steps of the real sampling frequency) of the time lags within which the standard deviation of the turning angles will be computed during optimization, if <code>nbins.hist[3] &gt; 0</code>. A different way of providing <code>nlags</code>. See details.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_aggregate.obj.hist">aggregate.obj.hist</code></td>
<td>
<p>if <code>FALSE</code>, comparison of histograms is done bin by bin (each bin absolute difference is an objective to minimize), if <code>TRUE</code> the absolute differences of the bins are summed in each histogram to a single number which is the objective being minimized (the overall absolute difference in each of the histograms).</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_step.hist.range">step.hist.range</code></td>
<td>
<p>the quantiles used to define the range of the step length histogram computation. Used if the user wants to exclude outliers. The default is not to exclude outliers, thus <code>c(0, 1)</code>.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_popsize">popsize</code></td>
<td>
<p>number of solutions to optimize, to pass to <code><a href="mco.html#topic+nsga2">nsga2</a></code></p>
</td></tr>
<tr><td><code id="adjustModel_+3A_generations">generations</code></td>
<td>
<p>number of algorithm generations to run, to pass to <code><a href="mco.html#topic+nsga2">nsga2</a></code>. The default is a vector, so that convergence of results can be assessed along generations.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_mprob">mprob</code></td>
<td>
<p>mutation probability, to pass to <code><a href="mco.html#topic+nsga2">nsga2</a></code></p>
</td></tr>
<tr><td><code id="adjustModel_+3A_parallel">parallel</code></td>
<td>
<p>set to <code>TRUE</code> to use multicore processing.</p>
</td></tr>
<tr><td><code id="adjustModel_+3A_trace">trace</code></td>
<td>
<p>set to <code>TRUE</code> to print the matrix of optimization objectives (rows) for each solution (columns) in each generation along optimization. These are the values that are being internally minimized. The number of rows is <code>sum(nbins.hist)</code>; the first <code>nbins.hist[1]</code> are the turning angle variation objectives, the last are the step length objectives.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds possible parameters for the simulation (solutions), so that the resulting movements are as similar as possible
to the given real trajectory, in terms of their intrinsic properties measured by step lengths and variation in turning angles. The input parameter
approximations are found using a multiobjective genetic algorithm (NSGA-II, <cite>Deb et al. 2002</cite>). The algorithm minimizes a vector
of N objectives (N=sum(nbins.hist) if aggregate.obj.hist == FALSE, N=sum(nbins.hist &gt; 0) otherwise)
whose values are computed by the absolute differences between each pair of bins (real and simulated) of up to three histograms:
an histogram of the step lengths, an histogram of turning angles and/or and histogram of the standard deviation in turning angles
computed in a moving time window along each trajectory. Using either of these histograms (and the respective number of bins) is
specified in the parameter <code>nbins.hist</code>, which has three elements, one for each histogram. A value of 0 tells the function
not to use that corresponding histogram.
</p>
<p>SiMRiv simulations are intended to reproduce the fine-scale movement steps, unlike what is normally collected in field data.
Hence, simulations should be conducted with a much higher time frequency than provided by the real data, which poses challenges for parameterization.
This function incorporates this difference in the time scale during optimization (<code>resolution</code>), allowing the user
to find the input parameters for simulations at a much higher frequency, which, when downsampled to the real data's time
frequency, will present similar patterns. The higher the frequency, the more flexibility the model has to adjust to real data,
but the more possible solutions may exist to achieve the same result.
</p>
<p>There are no limits to the number of parameters that can be approximated, but obviously, the higher the number, the larger the solution space, so,
in theory, the longer the algorithm has to run in order to converge.
The number of parameters to approximate is defined by the user by providing a <code><a href="#topic+speciesModel">speciesModel</a></code>. This defines how many states and which types of states are to be &quot;fit&quot; to the data.
See <code><a href="#topic+speciesModel">speciesModel</a></code> for details. Trials have shown that even when the number of parameters to approximate is high (e.g. 12 parameters
for &quot;fitting&quot; a 3-state movement model), the algorithm converges rapidly if the real movement suits such model.
However, as in any other method, a compromise should be sought. A good starting point is to provide a two-state species model,
in which both states are Correlated Random Walks. This model involves the approximation of 6 parameters and is sufficiently flexible for simulating a variety of movements, while not overly complex.
Note that all complex models can accomodate to simpler ones (i.e. the simpler models are special cases of the complex ones).
</p>
<p>To assess the convergence of the algorithm, an utility plotting function is provided, see the example below and <code><a href="#topic+generationPlot">generationPlot</a></code> for details.
</p>


<h3>Value</h3>

<p>The object returned by <code><a href="mco.html#topic+nsga2">nsga2</a></code> (package <code>mco</code>), see details therein. If <code>generations</code> is a vector (which is recommended,
for assessing convergence), this object contains the approximated input parameter values in each generation given in the vector. See examples
for easily plotting results.
</p>


<h3>Note</h3>

<p>This function is an experimental feature, here provided only to guide the user on how to parameterize the simulations. Care must be taken
when interpreting the results, at least by assessing algorithm convergence and visually comparing simulations with the approximated
parameters to the real data (see examples).
</p>


<h3>References</h3>


<ul>
<li><p>Deb, K., Pratap, A., Agarwal, S., &amp; Meyarivan, T. 2002. A fast and elitist multiobjective genetic algorithm: NSGA-II. IEEE Transactions on Evolutionary Computation, 6(2), 182-197.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate">simulate</a></code>, <code><a href="#topic+generationPlot">generationPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(SiMRiv)
library(adehabitatLT)

## simulate "real" data, a Levy walk, for which we want to
## parameterize our model

real.data &lt;- simm.levy(1:500)[[1]][, 1:2]

## Define a species model to adjust. Let's assume we don't know
## much about what kind of real data we have, hence define
## a flexible model: a two-state correlated random walk model
## with variable step lengths.
## This model implies "estimating" 6 parameters:
##   - turning angle correlation of state 1 [0, 1]
##   - turning angle correlation of state 2 [0, 1]
##   - switching probability S1 -&gt; S2 [0, 1]
##   - switching probability S2 -&gt; S1 [0, 1]
##   - maximum step length of state 1 [0, ?]
##   - maximum step length of state 2 [0, ?]

## Let's assume we want to simulate at a 20 times higher time frequency
## than real data.
## In order to allow our model to adjust to real data, we have
## to provide a maximum allowable step length to the optimization algorithm
## that allows to recover real data after downsampling 20 times.
## Let's make a simple calculation of the step lengths of real data:

tmp &lt;- sampleMovement(real.data)

## and compute a good maximum allowed step length during optimization
## using the observed maximum divided by 20 (because each real step
## will comprise 20 simulated steps)

max.step.length &lt;- max(tmp$stat[, "steplengths"]) / 20

## and finally build the species model with it.
## Note: "CRW.CRW.sl" is the short name for the model we want,
## as defined above

species.model &lt;- speciesModel("CRW.CRW.sl", steplength = max.step.length)

## now run optimization

sol &lt;- adjustModel(real.data, species.model, resol = 20
	, nbins.hist = c(3, 3, 0), step.hist.log = TRUE)

## After finishing, we can extract the input parameters of the optimized
## solutions (100 by default) in the last generation (generation 1000
## by default):

pars &lt;- sol[[length(sol)]]$par

## now we can take the optimized solutions and reconstruct species
## based on them:

optimized.species &lt;- apply(pars, 1, species.model)

## and make some simulations with those optimized species.
## Plot real trajectory

par(mfrow = c(2, 2), mar = c(0, 0, 1, 0))
plot(real.data, type = "l", asp = 1, axes = F, main = "Real")

## plot three simulated trajectories with optimized species

for(i in 1:3) {
	# remember we want to simulate at a 20 times higher frequency
	# so we do 500 (real data) x 20 steps
	sim &lt;- simulate(optimized.species[[i]], 500 * 20)
	
	# now we downsample frequency to match real
	samp &lt;- sampleMovement(sim, 20)
	
	# and plot the simulated trajectory before and after
	# downsampling 20 times.
	
	plot(sim[, 1:2], type = "l", asp = 1, axes = F, col = "gray"
		, main = "Simulated and downsampled")
	lines(samp$relocs, col = "black")
}

## Now plot the evolution of parameters along algorithm's generations.
## This is good to assess whether the final solutions converged
## but see ?generationPlot for details

generationPlot(sol, species.model)


## End(Not run)
</code></pre>

<hr>
<h2 id='Arith-methods'>Shortcuts for defining species movement states</h2><span id='topic+Arith-methods'></span><span id='topic++2B-methods'></span><span id='topic++2B+2Clist+2Cstate-method'></span><span id='topic++2B+2Cspecies+2CANY-method'></span><span id='topic++2B+2Cstate+2Clist-method'></span><span id='topic++2B+2Cstate+2Cnumeric-method'></span><span id='topic++2B+2Cstate+2Cstate-method'></span><span id='topic++2A+2Cstate+2Cnumeric-method'></span><span id='topic++2A+2Cspecies+2CANY-method'></span>

<h3>Description</h3>

<p>Shortcuts for defining species movement states with the arithmetic operators <code> +, *</code>.
</p>
<p>The <code>+</code> applied to states or species and a number defines the step length of one behavioural state or of all states of a species.
</p>
<p>The <code>*</code> applied to states or species and a number defines the radius of the perceptual range of one behavioural state or of all states of a species.
</p>
<p>Further, states can be combined with <code>+</code> to define multistate movements in a species. See examples.
</p>


<h3>Methods</h3>


<dl>
<dt><code>signature(e1 = "list", e2 = "state")</code></dt><dd>
<p>Adds one state to a list of states.
</p>
</dd>
<dt><code>signature(e1 = "species", e2 = "ANY")</code></dt><dd>
<p>Applies the operation to all states in the given species.
</p>
</dd>
<dt><code>signature(e1 = "state", e2 = "list")</code></dt><dd>
<p>Adds one state to a list of states.
</p>
</dd>
<dt><code>signature(e1 = "state", e2 = "numeric")</code></dt><dd>
<p>Sets the step length of the given state to the given value.
</p>
</dd>
<dt><code>signature(e1 = "state", e2 = "state")</code></dt><dd>
<p>Combines two states in a list of states to be used with <code><a href="#topic+species">species</a></code>.
</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+species">species</a></code>, <code><a href="#topic+state">state</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a species with two states
twostatespecies &lt;- species(state.RW() + state.CRW(0.9)
  , transitionMatrix(0.01, 0.02))

# set the perception window radius of both states to 200
# and the step length to 10
twostatespecies &lt;- twostatespecies * 200 + 10
</code></pre>

<hr>
<h2 id='binCounts'>Count values in given bins</h2><span id='topic+binCounts'></span>

<h3>Description</h3>

<p>A convenience function to count the values (optionally log-transformed) falling within given equal-range bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binCounts(data, range, nbins, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binCounts_+3A_data">data</code></td>
<td>
<p>a numeric vector with the data.</p>
</td></tr>
<tr><td><code id="binCounts_+3A_range">range</code></td>
<td>
<p>the closed data range in which to divide bins, as a two-element numeric vector. Values falling outside <code>range</code> are discarded.</p>
</td></tr>
<tr><td><code id="binCounts_+3A_nbins">nbins</code></td>
<td>
<p>the number of bins to split the data. Result is guaranteed to have this number of bins, irrespective of data.</p>
</td></tr>
<tr><td><code id="binCounts_+3A_log">log</code></td>
<td>
<p>whether or not to log-transform data and ranges before binning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is just a convenience function to simplify the task of couting data in equal bins.
The same result could be achieved with <code>hist</code> with the right arguments.
It is mostly used internally by <code><a href="#topic+adjustModel">adjustModel</a></code> during the approximation on input parameters,
for the computation of objectives.
</p>


<h3>Value</h3>

<p>A named vector with the counts of values in each bin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjustModel">adjustModel</a></code>.
</p>

<hr>
<h2 id='generationPlot'>Plots input parameter optimization results</h2><span id='topic+generationPlot'></span>

<h3>Description</h3>

<p>Plots the evolution of the optimized solutions (sets of input parameters) along the <code><a href="#topic+adjustModel">adjustModel</a></code> algorithm's generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  generationPlot(solutions, species.model
    , plot.quantiles = c(0.10, 0.5, 0.90), only.pareto = FALSE
    , show.legend = TRUE, lwd = 1.5, mar = c(2.3, 2.3, 0.2, 2.3)
    , mgp = c(1.2, 0.2, 0), tcl = -0.25, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generationPlot_+3A_solutions">solutions</code></td>
<td>
<p>the result of <code><a href="#topic+adjustModel">adjustModel</a></code>.</p>
</td></tr>
<tr><td><code id="generationPlot_+3A_species.model">species.model</code></td>
<td>
<p>the species model that was adjusted and that was passed to <code><a href="#topic+adjustModel">adjustModel</a></code>.</p>
</td></tr>
<tr><td><code id="generationPlot_+3A_plot.quantiles">plot.quantiles</code></td>
<td>
<p>the three quantiles to plot. The middle is plotted as a solid line, the extremes define the shaded area.</p>
</td></tr>
<tr><td><code id="generationPlot_+3A_only.pareto">only.pareto</code></td>
<td>
<p>whether to display the quantiles only of the Pareto front (<code>TRUE</code>) or of all solutions (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="generationPlot_+3A_show.legend">show.legend</code></td>
<td>
<p>whether to show a legend indicating the correspondence of colors - input parameters.</p>
</td></tr>
<tr><td><code id="generationPlot_+3A_lwd">lwd</code></td>
<td>
<p>line width to be used to draw the middle quantile (usually the median).</p>
</td></tr>
<tr><td><code id="generationPlot_+3A_mar">mar</code>, <code id="generationPlot_+3A_mgp">mgp</code>, <code id="generationPlot_+3A_tcl">tcl</code>, <code id="generationPlot_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generation plot depicts, for each generation of the optimization algorithm, the given quantiles of each input parameter being optimized
in the population of solutions. This is not the ideal plot because input parameters are plotted independently, while they are only supposed to
make sense in the context of a given solution (i.e. it is the combination of the input parameters that is being optimized, not the parameters in isolation).
</p>
<p>Nonetheless, this plot is still a good way to assess whether the final solutions converged to stable values, which can indicate that the algorithm succeeded in replicating the real trajectory provided.
However, note that depending on how the problem is formulated, the solutions might not be expected to converge to a single solution &quot;type&quot;:
for example, there can be two types of solutions, corresponding to two different ways of achieving similar results.
</p>


<h3>Value</h3>

<p>Returns, invisibly, a 3-D matrix with the computed quantiles for all input parameters along generations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjustModel">adjustModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see ?adjustModel for a complete example
</code></pre>

<hr>
<h2 id='perceptualRange'>Define a perceptual range</h2><span id='topic+perceptualRange'></span>

<h3>Description</h3>

<p>Defines the perceptual range to be used in a movement state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perceptualRange(type = "circular", radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perceptualRange_+3A_type">type</code></td>
<td>
<p>defines the type of weights that are given to each pixel, according to the distance to its center. One of <code>circular</code> or <code>gaussian</code>.</p>
</td></tr>
<tr><td><code id="perceptualRange_+3A_radius">radius</code></td>
<td>
<p>the radius of the circular perceptual range, or the sigma of the gaussian perceptual range, in map units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The perceptual range is often defined as the distance (radius) at which the species perceives the environment, 
based, e.g., on sense of smell, vision, audition, etc. (<cite>Lima &amp; Zollner 1996</cite>; <cite>Powell 2000</cite>).
In SiMRiv, perceptual range should be seen as the distance (radius) at which the species evaluates the landscape resistance around its current location, influencing species next heading.
Perceptual range size can be defined (in meters or other map units) based on available literature (on species perceptual range, or, as its surrogate, species home range size), on expert-based criteria, or be estimated from real data.
</p>
<p>A <code>circular</code> range gives equal weight to all pixels, which form a circle centered on current individual's position.
A <code>gaussian</code> range gives weights corresponding to a gaussian kernel centered on current individual's position.
</p>


<h3>References</h3>


<ul>
<li><p>Lima, S. L., &amp; Zollner, P. A. (1996). Towards a behavioral ecology of ecological landscapes. Trends in Ecology &amp; Evolution, 11(3), 131-135.
</p>
</li>
<li><p>Powell, R. A. 2000. Animal home ranges and territories and home range estimators. In: Research techniques in animal ecology: controversies and consequences, 442. Boitani, L., &amp; Fuller, T. (Eds.). Columbia university press, New York: pp.65-110.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+state">state</a></code>.
</p>

<hr>
<h2 id='resistanceFromShape'>Build resistance raster by combining shapefiles</h2><span id='topic+resistanceFromShape'></span>

<h3>Description</h3>

<p>Creates a resistance raster to be used in simulations, by rasterizing and combining different shapefiles.
It is basically a helper function that uses the functions from package <code><a href="raster.html#topic+raster-package">raster-package</a></code> to create and manipulate
such raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  resistanceFromShape(shp, baseRaster, res, binary = is.na(field)
	, field = NA, background = 1, buffer = NA, margin = 0
	, mapvalues = NA, extend = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resistanceFromShape_+3A_shp">shp</code></td>
<td>
<p>either a character string specifying the shapefile filename or a shapefile object itself.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_baseraster">baseRaster</code></td>
<td>
<p>if provided, a raster onto which to stack the given rasterized shapefile. If not provided, a new raster will be created.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_res">res</code></td>
<td>
<p>the desired pixel resolution of the raster to be created, when <code>baseRaster</code> is not provided.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_binary">binary</code></td>
<td>
<p>if TRUE, the shapefile will be rasterized so that any feature is assigned a value of 0, and the background 1.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_field">field</code></td>
<td>
<p>either a number in the range [0-1], in which case it will be assigned to all pixels covered by features of the shapefile; or the name of the numeric shapefile field from which to extract such number; or the name of the factor shapefile field containing classes to map to resistance values (see <code>mapvalues</code>).</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_background">background</code></td>
<td>
<p>the value in the range [0-1] to assign to all pixels that are not covered by any shapefile feature.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_buffer">buffer</code></td>
<td>
<p>the size of a buffer to build around every shapefile feature before rasterizing.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_margin">margin</code></td>
<td>
<p>the margin to leave around the shapefile's extent when rasterizing (i.e. how much to increase shapefile's extent).</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_mapvalues">mapvalues</code></td>
<td>
<p>a named vector specifying the resistance value mapping from the classes of <code>field</code>.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_extend">extend</code></td>
<td>
<p>set to TRUE to extend <code>baseRaster</code> if the shapefile has a larger extent. If FALSE, the shapefile will be clipped to <code>baseRaster</code>'s extent.</p>
</td></tr>
<tr><td><code id="resistanceFromShape_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code><a href="raster.html#topic+rasterize">rasterize</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function rasterizes the given shapefile using provided options and optionally stacks it onto the provided <code>baseRaster</code>.
The produced raster does not contain NAs and all values are in the range [0, 1]. All the areas of the raster for which data is not provided are assigned the value of <code>background</code>.
</p>
<p>When combining a shapefile to an existing <code>baseRaster</code>, only the areas covered by features are updated in the base raster;
all the remaining areas are left with the original values of <code>baseRaster</code>. If the shapefile to combine has a larger extent than <code>baseRaster</code>,
those extra pixels will be assigned the <code>background</code> value defined for the shapefile (not use the original background of <code>baseRaster</code>).
</p>


<h3>Value</h3>

<p>The resistance raster, an object of class <code><a href="raster.html#topic+RasterLayer-class">RasterLayer-class</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate">simulate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example taken from the vignette; see the vignette
## for more details and examples.
## In this example we read a land cover shapefile and
## assign resistance values based on each polygon's
## land cover class (provided in the field 'coverclass')

landcover &lt;- resistanceFromShape(
  system.file("doc/landcover.shp", package="SiMRiv")
  , res = 150, field = "coverclass", mapvalues = c(
    "forest" = 0.5, "urban" = 1, "dam" = 0
    , "shrubland" = 0.75), background = 0.95)
    
## We then combine it with a river network from another
## shapefile, assigning a value of 0 to all rivers

river.landcover &lt;- resistanceFromShape(
  system.file("doc/river-sample.shp", package="SiMRiv")
  , baseRaster = landcover, buffer = 100, field = 0
  , background = 0.95, margin = 1000)

plot(river.landcover, axes = FALSE, mar = c(0, 0, 0, 2))

</code></pre>

<hr>
<h2 id='river'>Sample River Network in Raster Format</h2><span id='topic+river'></span>

<h3>Description</h3>

<p>This is a <code>RasterLayer</code> object representing a river network, with a 30 meter pixel size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>river</code></pre>


<h3>Format</h3>

<p>A <code>RasterLayer</code> object (package <code>raster</code>)</p>

<hr>
<h2 id='sampleMovement'>Resample a simulated movement and compute step-wise statistics</h2><span id='topic+sampleMovement'></span>

<h3>Description</h3>

<p>Resamples a movement simulated with the function <code><a href="#topic+simulate">simulate</a></code> to a lower temporal resolution (frequency).
Simultaneously, computes step length, turning angles (<cite>Turchin 1998</cite>) and accumulated resistance
for each resampled step, assuming that a straight line connects each re-sampled location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sampleMovement(relocs, resolution = 1, resist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleMovement_+3A_relocs">relocs</code></td>
<td>
<p>the simulated movement, an object returned by <code><a href="#topic+simulate">simulate</a></code>. NOTE: currently this is only implemented for simulations of single individuals.</p>
</td></tr>
<tr><td><code id="sampleMovement_+3A_resolution">resolution</code></td>
<td>
<p>movement will be resampled every this number of time ticks. If 1, no resampling is done (but metrics are computed).</p>
</td></tr>
<tr><td><code id="sampleMovement_+3A_resist">resist</code></td>
<td>
<p>a landscape resistance raster, usually the same that was used in <code>simulate</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function mimics what happens in real world movement data: it resamples the simulated movement
(which is supposed to be infinitesimal) into a lower temporal resolution, so that it is comparable to real world field data (e.g. telemetry data).
During the process, it computes, for each resampled step:
</p>

<ul>
<li><p>the step length
</p>
</li>
<li><p>the turning angle
</p>
</li>
<li><p>the accumulated resistance along the step, assuming a straight line is taken from start to end
</p>
</li></ul>



<h3>Value</h3>

<p>A list with the components <code>relocs</code> and <code>stats</code>.
</p>
<p><code>relocs</code> contains the resampled positions, <code>stats</code> contains the metrics for each step (which has N-2 rows because of the turning angles).
</p>


<h3>Note</h3>

<p>These metrics are only meaningful for <code>resolution</code> &gt;&gt; 1, otherwise they are just a consequence of the simulation input parameters.
</p>


<h3>References</h3>


<ul>
<li><p>Turchin, P. 1998. Quantitative analysis of movement: measuring and modeling population redistribution in animals and plants (Vol. 1). Sinauer Associates, Sunderland, MA.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate">simulate</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SiMRiv)

LevyWalker &lt;- species(
  state.RW() + state.CRW(0.99),
  trans = transitionMatrix(0.005, 0.02))

sim &lt;- simulate(LevyWalker, 10000)
resamp &lt;- sampleMovement(sim, 50)
plot(sim, type="l", asp=1, col = "#777777")
lines(resamp$relocs, col = "red")
</code></pre>

<hr>
<h2 id='SiMRiv-package'>
Simulating Multistate Movements in River/Heterogeneous Landscapes
</h2><span id='topic+SiMRiv-package'></span><span id='topic+SiMRiv'></span>

<h3>Description</h3>

<p>Provides functions to generate and analyze individual-based, spatially-explicit simulations of multi-state movements in homogeneous or heterogeneous
landscapes, based on &quot;resistance&quot; rasters. Although originally conceived and designed to simulate spatially-explicit
trajectories of species constrained to linear habitats or dendritic ecological networks (e.g., river networks), the simulation algorithm is built to be highly
flexible and can be applied to any (aquatic, semi-aquatic or terrestrial) organism, independently of the landscape in which it moves. Thus, the user will be able to use the package to
simulate movements either in homogeneous landscapes, heterogeneous landscapes (e.g. semi-aquatic animal moving mainly along rivers but also using the matrix),
or even in highly contrasted landscapes (e.g. fish in a river network). The algorithm and its input parameters are the same for all cases, so that
results are comparable. Simulated trajectories can then be used as mechanistic null models (Moorcroft and Lewis 2006) to test e.g. for
species site fidelity (Powell 2000) and other 'Movement Ecology' hypotheses (Nathan et al. 2008), or for other predictive purposes.
The package should thus be relevant to explore a broad spectrum of ecological phenomena, such as those at the interface of animal behaviour,
landscape, spatial and movement ecology, disease and invasive species spread, and population dynamics.
</p>


<h3>Details</h3>

<p><code><a href="#topic+simulate">simulate</a></code> is the central function. See the examples in <code>?simulate</code> to quickly get started, or the vignette for a more verbose tutorial.
</p>

<p>Index of help topics:
</p>
<pre>
Arith-methods           Shortcuts for defining species movement states
SiMRiv-package          Simulating Multistate Movements in
                        River/Heterogeneous Landscapes
adjustModel             Finds ("estimates") simulation input parameters
                        able to replicate a given (real) trajectory,
                        assuming the given species model
binCounts               Count values in given bins
generationPlot          Plots input parameter optimization results
perceptualRange         Define a perceptual range
resistanceFromShape     Build resistance raster by combining shapefiles
river                   Sample River Network in Raster Format
sampleMovement          Resample a simulated movement and compute
                        step-wise statistics
simulate                Simulate movements in river networks,
                        homogeneous, or heterogeneous landscapes
species                 Create a species
speciesModel            Defines a species model to adjust to a real
                        trajectory
state                   Define a movement state
transitionMatrix        Define a state transition matrix
</pre>

<p>Further information is available in the following vignettes:<br /><br />
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>SiMRiv</code> </td><td style="text-align: left;"> Usage of the SiMRiv package (source)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>References</h3>


<ul>
<li><p>Powell, R. A. 2000. Animal home ranges and territories and home range estimators. In: Research techniques in animal ecology: controversies and consequences, 442. Boitani, L., &amp; Fuller, T. (Eds.). Columbia university press, New York: pp.65-110.
</p>
</li>
<li><p>Moorcroft, P. R. &amp; Lewis, M. A. 2006. Mechanistic Home Range Analysis. Monographs in Population Biology 43. Eds. Levin S.A. and H.S. Horn. Princeton University Press. pp 172.
</p>
</li>
<li><p>Nathan, R., Getz, W. M., Revilla, E., Holyoak, M., Kadmon, R., Saltz, D., &amp; Smouse, P. E. 2008. A movement ecology paradigm for unifying organismal movement research. Proceedings of the National Academy of Sciences,105(49), 19052-19059.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## a simple Levy-like movement in homogeneous space
## see ?simulate for more complex examples

LevyWalker &lt;- species(
    state.RW() + state.CRW(0.99),
    transitionMatrix(0.005, 0.02))

sim &lt;- simulate(LevyWalker, 20000)
plot(sim, type="l", asp=1)
</code></pre>

<hr>
<h2 id='simulate'>Simulate movements in river networks, homogeneous, or heterogeneous landscapes</h2><span id='topic+simulate'></span>

<h3>Description</h3>

<p>Performs fast and spatially-explicit simulation of multi-state random movements (<cite>Morales et al. 2004, McClintock et al. 2012</cite>) of individuals created with the function <code><a href="#topic+species">species</a></code> in an optional landscape resistance raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate(individuals, time, coords = NULL
  , states = NULL, resist = NULL, angles = NULL
  , start.resistance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_individuals">individuals</code></td>
<td>
<p>a <code>species</code> or a list of N <code>species</code> whose movements are to be simulated</p>
</td></tr>
<tr><td><code id="simulate_+3A_time">time</code></td>
<td>
<p>the number of time steps to be simulated</p>
</td></tr>
<tr><td><code id="simulate_+3A_coords">coords</code></td>
<td>
<p>a N x 2 matrix giving the initial coordinates of the simulation, for each individual. Can be a vector of the form c(x, y) if only one individual is provided.</p>
</td></tr>
<tr><td><code id="simulate_+3A_resist">resist</code></td>
<td>
<p>an optional landscape resistance raster of class <code>RasterLayer</code>. If not provided, movements are simulated in an homogeneous environment.</p>
</td></tr>
<tr><td><code id="simulate_+3A_angles">angles</code></td>
<td>
<p>an optional numeric vector of length N defining the initial heading of each individual, in radians. Zero is north and angles increase clockwise.</p>
</td></tr>
<tr><td><code id="simulate_+3A_start.resistance">start.resistance</code></td>
<td>
<p>an optional scalar in the range [0, 1] giving the maximum resistance value in which the individuals are allowed to start, if <code>coords</code> is <code>NULL</code> and <code>resist</code> is provided</p>
</td></tr>
<tr><td><code id="simulate_+3A_states">states</code></td>
<td>
<p>Not implemented yet. An optional numeric vector of length N defining the initial state of each individual.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a mechanistic simulation of the movement of the given individual/s (when more than one individual is given,
their movements are simulated simultaneously) in the given landscape raster defining physical resistance values.
At present, multiple individuals do not interact, but in the upcoming version it will be possible to
define positive and negative interactions between simulated individuals, thus accounting for spatial bias.
</p>
<p>The simulation runs in a series of micro-steps, and is intended to be a high-resolution simulation
(which can be later sampled with <code><a href="#topic+sampleMovement">sampleMovement</a></code> to emulate real field data, e.g. telemetry data).
</p>
<p>In summary, at each micro-step the individual chooses a random direction which is based on the previous step heading and
in the resistance context at the current position, such that it will avoid heading to areas with high resistance.
This evaluation depends on the individual's perceptual range in the current movement state.
At each step, a test to see if the individual changes its state is also performed, based on the provided <code><a href="#topic+transitionMatrix">transitionMatrix</a></code>.
Each state may have its own perceptual range, step length and angular correlation (with previous step heading). It's up to the user the
definition of these values (e.g., expert- or literature-based), but we provide an experimental function to numerically approximate these
values from real data, see <code><a href="#topic+adjustModel">adjustModel</a></code>.
</p>
<p>In more detail, in each of the <code>time</code> steps, the procedure is as follows:
</p>

<ol>
<li><p>Draw state for the current step according to state transition matrix and previous state
</p>
</li>
<li><p>Compute empirical probability density for changing heading, from the landscape raster values around current position (resistance component). See details below.
</p>
</li>
<li><p>Compute probability density for changing heading, given the previous step heading and correlation defined in the current state (correlated walk component)
</p>
</li>
<li><p>Intersect the resistance component with the correlated walk component to make a compound probability density for changing heading
</p>
</li>
<li><p>Draw the new heading from the probability density distribution computed above
</p>
</li>
<li><p>Compute the length of the step that will be taken as a fraction of current step's defined length proportional to mean resistance of the starting and ending points in the chosen heading
</p>
</li>
<li><p>Move to the new position, defined by the drawn heading and length of step.
</p>
</li></ol>



<h4>Details of the simulation algorithm</h4>



<h5>The landscape resistance raster</h5>

<p>This raster represents the amount of physical resistance that is offered to the simulated individuals. The values must be between 0 (no resistance) and 1 (infinite resistance).
In the future, other types of rasters can be provided, for example rasters for resource
availability, habitat suitability and points of attraction/repulsion, allowing to conduct simulations
with various types of spatial bias.
</p>
<p>A careful choice of pixel size must be taken for the resistance raster. If rasterizing from vector lines (e.g. river network),
please be sure to adjust the pixel size so that there are no gaps between river pixels and all pixels of the river are connected
orthogonally.
</p>



<h5>The empirical probability density</h5>

<p>The empirical probability density for a given point (resistance component) is computed by summing the <code>1 - resistance</code> values along a set of discrete radial lines departing from that point, forming a circle.
The length of the lines (i.e. radius) and weighting given to each pixel are defined in the current state's perceptual range.
The sums are packed and used as the circular empirical distribution of the resistance component.
This will be crossed with the correlated walk component to yield the final empirical probability distribution from which heading will be drawn.
</p>




<h3>Value</h3>

<p>A matrix with 3 columns for each simulated individual, in the order x1, y1, state1, x2, y2, state2, ...; and the same number of rows as the simulation length (given by <code>time</code>).
</p>


<h3>Note</h3>

<p>The structure of the returned object will change in the upcoming version.</p>


<h3>References</h3>


<ul>
<li><p>McClintock, B. T., King, R., Thomas, L., Matthiopoulos, J., McConnell, B. J., &amp; Morales, J. M. 2012. A general discrete-time modeling framework for animal movement using multistate random walks. Ecological Monographs, 82(3), 335-349.
</p>
</li>
<li><p>Morales, J. M., Haydon, D. T., Frair, J., Holsinger, K. E., &amp; Fryxell, J. M. 2004. Extracting more out of relocation data: building movement models as mixtures of random walks. Ecology, 85(9), 2436-2445.
</p>
</li>
<li><p>Sims, D. W., Southall, E. J., Humphries, N. E., Hays, G. C., Bradshaw, C. J., Pitchford, J. W., ... &amp; Morritt, D. 2008. Scaling laws of marine predator search behaviour. Nature, 451(7182), 1098-1102.
</p>
</li>
<li><p>Turchin, P. 1998. Quantitative analysis of movement: measuring and modeling population redistribution in animals and plants (Vol. 1). Sinauer Associates, Sunderland, MA.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+species">species</a></code>, <code><a href="#topic+sampleMovement">sampleMovement</a></code>, <code><a href="#topic+adjustModel">adjustModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SiMRiv)

## A classic: simple random walk (Brownian motion) (Turchin 1998)
## i.e. single-state uncorrelated movement in an homogeneous landscape
######################################################################

## a single state, other parameters set to defaults

rand.walker &lt;- species(state.RW())
sim &lt;- simulate(rand.walker, 10000)
plot(sim, type="l", asp=1)

## two random walkers
#####################

sim &lt;- simulate(list(rand.walker, rand.walker), 10000)
plot(sim[,1:2], type="l", asp=1, xlim=range(sim), ylim=range(sim), col=2)
lines(sim[,4:5], col=3)

## Another classic: Levy walk-like movement (e.g. Sims et al. 2008)
## i.e. two-state movement: composition of small-scale random walks
## with bursts of longer, correlated random walks
###################################################################

LevyWalker &lt;- species(
    state.RW() + state.CRW(0.99),
    transitionMatrix(0.005, 0.02))
    
sim &lt;- simulate(LevyWalker, 10000)
plot(sim, type="l", asp=1)

## Linear habitats, e.g. fish in a river network
################################################

## load sample river raster in a fish's perspective,
## i.e. resistance is 0 within the river, 1 otherwise.

data(river)

## let's try a Levy-like movement in a river network
## note: perceptual range radii and step lengths must be
## adequate to the raster resolution!

LevyWalker &lt;- species(list(
    state(0, perceptualRange("cir", 100), 10, "RandomWalk")
    ,state(0.97, perceptualRange("cir", 500), 20, "CorrelatedRW")
), transitionMatrix(0.005, 0.001))

## NOTE: the following lines do exactly the same as above, but
## using the more convenient arithmetic operator shortcuts

LevyWalker &lt;- species(
	(state.RW() * 100 + 10) + (state.CRW(0.97) * 500 + 20)
, transitionMatrix(0.005, 0.001))

sim &lt;- simulate(LevyWalker, 20000, resist = river
    , coords = c(280635, 505236))

## plot movement; we use a high-res TIFF so that it
## can be viewed in detail
## Not run: 
tiff("movement.tif", wid=5000, hei=5000, comp="lzw")
par(mar = c(0, 0, 0, 0))
plot(river, asp = 1, col = gray(seq(1, 0.5, len = 2))
    , ylim = range(sim[,2]), xlim = range(sim[,1]), axes = FALSE)
lines(sim, lwd = 2, col = "#0000ffcc")
dev.off()

## End(Not run)

## if we want the kernel density overlaid,
## uncomment these and put before dev.off()
# library(ks)
# d &lt;- kde(sim[,1:2])
# plot(d, disp = "image", add=TRUE
#    , col = rgb(1, 0, 0, seq(0, 1, len = 15)))
</code></pre>

<hr>
<h2 id='species'>Create a species</h2><span id='topic+species'></span>

<h3>Description</h3>

<p>Creates a species, characterized by one or more behavioral states, to be simulated with function <code><a href="#topic+simulate">simulate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  species(states, trans = transitionMatrix(), name = "&lt;unnamed&gt;"
    , resistanceMap = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="species_+3A_states">states</code></td>
<td>
<p>a list of <code>state</code>s characterizing the behavior of the species, or a single <code>state</code>, for simple movements</p>
</td></tr>
<tr><td><code id="species_+3A_trans">trans</code></td>
<td>
<p>a square state transition matrix, defining the probability of changing between states. For convenience, use the function <code><a href="#topic+transitionMatrix">transitionMatrix</a></code>. Can be omitted if this species has a single-state movement.</p>
</td></tr>
<tr><td><code id="species_+3A_name">name</code></td>
<td>
<p>the name of the species</p>
</td></tr>
<tr><td><code id="species_+3A_resistancemap">resistanceMap</code></td>
<td>
<p>not used. Will be implemented in future versions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rows and columns of the transition matrix correspond in the same order to the list of states.
The matrix is not symmetric, and is read along the rows, i.e. the probability of changing
from state 2 to state 1 is located in row 2, column 1; hence rows must sum to 1 but columns not.
</p>


<h3>Value</h3>

<p>An object of class <code>species</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate">simulate</a></code>, <code><a href="#topic+perceptualRange">perceptualRange</a></code>, <code><a href="#topic+state">state</a></code>, <code><a href="#topic+transitionMatrix">transitionMatrix</a></code>, <code><a href="#topic+Arith-methods">Arith-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from 'simulate'

## note: perceptual range radii and step lengths must be
## adequate to the raster resolution!

LevyWalker &lt;- species(
	(state.RW() * 100 + 10) + (state.CRW(0.97) * 500 + 20)
, transitionMatrix(0.005, 0.001))
</code></pre>

<hr>
<h2 id='speciesModel'>Defines a species model to adjust to a real trajectory</h2><span id='topic+speciesModel'></span>

<h3>Description</h3>

<p>The sole purpose of this function is to be used in conjunction with <code><a href="#topic+adjustModel">adjustModel</a></code>. It is used to tell the optimization
algorithm which parameters are to be approximated, and which are constant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  speciesModel(type, perceptual.range = 0, steplength = 1
    , prob.upperbound = 0.5, max.concentration = 0.99)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="speciesModel_+3A_type">type</code></td>
<td>
<p>the type of movement to &quot;fit&quot;. One of <code>CRW</code>, <code>RW.CRW</code>, <code>CRW.CRW</code>, <code>RW.CRW.sl</code>, <code>CRW.CRW.sl</code></p>
</td></tr>
<tr><td><code id="speciesModel_+3A_perceptual.range">perceptual.range</code></td>
<td>
<p>the perceptual range for all states.</p>
</td></tr>
<tr><td><code id="speciesModel_+3A_steplength">steplength</code></td>
<td>
<p>the fixed step length for fixed step length types <code>CRW</code>, <code>RW.CRW</code>, <code>CRW.CRW</code> or the maximum allowed value for variable step length types <code>RW.CRW.sl</code>
, <code>CRW.CRW.sl</code>, <code>CRW.CRW.CRW.sl</code> and <code>CRW.RW.Rest.sl</code>.</p>
</td></tr>
<tr><td><code id="speciesModel_+3A_prob.upperbound">prob.upperbound</code></td>
<td>
<p>the maximum allowed value for the state switching probabilities. The default is 0.5 because very high state switching probabilities don't make much sense from a biological point of view.</p>
</td></tr>
<tr><td><code id="speciesModel_+3A_max.concentration">max.concentration</code></td>
<td>
<p>the maximum allowed value for the turning angle concentration parameter for CRWs [0, 1]. By default it is set to 0.99 because values higher than this (for technical reasons) result in straight line paths, which is a technical artifact.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function defines the type of movement to be adjusted with <code><a href="#topic+adjustModel">adjustModel</a></code>. Before choosing the type, it is good practice
to plot the real trajectory and visually assess which would be the most adequate model to try. Currently included movement types are:
</p>

<ul>
<li><p><code>CRW</code>: single state CRW, fixed step length (1 parameter)
</p>
</li>
<li><p><code>RW.CRW</code>: two state RW/CRW, fixed step length (3 parameters)
</p>
</li>
<li><p><code>CRW.CRW</code>: two state CRW/CRW, fixed step length, (4 parameters)
</p>
</li>
<li><p><code>RW.CRW.sl</code>: two state RW/CRW, variable step length, (5 parameters)
</p>
</li>
<li><p><code>CRW.CRW.sl</code>: two state CRW/CRW, variable step length (6 parameters)
</p>
</li>
<li><p><code>CRW.CRW.CRW.sl</code>: three state CRW/CRW/CRW, variable step length (12 parameters)
</p>
</li>
<li><p><code>CRW.RW.Rest.sl</code>: three state CRW/RW/Rest, variable step length (7 parameters)
</p>
</li></ul>

<p>However, the user can easily write any custom function for addressing other movement types, see the code for details.
</p>


<h3>Value</h3>

<p>Returns a function that creates a species from a vector of parameter values. This function is normally used to create species
from the <code><a href="#topic+adjustModel">adjustModel</a></code> results, see examples there.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adjustModel">adjustModel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SiMRiv)

model &lt;- speciesModel("RW.CRW.sl")

# this shows the parameters that will be approximated
model

# this creates a species with 2 states
# RW and a CRW with correlation 0.9
# with the switching probabilities RW-&gt;CRW = 0.01, CRW-&gt;RW = 0.05
# and the step lengths RW = 15, CRW = 50.

species &lt;- model(c(0.9, 0.01, 0.05, 15, 50))
</code></pre>

<hr>
<h2 id='state'>Define a movement state</h2><span id='topic+state'></span><span id='topic+state.Resting'></span><span id='topic+state.RW'></span><span id='topic+state.CRW'></span>

<h3>Description</h3>

<p>Defines a behavioral state to be used when creating <code><a href="#topic+species">species</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  state(concentration, pwind = perceptualRange("circular", 0)
    , steplen = 1, name = "")
  state.Resting()    # still state
  state.RW()         # uniform random walk (brownian motion),
                     # independent of resistance
  state.CRW(concentration)  # correlated random walk,
                          # independent of resistance
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="state_+3A_concentration">concentration</code></td>
<td>
<p>turning angle concentration, a value between 0 (uniform distribution resulting in random walk) and 1 (only one value possible resulting in a straight line path)</p>
</td></tr>
<tr><td><code id="state_+3A_pwind">pwind</code></td>
<td>
<p>a <code><a href="#topic+perceptualRange">perceptualRange</a></code> definition</p>
</td></tr>
<tr><td><code id="state_+3A_steplen">steplen</code></td>
<td>
<p>the base (maximum) step length of this state in map units. Note that the actual step length depends on the resistance in each step.</p>
</td></tr>
<tr><td><code id="state_+3A_name">name</code></td>
<td>
<p>the name of the state</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+Arith-methods">Arith-methods</a></code> for more convenient ways of setting parameters, instead of using <code>state</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>state</code>.
</p>


<h3>Note</h3>

<p>The perceptual range radius and step length must be adequate to the resolution of the resistance raster (if provided in simulations).
If no raster will be provided, then the perceptual range is irrelevant, and the step length has solely a relative meaning (in relation to other states or other species).
</p>
<p>For a review of different random walks, see Codling et al. (2008)
</p>


<h3>References</h3>


<ul>
<li><p>Codling, E. A., Plank, M. J., &amp; Benhamou, S. 2008. Random walk models in biology. Journal of the Royal Society Interface, 5(25), 813-834.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+species">species</a></code>, <code><a href="#topic+perceptualRange">perceptualRange</a></code>, <code><a href="#topic+Arith-methods">Arith-methods</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a correlated random walk influenced by landscape

state(0.97, perceptualRange("cir", 500), 10, "CorrelatedRW")

## the same, but using the shortcut form

state.CRW(0.97) * 500 + 10
</code></pre>

<hr>
<h2 id='transitionMatrix'>Define a state transition matrix</h2><span id='topic+transitionMatrix'></span>

<h3>Description</h3>

<p>Defines a state transition matrix to be used when creating <code><a href="#topic+species">species</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  transitionMatrix(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitionMatrix_+3A_...">...</code></td>
<td>
<p>the probabilities that will form the matrix, see Details. If none given, returns a 1-element matrix (for one state only)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transition matrix (Markov matrix) is a square, non-symmetric matrix with all elements between 0 and 1, and whose rows must sum to 1 (but not columns).
It defines the probability of the individual changing from each behavioral state to another, and this
is tested in each time step of the simulation, hence probabilities should be small.
</p>
<p>This function is just a helper to create such matrix.
The arguments are probabilities given in the following order (example for 3 states):
</p>
<p>Probability of changing from:
</p>
<p>state 1 &ndash;&gt; state 2
</p>
<p>state 1 &ndash;&gt; state 3
</p>
<p>state 2 &ndash;&gt; state 1
</p>
<p>state 2 &ndash;&gt; state 3
</p>
<p>state 3 &ndash;&gt; state 1
</p>
<p>state 3 &ndash;&gt; state 2
</p>
<p>The diagonal (probablity of remaining in the same state) is computed so that rows sum to 1.  
</p>


<h3>Value</h3>

<p>A numeric matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+species">species</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## a 3-state transition matrix

transitionMatrix(0.01,0.02,0,0.03,0.0001,0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
