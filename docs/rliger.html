<!DOCTYPE html><html><head><title>Help for package rliger</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rliger}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.complexHeatmapDotPlot'><p>Generate dot plot from input matrix with ComplexHeatmap</p></a></li>
<li><a href='#.ggCellViolin'><p>Produce single violin plot with data frame passed from upstream</p></a></li>
<li><a href='#.ggplotLigerTheme'><p>Generic ggplot theme setting for rliger package</p></a></li>
<li><a href='#.ggScatter'><p>Produce single scatter plot with data frame passed from upstream</p></a></li>
<li><a href='#.plotHeatmap'><p>General heatmap plotting with prepared matrix and data.frames</p></a></li>
<li><a href='#as.liger.dgCMatrix'><p>Converting other classes of data to a liger object</p></a></li>
<li><a href='#as.ligerDataset.ligerDataset'><p>Converting other classes of data to a ligerDataset object</p></a></li>
<li><a href='#bmmc'><p>liger object of bone marrow subsample data with RNA and ATAC modality</p></a></li>
<li><a href='#calcAgreement'><p>Calculate agreement metric after integration</p></a></li>
<li><a href='#calcAlignment'><p>Calculate alignment metric after integration</p></a></li>
<li><a href='#calcARI'><p>Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables</p></a></li>
<li><a href='#calcDatasetSpecificity'><p>Calculate a dataset-specificity score for each factor</p></a></li>
<li><a href='#calcPurity'><p>Calculate purity by comparing two cluster labeling variables</p></a></li>
<li><a href='#closeAllH5'><p>Close all links (to HDF5 files) of a liger object</p></a></li>
<li><a href='#commandDiff'><p>Check difference of two liger command</p></a></li>
<li><a href='#convertOldLiger'><p>Convert old liger object to latest version</p></a></li>
<li><a href='#coordinate'><p>Access ligerSpatialDataset coordinate data</p></a></li>
<li><a href='#createH5LigerDataset'><p>Create on-disk ligerDataset Object</p></a></li>
<li><a href='#createLiger'><p>Create liger object</p></a></li>
<li><a href='#createLigerDataset'><p>Create in-memory ligerDataset object</p></a></li>
<li><a href='#downsample'><p>Downsample datasets</p></a></li>
<li><a href='#exportInteractTrack'><p>Export predicted gene-pair interaction</p></a></li>
<li><a href='#getFactorMarkers'><p>Find shared and dataset-specific markers</p></a></li>
<li><a href='#getProportionMito'><p>Calculate proportion mitochondrial contribution</p></a></li>
<li><a href='#H5Apply'><p>Apply function to chunks of H5 data in ligerDataset object</p></a></li>
<li><a href='#importPBMC'><p>Import prepared dataset publically available</p></a></li>
<li><a href='#imputeKNN'><p>Impute the peak counts from gene expression data referring to an ATAC dataset</p>
after integration</a></li>
<li><a href='#is.newLiger'><p>Check if given liger object if under new implementation</p></a></li>
<li><a href='#isH5Liger'><p>Check if a liger or ligerDataset object is made of HDF5 file</p></a></li>
<li><a href='#liger-class'><p>liger class</p></a></li>
<li><a href='#ligerATACDataset-class'><p>Subclass of ligerDataset for ATAC modality</p></a></li>
<li><a href='#ligerCommand-class'><p>ligerCommand object: Record the input and time of a LIGER function call</p></a></li>
<li><a href='#ligerDataset-class'><p>ligerDataset class</p></a></li>
<li><a href='#ligerMethDataset-class'><p>Subclass of ligerDataset for Methylation modality</p></a></li>
<li><a href='#ligerRNADataset-class'><p>Subclass of ligerDataset for RNA modality</p></a></li>
<li><a href='#ligerSpatialDataset-class'><p>Subclass of ligerDataset for Spatial modality</p></a></li>
<li><a href='#ligerToSeurat'><p>Convert between liger and Seurat object</p></a></li>
<li><a href='#linkGenesAndPeaks'><p>Linking genes to putative regulatory elements</p></a></li>
<li><a href='#louvainCluster-deprecated'><p>[Deprecated] Louvain algorithm for community detection</p></a></li>
<li><a href='#makeFeatureMatrix'><p>Fast calculation of feature count matrix</p></a></li>
<li><a href='#makeInteractTrack'><p>Deprecated functions in package <span class="pkg">rliger</span>.</p></a></li>
<li><a href='#makeInteractTrack-deprecated'><p>[Deprecated] Export predicted gene-pair interaction</p></a></li>
<li><a href='#makeRiverplot-deprecated'><p>[Deprecated] Generate a river (Sankey) plot</p></a></li>
<li><a href='#mapCellMeta'><p>Create new variable from categories in cellMeta</p></a></li>
<li><a href='#mergeH5'><p>Merge hdf5 files</p></a></li>
<li><a href='#mergeSparseAll'><p>Merge matrices while keeping the union of rows</p></a></li>
<li><a href='#modalOf'><p>Return preset modality of a ligerDataset object or that of all datasets in a</p>
liger object</a></li>
<li><a href='#normalize'><p>Normalize raw counts data</p></a></li>
<li><a href='#online_iNMF-deprecated'><p>[Deprecated] Perform online iNMF on scaled datasets</p></a></li>
<li><a href='#optimizeALS-deprecated'><p>[Deprecated] Perform iNMF on scaled datasets</p></a></li>
<li><a href='#optimizeNewData'><p>Perform factorization for new data</p></a></li>
<li><a href='#optimizeNewK'><p>Perform factorization for new value of k</p></a></li>
<li><a href='#optimizeNewLambda'><p>Perform factorization for new lambda value</p></a></li>
<li><a href='#optimizeSubset'><p>Perform factorization for subset of data</p></a></li>
<li><a href='#pbmc'><p>liger object of PBMC subsample data with Control and Stimulated datasets</p></a></li>
<li><a href='#pbmcPlot'><p>liger object of PBMC subsample data with plotting information available</p></a></li>
<li><a href='#plotCellViolin'><p>Generate violin/box plot(s) using liger object</p></a></li>
<li><a href='#plotClusterFactorDot'><p>Make dot plot of factor loading in cell groups</p></a></li>
<li><a href='#plotClusterGeneDot'><p>Make dot plot of gene expression in cell groups</p></a></li>
<li><a href='#plotDensityDimRed'><p>Create density plot basing on specified coordinates</p></a></li>
<li><a href='#plotDimRed'><p>Generate scatter plot(s) using liger object</p></a></li>
<li><a href='#plotGeneHeatmap'><p>Plot Heatmap of Gene Expression or Factor Loading</p></a></li>
<li><a href='#plotGeneLoadings'><p>Visualize factor expression and gene loading</p></a></li>
<li><a href='#plotGeneViolin'><p>Visualize gene expression or cell metadata with violin plot</p></a></li>
<li><a href='#plotGroupClusterDimRed'><p>Comprehensive group splited cluster plot on dimension reduction with</p>
proportion</a></li>
<li><a href='#plotMarkerHeatmap'><p>Create heatmap for showing top marker expression in conditions</p></a></li>
<li><a href='#plotProportion'><p>Visualize proportion across two categorical variables</p></a></li>
<li><a href='#plotSankey'><p>Make Riverplot/Sankey diagram that shows label mapping across datasets</p></a></li>
<li><a href='#plotSpatial2D'><p>Visualize a spatial dataset</p></a></li>
<li><a href='#plotVarFeatures'><p>Plot the variance vs mean of feature expression</p></a></li>
<li><a href='#plotVolcano'><p>Create volcano plot for Wilcoxon test result</p></a></li>
<li><a href='#quantile_norm-deprecated'><p>[Deprecated] Quantile align (normalize) factor loading</p></a></li>
<li><a href='#quantileAlignSNF'><p>Quantile align (normalize) factor loadings</p></a></li>
<li><a href='#quantileNorm'><p>Quantile Align (Normalize) Factor Loadings</p></a></li>
<li><a href='#rawPeak'><p>Access ligerATACDataset peak data</p></a></li>
<li><a href='#read10X'><p>Load in data from 10X</p></a></li>
<li><a href='#readLiger'><p>Read liger object from RDS file</p></a></li>
<li><a href='#readSubset'><p>[Deprecated] See <code>downsample</code></p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#removeMissing'><p>Remove missing cells or features from liger object</p></a></li>
<li><a href='#restoreH5Liger'><p>Restore links (to HDF5 files) for reloaded liger/ligerDataset object</p></a></li>
<li><a href='#retrieveCellFeature'><p>Retrieve a single matrix of cells from a slot</p></a></li>
<li><a href='#reverseMethData'><p>Create &quot;scaled data&quot; for DNA methylation datasets</p></a></li>
<li><a href='#runCINMF'><p>Perform consensus iNMF on scaled datasets</p></a></li>
<li><a href='#runCluster'><p>SNN Graph Based Community Detection</p></a></li>
<li><a href='#runDoubletFinder'><p>Doublet detection with DoubletFinder</p></a></li>
<li><a href='#runGeneralQC'><p>General QC for liger object</p></a></li>
<li><a href='#runGOEnrich'><p>Run Gene Ontology enrichment analysis on differentially expressed genes.</p></a></li>
<li><a href='#runGSEA'><p>Analyze biological interpretations of metagene</p></a></li>
<li><a href='#runINMF'><p>Perform iNMF on scaled datasets</p></a></li>
<li><a href='#runIntegration'><p>Integrate scaled datasets with iNMF or variant methods</p></a></li>
<li><a href='#runOnlineINMF'><p>Perform online iNMF on scaled datasets</p></a></li>
<li><a href='#runPairwiseDEG'><p>Find DEG between two groups</p></a></li>
<li><a href='#runTSNE'><p>Perform t-SNE dimensionality reduction</p></a></li>
<li><a href='#runUINMF'><p>Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features</p></a></li>
<li><a href='#runUMAP'><p>Perform UMAP Dimensionality Reduction</p></a></li>
<li><a href='#scaleNotCenter'><p>Scale genes by root-mean-square across cells</p></a></li>
<li><a href='#selectGenes'><p>Select a subset of informative genes</p></a></li>
<li><a href='#selectGenesVST'><p>Select variable genes from one dataset with Seurat VST method</p></a></li>
<li><a href='#sub-liger'><p>Subset liger with brackets</p></a></li>
<li><a href='#sub-ligerDataset'><p>Subset ligerDataset object</p></a></li>
<li><a href='#sub-sub-liger'><p>Get cell metadata variable</p></a></li>
<li><a href='#subsetLiger'><p>Subset liger object</p></a></li>
<li><a href='#subsetLigerDataset'><p>Subset ligerDataset object</p></a></li>
<li><a href='#writeH5'><p>Write in-memory data into H5 file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-20</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linked Inference of Genomic Experimental Relationships</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses an extension of nonnegative matrix factorization to identify shared and dataset-specific factors. See Welch J, Kozareva V, et al (2019) &lt;<a href="https://doi.org/10.1016%2Fj.cell.2019.05.006">doi:10.1016/j.cell.2019.05.006</a>&gt;, and Liu J, Gao C, Sodicoff J, et al (2020) &lt;<a href="https://doi.org/10.1038%2Fs41596-020-0391-8">doi:10.1038/s41596-020-0391-8</a>&gt; for more details.</td>
</tr>
<tr>
<td>Author:</td>
<td>Joshua Welch [aut],
  Yichen Wang [aut, cre],
  Chao Gao [aut],
  Jialin Liu [aut],
  Joshua Sodicoff [aut, ctb],
  Velina Kozareva [aut, ctb],
  Evan Macosko [aut, ctb],
  Paul Hoffman [ctb],
  Ilya Korsunsky [ctb],
  Robert Lee [ctb],
  Andrew Robbins [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yichen Wang &lt;wayichen@umich.edu&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/welch-lab/liger/issues">https://github.com/welch-lab/liger/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://welch-lab.github.io/liger/">https://welch-lab.github.io/liger/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td>https:/welch-lab.r-universe.dev,
<a href="https://blaserlab.r-universe.dev">https://blaserlab.r-universe.dev</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, stats, utils, R (&ge; 3.4)</td>
</tr>
<tr>
<td>Imports:</td>
<td>circlize, cli, cowplot, ComplexHeatmap, dplyr, ggplot2, grid,
hdf5r, leidenAlg (&ge; 1.1.1), lifecycle, magrittr, Matrix, RANN,
RColorBrewer, Rcpp, rlang, Rtsne, S4Vectors, scales, uwot,
viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>AnnotationDbi, DESeq2, DoubletFinder (&ge; 2.0.4),
EnhancedVolcano, fgsea, GenomicRanges, ggrepel, gprofiler2,
IRanges, knitr, org.Hs.eg.db, plotly, psych, RcppPlanc,
reactome.db, rmarkdown, sankey, scattermore (&ge; 0.7), Seurat,
SeuratObject, SingleCellExperiment, SummarizedExperiment,
testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-20 17:41:29 UTC; wangych</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-20 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.complexHeatmapDotPlot'>Generate dot plot from input matrix with ComplexHeatmap</h2><span id='topic+.complexHeatmapDotPlot'></span>

<h3>Description</h3>

<p>Generate dot plot from input matrix with ComplexHeatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.complexHeatmapDotPlot(
  colorMat,
  sizeMat,
  featureAnnDF = NULL,
  cellSplitVar = NULL,
  cellLabels = NULL,
  maxDotSize = 4,
  clusterFeature = FALSE,
  clusterCell = FALSE,
  legendColorTitle = "Matrix Value",
  legendSizeTitle = "Fraction Value",
  transpose = FALSE,
  baseSize = 8,
  cellTextSize = NULL,
  featureTextSize = NULL,
  cellTitleSize = NULL,
  featureTitleSize = NULL,
  legendTextSize = NULL,
  legendTitleSize = NULL,
  featureGrpRot = 0,
  viridisOption = "C",
  viridisDirection = -1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".complexHeatmapDotPlot_+3A_colormat">colorMat</code>, <code id=".complexHeatmapDotPlot_+3A_sizemat">sizeMat</code></td>
<td>
<p>Matrix of the same size. Values in <code>colorMat</code>
will be visualized with color while values in <code>sizeMat</code> will be
reflected by dot size.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_featureanndf">featureAnnDF</code></td>
<td>
<p>Data frame of features containing feature names and
grouping labels.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_cellsplitvar">cellSplitVar</code></td>
<td>
<p>Split the cell orientation (default columns) by this
variable.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_celllabels">cellLabels</code></td>
<td>
<p>Label to be shown on cell orientation.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_maxdotsize">maxDotSize</code></td>
<td>
<p>The maximum dot size. Default <code>4</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_clusterfeature">clusterFeature</code>, <code id=".complexHeatmapDotPlot_+3A_clustercell">clusterCell</code></td>
<td>
<p>Whether the feature/cell orientation
(default rows/column, respectively) should be clustered. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_legendcolortitle">legendColorTitle</code>, <code id=".complexHeatmapDotPlot_+3A_legendsizetitle">legendSizeTitle</code></td>
<td>
<p>The title for color bar and dot size
legends, repectively. Default see <code>"Matrix Value"</code> and <code>"Fraction
Value"</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_transpose">transpose</code></td>
<td>
<p>Logical, whether to rotate the dot plot orientation. i.e.
rows as cell aggregation and columns as features. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_basesize">baseSize</code></td>
<td>
<p>One-parameter control of all text sizes. Individual text
element sizes can be controlled by other size arguments. &quot;Title&quot; sizes are
2 points larger than &quot;text&quot; sizes when being controlled by this. Default
<code>8</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_celltextsize">cellTextSize</code>, <code id=".complexHeatmapDotPlot_+3A_featuretextsize">featureTextSize</code>, <code id=".complexHeatmapDotPlot_+3A_legendtextsize">legendTextSize</code></td>
<td>
<p>Size of cell labels,
feature label and legend text. Default <code>NULL</code> controls by
<code>baseSize</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_celltitlesize">cellTitleSize</code>, <code id=".complexHeatmapDotPlot_+3A_featuretitlesize">featureTitleSize</code>, <code id=".complexHeatmapDotPlot_+3A_legendtitlesize">legendTitleSize</code></td>
<td>
<p>Size of titles on
cell and feature orientation and legend title. Default <code>NULL</code> controls
by <code>baseSize + 2</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_featuregrprot">featureGrpRot</code></td>
<td>
<p>Number of degree to rotate the feature grouping label.
Default <code>0</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_viridisoption">viridisOption</code>, <code id=".complexHeatmapDotPlot_+3A_viridisdirection">viridisDirection</code></td>
<td>
<p>See argument <code>option</code> and
<code>direction</code> of <code><a href="viridisLite.html#topic+viridis">viridis</a></code>. Default <code>"A"</code>
and <code>-1</code>.</p>
</td></tr>
<tr><td><code id=".complexHeatmapDotPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ComplexHeatmap.html#topic+HeatmapList">HeatmapList</a></code> object.
</p>

<hr>
<h2 id='.ggCellViolin'>Produce single violin plot with data frame passed from upstream</h2><span id='topic+.ggCellViolin'></span>

<h3>Description</h3>

<p>Produce single violin plot with data frame passed from upstream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ggCellViolin(
  plotDF,
  y,
  groupBy = NULL,
  colorBy = NULL,
  violin = TRUE,
  violinAlpha = 0.8,
  violinWidth = 0.9,
  box = FALSE,
  boxAlpha = 0.6,
  boxWidth = 0.4,
  dot = FALSE,
  dotColor = "black",
  dotSize = getOption("ligerDotSize"),
  raster = NULL,
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ggCellViolin_+3A_plotdf">plotDF</code></td>
<td>
<p>Data frame like object (fortifiable) that contains all
necessary information to make the plot.</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_y">y</code>, <code id=".ggCellViolin_+3A_groupby">groupBy</code>, <code id=".ggCellViolin_+3A_colorby">colorBy</code></td>
<td>
<p>See <code><a href="#topic+plotCellViolin">plotCellViolin</a></code>.</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_violin">violin</code>, <code id=".ggCellViolin_+3A_box">box</code>, <code id=".ggCellViolin_+3A_dot">dot</code></td>
<td>
<p>Logical, whether to add violin plot, box plot or dot
(scatter) plot, respectively. Layers are added in the order of dot, violin,
and violin on the top surface. By default, only violin plot is generated.</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_violinalpha">violinAlpha</code>, <code id=".ggCellViolin_+3A_boxalpha">boxAlpha</code></td>
<td>
<p>Numeric, controls the transparency of layers.
Default <code>0.8</code>, <code>0.6</code>, respectively.</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_violinwidth">violinWidth</code>, <code id=".ggCellViolin_+3A_boxwidth">boxWidth</code></td>
<td>
<p>Numeric, controls the width of violin/box
bounding box. Default <code>0.9</code> and <code>0.4</code>.</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_dotcolor">dotColor</code>, <code id=".ggCellViolin_+3A_dotsize">dotSize</code></td>
<td>
<p>Numeric, globally controls the appearance of all
dots. Default <code>"black"</code> and <code>getOption("ligerDotSize")</code> (1).</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_raster">raster</code></td>
<td>
<p>Logical, whether to rasterize the dot plot. Default <code>NULL</code>
automatically rasterizes the dot plot when number of total cells to be
plotted exceeds 100,000.</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id=".ggCellViolin_+3A_...">...</code></td>
<td>
<p>More theme setting arguments passed to
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object by default. When <code>plotly = TRUE</code>, returns
plotly (htmlwidget) object.
</p>

<hr>
<h2 id='.ggplotLigerTheme'>Generic ggplot theme setting for rliger package</h2><span id='topic+.ggplotLigerTheme'></span>

<h3>Description</h3>

<p>Controls content and size of all peripheral texts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ggplotLigerTheme(
  plot,
  title = NULL,
  subtitle = NULL,
  xlab = TRUE,
  ylab = TRUE,
  legendColorTitle = NULL,
  legendFillTitle = NULL,
  legendShapeTitle = NULL,
  legendSizeTitle = NULL,
  showLegend = TRUE,
  legendPosition = "right",
  baseSize = getOption("ligerBaseSize"),
  titleSize = NULL,
  subtitleSize = NULL,
  xTextSize = NULL,
  xFacetSize = NULL,
  xTitleSize = NULL,
  yTextSize = NULL,
  yFacetSize = NULL,
  yTitleSize = NULL,
  legendTextSize = NULL,
  legendTitleSize = NULL,
  legendDotSize = 4,
  panelBorder = FALSE,
  legendNRow = NULL,
  legendNCol = NULL,
  colorLabels = NULL,
  colorValues = NULL,
  colorPalette = "magma",
  colorDirection = -1,
  naColor = "#DEDEDE",
  colorLow = NULL,
  colorMid = NULL,
  colorHigh = NULL,
  colorMidPoint = NULL,
  plotly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ggplotLigerTheme_+3A_plot">plot</code></td>
<td>
<p>ggplot object passed from wrapper plotting functions</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_title">title</code>, <code id=".ggplotLigerTheme_+3A_subtitle">subtitle</code>, <code id=".ggplotLigerTheme_+3A_xlab">xlab</code>, <code id=".ggplotLigerTheme_+3A_ylab">ylab</code></td>
<td>
<p>Main title, subtitle or X/Y axis title text.
By default, no main title or subtitle will be set, and X/Y axis title will be
the names of variables used for plotting. Use <code>NULL</code> to hide elements.
<code>TRUE</code> for <code>xlab</code> or <code>ylab</code> shows default values.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_legendcolortitle">legendColorTitle</code>, <code id=".ggplotLigerTheme_+3A_legendfilltitle">legendFillTitle</code>, <code id=".ggplotLigerTheme_+3A_legendshapetitle">legendShapeTitle</code>, <code id=".ggplotLigerTheme_+3A_legendsizetitle">legendSizeTitle</code></td>
<td>
<p>Set
alternative title text for legend on aes of color, fill, shape and size,
respectively. Default <code>NULL</code> shows the original variable name.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_showlegend">showLegend</code></td>
<td>
<p>Whether to show the legend. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_legendposition">legendPosition</code></td>
<td>
<p>Text indicating where to place the legend. Choose from
<code>"top"</code>, <code>"bottom"</code>, <code>"left"</code> or <code>"right"</code>. Default
<code>"right"</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_basesize">baseSize</code></td>
<td>
<p>One-parameter control of all text sizes. Individual text
element sizes can be controlled by other size arguments. &quot;Title&quot; sizes are
2 points larger than &quot;text&quot; sizes when being controlled by this.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_titlesize">titleSize</code>, <code id=".ggplotLigerTheme_+3A_xtitlesize">xTitleSize</code>, <code id=".ggplotLigerTheme_+3A_ytitlesize">yTitleSize</code>, <code id=".ggplotLigerTheme_+3A_legendtitlesize">legendTitleSize</code></td>
<td>
<p>Size of main title,
axis titles and legend title. Default <code>NULL</code> controls by
<code>baseSize + 2</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_subtitlesize">subtitleSize</code>, <code id=".ggplotLigerTheme_+3A_xtextsize">xTextSize</code>, <code id=".ggplotLigerTheme_+3A_ytextsize">yTextSize</code>, <code id=".ggplotLigerTheme_+3A_legendtextsize">legendTextSize</code></td>
<td>
<p>Size of subtitle text,
axis texts and legend text. Default <code>NULL</code> controls by <code>baseSize</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_xfacetsize">xFacetSize</code>, <code id=".ggplotLigerTheme_+3A_yfacetsize">yFacetSize</code></td>
<td>
<p>Size of facet label text. Default <code>NULL</code>
controls by <code>baseSize - 2</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_legenddotsize">legendDotSize</code></td>
<td>
<p>Allow dots in legend region to be large enough to see
the colors/shapes clearly. Default <code>4</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_panelborder">panelBorder</code></td>
<td>
<p>Whether to show rectangle border of the panel instead of
using ggplot classic bottom and left axis lines. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_legendnrow">legendNRow</code>, <code id=".ggplotLigerTheme_+3A_legendncol">legendNCol</code></td>
<td>
<p>Integer, when too many categories in one
variable, arranges number of rows or columns. Default <code>NULL</code>,
automatically split to <code>ceiling(levels(variable)/10)</code> columns.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_colorlabels">colorLabels</code>, <code id=".ggplotLigerTheme_+3A_colorvalues">colorValues</code></td>
<td>
<p>Each a vector with as many values as the
number of categories for the categorical coloring aesthetics. Labels will be
the shown text and values will be the color code. These are passed to
<code><a href="ggplot2.html#topic+scale_color_manual">scale_color_manual</a></code>. Default uses an internal selected
palette if there are &lt;= 26 colors needed, or ggplot hues otherwise, and plot
original labels (levels of the factor).</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_colorpalette">colorPalette</code></td>
<td>
<p>For continuous coloring, an index or a palette name to
select from available options from ggplot
<code><a href="ggplot2.html#topic+scale_brewer">scale_brewer</a></code> or <code><a href="viridisLite.html#topic+viridis">viridis</a></code>.
Default <code>"magma"</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_colordirection">colorDirection</code></td>
<td>
<p>Choose <code>1</code> or <code>-1</code>. Applied when
<code>colorPalette</code> is from Viridis options. Default <code>-1</code> use darker
color for higher value, while <code>1</code> reverses this direction.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_nacolor">naColor</code></td>
<td>
<p>The color code for <code>NA</code> values. Default <code>"#DEDEDE"</code>.
<code><a href="ggplot2.html#topic+scale_colour_gradient2">scale_colour_gradient2</a></code>. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_colorlow">colorLow</code>, <code id=".ggplotLigerTheme_+3A_colormid">colorMid</code>, <code id=".ggplotLigerTheme_+3A_colorhigh">colorHigh</code>, <code id=".ggplotLigerTheme_+3A_colormidpoint">colorMidPoint</code></td>
<td>
<p>All four of these must be
specified to customize palette with</p>
</td></tr>
<tr><td><code id=".ggplotLigerTheme_+3A_plotly">plotly</code></td>
<td>
<p>Whether to use plotly to enable web based interactive browsing
for the plot. Requires installation of package &quot;plotly&quot;. Default
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated ggplot object by default. When <code>plotly = TRUE</code>, returns
plotly (htmlwidget) object.
</p>

<hr>
<h2 id='.ggScatter'>Produce single scatter plot with data frame passed from upstream</h2><span id='topic+.ggScatter'></span>

<h3>Description</h3>

<p>Produce single scatter plot with data frame passed from upstream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.ggScatter(
  plotDF,
  x,
  y,
  colorBy = NULL,
  shapeBy = NULL,
  dotOrder = c("shuffle", "ascending", "descending"),
  dotSize = getOption("ligerDotSize"),
  dotAlpha = 0.9,
  trimHigh = NULL,
  trimLow = NULL,
  zeroAsNA = TRUE,
  raster = NULL,
  labelBy = colorBy,
  labelText = TRUE,
  labelTextSize = 4,
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".ggScatter_+3A_plotdf">plotDF</code></td>
<td>
<p>Data frame like object (fortifiable) that contains all
necessary information to make the plot.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_x">x</code>, <code id=".ggScatter_+3A_y">y</code></td>
<td>
<p>Available variable name in <code>cellMeta</code> slot to look for
the dot coordinates. See details.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_colorby">colorBy</code>, <code id=".ggScatter_+3A_shapeby">shapeBy</code></td>
<td>
<p>See <code><a href="#topic+plotDimRed">plotDimRed</a></code>.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_dotorder">dotOrder</code></td>
<td>
<p>Controls the order that each dot is added to the plot. Choose
from <code>"shuffle"</code>, <code>"ascending"</code>, or <code>"descending"</code>. Default
<code>"shuffle"</code>, useful when coloring by categories that overlaps (e.g.
&quot;dataset&quot;), <code>"ascending"</code> can be useful when coloring by a continuous
variable (e.g. gene expression) where high values needs more
highlight. <code>NULL</code> use default order.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_dotsize">dotSize</code>, <code id=".ggScatter_+3A_dotalpha">dotAlpha</code></td>
<td>
<p>Numeric, controls the size or transparency of all
dots. Default <code>getOption("ligerDotSize")</code> (1) and <code>0.9</code>.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_trimhigh">trimHigh</code>, <code id=".ggScatter_+3A_trimlow">trimLow</code></td>
<td>
<p>Numeric, limit the largest or smallest value of
continuous <code>colorBy</code> variable. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_zeroasna">zeroAsNA</code></td>
<td>
<p>Logical, whether to set zero values in continuous
<code>colorBy</code> variable to <code>NA</code> so the color of these value.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_raster">raster</code></td>
<td>
<p>Logical, whether to rasterize the plot. Default <code>NULL</code>
automatically rasterize the plot when number of total cells to be plotted
exceeds 100,000.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_labelby">labelBy</code></td>
<td>
<p>A variable name available in <code>plotDF</code>. If the variable is
categorical (a factor), the label position will be the median coordinates of
all dots within the same group. Unique labeling in character vector for each
dot is also acceptable. Default <code>colorBy</code>.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_labeltext">labelText</code></td>
<td>
<p>Logical, whether to show text label at the median position
of each categorical group specified by <code>colorBy</code>. Default <code>TRUE</code>.
Does not work when continuous coloring is specified.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_labeltextsize">labelTextSize</code></td>
<td>
<p>Numeric, controls the size of label size when
<code>labelText = TRUE</code>. Default <code>4</code>.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id=".ggScatter_+3A_...">...</code></td>
<td>
<p>More theme setting arguments passed to
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Having package &quot;ggrepel&quot; installed can help adding tidier text
labels on the scatter plot.
</p>


<h3>Value</h3>

<p>ggplot object by default. When <code>plotly = TRUE</code>, returns
plotly (htmlwidget) object.
</p>

<hr>
<h2 id='.plotHeatmap'>General heatmap plotting with prepared matrix and data.frames</h2><span id='topic+.plotHeatmap'></span>

<h3>Description</h3>

<p>This is not an exported function. This documentation just
serves for a manual of extra arguments that users can use when generating
heatmaps with <code><a href="#topic+plotGeneHeatmap">plotGeneHeatmap</a></code> or
<code><a href="#topic+plotFactorHeatmap">plotFactorHeatmap</a></code>.
</p>
<p>Note that the following arguments are pre-occupied by upstream wrappers so
users should not include them in a function call: <code>dataMatrix</code>,
<code>dataName</code>, <code>cellDF</code>, <code>featureDF</code>, <code>cellSplitVar</code>,
<code>featureSplitVar</code>.
</p>
<p>The following arguments of <code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code> is occupied
by this function, so users should include them in a function call as well:
<code>matrix</code>, <code>name</code>, <code>col</code>, <code>heatmap_legend_param</code>,
<code>top_annotation</code>, <code>column_title_gp</code>, <code>column_names_gp</code>,
<code>show_column_names</code>, <code>column_split</code>, <code>column_gap</code>,
<code>left_annotation</code>, <code>row_title_gp</code>, <code>row_names_gp</code>,
<code>show_row_names</code>, <code>row_split</code>, <code>row_gap</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.plotHeatmap(
  dataMatrix,
  dataName = "Value",
  cellDF = NULL,
  featureDF = NULL,
  transpose = FALSE,
  cellSplitVar = NULL,
  featureSplitVar = NULL,
  dataScaleFunc = NULL,
  showCellLabel = FALSE,
  showCellLegend = TRUE,
  showFeatureLabel = TRUE,
  showFeatureLegend = TRUE,
  cellAnnColList = NULL,
  featureAnnColList = NULL,
  scale = FALSE,
  trim = c(-2, 2),
  baseSize = 8,
  cellTextSize = NULL,
  featureTextSize = NULL,
  cellTitleSize = NULL,
  featureTitleSize = NULL,
  legendTextSize = NULL,
  legendTitleSize = NULL,
  viridisOption = "A",
  viridisDirection = -1,
  RColorBrewerOption = "RdBu",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".plotHeatmap_+3A_datamatrix">dataMatrix</code></td>
<td>
<p>Matrix object with features/factors as rows and cells as
columns.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_dataname">dataName</code></td>
<td>
<p>Text for heatmap color bar title. Default <code>Value</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_celldf">cellDF</code></td>
<td>
<p>data.frame object. Number of rows must match with number of
columns of <code>dataMatrix</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_featuredf">featureDF</code></td>
<td>
<p>data.frame object. Number of columns must match with number
of rows of <code>dataMatrix</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_transpose">transpose</code></td>
<td>
<p>Logical, whether to &quot;rotate&quot; the heatmap by 90 degrees so
that cell information is displayed by row. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_cellsplitvar">cellSplitVar</code>, <code id=".plotHeatmap_+3A_featuresplitvar">featureSplitVar</code></td>
<td>
<p>Subset columns of <code>cellDF</code> or
<code>featureDF</code>, respectively.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_datascalefunc">dataScaleFunc</code></td>
<td>
<p>A function object, applied to <code>dataMatrix</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_showcelllabel">showCellLabel</code>, <code id=".plotHeatmap_+3A_showfeaturelabel">showFeatureLabel</code></td>
<td>
<p>Logical, whether to show cell barcodes,
gene symbols or factor names. Default <code>TRUE</code> for gene/factors but
<code>FALSE</code> for cells.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_showcelllegend">showCellLegend</code>, <code id=".plotHeatmap_+3A_showfeaturelegend">showFeatureLegend</code></td>
<td>
<p>Logical, whether to show cell or
feature legends. Default <code>TRUE</code>. Can be a scalar for overall control
or a vector matching with each given annotation variable.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_cellanncollist">cellAnnColList</code>, <code id=".plotHeatmap_+3A_featureanncollist">featureAnnColList</code></td>
<td>
<p>List object, with each element a
named vector of R-interpretable color code. The names of the list elements
are used for matching the annotation variable names. The names of the colors
in the vectors are used for matching the levels of a variable (factor object,
categorical). Default <code>NULL</code> generates ggplot-flavor categorical colors.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_scale">scale</code></td>
<td>
<p>Logical, whether to take z-score to scale and center gene
expression. Applied after <code>dataScaleFunc</code>. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_trim">trim</code></td>
<td>
<p>Numeric vector of two values. Limit the z-score value into this
range when <code>scale = TRUE</code>. Default <code>c(-2, 2)</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_basesize">baseSize</code></td>
<td>
<p>One-parameter control of all text sizes. Individual text
element sizes can be controlled by other size arguments. &quot;Title&quot; sizes are
2 points larger than &quot;text&quot; sizes when being controlled by this.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_celltextsize">cellTextSize</code>, <code id=".plotHeatmap_+3A_featuretextsize">featureTextSize</code>, <code id=".plotHeatmap_+3A_legendtextsize">legendTextSize</code></td>
<td>
<p>Size of cell barcode
labels, gene/factor labels, or legend values. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_celltitlesize">cellTitleSize</code>, <code id=".plotHeatmap_+3A_featuretitlesize">featureTitleSize</code>, <code id=".plotHeatmap_+3A_legendtitlesize">legendTitleSize</code></td>
<td>
<p>Size of titles of the
cell slices, gene/factor slices, or the legends. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_viridisoption">viridisOption</code>, <code id=".plotHeatmap_+3A_viridisdirection">viridisDirection</code></td>
<td>
<p>See argument <code>option</code> and
<code>direction</code> of <code><a href="viridisLite.html#topic+viridis">viridis</a></code>. Default <code>"A"</code>
and <code>-1</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_rcolorbreweroption">RColorBrewerOption</code></td>
<td>
<p>When <code>scale = TRUE</code>, heatmap color will be
mapped with <code><a href="RColorBrewer.html#topic+brewer.pal">brewer.pal</a></code>. This is passed to
<code>name</code>. Default <code>"RdBu"</code>.</p>
</td></tr>
<tr><td><code id=".plotHeatmap_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
<code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="ComplexHeatmap.html#topic+HeatmapList-class">HeatmapList-class</a></code> object
</p>

<hr>
<h2 id='as.liger.dgCMatrix'>Converting other classes of data to a liger object</h2><span id='topic+as.liger.dgCMatrix'></span><span id='topic+as.liger.SingleCellExperiment'></span><span id='topic+as.liger.Seurat'></span><span id='topic+seuratToLiger'></span><span id='topic+as.liger'></span>

<h3>Description</h3>

<p>This function converts data stored in SingleCellExperiment (SCE), Seurat
object or a merged sparse matrix (dgCMatrix) into a liger object. This is
designed for a container object or matrix that already contains multiple
datasets to be integerated with LIGER. For individual datasets, please use
<code><a href="#topic+createLiger">createLiger</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dgCMatrix'
as.liger(object, datasetVar = NULL, modal = NULL, ...)

## S3 method for class 'SingleCellExperiment'
as.liger(object, datasetVar = NULL, modal = NULL, ...)

## S3 method for class 'Seurat'
as.liger(object, datasetVar = NULL, modal = NULL, assay = NULL, ...)

seuratToLiger(object, datasetVar = NULL, modal = NULL, assay = NULL, ...)

as.liger(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.liger.dgCMatrix_+3A_object">object</code></td>
<td>
<p>Object.</p>
</td></tr>
<tr><td><code id="as.liger.dgCMatrix_+3A_datasetvar">datasetVar</code></td>
<td>
<p>Specify the dataset belonging by: 1. Select a variable from
existing metadata in the object (e.g. colData column); 2. Specify a
vector/factor that assign the dataset belonging. 3. Give a single character
string which means that all data is from one dataset (must not be a metadata
variable, otherwise it is understood as 1.). Default <code>NULL</code> gathers
things into one dataset and names it &quot;sample&quot; for dgCMatrix, attempts
to find variable &quot;sample&quot; from SCE or &quot;orig.ident&quot; from Seurat.</p>
</td></tr>
<tr><td><code id="as.liger.dgCMatrix_+3A_modal">modal</code></td>
<td>
<p>Modality setting for each dataset. See
<code><a href="#topic+createLiger">createLiger</a></code>.</p>
</td></tr>
<tr><td><code id="as.liger.dgCMatrix_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+createLiger">createLiger</a></code></p>
</td></tr>
<tr><td><code id="as.liger.dgCMatrix_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Seurat V5 structure, it is highly recommended that users make use of its
split layer feature, where things like &quot;counts&quot;, &quot;data&quot;, and &quot;scale.data&quot;
can be held for each dataset in the same Seurat object, e.g. with
&quot;count.ctrl&quot;, &quot;count.stim&quot;, not merged. If a Seurat object with split layers
is given, <code>datasetVar</code> will be ignored and the layers will be directly
used.
</p>


<h3>Value</h3>

<p>a <a href="#topic+liger-class">liger</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dgCMatrix (common sparse matrix class), usually obtained from other
# container object, and contains multiple samples merged in one.
matList &lt;- rawData(pbmc)
multiSampleMatrix &lt;- mergeSparseAll(matList)
# The `datasetVar` argument expects the variable assigning the sample source
pbmc2 &lt;- as.liger(multiSampleMatrix, datasetVar = pbmc$dataset)
pbmc2


sce &lt;- SingleCellExperiment::SingleCellExperiment(
    assays = list(counts = multiSampleMatrix)
)
sce$sample &lt;- pbmc$dataset
pbmc3 &lt;- as.liger(sce, datasetVar = "sample")
pbmc3

seu &lt;- SeuratObject::CreateSeuratObject(multiSampleMatrix)
# Seurat creates variable "orig.ident" by identifying the cell barcode
# prefixes, which is indeed what we need in this case. Users might need
# to be careful and have it confirmed first.
pbmc4 &lt;- as.liger(seu, datasetVar = "orig.ident")
pbmc4

# As per Seurat V5 updates with layered data, specifically helpful udner the
# scenario of dataset integration. "counts" and etc for each datasets can be
# split into layers.
seu5 &lt;- seu
seu5[["RNA"]] &lt;- split(seu5[["RNA"]], pbmc$dataset)
print(SeuratObject::Layers(seu5))
pbmc5 &lt;- as.liger(seu5)

</code></pre>

<hr>
<h2 id='as.ligerDataset.ligerDataset'>Converting other classes of data to a ligerDataset object</h2><span id='topic+as.ligerDataset.ligerDataset'></span><span id='topic+as.ligerDataset.default'></span><span id='topic+as.ligerDataset.matrix'></span><span id='topic+as.ligerDataset.Seurat'></span><span id='topic+as.ligerDataset.SingleCellExperiment'></span><span id='topic+as.ligerDataset'></span>

<h3>Description</h3>

<p>Works for converting a matrix or container object to a single ligerDataset,
and can also convert the modality preset of a ligerDataset. When used with
a dense matrix object, it automatically converts the matrix to sparse form
(<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>). When used with container objects
such as Seurat or SingleCellExperiment, it is highly recommended that the
object contains only one dataset/sample which is going to be integrated with
LIGER. For multi-sample objects, please use <code><a href="#topic+as.liger">as.liger</a></code> with
dataset source variable specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ligerDataset'
as.ligerDataset(
  object,
  modal = c("default", "rna", "atac", "spatial", "meth"),
  ...
)

## Default S3 method:
as.ligerDataset(
  object,
  modal = c("default", "rna", "atac", "spatial", "meth"),
  ...
)

## S3 method for class 'matrix'
as.ligerDataset(
  object,
  modal = c("default", "rna", "atac", "spatial", "meth"),
  ...
)

## S3 method for class 'Seurat'
as.ligerDataset(
  object,
  modal = c("default", "rna", "atac", "spatial", "meth"),
  assay = NULL,
  ...
)

## S3 method for class 'SingleCellExperiment'
as.ligerDataset(
  object,
  modal = c("default", "rna", "atac", "spatial", "meth"),
  ...
)

as.ligerDataset(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ligerDataset.ligerDataset_+3A_object">object</code></td>
<td>
<p>Object.</p>
</td></tr>
<tr><td><code id="as.ligerDataset.ligerDataset_+3A_modal">modal</code></td>
<td>
<p>Modality setting for each dataset. Choose from <code>"default"</code>,
<code>"rna"</code>, <code>"atac"</code>, <code>"spatial"</code>, <code>"meth"</code>.</p>
</td></tr>
<tr><td><code id="as.ligerDataset.ligerDataset_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+createLigerDataset">createLigerDataset</a></code></p>
</td></tr>
<tr><td><code id="as.ligerDataset.ligerDataset_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="#topic+liger-class">liger</a> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- dataset(pbmc, "ctrl")
ctrl
# Convert the modality preset
as.ligerDataset(ctrl, modal = "atac")
rawCounts &lt;- rawData(ctrl)
class(rawCounts)
as.ligerDataset(rawCounts)
</code></pre>

<hr>
<h2 id='bmmc'>liger object of bone marrow subsample data with RNA and ATAC modality</h2><span id='topic+bmmc'></span>

<h3>Description</h3>

<p>liger object of bone marrow subsample data with RNA and ATAC modality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmmc
</code></pre>


<h3>Format</h3>

<p><a href="#topic+liger-class">liger</a> object with two dataset named by &quot;rna&quot; and &quot;atac&quot;
</p>


<h3>Source</h3>

<p>https://www.nature.com/articles/s41587-019-0332-7
</p>


<h3>References</h3>

<p>Jeffrey M. Granja and et. al., Nature Biotechnology, 2019
</p>

<hr>
<h2 id='calcAgreement'>Calculate agreement metric after integration</h2><span id='topic+calcAgreement'></span>

<h3>Description</h3>

<p>This metric quantifies how much the factorization and alignment distorts the
geometry of the original datasets. The greater the agreement, the less
distortion of geometry there is. This is calculated by performing
dimensionality reduction on the original and quantile aligned (or just
factorized) datasets, and measuring similarity between the k nearest
neighbors for each cell in original and aligned datasets. The Jaccard index
is used to quantify similarity, and is the final metric averages across all
cells.
</p>
<p>Note that for most datasets, the greater the chosen <code>nNeighbor</code>, the
greater the agreement in general. Although agreement can theoretically
approach 1, in practice it is usually no higher than 0.2-0.3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAgreement(
  object,
  ndims = 40,
  nNeighbors = 15,
  useRaw = FALSE,
  byDataset = FALSE,
  seed = 1,
  dr.method = NULL,
  k = nNeighbors,
  use.aligned = NULL,
  rand.seed = seed,
  by.dataset = byDataset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAgreement_+3A_object">object</code></td>
<td>
<p><code>liger</code> object. Should call quantile_norm before calling.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_ndims">ndims</code></td>
<td>
<p>Number of factors to produce in NMF. Default <code>40</code>.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>Number of nearest neighbors to use in calculating Jaccard
index. Default <code>15</code>.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_useraw">useRaw</code></td>
<td>
<p>Whether to evaluate just factorized <code class="reqn">H</code> matrices instead of
using quantile aligned <code class="reqn">H.norm</code> matrix. Default <code>FALSE</code> uses
aligned matrix.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_bydataset">byDataset</code></td>
<td>
<p>Whether to return agreement calculated for each dataset
instead of the average for all datasets. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_dr.method">dr.method</code></td>
<td>
<p>[defunct] We no longer support other methods but just NMF.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_k">k</code>, <code id="calcAgreement_+3A_rand.seed">rand.seed</code>, <code id="calcAgreement_+3A_by.dataset">by.dataset</code></td>
<td>
<p>[Deprecated] See Usage for replacement.</p>
</td></tr>
<tr><td><code id="calcAgreement_+3A_use.aligned">use.aligned</code></td>
<td>
<p>[defunct] Use <code>useRaw</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of agreement metric. A single value if
<code>byDataset = FALSE</code> or each dataset a value otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- pbmc %&gt;%
    normalize %&gt;%
    selectGenes %&gt;%
    scaleNotCenter %&gt;%
    runINMF %&gt;%
    quantileNorm
    calcAgreement(pbmc)
}
</code></pre>

<hr>
<h2 id='calcAlignment'>Calculate alignment metric after integration</h2><span id='topic+calcAlignment'></span>

<h3>Description</h3>

<p>This metric quantifies how well-aligned two or more datasets are. We randomly
downsample all datasets to have as many cells as the smallest one. We
construct a nearest-neighbor graph and calculate for each cell how many of
its neighbors are from the same dataset. We average across all cells and
compare to the expected value for perfectly mixed datasets, and scale the
value from 0 to 1. Note that in practice, alignment can be greater than 1
occasionally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcAlignment(
  object,
  clustersUse = NULL,
  clusterVar = NULL,
  nNeighbors = NULL,
  cellIdx = NULL,
  cellComp = NULL,
  resultBy = c("all", "dataset", "cell"),
  seed = 1,
  k = nNeighbors,
  rand.seed = seed,
  cells.use = cellIdx,
  cells.comp = cellComp,
  clusters.use = clustersUse,
  by.cell = NULL,
  by.dataset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcAlignment_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with <code><a href="#topic+quantileNorm">quantileNorm</a></code>
already run.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_clustersuse">clustersUse</code></td>
<td>
<p>The clusters to consider for calculating the alignment.
Should be a vector of existing levels in <code>clusterVar</code>. Default
<code>NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_clustervar">clusterVar</code></td>
<td>
<p>The name of one variable in <code>cellMeta(object)</code>.
Default <code>NULL</code> uses default clusters.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>Number of neighbors to use in calculating alignment.
Default <code>NULL</code> uses <code>floor(0.01*ncol(object))</code>, with a lower bound
of 10 in all cases except where the total number of sampled cells is less
than 10.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_cellidx">cellIdx</code>, <code id="calcAlignment_+3A_cellcomp">cellComp</code></td>
<td>
<p>Character, logical or numeric index that can
subscribe cells. Default <code>NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_resultby">resultBy</code></td>
<td>
<p>Select from <code>"all"</code>, <code>"dataset"</code> or <code>"cell"</code>.
On which level should the mean alignment be calculated. Default <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_k">k</code>, <code id="calcAlignment_+3A_rand.seed">rand.seed</code>, <code id="calcAlignment_+3A_cells.use">cells.use</code>, <code id="calcAlignment_+3A_cells.comp">cells.comp</code>, <code id="calcAlignment_+3A_clusters.use">clusters.use</code></td>
<td>
<p>[Deprecated] Please
see Usage for replacement.</p>
</td></tr>
<tr><td><code id="calcAlignment_+3A_by.cell">by.cell</code>, <code id="calcAlignment_+3A_by.dataset">by.dataset</code></td>
<td>
<p>[Defunct] Use <code>resultBy</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code class="reqn">\bar{x}</code> is the average number of neighbors belonging to any cells' same
dataset, <code class="reqn">N</code> is the number of datasets, <code class="reqn">k</code> is the number of
neighbors in the KNN graph.
</p>
<p style="text-align: center;"><code class="reqn">1 - \frac{\bar{x} - \frac{k}{N}}{k - \frac{k}{N}}</code>
</p>

<p>The selection on cells to be measured can be done in various way and
represent different scenarios:
</p>

<ol>
<li><p>By default, all cells are considered and the alignment across all
datasets will be calculated.
</p>
</li>
<li><p>Select <code>clustersUse</code> from <code>clusterVar</code> to use cells from the
clusters of interests. This measures the alignment across all covered
datasets within the specified clusters.
</p>
</li>
<li><p>Only Specify <code>cellIdx</code> for flexible selection. This measures the
alignment across all covered datasets within the specified cells. A none-NULL
<code>cellIdx</code> privileges over <code>clustersUse</code>.
</p>
</li>
<li><p>Specify <code>cellIdx</code> and <code>cellComp</code> at the same time, so that
the original dataset source will be ignored and cells specified by each
argument will be regarded as from each a dataset. This measures the alignment
between cells specified by the two arguments. <code>cellComp</code> can contain
cells already specified in <code>cellIdx</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>The alignment metric.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- pbmc %&gt;%
    normalize %&gt;%
    selectGenes %&gt;%
    scaleNotCenter %&gt;%
    runINMF %&gt;%
    quantileNorm
    calcAlignment(pbmc)
}
</code></pre>

<hr>
<h2 id='calcARI'>Calculate adjusted Rand index (ARI) by comparing two cluster labeling variables</h2><span id='topic+calcARI'></span>

<h3>Description</h3>

<p>This function aims at calculating the adjusted Rand index for the clustering
result obtained with LIGER and the external clustering (existing &quot;true&quot;
annotation). ARI ranges from 0 to 1, with a score of 0 indicating no
agreement between clusterings and 1 indicating perfect agreement.
</p>
<p>The true clustering annotation must be specified as the base line. We suggest
setting it to the object cellMeta so that it can be easily used for many
other visualization and evaluation functions.
</p>
<p>The ARI can be calculated for only specified datasets, since true annotation
might not be available for all datasets. Evaluation for only one or a few
datasets can be done by specifying <code>useDatasets</code>. If <code>useDatasets</code>
is specified, the argument checking for <code>trueCluster</code> and
<code>useCluster</code> will be enforced to match the cells in the specified
datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcARI(
  object,
  trueCluster,
  useCluster = NULL,
  useDatasets = NULL,
  verbose = getOption("ligerVerbose", TRUE),
  classes.compare = trueCluster
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcARI_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with the clustering result
present in cellMeta.</p>
</td></tr>
<tr><td><code id="calcARI_+3A_truecluster">trueCluster</code></td>
<td>
<p>Either the name of one variable in <code>cellMeta(object)</code>
or a factor object with annotation that matches with all cells being
considered.</p>
</td></tr>
<tr><td><code id="calcARI_+3A_usecluster">useCluster</code></td>
<td>
<p>The name of one variable in <code>cellMeta(object)</code>.
Default <code>NULL</code> uses default clusters.</p>
</td></tr>
<tr><td><code id="calcARI_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to be considered for the purity
calculation. Default <code>NULL</code> uses all datasets.</p>
</td></tr>
<tr><td><code id="calcARI_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="calcARI_+3A_classes.compare">classes.compare</code></td>
<td>
<p>[Deprecated/Renamed]. Use <code>trueCluster</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, the ARI of the clustering result indicated by
<code>useCluster</code> compared to <code>trueCluster</code>.
</p>


<h3>References</h3>

<p>L. Hubert and P. Arabie (1985) Comparing Partitions, Journal of
the Classification, 2, pp. 193-218.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assume the true cluster in `pbmcPlot` is "leiden_cluster"
# generate fake new labeling
fake &lt;- sample(1:7, ncol(pbmcPlot), replace = TRUE)
# Insert into cellMeta
pbmcPlot$new &lt;- factor(fake)
calcARI(pbmcPlot, trueCluster = "leiden_cluster", useCluster = "new")

# Now assume we got existing base line annotation only for "stim" dataset
nStim &lt;- ncol(dataset(pbmcPlot, "stim"))
stimTrueLabel &lt;- factor(fake[1:nStim])
# Insert into cellMeta
cellMeta(pbmcPlot, "stim_true_label", useDatasets = "stim") &lt;- stimTrueLabel
# Assume "leiden_cluster" is the clustering result we got and need to be
# evaluated
calcARI(pbmcPlot, trueCluster = "stim_true_label",
        useCluster = "leiden_cluster", useDatasets = "stim")
</code></pre>

<hr>
<h2 id='calcDatasetSpecificity'>Calculate a dataset-specificity score for each factor</h2><span id='topic+calcDatasetSpecificity'></span>

<h3>Description</h3>

<p>This score represents the relative magnitude of the
dataset-specific components of each factor's gene loadings compared to the
shared components for two datasets. First, for each dataset we calculate the
norm of the sum of each factor's shared loadings (<code class="reqn">W</code>) and
dataset-specific loadings (<code class="reqn">V</code>). We then determine the ratio of these two
values and subtract from 1... TODO: finish description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcDatasetSpecificity(
  object,
  dataset1,
  dataset2,
  doPlot = FALSE,
  do.plot = doPlot
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcDatasetSpecificity_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object with factorization results.</p>
</td></tr>
<tr><td><code id="calcDatasetSpecificity_+3A_dataset1">dataset1</code></td>
<td>
<p>Name of first dataset. Required.</p>
</td></tr>
<tr><td><code id="calcDatasetSpecificity_+3A_dataset2">dataset2</code></td>
<td>
<p>Name of second dataset. Required.</p>
</td></tr>
<tr><td><code id="calcDatasetSpecificity_+3A_doplot">doPlot</code></td>
<td>
<p>Logical. Whether to display a barplot of dataset specificity
scores (by factor). Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calcDatasetSpecificity_+3A_do.plot">do.plot</code></td>
<td>
<p><b>Deprecated</b>. Use <code>doPlot</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing three elements.
</p>
<table>
<tr><td><code>pct1</code></td>
<td>
<p>Vector of the norm of each metagene factor for dataset1.</p>
</td></tr>
<tr><td><code>pct2</code></td>
<td>
<p>Vector of the norm of each metagene factor for dataset2.</p>
</td></tr>
<tr><td><code>pctSpec</code></td>
<td>
<p>Vector of dataset specificity scores.</p>
</td></tr>
</table>

<hr>
<h2 id='calcPurity'>Calculate purity by comparing two cluster labeling variables</h2><span id='topic+calcPurity'></span>

<h3>Description</h3>

<p>This function aims at calculating the purity for the clustering result
obtained with LIGER and the external clustering (existing &quot;true&quot; annotation).
Purity can sometimes be a more useful metric when the clustering to be tested
contains more subgroups or clusters than the true clusters. Purity ranges
from 0 to 1, with a score of 1 representing a pure, accurate clustering.
</p>
<p>The true clustering annotation must be specified as the base line. We suggest
setting it to the object cellMeta so that it can be easily used for many
other visualization and evaluation functions.
</p>
<p>The purity can be calculated for only specified datasets, since true
annotation might not be available for all datasets. Evaluation for only one
or a few datasets can be done by specifying <code>useDatasets</code>. If
<code>useDatasets</code> is specified, the argument checking for <code>trueCluster</code>
and <code>useCluster</code> will be enforced to match the cells in the specified
datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPurity(
  object,
  trueCluster,
  useCluster = NULL,
  useDatasets = NULL,
  verbose = getOption("ligerVerbose", TRUE),
  classes.compare = trueCluster
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPurity_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with the clustering result
present in cellMeta.</p>
</td></tr>
<tr><td><code id="calcPurity_+3A_truecluster">trueCluster</code></td>
<td>
<p>Either the name of one variable in <code>cellMeta(object)</code>
or a factor object with annotation that matches with all cells being
considered.</p>
</td></tr>
<tr><td><code id="calcPurity_+3A_usecluster">useCluster</code></td>
<td>
<p>The name of one variable in <code>cellMeta(object)</code>.
Default <code>NULL</code> uses default clusters.</p>
</td></tr>
<tr><td><code id="calcPurity_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to be considered for the purity
calculation. Default <code>NULL</code> uses all datasets.</p>
</td></tr>
<tr><td><code id="calcPurity_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="calcPurity_+3A_classes.compare">classes.compare</code></td>
<td>
<p>[Deprecated/Renamed]. Use <code>trueCluster</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar, the purity of the clustering result indicated by
<code>useCluster</code> compared to <code>trueCluster</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assume the true cluster in `pbmcPlot` is "leiden_cluster"
# generate fake new labeling
fake &lt;- sample(1:7, ncol(pbmcPlot), replace = TRUE)
# Insert into cellMeta
pbmcPlot$new &lt;- factor(fake)
calcPurity(pbmcPlot, trueCluster = "leiden_cluster", useCluster = "new")

# Now assume we got existing base line annotation only for "stim" dataset
nStim &lt;- ncol(dataset(pbmcPlot, "stim"))
stimTrueLabel &lt;- factor(fake[1:nStim])
# Insert into cellMeta
cellMeta(pbmcPlot, "stim_true_label", useDatasets = "stim") &lt;- stimTrueLabel
# Assume "leiden_cluster" is the clustering result we got and need to be
# evaluated
calcPurity(pbmcPlot, trueCluster = "stim_true_label",
           useCluster = "leiden_cluster", useDatasets = "stim")
</code></pre>

<hr>
<h2 id='closeAllH5'>Close all links (to HDF5 files) of a liger object</h2><span id='topic+closeAllH5'></span><span id='topic+closeAllH5.liger'></span><span id='topic+closeAllH5.ligerDataset'></span>

<h3>Description</h3>

<p>When need to interact with the data embedded in HDF5 files out
of the currect R session, the HDF5 files has to be closed in order to be
available to other processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closeAllH5(object)

## S3 method for class 'liger'
closeAllH5(object)

## S3 method for class 'ligerDataset'
closeAllH5(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closeAllH5_+3A_object">object</code></td>
<td>
<p>liger object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned.
</p>

<hr>
<h2 id='commandDiff'>Check difference of two liger command</h2><span id='topic+commandDiff'></span>

<h3>Description</h3>

<p>Check difference of two liger command
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commandDiff(object, cmd1, cmd2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commandDiff_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="commandDiff_+3A_cmd1">cmd1</code>, <code id="commandDiff_+3A_cmd2">cmd2</code></td>
<td>
<p>Exact string of command labels. Available options could be
viewed with running <code>commands(object)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If any difference found, a character vector summarizing all
differences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- normalize(pbmc, log = TRUE, scaleFactor = 1e4)
cmds &lt;- commands(pbmc)
commandDiff(pbmc, cmds[1], cmds[2])
</code></pre>

<hr>
<h2 id='convertOldLiger'>Convert old liger object to latest version</h2><span id='topic+convertOldLiger'></span>

<h3>Description</h3>

<p>Convert old liger object to latest version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertOldLiger(
  object,
  dimredName,
  clusterName = "clusters",
  h5FilePath = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertOldLiger_+3A_object">object</code></td>
<td>
<p><code>liger</code> object from rliger version &lt;1.99.0</p>
</td></tr>
<tr><td><code id="convertOldLiger_+3A_dimredname">dimredName</code></td>
<td>
<p>The name of variable in <code>cellMeta</code> slot to store the
dimensionality reduction matrix, which originally located in
<code>tsne.coords</code> slot. Default <code>"tsne.coords"</code>.</p>
</td></tr>
<tr><td><code id="convertOldLiger_+3A_clustername">clusterName</code></td>
<td>
<p>The name of variable in <code>cellMeta</code> slot to store the
clustering assignment, which originally located in <code>clusters</code> slot.
Default <code>"clusters"</code>.</p>
</td></tr>
<tr><td><code id="convertOldLiger_+3A_h5filepath">h5FilePath</code></td>
<td>
<p>Named list, to specify the path to the H5 file of each
dataset if location has been changed. Default <code>NULL</code> looks at the file
paths stored in object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Suppose you have a liger object of old version (&lt;1.99.0)
newLig &lt;- convertOldLiger(oldLig)

## End(Not run)
</code></pre>

<hr>
<h2 id='coordinate'>Access ligerSpatialDataset coordinate data</h2><span id='topic+coordinate'></span><span id='topic+coordinate+3C-'></span><span id='topic+coordinate+2Cliger+2Ccharacter-method'></span><span id='topic+coordinate+3C-+2Cliger+2Ccharacter-method'></span><span id='topic+coordinate+2CligerSpatialDataset+2Cmissing-method'></span><span id='topic+coordinate+3C-+2CligerSpatialDataset+2Cmissing-method'></span>

<h3>Description</h3>

<p>Similar as how default <a href="#topic+ligerDataset-class">ligerDataset</a> data is
accessed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordinate(x, dataset)

coordinate(x, dataset, check = TRUE) &lt;- value

## S4 method for signature 'liger,character'
coordinate(x, dataset)

## S4 replacement method for signature 'liger,character'
coordinate(x, dataset, check = TRUE) &lt;- value

## S4 method for signature 'ligerSpatialDataset,missing'
coordinate(x, dataset = NULL)

## S4 replacement method for signature 'ligerSpatialDataset,missing'
coordinate(x, dataset = NULL, check = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordinate_+3A_x">x</code></td>
<td>
<p><a href="#topic+ligerSpatialDataset-class">ligerSpatialDataset</a> object or a <a href="#topic+liger-class">liger</a>
object.</p>
</td></tr>
<tr><td><code id="coordinate_+3A_dataset">dataset</code></td>
<td>
<p>Name or numeric index of an spatial dataset.</p>
</td></tr>
<tr><td><code id="coordinate_+3A_check">check</code></td>
<td>
<p>Logical, whether to perform object validity check on setting new
value.</p>
</td></tr>
<tr><td><code id="coordinate_+3A_value">value</code></td>
<td>
<p><code><a href="base.html#topic+matrix">matrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The retrieved coordinate matrix or the updated <code>x</code> object.
</p>

<hr>
<h2 id='createH5LigerDataset'>Create on-disk ligerDataset Object</h2><span id='topic+createH5LigerDataset'></span>

<h3>Description</h3>

<p>For convenience, the default <code>formatType = "10x"</code> directly fits the
structure of cellranger output. <code>formatType = "anndata"</code> works for
current AnnData H5AD file specification (see Details). If there a customized
H5 file  structure is presented, any of the <code>rawData</code>,
<code>indicesName</code>, <code>indptrName</code>, <code>genesName</code>, <code>barcodesName</code>
should be specified accordingly to override the <code>formatType</code> preset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createH5LigerDataset(
  h5file,
  formatType = "10X",
  rawData = NULL,
  normData = NULL,
  scaleData = NULL,
  barcodesName = NULL,
  genesName = NULL,
  indicesName = NULL,
  indptrName = NULL,
  anndataX = "X",
  modal = c("default", "rna", "atac", "spatial", "meth"),
  featureMeta = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createH5LigerDataset_+3A_h5file">h5file</code></td>
<td>
<p>Filename of an H5 file</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_formattype">formatType</code></td>
<td>
<p>Select preset of H5 file structure. Default <code>"10X"</code>.
Current available option is only <code>"10X"</code>.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_rawdata">rawData</code>, <code id="createH5LigerDataset_+3A_indicesname">indicesName</code>, <code id="createH5LigerDataset_+3A_indptrname">indptrName</code></td>
<td>
<p>The path in a H5 file for the raw
sparse matrix data. These three types of data stands for the <code>x</code>,
<code>i</code>, and <code>p</code> slots of a <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>
object. Default <code>NULL</code> uses <code>formatType</code> preset.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_normdata">normData</code></td>
<td>
<p>The path in a H5 file for the &quot;x&quot; vector of the normalized
sparse matrix. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_scaledata">scaleData</code></td>
<td>
<p>The path in a H5 file for the Group that contains the sparse
matrix constructing information for the scaled data. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_genesname">genesName</code>, <code id="createH5LigerDataset_+3A_barcodesname">barcodesName</code></td>
<td>
<p>The path in a H5 file for the gene names and
cell barcodes. Default <code>NULL</code> uses <code>formatType</code> preset.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_anndatax">anndataX</code></td>
<td>
<p>The HDF5 path to the raw count data in an H5AD file. See
Details. Default <code>"X"</code>.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_modal">modal</code></td>
<td>
<p>Name of modality for this dataset. Currently options of
<code>"default"</code>, <code>"rna"</code>, <code>"atac"</code>, <code>"spatial"</code> and
<code>"meth"</code> are supported. Default <code>"default"</code>.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_featuremeta">featureMeta</code></td>
<td>
<p>Data frame for feature metadata. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="createH5LigerDataset_+3A_...">...</code></td>
<td>
<p>Additional slot data. See <a href="#topic+ligerDataset-class">ligerDataset</a> for detail.
Given values will be directly placed at corresponding slots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For H5AD file written from an AnnData object, we allow using
<code>formatType = "anndata"</code> for the function to infer the proper structure.
However, while a typical AnnData-based analysis tends to in-place update the
<code>adata.X</code> attribute and there is no standard/forced convention for where
the raw count data, as needed from LIGER, is stored. Therefore, we expose
argument <code>anndataX</code> for specifying this information. The default value
<code>"X"</code> looks for <code>adata.X</code>. If the raw data is stored in a layer,
e.g. <code>adata.layers['count']</code>, then <code>anndataX = "layers/count"</code>.
If it is stored to <code>adata.raw.X</code>, then <code>anndataX = "raw/X"</code>. If
your AnnData object does not have the raw count retained, you will have to
go back to the Python work flow to have it inserted at desired object space
and re-write the H5AD file, or just go from upstream source files with which
the AnnData was originally created.
</p>


<h3>Value</h3>

<p>H5-based <a href="#topic+ligerDataset-class">ligerDataset</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h5Path &lt;- system.file("extdata/ctrl.h5", package = "rliger")
ld &lt;- createH5LigerDataset(h5Path)
</code></pre>

<hr>
<h2 id='createLiger'>Create liger object</h2><span id='topic+createLiger'></span>

<h3>Description</h3>

<p>This function allows creating <a href="#topic+liger-class">liger</a> object from
multiple datasets of various forms (See <code>rawData</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLiger(
  rawData,
  modal = NULL,
  cellMeta = NULL,
  removeMissing = TRUE,
  addPrefix = "auto",
  formatType = "10X",
  anndataX = "X",
  dataName = NULL,
  indicesName = NULL,
  indptrName = NULL,
  genesName = NULL,
  barcodesName = NULL,
  newH5 = TRUE,
  verbose = getOption("ligerVerbose", TRUE),
  ...,
  remove.missing = removeMissing,
  format.type = formatType,
  data.name = dataName,
  indices.name = indicesName,
  indptr.name = indptrName,
  genes.name = genesName,
  barcodes.name = barcodesName
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createLiger_+3A_rawdata">rawData</code></td>
<td>
<p>Named list of datasets. Required. Elements allowed include a
matrix, a <code>Seurat</code> object, a <code>SingleCellExperiment</code> object, an
<code>AnnData</code> object, a <a href="#topic+ligerDataset-class">ligerDataset</a> object or a filename to
an HDF5 file. See detail for HDF5 reading.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_modal">modal</code></td>
<td>
<p>Character vector for modality setting. Use one string for all
datasets, or the same number of strings as the number of datasets. Currently
options of <code>"default"</code>, <code>"rna"</code>, <code>"atac"</code>, <code>"spatial"</code>
and <code>"meth"</code> are supported.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_cellmeta">cellMeta</code></td>
<td>
<p>data.frame of metadata at single-cell level. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_removemissing">removeMissing</code></td>
<td>
<p>Logical. Whether to remove cells that do not have any
counts and features not expressed in any cells from each dataset. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_addprefix">addPrefix</code></td>
<td>
<p>Logical. Whether to add &quot;&lt;dataset name&gt;_&quot; as a prefix of
cell identifiers (e.g. barcodes) to avoid duplicates in multiple libraries (
common with 10X data). Default <code>"auto"</code> detects if matrix columns
already has the exact prefix or not. Logical value forces the action.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_formattype">formatType</code></td>
<td>
<p>Select preset of H5 file structure. Current available
options are <code>"10X"</code> and <code>"AnnData"</code>. Can be either a single
specification for all datasets or a character vector that match with each
dataset.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_anndatax">anndataX</code></td>
<td>
<p>The HDF5 path to the raw count data in an H5AD file. See
<code><a href="#topic+createH5LigerDataset">createH5LigerDataset</a></code> Details. Default <code>"X"</code>.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_dataname">dataName</code>, <code id="createLiger_+3A_indicesname">indicesName</code>, <code id="createLiger_+3A_indptrname">indptrName</code></td>
<td>
<p>The path in a H5 file for the raw
sparse matrix data. These three types of data stands for the <code>x</code>,
<code>i</code>, and <code>p</code> slots of a <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>
object. Default <code>NULL</code> uses <code>formatType</code> preset.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_genesname">genesName</code>, <code id="createLiger_+3A_barcodesname">barcodesName</code></td>
<td>
<p>The path in a H5 file for the gene names and
cell barcodes. Default <code>NULL</code> uses <code>formatType</code> preset.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_newh5">newH5</code></td>
<td>
<p>When using HDF5 based data and subsets created after removing
missing cells/features, whether to create new HDF5 files for the subset.
Default <code>TRUE</code>. If <code>FALSE</code>, data will be subset into memory and
can be dangerous for large scale analysis.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_...">...</code></td>
<td>
<p>Additional slot values that should be directly placed in object.</p>
</td></tr>
<tr><td><code id="createLiger_+3A_remove.missing">remove.missing</code>, <code id="createLiger_+3A_format.type">format.type</code>, <code id="createLiger_+3A_data.name">data.name</code>, <code id="createLiger_+3A_indices.name">indices.name</code>, <code id="createLiger_+3A_indptr.name">indptr.name</code>, <code id="createLiger_+3A_genes.name">genes.name</code>, <code id="createLiger_+3A_barcodes.name">barcodes.name</code></td>
<td>
<p><b>Deprecated.</b> See Usage section for replacement.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+createLigerDataset">createLigerDataset</a></code>, <code><a href="#topic+createH5LigerDataset">createH5LigerDataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create from raw count matrices
ctrl.raw &lt;- rawData(pbmc, "ctrl")
stim.raw &lt;- rawData(pbmc, "stim")
pbmc1 &lt;- createLiger(list(ctrl = ctrl.raw, stim = stim.raw))

# Create from H5 files
h5Path &lt;- system.file("extdata/ctrl.h5", package = "rliger")
print(h5Path)
lig &lt;- createLiger(list(ctrl = h5Path))

# Create from other container object
ctrl.seu &lt;- SeuratObject::CreateSeuratObject(ctrl.raw)
stim.seu &lt;- SeuratObject::CreateSeuratObject(stim.raw)
pbmc2 &lt;- createLiger(list(ctrl = ctrl.seu, stim = stim.seu))
</code></pre>

<hr>
<h2 id='createLigerDataset'>Create in-memory ligerDataset object</h2><span id='topic+createLigerDataset'></span>

<h3>Description</h3>

<p>Create in-memory ligerDataset object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLigerDataset(
  rawData = NULL,
  modal = c("default", "rna", "atac", "spatial", "meth"),
  normData = NULL,
  scaleData = NULL,
  featureMeta = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createLigerDataset_+3A_rawdata">rawData</code>, <code id="createLigerDataset_+3A_normdata">normData</code>, <code id="createLigerDataset_+3A_scaledata">scaleData</code></td>
<td>
<p>A <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>
object for the raw or normalized expression count or a dense matrix of scaled
variable gene expression, respectively. Default <code>NULL</code> for all three but
at lease one has to be specified.</p>
</td></tr>
<tr><td><code id="createLigerDataset_+3A_modal">modal</code></td>
<td>
<p>Name of modality for this dataset. Currently options of
<code>"default"</code>, <code>"rna"</code>, <code>"atac"</code>, <code>"spatial"</code> and
<code>"meth"</code> are supported. Default <code>"default"</code>.</p>
</td></tr>
<tr><td><code id="createLigerDataset_+3A_featuremeta">featureMeta</code></td>
<td>
<p>Data frame of feature metadata. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="createLigerDataset_+3A_...">...</code></td>
<td>
<p>Additional slot data. See <a href="#topic+ligerDataset-class">ligerDataset</a> for detail.
Given values will be directly placed at corresponding slots.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+ligerDataset-class">ligerDataset</a>, <a href="#topic+ligerATACDataset-class">ligerATACDataset</a>,
<a href="#topic+ligerSpatialDataset-class">ligerSpatialDataset</a>, <a href="#topic+ligerMethDataset-class">ligerMethDataset</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl.raw &lt;- rawData(pbmc, "ctrl")
ctrl.ld &lt;- createLigerDataset(ctrl.raw)
</code></pre>

<hr>
<h2 id='downsample'>Downsample datasets</h2><span id='topic+downsample'></span>

<h3>Description</h3>

<p>This function mainly aims at downsampling datasets to a size
suitable for plotting or expensive in-memmory calculation.
</p>
<p>Users can balance the sample size of categories of interests with
<code>balance</code>. Multi-variable specification to <code>balance</code> is supported,
so that at most <code>maxCells</code> cells will be sampled from each combination
of categories from the variables. For example, when two datasets are
presented and three clusters labeled across them, there would then be at most
<code class="reqn">2 \times 3 \times maxCells</code> cells being selected. Note that
<code>"dataset"</code> will automatically be added as one variable when balancing
the downsampling. However, if users want to balance the downsampling solely
basing on dataset origin, users have to explicitly set <code>balance =
"dataset"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample(
  object,
  balance = NULL,
  maxCells = 1000,
  useDatasets = NULL,
  seed = 1,
  returnIndex = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="downsample_+3A_balance">balance</code></td>
<td>
<p>Character vector of categorical variable names in
<code>cellMeta</code> slot, to subsample <code>maxCells</code> cells from each
combination of all specified variables. Default <code>NULL</code> samples
<code>maxCells</code> cells from the whole object.</p>
</td></tr>
<tr><td><code id="downsample_+3A_maxcells">maxCells</code></td>
<td>
<p>Max number of cells to sample from the grouping based on
<code>balance</code>.</p>
</td></tr>
<tr><td><code id="downsample_+3A_usedatasets">useDatasets</code></td>
<td>
<p>Index selection of datasets to include Default
<code>NULL</code> for using all datasets.</p>
</td></tr>
<tr><td><code id="downsample_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="downsample_+3A_returnindex">returnIndex</code></td>
<td>
<p>Logical, whether to only return the numeric index that can
subset the original object instead of a subset object. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="downsample_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+subsetLiger">subsetLiger</a></code>, where
<code>cellIdx</code> is occupied by internal implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>By default, a subset of <a href="#topic+liger-class">liger</a> <code>object</code>.
Alternatively when <code>returnIndex = TRUE</code>, a numeric vector to be used
with the original object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subsetting an object
pbmc &lt;- downsample(pbmc)
# Creating a subsetting index
sampleIdx &lt;- downsample(pbmcPlot, balance = "leiden_cluster",
                        maxCells = 10, returnIndex = TRUE)
plotClusterDimRed(pbmcPlot, cellIdx = sampleIdx)
</code></pre>

<hr>
<h2 id='exportInteractTrack'>Export predicted gene-pair interaction</h2><span id='topic+exportInteractTrack'></span>

<h3>Description</h3>

<p>Export the predicted gene-pair interactions calculated by
upstream function <code><a href="#topic+linkGenesAndPeaks">linkGenesAndPeaks</a></code> into an Interact Track file
which is compatible with <a href="https://genome.ucsc.edu/cgi-bin/hgCustom">UCSC
Genome Browser</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportInteractTrack(
  corrMat,
  pathToCoords,
  useGenes = NULL,
  outputPath = getwd()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exportInteractTrack_+3A_corrmat">corrMat</code></td>
<td>
<p>A sparse matrix of correlation with peak names as rows and
gene names as columns.</p>
</td></tr>
<tr><td><code id="exportInteractTrack_+3A_pathtocoords">pathToCoords</code></td>
<td>
<p>Path to the gene coordinates file.</p>
</td></tr>
<tr><td><code id="exportInteractTrack_+3A_usegenes">useGenes</code></td>
<td>
<p>Character vector of gene names to be exported. Default
<code>NULL</code> uses all genes available in <code>corrMat</code>.</p>
</td></tr>
<tr><td><code id="exportInteractTrack_+3A_outputpath">outputPath</code></td>
<td>
<p>Path of filename where the output file will be stored. If
a folder, a file named <code>"Interact_Track.bed"</code> will be created. Default
current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. A file located at <code>outputPath</code> will be created.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bmmc &lt;- normalize(bmmc)
bmmc &lt;- selectGenes(bmmc)
bmmc &lt;- scaleNotCenter(bmmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    bmmc &lt;- runINMF(bmmc)
    bmmc &lt;- quantileNorm(bmmc)
    bmmc &lt;- normalizePeak(bmmc)
    bmmc &lt;- imputeKNN(bmmc, reference = "atac", queries = "rna")
    corr &lt;- linkGenesAndPeaks(
        bmmc, useDataset = "rna",
        pathToCoords = system.file("extdata/hg19_genes.bed", package = "rliger")
    )
    resultPath &lt;- tempfile()
    exportInteractTrack(
        corrMat = corr,
        pathToCoords = system.file("extdata/hg19_genes.bed", package = "rliger"),
        outputPath = resultPath
    )
    head(read.table(resultPath, skip = 1))
}

</code></pre>

<hr>
<h2 id='getFactorMarkers'>Find shared and dataset-specific markers</h2><span id='topic+getFactorMarkers'></span>

<h3>Description</h3>

<p>Applies various filters to genes on the shared (<code class="reqn">W</code>) and
dataset-specific (<code class="reqn">V</code>) components of the factorization, before selecting
those which load most significantly on each factor (in a shared or
dataset-specific way).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFactorMarkers(
  object,
  dataset1,
  dataset2,
  factorShareThresh = 10,
  datasetSpecificity = NULL,
  logFCThresh = 1,
  pvalThresh = 0.05,
  nGenes = 30,
  printGenes = FALSE,
  verbose = getOption("ligerVerbose", TRUE),
  factor.share.thresh = factorShareThresh,
  dataset.specificity = datasetSpecificity,
  log.fc.thresh = logFCThresh,
  pval.thresh = pvalThresh,
  num.genes = nGenes,
  print.genes = printGenes
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFactorMarkers_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object with factorization results.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_dataset1">dataset1</code></td>
<td>
<p>Name of first dataset. Required.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_dataset2">dataset2</code></td>
<td>
<p>Name of second dataset. Required</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_factorsharethresh">factorShareThresh</code></td>
<td>
<p>Numeric. Only factors with a dataset specificity
less than or equal to this threshold will be used. Default <code>10</code>.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_datasetspecificity">datasetSpecificity</code></td>
<td>
<p>Numeric vector. Pre-calculated dataset specificity
if available. Length should match number of all factors available. Default
<code>NULL</code> automatically calculates with
<code><a href="#topic+calcDatasetSpecificity">calcDatasetSpecificity</a></code>.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_logfcthresh">logFCThresh</code></td>
<td>
<p>Numeric. Lower log-fold change threshold for differential
expression in markers. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_pvalthresh">pvalThresh</code></td>
<td>
<p>Numeric. Upper p-value threshold for Wilcoxon rank test for
gene expression. Default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_ngenes">nGenes</code></td>
<td>
<p>Integer. Max number of genes to report for each dataset.
Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_printgenes">printGenes</code></td>
<td>
<p>Logical. Whether to print ordered markers passing logFC,
UMI and frac thresholds, when <code>verbose = TRUE</code>. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="getFactorMarkers_+3A_factor.share.thresh">factor.share.thresh</code>, <code id="getFactorMarkers_+3A_dataset.specificity">dataset.specificity</code>, <code id="getFactorMarkers_+3A_log.fc.thresh">log.fc.thresh</code>, <code id="getFactorMarkers_+3A_pval.thresh">pval.thresh</code>, <code id="getFactorMarkers_+3A_num.genes">num.genes</code>, <code id="getFactorMarkers_+3A_print.genes">print.genes</code></td>
<td>
<p><b>Deprecated</b>. See Usage section for replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object consisting of the following entries:
</p>
<table>
<tr><td><code>[value of `dataset1`]</code></td>
<td>
<p>data.frame of dataset1-specific markers</p>
</td></tr>
<tr><td><code>shared</code></td>
<td>
<p>data.frame of shared markers</p>
</td></tr>
<tr><td><code>[value of `dataset1`]</code></td>
<td>
<p>data.frame of dataset2-specific markers</p>
</td></tr>
<tr><td><code>num_factors_V1</code></td>
<td>
<p>A frequency table indicating the number of factors each
marker appears, in dataset1</p>
</td></tr>
<tr><td><code>num_factors_V2</code></td>
<td>
<p>A frequency table indicating the number of factors each
marker appears, in dataset2</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
result &lt;- getFactorMarkers(pbmcPlot, dataset1 = "ctrl", dataset2 = "stim")
print(class(result))
print(names(result))
result$shared %&gt;% group_by(factor_num) %&gt;% top_n(2, logFC)
</code></pre>

<hr>
<h2 id='getProportionMito'>Calculate proportion mitochondrial contribution</h2><span id='topic+getProportionMito'></span>

<h3>Description</h3>

<p>Calculates proportion of mitochondrial contribution based on raw or
normalized data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProportionMito(object, use.norm = FALSE, pattern = "^mt-")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getProportionMito_+3A_object">object</code></td>
<td>
<p><code>liger</code> object.</p>
</td></tr>
<tr><td><code id="getProportionMito_+3A_use.norm">use.norm</code></td>
<td>
<p><b>Deprecated</b> Whether to use cell normalized data in
calculating contribution. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="getProportionMito_+3A_pattern">pattern</code></td>
<td>
<p>Regex pattern for identifying mitochondrial genes. Default
<code>"^mt-"</code> for mouse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector containing proportion of mitochondrial contribution for
each cell.
</p>


<h3>Note</h3>

<p><code>getProportionMito</code> will be deprecated because
<code><a href="#topic+runGeneralQC">runGeneralQC</a></code> generally covers and expands its use case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example dataset does not contain MT genes, expected to see a message
pbmc$mito &lt;- getProportionMito(pbmc)
</code></pre>

<hr>
<h2 id='H5Apply'>Apply function to chunks of H5 data in ligerDataset object</h2><span id='topic+H5Apply'></span>

<h3>Description</h3>

<p>h5 calculation wrapper, that runs specified calculation with
on-disk matrix in chunks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H5Apply(
  object,
  FUN,
  init = NULL,
  useData = c("rawData", "normData"),
  chunkSize = 1000,
  verbose = getOption("ligerVerbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H5Apply_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+ligerDataset-class">ligerDataset</a> object.</p>
</td></tr>
<tr><td><code id="H5Apply_+3A_fun">FUN</code></td>
<td>
<p>A function that is applied to each chunk. See detail for
restrictions.</p>
</td></tr>
<tr><td><code id="H5Apply_+3A_init">init</code></td>
<td>
<p>Initialized result if it need to be updated iteratively. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="H5Apply_+3A_usedata">useData</code></td>
<td>
<p>The slot name of the data to be processed. Choose from
<code>"rawData"</code>, <code>"normData"</code>, <code>"scaleData"</code>. Default
<code>"rawData"</code>.</p>
</td></tr>
<tr><td><code id="H5Apply_+3A_chunksize">chunkSize</code></td>
<td>
<p>Number if columns to be included in each chunk.
Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="H5Apply_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> which is <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="H5Apply_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>FUN</code> function has to have the first four arguments ordered
by:
</p>

<ol>
<li> <p><b>chunk data:</b> A sparse matrix
(<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code>) containing maximum <code>chunkSize</code>
columns.
</p>
</li>
<li> <p><b>x-vector index:</b> The index that subscribes the vector of <code>x</code>
slot of a dgCMatrix, which points to the values in each chunk. Mostly used
when need to write a new sparse matrix to H5 file.
</p>
</li>
<li> <p><b>cell index:</b> The column index of each chunk out of the whole
original matrix
</p>
</li>
<li> <p><b>Initialized result:</b> A customized object, the value passed to
<code>H5Apply(init)</code> argument will be passed here in the first iteration. And
the returned value of <code>FUN</code> will be iteratively passed here in next
chunk iterations. So it is important to keep the object structure of the
returned value consistent with <code>init</code>.
</p>
</li></ol>

<p>No default value to these four arguments should be pre-defined because
<code>H5Apply</code> will automatically generate the input.
</p>

<hr>
<h2 id='importPBMC'>Import prepared dataset publically available</h2><span id='topic+importPBMC'></span><span id='topic+importBMMC'></span><span id='topic+importCGE'></span>

<h3>Description</h3>

<p>These are functions to download example datasets that are subset from public
data.
</p>

<ul>
<li><p><b>PBMC</b> - Downsampled from GSE96583, Kang et al, Nature
Biotechnology, 2018. Contains two scRNAseq datasets.
</p>
</li>
<li><p><b>BMMC</b> - Downsampled from GSE139369, Granja et al, Nature
Biotechnology, 2019. Contains two scRNAseq datasets and one scATAC data.
</p>
</li>
<li><p><b>CGE</b> - Downsampled from GSE97179, Luo et al, Science, 2017.
Contains one scRNAseq dataset and one DNA methylation data.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>importPBMC(
  dir = getwd(),
  overwrite = FALSE,
  method = "libcurl",
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

importBMMC(
  dir = getwd(),
  overwrite = FALSE,
  method = "libcurl",
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

importCGE(
  dir = getwd(),
  overwrite = FALSE,
  method = "libcurl",
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importPBMC_+3A_dir">dir</code></td>
<td>
<p>Path to download datasets. Default current working directory
<code>getwd()</code>.</p>
</td></tr>
<tr><td><code id="importPBMC_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical, if a file exists at corresponding download
location, whether to re-download or directly use this file. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="importPBMC_+3A_method">method</code></td>
<td>
<p><code>method</code> argument directly passed to
<code><a href="utils.html#topic+download.file">download.file</a></code>. Using <code>"libcurl"</code> while other
options might not work depending on platform.</p>
</td></tr>
<tr><td><code id="importPBMC_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="importPBMC_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="utils.html#topic+download.file">download.file</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Constructed <a href="#topic+liger-class">liger</a> object with QC performed and missing
data removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

pbmc &lt;- importPBMC()
bmmc &lt;- importBMMC()
cge &lt;- importCGE()


</code></pre>

<hr>
<h2 id='imputeKNN'>Impute the peak counts from gene expression data referring to an ATAC dataset
after integration</h2><span id='topic+imputeKNN'></span>

<h3>Description</h3>

<p>This function is designed for creating peak data for a dataset with only gene
expression. This function uses quantile normalized cell factor loading to
find nearest neighbors between cells from the queried dataset (without peak)
and cells from reference dataset (with peak). And then impute the peak for
the former basing on the weight. Therefore, the reference dataset selected
must be of &quot;atac&quot; modality setting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeKNN(
  object,
  reference,
  queries = NULL,
  nNeighbors = 20,
  weight = TRUE,
  norm = TRUE,
  scale = FALSE,
  verbose = getOption("ligerVerbose", TRUE),
  ...,
  knn_k = nNeighbors
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeKNN_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object with aligned factor loading computed
in advance.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_reference">reference</code></td>
<td>
<p>Name of a dataset containing peak data to impute into query
dataset(s).</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_queries">queries</code></td>
<td>
<p>Names of datasets to be augmented by imputation. Should not
include <code>reference</code>. Default <code>NULL</code> uses all datasets except the
reference.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>The maximum number of nearest neighbors to search. Default
<code>20</code>.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_weight">weight</code></td>
<td>
<p>Logical. Whether to use KNN distances as weight matrix. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_norm">norm</code></td>
<td>
<p>Logical. Whether to normalize the imputed data. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_scale">scale</code></td>
<td>
<p>Logical. Whether to scale but not center the imputed data.
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <code><a href="#topic+normalize">normalize</a></code> when
<code>norm = TRUE</code>.</p>
</td></tr>
<tr><td><code id="imputeKNN_+3A_knn_k">knn_k</code></td>
<td>
<p><b>Deprecated</b>. See Usage section for replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <code>object</code> where queried <a href="#topic+ligerDataset-class">ligerDataset</a>
objects in <code>datasets</code> slot are replaced. These datasets will all be
converted to <a href="#topic+ligerATACDataset-class">ligerATACDataset</a> class with an additional slot
<code>rawPeak</code> to store the imputed peak counts, and <code>normPeak</code> for
normalized imputed peak counts if <code>norm = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bmmc &lt;- normalize(bmmc)
bmmc &lt;- selectGenes(bmmc, datasets.use = "rna")
bmmc &lt;- scaleNotCenter(bmmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    bmmc &lt;- runINMF(bmmc, k = 20)
    bmmc &lt;- quantileNorm(bmmc)
    bmmc &lt;- normalizePeak(bmmc)
    bmmc &lt;- imputeKNN(bmmc, reference = "atac", queries = "rna")
}
</code></pre>

<hr>
<h2 id='is.newLiger'>Check if given liger object if under new implementation</h2><span id='topic+is.newLiger'></span>

<h3>Description</h3>

<p>Check if given liger object if under new implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.newLiger(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.newLiger_+3A_object">object</code></td>
<td>
<p>A liger object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if the version of <code>object</code> is later than or equal to
1.99.0. Otherwise <code>FALSE</code>. It raises an error if input object is not of
<a href="#topic+liger-class">liger</a> class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.newLiger(pbmc) # TRUE
</code></pre>

<hr>
<h2 id='isH5Liger'>Check if a liger or ligerDataset object is made of HDF5 file</h2><span id='topic+isH5Liger'></span>

<h3>Description</h3>

<p>Check if a liger or ligerDataset object is made of HDF5 file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isH5Liger(object, dataset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isH5Liger_+3A_object">object</code></td>
<td>
<p>A liger or ligerDataset object.</p>
</td></tr>
<tr><td><code id="isH5Liger_+3A_dataset">dataset</code></td>
<td>
<p>If <code>object</code> is of liger class, check a specific dataset.
If <code>NULL</code>, Check if all datasets are made of HDF5 file. Default
<code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code> for the specified check.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isH5Liger(pbmc)
isH5Liger(pbmc, "ctrl")
ctrl &lt;- dataset(pbmc, "ctrl")
isH5Liger(ctrl)
</code></pre>

<hr>
<h2 id='liger-class'>liger class</h2><span id='topic+liger-class'></span><span id='topic+liger'></span><span id='topic+datasets'></span><span id='topic+datasets+3C-'></span><span id='topic+dataset'></span><span id='topic+dataset+3C-'></span><span id='topic+cellMeta'></span><span id='topic+cellMeta+3C-'></span><span id='topic+defaultCluster'></span><span id='topic+defaultCluster+3C-'></span><span id='topic+dimReds'></span><span id='topic+dimReds+3C-'></span><span id='topic+dimRed'></span><span id='topic+dimRed+3C-'></span><span id='topic+defaultDimRed'></span><span id='topic+defaultDimRed+3C-'></span><span id='topic+varFeatures'></span><span id='topic+varFeatures+3C-'></span><span id='topic+varUnsharedFeatures'></span><span id='topic+varUnsharedFeatures+3C-'></span><span id='topic+commands'></span><span id='topic+show+2Cliger-method'></span><span id='topic+dim+2Cliger-method'></span><span id='topic+dimnames+2Cliger-method'></span><span id='topic+dimnames+3C-+2Cliger+2Clist-method'></span><span id='topic+datasets+2Cliger-method'></span><span id='topic+datasets+3C-+2Cliger+2Clogical-method'></span><span id='topic+datasets+3C-+2Cliger+2Cmissing-method'></span><span id='topic+dataset+2Cliger+2Ccharacter_OR_NULL-method'></span><span id='topic+dataset+2Cliger+2Cmissing-method'></span><span id='topic+dataset+2Cliger+2Cnumeric-method'></span><span id='topic+dataset+3C-+2Cliger+2Ccharacter+2Cmissing+2CANY+2CligerDataset-method'></span><span id='topic+dataset+3C-+2Cliger+2Ccharacter+2CANY+2CANY+2CmatrixLike-method'></span><span id='topic+dataset+3C-+2Cliger+2Ccharacter+2Cmissing+2CANY+2CNULL-method'></span><span id='topic+names.liger'></span><span id='topic+names+3C-.liger'></span><span id='topic+length.liger'></span><span id='topic+lengths.liger'></span><span id='topic+cellMeta+2Cliger+2CNULL-method'></span><span id='topic+cellMeta+2Cliger+2Ccharacter-method'></span><span id='topic+cellMeta+2Cliger+2Cmissing-method'></span><span id='topic+cellMeta+3C-+2Cliger+2Cmissing-method'></span><span id='topic+cellMeta+3C-+2Cliger+2Ccharacter-method'></span><span id='topic+rawData+2Cliger-method'></span><span id='topic+rawData+3C-+2Cliger+2CANY+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+rawData+3C-+2Cliger+2CANY+2CANY+2CH5D-method'></span><span id='topic+normData+2Cliger-method'></span><span id='topic+normData+3C-+2Cliger+2CANY+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+normData+3C-+2Cliger+2CANY+2CANY+2CH5D-method'></span><span id='topic+scaleData+2Cliger+2CANY-method'></span><span id='topic+scaleData+3C-+2Cliger+2CANY+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+scaleData+3C-+2Cliger+2CANY+2CANY+2CH5D-method'></span><span id='topic+scaleData+3C-+2Cliger+2CANY+2CANY+2CH5Group-method'></span><span id='topic+scaleUnsharedData+2Cliger+2Ccharacter-method'></span><span id='topic+scaleUnsharedData+2Cliger+2Cnumeric-method'></span><span id='topic+scaleUnsharedData+3C-+2Cliger+2CANY+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+scaleUnsharedData+3C-+2Cliger+2CANY+2CANY+2CH5D-method'></span><span id='topic+scaleUnsharedData+3C-+2Cliger+2CANY+2CANY+2CH5Group-method'></span><span id='topic+getMatrix+2Cliger+2CANY+2CANY+2CANY-method'></span><span id='topic+getH5File+2Cliger+2CANY-method'></span><span id='topic++5B+5B+3C-.liger'></span><span id='topic++24.liger'></span><span id='topic++24+3C-.liger'></span><span id='topic+defaultCluster+2Cliger-method'></span><span id='topic+defaultCluster+3C-+2Cliger+2CANY+2CANY+2Ccharacter-method'></span><span id='topic+defaultCluster+3C-+2Cliger+2CANY+2CANY+2Cfactor-method'></span><span id='topic+defaultCluster+3C-+2Cliger+2CANY+2CANY+2CNULL-method'></span><span id='topic+dimReds+2Cliger-method'></span><span id='topic+dimReds+3C-+2Cliger+2Clist-method'></span><span id='topic+dimRed+2Cliger+2Cmissing_OR_NULL-method'></span><span id='topic+dimRed+2Cliger+2Cindex-method'></span><span id='topic+dimRed+3C-+2Cliger+2Cindex+2CANY+2CANY+2CNULL-method'></span><span id='topic+dimRed+3C-+2Cliger+2Ccharacter+2CANY+2CANY+2CmatrixLike-method'></span><span id='topic+defaultDimRed+2Cliger-method'></span><span id='topic+defaultDimRed+3C-+2Cliger+2Ccharacter-method'></span><span id='topic+varFeatures+2Cliger-method'></span><span id='topic+varFeatures+3C-+2Cliger+2CANY+2Ccharacter-method'></span><span id='topic+varUnsharedFeatures+2Cliger+2CANY-method'></span><span id='topic+varUnsharedFeatures+3C-+2Cliger+2CANY+2CANY+2Ccharacter-method'></span><span id='topic+fortify.liger'></span><span id='topic+c.liger'></span><span id='topic+commands+2Cliger-method'></span><span id='topic+varUnsharedFeatures+2CligerDataset+2Cmissing-method'></span><span id='topic+varUnsharedFeatures+3C-+2CligerDataset+2Cmissing+2CANY+2Ccharacter-method'></span>

<h3>Description</h3>

<p><code>liger</code> object is the main data container for LIGER
analysis in R. The slot <code>datasets</code> is a list where each element should
be a <a href="#topic+ligerDataset-class">ligerDataset</a> object containing dataset specific
information, such as the expression matrices. The other parts of liger object
stores information that can be shared across the analysis, such as the cell
metadata and factorization result matrices.
</p>
<p>This manual provides explanation to the <code>liger</code> object structure as well
as usage of class-specific methods. Please see detail sections for more
information.
</p>
<p>For <code>liger</code> objects created with older versions of rliger package,
please try updating the objects individually with
<code><a href="#topic+convertOldLiger">convertOldLiger</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datasets(x, check = NULL)

datasets(x, check = TRUE) &lt;- value

dataset(x, dataset = NULL)

dataset(x, dataset, type = NULL, qc = TRUE) &lt;- value

cellMeta(
  x,
  columns = NULL,
  useDatasets = NULL,
  cellIdx = NULL,
  as.data.frame = FALSE,
  ...
)

cellMeta(
  x,
  columns = NULL,
  useDatasets = NULL,
  cellIdx = NULL,
  inplace = FALSE,
  check = FALSE
) &lt;- value

defaultCluster(x, useDatasets = NULL, ...)

defaultCluster(x, name = NULL, useDatasets = NULL, ...) &lt;- value

dimReds(x)

dimReds(x) &lt;- value

dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...)

dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...) &lt;- value

defaultDimRed(x, useDatasets = NULL, cellIdx = NULL)

defaultDimRed(x) &lt;- value

varFeatures(x)

varFeatures(x, check = TRUE) &lt;- value

varUnsharedFeatures(x, dataset = NULL)

varUnsharedFeatures(x, dataset, check = TRUE) &lt;- value

commands(x, funcName = NULL, arg = NULL)

## S4 method for signature 'liger'
show(object)

## S4 method for signature 'liger'
dim(x)

## S4 method for signature 'liger'
dimnames(x)

## S4 replacement method for signature 'liger,list'
dimnames(x) &lt;- value

## S4 method for signature 'liger'
datasets(x, check = NULL)

## S4 replacement method for signature 'liger,logical'
datasets(x, check = TRUE) &lt;- value

## S4 replacement method for signature 'liger,missing'
datasets(x, check = TRUE) &lt;- value

## S4 method for signature 'liger,character_OR_NULL'
dataset(x, dataset = NULL)

## S4 method for signature 'liger,missing'
dataset(x, dataset = NULL)

## S4 method for signature 'liger,numeric'
dataset(x, dataset = NULL)

## S4 replacement method for signature 'liger,character,missing,ANY,ligerDataset'
dataset(x, dataset, type = NULL, qc = TRUE) &lt;- value

## S4 replacement method for signature 'liger,character,ANY,ANY,matrixLike'
dataset(x, dataset, type = c("rawData", "normData"), qc = FALSE) &lt;- value

## S4 replacement method for signature 'liger,character,missing,ANY,NULL'
dataset(x, dataset, type = NULL, qc = TRUE) &lt;- value

## S3 method for class 'liger'
names(x)

## S3 replacement method for class 'liger'
names(x) &lt;- value

## S3 method for class 'liger'
length(x)

## S3 method for class 'liger'
lengths(x, use.names = TRUE)

## S4 method for signature 'liger,NULL'
cellMeta(
  x,
  columns = NULL,
  useDatasets = NULL,
  cellIdx = NULL,
  as.data.frame = FALSE,
  ...
)

## S4 method for signature 'liger,character'
cellMeta(
  x,
  columns = NULL,
  useDatasets = NULL,
  cellIdx = NULL,
  as.data.frame = FALSE,
  ...
)

## S4 method for signature 'liger,missing'
cellMeta(
  x,
  columns = NULL,
  useDatasets = NULL,
  cellIdx = NULL,
  as.data.frame = FALSE,
  ...
)

## S4 replacement method for signature 'liger,missing'
cellMeta(x, columns = NULL, useDatasets = NULL, cellIdx = NULL, check = FALSE) &lt;- value

## S4 replacement method for signature 'liger,character'
cellMeta(
  x,
  columns = NULL,
  useDatasets = NULL,
  cellIdx = NULL,
  inplace = TRUE,
  check = FALSE
) &lt;- value

## S4 method for signature 'liger'
rawData(x, dataset = NULL)

## S4 replacement method for signature 'liger,ANY,ANY,matrixLike_OR_NULL'
rawData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,H5D'
rawData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'liger'
normData(x, dataset = NULL)

## S4 replacement method for signature 'liger,ANY,ANY,matrixLike_OR_NULL'
normData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,H5D'
normData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'liger,ANY'
scaleData(x, dataset = NULL)

## S4 replacement method for signature 'liger,ANY,ANY,matrixLike_OR_NULL'
scaleData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,H5D'
scaleData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,H5Group'
scaleData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'liger,character'
scaleUnsharedData(x, dataset = NULL)

## S4 method for signature 'liger,numeric'
scaleUnsharedData(x, dataset = NULL)

## S4 replacement method for signature 'liger,ANY,ANY,matrixLike_OR_NULL'
scaleUnsharedData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,H5D'
scaleUnsharedData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,H5Group'
scaleUnsharedData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'liger,ANY,ANY,ANY'
getMatrix(
  x,
  slot = c("rawData", "normData", "scaleData", "scaleUnsharedData", "H", "V", "U", "A",
    "B", "W", "H.norm"),
  dataset = NULL,
  returnList = FALSE
)

## S4 method for signature 'liger,ANY'
getH5File(x, dataset = NULL)

## S3 replacement method for class 'liger'
x[[i]] &lt;- value

## S3 method for class 'liger'
x$name

## S3 replacement method for class 'liger'
x$name &lt;- value

## S4 method for signature 'liger'
defaultCluster(x, useDatasets = NULL, droplevels = FALSE, ...)

## S4 replacement method for signature 'liger,ANY,ANY,character'
defaultCluster(x, name = NULL, useDatasets = NULL, ...) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,factor'
defaultCluster(x, name = NULL, useDatasets = NULL, droplevels = TRUE, ...) &lt;- value

## S4 replacement method for signature 'liger,ANY,ANY,NULL'
defaultCluster(x, name = NULL, useDatasets = NULL, ...) &lt;- value

## S4 method for signature 'liger'
dimReds(x)

## S4 replacement method for signature 'liger,list'
dimReds(x) &lt;- value

## S4 method for signature 'liger,missing_OR_NULL'
dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...)

## S4 method for signature 'liger,index'
dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...)

## S4 replacement method for signature 'liger,index,ANY,ANY,NULL'
dimRed(x, name = NULL, useDatasets = NULL, cellIdx = NULL, ...) &lt;- value

## S4 replacement method for signature 'liger,character,ANY,ANY,matrixLike'
dimRed(
  x,
  name = NULL,
  useDatasets = NULL,
  cellIdx = NULL,
  asDefault = NULL,
  inplace = FALSE,
  ...
) &lt;- value

## S4 method for signature 'liger'
defaultDimRed(x, useDatasets = NULL, cellIdx = cellIdx)

## S4 replacement method for signature 'liger,character'
defaultDimRed(x) &lt;- value

## S4 method for signature 'liger'
varFeatures(x)

## S4 replacement method for signature 'liger,ANY,character'
varFeatures(x, check = TRUE) &lt;- value

## S4 method for signature 'liger,ANY'
varUnsharedFeatures(x, dataset = NULL)

## S4 replacement method for signature 'liger,ANY,ANY,character'
varUnsharedFeatures(x, dataset, check = TRUE) &lt;- value

## S3 method for class 'liger'
fortify(model, data, ...)

## S3 method for class 'liger'
c(...)

## S4 method for signature 'liger'
commands(x, funcName = NULL, arg = NULL)

## S4 method for signature 'ligerDataset,missing'
varUnsharedFeatures(x, dataset = NULL)

## S4 replacement method for signature 'ligerDataset,missing,ANY,character'
varUnsharedFeatures(x, dataset = NULL, check = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="liger-class_+3A_x">x</code>, <code id="liger-class_+3A_object">object</code>, <code id="liger-class_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="liger-class_+3A_check">check</code></td>
<td>
<p>Logical, whether to perform object validity check on setting new
value. Users are not supposed to set <code>FALSE</code> here.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_value">value</code></td>
<td>
<p>Metadata value to be inserted</p>
</td></tr>
<tr><td><code id="liger-class_+3A_dataset">dataset</code></td>
<td>
<p>Name or numeric index of a dataset</p>
</td></tr>
<tr><td><code id="liger-class_+3A_type">type</code></td>
<td>
<p>When using <code>dataset&lt;-</code> with a matrix like <code>value</code>,
specify what type the matrix is. Choose from <code>"rawData"</code>,
<code>"normData"</code> or <code>"scaleData"</code>.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_qc">qc</code></td>
<td>
<p>Logical, whether to perform general qc on added new dataset.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_columns">columns</code></td>
<td>
<p>The names of available variables in <code>cellMeta</code> slot. When
<code>as.data.frame = TRUE</code>, please use variable names after coercion.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_usedatasets">useDatasets</code></td>
<td>
<p>Setter or getter method should only apply on cells in
specified datasets. Any valid character, numeric or logical subscriber is
acceptable. Default <code>NULL</code> works with all datasets.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_cellidx">cellIdx</code></td>
<td>
<p>Valid cell subscription to subset retrieved variables. Default
<code>NULL</code> uses all cells.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>Logical, whether to apply
<code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> on the subscription. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_...">...</code></td>
<td>
<p>See detailed sections for explanation.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_inplace">inplace</code></td>
<td>
<p>For <code>cellMeta&lt;-</code> method, when <code>columns</code> is for
existing variable and <code>useDatasets</code> or <code>cellIdx</code> indicate partial
insertion to the object, whether to by default (<code>TRUE</code>) in-place insert
<code>value</code> into the variable for selected cells or to replace the whole
variable with non-selected part left as NA.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_name">name</code></td>
<td>
<p>The name of available variables in <code>cellMeta</code> slot or the
name of a new variable to store.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_funcname">funcName</code>, <code id="liger-class_+3A_arg">arg</code></td>
<td>
<p>See Command records section.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_use.names">use.names</code></td>
<td>
<p>Whether returned vector should be named with dataset names.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_slot">slot</code></td>
<td>
<p>Name of slot to retrieve matrix from. Options shown in Usage.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_returnlist">returnList</code></td>
<td>
<p>Logical, whether to force return a list even when only one
dataset-specific matrix (i.e. expression matrices, H, V or U) is requested.
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_i">i</code></td>
<td>
<p>Name or numeric index of cell meta variable to be replaced</p>
</td></tr>
<tr><td><code id="liger-class_+3A_droplevels">droplevels</code></td>
<td>
<p>Whether to remove unused cluster levels from the factor
object fetched by <code>defaultCluster()</code>. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_asdefault">asDefault</code></td>
<td>
<p>Whether to set the inserted dimension reduction matrix as
default for visualization methods. Default <code>NULL</code> sets it when no
default has been set yet, otherwise does not change current default.</p>
</td></tr>
<tr><td><code id="liger-class_+3A_data">data</code></td>
<td>
<p>fortify method required argument. Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See detailed sections for explanetion.
</p>
<p>Input liger object updated with replaced/new variable in
<code>cellMeta(x)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>datasets</code></dt><dd><p>list of <a href="#topic+ligerDataset-class">ligerDataset</a> objects. Use generic
<code>dataset</code>, <code>dataset&lt;-</code>, <code>datasets</code> or <code>datasets&lt;-</code> to
interact with. See detailed section accordingly.</p>
</dd>
<dt><code>cellMeta</code></dt><dd><p><a href="S4Vectors.html#topic+DFrame-class">DFrame</a> object for cell metadata. Pre-existing
metadata, QC metrics, cluster labeling, low-dimensional embedding and etc.
are all stored here. Use generic <code>cellMeta</code>, <code>cellMeta&lt;-</code>,
<code>$</code>, <code>[[]]</code> or <code>[[]]&lt;-</code> to interact with. See detailed section
accordingly.</p>
</dd>
<dt><code>varFeatures</code></dt><dd><p>Character vector of feature names. Use generic
<code>varFeatures</code> or <code>varFeatures&lt;-</code> to interact with. See detailed
section accordingly.</p>
</dd>
<dt><code>W</code></dt><dd><p>Matrix of gene loading for each factor. See
<code><a href="#topic+runIntegration">runIntegration</a></code>.</p>
</dd>
<dt><code>H.norm</code></dt><dd><p>Matrix of aligned factor loading for each cell. See
<code><a href="#topic+quantileNorm">quantileNorm</a></code> and <code><a href="#topic+runIntegration">runIntegration</a></code>.</p>
</dd>
<dt><code>commands</code></dt><dd><p>List of <a href="#topic+ligerCommand-class">ligerCommand</a> objects. Record of
analysis. Use <code>commands</code> to retrieve information. See detailed section
accordingly.</p>
</dd>
<dt><code>uns</code></dt><dd><p>List for unstructured meta-info of analyses or presets.</p>
</dd>
<dt><code>version</code></dt><dd><p>Record of version of rliger package</p>
</dd>
</dl>


<h3>Dataset access</h3>

<p><code>datasets()</code> method only accesses the <code>datasets</code> slot, the list of
<a href="#topic+ligerDataset-class">ligerDataset</a> objects. <code>dataset()</code> method accesses a single
dataset, with subsequent cell metadata updates and checks bonded when adding
or modifying a dataset. Therefore, when users want to modify something inside
a <code>ligerDataset</code> while no cell metadata change should happen, it is
recommended to use: <code>datasets(x)[[name]] &lt;- ligerD</code> for efficiency,
though the result would be the same as <code>dataset(x, name) &lt;- ligerD</code>.
</p>
<p><code>length()</code> and <code>names()</code> methods are implemented to access the
number and names of datasets. <code>names&lt;-</code> method is supported for
modifying dataset names, with taking care of the &quot;dataset&quot; variable in cell
metadata.
</p>


<h3>Matrix access</h3>

<p>For <code>liger</code> object, <code>rawData()</code>, <code>normData</code>,
<code>scaleData()</code> and <code>scaleUnsharedData()</code> methods are exported for
users to access the corresponding feature expression matrix with
specification of one dataset. For retrieving a type of matrix from multiple
datasets, please use <code>getMatrix()</code> method.
</p>
<p>When only one matrix is expected to be retrieved by <code>getMatrix()</code>, the
matrix itself will be returned. A list will be returned if multiple matrices
is requested (by querying multiple datasets) or <code>returnList</code> is set to
<code>TRUE</code>.
</p>


<h3>Cell metadata access</h3>

<p>Three approaches are provided for access of cell metadata. A generic function
<code>cellMeta</code> is implemented with plenty of options and multi-variable
accessibility. Besides, users can use double-bracket (e.g.
<code>ligerObj[[varName]]</code>) or dollor-sign (e.g. <code>ligerObj$nUMI</code>) to
access or modify single variables.
</p>
<p>For users' convenience of generating a customized ggplot with available cell
metadata, the S3 method <code>fortify.liger</code> is implemented. With this under
the hook, users can create simple ggplots by directly starting with
<code>ggplot(ligerObj, aes(...))</code> where cell metadata variables can be
directly thrown into <code>aes()</code>.
</p>
<p>Special partial metadata insertion is implemented specifically for mapping
categorical annotation from sub-population (subset object) back to original
experiment (full-size object). For example, when sub-clustering and
annotation is done for a specific cell-type of cells (stored in
<code>subobj</code>) subset from an experiment (stored as <code>obj</code>), users can do
<code>cellMeta(obj, "sub_ann", cellIdx = colnames(subobj)) &lt;- subobj$sub_ann</code>
to map the value back, leaving other cells non-annotated with NAs. Plotting
with this variable will then also show NA cells with default grey color.
Furthermore, sub-clustering labels for other cell types can also be mapped
to the same variable. For example, <code>cellMeta(obj, "sub_ann",
cellIdx = colnames(subobj2)) &lt;- subobj2$sub_ann</code>. As long as the labeling
variables are stored as factor class (categorical), the levels (category
names) will be properly handled and merged. Other situations follow the R
default behavior (e.g. categories might be converted to integer numbers if
mapped to numerical variable in the original object). Note that this feature
is only available with using the generic function <code>cellMeta</code> but not
with the <code>`[[`</code> or <code>`$`</code> accessing methods due to syntax reasons.
</p>
<p>The generic <code>defaultCluster</code> works as both getter and setter. As a
setter, users can do <code>defaultCluster(obj) &lt;- "existingVariableName"</code> to
set a categorical variable as default cluster used for visualization or
downstream analysis. Users can also do <code>defaultCluster(obj,
"newVarName") &lt;- factorOfLabels</code> to push new labeling into the object and set
as default. For getter method, the function returns a factor object of the
default cluster labeling. Argument <code>useDatasets</code> can be used for
requiring that given or retrieved labeling should match with cells in
specified datasets. We generally don't recommend setting <code>"dataset"</code> as
a default cluster because it is a preserved (always existing) field in
metadata and can lead to meaningless result when running analysis that
utilizes both clustering information and the dataset source information.
</p>


<h3>Dimension reduction access</h3>

<p>Currently, low-dimensional representaion of cells, presented as dense
matrices, are all stored in <code>dimReds</code> slot, and can totally be accessed
with generics <code>dimRed</code> and <code>dimRed&lt;-</code>. Adding a dimRed to the
object looks as simple as <code>dimRed(obj, "name") &lt;- matrixLike</code>. It can
be retrieved back with <code>dimRed(obj, "name")</code>. Similar to having a
default cluster labeling, we also constructed the feature of default dimRed.
It can be set with <code>defaultDimRed(obj) &lt;- "existingMatLikeVar"</code> and the
matrix can be retrieved with <code>defaultDimRed(obj)</code>.
</p>


<h3>Variable feature access</h3>

<p>The <code>varFeatures</code> slot allows for character vectors of gene names.
<code>varFeatures(x)</code> returns this vector and <code>value</code> for
<code>varFeatures&lt;-</code> method has to be a character vector or <code>NULL</code>.
The replacement method, when <code>check = TRUE</code> performs checks on gene
name consistency check across the <code>scaleData</code>, <code>H</code>, <code>V</code> slots
of inner <code>ligerDataset</code> objects as well as the <code>W</code> and
<code>H.norm</code> slots of the input <code>liger</code> object.
</p>


<h3>Command records</h3>

<p>rliger functions, that perform calculation and update the <code>liger</code>
object, will be recorded in a <code>ligerCommand</code> object and stored in the
<code>commands</code> slot, a list, of <code>liger</code> object. Method
<code>commands()</code> is implemented to retrieve or show the log history.
Running with <code>funcName = NULL</code> (default) returns all command labels.
Specifying <code>funcName</code> allows partial matching to all command labels
and returns a subset list (of <code>ligerCommand</code> object) of matches (or
the <code>ligerCommand</code> object if only one match found). If <code>arg</code> is
further specified, a subset list of parameters from the matches will be
returned. For example, requesting a list of resolution values used in
all louvain cluster attempts: <code>commands(ligerObj, "louvainCluster",
"resolution")</code>
</p>


<h3>Dimensionality</h3>

<p>For a <code>liger</code> object, the column orientation is assigned for
cells. Due to the data structure, it is hard to define a row index for the
<code>liger</code> object, which might contain datasets that vary in number of
genes.
</p>
<p>Therefore, for <code>liger</code> objects, <code>dim</code> and <code>dimnames</code> returns
<code>NA</code>/<code>NULL</code> for rows and total cell counts/barcodes for the
columns.
</p>
<p>For direct call of <code>dimnames&lt;-</code> method, <code>value</code> should be a list
with <code>NULL</code> as the first element and valid cell identifiers as the
second element. For <code>colnames&lt;-</code> method, the character vector of cell
identifiers. <code>rownames&lt;-</code> method is not applicable.
</p>


<h3>Subsetting</h3>

<p>For more detail of subsetting a <code>liger</code> object or a
<a href="#topic+ligerDataset-class">ligerDataset</a> object, please check out <code><a href="#topic+subsetLiger">subsetLiger</a></code>
and <code><a href="#topic+subsetLigerDataset">subsetLigerDataset</a></code>. Here, we set the S4 method
&quot;single-bracket&quot; <code>[</code> as a quick wrapper to subset a <code>liger</code> object.
Note that <code>j</code> serves as cell subscriptor which can be any valid index
refering the collection of all cells (i.e. <code>rownames(cellMeta(obj))</code>).
While <code>i</code>, the feature subscriptor can only be character vector because
the features for each dataset can vary. <code>...</code> arugments are passed to
<code>subsetLiger</code> so that advanced options are allowed.
</p>


<h3>Combining multiple liger object</h3>

<p>The list of <code>datasets</code> slot,
the rows of <code>cellMeta</code> slot and the list of <code>commands</code> slot will
be simply concatenated. Variable features in <code>varFeatures</code> slot will be
taken a union. The <code class="reqn">W</code> and <code class="reqn">H.norm</code> matrices are not taken into
account for now.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Methods for base generics
pbmcPlot
print(pbmcPlot)
dim(pbmcPlot)
ncol(pbmcPlot)
colnames(pbmcPlot)[1:5]
pbmcPlot[varFeatures(pbmcPlot)[1:10], 1:10]
names(pbmcPlot)
length(pbmcPlot)

# rliger generics
## Retrieving dataset(s), replacement methods available
datasets(pbmcPlot)
dataset(pbmcPlot, "ctrl")
dataset(pbmcPlot, 2)

## Retrieving cell metadata, replacement methods available
cellMeta(pbmcPlot)
head(pbmcPlot[["nUMI"]])

## Retrieving dimemtion reduction matrix
head(dimRed(pbmcPlot, "UMAP"))

## Retrieving variable features, replacement methods available
varFeatures(pbmcPlot)

## Command record/history
pbmcPlot &lt;- scaleNotCenter(pbmcPlot)
commands(pbmcPlot)
commands(pbmcPlot, funcName = "scaleNotCenter")

# S3 methods
pbmcPlot2 &lt;- pbmcPlot
names(pbmcPlot2) &lt;- paste0(names(pbmcPlot), 2)
c(pbmcPlot, pbmcPlot2)

library(ggplot2)
ggplot(pbmcPlot, aes(x = UMAP_1, y = UMAP_2)) + geom_point()
cellMeta(pbmc)
# Add new variable
pbmc[["newVar"]] &lt;- 1
cellMeta(pbmc)
# Change existing variable
pbmc[["newVar"]][1:3] &lt;- 1:3
cellMeta(pbmc)
</code></pre>

<hr>
<h2 id='ligerATACDataset-class'>Subclass of ligerDataset for ATAC modality</h2><span id='topic+ligerATACDataset-class'></span><span id='topic+ligerATACDataset'></span>

<h3>Description</h3>

<p>Inherits from <a href="#topic+ligerDataset-class">ligerDataset</a> class. Contained slots
can be referred with the link.
</p>


<h3>Slots</h3>


<dl>
<dt><code>rawPeak</code></dt><dd><p>sparse matrix</p>
</dd>
<dt><code>normPeak</code></dt><dd><p>sparse matrix</p>
</dd>
</dl>

<hr>
<h2 id='ligerCommand-class'>ligerCommand object: Record the input and time of a LIGER function call</h2><span id='topic+ligerCommand-class'></span><span id='topic+ligerCommand'></span><span id='topic+show+2CligerCommand-method'></span>

<h3>Description</h3>

<p>ligerCommand object: Record the input and time of a LIGER function call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ligerCommand'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ligerCommand-class_+3A_object">object</code></td>
<td>
<p>A <code>ligerCommand</code> object</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>funcName</code></dt><dd><p>Name of the function</p>
</dd>
<dt><code>time</code></dt><dd><p>A time stamp object</p>
</dd>
<dt><code>call</code></dt><dd><p>A character string converted from system call</p>
</dd>
<dt><code>parameters</code></dt><dd><p>List of all arguments except the <a href="#topic+liger-class">liger</a> object.
Large object are summarized to short string.</p>
</dd>
<dt><code>objSummary</code></dt><dd><p>List of attributes of the <a href="#topic+liger-class">liger</a> object as a
snapshot when command is operated.</p>
</dd>
<dt><code>ligerVersion</code></dt><dd><p>Character string converted from
<code>packageVersion("rliger")</code>.</p>
</dd>
<dt><code>dependencyVersion</code></dt><dd><p>Named character vector of version number, if any
dependency library has a chance to be included by the function. A
dependency might only be invoked under certain conditions, such as using
an alternative algorithm, which a call does not actually reach to, but it
would still be included for this call.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
cmd &lt;- commands(pbmc, "normalize")
cmd
</code></pre>

<hr>
<h2 id='ligerDataset-class'>ligerDataset class</h2><span id='topic+ligerDataset-class'></span><span id='topic+ligerDataset'></span><span id='topic+rawData'></span><span id='topic+rawData+3C-'></span><span id='topic+normData'></span><span id='topic+normData+3C-'></span><span id='topic+scaleData'></span><span id='topic+scaleData+3C-'></span><span id='topic+scaleUnsharedData'></span><span id='topic+scaleUnsharedData+3C-'></span><span id='topic+getMatrix'></span><span id='topic+h5fileInfo'></span><span id='topic+h5fileInfo+3C-'></span><span id='topic+getH5File'></span><span id='topic+getH5File+2CligerDataset+2Cmissing-method'></span><span id='topic+featureMeta'></span><span id='topic+featureMeta+3C-'></span><span id='topic+show+2CligerDataset-method'></span><span id='topic+dim+2CligerDataset-method'></span><span id='topic+dimnames+2CligerDataset-method'></span><span id='topic+dimnames+3C-+2CligerDataset+2Clist-method'></span><span id='topic+rawData+2CligerDataset-method'></span><span id='topic+rawData+3C-+2CligerDataset+2CANY+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+rawData+3C-+2CligerDataset+2CANY+2CANY+2CH5D-method'></span><span id='topic+normData+2CligerDataset-method'></span><span id='topic+normData+3C-+2CligerDataset+2CANY+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+normData+3C-+2CligerDataset+2CANY+2CANY+2CH5D-method'></span><span id='topic+scaleData+2CligerDataset+2Cmissing-method'></span><span id='topic+scaleData+3C-+2CligerDataset+2CANY+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+scaleData+3C-+2CligerDataset+2CANY+2CANY+2CH5D-method'></span><span id='topic+scaleData+3C-+2CligerDataset+2CANY+2CANY+2CH5Group-method'></span><span id='topic+scaleUnsharedData+2CligerDataset+2Cmissing-method'></span><span id='topic+scaleUnsharedData+3C-+2CligerDataset+2Cmissing+2CANY+2CmatrixLike_OR_NULL-method'></span><span id='topic+scaleUnsharedData+3C-+2CligerDataset+2Cmissing+2CANY+2CH5D-method'></span><span id='topic+scaleUnsharedData+3C-+2CligerDataset+2Cmissing+2CANY+2CH5Group-method'></span><span id='topic+getMatrix+2CligerDataset+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic+h5fileInfo+2CligerDataset-method'></span><span id='topic+h5fileInfo+3C-+2CligerDataset-method'></span><span id='topic+featureMeta+2CligerDataset-method'></span><span id='topic+featureMeta+3C-+2CligerDataset-method'></span><span id='topic+cbind.ligerDataset'></span>

<h3>Description</h3>

<p>Object for storing dastaset specific information. Will be embedded within a
higher level <a href="#topic+liger-class">liger</a> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawData(x, dataset = NULL)

rawData(x, dataset = NULL, check = TRUE) &lt;- value

normData(x, dataset = NULL)

normData(x, dataset = NULL, check = TRUE) &lt;- value

scaleData(x, dataset = NULL)

scaleData(x, dataset = NULL, check = TRUE) &lt;- value

scaleUnsharedData(x, dataset = NULL)

scaleUnsharedData(x, dataset = NULL, check = TRUE) &lt;- value

getMatrix(x, slot = "rawData", dataset = NULL, returnList = FALSE)

h5fileInfo(x, info = NULL)

h5fileInfo(x, info = NULL, check = TRUE) &lt;- value

getH5File(x, dataset = NULL)

## S4 method for signature 'ligerDataset,missing'
getH5File(x, dataset = NULL)

featureMeta(x, check = NULL)

featureMeta(x, check = TRUE) &lt;- value

## S4 method for signature 'ligerDataset'
show(object)

## S4 method for signature 'ligerDataset'
dim(x)

## S4 method for signature 'ligerDataset'
dimnames(x)

## S4 replacement method for signature 'ligerDataset,list'
dimnames(x) &lt;- value

## S4 method for signature 'ligerDataset'
rawData(x, dataset = NULL)

## S4 replacement method for signature 'ligerDataset,ANY,ANY,matrixLike_OR_NULL'
rawData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'ligerDataset,ANY,ANY,H5D'
rawData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'ligerDataset'
normData(x, dataset = NULL)

## S4 replacement method for signature 'ligerDataset,ANY,ANY,matrixLike_OR_NULL'
normData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'ligerDataset,ANY,ANY,H5D'
normData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'ligerDataset,missing'
scaleData(x, dataset = NULL)

## S4 replacement method for signature 'ligerDataset,ANY,ANY,matrixLike_OR_NULL'
scaleData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'ligerDataset,ANY,ANY,H5D'
scaleData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 replacement method for signature 'ligerDataset,ANY,ANY,H5Group'
scaleData(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'ligerDataset,missing'
scaleUnsharedData(x, dataset = NULL)

## S4 replacement method for signature 'ligerDataset,missing,ANY,matrixLike_OR_NULL'
scaleUnsharedData(x, check = TRUE) &lt;- value

## S4 replacement method for signature 'ligerDataset,missing,ANY,H5D'
scaleUnsharedData(x, check = TRUE) &lt;- value

## S4 replacement method for signature 'ligerDataset,missing,ANY,H5Group'
scaleUnsharedData(x, check = TRUE) &lt;- value

## S4 method for signature 'ligerDataset,ANY,missing,missing'
getMatrix(
  x,
  slot = c("rawData", "normData", "scaleData", "scaleUnsharedData", "H", "V", "U", "A",
    "B"),
  dataset = NULL
)

## S4 method for signature 'ligerDataset'
h5fileInfo(x, info = NULL)

## S4 replacement method for signature 'ligerDataset'
h5fileInfo(x, info = NULL, check = TRUE) &lt;- value

## S4 method for signature 'ligerDataset'
featureMeta(x, check = NULL)

## S4 replacement method for signature 'ligerDataset'
featureMeta(x, check = TRUE) &lt;- value

## S3 method for class 'ligerDataset'
cbind(x, ..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ligerDataset-class_+3A_x">x</code>, <code id="ligerDataset-class_+3A_object">object</code></td>
<td>
<p>A <code>ligerDataset</code> object.</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_dataset">dataset</code></td>
<td>
<p>Not applicable for <code>ligerDataset</code> methods.</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_check">check</code></td>
<td>
<p>Whether to perform object validity check on setting new value.</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_value">value</code></td>
<td>
<p>See detail sections for requirements</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_slot">slot</code></td>
<td>
<p>The slot name when using <code>getMatrix</code>.</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_returnlist">returnList</code></td>
<td>
<p>Not applicable for <code>ligerDataset</code> methods.</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_info">info</code></td>
<td>
<p>Name of the entry in <code>h5fileInfo</code> slot.</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_...">...</code></td>
<td>
<p>See detailed sections for explanation.</p>
</td></tr>
<tr><td><code id="ligerDataset-class_+3A_deparse.level">deparse.level</code></td>
<td>
<p>Not used here.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>rawData</code></dt><dd><p>Raw data.</p>
</dd>
<dt><code>normData</code></dt><dd><p>Normalized data</p>
</dd>
<dt><code>scaleData</code></dt><dd><p>Scaled data, usually with subset variable features</p>
</dd>
<dt><code>scaleUnsharedData</code></dt><dd><p>Scaled data of features not shared with other
datasets</p>
</dd>
<dt><code>varUnsharedFeatures</code></dt><dd><p>Variable features not shared with other datasets</p>
</dd>
<dt><code>V</code></dt><dd><p>matrix</p>
</dd>
<dt><code>A</code></dt><dd><p>matrix</p>
</dd>
<dt><code>B</code></dt><dd><p>matrix</p>
</dd>
<dt><code>H</code></dt><dd><p>matrix</p>
</dd>
<dt><code>U</code></dt><dd><p>matrix</p>
</dd>
<dt><code>h5fileInfo</code></dt><dd><p>list</p>
</dd>
<dt><code>featureMeta</code></dt><dd><p>Feature metadata, DataFrame</p>
</dd>
<dt><code>colnames</code></dt><dd><p>character</p>
</dd>
<dt><code>rownames</code></dt><dd><p>character</p>
</dd>
</dl>


<h3>Matrix access</h3>

<p>For <code>ligerDataset</code> object, <code>rawData()</code>, <code>normData</code>,
<code>scaleData()</code> and <code>scaleUnsharedData()</code> methods are exported for
users to access the corresponding feature expression matrix. Replacement
methods are also available to modify the slots.
</p>
<p>For other matrices, such as the <code class="reqn">H</code> and <code class="reqn">V</code>, which are dataset
specific, please use <code>getMatrix()</code> method with specifying slot name.
Directly accessing slot with <code>@</code> is generally not recommended.
</p>


<h3>H5 file and information access</h3>

<p>A <code>ligerDataset</code> object has a slot called <code>h5fileInfo</code>, which is a
list object. The first element is called <code>$H5File</code>, which is an
<code>H5File</code> class object and is the connection to the input file. The
second element is <code>$filename</code> which stores the absolute path of the H5
file in the current machine. The third element <code>$formatType</code> stores the
name of preset being used, if applicable. The other following keys pair with
paths in the H5 file that point to specific data for constructing a feature
expression matrix.
</p>
<p><code>h5fileInfo()</code> method access the list described above and simply
retrieves the corresponding value. When <code>info = NULL</code>, returns the whole
list. When <code>length(info) == 1</code>, returns the requested list value. When
more info requested, returns a subset list.
</p>
<p>The replacement method modifies the list elements and corresponding slot
value (if applicable) at the same time. For example, running
<code>h5fileInfo(obj, "rawData") &lt;- newPath</code> not only updates the list, but
also updates the <code>rawData</code> slot with the <code>H5D</code> class data at
&quot;newPath&quot; in the <code>H5File</code> object.
</p>
<p><code>getH5File()</code> is a wrapper and is equivalent to
<code>h5fileInfo(obj, "H5File")</code>.
</p>


<h3>Feature metadata access</h3>

<p>A slot <code>featureMeta</code> is included for each <code>ligerDataset</code> object.
This slot requires a <code><a href="S4Vectors.html#topic+DataFrame-class">DataFrame-class</a></code> object, which
is the same as <code>cellMeta</code> slot of a <a href="#topic+liger-class">liger</a> object. However,
the associated S4 methods only include access to the whole table for now.
Internal information access follows the same way as data.frame operation.
For example, <code>featureMeta(ligerD)$nCell</code> or
<code>featureMeta(ligerD)[varFeatures(ligerObj), "gene_var"]</code>.
</p>


<h3>Dimensionality</h3>

<p>For a <code>ligerDataset</code> object, the column orientation is assigned for
cells and rows are for features. Therefore, for <code>ligerDataset</code> objects,
<code>dim()</code> returns a numeric vector of two numbers which are number of
features and number of cells. <code>dimnames()</code> returns a list of two
character vectors, which are the feature names and the cell barcodes.
</p>
<p>For direct call of <code>dimnames&lt;-</code> method, <code>value</code> should be a list
with a character vector of feature names as the first element and cell
identifiers as the second element. For <code>colnames&lt;-</code> method, the
character vector of cell identifiers. For <code>rownames&lt;-</code> method, the
character vector of feature names.
</p>


<h3>Subsetting</h3>

<p>For more detail of subsetting a <code>liger</code> object or a
<a href="#topic+ligerDataset-class">ligerDataset</a> object, please check out <code><a href="#topic+subsetLiger">subsetLiger</a></code>
and <code><a href="#topic+subsetLigerDataset">subsetLigerDataset</a></code>. Here, we set the S3 method
&quot;single-bracket&quot; <code>[</code> as a quick wrapper to subset a <code>ligerDataset</code>
object. <code>i</code> and <code>j</code> serves as feature and cell subscriptor,
respectively, which can be any valid index refering the available features
and cells in a dataset. <code>...</code> arugments are passed to
<code>subsetLigerDataset</code> so that advanced options are allowed.
</p>


<h3>Concatenate ligerDataset</h3>

<p><code>cbind()</code> method is implemented for concatenating <code>ligerDataset</code>
objects by cells. When applying, all feature expression matrix will be merged
with taking a union of all features for the rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- dataset(pbmc, "ctrl")

# Methods for base generics
ctrl
print(ctrl)
dim(ctrl)
ncol(ctrl)
nrow(ctrl)
colnames(ctrl)[1:5]
rownames(ctrl)[1:5]
ctrl[1:5, 1:5]

# rliger generics
## raw data
m &lt;- rawData(ctrl)
class(m)
dim(m)
## normalized data
pbmc &lt;- normalize(pbmc)
ctrl &lt;- dataset(pbmc, "ctrl")
m &lt;- normData(ctrl)
class(m)
dim(m)
## scaled data
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
ctrl &lt;- dataset(pbmc, "ctrl")
m &lt;- scaleData(ctrl)
class(m)
dim(m)
n &lt;- scaleData(pbmc, "ctrl")
identical(m, n)
## Any other matrices
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- runOnlineINMF(pbmc, k = 20, minibatchSize = 100)
    ctrl &lt;- dataset(pbmc, "ctrl")
    V &lt;- getMatrix(ctrl, "V")
    V[1:5, 1:5]
    Vs &lt;- getMatrix(pbmc, "V")
    length(Vs)
    names(Vs)
    identical(Vs$ctrl, V)
}
</code></pre>

<hr>
<h2 id='ligerMethDataset-class'>Subclass of ligerDataset for Methylation modality</h2><span id='topic+ligerMethDataset-class'></span><span id='topic+ligerMethDataset'></span>

<h3>Description</h3>

<p>Inherits from <a href="#topic+ligerDataset-class">ligerDataset</a> class. Contained slots
can be referred with the link. <code><a href="#topic+scaleNotCenter">scaleNotCenter</a></code> applied on
datasets of this class will automatically be taken by reversing the
normalized data instead of scaling the variable features.
</p>

<hr>
<h2 id='ligerRNADataset-class'>Subclass of ligerDataset for RNA modality</h2><span id='topic+ligerRNADataset-class'></span><span id='topic+ligerRNADataset'></span>

<h3>Description</h3>

<p>Inherits from <a href="#topic+ligerDataset-class">ligerDataset</a> class. Contained slots
can be referred with the link. This subclass does not have any different from
the default <code>ligerDataset</code> class except the class name.
</p>

<hr>
<h2 id='ligerSpatialDataset-class'>Subclass of ligerDataset for Spatial modality</h2><span id='topic+ligerSpatialDataset-class'></span><span id='topic+ligerSpatialDataset'></span>

<h3>Description</h3>

<p>Inherits from <a href="#topic+ligerDataset-class">ligerDataset</a> class. Contained slots
can be referred with the link.
</p>


<h3>Slots</h3>


<dl>
<dt><code>coordinate</code></dt><dd><p>dense matrix</p>
</dd>
</dl>

<hr>
<h2 id='ligerToSeurat'>Convert between liger and Seurat object</h2><span id='topic+ligerToSeurat'></span>

<h3>Description</h3>

<p>For converting a <a href="#topic+liger-class">liger</a> object to a Seurat object, the
<code>rawData</code>, <code>normData</code>, and <code>scaleData</code> from each dataset,
the <code>cellMeta</code>, <code>H.norm</code> and <code>varFeatures</code> slot will be
included. Compatible with V4 and V5. It is not recommended to use this
conversion if your <a href="#topic+liger-class">liger</a> object contains datasets from
various modalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ligerToSeurat(
  object,
  assay = NULL,
  identByDataset = FALSE,
  merge = FALSE,
  nms = NULL,
  renormalize = NULL,
  use.liger.genes = NULL,
  by.dataset = identByDataset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ligerToSeurat_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object to be converted</p>
</td></tr>
<tr><td><code id="ligerToSeurat_+3A_assay">assay</code></td>
<td>
<p>Name of assay to store the data. Default <code>NULL</code> detects by
dataset modality. If the object contains various modality, default to
<code>"LIGER"</code>. Default dataset modality setting is understood as
<code>"RNA"</code>.</p>
</td></tr>
<tr><td><code id="ligerToSeurat_+3A_identbydataset">identByDataset</code></td>
<td>
<p>Logical, whether to combine dataset variable and
default cluster labeling to set the Idents. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ligerToSeurat_+3A_merge">merge</code></td>
<td>
<p>Logical, whether to merge layers of different datasets into one.
Not recommended. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ligerToSeurat_+3A_nms">nms</code></td>
<td>
<p>[Defunct] Will be ignored because new object structure does not
have related problem.</p>
</td></tr>
<tr><td><code id="ligerToSeurat_+3A_renormalize">renormalize</code></td>
<td>
<p>[Defunct] Will be ignored because since Seurat V5, layers
of data can exist at the same time and it is better to left it for users to
do it by themselves.</p>
</td></tr>
<tr><td><code id="ligerToSeurat_+3A_use.liger.genes">use.liger.genes</code></td>
<td>
<p>[Defunct] Will be ignored and will always set LIGER
variable features to the place.</p>
</td></tr>
<tr><td><code id="ligerToSeurat_+3A_by.dataset">by.dataset</code></td>
<td>
<p>[Deprecated]. Use <code>identByDataset</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Always returns Seurat object(s) of the latest version. By default a
Seurat object with split layers, e.g. with layers like &quot;counts.ctrl&quot; and
&quot;counts.stim&quot;. If <code>merge = TRUE</code>, return a single Seurat object with
layers for all datasets merged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seu &lt;- ligerToSeurat(pbmc)
</code></pre>

<hr>
<h2 id='linkGenesAndPeaks'>Linking genes to putative regulatory elements</h2><span id='topic+linkGenesAndPeaks'></span>

<h3>Description</h3>

<p>Evaluate the relationships between pairs of genes and peaks
based on specified distance metric. Usually used for inferring the
correlation between gene expression and imputed peak counts for datasets
without the modality originally (i.e. applied to <code><a href="#topic+imputeKNN">imputeKNN</a></code>
result).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkGenesAndPeaks(
  object,
  useDataset,
  pathToCoords,
  useGenes = NULL,
  method = c("spearman", "pearson", "kendall"),
  alpha = 0.05,
  verbose = getOption("ligerVerbose", TRUE),
  path_to_coords = pathToCoords,
  genes.list = useGenes,
  dist = method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkGenesAndPeaks_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with datasets that is of
<a href="#topic+ligerATACDataset-class">ligerATACDataset</a> class in the <code>datasets</code> slot.</p>
</td></tr>
<tr><td><code id="linkGenesAndPeaks_+3A_usedataset">useDataset</code></td>
<td>
<p>Name of one dataset, with both normalized gene expression
and normalized peak counts available.</p>
</td></tr>
<tr><td><code id="linkGenesAndPeaks_+3A_pathtocoords">pathToCoords</code></td>
<td>
<p>Path tothe gene coordinates file, usually a BED file.</p>
</td></tr>
<tr><td><code id="linkGenesAndPeaks_+3A_usegenes">useGenes</code></td>
<td>
<p>Character vector of gene names to be tested. Default
<code>NULL</code> uses all genes available in <code>useDataset</code>.</p>
</td></tr>
<tr><td><code id="linkGenesAndPeaks_+3A_method">method</code></td>
<td>
<p>Choose the type of correlation to calculate, from
<code>"spearman"</code>, <code>"pearson"</code> and <code>"kendall"</code>. Default
<code>"spearman"</code></p>
</td></tr>
<tr><td><code id="linkGenesAndPeaks_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, significance threshold for correlation p-value.
Peak-gene correlations with p-values below this threshold are considered
significant. Default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="linkGenesAndPeaks_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="linkGenesAndPeaks_+3A_path_to_coords">path_to_coords</code>, <code id="linkGenesAndPeaks_+3A_genes.list">genes.list</code>, <code id="linkGenesAndPeaks_+3A_dist">dist</code></td>
<td>
<p><b>Deprecated</b>. See Usage section
for replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sparse matrix with peak names as rows and gene names as columns,
with each element indicating the correlation between peak i and gene j, 0 if
the gene and peak are not significantly linked.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+imputeKNN">imputeKNN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bmmc &lt;- normalize(bmmc)
bmmc &lt;- selectGenes(bmmc)
bmmc &lt;- scaleNotCenter(bmmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    bmmc &lt;- runINMF(bmmc, miniBatchSize = 100)
    bmmc &lt;- quantileNorm(bmmc)
    bmmc &lt;- normalizePeak(bmmc)
    bmmc &lt;- imputeKNN(bmmc, reference = "atac", queries = "rna")
    corr &lt;- linkGenesAndPeaks(
        bmmc, useDataset = "rna",
        pathToCoords = system.file("extdata/hg19_genes.bed", package = "rliger")
    )
}

</code></pre>

<hr>
<h2 id='louvainCluster-deprecated'>[Deprecated] Louvain algorithm for community detection</h2><span id='topic+louvainCluster-deprecated'></span>

<h3>Description</h3>

<p>After quantile normalization, users can additionally run the Louvain
algorithm for community detection, which is widely used in single-cell
analysis and excels at merging small clusters into broad cell classes.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="louvainCluster-deprecated_+3A_object">object</code></td>
<td>
<p><code>liger</code> object. Should run quantile_norm before calling.</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_k">k</code></td>
<td>
<p>The maximum number of nearest neighbours to compute. (default 20)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_resolution">resolution</code></td>
<td>
<p>Value of the resolution parameter, use a value above
(below) 1.0 if you want to obtain a larger (smaller) number of communities.
(default 1.0)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_prune">prune</code></td>
<td>
<p>Sets the cutoff for acceptable Jaccard index when
computing the neighborhood overlap for the SNN construction. Any edges with
values less than or equal to this will be set to 0 and removed from the SNN
graph. Essentially sets the strigency of pruning (0 &mdash; no pruning, 1 &mdash;
prune everything). (default 1/15)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_eps">eps</code></td>
<td>
<p>The error bound of the nearest neighbor search. (default 0.1)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_nrandomstarts">nRandomStarts</code></td>
<td>
<p>Number of random starts. (default 10)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_niterations">nIterations</code></td>
<td>
<p>Maximal number of iterations per random start. (default
100)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_random.seed">random.seed</code></td>
<td>
<p>Seed of the random number generator. (default 1)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_verbose">verbose</code></td>
<td>
<p>Print messages (TRUE by default)</p>
</td></tr>
<tr><td><code id="louvainCluster-deprecated_+3A_dims.use">dims.use</code></td>
<td>
<p>Indices of factors to use for clustering. Default <code>NULL</code>
uses all available factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with refined cluster assignment updated in
<code>"louvain_cluster"</code> variable in <code>cellMeta</code> slot. Can be fetched
with <code>object$louvain_cluster</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rliger-deprecated">rliger-deprecated</a></code>
</p>

<hr>
<h2 id='makeFeatureMatrix'>Fast calculation of feature count matrix</h2><span id='topic+makeFeatureMatrix'></span>

<h3>Description</h3>

<p>Fast calculation of feature count matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFeatureMatrix(bedmat, barcodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFeatureMatrix_+3A_bedmat">bedmat</code></td>
<td>
<p>A feature count list generated by bedmap</p>
</td></tr>
<tr><td><code id="makeFeatureMatrix_+3A_barcodes">barcodes</code></td>
<td>
<p>A list of barcodes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature count matrix with features as rows and barcodes as
columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gene.counts &lt;- makeFeatureMatrix(genes.bc, barcodes)
promoter.counts &lt;- makeFeatureMatrix(promoters.bc, barcodes)
samnple &lt;- gene.counts + promoter.counts

## End(Not run)
</code></pre>

<hr>
<h2 id='makeInteractTrack'>Deprecated functions in package <span class="pkg">rliger</span>.</h2><span id='topic+makeInteractTrack'></span><span id='topic+louvainCluster'></span><span id='topic+rliger-deprecated'></span><span id='topic+optimizeALS'></span><span id='topic+online_iNMF'></span><span id='topic+quantile_norm'></span><span id='topic+makeRiverplot'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality or a replacement are also mentioned. Help pages for
deprecated functions are available at <code>help("&lt;function&gt;-deprecated")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeInteractTrack(
  corr.mat,
  path_to_coords,
  genes.list = NULL,
  output_path = getwd()
)

louvainCluster(
  object,
  resolution = 1,
  k = 20,
  prune = 1/15,
  eps = 0.1,
  nRandomStarts = 10,
  nIterations = 100,
  random.seed = 1,
  verbose = getOption("ligerVerbose", TRUE),
  dims.use = NULL
)

optimizeALS(
  object,
  k,
  lambda = 5,
  thresh = NULL,
  max.iters = 30,
  nrep = 1,
  H.init = NULL,
  W.init = NULL,
  V.init = NULL,
  use.unshared = FALSE,
  rand.seed = 1,
  print.obj = NULL,
  verbose = TRUE,
  ...
)

online_iNMF(
  object,
  X_new = NULL,
  projection = FALSE,
  W.init = NULL,
  V.init = NULL,
  H.init = NULL,
  A.init = NULL,
  B.init = NULL,
  k = 20,
  lambda = 5,
  max.epochs = 5,
  miniBatch_max_iters = 1,
  miniBatch_size = 5000,
  h5_chunk_size = 1000,
  seed = 123,
  verbose = TRUE
)

quantile_norm(
  object,
  quantiles = 50,
  ref_dataset = NULL,
  min_cells = 20,
  knn_k = 20,
  dims.use = NULL,
  do.center = FALSE,
  max_sample = 1000,
  eps = 0.9,
  refine.knn = TRUE,
  clusterName = "H.norm_cluster",
  rand.seed = 1,
  verbose = getOption("ligerVerbose", TRUE)
)

makeRiverplot(
  object,
  cluster1,
  cluster2,
  cluster_consensus = NULL,
  min.frac = 0.05,
  min.cells = 10,
  river.yscale = 1,
  river.lty = 0,
  river.node_margin = 0.1,
  label.cex = 1,
  label.col = "black",
  lab.srt = 0,
  river.usr = NULL,
  node.order = "auto"
)
</code></pre>


<h3><code>makeInteractTrack</code></h3>

<p>For <code>makeInteractTrack</code>, use <code><a href="#topic+exportInteractTrack">exportInteractTrack</a></code>.
</p>


<h3><code>louvainCluster</code></h3>

<p>For <code>louvainCluster</code>, use <code><a href="#topic+runCluster">runCluster</a>(method = "louvain")</code>
as the replacement, while <code><a href="#topic+runCluster">runCluster</a></code> with default
<code>method = "leiden"</code> is more recommended.
</p>


<h3><code>optimizeALS</code></h3>

<p>For <code>optimizeALS</code>, use <code><a href="#topic+runIntegration">runIntegration</a></code> or
<code><a href="#topic+runINMF">runINMF</a></code>. For the case of
<code>optimizeALS(use.unshared = TRUE)</code>, use <code><a href="#topic+runIntegration">runIntegration</a></code>
with <code>method = "UINMF"</code> or <code><a href="#topic+runUINMF">runUINMF</a></code> instead.
</p>


<h3><code>online_iNMF</code></h3>

<p>For <code>online_iNMF</code>, use <code><a href="#topic+runIntegration">runIntegration</a></code> with
<code>method = "online"</code> or <code><a href="#topic+runOnlineINMF">runOnlineINMF</a></code>.
</p>


<h3><code>quantile_norm</code></h3>

<p>For <code>quantile_norm</code>, use <code><a href="#topic+quantileNorm">quantileNorm</a></code>.
</p>


<h3><code>makeRiverplot</code></h3>

<p>For <code>makeRiverplot</code>, use <code><a href="#topic+plotSankey">plotSankey</a></code> as the replacement.
</p>

<hr>
<h2 id='makeInteractTrack-deprecated'>[Deprecated] Export predicted gene-pair interaction</h2><span id='topic+makeInteractTrack-deprecated'></span>

<h3>Description</h3>

<p>Export the predicted gene-pair interactions calculated by
upstream function <code><a href="#topic+linkGenesAndPeaks">linkGenesAndPeaks</a></code> into an Interact Track file
which is compatible with <a href="https://genome.ucsc.edu/cgi-bin/hgCustom">UCSC
Genome Browser</a>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeInteractTrack-deprecated_+3A_corr.mat">corr.mat</code></td>
<td>
<p>A sparse matrix of correlation with peak names as rows and
gene names as columns.</p>
</td></tr>
<tr><td><code id="makeInteractTrack-deprecated_+3A_path_to_coords">path_to_coords</code></td>
<td>
<p>Path to the gene coordinates file.</p>
</td></tr>
<tr><td><code id="makeInteractTrack-deprecated_+3A_genes.list">genes.list</code></td>
<td>
<p>Character vector of gene names to be exported. Default
<code>NULL</code> uses all genes available in <code>corrMat</code>.</p>
</td></tr>
<tr><td><code id="makeInteractTrack-deprecated_+3A_output_path">output_path</code></td>
<td>
<p>Path of filename where the output file will be stored. If
a folder, a file named <code>"Interact_Track.bed"</code> will be created. Default
current working directory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. A file located at <code>outputPath</code> will be created.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rliger-deprecated">rliger-deprecated</a></code>, <code><a href="#topic+exportInteractTrack">exportInteractTrack</a></code>
</p>

<hr>
<h2 id='makeRiverplot-deprecated'>[Deprecated] Generate a river (Sankey) plot</h2><span id='topic+makeRiverplot-deprecated'></span>

<h3>Description</h3>

<p>Creates a riverplot to show how separate cluster assignments from two
datasets map onto a joint clustering. The joint clustering is by default the
object clustering, but an external one can also be passed in. Uses the
riverplot package to construct riverplot object and then plot.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeRiverplot-deprecated_+3A_object">object</code></td>
<td>
<p><code>liger</code> object. Should run quantileAlignSNF before calling.</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_cluster1">cluster1</code></td>
<td>
<p>Cluster assignments for dataset 1. Note that cluster names
should be distinct across datasets.</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_cluster2">cluster2</code></td>
<td>
<p>Cluster assignments for dataset 2. Note that cluster names
should be distinct across datasets.</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_cluster_consensus">cluster_consensus</code></td>
<td>
<p>Optional external consensus clustering (to use
instead of object clusters)</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_min.frac">min.frac</code></td>
<td>
<p>Minimum fraction of cluster for edge to be shown (default
0.05).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_min.cells">min.cells</code></td>
<td>
<p>Minumum number of cells for edge to be shown (default 10).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_river.yscale">river.yscale</code></td>
<td>
<p>y-scale to pass to riverplot &ndash; scales the edge with
values by this factor, can be used to squeeze vertically (default 1).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_river.lty">river.lty</code></td>
<td>
<p>Line style to pass to riverplot (default 0).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_river.node_margin">river.node_margin</code></td>
<td>
<p>Node_margin to pass to riverplot &ndash; how much
vertical space to keep between the nodes (default 0.1).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_label.cex">label.cex</code></td>
<td>
<p>Size of text labels (default 1).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_label.col">label.col</code></td>
<td>
<p>Color of text labels (defualt &quot;black&quot;).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_lab.srt">lab.srt</code></td>
<td>
<p>Angle of text labels (default 0).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_river.usr">river.usr</code></td>
<td>
<p>Coordinates at which to draw the plot in form (x0, x1, y0,
y1).</p>
</td></tr>
<tr><td><code id="makeRiverplot-deprecated_+3A_node.order">node.order</code></td>
<td>
<p>Order of clusters in each set (list with three vectors of
ordinal numbers). By default will try to automatically order them
appropriately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with refined cluster assignment updated in
<code>"louvain_cluster"</code> variable in <code>cellMeta</code> slot. Can be fetched
with <code>object$louvain_cluster</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rliger-deprecated">rliger-deprecated</a></code>
</p>

<hr>
<h2 id='mapCellMeta'>Create new variable from categories in cellMeta</h2><span id='topic+mapCellMeta'></span>

<h3>Description</h3>

<p>Designed for fast variable creation when a new variable is going to be
created from existing variable. For example, multiple samples can be mapped
to the same study design condition, clusters can be mapped to cell types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapCellMeta(object, from, newTo = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapCellMeta_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object.</p>
</td></tr>
<tr><td><code id="mapCellMeta_+3A_from">from</code></td>
<td>
<p>The name of the original variable to be mapped from.</p>
</td></tr>
<tr><td><code id="mapCellMeta_+3A_newto">newTo</code></td>
<td>
<p>The name of the new variable to store the mapped result. Default
<code>NULL</code> returns the new variable (factor class).</p>
</td></tr>
<tr><td><code id="mapCellMeta_+3A_...">...</code></td>
<td>
<p>Mapping criteria, argument names are original existing categories
in the <code>from</code> and values are new categories in the new variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>newTo = NULL</code>, a factor object of the new variable.
Otherwise, the input object with variable <code>newTo</code> updated in
<code>cellMeta(object)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- mapCellMeta(pbmc, from = "dataset", newTo = "modal",
                    ctrl = "rna", stim = "rna")
</code></pre>

<hr>
<h2 id='mergeH5'>Merge hdf5 files</h2><span id='topic+mergeH5'></span>

<h3>Description</h3>

<p>This function merges hdf5 files generated from different
libraries (cell ranger by default) before they are preprocessed through Liger
pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeH5(
  file.list,
  library.names,
  new.filename,
  format.type = "10X",
  data.name = NULL,
  indices.name = NULL,
  indptr.name = NULL,
  genes.name = NULL,
  barcodes.name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeH5_+3A_file.list">file.list</code></td>
<td>
<p>List of path to hdf5 files.</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_library.names">library.names</code></td>
<td>
<p>Vector of library names (corresponding to file.list)</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_new.filename">new.filename</code></td>
<td>
<p>String of new hdf5 file name after merging (default
new.h5).</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_format.type">format.type</code></td>
<td>
<p>string of HDF5 format (10X CellRanger by default).</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_data.name">data.name</code></td>
<td>
<p>Path to the data values stored in HDF5 file.</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_indices.name">indices.name</code></td>
<td>
<p>Path to the indices of data points stored in HDF5 file.</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_indptr.name">indptr.name</code></td>
<td>
<p>Path to the pointers stored in HDF5 file.</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_genes.name">genes.name</code></td>
<td>
<p>Path to the gene names stored in HDF5 file.</p>
</td></tr>
<tr><td><code id="mergeH5_+3A_barcodes.name">barcodes.name</code></td>
<td>
<p>Path to the barcodes stored in HDF5 file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Directly generates newly merged hdf5 file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# For instance, we want to merge two datasets saved in HDF5 files (10X
# CellRanger) paths to datasets: "library1.h5","library2.h5"
# dataset names: "lib1", "lib2"
# name for output HDF5 file: "merged.h5"
mergeH5(list("library1.h5","library2.h5"), c("lib1","lib2"), "merged.h5")

## End(Not run)
</code></pre>

<hr>
<h2 id='mergeSparseAll'>Merge matrices while keeping the union of rows</h2><span id='topic+mergeSparseAll'></span><span id='topic+mergeDenseAll'></span>

<h3>Description</h3>

<p><code>mergeSparseAll</code> takes in a list of DGEs, with genes as
rows and cells as columns, and merges them into a single DGE. Also adds
<code>libraryNames</code> to colnames from each DGE if expected to be overlap
(common with 10X barcodes). Values in <code>rawData</code> or <code>normData</code>
slot of a <a href="#topic+ligerDataset-class">ligerDataset</a> object can be processed with this.
</p>
<p>For a list of dense matrices, usually the values in <code>scaleData</code> slot of
a <a href="#topic+ligerDataset-class">ligerDataset</a> object, please use <code>mergeDenseAll</code> which
works in the same way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeSparseAll(
  datalist,
  libraryNames = NULL,
  mode = c("union", "intersection")
)

mergeDenseAll(datalist, libraryNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeSparseAll_+3A_datalist">datalist</code></td>
<td>
<p>List of dgCMatrix for <code>mergeSparseAll</code> or a list of
matrix for <code>mergeDenseAll</code>.</p>
</td></tr>
<tr><td><code id="mergeSparseAll_+3A_librarynames">libraryNames</code></td>
<td>
<p>Character vector to be added as the prefix for the
barcodes in each matrix in <code>datalist</code>. Length should match with the
number of matrices. Default <code>NULL</code> do not modify the barcodes.</p>
</td></tr>
<tr><td><code id="mergeSparseAll_+3A_mode">mode</code></td>
<td>
<p>Whether to take the <code>"union"</code> or <code>"intersection"</code> of
features when merging. Default <code>"union"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dgCMatrix or matrix with all barcodes in <code>datalist</code> as columns
and the union of genes in <code>datalist</code> as rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rawDataList &lt;- getMatrix(pbmc, "rawData")
merged &lt;- mergeSparseAll(rawDataList, libraryNames = names(pbmc))
</code></pre>

<hr>
<h2 id='modalOf'>Return preset modality of a ligerDataset object or that of all datasets in a
liger object</h2><span id='topic+modalOf'></span>

<h3>Description</h3>

<p>Return preset modality of a ligerDataset object or that of all datasets in a
liger object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modalOf(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modalOf_+3A_object">object</code></td>
<td>
<p>a <a href="#topic+ligerDataset-class">ligerDataset</a> object or a <a href="#topic+liger-class">liger</a>
object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single character of modality setting value for
<a href="#topic+ligerDataset-class">ligerDataset</a> <code>object</code>, or a named vector for
<a href="#topic+liger-class">liger</a> object, where the names are dataset names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>modalOf(pbmc)
ctrl &lt;- dataset(pbmc, "ctrl")
modalOf(ctrl)
ctrl.atac &lt;- as.ligerDataset(ctrl, modal = "atac")
modalOf(ctrl.atac)
</code></pre>

<hr>
<h2 id='normalize'>Normalize raw counts data</h2><span id='topic+normalize'></span><span id='topic+normalize.dgCMatrix'></span><span id='topic+normalize.ligerDataset'></span><span id='topic+normalize.liger'></span><span id='topic+normalize.Seurat'></span><span id='topic+normalizePeak'></span>

<h3>Description</h3>

<p>Perform library size normalization on raw counts input. As for
the preprocessing step of iNMF integration, by default we don't multiply the
normalized values with a scale factor, nor do we take the log transformation.
Applicable S3 methods can be found in Usage section.
</p>
<p><code>normalizePeak</code> is designed for datasets of &quot;atac&quot; modality, i.e. stored
in <a href="#topic+ligerATACDataset-class">ligerATACDataset</a>. S3 method for various container object is
not supported yet due to difference in architecture design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(object, ...)

## S3 method for class 'dgCMatrix'
normalize(object, log = FALSE, scaleFactor = NULL, ...)

## S3 method for class 'ligerDataset'
normalize(object, chunk = 1000, verbose = getOption("ligerVerbose", TRUE), ...)

## S3 method for class 'liger'
normalize(
  object,
  useDatasets = NULL,
  verbose = getOption("ligerVerbose", TRUE),
  format.type = NULL,
  remove.missing = NULL,
  ...
)

## S3 method for class 'Seurat'
normalize(object, assay = NULL, layer = "counts", save = "ligerNormData", ...)

normalizePeak(
  object,
  useDatasets = NULL,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to S3 methods. The &quot;liger&quot; method calls
the &quot;ligerDataset&quot; method, which then calls &quot;dgCMatrix&quot; method.
<code>normalizePeak</code> directly calls <code>normalize.dgCMatrix</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_log">log</code></td>
<td>
<p>Logical. Whether to do a <code>log(x + 1)</code> transform on the
normalized data. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_scalefactor">scaleFactor</code></td>
<td>
<p>Numeric. Scale the normalized expression value by this
factor before transformation. <code>NULL</code> for not scaling. Default
<code>1e4</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_chunk">chunk</code></td>
<td>
<p>Integer. Number of maximum number of cells in each chunk when
working on HDF5 file based ligerDataset. Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="normalize_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="normalize_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to be normalized. Should specify ATACseq
datasets when using <code>normalizePeak</code>. Default <code>NULL</code> normalizes all
valid datasets.</p>
</td></tr>
<tr><td><code id="normalize_+3A_format.type">format.type</code>, <code id="normalize_+3A_remove.missing">remove.missing</code></td>
<td>
<p><b>Deprecated</b>. The functionality of
these is covered through other parts of the whole workflow and is no long
needed. Will be ignored if specified.</p>
</td></tr>
<tr><td><code id="normalize_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
<tr><td><code id="normalize_+3A_layer">layer</code></td>
<td>
<p>Where the input raw counts should be from. Default
<code>"counts"</code>. For older Seurat, always retrieve from <code>counts</code> slot.</p>
</td></tr>
<tr><td><code id="normalize_+3A_save">save</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to store normalized data.
Default <code>"ligerNormData"</code>. For older Seurat, stored to <code>data</code> slot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>object</code>.
</p>

<ul>
<li><p>dgCMatrix method - Returns processed dgCMatrix object
</p>
</li>
<li><p>ligerDataset method - Updates the <code>normData</code> slot of the object
</p>
</li>
<li><p>liger method - Updates the <code>normData</code> slot of chosen datasets
</p>
</li>
<li><p>Seurat method - Adds a named layer in chosen assay (V5), or update the
<code>data</code> slot of the chosen assay (&lt;=V4)
</p>
</li>
<li><p><code>normalizePeak</code> - Updates the <code>normPeak</code> slot of chosen
datasets.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
</code></pre>

<hr>
<h2 id='online_iNMF-deprecated'>[Deprecated] Perform online iNMF on scaled datasets</h2><span id='topic+online_iNMF-deprecated'></span>

<h3>Description</h3>

<p><b>Please turn to <code><a href="#topic+runOnlineINMF">runOnlineINMF</a></code> or
<code><a href="#topic+runIntegration">runIntegration</a></code></b>.
</p>
<p>Perform online integrative non-negative matrix factorization to represent
multiple single-cell datasets in terms of H, W, and V matrices. It optimizes
the iNMF objective function using online learning (non-negative least squares
for H matrix, hierarchical alternating least squares for W and V matrices),
where the number of factors is set by k. The function allows online learning
in 3 scenarios: (1) fully observed datasets; (2) iterative refinement using
continually arriving datasets; and (3) projection of new datasets without
updating the existing factorization. All three scenarios require fixed memory
independent of the number of cells.
</p>
<p>For each dataset, this factorization produces an H matrix (cells by k), a V
matrix (k by genes), and a shared W matrix (k by genes). The H matrices
represent the cell factor loadings. W is identical among all datasets, as it
represents the shared components of the metagenes across datasets. The V
matrices represent the dataset-specific components of the metagenes.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="online_iNMF-deprecated_+3A_object">object</code></td>
<td>
<p><code>liger</code> object with data stored in HDF5 files. Should
normalize, select genes, and scale before calling.</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_x_new">X_new</code></td>
<td>
<p>List of new datasets for scenario 2 or scenario 3. Each list
element should be the name of an HDF5 file.</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_projection">projection</code></td>
<td>
<p>Perform data integration by shared metagene (W) projection
(scenario 3). (default FALSE)</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_w.init">W.init</code></td>
<td>
<p>Optional initialization for W. (default NULL)</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_v.init">V.init</code></td>
<td>
<p>Optional initialization for V (default NULL)</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_h.init">H.init</code></td>
<td>
<p>Optional initialization for H (default NULL)</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_a.init">A.init</code></td>
<td>
<p>Optional initialization for A (default NULL)</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_b.init">B.init</code></td>
<td>
<p>Optional initialization for B (default NULL)</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_k">k</code></td>
<td>
<p>Inner dimension of factorization&ndash;number of metagenes (default 20).
A value in the range 20-50 works well for most analyses.</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more
strongly (ie. alignment should increase as lambda increases). We recommend
always using the default value except
possibly for analyses with relatively small differences (biological
replicates, male/female comparisons, etc.)
in which case a lower value such as 1.0 may improve reconstruction quality.
(default 5.0).</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_max.epochs">max.epochs</code></td>
<td>
<p>Maximum number of epochs (complete passes through the
data). (default 5)</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_minibatch_max_iters">miniBatch_max_iters</code></td>
<td>
<p>Maximum number of block coordinate descent (HALS
algorithm) iterations to perform for each update of W and V (default 1).
Changing this parameter is not  recommended.</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_minibatch_size">miniBatch_size</code></td>
<td>
<p>Total number of cells in each minibatch (default 5000).
This is a reasonable default, but a smaller value such as 1000 may be
necessary for analyzing very small datasets. In general, minibatch size
should be no larger than the number of cells in the smallest dataset.</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_h5_chunk_size">h5_chunk_size</code></td>
<td>
<p>Chunk size of input hdf5 files (default 1000). The chunk
size should be no larger than the batch size.</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results (default 123).</p>
</td></tr>
<tr><td><code id="online_iNMF-deprecated_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bar/messages (TRUE by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>liger</code> object with H, W, V, A and B slots set.
</p>

<hr>
<h2 id='optimizeALS-deprecated'>[Deprecated] Perform iNMF on scaled datasets</h2><span id='topic+optimizeALS-deprecated'></span>

<h3>Description</h3>

<p><b>Please turn to <code><a href="#topic+runINMF">runINMF</a></code> or <code><a href="#topic+runIntegration">runIntegration</a></code></b>.
</p>
<p>Perform integrative non-negative matrix factorization to return factorized H,
W, and V matrices. It optimizes the iNMF objective function using block
coordinate descent (alternating non-negative least squares), where the number
of factors is set by k. TODO: include objective function equation here in
documentation (using deqn)
</p>
<p>For each dataset, this factorization produces an H matrix (cells by k), a V
matrix (k by genes), and a shared W matrix (k by genes). The H matrices
represent the cell factor loadings. W is held consistent among all datasets,
as it represents the shared components of the metagenes across datasets. The
V matrices represent the dataset-specific components of the metagenes.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeALS-deprecated_+3A_object">object</code></td>
<td>
<p><code>liger</code> object. Should normalize, select genes, and scale
before calling.</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_k">k</code></td>
<td>
<p>Inner dimension of factorization (number of factors). Run suggestK
to determine appropriate value; a general rule of thumb is that a higher k
will be needed for datasets with more sub-structure.</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more strongly (ie. alignment should increase as
lambda increases). Run suggestLambda to determine most appropriate value for
balancing dataset alignment and agreement (default 5.0).</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold. Convergence occurs when
|obj0-obj|/(mean(obj0,obj)) &lt; thresh. (default 1e-6)</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_max.iters">max.iters</code></td>
<td>
<p>Maximum number of block coordinate descent iterations to
perform (default 30).</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_nrep">nrep</code></td>
<td>
<p>Number of restarts to perform (iNMF objective function is
non-convex, so taking the best objective from multiple successive
initializations is recommended). For easier reproducibility, this increments
the random seed by 1 for each consecutive restart, so future factorizations
of the same dataset can be run with one rep if necessary. (default 1)</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_h.init">H.init</code></td>
<td>
<p>Initial values to use for H matrices. (default NULL)</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_w.init">W.init</code></td>
<td>
<p>Initial values to use for W matrix (default NULL)</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_v.init">V.init</code></td>
<td>
<p>Initial values to use for V matrices (default NULL)</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_rand.seed">rand.seed</code></td>
<td>
<p>Random seed to allow reproducible results (default 1).</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_print.obj">print.obj</code></td>
<td>
<p>Print objective function values after convergence (default
FALSE).</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_verbose">verbose</code></td>
<td>
<p>Print progress bar/messages (TRUE by default)</p>
</td></tr>
<tr><td><code id="optimizeALS-deprecated_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>liger</code> object with H, W, and V slots set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rliger-deprecated">rliger-deprecated</a></code>
</p>

<hr>
<h2 id='optimizeNewData'>Perform factorization for new data</h2><span id='topic+optimizeNewData'></span>

<h3>Description</h3>

<p>Uses an efficient strategy for updating that takes advantage of
the information in the existing factorization. Assumes that variable features
are presented in the new datasets. Two modes are supported (controlled by
<code>merge</code>):
</p>

<ul>
<li><p>Append new data to existing datasets specified by <code>useDatasets</code>.
Here the existing <code class="reqn">V</code> matrices for the target datasets will directly be
used as initialization, and new <code class="reqn">H</code> matrices for the merged matrices will
be initialized accordingly.
</p>
</li>
<li><p>Set new data as new datasets. Initial <code class="reqn">V</code> matrices for them will
be copied from datasets specified by <code>useDatasets</code>, and new <code class="reqn">H</code>
matrices will be initialized accordingly.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>optimizeNewData(
  object,
  dataNew,
  useDatasets,
  merge = TRUE,
  lambda = NULL,
  nIteration = 30,
  seed = 1,
  verbose = getOption("ligerVerbose"),
  new.data = dataNew,
  which.datasets = useDatasets,
  add.to.existing = merge,
  max.iters = nIteration,
  thresh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeNewData_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object. Should have integrative
factorization performed e.g. (<code><a href="#topic+runINMF">runINMF</a></code>) in advance.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_datanew">dataNew</code></td>
<td>
<p>Named list of <b>raw count</b> matrices, genes by cells.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_usedatasets">useDatasets</code></td>
<td>
<p>Selection of datasets to append new data to if
<code>merge = TRUE</code>, or the datasets to inherit <code class="reqn">V</code> matrices from and
initialize the optimization when <code>merge = FALSE</code>. Should match the
length and order of <code>dataNew</code>.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_merge">merge</code></td>
<td>
<p>Logical, whether to add the new data to existing
datasets or treat as totally new datasets (i.e. calculate new <code class="reqn">V</code>
matrices). Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_lambda">lambda</code></td>
<td>
<p>Numeric regularization parameter. By default <code>NULL</code>, this
will use the lambda value used in the latest factorization.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_niteration">nIteration</code></td>
<td>
<p>Number of block coordinate descent iterations to perform.
Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>. Used
by <code><a href="#topic+runINMF">runINMF</a></code> factorization.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> which is <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_new.data">new.data</code>, <code id="optimizeNewData_+3A_which.datasets">which.datasets</code>, <code id="optimizeNewData_+3A_add.to.existing">add.to.existing</code>, <code id="optimizeNewData_+3A_max.iters">max.iters</code></td>
<td>
<p>These arguments are
now replaced by others and will be removed in the future. Please see usage
for replacement.</p>
</td></tr>
<tr><td><code id="optimizeNewData_+3A_thresh">thresh</code></td>
<td>
<p><b>Deprecated</b>. New implementation of iNMF does not require
a threshold for convergence detection. Setting a large enough
<code>nIteration</code> will bring it to convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with <code>W</code> slot updated with the new <code class="reqn">W</code>
matrix, and the <code>H</code> and <code>V</code> slots of each
<a href="#topic+ligerDataset-class">ligerDataset</a> object in the <code>datasets</code> slot updated with
the new dataset specific <code class="reqn">H</code> and <code class="reqn">V</code> matrix, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runINMF">runINMF</a></code>, <code><a href="#topic+optimizeNewK">optimizeNewK</a></code>,
<code><a href="#topic+optimizeNewLambda">optimizeNewLambda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
# Only running a few iterations for fast examples
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- runINMF(pbmc, k = 20, nIteration = 2)
    # Create fake new data by increasing all non-zero count in "ctrl" by 1,
    # and make unique cell identifiers
    ctrl2 &lt;- rawData(dataset(pbmc, "ctrl"))
    ctrl2@x &lt;- ctrl2@x + 1
    colnames(ctrl2) &lt;- paste0(colnames(ctrl2), 2)
    pbmcNew &lt;- optimizeNewData(pbmc, dataNew = list(ctrl2 = ctrl2),
                               useDatasets = "ctrl", nIteration = 2)
}
</code></pre>

<hr>
<h2 id='optimizeNewK'>Perform factorization for new value of k</h2><span id='topic+optimizeNewK'></span>

<h3>Description</h3>

<p>This uses an efficient strategy for updating that takes
advantage of the information in the existing factorization. It is most
recommended for values of <code>kNew</code> smaller than current value (<code>k</code>,
which is set when running <code><a href="#topic+runINMF">runINMF</a></code>), where it is more likely to
speed up the factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizeNewK(
  object,
  kNew,
  lambda = NULL,
  nIteration = 30,
  seed = 1,
  verbose = getOption("ligerVerbose"),
  k.new = kNew,
  max.iters = nIteration,
  rand.seed = seed,
  thresh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeNewK_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object. Should have integrative
factorization performed e.g. (<code><a href="#topic+runINMF">runINMF</a></code>) in advance.</p>
</td></tr>
<tr><td><code id="optimizeNewK_+3A_knew">kNew</code></td>
<td>
<p>Number of factors of factorization.</p>
</td></tr>
<tr><td><code id="optimizeNewK_+3A_lambda">lambda</code></td>
<td>
<p>Numeric regularization parameter. By default <code>NULL</code>, this
will use the lambda value used in the latest factorization.</p>
</td></tr>
<tr><td><code id="optimizeNewK_+3A_niteration">nIteration</code></td>
<td>
<p>Number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="optimizeNewK_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>. Used
by <code><a href="#topic+runINMF">runINMF</a></code> factorization and initialization only when if
<code>kNew</code> is greater than <code>k</code>.</p>
</td></tr>
<tr><td><code id="optimizeNewK_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> which is <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="optimizeNewK_+3A_k.new">k.new</code>, <code id="optimizeNewK_+3A_max.iters">max.iters</code>, <code id="optimizeNewK_+3A_rand.seed">rand.seed</code></td>
<td>
<p>These arguments are now replaced by others
and will be removed in the future. Please see usage for replacement.</p>
</td></tr>
<tr><td><code id="optimizeNewK_+3A_thresh">thresh</code></td>
<td>
<p><b>Deprecated</b>. New implementation of iNMF does not require
a threshold for convergence detection. Setting a large enough
<code>nIteration</code> will bring it to convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with <code>W</code> slot updated with the new <code class="reqn">W</code>
matrix, and the <code>H</code> and <code>V</code> slots of each
<a href="#topic+ligerDataset-class">ligerDataset</a> object in the <code>datasets</code> slot updated with
the new dataset specific <code class="reqn">H</code> and <code class="reqn">V</code> matrix, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runINMF">runINMF</a></code>, <code><a href="#topic+optimizeNewLambda">optimizeNewLambda</a></code>,
<code><a href="#topic+optimizeNewData">optimizeNewData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
# Only running a few iterations for fast examples
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- runINMF(pbmc, k = 20, nIteration = 2)
    pbmc &lt;- optimizeNewK(pbmc, kNew = 25, nIteration = 2)
}
</code></pre>

<hr>
<h2 id='optimizeNewLambda'>Perform factorization for new lambda value</h2><span id='topic+optimizeNewLambda'></span>

<h3>Description</h3>

<p>Uses an efficient strategy for updating that takes advantage of
the information in the existing factorization; always uses previous k.
Recommended mainly when re-optimizing for higher lambda and when new lambda
value is significantly different; otherwise may not return optimal results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizeNewLambda(
  object,
  lambdaNew,
  nIteration = 30,
  seed = 1,
  verbose = getOption("ligerVerbose"),
  new.lambda = lambdaNew,
  max.iters = nIteration,
  rand.seed = seed,
  thresh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeNewLambda_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object. Should have integrative
factorization (e.g. <code><a href="#topic+runINMF">runINMF</a></code>) performed in advance.</p>
</td></tr>
<tr><td><code id="optimizeNewLambda_+3A_lambdanew">lambdaNew</code></td>
<td>
<p>Numeric regularization parameter. Larger values penalize
dataset-specific effects more strongly.</p>
</td></tr>
<tr><td><code id="optimizeNewLambda_+3A_niteration">nIteration</code></td>
<td>
<p>Number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="optimizeNewLambda_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>. Used
by <code><a href="#topic+runINMF">runINMF</a></code> factorization.</p>
</td></tr>
<tr><td><code id="optimizeNewLambda_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> which is <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="optimizeNewLambda_+3A_new.lambda">new.lambda</code>, <code id="optimizeNewLambda_+3A_max.iters">max.iters</code>, <code id="optimizeNewLambda_+3A_rand.seed">rand.seed</code></td>
<td>
<p>These arguments are now replaced by
others and will be removed in the future. Please see usage for replacement.</p>
</td></tr>
<tr><td><code id="optimizeNewLambda_+3A_thresh">thresh</code></td>
<td>
<p><b>Deprecated</b>. New implementation of iNMF does not require
a threshold for convergence detection. Setting a large enough
<code>nIteration</code> will bring it to convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Input <code>object</code> with optimized factorization values updated.
including the <code>W</code> matrix in <a href="#topic+liger-class">liger</a> object, and <code>H</code> and
<code>V</code> matrices in each <a href="#topic+ligerDataset-class">ligerDataset</a> object in the
<code>datasets</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runINMF">runINMF</a></code>, <code><a href="#topic+optimizeNewK">optimizeNewK</a></code>,
<code><a href="#topic+optimizeNewData">optimizeNewData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    # Only running a few iterations for fast examples
    pbmc &lt;- runINMF(pbmc, k = 20, nIteration = 2)
    pbmc &lt;- optimizeNewLambda(pbmc, lambdaNew = 5.5, nIteration = 2)
}
</code></pre>

<hr>
<h2 id='optimizeSubset'>Perform factorization for subset of data</h2><span id='topic+optimizeSubset'></span>

<h3>Description</h3>

<p>Uses an efficient strategy for updating that takes advantage of
the information in the existing factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizeSubset(
  object,
  clusterVar = NULL,
  useClusters = NULL,
  lambda = NULL,
  nIteration = 30,
  cellIdx = NULL,
  scaleDatasets = NULL,
  seed = 1,
  verbose = getOption("ligerVerbose"),
  cell.subset = cellIdx,
  cluster.subset = useClusters,
  max.iters = nIteration,
  datasets.scale = scaleDatasets,
  thresh = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizeSubset_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object. Should have integrative
factorization (e.g. <code><a href="#topic+runINMF">runINMF</a></code>) performed in advance.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_clustervar">clusterVar</code>, <code id="optimizeSubset_+3A_useclusters">useClusters</code></td>
<td>
<p>Together select the clusters to subset the
object conveniently. <code>clusterVar</code> is the name of variable in
<code>cellMeta(object)</code> and <code>useClusters</code> should be vector of names of
clusters in the variable. <code>clusterVar</code> is by default the default
cluster (See <code><a href="#topic+runCluster">runCluster</a></code>, or <code><a href="#topic+defaultCluster">defaultCluster</a></code> at
&quot;Cell metadata access&quot;). Users can otherwise select cells explicitly with
<code>cellIdx</code> for complex conditions. <code>useClusters</code> overrides
<code>cellIdx</code>.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_lambda">lambda</code></td>
<td>
<p>Numeric regularization parameter. By default <code>NULL</code>, this
will use the lambda value used in the latest factorization.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_niteration">nIteration</code></td>
<td>
<p>Maximum number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_cellidx">cellIdx</code></td>
<td>
<p>Valid index vector that applies to the whole object. See
<code><a href="#topic+subsetLiger">subsetLiger</a></code> for requirement. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_scaledatasets">scaleDatasets</code></td>
<td>
<p>Names of datasets to re-scale after subsetting.
Default <code>NULL</code> does not re-scale.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>. Used
by <code><a href="#topic+runINMF">runINMF</a></code> factorization.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> which is <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_cell.subset">cell.subset</code>, <code id="optimizeSubset_+3A_cluster.subset">cluster.subset</code>, <code id="optimizeSubset_+3A_max.iters">max.iters</code>, <code id="optimizeSubset_+3A_datasets.scale">datasets.scale</code></td>
<td>
<p>These arguments
are now replaced by others and will be removed in the future. Please see
usage for replacement.</p>
</td></tr>
<tr><td><code id="optimizeSubset_+3A_thresh">thresh</code></td>
<td>
<p><b>Deprecated</b>. New implementation of iNMF does not require
a threshold for convergence detection. Setting a large enough
<code>nIteration</code> will bring it to convergence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subset <code>object</code> with factorization matrices optimized, including
the <code>W</code> matrix in <a href="#topic+liger-class">liger</a> object, and <code>W</code> and <code>V</code>
matrices in each <a href="#topic+ligerDataset-class">ligerDataset</a> object in the <code>datasets</code>
slot. <code>scaleData</code> in the <a href="#topic+ligerDataset-class">ligerDataset</a> objects of
datasets specified by <code>scaleDatasets</code> will also be updated to reflect
the subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    # Only running a few iterations for fast examples
    pbmc &lt;- runINMF(pbmc, k = 20, nIteration = 2)
    pbmc &lt;- optimizeSubset(pbmc, cellIdx = sort(sample(ncol(pbmc), 200)),
                           nIteration = 2)
}
</code></pre>

<hr>
<h2 id='pbmc'>liger object of PBMC subsample data with Control and Stimulated datasets</h2><span id='topic+pbmc'></span>

<h3>Description</h3>

<p>liger object of PBMC subsample data with Control and Stimulated datasets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmc
</code></pre>


<h3>Format</h3>

<p><a href="#topic+liger-class">liger</a> object with two datasets named by &quot;ctrl&quot; and
&quot;stim&quot;.
</p>


<h3>Source</h3>

<p>https://www.nature.com/articles/nbt.4042
</p>


<h3>References</h3>

<p>Hyun Min Kang and et. al., Nature Biotechnology, 2018
</p>

<hr>
<h2 id='pbmcPlot'>liger object of PBMC subsample data with plotting information available</h2><span id='topic+pbmcPlot'></span>

<h3>Description</h3>

<p>This data was generated from data <code>"pbmc"</code> with default
parameter integration pipeline: normalize, selectGenes, scaleNotCenter,
runINMF, runCluster, runUMAP. To minimize the object size distributed with
the package, rawData and scaleData were removed. Genes are downsampled to
the top 50 variable genes, for smaller normData and <code class="reqn">W</code> matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbmcPlot
</code></pre>


<h3>Format</h3>

<p><a href="#topic+liger-class">liger</a> object with two datasets named by &quot;ctrl&quot; and
&quot;stim&quot;.
</p>


<h3>Source</h3>

<p>https://www.nature.com/articles/nbt.4042
</p>


<h3>References</h3>

<p>Hyun Min Kang and et. al., Nature Biotechnology, 2018
</p>

<hr>
<h2 id='plotCellViolin'>Generate violin/box plot(s) using liger object</h2><span id='topic+plotCellViolin'></span>

<h3>Description</h3>

<p>This function allows for using available cell metadata, feature
expression or factor loading to generate violin plot, and grouping the data
with available categorical cell metadata. Available categorical cell metadata
can be used to form the color annotation. When it is different from the
grouping, it forms a nested grouping. Multiple y-axis variables are allowed
from the same specification of <code>slot</code>, and this returns a list of violin
plot for each. Users can further split the plot(s) by grouping on cells (e.g.
datasets).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCellViolin(
  object,
  y,
  groupBy = NULL,
  slot = c("cellMeta", "rawData", "normData", "scaleData", "H.norm", "H"),
  yFunc = NULL,
  cellIdx = NULL,
  colorBy = NULL,
  splitBy = NULL,
  titles = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCellViolin_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_y">y</code></td>
<td>
<p>Available variable name in <code>slot</code> to look for the value to
visualize.</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_groupby">groupBy</code>, <code id="plotCellViolin_+3A_colorby">colorBy</code></td>
<td>
<p>Available variable name in <code>cellMeta</code> slot to
look for categorical grouping. See details. Default <code>NULL</code> produces no
grouping and all-black graphic elements.</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_slot">slot</code></td>
<td>
<p>Choose the slot to find the <code>y</code> variable. See Details.
Default <code>"cellMeta"</code>.</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_yfunc">yFunc</code></td>
<td>
<p>A function object that expects a vector/factor/data.frame
retrieved by <code>y</code> as the only input, and returns an object of the same
size, so that the y-axis is replaced by this output. Useful when, for
example, users need to scale the gene expression shown on plot.</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_cellidx">cellIdx</code></td>
<td>
<p>Character, logical or numeric index that can subscribe cells.
Missing or <code>NULL</code> for all cells.</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_splitby">splitBy</code></td>
<td>
<p>Character vector of categorical variable names in
<code>cellMeta</code> slot. Split all cells by groupings on this/these variable(s)
to produce a violin plot containing only the cells in each group. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_titles">titles</code></td>
<td>
<p>Title text. A character scalar or a character vector with as
many elements as multiple plots are supposed to be generated. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotCellViolin_+3A_...">...</code></td>
<td>
<p>More plot setting arguments. See <code><a href="#topic+.ggCellViolin">.ggCellViolin</a></code> and
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available option for <code>slot</code> include: <code>"cellMeta"</code>,
<code>"rawData"</code>, <code>"normData"</code>, <code>"scaleData"</code>, <code>"H.norm"</code>
and <code>"H"</code>. When <code>"rawData"</code>, <code>"normData"</code> or
<code>"scaleData"</code>, <code>y</code> has to be a character vector of feature names.
When <code>"H.norm"</code> or <code>"H"</code>, <code>colorBy</code> can be any valid index to
select one factor of interests. Note that character index follows
<code>"Factor_[k]"</code> format, with replacing <code>[k]</code> with an integer.
</p>
<p>When <code>"cellMeta"</code>, <code>y</code> has to be an available column name in
the table. Note that, for <code>y</code> as well as <code>groupBy</code>, <code>colorBy</code>
and <code>splitBy</code> since a matrix object is feasible in <code>cellMeta</code>
table, using a column (e.g. named as <code>"column1"</code> in a certain matrix
(e.g. named as <code>"matrixVar"</code>) should follow the syntax of
<code>"matrixVar.column1"</code>. When the matrix does not have a &quot;colname&quot;
attribute, the subscription goes with <code>"matrixVar.V1"</code>,
<code>"matrixVar.V2"</code> and etc. These are based on the nature of
<code>as.data.frame</code> method on a <code><a href="S4Vectors.html#topic+DataFrame">DataFrame</a></code> object.
</p>
<p><code>groupBy</code> is basically send to <code>ggplot2::aes(x)</code>, while
<code>colorBy</code> is for the &quot;colour&quot; aesthetics. Specifying <code>colorBy</code>
without <code>groupBy</code> visually creates grouping but there will not be
varying values on the x-axis, so <code>boxWidth</code> will be forced to the same
value as <code>violinWidth</code> under this situation.
</p>


<h3>Value</h3>

<p>A ggplot object when a single plot is intended. A list of ggplot
objects, when multiple <code>y</code> variables and/or <code>splitBy</code> are set. When
<code>plotly = TRUE</code>, all ggplot objects become plotly (htmlwidget) objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotCellViolin(pbmcPlot, y = "nUMI", groupBy = "dataset", slot = "cellMeta")
plotCellViolin(pbmcPlot, y = "nUMI", groupBy = "leiden_cluster",
               slot = "cellMeta", splitBy = "dataset",
               colorBy = "leiden_cluster",
               box = TRUE, dot = TRUE,
               ylab = "Total counts per cell",
               colorValues = RColorBrewer::brewer.pal(8, "Set1"))
plotCellViolin(pbmcPlot, y = "S100A8", slot = "normData",
               yFunc = function(x) log2(10000*x + 1),
               groupBy = "dataset", colorBy = "leiden_cluster",
               box = TRUE, ylab = "S100A8 Expression")
</code></pre>

<hr>
<h2 id='plotClusterFactorDot'>Make dot plot of factor loading in cell groups</h2><span id='topic+plotClusterFactorDot'></span>

<h3>Description</h3>

<p>This function produces dot plots. Each column represent a group
of cells specified by <code>groupBy</code>, each row is a factor specified by
<code>useDims</code>. The color of dots reflects mean of factor loading of
specified factors in each cell group and sizes reflects the percentage of
cells that have loadings of a factor in a group. We utilize
<a href="https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html">ComplexHeatmap</a>
for simplified management of adding annotation and slicing subplots. This was
inspired by the implementation in
<a href="https://samuel-marsh.github.io/scCustomize/reference/Clustered_DotPlot.html">scCustomize</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterFactorDot(
  object,
  groupBy = NULL,
  useDims = NULL,
  useRaw = FALSE,
  splitBy = NULL,
  factorScaleFunc = NULL,
  cellIdx = NULL,
  legendColorTitle = "Mean Factor\nLoading",
  legendSizeTitle = "Percent\nLoaded",
  viridisOption = "viridis",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterFactorDot_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_groupby">groupBy</code></td>
<td>
<p>The names of the columns in <code>cellMeta</code> slot storing
categorical variables. Loading data would be aggregated basing on these,
together with <code>splitBy</code>. Default uses default clusters.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_usedims">useDims</code></td>
<td>
<p>A Numeric vector to specify exact factors of interests.
Default <code>NULL</code> uses all available factors.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_useraw">useRaw</code></td>
<td>
<p>Whether to use un-aligned cell factor loadings (<code class="reqn">H</code>
matrices). Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_splitby">splitBy</code></td>
<td>
<p>The names of the columns in <code>cellMeta</code> slot storing
categorical variables. Dotplot panel splitting would be based on these.
Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_factorscalefunc">factorScaleFunc</code></td>
<td>
<p>A function object applied to factor loading matrix for
scaling the value for better visualization. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_cellidx">cellIdx</code></td>
<td>
<p>Valid cell subscription. See <code><a href="#topic+subsetLiger">subsetLiger</a></code>.
Default <code>NULL</code> for using all cells.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_legendcolortitle">legendColorTitle</code></td>
<td>
<p>Title for colorbar legend. Default
<code>"Mean Factor\nLoading"</code>.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_legendsizetitle">legendSizeTitle</code></td>
<td>
<p>Title for size legend. Default
<code>"Percent\nLoaded"</code></p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_viridisoption">viridisOption</code></td>
<td>
<p>Name of available viridis palette. See
<code><a href="viridis.html#topic+viridis">viridis</a></code>. Default <code>"viridis"</code>.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show progress information. Mainly when
subsetting data. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotClusterFactorDot_+3A_...">...</code></td>
<td>
<p>Additional theme setting arguments passed to
<code><a href="#topic+.complexHeatmapDotPlot">.complexHeatmapDotPlot</a></code> and heatmap setting arguments passed to
<code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>...</code>, please notice that arguments <code>colorMat</code>,
<code>sizeMat</code>, <code>featureAnnDF</code>, <code>cellSplitVar</code>, <code>cellLabels</code>
and <code>viridisOption</code> from <code><a href="#topic+.complexHeatmapDotPlot">.complexHeatmapDotPlot</a></code> are
already occupied by this function internally. A lot of arguments from
<code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code> have also been occupied: <code>matrix,
name, heatmap_legend_param, rect_gp, col, layer_fun, km, border, border_gp,
column_gap, row_gap, cluster_row_slices, cluster_rows, row_title_gp,
row_names_gp, row_split, row_labels, cluster_column_slices, cluster_columns,
column_split, column_title_gp, column_title, column_labels, column_names_gp,
top_annotation</code>.
</p>


<h3>Value</h3>

<p><code><a href="ComplexHeatmap.html#topic+HeatmapList">HeatmapList</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotClusterFactorDot(pbmcPlot)
</code></pre>

<hr>
<h2 id='plotClusterGeneDot'>Make dot plot of gene expression in cell groups</h2><span id='topic+plotClusterGeneDot'></span>

<h3>Description</h3>

<p>This function produces dot plots. Each column represent a group
of cells specified by <code>groupBy</code>, each row is a gene specified by
<code>features</code>. The color of dots reflects mean of normalized expression of
specified genes in each cell group and sizes reflects the percentage of cells
expressing each gene in a group. We utilize
<a href="https://jokergoo.github.io/ComplexHeatmap-reference/book/index.html">ComplexHeatmap</a>
for simplified management of adding annotation and slicing subplots. This was
inspired by the implementation in
<a href="https://samuel-marsh.github.io/scCustomize/reference/Clustered_DotPlot.html">scCustomize</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotClusterGeneDot(
  object,
  features,
  groupBy = NULL,
  splitBy = NULL,
  featureScaleFunc = function(x) log2(10000 * x + 1),
  cellIdx = NULL,
  legendColorTitle = "Mean\nExpression",
  legendSizeTitle = "Percent\nExpressed",
  viridisOption = "magma",
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotClusterGeneDot_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_features">features</code></td>
<td>
<p>Use a character vector of gene names to make plain dot plot
like a heatmap. Use a data.frame where the first column is gene names and
second column is a grouping variable (e.g. subset <code>runMarkerDEG</code> output)</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_groupby">groupBy</code></td>
<td>
<p>The names of the columns in <code>cellMeta</code> slot storing
categorical variables. Expression data would be aggregated basing on these,
together with <code>splitBy</code>. Default uses default clusters.</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_splitby">splitBy</code></td>
<td>
<p>The names of the columns in <code>cellMeta</code> slot storing
categorical variables. Dotplot panel splitting would be based on these.
Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_featurescalefunc">featureScaleFunc</code></td>
<td>
<p>A function object applied to normalized data for
scaling the value for better visualization. Default <code>function(x)
log2(10000*x + 1)</code></p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_cellidx">cellIdx</code></td>
<td>
<p>Valid cell subscription. See <code><a href="#topic+subsetLiger">subsetLiger</a></code>.
Default <code>NULL</code> for using all cells.</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_legendcolortitle">legendColorTitle</code></td>
<td>
<p>Title for colorbar legend. Default
<code>"Mean\nExpression"</code>.</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_legendsizetitle">legendSizeTitle</code></td>
<td>
<p>Title for size legend. Default
<code>"Percent\nExpressed"</code></p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_viridisoption">viridisOption</code></td>
<td>
<p>Name of available viridis palette. See
<code><a href="viridis.html#topic+viridis">viridis</a></code>. Default <code>"magma"</code>.</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show progress information. Mainly when
subsetting data. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotClusterGeneDot_+3A_...">...</code></td>
<td>
<p>Additional theme setting arguments passed to
<code><a href="#topic+.complexHeatmapDotPlot">.complexHeatmapDotPlot</a></code> and heatmap setting arguments passed to
<code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>...</code>, please notice that arguments <code>colorMat</code>,
<code>sizeMat</code>, <code>featureAnnDF</code>, <code>cellSplitVar</code>, <code>cellLabels</code>
and <code>viridisOption</code> from <code><a href="#topic+.complexHeatmapDotPlot">.complexHeatmapDotPlot</a></code> are
already occupied by this function internally. A lot of arguments from
<code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code> have also been occupied: <code>matrix,
name, heatmap_legend_param, rect_gp, col, layer_fun, km, border, border_gp,
column_gap, row_gap, cluster_row_slices, cluster_rows, row_title_gp,
row_names_gp, row_split, row_labels, cluster_column_slices, cluster_columns,
column_split, column_title_gp, column_title, column_labels, column_names_gp,
top_annotation</code>.
</p>


<h3>Value</h3>

<p><code><a href="ComplexHeatmap.html#topic+HeatmapList">HeatmapList</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use character vector of genes
features &lt;- varFeatures(pbmcPlot)[1:10]
plotClusterGeneDot(pbmcPlot, features = features)

# Use data.frame with grouping information, with more tweak on plot
features &lt;- data.frame(features, rep(letters[1:5], 2))
plotClusterGeneDot(pbmcPlot, features = features,
                   clusterFeature = TRUE, clusterCell = TRUE, maxDotSize = 6)
</code></pre>

<hr>
<h2 id='plotDensityDimRed'>Create density plot basing on specified coordinates</h2><span id='topic+plotDensityDimRed'></span>

<h3>Description</h3>

<p>This function shows the cell density presented in a 2D
dimensionality reduction coordinates. Density is shown with coloring and
contour lines. A scatter plot of the dimensionality reduction is added as
well. The density plot can be splitted by categorical variables (e.g.
<code>"dataset"</code>), while the scatter plot will always be shown for all cells
in subplots as a reference of the global structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDensityDimRed(
  object,
  useDimRed = NULL,
  splitBy = NULL,
  combinePlot = TRUE,
  minDensity = 8,
  contour = TRUE,
  contourLineWidth = 0.3,
  contourBins = 5,
  dot = TRUE,
  dotColor = "grey",
  dotSize = 0.6,
  dotAlpha = 0.3,
  dotRaster = NULL,
  title = NULL,
  legendFillTitle = "Density",
  colorPalette = "magma",
  colorDirection = -1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDensityDimRed_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_usedimred">useDimRed</code></td>
<td>
<p>Name of the variable storing dimensionality reduction result
in the <code>cellMeta</code> slot. Default uses default dimension reduction.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_splitby">splitBy</code></td>
<td>
<p>Character vector of categorical variable names in
<code>cellMeta</code> slot. Split all cells by groupings on this/these variable(s)
to produce a density plot containing only the cells in each group. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_combineplot">combinePlot</code></td>
<td>
<p>Logical, whether to utilize
<code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code> to combine multiple plots into one. Default
<code>TRUE</code> returns combined ggplot. <code>FALSE</code> returns a list of ggplot
or a single ggplot when only one plot is requested.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_mindensity">minDensity</code></td>
<td>
<p>A positive number to filter out low density region colored
on plot. Default <code>8</code>. Setting zero will show density on the whole panel.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_contour">contour</code></td>
<td>
<p>Logical, whether to draw the contour line. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_contourlinewidth">contourLineWidth</code></td>
<td>
<p>Numeric, the width of the contour line. Default
<code>0.3</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_contourbins">contourBins</code></td>
<td>
<p>Number of contour bins. Higher value generates more
contour lines. Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_dot">dot</code></td>
<td>
<p>Logical, whether to add scatter plot of all cells, even when
density plot is splitted with <code>splitBy</code>. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_dotcolor">dotColor</code>, <code id="plotDensityDimRed_+3A_dotsize">dotSize</code>, <code id="plotDensityDimRed_+3A_dotalpha">dotAlpha</code></td>
<td>
<p>Numeric, controls the appearance of all
dots. Default <code>"grey"</code>, <code>0.6</code> and <code>0.3</code>, respectively.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_dotraster">dotRaster</code></td>
<td>
<p>Logical, whether to rasterize the scatter plot. Default
<code>NULL</code> automatically rasterizes the dots when number of total cells to
be plotted exceeds 100,000.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_title">title</code></td>
<td>
<p>Text of main title of the plots. Default <code>NULL</code>. Length
of character vector input should match with number of plots generated.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_legendfilltitle">legendFillTitle</code></td>
<td>
<p>Text of legend title. Default <code>"Density"</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_colorpalette">colorPalette</code></td>
<td>
<p>Name of the option for
<code><a href="ggplot2.html#topic+scale_fill_viridis_c">scale_fill_viridis_c</a></code>. Default <code>"magma"</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_colordirection">colorDirection</code></td>
<td>
<p>Color gradient direction for
<code><a href="ggplot2.html#topic+scale_fill_viridis_c">scale_fill_viridis_c</a></code>. Default <code>-1</code>.</p>
</td></tr>
<tr><td><code id="plotDensityDimRed_+3A_...">...</code></td>
<td>
<p>More theme setting arguments passed to
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object when only one plot is generated, A ggplot object
combined with <code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code> when multiple plots and
<code>combinePlot = TRUE</code>. A list of ggplot when multiple plots and
<code>combinePlot = FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example dataset has small number of cells, thus cutoff adjusted.
plotDensityDimRed(pbmcPlot, minDensity = 1)
</code></pre>

<hr>
<h2 id='plotDimRed'>Generate scatter plot(s) using liger object</h2><span id='topic+plotDimRed'></span><span id='topic+plotClusterDimRed'></span><span id='topic+plotDatasetDimRed'></span><span id='topic+plotByDatasetAndCluster'></span><span id='topic+plotGeneDimRed'></span><span id='topic+plotPeakDimRed'></span><span id='topic+plotFactorDimRed'></span>

<h3>Description</h3>

<p>This function allows for using available cell metadata to build
the x-/y-axis. Available per-cell data can be used to form the color/shape
annotation, including cell metadata, raw or processed gene expression, and
unnormalized or aligned factor loading. Multiple coloring variable is allowed
from the same specification of <code>slot</code>, and this returns a list of plots
with different coloring values. Users can further split the plot(s) by
grouping on cells (e.g. datasets).
</p>
<p>some text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDimRed(
  object,
  colorBy = NULL,
  useDimRed = NULL,
  slot = c("cellMeta", "rawData", "normData", "scaleData", "H.norm", "H", "normPeak",
    "rawPeak"),
  colorByFunc = NULL,
  cellIdx = NULL,
  splitBy = NULL,
  shapeBy = NULL,
  titles = NULL,
  ...
)

plotClusterDimRed(object, useCluster = NULL, useDimRed = NULL, ...)

plotDatasetDimRed(object, useDimRed = NULL, ...)

plotByDatasetAndCluster(
  object,
  useDimRed = NULL,
  useCluster = NULL,
  combinePlots = TRUE,
  ...
)

plotGeneDimRed(
  object,
  features,
  useDimRed = NULL,
  log = TRUE,
  scaleFactor = 10000,
  zeroAsNA = TRUE,
  colorPalette = "C",
  ...
)

plotPeakDimRed(
  object,
  features,
  useDimRed = NULL,
  log = TRUE,
  scaleFactor = 10000,
  zeroAsNA = TRUE,
  colorPalette = "C",
  ...
)

plotFactorDimRed(
  object,
  factors,
  useDimRed = NULL,
  trimHigh = 0.03,
  zeroAsNA = TRUE,
  colorPalette = "D",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDimRed_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_colorby">colorBy</code></td>
<td>
<p>Available variable name in specified <code>slot</code> to look for
color annotation information. See details. Default <code>NULL</code> generates
all-black dots.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_usedimred">useDimRed</code></td>
<td>
<p>Name of the variable storing dimensionality reduction result
in the <code>cellMeta(object)</code>. Default <code>NULL</code> use default dimRed.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_slot">slot</code></td>
<td>
<p>Choose the slot to find the <code>colorBy</code> variable. See details.
Default <code>"cellMeta"</code>.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_colorbyfunc">colorByFunc</code></td>
<td>
<p>Default <code>NULL</code>. A function object that expects a
vector/factor/data.frame retrieved by <code>colorBy</code> as the only input, and
returns an object of the same size, so that the all color &quot;aes&quot; are replaced
by this output. Useful when, for example, users need to scale the gene
expression shown on plot.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_cellidx">cellIdx</code></td>
<td>
<p>Character, logical or numeric index that can subscribe cells.
Missing or <code>NULL</code> for all cells.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_splitby">splitBy</code></td>
<td>
<p>Character vector of categorical variable names in
<code>cellMeta</code> slot. Split all cells by groupings on this/these variable(s)
to produce a scatter plot containing only the cells in each group. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_shapeby">shapeBy</code></td>
<td>
<p>Available variable name in <code>cellMeta</code> slot to look for
categorical annotation to be reflected by dot shapes. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_titles">titles</code></td>
<td>
<p>Title text. A character scalar or a character vector with as
many elements as multiple plots are supposed to be generated. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_...">...</code></td>
<td>
<p>More plot setting arguments. See <code><a href="#topic+.ggScatter">.ggScatter</a></code> and
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_usecluster">useCluster</code></td>
<td>
<p>Name of variable in <code>cellMeta(object)</code>. Default
<code>NULL</code> uses default cluster.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_combineplots">combinePlots</code></td>
<td>
<p>Logical, whether to utilize
<code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code> to combine multiple plots into one. Default
<code>TRUE</code> returns combined ggplot. <code>FALSE</code> returns a list of ggplot.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_features">features</code>, <code id="plotDimRed_+3A_factors">factors</code></td>
<td>
<p>Name of genes or index of factors that need to be
visualized.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_log">log</code></td>
<td>
<p>Logical. Whether to log transform the normalized expression of
genes. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_scalefactor">scaleFactor</code></td>
<td>
<p>Number to be multiplied with the normalized expression of
genes before log transformation. Default <code>1e4</code>. <code>NULL</code> for not
scaling.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_zeroasna">zeroAsNA</code></td>
<td>
<p>Logical, whether to swap all zero values to <code>NA</code> so
<code>naColor</code> will be used to represent non-expressing features. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_colorpalette">colorPalette</code></td>
<td>
<p>Name of viridis palette. See
<code><a href="viridisLite.html#topic+viridis">viridis</a></code> for options. Default <code>"C"</code> (&quot;plasma&quot;)
for gene expression and <code>"D"</code> (&quot;viridis&quot;) for factor loading.</p>
</td></tr>
<tr><td><code id="plotDimRed_+3A_trimhigh">trimHigh</code></td>
<td>
<p>Number for highest cut-off to limit the outliers. Factor
loading above this value will all be trimmed to this value. Default
<code>0.03</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available option for <code>slot</code> include: <code>"cellMeta"</code>,
<code>"rawData"</code>, <code>"normData"</code>, <code>"scaleData"</code>, <code>"H.norm"</code>
and <code>"H"</code>. When <code>"rawData"</code>, <code>"normData"</code> or
<code>"scaleData"</code>, <code>colorBy</code> has to be a character vector of feature
names. When <code>"H.norm"</code> or <code>"H"</code>, <code>colorBy</code> can be any valid
index to select one factor of interests. Note that character index follows
<code>"Factor_[k]"</code> format, with replacing <code>[k]</code> with an integer.
</p>
<p>When <code>"cellMeta"</code>, <code>colorBy</code> has to be an available column name in
the table. Note that, for <code>colorBy</code> as well as <code>x</code>, <code>y</code>,
<code>shapeBy</code> and <code>splitBy</code>, since a matrix object is feasible in
<code>cellMeta</code> table, using a column (e.g. named as <code>"column1"</code> in a
certain matrix (e.g. named as <code>"matrixVar"</code>) should follow the syntax of
<code>"matrixVar.column1"</code>. When the matrix does not have a &quot;colname&quot;
attribute, the subscription goes with <code>"matrixVar.V1"</code>,
<code>"matrixVar.V2"</code> and etc. Use <code>"UMAP.1"</code>, <code>"UMAP.2"</code>,
<code>"TSNE.1"</code> or <code>"TSNE.2"</code> for the 2D embeddings generated with
rliger package. These are based on the nature of <code>as.data.frame</code> method
on a <code><a href="S4Vectors.html#topic+DataFrame">DataFrame</a></code> object.
</p>


<h3>Value</h3>

<p>A ggplot object when a single plot is intended. A list of ggplot
objects, when multiple <code>colorBy</code> variables and/or <code>splitBy</code> are
set. When <code>plotly = TRUE</code>, all ggplot objects become plotly (htmlwidget)
objects.
</p>
<p>ggplot object when only one feature (e.g. cluster variable, gene,
factor) is set. List object when multiple of those are specified.
</p>


<h3>See Also</h3>

<p>Please refer to <code><a href="#topic+plotDimRed">plotDimRed</a></code>,
<code><a href="#topic+.ggScatter">.ggScatter</a></code>, <code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code> for additional
graphic setting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotDimRed(pbmcPlot, colorBy = "dataset", slot = "cellMeta",
           labelText = FALSE)
plotDimRed(pbmcPlot, colorBy = "S100A8", slot = "normData",
           dotOrder = "ascending", dotSize = 2)
plotDimRed(pbmcPlot, colorBy = 2, slot = "H.norm",
           dotOrder = "ascending", dotSize = 2, colorPalette = "viridis")
plotClusterDimRed(pbmcPlot)
plotDatasetDimRed(pbmcPlot)
plotByDatasetAndCluster(pbmcPlot)
plotGeneDimRed(pbmcPlot, varFeatures(pbmcPlot)[1])
plotFactorDimRed(pbmcPlot, 2)
</code></pre>

<hr>
<h2 id='plotGeneHeatmap'>Plot Heatmap of Gene Expression or Factor Loading</h2><span id='topic+plotGeneHeatmap'></span><span id='topic+plotFactorHeatmap'></span>

<h3>Description</h3>

<p>Plot Heatmap of Gene Expression or Factor Loading
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGeneHeatmap(
  object,
  features,
  cellIdx = NULL,
  slot = c("normData", "rawData", "scaleData", "scaleUnsharedData"),
  useCellMeta = NULL,
  cellAnnotation = NULL,
  featureAnnotation = NULL,
  cellSplitBy = NULL,
  featureSplitBy = NULL,
  viridisOption = "C",
  ...
)

plotFactorHeatmap(
  object,
  factors = NULL,
  cellIdx = NULL,
  slot = c("H.norm", "H"),
  useCellMeta = NULL,
  cellAnnotation = NULL,
  factorAnnotation = NULL,
  cellSplitBy = NULL,
  factorSplitBy = NULL,
  trim = c(0, 0.03),
  viridisOption = "D",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGeneHeatmap_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with data to be plot available.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_features">features</code>, <code id="plotGeneHeatmap_+3A_factors">factors</code></td>
<td>
<p>Character vector of genes of interests or numeric
index of factor to be involved. <code>features</code> is required, while
<code>factors</code> is by default all the factors (reads object recorded k value
in <code>uns</code> slot).</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_cellidx">cellIdx</code></td>
<td>
<p>Valid index to subscribe cells to be included. See
<code><a href="#topic+subsetLiger">subsetLiger</a></code>. Default <code>NULL</code> use all cells.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_slot">slot</code></td>
<td>
<p>Use the chosen matrix for heatmap. For <code>plotGeneHeatmap</code>,
default <code>"normData"</code>, alternatively <code>"rawData"</code>,
<code>"scaleData"</code> or <code>"scaleUnsharedData"</code>. For
<code>plotFactorHeatmap</code>, default <code>"H.norm"</code>, alternatively <code>"H"</code>.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_usecellmeta">useCellMeta</code></td>
<td>
<p>Character vector of available variable names in
<code>cellMeta</code>, variables will be added as annotation to the heatmap.
Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_cellannotation">cellAnnotation</code></td>
<td>
<p>data.frame object for using external annotation, with
each column a variable and each row is a cell. Row names of this data.frame
will be used for matching cells involved in heatmap. For cells not found in
this data.frame, <code>NA</code>s will be added with warning. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_featureannotation">featureAnnotation</code>, <code id="plotGeneHeatmap_+3A_factorannotation">factorAnnotation</code></td>
<td>
<p>Similar as <code>cellAnnotation</code>,
while each row would be a gene or factor, respectively. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_cellsplitby">cellSplitBy</code></td>
<td>
<p>Character vector of variable names available in annotation
given by <code>useCellMeta</code> and <code>cellAnnotation</code>. This slices the
heatmap by specified variables. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_featuresplitby">featureSplitBy</code>, <code id="plotGeneHeatmap_+3A_factorsplitby">factorSplitBy</code></td>
<td>
<p>Similar as <code>cellSplitBy</code>. Default
<code>NULL</code></p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_viridisoption">viridisOption</code></td>
<td>
<p>See <code>option</code> argument of
<code><a href="viridisLite.html#topic+viridis">viridis</a></code>. Default <code>"C"</code> (plasma) for
<code>plotGeneHeatmap</code> and <code>"D"</code> (viridis) for <code>plotFactorHeatmap</code>.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to general function
<code><a href="#topic+.plotHeatmap">.plotHeatmap</a></code> and <code><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code>.</p>
</td></tr>
<tr><td><code id="plotGeneHeatmap_+3A_trim">trim</code></td>
<td>
<p>Numeric vector of two numbers. Higher value limits the maximum
value and lower value limits the minimum value. Default <code>c(0, 0.03)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="ComplexHeatmap.html#topic+HeatmapList-class">HeatmapList-class</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plotGeneHeatmap(pbmcPlot, varFeatures(pbmcPlot))
plotGeneHeatmap(pbmcPlot, varFeatures(pbmcPlot),
                useCellMeta = c("leiden_cluster", "dataset"),
                cellSplitBy = "leiden_cluster")

plotFactorHeatmap(pbmcPlot)
plotFactorHeatmap(pbmcPlot, cellIdx = pbmcPlot$leiden_cluster %in% 1:3,
                  useCellMeta = c("leiden_cluster", "dataset"),
                  cellSplitBy = "leiden_cluster")

</code></pre>

<hr>
<h2 id='plotGeneLoadings'>Visualize factor expression and gene loading</h2><span id='topic+plotGeneLoadings'></span><span id='topic+plotGeneLoadingRank'></span>

<h3>Description</h3>

<p>Visualize factor expression and gene loading
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGeneLoadings(
  object,
  markerTable,
  useFactor,
  useDimRed = NULL,
  nLabel = 15,
  nPlot = 30,
  ...
)

plotGeneLoadingRank(
  object,
  markerTable,
  useFactor,
  nLabel = 15,
  nPlot = 30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGeneLoadings_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object with valid factorization result.</p>
</td></tr>
<tr><td><code id="plotGeneLoadings_+3A_markertable">markerTable</code></td>
<td>
<p>Returned result of <code><a href="#topic+getFactorMarkers">getFactorMarkers</a></code>.</p>
</td></tr>
<tr><td><code id="plotGeneLoadings_+3A_usefactor">useFactor</code></td>
<td>
<p>Integer index for which factor to visualize.</p>
</td></tr>
<tr><td><code id="plotGeneLoadings_+3A_usedimred">useDimRed</code></td>
<td>
<p>Name of the variable storing dimensionality reduction result
in the <code>cellMeta</code> slot. Default <code>"UMAP"</code>.</p>
</td></tr>
<tr><td><code id="plotGeneLoadings_+3A_nlabel">nLabel</code></td>
<td>
<p>Integer, number of top genes to be shown with text labels.
Default <code>15</code>.</p>
</td></tr>
<tr><td><code id="plotGeneLoadings_+3A_nplot">nPlot</code></td>
<td>
<p>Integer, number of top genes to be shown in the loading rank
plot. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="plotGeneLoadings_+3A_...">...</code></td>
<td>
<p>Additional plot theme setting arguments passed to
<code><a href="#topic+.ggScatter">.ggScatter</a></code> and <code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- getFactorMarkers(pbmcPlot, "ctrl", "stim")
plotGeneLoadings(pbmcPlot, result, useFactor = 2)
</code></pre>

<hr>
<h2 id='plotGeneViolin'>Visualize gene expression or cell metadata with violin plot</h2><span id='topic+plotGeneViolin'></span><span id='topic+plotTotalCountViolin'></span><span id='topic+plotGeneDetectedViolin'></span>

<h3>Description</h3>

<p>Visualize gene expression or cell metadata with violin plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGeneViolin(object, gene, byDataset = TRUE, groupBy = NULL, ...)

plotTotalCountViolin(object, groupBy = "dataset", ...)

plotGeneDetectedViolin(object, groupBy = "dataset", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGeneViolin_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object.</p>
</td></tr>
<tr><td><code id="plotGeneViolin_+3A_gene">gene</code></td>
<td>
<p>Character gene names.</p>
</td></tr>
<tr><td><code id="plotGeneViolin_+3A_bydataset">byDataset</code></td>
<td>
<p>Logical, whether the violin plot should be splitted by
dataset. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotGeneViolin_+3A_groupby">groupBy</code></td>
<td>
<p>Names of available categorical variable in <code>cellMeta</code>
slot. Use <code>FALSE</code> for no grouping. Default <code>NULL</code> looks clustering
result but will not group if no clustering found.</p>
</td></tr>
<tr><td><code id="plotGeneViolin_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plotCellViolin">plotCellViolin</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot if using a single gene and not splitting by dataset.
Otherwise, list of ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotGeneViolin(pbmcPlot, varFeatures(pbmcPlot)[1],
               groupBy = "leiden_cluster")
plotTotalCountViolin(pbmc)
plotGeneDetectedViolin(pbmc, dot = TRUE, box = TRUE, colorBy = "dataset")
</code></pre>

<hr>
<h2 id='plotGroupClusterDimRed'>Comprehensive group splited cluster plot on dimension reduction with
proportion</h2><span id='topic+plotGroupClusterDimRed'></span>

<h3>Description</h3>

<p>This function produces combined plot on group level (e.g. dataset, other
metadata variable like biological conditions). Scatter plot of dimension
reduction with cluster labeled is generated per group. Furthermore, a stacked
barplot of cluster proportion within each group is also combined with the
subplot of each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGroupClusterDimRed(
  object,
  useGroup = "dataset",
  useCluster = NULL,
  useDimRed = NULL,
  combinePlot = TRUE,
  droplevels = TRUE,
  relHeightMainLegend = c(5, 1),
  relHeightDRBar = c(10, 1),
  mainNRow = NULL,
  mainNCol = NULL,
  legendNRow = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGroupClusterDimRed_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object with dimension reduction, grouping
variable and cluster assignment in <code>cellMeta(object)</code>.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_usegroup">useGroup</code></td>
<td>
<p>Variable name of the group division in metadata. Default
<code>"dataset"</code>.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_usecluster">useCluster</code></td>
<td>
<p>Name of variable in <code>cellMeta(object)</code>. Default
<code>NULL</code> uses default cluster.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_usedimred">useDimRed</code></td>
<td>
<p>Name of the variable storing dimensionality reduction result
in <code>cellMeta(object)</code>. Default <code>NULL</code> use default dimRed.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_combineplot">combinePlot</code></td>
<td>
<p>Whether to return combined plot. Default <code>TRUE</code>. If
<code>FALSE</code>, will return a list containing only the scatter plots.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_droplevels">droplevels</code></td>
<td>
<p>Logical, whether to perform <code><a href="base.html#topic+droplevels">droplevels</a>()</code> on
the selected grouping variable. Default <code>TRUE</code> will not show groups that
are listed as categories but do not indeed have any cells.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_relheightmainlegend">relHeightMainLegend</code></td>
<td>
<p>Relative heights of the main combination panel and
the legend at the bottom. Must be a numeric vector of 2 numbers. Default
<code>c(5, 1)</code>.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_relheightdrbar">relHeightDRBar</code></td>
<td>
<p>Relative heights of the scatter plot and the barplot
within each subpanel. Must be a numeric vector of 2 numbers. Default
<code>c(10, 1)</code>.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_mainnrow">mainNRow</code>, <code id="plotGroupClusterDimRed_+3A_mainncol">mainNCol</code></td>
<td>
<p>Arrangement of the main plotting region, for number
of rows and columns. Default <code>NULL</code> will be automatically handled by
<code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code>.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_legendnrow">legendNRow</code></td>
<td>
<p>Arrangement of the legend, number of rows. Default
<code>1</code>.</p>
</td></tr>
<tr><td><code id="plotGroupClusterDimRed_+3A_...">...</code></td>
<td>
<p>Additional graphic setting arguments passed to
<code><a href="#topic+plotDimRed">plotDimRed</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object when only one feature (e.g. cluster variable, gene,
factor) is set. List object when multiple of those are specified.
</p>


<h3>See Also</h3>

<p>Please refer to <code><a href="#topic+plotDimRed">plotDimRed</a></code>,
<code><a href="#topic+.ggScatter">.ggScatter</a></code>, <code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code> for additional
graphic setting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotGroupClusterDimRed(pbmcPlot)
</code></pre>

<hr>
<h2 id='plotMarkerHeatmap'>Create heatmap for showing top marker expression in conditions</h2><span id='topic+plotMarkerHeatmap'></span>

<h3>Description</h3>

<p>Create heatmap for showing top marker expression in conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMarkerHeatmap(
  object,
  result,
  topN = 5,
  lfcThresh = 1,
  padjThresh = 0.05,
  pctInThresh = 50,
  pctOutThresh = 50,
  dedupBy = c("logFC", "padj"),
  groupBy = NULL,
  groupSize = 50,
  column_title = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMarkerHeatmap_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with normalized data and metadata
to annotate available.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_result">result</code></td>
<td>
<p>The data.frame returned by <code><a href="#topic+runMarkerDEG">runMarkerDEG</a></code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_topn">topN</code></td>
<td>
<p>Number of top features to be plot for each group. Default
<code>5</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_lfcthresh">lfcThresh</code></td>
<td>
<p>Hard threshold on logFC value. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_padjthresh">padjThresh</code></td>
<td>
<p>Hard threshold on adjusted P-value. Default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_pctinthresh">pctInThresh</code>, <code id="plotMarkerHeatmap_+3A_pctoutthresh">pctOutThresh</code></td>
<td>
<p>Threshold on expression percentage. These
mean that a feature will only pass the filter if it is expressed in more than
<code>pctInThresh</code> percent of cells in the corresponding cluster. Similarly
for <code>pctOutThresh</code>. Default <code>50</code> percent for both.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_dedupby">dedupBy</code></td>
<td>
<p>When ranking by padj and logFC and a feature is ranked as top
for multiple clusters, assign this feature as the marker of a cluster when
it has the largest <code>"logFC"</code> in the cluster or has the lowest
<code>"padj"</code>. Default <code>"logFC"</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_groupby">groupBy</code></td>
<td>
<p>Cell metadata variable names for cell grouping. Downsample
balancing will also be aware of this. Default <code>c("dataset",
"leiden_cluster")</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_groupsize">groupSize</code></td>
<td>
<p>Maximum number of cells in each group to be downsampled for
plotting. Default <code>50</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_column_title">column_title</code></td>
<td>
<p>Title on the column. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plotMarkerHeatmap_+3A_...">...</code></td>
<td>
<p>Parameter passed to wrapped functions in the inheritance order:
<code><a href="#topic+plotGeneHeatmap">plotGeneHeatmap</a></code>, <code><a href="#topic+.plotHeatmap">.plotHeatmap</a></code>,
<code>ComplexHeatmap::<a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>markerTable &lt;- runMarkerDEG(pbmcPlot)
plotMarkerHeatmap(pbmcPlot, markerTable)
</code></pre>

<hr>
<h2 id='plotProportion'>Visualize proportion across two categorical variables</h2><span id='topic+plotProportion'></span><span id='topic+plotProportionDot'></span><span id='topic+plotProportionBar'></span><span id='topic+plotClusterProportions'></span><span id='topic+plotProportionPie'></span>

<h3>Description</h3>

<p><code>plotProportionBar</code> creates bar plots comparing the
cross-category proportion. <code>plotProportionDot</code> creates dot plots.
<code>plotClusterProportions</code> has variable pre-specified and calls the dot
plot. <code>plotProportion</code> produces a combination of both bar plots and dot
plot.
</p>
<p>Having package &quot;ggrepel&quot; installed can help adding tidier percentage
annotation on the pie chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotProportion(
  object,
  class1 = NULL,
  class2 = "dataset",
  method = c("stack", "group", "pie"),
  ...
)

plotProportionDot(
  object,
  class1 = NULL,
  class2 = "dataset",
  showLegend = FALSE,
  panelBorder = TRUE,
  ...
)

plotProportionBar(
  object,
  class1 = NULL,
  class2 = "dataset",
  method = c("stack", "group"),
  inclRev = FALSE,
  panelBorder = TRUE,
  combinePlot = TRUE,
  ...
)

plotClusterProportions(object, useCluster = NULL, return.plot = FALSE, ...)

plotProportionPie(
  object,
  class1 = NULL,
  class2 = "dataset",
  labelSize = 4,
  labelColor = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotProportion_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_class1">class1</code>, <code id="plotProportion_+3A_class2">class2</code></td>
<td>
<p>Each should be a single name of a categorical variable
available in <code>cellMeta</code> slot. Number of cells in each categories in
<code>class2</code> will be served as the denominator when calculating proportions.
By default <code>class1 = NULL</code> and uses default clusters and <code>class2 =
"dataset"</code>.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_method">method</code></td>
<td>
<p>For bar plot, choose whether to draw <code>"stack"</code> or
<code>"group"</code> bar plot. Default <code>"stack"</code>.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_showlegend">showLegend</code>, <code id="plotProportion_+3A_panelborder">panelBorder</code>, <code id="plotProportion_+3A_...">...</code></td>
<td>
<p>ggplot theme setting arguments passed to
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_inclrev">inclRev</code></td>
<td>
<p>Logical, for barplot, whether to reverse the specification for
<code>class1</code> and <code>class2</code> and produce two plots. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_combineplot">combinePlot</code></td>
<td>
<p>Logical, whether to combine the two plots with
<code><a href="cowplot.html#topic+plot_grid">plot_grid</a></code> when two plots are created. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_usecluster">useCluster</code></td>
<td>
<p>For <code>plotClusterProportions</code>. Same as <code>class1</code>
while <code>class2</code> is hardcoded with <code>"dataset"</code>.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_return.plot">return.plot</code></td>
<td>
<p><b>defuncted</b>.</p>
</td></tr>
<tr><td><code id="plotProportion_+3A_labelsize">labelSize</code>, <code id="plotProportion_+3A_labelcolor">labelColor</code></td>
<td>
<p>Settings on pie chart percentage label. Default
<code>4</code> and <code>"white"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot or list of ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotProportion(pbmcPlot)
plotProportionBar(pbmcPlot, method = "group")
plotProportionPie(pbmcPlot)
</code></pre>

<hr>
<h2 id='plotSankey'>Make Riverplot/Sankey diagram that shows label mapping across datasets</h2><span id='topic+plotSankey'></span>

<h3>Description</h3>

<p>Creates a riverplot/Sankey diagram to show how independent cluster
assignments from two datasets map onto a joint clustering. Prior knowledge of
cell annotation for the given datasets is required to make sense from the
visualization. Dataset original annotation can be added with the syntax shown
in example code in this manual. The joint clustering could be generated with
<code><a href="#topic+runCluster">runCluster</a></code> or set by any other metadata annotation.
</p>
<p>Dataset original annotation can be inserted before running this function
using <code>cellMeta&lt;-</code> method. Please see example below.
</p>
<p>This function depends on CRAN available package &quot;sankey&quot; and it has to be
installed in order to make this function work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSankey(
  object,
  cluster1,
  cluster2,
  clusterConsensus = NULL,
  minFrac = 0.01,
  minCell = 10,
  titles = NULL,
  prefixes = NULL,
  labelCex = 1,
  titleCex = 1.1,
  colorValues = scPalette,
  mar = c(2, 2, 4, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSankey_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object with all three clustering
variables available.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_cluster1">cluster1</code>, <code id="plotSankey_+3A_cluster2">cluster2</code></td>
<td>
<p>Name of the variables in <code>cellMeta(object)</code> for
the cluster assignments of dataset 1 and 2, respectively.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_clusterconsensus">clusterConsensus</code></td>
<td>
<p>Name of the joint cluster variable to use. Default
uses the default clustering of the object. Can select a variable name in
<code>cellMeta(object)</code>.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_minfrac">minFrac</code></td>
<td>
<p>Numeric. Minimum fraction of cluster for an edge to be shown.
Default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_mincell">minCell</code></td>
<td>
<p>Numeric. Minimum number of cells for an edge to be shown.
Default <code>10</code>.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_titles">titles</code></td>
<td>
<p>Character vector of three. Customizes the column title text
shown. Default uses the variable names <code>cluster1</code>,
<code>clusterConsensus</code> and <code>cluster2</code>.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_prefixes">prefixes</code></td>
<td>
<p>Character vector of three. Cluster names have to be unique
across all three variables, so this is provided to deduplicate the clusters
by adding <code>"prefixes[i]-"</code> before the actual label. This will not be
applied when no duplicate is found. Default <code>NULL</code> uses variable names.
An NA value or a string with no character (i.e. <code>""</code>) does not add the
prefix to the corresponding variable.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_labelcex">labelCex</code></td>
<td>
<p>Numeric. Amount by which node label text should be magnified
relative to the default. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_titlecex">titleCex</code></td>
<td>
<p>Numeric. Amount by which node label text should be magnified
relative to the default. Default <code>1.1</code>.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_colorvalues">colorValues</code></td>
<td>
<p>Character vector of color codes to set color for each
level in the consensus clustering. Default <code>scPalette</code>.</p>
</td></tr>
<tr><td><code id="plotSankey_+3A_mar">mar</code></td>
<td>
<p>Numeric vector of the form <code>c(bottom, left, top, right)</code>
which gives the number of lines of margin to be specified on the four sides
of the plot. Increasing the 2nd and 4th values can be helpful when cluster
labels are long and extend out side of the plotting region. Default
<code>c(2, 2, 4, 2)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No returned value. The sankey diagram will be displayed instead.
</p>


<h3>Note</h3>

<p>This function works as a replacement of the function <code>makeRiverplot</code>
in rliger &lt;1.99. We decide to make a new function because the dependency
adopted by the older version is archived on CRAN and will be no longer
available.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make fake dataset specific labels from joint clustering result
cellMeta(pbmcPlot, "ctrl_cluster", "ctrl") &lt;-
    cellMeta(pbmcPlot, "leiden_cluster", "ctrl")
cellMeta(pbmcPlot, "stim_cluster", "stim") &lt;-
    cellMeta(pbmcPlot, "leiden_cluster", "stim")
plotSankey(pbmcPlot, "ctrl_cluster", "stim_cluster",
           titles = c("control", "LIGER", "stim"),
           prefixes = c("c", NA, "s"))
</code></pre>

<hr>
<h2 id='plotSpatial2D'>Visualize a spatial dataset</h2><span id='topic+plotSpatial2D'></span><span id='topic+plotSpatial2D.liger'></span><span id='topic+plotSpatial2D.ligerSpatialDataset'></span>

<h3>Description</h3>

<p>Visualize a spatial dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatial2D(object, ...)

## S3 method for class 'liger'
plotSpatial2D(object, dataset, useCluster = NULL, legendColorTitle = NULL, ...)

## S3 method for class 'ligerSpatialDataset'
plotSpatial2D(
  object,
  useCluster = NULL,
  legendColorTitle = NULL,
  useDims = c(1, 2),
  xlab = NULL,
  ylab = NULL,
  labelText = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotSpatial2D_+3A_object">object</code></td>
<td>
<p>Either a <a href="#topic+liger-class">liger</a> object containing a spatial
dataset or a <a href="#topic+ligerSpatialDataset-class">ligerSpatialDataset</a> object.</p>
</td></tr>
<tr><td><code id="plotSpatial2D_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods. <code>.liger</code> method passes
everything to <code>.ligerSpatialDataset</code> method, and the latter passes
everything to <code><a href="#topic+.ggScatter">.ggScatter</a></code> and then
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
<tr><td><code id="plotSpatial2D_+3A_dataset">dataset</code></td>
<td>
<p>Name of one spatial dataset.</p>
</td></tr>
<tr><td><code id="plotSpatial2D_+3A_usecluster">useCluster</code></td>
<td>
<p>Either the name of one variable in <code>cellMeta(object)</code>
or a factor object with annotation that matches with all cells in the
specified dataset. Default <code>NULL</code> uses default clusters.</p>
</td></tr>
<tr><td><code id="plotSpatial2D_+3A_legendcolortitle">legendColorTitle</code></td>
<td>
<p>Alternative title text in the legend. Default
<code>NULL</code> uses the variable name set by <code>useCluster</code>, or
<code>"Annotation"</code> is <code>useCluster</code> is a customized factor object.</p>
</td></tr>
<tr><td><code id="plotSpatial2D_+3A_usedims">useDims</code></td>
<td>
<p>Numeric vector of two, choosing the coordinates to be drawn
on 2D space. (STARmap data could have 3 dimensions.) Default <code>c(1, 2)</code>.</p>
</td></tr>
<tr><td><code id="plotSpatial2D_+3A_xlab">xlab</code>, <code id="plotSpatial2D_+3A_ylab">ylab</code></td>
<td>
<p>Text label on x-/y-axis. Default <code>NULL</code> does not show
it.</p>
</td></tr>
<tr><td><code id="plotSpatial2D_+3A_labeltext">labelText</code></td>
<td>
<p>Logical, whether to label annotation onto the scatter plot.
Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl.fake.spatial &lt;- as.ligerDataset(dataset(pbmc, "ctrl"), modal = "spatial")
fake.coords &lt;- matrix(rnorm(2 * ncol(ctrl.fake.spatial)), ncol = 2)
dimnames(fake.coords) &lt;- list(colnames(ctrl.fake.spatial), c("x", "y"))
coordinate(ctrl.fake.spatial) &lt;- fake.coords
dataset(pbmc, "ctrl") &lt;- ctrl.fake.spatial
plotSpatial2D(pbmc, dataset = "ctrl")
</code></pre>

<hr>
<h2 id='plotVarFeatures'>Plot the variance vs mean of feature expression</h2><span id='topic+plotVarFeatures'></span>

<h3>Description</h3>

<p>For each dataset where the feature variablitity is calculated,
a plot of log10 feature expression variance and log10 mean will be produced.
Features that are considered as variable would be highlighted in red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVarFeatures(object, combinePlot = TRUE, dotSize = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVarFeatures_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object. <code><a href="#topic+selectGenes">selectGenes</a></code> needs to
be run in advance.</p>
</td></tr>
<tr><td><code id="plotVarFeatures_+3A_combineplot">combinePlot</code></td>
<td>
<p>Logical. If <code>TRUE</code>, sub-figures for all datasets will
be combined into one plot. if <code>FALSE</code>, a list of plots will be returned.
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotVarFeatures_+3A_dotsize">dotSize</code></td>
<td>
<p>Controls the size of dots in the main plot. Default
<code>0.8</code>.</p>
</td></tr>
<tr><td><code id="plotVarFeatures_+3A_...">...</code></td>
<td>
<p>More theme setting parameters passed to
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot</code> object when <code>combinePlot = TRUE</code>, a list of
<code>ggplot</code> objects when <code>combinePlot = FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
plotVarFeatures(pbmc)
</code></pre>

<hr>
<h2 id='plotVolcano'>Create volcano plot for Wilcoxon test result</h2><span id='topic+plotVolcano'></span><span id='topic+plotEnhancedVolcano'></span>

<h3>Description</h3>

<p><code>plotVolcano</code> is a simple implementation and shares
most of arguments with other rliger plotting functions.
<code>plotEnhancedVolcano</code> is a wrapper function of
<code><a href="EnhancedVolcano.html#topic+EnhancedVolcano">EnhancedVolcano</a></code>, which has provides
substantial amount of arguments for graphical control. However, that requires
the installation of package &quot;EnhancedVolcano&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotVolcano(
  result,
  group,
  logFCThresh = 1,
  padjThresh = 0.01,
  labelTopN = 20,
  dotSize = 2,
  dotAlpha = 0.8,
  legendPosition = "top",
  labelSize = 4,
  ...
)

plotEnhancedVolcano(result, group, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotVolcano_+3A_result">result</code></td>
<td>
<p>Data frame table returned by <code><a href="#topic+runWilcoxon">runWilcoxon</a></code></p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_group">group</code></td>
<td>
<p>Selection of one group available from <code>result$group</code></p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_logfcthresh">logFCThresh</code></td>
<td>
<p>Number for the threshold on the absolute value of the log2
fold change statistics. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_padjthresh">padjThresh</code></td>
<td>
<p>Number for the threshold on the adjusted p-value
statistics. Default <code>0.01</code>.</p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_labeltopn">labelTopN</code></td>
<td>
<p>Number of top differential expressed features to be labeled
on the top of the dots. Default <code>20</code>.</p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_dotsize">dotSize</code>, <code id="plotVolcano_+3A_dotalpha">dotAlpha</code></td>
<td>
<p>Numbers for universal aesthetics control of dots.
Default <code>2</code> and <code>0.8</code>.</p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_legendposition">legendPosition</code></td>
<td>
<p>Text indicating where to place the legend. Choose from
<code>"top"</code>, <code>"bottom"</code>, <code>"left"</code> or <code>"right"</code>. Default
<code>"top"</code>.</p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_labelsize">labelSize</code></td>
<td>
<p>Size of labeled top features and line annotations. Default
<code>4</code>.</p>
</td></tr>
<tr><td><code id="plotVolcano_+3A_...">...</code></td>
<td>
<p>For <code>plotVolcano</code>, more theme setting arguments passed to
<code><a href="#topic+.ggplotLigerTheme">.ggplotLigerTheme</a></code>. For <code>plotEnhancedVolcano</code>, arguments
passed to <code><a href="EnhancedVolcano.html#topic+EnhancedVolcano">EnhancedVolcano</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- runMarkerDEG(pbmcPlot)
plotVolcano(result, 1)
</code></pre>

<hr>
<h2 id='quantile_norm-deprecated'>[Deprecated] Quantile align (normalize) factor loading</h2><span id='topic+quantile_norm-deprecated'></span>

<h3>Description</h3>

<p><b>Please turn to <code><a href="#topic+quantileNorm">quantileNorm</a></code>.</b>
</p>
<p>This process builds a shared factor neighborhood graph to jointly cluster
cells, then quantile normalizes corresponding clusters.
</p>
<p>The first step, building the shared factor neighborhood graph, is performed
in SNF(), and produces a graph representation where edge weights between
cells (across all datasets) correspond to their similarity in the shared
factor neighborhood space. An important parameter here is knn_k, the number
of neighbors used to build the shared factor space.
</p>
<p>Next we perform quantile alignment for each dataset, factor, and cluster (by
stretching/compressing datasets' quantiles to better match those of the
reference dataset). These aligned factor loadings are combined into a single
matrix and returned as H.norm.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_norm-deprecated_+3A_object">object</code></td>
<td>
<p><code>liger</code> object. Should run optimizeALS before calling.</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_knn_k">knn_k</code></td>
<td>
<p>Number of nearest neighbors for within-dataset knn graph
(default 20).</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_ref_dataset">ref_dataset</code></td>
<td>
<p>Name of dataset to use as a &quot;reference&quot; for normalization.
By default, the dataset with the largest number of cells is used.</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_min_cells">min_cells</code></td>
<td>
<p>Minimum number of cells to consider a cluster shared across
datasets (default 20)</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_quantiles">quantiles</code></td>
<td>
<p>Number of quantiles to use for quantile normalization
(default 50).</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_eps">eps</code></td>
<td>
<p>The error bound of the nearest neighbor search. (default 0.9)
Lower values give more accurate nearest neighbor graphs but take much longer
to computer.</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_dims.use">dims.use</code></td>
<td>
<p>Indices of factors to use for shared nearest factor
determination (default 1:ncol(H[[1]])).</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_do.center">do.center</code></td>
<td>
<p>Centers the data when scaling factors (useful for less
sparse modalities like methylation data). (default FALSE)</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_max_sample">max_sample</code></td>
<td>
<p>Maximum number of cells used for quantile normalization of
each cluster and factor. (default 1000)</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_refine.knn">refine.knn</code></td>
<td>
<p>whether to increase robustness of cluster assignments using
KNN graph.(default TRUE)</p>
</td></tr>
<tr><td><code id="quantile_norm-deprecated_+3A_rand.seed">rand.seed</code></td>
<td>
<p>Random seed to allow reproducible results (default 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>liger</code> object with 'H.norm' and 'clusters' slot set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rliger-deprecated">rliger-deprecated</a></code>
</p>

<hr>
<h2 id='quantileAlignSNF'>Quantile align (normalize) factor loadings</h2><span id='topic+quantileAlignSNF'></span>

<h3>Description</h3>

<p>This is a deprecated function. Calling 'quantileNorm' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileAlignSNF(
  object,
  knn_k = 20,
  k2 = 500,
  prune.thresh = 0.2,
  ref_dataset = NULL,
  min_cells = 20,
  quantiles = 50,
  nstart = 10,
  resolution = 1,
  dims.use = 1:ncol(x = object@H[[1]]),
  dist.use = "CR",
  center = FALSE,
  small.clust.thresh = 0,
  id.number = NULL,
  print.mod = FALSE,
  print.align.summary = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileAlignSNF_+3A_object">object</code></td>
<td>
<p><code>liger</code> object. Should run optimizeALS before calling.</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_knn_k">knn_k</code></td>
<td>
<p>Number of nearest neighbors for within-dataset knn graph (default 20).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_k2">k2</code></td>
<td>
<p>Horizon parameter for shared nearest factor graph. Distances to all but the k2 nearest
neighbors are set to 0 (cuts down on memory usage for very large graphs). (default 500)</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_prune.thresh">prune.thresh</code></td>
<td>
<p>Minimum allowed edge weight. Any edges below this are removed (given weight
0) (default 0.2)</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_ref_dataset">ref_dataset</code></td>
<td>
<p>Name of dataset to use as a &quot;reference&quot; for normalization. By default,
the dataset with the largest number of cells is used.</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_min_cells">min_cells</code></td>
<td>
<p>Minimum number of cells to consider a cluster shared across datasets (default 2)</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_quantiles">quantiles</code></td>
<td>
<p>Number of quantiles to use for quantile normalization (default 50).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_nstart">nstart</code></td>
<td>
<p>Number of times to perform Louvain community detection with different random
starts (default 10).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_resolution">resolution</code></td>
<td>
<p>Controls the number of communities detected. Higher resolution -&gt; more
communities. (default 1)</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_dims.use">dims.use</code></td>
<td>
<p>Indices of factors to use for shared nearest factor determination (default
1:ncol(H[[1]])).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_dist.use">dist.use</code></td>
<td>
<p>Distance metric to use in calculating nearest neighbors (default &quot;CR&quot;).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_center">center</code></td>
<td>
<p>Centers the data when scaling factors (useful for less sparse modalities like
methylation data). (default FALSE)</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_small.clust.thresh">small.clust.thresh</code></td>
<td>
<p>Extracts small clusters loading highly on single factor with fewer
cells than this before regular alignment (default 0 &ndash; no small cluster extraction).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_id.number">id.number</code></td>
<td>
<p>Number to use for identifying edge file (when running in parallel)
(generates random value by default).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_print.mod">print.mod</code></td>
<td>
<p>Print modularity output from clustering algorithm (default FALSE).</p>
</td></tr>
<tr><td><code id="quantileAlignSNF_+3A_print.align.summary">print.align.summary</code></td>
<td>
<p>Print summary of clusters which did not align normally (default FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This process builds a shared factor neighborhood graph to jointly cluster cells, then quantile
normalizes corresponding clusters.
</p>
<p>The first step, building the shared factor neighborhood graph, is performed in SNF(), and
produces a graph representation where edge weights between cells (across all datasets)
correspond to their similarity in the shared factor neighborhood space. An important parameter
here is knn_k, the number of neighbors used to build the shared factor space (see SNF()). Afterwards,
modularity-based community detection is performed on this graph (Louvain clustering) in order
to identify shared clusters across datasets. The method was first developed by Waltman and van Eck
(2013) and source code is available at http://www.ludowaltman.nl/slm/. The most important parameter
here is resolution, which corresponds to the number of communities detected.
</p>
<p>Next we perform quantile alignment for each dataset, factor, and cluster (by
stretching/compressing datasets' quantiles to better match those of the reference dataset). These
aligned factor loadings are combined into a single matrix and returned as H.norm.
</p>


<h3>Value</h3>

<p><code>liger</code> object with H.norm and cluster slots set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# liger object, factorization complete
ligerex
# do basic quantile alignment
ligerex &lt;- quantileAlignSNF(ligerex)
# higher resolution for more clusters (note that SNF is conserved)
ligerex &lt;- quantileAlignSNF(ligerex, resolution = 1.2)
# change knn_k for more fine-grained local clustering
ligerex &lt;- quantileAlignSNF(ligerex, knn_k = 15, resolution = 1.2)

## End(Not run)

</code></pre>

<hr>
<h2 id='quantileNorm'>Quantile Align (Normalize) Factor Loadings</h2><span id='topic+quantileNorm'></span><span id='topic+quantileNorm.liger'></span><span id='topic+quantileNorm.Seurat'></span>

<h3>Description</h3>

<p>This process builds a shared factor neighborhood graph to
jointly cluster cells, then quantile normalizes corresponding clusters.
</p>
<p>The first step, building the shared factor neighborhood graph, is performed
in SNF(), and produces a graph representation where edge weights between
cells (across all datasets) correspond to their similarity in the shared
factor neighborhood space. An important parameter here is <code>nNeighbors</code>,
the number of neighbors used to build the shared factor space.
</p>
<p>Next we perform quantile alignment for each dataset, factor, and cluster (by
stretching/compressing datasets' quantiles to better match those of the
reference dataset).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileNorm(object, ...)

## S3 method for class 'liger'
quantileNorm(
  object,
  quantiles = 50,
  reference = NULL,
  minCells = 20,
  nNeighbors = 20,
  useDims = NULL,
  center = FALSE,
  maxSample = 1000,
  eps = 0.9,
  refineKNN = TRUE,
  clusterName = "quantileNorm_cluster",
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'Seurat'
quantileNorm(
  object,
  reduction = "inmf",
  quantiles = 50,
  reference = NULL,
  minCells = 20,
  nNeighbors = 20,
  useDims = NULL,
  center = FALSE,
  maxSample = 1000,
  eps = 0.9,
  refineKNN = TRUE,
  clusterName = "quantileNorm_cluster",
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileNorm_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> or Seurat object with valid factorization
result available (i.e. <code><a href="#topic+runIntegration">runIntegration</a></code> performed in advance).</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_...">...</code></td>
<td>
<p>Arguments passed to other S3 methods of this function.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_quantiles">quantiles</code></td>
<td>
<p>Number of quantiles to use for quantile normalization.
Default <code>50</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_reference">reference</code></td>
<td>
<p>Character, numeric or logical selection of one dataset, out
of all available datasets in <code>object</code>, to use as a &quot;reference&quot; for
normalization. Default <code>NULL</code> use the dataset with the largest number of
cells.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_mincells">minCells</code></td>
<td>
<p>Minimum number of cells to consider a cluster shared across
datasets. Default <code>20</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>Number of nearest neighbors for within-dataset knn graph.
Default <code>20</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_usedims">useDims</code></td>
<td>
<p>Indices of factors to use for shared nearest factor
determination. Default <code>NULL</code> uses all factors.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_center">center</code></td>
<td>
<p>Whether to center the data when scaling factors. Could be
useful for less sparse modalities like methylation data. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_maxsample">maxSample</code></td>
<td>
<p>Maximum number of cells used for quantile normalization of
each cluster and factor. Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_eps">eps</code></td>
<td>
<p>The error bound of the nearest neighbor search. Lower values give
more accurate nearest neighbor graphs but take much longer to compute.
Default <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_refineknn">refineKNN</code></td>
<td>
<p>whether to increase robustness of cluster assignments using
KNN graph. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_clustername">clusterName</code></td>
<td>
<p>Variable name that will store the clustering result
in metadata of a <a href="#topic+liger-class">liger</a> object or a <code>Seurat</code> object.
Default <code>"quantileNorm_cluster"</code></p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="quantileNorm_+3A_reduction">reduction</code></td>
<td>
<p>Name of the reduction where LIGER integration result is
stored. Default <code>"inmf"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated input object
</p>

<ul>
<li><p>liger method
</p>

<ul>
<li><p>Update the <code>H.norm</code> slot for the alignment cell factor
loading, ready for running graph based community detection
clustering or dimensionality reduction for visualization.
</p>
</li>
<li><p>Update the <code>cellMata</code> slot with a cluster assignment basing
on cell factor loading
</p>
</li></ul>

</li>
<li><p>Seurat method
</p>

<ul>
<li><p>Update the <code>reductions</code> slot with a new <code>DimReduc</code>
object containing the aligned cell factor loading.
</p>
</li>
<li><p>Update the metadata with a cluster assignment basing on cell
factor loading
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- quantileNorm(pbmcPlot)
</code></pre>

<hr>
<h2 id='rawPeak'>Access ligerATACDataset peak data</h2><span id='topic+rawPeak'></span><span id='topic+rawPeak+3C-'></span><span id='topic+normPeak'></span><span id='topic+normPeak+3C-'></span><span id='topic+rawPeak+2Cliger+2Ccharacter-method'></span><span id='topic+rawPeak+3C-+2Cliger+2Ccharacter-method'></span><span id='topic+normPeak+2Cliger+2Ccharacter-method'></span><span id='topic+normPeak+3C-+2Cliger+2Ccharacter-method'></span><span id='topic+rawPeak+2CligerATACDataset+2Cmissing-method'></span><span id='topic+rawPeak+3C-+2CligerATACDataset+2Cmissing-method'></span><span id='topic+normPeak+2CligerATACDataset+2Cmissing-method'></span><span id='topic+normPeak+3C-+2CligerATACDataset+2Cmissing-method'></span>

<h3>Description</h3>

<p>Similar as how default <a href="#topic+ligerDataset-class">ligerDataset</a> data is
accessed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawPeak(x, dataset)

rawPeak(x, dataset, check = TRUE) &lt;- value

normPeak(x, dataset)

normPeak(x, dataset, check = TRUE) &lt;- value

## S4 method for signature 'liger,character'
rawPeak(x, dataset)

## S4 replacement method for signature 'liger,character'
rawPeak(x, dataset, check = TRUE) &lt;- value

## S4 method for signature 'liger,character'
normPeak(x, dataset)

## S4 replacement method for signature 'liger,character'
normPeak(x, dataset, check = TRUE) &lt;- value

## S4 method for signature 'ligerATACDataset,missing'
rawPeak(x, dataset = NULL)

## S4 replacement method for signature 'ligerATACDataset,missing'
rawPeak(x, dataset = NULL, check = TRUE) &lt;- value

## S4 method for signature 'ligerATACDataset,missing'
normPeak(x, dataset = NULL)

## S4 replacement method for signature 'ligerATACDataset,missing'
normPeak(x, dataset = NULL, check = TRUE) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawPeak_+3A_x">x</code></td>
<td>
<p><a href="#topic+ligerATACDataset-class">ligerATACDataset</a> object or a <a href="#topic+liger-class">liger</a>
object.</p>
</td></tr>
<tr><td><code id="rawPeak_+3A_dataset">dataset</code></td>
<td>
<p>Name or numeric index of an ATAC dataset.</p>
</td></tr>
<tr><td><code id="rawPeak_+3A_check">check</code></td>
<td>
<p>Logical, whether to perform object validity check on setting new
value.</p>
</td></tr>
<tr><td><code id="rawPeak_+3A_value">value</code></td>
<td>
<p><code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix-class</a></code> matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The retrieved peak count matrix or the updated <code>x</code> object.
</p>

<hr>
<h2 id='read10X'>Load in data from 10X</h2><span id='topic+read10X'></span><span id='topic+read10XRNA'></span><span id='topic+read10XATAC'></span>

<h3>Description</h3>

<p>Enables easy loading of sparse data matrices provided by 10X genomics.
</p>
<p><code>read10X</code> works generally for 10X cellranger pipelines including:
CellRanger &lt; 3.0 &amp; &gt;= 3.0 and CellRanger-ARC.
</p>
<p><code>read10XRNA</code> invokes <code>read10X</code> and takes the &quot;Gene Expression&quot; out,
so that the result can directly be used to construct a <a href="#topic+liger-class">liger</a>
object. See Examples for demonstration.
</p>
<p><code>read10XATAC</code> works for both cellRanger-ARC and cellRanger-ATAC
pipelines but needs user arguments for correct recognition. Similarly, the
returned value can directly be used for constructing a <a href="#topic+liger-class">liger</a>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read10X(
  path,
  sampleNames = NULL,
  useFiltered = NULL,
  reference = NULL,
  geneCol = 2,
  cellCol = 1,
  returnList = FALSE,
  verbose = getOption("ligerVerbose", TRUE),
  sample.dirs = path,
  sample.names = sampleNames,
  use.filtered = useFiltered,
  data.type = NULL,
  merge = NULL,
  num.cells = NULL,
  min.umis = NULL
)

read10XRNA(
  path,
  sampleNames = NULL,
  useFiltered = NULL,
  reference = NULL,
  returnList = FALSE,
  ...
)

read10XATAC(
  path,
  sampleNames = NULL,
  useFiltered = NULL,
  pipeline = c("atac", "arc"),
  arcFeatureType = "Peaks",
  returnList = FALSE,
  geneCol = 2,
  cellCol = 1,
  verbose = getOption("ligerVerbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read10X_+3A_path">path</code></td>
<td>
<p>[A.] A Directory containing the matrix.mtx, genes.tsv (or
features.tsv), and barcodes.tsv files provided by 10X. A vector, a named
vector, a list or a named list can be given in order to load several data
directories. [B.] The 10X root directory where subdirectories of per-sample
output folders can be found. Sample names will by default take the name of
the vector, list or subfolders.</p>
</td></tr>
<tr><td><code id="read10X_+3A_samplenames">sampleNames</code></td>
<td>
<p>A vector of names to override the detected or set sample
names for what is given to <code>path</code>. Default <code>NULL</code>. If no name
detected at all and multiple samples are given, will name them by numbers.</p>
</td></tr>
<tr><td><code id="read10X_+3A_usefiltered">useFiltered</code></td>
<td>
<p>Logical, if <code>path</code> is given as case B, whether to use
the filtered feature barcode matrix instead of raw (unfiltered). Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="read10X_+3A_reference">reference</code></td>
<td>
<p>In case of specifying a CellRanger&lt;3 root folder to
<code>path</code>, import the matrix from the output using which reference. Only
needed when multiple references present. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="read10X_+3A_genecol">geneCol</code></td>
<td>
<p>Specify which column of genes.tsv or features.tsv to use for
gene names. Default <code>2</code>.</p>
</td></tr>
<tr><td><code id="read10X_+3A_cellcol">cellCol</code></td>
<td>
<p>Specify which column of barcodes.tsv to use for cell names.
Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="read10X_+3A_returnlist">returnList</code></td>
<td>
<p>Logical, whether to still return a structured list instead
of a single matrix object, in the case where only one sample and only one
feature type can be found. Otherwise will always return a list. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="read10X_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="read10X_+3A_sample.dirs">sample.dirs</code>, <code id="read10X_+3A_sample.names">sample.names</code>, <code id="read10X_+3A_use.filtered">use.filtered</code></td>
<td>
<p>These arguments are renamed and
will be deprecated in the future. Please see usage for corresponding
arguments.</p>
</td></tr>
<tr><td><code id="read10X_+3A_data.type">data.type</code>, <code id="read10X_+3A_merge">merge</code>, <code id="read10X_+3A_num.cells">num.cells</code>, <code id="read10X_+3A_min.umis">min.umis</code></td>
<td>
<p>These arguments are defuncted
because the functionality can/should be fulfilled with other functions.</p>
</td></tr>
<tr><td><code id="read10X_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>read10X</code></p>
</td></tr>
<tr><td><code id="read10X_+3A_pipeline">pipeline</code></td>
<td>
<p>Which cellRanger pipeline type to find the ATAC data. Choose
<code>"atac"</code> to read the peak matrix from cellranger-atac pipeline output
folder(s), or <code>"arc"</code> to split the ATAC feature subset out from the
multiomic cellranger-arc pipeline output folder(s). Default <code>"atac"</code>.</p>
</td></tr>
<tr><td><code id="read10X_+3A_arcfeaturetype">arcFeatureType</code></td>
<td>
<p>When <code>pipeline = "arc"</code>, which feature type is
for the ATAC data of interests. Default <code>"Peaks"</code>. Other possible
feature types can be <code>"Chromatin Accessibility"</code>. Error message will
show available options if argument specification cannot be found.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>When only one sample is given or detected, and only one feature type
is detected or using CellRanger &lt; 3.0, and <code>returnList = FALSE</code>, a
sparse matrix object (dgCMatrix class) will be returned.
</p>
</li>
<li><p>When using <code>read10XRNA</code> or <code>read10XATAC</code>, which are modality
specific, returns a list named by samples, and each element is the
corresponding sparse matrix object (dgCMatrix class).
</p>
</li>
<li><p><code>read10X</code> generally returns a list named by samples. Each sample
element will be another list named by feature types even if only one feature
type is detected (or using CellRanger &lt; 3.0) for data structure consistency.
The feature type &quot;Gene Expression&quot; always comes as the first type if
available.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# For output from CellRanger &lt; 3.0
dir &lt;- 'path/to/data/directory'
list.files(dir) # Should show barcodes.tsv, genes.tsv, and matrix.mtx
mat &lt;- read10X(dir)
class(mat) # Should show dgCMatrix

# For root directory from CellRanger &lt; 3.0
dir &lt;- 'path/to/root'
list.dirs(dir) # Should show sample names
matList &lt;- read10X(dir)
names(matList) # Should show the sample names
class(matList[[1]][["Gene Expression"]]) # Should show dgCMatrix

# For output from CellRanger &gt;= 3.0 with multiple data types
dir &lt;- 'path/to/data/directory'
list.files(dir) # Should show barcodes.tsv.gz, features.tsv.gz, and matrix.mtx.gz
matList &lt;- read10X(dir, sampleNames = "tissue1")
names(matList) # Shoud show "tissue1"
names(matList$tissue1) # Should show feature types, e.g. "Gene Expression" and etc.

# For root directory from CellRanger &gt;= 3.0 with multiple data types
dir &lt;- 'path/to/root'
list.dirs(dir) # Should show sample names, e.g. "rep1", "rep2", "rep3"
matList &lt;- read10X(dir)
names(matList) # Should show the sample names: "rep1", "rep2", "rep3"
names(matList$rep1) # Should show the avalable feature types for rep1

## End(Not run)
## Not run: 
# For creating LIGER object from root directory of CellRanger &gt;= 3.0
dir &lt;- 'path/to/root'
list.dirs(dir) # Should show sample names, e.g. "rep1", "rep2", "rep3"
matList &lt;- read10XRNA(dir)
names(matList) # Should show the sample names: "rep1", "rep2", "rep3"
sapply(matList, class) # Should show matrix class all are "dgCMatrix"
lig &lt;- createLigerObject(matList)

## End(Not run)
</code></pre>

<hr>
<h2 id='readLiger'>Read liger object from RDS file</h2><span id='topic+readLiger'></span>

<h3>Description</h3>

<p>This file reads a liger object stored in RDS files under all kinds of types.
1. A <a href="#topic+liger-class">liger</a> object with in-memory data created from package
version since 1.99. 2. A liger object with on-disk H5 data associated, where
the link to H5 files will be automatically restored. 3. A liger object
created with older package version, and can be updated to the latest data
structure by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readLiger(
  filename,
  dimredName = "tsne_coords",
  clusterName = "clusters",
  h5FilePath = NULL,
  update = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readLiger_+3A_filename">filename</code></td>
<td>
<p>Path to an RDS file of a <code>liger</code> object of old versions.</p>
</td></tr>
<tr><td><code id="readLiger_+3A_dimredname">dimredName</code></td>
<td>
<p>The name of variable in <code>cellMeta</code> slot to store the
dimensionality reduction matrix, which originally located in
<code>tsne.coords</code> slot. Default <code>"tsne.coords"</code>.</p>
</td></tr>
<tr><td><code id="readLiger_+3A_clustername">clusterName</code></td>
<td>
<p>The name of variable in <code>cellMeta</code> slot to store the
clustering assignment, which originally located in <code>clusters</code> slot.
Default <code>"clusters"</code>.</p>
</td></tr>
<tr><td><code id="readLiger_+3A_h5filepath">h5FilePath</code></td>
<td>
<p>Named list, to specify the path to the H5 file of each
dataset if location has been changed. Default <code>NULL</code> looks at the file
paths stored in object.</p>
</td></tr>
<tr><td><code id="readLiger_+3A_update">update</code></td>
<td>
<p>Logical, whether to update an old (&lt;=1.0.0) <code>liger</code> object
to the currect version of structure. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New version of <a href="#topic+liger-class">liger</a> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Save and read regular current-version liger object
tempPath &lt;- tempfile(fileext = ".rds")
saveRDS(pbmc, tempPath)
pbmc &lt;- readLiger(tempPath)

# Save and read H5-based liger object
h5Path &lt;- system.file("extdata/ctrl.h5", package = "rliger")
lig &lt;- createLiger(list(ctrl = h5Path))
tempPath &lt;- tempfile(fileext = ".rds")
saveRDS(lig, tempPath)
lig &lt;- readLiger(tempPath)
</code></pre>

<hr>
<h2 id='readSubset'>[Deprecated] See <code><a href="#topic+downsample">downsample</a></code></h2><span id='topic+readSubset'></span>

<h3>Description</h3>

<p>This function mainly aims at downsampling datasets to a size
suitable for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSubset(
  object,
  slot.use = "normData",
  balance = NULL,
  max.cells = 1000,
  chunk = 1000,
  datasets.use = NULL,
  genes.use = NULL,
  rand.seed = 1,
  verbose = getOption("ligerVerbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSubset_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="readSubset_+3A_slot.use">slot.use</code></td>
<td>
<p>Only create subset from one or more of <code>"rawData"</code>,
<code>"normData"</code> and <code>"scaleData"</code>. Default <code>NULL</code> subsets the
whole <code>object</code> including downstream results.</p>
</td></tr>
<tr><td><code id="readSubset_+3A_balance">balance</code></td>
<td>
<p><code>"all"</code> for sampling <code>maxCells</code> cells from all
datasets specified by <code>useDatasets</code>. <code>"cluster"</code> for sampling
<code>maxCells</code> cells per cluster per dataset. <code>"dataset"</code> for
<code>maxCells</code> cells per dataset.</p>
</td></tr>
<tr><td><code id="readSubset_+3A_max.cells">max.cells</code></td>
<td>
<p>Max number of cells to sample from the grouping based on
<code>balance</code>.</p>
</td></tr>
<tr><td><code id="readSubset_+3A_chunk">chunk</code></td>
<td>
<p>Integer. Number of maximum number of cells in each chunk,
Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="readSubset_+3A_datasets.use">datasets.use</code></td>
<td>
<p>Index selection of datasets to consider. Default
<code>NULL</code> for using all datasets.</p>
</td></tr>
<tr><td><code id="readSubset_+3A_genes.use">genes.use</code></td>
<td>
<p>Character vector. Subset features to this specified range.
Default <code>NULL</code> does not subset features.</p>
</td></tr>
<tr><td><code id="readSubset_+3A_rand.seed">rand.seed</code></td>
<td>
<p>Random seed for reproducibility. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="readSubset_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subset of <a href="#topic+liger-class">liger</a> <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+downsample">downsample</a></code>, <code><a href="#topic+subsetLiger">subsetLiger</a></code>,
<code><a href="#topic+subsetLigerDataset">subsetLigerDataset</a></code>
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='removeMissing'>Remove missing cells or features from liger object</h2><span id='topic+removeMissing'></span><span id='topic+removeMissingObs'></span>

<h3>Description</h3>

<p>Remove missing cells or features from liger object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeMissing(
  object,
  orient = c("both", "feature", "cell"),
  minCells = NULL,
  minFeatures = NULL,
  useDatasets = NULL,
  newH5 = TRUE,
  filenameSuffix = "removeMissing",
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

removeMissingObs(
  object,
  slot.use = NULL,
  use.cols = TRUE,
  verbose = getOption("ligerVerbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeMissing_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_orient">orient</code></td>
<td>
<p>Choose to remove non-expressing features (<code>"feature"</code>),
empty barcodes (<code>"cell"</code>), or both of them (<code>"both"</code>). Default
<code>"both"</code>.</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_mincells">minCells</code></td>
<td>
<p>Keep features that are expressed in at least this number of
cells, calculated on a per-dataset base. A single value for all datasets or
a vector for each dataset. Default <code>NULL</code> only removes none expressing
features.</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_minfeatures">minFeatures</code></td>
<td>
<p>Keep cells that express at least this number of features,
calculated on a per-dataset base. A single value for all datasets or a vector
for each dataset. Default <code>NULL</code> only removes none expressing cells.</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to be processed. Default
<code>NULL</code> removes empty entries from all datasets.</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_newh5">newH5</code></td>
<td>
<p>Logical, whether to create a new H5 file on disk for each
H5-based dataset on subset. Default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="removeMissing_+3A_filenamesuffix">filenameSuffix</code></td>
<td>
<p>When subsetting H5-based datasets to new H5 files, this
suffix will be added to all the filenames. Default <code>"removeMissing"</code>.</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+subsetLigerDataset">subsetLigerDataset</a></code></p>
</td></tr>
<tr><td><code id="removeMissing_+3A_slot.use">slot.use</code></td>
<td>
<p><b>Deprecated</b>. Always look at <code>rawData</code> slot of
inner <a href="#topic+ligerDataset-class">ligerDataset</a> objects.</p>
</td></tr>
<tr><td><code id="removeMissing_+3A_use.cols">use.cols</code></td>
<td>
<p><b>Deprecated</b>. Previously means &quot;treating each column as
a cell&quot; when <code>TRUE</code>, now means <code>orient="cell"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated (subset) <code>object</code>.
</p>


<h3>Note</h3>

<p><code>removeMissingObs</code> will be deprecated. <code>removeMissing</code> covers and
expands the use case and should be easier to understand.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The example dataset does not contain non-expressing genes or empty barcodes
pbmc &lt;- removeMissing(pbmc)
</code></pre>

<hr>
<h2 id='restoreH5Liger'>Restore links (to HDF5 files) for reloaded liger/ligerDataset object</h2><span id='topic+restoreH5Liger'></span><span id='topic+restoreOnlineLiger'></span>

<h3>Description</h3>

<p>When loading the saved liger object with HDF5 data in a new R
session, the links to HDF5 files would be closed. This function enables
the restoration of those links so that new analyses can be carried out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restoreH5Liger(object, filePath = NULL)

restoreOnlineLiger(object, file.path = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restoreH5Liger_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> or <a href="#topic+ligerDataset-class">ligerDataset</a> object.</p>
</td></tr>
<tr><td><code id="restoreH5Liger_+3A_filepath">filePath</code></td>
<td>
<p>Paths to HDF5 files. A single character path for
<a href="#topic+ligerDataset-class">ligerDataset</a> input or a list of paths named by the datasets for
<a href="#topic+liger-class">liger</a> object input. Default <code>NULL</code> looks for the path(s)
of the last valid loading.</p>
</td></tr>
<tr><td><code id="restoreH5Liger_+3A_file.path">file.path</code></td>
<td>
<p>Will be deprecated with <code>restoreOnlineLiger</code>. The same
as <code>filePath</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with restored links.
</p>


<h3>Note</h3>

<p><code>restoreOnlineLiger</code> will be deprecated for clarifying the terms used
for data structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>h5Path &lt;- system.file("extdata/ctrl.h5", package = "rliger")
lig &lt;- createLiger(list(ctrl = h5Path))
# Now it is actually an invalid object! which is equivalent to what users
# will get with `saveRDS(lig, "object.rds"); lig &lt;- readRDS("object.rds")``
closeAllH5(lig)
lig &lt;- restoreH5Liger(lig)
</code></pre>

<hr>
<h2 id='retrieveCellFeature'>Retrieve a single matrix of cells from a slot</h2><span id='topic+retrieveCellFeature'></span>

<h3>Description</h3>

<p>Only retrieve data from specific slot to reduce memory used by
a whole <a href="#topic+liger-class">liger</a> object of the subset. Useful for plotting.
Internally used by <code><a href="#topic+plotDimRed">plotDimRed</a></code> and <code><a href="#topic+plotCellViolin">plotCellViolin</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieveCellFeature(
  object,
  feature,
  slot = c("rawData", "normData", "scaleData", "H", "H.norm", "cellMeta", "rawPeak",
    "normPeak"),
  cellIdx = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retrieveCellFeature_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="retrieveCellFeature_+3A_feature">feature</code></td>
<td>
<p>Gene names, factor index or cell metadata variable names.
Should be available in specified <code>slot</code>.</p>
</td></tr>
<tr><td><code id="retrieveCellFeature_+3A_slot">slot</code></td>
<td>
<p>Exactly choose from <code>"rawData"</code>, <code>"normData"</code>,
<code>"scaleData"</code>, <code>"H"</code>, <code>"H.norm"</code> or <code>"cellMeta"</code>.</p>
</td></tr>
<tr><td><code id="retrieveCellFeature_+3A_cellidx">cellIdx</code></td>
<td>
<p>Any valid type of index that subset from all cells. Default
<code>NULL</code> uses all cells.</p>
</td></tr>
<tr><td><code id="retrieveCellFeature_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+subsetLiger">subsetLiger</a></code> when
<code>slot</code> is one of <code>"rawData"</code>, <code>"normData"</code> or
<code>"scaleData"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object where rows are cells and columns are specified
features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S100A8Exp &lt;- retrieveCellFeature(pbmc, "S100A8")
qcMetrics &lt;- retrieveCellFeature(pbmc, c("nUMI", "nGene", "mito"),
                                 slot = "cellMeta")
</code></pre>

<hr>
<h2 id='reverseMethData'>Create &quot;scaled data&quot; for DNA methylation datasets</h2><span id='topic+reverseMethData'></span>

<h3>Description</h3>

<p>Because gene body mCH proportions are negatively correlated with gene
expression level in neurons, we need to reverse the direction of the
methylation data. We do this by simply subtracting all values from the
maximum methylation value. The resulting values are positively correlated
with gene expression. This will only be applied to variable genes detected in
prior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverseMethData(object, useDatasets, verbose = getOption("ligerVerbose", TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverseMethData_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with variable genes identified.</p>
</td></tr>
<tr><td><code id="reverseMethData_+3A_usedatasets">useDatasets</code></td>
<td>
<p>Required. A character vector of the names, a numeric or
logical vector of the index of the datasets that should be identified as
methylation data where the reversed data will be created.</p>
</td></tr>
<tr><td><code id="reverseMethData_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <a href="#topic+liger-class">liger</a> object, where the <code>scaleData</code> slot
of the specified datasets will be updated with value as described in
Description.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Assuming the second dataset in example data "pbmc" is methylation data
pbmc &lt;- normalize(pbmc, useDatasets = 1)
pbmc &lt;- selectGenes(pbmc, datasets.use = 1)
pbmc &lt;- scaleNotCenter(pbmc, useDatasets = 1)
pbmc &lt;- reverseMethData(pbmc, useDatasets = 2)
</code></pre>

<hr>
<h2 id='runCINMF'>Perform consensus iNMF on scaled datasets</h2><span id='topic+runCINMF'></span><span id='topic+runCINMF.liger'></span><span id='topic+runCINMF.Seurat'></span>

<h3>Description</h3>

<p>Performs consensus integrative non-negative matrix factorization (c-iNMF)
to return factorized <code class="reqn">H</code>, <code class="reqn">W</code>, and <code class="reqn">V</code> matrices. We run the
regular iNMF multiple times with different random starts, and then take the
consensus of frequently appearing factors from gene loading matrices, <code class="reqn">W</code>
and <code class="reqn">V</code>. The cell factor loading <code class="reqn">H</code> matrices are eventually solved
with the consensus <code class="reqn">W</code> and <code class="reqn">V</code> matrices.
</p>
<p>Please see <code><a href="#topic+runINMF">runINMF</a></code> for detailed introduction to the regular
iNMF algorithm which is run multiple times in this function.
</p>
<p>The consensus iNMF algorithm is developed basing on the consensus NMF (cNMF)
method (D. Kotliar et al., 2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCINMF(object, k = 20, lambda = 5, rho = 0.3, ...)

## S3 method for class 'liger'
runCINMF(
  object,
  k = 20,
  lambda = 5,
  rho = 0.3,
  nIteration = 30,
  nRandomStarts = 10,
  HInit = NULL,
  WInit = NULL,
  VInit = NULL,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'Seurat'
runCINMF(
  object,
  k = 20,
  lambda = 5,
  rho = 0.3,
  datasetVar = "orig.ident",
  layer = "ligerScaleData",
  assay = NULL,
  reduction = "cinmf",
  nIteration = 30,
  nRandomStarts = 10,
  HInit = NULL,
  WInit = NULL,
  VInit = NULL,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runCINMF_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object or a Seurat object with
non-negative scaled data of variable features (Done with
<code><a href="#topic+scaleNotCenter">scaleNotCenter</a></code>).</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_k">k</code></td>
<td>
<p>Inner dimension of factorization (number of factors). Generally, a
higher <code>k</code> will be needed for datasets with more sub-structure. Default
<code>20</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
<code>lambda</code> increases). Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_rho">rho</code></td>
<td>
<p>Numeric number between 0 and 1. Fraction for determining the
number of nearest neighbors to look at for consensus (by
<code>rho * nRandomStarts</code>). Default <code>0.3</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_niteration">nIteration</code></td>
<td>
<p>Total number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_nrandomstarts">nRandomStarts</code></td>
<td>
<p>Number of replicate runs for creating the pool of
factorization results. Default <code>10</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_hinit">HInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">H</code> matrices. A list object where
each element is the initial <code class="reqn">H</code> matrix of each dataset. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_winit">WInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">W</code> matrix. A matrix object.
Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_vinit">VInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">V</code> matrices. A list object where
each element is the initial <code class="reqn">V</code> matrix of each dataset. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_ncores">nCores</code></td>
<td>
<p>The number of parallel tasks to speed up the computation.
Default <code>2L</code>. Only supported for platform with OpenMP support.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_datasetvar">datasetVar</code></td>
<td>
<p>Metadata variable name that stores the dataset source
annotation. Default <code>"orig.ident"</code>.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_layer">layer</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to retrieve input
non-negative scaled data. Default <code>"ligerScaleData"</code>. For older Seurat,
always retrieve from <code>scale.data</code> slot.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
<tr><td><code id="runCINMF_+3A_reduction">reduction</code></td>
<td>
<p>Name of the reduction to store result. Also used as the
feature key. Default <code>"cinmf"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>liger method - Returns updated input <a href="#topic+liger-class">liger</a> object
</p>

<ul>
<li><p>A list of all <code class="reqn">H</code> matrices can be accessed with
<code>getMatrix(object, "H")</code>
</p>
</li>
<li><p>A list of all <code class="reqn">V</code> matrices can be accessed with
<code>getMatrix(object, "V")</code>
</p>
</li>
<li><p>The <code class="reqn">W</code> matrix can be accessed with
<code>getMatrix(object, "W")</code>
</p>
</li></ul>

</li>
<li><p>Seurat method - Returns updated input Seurat object
</p>

<ul>
<li><p><code class="reqn">H</code> matrices for all datasets will be concatenated and
transposed (all cells by k), and form a DimReduc object in the
<code>reductions</code> slot named by argument <code>reduction</code>.
</p>
</li>
<li><p><code class="reqn">W</code> matrix will be presented as <code>feature.loadings</code> in the
same DimReduc object.
</p>
</li>
<li><p><code class="reqn">V</code> matrices, an objective error value and the dataset
variable used for the factorization is currently stored in
<code>misc</code> slot of the same DimReduc object.
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Joshua D. Welch and et al., Single-Cell Multi-omic Integration Compares and
Contrasts Features of Brain Cell Identity, Cell, 2019
</p>
<p>Dylan Kotliar and et al., Identifying gene expression programs of cell-type
identity and cellular activity with single-cell RNA-Seq, eLife, 2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- runCINMF(pbmc)
}

</code></pre>

<hr>
<h2 id='runCluster'>SNN Graph Based Community Detection</h2><span id='topic+runCluster'></span>

<h3>Description</h3>

<p>After quantile normalization, users can additionally run the Leiden or
Louvain algorithm for community detection, which is widely used in
single-cell analysis and excels at merging small clusters into broad cell
classes.
</p>
<p>While using quantile normalized factor loadings (result from
<code><a href="#topic+quantileNorm">quantileNorm</a></code>) is recommended, this function looks for
unnormalized factor loadings (result from <code><a href="#topic+runIntegration">runIntegration</a></code>) when
the former is not available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCluster(
  object,
  resolution = 1,
  nNeighbors = 20,
  prune = 1/15,
  eps = 0.1,
  nRandomStarts = 10,
  nIterations = 5,
  method = c("leiden", "louvain"),
  useRaw = NULL,
  useDims = NULL,
  groupSingletons = TRUE,
  saveSNN = FALSE,
  clusterName = paste0(method, "_cluster"),
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runCluster_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object. Should have valid factorization
result available.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_resolution">resolution</code></td>
<td>
<p>Numeric, value of the resolution parameter, a larger value
results in a larger number of communities with smaller sizes. Default
<code>1.0</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>Integer, the maximum number of nearest neighbors to
compute. Default <code>20</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_prune">prune</code></td>
<td>
<p>Numeric. Sets the cutoff for acceptable Jaccard index when
computing the neighborhood overlap for the SNN construction. Any edges with
values less than or equal to this will be set to 0 and removed from the SNN
graph. Essentially sets the stringency of pruning. <code>0</code> for no pruning,
while <code>1</code> prunes everything. Default <code>1/15</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_eps">eps</code></td>
<td>
<p>Numeric, the error bound of the nearest neighbor search. Default
<code>0.1</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_nrandomstarts">nRandomStarts</code></td>
<td>
<p>Integer number of random starts. Will pick the
membership with highest quality to return. Default <code>10</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_niterations">nIterations</code></td>
<td>
<p>Integer, maximal number of iterations per random start.
Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_method">method</code></td>
<td>
<p>Community detection algorithm to use. Choose from
<code>"leiden"</code> or <code>"louvain"</code>. Default <code>"leiden"</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_useraw">useRaw</code></td>
<td>
<p>Whether to use un-aligned cell factor loadings (<code class="reqn">H</code>
matrices). Default <code>NULL</code> search for quantile-normalized loadings first
and un-aligned loadings then.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_usedims">useDims</code></td>
<td>
<p>Indices of factors to use for clustering. Default <code>NULL</code>
uses all available factors.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_groupsingletons">groupSingletons</code></td>
<td>
<p>Whether to group single cells that make up their own
cluster in with the cluster they are most connected to. Default <code>TRUE</code>,
if <code>FALSE</code>, assign all singletons to a <code>"singleton"</code> group.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_savesnn">saveSNN</code></td>
<td>
<p>Logical, whether to store the SNN graph, as a dgCMatrix
object, in the object. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_clustername">clusterName</code></td>
<td>
<p>Name of the variable that will store the clustering result
in <code>cellMeta</code> slot of <code>object</code>. Default <code>"leiden_cluster"</code> and
<code>"louvain_cluster"</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_seed">seed</code></td>
<td>
<p>Seed of the random number generator. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runCluster_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>object</code> with cluster assignment updated in <code>clusterName</code>
variable in <code>cellMeta</code> slot. Can be fetched with
<code>object[[clusterName]]</code>. If <code>saveSNN = TRUE</code>, the SNN graph will
be stored at <code>object@uns$snn</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmcPlot &lt;- runCluster(pbmcPlot)
head(pbmcPlot$leiden_cluster)
pbmcPlot &lt;- runCluster(pbmcPlot, method = "louvain")
head(pbmcPlot$louvain_cluster)
</code></pre>

<hr>
<h2 id='runDoubletFinder'>Doublet detection with DoubletFinder</h2><span id='topic+runDoubletFinder'></span>

<h3>Description</h3>

<p>Detect doublet with DoubletFinder. Package &quot;Seurat&quot; and
&quot;DoubletFinder&quot; would be required to run this function.
</p>
<p>This wrapper runs Seurat PCA workflow (NormalizeData,
FindVariableFeatures, ScaleData, RunPCA) with all default settings on each
dataset, and then calls <code>DoubletFinder::doubletFinder</code>. Users that
prefer having more control on the preprocessing part might consider creating
single-sample Seurat object with
<code>CreateSeuratObject(rawData(object, "datasetName"))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDoubletFinder(
  object,
  useDatasets = NULL,
  PCs = 1:10,
  nNeighbors = 20,
  nExp = NULL,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runDoubletFinder_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object.</p>
</td></tr>
<tr><td><code id="runDoubletFinder_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to run
<code>DoubletFinder::doubletFinder</code> with. Default <code>NULL</code>
applies to all datasets.</p>
</td></tr>
<tr><td><code id="runDoubletFinder_+3A_pcs">PCs</code></td>
<td>
<p>Specific principal components to use. Default <code>1:10</code>.</p>
</td></tr>
<tr><td><code id="runDoubletFinder_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>Number of the PC neighborhood size used to compute pANN.
See &quot;See Also&quot;. Scalar for all used datasets or vector for each. Default
<code>20</code>.</p>
</td></tr>
<tr><td><code id="runDoubletFinder_+3A_nexp">nExp</code></td>
<td>
<p>The total number of doublet predictions produced. Scalar for all
used datasets or vector for each. Default <code>NULL</code> sets a 0.15 proportion.</p>
</td></tr>
<tr><td><code id="runDoubletFinder_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runDoubletFinder_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code>DoubletFinder::doubletFinder</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>object</code> with variables <code>DoubletFinder_pANN</code> and
<code>DoubletFinder_classification</code> updated in <code>cellMeta</code> slot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("DoubletFinder", quietly = TRUE)) {
    pbmc &lt;- runDoubletFinder(pbmc)
    print(cellMeta(pbmc))
}
</code></pre>

<hr>
<h2 id='runGeneralQC'>General QC for liger object</h2><span id='topic+runGeneralQC'></span>

<h3>Description</h3>

<p>Calculate number of UMIs, number of detected features and
percentage of feature subset (e.g. mito) expression per cell.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGeneralQC(
  object,
  mito = TRUE,
  ribo = TRUE,
  hemo = TRUE,
  features = NULL,
  pattern = NULL,
  useDatasets = NULL,
  chunkSize = 1000,
  verbose = getOption("ligerVerbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runGeneralQC_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object with <code>rawData</code> available in
each <a href="#topic+ligerDataset-class">ligerDataset</a> embedded</p>
</td></tr>
<tr><td><code id="runGeneralQC_+3A_mito">mito</code>, <code id="runGeneralQC_+3A_ribo">ribo</code>, <code id="runGeneralQC_+3A_hemo">hemo</code></td>
<td>
<p>Whether to calculate the expression percentage of
mitochondrial, ribosomal or hemoglobin genes, respectively. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="runGeneralQC_+3A_features">features</code></td>
<td>
<p>Feature names matching the feature subsets that users want to
calculate the expression percentage with. A vector for a single subset, or a
named list for multiple subset. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runGeneralQC_+3A_pattern">pattern</code></td>
<td>
<p>Regex patterns for matching the feature subsets that users
want to calculate the expression percentage with. A vector for a single
subset, or a named list for multiple subset. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runGeneralQC_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to be included for QC. Default
<code>NULL</code> performs QC on all datasets.</p>
</td></tr>
<tr><td><code id="runGeneralQC_+3A_chunksize">chunkSize</code></td>
<td>
<p>Integer number of cells to include in a chunk when working
on HDF5 based dataset. Default <code>1000</code></p>
</td></tr>
<tr><td><code id="runGeneralQC_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>object</code> with <code>nUMI</code>, <code>nGene</code> updated
in <code>cellMeta(object)</code>, as well as expression percentage value for each
feature subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- runGeneralQC(pbmc)
</code></pre>

<hr>
<h2 id='runGOEnrich'>Run Gene Ontology enrichment analysis on differentially expressed genes.</h2><span id='topic+runGOEnrich'></span>

<h3>Description</h3>

<p>This function forms genesets basing on the differential expression result,
and calls gene ontology (GO) analysis method provided by gprofiler2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGOEnrich(
  result,
  group = NULL,
  useBg = TRUE,
  orderBy = "padj",
  logFCThresh = 1,
  padjThresh = 0.05,
  splitReg = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runGOEnrich_+3A_result">result</code></td>
<td>
<p>Data frame of unfiltered output from <code><a href="#topic+runMarkerDEG">runMarkerDEG</a></code>
or <code><a href="#topic+runPairwiseDEG">runPairwiseDEG</a></code>.</p>
</td></tr>
<tr><td><code id="runGOEnrich_+3A_group">group</code></td>
<td>
<p>Selection of one group available from <code>result$group</code>.
Default <code>NULL</code> uses all groups involved in DE <code>result</code> table.</p>
</td></tr>
<tr><td><code id="runGOEnrich_+3A_usebg">useBg</code></td>
<td>
<p>Logical, whether to set all genes involved in DE analysis
(before threshold filtering) as a domain background of GO analysis. Default
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="runGOEnrich_+3A_orderby">orderBy</code></td>
<td>
<p>Name of DE statistics metric to order the gene list for each
group. Choose from <code>"logFC"</code> (default), <code>"pval"</code> or <code>"padj"</code>.
Or set <code>NULL</code> to turn off ranked mode.</p>
</td></tr>
<tr><td><code id="runGOEnrich_+3A_logfcthresh">logFCThresh</code></td>
<td>
<p>The log2FC threshold above which the genes will be used.
Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runGOEnrich_+3A_padjthresh">padjThresh</code></td>
<td>
<p>The adjusted p-value threshold less than which the genes
will be used. Default <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="runGOEnrich_+3A_splitreg">splitReg</code></td>
<td>
<p>Whether to have queries of both up-regulated and
down-regulated genes for each group. Default <code>FALSE</code> only queries
up-regulated genes and should be preferred when <code>result</code> comes from
marker detection test. When <code>result</code> comes from group-to-group DE test,
it is recommended to set <code>splitReg = TRUE</code>.</p>
</td></tr>
<tr><td><code id="runGOEnrich_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code>gprofiler2::<a href="gprofiler2.html#topic+gost">gost</a></code>. Arguments <code>query</code>,
<code>custom_bg</code>, <code>domain_scope</code>, and <code>ordered_query</code> are
pre-specified by this wrapper function. Users must set
<code>organism = "mmusculus"</code> when working on mouse data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object where each element is a result list for a group. Each
result list contains two elements:
</p>
<table>
<tr><td><code>result</code></td>
<td>
<p>data.frame of main GO analysis result.</p>
</td></tr>
<tr><td><code>meta</code></td>
<td>
<p>Meta information for the query.</p>
</td></tr>
</table>
<p>See <code><a href="gprofiler2.html#topic+gost">gost</a></code>. for detailed explanation.
</p>


<h3>References</h3>

<p>Kolberg, L. et al, 2020 and Raudvere, U. et al, 2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- runMarkerDEG(pbmcPlot)
# Setting `significant = FALSE` because it's hard for a gene list obtained
# from small test dataset to represent real-life biology.

go &lt;- runGOEnrich(res, group = 0, significant = FALSE)

</code></pre>

<hr>
<h2 id='runGSEA'>Analyze biological interpretations of metagene</h2><span id='topic+runGSEA'></span>

<h3>Description</h3>

<p>Identify the biological pathways (gene sets from Reactome) that
each metagene (factor) might belongs to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGSEA(
  object,
  genesets = NULL,
  useW = TRUE,
  useV = NULL,
  customGenesets = NULL,
  gene_sets = genesets,
  mat_w = useW,
  mat_v = useV,
  custom_gene_sets = customGenesets
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runGSEA_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object with valid factorization result.</p>
</td></tr>
<tr><td><code id="runGSEA_+3A_genesets">genesets</code></td>
<td>
<p>Character vector of the Reactome gene sets names to be
tested. Default <code>NULL</code> uses all the gene sets from the Reactome.</p>
</td></tr>
<tr><td><code id="runGSEA_+3A_usew">useW</code></td>
<td>
<p>Logical, whether to use the shared factor loadings (<code class="reqn">W</code>).
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="runGSEA_+3A_usev">useV</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets where the <code class="reqn">V</code> matrices will be
included for analysis. Default <code>NULL</code> uses all datasets.</p>
</td></tr>
<tr><td><code id="runGSEA_+3A_customgenesets">customGenesets</code></td>
<td>
<p>A named list of character vectors of entrez gene ids.
Default <code>NULL</code> uses all the gene symbols from the input matrix.</p>
</td></tr>
<tr><td><code id="runGSEA_+3A_gene_sets">gene_sets</code>, <code id="runGSEA_+3A_mat_w">mat_w</code>, <code id="runGSEA_+3A_mat_v">mat_v</code>, <code id="runGSEA_+3A_custom_gene_sets">custom_gene_sets</code></td>
<td>
<p><b>Deprecated</b>. See Usage
section for replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices with GSEA analysis for each factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
runGSEA(pbmcPlot)

</code></pre>

<hr>
<h2 id='runINMF'>Perform iNMF on scaled datasets</h2><span id='topic+runINMF'></span><span id='topic+runINMF.liger'></span><span id='topic+runINMF.Seurat'></span>

<h3>Description</h3>

<p>Performs integrative non-negative matrix factorization (iNMF) (J.D. Welch,
2019) using block coordinate descent (alternating non-negative
least squares, ANLS) to return factorized <code class="reqn">H</code>, <code class="reqn">W</code>, and <code class="reqn">V</code>
matrices. The objective function is stated as
</p>
<p style="text-align: center;"><code class="reqn">\arg\min_{H\ge0,W\ge0,V\ge0}\sum_{i}^{d}||E_i-(W+V_i)Hi||^2_F+
\lambda\sum_{i}^{d}||V_iH_i||_F^2</code>
</p>

<p>where <code class="reqn">E_i</code> is the input non-negative matrix of the i'th dataset, <code class="reqn">d</code>
is the total number of datasets. <code class="reqn">E_i</code> is of size <code class="reqn">m \times n_i</code> for
<code class="reqn">m</code> variable genes and <code class="reqn">n_i</code> cells, <code class="reqn">H_i</code> is of size
<code class="reqn">n_i \times k</code>, <code class="reqn">V_i</code> is of size <code class="reqn">m \times k</code>, and <code class="reqn">W</code> is of
size <code class="reqn">m \times k</code>.
</p>
<p>The factorization produces a shared <code class="reqn">W</code> matrix (genes by k), and for each
dataset, an <code class="reqn">H</code> matrix (k by cells) and a <code class="reqn">V</code> matrix (genes by k).
The <code class="reqn">H</code> matrices represent the cell factor loadings. <code class="reqn">W</code> is held
consistent among all datasets, as it represents the shared components of the
metagenes across datasets. The <code class="reqn">V</code> matrices represent the
dataset-specific components of the metagenes.
</p>
<p>This function adopts highly optimized fast and memory efficient
implementation extended from Planc (Kannan, 2016). Pre-installation of
extension package <code>RcppPlanc</code> is required. The underlying algorithm
adopts the identical ANLS strategy as <code><a href="#topic+optimizeALS">optimizeALS</a></code> in the old
version of LIGER.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runINMF(object, k = 20, lambda = 5, ...)

## S3 method for class 'liger'
runINMF(
  object,
  k = 20,
  lambda = 5,
  nIteration = 30,
  nRandomStarts = 1,
  HInit = NULL,
  WInit = NULL,
  VInit = NULL,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'Seurat'
runINMF(
  object,
  k = 20,
  lambda = 5,
  datasetVar = "orig.ident",
  layer = "ligerScaleData",
  assay = NULL,
  reduction = "inmf",
  nIteration = 30,
  nRandomStarts = 1,
  HInit = NULL,
  WInit = NULL,
  VInit = NULL,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runINMF_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object or a Seurat object with
non-negative scaled data of variable features (Done with
<code><a href="#topic+scaleNotCenter">scaleNotCenter</a></code>).</p>
</td></tr>
<tr><td><code id="runINMF_+3A_k">k</code></td>
<td>
<p>Inner dimension of factorization (number of factors). Generally, a
higher <code>k</code> will be needed for datasets with more sub-structure. Default
<code>20</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
<code>lambda</code> increases). Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_niteration">nIteration</code></td>
<td>
<p>Total number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_nrandomstarts">nRandomStarts</code></td>
<td>
<p>Number of restarts to perform (iNMF objective function
is non-convex, so taking the best objective from multiple successive
initialization is recommended). For easier reproducibility, this increments
the random seed by 1 for each consecutive restart, so future factorization
of the same dataset can be run with one rep if necessary. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_hinit">HInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">H</code> matrices. A list object where
each element is the initial <code class="reqn">H</code> matrix of each dataset. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_winit">WInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">W</code> matrix. A matrix object.
Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_vinit">VInit</code></td>
<td>
<p>Initial values to use for <code class="reqn">V</code> matrices. A list object where
each element is the initial <code class="reqn">V</code> matrix of each dataset. Default
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_ncores">nCores</code></td>
<td>
<p>The number of parallel tasks to speed up the computation.
Default <code>2L</code>. Only supported for platform with OpenMP support.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_datasetvar">datasetVar</code></td>
<td>
<p>Metadata variable name that stores the dataset source
annotation. Default <code>"orig.ident"</code>.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_layer">layer</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to retrieve input
non-negative scaled data. Default <code>"ligerScaleData"</code>. For older Seurat,
always retrieve from <code>scale.data</code> slot.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
<tr><td><code id="runINMF_+3A_reduction">reduction</code></td>
<td>
<p>Name of the reduction to store result. Also used as the
feature key. Default <code>"inmf"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>liger method - Returns updated input <a href="#topic+liger-class">liger</a> object
</p>

<ul>
<li><p>A list of all <code class="reqn">H</code> matrices can be accessed with
<code>getMatrix(object, "H")</code>
</p>
</li>
<li><p>A list of all <code class="reqn">V</code> matrices can be accessed with
<code>getMatrix(object, "V")</code>
</p>
</li>
<li><p>The <code class="reqn">W</code> matrix can be accessed with
<code>getMatrix(object, "W")</code>
</p>
</li></ul>

</li>
<li><p>Seurat method - Returns updated input Seurat object
</p>

<ul>
<li><p><code class="reqn">H</code> matrices for all datasets will be concatenated and
transposed (all cells by k), and form a DimReduc object in the
<code>reductions</code> slot named by argument <code>reduction</code>.
</p>
</li>
<li><p><code class="reqn">W</code> matrix will be presented as <code>feature.loadings</code> in the
same DimReduc object.
</p>
</li>
<li><p><code class="reqn">V</code> matrices, an objective error value and the dataset
variable used for the factorization is currently stored in
<code>misc</code> slot of the same DimReduc object.
</p>
</li></ul>

</li></ul>



<h3>Difference from optimizeALS()</h3>

<p>In the old version implementation, we compute the objective error at the end
of each iteration, and then compares if the algorithm is reaching a
convergence, using an argument <code>thresh</code>. Now, since the computation of
objective error is indeed expensive, we canceled this feature and directly
runs a default of 30 (<code>nIteration</code>) iterations, which empirically leads
to a convergence most of the time. Given that the new version is highly
optimized, running this many iteration should be acceptable.
</p>


<h3>References</h3>

<p>Joshua D. Welch and et al., Single-Cell Multi-omic Integration
Compares and Contrasts Features of Brain Cell Identity, Cell, 2019
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- runINMF(pbmc)
}
</code></pre>

<hr>
<h2 id='runIntegration'>Integrate scaled datasets with iNMF or variant methods</h2><span id='topic+runIntegration'></span><span id='topic+runIntegration.liger'></span><span id='topic+runIntegration.Seurat'></span>

<h3>Description</h3>

<p>LIGER provides dataset integration methods based on iNMF (integrative
Non-negative Matrix Factorization [1]) and its variants (online iNMF [2] and
UINMF [3]). This function wraps <code><a href="#topic+runINMF">runINMF</a></code>,
<code><a href="#topic+runOnlineINMF">runOnlineINMF</a></code> and <code><a href="#topic+runUINMF">runUINMF</a></code>, of which the help
pages have more detailed description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runIntegration(
  object,
  k = 20,
  lambda = 5,
  method = c("iNMF", "onlineINMF", "UINMF"),
  ...
)

## S3 method for class 'liger'
runIntegration(
  object,
  k = 20,
  lambda = 5,
  method = c("iNMF", "onlineINMF", "UINMF"),
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'Seurat'
runIntegration(
  object,
  k = 20,
  lambda = 5,
  method = c("iNMF", "onlineINMF"),
  datasetVar = "orig.ident",
  useLayer = "ligerScaleData",
  assay = NULL,
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runIntegration_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object or a Seurat object with
non-negative scaled data of variable features (Done with
<code><a href="#topic+scaleNotCenter">scaleNotCenter</a></code>).</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_k">k</code></td>
<td>
<p>Inner dimension of factorization (number of factors). Generally, a
higher <code>k</code> will be needed for datasets with more sub-structure. Default
<code>20</code>.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
<code>lambda</code> increases). Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_method">method</code></td>
<td>
<p>iNMF variant algorithm to use for integration. Choose from
<code>"iNMF"</code>, <code>"onlineINMF"</code>, <code>"UINMF"</code>. Default <code>"iNMF"</code>.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and wrapped functions.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_datasetvar">datasetVar</code></td>
<td>
<p>Metadata variable name that stores the dataset source
annotation. Default <code>"orig.ident"</code>.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_uselayer">useLayer</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to retrieve input
non-negative scaled data. Default <code>"ligerScaleData"</code>. For older Seurat,
always retrieve from <code>scale.data</code> slot.</p>
</td></tr>
<tr><td><code id="runIntegration_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated input object. For detail, please refer to the refered method
linked in Description.
</p>


<h3>References</h3>


<ol>
<li><p>Joshua D. Welch and et al., Single-Cell Multi-omic Integration Compares
and Contrasts Features of Brain Cell Identity, Cell, 2019
</p>
</li>
<li><p>Chao Gao and et al., Iterative single-cell multi-omic integration using
online learning, Nat Biotechnol., 2021
</p>
</li>
<li><p>April R. Kriebel and Joshua D. Welch, UINMF performs mosaic integration
of single-cell multi-omic datasets using nonnegative matrix factorization,
Nat. Comm., 2022
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    pbmc &lt;- runIntegration(pbmc)
}
</code></pre>

<hr>
<h2 id='runOnlineINMF'>Perform online iNMF on scaled datasets</h2><span id='topic+runOnlineINMF'></span><span id='topic+runOnlineINMF.liger'></span><span id='topic+runOnlineINMF.Seurat'></span>

<h3>Description</h3>

<p>Perform online integrative non-negative matrix factorization to
represent multiple single-cell datasets in terms of <code class="reqn">H</code>, <code class="reqn">W</code>, and
<code class="reqn">V</code> matrices. It optimizes the iNMF objective function (see
<code><a href="#topic+runINMF">runINMF</a></code>) using online learning (non-negative least squares for
<code class="reqn">H</code> matrices, and hierarchical alternating least squares (HALS) for
<code class="reqn">V</code> matrices and <code class="reqn">W</code>), where the number of factors is set by
<code>k</code>. The function allows online learning in 3 scenarios:
</p>

<ol>
<li><p> Fully observed datasets;
</p>
</li>
<li><p> Iterative refinement using continually arriving datasets;
</p>
</li>
<li><p> Projection of new datasets without updating the existing factorization
</p>
</li></ol>

<p>All three scenarios require fixed memory independent of the number of cells.
</p>
<p>For each dataset, this factorization produces an <code class="reqn">H</code> matrix (k by cell),
a <code class="reqn">V</code> matrix (genes by k), and a shared <code class="reqn">W</code>
matrix (genes by k). The <code class="reqn">H</code> matrices represent the cell factor loadings.
<code class="reqn">W</code> is identical among all datasets, as it represents the shared
components of the metagenes across datasets. The <code class="reqn">V</code> matrices represent
the dataset-specific components of the metagenes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runOnlineINMF(object, k = 20, lambda = 5, ...)

## S3 method for class 'liger'
runOnlineINMF(
  object,
  k = 20,
  lambda = 5,
  newDatasets = NULL,
  projection = FALSE,
  maxEpochs = 5,
  HALSiter = 1,
  minibatchSize = 5000,
  WInit = NULL,
  VInit = NULL,
  AInit = NULL,
  BInit = NULL,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'Seurat'
runOnlineINMF(
  object,
  k = 20,
  lambda = 5,
  datasetVar = "orig.ident",
  layer = "ligerScaleData",
  assay = NULL,
  reduction = "onlineINMF",
  maxEpochs = 5,
  HALSiter = 1,
  minibatchSize = 5000,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runOnlineINMF_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object. Scaled data required.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_k">k</code></td>
<td>
<p>Inner dimension of factorization&ndash;number of metagenes. A value in
the range 20-50 works well for most analyses. Default <code>20</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
lambda increases). We recommend always using the default value except
possibly for analyses with relatively small differences (biological
replicates, male/female comparisons, etc.) in which case a lower value such
as 1.0 may improve reconstruction quality. Default <code>5.0</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_...">...</code></td>
<td>
<p>Arguments passed to other S3 methods of this function.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_newdatasets">newDatasets</code></td>
<td>
<p>Named list of <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>. New datasets for
scenario 2 or scenario 3. Default <code>NULL</code> triggers scenario 1.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_projection">projection</code></td>
<td>
<p>Whether to perform data integration with scenario 3 when
<code>newDatasets</code> is specified. See description. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_maxepochs">maxEpochs</code></td>
<td>
<p>The number of epochs to iterate through. See detail.
Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_halsiter">HALSiter</code></td>
<td>
<p>Maximum number of block coordinate descent (HALS
algorithm) iterations to perform for each update of <code class="reqn">W</code> and <code class="reqn">V</code>.
Default <code>1</code>. Changing this parameter is not recommended.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_minibatchsize">minibatchSize</code></td>
<td>
<p>Total number of cells in each minibatch. See detail.
Default <code>5000</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_winit">WInit</code>, <code id="runOnlineINMF_+3A_vinit">VInit</code>, <code id="runOnlineINMF_+3A_ainit">AInit</code>, <code id="runOnlineINMF_+3A_binit">BInit</code></td>
<td>
<p>Optional initialization for <code class="reqn">W</code>, <code class="reqn">V</code>,
<code class="reqn">A</code>, and <code class="reqn">B</code> matrices, respectively. Must be presented all together.
See detail. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_ncores">nCores</code></td>
<td>
<p>The number of parallel tasks to speed up the computation.
Default <code>2L</code>. Only supported for platform with OpenMP support.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_datasetvar">datasetVar</code></td>
<td>
<p>Metadata variable name that stores the dataset source
annotation. Default <code>"orig.ident"</code>.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_layer">layer</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to retrieve input
non-negative scaled data. Default <code>"ligerScaleData"</code>. For older Seurat,
always retrieve from <code>scale.data</code> slot.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
<tr><td><code id="runOnlineINMF_+3A_reduction">reduction</code></td>
<td>
<p>Name of the reduction to store result. Also used as the
feature key. Default <code>"onlineINMF"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For performing scenario 2 or 3, a complete set of factorization result from
a run of scenario 1 is required. Given the structure of a <a href="#topic+liger-class">liger</a>
object, all of the required information can be retrieved automatically.
Under the circumstance where users need customized information for existing
factorization, arguments <code>WInit</code>, <code>VInit</code>, <code>AInit</code> and
<code>BInit</code> are exposed. The requirements for these argument follows:
</p>

<ul>
<li><p>WInit - A matrix object of size <code class="reqn">m \times k</code>. (see
<code><a href="#topic+runINMF">runINMF</a></code> for notation)
</p>
</li>
<li><p>VInit - A list object of matrices each of size <code class="reqn">m \times k</code>.
Number of matrices should match with <code>newDatasets</code>.
</p>
</li>
<li><p>AInit - A list object of matrices each of size <code class="reqn">k \times k</code>.
Number of matrices should match with <code>newDatasets</code>.
</p>
</li>
<li><p>BInit - A list object of matrices each of size <code class="reqn">m \times k</code>.
Number of matrices should match with <code>newDatasets</code>.
</p>
</li></ul>

<p>Minibatch iterations is performed on small subset of cells. The exact
minibatch size applied on each dataset is <code>minibatchSize</code> multiplied by
the proportion of cells in this dataset out of all cells. In general,
<code>minibatchSize</code> should be no larger than the number of cells in the
smallest dataset (considering both <code>object</code> and <code>newDatasets</code>).
Therefore, a smaller value may be necessary for analyzing very small
datasets.
</p>
<p>An epoch is one completion of calculation on all cells after a number of
iterations of minibatches. Therefore, the total number of iterations is
determined by the setting of <code>maxEpochs</code>, total number of cells, and
<code>minibatchSize</code>.
</p>
<p>Currently, Seurat S3 method does not support working on Scenario 2 and 3,
because there is no simple solution for organizing a number of miscellaneous
matrices with a single Seurat object. We strongly recommend that users create
a <a href="#topic+liger-class">liger</a> object which has the specific structure.
</p>


<h3>Value</h3>


<ul>
<li><p>liger method - Returns updated input <a href="#topic+liger-class">liger</a> object.
</p>

<ul>
<li><p>A list of all <code class="reqn">H</code> matrices can be accessed with
<code>getMatrix(object, "H")</code>
</p>
</li>
<li><p>A list of all <code class="reqn">V</code> matrices can be accessed with
<code>getMatrix(object, "V")</code>
</p>
</li>
<li><p>The <code class="reqn">W</code> matrix can be accessed with
<code>getMatrix(object, "W")</code>
</p>
</li>
<li><p>Meanwhile, intermediate matrices <code class="reqn">A</code> and <code class="reqn">B</code> produced in
HALS update can also be accessed similarly.
</p>
</li></ul>


</li>
<li><p>Seurat method - Returns updated input Seurat object.
</p>

<ul>
<li><p><code class="reqn">H</code> matrices for all datasets will be concatenated and
transposed (all cells by k), and form a DimReduc object in the
<code>reductions</code> slot named by argument <code>reduction</code>.
</p>
</li>
<li><p><code class="reqn">W</code> matrix will be presented as <code>feature.loadings</code> in the
same DimReduc object.
</p>
</li>
<li><p><code class="reqn">V</code> matrices, <code class="reqn">A</code> matrices, <code class="reqn">B</code> matricesm an objective
error value and the dataset variable used for the factorization is
currently stored in <code>misc</code> slot of the same DimReduc object.
</p>
</li></ul>

</li></ul>



<h3>References</h3>

<p>Chao Gao and et al., Iterative single-cell multi-omic integration
using online learning, Nat Biotechnol., 2021
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
if (requireNamespace("RcppPlanc", quietly = TRUE)) {
    # Scenario 1
    pbmc &lt;- runOnlineINMF(pbmc, minibatchSize = 200)
    # Scenario 2
    # Fake new dataset by increasing all non-zero value in "ctrl" by 1
    ctrl2 &lt;- rawData(dataset(pbmc, "ctrl"))
    ctrl2@x &lt;- ctrl2@x + 1
    colnames(ctrl2) &lt;- paste0(colnames(ctrl2), 2)
    pbmc2 &lt;- runOnlineINMF(pbmc, k = 20, newDatasets = list(ctrl2 = ctrl2),
                           minibatchSize = 100)
    # Scenario 3
    pbmc3 &lt;- runOnlineINMF(pbmc, k = 20, newDatasets = list(ctrl2 = ctrl2),
                           projection = TRUE)
}
</code></pre>

<hr>
<h2 id='runPairwiseDEG'>Find DEG between two groups</h2><span id='topic+runPairwiseDEG'></span><span id='topic+runMarkerDEG'></span><span id='topic+runWilcoxon'></span>

<h3>Description</h3>

<p>Find DEG between two groups. Two methods are supported:
<code>"wilcoxon"</code> and <code>"pseudoBulk"</code>. Wilcoxon rank sum test is
performed on single-cell level, while pseudo-bulk method aggregates cells
basing on biological replicates and calls bulk RNAseq DE methods, DESeq2 wald
test. When real biological replicates are not available, pseudo replicates
can be generated. Please see below for detailed scenario usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runPairwiseDEG(
  object,
  groupTest,
  groupCtrl,
  variable1 = NULL,
  variable2 = NULL,
  method = c("wilcoxon", "pseudoBulk"),
  usePeak = FALSE,
  useReplicate = NULL,
  nPsdRep = 5,
  minCellPerRep = 10,
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE)
)

runMarkerDEG(
  object,
  conditionBy = NULL,
  splitBy = NULL,
  method = c("wilcoxon", "pseudoBulk"),
  useDatasets = NULL,
  usePeak = FALSE,
  useReplicate = NULL,
  nPsdRep = 5,
  minCellPerRep = 10,
  seed = 1,
  verbose = getOption("ligerVerbose", TRUE)
)

runWilcoxon(
  object,
  data.use = NULL,
  compare.method = c("clusters", "datasets")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runPairwiseDEG_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object, with normalized data available</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_grouptest">groupTest</code>, <code id="runPairwiseDEG_+3A_groupctrl">groupCtrl</code>, <code id="runPairwiseDEG_+3A_variable1">variable1</code>, <code id="runPairwiseDEG_+3A_variable2">variable2</code></td>
<td>
<p>Condition specification. See
<code>?runPairwiseDEG</code> section <b>Pairwise DEG Scenarios</b> for detail.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_method">method</code></td>
<td>
<p>DEG test method to use. Choose from <code>"wilcoxon"</code> or
<code>"pseudoBulk"</code>. Default <code>"wilcoxon"</code></p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_usepeak">usePeak</code></td>
<td>
<p>Logical. Whether to use peak count instead of gene count.
Only supported when ATAC datasets are involved. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_usereplicate">useReplicate</code></td>
<td>
<p><code>cellMeta</code> variable of biological replicate
annotation. Only used with <code>method = "pseudoBulk"</code>. Default <code>NULL</code>
will create <code>nPsdRep</code> pseudo replicates per group.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_npsdrep">nPsdRep</code></td>
<td>
<p>Number of pseudo replicates to create. Only used when
<code>method = "pseudoBulk", useReplicate = NULL</code>. Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_mincellperrep">minCellPerRep</code></td>
<td>
<p>Numeric, will not make pseudo-bulk for replicate with
less than this number of cells. Default <code>10</code>.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_seed">seed</code></td>
<td>
<p>Random seed to use for pseudo-replicate generation. Default
<code>1</code>.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_conditionby">conditionBy</code></td>
<td>
<p><code>cellMeta</code> variable(s). Marker detection will be
performed for each level of this variable. Multiple variables will be
combined. Default <code>NULL</code> uses default cluster.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_splitby">splitBy</code></td>
<td>
<p>Split data by <code>cellMeta</code> variable(s) here and identify
markers for <code>conditionBy</code> within each chunk. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_usedatasets">useDatasets</code></td>
<td>
<p>Datasets to perform marker detection within. Default
<code>NULL</code> will use all datasets.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_data.use">data.use</code></td>
<td>
<p>Same as <code>useDatasets</code>.</p>
</td></tr>
<tr><td><code id="runPairwiseDEG_+3A_compare.method">compare.method</code></td>
<td>
<p>Choose from <code>"clusters"</code> (default) or
<code>"datasets"</code>. <code>"clusters"</code> compares each cluster against all other
cells, while <code>"datasets"</code> run within each cluster and compare each
dataset against all other datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with DEG information
</p>


<h3>Pairwise DEG Scenarios</h3>

<p>Users can select classes of cells from a variable in <code>cellMeta</code>.
<code>variable1</code> and <code>variable2</code> are used to specify a column in
<code>cellMeta</code>, and <code>groupTest</code> and <code>groupCtrl</code> are used to specify
existing classes from <code>variable1</code> and <code>variable2</code>, respectively.
When <code>variable2</code> is missing, <code>groupCtrl</code> will be considered from
<code>variable1</code>.
</p>
<p>For example, when <code>variable1 = "celltype"</code> and <code>variable2 = NULL</code>,
<code>groupTest</code> and <code>groupCtrl</code> should be valid cell types in
<code>object$celltype</code>.
</p>
<p>When <code>variable1</code> is &quot;celltype&quot; and <code>variable2</code> is &quot;gender&quot;,
<code>groupTest</code> should be a valid cell type from <code>object$celltype</code> and
<code>groupCtrl</code> should be a valid class from <code>object$gender</code>.
</p>
<p>When both <code>variable1</code> and <code>variable2</code> are missing, <code>groupTest</code>
and <code>groupCtrl</code> should be valid index of cells in <code>object</code>.
</p>


<h3>Marker Detection Scenarios</h3>

<p>Marker detection is generally performed in a one vs. rest manner. The
grouping of such condition is specified by <code>conditionBy</code>, which should
be a column name in <code>cellMeta</code>. When <code>splitBy</code> is specified as
another variable name in <code>cellMeta</code>, the marker detection will be
iteratively done for within each level of <code>splitBy</code> variable.
</p>
<p>For example, when <code>conditionBy = "celltype"</code> and <code>splitBy = NULL</code>,
marker detection will be performed by comparing all cells of &quot;celltype_i&quot;
against all other cells, and etc.
</p>
<p>When <code>conditionBy = "celltype"</code> and <code>splitBy = "gender"</code>, marker
detection will be performed by comparing &quot;celltype_i&quot; cells from &quot;gender_j&quot;
against other cells from &quot;gender_j&quot;, and etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compare between cluster "0" and cluster "1"
degStats &lt;- runPairwiseDEG(pbmcPlot, groupTest = 0, groupCtrl = 1,
                           variable1 = "leiden_cluster")
# Compare between all cells from cluster "5" and
# all cells from dataset "stim"
degStats &lt;- runPairwiseDEG(pbmcPlot, groupTest = "5", groupCtrl = "stim",
                           variable1 = "leiden_cluster",
                           variable2 = "dataset")
# Identify markers for each cluster. Equivalent to old version
# `runWilcoxon(method = "cluster")`
markerStats &lt;- runMarkerDEG(pbmcPlot, conditionBy = "leiden_cluster")
# Identify dataset markers within each cluster. Equivalent to old version
# `runWilcoxon(method = "dataset")`.
markerStatsList &lt;- runMarkerDEG(pbmcPlot, conditionBy = "dataset",
                                splitBy = "leiden_cluster")
</code></pre>

<hr>
<h2 id='runTSNE'>Perform t-SNE dimensionality reduction</h2><span id='topic+runTSNE'></span>

<h3>Description</h3>

<p>Runs t-SNE on the quantile normalized cell factors (result from
<code><a href="#topic+quantileNorm">quantileNorm</a></code>), or unnormalized cell factors (result from
<code><a href="#topic+runIntegration">runIntegration</a></code>)) to generate a 2D embedding for visualization.
By default <code><a href="Rtsne.html#topic+Rtsne">Rtsne</a></code> (Barnes-Hut implementation of t-SNE)
method is invoked, while alternative &quot;fftRtsne&quot; method (FFT-accelerated
Interpolation-based t-SNE, using Kluger Lab implementation) is also
supported. For very large datasets, it is recommended to use
<code>method = "fftRtsne"</code> due to its efficiency and scalability.
</p>
<p>Extra external installation steps are required for using &quot;fftRtsne&quot; method.
Please consult
<a href="https://welch-lab.github.io/liger/articles/installation.html">detailed guide</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runTSNE(
  object,
  useRaw = NULL,
  useDims = NULL,
  nDims = 2,
  usePCA = FALSE,
  perplexity = 30,
  theta = 0.5,
  method = c("Rtsne", "fftRtsne"),
  dimredName = "TSNE",
  fitsnePath = NULL,
  seed = 42,
  verbose = getOption("ligerVerbose", TRUE),
  k = nDims,
  use.raw = useRaw,
  dims.use = useDims,
  use.pca = usePCA,
  fitsne.path = fitsnePath,
  rand.seed = seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runTSNE_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object with factorization results.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_useraw">useRaw</code></td>
<td>
<p>Whether to use un-aligned cell factor loadings (<code class="reqn">H</code>
matrices). Default <code>NULL</code> search for quantile-normalized loadings first
and un-aligned loadings then.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_usedims">useDims</code></td>
<td>
<p>Index of factors to use for computing UMAP embedding. Default
<code>NULL</code> uses all factors.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_ndims">nDims</code></td>
<td>
<p>Number of dimensions to reduce to. Default <code>2</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_usepca">usePCA</code></td>
<td>
<p>Whether to perform initial PCA step for Rtsne. Default
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_perplexity">perplexity</code></td>
<td>
<p>Numeric parameter to pass to Rtsne (expected number of
neighbors). Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_theta">theta</code></td>
<td>
<p>Speed/accuracy trade-off (increase for less accuracy), set to
<code>0.0</code> for exact TSNE. Default <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_method">method</code></td>
<td>
<p>Choose from <code>"Rtsne"</code> or <code>"fftRtsne"</code>. See
Description. Default <code>"Rtsne"</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_dimredname">dimredName</code></td>
<td>
<p>Name of the variable in <code>cellMeta</code> slot to store the
result matrix. Default <code>"TSNE"</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_fitsnepath">fitsnePath</code></td>
<td>
<p>Path to the cloned FIt-SNE directory (i.e.
<code>'/path/to/dir/FIt-SNE'</code>). Required only when first time using
<code>runTSNE</code> with <code>method = "fftRtsne"</code>. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility. Default <code>42</code>.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runTSNE_+3A_use.raw">use.raw</code>, <code id="runTSNE_+3A_dims.use">dims.use</code>, <code id="runTSNE_+3A_k">k</code>, <code id="runTSNE_+3A_use.pca">use.pca</code>, <code id="runTSNE_+3A_fitsne.path">fitsne.path</code>, <code id="runTSNE_+3A_rand.seed">rand.seed</code></td>
<td>
<p><b>Deprecated</b>.
See Usage section for replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>object</code> where a <code>"TSNE"</code> variable is updated in the
<code>cellMeta</code> slot with the whole 2D embedding matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runUMAP">runUMAP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- runTSNE(pbmcPlot)
</code></pre>

<hr>
<h2 id='runUINMF'>Perform Mosaic iNMF (UINMF) on scaled datasets with unshared features</h2><span id='topic+runUINMF'></span><span id='topic+runUINMF.liger'></span>

<h3>Description</h3>

<p>Performs mosaic integrative non-negative matrix factorization (UINMF) (A.R.
Kriebel, 2022) using block coordinate descent (alternating non-negative
least squares, ANLS) to return factorized <code class="reqn">H</code>, <code class="reqn">W</code>, <code class="reqn">V</code> and
<code class="reqn">U</code> matrices. The objective function is stated as
</p>
<p style="text-align: center;"><code class="reqn">\arg\min_{H\ge0,W\ge0,V\ge0,U\ge0}\sum_{i}^{d}
||\begin{bmatrix}E_i \\ P_i \end{bmatrix} -
(\begin{bmatrix}W \\ 0 \end{bmatrix}+
\begin{bmatrix}V_i \\ U_i \end{bmatrix})Hi||^2_F+
\lambda_i\sum_{i}^{d}||\begin{bmatrix}V_i \\ U_i \end{bmatrix}H_i||_F^2</code>
</p>

<p>where <code class="reqn">E_i</code> is the input non-negative matrix of the <code class="reqn">i</code>'th dataset,
<code class="reqn">P_i</code> is the input non-negative matrix for the unshared features,
<code class="reqn">d</code> is the total number of datasets. <code class="reqn">E_i</code> is of size
<code class="reqn">m \times n_i</code> for <code class="reqn">m</code> shared features and <code class="reqn">n_i</code> cells, <code class="reqn">P_i</code>
is of size <code class="reqn">u_i \times n_i</code> for <code class="reqn">u_i</code> unshared feaetures,
<code class="reqn">H_i</code> is of size <code class="reqn">k \times n_i</code>, <code class="reqn">V_i</code> is of size
<code class="reqn">m \times k</code>, <code class="reqn">W</code> is of size <code class="reqn">m \times k</code> and <code class="reqn">U_i</code> is of
size <code class="reqn">u_i \times k</code>.
</p>
<p>The factorization produces a shared <code class="reqn">W</code> matrix (genes by k). For each
dataset, an <code class="reqn">H</code> matrix (k by cells), a <code class="reqn">V</code> matrix (genes by k) and
a <code class="reqn">U</code> matrix (unshared genes by k). The <code class="reqn">H</code> matrices represent the
cell factor loadings. <code class="reqn">W</code> is held consistent among all datasets, as it
represents the shared components of the metagenes across datasets. The
<code class="reqn">V</code> matrices represent the dataset-specific components of the metagenes,
<code class="reqn">U</code> matrices are similar to <code class="reqn">V</code>s but represents the loading
contributed by unshared features.
</p>
<p>This function adopts highly optimized fast and memory efficient
implementation extended from Planc (Kannan, 2016). Pre-installation of
extension package <code>RcppPlanc</code> is required. The underlying algorithm
adopts the identical ANLS strategy as <code><a href="#topic+optimizeALS">optimizeALS</a>(unshared =
TRUE)</code> in the old version of LIGER.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runUINMF(object, k = 20, lambda = 5, ...)

## S3 method for class 'liger'
runUINMF(
  object,
  k = 20,
  lambda = 5,
  nIteration = 30,
  nRandomStarts = 1,
  seed = 1,
  nCores = 2L,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runUINMF_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object. Should run
<code><a href="#topic+selectGenes">selectGenes</a></code> with <code>unshared = TRUE</code> and then run
<code><a href="#topic+scaleNotCenter">scaleNotCenter</a></code> in advance.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_k">k</code></td>
<td>
<p>Inner dimension of factorization (number of factors). Generally, a
higher <code>k</code> will be needed for datasets with more sub-structure. Default
<code>20</code>.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter. Larger values penalize
dataset-specific effects more strongly (i.e. alignment should increase as
<code>lambda</code> increases). Default <code>5</code>.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods and wrapped functions.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_niteration">nIteration</code></td>
<td>
<p>Total number of block coordinate descent iterations to
perform. Default <code>30</code>.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_nrandomstarts">nRandomStarts</code></td>
<td>
<p>Number of restarts to perform (iNMF objective function
is non-convex, so taking the best objective from multiple successive
initialization is recommended). For easier reproducibility, this increments
the random seed by 1 for each consecutive restart, so future factorization
of the same dataset can be run with one rep if necessary. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_seed">seed</code></td>
<td>
<p>Random seed to allow reproducible results. Default <code>1</code>.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_ncores">nCores</code></td>
<td>
<p>The number of parallel tasks to speed up the computation.
Default <code>2L</code>. Only supported for platform with OpenMP support.</p>
</td></tr>
<tr><td><code id="runUINMF_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>liger method - Returns updated input <a href="#topic+liger-class">liger</a> object.
</p>

<ul>
<li><p>A list of all <code class="reqn">H</code> matrices can be accessed with
<code>getMatrix(object, "H")</code>
</p>
</li>
<li><p>A list of all <code class="reqn">V</code> matrices can be accessed with
<code>getMatrix(object, "V")</code>
</p>
</li>
<li><p>The <code class="reqn">W</code> matrix can be accessed with
<code>getMatrix(object, "W")</code>
</p>
</li>
<li><p>A list of all <code class="reqn">U</code> matrices can be accessed with
<code>getMatrix(object, "U")</code>
</p>
</li></ul>


</li></ul>



<h3>Note</h3>

<p>Currently, Seurat S3 method is not supported for UINMF because there is no
simple solution for organizing a number of miscellaneous matrices with a
single Seurat object. We strongly recommend that users create a
<a href="#topic+liger-class">liger</a> object which has the specific structure.
</p>


<h3>References</h3>

<p>April R. Kriebel and Joshua D. Welch, UINMF performs mosaic
integration of single-cell multi-omic datasets using nonnegative matrix
factorization, Nat. Comm., 2022
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc, useUnsharedDatasets = c("ctrl", "stim"))
pbmc &lt;- scaleNotCenter(pbmc)
if (!is.null(getMatrix(pbmc, "scaleUnsharedData", "ctrl")) &amp;&amp;
    !is.null(getMatrix(pbmc, "scaleUnsharedData", "stim"))) {
    # TODO: unshared variable features cannot be detected from this example
    pbmc &lt;- runUINMF(pbmc)
}
</code></pre>

<hr>
<h2 id='runUMAP'>Perform UMAP Dimensionality Reduction</h2><span id='topic+runUMAP'></span>

<h3>Description</h3>

<p>Run UMAP on the quantile normalized cell factors (result from
<code><a href="#topic+quantileNorm">quantileNorm</a></code>), or unnormalized cell factors (result from
<code><a href="#topic+runIntegration">runIntegration</a></code>)) to generate a 2D embedding for visualization
(or general dimensionality reduction). Has option to run on subset of
factors. It is generally recommended to use this method for dimensionality
reduction with extremely large datasets. The underlying UMAP calculation
imports uwot <code><a href="uwot.html#topic+umap">umap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runUMAP(
  object,
  useRaw = NULL,
  useDims = NULL,
  nDims = 2,
  distance = c("cosine", "euclidean", "manhattan", "hamming"),
  nNeighbors = 20,
  minDist = 0.1,
  dimredName = "UMAP",
  seed = 42,
  verbose = getOption("ligerVerbose", TRUE),
  k = nDims,
  use.raw = useRaw,
  dims.use = useDims,
  n_neighbors = nNeighbors,
  min_dist = minDist,
  rand.seed = seed
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runUMAP_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object with factorization results.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_useraw">useRaw</code></td>
<td>
<p>Whether to use un-aligned cell factor loadings (<code class="reqn">H</code>
matrices). Default <code>NULL</code> search for quantile-normalized loadings first
and un-aligned loadings then.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_usedims">useDims</code></td>
<td>
<p>Index of factors to use for computing UMAP embedding. Default
<code>NULL</code> uses all factors.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_ndims">nDims</code></td>
<td>
<p>Number of dimensions to reduce to. Default <code>2</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_distance">distance</code></td>
<td>
<p>Character. Metric used to measure distance in the input
space. Default <code>"cosine"</code>, alternative options include:
<code>"euclidean"</code>, <code>"manhattan"</code> and <code>"hamming"</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_nneighbors">nNeighbors</code></td>
<td>
<p>Number of neighboring points used in local approximations
of manifold structure. Default <code>10</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_mindist">minDist</code></td>
<td>
<p>Numeric. Controls how tightly the embedding is allowed
compress points together. Default <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_dimredname">dimredName</code></td>
<td>
<p>Name of the variable in <code>cellMeta</code> slot to store the
result matrix. Default <code>"UMAP"</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_seed">seed</code></td>
<td>
<p>Random seed for reproducibility. Default <code>42</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_k">k</code>, <code id="runUMAP_+3A_use.raw">use.raw</code>, <code id="runUMAP_+3A_dims.use">dims.use</code>, <code id="runUMAP_+3A_n_neighbors">n_neighbors</code>, <code id="runUMAP_+3A_min_dist">min_dist</code>, <code id="runUMAP_+3A_rand.seed">rand.seed</code></td>
<td>
<p><b>Deprecated</b>.
See Usage section for replacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>nNeighbors</code>, larger values will result in more global
structure being preserved at the loss of detailed local structure. In general
this parameter should often be in the range 5 to 50, with a choice of 10 to
15 being a sensible default.
</p>
<p>For <code>minDist</code>, larger values ensure embedded points are more evenly
distributed, while smaller values allow the algorithm to optimize more
accurately with regard to local structure. Sensible values are in the range
0.001 to 0.5, with 0.1 being a reasonable default.
</p>


<h3>Value</h3>

<p>The <code>object</code> where a <code>"UMAP"</code> variable is updated in the
<code>cellMeta</code> slot with the whole 2D embedding matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+runTSNE">runTSNE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- runUMAP(pbmcPlot)
</code></pre>

<hr>
<h2 id='scaleNotCenter'>Scale genes by root-mean-square across cells</h2><span id='topic+scaleNotCenter'></span><span id='topic+scaleNotCenter.dgCMatrix'></span><span id='topic+scaleNotCenter.ligerDataset'></span><span id='topic+scaleNotCenter.ligerMethDataset'></span><span id='topic+scaleNotCenter.liger'></span><span id='topic+scaleNotCenter.Seurat'></span>

<h3>Description</h3>

<p>This function scales normalized gene expression data after
variable genes have been selected. We do not mean-center the data before
scaling in order to address the non-negativity constraint of NMF.
Computation applied to each normalized dataset matrix can form the following
equation:
</p>
<p style="text-align: center;"><code class="reqn">S_{i,j}=\frac{N_{i,j}}{\sqrt{\sum_{p}^{n}\frac{N_{i,p}^2}{n-1}}}</code>
</p>

<p>Where <code class="reqn">N</code> denotes the normalized matrix for an individual dataset,
<code class="reqn">S</code> is the output scaled matrix for this dataset, and <code class="reqn">n</code> is the
number of cells in this dataset. <code class="reqn">i, j</code> denotes the specific gene and
cell index, and <code class="reqn">p</code> is the cell iterator.
</p>
<p>Please see detailed section below for explanation on methylation dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleNotCenter(object, ...)

## S3 method for class 'dgCMatrix'
scaleNotCenter(object, ...)

## S3 method for class 'ligerDataset'
scaleNotCenter(
  object,
  features = NULL,
  chunk = 1000,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'ligerMethDataset'
scaleNotCenter(
  object,
  features = NULL,
  verbose = getOption("ligerVerbose", TRUE),
  ...
)

## S3 method for class 'liger'
scaleNotCenter(
  object,
  useDatasets = NULL,
  features = varFeatures(object),
  verbose = getOption("ligerVerbose", TRUE),
  remove.missing = NULL,
  ...
)

## S3 method for class 'Seurat'
scaleNotCenter(
  object,
  assay = NULL,
  layer = "ligerNormData",
  save = "ligerScaleData",
  datasetVar = "orig.ident",
  features = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scaleNotCenter_+3A_object">object</code></td>
<td>
<p><a href="#topic+liger-class">liger</a> object, <a href="#topic+ligerDataset-class">ligerDataset</a> object,
<a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>, or a Seurat object.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods. The order goes by: &quot;liger&quot;
method calls &quot;ligerDataset&quot; method&quot;, which then calls &quot;dgCMatrix&quot; method.
&quot;Seurat&quot; method directly calls &quot;dgCMatrix&quot; method.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_features">features</code></td>
<td>
<p>Character, numeric or logical index that choose the variable
feature to be scaled. &quot;liger&quot; method by default uses
<code><a href="#topic+varFeatures">varFeatures</a>(object)</code>. &quot;ligerDataset&quot; method by default uses all
features. &quot;Seurat&quot; method by default uses
<code><a href="SeuratObject.html#topic+VariableFeatures">VariableFeatures</a>(object)</code>.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_chunk">chunk</code></td>
<td>
<p>Integer. Number of maximum number of cells in each chunk, when
scaling is applied to any HDF5 based dataset. Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to be scaled but not centered. Default
<code>NULL</code> applies to all datasets.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_remove.missing">remove.missing</code></td>
<td>
<p><b>Deprecated</b>. The functionality of this is covered
through other parts of the whole workflow and is no long needed. Will be
ignored if specified.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_layer">layer</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to retrieve normalized
data. Default <code>"ligerNormData"</code>. For older Seurat, always retrieve from
<code>data</code> slot.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_save">save</code></td>
<td>
<p>For Seurat&gt;=4.9.9, the name of layer to store normalized data.
Default <code>"ligerScaleData"</code>. For older Seurat, stored to
<code>scale.data</code> slot.</p>
</td></tr>
<tr><td><code id="scaleNotCenter_+3A_datasetvar">datasetVar</code></td>
<td>
<p>Metadata variable name that stores the dataset source
annotation. Default <code>"orig.ident"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated <code>object</code>
</p>

<ul>
<li><p>dgCMatrix method - Returns scaled dgCMatrix object
</p>
</li>
<li><p>ligerDataset method - Updates the <code>scaleData</code> and
<code>scaledUnsharedData</code> (if unshared variable feature available) slot
of the object
</p>
</li>
<li><p>liger method - Updates the <code>scaleData</code> and
<code>scaledUnsharedData</code> (if unshared variable feature available) slot
of chosen datasets
</p>
</li>
<li><p>Seurat method - Adds a named layer in chosen assay (V5), or update the
<code>scale.data</code> slot of the chosen assay (&lt;=V4)
</p>
</li></ul>



<h3>Methylation dataset</h3>

<p>Because gene body mCH proportions are negatively correlated with gene
expression level in neurons, we need to reverse the direction of the
methylation data before performing the integration. We do this by simply
subtracting all values from the maximum methylation value. The resulting
values are positively correlated with gene expression. This will only be
applied to variable genes detected in prior. Please make sure that argument
<code>modal</code> is set accordingly when running <code><a href="#topic+createLiger">createLiger</a></code>. In
this way, this function can automatically detect it and take proper action.
If it is not set, users can still manually have the equivalent processing
done by doing <code>scaleNotCenter(lig, useDataset = c("other", "datasets"))</code>,
and then <code><a href="#topic+reverseMethData">reverseMethData</a>(lig, useDataset = c("meth", "datasets"))</code>.
</p>


<h3>Note</h3>

<p>Since the scaling on genes is applied on a per dataset base, other scaling
methods that apply to a whole concatenated matrix of multiple datasets might
not be considered as equivalent alternatives, even if options like
<code>center</code> are set to <code>FALSE</code>. Hence we implemented an efficient
solution that works under such circumstance, provided with the Seurat S3
method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
pbmc &lt;- selectGenes(pbmc)
pbmc &lt;- scaleNotCenter(pbmc)
</code></pre>

<hr>
<h2 id='selectGenes'>Select a subset of informative genes</h2><span id='topic+selectGenes'></span><span id='topic+selectGenes.liger'></span><span id='topic+selectGenes.Seurat'></span>

<h3>Description</h3>

<p>This function identifies highly variable genes from each dataset
and combines these gene sets (either by union or intersection) for use in
downstream analysis. Assuming that gene expression approximately follows a
Poisson distribution, this function identifies genes with gene expression
variance above a given variance threshold (relative to mean gene expression).
Alternatively, we allow selecting a desired number of genes for each dataset
by ranking the relative variance, and then take the combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectGenes(object, thresh = 0.1, nGenes = NULL, alpha = 0.99, ...)

## S3 method for class 'liger'
selectGenes(
  object,
  thresh = 0.1,
  nGenes = NULL,
  alpha = 0.99,
  useDatasets = NULL,
  useUnsharedDatasets = NULL,
  unsharedThresh = 0.1,
  combine = c("union", "intersection"),
  chunk = 1000,
  verbose = getOption("ligerVerbose", TRUE),
  var.thresh = thresh,
  alpha.thresh = alpha,
  num.genes = nGenes,
  datasets.use = useDatasets,
  unshared.datasets = useUnsharedDatasets,
  unshared.thresh = unsharedThresh,
  tol = NULL,
  do.plot = NULL,
  cex.use = NULL,
  unshared = NULL,
  ...
)

## S3 method for class 'Seurat'
selectGenes(
  object,
  thresh = 0.1,
  nGenes = NULL,
  alpha = 0.99,
  useDatasets = NULL,
  layer = "ligerNormData",
  assay = NULL,
  datasetVar = "orig.ident",
  combine = c("union", "intersection"),
  verbose = getOption("ligerVerbose", TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectGenes_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a>, <a href="#topic+ligerDataset-class">ligerDataset</a> or
<code>Seurat</code> object, with normalized data available (no scale factor
multipled nor log transformed).</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_thresh">thresh</code></td>
<td>
<p>Variance threshold used to identify variable genes. Higher
threshold results in fewer selected genes. Liger and Seurat S3 methods accept
a single value or a vector with specific threshold for each dataset in
<code>useDatasets</code>.* Default <code>0.1</code>.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_ngenes">nGenes</code></td>
<td>
<p>Number of genes to find for each dataset. By setting this,
we optimize the threshold used for each dataset so that we get <code>nGenes</code>
selected features for each dataset. Accepts single value or a vector for
dataset specific setting matching <code>useDataset</code>.* Default <code>NULL</code>
does not optimize.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_alpha">alpha</code></td>
<td>
<p>Alpha threshold. Controls upper bound for expected mean gene
expression. Lower threshold means higher upper bound. Default <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_...">...</code></td>
<td>
<p>Arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_usedatasets">useDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or logical
vector of the index of the datasets to use for shared variable feature
selection. Default <code>NULL</code> uses all datasets.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_useunshareddatasets">useUnsharedDatasets</code></td>
<td>
<p>A character vector of the names, a numeric or
logical vector of the index of the datasets to use for finding unshared
variable features. Default <code>NULL</code> does not attempt to find unshared
features.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_unsharedthresh">unsharedThresh</code></td>
<td>
<p>The same thing as <code>thresh</code> that is applied to test
unshared features. A single value for all datasets in
<code>useUnsharedDatasets</code> or a vector for dataset-specific setting.* Default
<code>0.1</code>.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_combine">combine</code></td>
<td>
<p>How to combine variable genes selected from all datasets.
Choose from <code>"union"</code> or <code>"intersection"</code>. Default <code>"union"</code>.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_chunk">chunk</code></td>
<td>
<p>Integer. Number of maximum number of cells in each chunk, when
gene selection is applied to any HDF5 based dataset. Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_var.thresh">var.thresh</code>, <code id="selectGenes_+3A_alpha.thresh">alpha.thresh</code>, <code id="selectGenes_+3A_num.genes">num.genes</code>, <code id="selectGenes_+3A_datasets.use">datasets.use</code>, <code id="selectGenes_+3A_unshared.datasets">unshared.datasets</code>, <code id="selectGenes_+3A_unshared.thresh">unshared.thresh</code></td>
<td>
<p><b>Deprecated</b>.
These arguments are renamed and will be removed in the future. Please see
function usage for replacement.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_tol">tol</code>, <code id="selectGenes_+3A_do.plot">do.plot</code>, <code id="selectGenes_+3A_cex.use">cex.use</code>, <code id="selectGenes_+3A_unshared">unshared</code></td>
<td>
<p><b>Deprecated</b>. Gene variability
metric is now visualized with separated function
<code><a href="#topic+plotVarFeatures">plotVarFeatures</a></code>. Users can now set none-NULL
<code>useUnsharedDatasets</code> to select unshared genes, instead of having to
switch <code>unshared</code> on.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_layer">layer</code></td>
<td>
<p>Where the input normalized counts should be from. Default
<code>"ligerNormData"</code>. For older Seurat, always retrieve from <code>data</code>
slot.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_assay">assay</code></td>
<td>
<p>Name of assay to use. Default <code>NULL</code> uses current active
assay.</p>
</td></tr>
<tr><td><code id="selectGenes_+3A_datasetvar">datasetVar</code></td>
<td>
<p>Metadata variable name that stores the dataset source
annotation. Default <code>"orig.ident"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated object
</p>

<ul>
<li><p>liger method - Each involved dataset stored in
<a href="#topic+ligerDataset-class">ligerDataset</a> is updated with its <code><a href="#topic+featureMeta">featureMeta</a></code>
slot and <code>varUnsharedFeatures</code> slot (if requested with
<code>useUnsharedDatasets</code>), while <code><a href="#topic+varFeatures">varFeatures</a>(object)</code> will be
updated with the final combined gene set.
</p>
</li>
<li><p>Seurat method - Final selection will be updated at
<code>Seurat::VariableFeatures(object)</code>. Per-dataset information is
stored in the <code>meta.features</code> slot of the chosen Assay.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- normalize(pbmc)
# Select basing on thresholding the relative variance
pbmc &lt;- selectGenes(pbmc, thresh = .1)
# Select specified number for each dataset
pbmc &lt;- selectGenes(pbmc, nGenes = c(60, 60))
</code></pre>

<hr>
<h2 id='selectGenesVST'>Select variable genes from one dataset with Seurat VST method</h2><span id='topic+selectGenesVST'></span>

<h3>Description</h3>

<p>Seurat FindVariableFeatures VST method. This allows the selection of a fixed
number of variable features, but only applies to one dataset. No
normalization is needed in advance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectGenesVST(
  object,
  useDataset,
  n = 2000,
  loessSpan = 0.3,
  clipMax = "auto",
  useShared = TRUE,
  verbose = getOption("ligerVerbose", TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectGenesVST_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object.</p>
</td></tr>
<tr><td><code id="selectGenesVST_+3A_usedataset">useDataset</code></td>
<td>
<p>The names, a numeric or logical index of the dataset to
be considered for selection.</p>
</td></tr>
<tr><td><code id="selectGenesVST_+3A_n">n</code></td>
<td>
<p>Number of variable features needed. Default <code>2000</code>.</p>
</td></tr>
<tr><td><code id="selectGenesVST_+3A_loessspan">loessSpan</code></td>
<td>
<p>Loess span parameter used when fitting the variance-mean
relationship. Default <code>0.3</code>.</p>
</td></tr>
<tr><td><code id="selectGenesVST_+3A_clipmax">clipMax</code></td>
<td>
<p>After standardization values larger than <code>clipMax</code> will
be set to <code>clipMax</code>. Default <code>"auto"</code> sets this value to the square
root of the number of cells.</p>
</td></tr>
<tr><td><code id="selectGenesVST_+3A_useshared">useShared</code></td>
<td>
<p>Logical. Whether to only select from genes shared by all
dataset. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="selectGenesVST_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Seurat::FindVariableFeatures.default(selection.method = &quot;vst&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc &lt;- selectGenesVST(pbmc, "ctrl", n = 50)
</code></pre>

<hr>
<h2 id='sub-liger'>Subset liger with brackets</h2><span id='topic+sub-liger'></span><span id='topic++5B.liger'></span>

<h3>Description</h3>

<p>Subset liger with brackets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'liger'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub-liger_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="sub-liger_+3A_i">i</code></td>
<td>
<p>Feature subscriptor, passed to <code>featureIdx</code> of
<code><a href="#topic+subsetLiger">subsetLiger</a></code>.</p>
</td></tr>
<tr><td><code id="sub-liger_+3A_j">j</code></td>
<td>
<p>Cell subscriptor, passed to <code>cellIdx</code> of
<code><a href="#topic+subsetLiger">subsetLiger</a></code>.</p>
</td></tr>
<tr><td><code id="sub-liger_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+subsetLiger">subsetLiger</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subset of <code>x</code> with specified features and cells.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subsetLiger">subsetLiger</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmcPlot[varFeatures(pbmcPlot)[1:10], 1:10]
</code></pre>

<hr>
<h2 id='sub-ligerDataset'>Subset ligerDataset object</h2><span id='topic+sub-ligerDataset'></span><span id='topic++5B.ligerDataset'></span>

<h3>Description</h3>

<p>Subset ligerDataset object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ligerDataset'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub-ligerDataset_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+ligerDataset-class">ligerDataset</a> object</p>
</td></tr>
<tr><td><code id="sub-ligerDataset_+3A_i">i</code></td>
<td>
<p>Numeric, logical index or character vector of feature names to
subscribe. Leave missing for all features.</p>
</td></tr>
<tr><td><code id="sub-ligerDataset_+3A_j">j</code></td>
<td>
<p>Numeric, logical index or character vector of cell IDs to subscribe.
Leave missing for all cells.</p>
</td></tr>
<tr><td><code id="sub-ligerDataset_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+subsetLigerDataset">subsetLigerDataset</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>i</code> is given, the selected metadata will be returned; if it
is missing, the whole cell metadata table in
<code>S4Vectors::<a href="S4Vectors.html#topic+DataFrame">DataFrame</a></code> class will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- dataset(pbmc, "ctrl")
ctrl[1:5, 1:5]
</code></pre>

<hr>
<h2 id='sub-sub-liger'>Get cell metadata variable</h2><span id='topic+sub-sub-liger'></span><span id='topic++5B+5B.liger'></span>

<h3>Description</h3>

<p>Get cell metadata variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'liger'
x[[i, ...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub-sub-liger_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> object</p>
</td></tr>
<tr><td><code id="sub-sub-liger_+3A_i">i</code></td>
<td>
<p>Name or numeric index of cell meta data to fetch</p>
</td></tr>
<tr><td><code id="sub-sub-liger_+3A_...">...</code></td>
<td>
<p>Anything that <code>S4Vectors::<a href="S4Vectors.html#topic+DataFrame">DataFrame</a></code>
method allows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>i</code> is given, the selected metadata will be returned; if it
is missing, the whole cell metadata table in
<code>S4Vectors::<a href="S4Vectors.html#topic+DataFrame">DataFrame</a></code> class will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Retrieve whole cellMeta
pbmc[[]]
# Retrieve a variable
pbmc[["dataset"]]
</code></pre>

<hr>
<h2 id='subsetLiger'>Subset liger object</h2><span id='topic+subsetLiger'></span>

<h3>Description</h3>

<p>This function subsets a <a href="#topic+liger-class">liger</a> object with
character feature index and any valid cell index. For datasets based on HDF5,
the filenames of subset H5 files could only be automatically generated for
now. Feature subsetting is based on the intersection of available features
from datasets involved by <code>cellIdx</code>, while <code>featureIdx = NULL</code> does
not take the intersection (i.e. nothing done on the feature axis).
</p>
<p>a <a href="#topic+ligerDataset-class">ligerDataset</a> object is also allowed for now and meanwhile,
setting <code>filename</code> is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetLiger(
  object,
  featureIdx = NULL,
  cellIdx = NULL,
  useSlot = NULL,
  chunkSize = 1000,
  verbose = getOption("ligerVerbose", TRUE),
  newH5 = TRUE,
  returnObject = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetLiger_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+liger-class">liger</a> or <a href="#topic+ligerDataset-class">ligerDataset</a> object.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_featureidx">featureIdx</code></td>
<td>
<p>Character vector. Missing or <code>NULL</code> for all
features.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_cellidx">cellIdx</code></td>
<td>
<p>Character, logical or numeric index that can subscribe cells.
Missing or <code>NULL</code> for all cells.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_useslot">useSlot</code></td>
<td>
<p>The slot(s) to only consider. Choose one or more from
<code>"rawData"</code>, <code>"normData"</code> and <code>"scaleData"</code>. Default
<code>NULL</code> subsets the whole object including analysis result matrices.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_chunksize">chunkSize</code></td>
<td>
<p>Integer. Number of maximum number of cells in each chunk,
Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_newh5">newH5</code></td>
<td>
<p>Whether to create new H5 files on disk for the subset datasets
if involved datasets in the <code>object</code> is HDF5 based. <code>TRUE</code> writes a
new ones, <code>FALSE</code> returns in memory data.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_returnobject">returnObject</code></td>
<td>
<p>Logical, whether to return a <a href="#topic+liger-class">liger</a> object
for result. Default <code>TRUE</code>. <code>FALSE</code> returns a list containing
requested values.</p>
</td></tr>
<tr><td><code id="subsetLiger_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>subsetLigerDataset</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subset <code>object</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+subsetLigerDataset">subsetLigerDataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pbmc.small &lt;- subsetLiger(pbmc, cellIdx = pbmc$nUMI &gt; 200)
pbmc.small &lt;- pbmc[, pbmc$nGene &gt; 50]
</code></pre>

<hr>
<h2 id='subsetLigerDataset'>Subset ligerDataset object</h2><span id='topic+subsetLigerDataset'></span><span id='topic+subsetH5LigerDataset'></span><span id='topic+subsetMemLigerDataset'></span>

<h3>Description</h3>

<p>This function subsets a <a href="#topic+ligerDataset-class">ligerDataset</a> object with
valid feature and cell indices. For HDF5 based object, options are available
for subsetting data into memory or a new on-disk H5 file. Feature and cell
subscription is always based on the size of rawData. Therefore, the feature
subsetting on scaled data, which usually contains already a subset of
features, will select the intersection between the wanted features and the
set available from scaled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetLigerDataset(
  object,
  featureIdx = NULL,
  cellIdx = NULL,
  useSlot = NULL,
  newH5 = TRUE,
  filename = NULL,
  filenameSuffix = NULL,
  chunkSize = 1000,
  verbose = getOption("ligerVerbose", TRUE),
  returnObject = TRUE,
  ...
)

subsetH5LigerDataset(
  object,
  featureIdx = NULL,
  cellIdx = NULL,
  useSlot = NULL,
  newH5 = TRUE,
  filename = NULL,
  filenameSuffix = NULL,
  chunkSize = 1000,
  verbose = getOption("ligerVerbose", TRUE),
  returnObject = TRUE
)

subsetMemLigerDataset(
  object,
  featureIdx = NULL,
  cellIdx = NULL,
  useSlot = NULL,
  returnObject = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetLigerDataset_+3A_object">object</code></td>
<td>
<p><a href="#topic+ligerDataset-class">ligerDataset</a> object. HDF5 based object if using
<code>subsetH5LigerDataset</code>, in-memory data for <code>subsetMemLigerDataset</code>.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_featureidx">featureIdx</code></td>
<td>
<p>Character, logical or numeric index that can subscribe
features. Missing or <code>NULL</code> for all features.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_cellidx">cellIdx</code></td>
<td>
<p>Character, logical or numeric index that can subscribe cells.
Missing or <code>NULL</code> for all cells.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_useslot">useSlot</code></td>
<td>
<p>The slot(s) to only consider. Choose one or more from
<code>"rawData"</code>, <code>"normData"</code> and <code>"scaleData"</code>. Default
<code>NULL</code> subsets the whole object including analysis result matrices.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_newh5">newH5</code></td>
<td>
<p>Whether to create a new H5 file on disk for the subset dataset
if <code>object</code> is HDF5 based. <code>TRUE</code> writes a new one, <code>FALSE</code>
returns in memory data.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_filename">filename</code></td>
<td>
<p>Filename of the new H5 file if being created. Default
<code>NULL</code> adds suffix <code>".subset_{yymmdd_HHMMSS}.h5"</code> to the original
name.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_filenamesuffix">filenameSuffix</code></td>
<td>
<p>Instead of specifying the exact filename, set a suffix
for the new files so the new filename looks like
<code>original.h5.[suffix].h5</code>. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_chunksize">chunkSize</code></td>
<td>
<p>Integer. Number of maximum number of cells in each chunk,
Default <code>1000</code>.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Whether to show information of the progress. Default
<code>getOption("ligerVerbose")</code> or <code>TRUE</code> if users have not set.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_returnobject">returnObject</code></td>
<td>
<p>Logical, whether to return a <a href="#topic+ligerDataset-class">ligerDataset</a>
object for result. Default <code>TRUE</code>. <code>FALSE</code> returns a list
containing requested values.</p>
</td></tr>
<tr><td><code id="subsetLigerDataset_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>subsetH5LigerDataset</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Subset <code>object</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ctrl &lt;- dataset(pbmc, "ctrl")
ctrl.small &lt;- subsetLigerDataset(ctrl, cellIdx = 1:5)
ctrl.tiny &lt;- ctrl[1:5, 1:5]
</code></pre>

<hr>
<h2 id='writeH5'>Write in-memory data into H5 file</h2><span id='topic+writeH5'></span><span id='topic+writeH5.default'></span><span id='topic+writeH5.dgCMatrix'></span><span id='topic+writeH5.ligerDataset'></span><span id='topic+writeH5.liger'></span>

<h3>Description</h3>

<p>This function writes in-memory data into H5 file by default in 10x cellranger
HDF5 output format. The main goal of this function is to allow users to
integrate large H5-based dataset, that cannot be fully loaded into memory,
with other data already loaded in memory using <code><a href="#topic+runOnlineINMF">runOnlineINMF</a></code>.
In this case, users can write the smaller in-memory data to H5 file instead
of loading subset of the large H5-based dataset into memory, where
information might be lost.
</p>
<p>Basing on the goal of the whole workflow, the data will always be written
in a CSC matrix format and colnames/rownames are always required.
</p>
<p>The default method coerces the input to a <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a>. Methods
for other container classes tries to extract proper data and calls the
default method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeH5(x, file, ...)

## Default S3 method:
writeH5(x, file, ...)

## S3 method for class 'dgCMatrix'
writeH5(
  x,
  file,
  overwrite = FALSE,
  indicesPath = "matrix/indices",
  indptrPath = "matrix/indptr",
  dataPath = "matrix/data",
  shapePath = "matrix/shape",
  barcodesPath = "matrix/barcodes",
  featuresPath = "matrix/features/name",
  ...
)

## S3 method for class 'ligerDataset'
writeH5(x, file, ...)

## S3 method for class 'liger'
writeH5(x, file, useDatasets, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeH5_+3A_x">x</code></td>
<td>
<p>An object with in-memory data to be written into H5 file.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_file">file</code></td>
<td>
<p>A character string of the file path to be written.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_...">...</code></td>
<td>
<p>Arguments passed to other S3 methods.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical, whether to overwrite the file if it already exists.
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_indicespath">indicesPath</code>, <code id="writeH5_+3A_indptrpath">indptrPath</code>, <code id="writeH5_+3A_datapath">dataPath</code></td>
<td>
<p>The paths inside the H5 file where
the <a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a> constructor <code>i</code>, <code>p</code>, and <code>x</code> will
be written to, respectively. Default using cellranger convention
<code>"matrix/indices"</code>, <code>"matrix/indptr"</code>, and <code>"matrix/data"</code>.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_shapepath">shapePath</code></td>
<td>
<p>The path inside the H5 file where the shape of the matrix
will be written to. Default <code>"matrix/shape"</code>.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_barcodespath">barcodesPath</code></td>
<td>
<p>The path inside the H5 file where the barcodes/colnames
will be written to. Default <code>"matrix/barcodes"</code>. Skipped if the object
does not have colnames.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_featurespath">featuresPath</code></td>
<td>
<p>The path inside the H5 file where the features/rownames
will be written to. Default <code>"matrix/features/name"</code>. Skipped if the
object does not have rownames.</p>
</td></tr>
<tr><td><code id="writeH5_+3A_usedatasets">useDatasets</code></td>
<td>
<p>For liger method. Names or indices of datasets to be
written to H5 files. Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is returned. H5 file will be created on disk.
</p>


<h3>See Also</h3>

<p><a href="https://www.10xgenomics.com/cn/support/software/cell-ranger/latest/analysis/outputs/cr-outputs-h5-matrices">10X cellranger H5 matrix detail</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>raw &lt;- rawData(pbmc, "ctrl")
writeH5(raw, tempfile(pattern = "ctrl_", fileext = ".h5"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
