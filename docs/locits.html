<!DOCTYPE html><html lang="en"><head><title>Help for package locits</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {locits}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#locits-package'><p>New test of second-order stationarity and confidence intervals</p>
for localized autocovariance.</a></li>
<li><a href='#AutoBestBW'><p>Choose a good bandwidth for running mean smoothing of a EWS</p>
spectral estimator.</a></li>
<li><a href='#covI'><p>Compute the covariance between two wavelet periodogram</p>
ordinates at the same scale, but different time locations.</a></li>
<li><a href='#covIwrap'>
<p>A wrapper for the covI function.</p></a></li>
<li><a href='#Cvarip2'><p>Computes variance of Haar wavelet coefficients of</p>
wavelet periodogram using C code.</a></li>
<li><a href='#EstBetaCov'><p>Compute estimate of wavelet periodogram and the estimate's</p>
covariance matrix.</a></li>
<li><a href='#ewspec3'><p>Compute evolutionary wavelet spectrum of a time series.</p></a></li>
<li><a href='#ewspecHaarNonPer'><p>Compute evolutionary wavelet spectrum (EWS) estimate based</p>
on the Haar wavelet transform.</a></li>
<li><a href='#getridofendNA'><p>Replaces all NAs in vector by 0</p></a></li>
<li><a href='#HwdS'>
<p>Compute the non-decimated Haar wavelet transform without</p>
using periodic boundary conditions.</a></li>
<li><a href='#hwt'><p>Compute a Haar wavelet transform for data of arbitrary n length</p></a></li>
<li><a href='#hwtos'><p>Haar wavelet test for (second-order) stationarity for arbitrary length time series.</p>
</p></a></li>
<li><a href='#hwtos2'><p>Test of second-order stationarity using wavelets.</p></a></li>
<li><a href='#idlastzero'><p>Return the index of the last zero in a vector</p></a></li>
<li><a href='#lacf'><p>Compute localized autocovariance.</p></a></li>
<li><a href='#littlevar'><p>Subsidiary helper function for hwtos2</p></a></li>
<li><a href='#mkcoef'><p>Compute discrete wavelets.</p></a></li>
<li><a href='#plot.hwtANYN'><p>Plots the transform contained in an <code>hwtANYN</code> object.</p></a></li>
<li><a href='#plot.lacf'><p>Plot localized autocovariance (lacf) object.</p></a></li>
<li><a href='#plot.lacfCI'><p>Plot confidence intervals for localized autocovariance for</p>
locally stationary time series.</a></li>
<li><a href='#plot.tos'><p>Produces a graphical representation of the results of a</p>
test of stationarity contained in a <code>tos</code> object.</a></li>
<li><a href='#plot.tosANYN'><p>Produces a graphical representation of the results of a</p>
test of stationarity from a <code>tosANYN</code> object.</a></li>
<li><a href='#print.hwtANYN'><p>Print out a <code>hwtANYN</code> class object, eg from the <code>link{hwt}</code></p>
function.</a></li>
<li><a href='#print.lacf'><p>Print lacf class object</p></a></li>
<li><a href='#print.lacfCI'><p>Print basic information about a <code>lacfCI</code> object.</p></a></li>
<li><a href='#print.tos'><p>Print out a <code>tos</code> class object, eg from the <code>link{hwtos2}</code></p>
function.</a></li>
<li><a href='#print.tosANYN'><p>Print out a <code>tosANYN</code> class object, eg from the <code>link{hwtos}</code></p>
function.</a></li>
<li><a href='#runmean'><p>Compute a running mean of a vector</p></a></li>
<li><a href='#Rvarlacf'>
<p>Compute confidence intervals for localized autocovariance for</p>
locally stationary time series.</a></li>
<li><a href='#StoreStatistics'><p>Interogates calculation store to see how well we are</p>
reusing previous calculations (debugging)</a></li>
<li><a href='#summary.hwtANYN'><p>Summarize the results of a Haar wavelet transform object computed</p>
from an arbitrary length vector.
</p></a></li>
<li><a href='#summary.lacf'><p>Summarizes a lacf object</p></a></li>
<li><a href='#summary.lacfCI'><p>Produce a brief summary of the contents of a <code>lacfCI</code> object</p></a></li>
<li><a href='#summary.tos'><p>Summarize the results of a test of stationarity contained i</p>
a <code>tos</code> object.
</p></a></li>
<li><a href='#summary.tosANYN'><p>Summarize the results of a test of stationarity contained</p>
in an <code>tosANYN</code> class object.</a></li>
<li><a href='#tvar1sim'>
<p>Simulate a realization from a particular TVAR(1) model.</p></a></li>
<li><a href='#varip2'>
<p>Direct computation of estimate of variance of v_ip,</p>
the Haar wavelet coefficients of the periodogram.</a></li>
<li><a href='#whichlevel'>
<p>Helper routine for <code>mkcoef</code></p></a></li>
<li><a href='#zeropad'><p>Intersperse zeroes in a vector.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Test of Stationarity and Localized Autocovariance</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-04</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), wavethresh, igraph</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides test of second-order stationarity for time
	series (for dyadic and arbitrary-n length data). Provides
	localized autocovariance, with confidence intervals,
	for locally stationary (nonstationary) time series.
	See Nason, G P (2013) "A test for second-order stationarity and
	approximate confidence intervals for localized autocovariance
	for locally stationary time series." Journal of the Royal Statistical
	Society, Series B, 75, 879-904.  &lt;<a href="https://doi.org/10.1111%2Frssb.12015">doi:10.1111/rssb.12015</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-05 14:37:03 UTC; gnason</td>
</tr>
<tr>
<td>Author:</td>
<td>Guy Nason [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guy Nason &lt;g.nason@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-05 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='locits-package'>New test of second-order stationarity and confidence intervals
for localized autocovariance.
</h2><span id='topic+locits-package'></span><span id='topic+locits'></span>

<h3>Description</h3>

<p>Provides functionality to perform a new test of
second-order stationarity for time series. The method
works by computing a wavelet periodogram and then examining
its Haar wavelet coefficients for significant ones.
The other main feature of the software is to compute the
localized autocovariance and pointwise confidence intervals.
</p>


<h3>Details</h3>

<p>For the test of stationarity there are two main functions.
The original is
the <code><a href="#topic+hwtos2">hwtos2</a></code> function and this returns a
<code>tos</code> object. The <code><a href="#topic+hwtos2">hwtos2</a></code> function
works on data sets whose length is a power of two. Version 1.5
introduced a new function, <code><a href="#topic+hwtos">hwtos</a></code> which carries out the
test on arbitrary length data.
The <code><a href="#topic+summary.tos">summary.tos</a></code> function
performs a Bonferroni and FDR statistical analysis to detect
which Haar wavelet coefficients are significant. The
function <code><a href="#topic+plot.tos">plot.tos</a></code> provides a plot of the
original time series with any non-stationarities clearly indicated
on the plot (actually locations and scales of the Haar wavelet coefficients).
</p>
<p>For the localized autocovariance the main function is
<code><a href="#topic+Rvarlacf">Rvarlacf</a></code>. This computes the localized autocovariance
values and approximate pointwise condifence intervals. The function
<code><a href="#topic+plot.lacfCI">plot.lacfCI</a></code> can then plot the localized autocovariance
and its confidence intervals in a number of forms.
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>
<p>Maintainer: Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Rvarlacf">Rvarlacf</a></code>, <code><a href="#topic+hwtos2">hwtos2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Here's a simple simulated example.
#
# A series which is a concatenation of two iid Gaussian series with
# different variances.
#
x &lt;- c(rnorm(256, sd=1), rnorm(256, sd=2))
#
# Let's do a test of stationarity
#
st.test &lt;- hwtos2(x)
#8    7    6    5    4    3  
#
# Ok, that's the computation gone, let's look at the results.
#
st.test

#Class 'tos' : Stationarity Object :
#~~~~  : List with 9 components with names
#	nreject rejpval spvals sTS AllTS AllPVal alpha x xSD 
#
#
#summary(.):
#----------
#There are  186  hypothesis tests altogether
#There were  4  FDR rejects
#The rejection p-value was  0.0001376564 
#Using Bonferroni rejection p-value is  0.0002688172 
#And there would be  4  rejections.
#Listing FDR rejects... (thanks Y&amp;Y!)
#P: 5 HWTlev:  0  indices on next line...[1] 1
#P: 6 HWTlev:  0  indices on next line...[1] 1
#P: 7 HWTlev:  0  indices on next line...[1] 1
#P: 8 HWTlev:  0  indices on next line...[1] 1
#
# In the lines above if there are any rejects then the series is
# deemed to be nonstationary, and note that there were 4 in both
# the lines above (sometimes FDR rejects a few more).
#
# You can also plot the object and it shows you where it thinks the
# nonstationarities are
#
## Not run: plot(st.test)
#
# See the help page for the hwtos2 function, where there is an example
# with a stationary series.
#
# For the localized autocovariance...
#
# Let's use the function tvar1sim which generates a time-varying AR model
# with AR(1) paramter varying over the extent of the series from 0.9
# to -0.9 (that is, near the start of the series it behaves like an
# AR(1) with parameter 0.9, and near the end like an AR(1) with parameter
# -0.9, and in between the parameter is somewhere between 0.9 and -0.9
# figured linearly between the two.
#
x &lt;- tvar1sim()
#
# Plot it, so you know what the series looks like, should always do this.
#
## Not run: ts.plot(x)
#
# Now, let's compute the localized autocovariance and also confidence intervals
# For the variance, let's look at the first 20 lags
#
# Do it at t=50 and t=450, ie what is the localized autocovariance at these
# two times.
#
x.lacf.50 &lt;- Rvarlacf(x=x, nz=50, var.lag.max=20)
x.lacf.450 &lt;- Rvarlacf(x=x, nz=450, var.lag.max=20)
#
# Now plot the answers, you may want to do this on two different plots
# so that you can compare the answers
#
#
## Not run: plot(x.lacf.50, plotcor=FALSE, type="acf")
## Not run: plot(x.lacf.450, plotcor=FALSE, type="acf")
#
# Note that the plotcor argument is set so covariances and not correlations
# are plotted. Also, the type is set to "acf" to make the plot *look* like
# the regular acf plot. But DON'T be fooled, it is not the regular acf
# that is plotted, but a time localized plot. The two plots should look
# very different, both like AR(1) but with different parameters (from the
# same time series).
#
# You could also plot the regular acf and see how it gets it wrong!
#
</code></pre>

<hr>
<h2 id='AutoBestBW'>Choose a good bandwidth for running mean smoothing of a EWS
spectral estimator.
</h2><span id='topic+AutoBestBW'></span>

<h3>Description</h3>

<p>Computes running mean estimator closest to wavelet estimator of
evolutionary wavelet spectrum.
The idea is to obtain a good linear bandwidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoBestBW(x, filter.number = 1, family = "DaubExPhase",
    smooth.dev = var, AutoReflect = TRUE, tol = 0.01, maxits = 200,
    plot.it = FALSE, verbose = 0, ReturnAll = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AutoBestBW_+3A_x">x</code></td>
<td>

<p>Time series you want to analyze.
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_filter.number">filter.number</code></td>
<td>

<p>The wavelet filter used to carry out smoothing operations.
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_family">family</code></td>
<td>

<p>The wavelet family used to carry out smoothing operations.
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_smooth.dev">smooth.dev</code></td>
<td>

<p>The deviance estimate used for the smoothing (see ewspec help)
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_autoreflect">AutoReflect</code></td>
<td>

<p>Mitigate periodic boundary conditions of wavelet transforms
by reflecting time series about RHS end before taking 
transforms (and is undone before returning the answer).	
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_tol">tol</code></td>
<td>

<p>Tolerance for golden section search for the best bandwidth
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_maxits">maxits</code></td>
<td>

<p>Maximum number of iterations for the golden section search
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_plot.it">plot.it</code></td>
<td>

<p>Plot the values of the bandwidth and its closeness of the
linear smooth to the wavelet smooth, if TRUE.
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_verbose">verbose</code></td>
<td>

<p>If nonzero prints out informative messages about the progress
of the golden section search. Higher integers produce more
messages.
</p>
</td></tr>
<tr><td><code id="AutoBestBW_+3A_returnall">ReturnAll</code></td>
<td>

<p>If TRUE then return the best bandwidth (in the ans component),
the wavelet smooth (in EWS.wavelet) and the closest linear
smooth (EWS.linear). If FALSE then just the bandwidth is returned.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tries to find the best running mean fit to an estimated
spectrum obtained via wavelet shrinkage. The goal is to try
and find a reasonable linear bandwidth.
</p>


<h3>Value</h3>

<p>If ReturnAll argument is FALSE then the best bandwidth
is returned.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Rvarlacf">Rvarlacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate synthetic data
#
x &lt;- rnorm(256)
#
# Compute best linear bandwidth
#
tmp &lt;- AutoBestBW(x=x)
#
# Printing it out in my example gives:
# tmp
# [1] 168
</code></pre>

<hr>
<h2 id='covI'>Compute the covariance between two wavelet periodogram
ordinates at the same scale, but different time locations.
</h2><span id='topic+covI'></span>

<h3>Description</h3>

<p>Computes <code class="reqn">cov(I_{\ell, m}, I_{\ell, n})</code> using the formula
given in Nason (2012) in Theorem 1. Note: one usually should
use the <code><a href="#topic+covIwrap">covIwrap</a></code> function for efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covI(II, m, n, ll, ThePsiJ)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covI_+3A_ii">II</code></td>
<td>
<p>Actually the *spectral* estimate S, not the periodogram
values. This is for an assumed stationary series, so this is just
a vector of length J, one for each scale of S.
</p>
</td></tr>
<tr><td><code id="covI_+3A_m">m</code></td>
<td>
<p>Time location m
</p>
</td></tr>
<tr><td><code id="covI_+3A_n">n</code></td>
<td>
<p>Time location n
</p>
</td></tr>
<tr><td><code id="covI_+3A_ll">ll</code></td>
<td>
<p>Scale of the raw wavelet periodogram
</p>
</td></tr>
<tr><td><code id="covI_+3A_thepsij">ThePsiJ</code></td>
<td>
<p>Autocorrelation wavelet corresponding to the
wavelet that computed the raw peridogram (also assumed
to underlie the time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance is returned.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+covIwrap">covIwrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- PsiJ(-5, filter.number=1, family="DaubExPhase")
#
# Compute the covariance
#
covI(II=c(1/2, 1/4, 1/8, 1/16, 1/32), m=1, n=3, ll=5, ThePsiJ=P1)
#
# [1] 0.8430809
</code></pre>

<hr>
<h2 id='covIwrap'>
A wrapper for the covI function.
</h2><span id='topic+covIwrap'></span>

<h3>Description</h3>

<p>Computation of the <code><a href="#topic+covI">covI</a></code> function is
intensive. This function permits values of <code>covI</code>
to be stored in an object, and then if these values are
requested again the values can be obtained from a store
rather than being computed from scratch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covIwrap(S, m, n, ll, storewrap, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covIwrap_+3A_s">S</code></td>
<td>
<p>Same argument as for <code><a href="#topic+covI">covI</a></code>, a spectral
estimate (for a stationary series).
</p>
</td></tr>
<tr><td><code id="covIwrap_+3A_m">m</code></td>
<td>
<p>The same argument as in <code><a href="#topic+covI">covI</a></code>.
</p>
</td></tr>
<tr><td><code id="covIwrap_+3A_n">n</code></td>
<td>
<p>The same argument as in <code><a href="#topic+covI">covI</a></code>.
</p>
</td></tr>
<tr><td><code id="covIwrap_+3A_ll">ll</code></td>
<td>
<p>The same argument as in <code><a href="#topic+covI">covI</a></code>.
</p>
</td></tr>
<tr><td><code id="covIwrap_+3A_storewrap">storewrap</code></td>
<td>
<p>A list. On first call to this function the user should
supply <code>storewrap=NULL</code>. This causes the function to
initialize the storage. On every return from this function
the storewrap component should be extracted from the list
and then this storewrap component should be resupplied to
any future calls to this function. In this way the function
has access to previously computed values.
</p>
</td></tr>
<tr><td><code id="covIwrap_+3A_p">P</code></td>
<td>
<p>Same argument as in <code><a href="#topic+covI">covI</a></code>. An autocorrelation
wavelet computed using the <code>PsiJ</code> function in <code>wavethresh</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: <code>covIwrap</code> could be removed from the function tree
altogether. I.e. <code><a href="#topic+varip2">varip2</a></code> could call
<code><a href="#topic+covI">covI</a></code> directly. However,
<code>covIwrap</code> considerably improves the efficiency of the algorithm
as it stores intermediate calculations that can be reused rather
than being computed repeatedly.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>ans</code></td>
<td>
<p>The appropriate covariance</p>
</td></tr>
<tr><td><code>storewrap</code></td>
<td>
<p>A list containing information about all previously
computed covariances. This list should be supplied as the
<code>storewrap</code> argument to any future calls of this function,
so if the same covariance is requested it can be returned from
<code>storewrap</code> and not computed again.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+varip2">varip2</a></code>, <code><a href="#topic+covI">covI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- PsiJ(-5, filter.number=1, family="DaubExPhase")
#
# First call to covIwrap
#
ans &lt;- covIwrap(S=c(1/2, 1/4, 1/8, 1/16, 1/32), m=1, n=3, ll=5,
    storewrap=NULL, P=P1)
#
# Make sure you keep the storewrap component.
#
my.storewrap &lt;- ans$storewrap
#
# What is the answer?
#
ans$ans
#[1] 0.8430809
#
# Issue next call to covIwrap: but storewrap argument is now the one we stored.
#
ans &lt;- covIwrap(S=c(1/2, 1/4, 1/8, 1/16, 1/32), m=1, n=3, ll=5,
    storewrap=my.storewrap, P=P1)
#
# This call will reuse the stored value. However, if you change any of the
# arguments then the store won't be used.

</code></pre>

<hr>
<h2 id='Cvarip2'>Computes variance of Haar wavelet coefficients of
wavelet periodogram using C code.
</h2><span id='topic+Cvarip2'></span>

<h3>Description</h3>

<p>Performs precisely the same role as <code><a href="#topic+varip2">varip2</a></code>
except it is implemented internally using C code and hence
is much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cvarip2(i, p, ll, S, Pmat, PsiJL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cvarip2_+3A_i">i</code></td>
<td>
<p>Scale parameter of Haar wavelet analyzing periodogram.
Scale 1 is the finest scale.
</p>
</td></tr>
<tr><td><code id="Cvarip2_+3A_p">p</code></td>
<td>
<p>Location parameter of Haar wavelet analyzing periodogram
</p>
</td></tr>
<tr><td><code id="Cvarip2_+3A_ll">ll</code></td>
<td>
<p>Scale of the raw wavelet periodogram being analyzed.
</p>
</td></tr>
<tr><td><code id="Cvarip2_+3A_s">S</code></td>
<td>
<p>Estimate of the spectrum, under the assumption of stationarity.
So, this is just a vector of (possibly) J scales (which is often
the usual spectral estimate averaged over time). Note: that the
main calling function, <code><a href="#topic+hwtos2">hwtos2</a></code>, actually passes
<code>maxD</code> levels.
</p>
</td></tr>
<tr><td><code id="Cvarip2_+3A_pmat">Pmat</code></td>
<td>
<p>Matrix version of autocorrelation wavelet computed
using the <code>PsiJmat</code> function in <code>wavethresh</code>
</p>
</td></tr>
<tr><td><code id="Cvarip2_+3A_psijl">PsiJL</code></td>
<td>
<p>True length of the autocorrelation wavelets
in the <code>Pmat</code> matrix. This can be obtained simply
by using the list version of the ac wavelet (computed
by <code>PsiJ</code>) and applying <code>sapply</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list returned from the <code>.C</code> calling function.
The only object of real interest is the <code>ans</code> component
which contains the variance.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos2">hwtos2</a></code>,
<code><a href="#topic+varip2">varip2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example from varip2
#
#
my.Pmat &lt;- PsiJmat(-5, filter.number=1, family="DaubExPhase")
my.PsiJ &lt;- PsiJ(-5, filter.number=1, family="DaubExPhase")
my.PsiJL &lt;- sapply(my.PsiJ, "length")
Cvarip2(i=1, p=10, ll=2, S=c(1/2,1/4,1/8,1/16,1/32),
    Pmat=my.Pmat, PsiJL=my.PsiJL)
#
# Gives answer 1.865244, which is the same as given in the example for varip2
</code></pre>

<hr>
<h2 id='EstBetaCov'>Compute estimate of wavelet periodogram and the estimate's
covariance matrix.
</h2><span id='topic+EstBetaCov'></span>

<h3>Description</h3>

<p>An estimate of the wavelet periodogram at a location
<code>nz</code> is generated. This is obtained by first computing the
empirical raw wavelet periodogram by squaring the results of
the nondecimated wavelet transform of the time series. Then
a running mean smooth is applied.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>EstBetaCov(x, nz, filter.number = 1, family = "DaubExPhase", smooth.dev = var,
    AutoReflect = TRUE, WPsmooth.type = "RM", binwidth = 0, mkcoefOBJ,
    ThePsiJ, Cverbose = 0, verbose = 0, OPLENGTH = 10^5, ABB.tol = 0.1,
    ABB.plot.it = FALSE, ABB.verbose = 0, ABB.maxits = 10, do.init = TRUE, 
    truedenom=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EstBetaCov_+3A_x">x</code></td>
<td>
<p>The time series for which you wish to have the estimate for.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_nz">nz</code></td>
<td>
<p>The time point at which you want the estimate computed at.
This is an integer ranging from one up to the length of the time
series.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_filter.number">filter.number</code></td>
<td>
<p>The analysis wavelet (the wavelet periodogram is
computed using this to form the nondecimated wavelet coefficients)
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_family">family</code></td>
<td>
<p>The family of the analysis wavelet.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>The deviance function used in smoothing via the
internal call to the <code><a href="#topic+ewspec3">ewspec3</a></code> function.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>Whether better smoothing is to be obtained by
AutoReflection to mitigate the effects of using periodic
transforms on non-periodic data. See <code><a href="#topic+ewspec3">ewspec3</a></code>
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_wpsmooth.type">WPsmooth.type</code></td>
<td>
<p>The type of wavelet periodogram smoothing. For here
leave the option at <code>"RM"</code> otherwise unpredictable results can occur
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_binwidth">binwidth</code></td>
<td>
<p>The running mean length. If zero then a good bandwidth
will be chosen using the <code><a href="#topic+AutoBestBW">AutoBestBW</a></code> function.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_mkcoefobj">mkcoefOBJ</code></td>
<td>
<p>If this argument is missing then it is computed internally
using the <code><a href="#topic+mkcoef">mkcoef</a></code> function which computes discrete
wavelets. If this function is going to be repeatedly called then
it is more efficient to supply this function with a precomputed
version.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_thepsij">ThePsiJ</code></td>
<td>
<p>As for <code>mkcoefOBJ</code> argument but for the
autocorrelation wavelet and the function <code><a href="wavethresh.html#topic+PsiJ">PsiJ</a></code>.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_cverbose">Cverbose</code></td>
<td>
<p>This function called the C routine <code>CstarIcov</code>
if you set <code>Cverbose</code> to true then the routine instructs
the C code to produce debugging messages.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE then debugging messages from the R code are
produced.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_oplength">OPLENGTH</code></td>
<td>
<p>Subsidiary parameters for potential call to
<code><a href="wavethresh.html#topic+PsiJ">PsiJ</a></code> function
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_abb.tol">ABB.tol</code></td>
<td>
<p>Tolerance to be passed to <code><a href="#topic+AutoBestBW">AutoBestBW</a></code> function.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_abb.plot.it">ABB.plot.it</code></td>
<td>
<p>Argument to be passed to <code><a href="#topic+AutoBestBW">AutoBestBW</a></code>
<code>plot.it</code> argument.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_abb.verbose">ABB.verbose</code></td>
<td>
<p>Argument to be passed to <code><a href="#topic+AutoBestBW">AutoBestBW</a></code>
<code>verbose</code> argument.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_abb.maxits">ABB.maxits</code></td>
<td>
<p>Argument to be passed to <code><a href="#topic+AutoBestBW">AutoBestBW</a></code>
<code>maxits</code> argument.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_do.init">do.init</code></td>
<td>
<p>Initialize stored statistics, for cache hit rate info.
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_truedenom">truedenom</code></td>
<td>
<p>If TRUE use the actual number of terms in the sum as
the denominator in the formula for the calculation of the
covariance of the smoothed periodogram. If FALSE use the
(2s+1)
</p>
</td></tr>
<tr><td><code id="EstBetaCov_+3A_...">...</code></td>
<td>
<p>Other arguments that are passed to the
<code><a href="#topic+ewspec3">ewspec3</a></code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First optionally computes a good bandwidth using the
<code><a href="#topic+AutoBestBW">AutoBestBW</a></code> function. Then
computes raw wavelet periodogram using <code><a href="#topic+ewspec3">ewspec3</a></code>
using running mean smoothing with the <code>binwidth</code> bandwith
(which might be automatically chosen). This computes the estimate
of the wavelet periodogram at time <code>nz</code>. The covariance matrix
of this estimate is then computed in C using the
<code>CstarIcov</code> function and this is returned.
</p>


<h3>Value</h3>

<p>A list with two components:
</p>
<table role = "presentation">
<tr><td><code>betahat</code></td>
<td>
<p>A vector of length <code class="reqn">J</code> (the number of scales
in the wavelet periodogram, which is <code class="reqn">\log_2</code>
of the number of observations <code class="reqn">T</code></p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>A matrix of dimensions <code class="reqn">J\times J</code>
which is the covariance
of <code class="reqn">\hat{\beta}_j</code> with <code class="reqn">\hat{\beta}_\ell</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoBestBW">AutoBestBW</a></code>, <code><a href="#topic+ewspec3">ewspec3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Small example, not too computationally demanding on white noise
#
myb &lt;- EstBetaCov(rnorm(64), nz=32)
#
# Let's see the results (of my run)
#
## Not run: myb$betahat
#[1] 0.8323344 0.7926963 0.7272328 1.3459313 2.1873395 0.8364632
#
# For white noise, these values should be 1 (they're estimates)
## Not run: myb$Sigma
#            [,1]        [,2]        [,3]       [,4]        [,5]        [,6]
#[1,] 0.039355673 0.022886994 0.008980497 0.01146325 0.003211176 0.001064377
#[2,] 0.022886994 0.054363333 0.035228164 0.06519112 0.017146883 0.006079162
#[3,] 0.008980497 0.035228164 0.161340373 0.38326812 0.111068916 0.040068318
#[4,] 0.011463247 0.065191118 0.383268115 1.31229598 0.632725858 0.228574601
#[5,] 0.003211176 0.017146883 0.111068916 0.63272586 1.587765187 0.919247252
#[6,] 0.001064377 0.006079162 0.040068318 0.22857460 0.919247252 2.767615374
#
# Here's an example for T (length of series) bigger, T=1024
#
## Not run: myb &lt;- EstBetaCov(rnorm(1024), nz=512)
#
# Let's look at results
#
## Not run: myb$betahat
# [1] 1.0276157 1.0626069 0.9138419 1.1275545 1.4161028 0.9147333 1.1935089
# [8] 0.6598547 1.1355896 2.3374615
#
# These values (especially for finer scales) are closer to 1
#
</code></pre>

<hr>
<h2 id='ewspec3'>Compute evolutionary wavelet spectrum of a time series.
</h2><span id='topic+ewspec3'></span>

<h3>Description</h3>

<p>This function is a development of the <code>ewspec</code>
function from <code>wavethresh</code> but with more features.
The two new features are: the addition of running mean smoothing
and autoreflection which mitigates the problems caused in
<code>ewspec</code> which performed periodic transforms on
data (time series) which were generally not periodic. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewspec3(x, filter.number = 10, family = "DaubLeAsymm",
    UseLocalSpec = TRUE, DoSWT = TRUE, WPsmooth = TRUE,
    WPsmooth.type = "RM", binwidth = 5, verbose = FALSE,
    smooth.filter.number = 10, smooth.family = "DaubLeAsymm",
    smooth.levels = 3:WPwst$nlevels - 1, smooth.dev = madmad,
    smooth.policy = "LSuniversal", smooth.value = 0,
    smooth.by.level = FALSE, smooth.type = "soft",
    smooth.verbose = FALSE, smooth.cvtol = 0.01,
    smooth.cvnorm = l2norm, smooth.transform = I,
    smooth.inverse = I, AutoReflect = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ewspec3_+3A_x">x</code></td>
<td>
<p>The time series you want to compute the evolutionary
wavelet spectrum for.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_filter.number">filter.number</code></td>
<td>
<p>Wavelet filter number underlying the analysis
of the spectrum (see <code>filter.select</code> or <code>wd</code> for more
details).
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_family">family</code></td>
<td>
<p>Wavelet family. Again, see <code>filter.select</code> or <code>wd</code>
for more details.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_uselocalspec">UseLocalSpec</code></td>
<td>
<p> As <code>ewspec</code>, should usually leave as is.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_doswt">DoSWT</code></td>
<td>
<p>As <code>ewspec</code>, should usually leave as is.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_wpsmooth">WPsmooth</code></td>
<td>
<p>If <code>TRUE</code> then smoothing is applied to
the wavelet periodogram (and hence spectrum).
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_wpsmooth.type">WPsmooth.type</code></td>
<td>
<p>The type of periodogram smoothing. 
If this argument is <code>"RM"</code> then running mean
linear smoothing is used.
Otherwise, wavelet shrinkage as in <code>ewspec</code> is
used.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_binwidth">binwidth</code></td>
<td>
<p>If the periodogram smoothing is <code>"RM"</code> then
the this argument supplies the <code>binwidth</code> or number
of consecutive observations used in the running mean smooth.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then messages are produced. If 
<code>FALSE</code> then they are not.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.filter.number">smooth.filter.number</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the index number of
wavelet to use, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.family">smooth.family</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the family of
wavelet to use, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.levels">smooth.levels</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the levels to
smooth, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies  deviance used
to compute smoothing thresholds, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.policy">smooth.policy</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the policy
of wavelet shrinkage to use, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.value">smooth.value</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the value of the
smoothing parameter for some policies, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.by.level">smooth.by.level</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies whether level-by-level
thresholding is applied, or one threshold is applied to
all levels, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.type">smooth.type</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies the type of
thresholding, &quot;hard&quot; or &quot;soft&quot;, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.verbose">smooth.verbose</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies whether or not
verbose messages are produced during the smoothing,
exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.cvtol">smooth.cvtol</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies a tolerance
for the cross-validation algorithm if it is specified
in the <code>smooth.policy</code>, exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.cvnorm">smooth.cvnorm</code></td>
<td>
<p>Ditto to the previous argument, but this
one supplies the norm used by the cross-validation.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.transform">smooth.transform</code></td>
<td>
<p>If wavelet smoothing of the wavelet
periodogram is used then this specifies whether a transform
is used to transform the periodogram before smoothing, 
exactly as <code>ewspec</code>.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_smooth.inverse">smooth.inverse</code></td>
<td>
<p>Should be the mathematical inverse of
the <code>smooth.transform</code> argument.
</p>
</td></tr>
<tr><td><code id="ewspec3_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>Whether the series is internally reflected before
application of the wavelet transforms. So, <code>x</code> becomes
<code>c(x, rev(x))</code> which is a periodic sequence. After
estimation of the spectrum the second-half of the spectral
estimate is junked (because it is a reflection of the first
half). However, the estimate is better. This argument improves
over <code>ewspec</code> where poor estimates near boundaries were
obtained because the transforms assume periodicity but most
time series are not (and X_1 and X_T are very different, etc).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Precisely the same kind of output as <code>ewspec</code>.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoBestBW">AutoBestBW</a></code>, <code><a href="#topic+lacf">lacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate time series
#
x &lt;- tvar1sim()
#
# Compute its evolutionary wavelet spectrum, with linear running mean smooth
#
x.ewspec3 &lt;- ewspec3(x)
#
# Plot the answer, probably its a bit variable, because the default bandwidth
# is 5, which is probably inappropriate for many series
#
## Not run: plot(x.ewspec3$S)
#
# Try a larger bandwidth
#
x.ewspec3 &lt;- ewspec3(x, binwidth=100)
#
# Plot the answer, should look a lot smoother
#
# Note, a lot of high frequency power on the right hand side of the plot,
# which is expected as process looks like AR(1) with param of -0.9
#
## Not run: plot(x.ewspec3$S)
#
# Do smoothing like ewspec (but additionally AutoReflect)
#
x.ewspec3 &lt;- ewspec3(x, WPsmooth.type="wavelet")
#
# Plot the results
#
## Not run: plot(x.ewspec3$S)
#
# Another possibility is to use AutoBestBW which tries to find the best
# linear smooth closest to a wavelet smooth. This makes use of ewspec3
#
</code></pre>

<hr>
<h2 id='ewspecHaarNonPer'>Compute evolutionary wavelet spectrum (EWS) estimate based
on the Haar wavelet transform.
</h2><span id='topic+ewspecHaarNonPer'></span>

<h3>Description</h3>

<p>This function uses the special <code>HwdS</code> function
to compute the Haar wavelet transform with out boundary
conditions (neither periodic, interval, mirror reflection).
This is so all coefficients are genuine Haar coefficients without
involving extra/repeated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ewspecHaarNonPer(x, filter.number = 1, family = "DaubExPhase",
    UseLocalSpec = TRUE, DoSWT = TRUE, WPsmooth = TRUE,
    verbose = FALSE, smooth.filter.number = 10,
    smooth.family = "DaubLeAsymm",
    smooth.levels = 3:WPwst$nlevels - 1, smooth.dev = madmad,
    smooth.policy = "LSuniversal", smooth.value = 0,
    smooth.by.level = FALSE, smooth.type = "soft",
    smooth.verbose = FALSE, smooth.cvtol = 0.01,
    smooth.cvnorm = l2norm, smooth.transform = I,
    smooth.inverse = I)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ewspecHaarNonPer_+3A_x">x</code></td>
<td>
<p>A vector of dyadic length that contains the time series
you want to form the EWS of.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_filter.number">filter.number</code></td>
<td>
<p>Should always be 1 (for Haar)
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_family">family</code></td>
<td>
<p>Should always be &quot;DaubExPhase&quot;, for Haar.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_uselocalspec">UseLocalSpec</code></td>
<td>

<p>Should always be <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_doswt">DoSWT</code></td>
<td>
<p>Should always be <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_wpsmooth">WPsmooth</code></td>
<td>
<p>Should alway be <code>TRUE</code> to do smoothing. If <code>FALSE</code>
then not smoothed.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_verbose">verbose</code></td>
<td>
<p> If <code>TRUE</code> informative messages are printed during
the progress of the algorithm.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.filter.number">smooth.filter.number</code></td>
<td>
<p>Wavelet filter number for doing the
wavelet smoothing of the EWS estimate.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.family">smooth.family</code></td>
<td>
<p>Wavelet family for doing the wavelet smoothing
of the EWS estimate.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.levels">smooth.levels</code></td>
<td>
<p>Which levels of the EWS estimate to apply smoothing
to.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>What kind of deviance to use. The default is madmad,
an alternative might be var. 
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.policy">smooth.policy</code></td>
<td>
<p>What kind of smoothing to use. See help
page for <code>ewspec</code>
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.value">smooth.value</code></td>
<td>
<p>If a manual value has to be supplied according
to the <code>smooth.policy</code> then this is it.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.by.level">smooth.by.level</code></td>
<td>
<p>If <code>TRUE</code> then all levels are smoothed
independently with different smoothing, otherwise all levels
are smoothed together (eg one threshold for all levels).
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.type">smooth.type</code></td>
<td>
<p>The type of wavelet smoothing &quot;hard&quot; or &quot;soft&quot;
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.verbose">smooth.verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages about
the smoothing are printed.
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.cvtol">smooth.cvtol</code></td>
<td>
<p>If cross-validation smoothing is used, this is
the tolerance
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.cvnorm">smooth.cvnorm</code></td>
<td>
<p>If cross-validation smoothing used, this is the
norm that's used
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.transform">smooth.transform</code></td>
<td>

<p>A transform is applied before smoothing
</p>
</td></tr>
<tr><td><code id="ewspecHaarNonPer_+3A_smooth.inverse">smooth.inverse</code></td>
<td>

<p>The inverse transform is applied after smoothing
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is very similar
to <code>ewspec</code> from wavethresh, and many arguments here perform
the same function as there.
</p>


<h3>Value</h3>

<p>The same value as for the <code>ewspec</code> function.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos2">hwtos2</a></code>,
<code><a href="#topic+HwdS">HwdS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Requires wavethresh, so not run directly in installation of package
#
ewspecHaarNonPer(rnorm(512))
</code></pre>

<hr>
<h2 id='getridofendNA'>Replaces all NAs in vector by 0
</h2><span id='topic+getridofendNA'></span>

<h3>Description</h3>

<p>Replaces all NAs in vector by 0
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getridofendNA(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getridofendNA_+3A_x">x</code></td>
<td>

<p>Vector that might contain NAs
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Originally, this function did something more complex,
but now it merely replaces NAs by 0
</p>


<h3>Value</h3>

<p>The same vector as <code>x</code> but with NAs replaced by 0
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+HwdS">HwdS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
#
#
x &lt;- c(3, 4, 6, NA, 3)
getridofendNA(x)
#[1] 3 4 6 0 3
</code></pre>

<hr>
<h2 id='HwdS'>
Compute the non-decimated Haar wavelet transform without
using periodic boundary conditions.
</h2><span id='topic+HwdS'></span>

<h3>Description</h3>

<p>Function uses the <code>filter</code> function to achieve its aims.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HwdS(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HwdS_+3A_x">x</code></td>
<td>
<p>A vector of dyadic length that you wish to transform.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regular <code>wd</code> function that can compute the non-decimated
transform uses different kinds of boundary conditions, which can
result in coefficients being used multiply for consideration in
a test of stationarity, and distort results. This function
only computes Haar coefficients on the data it can, without
wrapround.
</p>


<h3>Value</h3>

<p>An object of class <code>wd</code> which contains the nondecimated
Haar transform of the input series, <code>x</code> without periodic
boundary conditions (nor interval, nor reflection).
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspecHaarNonPer">ewspecHaarNonPer</a></code>,
<code><a href="#topic+getridofendNA">getridofendNA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Apply Haar transform to Gaussian data
#
HwdS(rnorm(32))
#Class 'wd' : Discrete Wavelet Transform Object:
#       ~~  : List with 8 components with names
#              C D nlevels fl.dbase filter type bc date 
#
#$C and $D are LONG coefficient vectors
#
#Created on : Tue Jul 17 15:14:59 2012 
#Type of decomposition:  station 
#
#summary(.):
#----------
#Levels:  5 
#Length of original:  32 
#Filter was:  Haar wavelet 
#Boundary handling:  periodic 
#Transform type:  station 
#Date:  Tue Jul 17 15:14:59 2012 
</code></pre>

<hr>
<h2 id='hwt'>Compute a Haar wavelet transform for data of arbitrary n length
</h2><span id='topic+hwt'></span>

<h3>Description</h3>

<p>Function computes Haar wavelet and scaling function coefficients
for data set of any length. Algorithm computes every possible
coefficient that it can for both decimated and nondecimated
versions of the transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwt(x, type = c("wavelet", "station"), reindex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwt_+3A_x">x</code></td>
<td>
<p>A vector of length n, where n is a positive integer.
This is the data that you wish to compute the Haar wavelet
transform for.
</p>
</td></tr>
<tr><td><code id="hwt_+3A_type">type</code></td>
<td>
<p>The type of transform, either the decimated or nondecimated
algorithm.
</p>
</td></tr>
<tr><td><code id="hwt_+3A_reindex">reindex</code></td>
<td>
<p>If TRUE then the routine attempts to match scales
with the usual dyadic transform, <code>wd</code>. If FALSE then the
coefficients that are returned are &quot;as is&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this algorithm attempts to compute every
possible Haar wavelet coefficient. For example, if the length
of the input series was 6 then this means that three coefficients
at the finest scale can be computed using the first, second and
third pair of input data points using the weights
<code>c(1, -1)/sqrt(2)</code>. However, from the three coefficients
that result from this, there is only one pair, so only one
&quot;next coarser&quot; coefficient can be computed.
</p>
<p>The <code>reindex</code> option is subtle. Essentially, it tries to
ensure that the returned coefficients end up at the same
scales as if a data set of the next highest dyadic length was
analyzed by the wd function. E.g. if the length of the
series was 10 then with <code>reindex=FALSE</code> (default)
only three levels are returned for each of the wavelet and
scaling coefficients. If <code>reindex=TRUE</code> then the number
of levels returned would be as if <code>wd</code> analysed a data set
of length 16 (the smallest dyadic number larger than 10).
The wd levels would be zero to three and this is what
would be returned in this function if <code>reindex=TRUE</code>.
However, note, in this case, the coarsest level coefficient
happens to be NULL (or not computable). One can view the algorithm
as computing a partial transform of 10 of the 16 elements and
substituting NA for anything it can't compute. 
</p>


<h3>Value</h3>

<p>An object of class hwtANYN which is a list with the following
components.
</p>
<table role = "presentation">
<tr><td><code>c</code></td>
<td>
<p>The scaling function coefficients. This is a list of length
<code>nlevels</code> which contains the scaling function coefficients.
The coarsest scale coefficients are to be found in the lowest-indexed
slots of the list (e.g. c[[1]]) and increasing slot index corresponds
to finer scales. So, <code>c[[length(c)]]</code> corresponds to the finest
coefficients. Note, an entry in the slot can also be NULL. This
indicates that no coefficients could be calculated at this scale,
usually the coarsest.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>A for <code>c</code> but for wavelet coefficients.</p>
</td></tr>
<tr><td><code>nlevels</code></td>
<td>
<p>The number of scale levels in the Haar wavelet decomposition.
if <code>reindex=TRUE</code> then this number will be the log to base 2
of the smallest power of two larger than the length of the input
vector <code>x</code>.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Whether a decimated wavelet transform has been computed
(<code>"wavelet"</code>) or a nondecimated transform (<code>"station"</code>).
Note, the name of the argument <code>"station"</code> has been chosen
to coincide with the <code>type</code> in the regular wavelet
transform computed by <code>wd</code>.</p>
</td></tr>
<tr><td><code>reindex</code></td>
<td>
<p>Either <code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code> then
the scale levels correspond directly to those computed by
<code>wd</code>, the regular wavelet transform. If <code>FALSE</code> then
the levels returned in <code>c</code> and <code>d</code> are just indexed from
the first non-null level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>G. P. Nason
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>
<p>Priestley, M.B. and Subba Rao (1969) A test for non-stationarity of
time series. <em>J. R. Statist. Soc. B</em>, <b>31</b>, 140-149.
</p>
<p>von Sachs, R. and Neumann, M.H. (2000) A wavelet-based test for
stationarity. <em>J. Time Ser. Anal.</em>, <b>21</b>,
597-613.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+hwtos">hwtos</a></code>,
<code><a href="#topic+plot.hwtANYN">plot.hwtANYN</a></code>, <code><a href="#topic+print.hwtANYN">print.hwtANYN</a></code>,
<code><a href="#topic+summary.hwtANYN">summary.hwtANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate test data set of length 5 (note, NOT a power of two)
#
v2 &lt;- rnorm(5)
#
# Compute its Haar transform
#
v2hwt &lt;- hwt(v2)
#
# How many levels does it have?
#
nlevelsWT(v2hwt)
#
# What are the coarsest scale wavelet coefficients
#
v2hwt$d[[1]]
#
# What are the finest scale scaling function coefficients
#
v2hwt$c[[nlevels(v2hwt$c)-1]]
</code></pre>

<hr>
<h2 id='hwtos'>Haar wavelet test for (second-order) stationarity for arbitrary length time series.
</h2><span id='topic+hwtos'></span>

<h3>Description</h3>

<p>NOTE: CURRENTLY THIS FUNCTION IS NOT INCLUDED IN THE PACKAGE.
USE hwtos2. This function computes the raw wavelet periodogram of the
arbitrary time series vector <code>x</code>. The periodogram is then
subject to a hypothesis test to see if its expectation over time,
for different scales, is constant. The constancy test is carried out
using tests on its Haar wavelet coefficients. The overall test is
for second-order stationarity (e.g. constant variance, constant
acf function, mean is assumed zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwtos(x, alpha = 0.05, lowlev = 1, WTscale = NULL, maxSD = NULL,
    verbose = FALSE, silent = FALSE, UseCForVarip2 = TRUE, OPLENGTH = 1e+05,
    mc.method = p.adjust.methods)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwtos_+3A_x">x</code></td>
<td>
<p>The time series you wish to test for second-order stationarity.
Minimum length series that this function will operate for is 20.
However, for short series the power of the test might not be good
and could be investigated via simulation that reflect your particular
circumstances.
This should be a stochastic series. The function
will report an error if <code>x</code> is a constant function. The
function might not work properly if it contains a significant trend
or patches of non-stochastic observations.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_alpha">alpha</code></td>
<td>
<p>The (nominal) size of the hypothesis test.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_lowlev">lowlev</code></td>
<td>
<p>Controls the lowest scale of the wavelet periodogram that
gets analyzed. Generally, leave this parameter alone.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_wtscale">WTscale</code></td>
<td>
<p>Controls the finest scale of the Haar wavelet transform
of a particular wavelet periodogram scale. Generally, we have to
stay away from the finest Haar wavelet transform scales of the
periodogram as the test relies on a central limit theorem effect
which only &quot;kicks in&quot; when the Haar wavelet scale is medium-to-coarse.
Generally, leave this argument alone.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_maxsd">maxSD</code></td>
<td>
<p>Parameter which controls which scales go towards overall
variance calculation. Generally, leave alone.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative messages are printed.
If <code>FALSE</code> only limited informational messages are printed
unless <code>silent=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code> then no messages are printed during the
operation of the function at all.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_usecforvarip2">UseCForVarip2</code></td>
<td>
<p>If <code>TRUE</code> then fast C code is used for the
variance calculation, otherwise slower R code is used. 
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_oplength">OPLENGTH</code></td>
<td>
<p>Some of the internal functions require workspace to
perform their calculations. In exceptional circumstances more
static workspace might be required and so this argument might
need to be higher than the default. However, the code will tell
you how high this number will need to be. The code can, with
default arguments, handle series that are up to 30000 in length.
However, at 35000 the OPLENGTH parameter will need to be increased.
</p>
</td></tr>
<tr><td><code id="hwtos_+3A_mc.method">mc.method</code></td>
<td>
<p>Method to control overall size for test taking into
account multiple comparisons. The default argument is
<code>p.adjust.methods</code> which is the same as the default argument
to the <code>p.adjust</code> function in R. This includes a number
of the popular methods such as &quot;Holm&quot;, &quot;Bonferonni&quot; and &quot;FDR&quot;,
for example.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes all possible Haar wavelet coefficients
of the time series <code>x</code>. Then, squares those to obtain the
raw wavelet periodogram. Then the test of stationarity works
by taking each level of the raw wavelet periodogram and subjecting
it to another (decimated) Haar wavelet transform and then assessing
whether any of those coefficients is significantly different to
zero. It does this by using a Gaussian approximation first
introduced by Neumann and von Sachs (2000). This is a multiple
testing problem: many individual wavelet coefficients need to
be assessed simultaneously and the user can choose the type of
assessment using the <code>mc.method</code> argument.
</p>


<h3>Value</h3>

<p>An object of class <code>tosANYN</code>. This is a list containing the
following components.
</p>
<table role = "presentation">
<tr><td><code>nreject</code></td>
<td>
<p>The number of wavelet coefficients that reject the null
hypothesis of being zero.</p>
</td></tr>
<tr><td><code>mc.method</code></td>
<td>
<p>The multiple comparison method used.</p>
</td></tr>
<tr><td><code>AllTS</code></td>
<td>
<p>All the t-statistics. This is a list containing J levels,
where J is the number of periodogram levels. Each slot in
the <code>AllTS</code> list itself contains a Haar wavelet transform
object (<code>hwtANYN</code>) which are the t-statistics associated with
each Haar wavelet coefficient of the Haar raw wavelet periodogram.
</p>
</td></tr>
<tr><td><code>AllPVal</code></td>
<td>
<p>As <code>AllTS</code> but for p-values</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The size of the test</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The time series that was analyzed</p>
</td></tr>
<tr><td><code>xSD</code></td>
<td>
<p>The estimated mean spectrum value for each level of the
spectrum, mean over time that is.</p>
</td></tr>
<tr><td><code>allTS</code></td>
<td>
<p>A vector containing all of the test statistics. So,
the information in <code>AllTS</code> but arranged as a single vector</p>
</td></tr>
<tr><td><code>allpvals</code></td>
<td>
<p>As <code>allTS</code> but for p-values. These values have been
adjusted to take account of the multiple comparisons. See the
vaector <code>allpvals.unadjust</code> for an unadjusted set.</p>
</td></tr>
<tr><td><code>allbigscale</code></td>
<td>
<p>The wavelet periodogram scale associated with each
t-statistic in <code>allTS</code>.</p>
</td></tr>
<tr><td><code>alllitscale</code></td>
<td>
<p>As for <code>allbigscale</code> but for the wavelet transform
of the wavelet periodogram.</p>
</td></tr>
<tr><td><code>allindex</code></td>
<td>
<p>As for <code>allbigscale</code> but the wavelet coefficient index
in the Haar wavelet transform of the wavelet periodogram</p>
</td></tr>
<tr><td><code>alllv</code></td>
<td>
<p>The maximum number of wavelet coefficients in a particular
Haar wavelet scale of a particular scale of the wavelet periodogram.
Note, this information is useful because the wavelet transforms
are computed on arbitrary length objects and so keeping track of
the number of coefficients per scale is useful later, e.g. for
plotting purposes. This information is not required in the
dyadic case because the coefficient vector lengths are completely
predictable.</p>
</td></tr>
<tr><td><code>allpvals.unadjust</code></td>
<td>
<p>A vector of p-values that has not been adjusted
by a multiple hypothesis test technique.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>G. P. Nason
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>
<p>Priestley, M.B. and Subba Rao (1969) A test for non-stationarity of
time series. <em>J. R. Statist. Soc. B</em>, <b>31</b>, 140-149.
</p>
<p>von Sachs, R. and Neumann, M.H. (2000) A wavelet-based test for
stationarity. <em>J. Time Ser. Anal.</em>, <b>21</b>,
597-613.
</p>


<h3>See Also</h3>

<p><code>link{hwt}</code>,
<code><a href="#topic+hwtos2">hwtos2</a></code>,
<code><a href="#topic+plot.tosANYN">plot.tosANYN</a></code>,
<code><a href="#topic+print.tosANYN">print.tosANYN</a></code>,
<code><a href="#topic+summary.tosANYN">summary.tosANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate test data set of non-dyadic length
#
v3 &lt;- rnorm(300)
#
# Run the test of stationarity
#
## Not run: v3.TOS &lt;- hwtos(v3)
#
#Scales get printed 
#8    7    6    5    4    3    2 
#
## Not run: print(v3.TOS)
#Class 'tosANYN' : Stationarity Object for Arbitrary Length Data :
#	~~~~~~~  : List with 14 components with names
#	nreject mc.method AllTS AllPVal alpha x xSD allTS
#	allpvals allbigscale alllitscale allindex alllv
#	allpvals.unadjust 
#
#
#summary(.):
#----------
#There are  54  hypothesis tests altogether
#There were  0  reject(s)
#P-val adjustment method was:  holm 
#
# Note, nothing got rejected. So accept the H_0 null hypothesis of stationarity.
# This is precisely what you'd expect operating on iid Gaussians.
#
# Let's construct obvious example of non-stationarity.
#
v4 &lt;- c(rnorm(150), rnorm(150,sd=3))
#
# I.e. v4 has sharp variance change halfway along
# Now compute test of stationarity
#
## Not run: v4.TOS &lt;- hwtos(v4)
#
#  Print out results
#
## Not run: print(v4.TOS)
#
#Class 'tosANYN' : Stationarity Object for Arbitrary Length Data :
#       ~~~~~~~  : List with 14 components with names
#       nreject mc.method AllTS AllPVal alpha x xSD allTS
#       allpvals allbigscale alllitscale allindex alllv
#       allpvals.unadjust 
#
#
#summary(.):
#----------
#There are  54  hypothesis tests altogether
#There were  5  reject(s)
#P-val adjustment method was:  holm 
#Listing rejects...
#P:  7  HWTlev:  2  Max Poss Ix:  2  Indices:  2 
#P:  7  HWTlev:  1  Max Poss Ix:  1  Indices:  1 
#P:  6  HWTlev:  1  Max Poss Ix:  1  Indices:  1 
#P:  5  HWTlev:  1  Max Poss Ix:  1  Indices:  1 
#P:  4  HWTlev:  1  Max Poss Ix:  1  Indices:  1 
</code></pre>

<hr>
<h2 id='hwtos2'>Test of second-order stationarity using wavelets.
</h2><span id='topic+hwtos2'></span>

<h3>Description</h3>

<p>The main function to perform a test of second-order
stationarity as outlined in Nason (2012). Essentially,
this routine computes an evolutionary wavelet spectral
estimate and then computes the Haar wavelet coefficients
of each scale of the spectral estimate. Any large Haar
coefficients are indicative of nonstationarity. A multiple
hypothesis test assesses whether any of the Haar coefficients
are large enough to reject the null hypothesis of stationarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hwtos2(x, alpha = 0.05, filter.number = 1, family = "DaubExPhase",
    lowlev = 3, WTscale = NULL, maxSD = NULL, verbose = FALSE,
    silent = FALSE, UseCForVarip2 = TRUE, OPLENGTH = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hwtos2_+3A_x">x</code></td>
<td>
<p>The time series you want to test for second order
stationarity. This should be a stochastic series. The function
will report an error if <code>x</code> is a constant function. The
function might not work properly if it contains a significant trend
or patches of non-stochastic observations.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_alpha">alpha</code></td>
<td>
<p>The overall (nominal) size of the test.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_filter.number">filter.number</code></td>
<td>
<p>The index number of the wavelet used
to compute the evolutionary spectral estimate with.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_family">family</code></td>
<td>
<p>The family of wavelet used to compute
the evolutionary spectral estimate.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_lowlev">lowlev</code></td>
<td>
<p>Do not compute Haar wavelet coefficients on
evolutionary wavelet spectra at level lower than <code>lowlev</code>. 
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_wtscale">WTscale</code></td>
<td>
<p>The theory of the test shows that the Haar wavelet
coefficients of the raw wavelet periodogram are asymptotically
normal as long as the scale of the Haar wavelet is
&lsquo;coarse&rsquo; enough. Roughly, speaking <code>WTscale</code>
is internally coded to be the log of the square root of T,
the length of the series (J/2), but you can set another
value. 
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_maxsd">maxSD</code></td>
<td>
<p>As part of its execution, this function computes an
evolutionary wavelet spectral estimate from the time series.
Since the test is based on the assumption of stationarity, the
EWS is averaged over time. There will be <code class="reqn">J = \log_2 T</code>
scale levels and, if <code>maxSD = NULL</code> then all of the <code class="reqn">J</code>
levels get used for later functions, such as computing the
variance of Haar wavelet coefficients. This argument
permits you to restrict the number of coarse scales going into
further calculations (e.g. removes the coarser scales from
further examination). Mostly, the default will be fine and maximises
the use of the available information.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative error messages are printed.
If <code>FALSE</code> they are not.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code> then no informative messages are printed.
If <code>FALSE</code> then a limited amout of informative is printed.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_usecforvarip2">UseCForVarip2</code></td>
<td>
<p>If <code>TRUE</code> then fast C code is use to
compute wavelet coefficients' variance. If <code>FALSE</code> then
R code is used wholly throughout, but the execution will be much
slower.
</p>
</td></tr>
<tr><td><code id="hwtos2_+3A_oplength">OPLENGTH</code></td>
<td>
<p>The <code>PsiJ</code> and <code>PsiJmat</code> routines both
used preallocated storage. This argument can be provided to
increase the amount of storage. Note, you should not need to change
this unless the routine as whole stops and tells you to rerun it
with increased storage.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function looks at the Haar wavelet coefficients
of an evolutionary wavelet spectrum. This is a modification
of the principle of von Sachs and Neumann (2000) which
worked with the Haar wavelet coefficients of a local
Fourier spectrum.
</p>
<p>See also, the <code>stationarity</code> test which implements
the Priestley-Subba Rao (1969) test. This function
is contained in the <code>fractal</code> package.
</p>


<h3>Value</h3>

<p>An object of class <code>tos</code>, a list containing the following
components:
</p>
<table role = "presentation">
<tr><td><code>nreject</code></td>
<td>
<p>The number of FDR rejections</p>
</td></tr>
<tr><td><code>rejpval</code></td>
<td>
<p>The p-value associated with FDR rejections</p>
</td></tr>
<tr><td><code>spvals</code></td>
<td>
<p>A vector of p-values from all of the tests, sorted in
ascending order.</p>
</td></tr>
<tr><td><code>sTS</code></td>
<td>
<p>A vector of sorted test statistics from all of the tests,
sorted into the same order as <code>spvals</code></p>
</td></tr>
<tr><td><code>AllTS</code></td>
<td>
<p>A list containing all of the test statistics.
The first entry contains test statistics corresponding
to the coarsest scale, the last entry corresponds to the
finest scale. Each component in the list is either empty
(because the scale was omitted because it was less than
<code>lowlev</code>) or contains a <code>wd</code> class object. The
<code>wd</code> class object contains the test statistics for
each Haar wavelet coefficient (not the coefficients).
Hence, the value of the test statistic for any scale/location
or level of the wavelet periodogram can easily be extracted.
</p>
</td></tr>
<tr><td><code>AllPVal</code></td>
<td>
<p>As <code>AllTS</code> except the values stored are
the p-values, not the test statistics.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The nominal size of the overall hypothesis test.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The original time series that was analyzed</p>
</td></tr>
<tr><td><code>xSD</code></td>
<td>
<p>A vector containing <code>J</code> levels, which is the
EWS estimate averaged across time.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>
<p>Priestley, M.B. and Subba Rao (1969) A test for non-stationarity of
time series. <em>J. R. Statist. Soc. B</em>, <b>31</b>, 140-149.
</p>
<p>von Sachs, R. and Neumann, M.H. (2000) A wavelet-based test for
stationarity. <em>J. Time Ser. Anal.</em>, <b>21</b>,
597-613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varip2">varip2</a></code>, <code>stationarity</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# First, test a set of iid Gaussians: should be stationary!
#
hwtos2(rnorm(256))
#  8    7    6    5    4    3  
#Class 'tos' : Stationarity Object :
#       ~~~~  : List with 9 components with names
#              nreject rejpval spvals sTS AllTS AllPVal alpha x xSD 
#
#
#summary(.):
#----------
#There are  186  hypothesis tests altogether
#There were  0  FDR rejects
#No p-values were smaller than the FDR val of:   
#Using Bonferroni rejection p-value is  0.0002688172 
#And there would be  0  rejections.
#
#  NOTE: the summary indicates that nothing was rejected: hence stationary!
#
# Second, example. Concatenated Gaussians with different variances
#
hwtos2(c(rnorm(256), rnorm(256,sd=2)))
#  9    8    7    6    5    4    3  
#Class 'tos' : Stationarity Object :
#       ~~~~  : List with 9 components with names
#              nreject rejpval spvals sTS AllTS AllPVal alpha x xSD 
#
#
#summary(.):
#----------
#There are  441  hypothesis tests altogether
#There were  5  FDR rejects
#The rejection p-value was  3.311237e-06 
#Using Bonferroni rejection p-value is  0.0001133787 
#And there would be  5  rejections.
#Listing FDR rejects... (thanks Y&amp;Y!)
#P: 5 HWTlev:  0  indices on next line...[1] 1
#P: 6 HWTlev:  0  indices on next line...[1] 1
#P: 7 HWTlev:  0  indices on next line...[1] 1
#P: 8 HWTlev:  0  indices on next line...[1] 1
#P: 9 HWTlev:  0  indices on next line...[1] 1
#
# NOTE: This time 5 Haar wavelet coefficients got rejected: hence series
# is not stationary.

</code></pre>

<hr>
<h2 id='idlastzero'>Return the index of the last zero in a vector
</h2><span id='topic+idlastzero'></span>

<h3>Description</h3>

<p>Return the index of the last zero in a vector, otherwise
stop and return errror message. A helper routine for
<code><a href="#topic+mkcoef">mkcoef</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idlastzero(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idlastzero_+3A_v">v</code></td>
<td>
<p>Vector you wish to investigate
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index within <code>v</code> of the last (right-most or one with
the largest index) zero.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mkcoef">mkcoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idlastzero(c(3,4,5,0,9))
#[1] 4
</code></pre>

<hr>
<h2 id='lacf'>Compute localized autocovariance.
</h2><span id='topic+lacf'></span>

<h3>Description</h3>

<p>Compute localized autocovariance function for nonstationary
time series. Note: this function is borrowed from the <code>costat</code>
package, and modified to have linear smoothing,  and when that package is complete, it will be removed
from this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lacf(x, filter.number = 10, family = "DaubLeAsymm", smooth.dev = var,
    AutoReflect = TRUE, lag.max = NULL, WPsmooth.type = "RM",
    binwidth, tol=0.1, maxits=5, ABBverbose=0, verbose=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lacf_+3A_x">x</code></td>
<td>
<p>The time series you wish to analyze
</p>
</td></tr>
<tr><td><code id="lacf_+3A_filter.number">filter.number</code></td>
<td>
<p>Wavelet filter number you wish to use to 
analyse the time series (to form the wavelet periodogram, etc)
See <code>filter.select</code> for more details.
</p>
</td></tr>
<tr><td><code id="lacf_+3A_family">family</code></td>
<td>
<p>Wavelet family to use, see <code>filter.select</code> for
more details.
</p>
</td></tr>
<tr><td><code id="lacf_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>Change variance estimate for smoothing. Note: <code>var</code>
is good for this purpose.
</p>
</td></tr>
<tr><td><code id="lacf_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>If <code>TRUE</code> then an internal reflection method
is used to repackage the time series so that it can be
analyzed by the periodic-assuming wavelet transforms.
</p>
</td></tr>
<tr><td><code id="lacf_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum lag of acf required. If NULL then the
same default as in the regular <code>acf</code> function is used.
</p>
</td></tr>
<tr><td><code id="lacf_+3A_wpsmooth.type">WPsmooth.type</code></td>
<td>
<p>The type of smoothing used to produce the
estimate. See <code><a href="#topic+ewspec3">ewspec3</a></code> for more advice on this.
</p>
</td></tr>
<tr><td><code id="lacf_+3A_binwidth">binwidth</code></td>
<td>
<p>If necessary, the <code>binwidth</code> for the
spectral smoothing, see <code><a href="#topic+ewspec3">ewspec3</a></code> for more info.
If <code>WTsmooth.type=="RM"</code> then this argument specifies
the binwidth of the kernel smoother applied to the wavelet
periodogram. If the argument is missing or zero then 
an automatic bandwidth is calculated by <code><a href="#topic+AutoBestBW">AutoBestBW</a></code>.
</p>
</td></tr>
<tr><td><code id="lacf_+3A_tol">tol</code></td>
<td>
<p>Tolerance argument for <code><a href="#topic+AutoBestBW">AutoBestBW</a></code></p>
</td></tr>
<tr><td><code id="lacf_+3A_maxits">maxits</code></td>
<td>
<p>Maximum iterations argument for <code><a href="#topic+AutoBestBW">AutoBestBW</a></code></p>
</td></tr>
<tr><td><code id="lacf_+3A_abbverbose">ABBverbose</code></td>
<td>
<p>Verbosity of execution of <code><a href="#topic+AutoBestBW">AutoBestBW</a></code></p>
</td></tr>
<tr><td><code id="lacf_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then informative message is printed</p>
</td></tr>
<tr><td><code id="lacf_+3A_...">...</code></td>
<td>
<p>Other arguments for <code><a href="#topic+ewspec3">ewspec3</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In essence, this routine is fairly simple. First, the EWS
of the time series is computed. Then formula (14) from
Nason, von Sachs and Kroisandr (2000) is applied to obtain
the time-localized autocovariance from the spectral estimate.
</p>


<h3>Value</h3>

<p>An object of class <code>lacf</code> which contains the
autocovariance. This object can be handled by functions
from the <code>costat</code> package. The idea in this package
is that the function gets used internally and much of the
same functionality can be achieved by running
<code><a href="#topic+Rvarlacf">Rvarlacf</a></code> and <code><a href="#topic+plot.lacfCI">plot.lacfCI</a></code>. However,
running <code>lacf</code> on its own is much faster than
<code><a href="#topic+Rvarlacf">Rvarlacf</a></code> as the CI computation is intenstive.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>
<p>Nason, G.P., von Sachs, R. and Kroisandt, G. (2000) Wavelet processes
and adaptive estimation of the evolutionary wavelet spectrum.
<em>J. R. Statist. Soc.</em> Ser B, <b>62</b>, 271-292.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Rvarlacf">Rvarlacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# With wavethresh attached, note binwidth is fabricated here,
# just to make the example work. The lacf implementation in
# the costat package performs wavelet (ie maybe better) smoothing automatically
#
v &lt;- lacf(rnorm(256), binwidth=40)
#
# With costat attached also
#
## Not run: plot(v)
</code></pre>

<hr>
<h2 id='littlevar'>Subsidiary helper function for hwtos2 
</h2><span id='topic+littlevar'></span>

<h3>Description</h3>

<p>Computes a variance estimate for <code><a href="#topic+hwtos2">hwtos2</a></code>
Merely takes a wavelet periodogram (actually <code>wd</code> class
object), and a level argument. Then extracts the wavelet periodogram
coefficients at that level and returns twice the mean of their
squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>littlevar(WP, ll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="littlevar_+3A_wp">WP</code></td>
<td>
<p>The wavelet periodogram that you wish to analyze (actually
a <code>wd</code> class object, <code>type="station"</code>
</p>
</td></tr>
<tr><td><code id="littlevar_+3A_ll">ll</code></td>
<td>
<p>A valid level for the periodogram
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Twice the mean of the square of the coefficients at the level
extracted.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos2">hwtos2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Not intended for direct user use
#
</code></pre>

<hr>
<h2 id='mkcoef'>Compute discrete wavelets.
</h2><span id='topic+mkcoef'></span>

<h3>Description</h3>

<p>For a given wavelet computes a list with each entry
of the list containing that discrete wavelet at a different
scale. The first entry corresponds to the finest wavelet,
the next entry to the next finest, and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkcoef(J, filter.number = 10, family = "DaubLeAsymm")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mkcoef_+3A_j">J</code></td>
<td>
<p>A NEGATIVE integer. -J is the maximum number of levels to compute.
</p>
</td></tr>
<tr><td><code id="mkcoef_+3A_filter.number">filter.number</code></td>
<td>
<p>The filter number (number of vanishing moments)
of the underlying wavelet to use.
</p>
</td></tr>
<tr><td><code id="mkcoef_+3A_family">family</code></td>
<td>
<p>The family of the wavelet. See <code>wd</code> help for further
info.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length J. The first entry contains the discrete
wavelet at the finest scale, the 2nd entry contains the next
most finest wavelet, and so on.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Rvarlacf">Rvarlacf</a></code>,
<code><a href="#topic+whichlevel">whichlevel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# E.g. compute discrete Haar wavelets on scales 1, 2, 3.
#
mkcoef(-3, 1, "DaubExPhase")
#[[1]]
#[1]  0.7071068 -0.7071068
#
#[[2]]
#[1]  0.5  0.5 -0.5 -0.5
#
#[[3]]
#[1]  0.3535534  0.3535534  0.3535534  0.3535534 -0.3535534 -0.3535534 -0.3535534
#[8] -0.3535534
</code></pre>

<hr>
<h2 id='plot.hwtANYN'>Plots the transform contained in an <code>hwtANYN</code> object.
</h2><span id='topic+plot.hwtANYN'></span>

<h3>Description</h3>

<p>An <code>hwtANYN</code> object contains the results of a Haar
wavelet transform computed on an object of non-dyadic length.
It is the equivalent of the <code>wd</code> object for non-dyadic
vectors for Haar wavelets. Note, the plot can only be carried
out where the <code>reindex</code> slot of the object is <code>TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hwtANYN'
plot(x, xlabvals, xlabchars, ylabchars, first.level = 1,
    main = "Haar Wavelet Coefficients", scaling = c("global", "by.level"),
    rhlab = FALSE, sub, NotPlotVal = 0.005, xlab = "Translate",
    ylab = "wd-equivalent Resolution Level", miss.coef.col = 2,
    miss.coef.cex = 0.5, miss.coef.pch = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hwtANYN_+3A_x">x</code></td>
<td>
<p>The <code>hwtANYN</code> object containing the Haar wavelet transform
coefficients you wish to plot.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_xlabvals">xlabvals</code></td>
<td>
<p>Coordinates of x-axis labels you wish to add.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_xlabchars">xlabchars</code></td>
<td>
<p>Labels to be printed at the x-axis labels specified.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_ylabchars">ylabchars</code></td>
<td>
<p>Y-axis labels</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_first.level">first.level</code></td>
<td>
<p>Specifies the coarsest level to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_main">main</code></td>
<td>
<p>Specify a different main title for the plot.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_scaling">scaling</code></td>
<td>
<p>How coefficients will be scaled on the plot.
This can be two arguments <code>"global"</code> where all coefficients
are plotted to the same scale and <code>"by.level"</code> where all
coefficients on the same resolution level are plotted to the same
scale, but coefficients on different resolution levels might be
of different scales. 
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_rhlab">rhlab</code></td>
<td>
<p>If <code>TRUE</code> then the scale factor used for each level is
shown.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_sub">sub</code></td>
<td>
<p>Specify a different subtitle for the plot.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_notplotval">NotPlotVal</code></td>
<td>
<p>Coefficients will not be plotted if their scaled
height is less than <code>NotPlotVal</code> in absolute value. This is a
useful way to completely suppress very small coefficient values.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_xlab">xlab</code></td>
<td>
<p>Specify the x-axis label.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_ylab">ylab</code></td>
<td>
<p>Specify the y-axis label.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_miss.coef.col">miss.coef.col</code></td>
<td>
<p>What color to plot &quot;missing coefficients&quot; in.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_miss.coef.cex">miss.coef.cex</code></td>
<td>
<p>How big to plot the &quot;missing coefficients&quot; symbol.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_miss.coef.pch">miss.coef.pch</code></td>
<td>
<p>The type of plotting character used to plot the
&quot;missing coefficients&quot;.
</p>
</td></tr>
<tr><td><code id="plot.hwtANYN_+3A_...">...</code></td>
<td>
<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot of the different wavelet coefficients at the scales
ranging from <code>first.level</code> to the finest scale. Note, in this
plot the coefficients are NOT aligned with time at different
scales in the same way as in the <code>wd</code> type plot
- except the finest scale.
</p>
<p>The Haar wavelet transform objects that this function plots
are obtained originally from vectors of non-dyadic length. One
can think of such a vector as a sub-vector of a longer vector
of dyadic length. E.g. if your vector is of length 35 then it is
a sub-vector of a vector of 64 (the next highest power of two).
So, you can think of the Haar wavelet transform being of a vector
of length 64 where 64-35=29 of the observations are missing. These
missing observations &quot;contribute&quot; to wavelet (and scaling function)
coefficients that are missing. This function has the ability to
plot the &quot;missing&quot; coefficients, by default as small red triangles.
The user can control the colour, size and plotting character of the
missing observations.
</p>


<h3>Value</h3>

<p>A single vector of length the number of levels plotted containing
the value of the maximum absolute coefficient value.
</p>


<h3>Author(s)</h3>

<p>G. P. Nason
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>
<p>Priestley, M.B. and Subba Rao (1969) A test for non-stationarity of
time series. <em>J. R. Statist. Soc. B</em>, <b>31</b>, 140-149.
</p>
<p>von Sachs, R. and Neumann, M.H. (2000) A wavelet-based test for
stationarity. <em>J. Time Ser. Anal.</em>, <b>21</b>,
597-613.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hwt">hwt</a></code>, <code><a href="#topic+print.hwtANYN">print.hwtANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate test data of length 82
#
v3 &lt;- rnorm(82)
#
# Compute Haar wavelet transform, note reindex has to be true for subsequent
# plot.
#
v3.hwt &lt;- hwt(v3, reindex=TRUE)
#
#
## Not run: plot(v3.hwt)
</code></pre>

<hr>
<h2 id='plot.lacf'>Plot localized autocovariance (lacf) object.
</h2><span id='topic+plot.lacf'></span>

<h3>Description</h3>

<p>Produces various ways of looking at a localized autocovariance
(lacf) object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacf'
plot(x, plotcor = TRUE, type = "line",
        lags = 0:min(as.integer(10 * log10(nrow(x$lacf))), ncol(x$lacf) - 1),
        tcex = 1, lcol = 1, llty = 1, the.time = NULL, plot.it=TRUE,
	xlab, ylab, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lacf_+3A_x">x</code></td>
<td>
<p>The localized autocovariance object you want to plot (lacf)
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_plotcor">plotcor</code></td>
<td>
<p>If TRUE then plot autocorrelations, otherwise plot
autocovariances.
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_type">type</code></td>
<td>
<p>The lacf objects are fairly complex and so there are
different ways you can plot them. The <code>type</code>s are
<code>line</code>, <code>persp</code> or <code>acf</code>, see the details for
description. Note that the <code>line</code> plot only works with
correlations currently.
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_lags">lags</code></td>
<td>
<p>The <code>lags</code> that you wish included in the plot.
The default is all the lags from 0 up to the maximum that
is used in the R acf plot 
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_tcex">tcex</code></td>
<td>
<p>In the <code>line</code> plot lines are plotted that indicate
the time-varying correlation. Each lag gets a different line
and the lines are differentiated by the lag id being placed
at intervals along the line. This argument changes the
size of those ids (numbers).
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_lcol">lcol</code></td>
<td>
<p>Controls the colours of the lines in the <code>line</code>
plot.
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_llty">llty</code></td>
<td>
<p>Controls the line types of the lines in the <code>line</code>
plot.
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_the.time">the.time</code></td>
<td>
<p>If the <code>acf</code> plot is chosen then you have to specify
a time point about which to plot the acf. I.e. in general this
funcion's lacf argument is a 2D function: <code class="reqn">c(t, \tau)</code>, the
<code>acf</code> plot produces a plot like the regular acf function
and so you have to turn the 2D <code class="reqn">c(t, \tau)</code> into a
1D function <code class="reqn">c(t_0, \tau)</code> by specifying a fixed time
point <code class="reqn">t_0</code>.
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>TRUE</code> the plot is produced and displayed. If
<code>FALSE</code> then no plot is produced but the autocovariance
or autocorrelation values that would have been produced are
returned as numerical values instead. This means that
this function is an extractor function for the <code>lacf</code>
class object.
</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label, constructed internally if not supplied</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label, constructed internally if not supplied</p>
</td></tr>
<tr><td><code id="plot.lacf_+3A_...">...</code></td>
<td>
<p>Other arguments to plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces pictures of the
two-dimensional time-varying autocovariance
or autocorrelation, <code class="reqn">c(t, \tau)</code>,
of a locally stationary time series.
There are three types of plot depending on the argument to
the <code>type</code> argument.
</p>
<p>The <code>line</code> plot draws the autocorrelations as a series of
lines, one for each lag, as lines over time. E.g. a sequence
#of lines <code class="reqn">c(t, \tau_i)</code> is drawn, one for each <code class="reqn">\tau_i</code>.
The zeroth lag line is the autocorrelation at lag 0 which is
always 1. By default all the lags are drawn which can result
in a confusing picture. Often, one is only interested in the low
level lags, so only these can be plotted by changing the <code>lags</code>
argument and any selection of lags can be plotted. The colour
and line type of the plotted lines can be changed with the
<code>lcol</code> and the <code>llty</code> arguments.
</p>
<p>The <code>acf</code> plot produces pictures similar to the standard
R <code>acf()</code> function plot. However, the regular acf is a
1D function, since it is defined to be constant over all time.
The time-varying acf supplied to this function is not constant
over all time (except for stationary processes, theoretically).
So, this type of plot requires the user to specify a fixed
time at which to produce the plot, and this is supplied by
the <code>the.time</code> argument.
</p>
<p>The <code>persp</code> plot plots the 2D function <code class="reqn">c(t, \tau)</code>
as a perspective plot. 
</p>


<h3>Value</h3>

<p>For the <code>acf</code> type plot the acf values are returned
invisibly. For the other types nothing is returned.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, G.P. (2012) Costationarity of Locally 
Stationary Time Series using <code>costat</code>.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>
<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lacf">lacf</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make some dummy data, e.g. white noise
#
v &lt;- rnorm(256)
#
# Compute the localized autocovariance (ok, the input is stationary
# but this is just an example. More interesting things could be achieved
# by putting the results of simulating from a LSW process, or piecewise
# stationary by concatenating different stationary realizations, etc.
#
vlacf &lt;- lacf(v, lag.max=30)
#
# Now let's do some plotting of the localized autocovariance
#
## Not run: plot(vlacf, lags=0:6)
#
# Should get a plot where lag 0 is all up at value 1, and all other
# autocorrelations are near zero (since its white noise).
#
#
# How about just looking at lags 0, 2 and 4, and some different colours.
#
## Not run: plot(vlacf, lags=c(0,2,4), lcol=c(1,2,3))
#
# O.k. Let's concentrate on time t=200, let's look at a standard acf
# plot near there.
#
## Not run: plot(vlacf, type="acf", the.time=200)
#
# Now plot the autocovariance, rather than the autocorrelation.
#
## Not run: plot(vlacf, type="acf", the.time=200, plotcor=FALSE)
#
# Actually, the plot doesn't look a lot different as the series is white
# noise, but it is different if you look closely.
</code></pre>

<hr>
<h2 id='plot.lacfCI'>Plot confidence intervals for localized autocovariance for
locally stationary time series.
</h2><span id='topic+plot.lacfCI'></span>

<h3>Description</h3>

<p>Plot the localized autocovariance and
approximate confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacfCI'
plot(x, plotcor = TRUE, type = "line",
    lags = 0:as.integer(10 * log10(nrow(x$lacf))), tcex = 1,
    lcol = 1, llty = 1, ylim = NULL, segwid = 1,
    segandcross = TRUE, conf.level = 0.95, plot.it = TRUE,
    xlab, ylab, sub, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.lacfCI_+3A_x">x</code></td>
<td>
<p>The <code>lacfCI</code> object you wish to plot, e.g. produced
by the <code>Rvarlacf</code> function.
</p>
</td></tr> 
<tr><td><code id="plot.lacfCI_+3A_plotcor">plotcor</code></td>
<td>
<p>If <code>TRUE</code> then autocorrelations are plotted,
if <code>FALSE</code> then autocovariances are. Note: not all combinations
of types of plot and <code>plotcor</code> are valid, but many are.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_type">type</code></td>
<td>
<p>This can be one of three values <code>"line"</code>,
<code>"persp"</code> or <code>"acf"</code>. The value
<code>"acf"</code> produces a plot like the regular <code>acf</code>
function, but note, the values plotted are from a localized
autocovariance function centred at the time location
contained in the <code>object</code> object (and that time appears in
the subtitle). This is the only plot that also plots the
confidence intervals. The <code>"line"</code> plot plots 
autocorrelations (only) for the specified <code>lags</code>
and does this over all time for the whole extent of the
series. This plot is useful to see if the autocorrelations
are changing over time. The final option,
<code>"persp"</code> produces a perspective plot of the autocovariance
or autocorrelations. Arguments can be supplied (<code>theta</code>,
<code>phi</code>) to rotate the perspective plot, as it can be
sometimes hard to visualize the plot.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_lags">lags</code></td>
<td>
<p>The lags that you wish to display. This
should be a list of non-negative integers, but not necessarily
consecutive.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_tcex">tcex</code></td>
<td>
<p>On the <code>"line"</code> plot this argument controls
the expansion of the font for the labels on the lines.
So, setting <code>tcex=2</code>, for example, will double the size
of these. These labels visually indicate which line corresponds
to which lag.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_lcol">lcol</code></td>
<td>
<p>On the <code>"line"</code> plot, this argument
controls the colour of the lines that are used to show
the acfs.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_llty">llty</code></td>
<td>
<p>As <code>lcol</code> but for line types.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_ylim">ylim</code></td>
<td>
<p>The vertical limits of the plot.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_segwid">segwid</code></td>
<td>
<p>On the <code>"acf"</code> plot, this argument controls
the widths of the little acf segments that connect the x-axis
with the acf values.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_segandcross">segandcross</code></td>
<td>
<p>If <code>TRUE</code> then a small diamond is plotted
at the location of the acf, to make it clearer.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level of the confidence intervals.
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_plot.it">plot.it</code></td>
<td>
<p>If <code>FALSE</code> then no plot is produced. This
can be used if you merely want to extract the relevant
acf values (which are returned).
</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_xlab">xlab</code></td>
<td>
<p>X-axis label, constructed internally if not supplied</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_ylab">ylab</code></td>
<td>
<p>Y-axis label, constructed internally if not supplied</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_sub">sub</code></td>
<td>
<p>A subtitle for the plot</p>
</td></tr>
<tr><td><code id="plot.lacfCI_+3A_...">...</code></td>
<td>
<p>Other arguments to the main <code>plot</code> command.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can plot the localized autocovariance in
three ways. Like a regular acf plot (but obviously a slice
out of a time-varying autocovariance, not the regular acf),
a line plot which shows the acfs over time and a perspective
plot which can plot the estimate of <code class="reqn">c(z, \tau)</code> as a
2D function. Currently, the confidence intervals can only
be displayed on the <code>"acf"</code> type plot.
</p>


<h3>Value</h3>

<p>A vector of the extracted acfvals invisibly returned.
Note: what is returned depends on the arguments, what is
returned is what would have been plotted if <code>plot.it</code>
were <code>TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Rvarlacf">Rvarlacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Simulate a TVAR(1) process
#
x &lt;- tvar1sim()
#
# Computes its time-localized autocovariance and confidence intervals
# Note: smoothing is done automatically!
#
x.lacf &lt;- Rvarlacf(x=x, nz=50, var.lag.max=20)
#
# Now plot this, plot covariances as an acf plot, with the CIs
#
## Not run: plot(x.lacf, type="acf", plotcor=FALSE)
#
# Now plot it as a line plot, as correlations and can't do CIs
#
## Not run: plot(x.lacf)
</code></pre>

<hr>
<h2 id='plot.tos'>Produces a graphical representation of the results of a
test of stationarity contained in a <code>tos</code> object.
</h2><span id='topic+plot.tos'></span>

<h3>Description</h3>

<p>After a test of stationarity for dyadic data
(e.g. <code><a href="#topic+hwtos2">hwtos2</a></code>)
is applied to a time series it generates a results object of
class <code>tos</code>. This function takes objects of that
class and produces a graphical representation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tos'
plot(x, mctype = "FDR", sub = NULL, xlab = "Time",
    arrow.length = 0.05, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tos_+3A_x">x</code></td>
<td>
<p>The <code>tos</code> class object, the results of the
test of stationarity that you wish to plot.
</p>
</td></tr>
<tr><td><code id="plot.tos_+3A_mctype">mctype</code></td>
<td>
<p>Whether you wish to see rejections (if they exist)
according to a Bonferroni assessment (<code>"BON"</code>) or
according to FDR (<code>"FDR"</code>)</p>
</td></tr>
<tr><td><code id="plot.tos_+3A_sub">sub</code></td>
<td>
<p>An argument to change the subtitle.
</p>
</td></tr>
<tr><td><code id="plot.tos_+3A_xlab">xlab</code></td>
<td>
<p>An argument to change the x-axis label.
</p>
</td></tr>
<tr><td><code id="plot.tos_+3A_arrow.length">arrow.length</code></td>
<td>
<p>The length of the edges of the arrow
head (in inches). Note that this is the argument that is
supplied as the <code>length</code> argument of the <code>arrow</code>
function that is called by this routine to draw the arrows.
</p>
</td></tr>
<tr><td><code id="plot.tos_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then some meaningless debugging
information is printed.
</p>
</td></tr>
<tr><td><code id="plot.tos_+3A_...">...</code></td>
<td>

<p>Other arguments to the main <code>ts.plot</code> routine that
does the plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following things are usually plotted. 1. The time series
that was investigated. The left-hand axes is that for the time series.
The horizontal axis is time (but just integers indexing).
If the series was deemed stationary by the test then that's it
except that the subtitle indicates that no Haar wavelet coefficients
were rejected as being nonzero.
</p>
<p>If the test indicated that the series was nonstationary then
the subtitle indicates this by stating the number of rejections
(this might be according to FDR or Bonferroni depending on 
the setting of the <code>mctype</code> argument. Then graphical
representations of any significant Haar wavelet coefficients
are plotted as double-headed red horizontal arrows on the plot.
The horizontal extent corresponds to the support of the underlying
wavelet. The vertical position of the arrows gives an indication
of the wavelet periodogram scale where the significant coefficient
was found. The wavelet periodogram scales are indexed by the right
hand axis, and beware, the numbers might not be consecutive, but
they will be ordered (so e.g. if no signficant coefficients were
discovered at wavelet periodogram scale level 6, then that scale/axis
label will not appear). The scale within the Haar wavelet transform
is indicated by the vertical position WITHIN ticks between
wavelet periodogram scales (ie, there are TWO scales: the wavelet
periodogram scale that is currently being analyzed, and the
Haar wavelet transform scale within the periodogram scale).
So, if two right hand axis labels are, e.g., 4 and 5, and
horizontal arrows appear between these two they actually correspond
to different Haar wavelet transform scales AT wavelet periodogram
level 4. It is not usually possible to tell precisely which
Haar wavelet transform scale the coefficients can come from,
but the information can be extracted from the <code><a href="#topic+summary.tos">summary.tos</a></code>
function which lists this.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos2">hwtos2</a></code>, <code><a href="#topic+summary.tos">summary.tos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Produces an interesting plot with high probability
#
#
# Note that the input time series is two concatenated white noise
# sequences with very different variances.
#
answer &lt;- hwtos2(c(rnorm(256), rnorm(256, sd=5)))
## Not run: plot(answer)
</code></pre>

<hr>
<h2 id='plot.tosANYN'>Produces a graphical representation of the results of a
test of stationarity from a <code>tosANYN</code> object.
</h2><span id='topic+plot.tosANYN'></span>

<h3>Description</h3>

<p>After a test of stationarity (e.g. <code><a href="#topic+hwtos">hwtos</a></code>)
is applied to a time series it generates a results object of
class <code>tosANYN</code>. This function takes objects of that
class and produces a graphical representation of the test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tosANYN'
plot(x, sub = NULL, xlab = "Time",
    arrow.length = 0.05, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tosANYN_+3A_x">x</code></td>
<td>
<p>The <code>tosANYN</code> class object, the results of the
test of stationarity that you wish to plot.
</p>
</td></tr>
<tr><td><code id="plot.tosANYN_+3A_sub">sub</code></td>
<td>
<p>An argument to change the subtitle.
</p>
</td></tr>
<tr><td><code id="plot.tosANYN_+3A_xlab">xlab</code></td>
<td>
<p>An argument to change the x-axis label.
</p>
</td></tr>
<tr><td><code id="plot.tosANYN_+3A_arrow.length">arrow.length</code></td>
<td>
<p>The length of the edges of the arrow
head (in inches). Note that this is the argument that is
supplied as the <code>length</code> argument of the <code>arrow</code>
function that is called by this routine to draw the arrows.
</p>
</td></tr>
<tr><td><code id="plot.tosANYN_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code> then some meaningless debugging
information is printed.
</p>
</td></tr>
<tr><td><code id="plot.tosANYN_+3A_...">...</code></td>
<td>

<p>Other arguments to the main <code>ts.plot</code> routine that
does the plotting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following things are usually plotted. 1. The time series
that was investigated. The left-hand axes is that for the time series.
The horizontal axis is time (but just integers indexing).
If the series was deemed stationary by the test then that's it
except that the subtitle indicates that no Haar wavelet coefficients
were rejected as being nonzero.
</p>
<p>If the test indicated that the series was nonstationary then
the subtitle indicates this by stating the number of rejections.
Then graphical
representations of any significant Haar wavelet coefficients
are plotted as double-headed red horizontal arrows on the plot.
The horizontal extent corresponds to the support of the underlying
wavelet. The vertical position of the arrows gives an indication
of the wavelet periodogram scale where the significant coefficient
was found. The wavelet periodogram scales are indexed by the right
hand axis, and beware, the numbers might not be consecutive, but
the will be ordered (so e.g. if no signficant coefficients were
discovered at wavelet periodogram scale level 6, then that scale/axis
label will not appear). The scale within the Haar wavelet transform
is indicated by the vertical position WITHIN ticks between
wavelet periodogram scales (ie, there are TWO scales: the wavelet
periodogram scale that is currently being analyzed, and the
Haar wavelet transform scale within the periodogram scale).
So, if two right hand axis labels are, e.g., 4 and 5, and
horizontal arrows appear between these two they actually correspond
to different Haar wavelet transform scales AT wavelet periodogram
level 4. It is not usually possible to tell precisely which
Haar wavelet transform scale the coefficients can come from,
but the information can be extracted from the <code><a href="#topic+summary.tosANYN">summary.tosANYN</a></code>
function which lists this.
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos">hwtos</a></code>, <code><a href="#topic+summary.tosANYN">summary.tosANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Produces an interesting plot with high probability
#
#
# Note that the input time series is two concatenated white noise
# sequences with very different variances.
#
## Not run: answer &lt;- hwtos(c(rnorm(256), rnorm(256, sd=5)))
## Not run: plot(answer)
</code></pre>

<hr>
<h2 id='print.hwtANYN'>Print out a <code>hwtANYN</code> class object, eg from the <code>link{hwt}</code>
function.
</h2><span id='topic+print.hwtANYN'></span>

<h3>Description</h3>

<p>Prints out very basic information on an object that
represents a Haar wavelet transform of a data set of non-dyadic length. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hwtANYN'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.hwtANYN_+3A_x">x</code></td>
<td>

<p>The object you wish to print.
</p>
</td></tr>
<tr><td><code id="print.hwtANYN_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function calls the <code><a href="#topic+summary.hwtANYN">summary.hwtANYN</a></code>
function as its last action. So, the return from this
function is the return from <code><a href="#topic+summary.hwtANYN">summary.hwtANYN</a></code>
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwt">hwt</a></code>, <code><a href="#topic+summary.hwtANYN">summary.hwtANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate test vector of length 5
#
v2 &lt;- rnorm(5)
#
# Compute Haar wavelet transform
#
v2.hwt &lt;- hwt(v2)
#
# Print out the answer
#
print(v2.hwt)
#Class 'hwtANYN' : Haar Wavelet for Arbitrary Length Data object:
#       ~~~~~~~  : List with 5 components with names
#		   c d nlevels type reindex 
#
#
#summary(.):
#----------
#Levels:  2 
#Filter was: Haar
#Transform type:  wavelet 
#Object was reindex to match wd:  FALSE 
</code></pre>

<hr>
<h2 id='print.lacf'>Print lacf class object
</h2><span id='topic+print.lacf'></span>

<h3>Description</h3>

<p>Prints information about lacf class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lacf_+3A_x">x</code></td>
<td>
<p>The lacf class object you want to print
</p>
</td></tr>
<tr><td><code id="print.lacf_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, G.P. (2012) Costationarity of Locally 
Stationary Time Series using <code>costat</code>.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>
<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lacf">lacf</a></code>, <code><a href="#topic+plot.lacf">plot.lacf</a></code>, <code><a href="#topic+summary.lacf">summary.lacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make some dummy data, e.g. white noise
#
v &lt;- rnorm(256)
#
# Compute the localized autocovariance (ok, the input is stationary
# but this is just an example. More interesting things could be achieved
# by putting the results of simulating from a LSW process, or piecewise
# stationary by concatenating different stationary realizations, etc.
#
vlacf &lt;- lacf(v, lag.max=30)
#
# Now let's print the lacf object 
#
print(vlacf)
#Class 'lacf' : Localized Autocovariance/correlation Object:
#       ~~~~  : List with 3 components with names
#             lacf lacr date 
#
#
#summary(.):
#----------
#Name of originating time series:  
#Date produced:  Thu Oct 25 12:11:29 2012 
#Number of times:  256 
#Number of lags:  30 
</code></pre>

<hr>
<h2 id='print.lacfCI'>Print basic information about a <code>lacfCI</code> object.
</h2><span id='topic+print.lacfCI'></span>

<h3>Description</h3>

<p>Prints basic information about a <code>lacfCI</code> object, which
contains information on confidence intervals for localized
autocovariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacfCI'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lacfCI_+3A_x">x</code></td>
<td>
<p>The <code>lacfCI</code> object.
</p>
</td></tr>
<tr><td><code id="print.lacfCI_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The last action of this function is to compute
<code><a href="#topic+summary.tos">summary.tos</a></code> so the return code is whatever
that function returns.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lacfCI">summary.lacfCI</a></code>, <code><a href="#topic+Rvarlacf">Rvarlacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example on Rvarlacf help page
</code></pre>

<hr>
<h2 id='print.tos'>Print out a <code>tos</code> class object, eg from the <code>link{hwtos2}</code>
function.
</h2><span id='topic+print.tos'></span>

<h3>Description</h3>

<p>Prints out very basic information on an object that
represents the output from a test of stationarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tos'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tos_+3A_x">x</code></td>
<td>

<p>The object you wish to print.
</p>
</td></tr>
<tr><td><code id="print.tos_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function calls the <code><a href="#topic+summary.tos">summary.tos</a></code>
function as its last action. So, the return from this
function is the return from <code><a href="#topic+summary.tos">summary.tos</a></code>
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos2">hwtos2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example at end of help for hwtos2
#
</code></pre>

<hr>
<h2 id='print.tosANYN'>Print out a <code>tosANYN</code> class object, eg from the <code>link{hwtos}</code>
function.
</h2><span id='topic+print.tosANYN'></span>

<h3>Description</h3>

<p>Prints out very basic information on an object that
represents the output from a test of stationarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tosANYN'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.tosANYN_+3A_x">x</code></td>
<td>

<p>The object you wish to print.
</p>
</td></tr>
<tr><td><code id="print.tosANYN_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function calls the <code><a href="#topic+summary.tosANYN">summary.tosANYN</a></code>
function as its last action. So, the return from this
function is the return from <code><a href="#topic+summary.tosANYN">summary.tosANYN</a></code>
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos">hwtos</a></code>,<code><a href="#topic+summary.tosANYN">summary.tosANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example at end of help for hwtos
#
</code></pre>

<hr>
<h2 id='runmean'>Compute a running mean of a vector
</h2><span id='topic+runmean'></span>

<h3>Description</h3>

<p>This function essentially uses the <code>running.mean</code>
function from the <code>igraph</code> package. However, adjustments
are made to ensure that the output is always the same length
as the input (by fiddling at the boundaries).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runmean(x, binwidth)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runmean_+3A_x">x</code></td>
<td>
<p>Vector that you wish to smooth using a running mean.
</p>
</td></tr>
<tr><td><code id="runmean_+3A_binwidth">binwidth</code></td>
<td>
<p>Number of ordinates over which you wish to average
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, if <code>binwidth=2</code> and <code>x=1:6</code> then
the function averages each pair to get 1.5, 2.5, 3.5, 4.5, 5.5.
However, this is only 5 numbers and the input had 6. So, in this
case the function arranges for the output to be extended (in this
case 1 gets padded onto the front. For vectors of length &gt; 3
the padding depends on whether the vector is even or odd.
</p>


<h3>Value</h3>

<p>The running mean of the input at the given bandwidth.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ewspec3">ewspec3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>runmean(1:6, 2)
#
# [1] 1.0 1.5 2.5 3.5 4.5 5.5
#
runmean(1:14, 4)
#
#  [1]  1.75  2.50  3.50  4.50  5.50  6.50  7.50  8.50  9.50 10.50 11.50 12.5
# [13] 13.25 13.50
#
</code></pre>

<hr>
<h2 id='Rvarlacf'>
Compute confidence intervals for localized autocovariance for
locally stationary time series.
</h2><span id='topic+Rvarlacf'></span>

<h3>Description</h3>

<p>Compute a localized autocovariance and associated
confidence intervals for a locally stationary time
series. The underlying theory assumes a locally stationary
wavelet time series, but will work well for other time
series that are not too far away.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rvarlacf(x, nz, filter.number = 1, family = "DaubExPhase",
    smooth.dev = var, AutoReflect = TRUE, lag.max = NULL,
    WPsmooth.type = "RM", binwidth = 0, mkcoefOBJ, ThePsiJ,
    Cverbose = 0, verbose = 0, OPLENGTH = 10^5, var.lag.max = 3,
    ABB.tol = 0.1, ABB.plot.it = FALSE, ABB.verbose = 0,
    ABB.maxits = 10, truedenom=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rvarlacf_+3A_x">x</code></td>
<td>
<p>The time series you wish to analyze
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_nz">nz</code></td>
<td>
<p>The time point at which you wish to compute the
localized autocovariance for.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_filter.number">filter.number</code></td>
<td>
<p>The analysis wavelet for many things, including
smoothing. See <code>wd</code> for information on the various types.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_family">family</code></td>
<td>
<p>The analysis wavelet family. See <code>wd</code> again.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_smooth.dev">smooth.dev</code></td>
<td>
<p>The deviance function used to perform smoothing of
the evolutionary wavelet spectrum. 
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_autoreflect">AutoReflect</code></td>
<td>
<p>The internal wavelet transforms assume periodic
boundary conditions. However, most time series are not
periodic (in terms of their support, e.g. the series at time
1 is not normally anywhere near the value of the series at
time T). This argument, if <code>TRUE</code> mitigates this
by reflecting the whole series by the right-hand end, computing
the transform (for which periodic transforms are now valid)
and then junking the second half of the estimate. Although this
is slightly more computationally intensive, the results are better.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_lag.max">lag.max</code></td>
<td>
<p>The maximum number of lags to compute the localized
autocovariance for. The default is the same as in the
regular <code>acf</code> function.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_wpsmooth.type">WPsmooth.type</code></td>
<td>
<p>The type of smoothing of the evolutionary
wavelet spectrum and the localized autocovariance. See the
arguments to <code><a href="#topic+lacf">lacf</a></code>.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_binwidth">binwidth</code></td>
<td>
<p>The smoothing bandwidth associated with the
smoothing controlled by <code>WPsmooth.type</code>. If this value
is zero then the <code>binwidth</code> is computed automatically
by the routine. And if <code>verbose&gt;0</code> the value is also
printed.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_mkcoefobj">mkcoefOBJ</code></td>
<td>
<p>Optionally, the appropriate discrete wavelet
transform object can be supplied. If it is not supplied
then the routine automatically computes it. There is a small
saving in providing it, so for everyday use probably not worth
it.  
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_thepsij">ThePsiJ</code></td>
<td>
<p>As for <code>mkcoefOBJ</code> but the autocorrelation
wavelet object.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_cverbose">Cverbose</code></td>
<td>
<p>If positive integer then the called C code produces
verbose messages. Useful for debugging. 
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_verbose">verbose</code></td>
<td>
<p>If positive integer &gt;0 then useful messages are printed.
Higher values give more information.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_oplength">OPLENGTH</code></td>
<td>
<p>Parameter that controls storage allocated to
the <code>PsiJ</code> routine. It is possible, for large time series,
you might be asked to increase this value.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_var.lag.max">var.lag.max</code></td>
<td>
<p>Number of lags that you want to compute confidence
intervals for. Usually, it is quick to compute for more lags,
so this could usually be set to be the value of <code>lag.max</code>
above. 
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_abb.tol">ABB.tol</code></td>
<td>

<p>The routine selects the automatic bandwidth via a golden section
search. This argument controls the optimization tolerance.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_abb.plot.it">ABB.plot.it</code></td>
<td>
<p>Whether or not to plot the iterations of the
automatic bandwidth golden section search. (<code>TRUE</code>/<code>FALSE</code>)
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_abb.verbose">ABB.verbose</code></td>
<td>
<p>Positive integer controlling the amount of
detail from the automatic bandwidth golden section search
algorithm. If zero nothing is produced.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_abb.maxits">ABB.maxits</code></td>
<td>

<p>The maximum number of iterations in the automatic bandwidth
golden section search.
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_truedenom">truedenom</code></td>
<td>
<p>If TRUE use the actual number of terms in the sum as
the denominator in the formula for the calculation of the
covariance of the smoothed periodogram. If FALSE use the
eqn(2s+1)^-2 (this was the default in versions prior to
1.7.4)
</p>
</td></tr>
<tr><td><code id="Rvarlacf_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1. If <code>binwidth=0</code> the function first computes the
&lsquo;best&rsquo; linear running mean binwidth (bandwidth)
for the smooth of the localized autocovariance.
2. The function computes the localized autocovariance
smoothed with a running mean with the selected binwidth.
Then, the variance of <code class="reqn">\hat{c}(z, \tau)</code> is
computed for the selected value of time z=nz and for the
lags specified (in <code>var.lag.max</code>). The results are
returned in an object of class <code>lacfCI</code>.
</p>
<p>Note, this function
computes and plots localized autocovariances for a particular
and fixed time location. Various other plots, including
perspective plots or the localized autocovariance function
over all time can be found in the <code>costat</code> package.
(Indeed, this function returns a <code>lacfCI</code> object that
contains a <code>lacf</code> object, and interesting plots
can be plotted using the <code>plot.lacf</code> function within
<code>costast</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>lacfCI</code>. This is a list with
the following components.
</p>
<table role = "presentation">
<tr><td><code>lag</code></td>
<td>
<p>The lags for which the localized autocovariance variance is
computed</p>
</td></tr>
<tr><td><code>cvar</code></td>
<td>
<p>The variances associated with each localized autocovariance</p>
</td></tr>
<tr><td><code>the.lacf</code></td>
<td>
<p>The <code>lacf</code> class object that contains the
localized autocovariances themselves. This object
can be handled/plotted/etc using the functions
in the <code>costat</code> package although <code>plot.lacfCI</code>
contains much of the functionality of <code>plot.lacf</code>.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lacfCI">plot.lacfCI</a></code>, <code><a href="#topic+print.lacfCI">print.lacfCI</a></code>,
<code><a href="#topic+summary.lacfCI">summary.lacfCI</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Do localized autocovariance on a iid Gaussian sequence
#
tmp &lt;- Rvarlacf(rnorm(256), nz=125)
#
# Plot the localized autocovariances over time (default plot, doesn't
# produce CIs)
#
## Not run: plot(tmp)
#
# You should get a plot where the lag 0 acs are all near 1 and all the
# others are near zero, the acfs over time. 
#
## Not run: plot(tmp, plotcor=FALSE, type="acf")
#
# This plots the autocovariances (note: \code{plotcor=FALSE}) and the
# type of plot is \code{"acf"} which means like a regular ACF plot, except
# this is c(125, tau), ie the acf localized to time=125 The confidence
# intervals are also plotted. 
# The plot subtitle indicates that it is c(125, tau) that is being plotted
#
</code></pre>

<hr>
<h2 id='StoreStatistics'>Interogates calculation store to see how well we are
reusing previous calculations (debugging)
</h2><span id='topic+StoreStatistics'></span>

<h3>Description</h3>

<p>The computation of the variance of the lacf
estimator is intensive and we try to speed that up
by reusing calculations. These calculations are stored
in internal C arrays. This function interrogates those
arrays and can provide details on how well the storage
is working and provide hints if more storage needs to be
allocated. For very large time series it is possible that
values need to be calculated that can be stored and this
function can monitor this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StoreStatistics()
</code></pre>


<h3>Details</h3>

<p>The function prints out the state of the storage.
Three numbers are reported on. 1. The number of values
that were calculated but not stored &quot;outside framework&quot;.
Ideally you want this number to be low, if it gets persistently
high then more storage needs to be allocated in the
C code (notably MAXELL, MAXJ, MAXK, MAXD for the
ThmStore and ValExists arrays). 
</p>
<p>The other two numbers are &quot;Number stored&quot; and &quot;Number found&quot;.
The first number corresponds to the number of values calculated
once and then stored. The second number contains the
number of times the software interogated the store and found
a value that it did not have to then calculate. So,
ideally, you'd like the latter number to be a high percentage
of the former number, as this means the store is working
efficiently.
</p>
<p>Note, this function is definitely not intended for
casual users. However, for users of very large series,
who have the computational resources, these storage parameters
might need to be increased.
</p>
<p>The values will be zero if <code><a href="#topic+Rvarlacf">Rvarlacf</a></code> has not
yet been called, and only refer to the last call to that function
(as the function zeroes the store on invocation).
</p>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Rvarlacf">Rvarlacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Simulate some data
#
x &lt;- tvar1sim()
#
# Calculate lacf and confidence intervals
#
x.lacf &lt;- Rvarlacf(x=x, nz=50, var.lag.max=20)
#
# Find out how the store did
#
StoreStatistics()
#Number calculated outside framework:  0 
#Number calculated then stored:  154440 
#Number found in store:  14980680 
#
#Overall % calculated:  1.020408 
#% outside framework:  0 
</code></pre>

<hr>
<h2 id='summary.hwtANYN'>Summarize the results of a Haar wavelet transform object computed
from an arbitrary length vector. 
</h2><span id='topic+summary.hwtANYN'></span>

<h3>Description</h3>

<p>This function summarizes the results of a <code>hwtANYN</code>
object that contains the results of a Haar wavelet transform that
had been carried out on an original vector of (potentially) non-dyadic
length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hwtANYN'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.hwtANYN_+3A_object">object</code></td>
<td>
<p>The object that you want a summary of. The object might be
the results from, e.g., <code><a href="#topic+hwt">hwt</a></code> function.</p>
</td></tr> 
<tr><td><code id="summary.hwtANYN_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwt">hwt</a></code>, <code><a href="#topic+print.hwtANYN">print.hwtANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See help for print.hwtANYN 
</code></pre>

<hr>
<h2 id='summary.lacf'>Summarizes a lacf object
</h2><span id='topic+summary.lacf'></span>

<h3>Description</h3>

<p>Summarizes a lacf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lacf_+3A_object">object</code></td>
<td>
<p>The lacf object you wish summarized.
</p>
</td></tr>
<tr><td><code id="summary.lacf_+3A_...">...</code></td>
<td>
<p>Other arguments
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Guy Nason
</p>


<h3>References</h3>

<p>Cardinali, A. and Nason, G.P. (2012) Costationarity of Locally 
Stationary Time Series using <code>costat</code>.
</p>
<p>Cardinali, A. and Nason, G.P. (2010) Costationarity of locally stationary
time series. <em>J. Time Series Econometrics</em>, <b>2</b>, Issue 2, Article 1.
</p>
<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lacf">lacf</a></code>, <code><a href="#topic+plot.lacf">plot.lacf</a></code>, <code><a href="#topic+print.lacf">print.lacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Make some dummy data, e.g. white noise
#
v &lt;- rnorm(256)
#
# Compute the localized autocovariance (ok, the input is stationary
# but this is just an example. More interesting things could be achieved
# by putting the results of simulating from a LSW process, or piecewise
# stationary by concatenating different stationary realizations, etc.
#
vlacf &lt;- lacf(v, lag.max=20)
#
# Now let's summarize the lacf object
#
summary(vlacf)
#Name of originating time series:  
#Date produced:  Thu Oct 25 12:11:29 2012 
#Number of times:  256 
#Number of lags:  20  
</code></pre>

<hr>
<h2 id='summary.lacfCI'>Produce a brief summary of the contents of a <code>lacfCI</code> object
</h2><span id='topic+summary.lacfCI'></span>

<h3>Description</h3>

<p>Produces brief summary of the contents of a <code>lacfCI</code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lacfCI'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lacfCI_+3A_object">object</code></td>
<td>

<p>The <code>lacfCI</code> object that you wish to glean info on
</p>
</td></tr>
<tr><td><code id="summary.lacfCI_+3A_...">...</code></td>
<td>

<p>Other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+print.lacfCI">print.lacfCI</a></code>,<code><a href="#topic+Rvarlacf">Rvarlacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example in the Rvarlacf function
</code></pre>

<hr>
<h2 id='summary.tos'>Summarize the results of a test of stationarity contained i
a <code>tos</code> object.
</h2><span id='topic+summary.tos'></span>

<h3>Description</h3>

<p>This function summarizes the results of a <code>tos</code>
object that contains information about a test of stationarity.
The summary function prints out information about how many
individual hypothesis tests there were, how many were rejected
and what the (equivalent) rejection p-value was (in the last cases
both for FDR and Bonferroni). If the hypothesis of stationarity
is rejected then the routine also prints out a list of the Haar
wavelet coefficients (and their scales, locations and scale of
the wavelet periodogram) that were significant.
The function also returns a lot of this information (invisibly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tos'
summary(object, size = 0.05, quiet = FALSE, mctype = "FDR", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tos_+3A_object">object</code></td>
<td>
<p>The output from a function that carries out a test
of stationarity, e.g. <code><a href="#topic+hwtos2">hwtos2</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.tos_+3A_size">size</code></td>
<td>
<p>The nominal overall significance level of the test.
</p>
</td></tr>
<tr><td><code id="summary.tos_+3A_quiet">quiet</code></td>
<td>
<p>If this argument is <code>TRUE</code> then nothing is printed
to the screen, although the information is still returned as
an object. If <code>FALSE</code> then this function prints out
the information about the hypothesis test.
</p>
</td></tr>
<tr><td><code id="summary.tos_+3A_mctype">mctype</code></td>
<td>
<p>This argument can be <code>"FDR"</code> for false discovery
rate or <code>"BON"</code> for Bonferroni. This argument does not
effect the basis printout. However, it does control whether
FDR or Bonferroni rejects are listed, and it does control
the type of information returned by the function (whether
FDR or Bonferroni info).
</p>
</td></tr>
<tr><td><code id="summary.tos_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list which contain a list of the
rejected coefficients. Each list item contains the index
of a particular rejected coefficient, which is a vector
of at least three elements. The first element corresponds to
the scale of the wavelet periodogram, the second is the level of
the Haar wavelet transform, and all remaining values are the
index of the significant wavelet coefficients at that Haar wavelet
transform scale. The list also contains the total number of
Haar wavelet coefficients rejected and the <code>mctype</code>
argument also.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos2">hwtos2</a></code>, <code><a href="#topic+print.tos">print.tos</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example for hwtos2, this contains two examples where
# summary.tos (as summary(.) is used in the output.
</code></pre>

<hr>
<h2 id='summary.tosANYN'>Summarize the results of a test of stationarity contained
in an <code>tosANYN</code> class object. 
</h2><span id='topic+summary.tosANYN'></span>

<h3>Description</h3>

<p>This function summarizes the results of a <code>tosANYN</code>
object that contains information about a test of stationarity.
The summary function prints out information about how many
individual hypothesis tests there were, how many were rejected.
If the hypothesis of stationarity
is rejected then the routine also prints out a list of the Haar
wavelet coefficients (and their scales, locations and scale of
the wavelet periodogram) that were significant.
The function also returns a lot of this information (invisibly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tosANYN'
summary(object, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.tosANYN_+3A_object">object</code></td>
<td>
<p>The output from a function that carries out a test
of stationarity, e.g. <code><a href="#topic+hwtos">hwtos</a></code>.</p>
</td></tr>
<tr><td><code id="summary.tosANYN_+3A_quiet">quiet</code></td>
<td>
<p>If this argument is <code>TRUE</code> then nothing is printed
to the screen, although the information is still returned as
an object. If <code>FALSE</code> then this function prints out
the information about the hypothesis test.
</p>
</td></tr>
<tr><td><code id="summary.tosANYN_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list which contain a list of the
rejected coefficients. Each list item contains the index
of a particular rejected coefficient, which is a vector
of at least three elements. The first element corresponds to
the scale of the wavelet periodogram, the second is the level of
the Haar wavelet transform, and all remaining values are the
index of the significant wavelet coefficients at that Haar wavelet
transform scale. The list also contains the total number of
Haar wavelet coefficients rejected and the <code>mctype</code>
argument also.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+hwtos">hwtos</a></code>, <code><a href="#topic+print.tosANYN">print.tosANYN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# See example for hwtos, this contains two examples where
# summary.tosANYN (as summary(.) is used in the output.
</code></pre>

<hr>
<h2 id='tvar1sim'>
Simulate a realization from a particular TVAR(1) model.
</h2><span id='topic+tvar1sim'></span>

<h3>Description</h3>

<p>Simulates a realization from a TVAR(1) model where
the AR(1) parameter moves from 0.9 to -0.9 in equal steps
over 512 time points. The realization is also of length 512.
The innovations are normally distributed with mean zero and
standard deviation of <code>sd</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvar1sim(sd = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvar1sim_+3A_sd">sd</code></td>
<td>
<p>This is the standard deviation of the Gaussian innovation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is easily converted into one that does the
same thing but for a different sample size.
</p>


<h3>Value</h3>

<p>A realization of the aforementioned TVAR(1) process.
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Rvarlacf">Rvarlacf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate realization from the TVAR(1) process
#
x &lt;- tvar1sim()
#
# Maybe plot it
#
## Not run: ts.plot(x)
</code></pre>

<hr>
<h2 id='varip2'>
Direct computation of estimate of variance of v_ip,
the Haar wavelet coefficients of the periodogram.
</h2><span id='topic+varip2'></span>

<h3>Description</h3>

<p>Performs a direct computation of an estimate
of the variance of the Haar wavelet coefficients of
the raw wavelet periodogram of a time series. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varip2(i, p, ll, S, P)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varip2_+3A_i">i</code></td>
<td>
<p>Scale parameter of Haar wavelet analyzing periodogram.
Scale 1 is the finest scale.
</p>
</td></tr>
<tr><td><code id="varip2_+3A_p">p</code></td>
<td>
<p>Location parameter of Haar wavelet analyzing periodogram
</p>
</td></tr>
<tr><td><code id="varip2_+3A_ll">ll</code></td>
<td>
<p>Scale of the raw wavelet periodogram being analyzed
</p>
</td></tr>
<tr><td><code id="varip2_+3A_s">S</code></td>
<td>

<p>Estimate of the spectrum, under the assumption of stationarity.
So, this is just a vector of (possibly) J scales (which is often
the usual spectral estimate averaged over time). Note: that the
main calling function, <code><a href="#topic+hwtos2">hwtos2</a></code>, actually passes
<code>maxD</code> levels.
</p>
</td></tr>
<tr><td><code id="varip2_+3A_p">P</code></td>
<td>
<p>Is an autocorrelation wavelet object, returned by the
<code>PsiJ</code> function. The wavelet concerned is the analyzing
one underlying the raw wavelet periodogram of the series.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the variance of the Haar wavelet coefficients of
the raw wavelet periodogram. Note, that this is merely
an estimate of the variances.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>covAA</code></td>
<td>
<p>A component of the variance</p>
</td></tr>
<tr><td><code>covAB</code></td>
<td>
<p>A component of the variance</p>
</td></tr>
<tr><td><code>covBB</code></td>
<td>
<p>A component of the variance</p>
</td></tr>
<tr><td><code>ans</code></td>
<td>
<p>The actual variance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Cvarip2">Cvarip2</a></code>,<code><a href="#topic+hwtos2">hwtos2</a></code>, <code><a href="#topic+covIwrap">covIwrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Generate autocorrelation wavelets
#
P1 &lt;- PsiJ(-5, filter.number=1, family="DaubExPhase")
#
#
# Now compute varip2: this is the variance of the Haar wavelet coefficient
# at the finest scale, location 10 and P1 autocorrelation wavelet.
# Note, I've used S to be the exact coefficients which would be for white noise.
# In practice, S would be an *estimate* calculated from the data.
#
varip2(i=1, p=10, ll=2, S=c(1/2, 1/4, 1/8, 1/16, 1/32), P=P1)
#
# Ans component is 1.865244
  </code></pre>

<hr>
<h2 id='whichlevel'>
Helper routine for <code>mkcoef</code>
</h2><span id='topic+whichlevel'></span>

<h3>Description</h3>

<p>Helps <code><a href="#topic+mkcoef">mkcoef</a></code> by finding out how many
more levels are required to compute a set of discrete
wavelets to a given (other) level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichlevel(J, filter.number = 10, family = "DaubLeAsymm")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="whichlevel_+3A_j">J</code></td>
<td>
<p>The level that <code><a href="#topic+mkcoef">mkcoef</a></code> wants to compute to.
</p>
</td></tr>
<tr><td><code id="whichlevel_+3A_filter.number">filter.number</code></td>
<td>
<p>The wavelet number (see <code>wd</code>)
</p>
</td></tr>
<tr><td><code id="whichlevel_+3A_family">family</code></td>
<td>
<p>The wavelet family (see <code>wd</code>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When computing the discrete wavelets up to a given scale
we use the inverse wavelet transform to do this. However, to
generate a wavelet within the range of a wavelet decomposition
you have to use more scales in the inverse wavelet transform
than first requested. This is because wavelet coefficients at
the coarsest scales are associated with wavelets whose support
is greater than the whole extent of the series. Hence, you 
have to have a larger wavelet transform, with more levels, insert
a coefficient mid-level to generate a discrete wavelet whose
support lies entirely within the extent of the series. This
function figures out what the extra number of levels should be.
</p>


<h3>Value</h3>

<p>Simply returns the required number of levels
</p>


<h3>Author(s)</h3>

<p>Guy Nason.
</p>


<h3>References</h3>

<p>Nason, G.P. (2013) A test for second-order stationarity and
approximate confidence intervals for localized autocovariances
for locally stationary time series. <em>J. R. Statist. Soc.</em> B,
<b>75</b>, 879-904.
<a href="https://doi.org/10.1111/rssb.12015">doi:10.1111/rssb.12015</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+mkcoef">mkcoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>whichlevel(6)
# [1] 11
#
# E.g. mkcoef wanted to generate 6 levels of discrete wavelets and
# whichlevel tells it that it needs to generate a wavelet transform
# of at least 11 levels.
</code></pre>

<hr>
<h2 id='zeropad'>Intersperse zeroes in a vector.
</h2><span id='topic+zeropad'></span>

<h3>Description</h3>

<p>Take a vector of any length and then intersperse zeroes
between existing elements (and add a further zero to the end).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeropad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zeropad_+3A_x">x</code></td>
<td>
<p>Vector that you want to intersperse zeros into.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Title says it all.
</p>


<h3>Value</h3>

<p>A vector whose odd elements are just <code>x</code> and whose
even elements are zeroes.
</p>


<h3>Author(s)</h3>

<p>G.P. Nason
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hwt">hwt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#
# Operate on a test set
#
v &lt;- 1:3
zeropad(v)
#[1] 1 0 2 0 3 0
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
