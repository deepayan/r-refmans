<!DOCTYPE html><html lang="en"><head><title>Help for package micEcon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {micEcon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#appleProdFr86'><p>Data on French Apple Producers in 1986</p></a></li>
<li><a href='#Bleymueller79E25.1'><p>Artificial Prices and Quantities</p></a></li>
<li><a href='#checkConsist'><p>Testing Theoretical Consistency</p></a></li>
<li><a href='#cobbDouglasCalc'><p>Calculate dependent variable of a Cobb-Douglas function</p></a></li>
<li><a href='#cobbDouglasDeriv'><p>Derivatives of a Cobb-Douglas function</p></a></li>
<li><a href='#cobbDouglasOpt'><p>Optimal Values of Independent Variables of a Cobb-Douglas Function</p></a></li>
<li><a href='#coef.quadFuncEst'><p>Coefficients of a Quadratic Function</p></a></li>
<li><a href='#coef.translogEst'><p>Coefficients of a Translog Function</p></a></li>
<li><a href='#elas'><p>Calculating and returning elasticities</p></a></li>
<li><a href='#germanFarms'><p>Output and Inputs of Farms in West-Germany</p></a></li>
<li><a href='#logDataSet'><p>Creating a Data Set with the Logarithms of the Original Variables</p></a></li>
<li><a href='#Missong03E7.7'><p>Meat Prices and Quantities in Germany</p></a></li>
<li><a href='#quadFuncCalc'><p>Calculate dependent variable of a quadratic function</p></a></li>
<li><a href='#quadFuncDeriv'><p>Derivatives of a quadratic function</p></a></li>
<li><a href='#quadFuncEla'><p>Elasticities of a Quadratic Function</p></a></li>
<li><a href='#quadFuncEst'><p>Estimate a quadratic function</p></a></li>
<li><a href='#residuals.translogEst'><p>Residuals of a Translog function</p></a></li>
<li><a href='#summary.translogEst'><p>Summarizing the Estimation of a Translog Function</p></a></li>
<li><a href='#translogCalc'><p>Calculate dependent variable of a translog function</p></a></li>
<li><a href='#translogCheckCurvature'><p>Curvature of a Translog Function</p></a></li>
<li><a href='#translogCheckMono'><p>Monotonicity of a Translog Function</p></a></li>
<li><a href='#translogCostEst'><p>Estimate a translog Cost Function</p></a></li>
<li><a href='#translogDeriv'><p>Derivatives of a translog function</p></a></li>
<li><a href='#translogEla'><p>Elasticities of a translog Function</p></a></li>
<li><a href='#translogEst'><p>Estimate a translog function</p></a></li>
<li><a href='#translogHessian'><p>Hessian matrix of a translog function</p></a></li>
<li><a href='#translogMonoRestr'><p>Monotonicity Restrictions of a Translog Function</p></a></li>
<li><a href='#translogProdFuncMargCost'><p>Marginal Costs of Translog Production Function</p></a></li>
<li><a href='#utility'><p>Fossil Fuel Fired Steam Electric Power Plants</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6-18</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Microeconomic Analysis and Modelling</td>
</tr>
<tr>
<td>Author:</td>
<td>Arne Henningsen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arne Henningsen &lt;arne.henningsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>miscTools (&ge; 0.6-1), plm (&ge; 1.1-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Ecdat (&ge; 0.1-5), systemfit (&ge; 1.0-0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Various tools for microeconomic analysis and microeconomic modelling,
   e.g. estimating quadratic, Cobb-Douglas and Translog functions,
   calculating partial derivatives and elasticities of these functions,
   and calculating Hessian matrices, checking curvature
   and preparing restrictions for imposing monotonicity of Translog functions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.micEcon.org">http://www.micEcon.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-03 20:03:18 UTC; gsl324</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-03 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='appleProdFr86'>Data on French Apple Producers in 1986</h2><span id='topic+appleProdFr86'></span>

<h3>Description</h3>

<p>The <code>appleProdFr86</code> data frame includes 
cross-sectional production data of 140 French apple producers 
from the year 1986. 
These data have been extracted from a panel data set
that was used in Ivaldi et al. (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(appleProdFr86)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>vCap</dt><dd><p>costs of capital (including land).</p>
</dd>
<dt>vLab</dt><dd><p>costs of labour 
(including remuneration of unpaid family labour).</p>
</dd>
<dt>vMat</dt><dd><p>costs of intermediate materials 
(e.g. seedlings, fertilizer, pesticides, fuel).</p>
</dd>
<dt>qApples</dt><dd><p>quantity index of produced apples.</p>
</dd>
<dt>qOtherOut</dt><dd><p>quantity index of all other outputs.</p>
</dd>
<dt>qOut</dt><dd><p>quantity index of all outputs
(not in the original data set, 
calculated as 580,000 <code class="reqn">\cdot</code> 
(<code>qApples</code> + <code>qOtherOut</code>)).</p>
</dd>
<dt>pCap</dt><dd><p>price index of capital goods</p>
</dd>
<dt>pLab</dt><dd><p>price index of labour.</p>
</dd>
<dt>pMat</dt><dd><p>price index of materials.</p>
</dd>
<dt>pOut</dt><dd><p>price index of the aggregate output 
(not in the original data set, artificially generated).</p>
</dd>
<dt>adv</dt><dd><p>dummy variable indicating the use of an advisory service
(not in the original data set, artificially generated).</p>
</dd>
</dl>



<h3>Source</h3>

<p>This cross-sectional data set has been extracted 
from a panel data set
that is available in the data archive 
of the Journal of Applied Econometrics: 
<a href="http://qed.econ.queensu.ca/jae/1996-v11.6/ivaldi-ladoux-ossard-simioni/">http://qed.econ.queensu.ca/jae/1996-v11.6/ivaldi-ladoux-ossard-simioni/</a>. 
</p>


<h3>References</h3>

<p>Ivaldi, M., N. Ladoux, H. Ossard, and M. Simioni (1996)
Comparing Fourier and Translog Specifications of Multiproduct 
Technology: Evidence from an Incomplete Panel of French Farmers.
<em>Journal of Applied Econometrics</em>, 11(6), p. 649-667.
</p>

<hr>
<h2 id='Bleymueller79E25.1'>Artificial Prices and Quantities</h2><span id='topic+Bleymueller79E25.1'></span>

<h3>Description</h3>

<p>The <code>Bleymueller251</code> data frame contains prices and quantities of
4 products for the years 1970, 1974 and 1978.
This data are part of Exercise 25.1 of Bleymueller, Gehler und Guetlicher (1979).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Bleymueller79E25.1)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>p.A</dt><dd><p>Price of good A.</p>
</dd>
<dt>p.B</dt><dd><p>Price of good B.</p>
</dd>
<dt>p.C</dt><dd><p>Price of good C.</p>
</dd>
<dt>p.D</dt><dd><p>Price of good D.</p>
</dd>
<dt>q.A</dt><dd><p>Quantity of good A.</p>
</dd>
<dt>q.B</dt><dd><p>Quantity of good B.</p>
</dd>
<dt>q.C</dt><dd><p>Quantity of good C.</p>
</dd>
<dt>q.D</dt><dd><p>Quantity of good D.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bleymueller, J; G. Gehlert and H. Guelicher (1979)
Statistik fuer Wirtschaftswissenschaftler. Verlag Vahlen, Muenchen.
</p>

<hr>
<h2 id='checkConsist'>Testing Theoretical Consistency</h2><span id='topic+checkConsist'></span>

<h3>Description</h3>

<p>Test theoretical consistency of microeconomic models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkConsist( object, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkConsist_+3A_object">object</code></td>
<td>
<p>a microeconomic model</p>
</td></tr>
<tr><td><code id="checkConsist_+3A_...">...</code></td>
<td>
<p>further arguments for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="micEconAids.html#topic+checkConsist.aidsEst">checkConsist.aidsEst</a></code></p>

<hr>
<h2 id='cobbDouglasCalc'>Calculate dependent variable of a Cobb-Douglas function</h2><span id='topic+cobbDouglasCalc'></span>

<h3>Description</h3>

<p>Calculate the dependent variable of a Cobb-Douglas function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobbDouglasCalc( xNames, data, coef, coefCov = NULL, dataLogged = FALSE  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cobbDouglasCalc_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="cobbDouglasCalc_+3A_data">data</code></td>
<td>
<p>data frame containing the data.</p>
</td></tr>
<tr><td><code id="cobbDouglasCalc_+3A_coef">coef</code></td>
<td>
<p>vector containing the coefficients:
if the elements of the vector have no names,
the first element is taken as intercept of the <em>logged</em> equation
and the following elements are taken as coefficients of
the independent variables defined in argument <code>xNames</code>
(in the same order);
if the elements of <code>coef</code> have names,
the element named <code>a_0</code> is taken as intercept of the <em>logged</em>
equation
and the elements named <code>a_1</code>, ..., <code>a_n</code>
are taken as coefficients of the independent variables
defined in argument <code>xNames</code> (numbered in that order).</p>
</td></tr>
<tr><td><code id="cobbDouglasCalc_+3A_coefcov">coefCov</code></td>
<td>
<p>optional covariance matrix of the coefficients
(the order of the rows and columns must correspond
to the order of the coefficients in argument <code>coef</code>).</p>
</td></tr>
<tr><td><code id="cobbDouglasCalc_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the endogenous variable.
If the inputs are provided as logarithmic values
(argument <code>dataLogged</code> is <code>TRUE</code>),
the endogenous variable is returned as logarithm;
non-logarithmic values are returned otherwise.
</p>
<p>If argument <code>coefCov</code> is specified,
the returned vector has an attribute <code>"variance"</code>
that is a vector containing the variances
of the calculated (fitted) endogenous variable.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogCalc">translogCalc</a></code>, <code><a href="#topic+cobbDouglasOpt">cobbDouglasOpt</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a Cobb-Douglas production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, linear = TRUE )

   # fitted values
   fitted &lt;- cobbDouglasCalc( c( "qLabor", "land", "qVarInput", "time" ), germanFarms,
      coef( estResult )[ 1:5 ] )
   #equal to estResult$fitted

   # fitted values and their variances
   fitted2 &lt;- cobbDouglasCalc( c( "qLabor", "land", "qVarInput", "time" ), germanFarms,
      coef( estResult )[ 1:5 ], coefCov = vcov( estResult )[ 1:5, 1:5 ] )
   # t-values
   c( fitted2 ) / attributes( fitted2 )$variance^0.5
</code></pre>

<hr>
<h2 id='cobbDouglasDeriv'>Derivatives of a Cobb-Douglas function</h2><span id='topic+cobbDouglasDeriv'></span>

<h3>Description</h3>

<p>Calculate the derivatives of a Cobb-Douglas function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobbDouglasDeriv( xNames, data, coef, coefCov = NULL,
   yName = NULL, dataLogged = FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cobbDouglasDeriv_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="cobbDouglasDeriv_+3A_data">data</code></td>
<td>
<p>data frame containing the data.</p>
</td></tr>
<tr><td><code id="cobbDouglasDeriv_+3A_coef">coef</code></td>
<td>
<p>vector containing the coefficients:
if the elements of the vector have no names,
the first element is taken as intercept of the <em>logged</em> equation
and the following elements are taken as coefficients of
the independent variables defined in argument <code>xNames</code>
(in the same order);
if the elements of <code>coef</code> have names,
the element named <code>a_0</code> is taken as intercept of the <em>logged</em>
equation
and the elements named <code>a_1</code>, ..., <code>a_n</code>
are taken as coefficients of the independent variables
defined in argument <code>xNames</code> (numbered in that order).</p>
</td></tr>
<tr><td><code id="cobbDouglasDeriv_+3A_coefcov">coefCov</code></td>
<td>
<p>optional covariance matrix of the coefficients
(the order of the rows and columns must correspond
to the order of the coefficients in argument <code>coef</code>).</p>
</td></tr>
<tr><td><code id="cobbDouglasDeriv_+3A_yname">yName</code></td>
<td>
<p>an optional string containing the name of the dependent
variable.
If it is <code>NULL</code>, the dependent variable is calculated
from the independent variables and the coefficients.</p>
</td></tr>
<tr><td><code id="cobbDouglasDeriv_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>cobbDouglasDeriv</code> containing following objects:
</p>
<table role = "presentation">
<tr><td><code>deriv</code></td>
<td>
<p>data frame containing the derivatives.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>data frame containing the variances of the derivatives
(only if argument <code>coefCov</code> is provided).
NOTE: if argument <code>yName</code> is specified,
the variance of the endogenous variable is currently ignored.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+cobbDouglasCalc">cobbDouglasCalc</a></code>, <code><a href="#topic+translogDeriv">translogDeriv</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a Cobb-Douglas production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "qVarInput", "land", "time" ),
      germanFarms, linear = TRUE )

   # compute the marginal products of the inputs (with "fitted" Output)
   margProducts &lt;- cobbDouglasDeriv( c( "qLabor", "qVarInput", "land", "time" ),
      data = germanFarms, coef = coef( estResult )[1:5],
      coefCov = vcov( estResult )[1:5,1:5] )
   margProducts$deriv
   # t-values
   margProducts$deriv / margProducts$variance^0.5

   # compute the marginal products of the inputs (with observed Output)
   margProductsObs &lt;- cobbDouglasDeriv( c( "qLabor", "qVarInput", "land", "time" ),
      data = germanFarms, coef = coef( estResult )[1:5], yName = "qOutput",
      coefCov = vcov( estResult )[1:5,1:5] )
   margProductsObs$deriv
   # t-values
   margProductsObs$deriv / margProductsObs$variance^0.5
</code></pre>

<hr>
<h2 id='cobbDouglasOpt'>Optimal Values of Independent Variables of a Cobb-Douglas Function</h2><span id='topic+cobbDouglasOpt'></span>

<h3>Description</h3>

<p>Calculate the optimal values of the variable independent variables
of a Cobb-Douglas function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cobbDouglasOpt( pyName, pxNames, data, coef,
   zNames = NULL, zCoef = NULL, xNames = NULL, dataLogged = FALSE  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cobbDouglasOpt_+3A_pyname">pyName</code></td>
<td>
<p>character string containing the name of the
price of the dependent variable.</p>
</td></tr>
<tr><td><code id="cobbDouglasOpt_+3A_pxnames">pxNames</code></td>
<td>
<p>a vector of strings containing the names of the
prices of the variable independent variables.</p>
</td></tr>
<tr><td><code id="cobbDouglasOpt_+3A_data">data</code></td>
<td>
<p>data frame containing the data.</p>
</td></tr>
<tr><td><code id="cobbDouglasOpt_+3A_coef">coef</code></td>
<td>
<p>vector containing the intercept and the coefficients
of the variable independent variables:
if the elements of the vector have no names,
the first element is taken as intercept of the <em>logged</em> equation
and the following elements are taken as coefficients of
the variable independent variables with corresponding prices
defined in argument <code>pxNames</code> (in the same order);
if the elements of <code>coef</code> have names,
the element named <code>a_0</code> is taken as intercept of the <em>logged</em>
equation
and the elements named <code>a_1</code>, ..., <code>a_n</code>
are taken as coefficients of the variable independent variables
with corresponding prices
defined in argument <code>xNames</code> (numbered in that order).</p>
</td></tr>
<tr><td><code id="cobbDouglasOpt_+3A_znames">zNames</code></td>
<td>
<p>optional vector of strings containing the names of
the fixed independent variables.</p>
</td></tr>
<tr><td><code id="cobbDouglasOpt_+3A_zcoef">zCoef</code></td>
<td>
<p>vector containing the coefficients
of the fixed independent variables:
if the elements of the vector have no names,
they are taken as coefficients of the fixed independent variables
defined in argument <code>zNames</code> (in the same order);
if the elements of <code>coef</code> have names,
the elements named <code>d_1</code>, ..., <code>d_m</code>
are taken as coefficients of the fixed independent variables
with corresponding prices
defined in argument <code>zNames</code> (numbered in that order).</p>
</td></tr>
<tr><td><code id="cobbDouglasOpt_+3A_xnames">xNames</code></td>
<td>
<p>optional vector of strings containing the names
that should be assigned to the returned variable independent variables.</p>
</td></tr>
<tr><td><code id="cobbDouglasOpt_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the prices and fixed independent variables
in <code>data</code>
with names defined in <code>pyName</code>, <code>pxNames</code>, and <code>zNames</code>
already logged?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the optimal values of the variable
independent variables.
If the prices and fixed independent variables are provided
as logarithmic values
(argument <code>dataLogged</code> is <code>TRUE</code>),
the optimal values of the variable independent variables are returned
as logarithms, too;
non-logarithmic values are returned otherwise.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+cobbDouglasCalc">cobbDouglasCalc</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a Cobb-Douglas production function
   estResult &lt;- translogEst( yName = "qOutput",
      xNames = c( "qLabor", "qVarInput", "land", "time" ),
      data = germanFarms, linear = TRUE )

   # calculate optimal quantities of variable inputs
   xCoef &lt;- coef( estResult )[ 1:3 ]
   zCoef &lt;- coef( estResult )[ 4:5 ]
   names( zCoef ) &lt;- c( "d_1", "d_2" )
   optInput &lt;- cobbDouglasOpt( pyName = "pOutput",
      pxNames = c( "pLabor", "pVarInput" ), coef = xCoef,
      data = germanFarms, xNames = c( "qLabor", "qVarInput" ),
      zNames = c( "land", "time" ), zCoef = zCoef )

   # compare observed with optimal input quantities
   plot( germanFarms$qLabor, optInput$qLabor )
   plot( germanFarms$qVarInput, optInput$qVarInput )
</code></pre>

<hr>
<h2 id='coef.quadFuncEst'>Coefficients of a Quadratic Function</h2><span id='topic+coef.quadFuncEst'></span><span id='topic+vcov.quadFuncEst'></span>

<h3>Description</h3>

<p>These methods return the coefficients and their covariance matrix
from an estimated quadratic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'quadFuncEst'
coef( object, ... )

   ## S3 method for class 'quadFuncEst'
vcov( object, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.quadFuncEst_+3A_object">object</code></td>
<td>
<p>an object of class <code>quadFuncEst</code>.</p>
</td></tr>
<tr><td><code id="coef.quadFuncEst_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>coef</code> method returns a vector containing all (linearly independent)
coefficients of a quadratic function.
</p>
<p>The <code>vcov</code> method returns the covariance matrix
of all (linearly independent) coefficients of a quadratic function.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadFuncEst">quadFuncEst</a></code></p>

<hr>
<h2 id='coef.translogEst'>Coefficients of a Translog Function</h2><span id='topic+coef.translogEst'></span><span id='topic+vcov.translogEst'></span>

<h3>Description</h3>

<p>These methods return the coefficients and their covariance matrix
from an estimated translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'translogEst'
coef( object, ... )

   ## S3 method for class 'translogEst'
vcov( object, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.translogEst_+3A_object">object</code></td>
<td>
<p>an object of class <code>translogEst</code>.</p>
</td></tr>
<tr><td><code id="coef.translogEst_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>coef</code> method returns a vector containing all (linearly independent)
coefficients of a translog function.
</p>
<p>The <code>vcov</code> method returns the covariance matrix
of all (linearly independent) coefficients of a translog function.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code></p>

<hr>
<h2 id='elas'>Calculating and returning elasticities</h2><span id='topic+elas'></span><span id='topic+elasticities'></span><span id='topic+elas.default'></span>

<h3>Description</h3>

<p>These functions calculate and return
elasticities of microeconomic models.
<code>elasticities</code> is an alias for <code>elas</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   elas( object, ... )
   elasticities( object, ... )
   ## Default S3 method:
elas( object, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elas_+3A_object">object</code></td>
<td>
<p>a microeconomic model</p>
</td></tr>
<tr><td><code id="elas_+3A_...">...</code></td>
<td>
<p>further arguments for methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function.
The default method just returns the element
<code>elas</code> from <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="micEconAids.html#topic+elas.aidsEst">elas.aidsEst</a></code></p>

<hr>
<h2 id='germanFarms'>Output and Inputs of Farms in West-Germany</h2><span id='topic+germanFarms'></span>

<h3>Description</h3>

<p>The <code>germanFarms</code> data frame contains annual data of an average
full-time farm in West-Germany. Additionally, the price indices
for agricultural output and agricultural variable input are
included. 20 book-keeping years are included - starting in
1975/76 and ending in 1994/95.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(germanFarms)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>year</dt><dd><p>the book-keeping year.</p>
</dd>
<dt>vCrop</dt><dd><p>the value of crop outputs (in current Deutschmark).</p>
</dd>
<dt>vAnimal</dt><dd><p>the value of animal outputs (in current Deutschmark).</p>
</dd>
<dt>vOutput</dt><dd><p>the value of outputs (in current Deutschmark).</p>
</dd>
<dt>pOutput</dt><dd><p>price index of agricultural outputs (1980/81 = 100).</p>
</dd>
<dt>vVarInput</dt><dd><p>the value of variable inputs (in current Deutschmark).</p>
</dd>
<dt>pVarInput</dt><dd><p>price index of variable agricultural inputs (1980/81 = 100).</p>
</dd>
<dt>qLabor</dt><dd><p>the number of full-time worker equivalents.</p>
</dd>
<dt>pLabor</dt><dd><p>costs of an agricultural worker (Deutschmarks per year).</p>
</dd>
<dt>land</dt><dd><p>land used for agricultural production (in ha).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bundesministerium für Ernährung, Landwirtschaft und Forsten
(Federal Department for Food, Agriculture and Forests),
<em>Agrarbericht der Bundesregierung
(Agricultural Report of the Federal Government)</em>,
Jahrgänge 1977-1996
(years 1977-1996).
</p>

<hr>
<h2 id='logDataSet'>Creating a Data Set with the Logarithms of the Original Variables</h2><span id='topic+logDataSet'></span>

<h3>Description</h3>

<p>This function creates a data set with the logarithms
of the original variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logDataSet( data, varNames, varNamesNum = NULL  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logDataSet_+3A_data">data</code></td>
<td>
<p>a data frame containing the data
(possibly a panel data frame created with
<code><a href="plm.html#topic+pdata.frame">pdata.frame</a></code>).</p>
</td></tr>
<tr><td><code id="logDataSet_+3A_varnames">varNames</code></td>
<td>
<p>vector of character strings
that indicates names of variables in the data frame.
The logarithm of these variables
are included in the returned data frame.</p>
</td></tr>
<tr><td><code id="logDataSet_+3A_varnamesnum">varNamesNum</code></td>
<td>
<p>optional vector of character strings
that indicates names of further variables in tha data frame.
In case of numeric variables,
the logarithms of these variabes
are included in the returned data frame.
In case of factor of logical variables,
these variabes are included in the returned data frame
without any transformation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( "germanFarms" )
   datLog &lt;- logDataSet( germanFarms, c( "vAnimal", "vOutput", "vVarInput" ) )
   summary( datLog )
</code></pre>

<hr>
<h2 id='Missong03E7.7'>Meat Prices and Quantities in Germany</h2><span id='topic+Missong03E7.7'></span>

<h3>Description</h3>

<p>The <code>Missong03E7.7</code> data frame contains meat prices and demanded quantities
of a representative (West-)German household for the years 1986 to 1989.
This data are part of Exercise 7.7 of Missong (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Missong03E7.7)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>p.beef</dt><dd><p>Average price of beef (DM/kg).</p>
</dd>
<dt>q.beef</dt><dd><p>Demanded Quantity of beef (kg).</p>
</dd>
<dt>p.veal</dt><dd><p>Average price of veal (DM/kg).</p>
</dd>
<dt>q.veal</dt><dd><p>Demanded Quantity of veal (kg).</p>
</dd>
<dt>p.pork</dt><dd><p>Average price of pork (DM/kg).</p>
</dd>
<dt>q.pork</dt><dd><p>Demanded Quantity of pork (kg).</p>
</dd>
</dl>



<h3>Source</h3>

<p>Missong, M. (2003)
Aufgabensammlung zur deskriptiven Statistik, Oldenbourg, Muenchen.
</p>
<p>Statistisches Bundesamt (1989)
Fachserie 15, Reihe 1, p. 76f.
</p>

<hr>
<h2 id='quadFuncCalc'>Calculate dependent variable of a quadratic function</h2><span id='topic+quadFuncCalc'></span>

<h3>Description</h3>

<p>Calculate the dependent variable of a quadratic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadFuncCalc( xNames, data, coef, shifterNames = NULL, 
   homWeights = NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadFuncCalc_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="quadFuncCalc_+3A_data">data</code></td>
<td>
<p>dataframe or a vector with named elements containing the data.</p>
</td></tr>
<tr><td><code id="quadFuncCalc_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients: 
if there are <code>n</code> exogenous variables in <code>xNames</code>
and <code>m</code> shifter variables in <code>shifterNames</code>,
the <code>n+1</code> alpha coefficients must have names 
<code>a_0</code>, ..., <code>a_n</code>,
the <code>n*(n+1)/2</code> beta coefficients must have names
<code>b_1_1</code>, ..., <code>b_1_n</code>, ..., <code>b_n_n</code>,
and the <code>m</code> delta coefficients must have names
<code>d_1</code>, ..., <code>d_m</code>
(only the elements of the upper right triangle of the beta matrix
are directly obtained from <code>coef</code>;
the elements of the lower left triangle are obtained by assuming
symmetry of the beta matrix).</p>
</td></tr>
<tr><td><code id="quadFuncCalc_+3A_shifternames">shifterNames</code></td>
<td>
<p>a vector of strings containing the names
of the independent variables that should be included
as shifters only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="quadFuncCalc_+3A_homweights">homWeights</code></td>
<td>
<p>numeric vector with named elements that are weighting factors
for calculating an index that is used to normalize the variables
for imposing homogeneity of degree zero in these variables
(see documentation of <code><a href="#topic+quadFuncEst">quadFuncEst</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the endogenous variable.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadFuncEst">quadFuncEst</a></code> and <code><a href="#topic+quadFuncDeriv">quadFuncDeriv</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a quadratic production function
   estResult &lt;- quadFuncEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   quadFuncCalc( c( "qLabor", "land", "qVarInput", "time" ), germanFarms,
      coef( estResult ) )
   #equal to estResult$fitted
</code></pre>

<hr>
<h2 id='quadFuncDeriv'>Derivatives of a quadratic function</h2><span id='topic+quadFuncDeriv'></span>

<h3>Description</h3>

<p>Calculate the derivatives of a quadratic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   quadFuncDeriv( xNames, data, coef, coefCov = NULL, 
      homWeights = NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadFuncDeriv_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="quadFuncDeriv_+3A_data">data</code></td>
<td>
<p>dataframe or a vector with named elements containing the data.</p>
</td></tr>
<tr><td><code id="quadFuncDeriv_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients:
if there are <code>n</code> exogenous variables in <code>xNames</code>,
the <code>n+1</code> alpha coefficients must have names 
<code>a_0</code>, ..., <code>a_n</code>
and the <code>n*(n+1)/2</code> beta coefficients must have names
<code>b_1_1</code>, ..., <code>b_1_n</code>, ..., <code>b_n_n</code>
(only the elements of the upper right triangle of the beta matrix
are directly obtained from <code>coef</code>;
the elements of the lower left triangle are obtained by assuming
symmetry of the beta matrix).</p>
</td></tr>
<tr><td><code id="quadFuncDeriv_+3A_coefcov">coefCov</code></td>
<td>
<p>optional covariance matrix of the coefficients:
the row names and column names must be the same as the names
of <code>coef</code>.</p>
</td></tr>
<tr><td><code id="quadFuncDeriv_+3A_homweights">homWeights</code></td>
<td>
<p>numeric vector with named elements that are weighting factors
for calculating an index that is used to normalize the variables
for imposing homogeneity of degree zero in these variables
(see documentation of <code><a href="#topic+quadFuncEst">quadFuncEst</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shifter variables do not need to be specified, 
because they have no effect on the partial derivatives.
Hence, you can use this function to calculate partial derivatives
even for quadratic functions that have been estimated
with shifter variables.
</p>


<h3>Value</h3>

<p>A data frame containing the derivatives,
where each column corresponds to one of the independent variables.
If argument <code>coefCov</code> is provided, it has the attributes
<code>variance</code> and <code>stdDev</code>,
which are two data frames containing the variances
and the standard deviations, respectively, of the derivatives.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadFuncEst">quadFuncEst</a></code> and <code><a href="#topic+quadFuncCalc">quadFuncCalc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a quadratic production function
   estResult &lt;- quadFuncEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   # compute the marginal products of the inputs
   margProducts &lt;- quadFuncDeriv( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ), vcov( estResult ) )
   # all marginal products
   margProducts
   # their t-values
   margProducts / attributes( margProducts )$stdDev
</code></pre>

<hr>
<h2 id='quadFuncEla'>Elasticities of a Quadratic Function</h2><span id='topic+quadFuncEla'></span><span id='topic+elas.quadFuncEst'></span>

<h3>Description</h3>

<p>Calculate elasticities of a quadratic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadFuncEla( xNames, data, coef, yName = NULL, 
   shifterNames = NULL, homWeights = NULL )

## S3 method for class 'quadFuncEst'
elas( object, data = NULL, yObs = FALSE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadFuncEla_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_data">data</code></td>
<td>
<p>dataframe or a vector with named elements containing the data;
if argument <code>data</code> of <code>elas.quadFuncEst</code> is not specified,
the data frame that was used for the estimation
is used for calculating elasticities.</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients.</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_yname">yName</code></td>
<td>
<p>an optional string containing the name of the dependent
variable.
If it is <code>NULL</code>, the dependent variable is calculated
from the independent variables and the coefficients.</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_shifternames">shifterNames</code></td>
<td>
<p>an optional vector of strings containing the names
of the independent variables that are included
as shifters only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_homweights">homWeights</code></td>
<td>
<p>numeric vector with named elements that are weighting factors
for calculating an index that is used to normalize the variables
for imposing homogeneity of degree zero in these variables
(see documentation of <code><a href="#topic+quadFuncEst">quadFuncEst</a></code>).</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_object">object</code></td>
<td>
<p>object of class <code>quadFuncEst</code>
(returned by <code><a href="#topic+quadFuncEst">quadFuncEst</a></code>).</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_yobs">yObs</code></td>
<td>
<p>logical. Use observed values of the endogenous variable.
If <code>FALSE</code> (default) predicted values calculated by
<code><a href="#topic+quadFuncCalc">quadFuncCalc</a></code> are used.</p>
</td></tr>
<tr><td><code id="quadFuncEla_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame of class <code>quadFuncEla</code>, 
where each column corresponds to one of the independent variables.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadFuncEst">quadFuncEst</a></code>, <code><a href="#topic+quadFuncDeriv">quadFuncDeriv</a></code>, and
<code><a href="#topic+quadFuncCalc">quadFuncCalc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a quadratic production function
   estResult &lt;- quadFuncEst( yName = "qOutput", 
      xNames = c( "qLabor", "land", "qVarInput", "time" ),
      data = germanFarms )

   # compute the partial production elasticities with "fitted" output
   elaFit &lt;- quadFuncEla( xNames = c( "qLabor", "land", "qVarInput", "time" ),
      data = germanFarms, coef = coef( estResult ) )
   elaFit
   # same as
   elaFit2 &lt;- elas( estResult )
   all.equal( elaFit, elaFit2 )

   # compute the partial production elasticities with observed output
   elaObs &lt;- quadFuncEla( xNames = c( "qLabor", "land", "qVarInput", "time" ),
      data = germanFarms, coef = coef( estResult ), yName = "qOutput" )
   elaObs
   # same as
   elaObs2 &lt;- elas( estResult, yObs = TRUE )
   all.equal( elaObs, elaObs2 )
</code></pre>

<hr>
<h2 id='quadFuncEst'>Estimate a quadratic function</h2><span id='topic+quadFuncEst'></span>

<h3>Description</h3>

<p>Estimate a quadratic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quadFuncEst( yName, xNames, data, shifterNames = NULL,
   linear = FALSE, homWeights = NULL, 
   regScale = 1, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quadFuncEst_+3A_yname">yName</code></td>
<td>
<p>a character string containing the name of the dependent
variable.</p>
</td></tr>
<tr><td><code id="quadFuncEst_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="quadFuncEst_+3A_data">data</code></td>
<td>
<p>data frame containing the data
(possibly a panel data frame created with
<code><a href="plm.html#topic+pdata.frame">pdata.frame</a></code>).</p>
</td></tr>
<tr><td><code id="quadFuncEst_+3A_shifternames">shifterNames</code></td>
<td>
<p>a vector of strings containing the names
of the independent variables that should be included
as shifters only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="quadFuncEst_+3A_linear">linear</code></td>
<td>
<p>logical. Restrict the coefficients of all quadratic
and interaction terms to be zero so that the estimated function
is linear in the exogenous variables?</p>
</td></tr>
<tr><td><code id="quadFuncEst_+3A_homweights">homWeights</code></td>
<td>
<p>numeric vector with named elements that are weighting factors
for calculating an index that is used to normalize the variables
for imposing homogeneity of degree zero in these variables
(see details).</p>
</td></tr>
<tr><td><code id="quadFuncEst_+3A_regscale">regScale</code></td>
<td>
<p>a scalar or vector with length equal to <code>nrow( data )</code>.
All regressors except for shifter variables that are logical 
or factors are divided by <code>regScale</code>
(NOTE: quadratic and interaction terms are also divided by 
<code>regScale</code> and NOT divided by the square of <code>regScale</code>).</p>
</td></tr>
<tr><td><code id="quadFuncEst_+3A_...">...</code></td>
<td>
<p>further arguments are passed to <code><a href="stats.html#topic+lm">lm</a></code>
or <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>homWeights</code> is used to impose homogeneity of degree
zero in some variables, 
the weighting factors in this vector must have names 
that are equal to the variable names in argument <code>xNames</code>.
The order of the elements in <code>homWeights</code>
is arbitrary and may or may not be equal 
to the order of the elements in <code>xNames</code>.
Argument <code>homWeights</code> may contain less elements 
than <code>xNames</code>;
in this case, homogeneity of degree zero is imposed only
on variables with names in <code>homWeights</code>.
Please note that the weighting factor of a variable
(<code class="reqn">P_i</code>) in <code>homWeights</code>
(<code class="reqn">w_i = \partial P / \partial P_i</code>)
is not really its weight
(<code class="reqn">( \partial P / \partial P_i ) ( P_i / P )</code>),
in particular,
if the numerical values of the variables (<code class="reqn">P_1, \ldots, P_n</code>)
are rather different.
</p>


<h3>Value</h3>

<p>a list of class <code>quadFuncEst</code> containing following objects:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>the object returned by <code><a href="stats.html#topic+lm">lm</a></code>
or <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
<tr><td><code>nExog</code></td>
<td>
<p>length of argument <code>xNames</code>.</p>
</td></tr>
<tr><td><code>nShifter</code></td>
<td>
<p>length of argument <code>shifterNames</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>vector of all coefficients.</p>
</td></tr>
<tr><td><code>coefCov</code></td>
<td>
<p>covariance matrix of all coefficients.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p><code class="reqn">R^2</code> value.</p>
</td></tr>
<tr><td><code>r2bar</code></td>
<td>
<p>adjusted <code class="reqn">R^2</code> value.</p>
</td></tr>
<tr><td><code>nObs</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>model.matrix</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>yName</code></td>
<td>
<p>argument <code>yName</code>.</p>
</td></tr>
<tr><td><code>xNames</code></td>
<td>
<p>argument <code>xNames</code>.</p>
</td></tr>
<tr><td><code>shifterNames</code></td>
<td>
<p>argument <code>shifterNames</code>.</p>
</td></tr>
<tr><td><code>homWeights</code></td>
<td>
<p>argument <code>homWeights</code>.</p>
</td></tr>
<tr><td><code>regScale</code></td>
<td>
<p>argument <code>regScale</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+quadFuncCalc">quadFuncCalc</a></code>, <code><a href="#topic+quadFuncDeriv">quadFuncDeriv</a></code>,
<code><a href="#topic+translogEst">translogEst</a></code> and <code><a href="micEconSNQP.html#topic+snqProfitEst">snqProfitEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a quadratic production function
   estResult &lt;- quadFuncEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   coef( estResult )
   estResult$r2
</code></pre>

<hr>
<h2 id='residuals.translogEst'>Residuals of a Translog function</h2><span id='topic+residuals.translogEst'></span>

<h3>Description</h3>

<p>Extract the residuals from the estimation of a Translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'translogEst'
residuals( object, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.translogEst_+3A_object">object</code></td>
<td>
<p>an object of class <code>translogEst</code>.</p>
</td></tr>
<tr><td><code id="residuals.translogEst_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>residuals.translogEst</code> returns a vector
containing the residuals of an estimated translog function.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code> and <code><a href="stats.html#topic+residuals">residuals</a></code>
</p>

<hr>
<h2 id='summary.translogEst'>Summarizing the Estimation of a Translog Function</h2><span id='topic+summary.translogEst'></span><span id='topic+print.summary.translogEst'></span>

<h3>Description</h3>

<p><code>summary.translogEst</code> summarizes the estimation results
of a Translog Function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'translogEst'
summary( object, ... )

## S3 method for class 'summary.translogEst'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.translogEst_+3A_object">object</code></td>
<td>
<p>an object of class <code>translogEst</code>.</p>
</td></tr>
<tr><td><code id="summary.translogEst_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.translogEst</code>.</p>
</td></tr>
<tr><td><code id="summary.translogEst_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.translogEst</code> returns a list of class <code>summary.translogEst</code>
that is currently the provided <code>object</code>,
but an element <code>coefTable</code> has been added
and the class has been changed.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code>.</p>

<hr>
<h2 id='translogCalc'>Calculate dependent variable of a translog function</h2><span id='topic+translogCalc'></span>

<h3>Description</h3>

<p>Calculate the dependent variable of a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translogCalc( xNames, data, coef, shifterNames = NULL,
   dataLogged = FALSE  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogCalc_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogCalc_+3A_data">data</code></td>
<td>
<p>dataframe containing the data.</p>
</td></tr>
<tr><td><code id="translogCalc_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients: 
if there are <code>n</code> exogenous variables in <code>xNames</code>
and <code>m</code> shifter variables in <code>shifterNames</code>,
the <code>n+1</code> alpha coefficients must have names 
<code>a_0</code>, ..., <code>a_n</code>,
the <code>n*(n+1)/2</code> beta coefficients must have names
<code>b_1_1</code>, ..., <code>b_1_n</code>, ..., <code>b_n_n</code>,
and the <code>m</code> delta coefficients must have names
<code>d_1</code>, ..., <code>d_m</code>
(only the elements of the upper right triangle of the beta matrix
are directly obtained from <code>coef</code>;
the elements of the lower left triangle are obtained by assuming
symmetry of the beta matrix).</p>
</td></tr>
<tr><td><code id="translogCalc_+3A_shifternames">shifterNames</code></td>
<td>
<p>a vector of strings containing the names
of the independent variables that should be included
as shifters only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="translogCalc_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the endogenous variable.
If the inputs are provided as logarithmic values
(argument <code>dataLogged</code> is <code>TRUE</code>),
the endogenous variable is returned as logarithm;
non-logarithmic values are returned otherwise.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code> and <code><a href="#topic+translogDeriv">translogDeriv</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a Translog production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   translogCalc( c( "qLabor", "land", "qVarInput", "time" ), germanFarms,
      coef( estResult ) )
   #equal to estResult$fitted
</code></pre>

<hr>
<h2 id='translogCheckCurvature'>Curvature of a Translog Function</h2><span id='topic+translogCheckCurvature'></span><span id='topic+print.translogCheckCurvature'></span>

<h3>Description</h3>

<p>Check curvature of a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translogCheckCurvature( xNames, data, coef, convexity = TRUE,
   quasi = FALSE, dataLogged = FALSE, ... )

## S3 method for class 'translogCheckCurvature'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogCheckCurvature_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogCheckCurvature_+3A_data">data</code></td>
<td>
<p>dataframe containing the data.</p>
</td></tr>
<tr><td><code id="translogCheckCurvature_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients.</p>
</td></tr>
<tr><td><code id="translogCheckCurvature_+3A_convexity">convexity</code></td>
<td>
<p>logical. Check whether the function is (quasi)convex
(default, <code>TRUE</code>) or (quasi)concave (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="translogCheckCurvature_+3A_quasi">quasi</code></td>
<td>
<p>logical. Check whether the function is quasiconvex/quasiconcave
(<code>TRUE</code>) or convex/concave (default, <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="translogCheckCurvature_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
<tr><td><code id="translogCheckCurvature_+3A_x">x</code></td>
<td>
<p>an object returned by <code>translogCheckCurvature</code>.</p>
</td></tr>
<tr><td><code id="translogCheckCurvature_+3A_...">...</code></td>
<td>
<p>arguments passed from <code>translogCheckCurvature</code>
to <code>semidefiniteness</code>
(if argument <code>quasi</code> is <code>FALSE</code>),
<code>quasiconvexity</code>
(if arguments <code>convexity</code> and <code>quasi</code> are both <code>TRUE</code>),
or <code>quasiconcavity</code>
(if argument <code>convexity</code> is <code>FALSE</code>
and <code>quasi</code> is <code>TRUE</code>).
Further arguments to <code>print.translogCheckCurvature</code>
are currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>translogCheckCurvature</code> returns a list of class
<code>translogCheckCurvature</code> containing following objects:
</p>
<table role = "presentation">
<tr><td><code>obs</code></td>
<td>
<p>a vector indicating whether the condition
for the specified curvature is fulfilled at each observation.</p>
</td></tr>
<tr><td><code>convexity</code></td>
<td>
<p>argument <code>convexity</code>.</p>
</td></tr>
<tr><td><code>quasi</code></td>
<td>
<p>argument <code>quasi</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code> and <code><a href="#topic+translogCheckMono">translogCheckMono</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a translog production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   # check whether the production function is quasiconcave
   translogCheckCurvature( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ), convexity = FALSE, quasi = TRUE )
</code></pre>

<hr>
<h2 id='translogCheckMono'>Monotonicity of a Translog Function</h2><span id='topic+translogCheckMono'></span><span id='topic+print.translogCheckMono'></span><span id='topic+summary.translogCheckMono'></span><span id='topic+print.summary.translogCheckMono'></span>

<h3>Description</h3>

<p>Check monotonicity of a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translogCheckMono( xNames, data, coef, increasing = TRUE,
   strict = FALSE, dataLogged = FALSE,
   tol = 10 * .Machine$double.eps )

## S3 method for class 'translogCheckMono'
print( x, ... )

## S3 method for class 'translogCheckMono'
summary( object, ... )

## S3 method for class 'summary.translogCheckMono'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogCheckMono_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_data">data</code></td>
<td>
<p>dataframe containing the data.</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients.</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_increasing">increasing</code></td>
<td>
<p>single logical value or vector of logical values
of the same length as argument <code>xNames</code>
indicating whether it should be checked if the translog function
is monotonically increasing (default, TRUE) or decreasing (FALSE)
in the explanatory variables.</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_strict">strict</code></td>
<td>
<p>logical. Check for strict (TRUE) or non-strict
(default, FALSE) monotonicity?</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_tol">tol</code></td>
<td>
<p>tolerance level for checking non-strict monotonicity:
values between <code>-tol</code> and <code>tol</code> are considered to be zero
(ignored if argument <code>strict</code> is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_x">x</code></td>
<td>
<p>an object returned by <code>translogCheckMono</code> or
by <code>summary.translogCheckMono</code>.</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_object">object</code></td>
<td>
<p>an object returned by <code>translogCheckMono</code>.</p>
</td></tr>
<tr><td><code id="translogCheckMono_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>translogCheckMono</code> internally calls
function <code><a href="#topic+translogDeriv">translogDeriv</a></code>
and then checks if the derivatives have the sign
specified in argument <code>increasing</code>.
</p>
<p>Function <code>translogCheckMono</code> does not have an argument
<code>shifterNames</code>, because shifter variables do not affect
the monotonicity conditions of the eplanatory variables
defined in Argument <code>xNames</code>.
Therefore, <code>translogCheckMono</code> automatically removes
all coefficients of the shifter variables
before it calls <code><a href="#topic+translogDeriv">translogDeriv</a></code>.
</p>


<h3>Value</h3>

<p><code>translogCheckMono</code> returns a list of class <code>translogCheckMono</code>
containing following objects:
</p>
<table role = "presentation">
<tr><td><code>obs</code></td>
<td>
<p>a vector indicating whether monotonicity is fulfilled
at each observation.</p>
</td></tr>
<tr><td><code>exog</code></td>
<td>
<p>data frame indicating whether monotonicity is fulfilled
for each exogenous variable at each observation.</p>
</td></tr>
<tr><td><code>increasing</code></td>
<td>
<p>argument <code>increasing</code>.</p>
</td></tr>
<tr><td><code>strict</code></td>
<td>
<p>argument <code>strict</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code>, <code><a href="#topic+translogDeriv">translogDeriv</a></code>,
and <code><a href="#topic+translogCheckCurvature">translogCheckCurvature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a translog production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   # check whether the production function is monotonically increasing
   # in all inputs
   test &lt;- translogCheckMono( xNames = c( "qLabor", "land", "qVarInput", "time" ),
      data = germanFarms, coef = coef( estResult ) )
   test
   summary( test )

   # check whether the production function is monotonically decreasing
   # in time and monotonically increasing in all other inputs
   test &lt;- translogCheckMono( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ), increasing = c( TRUE, TRUE, TRUE, FALSE ) )
   test
   summary( test )
</code></pre>

<hr>
<h2 id='translogCostEst'>Estimate a translog Cost Function</h2><span id='topic+translogCostEst'></span>

<h3>Description</h3>

<p>Estimate a translog cost function.
</p>
<p>NOTE: this function is still under development and incomplete!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   translogCostEst( cName, yName, pNames, data, fNames = NULL, 
      shifterNames = NULL, dataLogged = FALSE, homPrice = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogCostEst_+3A_cname">cName</code></td>
<td>
<p>a string containing the name of the variable 
for total cost.</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_yname">yName</code></td>
<td>
<p>a string containing the name of the variable
for the total output quantity.</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_pnames">pNames</code></td>
<td>
<p>a vector of strings containing the names
of the input prices.</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_data">data</code></td>
<td>
<p>data frame containing the data
(possibly a panel data frame created with
<code><a href="plm.html#topic+pdata.frame">pdata.frame</a></code>).</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_fnames">fNames</code></td>
<td>
<p>a vector of strings containing the names
of fixed inputs.</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_shifternames">shifterNames</code></td>
<td>
<p>a vector of strings containing the names
of the independent variables that should be included
as shifters only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_homprice">homPrice</code></td>
<td>
<p>logical. Should homogeneity of degree one in prices be 
imposed?</p>
</td></tr>
<tr><td><code id="translogCostEst_+3A_...">...</code></td>
<td>
<p>further arguments
are passed to <code><a href="stats.html#topic+lm">lm</a></code>
or <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>translogCostEst</code> containing following objects:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>the object returned by <code><a href="stats.html#topic+lm">lm</a></code>
or <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
<tr><td><code>nExog</code></td>
<td>
<p>length of argument <code>xNames</code>.</p>
</td></tr>
<tr><td><code>nShifter</code></td>
<td>
<p>length of argument <code>shifterNames</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>vector of all coefficients.</p>
</td></tr>
<tr><td><code>coefCov</code></td>
<td>
<p>covariance matrix of all coefficients.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p><code class="reqn">R^2</code> value.</p>
</td></tr>
<tr><td><code>r2bar</code></td>
<td>
<p>adjusted <code class="reqn">R^2</code> value.</p>
</td></tr>
<tr><td><code>nObs</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>model.matrix</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>cName</code></td>
<td>
<p>argument <code>cName</code>.</p>
</td></tr>
<tr><td><code>yName</code></td>
<td>
<p>argument <code>yName</code>.</p>
</td></tr>
<tr><td><code>pNames</code></td>
<td>
<p>argument <code>pNames</code>.</p>
</td></tr>
<tr><td><code>fNames</code></td>
<td>
<p>argument <code>fNames</code>.</p>
</td></tr>
<tr><td><code>shifterNames</code></td>
<td>
<p>argument <code>shifterNames</code>.</p>
</td></tr>
<tr><td><code>dataLogged</code></td>
<td>
<p>argument <code>dataLogged</code>.</p>
</td></tr>
<tr><td><code>homPrice</code></td>
<td>
<p>argument <code>homPrice</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code>
and <code><a href="#topic+quadFuncEst">quadFuncEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # value of labor input
   germanFarms$vLabor &lt;- germanFarms$pLabor + germanFarms$qLabor
   # total variable cost
   germanFarms$cost &lt;- germanFarms$vLabor + germanFarms$vVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a translog cost function
   estResult &lt;- translogCostEst( cName = "cost", yName = "qOutput", 
      pNames = c( "pLabor", "pVarInput" ), fNames = "land",
      shifterNames = "time", data = germanFarms, homPrice = FALSE )

   summary( estResult$est )
</code></pre>

<hr>
<h2 id='translogDeriv'>Derivatives of a translog function</h2><span id='topic+translogDeriv'></span>

<h3>Description</h3>

<p>Calculate the derivatives of a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translogDeriv( xNames, data, coef, coefCov = NULL,
   yName = NULL, dataLogged = FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogDeriv_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogDeriv_+3A_data">data</code></td>
<td>
<p>dataframe containing the data.</p>
</td></tr>
<tr><td><code id="translogDeriv_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients.</p>
</td></tr>
<tr><td><code id="translogDeriv_+3A_coefcov">coefCov</code></td>
<td>
<p>optional covariance matrix of the coefficients.</p>
</td></tr>
<tr><td><code id="translogDeriv_+3A_yname">yName</code></td>
<td>
<p>an optional string containing the name of the dependent
variable.
If it is <code>NULL</code>, the dependent variable is calculated
from the independent variables and the coefficients.</p>
</td></tr>
<tr><td><code id="translogDeriv_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>translogDeriv</code> containing following objects:
</p>
<table role = "presentation">
<tr><td><code>deriv</code></td>
<td>
<p>data frame containing the derivatives.</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>data frame containing the variances of the derivatives
(not implemented yet).</p>
</td></tr>
<tr><td><code>stdDev</code></td>
<td>
<p>data frame containing the standard deviations of the derivatives
(not implemented yet).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code>, <code><a href="#topic+translogCalc">translogCalc</a></code> and
<code><a href="#topic+translogHessian">translogHessian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a translog production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   # compute the marginal products of the inputs (with "fitted" Output)
   margProducts &lt;- translogDeriv( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ), vcov( estResult ) )
   margProducts$deriv

   # compute the marginal products of the inputs (with observed Output)
   margProductsObs &lt;- translogDeriv( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ), vcov( estResult ), "qOutput" )
   margProductsObs$deriv
</code></pre>

<hr>
<h2 id='translogEla'>Elasticities of a translog Function</h2><span id='topic+translogEla'></span><span id='topic+elas.translogEst'></span>

<h3>Description</h3>

<p>Calculate the elasticities of a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translogEla( xNames, data, coef, coefCov = NULL,
   dataLogged = FALSE  )

## S3 method for class 'translogEst'
elas( object, data = NULL, dataLogged = NULL,
   ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogEla_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogEla_+3A_data">data</code></td>
<td>
<p>dataframe containing the data;
if argument <code>data</code> of <code>elas.translogEst</code> is not specified,
the data frame that was used for the estimation 
is used for calculating elasticities.</p>
</td></tr>
<tr><td><code id="translogEla_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients:
if there are <code>n</code> exogenous variables in <code>xNames</code>,
the <code>n+1</code> alpha coefficients must have names 
<code>a_0</code>, ..., <code>a_n</code>
and the <code>n*(n+1)/2</code> beta coefficients must have names
<code>b_1_1</code>, ..., <code>b_1_n</code>, ..., <code>b_n_n</code>
(only the elements of the upper right triangle of the beta matrix
are directly obtained from <code>coef</code>;
the elements of the lower left triangle are obtained by assuming
symmetry of the beta matrix).</p>
</td></tr>
<tr><td><code id="translogEla_+3A_coefcov">coefCov</code></td>
<td>
<p>optional covariance matrix of the coefficients:
the row names and column names must be the same as the names
of <code>coef</code>.</p>
</td></tr>
<tr><td><code id="translogEla_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?
If argument <code>dataLogged</code> of <code>elas.translogEst</code> is not specified,
the same value as used in <code>translogEst</code> for creating <code>object</code>
is used.</p>
</td></tr>
<tr><td><code id="translogEla_+3A_object">object</code></td>
<td>
<p>object of class <code>translogEst</code> 
(returned by <code><a href="#topic+translogEst">translogEst</a></code>).</p>
</td></tr>
<tr><td><code id="translogEla_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shifter variables do not need to be specified, 
because they have no effect on the elasticities.
Hence, you can use this function to calculate elasticities
even for translog functions that have been estimated
with shifter variables.
</p>


<h3>Value</h3>

<p>A data frame containing the elasticities,
where each column corresponds to one of the independent variables.
If argument <code>coefCov</code> is provided, it has the attributes
<code>variance</code> and <code>stdDev</code>,
which are two data frames containing the variances
and the standard deviations, respectively, of the elasticities.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code> and <code><a href="#topic+translogCalc">translogCalc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a quadratic production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   # calculate production elasticities of all inputs
   estEla &lt;- translogEla( c( "qLabor", "land", "qVarInput", "time" ), 
      data = germanFarms, coef = coef( estResult ), 
      coefCov = vcov( estResult ) )
   # all elasticities
   estEla
   # t-values of all elasticities
   estEla / attributes( estEla )$stdDev
</code></pre>

<hr>
<h2 id='translogEst'>Estimate a translog function</h2><span id='topic+translogEst'></span><span id='topic+print.translogEst'></span>

<h3>Description</h3>

<p>Estimate a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   translogEst( yName, xNames, data, shifterNames = NULL,
      dataLogged = FALSE, ... )

   ## S3 method for class 'translogEst'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogEst_+3A_yname">yName</code></td>
<td>
<p>a string containing the name of the dependent
variable.</p>
</td></tr>
<tr><td><code id="translogEst_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogEst_+3A_data">data</code></td>
<td>
<p>data frame containing the data
(possibly a panel data frame created with
<code><a href="plm.html#topic+pdata.frame">pdata.frame</a></code>).</p>
</td></tr>
<tr><td><code id="translogEst_+3A_shifternames">shifterNames</code></td>
<td>
<p>a vector of strings containing the names
of the independent variables that should be included
as shifters only (not in quadratic or interaction terms).</p>
</td></tr>
<tr><td><code id="translogEst_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?
If <code>FALSE</code>, the logarithms of all variables (<code>yName</code>, 
<code>xNames</code>, <code>shifterNames</code>) are used except for
shifter variables that are factors or logical variables.</p>
</td></tr>
<tr><td><code id="translogEst_+3A_x">x</code></td>
<td>
<p>An object of class <code>translogEst</code>.</p>
</td></tr>
<tr><td><code id="translogEst_+3A_...">...</code></td>
<td>
<p>further arguments of <code>translogEst</code>
are passed to <code><a href="stats.html#topic+lm">lm</a></code>
or <code><a href="plm.html#topic+plm">plm</a></code>;
further arguments of <code>print.translogEst</code>
are currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>translogEst</code> containing following objects:
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>the object returned by <code><a href="stats.html#topic+lm">lm</a></code>
or <code><a href="plm.html#topic+plm">plm</a></code>.</p>
</td></tr>
<tr><td><code>nExog</code></td>
<td>
<p>length of argument <code>xNames</code>.</p>
</td></tr>
<tr><td><code>nShifter</code></td>
<td>
<p>length of argument <code>shifterNames</code>.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>residuals.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>fitted values.</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>vector of all coefficients.</p>
</td></tr>
<tr><td><code>coefCov</code></td>
<td>
<p>covariance matrix of all coefficients.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p><code class="reqn">R^2</code> value.</p>
</td></tr>
<tr><td><code>r2bar</code></td>
<td>
<p>adjusted <code class="reqn">R^2</code> value.</p>
</td></tr>
<tr><td><code>nObs</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code>model.matrix</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>yName</code></td>
<td>
<p>argument <code>yName</code>.</p>
</td></tr>
<tr><td><code>xNames</code></td>
<td>
<p>argument <code>xNames</code>.</p>
</td></tr>
<tr><td><code>shifterNames</code></td>
<td>
<p>argument <code>shifterNames</code>.</p>
</td></tr>
<tr><td><code>dataLogged</code></td>
<td>
<p>argument <code>dataLogged</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogCalc">translogCalc</a></code>, <code><a href="#topic+translogDeriv">translogDeriv</a></code>
and <code><a href="#topic+quadFuncEst">quadFuncEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a quadratic production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   estResult
   summary( estResult )
</code></pre>

<hr>
<h2 id='translogHessian'>Hessian matrix of a translog function</h2><span id='topic+translogHessian'></span>

<h3>Description</h3>

<p>Calculate the Hessian matrices of a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   translogHessian( xNames, data, coef, yName = NULL,
   dataLogged = FALSE, bordered = FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogHessian_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogHessian_+3A_data">data</code></td>
<td>
<p>dataframe containing the data.</p>
</td></tr>
<tr><td><code id="translogHessian_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients.</p>
</td></tr>
<tr><td><code id="translogHessian_+3A_yname">yName</code></td>
<td>
<p>an optional string containing the name of the dependent
variable.
If it is <code>NULL</code>, the dependent variable is calculated
from the independent variables and the coefficients.</p>
</td></tr>
<tr><td><code id="translogHessian_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
<tr><td><code id="translogHessian_+3A_bordered">bordered</code></td>
<td>
<p>logical. Should the <em>bordered</em> Hessians be returned?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing following the (bordered) Hessian matrices at
each data point.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code>, <code><a href="#topic+translogDeriv">translogDeriv</a></code> and
<code><a href="#topic+translogCalc">translogCalc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # estimate a quadratic production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   # compute the Hessian matrices (with "fitted" output)
   hessians &lt;- translogHessian( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ) )
   hessians[[ 1 ]]

   # compute the Hessian matrices (with observed output)
   hessiansObs &lt;- translogHessian( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ), "qOutput" )
   hessiansObs[[ 1 ]]

   # compute the bordered Hessian matrices
   borderedHessians &lt;- translogHessian( c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms, coef( estResult ), bordered = TRUE )
   borderedHessians[[ 1 ]]
</code></pre>

<hr>
<h2 id='translogMonoRestr'>Monotonicity Restrictions of a Translog Function</h2><span id='topic+translogMonoRestr'></span>

<h3>Description</h3>

<p>Create matrix to check or impose the monotonicity restrictions 
of a translog function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translogMonoRestr( xNames, data,
   dataLogged = FALSE, box = FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogMonoRestr_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
independent variables.</p>
</td></tr>
<tr><td><code id="translogMonoRestr_+3A_data">data</code></td>
<td>
<p>dataframe containing the data.</p>
</td></tr>
<tr><td><code id="translogMonoRestr_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
<tr><td><code id="translogMonoRestr_+3A_box">box</code></td>
<td>
<p>logical. Should monotonicity be imposed within 
an <code class="reqn">n</code>-dimensional box that includes all points in <code>data</code>?
If <code>FALSE</code>, monotonicity is imposed (only) within 
an <code class="reqn">n</code>-dimensional polygon that includes all points in <code>data</code>.
(<code class="reqn">n</code> is the number of independent varables.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>translogMonoRestr</code> returns a matrix of dimension
<code class="reqn">( n \cdot N ) \times c</code>,
where <code class="reqn">n</code> is the number of independent varables,
<code class="reqn">N</code> is the number of data points at which monotonicity
should be imposed (if argument <code>box</code> is <code>FALSE</code>,
<code class="reqn">N</code> is the number of rows in <code>data</code>;
if argument <code>box</code> is <code>TRUE</code>, <code class="reqn">N = 2^n</code>),
and <code class="reqn">c = 1 + n ( n + 3 ) / 2</code> is the number of (linearly independent) 
coefficients.
Multiplying a row of this matrix (e.g.\ the <code class="reqn">k</code>th row of <code class="reqn">M</code>)
by the vector of coefficients (<code class="reqn">\beta</code>)
results in the derivative of the dependent variable (<code class="reqn">y</code>) 
with respect to one independent variable (e.g.\ <code class="reqn">x_i</code>)
at one data point (e.g.\ <code class="reqn">j</code>): 
</p>
<p style="text-align: center;"><code class="reqn">M[k,] \cdot \beta = \frac{ \partial \ln y }{ \partial \ln x_i}</code>
</p>
<p>,
evaluated at <code class="reqn">x_{1j}</code>, ..., <code class="reqn">x_{nj}</code>,
where <code class="reqn">k = ( i - 1 ) N + j</code>.
Hence, the observations run faster than the independent variables.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code>, <code><a href="#topic+translogDeriv">translogDeriv</a></code>,
and <code><a href="#topic+translogCheckMono">translogCheckMono</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput

   # matrix to check or impose monotonicity at all observations
   monoRestrObs &lt;- translogMonoRestr( c( "qLabor", "land", "qVarInput" ),
      germanFarms )

   # matrix to check or impose monotonicity within a box that includes all 
   # observations
   monoRestrBox &lt;- translogMonoRestr( c( "qLabor", "land", "qVarInput" ),
      germanFarms, box = TRUE )
</code></pre>

<hr>
<h2 id='translogProdFuncMargCost'>Marginal Costs of Translog Production Function</h2><span id='topic+translogProdFuncMargCost'></span>

<h3>Description</h3>

<p>Calculate the marginal costs of the output
from a translog production function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>translogProdFuncMargCost( yName, xNames, wNames, data, coef,
   dataLogged = FALSE )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="translogProdFuncMargCost_+3A_yname">yName</code></td>
<td>
<p>a single character string
containing the name of the output quantity.</p>
</td></tr>
<tr><td><code id="translogProdFuncMargCost_+3A_xnames">xNames</code></td>
<td>
<p>a vector of strings containing the names of the
input quantities.</p>
</td></tr>
<tr><td><code id="translogProdFuncMargCost_+3A_wnames">wNames</code></td>
<td>
<p>a vector of strings containing the names of the
input prices.</p>
</td></tr>
<tr><td><code id="translogProdFuncMargCost_+3A_data">data</code></td>
<td>
<p>dataframe containing the data.</p>
</td></tr>
<tr><td><code id="translogProdFuncMargCost_+3A_coef">coef</code></td>
<td>
<p>vector containing all coefficients:
if there are <code>n</code> inputs in <code>xNames</code>,
the <code>n+1</code> alpha coefficients must have names
<code>a_0</code>, ..., <code>a_n</code>
and the <code>n*(n+1)/2</code> beta coefficients must have names
<code>b_1_1</code>, ..., <code>b_1_n</code>, ..., <code>b_n_n</code>
(only the elements of the upper right triangle of the beta matrix
are directly obtained from <code>coef</code>;
the elements of the lower left triangle are obtained by assuming
symmetry of the beta matrix).</p>
</td></tr>
<tr><td><code id="translogProdFuncMargCost_+3A_datalogged">dataLogged</code></td>
<td>
<p>logical. Are the values in <code>data</code> already logged?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the marginal costs of producing the output.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen and Geraldine Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+translogEst">translogEst</a></code>, <code><a href="#topic+translogCalc">translogCalc</a></code>,
<code><a href="#topic+translogDeriv">translogDeriv</a></code>, <code><a href="#topic+translogEla">translogEla</a></code> and
<code><a href="#topic+translogCostEst">translogCostEst</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   data( germanFarms )
   # output quantity:
   germanFarms$qOutput &lt;- germanFarms$vOutput / germanFarms$pOutput
   # quantity of variable inputs
   germanFarms$qVarInput &lt;- germanFarms$vVarInput / germanFarms$pVarInput
   # a time trend to account for technical progress:
   germanFarms$time &lt;- c(1:20)

   # generate (artificial) prices
   germanFarms$pLand &lt;- 200 + 15 * germanFarms$time
   germanFarms$pTime &lt;- 1

   # estimate a single-output translog production function
   estResult &lt;- translogEst( "qOutput", c( "qLabor", "land", "qVarInput", "time" ),
      germanFarms )

   # compute the marginal costs of producing the output
   margCost &lt;- translogProdFuncMargCost( yName = "qOutput",
      xNames = c( "qLabor", "land", "qVarInput", "time" ),
      wNames = c( "pLabor", "pLand", "pVarInput", "pTime" ),
      data = germanFarms, coef = coef( estResult ) )
</code></pre>

<hr>
<h2 id='utility'>Fossil Fuel Fired Steam Electric Power Plants</h2><span id='topic+utility'></span>

<h3>Description</h3>

<p>The data frame <code>utility</code> is a panel data set 
of 72 investor-owned fossil fuel fired steam electric power plants
in the United States over eleven years (1986-1996).
This data set has 791 observations and, thus, is almost balanced
(only one firm-year observation is missing).
This data set is used as an example in 
Kumbhakar, Wang, and Horncastle (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(utility)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns/variables:
</p>

<dl>
<dt>firm</dt><dd><p>firm number (1-72).</p>
</dd>
<dt>year</dt><dd><p>last two digits of the year (86-96).</p>
</dd>
<dt>y</dt><dd><p>net steam electric power generation in MWh.</p>
</dd>
<dt>regu</dt><dd><p>a dummy variable indicating whether the firm is regulated.</p>
</dd>
<dt>k</dt><dd><p>capital input quantity (estimate of capital cost).</p>
</dd>
<dt>labor</dt><dd><p>quantity index of labor and maintenance input
(costs of labor and maintenance divided by <code>wl</code>).</p>
</dd>
<dt>fuel</dt><dd><p>quantity index of fuel input.
(costs of fuel divided by <code>wf</code>).</p>
</dd>
<dt>wl</dt><dd><p>cost-share weighted price of labor and maintenance.</p>
</dd>
<dt>wf</dt><dd><p>average price of fuel (coal, oil and gas) in USD per BTU.</p>
</dd>
<dt>wk</dt><dd><p>price of the capital input.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set is a revised version of the data set
that is used in Kumbhakar and Wang (2006).
A detailed description of the data set and the variables
can be found in Section 4 of Kumbhakar and Wang (2006).
</p>


<h3>Source</h3>

<p>Companion website to Kumbhakar, Wang, and Horncastle (2015):
<a href="https://sites.google.com/site/sfbook2014/">https://sites.google.com/site/sfbook2014/</a>.
</p>


<h3>References</h3>

<p>Kumbhakar, Subal C. and Hung-Jen Wang (2006):
Estimation of Technical and Allocative Inefficiency: A Primal System Approach,
Journal of Econometrics 134(2), p. 419-440.
(<a href="https://doi.org/10.1016/j.jeconom.2005.07.001">doi:10.1016/j.jeconom.2005.07.001</a>)
</p>
<p>Kumbhakar, Subal C., Hung-Jen Wang, and Alan P. Horncastle (2015): 
A Practitioner's Guide to Stochastic Frontier Analysis Using Stata. 
Cambridge University Press. 
(<a href="https://doi.org/10.1017/CBO9781139342070">doi:10.1017/CBO9781139342070</a>)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
