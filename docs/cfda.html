<!DOCTYPE html><html><head><title>Help for package cfda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cfda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biofam2'><p>Family life states from the Swiss Household Panel biographical survey</p></a></li>
<li><a href='#boxplot.timeSpent'><p>Boxplot of time spent in each state</p></a></li>
<li><a href='#care'><p>Care trajectories</p></a></li>
<li><a href='#cfda-package'><p>Categorical Functional Data Analysis</p></a></li>
<li><a href='#compute_duration'><p>Compute duration of individuals</p></a></li>
<li><a href='#compute_number_jumps'><p>Compute the number of jumps</p></a></li>
<li><a href='#compute_optimal_encoding'><p>Compute the optimal encoding for each state</p></a></li>
<li><a href='#compute_time_spent'><p>Compute time spent in each state</p></a></li>
<li><a href='#convertToCfd'><p>Convert data to categorical functional data</p></a></li>
<li><a href='#cut_data'><p>Cut data to a maximal given time</p></a></li>
<li><a href='#estimate_Markov'><p>Estimate transition matrix and spent time</p></a></li>
<li><a href='#estimate_pt'><p>Estimate probabilities to be in each state</p></a></li>
<li><a href='#flours'><p>Flours dataset</p></a></li>
<li><a href='#generate_2State'><p>Generate data following a 2 states model</p></a></li>
<li><a href='#generate_Markov'><p>Generate Markov Trajectories</p></a></li>
<li><a href='#get_encoding'><p>Extract the computed encoding</p></a></li>
<li><a href='#get_state'><p>Extract the state of each individual at a given time</p></a></li>
<li><a href='#hist.duration'><p>Plot the duration</p></a></li>
<li><a href='#hist.njump'><p>Plot the number of jumps</p></a></li>
<li><a href='#matrixToCfd'><p>Convert a matrix to a cfda data.frame</p></a></li>
<li><a href='#plot.fmca'><p>Plot the optimal encoding</p></a></li>
<li><a href='#plot.Markov'><p>Plot the transition graph</p></a></li>
<li><a href='#plot.pt'><p>Plot probabilities</p></a></li>
<li><a href='#plotComponent'><p>Plot Components</p></a></li>
<li><a href='#plotData'><p>Plot categorical functional data</p></a></li>
<li><a href='#plotEigenvalues'><p>Plot Eigenvalues</p></a></li>
<li><a href='#predict.fmca'><p>Predict the principal components for new trajectories</p></a></li>
<li><a href='#print.fmca'><p>Print a <code>fmca</code> object</p></a></li>
<li><a href='#remove_duplicated_states'><p>Remove duplicated states</p></a></li>
<li><a href='#statetable'><p>Table of transitions</p></a></li>
<li><a href='#summary_cfd'><p>Summary</p></a></li>
<li><a href='#summary.fmca'><p>Object Summaries</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Categorical Functional Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-07</td>
</tr>
<tr>
<td>Copyright:</td>
<td>Inria - Université de Lille</td>
</tr>
<tr>
<td>Description:</td>
<td>Package for the analysis of categorical functional data.
  The main purpose is to compute an encoding (real functional variable) for each state &lt;<a href="https://doi.org/10.3390%2Fmath9233074">doi:10.3390/math9233074</a>&gt;.
  It also provides functions to perform basic statistical analysis on categorical functional data.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/modal-inria/cfda/issues">https://github.com/modal-inria/cfda/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>msm, diagram, mgcv, parallel, pbapply</td>
</tr>
<tr>
<td>Depends:</td>
<td>fda, ggplot2, R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://modal-inria.github.io/cfda/">https://modal-inria.github.io/cfda/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-07 15:10:30 UTC; quentin</td>
</tr>
<tr>
<td>Author:</td>
<td>Cristian Preda [aut],
  Quentin Grimonprez [aut, cre],
  Vincent Vandewalle [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Quentin Grimonprez &lt;quentingrim@yahoo.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-07 15:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='biofam2'>Family life states from the Swiss Household Panel biographical survey</h2><span id='topic+biofam2'></span>

<h3>Description</h3>

<p>2000 16 year-long family life sequences built from the retrospective biographical survey carried out by the Swiss
Household Panel (SHP) in 2002. Data from <code>TraMineR</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(biofam2)
</code></pre>


<h3>Format</h3>

<p>A data.frame containing three columns:
</p>

<ul>
<li> <p><em>id</em> id of individuals (2000 different ids)
</p>
</li>
<li> <p><em>time</em> age in years where a change occurs
</p>
</li>
<li> <p><em>state</em> new state.
</p>
</li></ul>



<h3>Details</h3>

<p>The biofam2 dataset derives from the biofam dataset from <code>TraMineR</code> package.
The biofam2 format is adapted to <code>cfda</code> functions.
The biofam data set was constructed by Müller et al. (2007) from the data of the retrospective biographical survey
carried out by the Swiss Household Panel (SHP) in 2002.
The data set contains sequences of family life states from age 15 to 30 (sequence length is 16).
The sequences are a sample of 2000 sequences of those created from the SHP biographical survey.
It includes only individuals who were at least 30 years old at the time of the survey.
The biofam data set describes family life courses of 2000 individuals born between 1909 and 1972.
</p>
<p>The eight states are defined from the combination of five basic states, namely Living with parents (Parent),
Left home (Left), Married (Marr), Having Children (Child), Divorced:
&quot;Parent&quot;, &quot;Left&quot;, &quot;Married&quot;, &quot;Left+Marr&quot;, &quot;Child&quot;, &quot;Left+Child&quot;, &quot;Left+Marr+Child&quot;, &quot;Divorced&quot;
</p>


<h3>Source</h3>

<p>Swiss Household Panel https://forscenter.ch/projects/swiss-household-panel/
</p>


<h3>References</h3>

<p>Müller, N. S., M. Studer, G. Ritschard (2007). Classification de parcours de vie à l'aide de l'optimal matching.
In XIVe Rencontre de la Société francophone de classification (SFC 2007), Paris, 5 - 7 septembre 2007, pp. 157–160.
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+care">care</a></code>,
<code><a href="#topic+flours">flours</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam2)
head(biofam2)

plotData(biofam2)


# It is recommended to increase the number of cores to reduce computation time
set.seed(42)
basis &lt;- create.bspline.basis(c(15, 30), nbasis = 4, norder = 4)
fmca &lt;- compute_optimal_encoding(biofam2, basis, nCores = 2)

plot(fmca, harm = 1)
plot(fmca, harm = 2)
plotEigenvalues(fmca, cumulative = TRUE, normalize = TRUE)
plotComponent(fmca, comp = c(1, 2), addNames = FALSE)

</code></pre>

<hr>
<h2 id='boxplot.timeSpent'>Boxplot of time spent in each state</h2><span id='topic+boxplot.timeSpent'></span>

<h3>Description</h3>

<p>Boxplot of time spent in each state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'timeSpent'
boxplot(x, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot.timeSpent_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+compute_time_spent">compute_time_spent</a></code> function</p>
</td></tr>
<tr><td><code id="boxplot.timeSpent_+3A_col">col</code></td>
<td>
<p>a vector containing color for each state</p>
</td></tr>
<tr><td><code id="boxplot.timeSpent_+3A_...">...</code></td>
<td>
<p>extra parameters for <code>geom_boxplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+compute_time_spent">compute_time_spent</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# cut at Tmax = 8
d_JK2 &lt;- cut_data(d_JK, Tmax = 8)

# compute time spent by each id in each state
timeSpent &lt;- compute_time_spent(d_JK2)

# plot the result
boxplot(timeSpent, col = c("#8DA0CB", "#E78AC3", "#A6D854", "#FFD92F"))

# modify the plot using ggplot2
library(ggplot2)
boxplot(timeSpent, notch = TRUE, outlier.colour = "black") +
  coord_flip() +
  labs(title = "Time spent in each state")
</code></pre>

<hr>
<h2 id='care'>Care trajectories</h2><span id='topic+care'></span>

<h3>Description</h3>

<p>Care trajectories of patients diagnosed with a serious and chronic condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(care)
</code></pre>


<h3>Format</h3>

<p>A data.frame containing three columns:
</p>

<ul>
<li> <p><em>id</em> id of individuals (2929 different ids)
</p>
</li>
<li> <p><em>time</em> number of months since the diagnosis
</p>
</li>
<li> <p><em>state</em> new state.
</p>
</li></ul>



<h3>Details</h3>

<p>In this study, patients were followed from the time they were diagnosed with a serious and chronic condition
and their care trajectories were tracked monthly from the time of diagnosis.
The status variable contains the care status of each individual for each month of follow-up.
Trajectories have different lengths.
</p>
<p>The four states are:
</p>

<ul>
<li><p>D: diagnosed, but not in care
</p>
</li>
<li><p>C: in care, but not on treatment
</p>
</li>
<li><p>T: on treatment, but infection not suppressed
</p>
</li>
<li><p>S: on treatment and suppressed infection
</p>
</li></ul>



<h3>Source</h3>

<p>https://larmarange.github.io/analyse-R/data/care_trajectories.RData
https://larmarange.github.io/analyse-R/trajectoires-de-soins.html
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+biofam2">biofam2</a></code>,
<code><a href="#topic+flours">flours</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(care)
head(care)

plotData(care)

# Individuals has not the same length. In order to compute the encoding,
# we keep individuals with at least 18 months of history and work
# with the 18 first months.
duration &lt;- compute_duration(care)
idToKeep &lt;- as.numeric(names(duration[duration &gt;= 18]))
care2 &lt;- cut_data(care[care$id %in% idToKeep, ], 18)
head(care2)

# It is recommended to increase the number of cores to reduce computation time
set.seed(42)
basis &lt;- create.bspline.basis(c(0, 18), nbasis = 10, norder = 4)
fmca &lt;- compute_optimal_encoding(care2, basis, nCores = 2)

plotEigenvalues(fmca, cumulative = TRUE, normalize = TRUE)
plot(fmca)
plot(fmca, addCI = TRUE)
plotComponent(fmca, addNames = FALSE)

</code></pre>

<hr>
<h2 id='cfda-package'>Categorical Functional Data Analysis</h2><span id='topic+cfda-package'></span>

<h3>Description</h3>

<p>cfda provides functions for the analysis of categorical functional data.
</p>
<p>The main contribution is the computation of an optimal encoding (real functional variable) of each state of the categorical
functional data.
This can be done using the <code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a></code> function that takes in arguments the data in a specific
format and a basis of functions created using the <code>fda</code> package (cf. <code>create.basis</code>).
The output can be analysed with <code><a href="#topic+summary.fmca">summary.fmca</a></code>, <code><a href="#topic+plot.fmca">plot.fmca</a></code>, <code><a href="#topic+get_encoding">get_encoding</a></code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a></code> and <code><a href="#topic+plotComponent">plotComponent</a></code>.
</p>
<p>Moreover, <code>cfda</code> contains functions to visualize and compute some statistics about categorical functional data.
A summary of the dataset is available with <code><a href="#topic+summary_cfd">summary_cfd</a></code>.
<code><a href="#topic+plotData">plotData</a></code> shows a graphical representation of the dataset.
Basic statistics can be computed: the number of jumps (<code><a href="#topic+compute_number_jumps">compute_number_jumps</a></code>), the duration
(<code><a href="#topic+compute_duration">compute_duration</a></code>), the time spent in each state (<code><a href="#topic+compute_time_spent">compute_time_spent</a></code>),
the probability to be in each state at any given time (<code><a href="#topic+estimate_pt">estimate_pt</a></code>), the transition table
(<code><a href="#topic+statetable">statetable</a></code>).
</p>
<p>The parameters of a Markov process can be estimated using <code><a href="#topic+estimate_Markov">estimate_Markov</a></code> function.
</p>
<p>In order to test the different functions, a real dataset is provided (<code><a href="#topic+biofam2">biofam2</a></code>) as well as two functions
for generating data: (<code><a href="#topic+generate_Markov">generate_Markov</a></code> and <code><a href="#topic+generate_2State">generate_2State</a></code>).
</p>


<h3>Details</h3>

<p>See the vignette for a detailed example and mathematical background:
<code>RShowDoc("cfda", package = "cfda")</code>
</p>


<h3>References</h3>


<ul>
<li><p> Deville J.C. (1982) Analyse de données chronologiques qualitatives : comment analyser des calendriers ?,
Annales de l'INSEE, No 45, p. 45-104.
</p>
</li>
<li><p> Deville J.C. et  Saporta G. (1980) Analyse harmonique qualitative, DIDAY et al. (editors),
Data Analysis and Informatics, North Holland, p. 375-389.
</p>
</li>
<li><p> Saporta G. (1981) Méthodes exploratoires d'analyse de données temporelles, Cahiers du B.U.R.O,
Université Pierre et Marie Curie, 37-38, Paris.
</p>
</li>
<li><p> Preda C, Grimonprez Q, Vandewalle V. Categorical Functional Data Analysis. The cfda R Package.
Mathematics. 2021; 9(23):3074. https://doi.org/10.3390/math9233074
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
Tmax &lt;- 5
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax)
d_JK2 &lt;- cut_data(d_JK, Tmax)

# create basis object
m &lt;- 5
b &lt;- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding &lt;- compute_optimal_encoding(d_JK2, b, computeCI = FALSE, nCores = 1)
summary(encoding)

# plot eigenvalues
plotEigenvalues(encoding, cumulative = TRUE, normalize = TRUE)

# plot the two first components
plotComponent(encoding, comp = c(1, 2))

# plot the encoding using the first harmonic
plot(encoding)

# extract the encoding using the first harmonic
encod &lt;- get_encoding(encoding)
</code></pre>

<hr>
<h2 id='compute_duration'>Compute duration of individuals</h2><span id='topic+compute_duration'></span>

<h3>Description</h3>

<p>For each individual, compute the duration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_duration(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_duration_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs
and <code>state</code>, associated state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the duration of each trajectories
</p>


<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+hist.duration">hist.duration</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)


# compute duration of each individual
duration &lt;- compute_duration(d_JK)

hist(duration)
</code></pre>

<hr>
<h2 id='compute_number_jumps'>Compute the number of jumps</h2><span id='topic+compute_number_jumps'></span>

<h3>Description</h3>

<p>For each individual, compute the number of jumps performed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_number_jumps(data, countDuplicated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_number_jumps_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="compute_number_jumps_+3A_countduplicated">countDuplicated</code></td>
<td>
<p>if <code>TRUE</code>, jumps in the same state are counted as jump</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the number of jumps for each individual
</p>


<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+hist.njump">hist.njump</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# compute the number of jumps
nJump &lt;- compute_number_jumps(d_JK)
</code></pre>

<hr>
<h2 id='compute_optimal_encoding'>Compute the optimal encoding for each state</h2><span id='topic+compute_optimal_encoding'></span>

<h3>Description</h3>

<p>Compute the optimal encoding for categorical functional data using an extension of the multiple correspondence analysis
to a stochastic process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_optimal_encoding(
  data,
  basisobj,
  computeCI = TRUE,
  nBootstrap = 50,
  propBootstrap = 1,
  method = c("precompute", "parallel"),
  verbose = TRUE,
  nCores = max(1, ceiling(detectCores()/2)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_optimal_encoding_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, associated state. All individuals must begin at the same time T0 and end at the same time Tmax
(use <code><a href="#topic+cut_data">cut_data</a></code>).</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_basisobj">basisobj</code></td>
<td>
<p>basis created using the <code>fda</code> package (cf. <code>create.basis</code>).</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_computeci">computeCI</code></td>
<td>
<p>if TRUE, perform a bootstrap to estimate the variance of encoding functions coefficients</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_nbootstrap">nBootstrap</code></td>
<td>
<p>number of bootstrap samples</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_propbootstrap">propBootstrap</code></td>
<td>
<p>size of bootstrap samples relative to the number of individuals: propBootstrap * number of individuals</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_method">method</code></td>
<td>
<p>computation method: &quot;parallel&quot; or &quot;precompute&quot;: precompute all integrals
(efficient when the number of unique time values is low)</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print some information</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_ncores">nCores</code></td>
<td>
<p>number of cores used for parallelization (only if method == &quot;parallel&quot;). Default is half the cores.</p>
</td></tr>
<tr><td><code id="compute_optimal_encoding_+3A_...">...</code></td>
<td>
<p>parameters for <code><a href="stats.html#topic+integrate">integrate</a></code> function (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette for the mathematical background: <code>RShowDoc("cfda", package = "cfda")</code>
</p>
<p>Extra parameters (<em>...</em>) for the <code><a href="stats.html#topic+integrate">integrate</a></code> function can be:
</p>

<ul>
<li> <p><em>subdivisions</em> the maximum number of subintervals.
</p>
</li>
<li> <p><em>rel.tol</em> relative accuracy requested.
</p>
</li>
<li> <p><em>abs.tol</em> absolute accuracy requested.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>eigenvalues</code> eigenvalues
</p>
</li>
<li> <p><code>alpha</code> optimal encoding coefficients associated with each eigenvectors
</p>
</li>
<li> <p><code>pc</code> principal components
</p>
</li>
<li> <p><code>F</code> matrix containing the <code class="reqn">F_{(x,i)(y,j)}</code>
</p>
</li>
<li> <p><code>V</code> matrix containing the <code class="reqn">V_{(x,i)}</code>
</p>
</li>
<li> <p><code>G</code> covariance matrix of <code>V</code>
</p>
</li>
<li> <p><code>basisobj</code> <code>basisobj</code> input parameter
</p>
</li>
<li> <p><code>pt</code> output of <a href="#topic+estimate_pt">estimate_pt</a> function
</p>
</li>
<li> <p><code>bootstrap</code> Only if <code>computeCI = TRUE</code>. Output of every bootstrap run
</p>
</li>
<li> <p><code>varAlpha</code> Only if <code>computeCI = TRUE</code>. Variance of alpha parameters
</p>
</li>
<li> <p><code>runTime</code> Total elapsed time
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>


<h3>References</h3>


<ul>
<li><p> Deville J.C. (1982) Analyse de données chronologiques qualitatives : comment analyser des calendriers ?,
Annales de l'INSEE, No 45, p. 45-104.
</p>
</li>
<li><p> Deville J.C. et  Saporta G. (1980) Analyse harmonique qualitative, DIDAY et al. (editors), Data Analysis and
Informatics, North Holland, p. 375-389.
</p>
</li>
<li><p> Saporta G. (1981) Méthodes exploratoires d'analyse de données temporelles, Cahiers du B.U.R.O, Université
Pierre et Marie Curie, 37-38, Paris.
</p>
</li>
<li><p> Preda C, Grimonprez Q, Vandewalle V. Categorical Functional Data Analysis. The cfda R Package.
Mathematics. 2021; 9(23):3074. https://doi.org/10.3390/math9233074
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+plot.fmca">plot.fmca</a> <a href="#topic+print.fmca">print.fmca</a> <a href="#topic+summary.fmca">summary.fmca</a> <a href="#topic+plotComponent">plotComponent</a> <a href="#topic+get_encoding">get_encoding</a>
</p>
<p>Other encoding functions: 
<code><a href="#topic+get_encoding">get_encoding</a>()</code>,
<code><a href="#topic+plot.fmca">plot.fmca</a>()</code>,
<code><a href="#topic+plotComponent">plotComponent</a>()</code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a>()</code>,
<code><a href="#topic+predict.fmca">predict.fmca</a>()</code>,
<code><a href="#topic+print.fmca">print.fmca</a>()</code>,
<code><a href="#topic+summary.fmca">summary.fmca</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
Tmax &lt;- 5
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(
  n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax,
  labels = c("A", "C", "G", "T")
)
d_JK2 &lt;- cut_data(d_JK, Tmax)

# create basis object
m &lt;- 5
b &lt;- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding &lt;- compute_optimal_encoding(d_JK2, b, computeCI = FALSE, nCores = 1)
summary(encoding)

# plot the optimal encoding
plot(encoding)

# plot the two first components
plotComponent(encoding, comp = c(1, 2))

# extract the optimal encoding
get_encoding(encoding, harm = 1)
</code></pre>

<hr>
<h2 id='compute_time_spent'>Compute time spent in each state</h2><span id='topic+compute_time_spent'></span>

<h3>Description</h3>

<p>For each individual, compute the time spent in each state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_time_spent(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_time_spent_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs
and <code>state</code>, associated state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with <code>K</code> columns containing the total time spent in each state for each individual
</p>


<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# cut at Tmax = 8
d_JK2 &lt;- cut_data(d_JK, Tmax = 8)

# compute time spent by each id in each state
timeSpent &lt;- compute_time_spent(d_JK2)
</code></pre>

<hr>
<h2 id='convertToCfd'>Convert data to categorical functional data</h2><span id='topic+convertToCfd'></span>

<h3>Description</h3>

<p>Convert data to categorical functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertToCfd(
  x,
  breaks,
  labels = NULL,
  include.lowest = FALSE,
  right = TRUE,
  times = NULL,
  idLabels = NULL,
  nx = 200,
  byrow = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertToCfd_+3A_x">x</code></td>
<td>
<p>matrix or fd object</p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_breaks">breaks</code></td>
<td>
<p>either a numeric vector of two or more unique cut points or a single number (greater than or equal to 2)
giving the number of intervals into which x is to be cut.</p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_labels">labels</code></td>
<td>
<p>labels for the levels of the resulting category. By default, labels are constructed using &quot;(a,b]&quot;
interval notation. If labels = FALSE, simple integer codes are returned instead of a factor.</p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_include.lowest">include.lowest</code></td>
<td>
<p>logical, indicating if an ‘x[i]’ equal to the lowest (or highest, for right = FALSE) ‘breaks’
value should be included.</p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_right">right</code></td>
<td>
<p>logical, indicating if the intervals should be closed on the right (and open on the left) or vice versa.</p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_times">times</code></td>
<td>
<p>vector containing values at which <code>fd</code> is to be evaluated</p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_idlabels">idLabels</code></td>
<td>
<p>vector containing id labels. If NULL it use the names found in the matrix or fd object</p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_nx">nx</code></td>
<td>
<p>Only if <code>x</code> is a fd object. Number of points to evaluate <code>fd</code></p>
</td></tr>
<tr><td><code id="convertToCfd_+3A_byrow">byrow</code></td>
<td>
<p>Only if <code>x</code> is a matrix. If <code>FALSE</code>, one column = one trajectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame in the cfda format
</p>


<h3>See Also</h3>

<p><a href="#topic+flours">flours</a>
</p>
<p>Other format: 
<code><a href="#topic+cut_data">cut_data</a>()</code>,
<code><a href="#topic+matrixToCfd">matrixToCfd</a>()</code>,
<code><a href="#topic+remove_duplicated_states">remove_duplicated_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fd object
data("CanadianWeather")
temp &lt;- CanadianWeather$dailyAv[,, "Temperature.C"]
basis &lt;- create.bspline.basis(c(1, 365), nbasis = 8, norder = 4)
fd &lt;- smooth.basis(1:365, temp, basis)$fd

# "Very Cold" = [-50:-10), "Cold" = [-10:0), ...
out &lt;- convertToCfd(fd, breaks = c(-50, -10, 0, 10, 20, 50),
                    labels = c("Very Cold", "Cold", "Fresh", "OK", "Hot"),
                    times = 1:365)

# matrix
out2 &lt;- convertToCfd(temp, breaks = c(-50, -10, 0, 10, 20, 50),
                     labels = c("Very Cold", "Cold", "Fresh", "OK", "Hot"),
                     times = 1:365, byrow = FALSE)
</code></pre>

<hr>
<h2 id='cut_data'>Cut data to a maximal given time</h2><span id='topic+cut_data'></span>

<h3>Description</h3>

<p>Cut data to a maximal given time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_data(
  data,
  Tmax,
  prolongLastState = "all",
  NAstate = "Not observed",
  warning = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_data_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>,
time at which a change occurs and <code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="cut_data_+3A_tmax">Tmax</code></td>
<td>
<p>max time considered</p>
</td></tr>
<tr><td><code id="cut_data_+3A_prolonglaststate">prolongLastState</code></td>
<td>
<p>list of states to prolong (can be &quot;all&quot;). In the case where the last state of a trajectory is
lesser than <code>Tmax</code>, we can assume that this trajectory will be in the same state at time Tmax only if it is an
absorbing state. Otherwise it will add <code>NAstate</code> and throw a warning.
Set 'prolongLastState = c()' to indicate there is no absorbing state.</p>
</td></tr>
<tr><td><code id="cut_data_+3A_nastate">NAstate</code></td>
<td>
<p>state value used when the last state is not prolonged.</p>
</td></tr>
<tr><td><code id="cut_data_+3A_warning">warning</code></td>
<td>
<p>if TRUE, the function raises warnings when it has prolonged a trajectory with NAstate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the same format as <code>data</code> where each individual has <code>Tmax</code> as last time entry.
</p>


<h3>Author(s)</h3>

<p>Cristian Preda
</p>


<h3>See Also</h3>

<p>Other format: 
<code><a href="#topic+convertToCfd">convertToCfd</a>()</code>,
<code><a href="#topic+matrixToCfd">matrixToCfd</a>()</code>,
<code><a href="#topic+remove_duplicated_states">remove_duplicated_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
set.seed(42)
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)
tail(d_JK)

# cut at Tmax = 8
d_JK2 &lt;- cut_data(d_JK, Tmax = 8)
tail(d_JK2)

# do not prolong any state
try(d_JK2 &lt;- cut_data(d_JK, Tmax = 12, prolongLastState = c()))
</code></pre>

<hr>
<h2 id='estimate_Markov'>Estimate transition matrix and spent time</h2><span id='topic+estimate_Markov'></span>

<h3>Description</h3>

<p>Calculates crude initial values for transition intensities by assuming that the data represent the exact transition
times of the Markov process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_Markov(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_Markov_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, associated state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two elements: <code>Q</code>, the estimated transition matrix, and <code>lambda</code>,
the estimated time spent in each state
</p>


<h3>Author(s)</h3>

<p>Cristian Preda
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.Markov">plot.Markov</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 100, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# estimation
mark &lt;- estimate_Markov(d_JK)
mark$P
mark$lambda
</code></pre>

<hr>
<h2 id='estimate_pt'>Estimate probabilities to be in each state</h2><span id='topic+estimate_pt'></span>

<h3>Description</h3>

<p>Estimate probabilities to be in each state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_pt(data, NAafterTmax = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_pt_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs
and <code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="estimate_pt_+3A_naaftertmax">NAafterTmax</code></td>
<td>
<p>if TRUE, return NA if t &gt; Tmax otherwise return the state associated with Tmax
(useful when individuals has different lengths)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li><p>t: vector of time
</p>
</li>
<li><p>pt: a matrix with K (= number of states) rows and with <code>length(t)</code> columns containing the
probabilities to be in each state at each time.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.pt">plot.pt</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

d_JK2 &lt;- cut_data(d_JK, 10)

# estimate probabilities
estimate_pt(d_JK2)
</code></pre>

<hr>
<h2 id='flours'>Flours dataset</h2><span id='topic+flours'></span>

<h3>Description</h3>

<p>Resistance of dough during the kneading process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(flours)
</code></pre>


<h3>Format</h3>

<p><code>flours</code> is a list of 3 elements:
</p>

<ul>
<li> <p><code>data</code> A matrix of size 241*115 containing the resistance of dough (measured every 2s) during the kneading
process. One dough batch = 1 column
</p>
</li>
<li> <p><code>quality</code> Quality of cookies baked with the associated dough (1=Good, 2=Medium, 3=Bad)
</p>
</li>
<li> <p><code>time</code> time values
</p>
</li></ul>



<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+biofam2">biofam2</a></code>,
<code><a href="#topic+care">care</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(flours)

matplot(flours$time, flours$data, col = flours$quality, type = "l", lty = 1)

# convert to categorical data
flours_cfd &lt;- convertToCfd(flours$data, breaks = c(-Inf, 150, 300, 450, 600, Inf),
                           times = flours$time)

plotData(flours_cfd, group = flours$quality)


# convert to categorical data after projecting in a basis of functions
basis &lt;- create.bspline.basis(c(0, 480), nbasis = 10)
flours_fd &lt;- Data2fd(flours$time, flours$data, basis)
plot(flours_fd)

flours_cfd2 &lt;- convertToCfd(flours_fd, breaks = c(-Inf, 150, 300, 450, 600, Inf))

plotData(flours_cfd2, group = flours$quality)
</code></pre>

<hr>
<h2 id='generate_2State'>Generate data following a 2 states model</h2><span id='topic+generate_2State'></span>

<h3>Description</h3>

<p>Generate individuals such that each individual starts at time 0 with state 0 and then an unique change
to state 1 occurs at a time <code class="reqn">t</code> generated using an uniform law between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_2State(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_2State_+3A_n">n</code></td>
<td>
<p>number of individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with 3 columns: <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, new state.
</p>


<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>

<hr>
<h2 id='generate_Markov'>Generate Markov Trajectories</h2><span id='topic+generate_Markov'></span>

<h3>Description</h3>

<p>Simulate individuals from a Markov process defined by a transition matrix,
time spent in each time and initial probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_Markov(
  n = 5,
  K = 2,
  P = (1 - diag(K))/(K - 1),
  lambda = rep(1, K),
  pi0 = c(1, rep(0, K - 1)),
  Tmax = 1,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_Markov_+3A_n">n</code></td>
<td>
<p>number of trajectories to generate</p>
</td></tr>
<tr><td><code id="generate_Markov_+3A_k">K</code></td>
<td>
<p>number of states</p>
</td></tr>
<tr><td><code id="generate_Markov_+3A_p">P</code></td>
<td>
<p>matrix containing the transition probabilities from one state to another.
Each row contains positive reals summing to 1.</p>
</td></tr>
<tr><td><code id="generate_Markov_+3A_lambda">lambda</code></td>
<td>
<p>time spent in each state</p>
</td></tr>
<tr><td><code id="generate_Markov_+3A_pi0">pi0</code></td>
<td>
<p>initial distribution of states</p>
</td></tr>
<tr><td><code id="generate_Markov_+3A_tmax">Tmax</code></td>
<td>
<p>maximal duration of trajectories</p>
</td></tr>
<tr><td><code id="generate_Markov_+3A_labels">labels</code></td>
<td>
<p>state names. If <code>NULL</code>, integers are used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For one individual, assuming the current state is <code class="reqn">s_j</code> at time <code class="reqn">t_j</code>,
the next state and time is simulated as follows:
</p>

<ol>
<li><p> generate one sample, <code class="reqn">d</code>, of an exponential law of parameter <code>lambda[s_j]</code>
</p>
</li>
<li><p> define the next time values as: <code class="reqn">t_{j+1} = t_j + d</code>
</p>
</li>
<li><p> generate the new state <code class="reqn">s_{j+1}</code> using a multinomial law with probabilities <code>Q[s_j,]</code>
</p>
</li></ol>



<h3>Value</h3>

<p>a data.frame with 3 columns: <code>id</code>, id of the trajectory, <code>time</code>,
time at which a change occurs and <code>state</code>, new state.
</p>


<h3>Author(s)</h3>

<p>Cristian Preda
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(
  n = 100, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10,
  labels = c("A", "C", "G", "T")
)

head(d_JK)
</code></pre>

<hr>
<h2 id='get_encoding'>Extract the computed encoding</h2><span id='topic+get_encoding'></span>

<h3>Description</h3>

<p>Extract the encoding as an <code>fd</code> object or as a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_encoding(x, harm = 1, fdObject = FALSE, nx = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_encoding_+3A_x">x</code></td>
<td>
<p>Output of <code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a></code></p>
</td></tr>
<tr><td><code id="get_encoding_+3A_harm">harm</code></td>
<td>
<p>harmonic to use for the encoding</p>
</td></tr>
<tr><td><code id="get_encoding_+3A_fdobject">fdObject</code></td>
<td>
<p>If TRUE returns a <code>fd</code> object else a matrix</p>
</td></tr>
<tr><td><code id="get_encoding_+3A_nx">nx</code></td>
<td>
<p>(Only if <code>fdObject = TRUE</code>) Number of points to evaluate the encoding</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding is <code class="reqn">a_{x} \approx \sum_{i=1}^m \alpha_{x,i}\phi_i</code>.
</p>


<h3>Value</h3>

<p>a <code>fd</code> object or a list of two elements <code>y</code>, a matrix with <code>nx</code> rows containing
the encoding of the state and <code>x</code>, the vector with time values.
</p>


<h3>Author(s)</h3>

<p>Cristian Preda
</p>


<h3>See Also</h3>

<p>Other encoding functions: 
<code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>()</code>,
<code><a href="#topic+plot.fmca">plot.fmca</a>()</code>,
<code><a href="#topic+plotComponent">plotComponent</a>()</code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a>()</code>,
<code><a href="#topic+predict.fmca">predict.fmca</a>()</code>,
<code><a href="#topic+print.fmca">print.fmca</a>()</code>,
<code><a href="#topic+summary.fmca">summary.fmca</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
Tmax &lt;- 6
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax)
d_JK2 &lt;- cut_data(d_JK, Tmax)

# create basis object
m &lt;- 6
b &lt;- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding &lt;- compute_optimal_encoding(d_JK2, b, computeCI = FALSE, nCores = 1)

# extract the encoding using 1 harmonic
encodFd &lt;- get_encoding(encoding, fdObject = TRUE)
encodMat &lt;- get_encoding(encoding, nx = 200)


</code></pre>

<hr>
<h2 id='get_state'>Extract the state of each individual at a given time</h2><span id='topic+get_state'></span>

<h3>Description</h3>

<p>Extract the state of each individual at a given time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_state(data, t, NAafterTmax = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_state_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="get_state_+3A_t">t</code></td>
<td>
<p>time at which extract the state</p>
</td></tr>
<tr><td><code id="get_state_+3A_naaftertmax">NAafterTmax</code></td>
<td>
<p>if TRUE, return NA if t &gt; Tmax otherwise return the state associated with Tmax
(useful when individuals has different lengths)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the state of each individual at time t
</p>


<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# get the state of each individual at time t = 6
get_state(d_JK, 6)


# get the state of each individual at time t = 12 (&gt; Tmax)
get_state(d_JK, 12)
# if NAafterTmax = TRUE, it will return NA for t &gt; Tmax
get_state(d_JK, 12, NAafterTmax = TRUE)

</code></pre>

<hr>
<h2 id='hist.duration'>Plot the duration</h2><span id='topic+hist.duration'></span>

<h3>Description</h3>

<p>Plot the duration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duration'
hist(x, breaks = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.duration_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+compute_duration">compute_duration</a></code> function</p>
</td></tr>
<tr><td><code id="hist.duration_+3A_breaks">breaks</code></td>
<td>
<p>number of breaks. If not given, use the Sturges rule</p>
</td></tr>
<tr><td><code id="hist.duration_+3A_...">...</code></td>
<td>
<p>parameters for <code>geom_histogram</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+compute_duration">compute_duration</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)


# compute duration of each individual
duration &lt;- compute_duration(d_JK)

hist(duration)

# modify the plot using ggplot2
library(ggplot2)
hist(duration) +
  labs(title = "Distribution of the duration")
</code></pre>

<hr>
<h2 id='hist.njump'>Plot the number of jumps</h2><span id='topic+hist.njump'></span>

<h3>Description</h3>

<p>Plot the number of jumps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'njump'
hist(x, breaks = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.njump_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+compute_number_jumps">compute_number_jumps</a></code> function</p>
</td></tr>
<tr><td><code id="hist.njump_+3A_breaks">breaks</code></td>
<td>
<p>number of breaks. If not given, use the Sturges rule</p>
</td></tr>
<tr><td><code id="hist.njump_+3A_...">...</code></td>
<td>
<p>parameters for <code>geom_histogram</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+compute_number_jumps">compute_number_jumps</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

nJump &lt;- compute_number_jumps(d_JK)

hist(nJump)

# modify the plot using ggplot2
library(ggplot2)
hist(nJump, fill = "#984EA3") +
  labs(title = "Distribution of the number of jumps")
</code></pre>

<hr>
<h2 id='matrixToCfd'>Convert a matrix to a cfda data.frame</h2><span id='topic+matrixToCfd'></span>

<h3>Description</h3>

<p>Convert a matrix to a cfda data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixToCfd(X, times = NULL, labels = NULL, byrow = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixToCfd_+3A_x">X</code></td>
<td>
<p>matrix containing the states</p>
</td></tr>
<tr><td><code id="matrixToCfd_+3A_times">times</code></td>
<td>
<p>time values. If <code>NULL</code>, it uses a sequence of integers starting with 1</p>
</td></tr>
<tr><td><code id="matrixToCfd_+3A_labels">labels</code></td>
<td>
<p>id labels. If <code>NULL</code>, it uses the matrix colnames</p>
</td></tr>
<tr><td><code id="matrixToCfd_+3A_byrow">byrow</code></td>
<td>
<p>if <code>FALSE</code>, one column = one trajectory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame in the cfda format
</p>


<h3>See Also</h3>

<p>Other format: 
<code><a href="#topic+convertToCfd">convertToCfd</a>()</code>,
<code><a href="#topic+cut_data">cut_data</a>()</code>,
<code><a href="#topic+remove_duplicated_states">remove_duplicated_states</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(c("a", "b", "c", "c",
              "c", "a", "a", "a",
              "b", "c", "a", "b"), ncol = 4, byrow = TRUE,
              dimnames = list(NULL, paste0("ind", 1:4)))
matrixToCfd(x)
</code></pre>

<hr>
<h2 id='plot.fmca'>Plot the optimal encoding</h2><span id='topic+plot.fmca'></span>

<h3>Description</h3>

<p>Plot the optimal encoding
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmca'
plot(
  x,
  harm = 1,
  states = NULL,
  addCI = FALSE,
  coeff = 1.96,
  col = NULL,
  nx = 128,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fmca_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a></code> function</p>
</td></tr>
<tr><td><code id="plot.fmca_+3A_harm">harm</code></td>
<td>
<p>harmonic to use for the encoding</p>
</td></tr>
<tr><td><code id="plot.fmca_+3A_states">states</code></td>
<td>
<p>states to plot (default = NULL, it plots all states)</p>
</td></tr>
<tr><td><code id="plot.fmca_+3A_addci">addCI</code></td>
<td>
<p>if TRUE, plot confidence interval (only when <code>computeCI = TRUE</code> in <a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>)</p>
</td></tr>
<tr><td><code id="plot.fmca_+3A_coeff">coeff</code></td>
<td>
<p>the confidence interval is computed with +- coeff * the standard deviation</p>
</td></tr>
<tr><td><code id="plot.fmca_+3A_col">col</code></td>
<td>
<p>a vector containing color for each state</p>
</td></tr>
<tr><td><code id="plot.fmca_+3A_nx">nx</code></td>
<td>
<p>number of time points used to plot</p>
</td></tr>
<tr><td><code id="plot.fmca_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The encoding for the harmonic <code>h</code> is <code class="reqn">a_{x}^{(h)} \approx \sum_{i=1}^m \alpha_{x,i}^{(h)}\phi_i</code>.
</p>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other encoding functions: 
<code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>()</code>,
<code><a href="#topic+get_encoding">get_encoding</a>()</code>,
<code><a href="#topic+plotComponent">plotComponent</a>()</code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a>()</code>,
<code><a href="#topic+predict.fmca">predict.fmca</a>()</code>,
<code><a href="#topic+print.fmca">print.fmca</a>()</code>,
<code><a href="#topic+summary.fmca">summary.fmca</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
Tmax &lt;- 6
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax)
d_JK2 &lt;- cut_data(d_JK, Tmax)

# create basis object
m &lt;- 6
b &lt;- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding &lt;- compute_optimal_encoding(d_JK2, b, computeCI = FALSE, nCores = 1)

# plot the encoding produced by the first harmonic
plot(encoding)


# modify the plot using ggplot2
library(ggplot2)
plot(encoding, harm = 2, col = c("red", "blue", "darkgreen", "yellow")) +
  labs(title = "Optimal encoding")


</code></pre>

<hr>
<h2 id='plot.Markov'>Plot the transition graph</h2><span id='topic+plot.Markov'></span>

<h3>Description</h3>

<p>Plot the transition graph between the different states. A node corresponds to a state with the mean
time spent in this state. Each arrow represents the probability of transition between states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Markov'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Markov_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+estimate_Markov">estimate_Markov</a></code> function</p>
</td></tr>
<tr><td><code id="plot.Markov_+3A_...">...</code></td>
<td>
<p>parameters of <code>plotmat</code> function from <code>diagram</code> package (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some useful extra parameters:
</p>

<ul>
<li> <p><code>main</code> main title.
</p>
</li>
<li> <p><code>dtext</code> controls the position of arrow text relative to arrowhead (default = 0.3).
</p>
</li>
<li> <p><code>relsize</code>	scaling factor for size of the graph (default = 1).
</p>
</li>
<li> <p><code>box.size</code> size of label box, one value or a vector with dimension = number of rows of <code>x$P</code>.
</p>
</li>
<li> <p><code>box.cex</code>	relative size of text in boxes, one value or a vector with dimension=number of rows of <code>x$P</code>.
</p>
</li>
<li> <p><code>arr.pos</code> relative position of arrowhead on arrow segment/curve.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Author(s)</h3>

<p>Cristian Preda
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 100, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# estimation
mark &lt;- estimate_Markov(d_JK)

# transition graph
plot(mark)
</code></pre>

<hr>
<h2 id='plot.pt'>Plot probabilities</h2><span id='topic+plot.pt'></span>

<h3>Description</h3>

<p>Plot the probabilities of each state at each given time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pt'
plot(x, col = NULL, ribbon = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pt_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+estimate_pt">estimate_pt</a></code></p>
</td></tr>
<tr><td><code id="plot.pt_+3A_col">col</code></td>
<td>
<p>a vector containing color for each state</p>
</td></tr>
<tr><td><code id="plot.pt_+3A_ribbon">ribbon</code></td>
<td>
<p>if TRUE, use ribbon to plot probabilities</p>
</td></tr>
<tr><td><code id="plot.pt_+3A_...">...</code></td>
<td>
<p>only if <code>ribbon = TRUE</code>, parameter <code>addBorder</code>, if TRUE, add black border to the ribbons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p><a href="#topic+estimate_pt">estimate_pt</a>
</p>
<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

d_JK2 &lt;- cut_data(d_JK, 10)

pt &lt;- estimate_pt(d_JK2)

plot(pt, ribbon = TRUE)
</code></pre>

<hr>
<h2 id='plotComponent'>Plot Components</h2><span id='topic+plotComponent'></span>

<h3>Description</h3>

<p>Plot Components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotComponent(
  x,
  comp = c(1, 2),
  addNames = TRUE,
  nudge_x = 0.1,
  nudge_y = 0.1,
  size = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotComponent_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a></code> function</p>
</td></tr>
<tr><td><code id="plotComponent_+3A_comp">comp</code></td>
<td>
<p>a vector of two elements indicating the components to plot</p>
</td></tr>
<tr><td><code id="plotComponent_+3A_addnames">addNames</code></td>
<td>
<p>if TRUE, add the id labels on the plot</p>
</td></tr>
<tr><td><code id="plotComponent_+3A_nudge_x">nudge_x</code>, <code id="plotComponent_+3A_nudge_y">nudge_y</code></td>
<td>
<p>horizontal and vertical adjustment to nudge labels by</p>
</td></tr>
<tr><td><code id="plotComponent_+3A_size">size</code></td>
<td>
<p>size of labels</p>
</td></tr>
<tr><td><code id="plotComponent_+3A_...">...</code></td>
<td>
<p><code>geom_point</code> parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other encoding functions: 
<code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>()</code>,
<code><a href="#topic+get_encoding">get_encoding</a>()</code>,
<code><a href="#topic+plot.fmca">plot.fmca</a>()</code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a>()</code>,
<code><a href="#topic+predict.fmca">predict.fmca</a>()</code>,
<code><a href="#topic+print.fmca">print.fmca</a>()</code>,
<code><a href="#topic+summary.fmca">summary.fmca</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
Tmax &lt;- 6
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax)
d_JK2 &lt;- cut_data(d_JK, Tmax)

# create basis object
m &lt;- 6
b &lt;- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding &lt;- compute_optimal_encoding(d_JK2, b, computeCI = FALSE, nCores = 1)

plotComponent(encoding, comp = c(1, 2))

# modify the plot using ggplot2
library(ggplot2)
plotComponent(encoding, comp = c(1, 2), shape = 23) +
  labs(title = "Two first components")



</code></pre>

<hr>
<h2 id='plotData'>Plot categorical functional data</h2><span id='topic+plotData'></span>

<h3>Description</h3>

<p>Plot categorical functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotData(
  data,
  group = NULL,
  col = NULL,
  addId = TRUE,
  addBorder = TRUE,
  sort = FALSE,
  nCol = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotData_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="plotData_+3A_group">group</code></td>
<td>
<p>vector, of the same length as the number individuals of <code>data</code>, containing group index.
Groups are displayed on separate plots.
If <code>group = NA</code>, the corresponding individuals in <code>data</code> is ignored.</p>
</td></tr>
<tr><td><code id="plotData_+3A_col">col</code></td>
<td>
<p>a vector containing color for each state (can be named)</p>
</td></tr>
<tr><td><code id="plotData_+3A_addid">addId</code></td>
<td>
<p>If TRUE, add id labels</p>
</td></tr>
<tr><td><code id="plotData_+3A_addborder">addBorder</code></td>
<td>
<p>If TRUE, add black border to each individual</p>
</td></tr>
<tr><td><code id="plotData_+3A_sort">sort</code></td>
<td>
<p>If TRUE, id are sorted according to the duration in their first state</p>
</td></tr>
<tr><td><code id="plotData_+3A_ncol">nCol</code></td>
<td>
<p>number of columns when <code>group</code> is given</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
On the plot, each row represents an individual over [0:Tmax].
The color at a given time gives the state of the individual.
</p>


<h3>Author(s)</h3>

<p>Cristian Preda, Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# add a line with time Tmax at the end of each individual
d_JKT &lt;- cut_data(d_JK, Tmax = 10)

plotData(d_JKT)

# modify the plot using ggplot2
library(ggplot2)
plotData(d_JKT, col = c("red", "blue", "green", "brown")) +
  labs(title = "Trajectories of a Markov process")


# use the group variable: create a group with the 3 first variables and one with the others
group &lt;- rep(1:2, c(3, 7))
plotData(d_JKT, group = group)


# use the group variable: remove the id number 5 and 6
group[c(5, 6)] &lt;- NA
plotData(d_JKT, group = group)
</code></pre>

<hr>
<h2 id='plotEigenvalues'>Plot Eigenvalues</h2><span id='topic+plotEigenvalues'></span>

<h3>Description</h3>

<p>Plot Eigenvalues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEigenvalues(x, cumulative = FALSE, normalize = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEigenvalues_+3A_x">x</code></td>
<td>
<p>output of <code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a></code> function</p>
</td></tr>
<tr><td><code id="plotEigenvalues_+3A_cumulative">cumulative</code></td>
<td>
<p>if TRUE, plot the cumulative eigenvalues</p>
</td></tr>
<tr><td><code id="plotEigenvalues_+3A_normalize">normalize</code></td>
<td>
<p>if TRUE eigenvalues are normalized for summing to 1</p>
</td></tr>
<tr><td><code id="plotEigenvalues_+3A_...">...</code></td>
<td>
<p><code>geom_point</code> parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> object that can be modified using <code>ggplot2</code> package.
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other encoding functions: 
<code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>()</code>,
<code><a href="#topic+get_encoding">get_encoding</a>()</code>,
<code><a href="#topic+plot.fmca">plot.fmca</a>()</code>,
<code><a href="#topic+plotComponent">plotComponent</a>()</code>,
<code><a href="#topic+predict.fmca">predict.fmca</a>()</code>,
<code><a href="#topic+print.fmca">print.fmca</a>()</code>,
<code><a href="#topic+summary.fmca">summary.fmca</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
Tmax &lt;- 6
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax)
d_JK2 &lt;- cut_data(d_JK, Tmax)

# create basis object
m &lt;- 6
b &lt;- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding &lt;- compute_optimal_encoding(d_JK2, b, computeCI = FALSE, nCores = 1)

# plot eigenvalues
plotEigenvalues(encoding, cumulative = TRUE, normalize = TRUE)

# modify the plot using ggplot2
library(ggplot2)
plotEigenvalues(encoding, shape = 23) +
  labs(caption = "Jukes-Cantor model of nucleotide replacement")



</code></pre>

<hr>
<h2 id='predict.fmca'>Predict the principal components for new trajectories</h2><span id='topic+predict.fmca'></span>

<h3>Description</h3>

<p>Predict the principal components for new trajectories
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmca'
predict(
  object,
  newdata = NULL,
  method = c("precompute", "parallel"),
  verbose = TRUE,
  nCores = max(1, ceiling(detectCores()/2)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.fmca_+3A_object">object</code></td>
<td>
<p>output of <a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a> function.</p>
</td></tr>
<tr><td><code id="predict.fmca_+3A_newdata">newdata</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, associated state. All individuals must begin at the same time T0 and end at the same time Tmax
(use <code><a href="#topic+cut_data">cut_data</a></code>).</p>
</td></tr>
<tr><td><code id="predict.fmca_+3A_method">method</code></td>
<td>
<p>computation method: &quot;parallel&quot; or &quot;precompute&quot;: precompute all integrals
(efficient when the number of unique time values is low)</p>
</td></tr>
<tr><td><code id="predict.fmca_+3A_verbose">verbose</code></td>
<td>
<p>if TRUE print some information</p>
</td></tr>
<tr><td><code id="predict.fmca_+3A_ncores">nCores</code></td>
<td>
<p>number of cores used for parallelization (only if method == &quot;parallel&quot;). Default is half the cores.</p>
</td></tr>
<tr><td><code id="predict.fmca_+3A_...">...</code></td>
<td>
<p>parameters for <code><a href="stats.html#topic+integrate">integrate</a></code> function (see details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>principal components for the individuals
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other encoding functions: 
<code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>()</code>,
<code><a href="#topic+get_encoding">get_encoding</a>()</code>,
<code><a href="#topic+plot.fmca">plot.fmca</a>()</code>,
<code><a href="#topic+plotComponent">plotComponent</a>()</code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a>()</code>,
<code><a href="#topic+print.fmca">print.fmca</a>()</code>,
<code><a href="#topic+summary.fmca">summary.fmca</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
Tmax &lt;- 6
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(
  n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax,
  labels = c("A", "C", "G", "T")
)
d_JK2 &lt;- cut_data(d_JK, Tmax)

# create basis object
m &lt;- 6
b &lt;- create.bspline.basis(c(0, Tmax), nbasis = m, norder = 4)

# compute encoding
encoding &lt;- compute_optimal_encoding(d_JK2, b, computeCI = FALSE, nCores = 1)

# predict principal components
d_JK_predict &lt;- generate_Markov(
  n = 5, K = K, P = PJK, lambda = lambda_PJK, Tmax = Tmax,
  labels = c("A", "C", "G", "T")
)
d_JK_predict2 &lt;- cut_data(d_JK, Tmax)

pc &lt;- predict(encoding, d_JK_predict2, nCores = 1)


</code></pre>

<hr>
<h2 id='print.fmca'>Print a <code>fmca</code> object</h2><span id='topic+print.fmca'></span>

<h3>Description</h3>

<p>Print a <code>fmca</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmca'
print(x, n = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fmca_+3A_x">x</code></td>
<td>
<p><code>fmca</code> object (see <a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a> function)</p>
</td></tr>
<tr><td><code id="print.fmca_+3A_n">n</code></td>
<td>
<p>maximal number of rows and cols to print</p>
</td></tr>
<tr><td><code id="print.fmca_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p>Other encoding functions: 
<code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>()</code>,
<code><a href="#topic+get_encoding">get_encoding</a>()</code>,
<code><a href="#topic+plot.fmca">plot.fmca</a>()</code>,
<code><a href="#topic+plotComponent">plotComponent</a>()</code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a>()</code>,
<code><a href="#topic+predict.fmca">predict.fmca</a>()</code>,
<code><a href="#topic+summary.fmca">summary.fmca</a>()</code>
</p>

<hr>
<h2 id='remove_duplicated_states'>Remove duplicated states</h2><span id='topic+remove_duplicated_states'></span>

<h3>Description</h3>

<p>Remove duplicated consecutive states from data.
If for an individual there is two or more consecutive states that are identical, only the first is kept.
Only time when the state changes are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_duplicated_states(data, keep.last = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_duplicated_states_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs
and <code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="remove_duplicated_states_+3A_keep.last">keep.last</code></td>
<td>
<p>if TRUE, keep the last state for every individual even if it is a duplicated state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data</code> without duplicated consecutive states
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other format: 
<code><a href="#topic+convertToCfd">convertToCfd</a>()</code>,
<code><a href="#topic+cut_data">cut_data</a>()</code>,
<code><a href="#topic+matrixToCfd">matrixToCfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(
  id = rep(1:3, c(10, 3, 8)), time = c(1:10, 1:3, 1:8),
  state = c(rep(1:5, each = 2), 1:3, rep(1:3, c(1, 6, 1)))
)
out &lt;- remove_duplicated_states(data)
</code></pre>

<hr>
<h2 id='statetable'>Table of transitions</h2><span id='topic+statetable'></span>

<h3>Description</h3>

<p>Calculates a frequency table counting the number of times each pair of states were observed in successive observation times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statetable(data, removeDiagonal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statetable_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs
and <code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="statetable_+3A_removediagonal">removeDiagonal</code></td>
<td>
<p>if TRUE, does not count transition from a state i to i</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of size <code>K*K</code> containing the number of transition for each pair
</p>


<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+summary_cfd">summary_cfd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate the Jukes-Cantor model of nucleotide replacement
K &lt;- 4
PJK &lt;- matrix(1 / 3, nrow = K, ncol = K) - diag(rep(1 / 3, K))
lambda_PJK &lt;- c(1, 1, 1, 1)
d_JK &lt;- generate_Markov(n = 10, K = K, P = PJK, lambda = lambda_PJK, Tmax = 10)

# table of transitions
statetable(d_JK)
</code></pre>

<hr>
<h2 id='summary_cfd'>Summary</h2><span id='topic+summary_cfd'></span>

<h3>Description</h3>

<p>Get a summary of the data.frame containing categorical functional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_cfd(data, max.print = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_cfd_+3A_data">data</code></td>
<td>
<p>data.frame containing <code>id</code>, id of the trajectory, <code>time</code>, time at which a change occurs and
<code>state</code>, associated state.</p>
</td></tr>
<tr><td><code id="summary_cfd_+3A_max.print">max.print</code></td>
<td>
<p>maximal number of states to display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing:
</p>

<ul>
<li> <p><code>nRow</code> number of rows
</p>
</li>
<li> <p><code>nInd</code> number of individuals
</p>
</li>
<li> <p><code>timeRange</code> minimal and maximal time value
</p>
</li>
<li> <p><code>uniqueStart</code> TRUE, if all individuals have the same time start value
</p>
</li>
<li> <p><code>uniqueEnd</code> TRUE, if all individuals have the same time start value
</p>
</li>
<li> <p><code>states</code> vector containing the different states
</p>
</li>
<li> <p><code>visit</code> number of individuals visiting each state
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Quentin Grimonprez
</p>


<h3>See Also</h3>

<p>Other Descriptive statistics: 
<code><a href="#topic+boxplot.timeSpent">boxplot.timeSpent</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_number_jumps">compute_number_jumps</a>()</code>,
<code><a href="#topic+compute_time_spent">compute_time_spent</a>()</code>,
<code><a href="#topic+estimate_pt">estimate_pt</a>()</code>,
<code><a href="#topic+hist.duration">hist.duration</a>()</code>,
<code><a href="#topic+hist.njump">hist.njump</a>()</code>,
<code><a href="#topic+plot.pt">plot.pt</a>()</code>,
<code><a href="#topic+plotData">plotData</a>()</code>,
<code><a href="#topic+statetable">statetable</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biofam2)
summary_cfd(biofam2)
</code></pre>

<hr>
<h2 id='summary.fmca'>Object Summaries</h2><span id='topic+summary.fmca'></span>

<h3>Description</h3>

<p>Summary of a <code>fmca</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmca'
summary(object, n = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fmca_+3A_object">object</code></td>
<td>
<p><code>fmca</code> object (see <a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a> function)</p>
</td></tr>
<tr><td><code id="summary.fmca_+3A_n">n</code></td>
<td>
<p>maximal number of rows and cols to print</p>
</td></tr>
<tr><td><code id="summary.fmca_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p>Other encoding functions: 
<code><a href="#topic+compute_optimal_encoding">compute_optimal_encoding</a>()</code>,
<code><a href="#topic+get_encoding">get_encoding</a>()</code>,
<code><a href="#topic+plot.fmca">plot.fmca</a>()</code>,
<code><a href="#topic+plotComponent">plotComponent</a>()</code>,
<code><a href="#topic+plotEigenvalues">plotEigenvalues</a>()</code>,
<code><a href="#topic+predict.fmca">predict.fmca</a>()</code>,
<code><a href="#topic+print.fmca">print.fmca</a>()</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
