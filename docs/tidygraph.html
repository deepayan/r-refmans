<!DOCTYPE html><html lang="en"><head><title>Help for package tidygraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidygraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tidygraph-package'><p>tidygraph: A Tidy API for Graph Manipulation</p></a></li>
<li><a href='#activate'><p>Determine the context of subsequent manipulations</p></a></li>
<li><a href='#as_tbl_graph.data.frame'><p>A data structure for tidy graph manipulation</p></a></li>
<li><a href='#bind_graphs'><p>Add graphs, nodes, or edges to a tbl_graph</p></a></li>
<li><a href='#centrality'><p>Calculate node and edge centrality</p></a></li>
<li><a href='#component_games'><p>Graph games based on connected components</p></a></li>
<li><a href='#context_accessors'><p>Access graph, nodes, and edges directly inside verbs</p></a></li>
<li><a href='#create_graphs'><p>Create different types of well-defined graphs</p></a></li>
<li><a href='#edge_rank'><p>Calculate edge ranking</p></a></li>
<li><a href='#edge_types'><p>Querying edge types</p></a></li>
<li><a href='#evolution_games'><p>Graph games based on evolution</p></a></li>
<li><a href='#focus'><p>Select specific nodes or edges to compute on</p></a></li>
<li><a href='#fortify.tbl_graph'><p>Fortify a tbl_graph for ggplot2 plotting</p></a></li>
<li><a href='#graph_join'><p>Join graphs on common nodes</p></a></li>
<li><a href='#graph_measures'><p>Graph measurements</p></a></li>
<li><a href='#graph_types'><p>Querying graph types</p></a></li>
<li><a href='#graph-context'><p>Register a graph context for the duration of the current frame</p></a></li>
<li><a href='#group_graph'><p>Group nodes and edges based on community structure</p></a></li>
<li><a href='#iterate'><p>Repeatedly modify a graph by a function</p></a></li>
<li><a href='#local_graph'><p>Measures based on the neighborhood of each node</p></a></li>
<li><a href='#map_bfs'><p>Apply a function to nodes in the order of a breath first search</p></a></li>
<li><a href='#map_bfs_back'><p>Apply a function to nodes in the reverse order of a breath first search</p></a></li>
<li><a href='#map_dfs'><p>Apply a function to nodes in the order of a depth first search</p></a></li>
<li><a href='#map_dfs_back'><p>Apply a function to nodes in the reverse order of a depth first search</p></a></li>
<li><a href='#map_local'><p>Map a function over a graph representing the neighborhood of each node</p></a></li>
<li><a href='#morph'><p>Create a temporary alternative representation of the graph to compute on</p></a></li>
<li><a href='#morphers'><p>Functions to generate alternate representations of graphs</p></a></li>
<li><a href='#mutate_as_tbl'><p>Base implementation of mutate</p></a></li>
<li><a href='#node_measures'><p>Querying node measures</p></a></li>
<li><a href='#node_rank'><p>Calculate node ranking</p></a></li>
<li><a href='#node_topology'><p>Node properties related to the graph topology</p></a></li>
<li><a href='#node_types'><p>Querying node types</p></a></li>
<li><a href='#pair_measures'><p>Calculate node pair properties</p></a></li>
<li><a href='#random_walk_rank'><p>Perform a random walk on the graph and return encounter rank</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#reroute'><p>Change terminal nodes of edges</p></a></li>
<li><a href='#sampling_games'><p>Graph games based on direct sampling</p></a></li>
<li><a href='#search_graph'><p>Search a graph with depth first and breath first</p></a></li>
<li><a href='#type_games'><p>Graph games based on different node types</p></a></li>
<li><a href='#with_graph'><p>Evaluate a tidygraph algorithm in the context of a graph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Tidy API for Graph Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomasp85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A graph, while not "tidy" in itself, can be thought of as two
    tidy data frames describing node and edge data respectively.
    'tidygraph' provides an approach to manipulate these two virtual data
    frames using the API defined in the 'dplyr' package, as well as
    provides tidy interfaces to a lot of common graph algorithms.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://tidygraph.data-imaginist.com">https://tidygraph.data-imaginist.com</a>,
<a href="https://github.com/thomasp85/tidygraph">https://github.com/thomasp85/tidygraph</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/thomasp85/tidygraph/issues">https://github.com/thomasp85/tidygraph/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, dplyr (&ge; 0.8.5), igraph (&ge; 2.0.0), lifecycle, magrittr,
pillar, R6, rlang, stats, tibble, tidyr, tools, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, covr, data.tree, graph, influenceR, methods, netrankr,
NetSwan, network, seriation, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 12:17:51 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tidygraph-package'>tidygraph: A Tidy API for Graph Manipulation</h2><span id='topic+tidygraph'></span><span id='topic+tidygraph-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A graph, while not &quot;tidy&quot; in itself, can be thought of as two tidy data frames describing node and edge data respectively. 'tidygraph' provides an approach to manipulate these two virtual data frames using the API defined in the 'dplyr' package, as well as provides tidy interfaces to a lot of common graph algorithms.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomasp85@gmail.com">thomasp85@gmail.com</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://tidygraph.data-imaginist.com">https://tidygraph.data-imaginist.com</a>
</p>
</li>
<li> <p><a href="https://github.com/thomasp85/tidygraph">https://github.com/thomasp85/tidygraph</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/thomasp85/tidygraph/issues">https://github.com/thomasp85/tidygraph/issues</a>
</p>
</li></ul>


<hr>
<h2 id='activate'>Determine the context of subsequent manipulations</h2><span id='topic+activate'></span><span id='topic+active'></span><span id='topic++25N+3E+25'></span><span id='topic++25E+3E+25'></span>

<h3>Description</h3>

<p>As a <a href="#topic+tbl_graph">tbl_graph</a> can be considered as a collection of two linked tables it is
necessary to specify which table is referenced during manipulations. The
<code>activate</code> verb does just that and needs affects all subsequent manipulations
until a new table is activated. <code>active</code> is a simple query function to get
the currently acitve context. In addition to the use of <code>activate</code> it is also
possible to activate nodes or edges as part of the piping using the <code style="white-space: pre;">&#8288;%N&gt;%&#8288;</code>
and <code style="white-space: pre;">&#8288;%E&gt;%&#8288;</code> pipes respectively. Do note that this approach somewhat obscures
what is going on and is thus only recommended for quick, one-line, fixes in
interactive use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>activate(.data, what)

active(x)

lhs %N&gt;% rhs

lhs %E&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="activate_+3A_.data">.data</code>, <code id="activate_+3A_x">x</code>, <code id="activate_+3A_lhs">lhs</code></td>
<td>
<p>A tbl_graph or a grouped_tbl_graph</p>
</td></tr>
<tr><td><code id="activate_+3A_what">what</code></td>
<td>
<p>What should get activated? Possible values are <code>nodes</code> or
<code>edges</code>.</p>
</td></tr>
<tr><td><code id="activate_+3A_rhs">rhs</code></td>
<td>
<p>A function to pipe into</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph
</p>


<h3>Note</h3>

<p>Activate will ungroup a grouped_tbl_graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gr &lt;- create_complete(5) %&gt;%
  activate(nodes) %&gt;%
  mutate(class = sample(c('a', 'b'), 5, TRUE)) %&gt;%
  activate(edges) %&gt;%
  arrange(from)

# The above could be achieved using the special pipes as well
gr &lt;- create_complete(5) %N&gt;%
  mutate(class = sample(c('a', 'b'), 5, TRUE)) %E&gt;%
  arrange(from)
# But as you can see it obscures what part of the graph is being targeted

</code></pre>

<hr>
<h2 id='as_tbl_graph.data.frame'>A data structure for tidy graph manipulation</h2><span id='topic+as_tbl_graph.data.frame'></span><span id='topic+as_tbl_graph.Node'></span><span id='topic+as_tbl_graph.dendrogram'></span><span id='topic+as_tbl_graph.graphNEL'></span><span id='topic+as_tbl_graph.graphAM'></span><span id='topic+as_tbl_graph.graphBAM'></span><span id='topic+as_tbl_graph.hclust'></span><span id='topic+as_tbl_graph.igraph'></span><span id='topic+as_tbl_graph.list'></span><span id='topic+as_tbl_graph.matrix'></span><span id='topic+as_tbl_graph.network'></span><span id='topic+as_tbl_graph.phylo'></span><span id='topic+as_tbl_graph.evonet'></span><span id='topic+tbl_graph'></span><span id='topic+as_tbl_graph'></span><span id='topic+as_tbl_graph.default'></span><span id='topic+is.tbl_graph'></span>

<h3>Description</h3>

<p>The <code>tbl_graph</code> class is a thin wrapper around an <code>igraph</code> object that
provides methods for manipulating the graph using the tidy API. As it is just
a subclass of <code>igraph</code> every igraph method will work as expected. A
<code>grouped_tbl_graph</code> is the equivalent of a <code>grouped_df</code> where either the
nodes or the edges has been grouped. The <code>grouped_tbl_graph</code> is not
constructed directly but by using the <code><a href="#topic+group_by">group_by()</a></code> verb. After creation of a
<code>tbl_graph</code> the nodes are activated by default. The context can be changed
using the <code><a href="#topic+activate">activate()</a></code> verb and affects all subsequent operations. Changing
context automatically drops any grouping. The current active context can
always be extracted with <code><a href="#topic+as_tibble">as_tibble()</a></code>, which drops the graph structure and
just returns a <code>tbl_df</code> or a <code>grouped_df</code> depending on the state of the
<code>tbl_graph</code>. The returned context can be overriden by using the <code>active</code>
argument in <code><a href="#topic+as_tibble">as_tibble()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
as_tbl_graph(x, directed = TRUE, ...)

## S3 method for class 'Node'
as_tbl_graph(x, directed = TRUE, mode = "out", ...)

## S3 method for class 'dendrogram'
as_tbl_graph(x, directed = TRUE, mode = "out", ...)

## S3 method for class 'graphNEL'
as_tbl_graph(x, ...)

## S3 method for class 'graphAM'
as_tbl_graph(x, ...)

## S3 method for class 'graphBAM'
as_tbl_graph(x, ...)

## S3 method for class 'hclust'
as_tbl_graph(x, directed = TRUE, mode = "out", ...)

## S3 method for class 'igraph'
as_tbl_graph(x, ...)

## S3 method for class 'list'
as_tbl_graph(x, directed = TRUE, node_key = "name", ...)

## S3 method for class 'matrix'
as_tbl_graph(x, directed = TRUE, ...)

## S3 method for class 'network'
as_tbl_graph(x, ...)

## S3 method for class 'phylo'
as_tbl_graph(x, directed = NULL, ...)

## S3 method for class 'evonet'
as_tbl_graph(x, directed = TRUE, ...)

tbl_graph(nodes = NULL, edges = NULL, directed = TRUE, node_key = "name")

as_tbl_graph(x, ...)

## Default S3 method:
as_tbl_graph(x, ...)

is.tbl_graph(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_tbl_graph.data.frame_+3A_x">x</code></td>
<td>
<p>An object convertible to a <code>tbl_graph</code></p>
</td></tr>
<tr><td><code id="as_tbl_graph.data.frame_+3A_directed">directed</code></td>
<td>
<p>Should the constructed graph be directed (defaults to <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="as_tbl_graph.data.frame_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the conversion function</p>
</td></tr>
<tr><td><code id="as_tbl_graph.data.frame_+3A_mode">mode</code></td>
<td>
<p>In case <code>directed = TRUE</code> should the edge direction be away from
node or towards. Possible values are <code>"out"</code> (default) or <code>"in"</code>.</p>
</td></tr>
<tr><td><code id="as_tbl_graph.data.frame_+3A_node_key">node_key</code></td>
<td>
<p>The name of the column in <code>nodes</code> that character represented
<code>to</code> and <code>from</code> columns should be matched against. If <code>NA</code> the first column
is always chosen. This setting has no effect if <code>to</code> and <code>from</code> are given as
integers.</p>
</td></tr>
<tr><td><code id="as_tbl_graph.data.frame_+3A_nodes">nodes</code></td>
<td>
<p>A <code>data.frame</code> containing information about the nodes in the
graph. If <code>edges$to</code> and/or <code>edges$from</code> are characters then they will be
matched to the column named according to <code>node_key</code> in nodes, if it exists.
If not, they will be matched to the first column.</p>
</td></tr>
<tr><td><code id="as_tbl_graph.data.frame_+3A_edges">edges</code></td>
<td>
<p>A <code>data.frame</code> containing information about the edges in the
graph. The terminal nodes of each edge must either be encoded in a <code>to</code> and
<code>from</code> column, or in the two first columns, as integers. These integers refer to
<code>nodes</code> index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructors are provided for most data structures that resembles networks.
If a class provides an <code><a href="igraph.html#topic+as.igraph">igraph::as.igraph()</a></code> method it is automatically
supported.
</p>


<h3>Value</h3>

<p>A <code>tbl_graph</code> object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>as_tbl_graph(data.frame)</code>: Method for edge table and set membership table
</p>
</li>
<li> <p><code>as_tbl_graph(Node)</code>: Method to deal with Node objects from the data.tree package
</p>
</li>
<li> <p><code>as_tbl_graph(dendrogram)</code>: Method for dendrogram objects
</p>
</li>
<li> <p><code>as_tbl_graph(graphNEL)</code>: Method for handling graphNEL objects from the graph package (on Bioconductor)
</p>
</li>
<li> <p><code>as_tbl_graph(graphAM)</code>: Method for handling graphAM objects from the graph package (on Bioconductor)
</p>
</li>
<li> <p><code>as_tbl_graph(graphBAM)</code>: Method for handling graphBAM objects from the graph package (on Bioconductor)
</p>
</li>
<li> <p><code>as_tbl_graph(hclust)</code>: Method for hclust objects
</p>
</li>
<li> <p><code>as_tbl_graph(igraph)</code>: Method for igraph object. Simply subclasses the object into a <code>tbl_graph</code>
</p>
</li>
<li> <p><code>as_tbl_graph(list)</code>: Method for adjacency lists and lists of node and edge tables
</p>
</li>
<li> <p><code>as_tbl_graph(matrix)</code>: Method for edgelist, adjacency and incidence matrices
</p>
</li>
<li> <p><code>as_tbl_graph(network)</code>: Method to handle network objects from the <code>network</code>
package. Requires this packages to work.
</p>
</li>
<li> <p><code>as_tbl_graph(phylo)</code>: Method for handling phylo objects from the ape package
</p>
</li>
<li> <p><code>as_tbl_graph(evonet)</code>: Method for handling evonet objects from the ape package
</p>
</li>
<li> <p><code>as_tbl_graph(default)</code>: Default method. tries to call <code><a href="igraph.html#topic+as.igraph">igraph::as.igraph()</a></code> on the input.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>rstat_nodes &lt;- data.frame(name = c("Hadley", "David", "Romain", "Julia"))
rstat_edges &lt;- data.frame(from = c(1, 1, 1, 2, 3, 3, 4, 4, 4),
                            to = c(2, 3, 4, 1, 1, 2, 1, 2, 3))
tbl_graph(nodes = rstat_nodes, edges = rstat_edges)
</code></pre>

<hr>
<h2 id='bind_graphs'>Add graphs, nodes, or edges to a tbl_graph</h2><span id='topic+bind_graphs'></span><span id='topic+bind_nodes'></span><span id='topic+bind_edges'></span>

<h3>Description</h3>

<p>These functions are tbl_graph pendants to <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code> that allows
you to grow your <code>tbl_graph</code> by adding rows to either the nodes data, the
edges data, or both. As with <code>bind_rows()</code> columns are matched by name and
are automatically filled with <code>NA</code> if the column doesn't exist in some
instances. In the case of <code>bind_graphs()</code> the graphs are automatically
converted to <code>tbl_graph</code> objects prior to binding. The edges in each graph
will continue to reference the nodes in the graph where they originated,
meaning that their terminal node indexes will be shifted to match the new
index of the node in the combined graph. This means the <code>bind_graphs()</code>
always result in a disconnected graph. See <code><a href="#topic+graph_join">graph_join()</a></code> for merging graphs
on common nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_graphs(.data, ...)

bind_nodes(.data, ...)

bind_edges(.data, ..., node_key = "name")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bind_graphs_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl_graph</code>, or a list of <code>tbl_graph</code> objects (for
<code>bind_graphs()</code>).</p>
</td></tr>
<tr><td><code id="bind_graphs_+3A_...">...</code></td>
<td>
<p>In case of <code>bind_nodes()</code> and <code>bind_edges()</code> data.frames to add.
In the case of <code>bind_graphs()</code> objects that are convertible to <code>tbl_graph</code>
using <code>as_tbl_graph()</code>.</p>
</td></tr>
<tr><td><code id="bind_graphs_+3A_node_key">node_key</code></td>
<td>
<p>The name of the column in <code>nodes</code> that character represented
<code>to</code> and <code>from</code> columns should be matched against. If <code>NA</code> the first column
is always chosen. This setting has no effect if <code>to</code> and <code>from</code> are given as
integers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_graph</code> containing the new data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- create_notable('bull')
new_graph &lt;- create_notable('housex')

# Add nodes
graph %&gt;% bind_nodes(data.frame(new = 1:4))

# Add edges
graph %&gt;% bind_edges(data.frame(from = 1, to = 4:5))

# Add graphs
graph %&gt;% bind_graphs(new_graph)

</code></pre>

<hr>
<h2 id='centrality'>Calculate node and edge centrality</h2><span id='topic+centrality'></span><span id='topic+centrality_alpha'></span><span id='topic+centrality_authority'></span><span id='topic+centrality_betweenness'></span><span id='topic+centrality_power'></span><span id='topic+centrality_closeness'></span><span id='topic+centrality_eigen'></span><span id='topic+centrality_hub'></span><span id='topic+centrality_pagerank'></span><span id='topic+centrality_subgraph'></span><span id='topic+centrality_degree'></span><span id='topic+centrality_edge_betweenness'></span><span id='topic+centrality_harmonic'></span><span id='topic+centrality_manual'></span><span id='topic+centrality_closeness_harmonic'></span><span id='topic+centrality_closeness_residual'></span><span id='topic+centrality_closeness_generalised'></span><span id='topic+centrality_integration'></span><span id='topic+centrality_communicability'></span><span id='topic+centrality_communicability_odd'></span><span id='topic+centrality_communicability_even'></span><span id='topic+centrality_subgraph_odd'></span><span id='topic+centrality_subgraph_even'></span><span id='topic+centrality_katz'></span><span id='topic+centrality_betweenness_network'></span><span id='topic+centrality_betweenness_current'></span><span id='topic+centrality_betweenness_communicability'></span><span id='topic+centrality_betweenness_rsp_simple'></span><span id='topic+centrality_betweenness_rsp_net'></span><span id='topic+centrality_information'></span><span id='topic+centrality_decay'></span><span id='topic+centrality_random_walk'></span><span id='topic+centrality_expected'></span>

<h3>Description</h3>

<p>The centrality of a node measures the importance of node in the network. As
the concept of importance is ill-defined and dependent on the network and
the questions under consideration, many centrality measures exist.
<code>tidygraph</code> provides a consistent set of wrappers for all the centrality
measures implemented in <code>igraph</code> for use inside <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> and other
relevant verbs. All functions provided by <code>tidygraph</code> have a consistent
naming scheme and automatically calls the function on the graph, returning a
vector with measures ready to be added to the node data. Further <code>tidygraph</code>
provides access to the <code>netrankr</code> engine for centrality calculations and
define a number of centrality measures based on that, as well as provide a
manual mode for specifying more-or-less any centrality score. These measures
all only work on undirected graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centrality_alpha(
  weights = NULL,
  alpha = 1,
  exo = 1,
  tol = 1e-07,
  loops = FALSE
)

centrality_authority(weights = NULL, scale = TRUE, options = arpack_defaults())

centrality_betweenness(
  weights = NULL,
  directed = TRUE,
  cutoff = -1,
  normalized = FALSE
)

centrality_power(exponent = 1, rescale = FALSE, tol = 1e-07, loops = FALSE)

centrality_closeness(
  weights = NULL,
  mode = "out",
  normalized = FALSE,
  cutoff = NULL
)

centrality_eigen(
  weights = NULL,
  directed = FALSE,
  scale = TRUE,
  options = arpack_defaults()
)

centrality_hub(weights = NULL, scale = TRUE, options = arpack_defaults())

centrality_pagerank(
  weights = NULL,
  directed = TRUE,
  damping = 0.85,
  personalized = NULL
)

centrality_subgraph(loops = FALSE)

centrality_degree(
  weights = NULL,
  mode = "out",
  loops = TRUE,
  normalized = FALSE
)

centrality_edge_betweenness(weights = NULL, directed = TRUE, cutoff = NULL)

centrality_harmonic(
  weights = NULL,
  mode = "out",
  normalized = FALSE,
  cutoff = NULL
)

centrality_manual(relation = "dist_sp", aggregation = "sum", ...)

centrality_closeness_harmonic()

centrality_closeness_residual()

centrality_closeness_generalised(alpha)

centrality_integration()

centrality_communicability()

centrality_communicability_odd()

centrality_communicability_even()

centrality_subgraph_odd()

centrality_subgraph_even()

centrality_katz(alpha = NULL)

centrality_betweenness_network(netflowmode = "raw")

centrality_betweenness_current()

centrality_betweenness_communicability()

centrality_betweenness_rsp_simple(rspxparam = 1)

centrality_betweenness_rsp_net(rspxparam = 1)

centrality_information()

centrality_decay(alpha = 1)

centrality_random_walk()

centrality_expected()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="centrality_+3A_weights">weights</code></td>
<td>
<p>The weight of the edges to use for the calculation. Will be
evaluated in the context of the edge data.</p>
</td></tr>
<tr><td><code id="centrality_+3A_alpha">alpha</code></td>
<td>
<p>Relative importance of endogenous vs exogenous factors (<code>centrality_alpha</code>), the exponent to the power transformation of the distance metric (<code>centrality_closeness_generalised</code>), the base of power transformation (<code>centrality_decay</code>), or the attenuation factor (<code>centrality_katz</code>)</p>
</td></tr>
<tr><td><code id="centrality_+3A_exo">exo</code></td>
<td>
<p>The exogenous factors of the nodes. Either a scalar or a number
number for each node. Evaluated in the context of the node data.</p>
</td></tr>
<tr><td><code id="centrality_+3A_tol">tol</code></td>
<td>
<p>Tolerance for near-singularities during matrix inversion</p>
</td></tr>
<tr><td><code id="centrality_+3A_loops">loops</code></td>
<td>
<p>Should loops be included in the calculation</p>
</td></tr>
<tr><td><code id="centrality_+3A_scale">scale</code></td>
<td>
<p>Should the output be scaled between 0 and 1</p>
</td></tr>
<tr><td><code id="centrality_+3A_options">options</code></td>
<td>
<p>Settings passed on to <code>igraph::arpack()</code></p>
</td></tr>
<tr><td><code id="centrality_+3A_directed">directed</code></td>
<td>
<p>Should direction of edges be used for the calculations</p>
</td></tr>
<tr><td><code id="centrality_+3A_cutoff">cutoff</code></td>
<td>
<p>maximum path length to use during calculations</p>
</td></tr>
<tr><td><code id="centrality_+3A_normalized">normalized</code></td>
<td>
<p>Should the output be normalized</p>
</td></tr>
<tr><td><code id="centrality_+3A_exponent">exponent</code></td>
<td>
<p>The decay rate for the Bonacich power centrality</p>
</td></tr>
<tr><td><code id="centrality_+3A_rescale">rescale</code></td>
<td>
<p>Should the output be scaled to sum up to 1</p>
</td></tr>
<tr><td><code id="centrality_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed. Ignored for undirected graphs</p>
</td></tr>
<tr><td><code id="centrality_+3A_damping">damping</code></td>
<td>
<p>The damping factor of the page rank algorithm</p>
</td></tr>
<tr><td><code id="centrality_+3A_personalized">personalized</code></td>
<td>
<p>The probability of jumping to a node when abandoning a
random walk. Evaluated in the context of the node data.</p>
</td></tr>
<tr><td><code id="centrality_+3A_relation">relation</code></td>
<td>
<p>The indirect relation measure type to be used in <code>netrankr::indirect_relations</code></p>
</td></tr>
<tr><td><code id="centrality_+3A_aggregation">aggregation</code></td>
<td>
<p>The aggregation type to use on the indirect relations to be used in <code>netrankr::aggregate_positions</code></p>
</td></tr>
<tr><td><code id="centrality_+3A_...">...</code></td>
<td>
<p>Arguments to pass on to <code>netrankr::indirect_relations</code></p>
</td></tr>
<tr><td><code id="centrality_+3A_netflowmode">netflowmode</code></td>
<td>
<p>The return type of the network flow distance, either <code>'raw'</code> or <code>'frac'</code></p>
</td></tr>
<tr><td><code id="centrality_+3A_rspxparam">rspxparam</code></td>
<td>
<p>inverse temperature parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the centrality measure of each node.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>centrality_alpha()</code>: Wrapper for <code><a href="igraph.html#topic+alpha_centrality">igraph::alpha_centrality()</a></code>
</p>
</li>
<li> <p><code>centrality_authority()</code>: Wrapper for <code><a href="igraph.html#topic+hub_score">igraph::authority_score()</a></code>
</p>
</li>
<li> <p><code>centrality_betweenness()</code>: Wrapper for <code><a href="igraph.html#topic+betweenness">igraph::betweenness()</a></code>
</p>
</li>
<li> <p><code>centrality_power()</code>: Wrapper for <code><a href="igraph.html#topic+power_centrality">igraph::power_centrality()</a></code>
</p>
</li>
<li> <p><code>centrality_closeness()</code>: Wrapper for <code><a href="igraph.html#topic+closeness">igraph::closeness()</a></code>
</p>
</li>
<li> <p><code>centrality_eigen()</code>: Wrapper for <code><a href="igraph.html#topic+eigen_centrality">igraph::eigen_centrality()</a></code>
</p>
</li>
<li> <p><code>centrality_hub()</code>: Wrapper for <code><a href="igraph.html#topic+hub_score">igraph::hub_score()</a></code>
</p>
</li>
<li> <p><code>centrality_pagerank()</code>: Wrapper for <code><a href="igraph.html#topic+page_rank">igraph::page_rank()</a></code>
</p>
</li>
<li> <p><code>centrality_subgraph()</code>: Wrapper for <code><a href="igraph.html#topic+subgraph_centrality">igraph::subgraph_centrality()</a></code>
</p>
</li>
<li> <p><code>centrality_degree()</code>: Wrapper for <code><a href="igraph.html#topic+degree">igraph::degree()</a></code> and <code><a href="igraph.html#topic+strength">igraph::strength()</a></code>
</p>
</li>
<li> <p><code>centrality_edge_betweenness()</code>: Wrapper for <code><a href="igraph.html#topic+betweenness">igraph::edge_betweenness()</a></code>
</p>
</li>
<li> <p><code>centrality_harmonic()</code>: Wrapper for <code><a href="igraph.html#topic+harmonic_centrality">igraph::harmonic_centrality()</a></code>
</p>
</li>
<li> <p><code>centrality_manual()</code>: Manually specify your centrality score using the <code>netrankr</code> framework (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_closeness_harmonic()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> centrality based on inverse shortest path (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_closeness_residual()</code>: centrality based on 2-to-the-power-of negative shortest path (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_closeness_generalised()</code>: centrality based on alpha-to-the-power-of negative shortest path (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_integration()</code>: centrality based on <code class="reqn">1 - (x - 1)/max(x)</code> transformation of shortest path (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_communicability()</code>: centrality an exponential tranformation of walk counts (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_communicability_odd()</code>: centrality an exponential tranformation of odd walk counts (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_communicability_even()</code>: centrality an exponential tranformation of even walk counts (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_subgraph_odd()</code>: subgraph centrality based on odd walk counts (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_subgraph_even()</code>: subgraph centrality based on even walk counts (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_katz()</code>: centrality based on walks penalizing distant nodes (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_betweenness_network()</code>: Betweenness centrality based on network flow (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_betweenness_current()</code>: Betweenness centrality based on current flow (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_betweenness_communicability()</code>: Betweenness centrality based on communicability (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_betweenness_rsp_simple()</code>: Betweenness centrality based on simple randomised shortest path dependencies (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_betweenness_rsp_net()</code>: Betweenness centrality based on net randomised shortest path dependencies (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_information()</code>: centrality based on inverse sum of resistance distance between nodes (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_decay()</code>: based on a power transformation of the shortest path (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_random_walk()</code>: centrality based on the inverse sum of expected random walk length between nodes (<code>netrankr</code>)
</p>
</li>
<li> <p><code>centrality_expected()</code>: Expected centrality ranking based on exact rank probability (<code>netrankr</code>)
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>create_notable('bull') %&gt;%
  activate(nodes) %&gt;%
  mutate(importance = centrality_alpha())

# Most centrality measures are for nodes but not all
create_notable('bull') %&gt;%
  activate(edges) %&gt;%
  mutate(importance = centrality_edge_betweenness())
</code></pre>

<hr>
<h2 id='component_games'>Graph games based on connected components</h2><span id='topic+component_games'></span><span id='topic+play_blocks'></span><span id='topic+play_blocks_hierarchy'></span><span id='topic+play_islands'></span><span id='topic+play_smallworld'></span>

<h3>Description</h3>

<p>This set of graph creation algorithms simulate the topology by, in some way,
connecting subgraphs. The nature of their algorithm is described in detail at
the linked igraph documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play_blocks(n, size_blocks, p_between, directed = TRUE, loops = FALSE)

play_blocks_hierarchy(n, size_blocks, rho, p_within, p_between)

play_islands(n_islands, size_islands, p_within, m_between)

play_smallworld(
  n_dim,
  dim_size,
  order,
  p_rewire,
  loops = FALSE,
  multiple = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="component_games_+3A_n">n</code></td>
<td>
<p>The number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="component_games_+3A_size_blocks">size_blocks</code></td>
<td>
<p>The number of vertices in each block</p>
</td></tr>
<tr><td><code id="component_games_+3A_p_between">p_between</code>, <code id="component_games_+3A_p_within">p_within</code></td>
<td>
<p>The probability of edges within and between groups/blocks</p>
</td></tr>
<tr><td><code id="component_games_+3A_directed">directed</code></td>
<td>
<p>Should the resulting graph be directed</p>
</td></tr>
<tr><td><code id="component_games_+3A_loops">loops</code></td>
<td>
<p>Are loop edges allowed</p>
</td></tr>
<tr><td><code id="component_games_+3A_rho">rho</code></td>
<td>
<p>The fraction of vertices per cluster</p>
</td></tr>
<tr><td><code id="component_games_+3A_n_islands">n_islands</code></td>
<td>
<p>The number of densely connected islands</p>
</td></tr>
<tr><td><code id="component_games_+3A_size_islands">size_islands</code></td>
<td>
<p>The number of nodes in each island</p>
</td></tr>
<tr><td><code id="component_games_+3A_m_between">m_between</code></td>
<td>
<p>The number of edges between groups/islands</p>
</td></tr>
<tr><td><code id="component_games_+3A_n_dim">n_dim</code>, <code id="component_games_+3A_dim_size">dim_size</code></td>
<td>
<p>The dimension and size of the starting lattice</p>
</td></tr>
<tr><td><code id="component_games_+3A_order">order</code></td>
<td>
<p>The neighborhood size to create connections from</p>
</td></tr>
<tr><td><code id="component_games_+3A_p_rewire">p_rewire</code></td>
<td>
<p>The rewiring probability of edges</p>
</td></tr>
<tr><td><code id="component_games_+3A_multiple">multiple</code></td>
<td>
<p>Are multiple edges allowed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>play_blocks()</code>: Create graphs by sampling from stochastic block
model. See <code><a href="igraph.html#topic+sample_sbm">igraph::sample_sbm()</a></code>
</p>
</li>
<li> <p><code>play_blocks_hierarchy()</code>: Create graphs by sampling from the hierarchical
stochastic block model. See <code><a href="igraph.html#topic+sample_hierarchical_sbm">igraph::sample_hierarchical_sbm()</a></code>
</p>
</li>
<li> <p><code>play_islands()</code>: Create graphs with fixed size and edge
probability of subgraphs as well as fixed edge count between subgraphs. See
<code><a href="igraph.html#topic+sample_islands">igraph::sample_islands()</a></code>
</p>
</li>
<li> <p><code>play_smallworld()</code>: Create graphs based on the Watts-Strogatz small-
world model. See <code><a href="igraph.html#topic+sample_smallworld">igraph::sample_smallworld()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p>Other graph games: 
<code><a href="#topic+evolution_games">evolution_games</a></code>,
<code><a href="#topic+sampling_games">sampling_games</a></code>,
<code><a href="#topic+type_games">type_games</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(play_islands(4, 10, 0.7, 3))

</code></pre>

<hr>
<h2 id='context_accessors'>Access graph, nodes, and edges directly inside verbs</h2><span id='topic+context_accessors'></span><span id='topic+.G'></span><span id='topic+.N'></span><span id='topic+.E'></span>

<h3>Description</h3>

<p>These three functions makes it possible to directly access either the node
data, the edge data or the graph itself while computing inside verbs. It is
e.g. possible to add an attribute from the node data to the edges based on
the terminating nodes of the edge, or extract some statistics from the graph
itself to use in computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.G()

.N(focused = TRUE)

.E(focused = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="context_accessors_+3A_focused">focused</code></td>
<td>
<p>Should only the attributes of the currently focused nodes or
edges be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code>tbl_graph</code> (<code>.G()</code>) or a <code>tibble</code> (<code>.N()</code>)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.G()</code>: Get the tbl_graph you're currently working on
</p>
</li>
<li> <p><code>.N()</code>: Get the nodes data from the graph you're currently working on
</p>
</li>
<li> <p><code>.E()</code>: Get the edges data from the graph you're currently working on
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Get data from the nodes while computing for the edges
create_notable('bull') %&gt;%
  activate(nodes) %&gt;%
  mutate(centrality = centrality_power()) %&gt;%
  activate(edges) %&gt;%
  mutate(mean_centrality = (.N()$centrality[from] + .N()$centrality[to])/2)
</code></pre>

<hr>
<h2 id='create_graphs'>Create different types of well-defined graphs</h2><span id='topic+create_graphs'></span><span id='topic+create_ring'></span><span id='topic+create_path'></span><span id='topic+create_chordal_ring'></span><span id='topic+create_de_bruijn'></span><span id='topic+create_empty'></span><span id='topic+create_bipartite'></span><span id='topic+create_citation'></span><span id='topic+create_complete'></span><span id='topic+create_notable'></span><span id='topic+create_kautz'></span><span id='topic+create_lattice'></span><span id='topic+create_star'></span><span id='topic+create_tree'></span>

<h3>Description</h3>

<p>These functions creates a long list of different types of well-defined graphs,
that is, their structure is not based on any randomisation. All of these
functions are shallow wrappers around a range of <code style="white-space: pre;">&#8288;igraph::make_*&#8288;</code> functions
but returns <code>tbl_graph</code> rather than <code>igraph</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ring(n, directed = FALSE, mutual = FALSE)

create_path(n, directed = FALSE, mutual = FALSE)

create_chordal_ring(n, w)

create_de_bruijn(alphabet_size, label_size)

create_empty(n, directed = FALSE)

create_bipartite(n1, n2, directed = FALSE, mode = "out")

create_citation(n)

create_complete(n)

create_notable(name)

create_kautz(alphabet_size, label_size)

create_lattice(dim, directed = FALSE, mutual = FALSE, circular = FALSE)

create_star(n, directed = FALSE, mutual = FALSE, mode = "out")

create_tree(n, children, directed = TRUE, mode = "out")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_graphs_+3A_n">n</code>, <code id="create_graphs_+3A_n1">n1</code>, <code id="create_graphs_+3A_n2">n2</code></td>
<td>
<p>The number of nodes in the graph</p>
</td></tr>
<tr><td><code id="create_graphs_+3A_directed">directed</code></td>
<td>
<p>Should the graph be directed</p>
</td></tr>
<tr><td><code id="create_graphs_+3A_mutual">mutual</code></td>
<td>
<p>Should mutual edges be created in case of the graph being
directed</p>
</td></tr>
<tr><td><code id="create_graphs_+3A_w">w</code></td>
<td>
<p>A matrix specifying the additional edges in the chordan ring. See
<code><a href="igraph.html#topic+make_chordal_ring">igraph::make_chordal_ring()</a></code></p>
</td></tr>
<tr><td><code id="create_graphs_+3A_alphabet_size">alphabet_size</code></td>
<td>
<p>The number of unique letters in the alphabet used for
the graph</p>
</td></tr>
<tr><td><code id="create_graphs_+3A_label_size">label_size</code></td>
<td>
<p>The number of characters in each node</p>
</td></tr>
<tr><td><code id="create_graphs_+3A_mode">mode</code></td>
<td>
<p>In case of a directed, non-mutual, graph should the edges flow
<code>'out'</code> or <code>'in'</code></p>
</td></tr>
<tr><td><code id="create_graphs_+3A_name">name</code></td>
<td>
<p>The name of a notable graph. See a complete list in <code><a href="igraph.html#topic+make_graph">igraph::make_graph()</a></code></p>
</td></tr>
<tr><td><code id="create_graphs_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the lattice</p>
</td></tr>
<tr><td><code id="create_graphs_+3A_circular">circular</code></td>
<td>
<p>Should each dimension in the lattice wrap around</p>
</td></tr>
<tr><td><code id="create_graphs_+3A_children">children</code></td>
<td>
<p>The number of children each node has in the tree (if possible)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>create_ring()</code>: Create a simple ring graph
</p>
</li>
<li> <p><code>create_path()</code>: Create a simple path
</p>
</li>
<li> <p><code>create_chordal_ring()</code>: Create a chordal ring
</p>
</li>
<li> <p><code>create_de_bruijn()</code>: Create a de Bruijn graph with the specified alphabet and label size
</p>
</li>
<li> <p><code>create_empty()</code>: Create a graph with no edges
</p>
</li>
<li> <p><code>create_bipartite()</code>: Create a full bipartite graph
</p>
</li>
<li> <p><code>create_citation()</code>: Create a full citation graph
</p>
</li>
<li> <p><code>create_complete()</code>: Create a complete graph (a graph where all nodes are connected)
</p>
</li>
<li> <p><code>create_notable()</code>: Create a graph based on its name. See <code><a href="igraph.html#topic+make_graph">igraph::make_graph()</a></code>
</p>
</li>
<li> <p><code>create_kautz()</code>: Create a Kautz graph with the specified alphabet and label size
</p>
</li>
<li> <p><code>create_lattice()</code>: Create a multidimensional grid of nodes
</p>
</li>
<li> <p><code>create_star()</code>: Create a star graph (A single node in the center connected to all other nodes)
</p>
</li>
<li> <p><code>create_tree()</code>: Create a tree graph
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Create a complete graph with 10 nodes
create_complete(10)

</code></pre>

<hr>
<h2 id='edge_rank'>Calculate edge ranking</h2><span id='topic+edge_rank'></span><span id='topic+edge_rank_eulerian'></span>

<h3>Description</h3>

<p>This set of functions tries to calculate a ranking of the edges in a graph so
that edges sharing certain topological traits are in proximity in the
resulting order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_rank_eulerian(cyclic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_rank_+3A_cyclic">cyclic</code></td>
<td>
<p>should the eulerian path start and end at the same node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the position of each edge in the ranking
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>edge_rank_eulerian()</code>: Calculcate ranking as the visit order of a eulerian
path or cycle. If no such path or cycle exist it will return a vector of
<code>NA</code>s
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- create_notable('meredith') %&gt;%
  activate(edges) %&gt;%
  mutate(rank = edge_rank_eulerian())

</code></pre>

<hr>
<h2 id='edge_types'>Querying edge types</h2><span id='topic+edge_types'></span><span id='topic+edge_is_multiple'></span><span id='topic+edge_is_loop'></span><span id='topic+edge_is_mutual'></span><span id='topic+edge_is_from'></span><span id='topic+edge_is_to'></span><span id='topic+edge_is_between'></span><span id='topic+edge_is_incident'></span><span id='topic+edge_is_bridge'></span><span id='topic+edge_is_feedback_arc'></span>

<h3>Description</h3>

<p>These functions lets the user query whether the edges in a graph is of a
specific type. All functions return a logical vector giving whether each edge
in the graph corresponds to the specific type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edge_is_multiple()

edge_is_loop()

edge_is_mutual()

edge_is_from(from)

edge_is_to(to)

edge_is_between(from, to, ignore_dir = !graph_is_directed())

edge_is_incident(nodes)

edge_is_bridge()

edge_is_feedback_arc(weights = NULL, approximate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="edge_types_+3A_from">from</code>, <code id="edge_types_+3A_to">to</code>, <code id="edge_types_+3A_nodes">nodes</code></td>
<td>
<p>A vector giving node indices</p>
</td></tr>
<tr><td><code id="edge_types_+3A_ignore_dir">ignore_dir</code></td>
<td>
<p>Is both directions of the edge allowed</p>
</td></tr>
<tr><td><code id="edge_types_+3A_weights">weights</code></td>
<td>
<p>The weight of the edges to use for the calculation. Will be
evaluated in the context of the edge data.</p>
</td></tr>
<tr><td><code id="edge_types_+3A_approximate">approximate</code></td>
<td>
<p>Should the minimal set be approximated or exact</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as the number of edges in the
graph
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>edge_is_multiple()</code>: Query whether each edge has any parallel siblings
</p>
</li>
<li> <p><code>edge_is_loop()</code>: Query whether each edge is a loop
</p>
</li>
<li> <p><code>edge_is_mutual()</code>: Query whether each edge has a sibling going in the reverse direction
</p>
</li>
<li> <p><code>edge_is_from()</code>: Query whether an edge goes from a set of nodes
</p>
</li>
<li> <p><code>edge_is_to()</code>: Query whether an edge goes to a set of nodes
</p>
</li>
<li> <p><code>edge_is_between()</code>: Query whether an edge goes between two sets of nodes
</p>
</li>
<li> <p><code>edge_is_incident()</code>: Query whether an edge goes from or to a set of nodes
</p>
</li>
<li> <p><code>edge_is_bridge()</code>: Query whether an edge is a bridge (ie. it's removal
will increase the number of components in a graph)
</p>
</li>
<li> <p><code>edge_is_feedback_arc()</code>: Query whether an edge is part of the minimal feedback
arc set (its removal together with the rest will break all cycles in the
graph)
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>create_star(10, directed = TRUE, mutual = TRUE) %&gt;%
  activate(edges) %&gt;%
  sample_frac(0.7) %&gt;%
  mutate(single_edge = !edge_is_mutual())
</code></pre>

<hr>
<h2 id='evolution_games'>Graph games based on evolution</h2><span id='topic+evolution_games'></span><span id='topic+play_citation_age'></span><span id='topic+play_forestfire'></span><span id='topic+play_growing'></span><span id='topic+play_barabasi_albert'></span><span id='topic+play_barabasi_albert_aging'></span>

<h3>Description</h3>

<p>This games create graphs through different types of evolutionary mechanisms
(not necessarily in a biological sense). The nature of their algorithm is
described in detail at the linked igraph documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play_citation_age(
  n,
  growth = 1,
  bins = n/7100,
  p_pref = (1:(bins + 1))^-3,
  directed = TRUE
)

play_forestfire(
  n,
  p_forward,
  p_backward = p_forward,
  growth = 1,
  directed = TRUE
)

play_growing(n, growth = 1, directed = TRUE, citation = FALSE)

play_barabasi_albert(
  n,
  power,
  growth = 1,
  growth_dist = NULL,
  use_out = FALSE,
  appeal_zero = 1,
  directed = TRUE,
  method = "psumtree"
)

play_barabasi_albert_aging(
  n,
  power,
  power_age,
  growth = 1,
  growth_dist = NULL,
  bins = 300,
  use_out = FALSE,
  appeal_zero = 1,
  appeal_zero_age = 0,
  directed = TRUE,
  coefficient = 1,
  coefficient_age = 1,
  window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evolution_games_+3A_n">n</code></td>
<td>
<p>The number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_growth">growth</code></td>
<td>
<p>The number of edges added at each iteration</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_bins">bins</code></td>
<td>
<p>The number of aging bins</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_p_pref">p_pref</code></td>
<td>
<p>The probability that an edge will be made to an age bin.</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_directed">directed</code></td>
<td>
<p>Should the resulting graph be directed</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_p_forward">p_forward</code>, <code id="evolution_games_+3A_p_backward">p_backward</code></td>
<td>
<p>Forward and backward burning probability</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_citation">citation</code></td>
<td>
<p>Should a citation graph be created</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_power">power</code></td>
<td>
<p>The power of the preferential attachment</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_growth_dist">growth_dist</code></td>
<td>
<p>The distribution of the number of added edges at each iteration</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_use_out">use_out</code></td>
<td>
<p>Should outbound edges be used for calculating citation probability</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_appeal_zero">appeal_zero</code></td>
<td>
<p>The appeal value for unconnected nodes</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_method">method</code></td>
<td>
<p>The algorithm to use for graph creation. Either <code>'psumtree'</code>,
<code>'psumtree-multiple'</code>, or <code>'bag'</code></p>
</td></tr>
<tr><td><code id="evolution_games_+3A_power_age">power_age</code></td>
<td>
<p>The aging exponent</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_appeal_zero_age">appeal_zero_age</code></td>
<td>
<p>The appeal value of nodes without age</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_coefficient">coefficient</code></td>
<td>
<p>The coefficient of the degree dependent part of attrictiveness</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_coefficient_age">coefficient_age</code></td>
<td>
<p>The coefficient of the age dependent part of attrictiveness</p>
</td></tr>
<tr><td><code id="evolution_games_+3A_window">window</code></td>
<td>
<p>The aging window to take into account when calculating the preferential attraction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>play_citation_age()</code>: Create citation graphs based on a specific age
link probability. See <code><a href="igraph.html#topic+sample_last_cit">igraph::sample_last_cit()</a></code>
</p>
</li>
<li> <p><code>play_forestfire()</code>: Create graphs by simulating the spead of fire in
a forest. See <code><a href="igraph.html#topic+sample_forestfire">igraph::sample_forestfire()</a></code>
</p>
</li>
<li> <p><code>play_growing()</code>: Create graphs by adding a fixed number of edges
at each iteration. See <code><a href="igraph.html#topic+sample_growing">igraph::sample_growing()</a></code>
</p>
</li>
<li> <p><code>play_barabasi_albert()</code>: Create graphs based on the Barabasi-Alberts
preferential attachment model. See <code><a href="igraph.html#topic+sample_pa">igraph::sample_pa()</a></code>
</p>
</li>
<li> <p><code>play_barabasi_albert_aging()</code>: Create graphs based on the Barabasi-Alberts
preferential attachment model, incoorporating node age preferrence. See
<code><a href="igraph.html#topic+sample_pa_age">igraph::sample_pa_age()</a></code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+play_traits">play_traits()</a></code> and <code><a href="#topic+play_citation_type">play_citation_type()</a></code> for an evolutionary
algorithm based on different node types
</p>
<p>Other graph games: 
<code><a href="#topic+component_games">component_games</a></code>,
<code><a href="#topic+sampling_games">sampling_games</a></code>,
<code><a href="#topic+type_games">type_games</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(play_forestfire(50, 0.5))

</code></pre>

<hr>
<h2 id='focus'>Select specific nodes or edges to compute on</h2><span id='topic+focus'></span><span id='topic+focus.tbl_graph'></span><span id='topic+focus.morphed_tbl_graph'></span><span id='topic+unfocus'></span><span id='topic+unfocus.tbl_graph'></span><span id='topic+unfocus.focused_tbl_graph'></span><span id='topic+unfocus.morphed_tbl_graph'></span>

<h3>Description</h3>

<p>The <code>focus()</code>/<code>unfocus()</code> idiom allow you to temporarily tell tidygraph
algorithms to only calculate on a subset of the data, while keeping the full
graph intact. The purpose of this is to avoid having to calculate time
costly measures etc on all nodes or edges of a graph if only a few is needed.
E.g. you might only be interested in the shortest distance from one node to
another so rather than calculating this for all nodes you apply a focus on
one node and perform the calculation. It should be made clear that not all
algorithms will see a performance boost by being applied to a few nodes/edges
since their calculation is applied globally and the result for all
nodes/edges are provided in unison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focus(.data, ...)

## S3 method for class 'tbl_graph'
focus(.data, ...)

## S3 method for class 'morphed_tbl_graph'
focus(.data, ...)

unfocus(.data, ...)

## S3 method for class 'tbl_graph'
unfocus(.data, ...)

## S3 method for class 'focused_tbl_graph'
unfocus(.data, ...)

## S3 method for class 'morphed_tbl_graph'
unfocus(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="focus_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g. a tibble), or a
lazy data frame (e.g. from dbplyr or dtplyr). See <em>Methods</em>, below, for
more details.</p>
</td></tr>
<tr><td><code id="focus_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt; Expressions that
return a logical value, and are defined in terms of the variables in
<code>.data</code>. If multiple expressions are included, they are combined with the
<code>&amp;</code> operator. Only rows for which all conditions evaluate to <code>TRUE</code> are
kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A graph with focus applied
</p>


<h3>Note</h3>

<p>focusing is the lowest prioritised operation on a graph. Applying a
<code><a href="#topic+morph">morph()</a></code> or a <code><a href="#topic+group_by">group_by()</a></code> operation will unfocus the graph prior to
performing the operation. The same is true for the inverse operations
(<code><a href="#topic+unmorph">unmorph()</a></code> and <code><a href="#topic+ungroup">ungroup()</a></code>). Further, unfocusing will happen any time some
graph altering operation is performed, such as the <code>arrange()</code> and <code>slice()</code>
operations
</p>

<hr>
<h2 id='fortify.tbl_graph'>Fortify a tbl_graph for ggplot2 plotting</h2><span id='topic+fortify.tbl_graph'></span>

<h3>Description</h3>

<p>In general <code>tbl_graph</code> objects are intended to be plotted by network
visualisation libraries such as <code>ggraph</code>. However, if you do wish to plot
either the node or edge data directly with <code>ggplot2</code> you can simply add the
<code>tbl_graph</code> object as either the global or layer data and the currently
active data is passed on as a regular data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fortify.tbl_graph(model, data, ...)
</code></pre>

<hr>
<h2 id='graph_join'>Join graphs on common nodes</h2><span id='topic+graph_join'></span>

<h3>Description</h3>

<p>This graph-specific join method makes a full join on the nodes data and
updates the edges in the joining graph so they matches the new indexes of the
nodes in the resulting graph. Node and edge data is combined using
<code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code> semantic, meaning that data is matched by column name
and filled with <code>NA</code> if it is missing in either of the graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_join(x, y, by = NULL, copy = FALSE, suffix = c(".x", ".y"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_join_+3A_x">x</code></td>
<td>
<p>A <code>tbl_graph</code></p>
</td></tr>
<tr><td><code id="graph_join_+3A_y">y</code></td>
<td>
<p>An object convertible to a <code>tbl_graph</code> using <code><a href="#topic+as_tbl_graph">as_tbl_graph()</a></code></p>
</td></tr>
<tr><td><code id="graph_join_+3A_by">by</code></td>
<td>
<p>A join specification created with <code><a href="dplyr.html#topic+join_by">join_by()</a></code>, or a character
vector of variables to join by.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;*_join()&#8288;</code> will perform a natural join, using all
variables in common across <code>x</code> and <code>y</code>. A message lists the variables so
that you can check they're correct; suppress the message by supplying <code>by</code>
explicitly.
</p>
<p>To join on different variables between <code>x</code> and <code>y</code>, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code>
specification. For example, <code>join_by(a == b)</code> will match <code>x$a</code> to <code>y$b</code>.
</p>
<p>To join by multiple variables, use a <code><a href="dplyr.html#topic+join_by">join_by()</a></code> specification with
multiple expressions. For example, <code>join_by(a == b, c == d)</code> will match
<code>x$a</code> to <code>y$b</code> and <code>x$c</code> to <code>y$d</code>. If the column names are the same between
<code>x</code> and <code>y</code>, you can shorten this by listing only the variable names, like
<code>join_by(a, c)</code>.
</p>
<p><code><a href="dplyr.html#topic+join_by">join_by()</a></code> can also be used to perform inequality, rolling, and overlap
joins. See the documentation at <a href="dplyr.html#topic+join_by">?join_by</a> for details on
these types of joins.
</p>
<p>For simple equality joins, you can alternatively specify a character vector
of variable names to join by. For example, <code>by = c("a", "b")</code> joins <code>x$a</code>
to <code>y$a</code> and <code>x$b</code> to <code>y$b</code>. If variable names differ between <code>x</code> and <code>y</code>,
use a named character vector like <code>by = c("x_a" = "y_a", "x_b" = "y_b")</code>.
</p>
<p>To perform a cross-join, generating all combinations of <code>x</code> and <code>y</code>, see
<code><a href="dplyr.html#topic+cross_join">cross_join()</a></code>.</p>
</td></tr>
<tr><td><code id="graph_join_+3A_copy">copy</code></td>
<td>
<p>If <code>x</code> and <code>y</code> are not from the same data source,
and <code>copy</code> is <code>TRUE</code>, then <code>y</code> will be copied into the
same src as <code>x</code>.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.</p>
</td></tr>
<tr><td><code id="graph_join_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>x</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="graph_join_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_graph</code> containing the merged graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gr1 &lt;- create_notable('bull') %&gt;%
  activate(nodes) %&gt;%
  mutate(name = letters[1:5])
gr2 &lt;- create_ring(10) %&gt;%
  activate(nodes) %&gt;%
  mutate(name = letters[4:13])

gr1 %&gt;% graph_join(gr2)
</code></pre>

<hr>
<h2 id='graph_measures'>Graph measurements</h2><span id='topic+graph_measures'></span><span id='topic+graph_adhesion'></span><span id='topic+graph_assortativity'></span><span id='topic+graph_automorphisms'></span><span id='topic+graph_clique_num'></span><span id='topic+graph_clique_count'></span><span id='topic+graph_component_count'></span><span id='topic+graph_motif_count'></span><span id='topic+graph_diameter'></span><span id='topic+graph_girth'></span><span id='topic+graph_radius'></span><span id='topic+graph_mutual_count'></span><span id='topic+graph_asym_count'></span><span id='topic+graph_unconn_count'></span><span id='topic+graph_size'></span><span id='topic+graph_order'></span><span id='topic+graph_reciprocity'></span><span id='topic+graph_min_cut'></span><span id='topic+graph_mean_dist'></span><span id='topic+graph_modularity'></span><span id='topic+graph_efficiency'></span>

<h3>Description</h3>

<p>This set of functions provide wrappers to a number of <code>graph</code>s graph
statistic algorithms. As for the other wrappers provided, they are intended
for use inside the <code>tidygraph</code> framework and it is thus not necessary to
supply the graph being computed on as the context is known. All of these
functions are guarantied to return scalars making it easy to compute with
them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_adhesion()

graph_assortativity(attr, in_attr = NULL, directed = TRUE)

graph_automorphisms(sh = "fm", colors = NULL)

graph_clique_num()

graph_clique_count(min = NULL, max = NULL, subset = NULL)

graph_component_count(type = "weak")

graph_motif_count(size = 3, cut.prob = rep(0, size))

graph_diameter(weights = NULL, directed = TRUE, unconnected = TRUE)

graph_girth()

graph_radius(mode = "out")

graph_mutual_count()

graph_asym_count()

graph_unconn_count()

graph_size()

graph_order()

graph_reciprocity(ignore_loops = TRUE, ratio = FALSE)

graph_min_cut(capacity = NULL)

graph_mean_dist(directed = TRUE, unconnected = TRUE, weights = NULL)

graph_modularity(group, weights = NULL)

graph_efficiency(weights = NULL, directed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_measures_+3A_attr">attr</code></td>
<td>
<p>The node attribute to measure on</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_in_attr">in_attr</code></td>
<td>
<p>An alternative node attribute to use for incomming node. If <code>NULL</code> the attribute given by <code>type</code> will be used</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_directed">directed</code></td>
<td>
<p>Should a directed graph be treated as directed</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_sh">sh</code></td>
<td>
<p>The splitting heuristics for the BLISS algorithm. Possible values
are: &lsquo;<code>f</code>&rsquo;: first non-singleton cell, &lsquo;<code>fl</code>&rsquo;: first
largest non-singleton cell, &lsquo;<code>fs</code>&rsquo;: first smallest non-singleton
cell, &lsquo;<code>fm</code>&rsquo;: first maximally non-trivially connected
non-singleton cell, &lsquo;<code>flm</code>&rsquo;: first largest maximally
non-trivially connected non-singleton cell, &lsquo;<code>fsm</code>&rsquo;: first
smallest maximally non-trivially connected non-singleton cell.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_colors">colors</code></td>
<td>
<p>The colors of the individual vertices of the graph; only
vertices having the same color are allowed to match each other in an
automorphism. When omitted, igraph uses the <code>color</code> attribute of the
vertices, or, if there is no such vertex attribute, it simply assumes that
all vertices have the same color. Pass NULL explicitly if the graph has a
<code>color</code> vertex attribute but you do not want to use it.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_min">min</code>, <code id="graph_measures_+3A_max">max</code></td>
<td>
<p>The upper and lower bounds of the cliques to be considered.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_subset">subset</code></td>
<td>
<p>The indexes of the nodes to start the search from (logical or integer). If provided only the cliques containing these nodes will be counted.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_type">type</code></td>
<td>
<p>The type of component to count, either 'weak' or 'strong'. Ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_size">size</code></td>
<td>
<p>The size of the motif.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_cut.prob">cut.prob</code></td>
<td>
<p>Numeric vector giving the probabilities that the search
graph is cut at a certain level. Its length should be the same as the size
of the motif (the <code>size</code> argument). By default no cuts are made.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_weights">weights</code></td>
<td>
<p>Optional positive weight vector for calculating weighted
distances. If the graph has a <code>weight</code> edge attribute, then this is
used by default.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_unconnected">unconnected</code></td>
<td>
<p>Logical, what to do if the graph is unconnected. If
FALSE, the function will return a number that is one larger the largest
possible diameter, which is always the number of vertices. If TRUE, the
diameters of the connected components will be calculated and the largest one
will be returned.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_mode">mode</code></td>
<td>
<p>How should eccentricity be calculated. If <code>"out"</code> only outbound edges are followed. If <code>"in"</code> only inbound are followed. If <code>"all"</code> all edges are followed. Ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_ignore_loops">ignore_loops</code></td>
<td>
<p>Logical. Should loops be ignored while calculating the reciprocity</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_ratio">ratio</code></td>
<td>
<p>Should the old &quot;ratio&quot; approach from igraph &lt; v0.6 be used</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_capacity">capacity</code></td>
<td>
<p>The capacity of the edges</p>
</td></tr>
<tr><td><code id="graph_measures_+3A_group">group</code></td>
<td>
<p>The node grouping to calculate the modularity on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, the type depending on the function
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>graph_adhesion()</code>: Gives the minimum edge connectivity. Wraps <code><a href="igraph.html#topic+edge_connectivity">igraph::edge_connectivity()</a></code>
</p>
</li>
<li> <p><code>graph_assortativity()</code>: Measures the propensity of similar nodes to be connected. Wraps <code><a href="igraph.html#topic+assortativity">igraph::assortativity()</a></code>
</p>
</li>
<li> <p><code>graph_automorphisms()</code>: Calculate the number of automorphisms of the graph. Wraps <code><a href="igraph.html#topic+count_automorphisms">igraph::count_automorphisms()</a></code>
</p>
</li>
<li> <p><code>graph_clique_num()</code>: Get the size of the largest clique. Wraps <code><a href="igraph.html#topic+cliques">igraph::clique_num()</a></code>
</p>
</li>
<li> <p><code>graph_clique_count()</code>: Get the number of maximal cliques in the graph. Wraps <code><a href="igraph.html#topic+cliques">igraph::count_max_cliques()</a></code>
</p>
</li>
<li> <p><code>graph_component_count()</code>: Count the number of unconnected componenets in the graph. Wraps <code><a href="igraph.html#topic+components">igraph::count_components()</a></code>
</p>
</li>
<li> <p><code>graph_motif_count()</code>: Count the number of motifs in a graph. Wraps <code><a href="igraph.html#topic+count_motifs">igraph::count_motifs()</a></code>
</p>
</li>
<li> <p><code>graph_diameter()</code>: Measures the length of the longest geodesic. Wraps <code><a href="igraph.html#topic+diameter">igraph::diameter()</a></code>
</p>
</li>
<li> <p><code>graph_girth()</code>: Measrues the length of the shortest circle in the graph. Wraps <code><a href="igraph.html#topic+girth">igraph::girth()</a></code>
</p>
</li>
<li> <p><code>graph_radius()</code>: Measures the smallest eccentricity in the graph. Wraps <code><a href="igraph.html#topic+radius">igraph::radius()</a></code>
</p>
</li>
<li> <p><code>graph_mutual_count()</code>: Counts the number of mutually connected nodes. Wraps <code><a href="igraph.html#topic+dyad_census">igraph::dyad_census()</a></code>
</p>
</li>
<li> <p><code>graph_asym_count()</code>: Counts the number of asymmetrically connected nodes. Wraps <code><a href="igraph.html#topic+dyad_census">igraph::dyad_census()</a></code>
</p>
</li>
<li> <p><code>graph_unconn_count()</code>: Counts the number of unconnected node pairs. Wraps <code><a href="igraph.html#topic+dyad_census">igraph::dyad_census()</a></code>
</p>
</li>
<li> <p><code>graph_size()</code>: Counts the number of edges in the graph. Wraps <code><a href="igraph.html#topic+gsize">igraph::gsize()</a></code>
</p>
</li>
<li> <p><code>graph_order()</code>: Counts the number of nodes in the graph. Wraps <code><a href="igraph.html#topic+gorder">igraph::gorder()</a></code>
</p>
</li>
<li> <p><code>graph_reciprocity()</code>: Measures the proportion of mutual connections in the graph. Wraps <code><a href="igraph.html#topic+reciprocity">igraph::reciprocity()</a></code>
</p>
</li>
<li> <p><code>graph_min_cut()</code>: Calculates the minimum number of edges to remove in order to split the graph into two clusters. Wraps <code><a href="igraph.html#topic+min_cut">igraph::min_cut()</a></code>
</p>
</li>
<li> <p><code>graph_mean_dist()</code>: Calculates the mean distance between all node pairs in the graph. Wraps <code><a href="igraph.html#topic+distances">igraph::mean_distance()</a></code>
</p>
</li>
<li> <p><code>graph_modularity()</code>: Calculates the modularity of the graph contingent on a provided node grouping
</p>
</li>
<li> <p><code>graph_efficiency()</code>: Calculate the global efficiency of the graph
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Use e.g. to modify computations on nodes and edges
create_notable('meredith') %&gt;%
  activate(nodes) %&gt;%
  mutate(rel_neighbors = centrality_degree()/graph_order())
</code></pre>

<hr>
<h2 id='graph_types'>Querying graph types</h2><span id='topic+graph_types'></span><span id='topic+graph_is_simple'></span><span id='topic+graph_is_directed'></span><span id='topic+graph_is_bipartite'></span><span id='topic+graph_is_connected'></span><span id='topic+graph_is_tree'></span><span id='topic+graph_is_forest'></span><span id='topic+graph_is_dag'></span><span id='topic+graph_is_chordal'></span><span id='topic+graph_is_complete'></span><span id='topic+graph_is_isomorphic_to'></span><span id='topic+graph_is_subgraph_isomorphic_to'></span><span id='topic+graph_is_eulerian'></span>

<h3>Description</h3>

<p>This set of functions lets the user query different aspects of the graph
itself. They are all concerned with wether the graph implements certain
properties and will all return a logical scalar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_is_simple()

graph_is_directed()

graph_is_bipartite()

graph_is_connected()

graph_is_tree()

graph_is_forest()

graph_is_dag()

graph_is_chordal()

graph_is_complete()

graph_is_isomorphic_to(graph, method = "auto", ...)

graph_is_subgraph_isomorphic_to(graph, method = "auto", ...)

graph_is_eulerian(cyclic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_types_+3A_graph">graph</code></td>
<td>
<p>The graph to compare structure to</p>
</td></tr>
<tr><td><code id="graph_types_+3A_method">method</code></td>
<td>
<p>The algorithm to use for comparison</p>
</td></tr>
<tr><td><code id="graph_types_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the comparison methods. See
<code><a href="igraph.html#topic+isomorphic">igraph::is_isomorphic_to()</a></code> and <code><a href="igraph.html#topic+subgraph_isomorphic">igraph::is_subgraph_isomorphic_to()</a></code></p>
</td></tr>
<tr><td><code id="graph_types_+3A_cyclic">cyclic</code></td>
<td>
<p>should the eulerian path start and end at the same node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical scalar
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>graph_is_simple()</code>: Is the graph simple (no parallel edges)
</p>
</li>
<li> <p><code>graph_is_directed()</code>: Is the graph directed
</p>
</li>
<li> <p><code>graph_is_bipartite()</code>: Is the graph bipartite
</p>
</li>
<li> <p><code>graph_is_connected()</code>: Is the graph connected
</p>
</li>
<li> <p><code>graph_is_tree()</code>: Is the graph a tree
</p>
</li>
<li> <p><code>graph_is_forest()</code>: Is the graph an ensemble of multiple trees
</p>
</li>
<li> <p><code>graph_is_dag()</code>: Is the graph a directed acyclic graph
</p>
</li>
<li> <p><code>graph_is_chordal()</code>: Is the graph chordal
</p>
</li>
<li> <p><code>graph_is_complete()</code>: Is the graph fully connected
</p>
</li>
<li> <p><code>graph_is_isomorphic_to()</code>: Is the graph isomorphic to another graph. See <code><a href="igraph.html#topic+isomorphic">igraph::is_isomorphic_to()</a></code>
</p>
</li>
<li> <p><code>graph_is_subgraph_isomorphic_to()</code>: Is the graph an isomorphic subgraph to another graph. see <code><a href="igraph.html#topic+subgraph_isomorphic">igraph::is_subgraph_isomorphic_to()</a></code>
</p>
</li>
<li> <p><code>graph_is_eulerian()</code>: Can all the edges in the graph be reaches by a single
path or cycle that only goes through each edge once
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>gr &lt;- create_tree(50, 4)

with_graph(gr, graph_is_tree())

</code></pre>

<hr>
<h2 id='graph-context'>Register a graph context for the duration of the current frame</h2><span id='topic+graph-context'></span><span id='topic+.graph_context'></span><span id='topic+.register_graph_context'></span><span id='topic+.free_graph_context'></span>

<h3>Description</h3>

<p>This function sets the provided graph to be the context for tidygraph
algorithms, such as e.g. <code><a href="#topic+node_is_center">node_is_center()</a></code>, for the duration of the current
environment. It automatically removes the graph once the environment exits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.graph_context

.register_graph_context(graph, free = FALSE, env = parent.frame())

.free_graph_context(env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph-context_+3A_graph">graph</code></td>
<td>
<p>A <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="graph-context_+3A_free">free</code></td>
<td>
<p>Should the active state of the graph be ignored?</p>
</td></tr>
<tr><td><code id="graph-context_+3A_env">env</code></td>
<td>
<p>The environment where the context should be active</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>ContextBuilder</code> (inherits from <code>R6</code>) of length 12.
</p>

<hr>
<h2 id='group_graph'>Group nodes and edges based on community structure</h2><span id='topic+group_graph'></span><span id='topic+group_components'></span><span id='topic+group_edge_betweenness'></span><span id='topic+group_fast_greedy'></span><span id='topic+group_infomap'></span><span id='topic+group_label_prop'></span><span id='topic+group_leading_eigen'></span><span id='topic+group_louvain'></span><span id='topic+group_leiden'></span><span id='topic+group_optimal'></span><span id='topic+group_spinglass'></span><span id='topic+group_walktrap'></span><span id='topic+group_fluid'></span><span id='topic+group_biconnected_component'></span><span id='topic+group_color'></span>

<h3>Description</h3>

<p>These functions are wrappers around the various clustering functions provided
by <code>igraph</code>. As with the other wrappers they automatically use the graph that
is being computed on, and otherwise passes on its arguments to the relevant
clustering function. The return value is always a numeric vector of group
memberships so that nodes or edges with the same number are part of the same
group. Grouping is predominantly made on nodes and currently the only
grouping of edges supported is biconnected components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_components(type = "weak")

group_edge_betweenness(weights = NULL, directed = TRUE, n_groups = NULL)

group_fast_greedy(weights = NULL, n_groups = NULL)

group_infomap(weights = NULL, node_weights = NULL, trials = 10)

group_label_prop(weights = NULL, label = NULL, fixed = NULL)

group_leading_eigen(
  weights = NULL,
  steps = -1,
  label = NULL,
  options = arpack_defaults(),
  n_groups = NULL
)

group_louvain(weights = NULL, resolution = 1)

group_leiden(
  weights = NULL,
  resolution = 1,
  objective_function = "CPM",
  beta = 0.01,
  label = NULL,
  n = 2,
  node_weights = NULL
)

group_optimal(weights = NULL)

group_spinglass(weights = NULL, ...)

group_walktrap(weights = NULL, steps = 4, n_groups = NULL)

group_fluid(n_groups = 2)

group_biconnected_component()

group_color()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_graph_+3A_type">type</code></td>
<td>
<p>The type of component to find. Either <code>'weak'</code> or <code>'strong'</code></p>
</td></tr>
<tr><td><code id="group_graph_+3A_weights">weights</code></td>
<td>
<p>The weight of the edges to use for the calculation. Will be
evaluated in the context of the edge data.</p>
</td></tr>
<tr><td><code id="group_graph_+3A_directed">directed</code></td>
<td>
<p>Should direction of edges be used for the calculations</p>
</td></tr>
<tr><td><code id="group_graph_+3A_n_groups">n_groups</code></td>
<td>
<p>Integer scalar, the desired number of communities. If too low
or two high, then an error message is given. The measure is applied to the
full graph so the number of groups returned may be lower for focused graphs</p>
</td></tr>
<tr><td><code id="group_graph_+3A_node_weights">node_weights</code></td>
<td>
<p>The weight of the nodes to use for the calculation. Will
be evaluated in the context of the node data.</p>
</td></tr>
<tr><td><code id="group_graph_+3A_trials">trials</code></td>
<td>
<p>Number of times partition of the network should be attempted</p>
</td></tr>
<tr><td><code id="group_graph_+3A_label">label</code></td>
<td>
<p>The initial groups of the nodes. Will be evaluated in the
context of the node data.</p>
</td></tr>
<tr><td><code id="group_graph_+3A_fixed">fixed</code></td>
<td>
<p>A logical vector determining which nodes should keep their
initial groups. Will be evaluated in the context of the node data.</p>
</td></tr>
<tr><td><code id="group_graph_+3A_steps">steps</code></td>
<td>
<p>The number of steps in the random walks</p>
</td></tr>
<tr><td><code id="group_graph_+3A_options">options</code></td>
<td>
<p>Settings passed on to <code>igraph::arpack()</code></p>
</td></tr>
<tr><td><code id="group_graph_+3A_resolution">resolution</code></td>
<td>
<p>Resolution of the modularity function used internally in
the algorithm</p>
</td></tr>
<tr><td><code id="group_graph_+3A_objective_function">objective_function</code></td>
<td>
<p>Either <code>"CPM"</code> (constant potts model) or
<code>"modularity"</code>. Sets the objective function to use.</p>
</td></tr>
<tr><td><code id="group_graph_+3A_beta">beta</code></td>
<td>
<p>Parameter affecting the randomness in the Leiden algorithm. This
affects only the refinement step of the algorithm.</p>
</td></tr>
<tr><td><code id="group_graph_+3A_n">n</code></td>
<td>
<p>The number of iterations to run the clustering</p>
</td></tr>
<tr><td><code id="group_graph_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="igraph.html#topic+cluster_spinglass">igraph::cluster_spinglass()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with the membership for each node in the graph. The
enumeration happens in order based on group size progressing from the largest
to the smallest group
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>group_components()</code>: Group by connected compenents using <code><a href="igraph.html#topic+components">igraph::components()</a></code>
</p>
</li>
<li> <p><code>group_edge_betweenness()</code>: Group densely connected nodes using <code><a href="igraph.html#topic+cluster_edge_betweenness">igraph::cluster_edge_betweenness()</a></code>
</p>
</li>
<li> <p><code>group_fast_greedy()</code>: Group nodes by optimising modularity using <code><a href="igraph.html#topic+cluster_fast_greedy">igraph::cluster_fast_greedy()</a></code>
</p>
</li>
<li> <p><code>group_infomap()</code>: Group nodes by minimizing description length using <code><a href="igraph.html#topic+cluster_infomap">igraph::cluster_infomap()</a></code>
</p>
</li>
<li> <p><code>group_label_prop()</code>: Group nodes by propagating labels using <code><a href="igraph.html#topic+cluster_label_prop">igraph::cluster_label_prop()</a></code>
</p>
</li>
<li> <p><code>group_leading_eigen()</code>: Group nodes based on the leading eigenvector of the modularity matrix using <code><a href="igraph.html#topic+cluster_leading_eigen">igraph::cluster_leading_eigen()</a></code>
</p>
</li>
<li> <p><code>group_louvain()</code>: Group nodes by multilevel optimisation of modularity using <code><a href="igraph.html#topic+cluster_louvain">igraph::cluster_louvain()</a></code>
</p>
</li>
<li> <p><code>group_leiden()</code>: Group nodes according to the Leiden algorithm (<code><a href="igraph.html#topic+cluster_leiden">igraph::cluster_leiden()</a></code>) which is similar, but more efficient and provides higher quality results than <code>cluster_louvain()</code>
</p>
</li>
<li> <p><code>group_optimal()</code>: Group nodes by optimising the moldularity score using <code><a href="igraph.html#topic+cluster_optimal">igraph::cluster_optimal()</a></code>
</p>
</li>
<li> <p><code>group_spinglass()</code>: Group nodes using simulated annealing with <code><a href="igraph.html#topic+cluster_spinglass">igraph::cluster_spinglass()</a></code>
</p>
</li>
<li> <p><code>group_walktrap()</code>: Group nodes via short random walks using <code><a href="igraph.html#topic+cluster_walktrap">igraph::cluster_walktrap()</a></code>
</p>
</li>
<li> <p><code>group_fluid()</code>: Group nodes by simulating fluid interactions on the graph topology using <code><a href="igraph.html#topic+cluster_fluid_communities">igraph::cluster_fluid_communities()</a></code>
</p>
</li>
<li> <p><code>group_biconnected_component()</code>: Group edges by their membership of the maximal binconnected components using <code><a href="igraph.html#topic+biconnected_components">igraph::biconnected_components()</a></code>
</p>
</li>
<li> <p><code>group_color()</code>: Groups nodes by their color using <code><a href="igraph.html#topic+greedy_vertex_coloring">igraph::greedy_vertex_coloring()</a></code>. Be aware that this is not a clustering algorithm as coloring specifically provide a color to each node so that no neighbors have the same color
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>create_notable('tutte') %&gt;%
  activate(nodes) %&gt;%
  mutate(group = group_infomap())

</code></pre>

<hr>
<h2 id='iterate'>Repeatedly modify a graph by a function</h2><span id='topic+iterate'></span><span id='topic+iterate_n'></span><span id='topic+iterate_while'></span>

<h3>Description</h3>

<p>The iterate family of functions allow you to call the same modification
function on a graph until some condition is met. This can be used to create
simple simulations in a tidygraph friendly API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_n(.data, n, .f, ...)

iterate_while(.data, cnd, .f, ..., max_n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterate_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="iterate_+3A_n">n</code></td>
<td>
<p>The number of times to iterate</p>
</td></tr>
<tr><td><code id="iterate_+3A_.f">.f</code></td>
<td>
<p>A function taking in a <code>tbl_graph</code> as the first argument and
returning a <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="iterate_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code>.f</code></p>
</td></tr>
<tr><td><code id="iterate_+3A_cnd">cnd</code></td>
<td>
<p>A condition that must evaluate to <code>TRUE</code> or <code>FALSE</code> determining if
iteration should continue</p>
</td></tr>
<tr><td><code id="iterate_+3A_max_n">max_n</code></td>
<td>
<p>The maximum number of iterations in case <code>cnd</code> never evaluates
to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tbl_graph</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gradually remove edges from the least connected nodes while avoiding
# isolates
create_notable('zachary') |&gt;
  iterate_n(20, function(gr) {
    gr |&gt;
      activate(nodes) |&gt;
      mutate(deg = centrality_degree(), rank = order(deg)) |&gt;
      activate(edges) |&gt;
      slice(
        -which(edge_is_incident(.N()$rank == sum(.N()$deg == 1) + 1))[1]
      )
  })

# Remove a random edge until the graph is split in two
create_notable('zachary') |&gt;
  iterate_while(graph_component_count() == 1, function(gr) {
    gr |&gt;
      activate(edges) |&gt;
      slice(-sample(graph_size(), 1))
  })

</code></pre>

<hr>
<h2 id='local_graph'>Measures based on the neighborhood of each node</h2><span id='topic+local_graph'></span><span id='topic+local_size'></span><span id='topic+local_members'></span><span id='topic+local_triangles'></span><span id='topic+local_ave_degree'></span><span id='topic+local_transitivity'></span>

<h3>Description</h3>

<p>These functions wraps a set of functions that all measures quantities of the
local neighborhood of each node. They all return a vector or list matching
the node position.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_size(order = 1, mode = "all", mindist = 0)

local_members(order = 1, mode = "all", mindist = 0)

local_triangles()

local_ave_degree(weights = NULL)

local_transitivity(weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="local_graph_+3A_order">order</code></td>
<td>
<p>Integer giving the order of the neighborhood.</p>
</td></tr>
<tr><td><code id="local_graph_+3A_mode">mode</code></td>
<td>
<p>Character constant, it specifies how to use the direction of
the edges if a directed graph is analyzed. For &lsquo;out&rsquo; only the
outgoing edges are followed, so all vertices reachable from the source
vertex in at most <code>order</code> steps are counted. For &lsquo;&quot;in&quot;&rsquo; all
vertices from which the source vertex is reachable in at most <code>order</code>
steps are counted. &lsquo;&quot;all&quot;&rsquo; ignores the direction of the edges. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="local_graph_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance to include the vertex in the result.</p>
</td></tr>
<tr><td><code id="local_graph_+3A_weights">weights</code></td>
<td>
<p>An edge weight vector. For <code>local_ave_degree</code>: If this argument
is given, the average vertex strength is calculated instead of vertex degree.
For <code>local_transitivity</code>: if given weighted transitivity using the approach by
<em>A. Barrat</em> will be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector or a list (for <code>local_members</code>) with elements
corresponding to the nodes in the graph.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>local_size()</code>: The size of the neighborhood in a given distance from
the node. (Note that the node itself is included unless <code>mindist &gt; 0</code>). Wraps <code><a href="igraph.html#topic+ego">igraph::ego_size()</a></code>.
</p>
</li>
<li> <p><code>local_members()</code>: The members of the neighborhood of each node in a
given distance. Wraps <code><a href="igraph.html#topic+ego">igraph::ego()</a></code>.
</p>
</li>
<li> <p><code>local_triangles()</code>: The number of triangles each node participate in. Wraps <code><a href="igraph.html#topic+count_triangles">igraph::count_triangles()</a></code>.
</p>
</li>
<li> <p><code>local_ave_degree()</code>: Calculates the average degree based on the neighborhood of each node. Wraps <code><a href="igraph.html#topic+knn">igraph::knn()</a></code>.
</p>
</li>
<li> <p><code>local_transitivity()</code>: Calculate the transitivity of each node, that is, the
propensity for the nodes neighbors to be connected. Wraps <code><a href="igraph.html#topic+transitivity">igraph::transitivity()</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Get all neighbors of each graph
create_notable('chvatal') %&gt;%
  activate(nodes) %&gt;%
  mutate(neighborhood = local_members(mindist = 1))

# These are equivalent
create_notable('chvatal') %&gt;%
  activate(nodes) %&gt;%
  mutate(n_neighbors = local_size(mindist = 1),
         degree = centrality_degree()) %&gt;%
  as_tibble()

</code></pre>

<hr>
<h2 id='map_bfs'>Apply a function to nodes in the order of a breath first search</h2><span id='topic+map_bfs'></span><span id='topic+map_bfs_lgl'></span><span id='topic+map_bfs_chr'></span><span id='topic+map_bfs_int'></span><span id='topic+map_bfs_dbl'></span>

<h3>Description</h3>

<p>These functions allow you to map over the nodes in a graph, by first
performing a breath first search on the graph and then mapping over each
node in the order they are visited. The mapping function will have access to
the result and search statistics for all the nodes between itself and the
root in the search. To map over the nodes in the reverse direction use
<code><a href="#topic+map_bfs_back">map_bfs_back()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_bfs(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_lgl(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_chr(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_int(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_dbl(root, mode = "out", unreachable = FALSE, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_bfs_+3A_root">root</code></td>
<td>
<p>The node to start the search from</p>
</td></tr>
<tr><td><code id="map_bfs_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed? <code>'out'</code> only follows outbound
edges, <code>'in'</code> only follows inbound edges, and <code>'all'</code> follows all edges. This
parameter is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="map_bfs_+3A_unreachable">unreachable</code></td>
<td>
<p>Should the search jump to an unvisited node if the search
is completed without visiting all nodes.</p>
</td></tr>
<tr><td><code id="map_bfs_+3A_.f">.f</code></td>
<td>
<p>A function to map over all nodes. See Details</p>
</td></tr>
<tr><td><code id="map_bfs_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>.f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provided to <code>.f</code> will be called with the following arguments in
addition to those supplied through <code>...</code>:
</p>

<ul>
<li> <p><code>graph</code>: The full <code>tbl_graph</code> object
</p>
</li>
<li> <p><code>node</code>: The index of the node currently mapped over
</p>
</li>
<li> <p><code>rank</code>: The rank of the node in the search
</p>
</li>
<li> <p><code>parent</code>: The index of the node that led to the current node
</p>
</li>
<li> <p><code>before</code>: The index of the node that was visited before the current node
</p>
</li>
<li> <p><code>after</code>: The index of the node that was visited after the current node.
</p>
</li>
<li> <p><code>dist</code>: The distance of the current node from the root
</p>
</li>
<li> <p><code>path</code>: A table containing <code>node</code>, <code>rank</code>, <code>parent</code>, <code>before</code>, <code>after</code>,
<code>dist</code>, and <code>result</code> columns giving the values for each node leading to the
current node. The <code>result</code> column will contain the result of the mapping
of each node in a list.
</p>
</li></ul>

<p>Instead of spelling out all of these in the function it is possible to simply
name the ones needed and use <code>...</code> to catch the rest.
</p>


<h3>Value</h3>

<p><code>map_bfs()</code> returns a list of the same length as the number of nodes
in the graph, in the order matching the node order in the graph (that is, not
in the order they are called). <code style="white-space: pre;">&#8288;map_bfs_*()&#8288;</code> tries to coerce its result into
a vector of the classes <code>logical</code> (<code>map_bfs_lgl</code>), <code>character</code>
(<code>map_bfs_chr</code>), <code>integer</code> (<code>map_bfs_int</code>), or <code>double</code> (<code>map_bfs_dbl</code>).
These functions will throw an error if they are unsuccesful, so they are type
safe.
</p>


<h3>See Also</h3>

<p>Other node map functions: 
<code><a href="#topic+map_bfs_back">map_bfs_back</a>()</code>,
<code><a href="#topic+map_dfs">map_dfs</a>()</code>,
<code><a href="#topic+map_dfs_back">map_dfs_back</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Accumulate values along a search
create_tree(40, children = 3, directed = TRUE) %&gt;%
  mutate(value = round(runif(40)*100)) %&gt;%
  mutate(value_acc = map_bfs_dbl(node_is_root(), .f = function(node, path, ...) {
    sum(.N()$value[c(node, path$node)])
  }))
</code></pre>

<hr>
<h2 id='map_bfs_back'>Apply a function to nodes in the reverse order of a breath first search</h2><span id='topic+map_bfs_back'></span><span id='topic+map_bfs_back_lgl'></span><span id='topic+map_bfs_back_chr'></span><span id='topic+map_bfs_back_int'></span><span id='topic+map_bfs_back_dbl'></span>

<h3>Description</h3>

<p>These functions allow you to map over the nodes in a graph, by first
performing a breath first search on the graph and then mapping over each
node in the reverse order they are visited. The mapping function will have
access to the result and search statistics for all the nodes following itself
in the search. To map over the nodes in the original direction use
<code><a href="#topic+map_bfs">map_bfs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_bfs_back(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_back_lgl(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_back_chr(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_back_int(root, mode = "out", unreachable = FALSE, .f, ...)

map_bfs_back_dbl(root, mode = "out", unreachable = FALSE, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_bfs_back_+3A_root">root</code></td>
<td>
<p>The node to start the search from</p>
</td></tr>
<tr><td><code id="map_bfs_back_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed? <code>'out'</code> only follows outbound
edges, <code>'in'</code> only follows inbound edges, and <code>'all'</code> follows all edges. This
parameter is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="map_bfs_back_+3A_unreachable">unreachable</code></td>
<td>
<p>Should the search jump to an unvisited node if the search
is completed without visiting all nodes.</p>
</td></tr>
<tr><td><code id="map_bfs_back_+3A_.f">.f</code></td>
<td>
<p>A function to map over all nodes. See Details</p>
</td></tr>
<tr><td><code id="map_bfs_back_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>.f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provided to <code>.f</code> will be called with the following arguments in
addition to those supplied through <code>...</code>:
</p>

<ul>
<li> <p><code>graph</code>: The full <code>tbl_graph</code> object
</p>
</li>
<li> <p><code>node</code>: The index of the node currently mapped over
</p>
</li>
<li> <p><code>rank</code>: The rank of the node in the search
</p>
</li>
<li> <p><code>parent</code>: The index of the node that led to the current node
</p>
</li>
<li> <p><code>before</code>: The index of the node that was visited before the current node
</p>
</li>
<li> <p><code>after</code>: The index of the node that was visited after the current node.
</p>
</li>
<li> <p><code>dist</code>: The distance of the current node from the root
</p>
</li>
<li> <p><code>path</code>: A table containing <code>node</code>, <code>rank</code>, <code>parent</code>, <code>before</code>, <code>after</code>,
<code>dist</code>, and <code>result</code> columns giving the values for each node reached from
the current node. The <code>result</code> column will contain the result of the mapping
of each node in a list.
</p>
</li></ul>

<p>Instead of spelling out all of these in the function it is possible to simply
name the ones needed and use <code>...</code> to catch the rest.
</p>


<h3>Value</h3>

<p><code>map_bfs_back()</code> returns a list of the same length as the number of
nodes in the graph, in the order matching the node order in the graph (that
is, not in the order they are called). <code style="white-space: pre;">&#8288;map_bfs_back_*()&#8288;</code> tries to coerce
its result into a vector of the classes <code>logical</code> (<code>map_bfs_back_lgl</code>),
<code>character</code> (<code>map_bfs_back_chr</code>), <code>integer</code> (<code>map_bfs_back_int</code>), or <code>double</code>
(<code>map_bfs_back_dbl</code>). These functions will throw an error if they are
unsuccesful, so they are type safe.
</p>


<h3>See Also</h3>

<p>Other node map functions: 
<code><a href="#topic+map_bfs">map_bfs</a>()</code>,
<code><a href="#topic+map_dfs">map_dfs</a>()</code>,
<code><a href="#topic+map_dfs_back">map_dfs_back</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Collect values from children
create_tree(40, children = 3, directed = TRUE) %&gt;%
  mutate(value = round(runif(40)*100)) %&gt;%
  mutate(child_acc = map_bfs_back_dbl(node_is_root(), .f = function(node, path, ...) {
    if (nrow(path) == 0) .N()$value[node]
    else {
      sum(unlist(path$result[path$parent == node]))
    }
  }))
</code></pre>

<hr>
<h2 id='map_dfs'>Apply a function to nodes in the order of a depth first search</h2><span id='topic+map_dfs'></span><span id='topic+map_dfs_lgl'></span><span id='topic+map_dfs_chr'></span><span id='topic+map_dfs_int'></span><span id='topic+map_dfs_dbl'></span>

<h3>Description</h3>

<p>These functions allow you to map over the nodes in a graph, by first
performing a depth first search on the graph and then mapping over each
node in the order they are visited. The mapping function will have access to
the result and search statistics for all the nodes between itself and the
root in the search. To map over the nodes in the reverse direction use
<code><a href="#topic+map_dfs_back">map_dfs_back()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_dfs(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_lgl(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_chr(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_int(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_dbl(root, mode = "out", unreachable = FALSE, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_dfs_+3A_root">root</code></td>
<td>
<p>The node to start the search from</p>
</td></tr>
<tr><td><code id="map_dfs_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed? <code>'out'</code> only follows outbound
edges, <code>'in'</code> only follows inbound edges, and <code>'all'</code> follows all edges. This
parameter is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="map_dfs_+3A_unreachable">unreachable</code></td>
<td>
<p>Should the search jump to an unvisited node if the search
is completed without visiting all nodes.</p>
</td></tr>
<tr><td><code id="map_dfs_+3A_.f">.f</code></td>
<td>
<p>A function to map over all nodes. See Details</p>
</td></tr>
<tr><td><code id="map_dfs_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>.f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provided to <code>.f</code> will be called with the following arguments in
addition to those supplied through <code>...</code>:
</p>

<ul>
<li> <p><code>graph</code>: The full <code>tbl_graph</code> object
</p>
</li>
<li> <p><code>node</code>: The index of the node currently mapped over
</p>
</li>
<li> <p><code>rank</code>: The rank of the node in the search
</p>
</li>
<li> <p><code>rank_out</code>: The rank of the completion of the nodes subtree
</p>
</li>
<li> <p><code>parent</code>: The index of the node that led to the current node
</p>
</li>
<li> <p><code>dist</code>: The distance of the current node from the root
</p>
</li>
<li> <p><code>path</code>: A table containing <code>node</code>, <code>rank</code>, <code>rank_out</code>, <code>parent</code>, dist<code style="white-space: pre;">&#8288;, and &#8288;</code>result<code style="white-space: pre;">&#8288;columns giving the values for each node leading to the current node. The&#8288;</code>result' column will contain the result of the mapping
of each node in a list.
</p>
</li></ul>

<p>Instead of spelling out all of these in the function it is possible to simply
name the ones needed and use <code>...</code> to catch the rest.
</p>


<h3>Value</h3>

<p><code>map_dfs()</code> returns a list of the same length as the number of nodes
in the graph, in the order matching the node order in the graph (that is, not
in the order they are called). <code style="white-space: pre;">&#8288;map_dfs_*()&#8288;</code> tries to coerce its result into
a vector of the classes <code>logical</code> (<code>map_dfs_lgl</code>), <code>character</code>
(<code>map_dfs_chr</code>), <code>integer</code> (<code>map_dfs_int</code>), or <code>double</code> (<code>map_dfs_dbl</code>).
These functions will throw an error if they are unsuccesful, so they are type
safe.
</p>


<h3>See Also</h3>

<p>Other node map functions: 
<code><a href="#topic+map_bfs">map_bfs</a>()</code>,
<code><a href="#topic+map_bfs_back">map_bfs_back</a>()</code>,
<code><a href="#topic+map_dfs_back">map_dfs_back</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Add a random integer to the last value along a search
create_tree(40, children = 3, directed = TRUE) %&gt;%
  mutate(child_acc = map_dfs_int(node_is_root(), .f = function(node, path, ...) {
    last_val &lt;- if (nrow(path) == 0) 0L else tail(unlist(path$result), 1)
    last_val + sample(1:10, 1)
  }))
</code></pre>

<hr>
<h2 id='map_dfs_back'>Apply a function to nodes in the reverse order of a depth first search</h2><span id='topic+map_dfs_back'></span><span id='topic+map_dfs_back_lgl'></span><span id='topic+map_dfs_back_chr'></span><span id='topic+map_dfs_back_int'></span><span id='topic+map_dfs_back_dbl'></span>

<h3>Description</h3>

<p>These functions allow you to map over the nodes in a graph, by first
performing a depth first search on the graph and then mapping over each
node in the reverse order they are visited. The mapping function will have
access to the result and search statistics for all the nodes following itself
in the search. To map over the nodes in the original direction use
<code><a href="#topic+map_dfs">map_dfs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_dfs_back(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_back_lgl(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_back_chr(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_back_int(root, mode = "out", unreachable = FALSE, .f, ...)

map_dfs_back_dbl(root, mode = "out", unreachable = FALSE, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_dfs_back_+3A_root">root</code></td>
<td>
<p>The node to start the search from</p>
</td></tr>
<tr><td><code id="map_dfs_back_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed? <code>'out'</code> only follows outbound
edges, <code>'in'</code> only follows inbound edges, and <code>'all'</code> follows all edges. This
parameter is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="map_dfs_back_+3A_unreachable">unreachable</code></td>
<td>
<p>Should the search jump to an unvisited node if the search
is completed without visiting all nodes.</p>
</td></tr>
<tr><td><code id="map_dfs_back_+3A_.f">.f</code></td>
<td>
<p>A function to map over all nodes. See Details</p>
</td></tr>
<tr><td><code id="map_dfs_back_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>.f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provided to <code>.f</code> will be called with the following arguments in
addition to those supplied through <code>...</code>:
</p>

<ul>
<li> <p><code>graph</code>: The full <code>tbl_graph</code> object
</p>
</li>
<li> <p><code>node</code>: The index of the node currently mapped over
</p>
</li>
<li> <p><code>rank</code>: The rank of the node in the search
</p>
</li>
<li> <p><code>rank_out</code>: The rank of the completion of the nodes subtree
</p>
</li>
<li> <p><code>parent</code>: The index of the node that led to the current node
</p>
</li>
<li> <p><code>dist</code>: The distance of the current node from the root
</p>
</li>
<li> <p><code>path</code>: A table containing <code>node</code>, <code>rank</code>, <code>rank_out</code>, <code>parent</code>, dist<code style="white-space: pre;">&#8288;, and &#8288;</code>result<code style="white-space: pre;">&#8288;columns giving the values for each node reached from the current node. The&#8288;</code>result' column will contain the result of the mapping
of each node in a list.
</p>
</li></ul>

<p>Instead of spelling out all of these in the function it is possible to simply
name the ones needed and use <code>...</code> to catch the rest.
</p>


<h3>Value</h3>

<p><code>map_dfs_back()</code> returns a list of the same length as the number of
nodes in the graph, in the order matching the node order in the graph (that
is, not in the order they are called). <code style="white-space: pre;">&#8288;map_dfs_back_*()&#8288;</code> tries to coerce
its result into a vector of the classes <code>logical</code> (<code>map_dfs_back_lgl</code>),
<code>character</code> (<code>map_dfs_back_chr</code>), <code>integer</code> (<code>map_dfs_back_int</code>), or <code>double</code>
(<code>map_dfs_back_dbl</code>). These functions will throw an error if they are
unsuccesful, so they are type safe.
</p>


<h3>See Also</h3>

<p>Other node map functions: 
<code><a href="#topic+map_bfs">map_bfs</a>()</code>,
<code><a href="#topic+map_bfs_back">map_bfs_back</a>()</code>,
<code><a href="#topic+map_dfs">map_dfs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Collect values from the 2 closest layers of children in a dfs search
create_tree(40, children = 3, directed = TRUE) %&gt;%
  mutate(value = round(runif(40)*100)) %&gt;%
  mutate(child_acc = map_dfs_back(node_is_root(), .f = function(node, path, dist, ...) {
    if (nrow(path) == 0) .N()$value[node]
    else {
      unlist(path$result[path$dist - dist &lt;= 2])
    }
  }))
</code></pre>

<hr>
<h2 id='map_local'>Map a function over a graph representing the neighborhood of each node</h2><span id='topic+map_local'></span><span id='topic+map_local_lgl'></span><span id='topic+map_local_chr'></span><span id='topic+map_local_int'></span><span id='topic+map_local_dbl'></span>

<h3>Description</h3>

<p>This function extracts the neighborhood of each node as a graph and maps over
each of these neighborhood graphs. Conceptually it is similar to
<code><a href="igraph.html#topic+local_scan">igraph::local_scan()</a></code>, but it borrows the type safe versions available in
<code><a href="#topic+map_bfs">map_bfs()</a></code> and <code><a href="#topic+map_dfs">map_dfs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_local(order = 1, mode = "all", mindist = 0, .f, ...)

map_local_lgl(order = 1, mode = "all", mindist = 0, .f, ...)

map_local_chr(order = 1, mode = "all", mindist = 0, .f, ...)

map_local_int(order = 1, mode = "all", mindist = 0, .f, ...)

map_local_dbl(order = 1, mode = "all", mindist = 0, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="map_local_+3A_order">order</code></td>
<td>
<p>Integer giving the order of the neighborhood.</p>
</td></tr>
<tr><td><code id="map_local_+3A_mode">mode</code></td>
<td>
<p>Character constant, it specifies how to use the direction of
the edges if a directed graph is analyzed. For &lsquo;out&rsquo; only the
outgoing edges are followed, so all vertices reachable from the source
vertex in at most <code>order</code> steps are counted. For &lsquo;&quot;in&quot;&rsquo; all
vertices from which the source vertex is reachable in at most <code>order</code>
steps are counted. &lsquo;&quot;all&quot;&rsquo; ignores the direction of the edges. This
argument is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="map_local_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance to include the vertex in the result.</p>
</td></tr>
<tr><td><code id="map_local_+3A_.f">.f</code></td>
<td>
<p>A function to map over all nodes. See Details</p>
</td></tr>
<tr><td><code id="map_local_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code>.f</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provided to <code>.f</code> will be called with the following arguments in
addition to those supplied through <code>...</code>:
</p>

<ul>
<li> <p><code>neighborhood</code>: The neighborhood graph of the node
</p>
</li>
<li> <p><code>graph</code>: The full <code>tbl_graph</code> object
</p>
</li>
<li> <p><code>node</code>: The index of the node currently mapped over
</p>
</li></ul>

<p>The <code>neighborhood</code> graph will contain an extra node attribute called
<code>.central_node</code>, which will be <code>TRUE</code> for the node that the neighborhood is
expanded from and <code>FALSE</code> for everything else.
</p>


<h3>Value</h3>

<p><code>map_local()</code> returns a list of the same length as the number of
nodes in the graph, in the order matching the node order in the graph.
<code style="white-space: pre;">&#8288;map_local_*()&#8288;</code> tries to coerce its result into a vector of the classes
<code>logical</code> (<code>map_local_lgl</code>), <code>character</code> (<code>map_local_chr</code>), <code>integer</code>
(<code>map_local_int</code>), or <code>double</code> (<code>map_local_dbl</code>). These functions will throw
an error if they are unsuccesful, so they are type safe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Smooth out values over a neighborhood
create_notable('meredith') %&gt;%
  mutate(value = rpois(graph_order(), 5)) %&gt;%
  mutate(value_smooth = map_local_dbl(order = 2, .f = function(neighborhood, ...) {
    mean(as_tibble(neighborhood, active = 'nodes')$value)
  }))
</code></pre>

<hr>
<h2 id='morph'>Create a temporary alternative representation of the graph to compute on</h2><span id='topic+morph'></span><span id='topic+unmorph'></span><span id='topic+crystallise'></span><span id='topic+crystallize'></span><span id='topic+convert'></span>

<h3>Description</h3>

<p>The <code>morph</code>/<code>unmorph</code> verbs are used to create temporary representations of
the graph, such as e.g. its search tree or a subgraph. A morphed graph will
accept any of the standard <code>dplyr</code> verbs, and changes to the data is
automatically propagated to the original graph when unmorphing. Tidygraph
comes with a range of <a href="#topic+morphers">morphers</a>, but is it also possible to supply your own.
See Details for the requirement for custom morphers. The <code>crystallise</code> verb
is used to extract the temporary graph representation into a tibble
containing one separate graph per row and a <code>name</code> and <code>graph</code> column holding
the name of each graph and the graph itself respectively. <code>convert()</code> is a
shorthand for performing both <code>morph</code> and <code>crystallise</code> along with extracting
a single <code>tbl_graph</code> (defaults to the first). For morphs were you know they
only create a single graph, and you want to keep it, this is an easy way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morph(.data, .f, ...)

unmorph(.data)

crystallise(.data)

crystallize(.data)

convert(.data, .f, ..., .select = 1, .clean = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="morph_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl_graph</code> or a <code>morphed_tbl_graph</code></p>
</td></tr>
<tr><td><code id="morph_+3A_.f">.f</code></td>
<td>
<p>A morphing function. See <a href="#topic+morphers">morphers</a> for a list of provided one.</p>
</td></tr>
<tr><td><code id="morph_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the morpher</p>
</td></tr>
<tr><td><code id="morph_+3A_.select">.select</code></td>
<td>
<p>The graph to return during <code>convert()</code>. Either an index or the
name as created during <code>crystallise()</code>.</p>
</td></tr>
<tr><td><code id="morph_+3A_.clean">.clean</code></td>
<td>
<p>Should references to the node and edge indexes in the original
graph be removed when using <code>convert</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is only possible to change and add to node and edge data from a
morphed state. Any filtering/removal of nodes and edges will not result in
removal from the main graph. However, nodes and edges not present in the
morphed state will be unaffected in the main graph when unmorphing (if new
columns were added during the morhped state they will be filled with <code>NA</code>).
</p>
<p>Morphing an already morhped graph will unmorph prior to applying the new
morph.
</p>
<p>During a morphed state, the mapping back to the original graph is stored in
<code>.tidygraph_node_index</code> and <code>.tidygraph_edge_index</code> columns. These are
accesible but protected, meaning that any changes to them with e.g. mutate
will be ignored. Furthermore, if the morph results in the merging of nodes
and/or edges the original data is stored in a <code>.data</code> column. This is
protected as well.
</p>
<p>When supplying your own morphers the morphing function should accept a
<code>tbl_graph</code> as its first input. The provided graph will already have nodes
and edges mapped with a <code>.tidygraph_node_index</code> and <code>.tidygraph_edge_index</code>
column. The return value must be a <code>tbl_graph</code> or a list of <code>tbl_graph</code>s and
these must contain either a <code>.tidygraph_node_index</code> column or a
<code>.tidygraph_edge_index</code> column (or both). Note that it is possible for the
morph to have the edges mapped back to the original nodes and vice versa
(e.g. as with <a href="#topic+to_linegraph">to_linegraph</a>). In that case the edge data in the morphed
graph(s) will contain a <code>.tidygraph_node_index</code> column and/or the node data a
<code>.tidygraph_edge_index</code> column. If the morphing results in the collapse of
multiple columns or edges the index columns should be converted to list
columns mapping the new node/edge back to all the nodes/edges it represents.
Furthermore the original node/edge data should be collapsed to a list of
tibbles, with the row order matching the order in the index column element.
</p>


<h3>Value</h3>

<p>A <code>morphed_tbl_graph</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_notable('meredith') %&gt;%
  mutate(group = group_infomap()) %&gt;%
  morph(to_contracted, group) %&gt;%
  mutate(group_centrality = centrality_pagerank()) %&gt;%
  unmorph()
</code></pre>

<hr>
<h2 id='morphers'>Functions to generate alternate representations of graphs</h2><span id='topic+morphers'></span><span id='topic+to_linegraph'></span><span id='topic+to_subgraph'></span><span id='topic+to_subcomponent'></span><span id='topic+to_split'></span><span id='topic+to_components'></span><span id='topic+to_largest_component'></span><span id='topic+to_complement'></span><span id='topic+to_local_neighborhood'></span><span id='topic+to_dominator_tree'></span><span id='topic+to_minimum_spanning_tree'></span><span id='topic+to_random_spanning_tree'></span><span id='topic+to_shortest_path'></span><span id='topic+to_bfs_tree'></span><span id='topic+to_dfs_tree'></span><span id='topic+to_simple'></span><span id='topic+to_contracted'></span><span id='topic+to_unfolded_tree'></span><span id='topic+to_directed'></span><span id='topic+to_undirected'></span><span id='topic+to_hierarchical_clusters'></span>

<h3>Description</h3>

<p>These functions are meant to be passed into <code><a href="#topic+morph">morph()</a></code> to create a temporary
alternate representation of the input graph. They are thus not meant to be
called directly. See below for detail of each morpher.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_linegraph(graph)

to_subgraph(graph, ..., subset_by = NULL)

to_subcomponent(graph, node)

to_split(graph, ..., split_by = NULL)

to_components(graph, type = "weak", min_order = 1)

to_largest_component(graph, type = "weak")

to_complement(graph, loops = FALSE)

to_local_neighborhood(graph, node, order = 1, mode = "all")

to_dominator_tree(graph, root, mode = "out")

to_minimum_spanning_tree(graph, weights = NULL)

to_random_spanning_tree(graph)

to_shortest_path(graph, from, to, mode = "out", weights = NULL)

to_bfs_tree(graph, root, mode = "out", unreachable = FALSE)

to_dfs_tree(graph, root, mode = "out", unreachable = FALSE)

to_simple(graph, remove_multiples = TRUE, remove_loops = TRUE)

to_contracted(graph, ..., simplify = TRUE)

to_unfolded_tree(graph, root, mode = "out")

to_directed(graph)

to_undirected(graph)

to_hierarchical_clusters(graph, method = "walktrap", weights = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="morphers_+3A_graph">graph</code></td>
<td>
<p>A <code>tbl_graph</code></p>
</td></tr>
<tr><td><code id="morphers_+3A_...">...</code></td>
<td>
<p>Arguments to pass on to <code><a href="#topic+filter">filter()</a></code>, <code><a href="#topic+group_by">group_by()</a></code>, or the cluster
algorithm (see <code><a href="igraph.html#topic+cluster_walktrap">igraph::cluster_walktrap()</a></code>, <code><a href="igraph.html#topic+cluster_leading_eigen">igraph::cluster_leading_eigen()</a></code>,
and <code><a href="igraph.html#topic+cluster_edge_betweenness">igraph::cluster_edge_betweenness()</a></code>)</p>
</td></tr>
<tr><td><code id="morphers_+3A_subset_by">subset_by</code>, <code id="morphers_+3A_split_by">split_by</code></td>
<td>
<p>Whether to create subgraphs based on nodes or edges</p>
</td></tr>
<tr><td><code id="morphers_+3A_node">node</code></td>
<td>
<p>The center of the neighborhood for <code>to_local_neighborhood()</code> and
the node to that should be included in the component for <code>to_subcomponent()</code></p>
</td></tr>
<tr><td><code id="morphers_+3A_type">type</code></td>
<td>
<p>The type of component to split into. Either <code>'weak'</code> or <code>'strong'</code></p>
</td></tr>
<tr><td><code id="morphers_+3A_min_order">min_order</code></td>
<td>
<p>The minimum order (number of vertices) of the component.
Components below this will not be created</p>
</td></tr>
<tr><td><code id="morphers_+3A_loops">loops</code></td>
<td>
<p>Should loops be included. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="morphers_+3A_order">order</code></td>
<td>
<p>The radius of the neighborhood</p>
</td></tr>
<tr><td><code id="morphers_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed? <code>'out'</code> only follows outbound
edges, <code>'in'</code> only follows inbound edges, and <code>'all'</code> follows all edges. This
parameter is ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="morphers_+3A_root">root</code></td>
<td>
<p>The root of the tree</p>
</td></tr>
<tr><td><code id="morphers_+3A_weights">weights</code></td>
<td>
<p>Optional edge weights for the calculations</p>
</td></tr>
<tr><td><code id="morphers_+3A_from">from</code>, <code id="morphers_+3A_to">to</code></td>
<td>
<p>The start and end node of the path</p>
</td></tr>
<tr><td><code id="morphers_+3A_unreachable">unreachable</code></td>
<td>
<p>Should the search jump to a node in a new component when
stuck.</p>
</td></tr>
<tr><td><code id="morphers_+3A_remove_multiples">remove_multiples</code></td>
<td>
<p>Should edges that run between the same nodes be
reduced to one</p>
</td></tr>
<tr><td><code id="morphers_+3A_remove_loops">remove_loops</code></td>
<td>
<p>Should edges that start and end at the same node be removed</p>
</td></tr>
<tr><td><code id="morphers_+3A_simplify">simplify</code></td>
<td>
<p>Should edges in the contracted graph be simplified? Defaults
to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="morphers_+3A_method">method</code></td>
<td>
<p>The clustering method to use. Either <code>'walktrap'</code>, <code>'leading_eigen'</code>, or <code>'edge_betweenness'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>tbl_graph</code>s
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>to_linegraph()</code>: Convert a graph to its line graph. When unmorphing node
data will be merged back into the original edge data. Edge data will be
ignored.
</p>
</li>
<li> <p><code>to_subgraph()</code>: Convert a graph to a single subgraph. <code>...</code> is evaluated
in the same manner as <code>filter</code>. When unmorphing all data in the subgraph
will get merged back.
</p>
</li>
<li> <p><code>to_subcomponent()</code>: Convert a graph to a single component containing the specified node
</p>
</li>
<li> <p><code>to_split()</code>: Convert a graph into a list of separate subgraphs. <code>...</code>
is evaluated in the same manner as <code>group_by</code>. When unmorphing all data in
the subgraphs will get merged back, but in the case of <code>split_by = 'edges'</code>
only the first instance of node data will be used (as the same node can be
present in multiple subgraphs).
</p>
</li>
<li> <p><code>to_components()</code>: Split a graph into its separate components. When
unmorphing all data in the subgraphs will get merged back.
</p>
</li>
<li> <p><code>to_largest_component()</code>: Create a new graph only consisting of it's largest
component. If multiple largest components exists, the one with containing the
node with the lowest index is chosen.
</p>
</li>
<li> <p><code>to_complement()</code>: Convert a graph into its complement. When unmorphing
only node data will get merged back.
</p>
</li>
<li> <p><code>to_local_neighborhood()</code>: Convert a graph into the local neighborhood around a
single node. When unmorphing all data will be merged back.
</p>
</li>
<li> <p><code>to_dominator_tree()</code>: Convert a graph into its dominator tree based on a
specific root. When unmorphing only node data will get merged back.
</p>
</li>
<li> <p><code>to_minimum_spanning_tree()</code>: Convert a graph into its minimum spanning tree/forest.
When unmorphing all data will get merged back.
</p>
</li>
<li> <p><code>to_random_spanning_tree()</code>: Convert a graph into a random spanning tree/forest. When
unmorphing all data will get merged back
</p>
</li>
<li> <p><code>to_shortest_path()</code>: Limit a graph to the shortest path between two nodes.
When unmorphing all data is merged back.
</p>
</li>
<li> <p><code>to_bfs_tree()</code>: Convert a graph into a breath-first search tree based on
a specific root. When unmorphing only node data is merged back.
</p>
</li>
<li> <p><code>to_dfs_tree()</code>: Convert a graph into a depth-first search tree based on
a specific root. When unmorphing only node data is merged back.
</p>
</li>
<li> <p><code>to_simple()</code>: Collapse parallel edges and remove loops in a graph.
When unmorphing all data will get merged back
</p>
</li>
<li> <p><code>to_contracted()</code>: Combine multiple nodes into one. <code>...</code>
is evaluated in the same manner as <code>group_by</code>. When unmorphing all
data will get merged back.
</p>
</li>
<li> <p><code>to_unfolded_tree()</code>: Unfold a graph to a tree or forest starting from
multiple roots (or one), potentially duplicating nodes and edges.
</p>
</li>
<li> <p><code>to_directed()</code>: Make a graph directed in the direction given by from and
to
</p>
</li>
<li> <p><code>to_undirected()</code>: Make a graph undirected
</p>
</li>
<li> <p><code>to_hierarchical_clusters()</code>: Convert a graph into a hierarchical clustering based on a grouping
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Compute only on a subgraph of every even node
create_notable('meredith') %&gt;%
  morph(to_subgraph, seq_len(graph_order()) %% 2 == 0) %&gt;%
  mutate(neighbour_count = centrality_degree()) %&gt;%
  unmorph()
</code></pre>

<hr>
<h2 id='mutate_as_tbl'>Base implementation of mutate</h2><span id='topic+mutate_as_tbl'></span>

<h3>Description</h3>

<p>This implementation of mutate is slightly faster than <code>mutate</code> at the expense
of the graph only being updated in the end. This means that graph algorithms
will not take changes happening during the mutate call into account.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_as_tbl(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutate_as_tbl_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl_graph</code> object</p>
</td></tr>
<tr><td><code id="mutate_as_tbl_+3A_...">...</code></td>
<td>
<p>columns to mutate</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of speed increase are rather small and in the ~1 millisecond per
mutateed column order, so for regular use this should not be a choice. The
operations not supported by <code>mutate_as_tbl</code> are e.g.
</p>
<div class="sourceCode"><pre>gr %&gt;%
  activate(nodes) %&gt;%
  mutate(weights = runif(10), degree = centrality_degree(weights))
</pre></div>
<p>as <code>weights</code> will only be made available in the graph at the end of the
mutate call.
</p>


<h3>Value</h3>

<p>A <code>tbl_graph</code> object
</p>

<hr>
<h2 id='node_measures'>Querying node measures</h2><span id='topic+node_measures'></span><span id='topic+node_eccentricity'></span><span id='topic+node_constraint'></span><span id='topic+node_coreness'></span><span id='topic+node_diversity'></span><span id='topic+node_efficiency'></span><span id='topic+node_bridging_score'></span><span id='topic+node_effective_network_size'></span><span id='topic+node_connectivity_impact'></span><span id='topic+node_closeness_impact'></span><span id='topic+node_fareness_impact'></span>

<h3>Description</h3>

<p>These functions are a collection of node measures that do not really fall
into the class of <a href="#topic+centrality">centrality</a> measures. For lack of a better place they are
collected under the <code style="white-space: pre;">&#8288;node_*&#8288;</code> umbrella of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_eccentricity(mode = "out")

node_constraint(weights = NULL)

node_coreness(mode = "out")

node_diversity(weights)

node_efficiency(weights = NULL, directed = TRUE, mode = "all")

node_bridging_score()

node_effective_network_size()

node_connectivity_impact()

node_closeness_impact()

node_fareness_impact()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="node_measures_+3A_mode">mode</code></td>
<td>
<p>How edges are treated. In <code>node_coreness()</code> it chooses which kind
of coreness measure to calculate. In <code>node_efficiency()</code> it defines how the
local neighborhood is created</p>
</td></tr>
<tr><td><code id="node_measures_+3A_weights">weights</code></td>
<td>
<p>The weights to use for each node during calculation</p>
</td></tr>
<tr><td><code id="node_measures_+3A_directed">directed</code></td>
<td>
<p>Should the graph be treated as a directed graph if it is in
fact directed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as the number of nodes in the
graph.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>node_eccentricity()</code>: measure the maximum shortest path to all other nodes in the graph
</p>
</li>
<li> <p><code>node_constraint()</code>: measures Burts constraint of the node. See <code><a href="igraph.html#topic+constraint">igraph::constraint()</a></code>
</p>
</li>
<li> <p><code>node_coreness()</code>: measures the coreness of each node. See <code><a href="igraph.html#topic+coreness">igraph::coreness()</a></code>
</p>
</li>
<li> <p><code>node_diversity()</code>: measures the diversity of the node. See <code><a href="igraph.html#topic+diversity">igraph::diversity()</a></code>
</p>
</li>
<li> <p><code>node_efficiency()</code>: measures the local efficiency around each node. See <code><a href="igraph.html#topic+global_efficiency">igraph::local_efficiency()</a></code>
</p>
</li>
<li> <p><code>node_bridging_score()</code>: measures Valente's Bridging measures for detecting structural bridges (<code>influenceR</code>)
</p>
</li>
<li> <p><code>node_effective_network_size()</code>: measures Burt's Effective Network Size indicating access to structural holes in the network (<code>influenceR</code>)
</p>
</li>
<li> <p><code>node_connectivity_impact()</code>: measures the impact on connectivity when removing the node (<code>NetSwan</code>)
</p>
</li>
<li> <p><code>node_closeness_impact()</code>: measures the impact on closeness when removing the node (<code>NetSwan</code>)
</p>
</li>
<li> <p><code>node_fareness_impact()</code>: measures the impact on fareness (distance between all node pairs) when removing the node (<code>NetSwan</code>)
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate Burt's Constraint for each node
create_notable('meredith') %&gt;%
  mutate(b_constraint = node_constraint())
</code></pre>

<hr>
<h2 id='node_rank'>Calculate node ranking</h2><span id='topic+node_rank'></span><span id='topic+node_rank_hclust'></span><span id='topic+node_rank_anneal'></span><span id='topic+node_rank_branch_bound'></span><span id='topic+node_rank_traveller'></span><span id='topic+node_rank_two'></span><span id='topic+node_rank_mds'></span><span id='topic+node_rank_leafsort'></span><span id='topic+node_rank_visual'></span><span id='topic+node_rank_spectral'></span><span id='topic+node_rank_spin_out'></span><span id='topic+node_rank_spin_in'></span><span id='topic+node_rank_quadratic'></span><span id='topic+node_rank_genetic'></span><span id='topic+node_rank_dendser'></span>

<h3>Description</h3>

<p>This set of functions tries to calculate a ranking of the nodes in a graph so
that nodes sharing certain topological traits are in proximity in the
resulting order. These functions are of great value when composing matrix
layouts and arc diagrams but could concievably be used for other things as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_rank_hclust(
  method = "average",
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_anneal(
  cool = 0.5,
  tmin = 1e-04,
  swap_to_inversion = 0.5,
  step_multiplier = 100,
  reps = 1,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_branch_bound(
  weighted_gradient = FALSE,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_traveller(
  method = "two_opt",
  ...,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_two(
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_mds(
  method = "cmdscale",
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_leafsort(
  method = "average",
  type = "OLO",
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_visual(
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_spectral(
  normalized = FALSE,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_spin_out(
  step = 25,
  nstart = 10,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_spin_in(
  step = 5,
  sigma = seq(20, 1, length.out = 10),
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_quadratic(
  criterion = "2SUM",
  reps = 1,
  step = 2 * graph_order(),
  step_multiplier = 1.1,
  temp_multiplier = 0.5,
  maxsteps = 50,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_genetic(
  ...,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_rank_dendser(
  ...,
  dist = "shortest",
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="node_rank_+3A_method">method</code></td>
<td>
<p>The method to use. See <em>Functions</em> section for reference</p>
</td></tr>
<tr><td><code id="node_rank_+3A_dist">dist</code></td>
<td>
<p>The algorithm to use for deriving a distance matrix from the
graph. One of
</p>

<ul>
<li> <p><code>"shortest"</code> (default): Use the shortest path between all nodes
</p>
</li>
<li> <p><code>"euclidean"</code>: Calculate the L2 norm on the adjacency matrix of the graph
</p>
</li>
<li> <p><code>"manhattan"</code>: Calculate the L1 norm on the adjacency matrix of the graph
</p>
</li>
<li> <p><code>"maximum"</code>: Calculate the supremum norm on the adjacenecy matrix of the graph
</p>
</li>
<li> <p><code>"canberra"</code>: Calculate a weighted manhattan distance on the adjacency matrix of the graph
</p>
</li>
<li> <p><code>"binary"</code>: Calculate distance as the proportion of agreement between nodes based on the adjacency matrix of the graph
</p>
</li></ul>

<p>or a function that takes a <code>tbl_graph</code> and return a <code>dist</code> object with a size
matching the order of the graph.</p>
</td></tr>
<tr><td><code id="node_rank_+3A_mode">mode</code></td>
<td>
<p>Which edges should be included in the distance calculation. For
distance measures based on the adjacency matrix, <code>'out' </code> will use the matrix
as is, <code>'in'</code> will use the transpose, and <code>'all'</code> will take the mean of the
two. Defaults to <code>'out'</code>. Ignored for undirected graphs.</p>
</td></tr>
<tr><td><code id="node_rank_+3A_weights">weights</code></td>
<td>
<p>An edge variable to use as weight for the shortest path
calculation if <code>dist = 'shortest'</code></p>
</td></tr>
<tr><td><code id="node_rank_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use for the shortest path calculation if
<code>dist = 'shortest'</code></p>
</td></tr>
<tr><td><code id="node_rank_+3A_cool">cool</code></td>
<td>
<p>cooling rate</p>
</td></tr>
<tr><td><code id="node_rank_+3A_tmin">tmin</code></td>
<td>
<p>minimum temperature</p>
</td></tr>
<tr><td><code id="node_rank_+3A_swap_to_inversion">swap_to_inversion</code></td>
<td>
<p>Proportion of swaps in local neighborhood search</p>
</td></tr>
<tr><td><code id="node_rank_+3A_step_multiplier">step_multiplier</code></td>
<td>
<p>Multiplication factor for number of iterations per temperature</p>
</td></tr>
<tr><td><code id="node_rank_+3A_reps">reps</code></td>
<td>
<p>Number of repeats with random initialisation</p>
</td></tr>
<tr><td><code id="node_rank_+3A_weighted_gradient">weighted_gradient</code></td>
<td>
<p>minimize the weighted gradient measure? Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="node_rank_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other algorithms. See <em>Functions</em> section for reference</p>
</td></tr>
<tr><td><code id="node_rank_+3A_type">type</code></td>
<td>
<p>The type of leaf reordering, either <code>'GW'</code> to use the &quot;GW&quot; method or <code>'OLO'</code> to use the &quot;OLO&quot; method (both in <code>seriation</code>)</p>
</td></tr>
<tr><td><code id="node_rank_+3A_normalized">normalized</code></td>
<td>
<p>Should the normalized laplacian of the similarity matrix be used?</p>
</td></tr>
<tr><td><code id="node_rank_+3A_step">step</code></td>
<td>
<p>The number iterations to run per initialisation</p>
</td></tr>
<tr><td><code id="node_rank_+3A_nstart">nstart</code></td>
<td>
<p>The number of random initialisations to perform</p>
</td></tr>
<tr><td><code id="node_rank_+3A_sigma">sigma</code></td>
<td>
<p>The variance around the diagonal to use for the weight matrix. Either a single number or a decreasing sequence.</p>
</td></tr>
<tr><td><code id="node_rank_+3A_criterion">criterion</code></td>
<td>
<p>The criterion to minimize. Either &quot;LS&quot; (Linear Seriation Problem), &quot;2SUM&quot; (2-Sum Problem), &quot;BAR&quot; (Banded Anti-Robinson form), or &quot;Inertia&quot; (Inertia criterion)</p>
</td></tr>
<tr><td><code id="node_rank_+3A_temp_multiplier">temp_multiplier</code></td>
<td>
<p>Temperature multiplication factor between 0 and 1</p>
</td></tr>
<tr><td><code id="node_rank_+3A_maxsteps">maxsteps</code></td>
<td>
<p>The upper bound of iterations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector giving the position of each node in the ranking
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>node_rank_hclust()</code>: Use hierarchical clustering to rank nodes (see <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> for allowed methods)
</p>
</li>
<li> <p><code>node_rank_anneal()</code>: Use simulated annealing based on the &quot;ARSA&quot; method in <code>seriation</code>
</p>
</li>
<li> <p><code>node_rank_branch_bound()</code>: Use branch and bounds strategy to minimize the gradient measure (only feasable for small graphs). Will use &quot;BBURCG&quot; or &quot;BBWRCG&quot; in <code>seriation</code> dependent on the <code>weighted_gradient</code> argument
</p>
</li>
<li> <p><code>node_rank_traveller()</code>: Minimize hamiltonian path length using a travelling salesperson solver. See the the <code>solve_TSP</code> function in <code>TSP</code> for an overview of possible arguments
</p>
</li>
<li> <p><code>node_rank_two()</code>: Use Rank-two ellipse seriation to rank the nodes. Uses &quot;R2E&quot; method in <code>seriation</code>
</p>
</li>
<li> <p><code>node_rank_mds()</code>: Rank by multidimensional scaling onto one dimension. <code>method = 'cmdscale'</code> will use the classic scaling from <code>stats</code>, <code>method = 'isoMDS'</code> will use <code>isoMDS</code> from <code>MASS</code>, and <code>method = 'sammon'</code> will use <code>sammon</code> from <code>MASS</code>
</p>
</li>
<li> <p><code>node_rank_leafsort()</code>: Minimize hamiltonian path length by reordering leafs in a hierarchical clustering. Method refers to the clustering algorithm (either 'average', 'single', 'complete', or 'ward')
</p>
</li>
<li> <p><code>node_rank_visual()</code>: Use Prim's algorithm to find a minimum spanning tree giving the rank. Uses the &quot;VAT&quot; method in <code>seriation</code>
</p>
</li>
<li> <p><code>node_rank_spectral()</code>: Minimize the 2-sum problem using a relaxation approach. Uses the &quot;Spectral&quot; or &quot;Spectral_norm&quot; methods in <code>seriation</code> depending on the value of the <code>norm</code> argument
</p>
</li>
<li> <p><code>node_rank_spin_out()</code>: Sorts points into neighborhoods by pushing large distances away from the diagonal. Uses the &quot;SPIN_STS&quot; method in <code>seriation</code>
</p>
</li>
<li> <p><code>node_rank_spin_in()</code>: Sorts points into neighborhoods by concentrating low distances around the diagonal. Uses the &quot;SPIN_NH&quot; method in <code>seriation</code>
</p>
</li>
<li> <p><code>node_rank_quadratic()</code>: Use quadratic assignment problem formulations to minimize criterions using simulated annealing. Uses the &quot;QAP_LS&quot;, &quot;QAP_2SUM&quot;, &quot;QAP_BAR&quot;, or &quot;QAP_Inertia&quot; methods from <code>seriation</code> dependant on the <code>criterion</code> argument
</p>
</li>
<li> <p><code>node_rank_genetic()</code>: Optimizes different criteria based on a genetic algorithm. Uses the &quot;GA&quot; method from <code>seriation</code>. See <code>register_GA</code> for an overview of relevant arguments
</p>
</li>
<li> <p><code>node_rank_dendser()</code>: Optimizes different criteria based on heuristic dendrogram seriation. Uses the &quot;DendSer&quot; method from <code>seriation</code>. See <code>register_DendSer</code> for an overview of relevant arguments
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- create_notable('zachary') %&gt;%
  mutate(rank = node_rank_hclust())

</code></pre>

<hr>
<h2 id='node_topology'>Node properties related to the graph topology</h2><span id='topic+node_topology'></span><span id='topic+node_dominator'></span><span id='topic+node_topo_order'></span>

<h3>Description</h3>

<p>These functions calculate properties that are dependent on the overall
topology of the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_dominator(root, mode = "out")

node_topo_order(mode = "out")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="node_topology_+3A_root">root</code></td>
<td>
<p>The node to start the dominator search from</p>
</td></tr>
<tr><td><code id="node_topology_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed. Either <code>'in'</code> or <code>'out'</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as the number of nodes in the graph
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>node_dominator()</code>: Get the immediate dominator of each node. Wraps <code><a href="igraph.html#topic+dominator_tree">igraph::dominator_tree()</a></code>.
</p>
</li>
<li> <p><code>node_topo_order()</code>: Get the topological order of nodes in a DAG. Wraps <code><a href="igraph.html#topic+topo_sort">igraph::topo_sort()</a></code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Sort a graph based on its topological order
create_tree(10, 2) %&gt;%
  arrange(sample(graph_order())) %&gt;%
  mutate(old_ind = seq_len(graph_order())) %&gt;%
  arrange(node_topo_order())
</code></pre>

<hr>
<h2 id='node_types'>Querying node types</h2><span id='topic+node_types'></span><span id='topic+node_is_cut'></span><span id='topic+node_is_root'></span><span id='topic+node_is_leaf'></span><span id='topic+node_is_sink'></span><span id='topic+node_is_source'></span><span id='topic+node_is_isolated'></span><span id='topic+node_is_universal'></span><span id='topic+node_is_simplical'></span><span id='topic+node_is_center'></span><span id='topic+node_is_adjacent'></span><span id='topic+node_is_keyplayer'></span><span id='topic+node_is_connected'></span>

<h3>Description</h3>

<p>These functions all lets the user query whether each node is of a certain
type. All of the functions returns a logical vector indicating whether the
node is of the type in question. Do note that the types are not mutually
exclusive and that nodes can thus be of multiple types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_is_cut()

node_is_root()

node_is_leaf()

node_is_sink()

node_is_source()

node_is_isolated()

node_is_universal(mode = "out")

node_is_simplical(mode = "out")

node_is_center(mode = "out")

node_is_adjacent(to, mode = "all", include_to = TRUE)

node_is_keyplayer(k, p = 0, tol = 1e-04, maxsec = 120, roundsec = 30)

node_is_connected(nodes, mode = "all", any = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="node_types_+3A_mode">mode</code></td>
<td>
<p>The way edges should be followed in the case of directed graphs.</p>
</td></tr>
<tr><td><code id="node_types_+3A_to">to</code></td>
<td>
<p>The nodes to test for adjacency to</p>
</td></tr>
<tr><td><code id="node_types_+3A_include_to">include_to</code></td>
<td>
<p>Should the nodes in <code>to</code> be marked as adjacent as well</p>
</td></tr>
<tr><td><code id="node_types_+3A_k">k</code></td>
<td>
<p>The number of keyplayers to identify</p>
</td></tr>
<tr><td><code id="node_types_+3A_p">p</code></td>
<td>
<p>The probability to accept a lesser state</p>
</td></tr>
<tr><td><code id="node_types_+3A_tol">tol</code></td>
<td>
<p>Optimisation tolerance, below which the optimisation will stop</p>
</td></tr>
<tr><td><code id="node_types_+3A_maxsec">maxsec</code></td>
<td>
<p>The total computation budget for the optimization, in seconds</p>
</td></tr>
<tr><td><code id="node_types_+3A_roundsec">roundsec</code></td>
<td>
<p>Number of seconds in between synchronizing workers' answer</p>
</td></tr>
<tr><td><code id="node_types_+3A_nodes">nodes</code></td>
<td>
<p>The set of nodes to test connectivity to. Can be a list to use
different sets for different nodes. If a list it will be recycled as
necessary.</p>
</td></tr>
<tr><td><code id="node_types_+3A_any">any</code></td>
<td>
<p>Logical. If <code>TRUE</code> the node only needs to be connected to a single
node in the set for it to return <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as the number of nodes in the
graph.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>node_is_cut()</code>: is the node a cut node (articaultion node)
</p>
</li>
<li> <p><code>node_is_root()</code>: is the node a root in a tree
</p>
</li>
<li> <p><code>node_is_leaf()</code>: is the node a leaf in a tree
</p>
</li>
<li> <p><code>node_is_sink()</code>: does the node only have incomming edges
</p>
</li>
<li> <p><code>node_is_source()</code>: does the node only have outgoing edges
</p>
</li>
<li> <p><code>node_is_isolated()</code>: is the node unconnected
</p>
</li>
<li> <p><code>node_is_universal()</code>: is the node connected to all other nodes in the graph
</p>
</li>
<li> <p><code>node_is_simplical()</code>: are all the neighbors of the node connected
</p>
</li>
<li> <p><code>node_is_center()</code>: does the node have the minimal eccentricity in the graph
</p>
</li>
<li> <p><code>node_is_adjacent()</code>: is a node adjacent to any of the nodes given in <code>to</code>
</p>
</li>
<li> <p><code>node_is_keyplayer()</code>: Is a node part of the keyplayers in the graph (<code>influenceR</code>)
</p>
</li>
<li> <p><code>node_is_connected()</code>: Is a node connected to all (or any) nodes in a set
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Find the root and leafs in a tree
create_tree(40, 2) %&gt;%
  mutate(root = node_is_root(), leaf = node_is_leaf())
</code></pre>

<hr>
<h2 id='pair_measures'>Calculate node pair properties</h2><span id='topic+pair_measures'></span><span id='topic+node_adhesion_to'></span><span id='topic+node_adhesion_from'></span><span id='topic+node_cohesion_to'></span><span id='topic+node_cohesion_from'></span><span id='topic+node_distance_to'></span><span id='topic+node_distance_from'></span><span id='topic+node_cocitation_with'></span><span id='topic+node_bibcoupling_with'></span><span id='topic+node_similarity_with'></span><span id='topic+node_max_flow_to'></span><span id='topic+node_max_flow_from'></span>

<h3>Description</h3>

<p>This set of functions can be used for calculations that involve node pairs.
If the calculateable measure is not symmetric the function will come in two
flavours, differentiated with <code style="white-space: pre;">&#8288;_to&#8288;</code>/<code style="white-space: pre;">&#8288;_from&#8288;</code> suffix. The <code style="white-space: pre;">&#8288;*_to()&#8288;</code> functions
will take the provided node indexes as the target node (recycling if
necessary). For the <code style="white-space: pre;">&#8288;*_from()&#8288;</code> functions the provided nodes are taken as
the source. As for the other wrappers provided, they are intended
for use inside the <code>tidygraph</code> framework and it is thus not necessary to
supply the graph being computed on as the context is known.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_adhesion_to(nodes)

node_adhesion_from(nodes)

node_cohesion_to(nodes)

node_cohesion_from(nodes)

node_distance_to(nodes, mode = "out", weights = NULL, algorithm = "automatic")

node_distance_from(
  nodes,
  mode = "out",
  weights = NULL,
  algorithm = "automatic"
)

node_cocitation_with(nodes)

node_bibcoupling_with(nodes)

node_similarity_with(nodes, mode = "out", loops = FALSE, method = "jaccard")

node_max_flow_to(nodes, capacity = NULL)

node_max_flow_from(nodes, capacity = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pair_measures_+3A_nodes">nodes</code></td>
<td>
<p>The other part of the node pair (the first part is the node
defined by the row). Recycled if necessary.</p>
</td></tr>
<tr><td><code id="pair_measures_+3A_mode">mode</code></td>
<td>
<p>How should edges be followed? If <code>'all'</code> all edges are
considered, if <code>'in'</code> only inbound edges are considered, and if <code>'out'</code> only
outbound edges are considered</p>
</td></tr>
<tr><td><code id="pair_measures_+3A_weights">weights</code></td>
<td>
<p>The weights to use for calculation</p>
</td></tr>
<tr><td><code id="pair_measures_+3A_algorithm">algorithm</code></td>
<td>
<p>The distance algorithms to use. By default it will try to
select the fastest suitable algorithm. Possible values are <code>"automatic"</code>,
<code>"unweighted"</code>, <code>"dijkstra"</code>, <code>"bellman-ford"</code>, and <code>"johnson"</code></p>
</td></tr>
<tr><td><code id="pair_measures_+3A_loops">loops</code></td>
<td>
<p>Should loop edges be considered</p>
</td></tr>
<tr><td><code id="pair_measures_+3A_method">method</code></td>
<td>
<p>The similarity measure to calculate. Possible values are:
<code>"jaccard"</code>, <code>"dice"</code>, and <code>"invlogweighted"</code></p>
</td></tr>
<tr><td><code id="pair_measures_+3A_capacity">capacity</code></td>
<td>
<p>The edge capacity to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as the number of nodes in the
graph
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>node_adhesion_to()</code>: Calculate the adhesion to the specified node. Wraps <code><a href="igraph.html#topic+edge_connectivity">igraph::edge_connectivity()</a></code>
</p>
</li>
<li> <p><code>node_adhesion_from()</code>: Calculate the adhesion from the specified node. Wraps <code><a href="igraph.html#topic+edge_connectivity">igraph::edge_connectivity()</a></code>
</p>
</li>
<li> <p><code>node_cohesion_to()</code>: Calculate the cohesion to the specified node. Wraps <code><a href="igraph.html#topic+vertex_connectivity">igraph::vertex_connectivity()</a></code>
</p>
</li>
<li> <p><code>node_cohesion_from()</code>: Calculate the cohesion from the specified node. Wraps <code><a href="igraph.html#topic+vertex_connectivity">igraph::vertex_connectivity()</a></code>
</p>
</li>
<li> <p><code>node_distance_to()</code>: Calculate various distance metrics between node pairs. Wraps <code><a href="igraph.html#topic+distances">igraph::distances()</a></code>
</p>
</li>
<li> <p><code>node_distance_from()</code>: Calculate various distance metrics between node pairs. Wraps <code><a href="igraph.html#topic+distances">igraph::distances()</a></code>
</p>
</li>
<li> <p><code>node_cocitation_with()</code>: Calculate node pair cocitation count. Wraps <code><a href="igraph.html#topic+cocitation">igraph::cocitation()</a></code>
</p>
</li>
<li> <p><code>node_bibcoupling_with()</code>: Calculate node pair bibliographic coupling. Wraps <code><a href="igraph.html#topic+cocitation">igraph::bibcoupling()</a></code>
</p>
</li>
<li> <p><code>node_similarity_with()</code>: Calculate various node pair similarity measures. Wraps <code><a href="igraph.html#topic+similarity">igraph::similarity()</a></code>
</p>
</li>
<li> <p><code>node_max_flow_to()</code>: Calculate the maximum flow to a node. Wraps <code><a href="igraph.html#topic+max_flow">igraph::max_flow()</a></code>
</p>
</li>
<li> <p><code>node_max_flow_from()</code>: Calculate the maximum flow from a node. Wraps <code><a href="igraph.html#topic+max_flow">igraph::max_flow()</a></code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate the distance to the center node
create_notable('meredith') %&gt;%
  mutate(dist_to_center = node_distance_to(node_is_center()))
</code></pre>

<hr>
<h2 id='random_walk_rank'>Perform a random walk on the graph and return encounter rank</h2><span id='topic+random_walk_rank'></span>

<h3>Description</h3>

<p>A random walk is a traversal of the graph starting from a node and going a
number of steps by picking an edge at random (potentially weighted).
<code>random_walk()</code> can be called both when nodes and edges are active and will
adapt to return a value fitting to the currently active part. As the
walk order cannot be directly encoded in the graph the return value is a list
giving a vector of positions along the walk of each node or edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_walk_rank(n, root = NULL, mode = "out", weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="random_walk_rank_+3A_n">n</code></td>
<td>
<p>The number of steps to perform. If the walk gets stuck before
reaching this number the walk is terminated</p>
</td></tr>
<tr><td><code id="random_walk_rank_+3A_root">root</code></td>
<td>
<p>The node to start the walk at. If <code>NULL</code> a random node will be
used</p>
</td></tr>
<tr><td><code id="random_walk_rank_+3A_mode">mode</code></td>
<td>
<p>How edges are followed in the search if the graph is directed.
<code>"out"</code> only follows outbound edges, <code>"in"</code> only follows inbound edges, and
<code>"all"</code> or <code>"total"</code> follows all edges. This is ignored for undirected
graphs.</p>
</td></tr>
<tr><td><code id="random_walk_rank_+3A_weights">weights</code></td>
<td>
<p>The weights to use for edges when selecting the next step of
the walk. Currently only used when edges are active</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an integer vector for each node or edge (depending on
what is active) each element encode the time the node/edge is encountered
along the walk
</p>


<h3>Examples</h3>

<pre><code class='language-R'>graph &lt;- create_notable("zachary")

# Random walk returning node order
graph |&gt;
  mutate(walk_rank = random_walk_rank(200))

# Rank edges instead
graph |&gt;
  activate(edges) |&gt;
  mutate(walk_rank = random_walk_rank(200))

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+arrange'></span><span id='topic+distinct'></span><span id='topic+filter'></span><span id='topic+top_n'></span><span id='topic+group_by'></span><span id='topic+ungroup'></span><span id='topic+group_size'></span><span id='topic+n_groups'></span><span id='topic+groups'></span><span id='topic+group_vars'></span><span id='topic+group_data'></span><span id='topic+group_indices'></span><span id='topic+group_keys'></span><span id='topic+as.igraph'></span><span id='topic+left_join'></span><span id='topic+right_join'></span><span id='topic+inner_join'></span><span id='topic+full_join'></span><span id='topic+semi_join'></span><span id='topic+anti_join'></span><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+mutate_all'></span><span id='topic+mutate_at'></span><span id='topic+n'></span><span id='topic+pull'></span><span id='topic+rename'></span><span id='topic+sample_frac'></span><span id='topic+sample_n'></span><span id='topic+select'></span><span id='topic+contains'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span><span id='topic+slice'></span><span id='topic+slice_head'></span><span id='topic+slice_tail'></span><span id='topic+slice_min'></span><span id='topic+slice_max'></span><span id='topic+slice_sample'></span><span id='topic+tbl_vars'></span><span id='topic+as_tibble'></span><span id='topic++25+3E+25'></span><span id='topic+replace_na'></span><span id='topic+drop_na'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter-joins">anti_join</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+reexports">contains</a></code>, <code><a href="dplyr.html#topic+distinct">distinct</a></code>, <code><a href="dplyr.html#topic+reexports">ends_with</a></code>, <code><a href="dplyr.html#topic+reexports">everything</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate-joins">full_join</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+group_data">group_data</a></code>, <code><a href="dplyr.html#topic+group_data">group_indices</a></code>, <code><a href="dplyr.html#topic+group_data">group_keys</a></code>, <code><a href="dplyr.html#topic+group_data">group_size</a></code>, <code><a href="dplyr.html#topic+group_data">group_vars</a></code>, <code><a href="dplyr.html#topic+group_data">groups</a></code>, <code><a href="dplyr.html#topic+mutate-joins">inner_join</a></code>, <code><a href="dplyr.html#topic+mutate-joins">left_join</a></code>, <code><a href="dplyr.html#topic+reexports">matches</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+mutate_all">mutate_all</a></code>, <code><a href="dplyr.html#topic+mutate_all">mutate_at</a></code>, <code><a href="dplyr.html#topic+context">n</a></code>, <code><a href="dplyr.html#topic+group_data">n_groups</a></code>, <code><a href="dplyr.html#topic+reexports">num_range</a></code>, <code><a href="dplyr.html#topic+reexports">one_of</a></code>, <code><a href="dplyr.html#topic+pull">pull</a></code>, <code><a href="dplyr.html#topic+rename">rename</a></code>, <code><a href="dplyr.html#topic+mutate-joins">right_join</a></code>, <code><a href="dplyr.html#topic+sample_n">sample_frac</a></code>, <code><a href="dplyr.html#topic+sample_n">sample_n</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+filter-joins">semi_join</a></code>, <code><a href="dplyr.html#topic+slice">slice</a></code>, <code><a href="dplyr.html#topic+slice">slice_head</a></code>, <code><a href="dplyr.html#topic+slice">slice_max</a></code>, <code><a href="dplyr.html#topic+slice">slice_min</a></code>, <code><a href="dplyr.html#topic+slice">slice_sample</a></code>, <code><a href="dplyr.html#topic+slice">slice_tail</a></code>, <code><a href="dplyr.html#topic+reexports">starts_with</a></code>, <code><a href="dplyr.html#topic+tbl_vars">tbl_vars</a></code>, <code><a href="dplyr.html#topic+top_n">top_n</a></code>, <code><a href="dplyr.html#topic+transmute">transmute</a></code>, <code><a href="dplyr.html#topic+group_by">ungroup</a></code></p>
</dd>
<dt>igraph</dt><dd><p><code><a href="igraph.html#topic+as.igraph">as.igraph</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+drop_na">drop_na</a></code>, <code><a href="tidyr.html#topic+replace_na">replace_na</a></code></p>
</dd>
</dl>

<hr>
<h2 id='reroute'>Change terminal nodes of edges</h2><span id='topic+reroute'></span>

<h3>Description</h3>

<p>The reroute verb lets you change the beginning and end node of edges by
specifying the new indexes of the start and/or end node(s). Optionally only
a subset of the edges can be rerouted using the subset argument, which should
be an expression that are to be evaluated in the context of the edge data and
should return an index compliant vector (either logical or integer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reroute(.data, from = NULL, to = NULL, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reroute_+3A_.data">.data</code></td>
<td>
<p>A tbl_graph or morphed_tbl_graph object. grouped_tbl_graph will
be ungrouped prior to rerouting</p>
</td></tr>
<tr><td><code id="reroute_+3A_from">from</code>, <code id="reroute_+3A_to">to</code></td>
<td>
<p>The new indexes of the terminal nodes. If <code>NULL</code> nothing will
be changed</p>
</td></tr>
<tr><td><code id="reroute_+3A_subset">subset</code></td>
<td>
<p>An expression evaluating to an indexing vector in the context
of the edge data. If <code>NULL</code> it will use focused edges if available or all
edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as .data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Switch direction of edges
create_notable('meredith') %&gt;%
  activate(edges) %&gt;%
  reroute(from = to, to = from)

# Using subset
create_notable('meredith') %&gt;%
  activate(edges) %&gt;%
  reroute(from = 1, subset = to &gt; 10)
</code></pre>

<hr>
<h2 id='sampling_games'>Graph games based on direct sampling</h2><span id='topic+sampling_games'></span><span id='topic+play_degree'></span><span id='topic+play_dotprod'></span><span id='topic+play_fitness'></span><span id='topic+play_fitness_power'></span><span id='topic+play_gnm'></span><span id='topic+play_gnp'></span><span id='topic+play_geometry'></span><span id='topic+play_erdos_renyi'></span>

<h3>Description</h3>

<p>This set of graph games creates graphs directly through sampling of different
attributes, topologies, etc. The nature of their algorithm is described in
detail at the linked igraph documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play_degree(out_degree, in_degree = NULL, method = "simple")

play_dotprod(position, directed = TRUE)

play_fitness(m, out_fit, in_fit = NULL, loops = FALSE, multiple = FALSE)

play_fitness_power(
  n,
  m,
  out_exp,
  in_exp = -1,
  loops = FALSE,
  multiple = FALSE,
  correct = TRUE
)

play_gnm(n, m, directed = TRUE, loops = FALSE)

play_gnp(n, p, directed = TRUE, loops = FALSE)

play_geometry(n, radius, torus = FALSE)

play_erdos_renyi(n, p, m, directed = TRUE, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampling_games_+3A_out_degree">out_degree</code>, <code id="sampling_games_+3A_in_degree">in_degree</code></td>
<td>
<p>The degrees of each node in the graph</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_method">method</code></td>
<td>
<p>The algorithm to use for the generation. Either <code>'simple'</code>,
<code>'vl'</code>, or <code>'simple.no.multiple'</code></p>
</td></tr>
<tr><td><code id="sampling_games_+3A_position">position</code></td>
<td>
<p>The latent position of each node by column.</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_directed">directed</code></td>
<td>
<p>Should the resulting graph be directed</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_m">m</code></td>
<td>
<p>The number of edges in the graph</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_out_fit">out_fit</code>, <code id="sampling_games_+3A_in_fit">in_fit</code></td>
<td>
<p>The fitness of each node</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_loops">loops</code></td>
<td>
<p>Are loop edges allowed</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_multiple">multiple</code></td>
<td>
<p>Are multiple edges allowed</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_n">n</code></td>
<td>
<p>The number of nodes in the graph.</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_out_exp">out_exp</code>, <code id="sampling_games_+3A_in_exp">in_exp</code></td>
<td>
<p>Power law exponent of degree distribution</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_correct">correct</code></td>
<td>
<p>Use finite size correction</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_p">p</code></td>
<td>
<p>The probabilty of an edge occuring</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_radius">radius</code></td>
<td>
<p>The radius within which vertices are connected</p>
</td></tr>
<tr><td><code id="sampling_games_+3A_torus">torus</code></td>
<td>
<p>Should the vertices be distributed on a torus instead of a plane</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>play_degree()</code>: Create graphs based on the given node degrees. See
<code><a href="igraph.html#topic+sample_degseq">igraph::sample_degseq()</a></code>
</p>
</li>
<li> <p><code>play_dotprod()</code>: Create graphs with link probability given by the
dot product of the latent position of termintating nodes. See
<code><a href="igraph.html#topic+sample_dot_product">igraph::sample_dot_product()</a></code>
</p>
</li>
<li> <p><code>play_fitness()</code>: Create graphs where edge probabilities are
proportional to terminal node fitness scores. See <code><a href="igraph.html#topic+sample_fitness">igraph::sample_fitness()</a></code>
</p>
</li>
<li> <p><code>play_fitness_power()</code>: Create graphs with an expected power-law degree
distribution. See <code><a href="igraph.html#topic+sample_fitness_pl">igraph::sample_fitness_pl()</a></code>
</p>
</li>
<li> <p><code>play_gnm()</code>: Create graphs with a fixed edge count. See
<code><a href="igraph.html#topic+sample_gnm">igraph::sample_gnm()</a></code>
</p>
</li>
<li> <p><code>play_gnp()</code>: Create graphs with a fixed edge probability. See
<code><a href="igraph.html#topic+sample_gnp">igraph::sample_gnp()</a></code>
</p>
</li>
<li> <p><code>play_geometry()</code>: Create graphs by positioning nodes on a plane or
torus and connecting nearby ones. See <code><a href="igraph.html#topic+sample_grg">igraph::sample_grg()</a></code>
</p>
</li>
<li> <p><code>play_erdos_renyi()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Create graphs
with a fixed edge probability or count. See <code><a href="igraph.html#topic+sample_gnp">igraph::sample_gnp()</a></code> and
<code><a href="igraph.html#topic+sample_gnm">igraph::sample_gnm()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p>Other graph games: 
<code><a href="#topic+component_games">component_games</a></code>,
<code><a href="#topic+evolution_games">evolution_games</a></code>,
<code><a href="#topic+type_games">type_games</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(play_erdos_renyi(20, 0.3))
</code></pre>

<hr>
<h2 id='search_graph'>Search a graph with depth first and breath first</h2><span id='topic+search_graph'></span><span id='topic+bfs_rank'></span><span id='topic+bfs_parent'></span><span id='topic+bfs_before'></span><span id='topic+bfs_after'></span><span id='topic+bfs_dist'></span><span id='topic+dfs_rank'></span><span id='topic+dfs_rank_out'></span><span id='topic+dfs_parent'></span><span id='topic+dfs_dist'></span>

<h3>Description</h3>

<p>These functions wraps the <code><a href="igraph.html#topic+bfs">igraph::bfs()</a></code> and <code><a href="igraph.html#topic+dfs">igraph::dfs()</a></code> functions to
provide a consistent return value that can be used in <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>
calls. Each function returns an integer vector with values matching the order
of the nodes in the graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfs_rank(root, mode = "out", unreachable = FALSE)

bfs_parent(root, mode = "out", unreachable = FALSE)

bfs_before(root, mode = "out", unreachable = FALSE)

bfs_after(root, mode = "out", unreachable = FALSE)

bfs_dist(root, mode = "out", unreachable = FALSE)

dfs_rank(root, mode = "out", unreachable = FALSE)

dfs_rank_out(root, mode = "out", unreachable = FALSE)

dfs_parent(root, mode = "out", unreachable = FALSE)

dfs_dist(root, mode = "out", unreachable = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="search_graph_+3A_root">root</code></td>
<td>
<p>The node to start the search from</p>
</td></tr>
<tr><td><code id="search_graph_+3A_mode">mode</code></td>
<td>
<p>How edges are followed in the search if the graph is directed.
<code>"out"</code> only follows outbound edges, <code>"in"</code> only follows inbound edges, and
<code>"all"</code> or <code>"total"</code> follows all edges. This is ignored for undirected
graphs.</p>
</td></tr>
<tr><td><code id="search_graph_+3A_unreachable">unreachable</code></td>
<td>
<p>Should the search jump to a new component if the search is
terminated without all nodes being visited? Default to <code>FALSE</code> (only reach
connected nodes).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector, the nature of which is determined by the function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bfs_rank()</code>: Get the succession in which the nodes are visited in a breath first search
</p>
</li>
<li> <p><code>bfs_parent()</code>: Get the nodes from which each node is visited in a breath first search
</p>
</li>
<li> <p><code>bfs_before()</code>: Get the node that was visited before each node in a breath first search
</p>
</li>
<li> <p><code>bfs_after()</code>: Get the node that was visited after each node in a breath first search
</p>
</li>
<li> <p><code>bfs_dist()</code>: Get the number of nodes between the root and each node in a breath first search
</p>
</li>
<li> <p><code>dfs_rank()</code>: Get the succession in which the nodes are visited in a depth first search
</p>
</li>
<li> <p><code>dfs_rank_out()</code>: Get the succession in which each nodes subtree is completed in a depth first search
</p>
</li>
<li> <p><code>dfs_parent()</code>: Get the nodes from which each node is visited in a depth first search
</p>
</li>
<li> <p><code>dfs_dist()</code>: Get the number of nodes between the root and each node in a depth first search
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Get the depth of each node in a tree
create_tree(10, 2) %&gt;%
  activate(nodes) %&gt;%
  mutate(depth = bfs_dist(root = 1))

# Reorder nodes based on a depth first search from node 3
create_notable('franklin') %&gt;%
  activate(nodes) %&gt;%
  mutate(order = dfs_rank(root = 3)) %&gt;%
  arrange(order)

</code></pre>

<hr>
<h2 id='type_games'>Graph games based on different node types</h2><span id='topic+type_games'></span><span id='topic+play_preference'></span><span id='topic+play_preference_asym'></span><span id='topic+play_bipartite'></span><span id='topic+play_traits'></span><span id='topic+play_citation_type'></span>

<h3>Description</h3>

<p>This set of games are build around different types of nodes and simulating
their interaction. The nature of their algorithm is described in
detail at the linked igraph documentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play_preference(
  n,
  n_types,
  p_type = rep(1, n_types),
  p_pref = matrix(1, n_types, n_types),
  fixed = FALSE,
  directed = TRUE,
  loops = FALSE
)

play_preference_asym(
  n,
  n_types,
  p_type = matrix(1, n_types, n_types),
  p_pref = matrix(1, n_types, n_types),
  loops = FALSE
)

play_bipartite(n1, n2, p, m, directed = TRUE, mode = "out")

play_traits(
  n,
  n_types,
  growth = 1,
  p_type = rep(1, n_types),
  p_pref = matrix(1, n_types, n_types),
  callaway = TRUE,
  directed = TRUE
)

play_citation_type(
  n,
  growth,
  types = rep(0, n),
  p_pref = rep(1, length(unique(types))),
  directed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type_games_+3A_n">n</code>, <code id="type_games_+3A_n1">n1</code>, <code id="type_games_+3A_n2">n2</code></td>
<td>
<p>The number of nodes in the graph. For bipartite graphs <code>n1</code>
and <code>n2</code> specifies the number of nodes of each type.</p>
</td></tr>
<tr><td><code id="type_games_+3A_n_types">n_types</code></td>
<td>
<p>The number of different node types in the graph</p>
</td></tr>
<tr><td><code id="type_games_+3A_p_type">p_type</code></td>
<td>
<p>The probability that a node will be the given type. Either a
vector or a matrix, depending on the game</p>
</td></tr>
<tr><td><code id="type_games_+3A_p_pref">p_pref</code></td>
<td>
<p>The probability that an edge will be made to a type. Either a
vector or a matrix, depending on the game</p>
</td></tr>
<tr><td><code id="type_games_+3A_fixed">fixed</code></td>
<td>
<p>Should n_types be understood as a fixed number of nodes for each
type rather than as a probability</p>
</td></tr>
<tr><td><code id="type_games_+3A_directed">directed</code></td>
<td>
<p>Should the resulting graph be directed</p>
</td></tr>
<tr><td><code id="type_games_+3A_loops">loops</code></td>
<td>
<p>Are loop edges allowed</p>
</td></tr>
<tr><td><code id="type_games_+3A_p">p</code></td>
<td>
<p>The probabilty of an edge occuring</p>
</td></tr>
<tr><td><code id="type_games_+3A_m">m</code></td>
<td>
<p>The number of edges in the graph</p>
</td></tr>
<tr><td><code id="type_games_+3A_mode">mode</code></td>
<td>
<p>The flow direction of edges</p>
</td></tr>
<tr><td><code id="type_games_+3A_growth">growth</code></td>
<td>
<p>The number of edges added at each iteration</p>
</td></tr>
<tr><td><code id="type_games_+3A_callaway">callaway</code></td>
<td>
<p>Use the callaway version of the trait based game</p>
</td></tr>
<tr><td><code id="type_games_+3A_types">types</code></td>
<td>
<p>The type of each node in the graph, enumerated from 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_graph object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>play_preference()</code>: Create graphs by linking nodes of different types
based on a defined probability. See <code><a href="igraph.html#topic+sample_pref">igraph::sample_pref()</a></code>
</p>
</li>
<li> <p><code>play_preference_asym()</code>: Create graphs by linking nodes of different types
based on an asymmetric probability. See <code><a href="igraph.html#topic+sample_pref">igraph::sample_asym_pref()</a></code>
</p>
</li>
<li> <p><code>play_bipartite()</code>: Create bipartite graphs of fixed size and edge count
or probability. See <code><a href="igraph.html#topic+sample_bipartite">igraph::sample_bipartite()</a></code>
</p>
</li>
<li> <p><code>play_traits()</code>: Create graphs by evolving a graph with type based edge
probabilities. See <code><a href="igraph.html#topic+sample_traits_callaway">igraph::sample_traits()</a></code> and
<code><a href="igraph.html#topic+sample_traits_callaway">igraph::sample_traits_callaway()</a></code>
</p>
</li>
<li> <p><code>play_citation_type()</code>: Create citation graphs by evolving with type based
linking probability. See <code><a href="igraph.html#topic+sample_last_cit">igraph::sample_cit_types()</a></code> and
<code><a href="igraph.html#topic+sample_last_cit">igraph::sample_cit_cit_types()</a></code>
</p>
</li></ul>


<h3>See Also</h3>

<p>Other graph games: 
<code><a href="#topic+component_games">component_games</a></code>,
<code><a href="#topic+evolution_games">evolution_games</a></code>,
<code><a href="#topic+sampling_games">sampling_games</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(play_bipartite(20, 30, 0.4))

</code></pre>

<hr>
<h2 id='with_graph'>Evaluate a tidygraph algorithm in the context of a graph</h2><span id='topic+with_graph'></span>

<h3>Description</h3>

<p>All tidygraph algorithms are meant to be called inside tidygraph verbs such
as <code>mutate()</code>, where the graph that is currently being worked on is known and
thus not needed as an argument to the function. In the off chance that you
want to use an algorithm outside of the tidygraph framework you can use
<code>with_graph()</code> to set the graph context temporarily while the algorithm is
being evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>with_graph(graph, expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="with_graph_+3A_graph">graph</code></td>
<td>
<p>The <code>tbl_graph</code> to use as context</p>
</td></tr>
<tr><td><code id="with_graph_+3A_expr">expr</code></td>
<td>
<p>The expression to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of <code>expr</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gr &lt;- play_gnp(10, 0.3)

with_graph(gr, centrality_degree())

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
