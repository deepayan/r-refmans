<!DOCTYPE html><html><head><title>Help for package overlap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {overlap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bootstrap confidence intervals'>
<p>Confidence interval calculation from bootstrap samples.</p></a></li>
<li><a href='#bootstrap functions'>
<p>Functions to generate bootstrap estimates of overlap</p></a></li>
<li><a href='#densityFit'>
<p>Fits von Mises kernel density to time-of-day data.</p></a></li>
<li><a href='#densityPlot'>
<p>Plot fitted kernel densities</p></a></li>
<li><a href='#Example data'>
<p>Times of 'capture' of large mammals</p></a></li>
<li><a href='#getBandWidth'>
<p>Optimal bandwidth calculation</p></a></li>
<li><a href='#overlap-package'>
<p>Functions to estimate overlap of temporal activity patterns of animals</p></a></li>
<li><a href='#overlapEst'>
<p>Estimates of coefficient of overlapping</p></a></li>
<li><a href='#overlapPlot'>
<p>Plot overlapping kernel densities</p></a></li>
<li><a href='#overlapTrue'>
<p>Calculates the true coefficient of overlapping between two distributions.</p></a></li>
<li><a href='#Simulated call data'>
<p>Simulated data for bird calls influenced by sunrise</p></a></li>
<li><a href='#Simulated data'>
<p>Simulated data for diel activity patterns</p></a></li>
<li><a href='#sunTime'>
<p>Convert clock times to sun times</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimates of Coefficient of Overlapping for Animal Activity
Patterns</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-16</td>
</tr>
<tr>
<td>Depends:</td>
<td>suntools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sp</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to fit kernel density functions to
    data on temporal activity patterns of animals; estimate coefficients
    of overlapping of densities for two species; and calculate bootstrap
    estimates of confidence intervals. As in Ridout and Linkie (2009) &lt;<a href="https://doi.org/10.1198%2Fjabes.2009.08038">doi:10.1198/jabes.2009.08038</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-19 08:56:02 UTC; &lt;ef&gt;&lt;82&gt;&lt;9d&gt; &lt;d1&gt;&lt;8f&gt;&lt;d0&gt;&lt;be&gt;&lt;d1&gt;&lt;95&gt;&lt;d1&gt;&lt;94&gt; &lt;ce&gt;&lt;b1&gt;&lt;d0&gt;&lt;bc&gt;&lt;ce&gt;&lt;b1&gt;&lt;d0&gt;&lt;b3&gt;&lt;ce&gt;&lt;b1&gt;&lt;ce&gt;&lt;b7&gt;&lt;cf&gt;&lt;84&gt;&lt;d0&gt;&lt;bd&gt;&lt;d1&gt;&lt;94&gt; &lt;ef&gt;&lt;82&gt;&lt;9c&gt;</td>
</tr>
<tr>
<td>Author:</td>
<td>Mike Meredith [aut],
  Martin Ridout [aut],
  Liz A.D. Campbell <a href="https://orcid.org/0000-0002-8302-7430"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Liz A.D. Campbell &lt;lizadcampbell@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-19 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bootstrap+20confidence+20intervals'>
Confidence interval calculation from bootstrap samples.
</h2><span id='topic+bootCI'></span><span id='topic+bootCIlogit'></span>

<h3>Description</h3>

<p><code>bootCI</code> calculates five different confidence intervals from bootstrap samples: see details: <code>bootCIlogit</code> calculates corrections on the logit scale and back-transforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootCI(t0, bt, conf = 0.95)
bootCIlogit(t0, bt, conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Bootstrap+2B20confidence+2B20intervals_+3A_t0">t0</code></td>
<td>

<p>the statistic estimated from the original sample, usually the output from <code><a href="#topic+overlapEst">overlapEst</a></code>.
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B20confidence+2B20intervals_+3A_bt">bt</code></td>
<td>

<p>a vector of bootstrap statistics, usually the output from <code><a href="#topic+bootEst">bootEst</a></code>
</p>
</td></tr>
<tr><td><code id="Bootstrap+2B20confidence+2B20intervals_+3A_conf">conf</code></td>
<td>

<p>a (single!) confidence interval to estimate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let t = true value of the statistic,<br />
t0 = estimate of t based on the original sample,<br />
bt = bootstrap estimates.
</p>
<p>If bootstrap sampling introduces no bias, E[mean(bt)] = t0, otherwise BS bias = mean(bt) - t0.
</p>
<p>Assuming that the original sampling causes the same bias as the bootstrap sampling, we write: mean(bt) - t0 = t0 - t, and hence calculate a bias-corrected estimate, t1 = 2 x t0 - mean(bt).
</p>
<p>The percentiles CI, &ldquo;perc&rdquo;, gives quantiles of the bootstrap values, interpolated if necessary. However, in general, the bootstrap estimates are biased, so &ldquo;perc&rdquo; should be corrected. 
</p>
<p>&ldquo;basic&rdquo; is a bias-corrected version of &ldquo;perc&rdquo;, analogous to t1: 2 x t0 - <code>perc</code>.
</p>
<p>&ldquo;norm&rdquo; gives tail cutoffs for a normal distribution with mean = t1 and sd = sd(bt).
</p>
<p>These three are equivalent to the confidence intervals returned by <code>boot::boot.ci</code>. &ldquo;basic&rdquo; and &ldquo;norm&rdquo; are appropriate if you are using the bias-corrected estimator, t1. If you use the uncorrected estimator, t0, you should use &ldquo;basic0&rdquo; or &ldquo;norm0&rdquo;:
</p>
<p>&ldquo;basic0&rdquo; is <code>perc</code> - mean(bt) + t0.
</p>
<p>&ldquo;norm0&rdquo; gives tail cutoffs as before, but with mean = t0 instead of t1.
</p>
<p>The &quot;logit&quot; versions perform the corrections on the logit scale and then back transform. This would be appropriate for probabilities or proportions.
</p>


<h3>Value</h3>

<p>A named matrix with 2 columns for lower and upper limits and a row for each type of estimate. Values will be NA if the bootstrap sample is too small (after removing NAs) for estimation: 40 is the minimum for a 95% confidence interval, 200 for 99% (though for stable estimates you need at least 999 bootstrap estimates, preferably 10,000).
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>See Also</h3>

<p><code>boot.ci</code> in package <code>boot</code>. See <code><a href="#topic+kerinci">kerinci</a></code> for an example.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?kerinci
</code></pre>

<hr>
<h2 id='bootstrap+20functions'>
Functions to generate bootstrap estimates of overlap
</h2><span id='topic+bootstrap'></span><span id='topic+bootEst'></span><span id='topic+resample'></span>

<h3>Description</h3>

<p><code>bootstrap</code> takes two sets of times of observations and calculates bootstrap estimates of the chosen estimator of overlap. Alternatively, bootstrap estimates can be calculated in a 2-stage process: (1) create a matrix of bootstrap samples for each data set, using <code>resample</code>; (2) pass these matrices to <code>bootEst</code> to obtain the bootstrap estimates.
</p>
<p>A vector of bootstrap estimates can then be used to produce confidence intervals with <code><a href="#topic+bootCI">bootCI</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(A, B, nb, smooth=TRUE, kmax=3, adjust=NA, n.grid=128,
    type=c("Dhat1", "Dhat4", "Dhat5"), cores=1)

resample(x, nb, smooth = TRUE, kmax = 3, adjust = 1, n.grid = 512)

bootEst(Amat, Bmat, kmax = 3, adjust=c(0.8, 1, 4), n.grid = 128,
      type=c("all", "Dhat1", "Dhat4", "Dhat5"), cores=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap+2B20functions_+3A_a">A</code>, <code id="bootstrap+2B20functions_+3A_b">B</code></td>
<td>

<p>vectors of times of observations of two different species in radians, ie. scaled to [0, <code class="reqn">2\pi</code>].
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_nb">nb</code></td>
<td>

<p>the number of bootstrap samples required
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_smooth">smooth</code></td>
<td>

<p>if TRUE, smoothed bootstrap samples are produced.
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_kmax">kmax</code></td>
<td>

<p>maximum value of k for optimal bandwidth estimation.
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_adjust">adjust</code></td>
<td>

<p>bandwidth adjustment. If <code>adjust=NA</code> in <code>bootstrap</code>, adjust will be set to 0.8 for <code>type="Dhat1"</code>, 1 for <code>type="Dhat4"</code> and 4 for <code>type="Dhat5"</code>.
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_n.grid">n.grid</code></td>
<td>

<p>number of points at which to estimate density for comparison between species; smaller values give lower precision but run faster in bootstraps.
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_type">type</code></td>
<td>

<p>the name of the estimator to use, or &quot;all&quot; to produce all three estimates. See <code><a href="#topic+overlapEst">overlapEst</a></code> for recommendations on which to use.
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_cores">cores</code></td>
<td>

<p>the number of cores to use for parallel processing. If NA, all but one of the available cores will used. Parallel processing may take longer than serial processing if the bootstrap runs quickly.
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_x">x</code></td>
<td>

<p>a numeric vector of time-of-capture data in <em>radians</em>, ie. on [0, <code class="reqn">2\pi</code>] scale
</p>
</td></tr>
<tr><td><code id="bootstrap+2B20functions_+3A_amat">Amat</code>, <code id="bootstrap+2B20functions_+3A_bmat">Bmat</code></td>
<td>

<p>matrices of resampled data for each species produced by <code>resample</code>; see Value below.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>bootstrap</code> returns a vector of bootstrap estimates. If estimation fails for a bootstrap sample, the corresponding value will be NA.
</p>
<p>The function <code>resample</code> returns a numeric matrix with each column corresponding to a bootstrap sample. Times are in <em>radians</em>. It may return a matrix of NAs if <code>smooth = TRUE</code> and bandwidth estimation fails.
</p>
<p>Function <code>bootEst</code> with <code>type = "all"</code> returns a numeric matrix with three columns, one for each estimator of overlap, otherwise a vector of bootstrap estimates.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith, including code by Martin Ridout.
</p>


<h3>References</h3>

<p>Ridout &amp; Linkie (2009) Estimating overlap of daily activity patterns from camera trap data. <em>Journal of Agricultural, Biological, and Environmental Statistics</em> 14:322-337
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootCI">bootCI</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulatedData)
est &lt;- overlapEst(tigerObs, pigObs, type="Dhat4")

boots &lt;- bootstrap(tigerObs, pigObs, 99, type="Dhat4", cores=1)
mean(boots)
hist(boots)
bootCI(est, boots)

# alternatively:
tigSim &lt;- resample(tigerObs, 99)
dim(tigSim)
pigSim &lt;- resample(pigObs, 99)
boots &lt;- bootEst(tigSim, pigSim, type="Dhat4", cores=1)
mean(boots)
</code></pre>

<hr>
<h2 id='densityFit'>
Fits von Mises kernel density to time-of-day data.
</h2><span id='topic+densityFit'></span>

<h3>Description</h3>

<p>Fits von Mises kernel density to time-of-day data. Intended primarily for internal use: input checking is minimal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityFit(x, grid, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityFit_+3A_x">x</code></td>
<td>

<p>a vector of times of observations in <em>radians</em>, ie. scaled to [<code class="reqn">0, 2\pi</code>].
</p>
</td></tr>
<tr><td><code id="densityFit_+3A_grid">grid</code></td>
<td>

<p>a vector of times in <em>radians</em> for which the density is required. This could be a vector of equidistant values in [<code class="reqn">0, 2\pi</code>], eg. <code>seq(0, 2*pi, length=128)</code>, or it could be any set of times for which a density is needed.
</p>
</td></tr>
<tr><td><code id="densityFit_+3A_bw">bw</code></td>
<td>

<p>bandwidth, the concentration parameter for the von Mises kernel: smaller values result in smoother curves.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of densities corresponding to the times in grid.
</p>


<h3>Author(s)</h3>

<p>C code written by Mike Meredith.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getBandWidth">getBandWidth</a></code> for appropriate bandwidth.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get example data:
data(simulatedData)

densityFit(tigerObs, c(0, pi/2, pi, 3*pi/2, 2*pi), 50)
# Densities at 6am and 6pm are fairly high, at midnight and midday, tiny.
# A crepuscular species!
</code></pre>

<hr>
<h2 id='densityPlot'>
Plot fitted kernel densities
</h2><span id='topic+densityPlot'></span>

<h3>Description</h3>

<p>Fits a kernel density function to a data set and plots it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densityPlot(A, xscale = 24, xcenter = c("noon", "midnight"),
   add = FALSE, rug = FALSE, extend = 'lightgrey',
   n.grid = 128, kmax = 3, adjust = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densityPlot_+3A_a">A</code></td>
<td>

<p>a vector of times of observations in <em>radians</em>, ie. scaled to [<code class="reqn">0, 2\pi</code>]. It must include at least 2 unique observations to fit a kernel density.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_xscale">xscale</code></td>
<td>

<p>The scale for the x axis: 24 (the default) produces a curve with 0 to 24 hours. NA gives a scale in radians, labelled with <code class="reqn">pi</code>.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_xcenter">xcenter</code></td>
<td>

<p>the center of the plot on the x axis: 'noon' (default) or 'midnight'.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_add">add</code></td>
<td>

<p>If TRUE, the curve will be added to the existing plot. Use the same settings for xscale and xcenter as for the original plot.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_rug">rug</code></td>
<td>

<p>If TRUE, the original observations will be displayed as a rug at the bottom of the plot.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_extend">extend</code></td>
<td>

<p>If not NULL, the plot extends 3 hours before and after the main 24-hr period, and <code>extend</code> specifies the background colour; the plot is not extended if <code>extend = NULL</code>.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_n.grid">n.grid</code></td>
<td>

<p>Number of points at which to estimate the density for plotting; 100 is usually adequate to give a smooth-looking curve.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_kmax">kmax</code></td>
<td>

<p>maximum value of k for optimal bandwidth estimation.
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_adjust">adjust</code></td>
<td>

<p>bandwidth adjustment (scalar).
</p>
</td></tr>
<tr><td><code id="densityPlot_+3A_...">...</code></td>
<td>

<p>Further arguments passed to the plotting functions, such as <code>col, lty, lwd</code> or <code>xlab, ylab, main</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a data frame with x and y coordinates which can be used for further plotting or calculations; see examples.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get example data:
data(simulatedData)

# Do basic plot with defaults:
densityPlot(pigObs)

# Prettier plots:
densityPlot(pigObs, extend=NULL, lwd=2)
densityPlot(pigObs, rug=TRUE, main="Simulated data", extend='gold')
densityPlot(tigerObs, add=TRUE, rug=TRUE, col='red')
legend('topleft', c("Tiger", "Pig"), lty=1, col=c('black', 'red'), bg='white')
# Add vertical dotted lines to mark sunrise (say 05:30) and sunset (18:47):
# (times must be in hours if the x-axis is labelled in hours)
abline(v=c(5.5, 18+47/60), lty=3)

# A plot centered on midnight:
densityPlot(pigObs, xcenter = "m")
# Mark sunrise/sunset; values to the left of "00:00" are negative
# so subtract 24:
abline(v=c(5.5, (18+47/60) - 24), lty=3)

# Using object returned:
densityPlot(pigObs, rug=TRUE, lwd=3)
# Don't like the rug with lwd = 3?
pigDens &lt;- densityPlot(pigObs, rug=TRUE)
lines(pigDens, lwd=3)

# Add shading below the curve:
pigDens &lt;- densityPlot(pigObs, extend=NULL)
polygon(pigDens, col='skyblue') # works if density at midnight = 0
tigDens &lt;- densityPlot(tigerObs, extend=NULL)
# Add vertices at (0,0) and (24, 0)
poly &lt;- rbind(c(0,0), tigDens, c(24,0))
polygon(poly, col='pink', border=NA)
lines(tigDens, lwd=2)

# What proportion of the density lies between 9:00 and 15:00 hrs?
wanted &lt;- pigDens$x &gt; 9 &amp; pigDens$x &lt; 15
mean(pigDens$y[wanted]) * 6  # probability mass for the 6 hr period.

# Plotting time in radians:
densityPlot(pigObs, xscale=NA, rug=TRUE)
densityPlot(tigerObs, xscale=NA, add=TRUE, rug=TRUE, col='red')

</code></pre>

<hr>
<h2 id='Example+20data'>
Times of 'capture' of large mammals
</h2><span id='topic+Example+20data'></span><span id='topic+kerinci'></span>

<h3>Description</h3>

<p>Times of capture of large mammals in camera traps in Kerinci Seblat National Park, Indonesia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kerinci)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1098 rows and three columns:
</p>

<dl>
<dt>Zone</dt><dd><p>A number indicating which of four zones the record comes from.</p>
</dd>
<dt>Sps</dt><dd><p>A factor indicating which species was observed: boar (wild pig), clouded leopard, golden cat, macaque, muntjac, sambar deer, tapir, or tiger.</p>
</dd>
<dt>Time</dt><dd><p>The time of the observation on a scale of 0 to 1, where 0 and 1 both correspond to midnight</p>
</dd>
</dl>



<h3>Source</h3>

<p>Ridout, M.S. and Linkie, M. (2009) Estimating overlap of daily activity patterns from camera trap data. <em>Journal of Agricultural, Biological and Environmental Statistics</em>, 14, 322-337.
</p>
<p><a href="https://www.kent.ac.uk/smsas/personal/msr/overlap.html">https://www.kent.ac.uk/smsas/personal/msr/overlap.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kerinci)
str(kerinci)
# Time is in days, ie. 0 to 1:
range(kerinci$Time)
# Convert to radians:
timeRad &lt;- kerinci$Time * 2*pi

# Extract data for tiger and tapir for Zone3:
spsA &lt;- timeRad[kerinci$Zone == 3 &amp; kerinci$Sps == 'tiger']
spsB &lt;- timeRad[kerinci$Zone == 3 &amp; kerinci$Sps == 'tapir']

# Plot the data:
overlapPlot(spsA, spsB)  # Tapir are mainly nocturnal
overlapPlot(spsA, spsB, xcenter="midnight")
legend('topleft', c("Tiger", "Tapir"), lty=c(1, 2), col=c("black", "blue"), bty='n')

# Check sample sizes:
length(spsA)
length(spsB)
# If the smaller sample is less than 50, Dhat1 gives the best estimates, together with
# confidence intervals from a smoothed bootstrap with norm0 or basic0 confidence interval.

# Calculate estimates of overlap:
( Dhats &lt;- overlapEst(spsA, spsB) )  # or just get Dhat1
( Dhat1 &lt;- overlapEst(spsA, spsB, type="Dhat1") )

# Do 999 smoothed bootstrap values:
bs &lt;- bootstrap(spsA, spsB, 999, type="Dhat1", cores=1)
mean(bs)
hist(bs)
abline(v=Dhat1, col='red', lwd=2)
abline(v=mean(bs), col='blue', lwd=2, lty=3)

# Get confidence intervals:
bootCI(Dhat1, bs)['norm0', ]
bootCI(Dhat1, bs)['basic0', ]
</code></pre>

<hr>
<h2 id='getBandWidth'>
Optimal bandwidth calculation
</h2><span id='topic+getBandWidth'></span>

<h3>Description</h3>

<p>Calculates the optimal bandwidth for von Mises kernel density estimation for a given sample. Used internally by other functions in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBandWidth(A, kmax = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBandWidth_+3A_a">A</code></td>
<td>

<p>a vector of times of observations in <em>radians</em>, ie. scaled to [0, <code class="reqn">2\pi</code>].
</p>
</td></tr>
<tr><td><code id="getBandWidth_+3A_kmax">kmax</code></td>
<td>

<p>maximum moment to use for estimation; see Ridout &amp; Linkie 2009.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Optimal bandwidth for the sample data, or NA if estimation fails.
</p>


<h3>Author(s)</h3>

<p>Code by Martin Ridout, error handling modified by Mike Meredith.
</p>


<h3>References</h3>

<p>Ridout &amp; Linkie (2009) Estimating overlap of daily activity patterns from camera trap data. <em>Journal of Agricultural, Biological, and Environmental Statistics</em> 14:322-337
</p>
<p>Taylor (2008) Automatic bandwidth selection for circular density estimation, <em>Computational Statistics and Data Analysis</em>, 52:3493-3500.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulatedData)
getBandWidth(tigerObs, kmax = 3)

</code></pre>

<hr>
<h2 id='overlap-package'>
Functions to estimate overlap of temporal activity patterns of animals
</h2><span id='topic+overlap-package'></span><span id='topic+overlap'></span>

<h3>Description</h3>

<p>The times recorded on camera trap photos provide information on the period during the day that a species is most active. Species active at the same periods may interact as predator and prey, or as competitors. The functions in this package allow the overlap to be quantified, and provide means of estimating confidence intervals with bootstraps.
</p>


<h3>Details</h3>

<p>The functions in this package were originally optimised for a simulation study. Hence, speed is important and checking of input is minimal. It is the user's responsibility to make sure that input is valid.
</p>
<p>In particular, note that all times are measured in <b>radians</b>. If your original data use 0-24 hours or 0-1 days, convert to radians: see the example in <code><a href="#topic+kerinci">kerinci</a></code>. If you need fitted densities in other units, use the output from <code><a href="#topic+densityPlot">densityPlot</a></code> or <code><a href="#topic+overlapPlot">overlapPlot</a></code>.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith, based on work by Martin Ridout.
</p>


<h3>References</h3>

<p>Ridout &amp; Linkie (2009) Estimating overlap of daily activity patterns from camera trap data. <em>Journal of Agricultural, Biological, and Environmental Statistics</em> 14:322-337
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+overlapTrue">overlapTrue</a></code> for the definition of the coefficient of overlapping, and <code><a href="#topic+overlapEst">overlapEst</a></code> for equations for the estimators. See <code><a href="#topic+kerinci">kerinci</a></code> for an example of calculation of overlap and confidence interval from real data.
</p>
<p>The <span class="rlang"><b>R</b></span> package <span class="pkg">activity</span> has more functions for analysis of animal activity patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get example data:
data(simulatedData)

# Use defaults:
overlapEst(tigerObs, pigObs)
#     Dhat1     Dhat4     Dhat5
# 0.2908618 0.2692011 0.2275000

overlapEst(tigerObs, pigObs, type="Dhat4")
# Dhat4
# 0.2692011
</code></pre>

<hr>
<h2 id='overlapEst'>
Estimates of coefficient of overlapping
</h2><span id='topic+overlapEst'></span>

<h3>Description</h3>

<p>Calculates up to three estimates of activity pattern overlap based on times of observations for two species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlapEst(A, B, kmax = 3, adjust=c(0.8, 1, 4), n.grid = 128,
    type=c("all", "Dhat1", "Dhat4", "Dhat5"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlapEst_+3A_a">A</code></td>
<td>

<p>a vector of times of observations of species A in radians, ie. scaled to [0, <code class="reqn">2\pi</code>].
</p>
</td></tr>
<tr><td><code id="overlapEst_+3A_b">B</code></td>
<td>

<p>a vector of times of observations of species B in radians.
</p>
</td></tr>
<tr><td><code id="overlapEst_+3A_kmax">kmax</code></td>
<td>

<p>maximum value of k for optimal bandwidth estimation.
</p>
</td></tr>
<tr><td><code id="overlapEst_+3A_adjust">adjust</code></td>
<td>

<p>bandwidth adjustment; either a single value used for all 3 overlap estimates, or a vector of 3 different values. This corresponds to <em>1/c</em> in Ridout &amp; Linkie 2009.
</p>
</td></tr>
<tr><td><code id="overlapEst_+3A_n.grid">n.grid</code></td>
<td>

<p>number of points at which to estimate density for comparison between species; smaller values give lower precision but run faster in simulations and bootstraps.
</p>
</td></tr>
<tr><td><code id="overlapEst_+3A_type">type</code></td>
<td>

<p>the name of the estimator to use: <code>Dhat4</code> is recommended if both samples are larger then 50, otherwise use <code>Dhat1</code>. See Details. The default is &quot;all&quot; for compatibility with older versions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+overlapTrue">overlapTrue</a></code> for the meaning of coefficient of overlapping, <code class="reqn">\Delta</code>.
</p>
<p>These estimators of <code class="reqn">\Delta</code> use kernel density estimates fitted to the data to approximate the true density functions <em>f(t)</em> and <em>g(t)</em>. Schmid &amp; Schmidt (2006) propose five estimators of overlap:
</p>
<p>Dhat1 is calculated from vectors of densities estimated at <em>T</em> equally-spaced times, <em>t</em>, between 0 and <code class="reqn">2\pi</code>:
</p>
<p><img src="../help/figures/Dhat1.jpg" alt="Equation for Dhat1" />
</p>
<p>For circular distributions, Dhat2 is equivalent to Dhat1, and Dhat3 is inapplicable.
</p>
<p>Dhat4 and Dhat5 use vectors of densities estimated at the times of the observations of the species, <em>x</em> and <em>y</em>:
</p>
<p><img src="../help/figures/Dhat4.jpg" alt="Equation for Dhat4" /><br /> 
<br />
<img src="../help/figures/Dhat5.jpg" alt="Equation for Dhat5" />
</p>
<p>where <em>n, m</em> are the sample sizes and <em>I</em> is the indicator function (1 if the condition is true, 0 otherwise).
</p>
<p>Dhat5 simply checks which curve is higher at each point; even tiny changes in the data can result in large, discontinuous changes in Dhat5, and it can take values &gt; 1. Don't use Dhat5.
</p>
<p>Comparing curves at times of actual observations works well if there are enough observations of each species. Simulations show that Dhat4 is best when the smallest sample has at least 50 observations. Dhat1 compares curves at <code>n.grid</code> equally spaced points, and is best for small samples.
</p>


<h3>Value</h3>

<p>If <code>type = all</code>, a named vector of three estimates of overlap, otherwise a single estimate. Will be NA if optimal bandwidth estimation failed.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith, based on work by Martin Ridout.
</p>


<h3>References</h3>

<p>Ridout &amp; Linkie (2009) Estimating overlap of daily activity patterns from camera trap data. <em>Journal of Agricultural, Biological, and Environmental Statistics</em> 14:322-337
</p>
<p>Schmid &amp; Schmidt (2006) Nonparametric estimation of the coefficient of overlapping - theory and empirical application, <em>Computational Statistics and Data Analysis</em>, 50:1583-1596.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlapTrue">overlapTrue</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get example data:
data(simulatedData)

# Use defaults:
overlapEst(tigerObs, pigObs)
#     Dhat1     Dhat4     Dhat5 
# 0.2908618 0.2692011 0.2275000 

overlapEst(tigerObs, pigObs, type="Dhat4")
#    Dhat4
#    0.2692011
</code></pre>

<hr>
<h2 id='overlapPlot'>
Plot overlapping kernel densities
</h2><span id='topic+overlapPlot'></span>

<h3>Description</h3>

<p>Fits kernel density functions to two data sets and plots them, shading the area corresponding to the coefficient of overlap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlapPlot(A, B, xscale = 24, xcenter = c("noon", "midnight"),
   linetype = c(1, 2), linecol = c("black", "blue"), linewidth = c(1, 1),
   olapcol = "lightgrey", rug=FALSE, extend=NULL,
   n.grid = 128, kmax = 3, adjust = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlapPlot_+3A_a">A</code>, <code id="overlapPlot_+3A_b">B</code></td>
<td>

<p>vectors of times of observations for species A and species B in <em>radians</em>, ie. scaled to [<code class="reqn">0, 2\pi</code>]. Each must include at least 2 unique observations to fit a kernel density.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_xscale">xscale</code></td>
<td>

<p>the scale for the x axis: 24 (the default) produces a curve with 0 to 24 hours. NA gives a scale in radians, labelled with <code class="reqn">pi</code>.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_xcenter">xcenter</code></td>
<td>

<p>the center of the plot on the x axis: 'noon' (default) or 'midnight'.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_linetype">linetype</code></td>
<td>

<p>a vector of length 2 giving the line type for each species. Look for <code>lty</code> in <code><a href="graphics.html#topic+par">par</a></code> for ways to specify this.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_linecol">linecol</code></td>
<td>

<p>a vector of length 2 giving the line colour for each species. See the Color Specification section in <code><a href="graphics.html#topic+par">par</a></code> for details.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_linewidth">linewidth</code></td>
<td>

<p>a vector of length 2 giving the line width for each species.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_olapcol">olapcol</code></td>
<td>

<p>the colour to use for the shaded area. See the Color Specification section in <code><a href="graphics.html#topic+par">par</a></code> for details.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_rug">rug</code></td>
<td>

<p>if TRUE, the original observations will be displayed as a rug at the bottom of the plot, A below B.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_extend">extend</code></td>
<td>

<p>If not NULL, the plot extends 3 hours before and after the main 24-hr period, and <code>extend</code> specifies the background colour; the plot is not extended if <code>extend = NULL</code>.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_n.grid">n.grid</code></td>
<td>

<p>number of points at which to estimate the density for plotting; 100 is usually adequate to give a smooth-looking curve.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_kmax">kmax</code></td>
<td>

<p>maximum value of k for optimal bandwidth estimation.
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_adjust">adjust</code></td>
<td>

<p>bandwidth adjustment (scalar).
</p>
</td></tr>
<tr><td><code id="overlapPlot_+3A_...">...</code></td>
<td>

<p>Further arguments passed to the plotting functions such as <code>main, xlab, ylab, ylim</code>. Values for <code>col, lwd, lty</code> should be passed with <code>linecol, linewidth, linetype</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a data frame with columns:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>a vector of equally-spaced times from midnight to midnight inclusive on the scale specified by <code>xscale</code>.</p>
</td></tr>
<tr><td><code>densA</code></td>
<td>
<p>a vector of length <code>x</code> with the fitted kernel density for species A.</p>
</td></tr>
<tr><td><code>densB</code></td>
<td>
<p>a similar vector for species B.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mike Meredith
</p>


<h3>See Also</h3>

<p><code><a href="#topic+densityPlot">densityPlot</a></code> for plotting a single density curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get example data:
data(simulatedData)

# Do basic plot with defaults:
overlapPlot(pigObs, tigerObs)
# Make it prettier:
overlapPlot(tigerObs, pigObs, linet = c(1,1), linec = c("red", "blue"),
  rug=TRUE, extend="lightgreen", main="Simulated data")
legend("topleft", c("Tiger", "Pig"), lty=1, col=c("red", "blue"), bg="white")
# Add vertical dotted lines to mark sunrise (05:30) and sunset (18:47):
# (times must be in hours if the x-axis is labelled in hours)
abline(v=c(5.5, 18+47/60), lty=3)

# A plot centered on midnight:
overlapPlot(pigObs, tigerObs, xcenter = "m", rug=TRUE)
# Mark sunrise/sunset; values to the left of "00:00" are negative
# so subtract 24:
abline(v=c(5.5, (18+47/60) - 24), lty=3)

</code></pre>

<hr>
<h2 id='overlapTrue'>
Calculates the true coefficient of overlapping between two distributions.
</h2><span id='topic+overlapTrue'></span>

<h3>Description</h3>

<p>Calculates the true coefficient of overlapping between two distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlapTrue(d1, d2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlapTrue_+3A_d1">d1</code></td>
<td>

<p>either a vector or a 2-column matrix of densities for equidistant points from 0 to <code class="reqn">2\pi</code>; if densities for both 0 and <code class="reqn">2\pi</code> are included (and are equal), one will be ignored.
</p>
</td></tr>
<tr><td><code id="overlapTrue_+3A_d2">d2</code></td>
<td>

<p>a vector of densities as for d1; ignored if d1 is a matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficient of overlapping <code class="reqn">\Delta</code> for two probability density functions <em>f(x)</em> and <em>g(x)</em> is given by:
<img src="../help/figures/Delta.jpg" alt="Formula for Delta" />
If the two curves in the plot below represent activity patterns of two species, the coefficient of overlapping is the area under the lower of the two curves, shaded grey in the figure:
</p>
<p><img src="../help/figures/overlap.jpg" alt="Plot of 2 curves, overlap shaded" />
</p>


<h3>Value</h3>

<p>The coefficient of overlap of the two distributions. The function is intended to calculate true overlap for simulated data. If the densities provided are fitted kernel densities, an estimate of overlap results.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith, based on code by Martin Ridout.
</p>


<h3>References</h3>

<p>Ridout &amp; Linkie (2009) Estimating overlap of daily activity patterns from camera trap data. <em>Journal of Agricultural, Biological, and Environmental Statistics</em> 14:322-337
</p>


<h3>See Also</h3>

<p><code><a href="#topic+overlapEst">overlapEst</a></code> for various estimators of overlap.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulatedData)

overlapTrue(tigerTrue, pigTrue)

overlapTrue(cbind(tigerTrue, pigTrue))

</code></pre>

<hr>
<h2 id='Simulated+20call+20data'>
Simulated data for bird calls influenced by sunrise
</h2><span id='topic+simCalls'></span>

<h3>Description</h3>

<p>A simulated data set of bird calling activity. 80% occur around sunrise with a strong peak just before sunrise, the remainder occur around sunset. Changes in the times of sunrise and sunset through the year mean that both peaks appear to be broader than they should. The hypothetical location is near St Andrews, UK, longitude 3 degrees West, latitude 56 degrees North (CRS WGS84) and times are GMT throughout (not British Summer Time).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simCalls)
</code></pre>


<h3>Format</h3>

<p>The data set consists of a data frame with two columns:
</p>
<p>time is a vector of 100 observations of bird calls in radians. Here <code class="reqn">\pi/2</code> corresponds to 6am and <code class="reqn">3\pi/2</code> to 6pm. The time zone is UTC (GMT).
</p>
<p>dates is a character vector of dates in ISO format.
</p>


<h3>Source</h3>

<p>Simulated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples for the function 'sunTime'.
</code></pre>

<hr>
<h2 id='Simulated+20data'>
Simulated data for diel activity patterns
</h2><span id='topic+simulatedData'></span><span id='topic+tigerObs'></span><span id='topic+tigerTrue'></span><span id='topic+pigObs'></span><span id='topic+pigTrue'></span>

<h3>Description</h3>

<p>tigerObs and pigObs are simulated data sets with times of observation. tigerTrue and pigTrue are densities from which the simulated observations were drawn.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simulatedData)
</code></pre>


<h3>Format</h3>

<p>The data set consists of four vectors:
</p>
<p>tigerObs is a vector of 100 observations of a crepuscular species in radians.
</p>
<p>pigObs is a vector of 80 observations of a diurnal species in radians.
</p>
<p>tigerTrue and pigTrue are vectors of densities at 128 times equidistant between 0 and <code class="reqn">2\pi</code> inclusive.
</p>


<h3>Details</h3>

<p>The figures below show the true densities (solid line), the simulated data (rug at the foot of the plot) and a kernel density fitted to the simulated data (dotted line).
</p>
<p><img src="../help/figures/tigNpig.jpg" alt="plots of tiger and pig densities" />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(simulatedData)

xx &lt;- seq(0, 2*pi, length=128)
plot(xx, tigerTrue, type='l') # True density from which sample was drawn
rug(tigerObs)

</code></pre>

<hr>
<h2 id='sunTime'>
Convert clock times to sun times
</h2><span id='topic+sunTime'></span>

<h3>Description</h3>

<p>Converts a vector of clock times to &quot;sun times&quot;, by mapping sunrise to <code class="reqn">\pi/2</code> and sunset to <code class="reqn">3\pi/2</code>. Sunrise and sunset times are determined based on the dates and locations provided. See Nouvellet et al (2012) for a discussion. Requires the <span class="pkg">suntools</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sunTime(clockTime, Dates, Coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sunTime_+3A_clocktime">clockTime</code></td>
<td>

<p>a vector of times of observations in <em>radians</em>, ie. scaled to [<code class="reqn">0, 2\pi</code>].
</p>
</td></tr>
<tr><td><code id="sunTime_+3A_dates">Dates</code></td>
<td>

<p>a POSIXct object with the dates of the observations; the time zone must be set to the time zone used for 'clockTime'.
</p>
</td></tr>
<tr><td><code id="sunTime_+3A_coords">Coords</code></td>
<td>

<p>a SpatialPoints object with the locations of the observations, or with a single point giving a approximate location for the study area; the coordinates must be geographical coordinates, eg, WGS84, with long before lat.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of &quot;sun times&quot; in <em>radians</em>, where <code class="reqn">\pi/2</code> corresponds to sunrise and <code class="reqn">3\pi/2</code> to sunset.
</p>


<h3>Author(s)</h3>

<p>Mike Meredith.
</p>


<h3>References</h3>

<p>Nouvellet et al (2012) Noisy clocks and silent sunrises: measurement methods of daily activity pattern. <em>Journal of Zoology</em> 286:179-184.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check that sp and suntools packages are installed
if(requireNamespace("sp") &amp;&amp; requireNamespace("suntools")) {
  # Get example data:
  data(simCalls)
  str(simCalls)

  # Convert dates to a POSIXct object with the right time zone (GMT):
  Dates &lt;- as.POSIXct(simCalls$dates, tz="GMT")

  # Create a SpatialPoints object with the location
  coords &lt;- matrix(c(-3, 56), nrow=1)
  Coords &lt;- sp::SpatialPoints(coords, proj4string=sp::CRS("+proj=longlat +datum=WGS84"))

  st &lt;- sunTime(simCalls$time, Dates, Coords)

  exPar&lt;-par(mfrow=c(2,1))
	densityPlot(st, col='red', lwd=2, xaxt='n', main="Sun time")
		axis(1, at=c(0, 6, 12, 18, 24),
		labels=c("midnight", "sunrise", "noon", "sunset", "midnight"))
	densityPlot(simCalls$time, lwd=2, main="Clock time")
  par(exPar)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
