<!DOCTYPE html><html><head><title>Help for package runner</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {runner}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.check_unresolved_at'><p>Resolves at argument</p></a></li>
<li><a href='#.check_unresolved_difftime'><p>Resolves time difference argument</p></a></li>
<li><a href='#.check_unresolved_index'><p>Resolves index argument</p></a></li>
<li><a href='#.is_datetime_valid'><p>Validate date time character</p></a></li>
<li><a href='#.k_by'><p>Converts k and lag from time-unit-interval to int</p></a></li>
<li><a href='#.reformat_k'><p>Formats time-unit-interval to valid for runner</p></a></li>
<li><a href='#.resolve_arg'><p>Resolves at argument</p></a></li>
<li><a href='#.seq_at'><p>Creates sequence for at as time-unit-interval</p></a></li>
<li><a href='#.this_group'><p>Access group data in mutate</p></a></li>
<li><a href='#fill_run'><p>Fill NA with previous non-NA element</p></a></li>
<li><a href='#lag_run'><p>Lag dependent on variable</p></a></li>
<li><a href='#length_run'><p>Length of running windows</p></a></li>
<li><a href='#max_run'><p>Running maximum</p></a></li>
<li><a href='#mean_run'><p>Running mean</p></a></li>
<li><a href='#min_run'><p>Running minimum</p></a></li>
<li><a href='#minmax_run'><p>Running min/max</p></a></li>
<li><a href='#run_by'><p>Set window parameters</p></a></li>
<li><a href='#runner'><p>Apply running function</p></a></li>
<li><a href='#streak_run'><p>Running streak length</p></a></li>
<li><a href='#sum_run'><p>Running sum</p></a></li>
<li><a href='#which_run'><p>Running which</p></a></li>
<li><a href='#window_run'><p>List of running windows</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Running Operations for Vectors</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.4</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dawid Kałędkowski &lt;dawid.kaledkowski@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Lightweight library for rolling windows operations. Package enables
  full control over the window length, window lag and a time indices. With a runner 
  one can apply any R function on a rolling windows. The package eases work with 
  equally and unequally spaced time series.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gogonzo/runner/issues">https://github.com/gogonzo/runner/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, tinytest</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-03 20:09:02 UTC; gonzo</td>
</tr>
<tr>
<td>Author:</td>
<td>Dawid Kałędkowski <a href="https://orcid.org/0000-0001-9533-457X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-03 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.check_unresolved_at'>Resolves at argument</h2><span id='topic+.check_unresolved_at'></span>

<h3>Description</h3>

<p>Resolves <code>at</code> argument passed to the <code>runner</code> -
checks if the argument has a valid value. If argument is a single character
matching column name in the <code>x</code> then is replaced with the value <code>x[[at]]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_unresolved_at(x, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_unresolved_at_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)</p>
</td></tr>
<tr><td><code id=".check_unresolved_at_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resolved <code>at</code>
</p>

<hr>
<h2 id='.check_unresolved_difftime'>Resolves time difference argument</h2><span id='topic+.check_unresolved_difftime'></span>

<h3>Description</h3>

<p>Resolves <code>at</code> argument passed to the <code>runner</code> (<code>k</code> or <code>lag</code>)
checks if the argument has a valid value. If argument is a single character
matching column name in the <code>x</code> then is replaced with the value <code>x[[idx]]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_unresolved_difftime(x, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_unresolved_difftime_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)</p>
</td></tr>
<tr><td><code id=".check_unresolved_difftime_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resolved <code>idx</code>
</p>

<hr>
<h2 id='.check_unresolved_index'>Resolves index argument</h2><span id='topic+.check_unresolved_index'></span>

<h3>Description</h3>

<p>Resolves <code>at</code> argument passed to the <code>runner</code> -
checks if the argument has a valid value. If argument is a single character
matching column name in the <code>x</code> then is replaced with the value <code>x[[idx]]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_unresolved_index(x, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_unresolved_index_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)</p>
</td></tr>
<tr><td><code id=".check_unresolved_index_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resolved <code>idx</code>
</p>

<hr>
<h2 id='.is_datetime_valid'>Validate date time character</h2><span id='topic+.is_datetime_valid'></span>

<h3>Description</h3>

<p>Checks if the character is a valid date time string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is_datetime_valid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".is_datetime_valid_+3A_x">x</code></td>
<td>
<p>(<code>character</code>) can be anything but suppose to be a character.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>logical(1)</code> denoting if all elements of the character vectors are valid
</p>

<hr>
<h2 id='.k_by'>Converts k and lag from time-unit-interval to int</h2><span id='topic+.k_by'></span>

<h3>Description</h3>

<p>Converts k and lag from time-unit-interval to int
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.k_by(k, idx, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".k_by_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id=".k_by_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id=".k_by_+3A_param">param</code></td>
<td>
<p>name of the parameter to be printed in error message</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>k &lt;- "1 month"
idx &lt;- seq(
  as.POSIXct("2019-01-01 03:02:01"),
  as.POSIXct("2020-01-01 03:02:01"),
  by = "month"
)
k_difftime &lt;- runner:::.k_by(k, idx, param = "k")
idx - k_difftime
</code></pre>

<hr>
<h2 id='.reformat_k'>Formats time-unit-interval to valid for runner</h2><span id='topic+.reformat_k'></span>

<h3>Description</h3>

<p>Formats time-unit-interval to valid for runner. User specifies <code>k</code> as
positive number but this means that this interval needs to be substracted
from <code>idx</code> - because windows length extends window backwards in time.
The same situation for lag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.reformat_k(k, only_positive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".reformat_k_+3A_k">k</code></td>
<td>
<p>(k or lag) object from runner to be formatted</p>
</td></tr>
<tr><td><code id=".reformat_k_+3A_only_positive">only_positive</code></td>
<td>
<p>for <code>k</code> is <code>TRUE</code>,
for <code>lag</code> is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>runner:::.reformat_k("1 days")
runner:::.reformat_k("day")
runner:::.reformat_k("10 days")
runner:::.reformat_k("-10 days", only_positive = FALSE)
runner:::.reformat_k(c("-10 days", "2 months"), only_positive = FALSE)
</code></pre>

<hr>
<h2 id='.resolve_arg'>Resolves at argument</h2><span id='topic+.resolve_arg'></span>

<h3>Description</h3>

<p>Resolves argument passed to the <code>runner</code> -
checks if the argument has a valid value. If argument is a single character
matching column name in the <code>x</code> then is replaced with the value <code>x[[arg]]</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.resolve_arg(x, arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".resolve_arg_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resolved <code>at</code>
</p>

<hr>
<h2 id='.seq_at'>Creates sequence for at as time-unit-interval</h2><span id='topic+.seq_at'></span>

<h3>Description</h3>

<p>Creates sequence for at as time-unit-interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.seq_at(at, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".seq_at_+3A_at">at</code></td>
<td>
<p>object from runner</p>
</td></tr>
<tr><td><code id=".seq_at_+3A_idx">idx</code></td>
<td>
<p>object from runner</p>
</td></tr>
</table>

<hr>
<h2 id='.this_group'>Access group data in mutate</h2><span id='topic+.this_group'></span>

<h3>Description</h3>

<p>Access group data in <code>dplyr::mutate</code> after
<code>dplyr::group_by</code>.
Function created because data available in <code>dplyr::group_by %&gt;% mutate</code>
scheme is not filtered by group - in mutate function <code>.</code> is still initial
dataset. This function creates <code>data.frame</code> using <code>dplyr::groups</code>
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.this_group(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".this_group_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>)<br />
object which can be <code>grouped_df</code> in special case.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame filtered by current <code>dplyr::groups()</code>
</p>

<hr>
<h2 id='fill_run'>Fill NA with previous non-NA element</h2><span id='topic+fill_run'></span>

<h3>Description</h3>

<p>Fill <code>NA</code> with last non-NA element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_run(x, run_for_first = FALSE, only_within = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_run_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="fill_run_+3A_run_for_first">run_for_first</code></td>
<td>
<p>If first elements are filled with <code>NA</code>, <code>run_for_first = TRUE</code>
allows to fill all initial <code>NA</code> with nearest non-NA value. By default
<code>run_for_first = TRUE</code></p>
</td></tr>
<tr><td><code id="fill_run_+3A_only_within">only_within</code></td>
<td>
<p><code>NA</code> are replaced only if previous and next non-NA
values are the same. By default <code>only_within = TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector - <code>x</code> containing all <code>x</code> elements with <code>NA</code>
replaced with previous non-NA element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fill_run(c(NA, NA, 1:10, NA, NA), run_for_first = TRUE)
fill_run(c(NA, NA, 1:10, NA, NA), run_for_first = TRUE)
fill_run(c(NA, NA, 1:10, NA, NA), run_for_first = FALSE)
fill_run(c(NA, NA, 1, 2, NA, NA, 2, 2, NA, NA, 1, NA, NA), run_for_first = TRUE, only_within = TRUE)
</code></pre>

<hr>
<h2 id='lag_run'>Lag dependent on variable</h2><span id='topic+lag_run'></span>

<h3>Description</h3>

<p>Vector of input lagged along integer vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_run(x, lag = 1L, idx = integer(0), nearest = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag_run_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="lag_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="lag_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="lag_run_+3A_nearest">nearest</code></td>
<td>
<p><code>logical</code> single value. Applied when <code>idx</code> is used,
then <code>nearest = FALSE</code> returns observation lagged exactly by the
specified number of &quot;periods&quot;. When <code>nearest = TRUE</code>
function returns latest observation within lag window.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>lag_run(1:10, lag = 3)
lag_run(letters[1:10], lag = -2, idx = c(1, 1, 1, 2, 3, 4, 6, 7, 8, 10))
lag_run(letters[1:10], lag = 2, idx = c(1, 1, 1, 2, 3, 4, 6, 7, 8, 10), nearest = TRUE)
</code></pre>

<hr>
<h2 id='length_run'>Length of running windows</h2><span id='topic+length_run'></span>

<h3>Description</h3>

<p>Number of elements in k-long window calculated on <code>idx</code> vector.
If <code>idx</code> is an <code>as.integer(date)</code> vector, then k=number of days in window -
then the result is number of observations within k days window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>length_run(k = integer(1), lag = integer(1), idx = integer(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length_run_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="length_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="length_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>length_run(k = 3, idx = c(1, 2, 2, 4, 5, 5, 5, 5, 5, 5))
</code></pre>

<hr>
<h2 id='max_run'>Running maximum</h2><span id='topic+max_run'></span>

<h3>Description</h3>

<p><code>min_run</code> calculates running max on given <code>x</code> numeric vector,
specified <code>k</code> window size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_run(
  x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_rm = TRUE,
  na_pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_run_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="max_run_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="max_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="max_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="max_run_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="max_run_+3A_na_rm">na_rm</code></td>
<td>
<p><code>logical</code> single value (default <code>na_rm = TRUE</code>) -
if <code>TRUE</code> sum is calculating excluding <code>NA</code>.</p>
</td></tr>
<tr><td><code id="max_run_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>max (<code>numeric</code>) vector of length equals length of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
x1 &lt;- sample(c(1, 2, 3), 15, replace = TRUE)
x2 &lt;- sample(c(NA, 1, 2, 3), 15, replace = TRUE)
k &lt;- sample(1:4, 15, replace = TRUE)
max_run(x1) # simple cumulative maximum
max_run(x2, na_rm = TRUE) # cumulative maximum with removing NA.
max_run(x2, na_rm = TRUE, k = 4) # maximum in 4-element window
max_run(x2, na_rm = FALSE, k = k) # maximum in varying k window size
</code></pre>

<hr>
<h2 id='mean_run'>Running mean</h2><span id='topic+mean_run'></span>

<h3>Description</h3>

<p>Running mean in specified window of numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_run(
  x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_rm = TRUE,
  na_pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_run_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector which running function is calculated on</p>
</td></tr>
<tr><td><code id="mean_run_+3A_k">k</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;integer`` vector or single value)\cr Denoting size of the running window. If &#8288;</code>k<code style="white-space: pre;">&#8288;is a single value then window size is constant for all elements, otherwise if&#8288;</code>length(k) == length(x)'
different window size for each element.</p>
</td></tr>
<tr><td><code id="mean_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward.</p>
</td></tr>
<tr><td><code id="mean_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and <code>lag</code>
are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length <code>x</code>.</p>
</td></tr>
<tr><td><code id="mean_run_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at.</p>
</td></tr>
<tr><td><code id="mean_run_+3A_na_rm">na_rm</code></td>
<td>
<p><code>logical</code> single value (default <code>na_rm = TRUE</code>) -
if <code>TRUE</code> sum is calculating excluding <code>NA</code>.</p>
</td></tr>
<tr><td><code id="mean_run_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean (<code>numeric</code>) vector of length equals length of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
x1 &lt;- rnorm(15)
x2 &lt;- sample(c(rep(NA, 5), rnorm(15)), 15, replace = TRUE)
k &lt;- sample(1:15, 15, replace = TRUE)
mean_run(x1)
mean_run(x2, na_rm = TRUE)
mean_run(x2, na_rm = FALSE)
mean_run(x2, na_rm = TRUE, k = 4)
</code></pre>

<hr>
<h2 id='min_run'>Running minimum</h2><span id='topic+min_run'></span>

<h3>Description</h3>

<p><code>min_run</code> calculates running min on given <code>x</code> numeric vector, specified <code>k</code> window size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_run(
  x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_rm = TRUE,
  na_pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_run_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="min_run_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="min_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="min_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="min_run_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="min_run_+3A_na_rm">na_rm</code></td>
<td>
<p><code>logical</code> single value (default <code>na_rm = TRUE</code>) -
if <code>TRUE</code> sum is calculating excluding <code>NA</code>.</p>
</td></tr>
<tr><td><code id="min_run_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>min (<code>numeric</code>) vector of length equals length of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
x1 &lt;- sample(c(1, 2, 3), 15, replace = TRUE)
x2 &lt;- sample(c(NA, 1, 2, 3), 15, replace = TRUE)
k &lt;- sample(1:4, 15, replace = TRUE)
min_run(x1)
min_run(x2, na_rm = TRUE)
min_run(x2, na_rm = TRUE, k = 4)
min_run(x2, na_rm = FALSE, k = k)
</code></pre>

<hr>
<h2 id='minmax_run'>Running min/max</h2><span id='topic+minmax_run'></span>

<h3>Description</h3>

<p><code>min_run</code> calculates running minimum-maximum on given <code>x</code> numeric
vector, specified <code>k</code> window size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minmax_run(x, metric = "min", na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minmax_run_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="minmax_run_+3A_metric">metric</code></td>
<td>
<p><code>character</code> what to return, minimum or maximum</p>
</td></tr>
<tr><td><code id="minmax_run_+3A_na_rm">na_rm</code></td>
<td>
<p><code>logical</code> single value (default <code>na_rm = TRUE</code>) -
if <code>TRUE</code> sum is calculating excluding <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list.
</p>

<hr>
<h2 id='run_by'>Set window parameters</h2><span id='topic+run_by'></span>

<h3>Description</h3>

<p>Set window parameters for <code><a href="#topic+runner">runner()</a></code>. This function sets the
attributes to <code>x</code> (only <code>data.frame</code>) object and saves user effort
to specify window parameters in further multiple <code><a href="#topic+runner">runner()</a></code> calls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_by(x, idx, k, lag, na_pad, at)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_by_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="run_by_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="run_by_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="run_by_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="run_by_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
<tr><td><code id="run_by_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x object which <code><a href="#topic+runner">runner()</a></code> can be executed on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)

data &lt;- data.frame(
  index = c(2, 3, 3, 4, 5, 8, 10, 10, 13, 15),
  a = rep(c("a", "b"), each = 5),
  b = 1:10
)

data %&gt;%
  group_by(a) %&gt;%
  run_by(idx = "index", k = 5) %&gt;%
  mutate(
    c = runner(
      x = .,
      f = function(x) {
        paste(x$b, collapse = "&gt;")
      }
    ),
    d = runner(
      x = .,
      f = function(x) {
        sum(x$b)
      }
    )
  )

## End(Not run)
</code></pre>

<hr>
<h2 id='runner'>Apply running function</h2><span id='topic+runner'></span><span id='topic+runner.default'></span><span id='topic+runner.data.frame'></span><span id='topic+runner.grouped_df'></span><span id='topic+runner.matrix'></span><span id='topic+runner.xts'></span>

<h3>Description</h3>

<p>Applies custom function on running windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## Default S3 method:
runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'data.frame'
runner(
  x,
  f = function(x) x,
  k = attr(x, "k"),
  lag = if (!is.null(attr(x, "lag"))) attr(x, "lag") else integer(1),
  idx = attr(x, "idx"),
  at = attr(x, "at"),
  na_pad = if (!is.null(attr(x, "na_pad"))) attr(x, "na_pad") else FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'grouped_df'
runner(
  x,
  f = function(x) x,
  k = attr(x, "k"),
  lag = if (!is.null(attr(x, "lag"))) attr(x, "lag") else integer(1),
  idx = attr(x, "idx"),
  at = attr(x, "at"),
  na_pad = if (!is.null(attr(x, "na_pad"))) attr(x, "na_pad") else FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'matrix'
runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)

## S3 method for class 'xts'
runner(
  x,
  f = function(x) x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE,
  simplify = TRUE,
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runner_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="runner_+3A_f">f</code></td>
<td>
<p>(<code>function</code>)<br />
Applied on windows created from <code>x</code>. This function is meant to summarize
windows and create single element for each window, but one can also specify
function which return multiple elements (runner output will be a list).
By default runner returns windows as is (<code style="white-space: pre;">&#8288;f = function(x)&#8288;</code>).</p>
</td></tr>
<tr><td><code id="runner_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="runner_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="runner_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="runner_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="runner_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
<tr><td><code id="runner_+3A_simplify">simplify</code></td>
<td>
<p>(<code>logical</code> or <code>character</code> value)<br />
should the result be simplified to a vector, matrix or higher dimensional
array if possible. The default value, <code>simplify = TRUE</code>, returns a vector or
matrix if appropriate, whereas if <code>simplify = "array"</code> the result may be an
array of &quot;rank&quot; <code style="white-space: pre;">&#8288;(=length(dim(.)))&#8288;</code> one higher than the result of output
from the function <code>f</code> for each window. Consequences of <code>simplify</code> in <code>runner</code>
are identical to <code>sapply</code>.</p>
</td></tr>
<tr><td><code id="runner_+3A_cl">cl</code></td>
<td>
<p>(<code>cluster</code>) <em>experimental</em><br />
Create and pass the cluster to the <code>runner</code> function to run each window
calculation in parallel. See <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code> in details.</p>
</td></tr>
<tr><td><code id="runner_+3A_...">...</code></td>
<td>
<p>(optional)<br />
other arguments passed to the function <code>f</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function can apply any R function on running windows defined by <code>x</code>,
<code>k</code>, <code>lag</code>, <code>idx</code> and <code>at</code>. Running window can be calculated
on several ways:
</p>

<ul>
<li> <p><strong>Cumulative windows</strong><br />
applied when user doesn't specify <code>k</code> argument or specify <code>k = length(x)</code>,
this would mean that <code>k</code> is equal to number of available elements <br />
<img src="../help/figures/cumulativewindows.png" width="75%" alt="Figure: cumulativewindows.png" />

</p>
</li>
<li> <p><strong>Constant sliding windows</strong>
applied when user specify <code>k</code> as constant value keeping <code>idx</code> and
<code>at</code> unspecified. <code>lag</code> argument shifts windows left (<code>lag &gt; 0</code>)
or right (<code>lag &lt; 0</code>). <br />
<img src="../help/figures/incrementalindex.png" width="75%" alt="Figure: incrementalindex.png" />

</p>
</li>
<li> <p><strong>Windows depending on date</strong><br />
If one specifies <code>idx</code> this would mean that output windows size might
change in size because of unequally spaced indexes. Fox example 5-period
window is different than 5-element window, because 5-period window might
contain any number of observation (7-day mean is not the same as 7-element
mean)
<br />
<img src="../help/figures/runningdatewindows.png" width="75%" alt="Figure: runningdatewindows.png" />

</p>
</li>
<li> <p><strong>Window at specific indices</strong><br />
<code>runner</code> by default returns vector of the same size as <code>x</code> unless one
specifies <code>at</code> argument. Each element of <code>at</code> is an index on which runner
calculates function - which means that output of the runner is now of
length equal to <code>at</code>. Note that one can change index of <code>x</code> by specifying
<code>idx</code>. Illustration below shows output of <code>runner</code> for
<code>at = c(18, 27, 45, 31)</code> which gives windows in ranges enclosed in square
brackets. Range for <code>at = 27</code> is <code style="white-space: pre;">&#8288;[22, 26]&#8288;</code> which is not available in
current indices. <br />
<img src="../help/figures/runnerat.png" width="75%" alt="Figure: runnerat.png" />

</p>
</li></ul>



<h4>Specifying time-intervals</h4>

<p><code>at</code> can also be specified as interval of the output defined by
<code>at = "&lt;increment&gt;"</code> which results in indices sequence defined by
<code>seq.POSIXt(min(idx), max(idx), by = "&lt;increment&gt;")</code>. Increment of sequence
is the same as in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code> function.
It's worth noting that increment interval can't be more frequent than
interval of <code>idx</code> - for <code>Date</code> the most frequent time-unit is a <code>"day"</code>,
for <code>POSIXt</code> a <code>sec</code>.
</p>
<p><code>k</code> and <code>lag</code> can also be specified as using time sequence increment.
Available time units are
<code style="white-space: pre;">&#8288;"sec", "min", "hour", "day", "DSTday", "week", "month", "quarter" or "year"&#8288;</code>.
To increment by number of units one can also specify <code style="white-space: pre;">&#8288;&lt;number&gt; &lt;unit&gt;s&#8288;</code>
for example <code>lag = "-2 days"</code>, <code>k = "5 weeks"</code>.
</p>
<p>Setting <code>k</code> and <code>lag</code> as a sequence increment can be also a vector can be a
vector which allows to stretch and lag/lead each window freely on in time
(on indices).
<br />
</p>



<h4>Parallel computing</h4>

<p>Beware that executing R call in parallel not always
have the edge over single-thread even if the
<code>cl &lt;- registerCluster(detectCores())</code> was specified before.
<br />
Parallel windows are executed in the independent environment, which means
that objects other than function arguments needs to be copied to the
parallel environment using <code><a href="parallel.html#topic+clusterApply">parallel::clusterExport()</a></code>. For
example using <code>f = function(x) x + y + z</code> will result in error as
<code>clusterExport(cl, varlist = c("y", "z"))</code> needs to be called before.
</p>



<h3>Value</h3>

<p>vector with aggregated values for each window. Length of output is
the same as <code>length(x)</code> or <code>length(at)</code> if specified. Type of the output
depends on the output from a function <code>f</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# runner returns windows as is by default
runner(1:10)

# mean on k = 3 elements windows
runner(1:10, f = mean, k = 3)

# mean on k = 3 elements windows with different specification
runner(1:10, k = 3, f = function(x) mean(x, na.rm = TRUE))

# concatenate two columns
runner(
  data.frame(
    a = letters[1:10],
    b = 1:10
  ),
  f = function(x) paste(paste0(x$a, x$b), collapse = "+")
)

# concatenate two columns with additional argument
runner(
  data.frame(
    a = letters[1:10],
    b = 1:10
  ),
  f = function(x, xxx) {
    paste(paste0(x$a, xxx, x$b), collapse = " + ")
  },
  xxx = "..."
)

# number of unique values in each window (varying window size)
runner(letters[1:10],
  k = c(1, 2, 2, 4, 5, 5, 5, 5, 5, 5),
  f = function(x) length(unique(x))
)

# concatenate only on selected windows index
runner(letters[1:10],
  f = function(x) paste(x, collapse = "-"),
  at = c(1, 5, 8)
)

# 5 days mean
idx &lt;- c(4, 6, 7, 13, 17, 18, 18, 21, 27, 31, 37, 42, 44, 47, 48)
runner::runner(
  x = idx,
  k = "5 days",
  lag = 1,
  idx = Sys.Date() + idx,
  f = function(x) mean(x)
)

# 5 days mean at 4-indices
runner::runner(
  x = 1:15,
  k = 5,
  lag = 1,
  idx = idx,
  at = c(18, 27, 48, 31),
  f = mean
)

# runner with data.frame
df &lt;- data.frame(
  a = 1:13,
  b = 1:13 + rnorm(13, sd = 5),
  idx = seq(as.Date("2022-02-22"), as.Date("2023-02-22"), by = "1 month")
)
runner(
  x = df,
  idx = "idx",
  at = "6 months",
  f = function(x) {
    cor(x$a, x$b)
  }
)

# parallel computing
library(parallel)
data &lt;- data.frame(
  a = runif(100),
  b = runif(100),
  idx = cumsum(sample(rpois(100, 5)))
)
const &lt;- 0
cl &lt;- makeCluster(1)
clusterExport(cl, "const", envir = environment())

runner(
  x = data,
  k = 10,
  f = function(x) {
    cor(x$a, x$b) + const
  },
  idx = "idx",
  cl = cl
)
stopCluster(cl)

# runner with matrix
data &lt;- matrix(data = runif(100, 0, 1), nrow = 20, ncol = 5)
runner(
  x = data,
  f = function(x) {
    tryCatch(
      cor(x),
      error = function(e) NA
    )
  }
)
</code></pre>

<hr>
<h2 id='streak_run'>Running streak length</h2><span id='topic+streak_run'></span>

<h3>Description</h3>

<p>Calculates running series of consecutive elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streak_run(
  x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_rm = TRUE,
  na_pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streak_run_+3A_x">x</code></td>
<td>
<p>any type vector which running function is calculated on</p>
</td></tr>
<tr><td><code id="streak_run_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="streak_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="streak_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="streak_run_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="streak_run_+3A_na_rm">na_rm</code></td>
<td>
<p><code>logical</code> single value (default <code>na_rm = TRUE</code>) -
if <code>TRUE</code> sum is calculating excluding <code>NA</code>.</p>
</td></tr>
<tr><td><code id="streak_run_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>streak <a href="base.html#topic+numeric">numeric</a> vector of length equals length of <code>x</code> containing
number of consecutive occurrences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
x1 &lt;- sample(c("a", "b"), 15, replace = TRUE)
x2 &lt;- sample(c(NA_character_, "a", "b"), 15, replace = TRUE)
k &lt;- sample(1:4, 15, replace = TRUE)
streak_run(x1) # simple streak run
streak_run(x1, k = 2) # streak run within 2-element window
streak_run(x2, na_pad = TRUE, k = 3) # streak run within k=3 with padding NA
streak_run(x1, k = k) # streak run within varying window size specified by vector k
</code></pre>

<hr>
<h2 id='sum_run'>Running sum</h2><span id='topic+sum_run'></span>

<h3>Description</h3>

<p>Running sum in specified window of numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_run(
  x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_rm = TRUE,
  na_pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_run_+3A_x">x</code></td>
<td>
<p><code>numeric</code> vector which running function is calculated on</p>
</td></tr>
<tr><td><code id="sum_run_+3A_k">k</code></td>
<td>
<p>(<code style="white-space: pre;">&#8288;integer`` vector or single value)\cr Denoting size of the running window. If &#8288;</code>k<code style="white-space: pre;">&#8288;is a single value then window size is constant for all elements, otherwise if&#8288;</code>length(k) == length(x)'
different window size for each element.</p>
</td></tr>
<tr><td><code id="sum_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward.</p>
</td></tr>
<tr><td><code id="sum_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and <code>lag</code>
are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length <code>x</code>.</p>
</td></tr>
<tr><td><code id="sum_run_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at.</p>
</td></tr>
<tr><td><code id="sum_run_+3A_na_rm">na_rm</code></td>
<td>
<p><code>logical</code> single value (default <code>na_rm = TRUE</code>) -
if <code>TRUE</code> sum is calculating excluding <code>NA</code>.</p>
</td></tr>
<tr><td><code id="sum_run_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum <code>numeric</code> vector of length equals length of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
x1 &lt;- rnorm(15)
x2 &lt;- sample(c(rep(NA, 5), rnorm(15)), 15, replace = TRUE)
k &lt;- sample(1:15, 15, replace = TRUE)
sum_run(x1)
sum_run(x2, na_rm = TRUE)
sum_run(x2, na_rm = FALSE)
sum_run(x2, na_rm = TRUE, k = 4)
</code></pre>

<hr>
<h2 id='which_run'>Running which</h2><span id='topic+which_run'></span>

<h3>Description</h3>

<p><code>min_run</code> calculates running which - returns index of element where <code>x == TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_run(
  x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  which = "last",
  na_rm = TRUE,
  na_pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="which_run_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="which_run_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="which_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="which_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="which_run_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="which_run_+3A_which">which</code></td>
<td>
<p><code>character</code> value &quot;first&quot; or &quot;last&quot; denoting if the first or last <code>TRUE</code>
index is returned from the window.</p>
</td></tr>
<tr><td><code id="which_run_+3A_na_rm">na_rm</code></td>
<td>
<p><code>logical</code> single value (default <code>na_rm = TRUE</code>) -
if <code>TRUE</code> sum is calculating excluding <code>NA</code>.</p>
</td></tr>
<tr><td><code id="which_run_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector of indexes of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
x1 &lt;- sample(c(1, 2, 3), 15, replace = TRUE)
x2 &lt;- sample(c(NA, 1, 2, 3), 15, replace = TRUE)
k &lt;- sample(1:4, 15, replace = TRUE)
which_run(x1)
which_run(x2, na_rm = TRUE)
which_run(x2, na_rm = TRUE, k = 4)
which_run(x2, na_rm = FALSE, k = k)
</code></pre>

<hr>
<h2 id='window_run'>List of running windows</h2><span id='topic+window_run'></span>

<h3>Description</h3>

<p>Creates <code>list</code> of windows with given arguments settings.
Length of output <code>list</code> is equal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>window_run(
  x,
  k = integer(0),
  lag = integer(1),
  idx = integer(0),
  at = integer(0),
  na_pad = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="window_run_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>, <code>data.frame</code>, <code>matrix</code>, <code>xts</code>, <code>grouped_df</code>)<br />
Input in runner custom function <code>f</code>.</p>
</td></tr>
<tr><td><code id="window_run_+3A_k">k</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting size of the running window. If <code>k</code> is a single value then window
size is constant for all elements, otherwise if <code>length(k) == length(x)</code>
different window size for each element. One can also specify <code>k</code> in the same
way as <code>by</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="window_run_+3A_lag">lag</code></td>
<td>
<p>(<code>integer</code> vector or single value)<br />
Denoting window lag. If <code>lag</code> is a single value then window lag is constant
for all elements, otherwise if <code>length(lag) == length(x)</code> different window
size for each element. Negative value shifts window forward. One can also
specify <code>lag</code> in the same way as <code>by</code> argument in
<code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>. See 'Specifying time-intervals' in details
section.</p>
</td></tr>
<tr><td><code id="window_run_+3A_idx">idx</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>)<br />
Optional integer vector containing sorted (ascending) index of observation.
By default <code>idx</code> is index incremented by one. User can provide index with
varying increment and with duplicated values. If specified then <code>k</code> and
<code>lag</code> are depending on <code>idx</code>. Length of <code>idx</code> have to be equal of length
<code>x</code>.</p>
</td></tr>
<tr><td><code id="window_run_+3A_at">at</code></td>
<td>
<p>(<code>integer</code>, <code>Date</code>, <code>POSIXt</code>, <code>character</code> vector)<br />
Vector of any size and any value defining output data points. Values of the
vector defines the indexes which data is computed at. Can be also <code>POSIXt</code>
sequence increment used in <code>at</code> argument in <code><a href="base.html#topic+seq.POSIXt">base::seq.POSIXt()</a></code>.
See 'Specifying time-intervals' in details section.</p>
</td></tr>
<tr><td><code id="window_run_+3A_na_pad">na_pad</code></td>
<td>
<p>(<code>logical</code> single value)<br />
Whether incomplete window should return <code>NA</code> (if <code>na_pad = TRUE</code>)
Incomplete window is when some parts of the window are out of range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of vectors (windows). Length of list is the same as
<code>length(x)</code> or <code>length(at)</code> if specified, and length of each
window is defined by <code>k</code> (unless window is out of range).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>window_run(1:10, k = 3, lag = -1)
window_run(letters[1:10], k = c(1, 2, 2, 4, 5, 5, 5, 5, 5, 5))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
