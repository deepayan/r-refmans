<!DOCTYPE html><html lang="en-US"><head><title>Help for package vapour</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vapour}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vapour-package'><p>vapour</p></a></li>
<li><a href='#buildvrt'><p>Build vrt, special case &quot;-separate&quot;</p></a></li>
<li><a href='#gdal_raster_data'><p>General raster read and convert</p></a></li>
<li><a href='#sst_c'><p>SST contours</p></a></li>
<li><a href='#tas_wkt'><p>Example WKT coordinate reference system</p></a></li>
<li><a href='#vapour_create'><p>Create raster file</p></a></li>
<li><a href='#vapour_crs_is_lonlat'><p>Is the CRS string representative of angular coordinates</p></a></li>
<li><a href='#vapour_gdal_version'><p>GDAL version and drivers.</p></a></li>
<li><a href='#vapour_geolocation'><p>Retrieve geolocation information for a dataset</p></a></li>
<li><a href='#vapour_geom_name'><p>Read geometry column name</p></a></li>
<li><a href='#vapour_geom_summary'><p>Summary of available geometry</p></a></li>
<li><a href='#vapour_layer_extent'><p>Read layer extent</p></a></li>
<li><a href='#vapour_layer_info'><p>Read GDAL layer info</p></a></li>
<li><a href='#vapour_layer_names'><p>Read GDAL layer names</p></a></li>
<li><a href='#vapour_raster_gcp'><p>Raster ground control points</p></a></li>
<li><a href='#vapour_raster_info'><p>Raster information</p></a></li>
<li><a href='#vapour_read_fids'><p>Read feature names</p></a></li>
<li><a href='#vapour_read_fields'><p>Read feature field data</p></a></li>
<li><a href='#vapour_read_geometry'><p>Read GDAL feature geometry</p></a></li>
<li><a href='#vapour_read_raster'><p>Raster IO (read)</p></a></li>
<li><a href='#vapour_read_raster_block'><p>Read or write raster block</p></a></li>
<li><a href='#vapour_read_raster_raw'><p>type safe(r) raster read</p></a></li>
<li><a href='#vapour_report_fields'><p>Read feature field types.</p></a></li>
<li><a href='#vapour_sds_names'><p>GDAL raster subdatasets (variables)</p></a></li>
<li><a href='#vapour_set_config'><p>Set and query GDAL configuration options</p></a></li>
<li><a href='#vapour_srs_wkt'><p>PROJ4 string to WKT</p></a></li>
<li><a href='#vapour_vrt'><p>Virtual raster</p></a></li>
<li><a href='#vapour_vsi_list'><p>Read GDAL virtual source contents</p></a></li>
<li><a href='#vapour_warp_raster'><p>Raster warper (reprojection)</p></a></li>
<li><a href='#vapour_warp_raster_raw'><p>type safe(r) raster warp</p></a></li>
<li><a href='#vapour_write_raster_block'><p>Write data to a block <em>in an existing file</em>.</p></a></li>
<li><a href='#vector_vrt'><p>Vector VRT</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Access to the 'Geospatial Data Abstraction Library' ('GDAL')</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides low-level access to 'GDAL' functionality.  
  'GDAL' is the 'Geospatial Data Abstraction Library' a translator for raster and vector geospatial data formats 
  that presents a single raster abstract data model and single vector abstract data model to the calling application 
  for all supported formats <a href="https://gdal.org/">https://gdal.org/</a>. This package is focussed on providing exactly and only what GDAL does, to enable
  developing further tools. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>jsonlite, Rcpp, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, markdown, rmarkdown, spelling</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>libgdal-dev, GDAL (&gt;= 2.2.3), PROJ (&gt;= 4.8.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/hypertidy/vapour">https://github.com/hypertidy/vapour</a>,
<a href="https://hypertidy.github.io/vapour/">https://hypertidy.github.io/vapour/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hypertidy/vapour/issues">https://github.com/hypertidy/vapour/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-14 08:00:45 UTC; mdsumner</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Sumner <a href="https://orcid.org/0000-0002-2471-7511"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Simon Wotherspoon [ctb] (RasterIO configuration for resampling options),
  Mark Padgham [ctb] (helped get started :)),
  Edzer Pebesma [ctb] (wrote the field-read handling, adapted here from
    sf),
  Roger Bivand [ctb] (wrote configure.ac, adapted here from rgdal),
  Jim Hester [ctb, cph] (wrote CollectorList.h, copied here from fs
    package),
  Timothy Keitt [ctb] (wrote GetPointsInternal copied here from rgdal2
    package),
  Jeroen Ooms [ctb] (tweaked build process, provided Windows build tools),
  Dale Maschette [ctb] (created the hex logo),
  Joseph Stachelek [ctb],
  Even Rouault [ctb] (primary author of the COG format and its use of the
    GDALwarp app-library, example code used by the warper function
    here),
  Robert Hijmans [ctb] (code in terra package used as
    example/inspiration),
  Dewey Dunnington [ctb] (wrote the columnar-access mode streaming Arrow
    support),
  Tomas Kalibera [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Sumner &lt;mdsumner@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-14 09:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vapour-package'>vapour</h2><span id='topic+vapour-package'></span><span id='topic+vapour'></span>

<h3>Description</h3>

<p>A lightweight GDAL API package for R.
</p>


<h3>Details</h3>

<p>Provides low-level access to 'GDAL' functionality for R packages. The aim is
to minimize the level of interpretation put on the 'GDAL' facilities, to
enable direct use of it for a variety of purposes. 'GDAL' is the 'Geospatial
Data Abstraction Library' a translator for raster and vector geospatial data
formats that presents a single raster abstract data model and single vector
abstract data model to the calling application for all supported formats
<a href="https://gdal.org/">https://gdal.org/</a>.
</p>
<p>Lightweight means we access parts of the GDAL API as near as possible to
their native usage. GDAL is not a lightweight library, but provide a very
nice abstraction over format details for a very large number of different
formats.
</p>
<p>Functions for raster and vector sources are included.
</p>

<table>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_all_drivers">vapour_all_drivers</a></code>         </td><td style="text-align: left;"> list of all
available drivers, with type and features </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_driver">vapour_driver</a></code>
</td><td style="text-align: left;"> report short name of driver that will be used for a data source </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vapour_gdal_version">vapour_gdal_version</a></code>        </td><td style="text-align: left;"> report version of GDAL in use
</td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_srs_wkt">vapour_srs_wkt</a></code>        </td><td style="text-align: left;"> produce WKT projection string
from various projection string inputs </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_vsi_list">vapour_vsi_list</a></code>
</td><td style="text-align: left;"> report contents of VSI sources </td>
</tr>
<tr>
 <td style="text-align: left;">

</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_raster_gcp">vapour_raster_gcp</a></code>        </td><td style="text-align: left;"> return internal
ground control points, if present </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_raster_info">vapour_raster_info</a></code>
</td><td style="text-align: left;"> structural metadata of a source </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_read_raster">vapour_read_raster</a></code>
</td><td style="text-align: left;"> read data direct from a window of a raster band source </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vapour_sds_names">vapour_sds_names</a></code>          </td><td style="text-align: left;"> list individual raster sources
in a source containing subdatasets </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_warp_raster">vapour_warp_raster</a></code>  </td><td style="text-align: left;">
read data direct from a raster source into a specific window </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_driver">vapour_driver</a></code>             </td><td style="text-align: left;"> report name of the
driver used for a given source </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_geom_name">vapour_geom_name</a></code>       </td><td style="text-align: left;">
report attribute name of geometry </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_geom_summary">vapour_geom_summary</a></code>
</td><td style="text-align: left;"> report simple properties of each feature geometry </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vapour_layer_names">vapour_layer_names</a></code>        </td><td style="text-align: left;"> list names of vector layers in a
data source </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_layer_info">vapour_layer_info</a></code> </td><td style="text-align: left;"> list of data source,
driver, layer name/s, fields, feature count, projection </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vapour_read_extent">vapour_read_extent</a></code>        </td><td style="text-align: left;"> read the extent, or bounding
box, of geometries in a layer </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_read_fields">vapour_read_fields</a></code>    </td><td style="text-align: left;">
read attributes of features in a layer, the columnar data associated with
each geometry </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_read_geometry">vapour_read_geometry</a></code>      </td><td style="text-align: left;"> read geometry
in binary (blob, WKB) form </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_read_geometry_ia">vapour_read_geometry_ia</a></code> </td><td style="text-align: left;">
read geometry by index, arbitrary </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_read_geometry_ij">vapour_read_geometry_ij</a></code>
</td><td style="text-align: left;"> read geometry by sequential index, i to j </td>
</tr>
<tr>
 <td style="text-align: left;">
<code><a href="#topic+vapour_read_geometry_text">vapour_read_geometry_text</a></code> </td><td style="text-align: left;"> read geometry in text form,
various formats </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_read_names">vapour_read_names</a></code>         </td><td style="text-align: left;"> read the
'names' of features in a layer, the 'FID' </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_read_type">vapour_read_type</a></code>
</td><td style="text-align: left;"> read the GDAL types of attributes </td>
</tr>
<tr>
 <td style="text-align: left;"> <code><a href="#topic+vapour_report_fields">vapour_report_fields</a></code>
</td><td style="text-align: left;"> report internal type of each attribute by name </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>As far as possible vapour aims to minimize the level of interpretation
provided for the functions, so that developers can choose how things are
implemented. Functions return raw lists or vectors rather than data frames or
classed types.
</p>


<h3>options</h3>

<p>The following options can be set to control global behaviour.
</p>

<table>
<tr>
 <td style="text-align: left;"> <code>Sys.getenv("vapour.sql.dialect")</code> </td><td style="text-align: left;"> the current SQL
dialect in use </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>



<h3>SQL dialect</h3>

<p>The SQL dialect can be set to &quot;&quot; (empty string), &quot;OGRSQL&quot;, or &quot;SQLITE&quot;.
</p>
<p>The empty string indicates that the native dialect will be used, see
<a href="https://gdal.org/user/ogr_sql_sqlite_dialect.html">OGRSQL and SQLITE for GDAL, accessed 2022-11-11</a> and the
<a href="https://gdal.org/api/raster_c_api.html#c.GDAL_DMD_SUPPORTED_SQL_DIALECTS">GDAL_DMD_SUPPORTED_SQL_DIALECTS development documentation (since GDAL 3.6)</a>.
</p>
<p>Setting &quot;NATIVE&quot; as an alias for &quot;&quot; is quite recent and has not been tested with vapour, similarly no testing has been done
with non OGRSQL-native or SQLITE-native drivers yet.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Sumner <a href="mailto:mdsumner@gmail.com">mdsumner@gmail.com</a> (<a href="https://orcid.org/0000-0002-2471-7511">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Simon Wotherspoon (RasterIO configuration for resampling options) [contributor]
</p>
</li>
<li><p> Mark Padgham (helped get started :)) [contributor]
</p>
</li>
<li><p> Edzer Pebesma (wrote the field-read handling, adapted here from sf) [contributor]
</p>
</li>
<li><p> Roger Bivand (wrote configure.ac, adapted here from rgdal) [contributor]
</p>
</li>
<li><p> Jim Hester (wrote CollectorList.h, copied here from fs package) [contributor, copyright holder]
</p>
</li>
<li><p> Timothy Keitt (wrote GetPointsInternal copied here from rgdal2 package) [contributor]
</p>
</li>
<li><p> Jeroen Ooms (tweaked build process, provided Windows build tools) [contributor]
</p>
</li>
<li><p> Dale Maschette (created the hex logo) [contributor]
</p>
</li>
<li><p> Joseph Stachelek [contributor]
</p>
</li>
<li><p> Even Rouault (primary author of the COG format and its use of the GDALwarp app-library, example code used by the warper function here) [contributor]
</p>
</li>
<li><p> Robert Hijmans (code in terra package used as example/inspiration) [contributor]
</p>
</li>
<li><p> Dewey Dunnington (wrote the columnar-access mode streaming Arrow support) [contributor]
</p>
</li>
<li><p> Tomas Kalibera [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/hypertidy/vapour">https://github.com/hypertidy/vapour</a>
</p>
</li>
<li> <p><a href="https://hypertidy.github.io/vapour/">https://hypertidy.github.io/vapour/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hypertidy/vapour/issues">https://github.com/hypertidy/vapour/issues</a>
</p>
</li></ul>


<hr>
<h2 id='buildvrt'>Build vrt, special case &quot;-separate&quot;</h2><span id='topic+buildvrt'></span>

<h3>Description</h3>

<p>Build vrt, special case &quot;-separate&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildvrt(dsn)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildvrt_+3A_dsn">dsn</code></td>
<td>
<p>one or more raster sources</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string of the built vrt, multiple sources treated as bands
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata/sst.tif", package = "vapour", mustWork = TRUE)
vrt &lt;- buildvrt(c(f, vapour_vrt(f)))
writeLines(vrt)
</code></pre>

<hr>
<h2 id='gdal_raster_data'>General raster read and convert</h2><span id='topic+gdal_raster_data'></span><span id='topic+gdal_raster_dsn'></span><span id='topic+gdal_raster_image'></span><span id='topic+gdal_raster_nara'></span>

<h3>Description</h3>

<p>The warper is used to convert source/s to an output file or to data in memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdal_raster_data(
  dsn,
  target_crs = NULL,
  target_dim = NULL,
  target_ext = NULL,
  target_res = NULL,
  resample = "near",
  bands = 1L,
  band_output_type = NULL,
  options = character(),
  include_meta = TRUE
)

gdal_raster_dsn(
  dsn,
  target_crs = NULL,
  target_dim = NULL,
  target_ext = NULL,
  target_res = NULL,
  resample = "near",
  bands = NULL,
  band_output_type = NULL,
  options = character(),
  out_dsn = tempfile(fileext = ".tif"),
  include_meta = TRUE
)

gdal_raster_image(
  dsn,
  target_crs = NULL,
  target_dim = NULL,
  target_ext = NULL,
  target_res = NULL,
  resample = "near",
  bands = NULL,
  band_output_type = NULL,
  options = character(),
  include_meta = TRUE
)

gdal_raster_nara(
  dsn,
  target_crs = NULL,
  target_dim = NULL,
  target_ext = NULL,
  target_res = NULL,
  resample = "near",
  bands = NULL,
  band_output_type = NULL,
  options = character(),
  include_meta = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdal_raster_data_+3A_dsn">dsn</code></td>
<td>
<p>data sources, files, urls, db strings, vrt, etc</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_target_crs">target_crs</code></td>
<td>
<p>projection of the target grid</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_target_dim">target_dim</code></td>
<td>
<p>dimension of the target grid</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_target_ext">target_ext</code></td>
<td>
<p>extent of the target grid</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_target_res">target_res</code></td>
<td>
<p>resolution of the target grid</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_resample">resample</code></td>
<td>
<p>resampling algorithm used</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_bands">bands</code></td>
<td>
<p>band or bands to include, default is first band only (use NULL or a value less that one to obtain all bands)</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_band_output_type">band_output_type</code></td>
<td>
<p>specify the band type, see <a href="#topic+vapour_read_raster">vapour_read_raster</a></p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_options">options</code></td>
<td>
<p>general options passed to gdal warper</p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_include_meta">include_meta</code></td>
<td>
<p>metadata is attached, turn off by setting this to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="gdal_raster_data_+3A_out_dsn">out_dsn</code></td>
<td>
<p>file name for output &quot;_dsn&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two functions 'gdal_raster_data' and 'gdal_raster_dsn' act like the gdalwarp command line
tool, a convenience third function 'gdal_raster_image()' works especially for image data.
</p>


<h3>Value</h3>

<p>pixel values in a list vector per band, or a list of file paths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dsn &lt;- system.file("extdata/sst.tif", package = "vapour")
## do nothing, get native
X &lt;- gdal_raster_data(dsn)

## set resolution (or dimension, extent, crs, or combination thereof - GDAL 
## will report/resolve incompatible opts)
X1 &lt;- gdal_raster_data(dsn,  target_res = 1)

## add a cutline, and cut to it using gdal warp args

if (interactive()) {
 cutline &lt;- tempfile(fileext = ".csv")
 wkt &lt;- "POLYGON ((142 -41, 149 -41, 146 -58, 142 -41))"
 write.csv(data.frame(id = 1, WKT = wkt), cutline, row.names = FALSE)
 X1c &lt;- gdal_raster_data(dsn,  target_res = .5, 
     options = c("-cutline",cutline, "-crop_to_cutline"))
 file.remove(cutline)
}

## warp whole grid to given res
X2 &lt;- gdal_raster_data(dsn,  target_res = 25000, target_crs = "EPSG:32755")

## specify exactly (as per vapour originally)
X3 &lt;- gdal_raster_data(dsn,  target_ext = c(-1, 1, -1, 1) * 8e6, 
 target_dim = c(512, 678), target_crs = "+proj=stere +lon_0=147 +lat_0=-90")
 
X4 &lt;- gdal_raster_dsn(dsn, out_dsn = tempfile(fileext = ".tif"))
</code></pre>

<hr>
<h2 id='sst_c'>SST contours</h2><span id='topic+sst_c'></span>

<h3>Description</h3>

<p>Southern Ocean GHRSST contours in sf data frame from 2017-07-28, read from
</p>


<h3>Details</h3>

<p>podaac-ftp.jpl.nasa.gov/allData/ghrsst/data/GDS2/L4
GLOB/JPL/MUR/v4.1/2017/209/
20170728090000-JPL-L4_GHRSST-SSTfnd-MUR-GLOB-v02.0-fv04.1.nc
</p>
<p>See data-raw/sst_c.R for the derivation column <code>sst_c</code> in Celsius.
</p>
<p>Also stored in FlatGeoBuf format in
<code>system.file("extdata/sst_c.fgb", package = "vapour")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata/sst_c.fgb", package = "vapour")

## create a class-less form of the data in the 'sst_c.fgb' file  with GeoJSON geometry
atts &lt;- vapour_read_fields(f)
dat &lt;- as.data.frame(atts, stringsAsFactors = FALSE)
dat[["json"]] &lt;- vapour_read_geometry_text(f)
names(dat)
names(sst_c)
</code></pre>

<hr>
<h2 id='tas_wkt'>Example WKT coordinate reference system</h2><span id='topic+tas_wkt'></span>

<h3>Description</h3>

<p>A Lambert Azimuthal Equal Area Well-Known-Text string for a region
centred on Tasmania.
</p>


<h3>Details</h3>

<p>Created from '+proj=laea +lon_0=147 +lat_0=-42 +datum=WGS84'.
For use in a future warping example.
</p>

<hr>
<h2 id='vapour_create'>Create raster file</h2><span id='topic+vapour_create'></span><span id='topic+vapour_create_options'></span>

<h3>Description</h3>

<p>This is in an incomplete interface to raster writing, for exploring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_create_options(driver = "GTiff")

vapour_create(
  filename,
  driver = "GTiff",
  extent = c(-180, 180, -90, 90),
  dimension = c(2048, 1024),
  projection = "EPSG:4326",
  n_bands = 1L,
  overwrite = FALSE,
  datatype = "Float32",
  options = vapour_create_options(driver)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_create_+3A_driver">driver</code></td>
<td>
<p>GDAL driver to use (GTiff is default, and recommended)</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_filename">filename</code></td>
<td>
<p>filename/path to create</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_extent">extent</code></td>
<td>
<p>xmin,xmax,ymin,ymax 4-element vector</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_dimension">dimension</code></td>
<td>
<p>dimension of the output, X * Y</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_projection">projection</code></td>
<td>
<p>projection of the output, best to use a full WKT but any string accepted</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_n_bands">n_bands</code></td>
<td>
<p>number of bands in the output, default is 1</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_overwrite">overwrite</code></td>
<td>
<p>not TRUE by default</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_datatype">datatype</code></td>
<td>
<p>the name of a GDAL datatype ('Float32', 'Int64', etc)</p>
</td></tr>
<tr><td><code id="vapour_create_+3A_options">options</code></td>
<td>
<p>character vector of creation of options for the driver in use <code>c('COMPRESS=DEFLATE')</code> note how these are constructed (no '-co' element)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If GeoTIFF is used (<code>driver = "GTiff"</code>, recommended) then the output is tiled 512x512, and has DEFLATE compression, and
is sparse when created (no values are initiated, so the file is tiny).
</p>
<p>Note that there is no restriction on where you can read or write from, the responsibility is yours. There is no auto driver detection
done for the file format, it's up to you to set the file extension <em>and</em> the driver.
</p>
<p>File is created using CreateCopy from a VRT in memory. This is so that we can instantiate COG layer with 'driver = &quot;COG&quot;'.
Please note that performance is best for GTiff itself, with 'SPARSE_OK=YES'. We don't yet know how to instantiate a large
COG with overviews.
</p>
<p>There are default creation options set for COG and GTiff drivers, see 'vapour_create_options(driver &quot;GTiff&quot;)' for what those are.
</p>


<h3>Value</h3>

<p>the file path that was created
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tfile &lt;- tempfile(fileext = ".tif")
if (!file.exists(tfile)) {
 vapour_create(tfile, extent = c(-1, 1, -1, 1) * 1e6, 
                     dimension = c(128, 128), 
                     projection = "+proj=laea")
 file.remove(tfile)
}
</code></pre>

<hr>
<h2 id='vapour_crs_is_lonlat'>Is the CRS string representative of angular coordinates</h2><span id='topic+vapour_crs_is_lonlat'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if this is longitude latitude data. Missing, malformed, zero-length values are disallowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_crs_is_lonlat(crs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_crs_is_lonlat_+3A_crs">crs</code></td>
<td>
<p>character string of length 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value <code>TRUE</code> for lonlat, <code>FALSE</code> otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vapour_gdal_version() ## versions to catch problems with string input
vapour_proj_version()
vapour_crs_is_lonlat("+proj=aeqd +lon_0=147 +lat_0=-42")
vapour_crs_is_lonlat("EPSG:4326")
vapour_srs_wkt("+proj=laea")
vapour_crs_is_lonlat("+proj=laea +type=crs")
vapour_crs_is_lonlat("OGC:CRS84")
vapour_crs_is_lonlat("WGS84")
vapour_crs_is_lonlat("NAD27")
vapour_crs_is_lonlat("EPSG:3031")
</code></pre>

<hr>
<h2 id='vapour_gdal_version'>GDAL version and drivers.</h2><span id='topic+vapour_gdal_version'></span><span id='topic+vapour_all_drivers'></span><span id='topic+vapour_driver'></span><span id='topic+vapour_proj_version'></span>

<h3>Description</h3>

<p>Return information about the GDAL library in use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_gdal_version()

vapour_proj_version()

vapour_all_drivers()

vapour_driver(dsource)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_gdal_version_+3A_dsource">dsource</code></td>
<td>
<p>data source string (i.e. file name or URL or database connection string)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vapour_gdal_version</code> returns the version of GDAL as a string. This corresponds to the &quot;&ndash;version&quot;
as described for &quot;GDALVersionInfo&quot;. <a href="https://gdal.org/">GDAL documentation</a>.
</p>
<p><code>vapour_all_drivers</code> returns the names and capabilities of all available drivers, in a list. This contains:
</p>

<ul>
<li> <p><code>driver</code> the driver (short) name
</p>
</li>
<li> <p><code>name</code> the (long) description name
</p>
</li>
<li> <p><code>vector</code> logical vector indicating a vector driver
</p>
</li>
<li> <p><code>raster</code> logical vector indicating a raster driver
</p>
</li>
<li> <p><code>create</code> driver can create (note vapour provides no write capacity)
</p>
</li>
<li> <p><code>copy</code>   driver can copy (note vapour provides no write capacity)
</p>
</li>
<li> <p><code>virtual</code> driver has virtual capabilities ('vsi')
</p>
</li></ul>

<p><code>vapour_driver()</code> returns the short name of the driver, e.g. 'GPKG' or 'GTiff', to get the
long name and other properties use <code>vapour_all_drivers()</code> and match on 'driver'.
</p>


<h3>Value</h3>

<p>please see Details, character vectors or lists of character vectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vapour_gdal_version()

drv &lt;- vapour_all_drivers()

f &lt;- system.file("extdata/sst_c.fgb", package = "vapour")
vapour_driver(f)

as.data.frame(drv)[match(vapour_driver(f), drv$driver), ]
</code></pre>

<hr>
<h2 id='vapour_geolocation'>Retrieve geolocation information for a dataset</h2><span id='topic+vapour_geolocation'></span>

<h3>Description</h3>

<p>Value is a named vector in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_geolocation(x, sds = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_geolocation_+3A_x">x</code></td>
<td>
<p>data source string (i.e. file name or URL or database connection string)</p>
</td></tr>
<tr><td><code id="vapour_geolocation_+3A_sds">sds</code></td>
<td>
<p>a subdataset number, if necessary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no geolocation exist the return value is an empty list.
</p>


<h3>Value</h3>

<p>list with a single character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>drivers &lt;- vapour_all_drivers()
ok &lt;- drivers$raster[ drivers$driver == "netCDF"]
if (isTRUE(ok)) {
 vapour_geolocation(system.file("extdata/gdal/geos_rad.nc", package = "vapour"), 0L)
}
</code></pre>

<hr>
<h2 id='vapour_geom_name'>Read geometry column name</h2><span id='topic+vapour_geom_name'></span>

<h3>Description</h3>

<p>There might be one or more geometry column names, or it might be an empty string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_geom_name(dsource, layer = 0L, sql = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_geom_name_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_geom_name_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_geom_name_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It might be &quot;&quot;, or &quot;geom&quot;, or &quot;<em>ogr_geometry</em>&quot; - the last is a default name
given when SQL is executed by GDAL but there was no geometry name, and 'SELECT * ' or
equivalent was used.
</p>
<p>This feature is required by the DBI backend work in RGDALSQL, so that when <code style="white-space: pre;">&#8288;SELECT * &#8288;</code> is used
we can give a reasonable name to the geometry column which is obtained separately.
</p>


<h3>Value</h3>

<p>character vector of geometry column name/s
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("extdata/tab/list_locality_postcode_meander_valley.tab", package = "vapour")
vapour_geom_name(file)  ## empty string
</code></pre>

<hr>
<h2 id='vapour_geom_summary'>Summary of available geometry</h2><span id='topic+vapour_geom_summary'></span>

<h3>Description</h3>

<p>Read properties of geometry from a source, optionally after SQL execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_geom_summary(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_geom_summary_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_geom_summary_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_geom_summary_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
<tr><td><code id="vapour_geom_summary_+3A_limit_n">limit_n</code></td>
<td>
<p>an arbitrary limit to the number of features scanned</p>
</td></tr>
<tr><td><code id="vapour_geom_summary_+3A_skip_n">skip_n</code></td>
<td>
<p>an arbitrary number of features to skip</p>
</td></tr>
<tr><td><code id="vapour_geom_summary_+3A_extent">extent</code></td>
<td>
<p>apply an arbitrary extent, only when 'sql' used (must be 'ex = c(xmin, xmax, ymin, ymax)' but sp bbox, sf bbox, and raster extent also accepted)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>limit_n</code> to arbitrarily limit the number of features queried.
</p>


<h3>Value</h3>

<p>list containing the following
</p>

<ul>
<li> <p><code>FID</code> the feature id value (an integer, usually sequential)
</p>
</li>
<li> <p><code>valid_geometry</code> logical value if a non-empty geometry is available
</p>
</li>
<li> <p><code>type</code> integer value of geometry type from <a href="https://gdal.org/doxygen/ogr__core_8h.html#a800236a0d460ef66e687b7b65610f12a">GDAL enumeration</a>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;xmin, xmax, ymin, ymax&#8288;</code> numeric values of the extent (bounding box) of each geometry
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
vapour_geom_summary(mvfile, limit_n = 3L)

gsum &lt;- vapour_geom_summary(mvfile)
plot(NA, xlim = range(c(gsum$xmin, gsum$xmax), na.rm = TRUE),
         ylim = range(c(gsum$ymin, gsum$ymax), na.rm = TRUE))
rect(gsum$xmin, gsum$ymin, gsum$xmax, gsum$ymax)
text(gsum$xmin, gsum$ymin, labels = gsum$FID)
</code></pre>

<hr>
<h2 id='vapour_layer_extent'>Read layer extent</h2><span id='topic+vapour_layer_extent'></span>

<h3>Description</h3>

<p>Extent of all features in entire layer, possibly after execution of sql query and
input extent filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_layer_extent(dsource, layer = 0L, sql = "", extent = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_layer_extent_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_layer_extent_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_layer_extent_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
<tr><td><code id="vapour_layer_extent_+3A_extent">extent</code></td>
<td>
<p>optional extent (xmin,xmax,ymin,ymax)</p>
</td></tr>
<tr><td><code id="vapour_layer_extent_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of numeric values xmin,xmax,ymin,ymax
</p>


<h3>See Also</h3>

<p>vapour_read_extent vapour_layer_info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
## A MapInfo TAB file with polygons
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
vapour_layer_extent(mvfile)
</code></pre>

<hr>
<h2 id='vapour_layer_info'>Read GDAL layer info</h2><span id='topic+vapour_layer_info'></span>

<h3>Description</h3>

<p>Read GDAL layer information for a vector data source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_layer_info(
  dsource,
  layer = 0L,
  sql = "",
  extent = NA,
  count = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_layer_info_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_layer_info_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_layer_info_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
<tr><td><code id="vapour_layer_info_+3A_extent">extent</code></td>
<td>
<p>apply an arbitrary extent, only when 'sql' used (must be 'ex = c(xmin, xmax, ymin, ymax)' but sp bbox, sf bbox, and raster extent also accepted)</p>
</td></tr>
<tr><td><code id="vapour_layer_info_+3A_count">count</code></td>
<td>
<p>logical to control if count calculated and returned, TRUE by default (set to FALSE to avoid the extra calculation and missing value is the result)</p>
</td></tr>
<tr><td><code id="vapour_layer_info_+3A_...">...</code></td>
<td>
<p>unused, reserved for future use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Set <code>extent</code> and/or <code>count</code> to <code>FALSE</code> to avoid calculating them if not needed, it might take some time.
</p>
<p>The layer information elements are
</p>

<dl>
<dt>dsn</dt><dd><p>the data source name</p>
</dd>
<dt>driver</dt><dd><p>the short name of the driver used</p>
</dd>
<dt>layer</dt><dd><p>the name of the layer queried</p>
</dd>
<dt>layer_names</dt><dd><p>the name/s of all available layers (see <a href="#topic+vapour_layer_names">vapour_layer_names</a>)</p>
</dd>
<dt>fields</dt><dd><p>a named vector of field types (see <a href="#topic+vapour_report_fields">vapour_report_fields</a>)</p>
</dd>
<dt>count</dt><dd><p>the number of features in this data source (can be turned off to avoid the extra work <code>count</code>)</p>
</dd>
<dt>extent</dt><dd><p>the extent of all features xmin, xmax, ymin, ymax (can be turned off to avoid the extra work <code>extent</code>)</p>
</dd>
<dt>projection</dt><dd><p>a list of character strings, see next</p>
</dd>
</dl>

<p><code style="white-space: pre;">&#8288;$projection&#8288;</code> is a list of various formats of the projection metadata.
Use <code style="white-space: pre;">&#8288;$projection$Wkt&#8288;</code> as most authoritative, but we don't enter into the discussion or limit what
might be done with this (that's up to you). Currently we see
<code>c("Proj4", "MICoordSys", "PrettyWkt", "Wkt", "EPSG", "XML")</code> as names of this <code style="white-space: pre;">&#8288;$projection&#8288;</code> element.
</p>
<p>To get the geometry type/s of a layer see <code><a href="#topic+vapour_read_type">vapour_read_type()</a></code>.
</p>


<h3>Value</h3>

<p>list with a list of character vectors of projection metadata, see details
</p>


<h3>See Also</h3>

<p>vapour_geom_name vapour_layer_names vapour_report_fields vapour_read_fields vapour_driver vapour_read_names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
## A MapInfo TAB file with polygons
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
info &lt;- vapour_layer_info(mvfile)
names(info$projection)

## info depends on the query/spatial-filter
vapour_layer_info(mvfile, extent = c(412000,  420000, 5352612.8, 5425154.3), 
  sql = "SELECT * FROM list_locality_postcode_meander_valley")$count
</code></pre>

<hr>
<h2 id='vapour_layer_names'>Read GDAL layer names</h2><span id='topic+vapour_layer_names'></span>

<h3>Description</h3>

<p>Obtain the names of available layers from a GDAL vector source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_layer_names(dsource, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_layer_names_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_layer_names_+3A_...">...</code></td>
<td>
<p>arguments ignore for deprecated compatibility (no 'sql' argument any longer)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some vector sources have multiple layers while many have only one. Shapefiles
for example have only one, and the single layer gets the file name with no path
and no extension. GDAL provides a quirk for shapefiles in that a directory may
act as a data source, and any shapefile in that directory acts like a layer of that
data source. This is a little like the one-or-many sleight that exists for raster
data sources with subdatasets (there's no way to virtualize single rasters into
a data source with multiple subdatasets, oh except by using VRT....)
</p>
<p>See <a href="#topic+vapour_sds_names">vapour_sds_names</a> for more on the multiple topic.
</p>


<h3>Value</h3>

<p>character vector of layer names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
vapour_layer_names(mvfile)
</code></pre>

<hr>
<h2 id='vapour_raster_gcp'>Raster ground control points</h2><span id='topic+vapour_raster_gcp'></span>

<h3>Description</h3>

<p>Return any ground control points for a raster data set, if they exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_raster_gcp(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_raster_gcp_+3A_x">x</code></td>
<td>
<p>data source string (i.e. file name or URL or database connection string)</p>
</td></tr>
<tr><td><code id="vapour_raster_gcp_+3A_...">...</code></td>
<td>
<p>ignored currently</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pixel and Line coordinates do not correspond to cells in the underlying raster grid, they
refer to the index space of that array in 0, ncols and 0, nrows. They are usually a subsample of
the grid and may not align with the grid spacing itself (though they often do in satellite remote sensing products).
</p>
<p>The coordinate system of the GCPs is currently not read.
</p>


<h3>Value</h3>

<p>list with
</p>

<ul>
<li> <p><code>Pixel</code> the pixel coordinate
</p>
</li>
<li> <p><code>Line</code> the line coordinate
</p>
</li>
<li> <p><code>X</code> the X coordinate of the GCP
</p>
</li>
<li> <p><code>Y</code> the Y coordinate of the GCP
</p>
</li>
<li> <p><code>Z</code> the Z coordinate of the GCP (usually zero)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## this file has no ground control points
## they are rare, and tend to be in large files
f &lt;- system.file("extdata", "sst.tif", package = "vapour")
vapour_raster_gcp(f)

## a very made-up example with no real use
f1 &lt;- system.file("extdata/gcps", "volcano_gcp.tif", package = "vapour")
vapour_raster_gcp(f1)

</code></pre>

<hr>
<h2 id='vapour_raster_info'>Raster information</h2><span id='topic+vapour_raster_info'></span>

<h3>Description</h3>

<p>Return the basic structural metadata of a raster source understood by GDAL.
Subdatasets may be specified by number, starting at 1. See
<a href="#topic+vapour_sds_names">vapour_sds_names</a> for more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_raster_info(x, ..., sds = NULL, min_max = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_raster_info_+3A_x">x</code></td>
<td>
<p>data source string (i.e. file name or URL or database connection string)</p>
</td></tr>
<tr><td><code id="vapour_raster_info_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
<tr><td><code id="vapour_raster_info_+3A_sds">sds</code></td>
<td>
<p>a subdataset number, if necessary</p>
</td></tr>
<tr><td><code id="vapour_raster_info_+3A_min_max">min_max</code></td>
<td>
<p>logical, control computing min and max values in source ('FALSE' by default)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The structural metadata are
</p>

<dl>
<dt>extent</dt><dd><p>the extent of the data, xmin, xmax, ymin, ymax - these are the lower left and upper right corners of pixels</p>
</dd>
<dt>geotransform</dt><dd><p>the affine transform</p>
</dd>
<dt>dimension</dt><dd><p>dimensions x-y, columns*rows</p>
</dd>
<dt>minmax</dt><dd><p>numeric values of the computed min and max from the first band (optional)</p>
</dd>
<dt>block</dt><dd><p>dimensions x-y of internal tiling scheme</p>
</dd>
<dt>projection</dt><dd><p>text version of map projection parameter string</p>
</dd>
<dt>bands</dt><dd><p>number of bands in the dataset</p>
</dd>
<dt>projstring</dt><dd><p>the proj string version of 'projection'</p>
</dd>
<dt>nodata_value</dt><dd><p>not implemented</p>
</dd>
<dt>overviews</dt><dd><p>the number and size of any available overviews</p>
</dd>
<dt>filelist</dt><dd><p>the list of files involved (may be none, and so will be a single NA character value)</p>
</dd>
<dt>datatype</dt><dd><p>the band type name, in GDAL form 'Byte', 'Int16', 'Float32', etc.</p>
</dd>
<dt>subdatasets</dt><dd><p>any subdataset DSNs is present, otherwise <code>NULL</code> </p>
</dd>
<dt>corners</dt><dd><p>corner coordinates of the data, for non-zero skew geotransforms a 2-column matrix with rows upperLeft, lowerLeft, lowerRight, upperRight, and center</p>
</dd>
</dl>

<p>Note that the geotransform is a kind of obscure combination of the extent and dimension, I don't find it
useful and modern GDAL is moving away from needing it so much. Extent is more sensible and used in many places in
a straightforward way.
</p>
<p>On access vapour functions will report on the existence of subdatasets while
defaulting to the first subdataset found.
</p>


<h3>Value</h3>

<p>list with vectors 'geotransform', 'dimXY', 'minmax', 'tilesXY', 'projection', 'bands', 'proj4', 'nodata_value',
'overviews', 'filelist' see sections in Details for more on each element
</p>


<h3>Subdatasets</h3>

<p>Some sources provide multiple data sets, where a dataset is described by a 2-
(or more) dimensional grid whose structure is described by the metadata
described above. Note that <em>subdataset</em> is a different concept to <em>band or
dimension</em>. Sources that may have multiple data sets are HDF4/HDF5 and
NetCDF, and they are loosely analogous to the concept of <em>layer</em> in GDAL
vector data. Variables are usually seen as distinct data but in GDAL and
related 2D-interpretations this concept is leveraged as a 3rd dimension (and
higher). In a GeoTIFF a third dimension might be implicit across bands, i.e.
to express time varying data and so each band is not properly a variable.
Similarly in NetCDF, the data may be any dimensional but there's only an
implicit link for other variables that exist in that same dimensional space.
When using GDAL you are always traversing this confusing realm.
</p>
<p>If subdatasets are present but not specified the first is queried. The choice
of subdataset is analogous to the way that the <code>raster</code> package behaves, and
uses the argument <code>varname</code>. Variables in NetCDF correspond to subdatasets,
but a single data set might have multiple variables in different bands or in
dimensions, so this guide does not hold across various systems.
</p>


<h3>The Geo Transform</h3>

<p>From <a href="https://gdal.org/user/raster_data_model.html">https://gdal.org/user/raster_data_model.html</a>.
</p>
<p>The affine transform consists of six coefficients returned by
<code>GDALDataset::GetGeoTransform()</code> which map pixel/line coordinates into
georeferenced space using the following relationship:
</p>
<p><code>Xgeo = GT(0) + Xpixel*GT(1) + Yline*GT(2)</code>
</p>
<p><code>Ygeo = GT(3) + Xpixel*GT(4) + Yline*GT(5)</code>
</p>
<p>They are
</p>

<dl>
<dt>GT0, xmin</dt><dd><p>the x position of the lower left corner of the lower left pixel</p>
</dd>
<dt>GT1, xres</dt><dd><p>the scale of the x-axis, the width of the pixel in x-units</p>
</dd>
<dt>GT2, yskew</dt><dd><p>y component of the pixel width</p>
</dd>
<dt>GT3, ymax</dt><dd><p>the y position of the upper left corner of the upper left pixel</p>
</dd>
<dt>GT4, xskew</dt><dd><p>x component of the pixel height</p>
</dd>
<dt>GT5, yres</dt><dd><p>the scale of the y-axis, the height of the pixel in <em>negative</em> y-units</p>
</dd>
</dl>

<p>Please note that these coefficients are equivalent to the contents of a
<em>world file</em> but that the order is not the same and the world file uses cell
centre convention rather than edge.
<a href="https://en.wikipedia.org/wiki/World_file">https://en.wikipedia.org/wiki/World_file</a>
</p>
<p>Usually the skew components are zero, and so only four coefficients are
relevant and correspond to the offset and scale used to position the raster -
in combination with the number of rows and columns of data they provide the
spatial extent and the pixel size in each direction.  Very rarely a an actual
affine raster will be use with this <em>rotation</em> specified within the transform
coefficients.
</p>
<p>Calculation of 'minmax' can take a significant amount of time, so it's not done by default. Use
'minmax = TRUE' to do it. (It does perform well, but may be prohibitive for very large or remote sources.)
</p>


<h3>Overviews</h3>

<p>If there are no overviews this element will simply be a single-element vector
of value 0. If there are overviews, the first value will give the number of overviews and
their dimensions will be listed as pairs of x,y values.
</p>


<h3>See Also</h3>

<p>vapour_sds_info
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "sst.tif", package = "vapour")
vapour_raster_info(f)
</code></pre>

<hr>
<h2 id='vapour_read_fids'>Read feature names</h2><span id='topic+vapour_read_fids'></span><span id='topic+vapour_read_names'></span>

<h3>Description</h3>

<p>Obtains the internal 'Feature ID (FID)' for a data source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_read_fids(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)

vapour_read_names(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_read_fids_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_read_fids_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_read_fids_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
<tr><td><code id="vapour_read_fids_+3A_limit_n">limit_n</code></td>
<td>
<p>an arbitrary limit to the number of features scanned</p>
</td></tr>
<tr><td><code id="vapour_read_fids_+3A_skip_n">skip_n</code></td>
<td>
<p>an arbitrary number of features to skip</p>
</td></tr>
<tr><td><code id="vapour_read_fids_+3A_extent">extent</code></td>
<td>
<p>apply an arbitrary extent, only when 'sql' used (must be 'ex = c(xmin, xmax, ymin, ymax)' but sp bbox, sf bbox, and raster extent also accepted)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This may be virtual (created by GDAL for the SQL interface) and may be 0- or
1- based. Some drivers have actual names, and they are persistent and
arbitrary. Please use with caution, this function can return the current
FIDs, but there's no guarantee of what it represents for subsequent access.
</p>
<p>An earlier version use 'OGRSQL' to obtain these names, which was slow for some
drivers and also clashed with independent use of the <code>sql</code> argument.
<code><a href="#topic+vapour_read_names">vapour_read_names()</a></code> is an older name, aliased to <code><a href="#topic+vapour_read_fids">vapour_read_fids()</a></code>.
</p>


<h3>Value</h3>

<p>character vector of geometry id 'names'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
range(fids &lt;- vapour_read_names(mvfile))
length(fids)
</code></pre>

<hr>
<h2 id='vapour_read_fields'>Read feature field data</h2><span id='topic+vapour_read_fields'></span><span id='topic+vapour_read_attributes'></span>

<h3>Description</h3>

<p>Read features fields (attributes), optionally after SQL execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_read_fields(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)

vapour_read_attributes(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_read_fields_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_read_fields_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_read_fields_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
<tr><td><code id="vapour_read_fields_+3A_limit_n">limit_n</code></td>
<td>
<p>an arbitrary limit to the number of features scanned</p>
</td></tr>
<tr><td><code id="vapour_read_fields_+3A_skip_n">skip_n</code></td>
<td>
<p>an arbitrary number of features to skip</p>
</td></tr>
<tr><td><code id="vapour_read_fields_+3A_extent">extent</code></td>
<td>
<p>apply an arbitrary extent, only when 'sql' used (must be 'ex = c(xmin, xmax, ymin, ymax)' but sp bbox, sf bbox, and raster extent also accepted)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal types are not fully supported, there are straightforward conversions
for numeric, integer (32-bit) and string types. Date, Time, DateTime are
returned as character, and Integer64 is returned as numeric.
</p>


<h3>Value</h3>

<p>list of vectors one for each field in the source, each will be the same length which will
depend on the values of 'skip_n', 'limit_n', 'sql', and the available records in the source. The
types will be raw, numeric, integer, character, logical depending on the available mapping to the types
in the source for the data there to R's native vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
att &lt;- vapour_read_fields(mvfile)
str(att)
sq &lt;- "SELECT * FROM list_locality_postcode_meander_valley WHERE FID &lt; 5"
(att &lt;- vapour_read_fields(mvfile, sql = sq))
pfile &lt;- "list_locality_postcode_meander_valley.tab"
dsource &lt;- system.file(file.path("extdata/tab", pfile), package="vapour")
SQL &lt;- "SELECT NAME FROM list_locality_postcode_meander_valley WHERE POSTCODE &lt; 7300"
vapour_read_fields(dsource, sql = SQL)
</code></pre>

<hr>
<h2 id='vapour_read_geometry'>Read GDAL feature geometry</h2><span id='topic+vapour_read_geometry'></span><span id='topic+vapour_read_geometry_ia'></span><span id='topic+vapour_read_geometry_ij'></span><span id='topic+vapour_read_geometry_text'></span><span id='topic+vapour_read_extent'></span><span id='topic+vapour_read_type'></span>

<h3>Description</h3>

<p>Read GDAL geometry as binary blob, text, or numeric extent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_read_geometry_ia(dsource, layer = 0L, sql = "", extent = NA, ia = NULL)

vapour_read_geometry_ij(dsource, layer = 0L, sql = "", extent = NA, ij = NULL)

vapour_read_geometry(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)

vapour_read_geometry_text(
  dsource,
  layer = 0L,
  sql = "",
  textformat = "json",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)

vapour_read_extent(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)

vapour_read_type(
  dsource,
  layer = 0L,
  sql = "",
  limit_n = NULL,
  skip_n = 0,
  extent = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_read_geometry_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_extent">extent</code></td>
<td>
<p>apply an arbitrary extent, only when 'sql' used (must be 'ex = c(xmin, xmax, ymin, ymax)' but sp bbox, sf bbox, and raster extent also accepted)</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_ia">ia</code></td>
<td>
<p>an arbitrary index, integer vector with values between 0 and one less the number of features, duplicates allowed and arbitrary order is ok</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_ij">ij</code></td>
<td>
<p>an range index, integer vector of length two with values between 0 and one less the number of features, this range of geometries is returned</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_limit_n">limit_n</code></td>
<td>
<p>an arbitrary limit to the number of features scanned</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_skip_n">skip_n</code></td>
<td>
<p>an arbitrary number of features to skip</p>
</td></tr>
<tr><td><code id="vapour_read_geometry_+3A_textformat">textformat</code></td>
<td>
<p>indicate text output format, available are &quot;json&quot; (default), &quot;gml&quot;, &quot;kml&quot;, &quot;wkt&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vapour_read_geometry</code> will read features as binary WKB, <code>vapour_read_geometry_text</code> as various text formats (geo-json, wkt, kml, gml),
</p>
<p><code>vapour_read_extent</code> a numeric extent which is the native bounding box, the four numbers (in this order) <code style="white-space: pre;">&#8288;xmin, xmax, ymin, ymax&#8288;</code>.
For each function an optional SQL string will be evaluated against the data source before reading.
</p>
<p><code>vapour_read_geometry_ia</code> will read features by <em>arbitrary index</em>, so any integer between 0 and one less than the number of
features. These may be duplicated. If 'ia' is greater than the highest index NULL is returned, but if less than 0 the function will error.
</p>
<p><code>vapour_read_geometry_ij</code> will read features by <em>index range</em>, so two numbers to read ever feature between those limits inclusively.
'i' and 'j' must be increasing.
</p>
<p><code>vapour_read_type</code> will read the (wkb) type of the geometry as an integer. These are
<code>0</code> unknown, <code>1</code> Point, <code>2</code> LineString, <code>3</code> Polygon, <code>4</code> MultiPoint, <code>5</code> MultiLineString,
<code>6</code> MultiPolygon, <code>7</code> GeometryCollection, and the other more exotic types listed in &quot;api/vector_c_api.html&quot; from the
GDAL home page (as at October 2020).  A missing value 'NA' indicates an empty geometry.
</p>
<p>Note that <code>limit_n</code> and <code>skip_n</code> interact with the affect of <code>sql</code>, first the query is executed on the data source, then
while looping through available features <code>skip_n</code> features are ignored, and then a feature-count begins and the loop
is stopped if <code>limit_n</code> is reached.
</p>
<p>Note that <code>extent</code> applies to the 'SpatialFilter' of 'ExecuteSQL': https://gdal.org/user/ogr_sql_dialect.html#executesql.
</p>


<h3>Value</h3>

<p>for <code><a href="#topic+vapour_read_geometry">vapour_read_geometry()</a></code>, <code><a href="#topic+vapour_read_geometry_ia">vapour_read_geometry_ia()</a></code> and <code><a href="#topic+vapour_read_geometry_ij">vapour_read_geometry_ij()</a></code> a raw vector of
geometry, for <code><a href="#topic+vapour_read_extent">vapour_read_extent()</a></code> a list of numeric vectors each with 'xmin,xmax,ymin,ymax' respectively for each geometry,
for <code><a href="#topic+vapour_read_type">vapour_read_type()</a></code> a character vector. See Details for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
## A MapInfo TAB file with polygons
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
## A shapefile with points
pfile &lt;- system.file("extdata/point.shp", package = "vapour")

## raw binary WKB points in a list
ptgeom &lt;- vapour_read_geometry(pfile)
## create a filter query to ensure data read is small
SQL &lt;- "SELECT FID FROM list_locality_postcode_meander_valley WHERE FID &lt; 3"
## polygons in raw binary (WKB)
plgeom &lt;- vapour_read_geometry_text(mvfile, sql = SQL)
## polygons in raw text (GeoJSON)
txtjson &lt;- vapour_read_geometry_text(mvfile, sql = SQL)

## polygon extents in a list xmin, xmax, ymin, ymax
exgeom &lt;- vapour_read_extent(mvfile)

## points in raw text (GeoJSON)
txtpointjson &lt;- vapour_read_geometry_text(pfile)
## points in raw text (WKT)
txtpointwkt &lt;- vapour_read_geometry_text(pfile, textformat = "wkt")
</code></pre>

<hr>
<h2 id='vapour_read_raster'>Raster IO (read)</h2><span id='topic+vapour_read_raster'></span>

<h3>Description</h3>

<p>Read a window of data from a GDAL raster source. The first argument is the source
name and the second is a 6-element <code>window</code> of offset, source dimension, and output dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_read_raster(
  x,
  band = 1,
  window,
  resample = "nearestneighbour",
  ...,
  sds = NULL,
  native = FALSE,
  set_na = TRUE,
  band_output_type = "",
  unscale = TRUE,
  nara = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_read_raster_+3A_x">x</code></td>
<td>
<p>data source</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_band">band</code></td>
<td>
<p>index of which band to read (1-based)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_window">window</code></td>
<td>
<p>src_offset, src_dim, out_dim</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_resample">resample</code></td>
<td>
<p>resampling method used (see details)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_...">...</code></td>
<td>
<p>reserved</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_sds">sds</code></td>
<td>
<p>index of subdataset to read (usually 1)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_native">native</code></td>
<td>
<p>apply the full native window for read, <code>FALSE</code> by default</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_set_na">set_na</code></td>
<td>
<p>specify whether NA values should be set for the NODATA</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_band_output_type">band_output_type</code></td>
<td>
<p>numeric type of band to apply (else the native type if &rdquo;), is mapped to one of 'Byte', 'Int32', or 'Float64'</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_unscale">unscale</code></td>
<td>
<p>default is <code>TRUE</code> so native values will be converted by offset and scale to floating point</p>
</td></tr>
<tr><td><code id="vapour_read_raster_+3A_nara">nara</code></td>
<td>
<p>logical whether to return a (scaled) nativeRaster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value of <code>window</code> may be input as only 4 elements, in which case the source dimension
Will be used as the output dimension.
</p>
<p>This is analogous to the <code>rgdal</code> function <code>readGDAL</code> with its arguments <code>offset</code>,  <code>region.dim</code>
and <code>output.dim</code>.  There's no semantic wrapper for this in vapour, but see
<code style="white-space: pre;">&#8288;https://github.com/hypertidy/lazyraster&#8288;</code> for one approach.
</p>
<p>Resampling options will depend on GDAL version,  but currently  'NearestNeighbour' (default),
'Average', 'Bilinear', 'Cubic', 'CubicSpline',  'Gauss', 'Lanczos', 'Mode' are potentially
available. These are compared internally by converting to lower-case. Detailed use of this is barely tried or tested with vapour, but is
a standard facility used in GDAL. Easiest way to compare results is with gdal_translate.
</p>
<p>There is no write support in vapour.
</p>
<p>Currently the <code>window</code> argument is required. If this argument unspecified and <code>native = TRUE</code> then
the default window specification will be used, the entire extent at native resolution. If 'window'
is specified and <code>native = TRUE</code> then the window is used as-is, with a warning (native is ignored).
</p>
<p>'band_output_type' can be 'raw', 'integer', 'double', or case-insensitive versions of the GDAL types
'Byte', 'UInt16', 'Int16', 'UInt32', 'Int32', 'Float32', or 'Float64'. These are mapped to one of the
supported types 'Byte' ('== raw'), 'Int32' ('== integer'), or 'Float64' ('== double').
</p>


<h3>Value</h3>

<p>list of numeric vectors (only one for 'band')
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "sst.tif", package = "vapour")
## a 5*5 window from a 10*10 region
vapour_read_raster(f, window = c(0, 0, 10, 10, 5, 5))
vapour_read_raster(f, window = c(0, 0, 10, 10, 5, 5), resample = "Lanczos")
## find the information first
ri &lt;- vapour_raster_info(f)
str(matrix(vapour_read_raster(f, window = c(0, 0, ri$dimXY, ri$dimXY)), ri$dimXY[1]))
## the method can be used to up-sample as well
str(matrix(vapour_read_raster(f, window = c(0, 0, 10, 10, 15, 25)), 15))

</code></pre>

<hr>
<h2 id='vapour_read_raster_block'>Read or write raster block</h2><span id='topic+vapour_read_raster_block'></span>

<h3>Description</h3>

<p>Read a 'block' from raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_read_raster_block(
  dsource,
  offset,
  dimension,
  band = 1L,
  band_output_type = "",
  unscale = TRUE,
  nara = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_read_raster_block_+3A_dsource">dsource</code></td>
<td>
<p>file name to read from, or write to</p>
</td></tr>
<tr><td><code id="vapour_read_raster_block_+3A_offset">offset</code></td>
<td>
<p>position x,y to start writing (0-based, y-top)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_block_+3A_dimension">dimension</code></td>
<td>
<p>window size to read from, or write to</p>
</td></tr>
<tr><td><code id="vapour_read_raster_block_+3A_band">band</code></td>
<td>
<p>which band to read (1-based)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_block_+3A_band_output_type">band_output_type</code></td>
<td>
<p>numeric type of band to apply (else the native type if &rdquo;) can be one of 'Byte', 'Int32', or 'Float64'</p>
</td></tr>
<tr><td><code id="vapour_read_raster_block_+3A_unscale">unscale</code></td>
<td>
<p>default is <code>TRUE</code> so native values will be converted by offset and scale to floating point</p>
</td></tr>
<tr><td><code id="vapour_read_raster_block_+3A_nara">nara</code></td>
<td>
<p>if 'TRUE' return in nativeRaster format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with a vector of data from the band read
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "sst.tif", package = "vapour")
v &lt;- vapour_read_raster_block(f, c(0L, 0L), dimension = c(2L, 3L), band = 1L)
</code></pre>

<hr>
<h2 id='vapour_read_raster_raw'>type safe(r) raster read</h2><span id='topic+vapour_read_raster_raw'></span><span id='topic+vapour_read_raster_int'></span><span id='topic+vapour_read_raster_dbl'></span><span id='topic+vapour_read_raster_chr'></span><span id='topic+vapour_read_raster_hex'></span>

<h3>Description</h3>

<p>These wrappers around <code><a href="#topic+vapour_read_raster">vapour_read_raster()</a></code> guarantee single vector output of the nominated type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_read_raster_raw(
  x,
  band = 1,
  window,
  resample = "nearestneighbour",
  ...,
  sds = NULL,
  native = FALSE,
  set_na = TRUE,
  nara = FALSE
)

vapour_read_raster_int(
  x,
  band = 1,
  window,
  resample = "nearestneighbour",
  ...,
  sds = NULL,
  native = FALSE,
  set_na = TRUE
)

vapour_read_raster_dbl(
  x,
  band = 1,
  window,
  resample = "nearestneighbour",
  ...,
  sds = NULL,
  native = FALSE,
  set_na = TRUE
)

vapour_read_raster_chr(
  x,
  band = 1,
  window,
  resample = "nearestneighbour",
  ...,
  sds = NULL,
  native = FALSE,
  set_na = TRUE
)

vapour_read_raster_hex(
  x,
  band = 1,
  window,
  resample = "nearestneighbour",
  ...,
  sds = NULL,
  native = FALSE,
  set_na = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_read_raster_raw_+3A_x">x</code></td>
<td>
<p>data source</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_band">band</code></td>
<td>
<p>index of which band to read (1-based)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_window">window</code></td>
<td>
<p>src_offset, src_dim, out_dim</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_resample">resample</code></td>
<td>
<p>resampling method used (see details)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_...">...</code></td>
<td>
<p>reserved</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_sds">sds</code></td>
<td>
<p>index of subdataset to read (usually 1)</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_native">native</code></td>
<td>
<p>apply the full native window for read, <code>FALSE</code> by default</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_set_na">set_na</code></td>
<td>
<p>specify whether NA values should be set for the NODATA</p>
</td></tr>
<tr><td><code id="vapour_read_raster_raw_+3A_nara">nara</code></td>
<td>
<p>logical whether to return a (scaled) nativeRaster</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code style="white-space: pre;">&#8288;*_hex&#8288;</code> and <code style="white-space: pre;">&#8288;*_chr&#8288;</code> are aliases of each other.
</p>


<h3>Value</h3>

<p>atomic vector of the nominated type raw, int, dbl, or character (hex)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "sst.tif", package = "vapour")
vapour_read_raster_int(f, window = c(0, 0, 5, 4))
vapour_read_raster_raw(f, window = c(0, 0, 5, 4))
vapour_read_raster_chr(f, window = c(0, 0, 5, 4))
plot(vapour_read_raster_dbl(f, native = TRUE), pch = ".", ylim = c(273, 300))
</code></pre>

<hr>
<h2 id='vapour_report_fields'>Read feature field types.</h2><span id='topic+vapour_report_fields'></span><span id='topic+vapour_report_attributes'></span>

<h3>Description</h3>

<p>Obtains the internal type-constant name for the data attributes in a source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_report_fields(dsource, layer = 0L, sql = "")

vapour_report_attributes(dsource, layer = 0L, sql = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_report_fields_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL)</p>
</td></tr>
<tr><td><code id="vapour_report_fields_+3A_layer">layer</code></td>
<td>
<p>integer of layer to work with, defaults to the first (0) or the name of the layer</p>
</td></tr>
<tr><td><code id="vapour_report_fields_+3A_sql">sql</code></td>
<td>
<p>if not empty this is executed against the data source (layer will be ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this to compare the interpreted versions converted into R types by
<code>vapour_read_fields</code>.
</p>
<p>This and <code><a href="#topic+vapour_read_fields">vapour_read_fields()</a></code> are aliased to older versions named 'vapour_report_attributes()' and
'vapour_read_attributes()', but &quot;field&quot; is a clearer and more sensible name (in our opinion).
</p>
<p>These are defined for the enum OGRFieldType in GDAL itself.
<a href="https://gdal.org/doxygen/ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc">https://gdal.org/doxygen/ogr__core_8h.html#a787194bea637faf12d61643124a7c9fc</a>
</p>


<h3>Value</h3>

<p>named character vector of the GDAL types for each field
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
vapour_report_fields(mvfile)

## modified by sql argument
vapour_report_fields(mvfile,
  sql = "SELECT POSTCODE, NAME FROM list_locality_postcode_meander_valley")
</code></pre>

<hr>
<h2 id='vapour_sds_names'>GDAL raster subdatasets (variables)</h2><span id='topic+vapour_sds_names'></span>

<h3>Description</h3>

<p>A <strong>subdataset</strong> is a collection abstraction for a number of <strong>variables</strong>
within a single GDAL source. If there's only one variable the datasource and
the variable have the same data source string. If there is more than one the
subdatasets have the form <strong>DRIVER:&quot;datasourcename&quot;:varname</strong>. Each
subdataset name can stand in place of a data source name that has only one
variable, so we always treat a source as a subdataset, even if there's only
one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_sds_names(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_sds_names_+3A_x">x</code></td>
<td>
<p>a data source string, filename, database connection string,  or other URL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a character vector of 'subdatasets<code style="white-space: pre;">&#8288;. In the case of a normal data source, with no subdatasets the value is simply  the &#8288;</code>datasource'.
</p>
<p>If the raw SDS names contain spaces these are replaced by '%20' escape strings. A specific example is
&quot;WCS:https://elevation.nationalmap.gov:443&quot; with request
&quot;arcgis/services/3DEPElevation/ImageServer/WCSServer?version=2.0.1&amp;coverage=DEP3Elevation_Hillshade Gray&quot;.
This function will return &quot;..DEP3Elevation_Hillshade%20Gray&quot;.
See <a href="https://github.com/hypertidy/vapour/wiki/Examples-of-subdatasets">wiki post</a> for more details.
</p>


<h3>Value</h3>

<p>character vector of subdataset names, or just the source itself if no SDS are present
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata/gdal", "sds.nc", package = "vapour")
## protect from error with netcdf problems
result &lt;- try(vapour_sds_names(f), silent = TRUE)
if (!inherits(result, "try-error")) {
  print(result)
}
vapour_sds_names(system.file("extdata", "sst.tif", package = "vapour"))

</code></pre>

<hr>
<h2 id='vapour_set_config'>Set and query GDAL configuration options</h2><span id='topic+vapour_set_config'></span><span id='topic+vapour_get_config'></span>

<h3>Description</h3>

<p>These functions can get and set configuration options for GDAL, for fine
control over specific GDAL behaviours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_set_config(option, value)

vapour_get_config(option)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_set_config_+3A_option">option</code></td>
<td>
<p>GDAL config name (see Details), character string</p>
</td></tr>
<tr><td><code id="vapour_set_config_+3A_value">value</code></td>
<td>
<p>value for config option, character string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Configuration options may also be set as environment variables.
</p>
<p>See <a href="https://gdal.org/user/configoptions.html">GDAL config options</a> for
details on available options.
</p>


<h3>Value</h3>

<p>character string for <code>vapour_get_config</code>, integer 1 for successful <code>vapour_set_config()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
(orig &lt;- vapour_get_config("GDAL_CACHEMAX"))
vapour_set_config("GDAL_CACHEMAX", "64")
vapour_get_config("GDAL_CACHEMAX")
vapour_set_config("GDAL_CACHEMAX", orig)

## End(Not run)
</code></pre>

<hr>
<h2 id='vapour_srs_wkt'>PROJ4 string to WKT</h2><span id='topic+vapour_srs_wkt'></span>

<h3>Description</h3>

<p>Convert a projstring to Well Known Text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_srs_wkt(crs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_srs_wkt_+3A_crs">crs</code></td>
<td>
<p>projection string, see Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is vectorized because why not, but probably only ever will be
used on single element vectors of character strings.
</p>
<p>Note that no sanitizing is done on inputs, we literally just 'OGRSpatialReference.SetFromUserInput(crs)' and
give the output as WKT. If it's an error in GDAL it's an error in R.
</p>
<p>Common inputs are WKT variants,
'AUTH:CODE's e.g. 'EPSG:3031', the 'OGC:CRS84' for long,lat WGS84, 'ESRI:code' and other authority variants, and
datum names such as 'WGS84','NAD27' recognized by PROJ itself.
</p>
<p>See help for 'SetFromUserInput' in 'OGRSpatialReference', and 'proj_create_crs_to_crs'.
</p>
<p><a href="https://proj.org/development/reference/functions.html#c.proj_create_crs_to_crs">c.proj_create_crs_to_crs</a>
</p>
<p><a href="https://proj.org/development/reference/functions.html#c.proj_create">c.proj_create</a>
</p>
<p><a href="https://gdal.org/doxygen/classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796">SetFromUserInput</a>
</p>


<h3>Value</h3>

<p>WKT2 projection string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vapour_srs_wkt("+proj=laea +datum=WGS84")
</code></pre>

<hr>
<h2 id='vapour_vrt'>Virtual raster</h2><span id='topic+vapour_vrt'></span>

<h3>Description</h3>

<p>Simple VRT creation of a GDAL virtual raster. The data source string is
<strong>augmented</strong> by input of other optional arguments. That means it <strong>overrides</strong>
their values provided by the source data, or stands in place of this information if
it is missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_vrt(
  x,
  extent = NULL,
  projection = NULL,
  sds = 1L,
  bands = NULL,
  geolocation = NULL,
  ...,
  relative_to_vrt = FALSE,
  nomd = FALSE,
  overview = -1L,
  options = character()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_vrt_+3A_x">x</code></td>
<td>
<p>data source name, filepath, url, database connection string, or VRT text</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_extent">extent</code></td>
<td>
<p>(optional) numeric extent, xmin,xmax,ymin,ymax</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_projection">projection</code></td>
<td>
<p>(optional) character string, projection string (&quot;auth:code&quot;, proj4, or WKT, or anything understood by PROJ, see Details)</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_sds">sds</code></td>
<td>
<p>which subdataset to select from a source with more than one</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_bands">bands</code></td>
<td>
<p>(optional) which band/s to include from the source</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_geolocation">geolocation</code></td>
<td>
<p>vector of 2 dsn to longitude, latitude geolocation array sources</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_relative_to_vrt">relative_to_vrt</code></td>
<td>
<p>default <code>FALSE</code>, if <code>TRUE</code> input strings that identify as files on the system are left as-is (by default they are made absolute at the R level)</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_nomd">nomd</code></td>
<td>
<p>if <code>TRUE</code> the Metadata tag is removed from the resulting VRT (it can be quite substantial)</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_overview">overview</code></td>
<td>
<p>pick an integer overview from the source (0L is highest resolution, default -1L does nothing)</p>
</td></tr>
<tr><td><code id="vapour_vrt_+3A_options">options</code></td>
<td>
<p>pass in options to the VRT creation, like 'c(&quot;-expand&quot;, &quot;rgb&quot;, &quot;-ot&quot;, &quot;Byte&quot;('</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a GDAL data source string (to be used like a filename) with various helpers.
VRT stands for 'ViRTual'. A VRT string then acts as a representative of a data source for
further use (to read or warp it).
</p>
<p>An input string will be converted to a single subdataset, use 'sds' argument to select.
</p>
<p>If 'extent', 'projection' is provided this is applied to override the source's extent and/or projection.
(These might be invalid, or missing, so we facilitate correcting this).
</p>
<p>If 'bands' is provided this is used to select a set of bands (numbered from 1), which might be repeated, or
in any order and contain repetitions.
</p>
<p><code>vapour_vrt()</code> is vectorized, it will return multiple VRT strings for multiple inputs in
a &quot;length &gt; 1&quot; character vector. These are all independent, this is different to the function
<code>vapour_warp_raster()</code> where multiple inputs are merged (possibly by sequential overlapping).
</p>
<p>If <code>geolocation</code> is set the 'GeoTransform' element is forcibly removed from the vrt output, in order
to avoid https://github.com/hypertidy/vapour/issues/210 (there might be a better fix).
</p>


<h3>Value</h3>

<p>VRT character string (for use by GDAL-capable tools, i.e. reading raster)
</p>


<h3>Rationale</h3>

<p>For a raster, the basic essentials we can specify or modify for a source  are
</p>

<ol>
<li><p> the source, 2) the extent, 3) the projection 4) what subdataset (these are
variables from NetCDF and the like that contain multiple datasets) and 5)
which band/s to provided. For extent and projection we are simply providing
or correcting complete information about how to interpret the georeferencing,
with subdatasets and bands this is more like a query of which ones we want.
If we only wanted band 5, then the output data would have one band only (and
we we read it we need <code>band = 1</code>).
</p>
</li></ol>

<p>We don't provide ability override the dimension, but that is possible as
well. More features may come with a 'VRTBuilder' interface.
</p>


<h3>Projections</h3>

<p>Common inputs for <code>projection</code> are WKT variants, &quot;AUTH:CODE&quot;s e.g.
&quot;EPSG:3031&quot;, the &quot;OGC:CRS84&quot; for long,lat WGS84, &quot;ESRI:code&quot; and other
authority variants, and datum names such as 'WGS84','NAD27' recognized by
PROJ itself.
</p>
<p>See the following links to GDAL and PROJ documentation:
</p>
<p><a href="https://proj.org/development/reference/functions.html#c.proj_create_crs_to_crs">PROJ documentation: c.proj_create_crs_to_crs</a>
</p>
<p><a href="https://proj.org/development/reference/functions.html#c.proj_create">PROJ documentation: c.proj_create</a>
</p>
<p><a href="https://gdal.org/doxygen/classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796">GDAL documentation: SetFromUserInput</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tif &lt;- system.file("extdata", "sst.tif", package = "vapour")
vapour_vrt(tif)

vapour_vrt(tif, bands = c(1, 1))

</code></pre>

<hr>
<h2 id='vapour_vsi_list'>Read GDAL virtual source contents</h2><span id='topic+vapour_vsi_list'></span>

<h3>Description</h3>

<p>Obtain the names of available items in a virtual file source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_vsi_list(dsource, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_vsi_list_+3A_dsource">dsource</code></td>
<td>
<p>data source name (path to file, connection string, URL) with virtual prefix, see Details</p>
</td></tr>
<tr><td><code id="vapour_vsi_list_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dsource</code> must begin with a valid form of the special <code>vsiPREFIX</code>, for details
see <a href="https://gdal.org/user/virtual_file_systems.html">GDAL Virtual File Systems</a>.
</p>
<p>Note that the listing is not recursive, and so cannot be used for automation. One would
use this function interactively to determine a  useable <code style="white-space: pre;">&#8288;/vsiPREFIX/dsource&#8288;</code> data
source string.
</p>


<h3>Value</h3>

<p>character vector listing of items
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pointzipfile &lt;- system.file("extdata/vsi/point_shp.zip", package = "vapour")
vapour_vsi_list(sprintf("/vsizip/%s", pointzipfile))

## Not run: 
## example from https://github.com/hypertidy/vapour/issues/55
#file &lt;- "http/radmap_v3_2015_filtered_dose/radmap_v3_2015_filtered_dose.ers.zip"
#url &lt;- "http://dapds00.nci.org.au/thredds/fileServer/rr2/national_geophysical_compilations"
#u &lt;- sprintf("/vsizip//vsicurl/%s", file.path(url, file))
#vapour_vsi_list(u)
#[1] "radmap_v3_2015_filtered_dose"     "radmap_v3_2015_filtered_dose.ers"
#[3] "radmap_v3_2015_filtered_dose.isi" "radmap_v3_2015_filtered_dose.txt"
#gdalinfo /vsitar//home/ubuntu/LT05_L1GS_027026_20060116_20160911_01_T2.tar.gz
#vapour_vsi_list("/vsitar//home/ubuntu/LT05_L1GS_027026_20060116_20160911_01_T2.tar.gz")
#"LT05_L1TP_027026_20061218_20160911_01_T1_ANG.txt"
#"LT05_L1TP_027026_20061218_20160911_01_T1_B1.TIF"
#"LT05_L1TP_027026_20061218_20160911_01_T1_B2.TIF"
#"LT05_L1TP_027026_20061218_20160911_01_T1_B3.TIF"
#...

## End(Not run)
</code></pre>

<hr>
<h2 id='vapour_warp_raster'>Raster warper (reprojection)</h2><span id='topic+vapour_warp_raster'></span>

<h3>Description</h3>

<p>Read a window of data from a GDAL raster source through a warp specification.
The warp specification is provided by 'extent', 'dimension', and 'projection'
properties of the transformed output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_warp_raster(
  x,
  bands = NULL,
  extent = NULL,
  dimension = NULL,
  projection = "",
  set_na = TRUE,
  source_projection = NULL,
  source_extent = 0,
  resample = "near",
  silent = TRUE,
  ...,
  band_output_type = "",
  warp_options = "",
  transformation_options = "",
  open_options = "",
  options = "",
  nomd = FALSE,
  overview = -1L,
  nara = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_warp_raster_+3A_x">x</code></td>
<td>
<p>vector of data source names (file name or URL or database connection string)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_bands">bands</code></td>
<td>
<p>index of band/s to read (1-based), may be new order or replicated, or NULL (all bands used, the default)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_extent">extent</code></td>
<td>
<p>extent of the target warped raster 'c(xmin, xmax, ymin, ymax)'</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_dimension">dimension</code></td>
<td>
<p>dimensions in pixels of the warped raster (x, y)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_projection">projection</code></td>
<td>
<p>projection of warped raster (in Well-Known-Text, or any projection string accepted by GDAL)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_set_na">set_na</code></td>
<td>
<p>NOT IMPLEMENTED logical, should 'NODATA' values be set to <code>NA</code></p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_source_projection">source_projection</code></td>
<td>
<p>optional, override or augment the projection of the source (in Well-Known-Text, or any projection string accepted by GDAL)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_source_extent">source_extent</code></td>
<td>
<p>extent of the source raster, used to override/augment incorrect source metadata</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_resample">resample</code></td>
<td>
<p>resampling method used (see details in <a href="#topic+vapour_read_raster">vapour_read_raster</a>)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_silent">silent</code></td>
<td>
<p><code>TRUE</code> by default, set to <code>FALSE</code> to report messages</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_band_output_type">band_output_type</code></td>
<td>
<p>numeric type of band to apply (else the native type if &rdquo;) can be one of 'Byte', 'Int32', or 'Float64' but see details in <code><a href="#topic+vapour_read_raster">vapour_read_raster()</a></code></p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_warp_options">warp_options</code></td>
<td>
<p>character vector of options, as in gdalwarp -wo - see Details</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_transformation_options">transformation_options</code></td>
<td>
<p>character vector of options, as in gdalwarp -to see Details</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_open_options">open_options</code></td>
<td>
<p>character vector of options, as in gdalwarp -oo - see Details</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_options">options</code></td>
<td>
<p>character vectors of options as per the gdalwarp command line</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_nomd">nomd</code></td>
<td>
<p>if <code>TRUE</code> the Metadata tag is removed from the resulting VRT (it can be quite substantial)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_overview">overview</code></td>
<td>
<p>pick an integer overview from the source (0L is highest resolution, default -1L does nothing)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_+3A_nara">nara</code></td>
<td>
<p>if 'TRUE' return in nativeRaster format</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any bands may be read, including repeats.
</p>
<p>This function is not memory safe, the source is left on disk but the output
raster is all computed in memory so please be careful with very large values
for 'dimension'. <code>1000 * 1000 * 8</code> for 1000 columns, 1000 rows and floating
point double type will be 8Mb.
</p>
<p>There's control over the output type, and is auto-detected from the source
(raw/Byte, integer/Int32, numeric/Float64) or can be set with
'band_output_type'.
</p>
<p>'projection' refers to any projection string for a CRS understood by GDAL.
This includes the full Well-Known-Text specification of a coordinate
reference system, PROJ strings, &quot;AUTH:CODE&quot; types, and others. See
<code><a href="#topic+vapour_srs_wkt">vapour_srs_wkt()</a></code> for conversion from PROJ.4 string to WKT, and
<code><a href="#topic+vapour_raster_info">vapour_raster_info()</a></code> and <code><a href="#topic+vapour_layer_info">vapour_layer_info()</a></code> for various formats
available from a data source. Any string accepted by GDAL may be used for
'projection' or 'source_projection', including EPSG strings, PROJ4 strings,
and file names. Note that this argument was named 'wkt' up until version
0.8.0.
</p>
<p>'extent' is the four-figure xmin,xmax,ymin,ymax outer corners of corner pixels
</p>
<p>'dimension' is the pixel dimensions of the output, x (ncol) then y (nrow).
</p>
<p>Options for missing data are not yet handled, just returned as-is. Note that
there may be regions of &quot;zero data&quot; in a warped output, separate from
propagated missing &quot;NODATA&quot; values in the source.
</p>
<p>Argument 'source_projection' may be used to assign the projection of the
source, 'source_extent' to assign the extent of the source. Sometimes both
are required. Note, this is now better done by creating 'VRT', see <code><a href="#topic+vapour_vrt">vapour_vrt()</a></code>
for assigning the source projection, extent, and some other options.
</p>
<p>If multiple sources are specified via 'x' and either 'source_projection' or
'source_extent' are provided, these are applied to every source even if they
have valid values already. If this is not sensible please use VRT to wrap the
multiple sources first.
</p>
<p>Wild combinations of 'source_extent' and/or 'extent' may be used for
arbitrary flip orientations, scale and offset. For expert usage only. Old
versions allowed transform input for target and source but this is now
disabled (maybe we'll write a new wrapper for that).
</p>


<h3>Value</h3>

<p>list of vectors (only 1 for 'band') of numeric values, in raster order
</p>


<h3>Options</h3>

<p>The various options are convenience arguments  for 'warp options -wo',
transformation options -to', 'open options -oo', and 'options' for any other
arguments in gdalwarp. There are no 'creation options -co' or 'dataset output
options -doo', because these are not supported by the MEM driver.
</p>
<p>All 'warp_options' are paired with a '-wo' declaration and similarly for '-to', and '-oo',
this is purely a convenience, since 'options' itself can be used for these as well but we recommend using
the individual arguments.
An example for warp options is  <code>warp_options = c("SAMPLE_GRID=YES", "SAMPLE_STEPS=30")</code> and one for
general arguments might be
'options = c(&quot;-ovr&quot;, &quot;AUTO&quot;, &quot;-nomd&quot;, &quot;-cutline&quot;, &quot;/path/to/cut.gpkg&quot;, &quot;-crop_to_cutline&quot;)'.  If they would
be separated by spaces on the command line then include as separate elements in the options character vector.
</p>
<p>See <a href="https://gdal.org/api/gdalwarp_cpp.html#_CPPv4N15GDALWarpOptions16papszWarpOptionsE">GDALWarpOptions</a> for '-wo'.
</p>
<p>See <a href="https://gdal.org/api/gdal_alg.html#_CPPv432GDALCreateGenImgProjTransformer212GDALDatasetH12GDALDatasetHPPc">GDAL transformation options</a> for '-to'.
</p>
<p>See <a href="https://gdal.org/programs/gdalwarp.html">GDALWARP command line app</a> for further details.
</p>
<p>Note we already apply the following gdalwarp arguments based on input R
arguments to this function.
</p>

<dl>
<dt>-of</dt><dd><p>MEM is hardcoded, but may be extended in future</p>
</dd>
<dt>-t_srs</dt><dd><p>set via 'projection'</p>
</dd>
<dt>-s_srs</dt><dd><p>set via 'source_projection'</p>
</dd>
<dt>-te</dt><dd><p>set via 'extent'</p>
</dd>
<dt>-ts</dt><dd><p>set via 'dimension'</p>
</dd>
<dt>-r</dt><dd><p>set via 'resample'</p>
</dd>
<dt>-ot</dt><dd><p>set via 'band_output_type'</p>
</dd>
<dt>-te_srs</dt><dd><p> not supported</p>
</dd>
<dt>-a_ullr</dt><dd><p>(not a gdalwarp argument, but we do analog) set via 'source_extent' use <code><a href="#topic+vapour_vrt">vapour_vrt()</a></code> instead</p>
</dd>
</dl>

<p>In future all 'source_*' arguments may be deprecated in favour of
augmentation by 'vapour_vrt()'.
</p>
<p>Common inputs for <code>projection</code> are WKT variants, 'AUTH:CODE's e.g.
'EPSG:3031', the 'OGC:CRS84' for lon,lat WGS84, 'ESRI:code' and other
authority variants, and datum names such as 'WGS84','NAD27' recognized by
PROJ itself.
</p>
<p>See help for 'SetFromUserInput' in 'OGRSpatialReference', and
'proj_create_crs_to_crs'.
</p>
<p><a href="https://proj.org/development/reference/functions.html#c.proj_create_crs_to_crs">c.proj_create_crs_to_crs</a>
</p>
<p><a href="https://proj.org/development/reference/functions.html#c.proj_create">c.proj_create</a>
</p>
<p><a href="https://gdal.org/doxygen/classOGRSpatialReference.html#aec3c6a49533fe457ddc763d699ff8796">SetFromUserInput</a>
</p>


<h3>See Also</h3>

<p>vapour_read_raster vapour_read_raster_raw vapour_read_raster_int vapour_read_raster_dbl vapour_read_raster_chr vapour_read_raster_hex
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- 4e5
f &lt;- system.file("extdata", "sst.tif", package = "vapour")
prj &lt;- "+proj=aeqd +lon_0=147 +lat_0=-42"
vals &lt;- vapour_warp_raster(f, extent = c(-b, b, -b, b),
                             dimension = c(186, 298),
                             bands = 1, 
                             projection = vapour_srs_wkt(prj), 
                             warp_options = c("SAMPLE_GRID=YES"))
                             
                             
image(list(x = seq(-b, b, length.out = 187), y = seq(-b, b, length.out = 298),
    z = matrix(unlist(vals, use.names = FALSE), 186)[,298:1]), asp = 1)
</code></pre>

<hr>
<h2 id='vapour_warp_raster_raw'>type safe(r) raster warp</h2><span id='topic+vapour_warp_raster_raw'></span><span id='topic+vapour_warp_raster_int'></span><span id='topic+vapour_warp_raster_dbl'></span><span id='topic+vapour_warp_raster_chr'></span><span id='topic+vapour_warp_raster_hex'></span>

<h3>Description</h3>

<p>These wrappers around <code><a href="#topic+vapour_warp_raster">vapour_warp_raster()</a></code> guarantee single vector output of the nominated type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_warp_raster_raw(
  x,
  bands = NULL,
  extent = NULL,
  dimension = NULL,
  projection = "",
  set_na = TRUE,
  source_projection = NULL,
  source_extent = 0,
  resample = "near",
  silent = TRUE,
  ...,
  warp_options = "",
  transformation_options = "",
  open_options = "",
  options = ""
)

vapour_warp_raster_int(
  x,
  bands = NULL,
  extent = NULL,
  dimension = NULL,
  projection = "",
  set_na = TRUE,
  source_projection = NULL,
  source_extent = 0,
  resample = "near",
  silent = TRUE,
  ...,
  warp_options = "",
  transformation_options = "",
  open_options = "",
  options = ""
)

vapour_warp_raster_dbl(
  x,
  bands = NULL,
  extent = NULL,
  dimension = NULL,
  projection = "",
  set_na = TRUE,
  source_projection = NULL,
  source_extent = 0,
  resample = "near",
  silent = TRUE,
  ...,
  warp_options = "",
  transformation_options = "",
  open_options = "",
  options = ""
)

vapour_warp_raster_chr(
  x,
  bands = NULL,
  extent = NULL,
  dimension = NULL,
  projection = "",
  set_na = TRUE,
  source_projection = NULL,
  source_extent = 0,
  resample = "near",
  silent = TRUE,
  ...,
  warp_options = "",
  transformation_options = "",
  open_options = "",
  options = ""
)

vapour_warp_raster_hex(
  x,
  bands = NULL,
  extent = NULL,
  dimension = NULL,
  projection = "",
  set_na = TRUE,
  source_projection = NULL,
  source_extent = 0,
  resample = "near",
  silent = TRUE,
  ...,
  warp_options = "",
  transformation_options = "",
  open_options = "",
  options = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_warp_raster_raw_+3A_x">x</code></td>
<td>
<p>vector of data source names (file name or URL or database connection string)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_bands">bands</code></td>
<td>
<p>index of band/s to read (1-based), may be new order or replicated, or NULL (all bands used, the default)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_extent">extent</code></td>
<td>
<p>extent of the target warped raster 'c(xmin, xmax, ymin, ymax)'</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_dimension">dimension</code></td>
<td>
<p>dimensions in pixels of the warped raster (x, y)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_projection">projection</code></td>
<td>
<p>projection of warped raster (in Well-Known-Text, or any projection string accepted by GDAL)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_set_na">set_na</code></td>
<td>
<p>NOT IMPLEMENTED logical, should 'NODATA' values be set to <code>NA</code></p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_source_projection">source_projection</code></td>
<td>
<p>optional, override or augment the projection of the source (in Well-Known-Text, or any projection string accepted by GDAL)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_source_extent">source_extent</code></td>
<td>
<p>extent of the source raster, used to override/augment incorrect source metadata</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_resample">resample</code></td>
<td>
<p>resampling method used (see details in <a href="#topic+vapour_read_raster">vapour_read_raster</a>)</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_silent">silent</code></td>
<td>
<p><code>TRUE</code> by default, set to <code>FALSE</code> to report messages</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_warp_options">warp_options</code></td>
<td>
<p>character vector of options, as in gdalwarp -wo - see Details</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_transformation_options">transformation_options</code></td>
<td>
<p>character vector of options, as in gdalwarp -to see Details</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_open_options">open_options</code></td>
<td>
<p>character vector of options, as in gdalwarp -oo - see Details</p>
</td></tr>
<tr><td><code id="vapour_warp_raster_raw_+3A_options">options</code></td>
<td>
<p>character vectors of options as per the gdalwarp command line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>_hex and _chr are aliases of each other.
</p>


<h3>Value</h3>

<p>atomic vector of the nominated type raw, int, dbl, or character (hex)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>b &lt;- 4e5
f &lt;- system.file("extdata", "sst.tif", package = "vapour")
prj &lt;- "+proj=aeqd +lon_0=147 +lat_0=-42"
bytes &lt;- vapour_warp_raster_raw(f, extent = c(-b, b, -b, b),
                             dimension = c(18, 2),
                             bands = 1, 
                             projection = prj)
# not useful given source type floating point, but works
str(bytes)
</code></pre>

<hr>
<h2 id='vapour_write_raster_block'>Write data to a block <em>in an existing file</em>.</h2><span id='topic+vapour_write_raster_block'></span>

<h3>Description</h3>

<p>Be careful! The write function doesn't create a file, you have to use an existing one.
Don't write to a file you don't want to update by mistake.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapour_write_raster_block(
  dsource,
  data,
  offset,
  dimension,
  band = 1L,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vapour_write_raster_block_+3A_dsource">dsource</code></td>
<td>
<p>data source name</p>
</td></tr>
<tr><td><code id="vapour_write_raster_block_+3A_data">data</code></td>
<td>
<p>data vector, length should match  <code>prod(dimension)</code> or length 1 allowed</p>
</td></tr>
<tr><td><code id="vapour_write_raster_block_+3A_offset">offset</code></td>
<td>
<p>offset to start</p>
</td></tr>
<tr><td><code id="vapour_write_raster_block_+3A_dimension">dimension</code></td>
<td>
<p>dimension to write</p>
</td></tr>
<tr><td><code id="vapour_write_raster_block_+3A_band">band</code></td>
<td>
<p>which band to write to (1-based)</p>
</td></tr>
<tr><td><code id="vapour_write_raster_block_+3A_overwrite">overwrite</code></td>
<td>
<p>set to FALSE as a safety valve to not overwrite an existing file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical value indicating success (or failure) of the write
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "sst.tif", package = "vapour")
v &lt;- vapour_read_raster_block(f, c(0L, 0L), dimension = c(2L, 3L), band = 1L)
file.copy(f, tf &lt;- tempfile(fileext = ".tif"))
try(vapour_write_raster_block(tf, data = v[[1]], offset = c(0L, 0L), 
               dimension = c(2L, 3L), band = 1L))
if (file.exists(tf)) file.remove(tf)
</code></pre>

<hr>
<h2 id='vector_vrt'>Vector VRT</h2><span id='topic+vector_vrt'></span>

<h3>Description</h3>

<p>Just a simple text generator to generate the VRT for a vector layer, First layer is chosen if not
otherwise specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vector_vrt(x, layer = 1L, projection = NULL, sql = NULL, a_srs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vector_vrt_+3A_x">x</code></td>
<td>
<p>data source name</p>
</td></tr>
<tr><td><code id="vector_vrt_+3A_layer">layer</code></td>
<td>
<p>layer index (1-based) or name</p>
</td></tr>
<tr><td><code id="vector_vrt_+3A_projection">projection</code></td>
<td>
<p>crs of the output</p>
</td></tr>
<tr><td><code id="vector_vrt_+3A_sql">sql</code></td>
<td>
<p>SQL for ExecuteSQL to define the layer</p>
</td></tr>
<tr><td><code id="vector_vrt_+3A_a_srs">a_srs</code></td>
<td>
<p>set the source crs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using 'sql' overrides the 'layer', and using 'projection' results in the geometries being transformed.
No check is made of the layer source projection.
</p>
<p>Use 'a_srs' to ensure the source has a source crs (that might be the only thing you use this for, even if not reprojecting).
</p>
<p>It's expected that if you use this with a source without a source projection,
you'll get &quot;Failed to import source SRS&quot;, so use argument &quot;a_srs&quot; to set it
if needed (or many other GDAL other facilities that do this).
</p>


<h3>Value</h3>

<p>single element character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- "list_locality_postcode_meander_valley.tab"
## A MapInfo TAB file with polygons
mvfile &lt;- system.file(file.path("extdata/tab", file), package="vapour")
vector_vrt(mvfile, sql = "SELECT * FROM list_locality_postcode_meander_valley LIMIT 5 OFFSET 4")

## read this with vapour_read_geometry() and it will be projected to VicGrid
vector_vrt(mvfile, projection = "EPSG:3111")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
