<!DOCTYPE html><html lang="en-US"><head><title>Help for package contentid</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {contentid}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#content_dir'><p>content store home directory</p></a></li>
<li><a href='#content_id'><p>Generate a content uri for a local file</p></a></li>
<li><a href='#default_lmdb'><p>default location for LMDB registry</p></a></li>
<li><a href='#default_registries'><p>default registries</p></a></li>
<li><a href='#has_resource'><p>has_resource</p></a></li>
<li><a href='#history_swh'><p>return the history of archive events of a given software repository</p></a></li>
<li><a href='#history_url'><p>List all content identifiers that have been seen at a given URL</p></a></li>
<li><a href='#pin'><p>Access the latest content at a URL (DEPRECATED)</p></a></li>
<li><a href='#purge_cache'><p>Purge older files from the local cache.</p></a></li>
<li><a href='#query'><p>query a Content URI or a URL with remote and/or local registries</p></a></li>
<li><a href='#register'><p>register a URL with remote and/or local registries</p></a></li>
<li><a href='#resolve'><p>Resolve content from a content identifier</p></a></li>
<li><a href='#retrieve'><p>Retrieve files from the local cache</p></a></li>
<li><a href='#retrieve_swh'><p>retrieve content from Software Heritage given a content identifier</p></a></li>
<li><a href='#sources'><p>List all known URL sources for a given Content URI</p></a></li>
<li><a href='#sources_swh'><p>List software heritage sources for a content identifier</p></a></li>
<li><a href='#store'><p>Store files in a local cache</p></a></li>
<li><a href='#store_swh'><p>Add content to the Software Heritage Archival Store</p></a></li>
<li><a href='#swh_ratelimit'><p>software heritage rate limit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.0.19</td>
</tr>
<tr>
<td>Title:</td>
<td>An Interface for Content-Based Identifiers</td>
</tr>
<tr>
<td>Description:</td>
<td>An interface for creating, registering, and resolving content-based
             identifiers for data management. Content-based identifiers rely on
             the 'cryptographic' hashes to refer to the files they identify, thus,
             anyone possessing the file can compute the identifier using a 
             well-known standard algorithm, such as 'SHA256'.  By registering
             a URL at which the content is accessible to a public archive (such as 
             Hash Archive) or depositing data in a scientific repository such 'Zenodo',
             'DataONE' or 'SoftwareHeritage', the content identifier can serve 
             many functions typically associated with A Digital Object Identifier
             ('DOI').  Unlike location-based identifiers like 'DOIs', content-based
             identifiers permit the same content to be registered in many locations.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cboettig/contentid">https://github.com/cboettig/contentid</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cboettig/contentid/issues">https://github.com/cboettig/contentid/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>openssl (&ge; 1.4.2), httr, curl, fs, tools, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, covr, thor, vroom, spelling</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-21 19:01:35 UTC; jovyan</td>
</tr>
<tr>
<td>Author:</td>
<td>Carl Boettiger <a href="https://orcid.org/0000-0002-1642-628X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jorrit Poelen <a href="https://orcid.org/0000-0003-3138-4118"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  NSF OAC 1839201 [fnd]
    (https://www.nsf.gov/awardsearch/showAward?AWD_ID=1839201)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carl Boettiger &lt;cboettig@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-21 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='content_dir'>content store home directory</h2><span id='topic+content_dir'></span>

<h3>Description</h3>

<p>A configurable default location for persistent data storage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>content_dir(dir = Sys.getenv("CONTENTID_HOME", tools::R_user_dir("contentid")))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="content_dir_+3A_dir">dir</code></td>
<td>
<p>directory to be used as the home directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to be called internally with no
arguments.  It will use the directory set by the system environmental
variable CONTENTID_HOME, if set.  Otherwise, it will use the default
location returned by <a href="tools.html#topic+userdir">tools::R_user_dir</a> for the application,
<code>contentid</code>.  Unlike rappdirs function, this function will also
create the directory if it does not yet exist.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## example using temporary storage: 
Sys.setenv(CONTENTID_HOME=tempdir())
content_dir()

## clean up
Sys.unsetenv("CONTENTID_HOME")

## Or explicitly with an argument:
content_dir(tempdir())
</code></pre>

<hr>
<h2 id='content_id'>Generate a content uri for a local file</h2><span id='topic+content_id'></span>

<h3>Description</h3>

<p>Generate a content uri for a local file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>content_id(
  file,
  algos = default_algos(),
  raw = TRUE,
  as.data.frame = length(algos) &gt; 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="content_id_+3A_file">file</code></td>
<td>
<p>path to the file, URL, or a <a href="base.html#topic+connections">base::file</a> connection</p>
</td></tr>
<tr><td><code id="content_id_+3A_algos">algos</code></td>
<td>
<p>Which algorithms should we compute contentid for? Default
&quot;sha256&quot;, see details.</p>
</td></tr>
<tr><td><code id="content_id_+3A_raw">raw</code></td>
<td>
<p>Logical, should compressed data be left as compressed binary?</p>
</td></tr>
<tr><td><code id="content_id_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>should the output be coerced into a data.frame?
Default is <code>FALSE</code> if only one algorithm is computed, otherwise <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://github.com/hash-uri/hash-uri">https://github.com/hash-uri/hash-uri</a> for an overview of the
content uri format and comparison to similar approaches.
</p>
<p>Compressed file streams will have different raw (binary) and uncompressed
hashes. Set <code>raw = FALSE</code> to allow <a href="base.html#topic+connections">base::file</a> connection to uncompress
common compression streams before calculating the hash, but this will
be slower.
</p>


<h3>Value</h3>

<p>a content identifier URI  If multiple algorithms
are requested, <code>content_id</code> will return a data.frame with one
column per algorithm and one row for each input file.  Otherwise
it will return a character vector with one identifier URI for
each input file.  See argument <code>as.data.frame</code> above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## local file
path &lt;- system.file("extdata", "vostok.icecore.co2", package = "contentid")
content_id(path)


content_id(paste0("https://knb.ecoinformatics.org/knb/d1/mn/v2/object/",
                  "ess-dive-457358fdc81d3a5-20180726T203952542"))





</code></pre>

<hr>
<h2 id='default_lmdb'>default location for LMDB registry</h2><span id='topic+default_lmdb'></span>

<h3>Description</h3>

<p>Helper utility to initialize an LMDB registry -
matcher uses the pattern: &quot;any file path ending in &quot;lmdb&quot;.
The default map size can be set using, e.g.
<code>options(thor_mapsize=1e12)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_lmdb(dir = content_dir())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_lmdb_+3A_dir">dir</code></td>
<td>
<p>base directory for LMDB</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Windows machines may need to set a smaller map size,
see <code>thor::mdb_env</code> for details.
</p>

<hr>
<h2 id='default_registries'>default registries</h2><span id='topic+default_registries'></span>

<h3>Description</h3>

<p>A helper function to conveniently load the default registries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_registries()
</code></pre>


<h3>Details</h3>

<p>This function is primarily useful to restrict the
scope of <a href="#topic+sources">sources</a> or <a href="#topic+register">register</a> to, e.g. either just the
remote registry or just the local registry.  Note that a user
can alter the registry on the fly by passing local paths and/or the
URL (<code style="white-space: pre;">&#8288;https://hash-archive.org&#8288;</code>) directly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Both defaults
default_registries()

## Only the fist one (local registry)
default_registries()[1]

## Alter the defaults with env var.
Sys.setenv(CONTENTID_REGISTRIES = tempfile())
default_registries()

Sys.unsetenv("CONTENTID_REGISTRIES")

</code></pre>

<hr>
<h2 id='has_resource'>has_resource</h2><span id='topic+has_resource'></span>

<h3>Description</h3>

<p>Helper function to ensure examples do not execute when internet
resource is temporarily unavailable, as in such cases rendering
the example does not provide a reliable check.  This allows
examples (&quot;tests&quot;) to &quot;fail gracefully&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_resource(url = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="has_resource_+3A_url">url</code></td>
<td>
<p>vector of URL resources required</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>has_resource("https://google.com")

</code></pre>

<hr>
<h2 id='history_swh'>return the history of archive events of a given software repository</h2><span id='topic+history_swh'></span>

<h3>Description</h3>

<p>Note that unlike the generic <a href="utils.html#topic+history">history</a> method, SWH history is repo-specific
rather than content-specific. An archive event adds all content from the repo
to the Software Heritage archival snapshot at once.  Any individual file can still
be referenced by its content identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>history_swh(origin_url, host = "https://archive.softwareheritage.org", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="history_swh_+3A_origin_url">origin_url</code></td>
<td>
<p>The url address to a GitHub, GitLab, or other recognized repository origin</p>
</td></tr>
<tr><td><code id="history_swh_+3A_host">host</code></td>
<td>
<p>the domain name for the Software Heritage API</p>
</td></tr>
<tr><td><code id="history_swh_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="utils.html#topic+history">history</a>, <a href="#topic+store_swh">store_swh</a>, <a href="#topic+sources_swh">sources_swh</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

history_swh("https://github.com/CSSEGISandData/COVID-19")


</code></pre>

<hr>
<h2 id='history_url'>List all content identifiers that have been seen at a given URL</h2><span id='topic+history_url'></span><span id='topic+history_url+2C'></span><span id='topic+query_history'></span>

<h3>Description</h3>

<p><a href="#topic+history_url">history_url</a> is the complement of <a href="#topic+sources">sources</a>, in that it filters a table
of content identifier : url : date entries by the url.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>history_url(url, registries = default_registries(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="history_url_+3A_url">url</code></td>
<td>
<p>A URL for a data file</p>
</td></tr>
<tr><td><code id="history_url_+3A_registries">registries</code></td>
<td>
<p>list of registries at which to register the URL</p>
</td></tr>
<tr><td><code id="history_url_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+history_url">history_url()</a></code> only applies to registries that contain mutable URLs,
i.e. hash-archive and local registries which merely record the contents last
seen at any URL.  Such URLs may have the same or different content at a later
date, or may fail to resolve.  In contrast, archives such as DataONE or
Zenodo that resolve identifiers to source URLs control both the registry and
the content storage, and thus only report URLs where content is currently found.
While Download URLs from archives may move and old URLs may fail, a download URL
never has &quot;history&quot; of different content (e.g. different versions) served
from the same access URL.
</p>


<h3>Value</h3>

<p>a data frame with all content identifiers that have been seen
at a given URL.  If the URL is version-stable, this should be a single
identifier.  Note that if multiple identifiers are listed, older content
may no longer be available, though there is a chance it has been registered
to a different url and can be resolved with <a href="#topic+sources">sources</a>.
</p>


<h3>See Also</h3>

<p>sources
</p>


<h3>Examples</h3>

<pre><code class='language-R'>




 
history_url(paste0("https://zenodo.org/api/files/5967f986-b599-4492-9a08",
"-94ce32323dc2/vostok.icecore.co2"), 
registries = "https://hash-archive.carlboettiger.info")


 

</code></pre>

<hr>
<h2 id='pin'>Access the latest content at a URL (DEPRECATED)</h2><span id='topic+pin'></span>

<h3>Description</h3>

<p>This will download the requested object to a local cache and return the local path of the
object.  first time it is run, and then use a local cache
unless content has changed. This behavior is similar to <code>pins::pin()</code>,
but uses cryptographic content hashes. Because content hashes are computed in a fast public
content registry, this will usually be faster than downloading on a local connection,
but slower than checking eTags in headers.  Use <a href="#topic+resolve">resolve</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pin(
  url,
  verify = TRUE,
  dir = content_dir(),
  registries = "https://hash-archive.org"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pin_+3A_url">url</code></td>
<td>
<p>a URL to a web resource</p>
</td></tr>
<tr><td><code id="pin_+3A_verify">verify</code></td>
<td>
<p>logical, default TRUE. Should we verify the content identifier (SHA-256 hash)
of content at the URL before we look for a local cache?</p>
</td></tr>
<tr><td><code id="pin_+3A_dir">dir</code></td>
<td>
<p>path to the local store directory. Defaults to first local registry given to
the <code>registries</code> argument.</p>
</td></tr>
<tr><td><code id="pin_+3A_registries">registries</code></td>
<td>
<p>list of registries at which to register the URL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>at this time, verify mode cannot process FTP resources.
Use verify = FALSE to enable a fast read from cache. This essentially allows
a URL to act as an identifier, and is a good choice for URLs known to be version
stable.  If verify = FALSE, this will merely attempt to find a local copy of data
previously associated (registered) at that URL. It will not attempt
to compute the content identifier of the content at the URL, thus the
local copy may or may not match the content at that address.
</p>


<h3>See Also</h3>

<p>resolve
</p>

<hr>
<h2 id='purge_cache'>Purge older files from the local cache.</h2><span id='topic+purge_cache'></span>

<h3>Description</h3>

<p>Deletes oldest files until cache size is below the threshold size.
Additionally, users can specify a maximum age in days to delete all
files older than the threshold, which can speed up file purge in large
stores. Setting either age and threshold to 0 will purge everything from
cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purge_cache(threshold = "1G", age = Inf, dir = content_dir(), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="purge_cache_+3A_threshold">threshold</code></td>
<td>
<p>Threshold size, accepts <code style="white-space: pre;">&#8288;[fs::fs_bytes]&#8288;</code> notation.</p>
</td></tr>
<tr><td><code id="purge_cache_+3A_age">age</code></td>
<td>
<p>Maximum age in days</p>
</td></tr>
<tr><td><code id="purge_cache_+3A_dir">dir</code></td>
<td>
<p>the path we should use for permanent / on-disk storage
of the registry. An appropriate default will be selected (also
configurable using the environmental variable <code>CONTENTID_HOME</code>),
if not specified.</p>
</td></tr>
<tr><td><code id="purge_cache_+3A_verbose">verbose</code></td>
<td>
<p>show deleted file paths?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default behavior will keep <code>contentid</code>'s local store size below 1 GB.
Note that <code>contentid</code> functions do not automatically call purge_cache(),
this must be handled by user workflows.
</p>


<h3>Value</h3>

<p>invisibly returns directory path
</p>

<hr>
<h2 id='query'>query a Content URI or a URL with remote and/or local registries</h2><span id='topic+query'></span>

<h3>Description</h3>

<p>DEPRECATED, please use <code><a href="#topic+sources">sources()</a></code> or <code><a href="#topic+history_url">history_url()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query(uri, registries = default_registries(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query_+3A_uri">uri</code></td>
<td>
<p>a content identifier or a regular URL for a data file</p>
</td></tr>
<tr><td><code id="query_+3A_registries">registries</code></td>
<td>
<p>list of registries at which to register the URL</p>
</td></tr>
<tr><td><code id="query_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with matching results
</p>

<hr>
<h2 id='register'>register a URL with remote and/or local registries</h2><span id='topic+register'></span>

<h3>Description</h3>

<p>register a URL with remote and/or local registries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register(url, registries = default_registries(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="register_+3A_url">url</code></td>
<td>
<p>a URL for a data file (or list of URLs)</p>
</td></tr>
<tr><td><code id="register_+3A_registries">registries</code></td>
<td>
<p>list of registries at which to register the URL</p>
</td></tr>
<tr><td><code id="register_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local registries can be specified as one or more file paths
where local registries should be created.  Usually a given application
will want to register in only one local registry.  For most use cases,
the default registry should be sufficient.
</p>


<h3>Value</h3>

<p>the <a href="httr.html#topic+response">httr::response</a> object for the request (invisibly)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



 


register(paste0("https://knb.ecoinformatics.org/knb/d1/mn/v2/object/",
"ess-dive-457358fdc81d3a5-20180726T203952542"))





</code></pre>

<hr>
<h2 id='resolve'>Resolve content from a content identifier</h2><span id='topic+resolve'></span>

<h3>Description</h3>

<p>Requested content can be found at mutiple locations:
cached to disk, or available at one or more URLs.  This function
provides a mechanism to always return a single, local path to the
content requested, (provided the content identifier can be found in
at least one of the registries).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve(
  id,
  registries = default_registries(),
  verify = TRUE,
  store = FALSE,
  dir = content_dir(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolve_+3A_id">id</code></td>
<td>
<p>A content identifier, see <a href="#topic+content_id">content_id</a></p>
</td></tr>
<tr><td><code id="resolve_+3A_registries">registries</code></td>
<td>
<p>list of registries at which to register the URL</p>
</td></tr>
<tr><td><code id="resolve_+3A_verify">verify</code></td>
<td>
<p>logical, default <a href="base.html#topic+TRUE">TRUE</a>. Should we verify that
content matches the requested hash?</p>
</td></tr>
<tr><td><code id="resolve_+3A_store">store</code></td>
<td>
<p>logical, should we add remotely downloaded copy to the local store?</p>
</td></tr>
<tr><td><code id="resolve_+3A_dir">dir</code></td>
<td>
<p>path to the local store directory. Defaults to first local registry given to
the <code>registries</code> argument.</p>
</td></tr>
<tr><td><code id="resolve_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Local storage
is checked first as it will allow us to bypass downloading content
when a local copy is available. If no local copy is found but
one or more remote URLs are registered for the hash, downloads
from these will be attempted in order from most recent first.
</p>


<h3>See Also</h3>

<p>query query_local query_remote
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# ensure some content in local storage for testing purposes:
vostok_co2 &lt;- system.file("extdata", "vostok.icecore.co2",
                          package = "contentid")
store(vostok_co2)


resolve(paste0(
 "hash://sha256/9412325831dab22aeebdd6",
 "74b6eb53ba6b7bdd04bb99a4dbb21ddff646287e37")
)




</code></pre>

<hr>
<h2 id='retrieve'>Retrieve files from the local cache</h2><span id='topic+retrieve'></span>

<h3>Description</h3>

<p>Retrieve files from the local cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve(id, dir = content_dir())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retrieve_+3A_id">id</code></td>
<td>
<p>a <a href="#topic+content_id">content_id</a></p>
</td></tr>
<tr><td><code id="retrieve_+3A_dir">dir</code></td>
<td>
<p>the path we should use for permanent / on-disk storage
of the registry. An appropriate default will be selected (also
configurable using the environmental variable <code>CONTENTID_HOME</code>),
if not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>path to a local copy of the file.
</p>


<h3>See Also</h3>

<p>store
</p>


<h3>Examples</h3>

<pre><code class='language-R'>



# Store &amp; retrieve local file
vostok_co2 &lt;- system.file("extdata", "vostok.icecore.co2",
                          package = "contentid")
 id &lt;- store(vostok_co2)
 retrieve(id)



</code></pre>

<hr>
<h2 id='retrieve_swh'>retrieve content from Software Heritage given a content identifier</h2><span id='topic+retrieve_swh'></span>

<h3>Description</h3>

<p>retrieve content from Software Heritage given a content identifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retrieve_swh(id, host = "https://archive.softwareheritage.org")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="retrieve_swh_+3A_id">id</code></td>
<td>
<p>a content identifier</p>
</td></tr>
<tr><td><code id="retrieve_swh_+3A_host">host</code></td>
<td>
<p>the domain name for the Software Heritage API</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+retrieve">retrieve</a>, <a href="#topic+sources_swh">sources_swh</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


id &lt;- paste0("hash://sha256/9412325831dab22aeebdd",
             "674b6eb53ba6b7bdd04bb99a4dbb21ddff646287e37")
retrieve_swh(id)



</code></pre>

<hr>
<h2 id='sources'>List all known URL sources for a given Content URI</h2><span id='topic+sources'></span><span id='topic+sources+2C'></span><span id='topic+query_sources'></span>

<h3>Description</h3>

<p>List all known URL sources for a given Content URI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sources(
  id,
  registries = default_registries(),
  cols = c("source", "date"),
  all = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sources_+3A_id">id</code></td>
<td>
<p>a content identifier</p>
</td></tr>
<tr><td><code id="sources_+3A_registries">registries</code></td>
<td>
<p>list of registries at which to register the URL</p>
</td></tr>
<tr><td><code id="sources_+3A_cols">cols</code></td>
<td>
<p>names of columns to keep. Default are <code>source</code> and <code>date</code>.
See details.</p>
</td></tr>
<tr><td><code id="sources_+3A_all">all</code></td>
<td>
<p>should we query remote registries even if a local source is found?
Default TRUE</p>
</td></tr>
<tr><td><code id="sources_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>possible columns are (in order): <code>identifier</code>, <code>source</code>, <code>date</code>,
<code>size</code>, <code>status</code>, <code>md5</code>, <code>sha1</code>, <code>sha256</code>, <code>sha384</code>, <code>sha512</code>
</p>


<h3>Value</h3>

<p>a data frame with all registration events when a URL or
a local path (including the local store) have contained the corresponding
content.
</p>


<h3>See Also</h3>

<p>history register store
</p>


<h3>Examples</h3>

<pre><code class='language-R'>




id &lt;- paste0("hash://sha256/9412325831dab22aeebdd",
             "674b6eb53ba6b7bdd04bb99a4dbb21ddff646287e37")
sources(id)




</code></pre>

<hr>
<h2 id='sources_swh'>List software heritage sources for a content identifier</h2><span id='topic+sources_swh'></span>

<h3>Description</h3>

<p>List software heritage sources for a content identifier
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sources_swh(id, host = "https://archive.softwareheritage.org", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sources_swh_+3A_id">id</code></td>
<td>
<p>a content identifier</p>
</td></tr>
<tr><td><code id="sources_swh_+3A_host">host</code></td>
<td>
<p>the domain name for the Software Heritage API</p>
</td></tr>
<tr><td><code id="sources_swh_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+sources">sources</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 

id &lt;- paste0("hash://sha256/9412325831dab22aeebdd",
             "674b6eb53ba6b7bdd04bb99a4dbb21ddff646287e37")
sources_swh(id)



</code></pre>

<hr>
<h2 id='store'>Store files in a local cache</h2><span id='topic+store'></span>

<h3>Description</h3>

<p>Resources at a specified URL will be downloaded and copied
into the local content-based storage. Local paths will simply
be copied into local storage. Identical content is not duplicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store(x, dir = content_dir(), algos = default_algos())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_+3A_x">x</code></td>
<td>
<p>a URL, <a href="base.html#topic+connection">connection</a>, or file path.</p>
</td></tr>
<tr><td><code id="store_+3A_dir">dir</code></td>
<td>
<p>the path we should use for permanent / on-disk storage
of the registry. An appropriate default will be selected (also
configurable using the environmental variable <code>CONTENTID_HOME</code>),
if not specified.</p>
</td></tr>
<tr><td><code id="store_+3A_algos">algos</code></td>
<td>
<p>Which algorithms should we compute contentid for? Default
&quot;sha256&quot;, see details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the content-based identifier
</p>


<h3>See Also</h3>

<p>retrieve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Store &amp; retrieve local file
vostok_co2 &lt;- system.file("extdata", "vostok.icecore.co2",
                          package = "contentid")
 id &lt;- store(vostok_co2)
 retrieve(id)



</code></pre>

<hr>
<h2 id='store_swh'>Add content to the Software Heritage Archival Store</h2><span id='topic+store_swh'></span>

<h3>Description</h3>

<p>Add content to the Software Heritage Archival Store
</p>


<h3>Usage</h3>

<pre><code class='language-R'>store_swh(
  origin_url,
  host = "https://archive.softwareheritage.org",
  type = "git",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="store_swh_+3A_origin_url">origin_url</code></td>
<td>
<p>The url address to a GitHub, GitLab, or other recognized repository origin</p>
</td></tr>
<tr><td><code id="store_swh_+3A_host">host</code></td>
<td>
<p>the domain name for the Software Heritage API</p>
</td></tr>
<tr><td><code id="store_swh_+3A_type">type</code></td>
<td>
<p>software repository type, i.e. &quot;git&quot;, &quot;svn&quot;</p>
</td></tr>
<tr><td><code id="store_swh_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

store_swh("https://github.com/CSSEGISandData/COVID-19")


</code></pre>

<hr>
<h2 id='swh_ratelimit'>software heritage rate limit</h2><span id='topic+swh_ratelimit'></span>

<h3>Description</h3>

<p>software heritage rate limit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swh_ratelimit(verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swh_ratelimit_+3A_verbose">verbose</code></td>
<td>
<p>show messages about current rate limits?
Software Heritage has a rate limit that can interfere with common queries
(resolve sources, register) when large numbers of queries are made.
contentid functions will not automatically check against wait limits,
but may fall back to other registeries when available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>remaining, total, and time until next reset are invisibly
returned as a data.frame.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
