<!DOCTYPE html><html><head><title>Help for package AlgDesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AlgDesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AlgDesign-internal'><p>Internal AlgDesign function</p></a></li>
<li><a href='#CCTable11.1a'><p>Cochran and Cox design</p></a></li>
<li><a href='#efficient.rounding'><p>Efficient Rounding</p></a></li>
<li><a href='#eval.blockdesign'><p>Evaluates a blocked design.</p></a></li>
<li><a href='#eval.design'><p>Evaluates a design.</p></a></li>
<li><a href='#expand.formula'><p>Expanding a formula</p></a></li>
<li><a href='#gen.factorial'><p>Generates a full factorial design</p></a></li>
<li><a href='#gen.mixture'><p>Generate mixture</p></a></li>
<li><a href='#GVTable1'><p>Goos Vandebroek Table 1</p></a></li>
<li><a href='#GVTable3'><p>Goos Vandebroek Table 3</p></a></li>
<li><a href='#model.matrix.formula'><p>Builds a model matrix</p></a></li>
<li><a href='#model.matrix.terms'><p>Internal model.matrix.terms  function</p></a></li>
<li><a href='#optBlock'><p>Optimal design blocking</p></a></li>
<li><a href='#optFederov'><p>Optimal design</p></a></li>
<li><a href='#optMonteCarlo'><p>Optimal design via Monte Carlo</p></a></li>
<li><a href='#TGTable3'><p>Trinca Gilmour Table 3</p></a></li>
<li><a href='#TGTable5'><p>Trinca Gilmour Table 5</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithmic Experimental Design</td>
</tr>
<tr>
<td>Author:</td>
<td>Bob Wheeler &lt;bwheelerg@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jerome Braun &lt;jvbraun.statistics@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithmic experimental designs. Calculates exact and
        approximate theory experimental designs for D,A, and I
        criteria. Very large designs may be created. Experimental
        designs may be blocked or blocked designs created from a
        candidate list, using several criteria.  The blocking can be
        done when whole and within plot factors interact.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jvbraun/AlgDesign">https://github.com/jvbraun/AlgDesign</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-24 06:04:45 UTC; Jerome</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-25 07:30:19 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
</table>
<hr>
<h2 id='AlgDesign-internal'>Internal AlgDesign function</h2><span id='topic+actuals'></span>

<h3>Description</h3>

<p>Outputs the actual argument list of a function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>actuals(frmals) 
</code></pre>


<h3>Details</h3>

<p>Where frmals is formals(&quot;fcnName&quot;).
This is not to be called by the user.
</p>

<hr>
<h2 id='CCTable11.1a'>Cochran and Cox design</h2><span id='topic+CCTable11.1a'></span>

<h3>Description</h3>

<p>A blocked experimental design from Cochran and Cox (1957).
</p>
<p>A Partially balanced incomplete block in 3 reps, and 27 blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(CCTable11.1a)
</code></pre>


<h3>Source</h3>

<p>Cochran, W.G. and Cox, G.M. (1957). <em>Experimental designs</em>. Wiley, N.Y.
</p>

<hr>
<h2 id='efficient.rounding'>Efficient Rounding</h2><span id='topic+efficient.rounding'></span>

<h3>Description</h3>

<p>A vector of proportions is efficiently rounded to integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>efficient.rounding(proportions,n,random=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="efficient.rounding_+3A_proportions">proportions</code></td>
<td>
<p>A vector of proportions.</p>
</td></tr>
<tr><td><code id="efficient.rounding_+3A_n">n</code></td>
<td>
<p>The sum of the resulting integers.</p>
</td></tr>
<tr><td><code id="efficient.rounding_+3A_random">random</code></td>
<td>
<p>If TRUE, ties will be broken at random, otherwise the first of the tied values will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements an efficient rounding procedure to round approximate theory designs
into replicated integer approximations.
</p>


<h3>Value</h3>

<p>A vector of replications summing to n.
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). efficient.rounding. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>


<h3>References</h3>

<p>Pulkesheim, F. and Rieder, S. (1992). Efficient rounding of approximate designs. Biometrika. 79-4. 763-770.</p>

<hr>
<h2 id='eval.blockdesign'>Evaluates a blocked design.</h2><span id='topic+eval.blockdesign'></span>

<h3>Description</h3>

<p>A blocked design is evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.blockdesign(frml,design,blocksizes,rho=1,confounding=FALSE,center=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.blockdesign_+3A_frml">frml</code></td>
<td>
<p>The formula used to create the blocked design.</p>
</td></tr>
<tr><td><code id="eval.blockdesign_+3A_design">design</code></td>
<td>
<p>The blocked design, which may be the design output by optBlock().</p>
</td></tr>
<tr><td><code id="eval.blockdesign_+3A_blocksizes">blocksizes</code></td>
<td>
<p>A vector of blocksizes for the design.</p>
</td></tr>
<tr><td><code id="eval.blockdesign_+3A_rho">rho</code></td>
<td>
<p>A vector, giving the ratios of whole to within variance components.</p>
</td></tr>
<tr><td><code id="eval.blockdesign_+3A_confounding">confounding</code></td>
<td>
<p>If confounding=TRUE, the confounding matrix will be output.</p>
</td></tr> 
<tr><td><code id="eval.blockdesign_+3A_center">center</code></td>
<td>
<p>If TRUE, numeric variables will be centered before frml is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>confounding</code></td>
<td>
<p>A matrix based on the design matrix in which the within block variables
have been centered about their block means. The columns of this matrix which give 
the regression coefficients of each variable regressed on the others. If <code class="reqn">C</code> is the 
confounding matrix, then <code class="reqn">-XC</code> is a matrix of residuals of the variables regressed on 
the other variables.</p>
</td></tr>
<tr><td><code>determinant.all.terms.within.terms.centered</code></td>
<td>
<p><code class="reqn">|M|^{1/k}</code>, where 
<code class="reqn">M=X^TX/N</code> and X is the model expanded <code class="reqn">N\times k</code> design matrix 
in which the within block variables	have been centered about the grand mean.</p>
</td></tr>
<tr><td><code>within.block.efficiencies</code></td>
<td>
<p>The determinant criterion blocking efficiencies for the range 
of rho's input. A high efficiency indicates that there is little intrablock information
to be recovered in the analysis.</p>
</td></tr>
<tr><td><code>block.centered.properties</code></td>
<td>
<p>A matrix with four rows. The columns correspond to constant, whole
block terms and within block terms:
</p>

<ol>
<li><p> The degrees of freedom for terms in the expanded model.  
</p>
</li>
<li><p> The determinant of the block centered within block terms.  
</p>
</li>
<li><p> The geometric mean of the block centered variances.  
</p>
</li>
<li><p> The geometric mean of the ratio of centered to block centered variances. 
</p>
</li></ol>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). eval.blockdesign. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>

<hr>
<h2 id='eval.design'>Evaluates a design.</h2><span id='topic+eval.design'></span>

<h3>Description</h3>

<p>A design is evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval.design(frml,design,confounding=FALSE,variances=TRUE,center=FALSE,X=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.design_+3A_frml">frml</code></td>
<td>
<p>The formula used to create the design.</p>
</td></tr>
<tr><td><code id="eval.design_+3A_design">design</code></td>
<td>
<p>The design, which may be the design part of the output of optFederov().</p>
</td></tr>
<tr><td><code id="eval.design_+3A_confounding">confounding</code></td>
<td>
<p>If confounding=TRUE, the confounding patterns will be shown.</p>
</td></tr> 
<tr><td><code id="eval.design_+3A_variances">variances</code></td>
<td>
<p>If TRUE, the variances each term will be output.</p>
</td></tr>
<tr><td><code id="eval.design_+3A_center">center</code></td>
<td>
<p>If TRUE, numeric variables will be centered before frml is applied.</p>
</td></tr>
<tr><td><code id="eval.design_+3A_x">X</code></td>
<td>
<p>X is either the matrix describing the prediction space for I or for G, the 
the candidate set from which the design was chosen. They are often
the same.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>confounding</code></td>
<td>
<p>A matrix. The columns of which give the regression coefficients of
each variable regressed on the others. If <code class="reqn">C</code> is the confounding matrix, then 
<code class="reqn">-ZC</code> is a matrix of residuals of the variables regressed on the other variables.</p>
</td></tr>
<tr><td><code>determinant</code></td>
<td>
<p><code class="reqn">|M|^{1/k}</code>, where <code class="reqn">M=Z'Z/N</code>, and Z is 
the model expanded <code class="reqn">N\times k</code> design matrix.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>The average coefficient variance: <code class="reqn">trace(Mi)/k</code>, where <code class="reqn">Mi</code> is the 
inverse of <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>The average prediction variance over X, which can be shown to be 
<code class="reqn">trace((X'X*Mi)/N)</code>.</p>
</td></tr> 
<tr><td><code>Ge</code></td>
<td>
<p>The minimax normalized variance over X, expressed as an efficiency with respect 
to the optimal approximate theory design. It is defined as <code class="reqn">k/max(d)</code>, where 
<code class="reqn">max(d)</code> is the maximum normalized variance over <code class="reqn">X</code> &ndash; i.e. the max of 
<code class="reqn">x'(Mi)x</code>, over all rows <code class="reqn">x'</code> of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>Dea</code></td>
<td>
<p>A lower bound on <code>D</code> efficiency for approximate theory designs. It is 
equal to <code class="reqn">exp(1-1/Ge)</code>.</p>
</td></tr>
<tr><td><code>diagonality</code></td>
<td>
<p>The diagonality of the design, excluding the constant, if any. Diagonality
is defined as <code class="reqn">(|M_1|/\prod{diag(M_1)})^{1/k}</code>, where 
<code class="reqn">M_1</code> is <code class="reqn">M</code> with first column and row deleted when there is a constant.</p>
</td></tr>
<tr><td><code>gmean.variances</code></td>
<td>
<p>The geometric mean of the coefficient variances.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>I, Ge and Dea are calculated only when X is input.
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). eval.design. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>

<hr>
<h2 id='expand.formula'>Expanding a formula</h2><span id='topic+expand.formula'></span>

<h3>Description</h3>

<p>Formulas are expanded to accommodate special functions for continuous and mixture variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.formula(frml,varNames,const=TRUE,numerics=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.formula_+3A_frml">frml</code></td>
<td>
<p>A formula starting with ~ in the usual way.</p>
</td></tr>
<tr><td><code id="expand.formula_+3A_varnames">varNames</code></td>
<td>
<p>A list of variable names to be used when a dot is used as shorthand for &ldquo;all variables.&rdquo;</p>
</td></tr>
<tr><td><code id="expand.formula_+3A_const">const</code></td>
<td>
<p>If FALSE, the constant will be suppressed.</p>
</td></tr>
<tr><td><code id="expand.formula_+3A_numerics">numerics</code></td>
<td>
<p>A vector the same length as varNames, with TRUE for corresponding numeric variables. If
missing, all variables will be assumed to be numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function expands formulas to accommodate polynomial models for which R has minimal support.
Assuming for illustration that there are three variables, A, B, and C, the following expressions
may be used. In addition, a dot may be used to indicate that all variables in varNames are to be used. 
</p>
<p>All agruments to quad(), cubic(), and cubicS() must be numeric.
</p>

<ul>
<li> <p><code class="reqn">~.</code> makes <code class="reqn">~ A + B + C</code>
</p>
</li>
<li> <p><code class="reqn">~.^p</code> makes <code class="reqn">~ (A + B + C)^p</code>, where p is an integer
</p>
</li>
<li><p> quad(A,B,C) makes <code class="reqn">~(A+B+C)^2+I(A^2)+I(B^2)+I(C^2)</code>
</p>
</li>
<li><p> cubic(A,B,C) makes <code class="reqn">~(A+B+C)^3+I(A^2)+I(B^2)+I(C^2)+I(A^3)+I(B^3)+I(C^3)</code>
</p>
</li>
<li><p> cubicS(A,B,C) makes <code class="reqn">~(A+B+C)^3+I(A*B*(A-B))+I(A*C*(A-C))+I(B*C*(B-C))</code>
</p>
</li></ul>

<p>The cubicS() function produces a non-singular representation of a cubic model, when the 
variables are mixture variables, that is when the rows of <code>data</code> sum to a constant
value, usually 1.0. Because of the mixture constraint, models containing mixture variables
should not have a constant term. The linear and quadratic models for mixture variables
A, B, and C are given by <code class="reqn">-1+(A+B+C)</code> and <code class="reqn">-1+(A+B+C)^2</code> respectively. See Gorman and Hinman [1962] for 
details.
</p>


<h3>Value</h3>

<p>An expanded formula is returned.
</p>


<h3>Note</h3>

<p>expand.formula() is called by model.matrix() through the method call model.matix.formula(), thus one may use the above special functions with model.matrix().
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). expand.formula. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>


<h3>References</h3>

<p>Gorman, J.W. and Hinman, J.E. (1962). Simplex lattice designs for 
multicomponent systems. <em>Technometrics</em>. 4-4. 463-487.
</p>

<hr>
<h2 id='gen.factorial'>Generates a full factorial design</h2><span id='topic+gen.factorial'></span>

<h3>Description</h3>

<p>A full factorial design is generated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	gen.factorial(levels, nVars=0, center=TRUE, factors="none",varNames=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.factorial_+3A_levels">levels</code></td>
<td>
<p>A vector of levels for the variables. May be an integer if nVars is specified.</p>
</td></tr>
<tr><td><code id="gen.factorial_+3A_nvars">nVars</code></td>
<td>
<p>The number of variables.</p>
</td></tr>
<tr><td><code id="gen.factorial_+3A_center">center</code></td>
<td>
<p>If TRUE, all non-factors will be centered.</p>
</td></tr>
<tr><td><code id="gen.factorial_+3A_factors">factors</code></td>
<td>
<p>If &quot;all&quot;, all variables are factors, otherwise a vector of the variable numbers
of the variables that are to be factors.</p>
</td></tr>
<tr><td><code id="gen.factorial_+3A_varnames">varNames</code></td>
<td>
<p>The names of the variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factorial design in a data.frame.
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). gen.factorial. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat&lt;-gen.factorial(3,3)
dat&lt;-gen.factorial(c(3,2,3))
dat&lt;-gen.factorial(3,3,factors="all")
dat&lt;-gen.factorial(3,3,varNames=c("A","B","C"))

</code></pre>

<hr>
<h2 id='gen.mixture'>Generate mixture</h2><span id='topic+gen.mixture'></span>

<h3>Description</h3>

<p>Creates a candidate list of mixture variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.mixture(levels,vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.mixture_+3A_levels">levels</code></td>
<td>
<p>An integer greater than 1. The number of levels of the mixture variables.</p>
</td></tr>
<tr><td><code id="gen.mixture_+3A_vars">vars</code></td>
<td>
<p>Either the number of variables, or a character vector of variable names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar in function to gen.factorial(), but for mixture variables such that the rows sum to unity.
For <code>levels=2</code>, the identity matrix is produced, so that each variable is either 0 or 1. For 
<code>levels=3</code>, rows are added to the identity containing two variables at 1/2 and the others at 0. etc.
</p>
<p>In general, a mixture model of degree d will have the same number of terms as the candidate
list generated by <code>gen.mixture</code> for <code>levels=d+1</code>, and this will be optimal. 
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). gen.mixture. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>

<hr>
<h2 id='GVTable1'>Goos Vandebroek Table 1</h2><span id='topic+GVTable1'></span>

<h3>Description</h3>

<p>A blocked experimental design from Goos and Vandebroek (2003).
</p>
<p>A matrix giving one whole plot and four within plot variables, 
in 21 blocks of 2.
The same as TGTable5, but produced by Goos Vandoebroek algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(GVTable1)
</code></pre>


<h3>Source</h3>

<p>Goos, P. and Vandebroek, M. (2003). D-optimal split-plot designs with given numbers and 
sizes of whole plots. <em>Technometrics.</em> 45-3. 235-245.
</p>

<hr>
<h2 id='GVTable3'>Goos Vandebroek Table 3</h2><span id='topic+GVTable3'></span>

<h3>Description</h3>

<p>A blocked experimental design from Goos and Vandebroek (2003).
</p>
<p>A matrix giving one whole and two within plot variables, 9 blocks of 21.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(GVTable3)
</code></pre>


<h3>Source</h3>

<p>Goos, P. and Vandebroek, M. (2003). D-optimal split-plot designs with given numbers and 
sizes of whole plots. <em>Technometrics.</em> 45-3. 235-245.
</p>

<hr>
<h2 id='model.matrix.formula'>Builds a model matrix</h2><span id='topic+model.matrix.formula'></span>

<h3>Description</h3>

<p>Produces a model matrix using expand.formula()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
model.matrix(frml,data,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.formula_+3A_frml">frml</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="model.matrix.formula_+3A_data">data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="model.matrix.formula_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to model.matrix.default()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method function signaled by a formula as the first argument. 
It causes the formula to be translated by expand.formula() before calling
model.matrix.default().
</p>


<h3>Value</h3>

<p>A matix.
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). model.matrix.formula. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>

<hr>
<h2 id='model.matrix.terms'>Internal model.matrix.terms  function</h2><span id='topic+model.matrix.terms'></span>

<h3>Description</h3>

<p>defines a model.matrix function for the terms class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'terms'
model.matrix(...) 
</code></pre>


<h3>Details</h3>

<p>This is not to be called by the user.
It fixes a bug whose solution was suggested  by Bill Dunlap, TIBCO Software Inc.
</p>

<hr>
<h2 id='optBlock'>Optimal design blocking</h2><span id='topic+optBlock'></span>

<h3>Description</h3>

<p>Blocking of experimental designs using various criteria.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
optBlock(frml,withinData,blocksizes,rows=NULL,wholeBlockData=NULL,center=FALSE,
	nRepeats=5,criterion="D",args=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optBlock_+3A_frml">frml</code></td>
<td>
<p>This may be omitted if <code>data</code> is the fully model expanded candidate list.
If present it should be a formula starting with <code>~</code> which describes the model using
variable names from <code>data</code>. It may be <code>~</code>. if all variables from <code>data</code> are to be 
used linearly. It may also be <code class="reqn">~.^p</code>, where p is an integer. In addition to the usual 
operators, quad(), cubic() and cubicS() may be used to expand variables from <code>data</code> 
into polynomial models.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_withindata">withinData</code></td>
<td>
<p>A matrix or data.frame describing the variables. If the columns are not 
named, they will be assumed to have the names X1,X2, etc. Although data may be input as
global variables used in frml, it is preferable to input it here. The number of rows in <code>withinData</code>
must be at least as large as the sum of the number of terms plus the number of blocks.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_blocksizes">blocksizes</code></td>
<td>
<p>A vector giving the block sizes for each block. The length of <code>blocksizes</code>
specifies the number of blocks.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_rows">rows</code></td>
<td>
<p>Row numbers (not rownames) of withinData rows to be used as a starting blocked design.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_wholeblockdata">wholeBlockData</code></td>
<td>
<p>A matrix or data.frame describing the whole block variables. The number of
rows should equal the length of blocksizes. Each row should
correspond to the settings of the whole block variable in a block.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_center">center</code></td>
<td>
<p>If TRUE, the withinData and wholeBlockData will be centered.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_nrepeats">nRepeats</code></td>
<td>
<p>The number of times the entire process is repeated.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_criterion">criterion</code></td>
<td>
<p>&quot;D&quot;:D-criterion: &quot;OB&quot;,&quot;OBS&quot;: orthogonal blocks, unscaled and scaled; &quot;Dp&quot;,&quot;Dpc&quot;: 
Product of block determinants, uncentered and centered.</p>
</td></tr>
<tr><td><code id="optBlock_+3A_args">args</code></td>
<td>
<p>If TRUE, the actual arguments to the function including the starting random number
seed should be output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cook and Nachtsheim (1989) developed a blocking algorithm using the D criterion, which not only finds blocks, but attempts to optimize the design itself. The package Dopt, converted by V.N. Venables, implements this technology &ndash; unfortunately there seem to be bugs in the FORTRAN code. 
</p>
<p>This function uses various criteria to block either pre-existing designs or to creates a new blocked design from a candidate list. There may be interactions between whole plot and within plot factors, and it may be used to produce multistratum blocked designs. 
</p>
<p>The algebraic expressions used here for the D criterion are quite different than those used by either Cook and Nachtshim or Goos and Vandebroek. They are described in <em>Comments on algorithmic design</em>, a paper accompanying this package.
</p>
<p>Although the D criterion produces good designs for all blocks, the allocation for individual blocks can often be improved upon by the use of either the Dp or Dpc criterion, which optimize the product of the determinants of the individual blocks. The Dp criterion uses uncentered blocks, the Dpc uses centered blocks. 
</p>
<p>Blocking may also be done using the orthogonal blocking procedure of Nguyen. This comes in two flavors OB and OBS which differ in that for OBS, the columns of S are scaled by division with the sample variance of the data, thus deemphasizing squared and other large terms.
</p>
<p>Blocking may be done when whole plot factors interact with within plot factors. Split plot experiments are sometimes of this nature. Goos and Vandebroek (2003) developed a procedure for this problem which algorithmically blocks using a candidate list and the ratio between the whole and within variances. Trinca and Gilmour (2001) give an algorithm which does not depend on the ratio of the variances. The present procedure assumes that the whole blocks and their factors, have been decided upon in advance. It makes no assumptions about the ratio between whole and within variances. 
</p>
<p>A vignette giving further details is availble. To access it, type
</p>
<p>vignette(&quot;AlgDesign&quot;)
</p>


<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p><code class="reqn">det(M)^{1/k}</code>, where <code class="reqn">det(M)</code> is the
determinant of the normalized dispersion matrix <code class="reqn">M</code> &ndash;
i.e. <code class="reqn">M=X'X/N</code>, where each row of X has had the appropriate block mean subtracted.</p>
</td></tr>
<tr><td><code>Dp (Dpc)</code></td>
<td>
<p><code class="reqn">\left(\prod_1^b (det(M_i))^{1/k}\right)^{1/b}</code>, 
where <code class="reqn">det(M_i)</code> is the determinant of the normalized dispersion matrix 
for the uncentered (centered) block submatrix of <code class="reqn">X</code>, and <code class="reqn">b</code> is the number of blocks. The
normalization is with respect to the number of observations in each block.</p>
</td></tr>
<tr><td><code>diagonality or SS</code></td>
<td>
<p>The diagonality is <code class="reqn">(|M|/P)^{1/k}</code>, where P is the product of the diagonal
elements of M. The SS is the sum of squares of S when the OB criterion is used.</p>
</td></tr>
<tr><td><code>Blocks</code></td>
<td>
<p>A list of the blocks, labeled B1, B2, etc.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>A data.frame. The design with blocks stacked in order.</p>
</td></tr>
<tr><td><code>rows</code></td>
<td>
<p>Numeric row numbers of the design rows corresponding to the withinData rows.</p>
</td></tr> 
<tr><td><code>args</code></td>
<td>
<p>A list of the actual arguments used in this call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). optBlock. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>


<h3>References</h3>

<p>Atkinson, A.C. and Donev, A.N. (1989). The construction of exact D-optimum experimental designs with application to blocking response surface designs. <em>Biometrika</em>. 76. 515-526.
</p>
<p>Cook, R.D. and Nachtsheim, C.J. (1989). Computer-aided blocking of factorial and response-surface designs. <em>Technometrics.</em> 31-3. 339-346.
</p>
<p>Goos, P. and Vandebroek, M. (2003). D-optimal split-plot designs with given numbers and sizes of whole plots. <em>Technometrics.</em> 45-3. 235-245.
</p>
<p>Nguyen, Nam-Ky. (2001). Cutting experimental designs into blocks. <em>AusNZJSt</em>. 43-3. 367-374.
</p>
<p>Trinca, L.A. and Gilmour, S.G. (2000). An algorithm for arranging response surface designs in small blocks. <em>Computational Statistics and Data Analysis</em>. 33. 25-43.
</p>
<p>Trinca, L.A. and Gilmour, S.G. (2001). Multistratum response surface designs. <em>Technometrics</em>. 43-1. 25-33.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Blocking the design for a quadratic polynomial in three variables into two 
# seven trial blocks:

dat&lt;-gen.factorial(3,3,varNames=c("A","B","C"))
desD&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE) # Choose an optimum 14 trail design.
optBlock(~quad(.),desD$design,c(7,7))

# Letting optBlock() search the dat candidate list instead of first choosing a 
# 14 trial design.
optBlock(~quad(.),dat,c(7,7))


# A block design for 7 treatments in 7 blocks of size 3. Note how withinData 
# is recycled to fill out the blocksize requirements.

BIB&lt;-optBlock(~.,withinData=factor(1:7),blocksizes=rep(3,7))

# This is a balanced incomplete block design as may be seen from:

crossprod(table(BIB$rows,c(rep(1:7, rep(3,7)))))

# A partially balanced incomplete block design with two associate classes:

tr&lt;-factor(1:9)
PBIB&lt;-optBlock(~.,withinData=tr,blocksizes=rep(3,9))

crossprod(table(PBIB$rows,c(rep(1:9, rep(3,9)))))


# Two fractions of a 2^(4-1).

dat&lt;-gen.factorial(2,4)
od&lt;-optBlock(~.,dat,c(8,8)) 

# The blocks are not themselves orthogonal even though the entire design is optimal.

bk&lt;-data.matrix(od$Blocks$B1)
t(bk)%*%bk 

# Better blocks may be obtained as follows, but note that they are not generally 
# the fractions that would be obtained by confounding the third order interaction.

od&lt;-optBlock(~.,dat,c(8,8),criterion="Dpc",nR=10)
bk&lt;-data.matrix(od$Blocks$B1)
t(bk)%*%bk

# Blocking with whole plot factors. Note that the 27 rows of within are recycled 
# to make the 54 trial blocked design. 

within&lt;-expand.grid(A=c(-1,0,1),B=c(-1,0,1),C=c(-1,0,1))
whole&lt;-expand.grid(D=factor(1:3),E=factor(1:3))
od&lt;-optBlock(~D+E*(quad(A,B,C)),withinData=within,blocksizes=rep(6,9),wholeBlockData=whole)

# Either withinData, or wholeBlockData may be an approximate theory optimial design 
# produced by optFederov() for nTrials. The first column in the optFederov() output 
# design, named "Rep..", is used to replicate the trials. 

within&lt;-optFederov(~quad(A,B,C),within,nT=54,approx=TRUE)
od&lt;-optBlock(~D+E*(quad(A,B,C)),withinData=within$design,blocksizes=rep(6,9),wholeBlockData=whole)

</code></pre>

<hr>
<h2 id='optFederov'>Optimal design</h2><span id='topic+optFederov'></span>

<h3>Description</h3>

<p>Calculates an exact or approximate algorithmic design for one of three criteria, using Federov's exchange algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optFederov(frml,data,nTrials,center=FALSE,approximate=FALSE,criterion="D",
	evaluateI=FALSE,space=NULL,augment=FALSE,rows,nullify=0,
	maxIteration=100,nRepeats=5,DFrac=1,CFrac=1,args=FALSE) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optFederov_+3A_frml">frml</code></td>
<td>
<p>This may be omitted if <code>data</code> is the fully model expanded candidate list.
If present it should be a formula starting with ~ which describes the model using
variable names from <code>data</code>. It may be ~. if all variables from <code>data</code> are to be used linearly.
In addition to the usual operators, quad(), cubic() and cubicS() may be used to 
expand variables from <code>data</code> into polynomial models.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_data">data</code></td>
<td>
<p>The candidate list. A matrix or data.frame describing the variables. If a matrix is input and 
the columns are not named, they will be assigned names X1,X2, etc. If a data.frame is input without 
column names, they will be named Var1, Var2, etc. Although data may be input as global variables used 
in frml, it is preferable to input it here.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_ntrials">nTrials</code></td>
<td>
<p>If approximate=FALSE, it is the number of trials in the final design and if missing, it will be 
taken as the greater of <code>length(rows)</code> or 5 plus the number of terms in the model. If approximate=TRUE,
nTrials will be used to round the optimal proportions so that the replications of the points add to nTrials.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_approximate">approximate</code></td>
<td>
<p>When FALSE, an exact design in nTrails will be calculated. When TRUE the proportions for
an approximate theory design will be calculated. If nTrials is set, any proportion less than 1/(2*maxIteration)
will be discarded before the proportions are efficiently rounded, otherwise all non-zero proportions will be 	 	 
shown: these are the support points.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_center">center</code></td>
<td>
<p>When TRUE, the numeric variables will be centered.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_criterion">criterion</code></td>
<td>
<p>&quot;D&quot;, &quot;A&quot;, or &quot;I&quot;</p>
</td></tr>
<tr><td><code id="optFederov_+3A_evaluatei">evaluateI</code></td>
<td>
<p>TRUE to evaluate and report I in addition to
other criteria. This parameter is included, because evaluating
I requires extra effort.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_space">space</code></td>
<td>
<p>If the criterion is &quot;I&quot; or evaluate I is true, the space over which the I criterion is to
be evaluated may be input. It should be a matrix with the same column types and names as in data. If
space is not input the evaluation will be done over the space described by data.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_augment">augment</code></td>
<td>
<p>If TRUE, the row numbers in <code>rows</code> will never be exchanged.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_rows">rows</code></td>
<td>
<p>Either a vector of row numbers (not row names) from <code>data</code> to be used as the
starting design or a vector of row numbers for the design to be augmented. Note, replicate
row numbers will be discarded and the length of rows cannot exceed the number of rows in data.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_nullify">nullify</code></td>
<td>
<p>When non-zero, the initial design is obtained by nullification. If <code>nullify=1</code>,
<code>nTrials</code> will be calculated (In this case nRepeats is set to 1). If <code>nullify=2</code>, 
number-of-terms trials will be calculated, and the remainder, up to <code>nTrials</code>, will be filled 
out at random.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_maxiteration">maxIteration</code></td>
<td>
<p>maximum number of times points are exchanged, within each repeat, in seeking an optimum design.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_nrepeats">nRepeats</code></td>
<td>
<p>Number of times the entire process is repeated. Has no effect when approximate=TRUE, 
or when nullify=1.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_dfrac">DFrac</code></td>
<td>
<p>Design fraction: the fraction of design used in search: 1 uses all of
them, 0 uses only the one with the smallest variance.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_cfrac">CFrac</code></td>
<td>
<p>Candidate fraction: the fraction of candidate set searched : 1 uses all of
them, 0 uses only the one with the largest variance.</p>
</td></tr>
<tr><td><code id="optFederov_+3A_args">args</code></td>
<td>
<p>If TRUE, the actual arguments to the function including the starting random number
seed will be output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E(y)=Zb</code>, where <code class="reqn">y</code> is a vector of n observations, <code class="reqn">Z</code> is an <code class="reqn">n\times k</code> matrix, and <code class="reqn">b</code> is a vector of k parameters. The &ldquo;exact&rdquo; design problem is to find a matrix <code class="reqn">Z</code>, with rows selected from a <code class="reqn">N \times k</code> matrix <code class="reqn">X</code>, that is &ldquo;best&rdquo; in some sense. The matrix <code class="reqn">X</code> can be a discretization of a continuous space or it can represent categories. In either case, the algorithmic design calculation is with respect to <code class="reqn">X</code>, and not to some larger space containing the points.
</p>
<p>Approximate designs weight the candidate points with a probability measure, which for practical purposes amounts to allowing unequal replication. 
</p>
<p>The Federov(1972) algorithm starts with <code class="reqn">n</code> points chosen from <code class="reqn">X</code>. They may be chosen randomly or by nullification, a procedure which iteratively adds points from the null space of <code class="reqn">X</code>, until a non-singular <code class="reqn">n</code> point design is found. The Federov algorithm exchanges points in the <code class="reqn">n</code> point design <code class="reqn">Z</code> with points in <code class="reqn">X-Z</code>, i.e. points not in <code class="reqn">Z</code>, in order to optimize a criterion, and quits when no profitable exchanges are possible, or the input parameter <code>maxIteration</code> is reached. The quality of the result depends on the starting design and the result may represent a local optimum. The procedure is repeated <code>nRepeats</code> times in order to come nearer to a global optimum. The parameters <code>DFrac</code> and <code>CFrac</code> control the portions of <code class="reqn">Z</code> and <code class="reqn">X-Z</code> that are used.
</p>
<p>The goal of algorithmic design is to maximize the information about the parameters. The information matrix is a matrix proportional to <code class="reqn">M=Z'Z/n</code>, and various functions of <code class="reqn">M</code> are chosen for optimization. The most popular of these is the <code>D</code> criterion, <code class="reqn">|M|^{1/k}</code>, which is thus a scaling of the &ldquo;generalized variance.&rdquo; Other criteria of interest involve the variance of predicted values, such as the <code>G</code> criterion, which is the minimax value of <code class="reqn">d(x)=x'(Mi)x</code>, over <code class="reqn">X</code>, where <code class="reqn">Mi</code> is the inverse of <code class="reqn">M</code>, and <code class="reqn">x'</code> is a row of <code class="reqn">X</code>; and the <code>I</code> criterion, which is the average value of <code class="reqn">d(x)</code> in the experimental region. These criteria are invariant under linear transformations of the parameter vector, which frees them from a dependency on units of scale. Other criteria are not invariant, such as the largest eigenvalue of <code class="reqn">M</code> or the <code>A</code> criterion, which is <code class="reqn">trace(Mi)/k</code>: it is of course proportional to the average variance of the parameter estimates. The criteria <code>D</code>, <code>A</code>, and <code>I</code> are supported by <code>optFederov()</code>, and <code>G</code>, which is intimately connected to <code>D</code>, is reported.
</p>
<p>The theoretical optimum value of <code>G</code> is known for approximate theory designs, and so <code class="reqn">G_e</code>, the <code>G</code> efficiency of <code>G</code> is available as a standard of design quality. It is especially useful, because <code class="reqn">G_e</code> provides a lower bound on <code class="reqn">D_e</code>, the <code>D</code> efficiency for approximate theory, to wit: </p>
<p style="text-align: center;"><code class="reqn">D_e\ge exp(1-1/G_e)</code>
</p>
<p>.
</p>
<p>A vignette giving further details is availble. To access it, type
</p>
<p>vignette(&quot;AlgDesign&quot;)
</p>


<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>The kth root of the generalized variance: <code class="reqn">det(M)^{1/k}</code>, where <code class="reqn">det(M)</code> is the
determinant of the normalized dispersion matrix <code class="reqn">M</code> &ndash;
i.e. <code class="reqn">M=Z'Z/n</code>, where <code class="reqn">Z=X[rows,]</code></p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>The average coefficient variance: <code class="reqn">trace(Mi)/k</code>, where <code class="reqn">Mi</code> is the inverse of <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>The average prediction variance over X, which can be shown to be <code class="reqn">trace((X'X*Mi)/N)</code>, where
N is the number of rows in X. This is calculated only when I is the criterion or when <code>evaluateI</code> is TRUE.</p>
</td></tr>
<tr><td><code>Ge</code></td>
<td>
<p>The minimax normalized variance over X, expressed as an efficiency with respect to the optimal approximate
theory design. It is defined as <code class="reqn">k/max(d)</code>, where <code class="reqn">max(d)</code> is the maximum normalized
variance over <code class="reqn">X</code> &ndash; i.e. the max of <code class="reqn">x'(Mi)x</code>, over all rows <code class="reqn">x'</code>
of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>Dea</code></td>
<td>
<p>A lower bound on <code>D</code> efficiency for approximate theory designs. It is equal to <code class="reqn">exp(1-1/Ge)</code>.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>The design.</p>
</td></tr> 
<tr><td><code>rows</code></td>
<td>
<p>A numerical vector of the design row numbers.</p>
</td></tr>
<tr><td><code>args</code></td>
<td>
<p>A list of the actual arguments used in this call.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Algorithmic design is often used with continuous and mixture variables for which R has minimal support, thus the functions quad(), cubic(), and cubicS() may be used in frml. The translation is done with <a href="#topic+expand.formula">expand.formula</a>.
</p>
<p>Mixture variables are variables such that the rows of <code>data</code> sum to a constant value, usually unity. Because of the mixture constraint, models containing mixture variables should not have a constant term. The linear and quadratic models for mixture variables A, B, and C are given by <code class="reqn">-1+(A+B+C)</code> and <code class="reqn">-1+(A+B+C)^2</code> respectively. See Gorman and Hinman [1962] for 
details.
</p>
<p>The function gen.mixture() generates a list of candidate points whose rows sum to unity.
</p>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). optFederov. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>


<h3>References</h3>

<p>Atkinson, A.C. and Donev, A.N. (1992). <em>Optimum experimental
designs</em>. Clarendon Press, Oxford.
</p>
<p>Gorman, J.W. and Hinman, J.E. (1962). Simplex lattice designs for 
multicomponent systems. <em>Technometrics</em>. 4-4. 463-487.
</p>
<p>Federov, V.V. (1972). <em>Theory of optimal experiments</em>. Academic
Press, N.Y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
# A quadratic polynomial in three variables. The resulting D will be about 0.46.
# This may be compared with a standard central composite design obtained from
# rows 1,3,5,7,9,11,13,15,17,19,21,23,25,27 of dat, which has a D value of 0.46.
# The central composite design seems to be the optimal design for all three criteria.

dat&lt;-gen.factorial(levels=3,nVars=3,varNames=c("A","B","C"))

desD&lt;-optFederov(~quad(A,B,C),dat,nTrials=14,eval=TRUE)
desA&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE,crit="A")
desI&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE,crit="I")

rows&lt;-c(1,3,5,7,9,11,13,15,17,19,21,23,25,27)
desO&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE,rows=rows)

# The I criterion may be seen to decrease as the space is expanded. 

levels&lt;-seq(-1,1,by=.1)
dat&lt;-expand.grid(list(A=levels,B=levels,C=levels))

desL&lt;-optFederov(~quad(.),dat,nTrials=14,eval=TRUE)

# This is not the case for A or D. For A and D, the support points are the points 
# of the grid with the three levels above. Points not on this grid move
# the criteria in a non-optimal direction; hence, the enlarging space has no effect.

# EXAMPLES 2
# Standard designs are usually optimal designs. If nTrials is set to that for
# a standard design, and if nRepeats is large enough, the standard design will 
# often be found For example, a half replicate of a 2^4 will be obtained by the 
# following. 

dat&lt;-gen.factorial(levels=2,nVars=3,varNames=c("A","B","C"))
desH&lt;-optFederov(~.,dat,8)

# A third replicate of a 3^3 will be obtained by the following:

dat&lt;-gen.factorial(levels=3,nVars=3,factor=1:3)
desT&lt;-optFederov(~.,dat,9)

# An orthogonal design similar to a 12 run Plackett-Burman design can be 
# created by the following. 

dat&lt;-gen.factorial(levels=2,nVars=11,varNames=c("A","B","C","D","E","F","G","H","J","K","L"))
desPB&lt;-optFederov(~.,dat,12,nRepeats=20)

# The above calculation is numerically difficult for the A and I criteria, 
# and nRepeats=100 or more may be needed. 

# It is instructive to examine a case in which the standard design is not found.
# The following is an attempt to create a Latin square design. It is not always successful.

lv&lt;-factor(1:5)
dat&lt;-expand.grid(A=lv,B=lv,C=lv)
desL&lt;-optFederov(~.,dat,nTrials=25,nRep=100)

# It may be summarized as follows.

cs&lt;-xtabs(~.,desL$design)
{xx&lt;-matrix(0,5,5); for (i in 1:5) xx=xx+cs[1:5,1:5,i]*i;xx}
 


# EXAMPLE 3
# Mixture variables have a constant sum, usually 1. This causes a linear dependency
# among terms of polynomial models. In particular the constant term is dependent.
# Squared terms in a quadratic model are confounded with interaction terms, so that
# a quadratic model for three mixture variables is ~0+(A+B+C)^2. The following
# calculation generates a set of candidate varibles using gen.mixture() with
# four values on each axis, and then creates a 15 run design. The design is optimal.
# Indeed, the candidate set produced by gen.mixture(2,5) is optimal. Note: 
# nullify=TRUE is used to ensure that this example will run withough error. The
# default value of 5 for nRepeats is sometimes not enought to find a starting
# design with a mixture problem.


dat&lt;-gen.mixture(4,5)
desM&lt;-optFederov(~(X1+X2+X3+X4+X5)^2-1,dat,15,nullify=TRUE)

# EXAMPLES 4
# Design augmenation can be obtained by setting augment=TRUE, and placing the row numbers
# of the design to be agmented in rows. Augmentation is often used to (1) add a new variable
# to an existing design or (2) to increase the complexity of the model. The following illustrates
# adding a variable to an existing design using desD above. It is assumed that all runs of the
# existing design have been made at the -1 level of the new variable:

dat&lt;-gen.factorial(levels=3,nVars=3,varNames=c("A","B","C"))
desA&lt;-optFederov(~quad(.),dat,nTrials=25,augment=TRUE,rows=desD$rows)

# The half fraction in desH, can be augmented to support an additional term:

dat&lt;-gen.factorial(levels=2,nVars=4,varNames=c("A","B","C","D"))
desH&lt;-optFederov(~.,dat,8)
desH2&lt;-optFederov(~A+B+C+D+I(A*B),dat,10,aug=TRUE,rows=desH$rows)

# EXAMPLES 5
# Optimal approximate theory designs have non-zero probabilities only on support points.
# For the first example above the approximate theory design is as follows. It shows
# that all points in the cubic lattice are support points. The D for this 
# design is 0.474 which may be compared with the D of 0.463 of the first example to
# indicate that that exact design had a D-efficiency of 97%. The lower bound Dea
# was 82%.

dat&lt;-gen.factorial(levels=3,nVars=3,varNames=c("A","B","C")) 
desDA&lt;-optFederov(~quad(A,B,C),dat,eval=TRUE,approx=TRUE)

# The largest proportions will be rounded if nTrials is specified.

desDAN&lt;-optFederov(~quad(A,B,C),dat,eval=TRUE,approx=TRUE,nTrials=15)
</code></pre>

<hr>
<h2 id='optMonteCarlo'>Optimal design via Monte Carlo</h2><span id='topic+optMonteCarlo'></span>

<h3>Description</h3>

<p>Finds a design using the specified criterion via Federov's algorithm
applied to a random subset of all possible candidate points. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optMonteCarlo(frml,data,nTrials,approximate=FALSE,criterion="D",evaluateI=FALSE,
	space=NULL,mixtureSum=1,constraints=NULL,RandomStart=TRUE,nRepeats=5,nCand,
	nCandNull,DFrac=1,CFrac=1,args=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optMonteCarlo_+3A_frml">frml</code></td>
<td>
<p>Required: A formula starting with ~ which will be used with 
model.matrix() to create a model matrix. If there are mixture variables,
the constant term is suppressed.</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_data">data</code></td>
<td>
<p>Required: A data frame with 7 or 8 columns. See details below
for specifics</p>
</td></tr> 
<tr><td><code id="optMonteCarlo_+3A_ntrials">nTrials</code></td>
<td>
<p>number trials in design &ndash; must be greater than the
number of terms in the model, if  missing will be set to the
number of model terms in the model  plus five.</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_approximate">approximate</code></td>
<td>
<p>When FALSE, an exact design in nTrails will be calculated. When TRUE the proportions for
an approximate theory design will be calculated. If nTrials is set, any proportion less than 1/(2*maxIteration)
will be discarded before the proportions are efficiently rounded, otherwise all non-zero proportions will be 
shown: these are the support points.</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_criterion">criterion</code></td>
<td>
<p>&quot;D&quot;, &quot;A&quot;, or &quot;I&quot;</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_evaluatei">evaluateI</code></td>
<td>
<p>TRUE if I is to be evaluated in addition to the
other criteria &ndash; slower because of calculations for I</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_space">space</code></td>
<td>
<p>If the criterion is &quot;I&quot; or evaluate I is true, the space over which the I criterion is to
be evaluated may be input. It should be a matrix with the same column types and names as in data. If
space is not input the evaluation will be done over the space described by data.</p>
</td></tr>	
<tr><td><code id="optMonteCarlo_+3A_constraints">constraints</code></td>
<td>
<p>A function taking a vector argument with length
equal to the number of variables, and returning TRUE if the vector is 
inside the constrained region</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_mixturesum">mixtureSum</code></td>
<td>
<p>The mixture variables, if any, will sum to this value.</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_randomstart">RandomStart</code></td>
<td>
<p>When TRUE, the starting design will be chosen
at random, otherwise nullification will be used. Note: the nullifcation
used here is different and much slower than that in optFederov().</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_nrepeats">nRepeats</code></td>
<td>
<p>number of times to retry the entire process</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_ncand">nCand</code></td>
<td>
<p>number of candidate points to generate, if missing,
it will be 10 times the number of terms</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_ncandnull">nCandNull</code></td>
<td>
<p>Number of candidate points to use for
nullification. If missing it will be set to nCand</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_dfrac">DFrac</code></td>
<td>
<p>Fraction of design used in search: 1 uses all of
them, 0 only the one with the smallest variance</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_cfrac">CFrac</code></td>
<td>
<p>Fraction of candidate set searched : 1 uses all of
them, 0 only the one with the largest variance</p>
</td></tr>
<tr><td><code id="optMonteCarlo_+3A_args">args</code></td>
<td>
<p>If TRUE, the actual arguments to the function including the starting 
random number seed will be output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns of the input data frame are as follows. The columns need
not be named. It is probably best to avoid naming the variables with
single letters, especially &quot;I&quot; &ndash; use paste(), as in the examples. For each variable
nLevels are randomly generated between low and high, inclusive, and then rounded
with round. For integer levels, round should be set to 0.
</p>

<dl>
<dt>var:</dt><dd><p>The names of the variables.</p>
</dd>
<dt>low:</dt><dd><p>The lower limit of the range for each variable. Ignored for mixtures.</p>
</dd> 
<dt>high:</dt><dd><p>The upper limit of the range for each variable. Ignored for mixtures.</p>
</dd> 
<dt>center:</dt><dd><p>The centering value for each variable. Ignored for mixtures.</p>
</dd>
<dt>nLevels:</dt><dd><p>The number of levels for each variable. Ignored for mixture variables.</p>
</dd>
<dt>round:</dt><dd><p>The number of decimal digits for the levels. The levels are randomly and 
uniformly chosen between low and high, and this parameter controls the number of 
trailing digits. The max value for mixture variables in this vector is used to 
round all mixture variables.</p>
</dd>
<dt>factor:</dt><dd><p>TRUE, FALSE depending on whether or not the variable is a factor. Note: other
columns will be reset to conform to a nLevels factor.</p>
</dd>
<dt>mix:</dt><dd><p>TRUE if the variable is a mixture variable. This column may
be omitted if there are no mixture variables.</p>
</dd>
</dl>

<p>Candidate lists required by <code>optFederov()</code> increase with the number of
variables, and can easily exceed storage capacity and can require
excessive amounts of time to process. To overcome this problem,
<code>optMonteCarlo()</code>, generates at random  <code>nCand</code>  points from a putative 
candidate list.
</p>
<p>For non-mixture variables, <code>optMonteCarlo()</code> samples from the putative
candidate list by choosing random levels inside the limits given by
<code>low</code> and <code>high</code> in <code>data</code>. These are rounded to the 
number of levels given by <code>nLevels</code> in <code>data</code> and to the 
number of decimal digits given by <code>round</code> in <code>data</code>.
</p>
<p>For mixture variables, <code>optMonteCarlo()</code> samples from the putative
candidate list by choosing random levels between 0 and 1, rounded to
the maximum in the <code>round</code> column of <code>data</code>, and such that the sum over 
all variables is equal to <code>mixtureSum</code>.
</p>
<p>If a constraint function is supplied in <code>Constraints</code>, it is
applied, and results which do not meet the constraint are
discarded. The constraint function should be written to process 
uncentered variables.
</p>
<p>The above procedures are repeated until <code>nCand</code> candidate points
are found.
</p>
<p>Nullification, successively adds points to a design until n points are 
found. This is the same procedure that is in <code>optFederov</code> except
that each new point is selected from a new sampling of the putative
candidate points. In general, this will produce better designs that
those from a random start.
</p>
<p>The entire process is repeated <code>nRepeats</code> times, and the best
result is reported. The methodology compares favorably with an
exhaustive search where the entire candidate list is searched by
<code>optFederov()</code>.
</p>
<p>The random numbers used in these calculations are controlled by the
usual R random number mechanism.
</p>
<p>A vignette giving further details is availble. To access it, type
</p>
<p>vignette(&quot;AlgDesign&quot;)
</p>


<h3>Value</h3>

<p>The output is the same list as from <code>optFederov</code>, but the criteria
values are relative to the randomly chosen subsets of the putative candidate 
space. In general, they should not differ greatly from those obtained by an 
exhaustive search.
</p>
<table>
<tr><td><code>D</code></td>
<td>
<p>The kth root of the generalized variance: <code class="reqn">det(M)^{1/k}</code>, where <code class="reqn">det(M)</code> is the
determinant of the normalized dispersion matrix <code class="reqn">M</code> &ndash;
i.e. <code class="reqn">M=Z'Z/n</code>, where <code class="reqn">Z=X[rows,]</code></p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>The average coefficient variance: <code class="reqn">trace(Mi)/k</code>, where <code class="reqn">Mi</code> is the inverse of <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>The average prediction variance over X, which can be shown to be <code class="reqn">trace((X'X*Mi)/N)</code>. 
This is calculated only when I is the criterion or when <code>evaluateI</code> is TRUE.</p>
</td></tr>
<tr><td><code>Ge</code></td>
<td>
<p>The minimax normalized variance over X, expressed as an efficiency with respect to the optimal approximate
theory design. It is defined as <code class="reqn">k/max(d)</code>, where <code class="reqn">max(d)</code> is the maximum normalized
variance over <code class="reqn">X</code> &ndash; i.e. the max of <code class="reqn">x'(Mi)x</code>, over all rows <code class="reqn">x'</code>
of <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>Dea</code></td>
<td>
<p>A lower bound on <code>D</code> efficiency for approximate theory designs. It is equal to <code class="reqn">exp(1-1/Ge)</code>.</p>
</td></tr>
<tr><td><code>Design</code></td>
<td>
<p>The design.</p>
</td></tr> 
<tr><td><code>args</code></td>
<td>
<p>A list of the actual arguments used in this call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Bob Wheeler <a href="mailto:bwheelerg@gmail.com">bwheelerg@gmail.com</a>
</p>
<p>Please cite this program as follows:
</p>
<p>Wheeler, R.E. (2004). optMonteCarlo. <em>AlgDesign</em>. The R project for statistical computing <a href="https://www.r-project.org/">https://www.r-project.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# EXAMPLE 1
# The data.frame in data might look like the following:
data&lt;-data.frame(var=paste("X",1:6,sep=""),low=c(1,1,1,0,0,0),
high=c(3,3,3,1,1,1),center=c(2,2,2,0,0,0),nLevels=3,
round=1,factor=0,mix=c(FALSE,FALSE,FALSE,TRUE,TRUE,TRUE))
data

# and the design:

optMonteCarlo(~(X1+X2+X3)^2+X4+X5+X6,data)

# Example 2
# Standard designs will often be produced, just as 
# they will with optFederov(). For example,
# a half fraction of a 2^4:
data&lt;-data.frame(paste("X",1:4,sep=""),-1,1,0,2,0,0)
data
optMonteCarlo(~.,data,nTrials=8)

# Example 3
# optMonteCarlo() can treat much larger problems than can 
# optFederov().  For example, optFederov()
# requires a candidate list of 3^20 points for
# a 20 variable, 3 level candidate list -- about
# 25 gigabytes. If the model is quadratic, this must
# be multiplied by about 12. There are other storage
# requirements internal to optFederov() which easily
# double this value. optMonteCarlo() since it only samples
# from the putative candidate list, has no difficulty 
# with a problem of this size. The criterion values
# appearing in the output of optMonteCarlo() are based on
# these samples, but their values seem to be reasonable
# correct, as the following shows: (These are commented
# out for those who have a slow machine.)

dat&lt;-gen.factorial(levels=3,nVar=8)
#desF&lt;-optFederov(~quad(.),dat,eval=TRUE)
#desF[1:5]

data&lt;-data.frame(paste("X",1:8,sep=""),-1,1,0,3,0,0)
#desH&lt;-optMonteCarlo(~quad(.),data,Rand=FALSE,eval=TRUE)
#desH[1:5]

# The following is a 20 variable quadratic. Uncomment
# and wait a while, even if you have a fast machine.
# Note: nRepeats has been changed from its default.
# Note: criterion values for exact designs are often
# far from approximate theory optima; hence, Ge and De
# will be small.

data&lt;-data.frame(paste("X",1:20,sep=""),-1,1,0,3,0,0)
#desBig&lt;-optMonteCarlo(~quad(.),data,nRepeats=1)

# The following will produce improved criterion values

#desNBig&lt;-optMonteCarlo(~quad(.),data,Rand=FALSE,nRepeats=1)

# EXAMPLE 4
# Practically infeasible combinations of variable are 
# common. Designs may be produced which avoid such
# combinations by using a constraint function. Suppose,
# for example that one corner of a cubic box is not
# feasible, then the following will produce a design
# that makes no use of this corner.

Constraints&lt;-function(x){!(x[1]&gt;0.75 &amp;&amp; x[2]&gt;0.75)}
data&lt;-data.frame(paste("X",1:4,sep=""),-1,1,0,3,0,0)
desC&lt;-optMonteCarlo(~.,data,con=Constraints)

# The above just removes a corner. Increasing the
# number of levels will remove points along the
# boundary.

data&lt;-data.frame(paste("X",1:4,sep=""),-1,1,0,11,3,0)
desC2&lt;-optMonteCarlo(~.,data,con=Constraints)

</code></pre>

<hr>
<h2 id='TGTable3'>Trinca Gilmour Table 3</h2><span id='topic+TGTable3'></span>

<h3>Description</h3>

<p>A blocked experimental design from Trinca and Gilmour (2001).
</p>
<p>A data.frame giving four three level variable in five blocks. There
are 45 trials in all.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(TGTable3)
</code></pre>


<h3>Source</h3>

<p>Trinca, L.A. and Gilmour, S.G. (2001). Multistratum response surface designs. 
<em>Technometrics</em>. 43-1. 25-33.
</p>

<hr>
<h2 id='TGTable5'>Trinca Gilmour Table 5</h2><span id='topic+TGTable5'></span>

<h3>Description</h3>

<p>A blocked experimental design from Trinca and Gilmour (2001).
</p>
<p>A matrix giving one whole plot and four within plot variables, 
in 21 blocks of 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	data(TGTable5)
</code></pre>


<h3>Source</h3>

<p>Trinca, L.A. and Gilmour, S.G. (2001). Multistratum response surface designs. 
<em>Technometrics</em>. 43-1. 25-33.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
