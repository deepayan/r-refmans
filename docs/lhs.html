<!DOCTYPE html><html><head><title>Help for package lhs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lhs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lhs-package'><p>lhs: Latin Hypercube Samples</p></a></li>
<li><a href='#augmentLHS'><p>Augment a Latin Hypercube Design</p></a></li>
<li><a href='#correlatedLHS'><p>Transformed Latin hypercube with a multivariate distribution</p></a></li>
<li><a href='#create_galois_field'><p>Create a Galois field</p></a></li>
<li><a href='#create_oalhs'><p>Create an orthogonal array Latin hypercube</p></a></li>
<li><a href='#createAddelKemp'><p>Create an orthogonal array using the Addelman-Kempthorne algorithm.</p></a></li>
<li><a href='#createAddelKemp3'><p>Create an orthogonal array using the Addelman-Kempthorne algorithm</p>
with <code>2q^3</code> rows.</a></li>
<li><a href='#createAddelKempN'><p>Create an orthogonal array using the Addelman-Kempthorne algorithm with</p>
alternate strength with <code>2q^n</code> rows.</a></li>
<li><a href='#createBose'><p>Create an orthogonal array using the Bose algorithm.</p></a></li>
<li><a href='#createBoseBush'><p>Create an orthogonal array using the Bose-Bush algorithm.</p></a></li>
<li><a href='#createBoseBushl'><p>Create an orthogonal array using the Bose-Bush algorithm with alternate strength &gt;= 3.</p></a></li>
<li><a href='#createBush'><p>Create an orthogonal array using the Bush algorithm.</p></a></li>
<li><a href='#createBusht'><p>Create an orthogonal array using the Bush algorithm with alternate strength.</p></a></li>
<li><a href='#geneticLHS'><p>Latin Hypercube Sampling with a Genetic Algorithm</p></a></li>
<li><a href='#get_library_versions'><p>Get version information for all libraries in the lhs package</p></a></li>
<li><a href='#improvedLHS'><p>Improved Latin Hypercube Sample</p></a></li>
<li><a href='#maximinLHS'><p>Maximin Latin Hypercube Sample</p></a></li>
<li><a href='#oa_to_oalhs'><p>Create a Latin hypercube from an orthogonal array</p></a></li>
<li><a href='#optAugmentLHS'><p>Optimal Augmented Latin Hypercube Sample</p></a></li>
<li><a href='#optimumLHS'><p>Optimum Latin Hypercube Sample</p></a></li>
<li><a href='#optSeededLHS'><p>Optimum Seeded Latin Hypercube Sample</p></a></li>
<li><a href='#poly_prod'><p>Multiplication in polynomial representation</p></a></li>
<li><a href='#poly_sum'><p>Addition in polynomial representation</p></a></li>
<li><a href='#poly2int'><p>Convert polynomial to integer in &lt;code&gt;0..q-1&lt;/code&gt;</p></a></li>
<li><a href='#qfactor'><p>Quantile Transformations</p></a></li>
<li><a href='#randomLHS'><p>Construct a random Latin hypercube design</p></a></li>
<li><a href='#runifint'><p>Create a Random Sample of Uniform Integers</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Latin Hypercube Samples</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a number of methods for creating and augmenting Latin Hypercube Samples and Orthogonal Array Latin Hypercube Samples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, DoE.base, knitr, rmarkdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bertcarnell/lhs">https://github.com/bertcarnell/lhs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bertcarnell/lhs/issues">https://github.com/bertcarnell/lhs/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-30 21:59:33 UTC; bertc</td>
</tr>
<tr>
<td>Author:</td>
<td>Rob Carnell [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rob Carnell &lt;bertcarnell@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-30 23:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lhs-package'>lhs: Latin Hypercube Samples</h2><span id='topic+lhs'></span><span id='topic+lhs-package'></span>

<h3>Description</h3>

<p>Provides a number of methods for creating and augmenting Latin Hypercube Samples and Orthogonal Array Latin Hypercube Samples.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Rob Carnell <a href="mailto:bertcarnell@gmail.com">bertcarnell@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bertcarnell/lhs">https://github.com/bertcarnell/lhs</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bertcarnell/lhs/issues">https://github.com/bertcarnell/lhs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='augmentLHS'>Augment a Latin Hypercube Design</h2><span id='topic+augmentLHS'></span>

<h3>Description</h3>

<p>Augments an existing Latin Hypercube Sample, adding points to the design, while
maintaining the <em>latin</em> properties of the design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augmentLHS(lhs, m = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augmentLHS_+3A_lhs">lhs</code></td>
<td>
<p>The Latin Hypercube Design to which points are to be added.
Contains an existing latin hypercube design with a number of rows equal
to the points in the design (simulations) and a number of columns equal
to the number of variables (parameters).  The values of each cell must be
between 0 and 1 and uniformly distributed</p>
</td></tr>
<tr><td><code id="augmentLHS_+3A_m">m</code></td>
<td>
<p>The number of additional points to add to matrix <code>lhs</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Augments an existing Latin Hypercube Sample, adding points to the design, while
maintaining the <em>latin</em> properties of the design.  Augmentation is perfomed
in a random manner.
</p>
<p>The algorithm used by this function has the following steps.
First, create a new matrix to hold the candidate points after the design has
been re-partitioned into <code class="reqn">(n+m)^{2}</code> cells, where n is number of
points in the original <code>lhs</code> matrix.  Then randomly sweep through each
column (1...<code>k</code>) in the repartitioned design to find the missing cells.
For each column (variable), randomly search for an empty row, generate a
random value that fits in that row, record the value in the new matrix.
The new matrix can contain more filled cells than <code>m</code> unles <code class="reqn">m = 2n</code>,
in which case the new matrix will contain exactly <code>m</code> filled cells.
Finally, keep only the first m rows of the new matrix.  It is guaranteed to
have <code>m</code> full rows in the new matrix.  The deleted rows are partially full.
The additional candidate points are selected randomly due to the random search
for empty cells.
</p>


<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> Latin Hypercube Sample matrix with values
uniformly distributed on [0,1]
</p>


<h3>Author(s)</h3>

<p>Rob Carnell
</p>


<h3>References</h3>

<p>Stein, M.  (1987) Large Sample Properties of Simulations Using Latin
Hypercube Sampling. <em>Technometrics</em>. <b>29</b>, 143&ndash;151.
</p>


<h3>See Also</h3>

<p>[randomLHS()], [geneticLHS()], [improvedLHS()], [maximinLHS()],
and [optimumLHS()] to generate Latin Hypercube Samples.  [optAugmentLHS()]
and [optSeededLHS()] to modify and augment existing designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
a &lt;- randomLHS(4,3)
b &lt;- augmentLHS(a, 2)
</code></pre>

<hr>
<h2 id='correlatedLHS'>Transformed Latin hypercube with a multivariate distribution</h2><span id='topic+correlatedLHS'></span>

<h3>Description</h3>

<p>A method to create a transformed Latin Hypercube sample where the marginal
distributions can be correlated according to an arbitrary set of criteria
contained in a minimized cost function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlatedLHS(
  lhs,
  marginal_transform_function,
  cost_function,
  debug = FALSE,
  maxiter = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlatedLHS_+3A_lhs">lhs</code></td>
<td>
<p>a Latin hypercube sample that is uniformly distributed on the
margins</p>
</td></tr>
<tr><td><code id="correlatedLHS_+3A_marginal_transform_function">marginal_transform_function</code></td>
<td>
<p>a function that takes Latin hypercube sample
as the first argument and other passed-through variables as desired.  <code>...</code> must
be passed as a argument.  For example, <code>f &lt;- function(W, second_argument, ...)</code>.
Must return a <code>matrix</code> or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="correlatedLHS_+3A_cost_function">cost_function</code></td>
<td>
<p>a function that takes a transformed Latin hypercube sample
as the first argument and other passed-through variables as desired.    <code>...</code> must
be passed as a argument.  For example, <code>f &lt;- function(W, second_argument, ...)</code></p>
</td></tr>
<tr><td><code id="correlatedLHS_+3A_debug">debug</code></td>
<td>
<p>Should debug messages be printed.  Causes cost function output
and iterations to be printed to aid in setting the maximum number of iterations</p>
</td></tr>
<tr><td><code id="correlatedLHS_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations.  The algorithm proceeds by
swapping one variable of two points at a time.  Each swap is an iteration.</p>
</td></tr>
<tr><td><code id="correlatedLHS_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed through to the <code>marginal_transform_function</code>
and <code>cost_function</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the Latin hypercube with uniform margins, the transformed
Latin hypercube, and the final cost
</p>


<h3>Examples</h3>

<pre><code class='language-R'>correlatedLHS(lhs::randomLHS(30, 2),
  marginal_transform_function = function(W, ...) {
    W[,1] &lt;- qnorm(W[,1], 1, 3)
    W[,2] &lt;- qexp(W[,2], 2)
    return(W)
  },
  cost_function = function(W, ...) {
    (cor(W[,1], W[,2]) - 0.5)^2
  },
  debug = FALSE,
  maxiter = 1000)
</code></pre>

<hr>
<h2 id='create_galois_field'>Create a Galois field</h2><span id='topic+create_galois_field'></span>

<h3>Description</h3>

<p>Create a Galois field
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_galois_field(q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_galois_field_+3A_q">q</code></td>
<td>
<p>The order of the Galois Field q = p^n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a GaloisField object containing
</p>

<dl>
<dt>n</dt><dd><p>q = p^n</p>
</dd>
<dt>p</dt><dd><p>The prime modulus of the field q=p^n</p>
</dd>
<dt>q</dt><dd><p>The order of the Galois Field q = p^n.  <code>q</code> must be a prime power.</p>
</dd>
<dt>xton</dt><dd><p>coefficients of the characteristic polynomial where the first coefficient is on $x^0$, the second is on $x^1$ and so on</p>
</dd>
<dt>inv</dt><dd><p>An index for which row of <code>poly</code> (zero based) is the multiplicative inverse of this row.  An <code>NA</code> indicates that this row of <code>poly</code> has no inverse.  e.g. c(3, 4) means that row 4=3+1 is the inverse of row 1 and row 5=4+1 is the inverse of row 2</p>
</dd>
<dt>neg</dt><dd><p>An index for which row of <code>poly</code> (zero based) is the negative or additive inverse of this row.  An <code>NA</code> indicates that this row of <code>poly</code> has no negative.  e.g. c(3, 4) means that row 4=3+1 is the negative of row 1 and row 5=4+1 is the negative of row 2</p>
</dd>
<dt>root</dt><dd><p>An index for which row of <code>poly</code> (zero based) is the square root of this row.  An <code>NA</code> indicates that this row of <code>poly</code> has no square root.  e.g. c(3, 4) means that row 4=3+1 is the square root of row 1 and row 5=4+1 is the square root of row 2</p>
</dd>
<dt>plus</dt><dd><p>sum table of the Galois Field</p>
</dd>
<dt>times</dt><dd><p>multiplication table of the Galois Field</p>
</dd>
<dt>poly</dt><dd><p>rows are polynomials of the Galois Field where the entries are the coefficients of the polynomial where the first coefficient is on $x^0$, the second is on $x^1$ and so on</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>gf &lt;- create_galois_field(4);
</code></pre>

<hr>
<h2 id='create_oalhs'>Create an orthogonal array Latin hypercube</h2><span id='topic+create_oalhs'></span>

<h3>Description</h3>

<p>Create an orthogonal array Latin hypercube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_oalhs(n, k, bChooseLargerDesign, bverbose)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_oalhs_+3A_n">n</code></td>
<td>
<p>the number of samples or rows in the LHS (integer)</p>
</td></tr>
<tr><td><code id="create_oalhs_+3A_k">k</code></td>
<td>
<p>the number of parameters or columns in the LHS (integer)</p>
</td></tr>
<tr><td><code id="create_oalhs_+3A_bchooselargerdesign">bChooseLargerDesign</code></td>
<td>
<p>should a larger oa design be chosen than the n and k requested?</p>
</td></tr>
<tr><td><code id="create_oalhs_+3A_bverbose">bverbose</code></td>
<td>
<p>should information be printed with execution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix which is an orthogonal array Latin hypercube sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(34)
A &lt;- create_oalhs(9, 4, TRUE, FALSE)
B &lt;- create_oalhs(9, 4, TRUE, FALSE)
</code></pre>

<hr>
<h2 id='createAddelKemp'>Create an orthogonal array using the Addelman-Kempthorne algorithm.</h2><span id='topic+createAddelKemp'></span>

<h3>Description</h3>

<p>The <code>addelkemp</code> program produces <code>OA( 2q^2, k, q, 2 )</code>,  <code>k &lt;= 2q+1</code>,
for odd prime powers <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAddelKemp(q, ncol, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createAddelKemp_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createAddelKemp_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createAddelKemp_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Owen, Art.  Orthogonal Arrays for: Computer Experiments, Visualizations, and
Integration in high dimensions. <a href="https://lib.stat.cmu.edu/designs/oa.c">https://lib.stat.cmu.edu/designs/oa.c</a>. 1994
S. Addelman and O. Kempthorne (1961) Annals of Mathematical Statistics, Vol 32 pp 1167-1176.
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBoseBush()],
[createBose()], [createAddelKemp3()],
[createAddelKempN()], [createBusht()], [createBoseBushl()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- createAddelKemp(3, 3, TRUE)
B &lt;- createAddelKemp(3, 5, FALSE)
</code></pre>

<hr>
<h2 id='createAddelKemp3'>Create an orthogonal array using the Addelman-Kempthorne algorithm
with <code>2q^3</code> rows.</h2><span id='topic+createAddelKemp3'></span>

<h3>Description</h3>

<p>The <code>addelkemp3</code> program produces
<code>OA( 2*q^3, k, q, 2 )</code>,  <code>k &lt;= 2q^2+2q+1</code>, for prime powers <code>q</code>.
<code>q</code> may be an odd prime power, or <code>q</code> may be 2 or 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAddelKemp3(q, ncol, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createAddelKemp3_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createAddelKemp3_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createAddelKemp3_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Owen, Art.  Orthogonal Arrays for: Computer Experiments, Visualizations, and
Integration in high dimensions. <a href="https://lib.stat.cmu.edu/designs/oa.c">https://lib.stat.cmu.edu/designs/oa.c</a>. 1994
S. Addelman and O. Kempthorne (1961) Annals of Mathematical Statistics, Vol 32 pp 1167-1176.
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBushBush()],
[createBose()], [createAddelKemp()],
[createAddelKempN()], [createBusht()], [createBoseBushl()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- createAddelKemp3(3, 3, TRUE)
B &lt;- createAddelKemp3(3, 5, FALSE)
</code></pre>

<hr>
<h2 id='createAddelKempN'>Create an orthogonal array using the Addelman-Kempthorne algorithm with
alternate strength with <code>2q^n</code> rows.</h2><span id='topic+createAddelKempN'></span>

<h3>Description</h3>

<p>The <code>addelkempn</code> program produces
<code>OA( 2*q^n, k, q, 2 )</code>,  <code>k &lt;= 2(q^n - 1)/(q-1)-1</code>, for prime powers <code>q</code>.
<code>q</code> may be an odd prime power, or <code>q</code> may be 2 or 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAddelKempN(q, ncol, exponent, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createAddelKempN_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createAddelKempN_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createAddelKempN_+3A_exponent">exponent</code></td>
<td>
<p>the exponent on q</p>
</td></tr>
<tr><td><code id="createAddelKempN_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBoseBush()],
[createBose()], [createBush()], [createAddelKemp()], [createAddelKemp3()],
[createBusht()], [createBoseBushl()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- createAddelKempN(3, 4, 3, TRUE)
B &lt;- createAddelKempN(3, 4, 4, TRUE)
</code></pre>

<hr>
<h2 id='createBose'>Create an orthogonal array using the Bose algorithm.</h2><span id='topic+createBose'></span>

<h3>Description</h3>

<p>The <code>bose</code> program
produces <code>OA( q^2, k, q, 2 )</code>,  <code>k &lt;= q+1</code> for prime powers <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBose(q, ncol, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBose_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createBose_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createBose_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Owen, Art.  Orthogonal Arrays for: Computer Experiments, Visualizations, and
Integration in high dimensions. <a href="https://lib.stat.cmu.edu/designs/oa.c">https://lib.stat.cmu.edu/designs/oa.c</a>. 1994
R.C. Bose (1938) Sankhya Vol 3 pp 323-338
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBush()],
[createBoseBush()], [createAddelKemp()], [createAddelKemp3()],
[createAddelKempN()], [createBusht()], [createBoseBushl()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- createBose(3, 3, FALSE)
B &lt;- createBose(5, 4, TRUE)
</code></pre>

<hr>
<h2 id='createBoseBush'>Create an orthogonal array using the Bose-Bush algorithm.</h2><span id='topic+createBoseBush'></span>

<h3>Description</h3>

<p>The <code>bosebush</code> program
produces <code>OA( 2q^2, k, q, 2 )</code>,  <code>k &lt;= 2q+1</code>, for powers of 2, <code>q=2^r</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBoseBush(q, ncol, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBoseBush_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createBoseBush_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createBoseBush_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Owen, Art.  Orthogonal Arrays for: Computer Experiments, Visualizations, and
Integration in high dimensions. <a href="https://lib.stat.cmu.edu/designs/oa.c">https://lib.stat.cmu.edu/designs/oa.c</a>. 1994
R.C. Bose and K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 508-524.
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBush()],
[createBose()], [createAddelKemp()], [createAddelKemp3()],
[createAddelKempN()], [createBusht()], [createBoseBushl()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- createBoseBush(4, 3, FALSE)
B &lt;- createBoseBush(8, 3, TRUE)
</code></pre>

<hr>
<h2 id='createBoseBushl'>Create an orthogonal array using the Bose-Bush algorithm with alternate strength &gt;= 3.</h2><span id='topic+createBoseBushl'></span>

<h3>Description</h3>

<p>The <code>bosebushl</code> program produces <code>OA( lambda*q^2, k, q, 2 )</code>,
<code>k &lt;= lambda*q+1</code>, for prime powers <code>q</code> and <code>lambda &gt; 1</code>.  Both <code>q</code> and
<code>lambda</code> must be powers of the same prime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBoseBushl(q, ncol, lambda, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBoseBushl_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createBoseBushl_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createBoseBushl_+3A_lambda">lambda</code></td>
<td>
<p>the lambda of the BoseBush algorithm</p>
</td></tr>
<tr><td><code id="createBoseBushl_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Owen, Art.  Orthogonal Arrays for: Computer Experiments, Visualizations, and
Integration in high dimensions. <a href="https://lib.stat.cmu.edu/designs/oa.c">https://lib.stat.cmu.edu/designs/oa.c</a>. 1994
R.C. Bose and K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 508-524.
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBoseBush()],
[createBose()], [createBush()], [createAddelKemp()], [createAddelKemp3()],
[createAddelKempN()], [createBusht()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- createBoseBushl(3, 3, 3, TRUE)
B &lt;- createBoseBushl(4, 4, 16, TRUE)
</code></pre>

<hr>
<h2 id='createBush'>Create an orthogonal array using the Bush algorithm.</h2><span id='topic+createBush'></span>

<h3>Description</h3>

<p>The <code>bush</code> program
produces <code>OA( q^3, k, q, 3 )</code>,  <code>k &lt;= q+1</code> for prime powers <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBush(q, ncol, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBush_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createBush_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createBush_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Owen, Art.  Orthogonal Arrays for: Computer Experiments, Visualizations, and
Integration in high dimensions. <a href="https://lib.stat.cmu.edu/designs/oa.c">https://lib.stat.cmu.edu/designs/oa.c</a>. 1994
K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 426-434
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBoseBush()],
[createBose()], [createAddelKemp()], [createAddelKemp3()],
[createAddelKempN()], [createBusht()], [createBoseBushl()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- createBush(3, 3, FALSE)
B &lt;- createBush(4, 5, TRUE)
</code></pre>

<hr>
<h2 id='createBusht'>Create an orthogonal array using the Bush algorithm with alternate strength.</h2><span id='topic+createBusht'></span>

<h3>Description</h3>

<p>The <code>busht</code> program produces <code>OA( q^t, k, q, t )</code>,  <code>k &lt;= q+1</code>, <code>t&gt;=3</code>,
for prime powers <code>q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBusht(q, ncol, strength, bRandom = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createBusht_+3A_q">q</code></td>
<td>
<p>the number of symbols in the array</p>
</td></tr>
<tr><td><code id="createBusht_+3A_ncol">ncol</code></td>
<td>
<p>number of parameters or columns</p>
</td></tr>
<tr><td><code id="createBusht_+3A_strength">strength</code></td>
<td>
<p>the strength of the array to be created</p>
</td></tr>
<tr><td><code id="createBusht_+3A_brandom">bRandom</code></td>
<td>
<p>should the array be randomized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From Owen: An orthogonal array <code>A</code> is a matrix of <code>n</code> rows, <code>k</code>
columns with every element being one of <code>q</code> symbols
<code>0,...,q-1</code>.  The array has strength <code>t</code> if, in every <code>n</code> by <code>t</code>
submatrix, the <code>q^t</code> possible distinct rows, all appear
the same number of times.  This number is the index
of the array, commonly denoted <code>lambda</code>.  Clearly,
<code>lambda*q^t=n</code>. The notation for such an array is <code>OA( n, k, q, t )</code>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Owen, Art.  Orthogonal Arrays for: Computer Experiments, Visualizations, and
Integration in high dimensions. <a href="https://lib.stat.cmu.edu/designs/oa.c">https://lib.stat.cmu.edu/designs/oa.c</a>. 1994
K.A. Bush (1952) Annals of Mathematical Statistics, Vol 23 pp 426-434
</p>


<h3>See Also</h3>

<p>Other methods to create orthogonal arrays [createBoseBush()],
[createBose()], [createAddelKemp()], [createAddelKemp3()],
[createAddelKempN()], [createBoseBushl()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
A &lt;- createBusht(3, 4, 2, TRUE)
B &lt;- createBusht(3, 4, 3, FALSE)
G &lt;- createBusht(3, 4, 3, TRUE)
</code></pre>

<hr>
<h2 id='geneticLHS'>Latin Hypercube Sampling with a Genetic Algorithm</h2><span id='topic+geneticLHS'></span>

<h3>Description</h3>

<p>Draws a Latin Hypercube Sample from a set of uniform distributions for use in
creating a Latin Hypercube Design.  This function attempts to optimize the
sample with respect to the S optimality criterion through a genetic type
algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneticLHS(
  n = 10,
  k = 2,
  pop = 100,
  gen = 4,
  pMut = 0.1,
  criterium = "S",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneticLHS_+3A_n">n</code></td>
<td>
<p>The number of partitions (simulations or design points or rows)</p>
</td></tr>
<tr><td><code id="geneticLHS_+3A_k">k</code></td>
<td>
<p>The number of replications (variables or columns)</p>
</td></tr>
<tr><td><code id="geneticLHS_+3A_pop">pop</code></td>
<td>
<p>The number of designs in the initial population</p>
</td></tr>
<tr><td><code id="geneticLHS_+3A_gen">gen</code></td>
<td>
<p>The number of generations over which the algorithm is applied</p>
</td></tr>
<tr><td><code id="geneticLHS_+3A_pmut">pMut</code></td>
<td>
<p>The probability with which a mutation occurs in a column of the progeny</p>
</td></tr>
<tr><td><code id="geneticLHS_+3A_criterium">criterium</code></td>
<td>
<p>The optimality criterium of the algorithm.  Default is <code>S</code>.  <code>Maximin</code> is also supported</p>
</td></tr>
<tr><td><code id="geneticLHS_+3A_verbose">verbose</code></td>
<td>
<p>Print informational messages.  Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Latin hypercube sampling (LHS) was developed to generate a distribution
of collections of parameter values from a multidimensional distribution.
A square grid containing possible sample points is a Latin square iff there
is only one sample in each row and each column. A Latin hypercube is the
generalisation of this concept to an arbitrary number of dimensions.  When
sampling a function of <code>k</code> variables, the range of each variable is divided
into <code>n</code> equally probable intervals. <code>n</code> sample points are then drawn such that a
Latin Hypercube is created.  Latin Hypercube sampling generates more efficient
estimates of desired parameters than simple Monte Carlo sampling.
</p>
<p>This program generates a Latin Hypercube Sample by creating random permutations
of the first <code>n</code> integers in each of <code>k</code> columns and then transforming those
integers into n sections of a standard uniform distribution.  Random values are
then sampled from within each of the n sections.  Once the sample is generated,
the uniform sample from a column can be transformed to any distribution by
using the quantile functions, e.g. qnorm().  Different columns can have
different distributions.
</p>
<p>S-optimality seeks to maximize the mean distance from each design point to all
the other points in the design, so the points are as spread out as possible.
</p>
<p>Genetic Algorithm:
</p>

<ol>
<li><p> Generate <code>pop</code> random latin hypercube designs of size <code>n</code> by <code>k</code>
</p>
</li>
<li><p> Calculate the S optimality measure of each design
</p>
</li>
<li><p> Keep the best design in the first position and throw away half of the rest of the population
</p>
</li>
<li><p> Take a random column out of the best matrix and place it in a random column of each of the other matricies, and take a random column out of each of the other matricies and put it in copies of the best matrix thereby causing the progeny
</p>
</li>
<li><p> For each of the progeny, cause a genetic mutation <code>pMut</code> percent of the time.  The mutation is accomplished by swtching two elements in a column
</p>
</li></ol>



<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> Latin Hypercube Sample matrix with values uniformly distributed on [0,1]
</p>


<h3>Author(s)</h3>

<p>Rob Carnell
</p>


<h3>References</h3>

<p>Stocki, R. (2005) A method to improve design reliability using optimal Latin hypercube sampling
<em>Computer Assisted Mechanics and Engineering Sciences</em> <b>12</b>, 87&ndash;105.
</p>
<p>Stein, M.  (1987) Large Sample Properties of Simulations Using Latin Hypercube Sampling.
<em>Technometrics</em>.  <b>29</b>, 143&ndash;151.
</p>


<h3>See Also</h3>

<p>[randomLHS()], [improvedLHS()], [maximinLHS()],
and [optimumLHS()] to generate Latin Hypercube Samples.  [optAugmentLHS()]
[optSeededLHS()], and [augtmentLHS()]  to modify and augment existing designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
A &lt;- geneticLHS(4, 3, 50, 5, .25)
</code></pre>

<hr>
<h2 id='get_library_versions'>Get version information for all libraries in the lhs package</h2><span id='topic+get_library_versions'></span>

<h3>Description</h3>

<p>Get version information for all libraries in the lhs package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_library_versions()
</code></pre>


<h3>Value</h3>

<p>a character string containing the versions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_library_versions()
</code></pre>

<hr>
<h2 id='improvedLHS'>Improved Latin Hypercube Sample</h2><span id='topic+improvedLHS'></span>

<h3>Description</h3>

<p>Draws a Latin Hypercube Sample from a set of uniform distributions for use in
creating a Latin Hypercube Design.  This function attempts to optimize the
sample with respect to an optimum euclidean distance between design points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improvedLHS(n, k, dup = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="improvedLHS_+3A_n">n</code></td>
<td>
<p>The number of partitions (simulations or design points or rows)</p>
</td></tr>
<tr><td><code id="improvedLHS_+3A_k">k</code></td>
<td>
<p>The number of replications (variables or columns)</p>
</td></tr>
<tr><td><code id="improvedLHS_+3A_dup">dup</code></td>
<td>
<p>A factor that determines the number of candidate points used in the
search. A multiple of the number of remaining points than can be added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Latin hypercube sampling (LHS) was developed to generate a distribution
of collections of parameter values from a multidimensional distribution.
A square grid containing possible sample points is a Latin square iff there
is only one sample in each row and each column. A Latin hypercube is the
generalisation of this concept to an arbitrary number of dimensions.  When
sampling a function of <code>k</code> variables, the range of each variable is divided
into <code>n</code> equally probable intervals. <code>n</code> sample points are then drawn such that a
Latin Hypercube is created.  Latin Hypercube sampling generates more efficient
estimates of desired parameters than simple Monte Carlo sampling.
</p>
<p>This program generates a Latin Hypercube Sample by creating random permutations
of the first <code>n</code> integers in each of <code>k</code> columns and then transforming those
integers into n sections of a standard uniform distribution.  Random values are
then sampled from within each of the n sections.  Once the sample is generated,
the uniform sample from a column can be transformed to any distribution byusing the quantile functions, e.g. qnorm().  Different columns can have
different distributions.
</p>
<p>This function attempts to optimize the sample with respect to an optimum
euclidean distance between design points.
</p>
<p style="text-align: center;"><code class="reqn">Optimum distance = frac{n}{n^{\frac{1.0}{k}}}</code>
</p>



<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> Latin Hypercube Sample matrix with values uniformly distributed on [0,1]
</p>


<h3>References</h3>

<p>Beachkofski, B., Grandhi, R.  (2002) Improved Distributed Hypercube Sampling
<em>American Institute of Aeronautics and Astronautics Paper</em> <b>1274</b>.
</p>
<p>This function is based on the MATLAB program written by John Burkardt and modified 16 Feb 2005
<a href="https://people.math.sc.edu/Burkardt/m_src/ihs/ihs.html">https://people.math.sc.edu/Burkardt/m_src/ihs/ihs.html</a>
</p>


<h3>See Also</h3>

<p>[randomLHS()], [geneticLHS()], [maximinLHS()], and [optimumLHS()]
to generate Latin Hypercube Samples.  [optAugmentLHS()], [optSeededLHS()], and
[augmentLHS()] to modify and augment existing designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
A &lt;- improvedLHS(4, 3, 2)
</code></pre>

<hr>
<h2 id='maximinLHS'>Maximin Latin Hypercube Sample</h2><span id='topic+maximinLHS'></span>

<h3>Description</h3>

<p>Draws a Latin Hypercube Sample from a set of uniform distributions for use in
creating a Latin Hypercube Design.  This function attempts to optimize the
sample by maximizing the minium distance between design points (maximin criteria).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximinLHS(
  n,
  k,
  method = "build",
  dup = 1,
  eps = 0.05,
  maxIter = 100,
  optimize.on = "grid",
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximinLHS_+3A_n">n</code></td>
<td>
<p>The number of partitions (simulations or design points or rows)</p>
</td></tr>
<tr><td><code id="maximinLHS_+3A_k">k</code></td>
<td>
<p>The number of replications (variables or columns)</p>
</td></tr>
<tr><td><code id="maximinLHS_+3A_method">method</code></td>
<td>
<p><code>build</code> or <code>iterative</code> is the method of LHS creation.
<code>build</code> finds the next best point while constructing the LHS.
<code>iterative</code> optimizes the resulting sample on [0,1] or sample grid on [1,N]</p>
</td></tr>
<tr><td><code id="maximinLHS_+3A_dup">dup</code></td>
<td>
<p>A factor that determines the number of candidate points used in the
search. A multiple of the number of remaining points than can be
added.  This is used when <code>method="build"</code></p>
</td></tr>
<tr><td><code id="maximinLHS_+3A_eps">eps</code></td>
<td>
<p>The minimum percent change in the minimum distance used in the
<code>iterative</code> method</p>
</td></tr>
<tr><td><code id="maximinLHS_+3A_maxiter">maxIter</code></td>
<td>
<p>The maximum number of iterations to use in the <code>iterative</code> method</p>
</td></tr>
<tr><td><code id="maximinLHS_+3A_optimize.on">optimize.on</code></td>
<td>
<p><code>grid</code> or <code>result</code> gives the basis of the optimization.
<code>grid</code> optimizes the LHS on the underlying integer grid.
<code>result</code> optimizes the resulting sample on [0,1]</p>
</td></tr>
<tr><td><code id="maximinLHS_+3A_debug">debug</code></td>
<td>
<p>prints additional information about the process of the optimization</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Latin hypercube sampling (LHS) was developed to generate a distribution
of collections of parameter values from a multidimensional distribution.
A square grid containing possible sample points is a Latin square iff there
is only one sample in each row and each column. A Latin hypercube is the
generalisation of this concept to an arbitrary number of dimensions.  When
sampling a function of <code>k</code> variables, the range of each variable is divided
into <code>n</code> equally probable intervals. <code>n</code> sample points are then drawn such that a
Latin Hypercube is created.  Latin Hypercube sampling generates more efficient
estimates of desired parameters than simple Monte Carlo sampling.
</p>
<p>This program generates a Latin Hypercube Sample by creating random permutations
of the first <code>n</code> integers in each of <code>k</code> columns and then transforming those
integers into n sections of a standard uniform distribution.  Random values are
then sampled from within each of the n sections.  Once the sample is generated,
the uniform sample from a column can be transformed to any distribution by
using the quantile functions, e.g. qnorm().  Different columns can have
different distributions.
</p>
<p>Here, values are added to the design one by one such that the maximin criteria is
satisfied.
</p>


<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> Latin Hypercube Sample matrix with values uniformly distributed on [0,1]
</p>


<h3>References</h3>

<p>Stein, M.  (1987) Large Sample Properties of Simulations Using Latin Hypercube Sampling.
<em>Technometrics</em>.  <b>29</b>, 143&ndash;151.
</p>
<p>This function is motivated by the MATLAB program written by John Burkardt and modified 16 Feb 2005
<a href="https://people.math.sc.edu/Burkardt/m_src/ihs/ihs.html">https://people.math.sc.edu/Burkardt/m_src/ihs/ihs.html</a>
</p>


<h3>See Also</h3>

<p>[randomLHS()], [geneticLHS()], [improvedLHS()] and [optimumLHS()]
to generate Latin Hypercube Samples.  [optAugmentLHS()], [optSeededLHS()], and
[augmentLHS()] to modify and augment existing designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
A1 &lt;- maximinLHS(4, 3, dup=2)
A2 &lt;- maximinLHS(4, 3, method="build", dup=2)
A3 &lt;- maximinLHS(4, 3, method="iterative", eps=0.05, maxIter=100, optimize.on="grid")
A4 &lt;- maximinLHS(4, 3, method="iterative", eps=0.05, maxIter=100, optimize.on="result")
</code></pre>

<hr>
<h2 id='oa_to_oalhs'>Create a Latin hypercube from an orthogonal array</h2><span id='topic+oa_to_oalhs'></span>

<h3>Description</h3>

<p>Create a Latin hypercube from an orthogonal array
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oa_to_oalhs(n, k, oa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oa_to_oalhs_+3A_n">n</code></td>
<td>
<p>the number of samples or rows in the LHS (integer)</p>
</td></tr>
<tr><td><code id="oa_to_oalhs_+3A_k">k</code></td>
<td>
<p>the number of parameters or columns in the LHS (integer)</p>
</td></tr>
<tr><td><code id="oa_to_oalhs_+3A_oa">oa</code></td>
<td>
<p>the orthogonal array to be used as the basis for the LHS (matrix of integers) or data.frame of factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix which is a Latin hypercube sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oa &lt;- createBose(3, 4, TRUE)
B &lt;- oa_to_oalhs(9, 4, oa)
</code></pre>

<hr>
<h2 id='optAugmentLHS'>Optimal Augmented Latin Hypercube Sample</h2><span id='topic+optAugmentLHS'></span>

<h3>Description</h3>

<p>Augments an existing Latin Hypercube Sample, adding points to the design, while
maintaining the <em>latin</em> properties of the design.  This function attempts to
add the points to the design in an optimal way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optAugmentLHS(lhs, m = 1, mult = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optAugmentLHS_+3A_lhs">lhs</code></td>
<td>
<p>The Latin Hypercube Design to which points are to be added</p>
</td></tr>
<tr><td><code id="optAugmentLHS_+3A_m">m</code></td>
<td>
<p>The number of additional points to add to matrix <code>lhs</code></p>
</td></tr>
<tr><td><code id="optAugmentLHS_+3A_mult">mult</code></td>
<td>
<p><code>m*mult</code> random candidate points will be created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Augments an existing Latin Hypercube Sample, adding points to the design, while
maintaining the <em>latin</em> properties of the design.  This function attempts to
add the points to the design in a way that maximizes S optimality.
</p>
<p>S-optimality seeks to maximize the mean distance from each design point to all
the other points in the design, so the points are as spread out as possible.
</p>


<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> Latin Hypercube Sample matrix with values uniformly distributed on [0,1]
</p>


<h3>References</h3>

<p>Stein, M.  (1987) Large Sample Properties of Simulations Using Latin Hypercube Sampling.
<em>Technometrics</em>. <b>29</b>, 143&ndash;151.
</p>


<h3>See Also</h3>

<p>[randomLHS()], [geneticLHS()], [improvedLHS()], [maximinLHS()], and
[optimumLHS()] to generate Latin Hypercube Samples.  [optSeededLHS()] and
[augmentLHS()] to modify and augment existing designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)
a &lt;- randomLHS(4,3)
b &lt;- optAugmentLHS(a, 2, 3)
</code></pre>

<hr>
<h2 id='optimumLHS'>Optimum Latin Hypercube Sample</h2><span id='topic+optimumLHS'></span>

<h3>Description</h3>

<p>Draws a Latin Hypercube Sample from a set of uniform distributions for use in
creating a Latin Hypercube Design.  This function uses the Columnwise
Pairwise (<abbr><span class="acronym">CP</span></abbr>) algorithm to generate an optimal design with respect to the S
optimality criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimumLHS(n = 10, k = 2, maxSweeps = 2, eps = 0.1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimumLHS_+3A_n">n</code></td>
<td>
<p>The number of partitions (simulations or design points or rows)</p>
</td></tr>
<tr><td><code id="optimumLHS_+3A_k">k</code></td>
<td>
<p>The number of replications (variables or columns)</p>
</td></tr>
<tr><td><code id="optimumLHS_+3A_maxsweeps">maxSweeps</code></td>
<td>
<p>The maximum number of times the CP algorithm is applied to all the columns.</p>
</td></tr>
<tr><td><code id="optimumLHS_+3A_eps">eps</code></td>
<td>
<p>The optimal stopping criterion.  Algorithm stops when the change in
optimality measure is less than eps*100% of the previous value.</p>
</td></tr>
<tr><td><code id="optimumLHS_+3A_verbose">verbose</code></td>
<td>
<p>Print informational messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Latin hypercube sampling (LHS) was developed to generate a distribution
of collections of parameter values from a multidimensional distribution.
A square grid containing possible sample points is a Latin square iff there
is only one sample in each row and each column. A Latin hypercube is the
generalisation of this concept to an arbitrary number of dimensions.  When
sampling a function of <code>k</code> variables, the range of each variable is divided
into <code>n</code> equally probable intervals. <code>n</code> sample points are then drawn such that a
Latin Hypercube is created.  Latin Hypercube sampling generates more efficient
estimates of desired parameters than simple Monte Carlo sampling.
</p>
<p>This program generates a Latin Hypercube Sample by creating random permutations
of the first <code>n</code> integers in each of <code>k</code> columns and then transforming those
integers into n sections of a standard uniform distribution.  Random values are
then sampled from within each of the n sections.  Once the sample is generated,
the uniform sample from a column can be transformed to any distribution by
using the quantile functions, e.g. qnorm().  Different columns can have
different distributions.
</p>
<p>S-optimality seeks to maximize the mean distance from each design point to all
the other points in the design, so the points are as spread out as possible.
</p>
<p>This function uses the <abbr><span class="acronym">CP</span></abbr> algorithm to generate an optimal
design with respect to the S optimality criterion.
</p>


<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> Latin Hypercube Sample matrix with values uniformly distributed on [0,1]
</p>


<h3>References</h3>

<p>Stocki, R. (2005) A method to improve design reliability using optimal Latin hypercube sampling
<em>Computer Assisted Mechanics and Engineering Sciences</em> <b>12</b>, 87&ndash;105.
</p>


<h3>See Also</h3>

<p>[randomLHS()], [geneticLHS()], [improvedLHS()] and [maximinLHS()]
to generate Latin Hypercube Samples.  [optAugmentLHS()], [optSeededLHS()], and
[augmentLHS()] to modify and augment existing designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- optimumLHS(4, 3, 5, .05)
</code></pre>

<hr>
<h2 id='optSeededLHS'>Optimum Seeded Latin Hypercube Sample</h2><span id='topic+optSeededLHS'></span>

<h3>Description</h3>

<p>Augments an existing Latin Hypercube Sample, adding points to the design, while
maintaining the <em>latin</em> properties of the design.  This function then uses the
columnwise pairwise (<abbr><span class="acronym">CP</span></abbr>) algoritm to optimize the design.  The original design is not necessarily maintained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optSeededLHS(seed, m = 0, maxSweeps = 2, eps = 0.1, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optSeededLHS_+3A_seed">seed</code></td>
<td>
<p>The number of partitions (simulations or design points)</p>
</td></tr>
<tr><td><code id="optSeededLHS_+3A_m">m</code></td>
<td>
<p>The number of additional points to add to the seed matrix <code>seed</code>.  default value is zero.  If m is zero then the seed design is optimized.</p>
</td></tr>
<tr><td><code id="optSeededLHS_+3A_maxsweeps">maxSweeps</code></td>
<td>
<p>The maximum number of times the CP algorithm is applied to all the columns.</p>
</td></tr>
<tr><td><code id="optSeededLHS_+3A_eps">eps</code></td>
<td>
<p>The optimal stopping criterion</p>
</td></tr>
<tr><td><code id="optSeededLHS_+3A_verbose">verbose</code></td>
<td>
<p>Print informational messages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Augments an existing Latin Hypercube Sample, adding points to the design, while
maintaining the <em>latin</em> properties of the design.  This function then uses the
<abbr><span class="acronym">CP</span></abbr> algoritm to optimize the design.  The original design
is not necessarily maintained.
</p>


<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> Latin Hypercube Sample matrix with values uniformly distributed on [0,1]
</p>


<h3>References</h3>

<p>Stein, M.  (1987) Large Sample Properties of Simulations Using Latin Hypercube Sampling.
<em>Technometrics</em>. <b>29</b>, 143&ndash;151.
</p>


<h3>See Also</h3>

<p>[randomLHS()], [geneticLHS()], [improvedLHS()], [maximinLHS()], and
[optimumLHS()] to generate Latin Hypercube Samples.  [optAugmentLHS()] and
[augmentLHS()] to modify and augment existing designs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1234)
  a &lt;- randomLHS(4,3)
  b &lt;- optSeededLHS(a, 2, 2, .1)
</code></pre>

<hr>
<h2 id='poly_prod'>Multiplication in polynomial representation</h2><span id='topic+poly_prod'></span>

<h3>Description</h3>

<p>Multiplication in polynomial representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_prod(p, n, xton, p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_prod_+3A_p">p</code></td>
<td>
<p>modulus</p>
</td></tr>
<tr><td><code id="poly_prod_+3A_n">n</code></td>
<td>
<p>length of polynomials</p>
</td></tr>
<tr><td><code id="poly_prod_+3A_xton">xton</code></td>
<td>
<p>characteristic polynomial vector for the field (x to the n power)</p>
</td></tr>
<tr><td><code id="poly_prod_+3A_p1">p1</code></td>
<td>
<p>polynomial vector 1</p>
</td></tr>
<tr><td><code id="poly_prod_+3A_p2">p2</code></td>
<td>
<p>polynomial vector 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the product of p1 and p2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gf &lt;- create_galois_field(4)
a &lt;- poly_prod(gf$p, gf$n, gf$xton, c(1, 0), c(0, 1))
stopifnot(all(a == c(0, 1)))
</code></pre>

<hr>
<h2 id='poly_sum'>Addition in polynomial representation</h2><span id='topic+poly_sum'></span>

<h3>Description</h3>

<p>Addition in polynomial representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_sum(p, n, p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_sum_+3A_p">p</code></td>
<td>
<p>modulus</p>
</td></tr>
<tr><td><code id="poly_sum_+3A_n">n</code></td>
<td>
<p>length of polynomial 1 and 2</p>
</td></tr>
<tr><td><code id="poly_sum_+3A_p1">p1</code></td>
<td>
<p>polynomial vector 1</p>
</td></tr>
<tr><td><code id="poly_sum_+3A_p2">p2</code></td>
<td>
<p>polynomial vector 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sum of p1 and p2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gf &lt;- create_galois_field(4)
a &lt;- poly_sum(gf$p, gf$n, c(1, 0), c(0, 1))
stopifnot(all(a == c(1, 1)))
</code></pre>

<hr>
<h2 id='poly2int'>Convert polynomial to integer in &lt;code&gt;0..q-1&lt;/code&gt;</h2><span id='topic+poly2int'></span>

<h3>Description</h3>

<p>Convert polynomial to integer in &lt;code&gt;0..q-1&lt;/code&gt;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly2int(p, n, poly)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly2int_+3A_p">p</code></td>
<td>
<p>modulus</p>
</td></tr>
<tr><td><code id="poly2int_+3A_n">n</code></td>
<td>
<p>the length of poly</p>
</td></tr>
<tr><td><code id="poly2int_+3A_poly">poly</code></td>
<td>
<p>the polynomial vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gf &lt;- create_galois_field(4)
stopifnot(poly2int(gf$p, gf$n, c(0, 0)) == 0)
</code></pre>

<hr>
<h2 id='qfactor'>Quantile Transformations</h2><span id='topic+qfactor'></span><span id='topic+qinteger'></span><span id='topic+qdirichlet'></span>

<h3>Description</h3>

<p>A collection of functions that transform the margins of a Latin hypercube
sample in multiple ways
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfactor(p, fact)

qinteger(p, a, b)

qdirichlet(X, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfactor_+3A_p">p</code></td>
<td>
<p>a vector of LHS samples on (0,1)</p>
</td></tr>
<tr><td><code id="qfactor_+3A_fact">fact</code></td>
<td>
<p>a factor or categorical variable.  Ordered and un-ordered variables are allowed.</p>
</td></tr>
<tr><td><code id="qfactor_+3A_a">a</code></td>
<td>
<p>a minimum integer</p>
</td></tr>
<tr><td><code id="qfactor_+3A_b">b</code></td>
<td>
<p>a maximum integer</p>
</td></tr>
<tr><td><code id="qfactor_+3A_x">X</code></td>
<td>
<p>multiple columns of an LHS sample on (0,1)</p>
</td></tr>
<tr><td><code id="qfactor_+3A_alpha">alpha</code></td>
<td>
<p>Dirichlet distribution parameters.  All <code>alpha &gt;= 1</code> The marginal
mean probability of the Dirichlet distribution is given by <code>alpha[i] / sum(alpha)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qdirichlet</code> is not an exact quantile function since the quantile of a
multivariate distribution is not unique.  <code>qdirichlet</code> is also not the
independent quantiles of the marginal distributions since
those quantiles do not sum to one.  <code>qdirichlet</code> is the quantile of the
underlying gamma functions, normalized.  This is the same procedure that
is used to generate random deviates from the Dirichlet distribution therefore
it will produce transformed Latin hypercube samples with the intended distribution.
</p>
<p><code>q_factor</code> divides the [0,1] interval into <code>nlevel(fact)</code> equal sections
and assigns values in those sections to the factor level.
</p>


<h3>Value</h3>

<p>the transformed column or columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- randomLHS(20, 7)
Y &lt;- as.data.frame(X)
Y[,1] &lt;- qnorm(X[,1], 2, 0.5)
Y[,2] &lt;- qfactor(X[,2], factor(LETTERS[c(1,3,5,7,8)]))
Y[,3] &lt;- qinteger(X[,3], 5, 17)
Y[,4:6] &lt;- qdirichlet(X[,4:6], c(2,3,4))
Y[,7] &lt;- qfactor(X[,7], ordered(LETTERS[c(1,3,5,7,8)]))
</code></pre>

<hr>
<h2 id='randomLHS'>Construct a random Latin hypercube design</h2><span id='topic+randomLHS'></span>

<h3>Description</h3>

<p><code>randomLHS(4,3)</code> returns a 4x3 matrix with each column
constructed as follows: A random permutation of (1,2,3,4) is
generated, say (3,1,2,4) for each of K columns.  Then a uniform
random number is picked from each indicated quartile.  In this
example a random number between .5 and .75 is chosen, then one between
0 and .25, then one between .25 and .5, finally one between
.75 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomLHS(n, k, preserveDraw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomLHS_+3A_n">n</code></td>
<td>
<p>the number of rows or samples</p>
</td></tr>
<tr><td><code id="randomLHS_+3A_k">k</code></td>
<td>
<p>the number of columns or parameters/variables</p>
</td></tr>
<tr><td><code id="randomLHS_+3A_preservedraw">preserveDraw</code></td>
<td>
<p>should the draw be constructed so that it is the same for variable numbers of columns?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a Latin hypercube sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- randomLHS(5, 3)
</code></pre>

<hr>
<h2 id='runifint'>Create a Random Sample of Uniform Integers</h2><span id='topic+runifint'></span>

<h3>Description</h3>

<p>Create a Random Sample of Uniform Integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runifint(n = 1, min_int = 0, max_int = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runifint_+3A_n">n</code></td>
<td>
<p>The number of samples</p>
</td></tr>
<tr><td><code id="runifint_+3A_min_int">min_int</code></td>
<td>
<p>the minimum integer <code>x &gt;= min_int</code></p>
</td></tr>
<tr><td><code id="runifint_+3A_max_int">max_int</code></td>
<td>
<p>the maximum integer <code>x &lt;= max_int</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the sample sample of size <code>n</code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
