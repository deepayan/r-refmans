<!DOCTYPE html><html lang="en"><head><title>Help for package fastplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fastplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fastplyr-package'><p>fastplyr: Fast Alternatives to 'tidyverse' Functions</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_group_id'><p>Add a column of useful IDs (group IDs, row IDs &amp; consecutive IDs)</p></a></li>
<li><a href='#desc'><p>Helpers to sort variables in ascending or descending order</p></a></li>
<li><a href='#f_arrange'><p>A <code>collapse</code> version of <code>dplyr::arrange()</code></p></a></li>
<li><a href='#f_bind_rows'><p>Bind data frame rows and columns</p></a></li>
<li><a href='#f_count'><p>A fast replacement to dplyr::count()</p></a></li>
<li><a href='#f_distinct'><p>Find distinct rows</p></a></li>
<li><a href='#f_duplicates'><p>Find duplicate rows</p></a></li>
<li><a href='#f_expand'><p>Fast versions of <code>tidyr::expand()</code> and <code>tidyr::complete()</code>.</p></a></li>
<li><a href='#f_fill'><p>Fill <code>NA</code> values forwards and backwards</p></a></li>
<li><a href='#f_filter'><p>Alternative to <code>dplyr::filter()</code></p></a></li>
<li><a href='#f_group_by'><p>'collapse' version of <code>dplyr::group_by()</code></p></a></li>
<li><a href='#f_left_join'><p>Fast SQL joins</p></a></li>
<li><a href='#f_nest_by'><p>Create a subset of data for each group</p></a></li>
<li><a href='#f_rowwise'><p>A convenience function to group by every row</p></a></li>
<li><a href='#f_select'><p>Fast 'dplyr' <code>select()</code>/<code>rename()</code>/<code>pull()</code></p></a></li>
<li><a href='#f_slice'><p>Faster <code>dplyr::slice()</code></p></a></li>
<li><a href='#f_summarise'><p>Summarise each group down to one row</p></a></li>
<li><a href='#group_by_order_default'><p>Default value for ordering of groups</p></a></li>
<li><a href='#group_id'><p>Fast group and row IDs</p></a></li>
<li><a href='#list_tidy'><p>Alternative to <code>rlang::list2</code></p></a></li>
<li><a href='#new_tbl'><p>Fast 'tibble' alternatives</p></a></li>
<li><a href='#remove_rows_if_any_na'><p>Fast remove rows with <code>NA</code> values</p></a></li>
<li><a href='#tidy_quantiles'><p>Fast grouped sample quantiles</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fast Alternatives to 'tidyverse' Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.5.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A full set of fast data manipulation tools with a tidy
    front-end and a fast back-end using 'collapse' and 'cheapr'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NicChr/fastplyr/issues">https://github.com/NicChr/fastplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cheapr (&ge; 0.9.91), collapse (&ge; 2.0.0), dplyr (&ge; 1.1.0),
lifecycle, magrittr, rlang, stringr, tidyselect, vctrs (&ge;
0.6.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nycflights13, testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-21 09:57:56 UTC; Nmc5</td>
</tr>
<tr>
<td>Author:</td>
<td>Nick Christofides <a href="https://orcid.org/0000-0002-9743-7342"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nick Christofides &lt;nick.christofides.r@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-21 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fastplyr-package'>fastplyr: Fast Alternatives to 'tidyverse' Functions</h2><span id='topic+fastplyr'></span><span id='topic+fastplyr-package'></span>

<h3>Description</h3>

<p>fastplyr is a tidy front-end using a faster and more efficient back-end based
on two packages, collapse and cheapr.
</p>
<p>fastplyr includes dplyr and tidyr alternatives that behave like their
tidyverse equivalents but are more efficient.
</p>
<p>Similar in spirit to the excellent tidytable package, fastplyr
also offers a tidy front-end that is fast and easy to use. Unlike tidytable,
fastplyr verbs are interchangeable with dplyr verbs.
</p>
<p>You can learn more about the tidyverse, collapse and cheapr
using the links below.
</p>
<p><a href="https://www.tidyverse.org/learn/">tidyverse</a>
</p>
<p><a href="https://sebkrantz.github.io/collapse/articles/collapse_intro.html">collapse</a>
</p>
<p><a href="https://github.com/NicChr/cheapr">cheapr</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nick Christofides <a href="mailto:nick.christofides.r@gmail.com">nick.christofides.r@gmail.com</a> (<a href="https://orcid.org/0000-0002-9743-7342">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/NicChr/fastplyr/issues">https://github.com/NicChr/fastplyr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_group_id'>Add a column of useful IDs (group IDs, row IDs &amp; consecutive IDs)</h2><span id='topic+add_group_id'></span><span id='topic+add_group_id.data.frame'></span><span id='topic+add_row_id'></span><span id='topic+add_row_id.data.frame'></span><span id='topic+add_consecutive_id'></span><span id='topic+add_consecutive_id.data.frame'></span>

<h3>Description</h3>

<p>Add a column of useful IDs (group IDs, row IDs &amp; consecutive IDs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_group_id(data, ...)

## S3 method for class 'data.frame'
add_group_id(
  data,
  ...,
  .order = df_group_by_order_default(data),
  .ascending = TRUE,
  .by = NULL,
  .cols = NULL,
  .name = NULL,
  as_qg = FALSE
)

add_row_id(data, ...)

## S3 method for class 'data.frame'
add_row_id(
  data,
  ...,
  .ascending = TRUE,
  .by = NULL,
  .cols = NULL,
  .name = NULL
)

add_consecutive_id(data, ...)

## S3 method for class 'data.frame'
add_consecutive_id(
  data,
  ...,
  .order = df_group_by_order_default(data),
  .by = NULL,
  .cols = NULL,
  .name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_group_id_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="add_group_id_+3A_...">...</code></td>
<td>
<p>Additional groups using tidy <code>data-masking</code> rules. <br />
To specify groups using <code>tidyselect</code>, simply use the <code>.by</code> argument.</p>
</td></tr>
<tr><td><code id="add_group_id_+3A_.order">.order</code></td>
<td>
<p>Should the groups be ordered? <br />
When <code>.order</code> is <code>TRUE</code> (the default) the group IDs will be
ordered but not sorted. <br />
If <code>FALSE</code> the order of the group IDs will be based on first appearance.</p>
</td></tr>
<tr><td><code id="add_group_id_+3A_.ascending">.ascending</code></td>
<td>
<p>Should the order be ascending or descending?
The default is <code>TRUE</code>. <br />
For <code>add_row_id()</code> this determines if the
row IDs are in increasing or decreasing order. <br />
<b>NOTE</b> - When <code>order = FALSE</code>, the <code>ascending</code> argument is
ignored. This is something that will be fixed in a later version.</p>
</td></tr>
<tr><td><code id="add_group_id_+3A_.by">.by</code></td>
<td>
<p>Alternative way of supplying groups using <code>tidyselect</code> notation.</p>
</td></tr>
<tr><td><code id="add_group_id_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="add_group_id_+3A_.name">.name</code></td>
<td>
<p>Name of the added ID column which should be a
character vector of length 1.
If <code>.name = NULL</code> (the default),
<code>add_group_id()</code> will add a column named &quot;group_id&quot;,
and if one already exists, a unique name will be used.</p>
</td></tr>
<tr><td><code id="add_group_id_+3A_as_qg">as_qg</code></td>
<td>
<p>Should the group IDs be returned as a
collapse &quot;qG&quot; class? The default (<code>FALSE</code>) always returns
an integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the requested ID column.
</p>


<h3>See Also</h3>

<p><a href="#topic+group_id">group_id</a> <a href="#topic+row_id">row_id</a> <a href="#topic+f_consecutive_id">f_consecutive_id</a>
</p>

<hr>
<h2 id='desc'>Helpers to sort variables in ascending or descending order</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>An alternative to <code>dplyr::desc()</code> which is much faster
for character vectors and factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="desc_+3A_x">x</code></td>
<td>
<p>Vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector that can be ordered in ascending or descending order. <br />
Useful in <code>dplyr::arrange()</code> or <code>f_arrange()</code>.
</p>

<hr>
<h2 id='f_arrange'>A <code>collapse</code> version of <code>dplyr::arrange()</code></h2><span id='topic+f_arrange'></span>

<h3>Description</h3>

<p>This is a fast and near-identical alternative to <code>dplyr::arrange()</code>
using the <code>collapse</code> package.
</p>
<p><code>desc()</code> is like <code>dplyr::desc()</code> but works faster when
called directly on vectors. <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_arrange(
  data,
  ...,
  .by = NULL,
  .by_group = FALSE,
  .cols = NULL,
  .descending = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_arrange_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_arrange_+3A_...">...</code></td>
<td>
<p>Variables to arrange by.</p>
</td></tr>
<tr><td><code id="f_arrange_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="f_arrange_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code> the sorting will be first done by the group
variables.</p>
</td></tr>
<tr><td><code id="f_arrange_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="f_arrange_+3A_.descending">.descending</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> data frame be arranged in descending order? Default is
<code>FALSE</code>. In simple cases this can be easily achieved through <code>desc()</code> but
for a mixture of ascending and descending variables, it's easier to use
the <code>.descending</code> arg to reverse the order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sorted <code>data.frame</code>.
</p>

<hr>
<h2 id='f_bind_rows'>Bind data frame rows and columns</h2><span id='topic+f_bind_rows'></span><span id='topic+f_bind_cols'></span>

<h3>Description</h3>

<p>Faster bind rows and columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_bind_rows(..., .fill = TRUE)

f_bind_cols(..., .repair_names = TRUE, .recycle = TRUE, .sep = "...")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_bind_rows_+3A_...">...</code></td>
<td>
<p>Data frames to bind.</p>
</td></tr>
<tr><td><code id="f_bind_rows_+3A_.fill">.fill</code></td>
<td>
<p>Should missing columns be filled with <code>NA</code>?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_bind_rows_+3A_.repair_names">.repair_names</code></td>
<td>
<p>Should duplicate column names be made unique?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_bind_rows_+3A_.recycle">.recycle</code></td>
<td>
<p>Should inputs be recycled to a common row size?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_bind_rows_+3A_.sep">.sep</code></td>
<td>
<p>Separator to use for creating unique column names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>f_bind_rows()</code> performs a union of the data frames specified via <code>...</code> and
joins the rows of all the data frames, without removing duplicates.
</p>
<p><code>f_bind_cols()</code> joins the columns, creating unique column names if there are
any duplicates by default.
</p>

<hr>
<h2 id='f_count'>A fast replacement to dplyr::count()</h2><span id='topic+f_count'></span><span id='topic+f_add_count'></span>

<h3>Description</h3>

<p>Near-identical alternative to <code>dplyr::count()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_count(
  data,
  ...,
  wt = NULL,
  sort = FALSE,
  .order = df_group_by_order_default(data),
  name = NULL,
  .by = NULL,
  .cols = NULL
)

f_add_count(
  data,
  ...,
  wt = NULL,
  sort = FALSE,
  .order = df_group_by_order_default(data),
  name = NULL,
  .by = NULL,
  .cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_count_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_count_+3A_...">...</code></td>
<td>
<p>Variables to group by.</p>
</td></tr>
<tr><td><code id="f_count_+3A_wt">wt</code></td>
<td>
<p>Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="f_count_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="f_count_+3A_.order">.order</code></td>
<td>
<p>Should the groups be calculated as ordered groups?
If <code>FALSE</code>, this will return the groups in order of first appearance,
and in many cases is faster.
If <code>TRUE</code> (the default), the groups are returned in sorted order,
exactly the same way as <code>dplyr::count</code>.</p>
</td></tr>
<tr><td><code id="f_count_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.
If there's already a column called <code>n</code>,
it will use <code>nn</code>.
If there's a column called <code>n</code> and <code>n</code>n,
it'll use <code>nnn</code>, and so on, adding <code>n</code>s until it gets a new name.</p>
</td></tr>
<tr><td><code id="f_count_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="f_count_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a fast and near-identical alternative to dplyr::count() using the <code>collapse</code> package.
Unlike <code>collapse::fcount()</code>, this works very similarly to <code>dplyr::count()</code>.
The only main difference is that anything supplied to <code>wt</code>
is recycled and added as a data variable.
Other than that everything works exactly as the dplyr equivalent.
</p>
<p><code>f_count()</code> and <code>f_add_count()</code> can be up to &gt;100x faster than the dplyr equivalents.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of frequency counts by group.
</p>

<hr>
<h2 id='f_distinct'>Find distinct rows</h2><span id='topic+f_distinct'></span>

<h3>Description</h3>

<p>Like <code>dplyr::distinct()</code> but faster when lots of
groups are involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_distinct(
  data,
  ...,
  .keep_all = FALSE,
  .sort = FALSE,
  .order = .sort,
  .by = NULL,
  .cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_distinct_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_distinct_+3A_...">...</code></td>
<td>
<p>Variables used to find distinct rows.</p>
</td></tr>
<tr><td><code id="f_distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> then all columns of data frame are kept,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_distinct_+3A_.sort">.sort</code></td>
<td>
<p>Should result be sorted? Default is <code>FALSE</code>.
When <code>order = FALSE</code> this option has no effect on the result.</p>
</td></tr>
<tr><td><code id="f_distinct_+3A_.order">.order</code></td>
<td>
<p>Should the groups be calculated as ordered groups?
Setting to <code>TRUE</code> may sometimes offer a speed benefit, but usually this
is not the case. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_distinct_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="f_distinct_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of distinct groups.
</p>

<hr>
<h2 id='f_duplicates'>Find duplicate rows</h2><span id='topic+f_duplicates'></span>

<h3>Description</h3>

<p>Find duplicate rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_duplicates(
  data,
  ...,
  .keep_all = FALSE,
  .both_ways = FALSE,
  .add_count = FALSE,
  .drop_empty = FALSE,
  .sort = FALSE,
  .by = NULL,
  .cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_duplicates_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_...">...</code></td>
<td>
<p>Variables used to find duplicate rows.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code> then all columns of data frame are kept,
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_.both_ways">.both_ways</code></td>
<td>
<p>If <code>TRUE</code> then duplicates and non-duplicate first instances
are retained. The default is <code>FALSE</code> which returns only duplicate rows. <br />
Setting this to <code>TRUE</code> can be particularly useful when examining
the differences between duplicate rows.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_.add_count">.add_count</code></td>
<td>
<p>If <code>TRUE</code> then a count column is added to denote the
number of duplicates (including first non-duplicate instance).
The naming convention of this column follows <code>dplyr::add_count()</code>.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_.drop_empty">.drop_empty</code></td>
<td>
<p>If <code>TRUE</code> then empty rows with all <code>NA</code> values are removed.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_.sort">.sort</code></td>
<td>
<p>Should result be sorted?
If <code>FALSE</code> (the default), then rows are returned in the exact same order as
they appear in the data.
If <code>TRUE</code> then the duplicate rows are sorted.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="f_duplicates_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works like <code>dplyr::distinct()</code> in its handling of
arguments and data-masking but returns duplicate rows.
In certain situations in can be much faster than <code>data %&gt;% group_by() %&gt;% filter(n() &gt; 1)</code>
when there are many groups.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of duplicate rows.
</p>


<h3>See Also</h3>

<p><a href="#topic+f_count">f_count</a> <a href="#topic+f_distinct">f_distinct</a>
</p>

<hr>
<h2 id='f_expand'>Fast versions of <code>tidyr::expand()</code> and <code>tidyr::complete()</code>.</h2><span id='topic+f_expand'></span><span id='topic+f_complete'></span><span id='topic+crossing'></span><span id='topic+nesting'></span>

<h3>Description</h3>

<p>Fast versions of <code>tidyr::expand()</code> and <code>tidyr::complete()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_expand(data, ..., .sort = FALSE, .by = NULL, .cols = NULL)

f_complete(data, ..., .sort = FALSE, .by = NULL, .cols = NULL, fill = NA)

crossing(..., .sort = FALSE)

nesting(..., .sort = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_expand_+3A_data">data</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="f_expand_+3A_...">...</code></td>
<td>
<p>Variables to expand.</p>
</td></tr>
<tr><td><code id="f_expand_+3A_.sort">.sort</code></td>
<td>
<p>Logical. If <code>TRUE</code> expanded/completed variables are sorted.
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_expand_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="f_expand_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="f_expand_+3A_fill">fill</code></td>
<td>
<p>A named list containing value-name pairs
to fill the named implicit missing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>crossing</code> and <code>nesting</code> are helpers that are basically identical to
tidyr's <code>crossing</code> and <code>nesting</code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of expanded groups.
</p>

<hr>
<h2 id='f_fill'>Fill <code>NA</code> values forwards and backwards</h2><span id='topic+f_fill'></span>

<h3>Description</h3>

<p>Fill <code>NA</code> values forwards and backwards
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_fill(
  data,
  ...,
  .by = NULL,
  .cols = NULL,
  .direction = c("forwards", "backwards"),
  .fill_limit = Inf,
  .new_names = "{.col}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_fill_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_fill_+3A_...">...</code></td>
<td>
<p>Cols to fill <code>NA</code> values specified through <code>tidyselect</code> notation.
If left empty all cols are used by default.</p>
</td></tr>
<tr><td><code id="f_fill_+3A_.by">.by</code></td>
<td>
<p>Cols to group by for this operation.
Specified through <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="f_fill_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="f_fill_+3A_.direction">.direction</code></td>
<td>
<p>Which direction should <code>NA</code> values be filled?
By default, &quot;forwards&quot; (Last-Observation-Carried-Forward) is used.
&quot;backwards&quot; is (Next-Observation-Carried-Backward).</p>
</td></tr>
<tr><td><code id="f_fill_+3A_.fill_limit">.fill_limit</code></td>
<td>
<p>The maximum number of consecutive <code>NA</code> values to fill.
Default is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="f_fill_+3A_.new_names">.new_names</code></td>
<td>
<p>A name specification for the names of filled variables.
The default <code>"{.col}"</code> replaces the given variables with the imputed ones.
New variables can be created alongside the originals if we give a different
specification, e.g.
<code>.new_names = "{.col}_imputed"</code>.
This follows the specification of <code>dplyr::across</code> if <code>.fns</code> were an empty
string <code>""</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with <code>NA</code> values filled forward or backward.
</p>

<hr>
<h2 id='f_filter'>Alternative to <code>dplyr::filter()</code></h2><span id='topic+f_filter'></span>

<h3>Description</h3>

<p>Alternative to <code>dplyr::filter()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_filter(data, ..., .by = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_filter_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_filter_+3A_...">...</code></td>
<td>
<p>Expressions used to filter the data frame with.</p>
</td></tr>
<tr><td><code id="f_filter_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A filtered data frame.
</p>

<hr>
<h2 id='f_group_by'>'collapse' version of <code>dplyr::group_by()</code></h2><span id='topic+f_group_by'></span><span id='topic+group_ordered'></span><span id='topic+f_ungroup'></span>

<h3>Description</h3>

<p>This works the exact same as <code>dplyr::group_by()</code> and typically
performs around the same speed but uses slightly less memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_group_by(
  data,
  ...,
  .add = FALSE,
  .order = df_group_by_order_default(data),
  .by = NULL,
  .cols = NULL,
  .drop = df_group_by_drop_default(data)
)

group_ordered(data)

f_ungroup(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_group_by_+3A_data">data</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="f_group_by_+3A_...">...</code></td>
<td>
<p>Variables to group by.</p>
</td></tr>
<tr><td><code id="f_group_by_+3A_.add">.add</code></td>
<td>
<p>Should groups be added to existing groups?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_group_by_+3A_.order">.order</code></td>
<td>
<p>Should groups be ordered? If <code>FALSE</code>
groups will be ordered based on first-appearance. <br />
Typically, setting order to <code>FALSE</code> is faster.</p>
</td></tr>
<tr><td><code id="f_group_by_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="f_group_by_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="f_group_by_+3A_.drop">.drop</code></td>
<td>
<p>Should unused factor levels be dropped? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>f_group_by()</code> works almost exactly like the 'dplyr' equivalent.
An attribute &quot;ordered&quot; (<code>TRUE</code> or <code>FALSE</code>) is added to the group data to
signify if the groups are sorted or not.
</p>


<h4>Ordered vs Sorted</h4>

<p>The distinction between ordered and sorted is somewhat subtle.
Functions in fastplyr that use a <code>sort</code> argument generally refer
to the top-level dataset being sorted in some way, either by sorting
the group columns like in <code>f_expand()</code> or <code>f_distinct()</code>, or
some other columns, like the count column in <code>f_count()</code>.
</p>
<p>The <code>.order</code> argument, when set to <code>TRUE</code> (the default),
is used to mean that the group data will be calculated
using a sort-based algorithm, leading to sorted group data.
When <code>.order</code> is <code>FALSE</code>, the group data will be returned based on
the order-of-first appearance of the groups in the data.
This order-of-first appearance may still naturally be sorted
depending on the data.
For example, <code>group_id(1:3, order = T)</code> results in the same group IDs
as <code>group_id(1:3, order = F)</code> because 1, 2, and 3 appear in the data in
ascending sequence whereas <code>group_id(3:1, order = T)</code> does not equal
<code>group_id(3:1, order = F)</code>
</p>
<p>Part of the reason for the distinction is that internally fastplyr
can in theory calculate group data
using the sort-based algorithm and still return unsorted groups,
though this combination is only available to the user in limited places like
<code>f_distinct(.order = TRUE, .sort = FALSE)</code>.
</p>
<p>The other reason is to prevent confusion in the meaning
of <code>sort</code> and <code>order</code> so that <code>order</code> always refers to the
algorithm specified, resulting in sorted groups, and <code>sort</code> implies a
physical sorting of the returned data. It's also worth mentioning that
in most functions, <code>sort</code> will implicitly utilise the sort-based algorithm
specified via <code>order = TRUE</code>.
</p>



<h4>Using the order-of-first appearance algorithm for speed</h4>

<p>In many situations (not all) it can be faster to use the
order-of-first appearance algorithm, specified via <code>.order = FALSE</code>.
</p>
<p>This can generally be accessed by first calling
<code>f_group_by(data, ..., .order = FALSE)</code> and then
performing your calculations.
</p>
<p>To utilise this algorithm more globally and package-wide,
set the '.fastplyr.order.groups' option to <code>FALSE</code> using the code:
<code>options(.fastplyr.order.groups = FALSE)</code>.
</p>



<h3>Value</h3>

<p><code>f_group_by()</code> returns a <code>grouped_df</code> that can be used
for further for grouped calculations.
</p>
<p><code>group_ordered()</code> returns <code>TRUE</code> if the group data are sorted,
i.e if <code>attr(attr(data, "groups"), "ordered") == TRUE</code>. If sorted,
which is usually the default, this leads to summary calculations
like <code>f_summarise()</code> or <code>dplyr::summarise()</code> producing sorted groups.
If <code>FALSE</code> they are returned based on order-of-first appearance in the data.
</p>

<hr>
<h2 id='f_left_join'>Fast SQL joins</h2><span id='topic+f_left_join'></span><span id='topic+f_right_join'></span><span id='topic+f_inner_join'></span><span id='topic+f_full_join'></span><span id='topic+f_anti_join'></span><span id='topic+f_semi_join'></span><span id='topic+f_cross_join'></span><span id='topic+f_union_all'></span><span id='topic+f_union'></span>

<h3>Description</h3>

<p>Mostly a wrapper around <code>collapse::join()</code> that behaves more like
dplyr's joins. List columns, lubridate intervals and vctrs rcrds
work here too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_left_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  multiple = TRUE,
  keep = FALSE,
  ...
)

f_right_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  multiple = TRUE,
  keep = FALSE,
  ...
)

f_inner_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  multiple = TRUE,
  keep = FALSE,
  ...
)

f_full_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  multiple = TRUE,
  keep = FALSE,
  ...
)

f_anti_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  multiple = TRUE,
  keep = FALSE,
  ...
)

f_semi_join(
  x,
  y,
  by = NULL,
  suffix = c(".x", ".y"),
  multiple = TRUE,
  keep = FALSE,
  ...
)

f_cross_join(x, y, suffix = c(".x", ".y"), ...)

f_union_all(x, y, ...)

f_union(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_left_join_+3A_x">x</code></td>
<td>
<p>Left data frame.</p>
</td></tr>
<tr><td><code id="f_left_join_+3A_y">y</code></td>
<td>
<p>Right data frame.</p>
</td></tr>
<tr><td><code id="f_left_join_+3A_by">by</code></td>
<td>
<p><code>character(1)</code> - Columns to join on.</p>
</td></tr>
<tr><td><code id="f_left_join_+3A_suffix">suffix</code></td>
<td>
<p><code>character(2)</code> - Suffix to paste onto common cols
between <code>x</code> and <code>y</code> in the joined output.</p>
</td></tr>
<tr><td><code id="f_left_join_+3A_multiple">multiple</code></td>
<td>
<p><code>logical(1)</code> - Should multiple matches be returned?
If <code>FALSE</code> the first match in y is used. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_left_join_+3A_keep">keep</code></td>
<td>
<p><code>logical(1)</code> - Should join columns from
both data frames be kept? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_left_join_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>collapse::join()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A joined data frame, joined on the columns specified with <code>by</code>, using an
equality join.
</p>
<p><code>f_cross_join()</code> returns all possible combinations
between the two data frames.
</p>

<hr>
<h2 id='f_nest_by'>Create a subset of data for each group</h2><span id='topic+f_nest_by'></span>

<h3>Description</h3>

<p>A faster <code>nest_by()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_nest_by(
  data,
  ...,
  .add = FALSE,
  .order = df_group_by_order_default(data),
  .by = NULL,
  .cols = NULL,
  .drop = df_group_by_drop_default(data)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_nest_by_+3A_data">data</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="f_nest_by_+3A_...">...</code></td>
<td>
<p>Variables to group by.</p>
</td></tr>
<tr><td><code id="f_nest_by_+3A_.add">.add</code></td>
<td>
<p>Should groups be added to existing groups?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_nest_by_+3A_.order">.order</code></td>
<td>
<p>Should groups be ordered? If <code>FALSE</code>
groups will be ordered based on first-appearance. <br />
Typically, setting order to <code>FALSE</code> is faster.</p>
</td></tr>
<tr><td><code id="f_nest_by_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="f_nest_by_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="f_nest_by_+3A_.drop">.drop</code></td>
<td>
<p>Should unused factor levels be dropped? Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row-wise <code>grouped_df</code> of the corresponding data of each group.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(fastplyr)

# Stratified linear-model example

models &lt;- iris %&gt;%
  f_nest_by(Species) %&gt;%
  mutate(model = list(lm(Sepal.Length ~ Petal.Width + Petal.Length, data = first(data))),
         summary = list(summary(first(model))),
         r_sq = first(summary)$r.squared)
models
models$summary

# dplyr's `nest_by()` is admittedly more convenient
# as it performs a double bracket subset `[[` on list elements for you
# which we have emulated by using `first()`

# `f_nest_by()` is faster when many groups are involved

models &lt;- iris %&gt;%
  nest_by(Species) %&gt;%
  mutate(model = list(lm(Sepal.Length ~ Petal.Width + Petal.Length, data = data)),
         summary = list(summary(model)),
         r_sq = summary$r.squared)
models$summary

models$summary[[1]]
</code></pre>

<hr>
<h2 id='f_rowwise'>A convenience function to group by every row</h2><span id='topic+f_rowwise'></span>

<h3>Description</h3>

<p>fastplyr currently cannot handle <code>rowwise_df</code> objects created through
<code>dplyr::rowwise()</code> and so this is a convenience function to allow you to
perform row-wise operations.
For common efficient row-wise functions,
see the 'kit' package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rowwise(data, ..., .ascending = TRUE, .cols = NULL, .name = ".row_id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_rowwise_+3A_data">data</code></td>
<td>
<p>data frame.</p>
</td></tr>
<tr><td><code id="f_rowwise_+3A_...">...</code></td>
<td>
<p>Variables to group by using <code>tidyselect</code>.</p>
</td></tr>
<tr><td><code id="f_rowwise_+3A_.ascending">.ascending</code></td>
<td>
<p>Should data be grouped in ascending row-wise order?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_rowwise_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="f_rowwise_+3A_.name">.name</code></td>
<td>
<p>Name of row-id column to be added.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A row-wise <code>grouped_df</code>.
</p>

<hr>
<h2 id='f_select'>Fast 'dplyr' <code>select()</code>/<code>rename()</code>/<code>pull()</code></h2><span id='topic+f_select'></span><span id='topic+f_rename'></span><span id='topic+f_pull'></span><span id='topic+nothing'></span>

<h3>Description</h3>

<p><code>f_select()</code> operates the exact same way as <code>dplyr::select()</code> and
can be used naturally with <code>tidy-select</code> helpers.
It uses collapse to perform the actual selecting of variables and is
considerably faster than dplyr for selecting exact columns,
and even more so when supplying the <code>.cols</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_select(data, ..., .cols = NULL)

f_rename(data, ..., .cols = NULL)

f_pull(data, ..., .cols = NULL)

nothing()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_select_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_select_+3A_...">...</code></td>
<td>
<p>Variables to select using <code>tidy-select</code>.
See <code>?dplyr::select</code> for more info.</p>
</td></tr>
<tr><td><code id="f_select_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) faster alternative to <code>...</code> that accepts
a named character vector or numeric vector. <br />
No checks on duplicates column names are done when using <code>.cols</code>. <br />
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of selected columns.
</p>

<hr>
<h2 id='f_slice'>Faster <code>dplyr::slice()</code></h2><span id='topic+f_slice'></span><span id='topic+f_slice_head'></span><span id='topic+f_slice_tail'></span><span id='topic+f_slice_min'></span><span id='topic+f_slice_max'></span><span id='topic+f_slice_sample'></span>

<h3>Description</h3>

<p>When there are lots of groups, the <code>f_slice()</code> functions are much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_slice(
  data,
  i = 0L,
  ...,
  .by = NULL,
  .order = df_group_by_order_default(data),
  keep_order = FALSE
)

f_slice_head(
  data,
  n,
  prop,
  .by = NULL,
  .order = df_group_by_order_default(data),
  keep_order = FALSE
)

f_slice_tail(
  data,
  n,
  prop,
  .by = NULL,
  .order = df_group_by_order_default(data),
  keep_order = FALSE
)

f_slice_min(
  data,
  order_by,
  n,
  prop,
  .by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  .order = df_group_by_order_default(data),
  keep_order = FALSE
)

f_slice_max(
  data,
  order_by,
  n,
  prop,
  .by = NULL,
  with_ties = TRUE,
  na_rm = FALSE,
  .order = df_group_by_order_default(data),
  keep_order = FALSE
)

f_slice_sample(
  data,
  n,
  replace = FALSE,
  prop,
  .by = NULL,
  .order = df_group_by_order_default(data),
  keep_order = FALSE,
  weights = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_slice_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_i">i</code></td>
<td>
<p>An <a href="base.html#topic+integer">integer</a> vector of slice locations. <br />
Please see the details below on how <code>i</code> works as it
only accepts simple integer vectors.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_...">...</code></td>
<td>
<p>A temporary argument to give the user an error if dots are used.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_.order">.order</code></td>
<td>
<p>Should the groups be returned in sorted order?
If <code>FALSE</code>, this will return the groups in order of first appearance,
and in many cases is faster.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_keep_order">keep_order</code></td>
<td>
<p>Should the sliced data frame be returned in its original order?
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_n">n</code></td>
<td>
<p>Number of rows.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_prop">prop</code></td>
<td>
<p>Proportion of rows.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_order_by">order_by</code></td>
<td>
<p>Variables to order by.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_na_rm">na_rm</code></td>
<td>
<p>Should missing values in <code>f_slice_max()</code> and <code>f_slice_min()</code> be removed?
The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_replace">replace</code></td>
<td>
<p>Should <code>f_slice_sample()</code> sample with or without replacement?
Default is <code>FALSE</code>, without replacement.</p>
</td></tr>
<tr><td><code id="f_slice_+3A_weights">weights</code></td>
<td>
<p>Probability weights used in <code>f_slice_sample()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Important note about the <code>i</code> argument in <code>f_slice</code></h4>

<p><code>i</code> is first evaluated on an un-grouped basis and then searches for
those locations in each group. Thus if you supply an expression
of slice locations that vary by-group, this will not be respected nor checked.
For example, <br />
do <code>f_slice(data, 10:20, .by = group)</code> <br />
not <code>f_slice(data, sample(1:10), .by = group)</code>. <br />
</p>
<p>The former results in slice locations that do not vary by group but the latter
will result in different within-group slice locations which <code>f_slice</code> cannot
correctly compute.
</p>
<p>To do the the latter type of by-group slicing, use <code>f_filter</code>, e.g. <br />
<code>f_filter(data, row_number() %in% slices, .by = groups)</code>
or even faster: <br />
<code>library(cheapr)</code> <br />
<code>f_filter(data, row_number() %in_% slices, .by = groups)</code>
</p>



<h4><code>f_slice_sample</code></h4>

<p>The arguments of <code>f_slice_sample()</code> align more closely with <code>base::sample()</code> and thus
by default re-samples each entire group without replacement.
</p>



<h3>Value</h3>

<p>A <code>data.frame</code> filtered on the specified row indices.
</p>

<hr>
<h2 id='f_summarise'>Summarise each group down to one row</h2><span id='topic+f_summarise'></span><span id='topic+f_summarize'></span>

<h3>Description</h3>

<p>Like <code>dplyr::summarise()</code> but with some internal optimisations
for common statistical functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_summarise(
  data,
  ...,
  .by = NULL,
  .order = df_group_by_order_default(data),
  .optimise = TRUE
)

f_summarize(
  data,
  ...,
  .by = NULL,
  .order = df_group_by_order_default(data),
  .optimise = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_summarise_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="f_summarise_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary functions. Expressions with
<code>across()</code> are also accepted.</p>
</td></tr>
<tr><td><code id="f_summarise_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="f_summarise_+3A_.order">.order</code></td>
<td>
<p>Should the groups be returned in sorted order?
If <code>FALSE</code>, this will return the groups in order of first appearance,
and in many cases is faster.</p>
</td></tr>
<tr><td><code id="f_summarise_+3A_.optimise">.optimise</code></td>
<td>
<p>(Optionally) turn off optimisations for common statistical
functions by setting to <code>FALSE</code>. Default is <code>TRUE</code> which uses optimisations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>f_summarise</code> behaves mostly like <code>dplyr::summarise</code> except that expressions
supplied to <code>...</code> are evaluated independently.
</p>


<h4>Optimised statistical functions</h4>

<p>Some functions are internally optimised using 'collapse'
fast statistical functions. This makes execution on many groups very fast.
</p>
<p>For fast quantiles (percentiles) by group, see <a href="#topic+tidy_quantiles">tidy_quantiles</a>
</p>
<p>List of currently optimised functions and their equivalent
'collapse' function
</p>
<p><code>base::sum</code> -&gt; <code>collapse::fsum</code> <br />
<code>base::prod</code> -&gt; <code>collapse::fprod</code> <br />
<code>base::min</code> -&gt; <code>collapse::fmin</code> <br />
<code>base::max</code> -&gt; <code>collapse::fmax</code> <br />
<code>stats::mean</code> -&gt; <code>collapse::fmean</code> <br />
<code>stats::median</code> -&gt; <code>collapse::fmedian</code> <br />
<code>stats::sd</code> -&gt; <code>collapse::fsd</code> <br />
<code>stats::var</code> -&gt; <code>collapse::fvar</code> <br />
<code>dplyr::first</code> -&gt; <code>collapse::ffirst</code> <br />
<code>dplyr::last</code> -&gt; <code>collapse::flast</code> <br />
<code>dplyr::n_distinct</code> -&gt; <code>collapse::fndistinct</code> <br />
</p>



<h3>Value</h3>

<p>An un-grouped data frame of summaries by group.
</p>


<h3>See Also</h3>

<p><a href="#topic+tidy_quantiles">tidy_quantiles</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fastplyr)
library(nycflights13)

# Number of flights per month, including first and last day
flights %&gt;%
  f_group_by(year, month) %&gt;%
  f_summarise(first_day = first(day),
              last_day = last(day),
              num_flights = n())

## Fast mean summary using `across()`

flights %&gt;%
  f_summarise(
    across(where(is.double), mean),
    .by = tailnum
  )

# To ignore or keep NAs, use collapse::set_collapse(na.rm)
collapse::set_collapse(na.rm = FALSE)
flights %&gt;%
  f_summarise(
    across(where(is.double), mean),
    .by = origin
  )
collapse::set_collapse(na.rm = TRUE)
</code></pre>

<hr>
<h2 id='group_by_order_default'>Default value for ordering of groups</h2><span id='topic+group_by_order_default'></span>

<h3>Description</h3>

<p>A default value, <code>TRUE</code> or <code>FALSE</code> that controls which algorithm to use
for calculating groups. See <a href="#topic+f_group_by">f_group_by</a> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_by_order_default(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_by_order_default_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical of length 1, either <code>TRUE</code> or <code>FALSE</code>.
</p>

<hr>
<h2 id='group_id'>Fast group and row IDs</h2><span id='topic+group_id'></span><span id='topic+row_id'></span><span id='topic+f_consecutive_id'></span>

<h3>Description</h3>

<p>These are tidy-based functions for calculating group IDs and row IDs. <br />
</p>

<ul>
<li> <p><code>group_id()</code> returns an integer vector of group IDs
the same size as the <code>x</code>.
</p>
</li>
<li> <p><code>row_id()</code> returns an integer vector of row IDs.
</p>
</li>
<li> <p><code>f_consecutive_id()</code> returns an integer vector of consecutive run IDs.
</p>
</li></ul>

<p>The <code>add_</code> variants add a column of group IDs/row IDs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_id(x, order = TRUE, ascending = TRUE, as_qg = FALSE)

row_id(x, ascending = TRUE)

f_consecutive_id(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="group_id_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="group_id_+3A_order">order</code></td>
<td>
<p>Should the groups be ordered?
When order is <code>TRUE</code> (the default) the group IDs will be
ordered but not sorted. <br />
If <code>FALSE</code> the order of the group IDs will be based on first appearance.</p>
</td></tr>
<tr><td><code id="group_id_+3A_ascending">ascending</code></td>
<td>
<p>Should the order be ascending or descending?
The default is <code>TRUE</code>. <br />
For <code>row_id()</code> this determines if the row IDs are in
increasing or decreasing order. <br /></p>
</td></tr>
<tr><td><code id="group_id_+3A_as_qg">as_qg</code></td>
<td>
<p>Should the group IDs be returned as a
collapse &quot;qG&quot; class? The default (<code>FALSE</code>) always returns
an integer vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Note</b> - When working with data frames it is highly recommended
to use the <code>add_</code> variants of these functions. Not only are they more
intuitive to use, they also have optimisations for large numbers of groups.
</p>


<h4><code>group_id</code></h4>

<p>This assigns an integer value to unique elements of a vector or unique
rows of a data frame. It is an extremely useful function for analysis
as you can compress a lot of information into a single column, using that
for further operations.
</p>



<h4><code>row_id</code></h4>

<p>This assigns a row number to each group. To assign plain row numbers
to a data frame one can use <code>add_row_id()</code>.
This function can be used in rolling calculations, finding duplicates and
more.
</p>



<h4><code>consecutive_id</code></h4>

<p>An alternative to <code>dplyr::consecutive_id()</code>, <code>f_consecutive_id()</code> also
creates an integer vector with values in the range <code style="white-space: pre;">&#8288;[1, n]&#8288;</code> where
<code>n</code> is the length of the vector or number of rows of the data frame.
The ID increments every time <code>x[i] != x[i - 1]</code> thus giving information on
when there is a change in value.
<code>f_consecutive_id</code> has a very small overhead in terms
of calling the function, making it suitable for repeated calls.
</p>



<h3>Value</h3>

<p>An integer vector.
</p>


<h3>See Also</h3>

<p><a href="#topic+add_group_id">add_group_id</a> <a href="#topic+add_row_id">add_row_id</a> <a href="#topic+add_consecutive_id">add_consecutive_id</a>
</p>

<hr>
<h2 id='list_tidy'>Alternative to <code>rlang::list2</code></h2><span id='topic+list_tidy'></span>

<h3>Description</h3>

<p>Evaluates arguments dynamically like <code>rlang::list2</code> but objects
created in <code>list_tidy</code> have precedence over environment objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_tidy(..., .keep_null = TRUE, .named = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_tidy_+3A_...">...</code></td>
<td>
<p>Dynamic name-value pairs.</p>
</td></tr>
<tr><td><code id="list_tidy_+3A_.keep_null">.keep_null</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> - Should <code>NULL</code> elements be kept?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="list_tidy_+3A_.named">.named</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code> - Should all list elements be named?
Default is <code>FALSE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='new_tbl'>Fast 'tibble' alternatives</h2><span id='topic+new_tbl'></span><span id='topic+f_enframe'></span><span id='topic+f_deframe'></span><span id='topic+as_tbl'></span>

<h3>Description</h3>

<p>Fast 'tibble' alternatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_tbl(..., .nrows = NULL, .recycle = TRUE, .name_repair = TRUE)

f_enframe(x, name = "name", value = "value")

f_deframe(x)

as_tbl(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_tbl_+3A_...">...</code></td>
<td>
<p>Dynamic name-value pairs.</p>
</td></tr>
<tr><td><code id="new_tbl_+3A_.nrows">.nrows</code></td>
<td>
<p><code>integer(1)</code> (Optional) number of rows. <br />
Commonly used to initialise a 0-column data frame with rows.</p>
</td></tr>
<tr><td><code id="new_tbl_+3A_.recycle">.recycle</code></td>
<td>
<p><code>logical(1)</code> Should arguments be recycled?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="new_tbl_+3A_.name_repair">.name_repair</code></td>
<td>
<p><code>logical(1)</code> Should duplicate names be made unique?
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="new_tbl_+3A_x">x</code></td>
<td>
<p>A data frame or vector.</p>
</td></tr>
<tr><td><code id="new_tbl_+3A_name">name</code></td>
<td>
<p><code>character(1)</code> Name to use for column of names.</p>
</td></tr>
<tr><td><code id="new_tbl_+3A_value">value</code></td>
<td>
<p><code>character(1)</code> Name to use for column of values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>new_tbl</code> and <code>as_tbl</code> are alternatives to
<code>tibble</code> and <code>as_tibble</code> respectively.
</p>
<p><code>f_enframe(x)</code> where <code>x</code> is a <code>data.frame</code> converts <code>x</code> into a tibble
of column names and list-values.
</p>


<h3>Value</h3>

<p>A tibble or vector.
</p>

<hr>
<h2 id='remove_rows_if_any_na'>Fast remove rows with <code>NA</code> values</h2><span id='topic+remove_rows_if_any_na'></span><span id='topic+remove_rows_if_all_na'></span>

<h3>Description</h3>

<p>Fast remove rows with <code>NA</code> values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_rows_if_any_na(data, ..., .cols = NULL)

remove_rows_if_all_na(data, ..., .cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_rows_if_any_na_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="remove_rows_if_any_na_+3A_...">...</code></td>
<td>
<p>Cols to fill <code>NA</code> values specified through <code>tidyselect</code> notation.
If left empty all cols are used by default.</p>
</td></tr>
<tr><td><code id="remove_rows_if_any_na_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with removed rows containing either any or all <code>NA</code> values.
</p>

<hr>
<h2 id='tidy_quantiles'>Fast grouped sample quantiles</h2><span id='topic+tidy_quantiles'></span>

<h3>Description</h3>

<p>Fast grouped sample quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_quantiles(
  data,
  ...,
  probs = seq(0, 1, 0.25),
  type = 7,
  pivot = c("long", "wide"),
  na.rm = TRUE,
  .by = NULL,
  .cols = NULL,
  .order = df_group_by_order_default(data),
  .drop_groups = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy_quantiles_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_...">...</code></td>
<td>
<p><code style="white-space: pre;">&#8288;&lt;data-masking&gt;&#8288;</code> Variables to calculate quantiles for.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_probs">probs</code></td>
<td>
<p><code>numeric(n)</code> - Quantile probabilities.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_type">type</code></td>
<td>
<p><code>integer(1)</code> - Quantile type, see <code>?collapse::fquantile</code></p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_pivot">pivot</code></td>
<td>
<p><code>character(1)</code> - Pivot result wide or long? Default is &quot;wide&quot;.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical(1)</code> Should <code>NA</code> values be ignored? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_.by">.by</code></td>
<td>
<p>(Optional). A selection of columns to group by for this operation.
Columns are specified using tidy-select.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_.cols">.cols</code></td>
<td>
<p>(Optional) alternative to <code>...</code> that accepts
a named character vector or numeric vector.
If speed is an expensive resource, it is recommended to use this.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_.order">.order</code></td>
<td>
<p>Should the groups be returned in sorted order?
If <code>FALSE</code>, this will return the groups in order of first appearance,
and in many cases is faster.</p>
</td></tr>
<tr><td><code id="tidy_quantiles_+3A_.drop_groups">.drop_groups</code></td>
<td>
<p><code>logical(1)</code> Should groups be dropped after calculation?
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of sample quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(fastplyr)
library(dplyr)
groups &lt;- 1 * 2^(0:10)

# Normal distributed samples by group using the group value as the mean
# and sqrt(groups) as the sd

samples &lt;- tibble(groups) %&gt;%
  reframe(x = rnorm(100, mean = groups, sd = sqrt(groups)), .by = groups) %&gt;%
  f_group_by(groups)

# Fast means and quantiles by group

quantiles &lt;- samples %&gt;%
  tidy_quantiles(x, pivot = "wide")

means &lt;- samples %&gt;%
  f_summarise(mean = mean(x))

means %&gt;%
  f_left_join(quantiles)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
