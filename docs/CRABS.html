<!DOCTYPE html><html><head><title>Help for package CRABS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CRABS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#congruent.models'><p>Create a set of congruent models</p></a></li>
<li><a href='#CRABS-package'><p>CRABS: Congruent Rate Analyses in Birth-death Scenarios</p></a></li>
<li><a href='#crabs.loglikelihood'><p>Compute likelihood</p></a></li>
<li><a href='#create.model'><p>Computes the congruent class, i.e., the pulled rates.</p></a></li>
<li><a href='#full.plot.regularity.thresholds'><p>Plots the rate functions after filtering them according to a given penalty and predefined thresholds.</p></a></li>
<li><a href='#get.gmrf.global.scale'><p>Global scale for GMRF using linear interpolation of pre-computed values</p></a></li>
<li><a href='#get.hsmrf.global.scale'><p>Global scale for HSMRF using linear interpolation of pre-computed values</p></a></li>
<li><a href='#joint.congruent.models'><p>Create a set of congruent models</p></a></li>
<li><a href='#model2df'><p>model2df</p></a></li>
<li><a href='#plot.CRABS'><p>Plots the rate functions including the pulled rates.</p></a></li>
<li><a href='#plot.CRABSset'><p>Plots the rate functions</p></a></li>
<li><a href='#primates'><p>Primates phylogenetic tree</p></a></li>
<li><a href='#primates_ebd'><p>RevBayes Primates birth-death model</p></a></li>
<li><a href='#primates_ebd_log'><p>Primates birth-death model</p></a></li>
<li><a href='#primates_ebd_tess'><p>TESS Primates birth-death model</p></a></li>
<li><a href='#primates_ebd_treepar'><p>TreePar Primates birth-death model</p></a></li>
<li><a href='#print.CRABS'><p>Print method for CRABS object</p></a></li>
<li><a href='#print.CRABSposterior'><p>Title</p></a></li>
<li><a href='#print.CRABSset'><p>Print method for CRABSset object</p></a></li>
<li><a href='#print.CRABSsets'><p>print.CRABSsets</p></a></li>
<li><a href='#read.RevBayes'><p>read RevBayes log file</p></a></li>
<li><a href='#sample.basic.models'><p>Samples simple increase/decrease models through time with noise.</p></a></li>
<li><a href='#sample.basic.models.joint'><p>Jointly samples speciation and extinction trajectories through time, with noise.</p></a></li>
<li><a href='#sample.congruence.class'><p>Stochastic exploration of congruent models.</p></a></li>
<li><a href='#sample.congruence.class.posterior'><p>Stochastic exploration of congruent models for all samples in the posterior</p></a></li>
<li><a href='#sample.rates'><p>Sample custom functions through time.</p></a></li>
<li><a href='#summarize.posterior'><p>Summarize trends in the posterior</p></a></li>
<li><a href='#summarize.trends'><p>Summarize trends in the congruence class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Congruent Rate Analyses in Birth-Death Scenarios</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Features tools for exploring congruent phylogenetic birth-death models. It can construct the pulled speciation- and net-diversification rates from a reference model. Given alternative speciation- or extinction rates, it can construct new models that are congruent with the reference model. Functionality is included to sample new rate functions, and to visualize the distribution of one congruence class. See also Louca &amp; Pennell (2020) &lt;<a href="https://doi.org/10.1038%2Fs41586-020-2176-1">doi:10.1038/s41586-020-2176-1</a>&gt;.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, deSolve, dplyr, tibble, colorspace, patchwork,
latex2exp, tidyr, pracma, ape</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/afmagee/CRABS">https://github.com/afmagee/CRABS</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 10:01:07 UTC; bkopper</td>
</tr>
<tr>
<td>Author:</td>
<td>Bjørn Tore Kopperud [aut, cre],
  Sebastian Höhna [aut],
  Andrew F. Magee [aut],
  Jérémy Andréoletti [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bjørn Tore Kopperud &lt;kopperud@protonmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-24 10:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='congruent.models'>Create a set of congruent models</h2><span id='topic+congruent.models'></span>

<h3>Description</h3>

<p>Create a set of congruent models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congruent.models(
  model,
  mus = NULL,
  lambdas = NULL,
  keep_ref = TRUE,
  ode_solver = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congruent.models_+3A_model">model</code></td>
<td>
<p>The reference model. An object of class &quot;CRABS&quot;</p>
</td></tr>
<tr><td><code id="congruent.models_+3A_mus">mus</code></td>
<td>
<p>A list of extinction-rate functions</p>
</td></tr>
<tr><td><code id="congruent.models_+3A_lambdas">lambdas</code></td>
<td>
<p>A list of speciation-rate functions</p>
</td></tr>
<tr><td><code id="congruent.models_+3A_keep_ref">keep_ref</code></td>
<td>
<p>Whether or not to keep the reference model in the congruent set</p>
</td></tr>
<tr><td><code id="congruent.models_+3A_ode_solver">ode_solver</code></td>
<td>
<p>Whether to use a numerical ODE solver to solve for lambda</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CRABSset&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates_ebd)
lambda &lt;- approxfun(primates_ebd$time, primates_ebd$lambda)
mu &lt;- approxfun(primates_ebd$time, primates_ebd$mu)

## A reference model
times &lt;- seq(0, max(primates_ebd$time), length.out = 500)
model &lt;- create.model(lambda, mu, times = times)

mu1 &lt;- lapply(c(0.5, 1.5, 3.0), function(m) function(t) m)

model_set1 &lt;- congruent.models(model, mus = mu1)

model_set1

lambda0 &lt;- lambda(0.0) ## Speciation rates must all be equal at the present
bs &lt;- c(0.0, 0.01, 0.02)
lambda1 &lt;- lapply(bs, function(b) function(t) lambda0 + b*t)

model_set2 &lt;- congruent.models(model, lambdas = lambda1)

model_set2
</code></pre>

<hr>
<h2 id='CRABS-package'>CRABS: Congruent Rate Analyses in Birth-death Scenarios</h2><span id='topic+CRABS'></span><span id='topic+CRABS-package'></span>

<h3>Description</h3>

<p>Features tools for exploring congruent phylogenetic birth-death models. It can construct the pulled speciation- and net-diversification rates from a reference model. Given alternative speciation- or extinction rates, it can construct new models that are congruent with the reference model. Functionality is included to sample new rate functions, and to visualize the distribution of one congruence class. See also Louca &amp; Pennell (2020) <a href="https://doi.org/10.1038/s41586-020-2176-1">doi:10.1038/s41586-020-2176-1</a>.
</p>


<h3>References</h3>


<ul>
<li><p> Louca, S., &amp; Pennell, M. W. (2020). Extant timetrees are consistent with a myriad of diversification histories. Nature, 580(7804), 502-505. https://doi.org/10.1038/s41586-020-2176-1
</p>
</li>
<li><p> Höhna, S., Kopperud, B. T., &amp; Magee, A. F. (2022). CRABS: Congruent rate analyses in birth–death scenarios. Methods in Ecology and Evolution, 13, 2709– 2718. https://doi.org/10.1111/2041-210X.13997
</p>
</li>
<li><p> Kopperud, B. T., Magee, A. F., &amp; Höhna, S. (2023). Rapidly Changing Speciation and Extinction Rates Can Be Inferred in Spite of Nonidentifiability. Proceedings of the National Academy of Sciences 120 (7): e2208851120. https://doi.org/10.1073/pnas.2208851120
</p>
</li>
<li><p> Andréoletti, J. &amp; Morlon, H. (2023). Exploring congruent diversification histories with flexibility and parsimony. Methods in Ecology and Evolution. https://doi.org/10.1111/2041-210X.14240
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Bjørn Tore Kopperud <a href="mailto:kopperud@protonmail.com">kopperud@protonmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Höhna
</p>
</li>
<li><p> Andrew F. Magee
</p>
</li>
<li><p> Jérémy Andréoletti
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/afmagee/CRABS">https://github.com/afmagee/CRABS</a>
</p>
</li></ul>


<hr>
<h2 id='crabs.loglikelihood'>Compute likelihood</h2><span id='topic+crabs.loglikelihood'></span>

<h3>Description</h3>

<p>Compute likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crabs.loglikelihood(phy, model, rho = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crabs.loglikelihood_+3A_phy">phy</code></td>
<td>
<p>an object of class &quot;phylo&quot;</p>
</td></tr>
<tr><td><code id="crabs.loglikelihood_+3A_model">model</code></td>
<td>
<p>an object of class &quot;CRABS&quot;</p>
</td></tr>
<tr><td><code id="crabs.loglikelihood_+3A_rho">rho</code></td>
<td>
<p>the taxon sampling fraction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log-likelihood of the tree given the model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ape)
lambda &lt;- function(t) exp(0.3*t) - 0.5*t
mu &lt;- function(t) exp(0.3*t) - 0.2*t - 0.8
 
model &lt;- create.model(lambda, mu, times = seq(0, 3, by = 0.005))

set.seed(123)
phy &lt;- rcoal(25)

crabs.loglikelihood(phy, model)
</code></pre>

<hr>
<h2 id='create.model'>Computes the congruent class, i.e., the pulled rates.</h2><span id='topic+create.model'></span>

<h3>Description</h3>

<p>Computes the congruent class, i.e., the pulled rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.model(
  func_spec0,
  func_ext0,
  times = seq(from = 0, to = 5, by = 0.005),
  func_p_spec = NULL,
  func_p_div = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.model_+3A_func_spec0">func_spec0</code></td>
<td>
<p>The speciation rate function (measured in time before present).</p>
</td></tr>
<tr><td><code id="create.model_+3A_func_ext0">func_ext0</code></td>
<td>
<p>The extinction rate function (measured in time before present).</p>
</td></tr>
<tr><td><code id="create.model_+3A_times">times</code></td>
<td>
<p>the time knots for the piecewise-linear rate functions</p>
</td></tr>
<tr><td><code id="create.model_+3A_func_p_spec">func_p_spec</code></td>
<td>
<p>the pulled speciation rate function</p>
</td></tr>
<tr><td><code id="create.model_+3A_func_p_div">func_p_div</code></td>
<td>
<p>the pulled net-diversification rate function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of rate functions representing this congruence class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda1 &lt;- function(t) exp(0.3*t) - 0.5*t + 1
mu1 &lt;- function(t) exp(0.3*t) - 0.2*t + 0.2

model1 &lt;- create.model(lambda1, mu1, times = seq(0, 5, by = 0.005))

model1

data("primates_ebd")

lambda2 &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["lambda"]])
mu2 &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["mu"]])
model2 &lt;- create.model(lambda2, mu2, primates_ebd[["time"]])

model2
</code></pre>

<hr>
<h2 id='full.plot.regularity.thresholds'>Plots the rate functions after filtering them according to a given penalty and predefined thresholds.</h2><span id='topic+full.plot.regularity.thresholds'></span>

<h3>Description</h3>

<p>Plots the rate functions after filtering them according to a given penalty and predefined thresholds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full.plot.regularity.thresholds(
  samples,
  filtering_fractions = c(0.01, 0.05, 0.2, 0.9),
  penalty = "L1",
  rates = c("lambda", "mu")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full.plot.regularity.thresholds_+3A_samples">samples</code></td>
<td>
<p>A list of (congruent) CRABS models</p>
</td></tr>
<tr><td><code id="full.plot.regularity.thresholds_+3A_filtering_fractions">filtering_fractions</code></td>
<td>
<p>A vector of thresholds for filtering, as fractions of the most regular trajectories.</p>
</td></tr>
<tr><td><code id="full.plot.regularity.thresholds_+3A_penalty">penalty</code></td>
<td>
<p>The choice of penalty, among &quot;L1&quot;, &quot;L2&quot; and &quot;L1_derivative&quot; (penalty on derivative shifts).</p>
</td></tr>
<tr><td><code id="full.plot.regularity.thresholds_+3A_rates">rates</code></td>
<td>
<p>A vector of rate(s) to be plotted, among &quot;lambda&quot; (speciation), &quot;mu&quot; (extinction), &quot;delta&quot; (net-diversification) and &quot;epsilon&quot; (turnover).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots an array of rate trajectories for the chosen rates and thresholds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("primates_ebd")
set.seed(123)

l &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["lambda"]])
mu &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["mu"]])
times &lt;- primates_ebd[["time"]]

model &lt;- create.model(l, mu, times)

sample.joint.rates &lt;- function(n) {
  sample.basic.models.joint(times = times, 
                            p.delta = model$p.delta,  
                            beta.param = c(0.5,0.3),  
                            lambda0 = l(0.0),  
                            mu0.median = mu(0.0))
}

joint.samples &lt;- sample.congruence.class(model = model, 
                                         num.samples = 100, 
                                         rate.type = "joint", 
                                         sample.joint.rates = sample.joint.rates)

full.plot.regularity.thresholds(joint.samples)
</code></pre>

<hr>
<h2 id='get.gmrf.global.scale'>Global scale for GMRF using linear interpolation of pre-computed values</h2><span id='topic+get.gmrf.global.scale'></span>

<h3>Description</h3>

<p>Global scale for GMRF using linear interpolation of pre-computed values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.gmrf.global.scale(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.gmrf.global.scale_+3A_v">v</code></td>
<td>
<p>The number of pieces in the approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Global scale
</p>

<hr>
<h2 id='get.hsmrf.global.scale'>Global scale for HSMRF using linear interpolation of pre-computed values</h2><span id='topic+get.hsmrf.global.scale'></span>

<h3>Description</h3>

<p>Global scale for HSMRF using linear interpolation of pre-computed values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.hsmrf.global.scale(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.hsmrf.global.scale_+3A_v">v</code></td>
<td>
<p>The number of pieces in the approximation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Global scale
</p>

<hr>
<h2 id='joint.congruent.models'>Create a set of congruent models</h2><span id='topic+joint.congruent.models'></span>

<h3>Description</h3>

<p>Create a set of congruent models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint.congruent.models(model, mus, lambdas, keep_ref = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="joint.congruent.models_+3A_model">model</code></td>
<td>
<p>The reference model. An object of class &quot;CRABS&quot;</p>
</td></tr>
<tr><td><code id="joint.congruent.models_+3A_mus">mus</code></td>
<td>
<p>A list of extinction-rate functions</p>
</td></tr>
<tr><td><code id="joint.congruent.models_+3A_lambdas">lambdas</code></td>
<td>
<p>A list of speciation-rate functions</p>
</td></tr>
<tr><td><code id="joint.congruent.models_+3A_keep_ref">keep_ref</code></td>
<td>
<p>Whether or not to keep the reference model in the congruent set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;CRABSset&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This function should not have to be used externally.
# It is called in the CRABS function `sample.congruence.class` when `rate.type=="joint"`.
</code></pre>

<hr>
<h2 id='model2df'>model2df</h2><span id='topic+model2df'></span>

<h3>Description</h3>

<p>model2df
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model2df(model, gather = TRUE, rho = 1, compute.pulled.rates = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model2df_+3A_model">model</code></td>
<td>
<p>an object of class &quot;CRABS&quot;</p>
</td></tr>
<tr><td><code id="model2df_+3A_gather">gather</code></td>
<td>
<p>boolean. Whether to return wide or long data frame</p>
</td></tr>
<tr><td><code id="model2df_+3A_rho">rho</code></td>
<td>
<p>the sampling fraction at the present. Used to calculate the pulled speciation rate</p>
</td></tr>
<tr><td><code id="model2df_+3A_compute.pulled.rates">compute.pulled.rates</code></td>
<td>
<p>whether to compute the pulled rates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda &lt;- function(t) 2.0 + sin(0.8*t)
mu &lt;- function(t) 1.5 + exp(0.15*t)
times &lt;- seq(from = 0, to = 4, length.out = 1000)
model &lt;- create.model( lambda, mu, times = times)

model2df(model)
</code></pre>

<hr>
<h2 id='plot.CRABS'>Plots the rate functions including the pulled rates.</h2><span id='topic+plot.CRABS'></span>

<h3>Description</h3>

<p>Plots the rate functions including the pulled rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRABS'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CRABS_+3A_x">x</code></td>
<td>
<p>An object of class &quot;CRABS&quot;</p>
</td></tr>
<tr><td><code id="plot.CRABS_+3A_...">...</code></td>
<td>
<p>other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a patchwork object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates_ebd)
lambda &lt;- approxfun(primates_ebd$time, primates_ebd$lambda)
mu &lt;- approxfun(primates_ebd$time, primates_ebd$mu)
times &lt;- seq(0, max(primates_ebd$time), length.out = 500)

model &lt;- create.model(lambda, mu, times = times)

plot(model)
</code></pre>

<hr>
<h2 id='plot.CRABSset'>Plots the rate functions</h2><span id='topic+plot.CRABSset'></span>

<h3>Description</h3>

<p>Plots the rate functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRABSset'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CRABSset_+3A_x">x</code></td>
<td>
<p>A list of congruent birth-death x</p>
</td></tr>
<tr><td><code id="plot.CRABSset_+3A_...">...</code></td>
<td>
<p>other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a patchwork object object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd)
lambda &lt;- approxfun(primates_ebd$time, primates_ebd$lambda)
mu &lt;- approxfun(primates_ebd$time, primates_ebd$mu)
times &lt;- seq(0, max(primates_ebd$time), length.out = 500)

model &lt;- create.model(lambda, mu, times = times)

mus &lt;- list(function(t) 0.2 + exp(0.01*t), 
           function(t) 0.2 + sin(0.35*t) + 0.1*t,
           function(t) 1.0, 
           function(t) 0.5 + 0.2*t)
models &lt;- congruent.models(model, mus = mus)

plot(models)
</code></pre>

<hr>
<h2 id='primates'>Primates phylogenetic tree</h2><span id='topic+primates'></span>

<h3>Description</h3>

<p>The example tree taken from the RevBayes tutorial website
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(primates)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>phylo</code> of length 5.
</p>

<hr>
<h2 id='primates_ebd'>RevBayes Primates birth-death model</h2><span id='topic+primates_ebd'></span>

<h3>Description</h3>

<p>The results of a bayesian horseshoe markov random field (HSMRF) episodic birth-death model, fitted on the primates tree. One hundred episodes. Each estimate is the posterior median. The time unit is millions of years before the present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(primates_ebd)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 100 rows and 3 columns.
</p>

<hr>
<h2 id='primates_ebd_log'>Primates birth-death model</h2><span id='topic+primates_ebd_log'></span>

<h3>Description</h3>

<p>See <code>?primates_ebd</code>, but including posterior samples instead of a summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(primates_ebd_log)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 251 rows and 604 columns.
</p>

<hr>
<h2 id='primates_ebd_tess'>TESS Primates birth-death model</h2><span id='topic+primates_ebd_tess'></span>

<h3>Description</h3>

<p>The results of a bayesian episodic birth-death model in the R-package TESS, fitted on the primates tree. One hundred episodes. Each estimate is the posterior median. The time unit is millions of years before the present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(primates_ebd_tess)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 100 rows and 3 columns.
</p>

<hr>
<h2 id='primates_ebd_treepar'>TreePar Primates birth-death model</h2><span id='topic+primates_ebd_treepar'></span>

<h3>Description</h3>

<p>The results of a birth-death model in the R-package TreePar, fitted on the primates tree. The estimated model has two epochs, that are maximum-likelihood estimates. The time unit is millions of years before the present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(primates_ebd_treepar)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 100 rows and 3 columns.
</p>

<hr>
<h2 id='print.CRABS'>Print method for CRABS object</h2><span id='topic+print.CRABS'></span>

<h3>Description</h3>

<p>Print method for CRABS object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRABS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CRABS_+3A_x">x</code></td>
<td>
<p>and object of class CRABS</p>
</td></tr>
<tr><td><code id="print.CRABS_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd)
lambda &lt;- approxfun(primates_ebd$time, primates_ebd$lambda)
mu &lt;- approxfun(primates_ebd$time, primates_ebd$mu)
times &lt;- seq(0, max(primates_ebd$time), length.out = 500)

model &lt;- create.model(lambda, mu, times = times)

print(model)
</code></pre>

<hr>
<h2 id='print.CRABSposterior'>Title</h2><span id='topic+print.CRABSposterior'></span>

<h3>Description</h3>

<p>Title
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRABSposterior'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CRABSposterior_+3A_x">x</code></td>
<td>
<p>a list of CRABS objects</p>
</td></tr>
<tr><td><code id="print.CRABSposterior_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd_log)
posterior &lt;- read.RevBayes(primates_ebd_log, max_t = 65, n_samples = 20)
print(posterior)
</code></pre>

<hr>
<h2 id='print.CRABSset'>Print method for CRABSset object</h2><span id='topic+print.CRABSset'></span>

<h3>Description</h3>

<p>Print method for CRABSset object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRABSset'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CRABSset_+3A_x">x</code></td>
<td>
<p>an object of class CRABSset</p>
</td></tr>
<tr><td><code id="print.CRABSset_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd)
lambda &lt;- approxfun(primates_ebd$time, primates_ebd$lambda)
mu &lt;- approxfun(primates_ebd$time, primates_ebd$mu)
times &lt;- seq(0, max(primates_ebd$time), length.out = 500)

model &lt;- create.model(lambda, mu, times = times)

mus &lt;- list(function(t) 0.2 + exp(0.01*t), 
           function(t) 0.2 + sin(0.35*t) + 0.1*t,
           function(t) 1.0, 
           function(t) 0.5 + 0.2*t)
models &lt;- congruent.models(model, mus = mus)

print(models)
</code></pre>

<hr>
<h2 id='print.CRABSsets'>print.CRABSsets</h2><span id='topic+print.CRABSsets'></span>

<h3>Description</h3>

<p>print.CRABSsets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CRABSsets'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CRABSsets_+3A_x">x</code></td>
<td>
<p>a list of (congruent) CRABS sets</p>
</td></tr>
<tr><td><code id="print.CRABSsets_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd_log)

posterior &lt;- read.RevBayes(primates_ebd_log, max_t = 65, n_samples = 10)

samples &lt;- sample.congruence.class.posterior(posterior, 
                                             num.samples = 5,
                                             rate.type = "extinction",
                                             rate0.median = 0.1,
                                             model = "MRF",
                                             max.rate = 1.0)
                                             
print(samples)
</code></pre>

<hr>
<h2 id='read.RevBayes'>read RevBayes log file</h2><span id='topic+read.RevBayes'></span>

<h3>Description</h3>

<p>read RevBayes log file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.RevBayes(x, n_times, max_t = 100, n_samples = 20, summary_type = "none", 
extinction_prefix = "extinction_rate.", speciation_prefix = "speciation_rate.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.RevBayes_+3A_x">x</code></td>
<td>
<p>path to log, or data frame</p>
</td></tr>
<tr><td><code id="read.RevBayes_+3A_n_times">n_times</code></td>
<td>
<p>number of time knots</p>
</td></tr>
<tr><td><code id="read.RevBayes_+3A_max_t">max_t</code></td>
<td>
<p>tree height</p>
</td></tr>
<tr><td><code id="read.RevBayes_+3A_n_samples">n_samples</code></td>
<td>
<p>first n posterior samples</p>
</td></tr>
<tr><td><code id="read.RevBayes_+3A_summary_type">summary_type</code></td>
<td>
<p>either &quot;none&quot; for all the posterior samples, or &quot;mean&quot; or &quot;median&quot; for the posterior mean/median</p>
</td></tr>
<tr><td><code id="read.RevBayes_+3A_extinction_prefix">extinction_prefix</code></td>
<td>
<p>the prefix string for the extinction rate column names. Must be unique</p>
</td></tr>
<tr><td><code id="read.RevBayes_+3A_speciation_prefix">speciation_prefix</code></td>
<td>
<p>the prefix string for the speciation rate column names. Must be unique</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a set of CRABS models, each being a sample in the posterior
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd_log)
posterior &lt;- read.RevBayes(primates_ebd_log, n_times = 500, max_t = 65, n_samples = 20)
</code></pre>

<hr>
<h2 id='sample.basic.models'>Samples simple increase/decrease models through time with noise.</h2><span id='topic+sample.basic.models'></span>

<h3>Description</h3>

<p>Samples simple increase/decrease models through time with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.basic.models(
  times,
  rate0 = NULL,
  model = "exponential",
  direction = "decrease",
  noisy = TRUE,
  MRF.type = "HSMRF",
  monotonic = FALSE,
  fc.mean = 3,
  rate0.median = 0.1,
  rate0.logsd = 1.17481,
  mrf.sd.scale = 1,
  min.rate = 0,
  max.rate = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.basic.models_+3A_times">times</code></td>
<td>
<p>the time knots</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_rate0">rate0</code></td>
<td>
<p>The rate at present, otherwise drawn randomly.</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_model">model</code></td>
<td>
<p>&quot;MRF&quot; for pure MRF model, otherwise MRF has a trend of type &quot;exponential&quot;,&quot;linear&quot;, or &quot;episodic&lt;n&gt;&quot;</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_direction">direction</code></td>
<td>
<p>&quot;increase&quot; or &quot;decrease&quot; (measured in past to present)</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_noisy">noisy</code></td>
<td>
<p>If FALSE, no MRF noise is added to the trajectory</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_mrf.type">MRF.type</code></td>
<td>
<p>&quot;HSMRF&quot; or &quot;GMRF&quot;, type for stochastic noise.</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_monotonic">monotonic</code></td>
<td>
<p>Whether the curve should be forced to always move in one direction.</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_fc.mean">fc.mean</code></td>
<td>
<p>Determines the average amount of change when drawing from the model.</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_rate0.median">rate0.median</code></td>
<td>
<p>When not specified, rate at present is drawn from a lognormal distribution with this median.</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_rate0.logsd">rate0.logsd</code></td>
<td>
<p>When not specified, rate at present is drawn from a lognormal distribution with this sd</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_mrf.sd.scale">mrf.sd.scale</code></td>
<td>
<p>scale the sd of the mrf process up or down. defaults to 1.0</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_min.rate">min.rate</code></td>
<td>
<p>The minimum rate (rescaling fone after after drawing rates).</p>
</td></tr>
<tr><td><code id="sample.basic.models_+3A_max.rate">max.rate</code></td>
<td>
<p>The maximum rate (rescaling fone after after drawing rates).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Speciation or extinction rate at a number of timepoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("primates_ebd")

l &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["lambda"]])
mu &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["mu"]])
times &lt;- primates_ebd[["time"]]

model &lt;- create.model(l, mu, times)

mus &lt;- sample.basic.models(times = times, 
                               rate0 = 0.05, 
                               "MRF", 
                               MRF.type = "HSMRF", 
                               fc.mean = 2.0, 
                               min.rate = 0.0, 
                               max.rate = 1.0)

model_set &lt;- congruent.models(model, mus = mus)

model_set
</code></pre>

<hr>
<h2 id='sample.basic.models.joint'>Jointly samples speciation and extinction trajectories through time, with noise.</h2><span id='topic+sample.basic.models.joint'></span>

<h3>Description</h3>

<p>Jointly samples speciation and extinction trajectories through time, with noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.basic.models.joint(
  times,
  p.delta,
  lambda0,
  mu0 = NULL,
  MRF.type = "HSMRF",
  beta.param = c(0.3, 0.3),
  mu0.median = 0.1,
  mu0.logsd = 1.17481,
  mrf.sd.scale = 1,
  min.lambda = 0,
  min.mu = 0,
  max.lambda = 10,
  max.mu = 10,
  min.p = -0.05,
  max.p = 1.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.basic.models.joint_+3A_times">times</code></td>
<td>
<p>the time knots</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_p.delta">p.delta</code></td>
<td>
<p>The The pulled diversification rate function (measured in time before present).</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_lambda0">lambda0</code></td>
<td>
<p>The speciation rate at present.</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_mu0">mu0</code></td>
<td>
<p>The extinction rate at present, otherwise drawn randomly.</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_mrf.type">MRF.type</code></td>
<td>
<p>&quot;HSMRF&quot; or &quot;GMRF&quot;, type for stochastic noise.</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_beta.param">beta.param</code></td>
<td>
<p>Parameters of the Beta distribution used for</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_mu0.median">mu0.median</code></td>
<td>
<p>When not specified, extinction rate at present is drawn from a lognormal distribution with this median.</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_mu0.logsd">mu0.logsd</code></td>
<td>
<p>When not specified, extinction rate at present is drawn from a lognormal distribution with this sd</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_mrf.sd.scale">mrf.sd.scale</code></td>
<td>
<p>scale the sd of the mrf process up or down. defaults to 1.0</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_min.lambda">min.lambda</code></td>
<td>
<p>The minimum speciation rate (rescaling done after after drawing rates).</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_min.mu">min.mu</code></td>
<td>
<p>The minimum extinction rate (rescaling done after after drawing rates).</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_max.lambda">max.lambda</code></td>
<td>
<p>The maximum speciation rate (rescaling done after after drawing rates).</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_max.mu">max.mu</code></td>
<td>
<p>The maximum extinction rate (rescaling done after after drawing rates).</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_min.p">min.p</code></td>
<td>
<p>The lower bound of parameter p's trajectory.</p>
</td></tr>
<tr><td><code id="sample.basic.models.joint_+3A_max.p">max.p</code></td>
<td>
<p>The upper bound of parameter p's trajectory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Speciation or extinction rate at a number of timepoints.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("primates_ebd")

l &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["lambda"]])
mu &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["mu"]])
times &lt;- primates_ebd[["time"]]

model &lt;- create.model(l, mu, times)

sample.joint.rates &lt;- function(n) {
  sample.basic.models.joint(times = times, 
                            p.delta = model$p.delta,  
                            beta.param = c(0.5,0.3),  
                            lambda0 = l(0.0),  
                            mu0.median = mu(0.0))
}

joint.samples &lt;- sample.congruence.class(model = model, 
                                         num.samples = 40, 
                                         rate.type = "joint", 
                                         sample.joint.rates = sample.joint.rates)

joint.samples
</code></pre>

<hr>
<h2 id='sample.congruence.class'>Stochastic exploration of congruent models.</h2><span id='topic+sample.congruence.class'></span>

<h3>Description</h3>

<p>Stochastic exploration of congruent models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.congruence.class(
  model,
  num.samples,
  rate.type = "both",
  sample.speciation.rates = NULL,
  sample.extinction.rates = NULL,
  sample.joint.rates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.congruence.class_+3A_model">model</code></td>
<td>
<p>the reference model, an object of class &quot;CRABS&quot;</p>
</td></tr>
<tr><td><code id="sample.congruence.class_+3A_num.samples">num.samples</code></td>
<td>
<p>The number of samples to be drawn</p>
</td></tr>
<tr><td><code id="sample.congruence.class_+3A_rate.type">rate.type</code></td>
<td>
<p>either &quot;extinction&quot;, &quot;speciation&quot;, &quot;both&quot; or &quot;joint&quot;</p>
</td></tr>
<tr><td><code id="sample.congruence.class_+3A_sample.speciation.rates">sample.speciation.rates</code></td>
<td>
<p>a function that when called returns a speciation rate function</p>
</td></tr>
<tr><td><code id="sample.congruence.class_+3A_sample.extinction.rates">sample.extinction.rates</code></td>
<td>
<p>a function that when called returns a extinction rate function</p>
</td></tr>
<tr><td><code id="sample.congruence.class_+3A_sample.joint.rates">sample.joint.rates</code></td>
<td>
<p>a function that when called returns a list with a speciation rate function and an extinction rate function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with congruent rates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("primates_ebd")

l &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["lambda"]])
mu &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["mu"]])
times &lt;- primates_ebd[["time"]]

model &lt;- create.model(l, mu, primates_ebd[["time"]])

# Sampling extinction rates

extinction_rate_samples &lt;- function(){
   res &lt;- sample.basic.models(times = times, 
                              rate0 = 0.05, 
                              model = "MRF", 
                              MRF.type = "HSMRF", 
                              fc.mean = 2.0, 
                              min.rate = 0.0, 
                              max.rate = 1.0)
   return(res)
} 

samples &lt;- sample.congruence.class(model, 
                                   num.samples = 8,
                                   rate.type = "extinction",
                                   sample.extinction.rates = extinction_rate_samples)

samples

# Jointly sampling speciation and extinction rates

sample.joint.rates &lt;- function(n) {
  sample.basic.models.joint(times = times, 
                            p.delta = model$p.delta,  
                            beta.param = c(0.5,0.3),  
                            lambda0 = l(0.0),  
                            mu0.median = mu(0.0))
}

joint.samples &lt;- sample.congruence.class(model = model, 
                                         num.samples = 40, 
                                         rate.type = "joint", 
                                         sample.joint.rates = sample.joint.rates)

joint.samples
</code></pre>

<hr>
<h2 id='sample.congruence.class.posterior'>Stochastic exploration of congruent models for all samples in the posterior</h2><span id='topic+sample.congruence.class.posterior'></span>

<h3>Description</h3>

<p>This function takes a posterior sample as input: a list of CRABS objects. 
It will then iterate over the samples, and for each posterior sample it will
sample from the posterior class. It will sample using the <code><a href="#topic+sample.basic.models">sample.basic.models</a></code>
function, and all additional parameters are passed to <code><a href="#topic+sample.basic.models">sample.basic.models</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.congruence.class.posterior(
  posterior,
  num.samples,
  rate.type = "extinction",
  mu0.equal = FALSE,
  rate0 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.congruence.class.posterior_+3A_posterior">posterior</code></td>
<td>
<p>a list of CRABS model objects</p>
</td></tr>
<tr><td><code id="sample.congruence.class.posterior_+3A_num.samples">num.samples</code></td>
<td>
<p>The number of samples to be drawn</p>
</td></tr>
<tr><td><code id="sample.congruence.class.posterior_+3A_rate.type">rate.type</code></td>
<td>
<p>either &quot;extinction&quot;, &quot;speciation&quot;, &quot;both&quot; or &quot;joint&quot;</p>
</td></tr>
<tr><td><code id="sample.congruence.class.posterior_+3A_mu0.equal">mu0.equal</code></td>
<td>
<p>whether to propose alternative mu starting at mu0 equal to the posterior sample. default to FALSE</p>
</td></tr>
<tr><td><code id="sample.congruence.class.posterior_+3A_rate0">rate0</code></td>
<td>
<p>rate0 allows the user to fix the extinction rate at the present to a single value. defaults to NULL, for drawing it randomly</p>
</td></tr>
<tr><td><code id="sample.congruence.class.posterior_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+sample.basic.models">sample.basic.models</a></code>
</p>

<dl>
<dt><code>times</code></dt><dd><p>the time knots</p>
</dd>
<dt><code>model</code></dt><dd><p>&quot;MRF&quot; for pure MRF model, otherwise MRF has a trend of type &quot;exponential&quot;,&quot;linear&quot;, or &quot;episodic&lt;n&gt;&quot;</p>
</dd>
<dt><code>direction</code></dt><dd><p>&quot;increase&quot; or &quot;decrease&quot; (measured in past to present)</p>
</dd>
<dt><code>noisy</code></dt><dd><p>If FALSE, no MRF noise is added to the trajectory</p>
</dd>
<dt><code>MRF.type</code></dt><dd><p>&quot;HSMRF&quot; or &quot;GMRF&quot;, type for stochastic noise.</p>
</dd>
<dt><code>monotonic</code></dt><dd><p>Whether the curve should be forced to always move in one direction.</p>
</dd>
<dt><code>fc.mean</code></dt><dd><p>Determines the average amount of change when drawing from the model.</p>
</dd>
<dt><code>rate0.median</code></dt><dd><p>When not specified, rate at present is drawn from a lognormal distribution with this median.</p>
</dd>
<dt><code>rate0.logsd</code></dt><dd><p>When not specified, rate at present is drawn from a lognormal distribution with this sd</p>
</dd>
<dt><code>mrf.sd.scale</code></dt><dd><p>scale the sd of the mrf process up or down. defaults to 1.0</p>
</dd>
<dt><code>min.rate</code></dt><dd><p>The minimum rate (rescaling fone after after drawing rates).</p>
</dd>
<dt><code>max.rate</code></dt><dd><p>The maximum rate (rescaling fone after after drawing rates).</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with congruent rates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd_log)

posterior &lt;- read.RevBayes(primates_ebd_log, max_t = 65, n_samples = 10)

samples &lt;- sample.congruence.class.posterior(posterior, 
                                             num.samples = 5,
                                             rate.type = "extinction",
                                             rate0.median = 0.1,
                                             model = "MRF",
                                             max.rate = 1.0)

print(samples)
</code></pre>

<hr>
<h2 id='sample.rates'>Sample custom functions through time.</h2><span id='topic+sample.rates'></span>

<h3>Description</h3>

<p>Sample custom functions through time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.rates(
  times,
  lambda0 = NULL,
  rsample = NULL,
  rsample0 = NULL,
  autocorrelated = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.rates_+3A_times">times</code></td>
<td>
<p>the time knots</p>
</td></tr>
<tr><td><code id="sample.rates_+3A_lambda0">lambda0</code></td>
<td>
<p>The rate at present</p>
</td></tr>
<tr><td><code id="sample.rates_+3A_rsample">rsample</code></td>
<td>
<p>Function to sample next rate</p>
</td></tr>
<tr><td><code id="sample.rates_+3A_rsample0">rsample0</code></td>
<td>
<p>Function to sample rate at present</p>
</td></tr>
<tr><td><code id="sample.rates_+3A_autocorrelated">autocorrelated</code></td>
<td>
<p>Should rates be autocorrelated?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sampled rate vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("primates_ebd")

l &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["lambda"]])
mu &lt;- approxfun(primates_ebd[["time"]], primates_ebd[["mu"]])
times &lt;- primates_ebd[["time"]]

model &lt;- create.model(l, mu, times)

rsample &lt;- function(n) runif(n, min = 0.0, max = 0.9)
mu &lt;- sample.rates(times, 0.5, rsample = rsample)


model_set &lt;- congruent.models(model, mus = mu)

model_set
</code></pre>

<hr>
<h2 id='summarize.posterior'>Summarize trends in the posterior</h2><span id='topic+summarize.posterior'></span>

<h3>Description</h3>

<p>Summarize trends in the posterior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize.posterior(posterior, threshold = 0.01, rate_name = "lambda", 
return_data = FALSE, rm_singleton = FALSE, per_time = TRUE, 
window_size = 1, relative_deltas = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize.posterior_+3A_posterior">posterior</code></td>
<td>
<p>a list of CRABS objects, each one representing a sample from the posterior</p>
</td></tr>
<tr><td><code id="summarize.posterior_+3A_threshold">threshold</code></td>
<td>
<p>a threshold for when <code class="reqn">\Delta \lambda i</code> should be interpreted as decreasing, flat, or increasing</p>
</td></tr>
<tr><td><code id="summarize.posterior_+3A_rate_name">rate_name</code></td>
<td>
<p>either &quot;lambda&quot; or &quot;mu&quot; or &quot;delta&quot;</p>
</td></tr>
<tr><td><code id="summarize.posterior_+3A_return_data">return_data</code></td>
<td>
<p>instead of plots, return the plotting dataframes</p>
</td></tr>
<tr><td><code id="summarize.posterior_+3A_rm_singleton">rm_singleton</code></td>
<td>
<p>whether or not to remove singletons. Pass starting at present, going towards ancient</p>
</td></tr>
<tr><td><code id="summarize.posterior_+3A_per_time">per_time</code></td>
<td>
<p>whether to compute <code class="reqn">\Delta\lambda i</code> that are in units of per time, i.e. divide by <code class="reqn">\Delta t</code></p>
</td></tr>
<tr><td><code id="summarize.posterior_+3A_window_size">window_size</code></td>
<td>
<p>the window size &quot;k&quot; in <code class="reqn">\Delta\lambda i = \lambda i - \lambda(i-k)</code></p>
</td></tr>
<tr><td><code id="summarize.posterior_+3A_relative_deltas">relative_deltas</code></td>
<td>
<p>whether to divide <code class="reqn">\Delta \lambda i</code> by the local lambda value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(primates_ebd_log)

posterior &lt;- read.RevBayes(primates_ebd_log, max_t = 65, n_samples = 10)

samples &lt;- sample.congruence.class.posterior(posterior, 
                                             num.samples = 5,
                                             rate.type = "extinction",
                                             rate0.median = 0.1,
                                             model = "MRF",
                                             max.rate = 1.0)

p &lt;- summarize.posterior(samples, threshold = 0.05)
</code></pre>

<hr>
<h2 id='summarize.trends'>Summarize trends in the congruence class</h2><span id='topic+summarize.trends'></span>

<h3>Description</h3>

<p>Summarize trends in the congruence class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize.trends(model_set, threshold = 0.005, rate_name = "lambda", 
window_size = 1, method = "neighbour", per_time = TRUE, return_data = FALSE,
rm_singleton = FALSE, relative_deltas = FALSE, group_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize.trends_+3A_model_set">model_set</code></td>
<td>
<p>an object of type &quot;CRABSset&quot;</p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_threshold">threshold</code></td>
<td>
<p>a threshold for when <code class="reqn">\Delta \lambda i</code> should be interpreted as decreasing, flat, or increasing</p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_rate_name">rate_name</code></td>
<td>
<p>either &quot;lambda&quot; or &quot;mu&quot; or &quot;delta&quot;</p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_window_size">window_size</code></td>
<td>
<p>the window size &quot;k&quot; in <code class="reqn">\Delta\lambda i = \lambda i - \lambda(i-k)</code></p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_method">method</code></td>
<td>
<p>default to &quot;neighbour&quot;, i.e. to compare rate values at neighbouring time points.</p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_per_time">per_time</code></td>
<td>
<p>whether to compute <code class="reqn">\Delta\lambda i</code> that are in units of per time, i.e. divide by <code class="reqn">\Delta t</code></p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_return_data">return_data</code></td>
<td>
<p>instead of plots, return the plotting dataframes</p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_rm_singleton">rm_singleton</code></td>
<td>
<p>whether or not to remove singletons. Pass starting at present, going towards ancient</p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_relative_deltas">relative_deltas</code></td>
<td>
<p>whether to divide <code class="reqn">\Delta \lambda i</code> by the local lambda value</p>
</td></tr>
<tr><td><code id="summarize.trends_+3A_group_names">group_names</code></td>
<td>
<p>a vector of prefixes, if you want to group the models in a facet. For example 'c(&quot;reference&quot;, &quot;model&quot;)'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a patchwork object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(primates_ebd)
lambda &lt;- approxfun(primates_ebd$time, primates_ebd$lambda)
mu &lt;- approxfun(primates_ebd$time, primates_ebd$mu)
times &lt;- seq(0, max(primates_ebd$time), length.out = 500)

reference &lt;- create.model(lambda, mu, times = times)

mus &lt;- list(function(t) exp(0.01*t) - 0.01*t - 0.9,
            function(t) exp(-0.02*t) - 0.2,
            function(t) exp(-0.07*t) + 0.02*t - 0.5,
            function(t) 0.2 + 0.01*t,
            function(t) 0.2)


model_set &lt;- congruent.models(reference, mus = mus)

p &lt;- summarize.trends(model_set, 0.02)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
