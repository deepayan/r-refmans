<!DOCTYPE html><html><head><title>Help for package RHawkes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RHawkes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#damllRH'>
<p>Dynamically approxomated minus loglikelihood of a RHawkes model</p></a></li>
<li><a href='#EM1partial'>
<p>Partial EM algorithm for the RHawkes process, version 1</p></a></li>
<li><a href='#EM2partial'>
<p>Partial EM algorithm for the RHawkes process, version 2</p></a></li>
<li><a href='#mllRH'>
<p>Minus loglikelihood of a RHawkes model</p></a></li>
<li><a href='#mllRH1'>
<p>Minus loglikelihood of a RHawkes model with parent probabilities</p></a></li>
<li><a href='#mllRH2'>
<p>Minus loglikelihood of a RHawkes model with Rosenblatt residuals</p></a></li>
<li><a href='#pred.den'>
<p>RHawkes predictive density function</p></a></li>
<li><a href='#pred.haz'>
<p>RHawkes predictive hazard function</p></a></li>
<li><a href='#quake'>
<p>An RHawkes earthquake data set</p></a></li>
<li><a href='#RHawkes-package'>
<p>Renewal Hawkes Process</p></a></li>
<li><a href='#sim.pred'>
<p>Simulate a fitted RHawkes process model</p></a></li>
<li><a href='#sim.pred1'>
<p>Simulate a fitted RHawkes process model for prediction purposes</p></a></li>
<li><a href='#simRHawkes'>
<p>Simulate a renewal Hawkes (RHawkes) process</p></a></li>
<li><a href='#simRHawkes1'>
<p>Simulate a renewal Hawkes (RHawkes) process</p></a></li>
<li><a href='#tms'>
<p>mid-price change times of the AUD/USD exchange rate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Renewal Hawkes Process</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-5-4</td>
</tr>
<tr>
<td>Description:</td>
<td>The renewal Hawkes (RHawkes) process (Wheatley,
    Filimonov, and Sornette, 2016 &lt;<a href="https://doi.org/10.1016%2Fj.csda.2015.08.007">doi:10.1016/j.csda.2015.08.007</a>&gt;) is
    an extension to the classical Hawkes self-exciting point process
    widely used in the modelling of clustered event sequence data.
    This package provides functions to simulate the RHawkes process
    with a given immigrant hazard rate function and offspring birth
    time density function, to compute the exact likelihood of a
    RHawkes process using the recursive algorithm proposed by Chen and
    Stindl (2018) &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1341324">doi:10.1080/10618600.2017.1341324</a>&gt;, to compute the
    Rosenblatt residuals for goodness-of-fit assessment, and to
    predict future event times based on observed event times up to a
    given time. A function implementing the linear time RHawkes
    process likelihood approximation algorithm proposed in Stindl and
    Chen (2021) &lt;<a href="https://doi.org/10.1007%2Fs11222-021-10002-0">doi:10.1007/s11222-021-10002-0</a>&gt; is also included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), IHSEP</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-04 13:17:53 UTC; z3243864</td>
</tr>
<tr>
<td>Author:</td>
<td>Feng Chen <a href="https://orcid.org/0000-0002-9646-3338"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Tom Stindl <a href="https://orcid.org/0000-0001-8627-9337"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-05 14:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='damllRH'>
Dynamically approxomated minus loglikelihood of a RHawkes model
</h2><span id='topic+damllRH'></span>

<h3>Description</h3>

<p> Calculates an apprximation to the minus loglikelihood of a
RHawkes model with given immigration hazard function <code class="reqn">\mu</code>,
offspring birth time density function <code class="reqn">h</code> and branching ratio
<code class="reqn">\eta</code> relative to event times <code>tms</code> on interval <code class="reqn">[0,cens]</code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>damllRH(tms, cens, par, q=0.999, qe=0.999,
      h.fn = function(x, p) dexp(x, rate = 1 / p), 
      mu.fn = function(x, p) {
        exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
        pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
      }, 
      H.fn = function(x, p) pexp(x, rate = 1 / p), 
      Mu.fn = function(x, p) {
        -pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
      },
      keepB=FALSE,
      H.inv=function(x,p)qexp(x,rate=1/p) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="damllRH_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_cens">cens</code></td>
<td>

<p>A numericl scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_par">par</code></td>
<td>

<p>A numeric vector containing the parameters of the model,
in order of the immigration parameters, in <code class="reqn">\mu(.)</code>, offspring
distribution parameters, in <code class="reqn">h(.)</code>, and lastly the branching ratio
<code class="reqn">\eta(.)</code>.  </p>
</td></tr>
<tr><td><code id="damllRH_+3A_q">q</code></td>
<td>

<p>A numeric scalar in (0,1] and close to 1, which controls how far
we look back when truncating the distribution of the most recent immigrant. 
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_qe">qe</code></td>
<td>

<p>A numeric scalar in (0,1] and close to 1, which controls how to
truncation is used in the offspring birth time distribution.
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_h.fn">h.fn</code></td>
<td>
<p> A (vectorized) function. The offspring birth time density
function.
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigrant waiting time hazard function. 
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring birth time density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant waiting time hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_keepb">keepB</code></td>
<td>
<p> A boolean scalar, indicating whether the looking back
values <code>B_i</code> should be part of the output or not.
</p>
</td></tr>
<tr><td><code id="damllRH_+3A_h.inv">H.inv</code></td>
<td>

<p>A (vectorized) function, giving the inverse function of the integral
of the excitation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A scalar giving the value of the (approximate) negative
log-likelihood, when <code>keepB</code> is FALSE (the default); A list with
components <code>mll</code>, whhich contains the value of the negative
log-likelihood, <code>Bs</code>, which gives the look-back order of the
truncation of the distribution of the last immigrant, and <code>Bes</code>,
which gives the look-forward order in determining how far into the
future the excitation effect is allowed to last.
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## earthquake times over 96 years
data(quake);
tms &lt;- sort(quake$time);
# add some random noise to the simultaneous occurring event times
tms[213:214] &lt;- tms[213:214] + 
                    sort(c(runif(1, -1, 1)/(24*60), runif(1, -1, 1)/(24*60)))


## calculate the minus loglikelihood of an RHawkes with some parameters 
## the default hazard function and density functions are Weibull and 
## exponential respectively
mllRH(tms, cens = 96*365.25 , par = c(0.5, 20, 1000, 0.5))
damllRH(tms, cens = 96*365.25 , par = c(0.5, 20, 1000, 0.5),q=1,qe=1)
## calculate the MLE for the parameter assuming known parametric forms
## of the immigrant hazard function and offspring density functions.  
system.time(est &lt;- optim(c(0.5, 20, 1000, 0.5), 
                        mllRH, tms = tms, cens = 96*365.25,
                        mu.fn=function(x,p)p[1]/p[2]*(x/p[2])^(p[1]-1),
                        Mu.fn=function(x,p)(x/p[2])^p[1],
                        control = list(maxit = 5000, trace = TRUE),
                        hessian = TRUE)
            )
system.time(est1 &lt;- optim(c(0.5, 20, 1000, 0.5), 
                        function(p){
                            if(any(p&lt;0)||p[4]&lt;0||p[4]&gt;=1)
                                return(Inf);
                            damllRH(tms = tms, cens = 96*365.25,
                                    mu.fn=function(x,p)p[1]/p[2]*(x/p[2])^(p[1]-1),
                                    Mu.fn=function(x,p)(x/p[2])^p[1],
                                    par=p,q=0.999999,qe=0.999999)
                        },
                        control = list(maxit = 5000, trace = TRUE),
                        hessian = TRUE)
            )
## point estimate by MLE
est$par
est1$par
## standard error estimates:
diag(solve(est$hessian))^0.5
diag(solve(est1$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='EM1partial'>
Partial EM algorithm for the RHawkes process, version 1
</h2><span id='topic+EM1partial'></span>

<h3>Description</h3>

<p>Calculates the RHawkes model parameters via a partial Expectation-Maximization 
(EM1) algorithm of Wheatley, Filimonov and Sornette (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EM1partial(tms, cens, pars, maxiter = 1000, tol = 1e-8,
         h.fn = function(x, p) dexp(x, rate = 1 / p),
         mu.fn = function(x, p){
              exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
              pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
         },
         H.fn = function(x, p) pexp(x, rate = 1 / p),
         logg.fn = function(x, p){
              dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
              pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE) 
              - (x / p[2])^p[1]},
         Mu.fn = function(x, p){
              - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
         })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM1partial_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_pars">pars</code></td>
<td>

<p>A numeric vector containing the parameters of the model, in order of the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and 
lastly the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_maxiter">maxiter</code></td>
<td>

<p>The maximum number of iterations to perform.
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_tol">tol</code></td>
<td>

<p>The algorithm stops when the difference between the previous iteration and 
current iteration parameters sum is less than <code>tol</code>.
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="EM1partial_+3A_logg.fn">logg.fn</code></td>
<td>

<p>A (vectorized) function. The log of the immigrant distribution function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>iterations</code></td>
<td>
<p>The number of iterations until convergence</p>
</td></tr>
<tr><td><code>diff</code></td>
<td>
<p>The absolute sum of the difference between the final two 
parameter estimates</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>The parameter estimates from the EM algorithm</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulated data
tms &lt;- sort(runif(100,0,100))
## the slower version of the EM algorithms on simulated data with default 
## immigrant hazard function
## and offspring density
system.time( est1 &lt;- EM1partial(tms, 101, c(2,1,0.5,1)) )

## End(Not run)
</code></pre>

<hr>
<h2 id='EM2partial'>
Partial EM algorithm for the RHawkes process, version 2
</h2><span id='topic+EM2partial'></span>

<h3>Description</h3>

<p>Calculates the RHawkes model parameters via a partial Expectation-Maximization 
(EM2) algorithm of Wheatley, Filimonov and Sornette (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    
EM2partial(tms, cens, pars, maxiter = 1000, tol = 1e-8,
         h.fn = function(x, p) dexp(x, rate = 1 / p),
         mu.fn = function(x, p){
              exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
              pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
         },
         H.fn = function(x, p) pexp(x, rate = 1 / p),
         logg.fn = function(x, p){
              dweibull(x, shape = p[1], scale = p[2], log = TRUE) -
              pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE) 
              - (x / p[2])^p[1]},
         Mu.fn = function(x, p){
              - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
         })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EM2partial_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_pars">pars</code></td>
<td>

<p>A numeric vector containing the parameters of the model, in order of the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and 
lastly the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_maxiter">maxiter</code></td>
<td>

<p>The maximum number of iterations to perform.
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_tol">tol</code></td>
<td>

<p>The algorithm stops when the difference between the previous iteration and 
current iteration parameters sum is less than <code>tol</code>.
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="EM2partial_+3A_logg.fn">logg.fn</code></td>
<td>

<p>A (vectorized) function. The log of the immigrant distribution function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>iterations</code></td>
<td>
<p>The number of iterations until convergence</p>
</td></tr>
<tr><td><code>diff</code></td>
<td>
<p>The absolute sum of the difference between the final two 
parameter estimates</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>The parameter estimates from the EM algorithm</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## simulated data
tms &lt;- sort(runif(100,0,100))
## the quicker version on simulated data with default immigrant hazard function
## and offspring density
system.time( est2 &lt;- EM2partial(tms, 101, c(2,1,0.5,1)) )

## End(Not run)
</code></pre>

<hr>
<h2 id='mllRH'>
Minus loglikelihood of a RHawkes model
</h2><span id='topic+mllRH'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of a RHawkes model with given
immigration hazard function <code class="reqn">\mu</code>, offspring density function 
<code class="reqn">h</code> and branching ratio <code class="reqn">\eta</code> for event times <code>tms</code> 
on interval <code class="reqn">[0,cens]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mllRH(tms, cens, par, 
      h.fn = function(x, p) dexp(x, rate = 1 / p), 
      mu.fn = function(x, p) {
        exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
        pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
      }, 
      H.fn = function(x, p) pexp(x, rate = 1 / p), 
      Mu.fn = function(x, p) {
        -pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
      })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mllRH_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="mllRH_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="mllRH_+3A_par">par</code></td>
<td>

<p>A numeric vector containing the parameters of the model, in order of the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and 
lastly the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="mllRH_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="mllRH_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
<tr><td><code id="mllRH_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="mllRH_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the negative log-likelihood. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## earthquake times over 96 years
data(quake);
tms &lt;- sort(quake$time);
# add some random noise to the simultaneous occurring event times
tms[213:214] &lt;- tms[213:214] + 
                    sort(c(runif(1, -1, 1)/(24*60), runif(1, -1, 1)/(24*60)))


## calculate the minus loglikelihood of an RHawkes with some parameters 
## the default hazard function and density functions are Weibull and 
## exponential respectively
mllRH(tms, cens = 96*365.25 , par = c(0.5, 20, 1000, 0.5))
## calculate the MLE for the parameter assuming known parametric forms
## of the immigrant hazard function and offspring density functions.  
system.time(est &lt;- optim(c(0.5, 20, 1000, 0.5), 
                        mllRH, tms = tms, cens = 96*365.25,
                        control = list(maxit = 5000, trace = TRUE),
                        hessian = TRUE)
            )
## point estimate by MLE
est$par
## standard error estimates:
diag(solve(est$hessian))^0.5

## End(Not run)
</code></pre>

<hr>
<h2 id='mllRH1'>
Minus loglikelihood of a RHawkes model with parent probabilities
</h2><span id='topic+mllRH1'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of a RHawkes model with given
immigration hazard function <code class="reqn">\mu</code>, offspring density function 
<code class="reqn">h</code> and branching ratio <code class="reqn">\eta</code> for event times <code>tms</code> 
on interval <code class="reqn">[0,cens]</code>. The same as <code>mllRH</code> although this
version also returns the parent probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mllRH1(tms, cens, par, 
      h.fn = function(x, p) dexp(x, rate = 1/p), 
      mu.fn = function(x, p) {
        exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
        pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
        }, 
        H.fn = function(x, p) pexp(x, rate = 1/p), 
        Mu.fn = function(x, p) {
          -pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
        })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mllRH1_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="mllRH1_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="mllRH1_+3A_par">par</code></td>
<td>

<p>A numeric vector containing the parameters of the model, in order of the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and 
lastly the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="mllRH1_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="mllRH1_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
<tr><td><code id="mllRH1_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="mllRH1_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mll</code></td>
<td>
<p>minus log-likelihood</p>
</td></tr>
<tr><td><code>log.p</code></td>
<td>
<p>parent probabilities</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of events</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;</p>


<h3>See Also</h3>

<p><code>mllRH</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>tmp &lt;- mllRH1(sort(runif(1000,0,1000)), 1001, c(2,1,0.5,1))
for(i in 1:tmp$n)
  cat(exp(tmp$log.p[i*(i - 1)/2 + 1:i]), "\n")    
</code></pre>

<hr>
<h2 id='mllRH2'>
Minus loglikelihood of a RHawkes model with Rosenblatt residuals</h2><span id='topic+mllRH2'></span>

<h3>Description</h3>

<p>Calculates the minus loglikelihood of a RHawkes model with given
immigration hazard function <code class="reqn">\mu</code>, offspring density function 
<code class="reqn">h</code> and branching ratio <code class="reqn">\eta</code> for event times <code>tms</code> 
on interval <code class="reqn">[0,cens]</code>. The same as <code>mllRH</code> although this
version also returns the Rosenblatt residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mllRH2(tms, cens, par, h.fn = function(x, p) dexp(x, rate = 1/p), 
       mu.fn = function(x, p) {
         exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
         pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))}, 
       H.fn = function(x, p) pexp(x, rate = 1/p), 
       Mu.fn = function(x, p) {
         -pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
       })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mllRH2_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="mllRH2_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="mllRH2_+3A_par">par</code></td>
<td>

<p>A numeric vector containing the parameters of the model, in order of the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and 
lastly the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="mllRH2_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="mllRH2_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
<tr><td><code id="mllRH2_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="mllRH2_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculate the RHawkes point process Rosenblatt residuals
</p>


<h3>Value</h3>

<table>
<tr><td><code>mll</code></td>
<td>
<p>minus log-likelihood</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Rosenblatt residual of observed event time</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of events</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;</p>


<h3>See Also</h3>

<p><code>mllRH</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tmp &lt;- mllRH2(sort(runif(1000,0,1000)),1001,c(2,1,0.5,1))
par(mfrow=c(1,2))
qqunif&lt;-function(dat,...){
  dat&lt;-sort(as.numeric(dat));
  n&lt;-length(dat);
  pvec&lt;-ppoints(n);
  plot(pvec,dat,xlab="Theoretical Quantiles",
       ylab="Sample Quantiles",main="Uniform Q-Q Plot",...)
}
qqunif(tmp$U)
acf(tmp$U)
ks.test(tmp$U,"punif")

## End(Not run)
</code></pre>

<hr>
<h2 id='pred.den'>
RHawkes predictive density function
</h2><span id='topic+pred.den'></span>

<h3>Description</h3>

<p>Calculates the predictive density of the next observed event time after the 
censoring time <code>cens</code> based on observations over the interval 
[0,<code>cens</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.den(x, tms, cens, par, 
        h.fn = function(x, p) dexp(x, rate = 1 / p), 
        mu.fn = function(x, p) {
          exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
          pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))}, 
          H.fn = function(x, p) pexp(x, rate = 1 / p), 
          Mu.fn = function(x, p) {
            -pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
          })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.den_+3A_x">x</code></td>
<td>

<p>A scalar. The amount of time after the censoring time <code>cens</code>.
</p>
</td></tr>
<tr><td><code id="pred.den_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. The event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="pred.den_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="pred.den_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the parameters of the model, in order of the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and 
lastly the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="pred.den_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="pred.den_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
<tr><td><code id="pred.den_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="pred.den_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predictive density of the next event evaluated at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quake);
tms &lt;- sort(quake$time);
# add some random noise to the identical event times
tms[213:214] &lt;- tms[213:214] + 
                    sort(c(runif(1, -1, 1)/(24*60), runif(1, -1, 1)/(24*60)))
curve(pred.den(x, tms = tms, cens = 35064, par= c(0.314, 22.2, 1266, 0.512)) 
        ,0 ,2000, col = 2, lty = 2)
</code></pre>

<hr>
<h2 id='pred.haz'>
RHawkes predictive hazard function</h2><span id='topic+pred.haz'></span>

<h3>Description</h3>

<p>Calculates the predictive hazard function of the next observed event time after 
the censoring time <code>cens</code> based on observations over the interval 
[0,<code>cens</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.haz(x, tms, cens, par, 
        h.fn = function(x, p) dexp(x, rate = 1 / p), 
        mu.fn = function(x, p) {
          exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
          pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
          }, 
        H.fn = function(x, p) pexp(x, rate = 1/p), 
        Mu.fn = function(x, p) {
          - pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE)
        })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.haz_+3A_x">x</code></td>
<td>

<p>A scalar. The amount of time after the censoring time <code>cens</code>.
</p>
</td></tr>
<tr><td><code id="pred.haz_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. The event times
to fit the RHawkes point process model.
</p>
</td></tr>
<tr><td><code id="pred.haz_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time.
</p>
</td></tr>
<tr><td><code id="pred.haz_+3A_par">par</code></td>
<td>

<p>A numeric vector. Contains the parameters of the model, in order of the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and 
lastly the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="pred.haz_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="pred.haz_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
<tr><td><code id="pred.haz_+3A_h.fn">H.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the offspring density function from 0 to <code>t</code>. 
</p>
</td></tr>
<tr><td><code id="pred.haz_+3A_mu.fn">Mu.fn</code></td>
<td>

<p>A (vectorized) function. Its value at <code>t</code> gives the integral of
the immigrant hazard function from 0 to <code>t</code>. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The predictive hazard rate of the next event evaluated at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(quake);
tms &lt;- sort(quake$time);
# add some random noise to the identical event times
tms[213:214] &lt;- tms[213:214] + 
                    sort(c(runif(1, -1, 1)/(24*60), runif(1, -1, 1)/(24*60)))
curve(pred.haz(x, tms = tms, cens = 35064, par= c(0.314, 22.2, 1266, 0.512)) 
        ,0 ,2000, col = 2, lty = 2)
</code></pre>

<hr>
<h2 id='quake'>
An RHawkes earthquake data set
</h2><span id='topic+quake'></span>

<h3>Description</h3>

<p>An earthquake data set containing the earthquake occurrence times near the Japan 
region previously examined by Ogata (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(quake)</code></pre>


<h3>Format</h3>

<p>The format is a vector of the arrival/birth times of earthquakes.
</p>


<h3>Details</h3>

<p>Times of arrivals of earthquake occurrences in a vector in ascending order.
</p>


<h3>Source</h3>

<p>Simulated by a call to the function <code>simHawkes1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(quake)
## number of earthquake occurrences
nrow(quake)

## End(Not run)
</code></pre>

<hr>
<h2 id='RHawkes-package'>
Renewal Hawkes Process
</h2><span id='topic+RHawkes-package'></span><span id='topic+RHawkes'></span>

<h3>Description</h3>

<p>The renewal Hawkes (RHawkes) process (Wheatley,
    Filimonov, and Sornette, 2016 &lt;doi:10.1016/j.csda.2015.08.007&gt;) is
    an extension to the classical Hawkes self-exciting point process
    widely used in the modelling of clustered event sequence data.
    This package provides functions to simulate the RHawkes process
    with a given immigrant hazard rate function and offspring birth
    time density function, to compute the exact likelihood of a
    RHawkes process using the recursive algorithm proposed by Chen and
    Stindl (2018) &lt;doi:10.1080/10618600.2017.1341324&gt;, to compute the
    Rosenblatt residuals for goodness-of-fit assessment, and to
    predict future event times based on observed event times up to a
    given time. A function implementing the linear time RHawkes
    process likelihood approximation algorithm proposed in Stindl and
    Chen (2021) &lt;doi:10.1007/s11222-021-10002-0&gt; is also included.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> RHawkes</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Renewal Hawkes Process</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-5-4</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person(given="Feng", 
	            family="Chen", 
		    role = c("aut", "cre"),
		    email = "feng.chen@unsw.edu.au",
		    comment = c(ORCID="0000-0002-9646-3338")
		    ),
             person(given="Tom", 
	            family="Stindl", 
		    role = "ctb", 
		    email="t.stindl@unsw.edu.au",
		    comment=c(ORCID="0000-0001-8627-9337")
		    )
             )</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The renewal Hawkes (RHawkes) process (Wheatley,
    Filimonov, and Sornette, 2016 &lt;doi:10.1016/j.csda.2015.08.007&gt;) is
    an extension to the classical Hawkes self-exciting point process
    widely used in the modelling of clustered event sequence data.
    This package provides functions to simulate the RHawkes process
    with a given immigrant hazard rate function and offspring birth
    time density function, to compute the exact likelihood of a
    RHawkes process using the recursive algorithm proposed by Chen and
    Stindl (2018) &lt;doi:10.1080/10618600.2017.1341324&gt;, to compute the
    Rosenblatt residuals for goodness-of-fit assessment, and to
    predict future event times based on observed event times up to a
    given time. A function implementing the linear time RHawkes
    process likelihood approximation algorithm proposed in Stindl and
    Chen (2021) &lt;doi:10.1007/s11222-021-10002-0&gt; is also included.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 2.10), IHSEP</td>
</tr>
<tr>
 <td style="text-align: left;">
NeedsCompilation: </td><td style="text-align: left;"> no</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Feng Chen [aut, cre] (&lt;https://orcid.org/0000-0002-9646-3338&gt;),
  Tom Stindl [ctb] (&lt;https://orcid.org/0000-0001-8627-9337&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
EM1partial              Partial EM algorithm for the RHawkes process,
                        version 1
EM2partial              Partial EM algorithm for the RHawkes process,
                        version 2
RHawkes-package         Renewal Hawkes Process
damllRH                 Dynamically approxomated minus loglikelihood of
                        a RHawkes model
mllRH                   Minus loglikelihood of a RHawkes model
mllRH1                  Minus loglikelihood of a RHawkes model with
                        parent probabilities
mllRH2                  Minus loglikelihood of a RHawkes model with
                        Rosenblatt residuals
pred.den                RHawkes predictive density function
pred.haz                RHawkes predictive hazard function
quake                   An RHawkes earthquake data set
sim.pred                Simulate a fitted RHawkes process model
sim.pred1               Simulate a fitted RHawkes process model for
                        prediction purposes
simRHawkes              Simulate a renewal Hawkes (RHawkes) process
simRHawkes1             Simulate a renewal Hawkes (RHawkes) process
tms                     mid-price change times of the AUD/USD exchange
                        rate
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>

<hr>
<h2 id='sim.pred'>
Simulate a fitted RHawkes process model
</h2><span id='topic+sim.pred'></span>

<h3>Description</h3>

<p>Simulate a fitted RHawkes process model after the censoring time <code>cens</code> 
to a future time point <code>cens.tilde</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pred(tms, re.dist = rweibull, par, 
    par.redist = list(shape = par[1], scale = par[2]), 
    h.fn = function(x, p) dexp(x, rate = 1 / p), p.ofd = par[3], 
    branching.ratio = par[4], cens, cens.tilde = cens * 1.5, 
    mu.fn = function(x, p) {
        exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
        pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
    })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.pred_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_re.dist">re.dist</code></td>
<td>

<p>A (vectorized) function. The immigrant renewal distribution function.
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_par">par</code></td>
<td>

<p>A numeric vector, giving the parameters of the model with the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and lastly
the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_par.redist">par.redist</code></td>
<td>

<p>A numeric vector. The parameters of the immigrant renewal distribution.  
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_h.fn">h.fn</code></td>
<td>

<p>A (vectorized) function. The offspring density function. 
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_p.ofd">p.ofd</code></td>
<td>

<p>A (named) list. The parameters of the offspring density.
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_branching.ratio">branching.ratio</code></td>
<td>

<p>A scalar. The branching ratio parameter.    
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time. 
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_cens.tilde">cens.tilde</code></td>
<td>

<p>A scalar. The future time that the simulation run until. 
</p>
</td></tr>
<tr><td><code id="sim.pred_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector that contains the simulated event times from censoring time 
<code>cens</code> up until <code>cens.tilde</code>
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 5; i &lt;- 0;
data(quake); tms &lt;- sort(quake$time);
# add some random noise the simultaneous occurring event times
tms[213:214] &lt;- tms[213:214] + 
                    sort(c(runif(1, -1, 1)/(24*60), runif(1, -1, 1)/(24*60)))
# simulate future event time based on MLE fitted RHawkes model
times &lt;- replicate(N,
                   {cat(i&lt;&lt;-i+1,'\n');
                   sim.pred(tms = tms, par = c(0.314, 22.2, 1266, 0.512),
                            cens=35063)
                   })
plot(NA,NA,xlim=c(0,35063*1.5),ylim=c(0,max(lengths(times))+nrow(quake)),
     xlab="time",ylab="Sample path")
lines(c(0,quake$time),0:nrow(quake),type="s")
for(i in 1:N)
    lines(c(tail(quake$time,1),times[[i]]),nrow(quake)+0:length(times[[i]]),
          type="s",lty=2)
</code></pre>

<hr>
<h2 id='sim.pred1'>
Simulate a fitted RHawkes process model for prediction purposes
</h2><span id='topic+sim.pred1'></span>

<h3>Description</h3>

<p>Simulate a fitted RHawkes process model from the censoring time <code>cens</code> 
to a future time point <code>cens.tilde</code>, conditional on the observed
event times until the censoring time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pred1(tms, par, re.dist = rweibull, 
    par.redist = list(shape = par[1], scale = par[2]), 
    of.dis="exp", par.ofdis = list(rate=par[3]), 
    branching.ratio = par[4], cens=tail(tms,1)+mean(diff(tms))/2, 
    cens.tilde = cens * 1.5, 
    mu.fn = function(x, p) {
        exp(dweibull(x, shape = p[1], scale = p[2], log = TRUE) - 
        pweibull(x, shape = p[1], scale = p[2], lower.tail = FALSE, log.p = TRUE))
    })
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.pred1_+3A_tms">tms</code></td>
<td>

<p>A numeric vector, with values sorted in ascending order. Event times
to fit the RHawkes point process model.</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_par">par</code></td>
<td>

<p>A numeric vector, giving the parameters of the model with the 
immigration parameters <code class="reqn">\mu(.)</code>, offspring parameters <code class="reqn">h(.)</code> and lastly
the branching ratio <code class="reqn">\eta(.)</code>.
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_re.dist">re.dist</code></td>
<td>

<p>A (vectorized) function. The function to simulate from the immigrant
waiting times distribution.
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_par.redist">par.redist</code></td>
<td>

<p>A (named) list, giving the parameters of the immigrant waiting time distribution.  
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_of.dis">of.dis</code></td>
<td>

<p>A character string, for the name of the offspring birth time distribution. 
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_par.ofdis">par.ofdis</code></td>
<td>

<p>A (named) list, giving the parameters of the offspring birth time distribution.
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_branching.ratio">branching.ratio</code></td>
<td>

<p>A scalar in [0,1), the branching ratio parameter.    
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time. 
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_cens.tilde">cens.tilde</code></td>
<td>

<p>A scalar. The future time to run the simulation to. 
</p>
</td></tr>
<tr><td><code id="sim.pred1_+3A_mu.fn">mu.fn</code></td>
<td>

<p>A (vectorized) function. The immigration hazard function. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector that contains the simulated event times from censoring time 
<code>cens</code> up until <code>cens.tilde</code>
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sim.pred">sim.pred</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 5; i &lt;- 0;
data(quake); tms &lt;- sort(quake$time);
# add some random noise the simultaneous occurring event times
tms[213:214] &lt;- tms[213:214] + 
                    sort(c(runif(1, -1, 1)/(24*60), runif(1, -1, 1)/(24*60)))
# simulate future event time based on MLE fitted RHawkes model
times &lt;- replicate(N,
                   {cat(i&lt;&lt;-i+1,'\n');
                   sim.pred1(tms = tms, par = c(0.314, 22.2, 1266, 0.512),
                             cens=35063)
                   })
plot(NA,NA,xlim=c(0,35063*1.5),ylim=c(0,max(lengths(times))+nrow(quake)),
     xlab="time",ylab="Sample path")
lines(c(0,quake$time),0:nrow(quake),type="s")
for(i in 1:N)
    lines(c(tail(quake$time,1),times[[i]]),nrow(quake)+0:length(times[[i]]),
          type="s",lty=2)
</code></pre>

<hr>
<h2 id='simRHawkes'>
Simulate a renewal Hawkes (RHawkes) process
</h2><span id='topic+simRHawkes'></span>

<h3>Description</h3>

<p>Simulate a renewal Hawkes (RHawkes) process with given renewal immigration 
distribution function, offspring density function and branching ratio. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRHawkes(re.dist = rweibull, par.redist = list(shape = 1, scale = 1), 
           ofspr.den = function(x, p.ofd) 1 / p.ofd * exp(-x / p.ofd), 
           p.ofd = 1, branching.ratio = 0.5, cens = 1, B = 10, B0 = 50, 
           max.ofspr.den = max(optimize(ofspr.den, c(0, cens), maximum = TRUE, 
           p = p.ofd)$obj, ofspr.den(0, p.ofd), ofspr.den(cens, p.ofd)) * 1.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simRHawkes_+3A_re.dist">re.dist</code></td>
<td>

<p>A (vectorized) function. The immigrant renewal distribution function.
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_par.redist">par.redist</code></td>
<td>

<p>A numeric vector. The parameters of the immigrant renewal distribution.  
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_ofspr.den">ofspr.den</code></td>
<td>

<p>A (vectorized) function. The offspring density function.    
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_p.ofd">p.ofd</code></td>
<td>

<p>A numeric vector. The parameters of the offspring density.
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_branching.ratio">branching.ratio</code></td>
<td>

<p>A scalar. The branching ratio parameter.    
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time. 
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_b">B</code></td>
<td>

<p>A scalar. Tuning parameter for simulation of further immigrants.  
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_b0">B0</code></td>
<td>

<p>A scalar. Tuning parameter for simulation of initial immigrants.
</p>
</td></tr>
<tr><td><code id="simRHawkes_+3A_max.ofspr.den">max.ofspr.den</code></td>
<td>

<p>A scalar. The maximum value of the offspring density function from 0 
to <code>cens</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by simulating the arrival times of immigrants
according to the renewal immigration distribution. The birth times of 
offspring from each immigrant are then simulated according to an 
inhomogeneous Poisson processes with appropriate intensity functions.
</p>


<h3>Value</h3>

<p>A numeric vector of all pooled events (immigration/birth) times of
all generations 0, 1, ...
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- 10; i &lt;- 0;
tms &lt;- replicate(B,
                  {cat(i&lt;&lt;-i+1,'\n');
                  simRHawkes(par.redist = list(shape = 3, scale = 1),
                      p.ofd = 0.5, branching.ratio = 0.5,
                      cens = 100)
                  })
</code></pre>

<hr>
<h2 id='simRHawkes1'>
Simulate a renewal Hawkes (RHawkes) process
</h2><span id='topic+simRHawkes1'></span>

<h3>Description</h3>

<p>Simulate a renewal Hawkes (RHawkes) process with given renewal immigration 
distribution function, offspring density function and branching ratio. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simRHawkes1(re.dist = rweibull, par.redist = list(shape = 1, scale = 1), 
            of.dis = "exp", par.ofdis = list(rate=1),
            branching.ratio = 0.5, cens = 1, B = 10, B0 = 50, 
            flatten=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simRHawkes1_+3A_re.dist">re.dist</code></td>
<td>

<p>A (vectorized) function. The immigrant renewal distribution function.
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_par.redist">par.redist</code></td>
<td>

<p>A numeric vector. The parameters of the immigrant renewal distribution.  
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_of.dis">of.dis</code></td>
<td>

<p>A character string indicating the distribution for the offspring
birth times, which has to be the
'distname' part of the <code>rdistname</code> functions for simulating
postive random variables implemented in R, such as &quot;exp&quot;, &quot;weibull&quot;,
&quot;gamma&quot;, &quot;lnorm&quot;, etc.
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_par.ofdis">par.ofdis</code></td>
<td>

<p>A list with named elements, giving the list of parameters of the
offspring distribution, such as list(rate=1), list(shape=1,scale=1),
etc. 
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_branching.ratio">branching.ratio</code></td>
<td>

<p>A scalar between 0 and 1, the branching ratio parameter. 
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_cens">cens</code></td>
<td>

<p>A scalar. The censoring time. 
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_b">B</code></td>
<td>

<p>A scalar. Tuning parameter for simulation of further immigrants.  
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_b0">B0</code></td>
<td>

<p>A scalar. Tuning parameter for simulation of initial immigrants.
</p>
</td></tr>
<tr><td><code id="simRHawkes1_+3A_flatten">flatten</code></td>
<td>

<p>A boolean scalar, which indicates whether the output events times
should be flattened into an increasing sequence of times, or not (in
which case the output is the immigrant arrival times, and the
offspring birth times for different immigrants).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works by simulating the arrival times of immigrants
according to the renewal immigration distribution. The birth times of 
offspring from each immigrant are then simulated according to an 
inhomogeneous Poisson processes with appropriate intensity functions.
</p>


<h3>Value</h3>

<p>A numeric vector of pooled event (immigration/offspring birth) times of
all generations 0, 1, ..., if <code>flatten=TRUE</code>; A list with two
components: <code>immitimes</code> for immigrant arrival times, and
<code>offspringtimes</code> for birth times of offspring due to different
immigrants. 
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Tom Stindl &lt;t.stindl@unsw.edu.au&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tms &lt;- simRHawkes1(par.redist = list(shape = 3, scale = 1),
                   par.ofdis = list(rate=0.5), branching.ratio = 0.5,
                   cens = 50)
plot(stepfun(tms,0:length(tms)),do.points=FALSE,vertical=FALSE,xlim=c(0,50))

tms.clust &lt;- simRHawkes1(par.redist = list(shape = 3, scale = 1),
                         par.ofdis = list(rate=0.5), branching.ratio = 0.5,
                         cens = 50,flatten=FALSE)
plot(c(0,50),c(0, 1+(nt &lt;-length(it &lt;- tms.clust$immitimes))),
     type="n",xlab="time",ylab="cluster")
segments(x0 = it,y0=-0.2,y1=0.2)
for(i in 1:nt)
    segments(x0 = c(it[i],it[i]+tms.clust$offspringtimes[[i]]),
             y0=i-0.2,y1=i+0.2)
abline(h=0:(nt+1),col="light gray",lty=2)
segments(x0=unlist(lapply(1:nt,function(i)c(it[i],it[i]+tms.clust$offspringtimes[[i]]))),
         y0=nt+1-0.2,y1=nt+1+0.2)
</code></pre>

<hr>
<h2 id='tms'>
mid-price change times of the AUD/USD exchange rate
</h2><span id='topic+tms'></span>

<h3>Description</h3>

<p>A financial data set containing the mid-price changes of the AUD/USD foreign
exchange rate during the trading week from 20:00:00 GMT on Sunday 19/07/2015 to 
21:00:00 GMT Friday 24/07/2015.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tms)</code></pre>


<h3>Format</h3>

<p>The format is a list of the arrival times of mid price changes that occur 
every hour in 121 non-overlapping windows.
</p>


<h3>Details</h3>

<p>Times of arrivals of mid-price changes is listed
together in ascending order.
</p>


<h3>Source</h3>

<p>Simulated by a call to the function <code>simHawkes1</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tms)
## number of non over-lapping hourly windows
length(tms)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
