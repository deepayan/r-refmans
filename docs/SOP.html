<!DOCTYPE html><html><head><title>Help for package SOP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SOP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SOP-package'>
<p>Generalised Additive P-Spline Regression Models Estimation</p></a></li>
<li><a href='#ad'><p>Adaptive smooth terms in a SOP model formula</p></a></li>
<li><a href='#f'><p>Defining smooth terms in SOP formulae</p></a></li>
<li><a href='#plot.sop'><p>Default SOP plotting</p></a></li>
<li><a href='#predict.sop'><p>Prediction from a fitted SOP model</p></a></li>
<li><a href='#print.sop'>
<p>Print method for sop objects</p></a></li>
<li><a href='#rae'><p>Defining random effects in SOP formula</p></a></li>
<li><a href='#sop'>
<p>Estimation of generalised additive P-spline regression models with overlapping penalties.</p></a></li>
<li><a href='#sop.control'><p>Function for controlling SOP fitting</p></a></li>
<li><a href='#sop.fit'>
<p>Fitting generalised linear mixed models with overlapping precision matrices.</p></a></li>
<li><a href='#summary.sop'>
<p>Summary method for a fitted SOP model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalised Additive P-Spline Regression Models Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-15</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SpATS</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maria Xose Rodriguez-Alvarez &lt;mxrodriguez@uvigo.gal&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generalised additive P-spline regression models estimation using the separation of overlapping precision matrices (SOP) method. Estimation is based on the equivalence between P-splines and linear mixed models, and variance/smoothing parameters are estimated based on restricted maximum likelihood (REML). The package enables users to estimate P-spline models with overlapping penalties. Based on the work described in Rodriguez-Alvarez et al. (2015) &lt;<a href="https://doi.org/10.1007%2Fs11222-014-9464-2">doi:10.1007/s11222-014-9464-2</a>&gt;; Rodriguez-Alvarez et al. (2019) &lt;<a href="https://doi.org/10.1007%2Fs11222-018-9818-2">doi:10.1007/s11222-018-9818-2</a>&gt;, and Eilers and Marx (1996) &lt;<a href="https://doi.org/10.1214%2Fss%2F1038425655">doi:10.1214/ss/1038425655</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-15 16:34:18 UTC; mrodriguez</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria Xose Rodriguez-Alvarez
    <a href="https://orcid.org/0000-0002-1329-9238"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Manuel Oviedo de la Fuente [aut],
  Maria Durban [ctb],
  Paul H.C. Eilers [ctb],
  Dae-Jin Lee [ctb],
  Mikis Stasinopoulos [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-15 21:52:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='SOP-package'>
Generalised Additive P-Spline Regression Models Estimation
</h2><span id='topic+SOP-package'></span><span id='topic+SOP'></span>

<h3>Description</h3>

<p>Generalised additive P-spline regression models estimation using the separation of overlapping precision matrices (SOP) method. Estimation is based on the equivalence between P-splines and linear mixed models, and variance/smoothing parameters are estimated based on restricted maximum likelihood (REML). The package enables users to estimate P-spline models with overlapping penalties. Based on the work described in Rodriguez-Alvarez et al. (2015) &lt;doi:10.1007/s11222-014-9464-2&gt;; Rodriguez-Alvarez et al. (2019) &lt;doi:10.1007/s11222-018-9818-2&gt;, and Eilers and Marx (1996) &lt;doi:10.1214/ss/1038425655&gt;.
</p>


<h3>Details</h3>


<p>Index of help topics:
</p>
<pre>
SOP-package             Generalised Additive P-Spline Regression Models
                        Estimation
ad                      Adaptive smooth terms in a SOP model formula
f                       Defining smooth terms in SOP formulae
plot.sop                Default SOP plotting
predict.sop             Prediction from a fitted SOP model
print.sop               Print method for sop objects
rae                     Defining random effects in SOP formula
sop                     Estimation of generalised additive P-spline
                        regression models with overlapping penalties.
sop.control             Function for controlling SOP fitting
sop.fit                 Fitting generalised linear mixed models with
                        overlapping precision matrices.
summary.sop             Summary method for a fitted SOP model.
</pre>
<p>This package incorporates the function <code>sop()</code> which enables users to estimate multidimensional generalised P-spline regression models with overlapping penalties. For a complete list of functions use <code>library(help = SOP)</code>.
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Maria Xose Rodriguez-Alvarez &lt;mxrodriguez@uvigo.gal&gt;
</p>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with B-splines and penalties. <em>Statistical Science</em>, <b>11 (2)</b>, 89&ndash;121.
</p>
<p>Rodriguez-Alvarez, M.X., Lee, D. J., Kneib, T., Durban, M., and Eilers, P. (2015). Fast smoothing parameter separation in multidimensional generalized P-splines: the SAP algorithm. <em>Statistics and Computing</em>, <b>25 (5)</b>, 941&ndash;957.
</p>
<p>Rodriguez-Alvarez, M.X., Durban, M., Lee, D. J. and Eilers, P. (2019). On the estimation of variance parameters in non-standard generalised linear mixed models: application to penalised smoothing. <em>Statistics and Computing</em>, <b>29 (3)</b>, 483&ndash;500.
</p>

<hr>
<h2 id='ad'>Adaptive smooth terms in a SOP model formula</h2><span id='topic+ad'></span>

<h3>Description</h3>

<p>Auxiliary function used to define adaptive smooth terms in a <code>sop</code> model formula. The function does not do any fitting but is used as part of a <code>sop()</code> model formula.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ad(..., nseg = 10, pord = 2, degree = 3, nseg.sp = 5, degree.sp = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ad_+3A_...">...</code></td>
<td>
<p>the x-variable (continuous) to be used for adaptive smoothing. Currently, only one dimensional adaptive smoothers are allowed.</p>
</td></tr>
<tr><td><code id="ad_+3A_nseg">nseg</code></td>
<td>
<p>the number of segments for the B-spline basis used to represent the smooth term. The default value is 10.</p>
</td></tr>
<tr><td><code id="ad_+3A_pord">pord</code></td>
<td>
<p>penalty order. The defauly value is 2 (second order penalty).</p>
</td></tr>
<tr><td><code id="ad_+3A_degree">degree</code></td>
<td>
<p>the order of the polynomial for the B-spline basis for this term. The default value is 3 (cubic B-splines).</p>
</td></tr>
<tr><td><code id="ad_+3A_nseg.sp">nseg.sp</code></td>
<td>
<p>the number of segments for the B-spline basis used to &lsquo;smooth&rsquo; the smoothing parameters. The default value is 5.</p>
</td></tr>
<tr><td><code id="ad_+3A_degree.sp">degree.sp</code></td>
<td>
<p>the order of the polynomial for the B-spline basis used for smoothing of the smoothing parameters. The default value is 3 (cubic B-splines).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>ad()</code> can be use to fit an adaptive smooth function of <code>x</code>.
An &lsquo;adaptive&rsquo;  smooth function is one in which the smoothing parameter is allowed to vary over the range of the explanatory variable <code>x</code>. Details can be found in Rodriguez-Alvarez <em>at. al</em> (2019).  
</p>


<h3>Value</h3>

<p>The function is interpreted in the formula of a <code>sop</code> model and creates the right framework for fitting the adaptive smoother. List containing the following objects:
</p>
<table>
<tr><td><code>vars</code></td>
<td>
<p>name of the covariates involved in the adaptive smooth term.</p>
</td></tr>
<tr><td><code>nseg</code></td>
<td>
<p>the number of segments for the B-spline basis.</p>
</td></tr>
<tr><td><code>pord</code></td>
<td>
<p>the penalty order.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>the order of the polynomial for the B-Spline basis for this term. </p>
</td></tr>
<tr><td><code>nseg.sp</code></td>
<td>
<p>the number of segments for the B-spline basis used to &lsquo;smooth&rsquo; the smoothing parameters.</p>
</td></tr>
<tr><td><code>degree.sp</code></td>
<td>
<p>the order of the polynomial for the B-spline basis used for smoothing of the smoothing parameters.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>The dimension of the smoother - i.e. the number of covariates that it is a function of.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>labels terms.</p>
</td></tr>    
</table>


<h3>References</h3>

<p>Rodriguez-Alvarez, M.X., Durban, M., Lee, D. J. and Eilers, P. (2019). On the estimation of variance parameters in non-standard generalised linear mixed models: application to penalised smoothing. <em>Statistics and Computing</em>, <b>29 (3)</b>, 483&ndash;500.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+f">f</a></code>, <code><a href="#topic+rae">rae</a></code>, <code><a href="#topic+sop">sop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
# Simulate the data
set.seed(123)
n &lt;- 1000
x &lt;- runif(n, 0.0001, 1)
doppler.function &lt;- function(x) sin(4 / (x + 0.1)) + 1.5
mu &lt;- doppler.function(x)
sigma &lt;- 0.2
y &lt;- mu + sigma*rnorm(n)
dat &lt;- data.frame(x = x, y = y)

# Fit the models
# With addaptive smoothing
m0 &lt;- sop(formula = y ~ ad(x, nseg = 197, nseg.sp = 17), data = dat, 
         control =  list(trace = FALSE, epsilon = 1e-03))

# Without addaptive smoothing
m1 &lt;- sop(formula = y ~ f(x, nseg = 197), data = dat, 
         control =  list(trace = FALSE, epsilon = 1e-03))         

# Plot results
plot(y ~ x, data = dat)
ox &lt;- order(dat$x)
lines(fitted(m0)[ox] ~ dat$x[ox], col = 2, lwd = 2)
lines(fitted(m1)[ox] ~ dat$x[ox], col = 4, lwd = 2)
legend("topright", c("Theoretical", "Adaptive", "Non Adaptive"), 
    col = c(1,2,4), lty = 1, lwd = 2, bty = "n")	
</code></pre>

<hr>
<h2 id='f'>Defining smooth terms in SOP formulae</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>Auxiliary function used to define smooth terms within <code>sop()</code> model formulae. The function does not evaluate the smooth - it exists purely to help set up a model using P-spline based smoothers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(..., nseg = 10, pord = 2 , degree = 3)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_+3A_...">...</code></td>
<td>
<p>a list of up to three variables to construct the smooth term.</p>
</td></tr>
<tr><td><code id="f_+3A_nseg">nseg</code></td>
<td>
<p>the number of segments for the (marginal) B-spline bases used to represent the smooth term. Numerical vector of length equal to the number of covariates. Atomic values are also valid, being recycled. The default value is 10.</p>
</td></tr>
<tr><td><code id="f_+3A_pord">pord</code></td>
<td>
<p>penalty order. Numerical vector of length equal to the number of covariates. Atomic values are also valid, being recycled. The default value is 2 (second-order penalty).</p>
</td></tr>
<tr><td><code id="f_+3A_degree">degree</code></td>
<td>
<p>the order of the polynomial for the (marginal) B-spline bases for this term. Numerical vector of length equal to the number of covariates. Atomic values are also valid, being recycled. The default value is 3 (cubic B-splines).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>f()</code> is designed to represent either a one dimensional smooth functions for main effects of an continuous explanatory variable or two or three dimensional smooth functions representing two way and three way interactions of continuous variables. By default, the values of the arguments  <code>nseg</code>, <code>pord</code> and <code>degree</code>  are repeated to the length of the explanatory covariates. The two and three dimensional smooth terms are constructed using the tensor-product of marginal (one-dimensional) B-spline bases and anisotropic penalties are considered.
</p>


<h3>Value</h3>

 
<p>The function is interpreted in the formula of a <code>sop</code> model and creates the right framework for fitting the smoother. List containing the following elements:
</p>
<table>
<tr><td><code>vars</code></td>
<td>
<p>names of the covariates involved in the smooth term.</p>
</td></tr>
<tr><td><code>nseg</code></td>
<td>
<p>the number of segments for the (marginal) B-spline basis for each covariate.</p>
</td></tr>
<tr><td><code>pord</code></td>
<td>
<p>the penalty order (numerical vector of length equal to the number of covariates).</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>the order of the polynomial for the (marginal) B-Spline bases for this term (numerical vector of length equal to the number of covariates). </p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>The dimension of the smoother - i.e. the number of covariates that it is a function of.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>labels terms.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ad">ad</a></code>, <code><a href="#topic+rae">rae</a></code>, <code><a href="#topic+sop">sop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.5
x &lt;- runif(n)
f0 &lt;- function(x) 2*sin(pi*x)
f &lt;- f0(x)
y &lt;- f + rnorm(n, 0, sigma)
dat &lt;- data.frame(x = x, y = y)

# Fit the model
m0 &lt;- sop(formula = y ~ f(x, nseg = 10), data = dat)
summary(m0)

# Plot results
plot(y ~ x, data = dat)
ox &lt;- order(dat$x)
lines(f[ox] ~ dat$x[ox], lwd = 2)
lines(fitted(m0)[ox] ~ dat$x[ox], col = "red", lwd = 2)
</code></pre>

<hr>
<h2 id='plot.sop'>Default SOP plotting</h2><span id='topic+plot.sop'></span>

<h3>Description</h3>

<p> Takes a fitted <code>sop</code> object produced by <code>sop()</code> and plots the component smooth functions that make it up, on the scale of the linear predictor. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sop'
plot(x, rug = TRUE, pages = 0, select = NULL, grid, ...) 
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="plot.sop_+3A_x">x</code></td>
<td>
<p> a fitted <code>sop</code> object as produced by <code>sop()</code>.</p>
</td></tr>
<tr><td><code id="plot.sop_+3A_rug">rug</code></td>
<td>
<p>when TRUE (default) then the covariate to which the plot applies is displayed as a rug plot at the foot of each plot of a 1-d smooth. Setting to <code>FALSE</code> will speed up plotting for large datasets.</p>
</td></tr> 
<tr><td><code id="plot.sop_+3A_pages">pages</code></td>
<td>
<p> (default 0) the number of pages over which to spread the output. For example, if <code>pages=1</code> then all terms will be plotted on one page with the layout performed automatically.  Set to 0 to have the routine leave all graphics settings as they are. </p>
</td></tr>
<tr><td><code id="plot.sop_+3A_select">select</code></td>
<td>
<p>Allows the  plot for a single model smooth term to be selected for printing. e.g. if you just want the plot for the second smooth term set <code>select = 2</code>. </p>
</td></tr>
<tr><td><code id="plot.sop_+3A_grid">grid</code></td>
<td>
<p>number of covariate values used for each 1-d plot - for a nice smooth plot this needs to be several times the estimated degrees of freedom for the smooth. Default value 100.
</p>
</td></tr>
<tr><td><code id="plot.sop_+3A_...">...</code></td>
<td>
<p> other graphics parameters to pass on to plotting commands. See details for smooth plot specific options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces default plot showing the smooth and random components of a fitted SOP.
</p>
<p>For smooth terms <code>plot.sop</code> actually calls plot method functions depending on the dimension of the smooth function.
</p>
<p>For plots of smooths in one dimension, the x axis of each plot is labelled with the covariate name, while the y axis is labelled '<code>f(cov),edf</code>'  where <code>cov</code> is the covariate name, and <code>edf</code> the estimated degrees of freedom of the smooth.
</p>
<p>Several smooth plots methods using <code><a href="graphics.html#topic+image">image</a></code> will accept a <code>colors</code> argument, which can be anything documented in <code><a href="grDevices.html#topic+topo.colors">topo.colors</a></code> (in which case something like <code>colors=rainbow(50)</code> is appropriate), or the <code><a href="grDevices.html#topic+grey">grey</a></code> function (in which case something like <code>colors=grey(0:50/50)</code> is needed).
</p>


<h3>Value</h3>

<p>The function main purpose is to generate plots. It also (silently) returns a list of the data used to produce the plots for the smooth terms. This function is inspired by the plot.gam function of the same name described in mgcv package (but is not a clone).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sop">sop</a></code>, <code><a href="#topic+predict.sop">predict.sop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
## Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.5
x &lt;- runif(n)
f0 &lt;- function(x) 2*sin(pi*x)
f &lt;- f0(x)
y &lt;- f + rnorm(n, 0, sigma)
dat &lt;- data.frame(x = x, y = y)

# Fit the model
m0 &lt;- sop(formula = y ~ f(x, nseg = 10), data = dat)
summary(m0)

# Plot results
plot(m0)

## An example of use of SOP package with tensor product B-splines in 2D
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.1
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
f0 &lt;- function(x1, x2) cos(2*pi*sqrt((x1 - 0.5)^2 + (x2 - 0.5)^2))
f &lt;- f0(x1, x2)
y &lt;- f + rnorm(n, 0, sigma)

dat &lt;- data.frame(x1 = x1, x2 = x2, y = y)

m0 &lt;- sop(formula = y ~ f(x1, x2, nseg = 10), data = dat, 
        control = list(trace = FALSE))

summary(m0)
plot(m0, col = topo.colors(100))

plot(m0, col = grey(0:100/100))

aux &lt;- plot(m0)
names(aux)
</code></pre>

<hr>
<h2 id='predict.sop'>Prediction from a fitted SOP model</h2><span id='topic+predict.sop'></span>

<h3>Description</h3>

<p>The function takes a fitted <code>sop</code> object and produces predictions for the original data if the argument <code>newdata</code> is not set or predictions for new data if <code>newdata</code> is specified. Predictions can be accompanied by standard errors, based on the Bayesian posterior distribution of the model coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sop'
predict(object, newdata, type = c("response", "link", "terms"), 
      se.fit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

 
<table>
<tr><td><code id="predict.sop_+3A_object">object</code></td>
<td>
<p>a fitted <code>sop</code> object as produced by <code>sop()</code>.</p>
</td></tr>
<tr><td><code id="predict.sop_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the values of the model covariates at which predictions are required. If this is not provided then predictions corresponding to the original data are returned. If the data frame <code>newdata</code> is provided then it should contain all the variables needed for prediction: a warning is generated if not. If <code>newdata</code> contains a variable <code>offset</code>, it is included into the predictions when <code>type = "link"</code> and <code>type = "response"</code>.</p>
</td></tr>
<tr><td><code id="predict.sop_+3A_type">type</code></td>
<td>
<p>When this has the value <code>"link"</code> the linear predictor fitted values or predictions (possibly with associated standard errors) 
are returned. 
When <code>type = "terms"</code> each component of the linear predictor is returned separately (possibly with approximate standard errors): this includes parametric model components, followed by each smooth component, but excludes any offset and any intercept.
When <code>type = "response"</code> (default) fitted values or predictions on the scale of the response are returned (possibly with approximate standard errors).
</p>
</td></tr>
<tr><td><code id="predict.sop_+3A_se.fit">se.fit</code></td>
<td>
<p>when this is TRUE (not default) standard error estimates are returned for each prediction.</p>
</td></tr>
<tr><td><code id="predict.sop_+3A_...">...</code></td>
<td>
<p> other arguments. Not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A vector/matrix (or list, with elements <code>fit</code> and <code>se.fit</code>, is <code>se  = TRUE</code>) equal to:
</p>
<table>
<tr><td><code>"link"</code></td>
<td>
<p>a vector of linear predictor values.</p>
</td></tr>
<tr><td><code>"response"</code></td>
<td>
<p>a vector of linear predictor values on the scale of the response.</p>
</td></tr>
<tr><td><code>"terms"</code></td>
<td>
<p>a matrix with a column per term, and may have an attribute &quot;constant&quot;.</p>
</td></tr>
</table>


<h3>See Also</h3>

  <p><code><a href="#topic+sop">sop</a></code>,  <code><a href="#topic+plot.sop">plot.sop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
## Example training/set
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.5
x &lt;- runif(n)
f0 &lt;- function(x)2*sin(pi*x)
f &lt;- f0(x)
y &lt;- f + rnorm(n, 0, sigma)
da &lt;- data.frame(x = x, y = y)# all data
rand &lt;-  sample(2, 610, replace=TRUE, prob=c(0.6,0.4))
traindata &lt;- da[rand==1,] # training data
valdata &lt;- da[rand==2,] # validation data  
plot(y ~ x, data = traindata, pch = 20, col = gray(.7))
points(y ~ x, data = valdata, pch = 20, col = gray(.2))

# Fit the model in the training data
m0 &lt;- sop(formula = y ~ f(x, nseg = 10), data = traindata)
lines(fitted(m0)[order(traindata$x)]~traindata$x[order(traindata$x)], 
       col="red", lwd=2)

# Predict and plot in the data used for the fit
po &lt;- predict(m0)
plot(y ~ x, data = traindata, pch = 20, col = gray(.7))
lines(po[order(traindata$x)] ~ traindata$x[order(traindata$x)], 
      col="red", lwd=2)

# Predict and plot in new data
pn &lt;- predict(m0, newdata = valdata)
plot(y ~ x, data = traindata, pch = 20, col = gray(.7))
lines(pn[order(valdata$x)] ~ valdata$x[order(valdata$x)], col = "yellow", lwd = 2)

# Example Gamma distribution
# Simulate the data
set.seed(123)
n &lt;- 1000
alpha &lt;- 0.75
x0 &lt;- runif(n)
x1 &lt;- x0*alpha + (1-alpha)*runif(n)
x2 &lt;- runif(n)
x3 &lt;- x2*alpha + (1-alpha)*runif(n)
x4 &lt;- runif(n)
x5 &lt;- runif(n)

f0 &lt;- function(x)2*sin(pi*x)
f1 &lt;- function(x)exp(2*x)
f2 &lt;- function(x) 0.2*x^11*(10*(1-x))^6+10*(10*x)^3*(1-x)^10

f &lt;- f0(x0) + f1(x1) + f2(x2)
y &lt;- rgamma(f,exp(f/4),scale=1.2)

df &lt;- data.frame(y = y, x0 = x0, x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)

# Fit the model
m1 &lt;- sop(formula = y ~ f(x0, nseg = 17) + f(x1, nseg = 17) + 
      f(x2, nseg = 17) + f(x3, nseg = 17) + 
      f(x4, nseg = 17) + f(x5, nseg = 17), 
      family = Gamma(link = log), data = df)
summary(m1)

# Predict in a new dataframe
x &lt;- seq(max(c(min(x1),min(x3))), min(c(max(x1),max(x3))), l = 100)
df.p &lt;- data.frame(x0 = x, x1 = x, x2 = x, x3 = x, x4 = x, x5 = x)
p &lt;- predict(m1, type = "terms", newdata = df.p)
colnames(p)

# Plot the different smooth terms
op &lt;- par(mfrow = c(2,3))
plot(m1, select = 1)
lines(x, p[,1], col = "red")
plot(m1, select = 2)
lines(x, p[,2], col = "red")
plot(m1, select = 3)
lines(x, p[,3], col = "red")
plot(m1, select = 4)
lines(x, p[,4], col = "red")
plot(m1, select = 5)
lines(x, p[,5], col = "red")
plot(m1, select = 6)
lines(x, p[,6], col = "red")
par(op)
</code></pre>

<hr>
<h2 id='print.sop'>
Print method for sop objects
</h2><span id='topic+print.sop'></span>

<h3>Description</h3>

<p>Print method for sop objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sop'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sop_+3A_x">x</code></td>
<td>
<p>an object of class <code>sop</code> as produced by <code>sop()</code></p>
</td></tr>
<tr><td><code id="print.sop_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints some summary statistics of the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sop">sop</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.5
x &lt;- runif(n)
f0 &lt;- function(x) 2*sin(pi*x)
f &lt;- f0(x)
y &lt;- f + rnorm(n, 0, sigma)
dat &lt;- data.frame(x = x, y = y)

# Fit the model
m0 &lt;- sop(formula = y ~ f(x, nseg = 10), data = dat)
m0
</code></pre>

<hr>
<h2 id='rae'>Defining random effects in SOP formula</h2><span id='topic+rae'></span>

<h3>Description</h3>

<p>Auxiliary function used to define random effects terms in a <code>sop</code> model formula.</p>


<h3>Usage</h3>

<pre><code class='language-R'>rae(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rae_+3A_x">x</code></td>
<td>
<p>the x-variable (factor) that defines the random effects term.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions is designed to represent random effects in SOP formulae. 
</p>


<h3>Value</h3>

<p>The function is interpreted in the formula of a <code>sop</code> model and creates the right framework for fitting the random effect. List containing the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>name of the covariate involved.</p>
</td></tr>
</table>


<h3>See Also</h3>

 <p><code><a href="#topic+f">f</a></code>, <code><a href="#topic+ad">ad</a></code>, <code><a href="#topic+sop">sop</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
require(SpATS)
## An example of use of SOP package for the analysis of field trials experiments.
## Taken from the SpATS package.
data(wheatdata)

# Create factor variable for row and columns
wheatdata$R &lt;- as.factor(wheatdata$row)
wheatdata$C &lt;- as.factor(wheatdata$col)

# package SOP
m0 &lt;- sop(formula = yield ~ colcode + rowcode + 
  f(col, row, nseg = c(10, 10)) + 
  rae(geno) + rae(R) + rae(C), data = wheatdata)
summary(m0)
plot(m0, col = topo.colors(100))
</code></pre>

<hr>
<h2 id='sop'>
Estimation of generalised additive P-spline regression models with overlapping penalties.
</h2><span id='topic+sop'></span>

<h3>Description</h3>

<p>The function <code>sop()</code> fits generalised additive regression models. For the smooth terms, it uses P-splines (Eilers and Marx, 1996) and it can cope with one, two and three dimensional smooth terms. The innovation of the function is that smoothing/variance parameters are estimated on the basis of the SOP method; see Rodriguez-Alvarez <em>et al.</em> (2015) and Rodriguez-Alvarez <em>et al.</em> (2019) for details. This speeds up the fit. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sop(formula, data = list(),  family = gaussian(), weights = NULL, offset = NULL, 
    control = sop.control(), fit = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sop_+3A_formula">formula</code></td>
<td>
<p>a sop formula. This is exactly like the formula for a GLM except that (1) P-splines in one, two and three dimensions (<code><a href="#topic+f">f</a></code>), (2)spatially adaptive P-splines in 1 dimension (<code><a href="#topic+ad">ad</a></code>); and (3) random effects (<code><a href="#topic+rae">rae</a></code>) can be added to the right hand side of the formula.</p>
</td></tr>
<tr><td><code id="sop_+3A_data">data</code></td>
<td>
<p>a data frame containing the model response variable and covariates required by the formula.</p>
</td></tr> 
<tr><td><code id="sop_+3A_family">family</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+family">family</a></code> specifying the distribution and link function.</p>
</td></tr> 
<tr><td><code id="sop_+3A_weights">weights</code></td>
<td>
<p>prior weights on the contribution of the data to the log likelihood. Note that a weight of 2, for example, is equivalent to having made exactly the same observation twice. If you want to reweight the contributions of each datum without changing the overall magnitude of the log likelihood, then you should normalize the weights e.g. <code>weights &lt;- weights/mean(weights)</code>). If NULL (default), the weights are considered to be one.</p>
</td></tr>
<tr><td><code id="sop_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of observations. </p>
</td></tr>                  
<tr><td><code id="sop_+3A_control">control</code></td>
<td>
<p>a list of control values to replace the default values returned by the function <code><a href="#topic+sop.control">sop.control</a>.</code></p>
</td></tr>
<tr><td><code id="sop_+3A_fit">fit</code></td>
<td>
<p>logical. If TRUE, the model is fitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>sop()</code> can be used to fit generalised additive models. It works similarly to the function  <code>gam()</code>  of the package <span class="pkg">mgcv</span>. The function <code>sop()</code> uses P-splines (Eilers and Marx, 1996), one of the option on <code>gam()</code>. Estimation is based on the equivalence between P-splines and linear mixed models, and variance/smoothing parameters are estimated based on restricted maximum likelihood (REML) using the separation of overlapping precision matrices (SOP) method described in Rodriguez-Alvarez <em>et al.</em> (2015) and Rodriguez-Alvarez <em>et al.</em> (2019).
The function <code>sop()</code> can be seen as a faster alternative to <code>gam()</code> for some data sets.  
</p>


<h3>Value</h3>

<p>An object of class &lsquo;sop&rsquo;. 
It is a list containing the following objects: 
</p>
<table>
<tr><td><code>b.fixed</code></td>
<td>
<p>the estimated fixed effect coefficients (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>b.random</code></td>
<td>
<p>the predicted random effect coefficients (present if <code>fit = TRUE</code>).</p>
</td></tr>   
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>linear.predictor</code></td>
<td>
<p>the values of the linear predictor (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the (deviance) residuals (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the fixed effect design matrix.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the random effect design matrix.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>a list containing information about the precision/penalty matrices (one for each smoothing/variance parameter in the model).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prior weights.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the distribution family.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>a list with i) <code>tol.ol</code> tolerance parameter (outer loop); ii) <code>it.ol</code> number of iteration (outer loop); iii) <code>tol.il</code> tolerance parameter (inner loop); <code>it.il</code> (number of iteration (inner loop)), iv) <code>vc</code> variance components estimates, v) <code>edf</code> effective degrees of freedom (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the null deviance (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>Vp</code></td>
<td>
<p>Bayesian posterior covariance matrix for the coefficients (present if <code>fit = TRUE</code>).</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the data.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula.</p>
</td></tr>
<tr><td><code>lin</code></td>
<td>
<p>a list containing information about the parametric/linear.</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>a list containing information about the random effects.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>a list containing information about the smoothers.</p>
</td></tr>       
<tr><td><code>na.action</code></td>
<td>
<p>vector with the observations (position) deleted due to missingness.</p>
</td></tr>
<tr><td><code>names.terms</code></td>
<td>
<p>the terms used in the formula.</p>
</td></tr>
<tr><td><code>model.terms</code></td>
<td>
<p>the explanatory variables.</p>
</td></tr>   
<tr><td><code>nterms</code></td>
<td>
<p>the number of linear, random and smooth terms in the formula.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible smoothing with B-splines and penalties. <em>Statistical Science</em>, <b>11 (2)</b>, 89&ndash;121.
</p>
<p>Rodriguez-Alvarez, M.X., Lee, D. J., Kneib, T., Durban, M., and Eilers, P. (2015). Fast smoothing parameter separation in multidimensional generalized P-splines: the SAP algorithm. <em>Statistics and Computing</em>, <b>25 (5)</b>, 941&ndash;957.
</p>
<p>Rodriguez-Alvarez, M.X., Durban, M., Lee, D. J. and Eilers, P. (2019). On the estimation of variance parameters in non-standard generalised linear mixed models: application to penalised smoothing. <em>Statistics and Computing</em>, <b>29 (3)</b>, 483&ndash;500.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
## An example of use of SOP package with tensor product B-splines in 2D
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.1
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
f0 &lt;- function(x1, x2) cos(2*pi*sqrt((x1 - 0.5)^2 + (x2 - 0.5)^2))
f &lt;- f0(x1, x2)
y &lt;- f + rnorm(n, 0, sigma)

dat &lt;- data.frame(x1 = x1, x2 = x2, y = y)

# Theoretical surface
np &lt;- 50
x1p &lt;- seq(-1, 1, length = np)  
x2p &lt;- seq(-1, 1, length = np)
fp &lt;- cos(2 * pi * sqrt(outer((x1p - 0.5) ^ 2, (x2p - 0.5) ^ 2, '+')))

image(x1p, x2p, matrix(fp, np, np), main = 'f(x1,x2) - Theor', 
     col = topo.colors(100))

# Fit the model
m0 &lt;- sop(formula = y ~ f(x1, x2, nseg = 10), data = dat, 
        control = list(trace = FALSE))

summary(m0)
plot(m0, col = topo.colors(100))

## An example of use of SOP package with several smooth terms and Gamma distribution
# Simulate the data
set.seed(123)
n &lt;- 1000
alpha &lt;- 0.75
x0 &lt;- runif(n)
x1 &lt;- x0*alpha + (1-alpha)*runif(n)
x2 &lt;- runif(n)
x3 &lt;- x2*alpha + (1-alpha)*runif(n)
x4 &lt;- runif(n)
x5 &lt;- runif(n)

f0 &lt;- function(x)2*sin(pi*x)
f1 &lt;- function(x)exp(2*x)
f2 &lt;- function(x) 0.2*x^11*(10*(1-x))^6+10*(10*x)^3*(1-x)^10

f &lt;- f0(x0) + f1(x1) + f2(x2)
y &lt;- rgamma(f,exp(f/4),scale=1.2)

df &lt;- data.frame(y = y, x0 = x0, x1 = x1, x2 = x2, x3 = x3, x4 = x4, x5 = x5)

# Fit the model
m1 &lt;- sop(formula = y ~ f(x0, nseg = 17) + 
                             f(x1, nseg = 17) + 
                             f(x2, nseg = 17) + 
                             f(x3, nseg = 17) + 
                             f(x4, nseg = 17) + 
                             f(x5, nseg = 17), family = Gamma(link = log), data = df)
summary(m1)
plot(m1)

## An example of use of SOP package for the analysis of field trials experiments.
## Taken from the SpATS package.
require(SpATS)
data(wheatdata)

# Create factor variable for row and columns
wheatdata$R &lt;- as.factor(wheatdata$row)
wheatdata$C &lt;- as.factor(wheatdata$col)

# package SOP
m2 &lt;- sop(formula = yield ~ colcode + rowcode + 
  f(col, row, nseg = c(10, 10)) + 
  rae(geno) + rae(R) + rae(C), data = wheatdata)
summary(m2)
plot(m2, col = topo.colors(100), pages = 1)

# Package SpATS: more adequate for this analysis.
# SpATS has been explicitly developed for the analysis field trials experiments. 
m3 &lt;- SpATS(response = "yield", 
    spatial = ~ SAP(col, row, nseg = c(10,10), degree = 3, pord = 2, center = TRUE), 
    genotype = "geno",
    genotype.as.random = TRUE,
    fixed = ~ colcode + rowcode, random = ~ R + C, data = wheatdata, 
    control =  list(tolerance = 1e-06))
summary(m3)
plot(m3)
</code></pre>

<hr>
<h2 id='sop.control'>Function for controlling SOP fitting</h2><span id='topic+sop.control'></span>

<h3>Description</h3>

<p>The function controls some of the fitting parameters of <code><a href="#topic+sop">sop</a></code>. Typically only used when calling <code>sop()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sop.control(maxit = 200, epsilon = 1e-6, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sop.control_+3A_maxit">maxit</code></td>
<td>
<p>numerical value indicating the maximum number of iterations. Default set to 200 (see Details).</p>
</td></tr>
<tr><td><code id="sop.control_+3A_epsilon">epsilon</code></td>
<td>
<p>numerical value indicating the tolerance for the convergence criterion. Default set to 1e-6 (see Details).</p>
</td></tr>
<tr><td><code id="sop.control_+3A_trace">trace</code></td>
<td>
<p>logical indicating if output should be produced for each iteration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Gaussian response variables, the implemented algorithm is an iterative procedure, with the fixed and random effects as well as the variance components being updated at each iteration. To check the convergence of this iterative procedure, the (REML) deviance is monitored.
For non-Gaussian response variables, estimation is based on Penalized Quasi-likelihood (PQL) methods. Here, the algorithm is a two-loop algorithm: the outer loop corresponds to the Fisher-Scoring algorithm (monitored on the basis of the change in the linear predictor between consecutive iterations), and the inner loop corresponds to that described for the Gaussian case. 
</p>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>References</h3>

<p>Rodriguez-Alvarez, M.X., Lee, D. J., Kneib, T., Durban, M., and Eilers, P. (2015). Fast smoothing parameter separation in multidimensional generalized P-splines: the SAP algorithm. <em>Statistics and Computing</em>, <b>25 (5)</b>, 941&ndash;957.
</p>
<p>Rodriguez-Alvarez, M.X., Durban, M., Lee, D. J. and Eilers, P. (2019). On the estimation of variance parameters in non-standard generalised linear mixed models: application to penalised smoothing. <em>Statistics and Computing</em>, <b>29 (3)</b>, 483&ndash;500.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sop">sop</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.5
x &lt;- runif(n)
f0 &lt;- function(x) 2*sin(pi*x)
f &lt;- f0(x)
y &lt;- f + rnorm(n, 0, sigma)
dat &lt;- data.frame(x = x, y = y)

# Fit the model
m0 &lt;- sop(formula = y ~ f(x, nseg = 10), data = dat, control = list(trace = FALSE))
summary(m0)
</code></pre>

<hr>
<h2 id='sop.fit'>
Fitting generalised linear mixed models with overlapping precision matrices.
</h2><span id='topic+sop.fit'></span>

<h3>Description</h3>

<p>This is an internal function of package SOP. It is used to fit SOP models by specifying the design matrices for the fixed and random effects as well as the precision matrices for each variance component in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sop.fit(y, X, Z, weights = NULL, G = NULL, vcstart = NULL, 
  etastart = NULL, mustart = NULL, offset = NULL, 
  family = gaussian(), control = sop.control())     
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sop.fit_+3A_y">y</code></td>
<td>
<p>vector of observations of length n.</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_x">X</code></td>
<td>
<p>design matrix for the fixed effects (dimension n x p).</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_z">Z</code></td>
<td>
<p>design matrix for the random effects (of dimension n x q).</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of 'prior weights' to be used in the fitting process. If NULL (default), the weights are considered to be one.</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_g">G</code></td>
<td>
<p>a list with the diagonal elements of the precision matrices for each variance component in the model. Each element of the list is a vector of the same length as the number of columns in Z (i.e. q). The vector can be padded out with zeroes to indicate random coefficient not &lsquo;affected&rsquo; by the variance component (see details).</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_vcstart">vcstart</code></td>
<td>
<p>optional numeric vector. Initial values for the variance components (including the error variance as the first element of the vector). If <code>NULL</code>, all variance components are initialised to one.</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_etastart">etastart</code></td>
<td>
<p>initial values for the linear predictor.</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_mustart">mustart</code></td>
<td>
<p>initial values for the expected response.</p>
</td></tr>
<tr><td><code id="sop.fit_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an a priori known component to be included in the linear predictor during fitting. This should be NULL or a numeric vector of length equal to the number of observations.</p>
</td></tr>            
<tr><td><code id="sop.fit_+3A_family">family</code></td>
<td>
<p>object of class <code><a href="stats.html#topic+family">family</a></code> specifying the distribution and link function.</p>
</td></tr> 
<tr><td><code id="sop.fit_+3A_control">control</code></td>
<td>
<p>a list of control values to replace the default values returned by the function <code><a href="#topic+sop.control">sop.control</a>.</code></p>
</td></tr>          
</table>


<h3>Details</h3>

<p><code>sop.fit</code> is the workhorse function: it is typically not normally called directly but can be more efficient where the response vector 'y', design matrixs 'X' and 'Z', and precision matrices 'G' have already been calculated. Currently, the funcion only allows for diagonal precision matrices (possibly overlappping).
</p>


<h3>Value</h3>

<p>A list containing the following objects: 
</p>
<table>
<tr><td><code>b.fixed</code></td>
<td>
<p>the estimated fixed effect coefficients.</p>
</td></tr>
<tr><td><code>b.random</code></td>
<td>
<p>the predicted random effect coefficients.</p>
</td></tr> 
<tr><td><code>residuals</code></td>
<td>
<p>the (deviance) residuals.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted values.</p>
</td></tr>
<tr><td><code>linear.predictor</code></td>
<td>
<p>the values of the linear predictor.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the fixed effect design matrix.</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>the random effect design matrix.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the prior weights.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the distribution family.</p>
</td></tr>
<tr><td><code>out</code></td>
<td>
<p>a list with i) <code>tol.ol</code> tolerance parameter (outer loop); ii) <code>it.ol</code> number of iteration (outer loop); iii) <code>tol.il</code> tolerance parameter (inner loop); <code>it.il</code> (number of iteration (inner loop)), iv) <code>vc</code> variance components estimates, v) <code>edf</code> effective degrees of freedom.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the null deviance.</p>
</td></tr>
<tr><td><code>Vp</code></td>
<td>
<p>Bayesian posterior covariance matrix for the coefficients.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rodriguez-Alvarez, M.X., Lee, D. J., Kneib, T., Durban, M., and Eilers, P. (2015). Fast smoothing parameter separation in multidimensional generalized P-splines: the SAP algorithm. <em>Statistics and Computing</em>, <b>25 (5)</b>, 941&ndash;957.
</p>
<p>Rodriguez-Alvarez, M.X., Durban, M., Lee, D. J. and Eilers, P. (2019). On the estimation of variance parameters in non-standard generalised linear mixed models: application to penalised smoothing. <em>Statistics and Computing</em>, <b>29 (3)</b>, 483&ndash;500.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.1
x1 &lt;- runif(n, -1, 1)
x2 &lt;- runif(n, -1, 1)
f0 &lt;- function(x1, x2) cos(2*pi*sqrt((x1 - 0.5)^2 + (x2 - 0.5)^2))
f &lt;- f0(x1, x2)
y &lt;- f + rnorm(n, 0, sigma)
dat &lt;- data.frame(x1 = x1, x2 = x2, y = y)

# Save but not fit the model
m0_nfit &lt;- sop(formula = y ~ f(x1, x2, nseg = 10), data = dat, 
	    	fit = FALSE)

# Now fit using sop.fit()
m0 &lt;- sop.fit(X = m0_nfit$X, Z = m0_nfit$Z, G = m0_nfit$G, 
	y = m0_nfit$y, weights = m0_nfit$weights, 
	   control = list(trace = FALSE))

names(m0)
</code></pre>

<hr>
<h2 id='summary.sop'>
Summary method for a fitted SOP model.
</h2><span id='topic+summary.sop'></span>

<h3>Description</h3>

<p>Summary method for a fitted SOP model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sop'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sop_+3A_object">object</code></td>
<td>
<p>an object of class <code>sop</code> as produced by <code>sop()</code>.</p>
</td></tr>
<tr><td><code id="summary.sop_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.sop</code> computes and returns a list of summary statistics of the fitted model given in <code>object</code>, using the components (list elements) <code>"call"</code> and <code>"terms"</code> from its argument, plus
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>b.random</code></td>
<td>
<p>a vector with the predicted random effects coefficients.</p>
</td></tr>
<tr><td><code>b.fixed</code></td>
<td>
<p>a vector with the estimated fixed effects coefficients.</p>
</td></tr>
<tr><td><code>r.sq.adj</code></td>
<td>
<p>the (adjusted) <code class="reqn">R^2</code>, i.e., &lsquo;fraction of variance explained by the model&rsquo;, </p>
<p style="text-align: center;"><code class="reqn">R^2 = 1 - \frac{\sum_i{R_i^2}/(n-df)}{\sum_i(y_i- y^*)^2/(n-1)},</code>
</p>
<p> where <code class="reqn">R_i = w_i(y_i - \mu_i)</code> and <code class="reqn">y^*</code> is the (weighted) mean of <code class="reqn">y_i</code>.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the null deviance.</p>
</td></tr>
<tr><td><code>dev.expl</code></td>
<td>
<p>proportion of the null deviance explained by the model.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of data.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code>residual.df</code></td>
<td>
<p>residual degrees of freedom.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>a vector with the estimated degrees of freedom for the (smooth and random) model terms.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the model formula.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family used.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>vector with the observations (position) deleted due to missingness.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+sop">sop</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SOP)
# Simulate the data
set.seed(123)
n &lt;- 1000
sigma &lt;- 0.5
x &lt;- runif(n)
f0 &lt;- function(x) 2*sin(pi*x)
f &lt;- f0(x)
y &lt;- f + rnorm(n, 0, sigma)
dat &lt;- data.frame(x = x, y = y)

# Fit the model
m0 &lt;- sop(formula = y ~ f(x, nseg = 10), data = dat)
summary(m0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
