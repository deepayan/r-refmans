<!DOCTYPE html><html lang="en"><head><title>Help for package GLSME</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GLSME}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GLSME-package'><p>Generalized Least Squares with Measurement Error</p></a></li>
<li><a href='#GLSME'>
<p>Estimate regression parameters with correlated observations measurement errors.</p></a></li>
<li><a href='#GLSME.predict'><p>Prediction for a new observation using parameters estimated by the <code>GLSME</code> function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Least Squares with Measurement Error</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-09-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Krzysztof Bartoszek &lt;krzbar@protonmail.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Krzysztof Bartoszek &lt;krzbar@protonmail.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs linear regression with correlated predictors, responses and correlated measurement errors in predictors and responses, correcting for biased caused by these.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.9.1), mvtnorm, corpcor</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, mvSLOUCH</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENCE [expanded from: GPL (&ge; 2) | file LICENCE]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>GLSME.R</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-15 18:11:48 UTC; bart</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-15 22:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='GLSME-package'>Generalized Least Squares with Measurement Error</h2><span id='topic+GLSME-package'></span>

<h3>Description</h3>

<p>The code fits the general linear model with correlated data and
observation error in both dependent and independent variables. The code fits the
model 
</p>
<p style="text-align: center;"><code class="reqn">y = D\beta + r, r \sim N(0,V), V = \sigma^{2} T + V_{e} + Var[U\beta|D],</code>
</p>

<p>where <code>y</code> is a vector of observed response variables, <code>D</code> is an observed design matrix, 
<code class="reqn">\beta</code>
is a vector of regression parameters to be estimated, 
<code class="reqn">\sigma^{2}</code><code>T</code> is a matrix representing the true residual
variance, <code class="reqn">V_{e}</code> is a matrix
of known measurement variance in the response variable, and <code>Var[U</code><code class="reqn">\beta</code><code>|D]</code> is a matrix
representing effects of measurement error in the predictor variables (see Hansen and Bartoszek 2012).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GLSME</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-09-15</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The code fits the general linear model with correlated data and
observation error in both dependent and independent variables. The code fits the
model 
</p>
<p style="text-align: center;"><code class="reqn">y = D\beta + r, r \sim N(0,V), V = \sigma^{2}T + V_{e} + Var[U\beta|D],</code>
</p>

<p>where <code>y</code> is a vector of observed response variables, <code>D</code> is an observed design matrix, 
<code class="reqn">\beta</code>
is a vector of regression parameters to be estimated, 
<code class="reqn">\sigma^{2}</code><code>T</code> is a matrix representing the true residual
variance, <code class="reqn">V_{e}</code> is a matrix
of known measurement variance in the response variable, and <code>Var[U</code><code class="reqn">\beta</code><code>|D]</code> is a matrix
representing effects of measurement error in the predictor variables (see Hansen and Bartoszek 2012).
</p>
<p>The estimation function is <code>GLSME</code>. It is an iterated (if the variance parameters are unknown)
generalized least squares estimation procedure. 
</p>
<p>The motivation for the approach is that the observations and errors are correlated due
to an underlying phylogeny but the program allows for any dependence structure. 
</p>
<p>In the <code><a href="mvSLOUCH.html#topic+mvSLOUCH">mvSLOUCH</a></code> package an alternative method of correcting 
for observation error is used. The error variance-covariance matrix enters
the likelihood function by being added to the biological variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek
Maintainer: &lt;bartoszekkj@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Hansen, T.F. and Pienaar, J. and Orzack, S.H. (2008) 
A comparative method for studying adaptation to randomly evolving environment. 
Evolution 62:1965-1977.
</p>


<h3>See Also</h3>

<p><code><a href="mvSLOUCH.html#topic+mvSLOUCH">mvSLOUCH</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-3 ## number of species
apetree&lt;-ape::rtree(n)
### Define Brownian motion parameters to be able to simulate data under the Brownian motion model.
BMparameters&lt;-list(vX0=matrix(0,nrow=2,ncol=1),Sxx=rbind(c(1,0),c(0.2,1)))
### Now simulate the data and remove the values corresponding to the internal nodes.
xydata&lt;-mvSLOUCH::simulBMProcPhylTree(apetree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
xydata&lt;-xydata[(nrow(xydata)-n+1):nrow(xydata),]

x&lt;-xydata[,1]
y&lt;-xydata[,2]

yerror&lt;-diag((stats::rnorm(n,mean=0,sd=0.1))^2) #create error matrix
y&lt;-mvtnorm::rmvnorm(1,mean=y,sigma=yerror)[1,]
xerror&lt;-diag((stats::rnorm(n,mean=0,sd=0.1))^2) #create error matrix
x&lt;-mvtnorm::rmvnorm(1,mean=x,sigma=xerror)[1,]
GLSME(y=y, CenterPredictor=TRUE, D=cbind(rep(1, n), x), Vt=ape::vcv(apetree), 
Ve=yerror, Vd=list("F",ape::vcv(apetree)), Vu=list("F", xerror))
</code></pre>

<hr>
<h2 id='GLSME'>
Estimate regression parameters with correlated observations measurement errors.
</h2><span id='topic+GLSME'></span>

<h3>Description</h3>

<p>The <code>GLSME</code> function estimates parameters of a linear model via generalized least squares. It allows 
for correlated predictors and responses. Furthermore it allows for correlated measurement errors
both in predictors and responses. The program specifically corrects for biase caused by these errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLSME(y, D, Vt, Ve, Vd, Vu, EstimateVariance = c(TRUE, TRUE), CenterPredictor = TRUE, 
InitialGuess = NULL, eps = 0.001, MaxIter = 50, MaxIterVar = 50, epsVar = 0.001, 
OutputType = "short", Vttype = NULL, Vetype = NULL, Vdtype = NULL, Vutype = NULL, 
ED = NULL, EDtype = "SingleValue")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLSME_+3A_y">y</code></td>
<td>
<p> A vector of observed response variables.</p>
</td></tr>
<tr><td><code id="GLSME_+3A_d">D</code></td>
<td>
 
<p>a design matrix in which each column corresponds to a parameter to be estimated
in the <code>B</code>-vector/matrix. 
Each entry in these columns corresponds to a data point (e.g. a species
in comparative studies). The first column will typically be a column of ones, which
will estimate an intercept. Columns with indicators for categorical fixed effects can
also be added. Each regression variable is added as a column vector. The program
will automatically estimate one coefficient for each column in the design matrix and
these will be output in the order of the columns in the design matrix. Note that
columns corresponding to &quot;random effects&quot;, indicated by nonzero entry in the <code>Vd</code>
matrix below, will be centered on their means unless the option 
<code>CenterPredictor = FALSE</code> is used to instruct the program to not do this.
If there is to be an INTERCEPT the user needs to put into <code>D</code> a constant column of 1s.</p>
</td></tr>
<tr><td><code id="GLSME_+3A_vt">Vt</code></td>
<td>
<p> The response biological residual covariance matrix (see Details).</p>
</td></tr>
<tr><td><code id="GLSME_+3A_ve">Ve</code></td>
<td>
<p> The response observation error covariance matrix (see Details).
observation errors in the response variable. In a comparative study in which the
response consists of species means, this will typically be a diagonal matrix with
squared standard errors of the means along the diagonal.</p>
</td></tr>
<tr><td><code id="GLSME_+3A_vd">Vd</code></td>
<td>
<p> Represents the true variance structure for the predictor variables. (see Details).</p>
</td></tr>
<tr><td><code id="GLSME_+3A_vu">Vu</code></td>
<td>
<p> The predictor observation variances (see Details)</p>
</td></tr>
<tr><td><code id="GLSME_+3A_estimatevariance">EstimateVariance</code></td>
<td>
 
<p>Option to turn off estimation of the variance parameters. This is a
vector of <code>TRUE</code> or <code>FALSE</code> values, 
where the first value corresponds to the true residual
variance, and the others correspond to the rest of the true predictor
variances. All the predictor variances can also be turned on or
off jointly by providing a single <code>TRUE</code> or <code>FALSE</code> value. 
The default is to estimate all
variance components. If a <code>FALSE</code> value is given the program assumes that the input
variance matrices are exact.</p>
</td></tr>
<tr><td><code id="GLSME_+3A_centerpredictor">CenterPredictor</code></td>
<td>
 <p><code>TRUE</code> or <code>FALSE</code> option to turn off automatic centering of predictors.</p>
</td></tr>
<tr><td><code id="GLSME_+3A_initialguess">InitialGuess</code></td>
<td>
<p> Starting value for the regression in the iterated GLS. The default is
<code>NULL</code>, in which case the program will use an OLS estimate. A specific starting
value can be given as a vector of numbers corresponding to each entry in the <code>B</code>-vector.
An additional number can also be given to specify the starting value of the residual
variance parameter.</p>
</td></tr>
<tr><td><code id="GLSME_+3A_eps">eps</code></td>
<td>
<p> tolerance for iterated GLS</p>
</td></tr>
<tr><td><code id="GLSME_+3A_maxiter">MaxIter</code></td>
<td>
<p> maximum number of iterations for iterated GLS</p>
</td></tr>
<tr><td><code id="GLSME_+3A_maxitervar">MaxIterVar</code></td>
<td>
<p> maximum number of iterations for iterated GLS</p>
</td></tr>
<tr><td><code id="GLSME_+3A_epsvar">epsVar</code></td>
<td>
<p> tolerance for estimating variance parameters in predictors</p>
</td></tr>
<tr><td><code id="GLSME_+3A_outputtype">OutputType</code></td>
<td>
<p> should just the estimates be presented and their standard errors (<code>"short"</code>) or more detailed information (<code>"long"</code>)</p>
</td></tr>
<tr><td><code id="GLSME_+3A_vttype">Vttype</code></td>
<td>
 <p><code>Vt</code> matrix type (see Details)</p>
</td></tr>
<tr><td><code id="GLSME_+3A_vetype">Vetype</code></td>
<td>
 <p><code>Ve</code> matrix type (see Details)</p>
</td></tr>
<tr><td><code id="GLSME_+3A_vdtype">Vdtype</code></td>
<td>
 <p><code>Vd</code> matrix type (see Details)</p>
</td></tr>
<tr><td><code id="GLSME_+3A_vutype">Vutype</code></td>
<td>
 <p><code>Vu</code> matrix type (see Details)</p>
</td></tr>
<tr><td><code id="GLSME_+3A_ed">ED</code></td>
<td>
<p> the expected value of the design matrix, can be <code>NULL</code> then is estimated from the data</p>
</td></tr>
<tr><td><code id="GLSME_+3A_edtype">EDtype</code></td>
<td>
<p> if <code>ED</code> is provided then specifies what is provided, allowed values are :
</p>

<ul>
<li><p><code>"constant"</code>  <code>ED</code> is a number and each value of <code>D</code> has mean equal to this number
</p>
</li>
<li><p><code>"variablemean"</code>  <code>ED</code> is a vector of length of number of variables, each value is a mean for the given predictor variable
</p>
</li>
<li><p><code>NULL</code>  <code>ED</code> is assumed to be calculated</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The code fits the general linear model with correlated data and
observation error in both dependent and independent variables. The code fits the
model 
</p>
<p style="text-align: center;"><code class="reqn">y = D\beta + r, r \sim N(0,V), V = \sigma^{2}V_{t} + V_{e} + Var[U\beta|D],</code>
</p>

<p>where <code>y</code> is a vector of observed response variables, <code>D</code> is an observed design matrix, 
<code class="reqn">\beta</code>
is a vector of parameters to be estimated, <code class="reqn">V_{t}</code> is a matrix representing the true residual
variance up to a scale parameter, <code class="reqn">\sigma^{2}</code>, that is estimated by the program, 
<code class="reqn">V_{e}</code> is a matrix
of known measurement variance in the response variable, and <code>Var[U</code><code class="reqn">\beta</code><code>|D]</code> 
is a matrix
representing effects of measurement error in the predictor variables (see appendix of
Hansen and Bartoszek 2012). To build the <code>Var[U</code><code class="reqn">\beta</code><code>|D]</code> matrix, 
the program needs a known measurement
variance matrix <code class="reqn">V_{u}</code> and a true variance matrix <code class="reqn">V_{xt}</code> 
for each of the predictor variables
(these will be zero for fixed effects). The true variance matrices are assumed to be on
the form <code class="reqn">V_{xt} = \sigma_{x}^{2}Sx</code> , where 
<code>Sx</code> is a matrix supplied by the user, and <code class="reqn">\sigma_{x}^{2}</code> is a scale
parameter that the program estimates by maximum likelihood.
</p>
<p>Note that this program cannot be used to fit parameters that enter nonlinearly
into the variance or the design matrix, as the <code class="reqn">\alpha</code> 
in the adaptation-inertia model, but it
can be used to fit the other parameters in such models conditionally on given values
of the parameterized values of the matrices (and could hence be used as a subroutine
in a program for fitting such models).
</p>
<p>Three important notes for the user :
</p>

<ul>
<li><p>The program does NOT assume there will be an intercept -&gt; hence the user needs to provide a column on <code>1</code>s in the design matrix if an intercept is desired.
</p>
</li>
<li><p>The program by default centres predictors (controlled by <code>CenterPredictor</code>). This means that estimates of
fixed effects will be changed due to them absorbing the mean of the predictors. Using the centering has been
found to improve estimation especially of variance constants (<code>PredictorVarianceConstantEstimate</code> and <code>ResponseVarianceConstantEstimate</code> see Value).
The user should try out the option with <code>CenterPredictor</code> <code>TRUE</code> and <code>FALSE</code> (here fixed effects will not be effected) and compare results.
</p>
</li>
<li><p>The program uses a Monte Carlo procedure as part of the estimation algorithm therefore the user should run the 
code a couple of times to see stability, and combine the results by e.g. a (weighted) average or
choose the best estimate according to e.g. the likelihood or <code class="reqn">R^{2}</code>.
</p>
</li></ul>

<p>The program tries to recognize the structure of the <code>Vt</code>, <code>Ve</code>, <code>Vd</code> and <code>Vu</code>
matrices passed (see the supplementary information to Hansen and Bartoszek 2012)
otherwise the user can specify how the matrix looks like in the appropriate matrix type variable, these can be 
in the respective <code>Vttype</code>, <code>Vetype</code>, <code>Vdtype</code> or <code>Vutype</code> parameter:
</p>

<ul>
<li><p><code>"SingleValue"</code>  the matrix variable is a single number that will be on the diagonal of the covariance matrix, used when the deviations are assumed to be uncorrelated and homoscedastic
</p>
</li>
<li><p><code>"Vector"</code>  the matrix variable is a vector each value corresponding to one of the variables and the covariance matrix will have that vector 
appropriately on its diagonal, if an element of the list has the value <code>"F"</code> then this means that the variable is a fixed effect 
and will get a 0 covariance matrix
</p>
</li>
<li><p><code>"CorrelatedPredictors"</code>  the matrix is a covariance matrix, it assumes that the observations are independent so the resulting covariance structure 
is block diagonal, if some of the variables are fixed effects then in the matrix the values of the corresponding rows 
and columns have to be 0 (this is a special case of BM with the second element equal to the identity matrix)
</p>
</li>
<li><p><code>"MatrixList"</code>  a list of length equal to the number of variables, each list element is the covariance structure 
for the given variable, if an element of the list has the value <code>"F"</code> then this means that the variable is a 
fixed effect and will get a 0 covariance matrix
</p>
</li>
<li><p><code>"BM"</code>  
the matrix variable <code>Vx</code> is to be a list of two values, 
&quot;Vx = Vx[[1]] 
then the first value corresponds to the variable vector covariance while the second will be the matrix of distances between 
species, if the first value is a number or vector then it is changed to a diagonal matrix, 
if some of the variables are fixed effects then in the matrix of the first element of the list the values of the corresponding 
rows and columns have to be 0

</p>
</li>
<li><p><code>NULL</code> or <code>"Matrix"</code>  the matrix is assumed calculated as given
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li><p>GLSestimate  the GLS estimates without any correction (centering the predictors CHANGES fixed effects)
</p>
</li>
<li><p>errorGLSestim  the estimates of their standard errors
</p>
</li>
<li><p>BiasCorrectedGLSestimate  the bias corrected estimates (centering the predictors CHANGES fixed effects)
</p>
</li>
<li><p>K  the bias attenuation factor matrix
</p>
</li>
<li><p>R2  <code class="reqn">R^{2}</code> of the model with the GLS estimates not bias corrected
</p>
</li>
<li><p>BiasCorrectedR2  <code class="reqn">R^{2}</code> of the model with the GLS estimates bias corrected
</p>
</li>
<li><p>PredictorVarianceConstantEstimate  if <code>EstimateVariance[2]</code> is <code>TRUE</code> then the estimates of the unknown variance constants for the predictors otherwise not present
</p>
</li>
<li><p>ResponseVarianceConstantEstimate  if <code>EstimateVariance[1]</code> is <code>TRUE</code> then the estimate of the unknown variance constant for the response otherwise not present
if the <code>outputType</code> variable is set to <code>"long"</code> then the following additional fields will be in the output :
</p>
</li>
<li><p>CovarianceGLSestimate  estimate of the covariance matrix of the bias uncorrected GLS estimates
</p>
</li>
<li><p>CovarianceBiasCorrectedGLSestimate  estimate of the covariance matrix of the bias corrected GLS estimates
</p>
</li>
<li><p>response  the provided <code>y</code> vector
</p>
</li>
<li><p>design  the provided design matrix <code>D</code>
</p>
</li>
<li><p>Vt  the final used <code>Vt</code> matrix with the unknown variance constant incorporated (if estimated)
</p>
</li>
<li><p>Ve  the final used <code>Ve</code> matrix 
</p>
</li>
<li><p>Vd  the final used <code>Vd</code> matrix with the unknown variance constant(s) incorporated (if estimated)
</p>
</li>
<li><p>Vu  the final used <code>Vu</code> matrix
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Bartoszek, K. and Pienaar, J. and Mostad. P. and Andersson, S. and Hansen, T. F. (2012)
A phylogenetic comparative method for studying  multivariate adaptation.
Journal of Theoretical Biology 314:204-215.
</p>
<p>Hansen, T.F. (1997) 
Stabilizing selection and the comparative analysis of adaptation. 
Evolution 51:1341-1351.
</p>
<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>
<p>Hansen, T.F. and Pienaar, J. and Orzack, S.H. (2008) 
A comparative method for studying adaptation to randomly evolving environment. 
Evolution 62:1965-1977.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n&lt;-3 ## number of species
apetree&lt;-ape::rtree(n)
### Define Brownian motion parameters to be able to simulate data under the Brownian motion model.
BMparameters&lt;-list(vX0=matrix(0,nrow=2,ncol=1),Sxx=rbind(c(1,0),c(0.2,1)))
### Now simulate the data and remove the values corresponding to the internal nodes.
xydata&lt;-mvSLOUCH::simulBMProcPhylTree(apetree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
xydata&lt;-xydata[(nrow(xydata)-n+1):nrow(xydata),]

x&lt;-xydata[,1]
y&lt;-xydata[,2]

yerror&lt;-diag((stats::rnorm(n,mean=0,sd=0.1))^2) #create error matrix
y&lt;-mvtnorm::rmvnorm(1,mean=y,sigma=yerror)[1,]
xerror&lt;-diag((stats::rnorm(n,mean=0,sd=0.1))^2) #create error matrix
x&lt;-mvtnorm::rmvnorm(1,mean=x,sigma=xerror)[1,]
GLSME(y=y, CenterPredictor=TRUE, D=cbind(rep(1, n), x), Vt=ape::vcv(apetree), 
Ve=yerror, Vd=list("F",ape::vcv(apetree)), Vu=list("F", xerror))
</code></pre>

<hr>
<h2 id='GLSME.predict'>Prediction for a new observation using parameters estimated by the <code>GLSME</code> function</h2><span id='topic+GLSME.predict'></span>

<h3>Description</h3>

<p>The function takes parameters estimated by the <code>GLSME</code> function and predicts the response
for a new observation of predictors. It also returns confidence intervals on the prediction.
The function is still under development.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLSME.predict(xo, glsme.estimate, vy, vx, alpha = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLSME.predict_+3A_xo">xo</code></td>
<td>
<p> The new observed predictors. In a intercept is in the model then a 1 has to be included for it.</p>
</td></tr>
<tr><td><code id="GLSME.predict_+3A_glsme.estimate">glsme.estimate</code></td>
<td>
<p> The output of the <code>GLSME</code> function. Has to have format <code>"long"</code>.</p>
</td></tr>
<tr><td><code id="GLSME.predict_+3A_vy">vy</code></td>
<td>
<p> Residual variance, both biological and measurement error.</p>
</td></tr>
<tr><td><code id="GLSME.predict_+3A_vx">vx</code></td>
<td>
<p> Biological variance in predictor, NOT observation variance of predictor. If there is a predictor in the model then a 0 row and column have to included for it.</p>
</td></tr>
<tr><td><code id="GLSME.predict_+3A_alpha">alpha</code></td>
<td>
<p> Level for confidence interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>BiasCorr</code></td>
<td>
<p> Prediction using the bias corrected estimate.
</p>

<ul>
<li><p>prediction  Predicted value
</p>
</li>
<li><p>MSE  Estimate of mean square error. They are calculated by the formula
</p>
<p style="text-align: center;"><code class="reqn">v_{y}+x_{o}^{T}(MSE[\beta | XO])x_{o}+ \beta'^{T} v_{x} \beta',</code>
</p>

<p>where <code class="reqn">\beta'</code> is the bias corrected estimate of <code class="reqn">\beta</code>.

</p>
</li>
<li><p>CI  <code class="reqn">1-\alpha</code> level confidence intervals. They are calculated by the formula
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{1+1/n}*t_{\alpha}*(v_{y}+ \beta'^{T} v_{x} \beta'),</code>
</p>

<p>where <code class="reqn">t_{\alpha}</code> is the <code class="reqn">1-\alpha/2</code> level quantile of the t-distribution with n-k degrees of freedom,
k is the number of regression parameters to estimate, 
<code class="reqn">\beta'</code> is the bias corrected estimate of <code class="reqn">\beta</code> and n is the sample size used in 
the estimation.
</p>
</li></ul>

</td></tr>
<tr><td><code>BiasUncorr</code></td>
<td>
<p> Prediction using the bias uncorrected estimate.
</p>

<ul>
<li><p>prediction  Predicted value
</p>
</li>
<li><p>MSE  Estimate of mean square error. They are calculated by the formula
</p>
<p style="text-align: center;"><code class="reqn">v_{y}+x_{o}^{T}(MSE[\beta | XO])x_{o}+ \beta'^{T} v_{x} \beta',</code>
</p>

<p>where <code class="reqn">\beta'</code> is the bias uncorrected estimate of <code class="reqn">\beta</code>.

</p>
</li>
<li><p>CI  <code class="reqn">1-\alpha</code> level confidence intervals. They are calculated by the formula
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{1+1/n}*t_{\alpha}*(v_{y}+ \beta'^{T} v_{x} \beta'),</code>
</p>

<p>where <code class="reqn">t_{\alpha}</code> is the <code class="reqn">1-\alpha/2</code> level quantile of the t-distribution with n-k degrees of freedom,
k is the number of regression parameters to estimate, <code class="reqn">\beta'</code> is the bias uncorrected estimate of <code class="reqn">\beta</code> 
and n is the sample size used in the estimation.
</p>
</li></ul>

</td></tr>
</table>


<h3>Author(s)</h3>

<p>Krzysztof Bartoszek</p>


<h3>References</h3>

<p>Hansen, T.F. and Bartoszek, K. (2012)
Interpreting the evolutionary regression: the interplay between observational and biological errors in phylogenetic comparative studies.
Systematic Biology 61(3):413-425.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
n&lt;-3 ## number of species
apetree&lt;-ape::rtree(n)
### Define Brownian motion parameters to be able to simulate data under the Brownian motion model.
BMparameters&lt;-list(vX0=matrix(0,nrow=2,ncol=1),Sxx=rbind(c(1,0),c(0.2,1)))
### Now simulate the data and remove the values corresponding to the internal nodes.
xydata&lt;-mvSLOUCH::simulBMProcPhylTree(apetree,X0=BMparameters$vX0,Sigma=BMparameters$Sxx)
xydata&lt;-xydata[(nrow(xydata)-n+1):nrow(xydata),]

x&lt;-xydata[,1]
y&lt;-xydata[,2]

yerror&lt;-diag((stats::rnorm(n,mean=0,sd=0.1))^2) #create error matrix
y&lt;-mvtnorm::rmvnorm(1,mean=y,sigma=yerror)[1,]
xerror&lt;-diag((stats::rnorm(n,mean=0,sd=0.1))^2) #create error matrix
x&lt;-mvtnorm::rmvnorm(1,mean=x,sigma=xerror)[1,]
glsme.res&lt;-GLSME(y=y, CenterPredictor=TRUE, D=cbind(rep(1, n), x), Vt=ape::vcv(apetree), 
Ve=yerror, Vd=list("F",ape::vcv(apetree)), Vu=list("F", xerror),OutputType="long")
GLSME.predict(c(1,1), glsme.res, vy=1, vx=rbind(c(0,0),c(0,1)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
