<!DOCTYPE html><html><head><title>Help for package bcv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bcv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bcv-package'><p>Cross-Validation for the SVD (Bi-Cross-Validation)</p></a></li>
<li><a href='#cv.svd.gabriel'><p>Cross-Validation for choosing the rank of an SVD approximation.</p></a></li>
<li><a href='#impute.svd'><p>Missing value imputation via the SVDImpute algorithm</p></a></li>
<li><a href='#plot.cvsvd'><p>Plot the Result of an SVD Cross-Validation</p></a></li>
<li><a href='#print.cvsvd'><p>Print the Result of an SVD Cross-Validation</p></a></li>
<li><a href='#summary.cvsvd'><p>Summarize the Result of an SVD Cross-Validation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Cross-Validation for the SVD (Bi-Cross-Validation)</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Methods for choosing the rank of an SVD (singular value decomposition) 
    approximation via cross validation. The package provides both Gabriel-style 
    "block" holdouts and Wold-style "speckled" holdouts. It also includes an 
    implementation of the SVDImpute algorithm. For more information about
    Bi-cross-validation, see Owen &amp; Perry's 2009 AoAS article
    (at &lt;<a href="https://arxiv.org/abs/0908.2062">arXiv:0908.2062</a>&gt;) and Perry's 2009 PhD thesis
    (at &lt;<a href="https://arxiv.org/abs/0909.3052">arXiv:0909.3052</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/michbur/bcv">https://github.com/michbur/bcv</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/michbur/bcv/issues">https://github.com/michbur/bcv/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-19 10:10:02 UTC; michbur</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Burdukiewicz
    <a href="https://orcid.org/0000-0001-8926-582X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, ctb],
  Patrick O. Perry [aut, cph],
  Seyed Morteza Najibi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Burdukiewicz &lt;michalburdukiewicz@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-19 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bcv-package'>Cross-Validation for the SVD (Bi-Cross-Validation)</h2><span id='topic+bcv-package'></span><span id='topic+bcv'></span>

<h3>Description</h3>

<p>This package implements methods for choosing the rank of an SVD
approximation via cross validation.  It provides both Gabriel-style &quot;block&quot;
holdouts and Wold-style &quot;speckled&quot; holdouts.  Also included is an
implementation of the SVDImpute algorithm.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> bcv</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
1.0</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2009-08-15</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> BSD3</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>Basic usage is to call either <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>.
</p>


<h3>Author(s)</h3>

<p>Patrick O. Perry &lt;patperry@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute.svd">impute.svd</a></code>, <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code>,
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>, <code><a href="#topic+plot.cvsvd">plot.cvsvd</a></code>,
<code><a href="#topic+print.cvsvd">print.cvsvd</a></code> <code><a href="#topic+summary.cvsvd">summary.cvsvd</a></code>
</p>

<hr>
<h2 id='cv.svd.gabriel'>Cross-Validation for choosing the rank of an SVD approximation.</h2><span id='topic+cv.svd.gabriel'></span><span id='topic+cv.svd'></span><span id='topic+cv.svd.wold'></span>

<h3>Description</h3>

<p>Perform Wold- or Gabriel-style cross-validation for determining the
appropriate rank SVD approximation of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.svd.gabriel(
  x,
  krow = 2,
  kcol = 2,
  maxrank = floor(min(n - n/krow, p - p/kcol))
)

cv.svd.wold(x, k = 5, maxrank = 20, tol = 1e-04, maxiter = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.svd.gabriel_+3A_x">x</code></td>
<td>
<p>the matrix to cross-validate.</p>
</td></tr>
<tr><td><code id="cv.svd.gabriel_+3A_krow">krow</code></td>
<td>
<p>the number of row folds (for Gabriel-style CV).</p>
</td></tr>
<tr><td><code id="cv.svd.gabriel_+3A_kcol">kcol</code></td>
<td>
<p>the number of column folds (for Gabriel-style CV).</p>
</td></tr>
<tr><td><code id="cv.svd.gabriel_+3A_maxrank">maxrank</code></td>
<td>
<p>the maximum rank to cross-validate up to.</p>
</td></tr>
<tr><td><code id="cv.svd.gabriel_+3A_k">k</code></td>
<td>
<p>the number of folds (for Wold-style CV).</p>
</td></tr>
<tr><td><code id="cv.svd.gabriel_+3A_tol">tol</code></td>
<td>
<p>the convergence tolerance for <code><a href="#topic+impute.svd">impute.svd</a></code>.</p>
</td></tr>
<tr><td><code id="cv.svd.gabriel_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations for
<code><a href="#topic+impute.svd">impute.svd</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are for cross-validating the SVD of a matrix.  They assume a
model $X = U D V' + E$ with the terms being signal and noise, and try to
find the best rank to truncate the SVD of <code>x</code> at for minimizing
prediction error.  Here, prediction error is measured as sum of squares of
residuals between the truncated SVD and the signal part.
</p>
<p>For both types of cross-validation, in each replicate we leave out part of
the matrix, fit an SVD approximation to the left-in part, and measure
prediction error on the left-out part.
</p>
<p>In Wold-style cross-validation, the holdout set is &quot;speckled&quot;, a random set
of elements in the matrix.  The missing elements are predicted using
<code><a href="#topic+impute.svd">impute.svd</a></code>.
</p>
<p>In Gabriel-style cross-validation, the holdout set is &quot;blocked&quot;.  We permute
the rows and columns of the matrix, and leave out the lower-right block.  We
use a modified Schur-complement to predict the held-out block.  In
Gabriel-style, there are <code>krow*kcol</code> total folds.
</p>


<h3>Value</h3>

<table>
<tr><td><code>call</code></td>
<td>
<p>the function call</p>
</td></tr> <tr><td><code>msep</code></td>
<td>
<p>the mean square error
of prediction (MSEP); this is a matrix whose columns contain the mean square
errors in the predictions of the holdout sets for ranks 0, 1, ...,
<code>maxrank</code> across the different replicates.</p>
</td></tr> <tr><td><code>maxrank</code></td>
<td>
<p>the maximum
rank for which prediction error is estimated; this is equal to
<code>nrow(msep)+1</code>.</p>
</td></tr>
<tr><td><code>krow</code></td>
<td>
<p>the number of row folds (for Gabriel-style only).</p>
</td></tr> <tr><td><code>kcol</code></td>
<td>
<p>the number of column folds (for Gabriel-style only).</p>
</td></tr> <tr><td><code>rowsets</code></td>
<td>
<p>the
partition of rows into <code>krow</code> holdout sets (for Gabriel-style only).</p>
</td></tr>
<tr><td><code>colsets</code></td>
<td>
<p>the partition of the columns into <code>kcol</code> holdout sets
(for Gabriel-style only).</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>the number of folds (for Wold-style only).</p>
</td></tr> <tr><td><code>sets</code></td>
<td>
<p>the
partition of indices into <code>k</code> holdout sets (for Wold-style only).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Gabriel's version of cross-validation was for leaving out a single
element of the matrix, which corresponds to n-by-p-fold.  Owen and Perry
generalized Gabriel's idea to larger holdouts, showing that 2-by-2-fold
cross-validation often works better.
</p>
<p>Wold's original version of cross-validation did not use the EM algorithm to
estimate the SVD.  He recommend using the NIPALS algorithm instead, which
has since faded into obscurity.
</p>
<p>Wold-style cross-validation takes a lot more computation than Gabriel-style.
The <code>maxrank</code>, <code>tol</code>, and <code>maxiter</code> have been chosen to give
up some accuracy in the name of expediency.  They may need to be adjusted to
get the best results.
</p>


<h3>Author(s)</h3>

<p>Patrick O. Perry
</p>


<h3>References</h3>

<p>Gabriel, K.R. (2002). Le biplot - outil d'explaration de
données multidimensionelles.  <em>Journal de la Société 
française de statistique</em>, Volume 143 (2002) no. 3-4, pp. 5-55.
B.
</p>
<p>Owen, A.B. and Perry, P.O. (2009). Bi-cross-validation of the SVD and the
non-negative matrix factorization.  <em>Annals of Applied Statistics</em>
<b>3</b>(2) 564&ndash;594.
</p>
<p>Wold, S. (1978).  Cross-validatory estimation of the number of components in
factor and principal components models.  <em>Technometrics</em> <b>20</b>(4)
397&ndash;405.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute.svd">impute.svd</a></code>, <code><a href="#topic+plot.cvsvd">plot.cvsvd</a></code>,
<code><a href="#topic+print.cvsvd">print.cvsvd</a></code> <code><a href="#topic+summary.cvsvd">summary.cvsvd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # generate a rank-2 matrix plus noise
  n &lt;- 50; p &lt;- 20; k &lt;- 2
  u &lt;- matrix( rnorm( n*k ), n, k )
  v &lt;- matrix( rnorm( p*k ), p, k )
  e &lt;- matrix( rnorm( n*p ), n, p )
  x &lt;- u %*% t(v) + e
  
  # perform 5-fold Wold-style cross-validtion
  (cvw &lt;- cv.svd.wold( x, 5, maxrank=10 ))
  
  # perform (2,2)-fold Gabriel-style cross-validation
  (cvg &lt;- cv.svd.gabriel( x, 2, 2, maxrank=10 ))

</code></pre>

<hr>
<h2 id='impute.svd'>Missing value imputation via the SVDImpute algorithm</h2><span id='topic+impute.svd'></span>

<h3>Description</h3>

<p>Given a matrix with missing values, impute the missing entries using a
low-rank SVD approximation estimated by the EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute.svd(x, k = min(n, p), tol = max(n, p) * 1e-10, maxiter = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute.svd_+3A_x">x</code></td>
<td>
<p>a matrix to impute the missing entries of.</p>
</td></tr>
<tr><td><code id="impute.svd_+3A_k">k</code></td>
<td>
<p>the rank of the SVD approximation.</p>
</td></tr>
<tr><td><code id="impute.svd_+3A_tol">tol</code></td>
<td>
<p>the convergence tolerance for the EM algorithm.</p>
</td></tr>
<tr><td><code id="impute.svd_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of EM steps to take.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Impute the missing values of <code>x</code> as follows: First, initialize all
<code>NA</code> values to the column means, or <code>0</code> if all entries in the
column are missing.  Then, until convergence, compute the first <code>k</code>
terms of the SVD of the completed matrix.  Replace the previously missing
values with their approximations from the SVD, and compute the RSS between
the <em>non-missing</em> values and the SVD.
</p>
<p>Declare convergence if <code> abs(rss0 - rss1) / (.Machine$double.eps +
rss1) &lt; tol </code>, where <code>rss0</code> and <code>rss1</code> are the RSS values computed
from successive iterations.  Stop early after <code>maxiter</code> iterations and
issue a warning.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>the completed version of the matrix.</p>
</td></tr> <tr><td><code>rss</code></td>
<td>
<p>the sum of
squares between the SVD approximation and the non-missing values in
<code>x</code>.</p>
</td></tr> <tr><td><code>iter</code></td>
<td>
<p>the number of EM iterations before algorithm
stopped.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick O. Perry
</p>


<h3>References</h3>

<p>Troyanskaya, O., Cantor, M., Sherlock, G., Brown, P., Hastie,
T., Tibshirani, R., Botstein, D. and Altman, R.B. (2001).  Missing value
estimation methods for DNA microarrays.  <em>Bioinformatics</em> <b>17</b>(6),
520&ndash;525.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # Generate a matrix with missing entries    
  n &lt;- 20
  p &lt;- 10
  u &lt;- rnorm( n )
  v &lt;- rnorm( p )
  xfull &lt;- u %*% rbind( v ) + rnorm( n*p )
  miss  &lt;- sample( seq_len( n*p ), n )
  x       &lt;- xfull
  x[miss] &lt;- NA
      
  # impute the missing entries with a rank-1 SVD approximation
  xhat &lt;- impute.svd( x, 1 )$x   
  
  # compute the prediction error for the missing entries
  sum( ( xfull-xhat )^2 )

</code></pre>

<hr>
<h2 id='plot.cvsvd'>Plot the Result of an SVD Cross-Validation</h2><span id='topic+plot.cvsvd'></span>

<h3>Description</h3>

<p>Plot the result of <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>, optionally with error bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvsvd'
plot(
  x,
  errorbars = TRUE,
  add = FALSE,
  xlab = "Rank",
  ylab = "Mean Sq. Prediction Error",
  col = "blue",
  col.errorbars = "gray50",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cvsvd_+3A_x">x</code></td>
<td>
<p>the result of a <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code>link{cv.svd.wold}</code> computation.</p>
</td></tr>
<tr><td><code id="plot.cvsvd_+3A_errorbars">errorbars</code></td>
<td>
<p>indicates whether or not to add error bars.</p>
</td></tr>
<tr><td><code id="plot.cvsvd_+3A_add">add</code></td>
<td>
<p>indicates whether or not to add to the current plot.</p>
</td></tr>
<tr><td><code id="plot.cvsvd_+3A_xlab">xlab</code></td>
<td>
<p>the label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.cvsvd_+3A_ylab">ylab</code></td>
<td>
<p>the label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.cvsvd_+3A_col">col</code></td>
<td>
<p>the color to use for showing prediction error.</p>
</td></tr>
<tr><td><code id="plot.cvsvd_+3A_col.errorbars">col.errorbars</code></td>
<td>
<p>the color to use for the error bars.</p>
</td></tr>
<tr><td><code id="plot.cvsvd_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the result of <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>.  This plots a the estimated prediction error as a
function of rank, optionally with error bars.
</p>
<p>If <code>add</code> is <code>TRUE</code>, the current plot is not cleared.
</p>


<h3>Author(s)</h3>

<p>Patrick O. Perry
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code>, <code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>,
<code><a href="#topic+print.cvsvd">print.cvsvd</a></code> <code><a href="#topic+summary.cvsvd">summary.cvsvd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  # generate a rank-2 matrix plus noise
  n &lt;- 50; p &lt;- 20; k &lt;- 2
  u &lt;- matrix( rnorm( n*k ), n, k )
  v &lt;- matrix( rnorm( p*k ), p, k )
  e &lt;- matrix( rnorm( n*p ), n, p )
  x &lt;- u %*% t(v) + e
  
  # perform 5-fold Wold-style cross-validtion
  cvw &lt;- cv.svd.wold( x, 5, maxrank=10 )
  
  # perform (2,2)-fold Gabriel-style cross-validation
  cvg &lt;- cv.svd.gabriel( x, 2, 2, maxrank=10 )
  
  # plot the results
  par( mfrow=c(2,1) )
  plot( cvw, main="Wold-style CV")
  plot( cvg, main="Gabriel-style CV")

</code></pre>

<hr>
<h2 id='print.cvsvd'>Print the Result of an SVD Cross-Validation</h2><span id='topic+print.cvsvd'></span>

<h3>Description</h3>

<p>Print the result of <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvsvd'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cvsvd_+3A_x">x</code></td>
<td>
<p>the result of a <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code> computation.</p>
</td></tr>
<tr><td><code id="print.cvsvd_+3A_digits">digits</code></td>
<td>
<p>the digits of precision to show in the output.</p>
</td></tr>
<tr><td><code id="print.cvsvd_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print a table of the estimated prediction errors and the standard errors of
the estimate.  Put an asterisk (<code>*</code>) next to the minimum and a plus
(<code>+</code>) next to the &quot;one standard error rule&quot; choice.
</p>


<h3>Author(s)</h3>

<p>Patrick O. Perry
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code>, <code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>,
<code><a href="#topic+plot.cvsvd">plot.cvsvd</a></code> <code><a href="#topic+summary.cvsvd">summary.cvsvd</a></code>
</p>

<hr>
<h2 id='summary.cvsvd'>Summarize the Result of an SVD Cross-Validation</h2><span id='topic+summary.cvsvd'></span>

<h3>Description</h3>

<p>Summarize the result of <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cvsvd'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cvsvd_+3A_object">object</code></td>
<td>
<p>the result of a <code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code> or
<code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code> computation.</p>
</td></tr>
<tr><td><code id="summary.cvsvd_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>summary</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Print a table of the estimated prediction errors and the standard errors of
the estimate.  Put an asterisk (<code>*</code>) next to the minimum and a plus
(<code>+</code>) next to the &quot;one standard error rule&quot; choice.
</p>


<h3>Value</h3>

<table>
<tr><td><code>nfolds</code></td>
<td>
<p>the number of cross-validation folds</p>
</td></tr> <tr><td><code>maxrank</code></td>
<td>
<p>the maximum rank for which prediction error is estimated.</p>
</td></tr> <tr><td><code>msep.mean</code></td>
<td>
<p>the average mean square error of prediction (MSEP) across all folds for
ranks 0, 1, ..., <code>maxrank</code>.</p>
</td></tr> <tr><td><code>msep.se</code></td>
<td>
<p>the standard errors of the
<code>msep.mean</code> estimates.</p>
</td></tr> <tr><td><code>rank.best</code></td>
<td>
<p>the rank with the minimum
<code>msep.mean</code> value.</p>
</td></tr> <tr><td><code>rank.1se</code></td>
<td>
<p>the smallest rank within one
standard error of the minimum <code>msep.mean</code> value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Patrick O. Perry
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.svd.gabriel">cv.svd.gabriel</a></code>, <code><a href="#topic+cv.svd.wold">cv.svd.wold</a></code>,
<code><a href="#topic+plot.cvsvd">plot.cvsvd</a></code> <code><a href="#topic+print.cvsvd">print.cvsvd</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
