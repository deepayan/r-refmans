<!DOCTYPE html><html lang="en"><head><title>Help for package SAFARI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SAFARI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SAFARI-package'><p>Shape Analysis for AI-Reconstructed Images</p></a></li>
<li><a href='#binary.segmentation'><p>Segmentation Procedure for Binary Images</p></a></li>
<li><a href='#compute.features'><p>Shape Features</p></a></li>
<li><a href='#rBPS'><p>Reconstructed Binary Pathology Slide</p></a></li>
<li><a href='#rc.plot'><p>Reconstructed Image Plot</p></a></li>
<li><a href='#read.image'><p>Read a Binary Image</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Shape Analysis for AI-Reconstructed Images</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for image processing and shape analysis in 
    the context of reconstructed medical images generated by deep learning-based
    methods or standard image processing algorithms and produced from different
    medical imaging types, such as X-ray, Computational Tomography (CT),
    Magnetic Resonance Imaging (MRI), and pathology imaging. Specifically,
    offers tools to segment regions of interest and to extract quantitative
    shape descriptors for applications in signal processing,
    statistical analysis and modeling, and machine learning.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caTools, EBImage, graphics, lattice, png</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/estfernandez/SAFARI">https://github.com/estfernandez/SAFARI</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-02-23 19:34:09 UTC; estfernandez</td>
</tr>
<tr>
<td>Author:</td>
<td>Esteban Fernandez Morales [aut, cre],
  Qiwei Li [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Esteban Fernandez Morales &lt;esteban.fernandezmorales@utdallas.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-02-25 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='SAFARI-package'>Shape Analysis for AI-Reconstructed Images</h2><span id='topic+SAFARI-package'></span>

<h3>Description</h3>

<p>The R package <span class="pkg">SAFARI</span> provides functions for image processing and
shape analysis of regions of interest (ROI) in AI-reconstructed images.
</p>


<h3>Details</h3>

<p>The main functions are summarized as follows:
</p>

<ul>
<li> <p><code>read.image</code>: loads and preprocesses reconstructed binary images for segmentation;
</p>
</li>
<li> <p><code>binary.segmentation</code>: ROI segmentation and optional feature extraction;
</p>
</li>
<li> <p><code>compute.features</code>: feature extraction for an individual ROI;
</p>
</li>
<li> <p><code>rc.plot</code>: visualize reconstructed binary or segmented images.
</p>
</li></ul>

<p>See the package vignettes for more introduction and demonstration.
</p>

<hr>
<h2 id='binary.segmentation'>Segmentation Procedure for Binary Images</h2><span id='topic+binary.segmentation'></span>

<h3>Description</h3>

<p>Identify and segment the regions of interest (ROI) in a reconstructed binary
image, while having the option to extract quantitative shape-based features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary.segmentation(
  x,
  id,
  filter = NA,
  k = 3,
  categories = c("none", "geometric", "boundary", "topological")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binary.segmentation_+3A_x">x</code></td>
<td>
<p>a binary matrix that represents the reconstructed image.</p>
</td></tr>
<tr><td><code id="binary.segmentation_+3A_id">id</code></td>
<td>
<p>a named character vector that contains the ID's pertaining to the sample.</p>
</td></tr>
<tr><td><code id="binary.segmentation_+3A_filter">filter</code></td>
<td>
<p>an integer vector that indicates the filtering procedure.</p>
</td></tr>
<tr><td><code id="binary.segmentation_+3A_k">k</code></td>
<td>
<p>an integer that specifies the factor to enlarge the regions.</p>
</td></tr>
<tr><td><code id="binary.segmentation_+3A_categories">categories</code></td>
<td>
<p>a character string or vector, see <code><a href="#topic+compute.features">compute.features</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>id</code> specifies the ID's corresponding to the sample.
A usual example that is used if the argument is an unnamed vector is composed
of the following entries:
</p>

<ul>
<li> <p><code>cohort</code>: name of cohort the sample belongs to;
</p>
</li>
<li> <p><code>patient.id</code>: unique identifier for patient the sample belongs to;
</p>
</li>
<li> <p><code>slide.id</code>: unique identifier for sample.
</p>
</li></ul>

<p>The argument <code>filter</code> specifies how the ROI should be filtered. There
are two ways to filter them, either by only specifying a minimum net area or
by additionally specifying the <code class="reqn">n</code> largest regions to keep in a two element
vector. The default value is <code>NA</code> which sets the minimum net area as
one-fourth the largest region.
</p>
<p>The argument <code>categories</code> specifies the shape features to compute. The
default is &quot;none&quot; which computes no features.
</p>


<h3>Value</h3>

<p>A <code>list</code> object whose components are the following:
</p>

<ul>
<li> <p><code>desc</code>:       a <code>data.frame</code> of the shape features
corresponding to each segmented ROI;
</p>
</li>
<li> <p><code>holes</code>:      an integer matrix that contains the holes within
each ROI, labeled according to
the <code>regions</code>;
</p>
</li>
<li> <p><code>id</code>:         a character vector that is identical to the
<code>id</code> argument passed;
</p>
</li>
<li> <p><code>k</code>:          argument <code>k</code> passed to function;
</p>
</li>
<li> <p><code>n</code>:          an integer that indicates the number of
segmented regions;
</p>
</li>
<li> <p><code>plg.chains</code>: a <code>list</code> where each component is the
polygonal chain of a segmented ROI;
</p>
</li>
<li> <p><code>regions</code>:    an integer matrix that contains the segmented
ROI, labeled from largest to smallest.
</p>
</li></ul>



<h3>Reconstructed Binary Image</h3>

<p>To produce a reconstructed binary image, a greyscale scan or an image easily
converted to binary, resulting from different modalities, is converted
to a matrix representation, usually by standard image processing algorithms.
</p>
<p>The resulting matrix is composed of two integer values that help represent the
regions of interest in the scan. Usually, as in the case of pathology
imaging, these are empty regions and tumor tissues, where we refer to the
integer values as categories. We note that the regions of interest must be
represented by <code>1</code>'s and what we consider the empty regions by <code>0</code>'s.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load libraries
library(SAFARI)

# load sample
data("rBPS")

# segmentation procedure
rBPS &lt;- binary.segmentation(
    rBPS,
    id = c("NLST", "AA00474", "11030"),
    filter = 150,
    categories = c("geometric", "boundary", "topological")
)
</code></pre>

<hr>
<h2 id='compute.features'>Shape Features</h2><span id='topic+compute.features'></span>

<h3>Description</h3>

<p>Compute the shape descriptors of the given region, represented by its
binary matrix and the polygonal chain of its boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.features(
  region,
  plg.chain,
  categories = c("geometric", "boundary", "topological")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute.features_+3A_region">region</code></td>
<td>
<p>a binary matrix that represents the region.</p>
</td></tr>
<tr><td><code id="compute.features_+3A_plg.chain">plg.chain</code></td>
<td>
<p>an <code class="reqn">n</code>-by-<code class="reqn">2</code> numeric matrix that represents the boundary.</p>
</td></tr>
<tr><td><code id="compute.features_+3A_categories">categories</code></td>
<td>
<p>a character string or vector, specifying which features to compute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shape descriptors are divided into three categories: geometric, boundary,
and topological. The default will compute the features from all categories.
We also note that, for the binary matrix, the ones and zeros make up the
region of interest and background, respectively.
</p>


<h3>Value</h3>

<p>A numeric vector composed of the shape descriptors.
</p>


<h3>See Also</h3>

<p>See <a href="https://en.wikipedia.org/wiki/Polygonal_chain">Polygonal Chain</a>
for more information on the closed polygonal chain.
</p>

<hr>
<h2 id='rBPS'>Reconstructed Binary Pathology Slide</h2><span id='topic+rBPS'></span>

<h3>Description</h3>

<p>This reconstructed binary image was first represented as a three-class image,
prepared using a tumor recognition system (ConvPath) developed by the
Quantitative Biomedical Research Center. The original whole-slide image
comes from a lung cancer patient in the Lung Screening Study (LSS)
subcomponent of NLST. Specifically, this is an image from an H&amp;E-stained
slide that was obtained as part of a pathology specimen collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rBPS)
</code></pre>


<h3>Format</h3>

<p><code>rBPS</code> is a 314-by-224 binary matrix where each entry
corresponds to a tissue or region in the H&amp;E image. In our case the ones and
zeros indicate an empty region or tumor tissue, respectively.
</p>


<h3>Source</h3>

<p>Original H&amp;E slide available at
<a href="https://biometry.nci.nih.gov/cdas/nlst/">https://biometry.nci.nih.gov/cdas/nlst/</a>.
</p>


<h3>References</h3>

<p>ConvPath: A software tool for lung adenocarcinoma digital
pathological image analysis aided by a convolutional neural network. (2019)
EBioMedicine.
</p>

<hr>
<h2 id='rc.plot'>Reconstructed Image Plot</h2><span id='topic+rc.plot'></span>

<h3>Description</h3>

<p>Plot a reconstructed image obtained from various types of modalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc.plot(x, type = c("binary", "segments"), publication = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rc.plot_+3A_x">x</code></td>
<td>
<p>an integer matrix that represents the reconstructed image.</p>
</td></tr>
<tr><td><code id="rc.plot_+3A_type">type</code></td>
<td>
<p>a character string that specifies the image type.</p>
</td></tr>
<tr><td><code id="rc.plot_+3A_publication">publication</code></td>
<td>
<p>a logical value, whether to create a figure without key nor scales.</p>
</td></tr>
<tr><td><code id="rc.plot_+3A_...">...</code></td>
<td>
<p>additional graphical parameters passed to <code><a href="lattice.html#topic+levelplot">levelplot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>type</code> specifies the image type with the following options:
</p>

<ul>
<li><p> binary: reconstructed binary image, representing a greyscale medical image;
</p>
</li>
<li><p> segments: segmented matrix, where each region is denoted by an integer value.
</p>
</li></ul>



<h3>Value</h3>

<p>No return value, called for side effects i.e. plotting.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary.segmentation">binary.segmentation</a></code> for more information on reconstructed images.
</p>

<hr>
<h2 id='read.image'>Read a Binary Image</h2><span id='topic+read.image'></span>

<h3>Description</h3>

<p>This function reads a reconstructed binary image, possibly, produced from an
X-Ray, CT scan, MRI, etc. and processed by standard image processing
algorithms. The image is then preprocessed to facilitate the procedure in
the <code><a href="#topic+binary.segmentation">binary.segmentation</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.image(file, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.image_+3A_file">file</code></td>
<td>
<p>a character string that specifies the image to read.</p>
</td></tr>
<tr><td><code id="read.image_+3A_invert">invert</code></td>
<td>
<p>a logical value that indicates if the B/W colors should be inverted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The binary image is preprocessed as follows:
</p>

<ul>
<li><p> Check if image contains multiple color channels, non-binary, or empty.
</p>
</li>
<li><p> Invert black and white colors (optional).
</p>
</li>
<li><p> Ensure image is truly binary by converting all values greater than zero to <code>1</code>.
</p>
</li>
<li><p> Expand the border around the image with <code>0</code>s.
</p>
</li>
<li><p> Rotating the image, if it is not stored as an <code>RData</code> file.
</p>
</li></ul>



<h3>Value</h3>

<p>An integer matrix that represents the preprocessed image.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary.segmentation">binary.segmentation</a></code> for more information on reconstructed binary images.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
