<!DOCTYPE html><html lang="en"><head><title>Help for package micEconSNQP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {micEconSNQP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#predict.snqProfitEst'><p>Predictions from an SNQ profit function</p></a></li>
<li><a href='#print.snqProfitEst'><p>Print output of estimated SNQ profit function</p></a></li>
<li><a href='#residuals.snqProfitEst'><p>Residuals of an SNQ profit function</p></a></li>
<li><a href='#snqProfitCalc'><p>Calculations with the SNQ Profit function</p></a></li>
<li><a href='#snqProfitEla'><p>Price Elasticities of SNQ Profit function</p></a></li>
<li><a href='#snqProfitEst'><p>Estimation of a SNQ Profit function</p></a></li>
<li><a href='#snqProfitFixEla'><p>Fixed Factor Elasticities of SNQ Profit function</p></a></li>
<li><a href='#snqProfitHessian'><p>SNQ Profit function: Hessian matrix</p></a></li>
<li><a href='#snqProfitHessianDeriv'><p>SNQ Profit function: Derivatives of the Hessian</p></a></li>
<li><a href='#snqProfitImposeConvexity'><p>Imposing Convexity on a SNQ Profit function</p></a></li>
<li><a href='#snqProfitShadowPrices'><p>Shadow Prices of a SNQ Profit function</p></a></li>
<li><a href='#snqProfitWeights'><p>SNQ Profit function: Weights of prices for normalization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6-10</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Symmetric Normalized Quadratic Profit Function</td>
</tr>
<tr>
<td>Author:</td>
<td>Arne Henningsen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arne Henningsen &lt;arne.henningsen@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>micEcon (&ge; 0.6-1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>miscTools (&ge; 0.6-1), systemfit (&ge; 1.0-0), MASS</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for econometric production analysis
   with the Symmetric Normalized Quadratic (SNQ) profit function,
   e.g. estimation, imposing convexity in prices,
   and calculating elasticities and shadow prices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.micEcon.org">http://www.micEcon.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-20 15:41:04 UTC; gsl324</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-21 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='predict.snqProfitEst'>Predictions from an SNQ profit function</h2><span id='topic+predict.snqProfitEst'></span><span id='topic+predict.snqProfitImposeConvexity'></span>

<h3>Description</h3>

<p>Returns the predicted values, their standard errors and the
confidence limits of prediction for an
Symmetric Normalized Quadratic (SNQ) profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snqProfitEst'
predict( object, newdata = object$data,
   se.fit = FALSE, se.pred = FALSE, interval = "none", level = 0.95,
   useDfSys = TRUE, ... )

## S3 method for class 'snqProfitImposeConvexity'
predict( object, newdata = object$data,
   se.fit = FALSE, se.pred = FALSE, interval = "none", level = 0.95,
   useDfSys = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.snqProfitEst_+3A_object">object</code></td>
<td>
<p>an object of type <code>snqProfitEst</code> or
<code>snqProfitImposeConvexity</code>.</p>
</td></tr>
<tr><td><code id="predict.snqProfitEst_+3A_newdata">newdata</code></td>
<td>
<p>data frame in which to predict.</p>
</td></tr>
<tr><td><code id="predict.snqProfitEst_+3A_se.fit">se.fit</code></td>
<td>
<p>logical. Return the standard error of the fitted values?</p>
</td></tr>
<tr><td><code id="predict.snqProfitEst_+3A_se.pred">se.pred</code></td>
<td>
<p>logical. Return the standard error of prediction?</p>
</td></tr>
<tr><td><code id="predict.snqProfitEst_+3A_interval">interval</code></td>
<td>
<p>Type of interval calculation (&quot;none&quot;, &quot;confidence&quot;
or &quot;prediction&quot;).</p>
</td></tr>
<tr><td><code id="predict.snqProfitEst_+3A_level">level</code></td>
<td>
<p>confidence level.</p>
</td></tr>
<tr><td><code id="predict.snqProfitEst_+3A_usedfsys">useDfSys</code></td>
<td>
<p>logical. Use the degrees of freedom of the whole system
(and not the degrees of freedom of the single equation)
to calculate the confidence intervals.</p>
</td></tr>
<tr><td><code id="predict.snqProfitEst_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the fitted values
(used to calculate the standard errors of the fitted values
and the &quot;confidence interval&quot;) is calculated by
<code class="reqn">Var[E[y^0]-\hat{y}^0]=x^0 \; Var[b] \; {x^0}'</code><br />
The variances of the predicted values
(used to calculate the standard errors of the predicted values
and the &quot;prediction intervals&quot;) is calculated by
<code class="reqn">Var[y^0-\hat{y}^0]=\hat{\sigma}^2+x^0 \; Var[b] \; {x^0}'</code>
</p>


<h3>Value</h3>

<p><code>predict.snqProfitEst</code> and <code>predict.snqProfitImposeConvexity</code> return
a dataframe that
contains the predicted profit and for each netput the predicted quantities
(e.g. &quot;quant1&quot; ) and if requested
the standard errors of the fitted values (e.g. &quot;quant1.se.fit&quot;),
the standard errors of the prediction (e.g. &quot;quant1.se.pred&quot;),
and the lower (e.g. &quot;quant1.lwr&quot;) and upper (e.g. &quot;quant1.upr&quot;)
limits of the confidence or prediction interval(s).
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Diewert, W.E. and T.J. Wales (1987)
Flexible functional forms and global curvature conditions.
<em>Econometrica</em>, 55, p. 43-68.
</p>
<p>Diewert, W.E. and T.J. Wales (1992)
Quadratic Spline Models for Producer's Supply and Demand Functions.
<em>International Economic Review</em>, 33, p. 705-722.
</p>
<p>Greene, W. H. (2003)
<em>Econometric Analysis, Fifth Edition</em>, Macmillan.
</p>
<p>Gujarati, D. N. (1995)
<em>Basic Econometrics, Third Edition</em>, McGraw-Hill.
</p>
<p>Kmenta, J. (1997)
<em>Elements of Econometrics, Second Edition</em>, University of
Michigan Publishing.
</p>
<p>Kohli, U.R. (1993)
A symmetric normalized quadratic GNP function and the US demand
for imports and supply of exports.
<em>International Economic Review</em>, 34, p. 243-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code>, <code><a href="#topic+snqProfitCalc">snqProfitCalc</a></code>
and <code><a href="stats.html#topic+predict">predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time      &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )
   estResult &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), data=germanFarms )
   predict( estResult )
   predict( estResult, se.fit = TRUE, se.pred = TRUE, interval = "confidence" )
}
</code></pre>

<hr>
<h2 id='print.snqProfitEst'>Print output of estimated SNQ profit function</h2><span id='topic+print.snqProfitEst'></span>

<h3>Description</h3>

<p>This function prints a summary estimation results of
a symmetric normalized quadraric (SNQ) profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'snqProfitEst'
print( x, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.snqProfitEst_+3A_x">x</code></td>
<td>
<p>an object of class <code>snqProfitEst</code>.</p>
</td></tr>
<tr><td><code id="print.snqProfitEst_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: library( systemfit )
if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, "land", data = germanFarms )
   print( estResult )
}
</code></pre>

<hr>
<h2 id='residuals.snqProfitEst'>Residuals of an SNQ profit function</h2><span id='topic+residuals.snqProfitEst'></span><span id='topic+residuals.snqProfitImposeConvexity'></span>

<h3>Description</h3>

<p>Extract the residuals from the estimation of a Symmetric Normalized
Quadratic (SNQ) profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'snqProfitEst'
residuals( object, scaled = TRUE, ... )

## S3 method for class 'snqProfitImposeConvexity'
residuals( object, scaled = TRUE, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.snqProfitEst_+3A_object">object</code></td>
<td>
<p>an object of type <code>snqProfitEst</code> or
<code>snqProfitImposeconvexity</code>.</p>
</td></tr>
<tr><td><code id="residuals.snqProfitEst_+3A_scaled">scaled</code></td>
<td>
<p>logical. Return scaled quantities?</p>
</td></tr>
<tr><td><code id="residuals.snqProfitEst_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>residuals.snqProfitEst</code> and <code>residuals.snqProfitEst</code> return a
dataframe that contains the residuals for each netput and the profit.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code>, <code><a href="#topic+snqProfitImposeConvexity">snqProfitImposeConvexity</a></code>
and <code><a href="stats.html#topic+residuals">residuals</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time      &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )
   estResult &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), data=germanFarms )
   residuals( estResult )
   residuals( estResult, scaled = FALSE )
}
</code></pre>

<hr>
<h2 id='snqProfitCalc'>Calculations with the SNQ Profit function</h2><span id='topic+snqProfitCalc'></span>

<h3>Description</h3>

<p>Calculation of netput quantities and profit with the
Symmetric Normalized Quadratic (SNQ) Profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   snqProfitCalc( priceNames, fixNames, data, weights,
      scalingFactors = rep( 1, length( weights ) ), coef,
      quantNames = NULL, form = 0 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitCalc_+3A_pricenames">priceNames</code></td>
<td>
<p>a vector of strings containing the names of netput prices.</p>
</td></tr>
<tr><td><code id="snqProfitCalc_+3A_fixnames">fixNames</code></td>
<td>
<p>an optional vector of strings containing the names of the
quantities of (quasi-)fix inputs.</p>
</td></tr>
<tr><td><code id="snqProfitCalc_+3A_data">data</code></td>
<td>
<p>a data frame containing the data.</p>
</td></tr>
<tr><td><code id="snqProfitCalc_+3A_weights">weights</code></td>
<td>
<p>vector of weights of the prices for normalization.</p>
</td></tr>
<tr><td><code id="snqProfitCalc_+3A_quantnames">quantNames</code></td>
<td>
<p>optional vector of strings containing the names of netput
quantities.</p>
</td></tr>
<tr><td><code id="snqProfitCalc_+3A_scalingfactors">scalingFactors</code></td>
<td>
<p>factors to scale prices (and quantities).</p>
</td></tr>
<tr><td><code id="snqProfitCalc_+3A_coef">coef</code></td>
<td>
<p>a list containing the coefficients alpha, beta, delta and gamma.</p>
</td></tr>
<tr><td><code id="snqProfitCalc_+3A_form">form</code></td>
<td>
<p>the functional form to be estimated (see <code><a href="#topic+snqProfitEst">snqProfitEst</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame: the first n columns are the netput quantities,
the last column is the profit.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Diewert, W.E. and T.J. Wales (1987)
Flexible functional forms and global curvature conditions.
<em>Econometrica</em>, 55, p. 43-68.
</p>
<p>Diewert, W.E. and T.J. Wales (1992)
Quadratic Spline Models for Producer's Supply and Demand Functions.
<em>International Economic Review</em>, 33, p. 705-722.
</p>
<p>Kohli, U.R. (1993)
A symmetric normalized quadratic GNP function and the US demand
for imports and supply of exports.
<em>International Economic Review</em>, 34, p. 243-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code> and <code><a href="#topic+snqProfitWeights">snqProfitWeights</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time      &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )
   fixNames &lt;- c( "land", "time" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, fixNames, data = germanFarms )
   snqProfitCalc( priceNames, fixNames, estResult$data, estResult$weights,
      estResult$scalingFactors, estResult$coef )
}
</code></pre>

<hr>
<h2 id='snqProfitEla'>Price Elasticities of SNQ Profit function</h2><span id='topic+snqProfitEla'></span>

<h3>Description</h3>

<p>Calculates the Price Elasticities of a Symmetric Normalized Quadratic (SNQ)
profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> snqProfitEla(  beta, prices, quant, weights,
   scalingFactors = rep( 1, length( weights ) ),
   coefVcov = NULL, df = NULL )</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitEla_+3A_beta">beta</code></td>
<td>
<p>matrix of estimated <code class="reqn">\beta</code> coefficients.</p>
</td></tr>
<tr><td><code id="snqProfitEla_+3A_prices">prices</code></td>
<td>
<p>vector of netput prices at which the elasticities
should be calculated.</p>
</td></tr>
<tr><td><code id="snqProfitEla_+3A_quant">quant</code></td>
<td>
<p>vector of netput quantities at which the elasticities
should be calculated.</p>
</td></tr>
<tr><td><code id="snqProfitEla_+3A_weights">weights</code></td>
<td>
<p>vector of weights of prices used for normalization.</p>
</td></tr>
<tr><td><code id="snqProfitEla_+3A_scalingfactors">scalingFactors</code></td>
<td>
<p>factors to scale prices (and quantities).</p>
</td></tr>
<tr><td><code id="snqProfitEla_+3A_coefvcov">coefVcov</code></td>
<td>
<p>variance covariance matrix of the coefficients (optional).</p>
</td></tr>
<tr><td><code id="snqProfitEla_+3A_df">df</code></td>
<td>
<p>degrees of freedom to calculate P-values of the elasticities
(optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class <code>snqProfitEla</code> containing following elements:
</p>
<table role = "presentation">
<tr><td><code>ela</code></td>
<td>
<p>matrix of the price elasticities.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>variance covariance matrix of the price elasticities.</p>
</td></tr>
<tr><td><code>stEr</code></td>
<td>
<p>standard errors of the price elasticities.</p>
</td></tr>
<tr><td><code>tval</code></td>
<td>
<p>t-values of the price elasticities.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>P-values of the price elasticities.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A price elasticity is defined as
</p>
<p style="text-align: center;"><code class="reqn">E_{ij} = \frac{ \displaystyle \frac{ \partial q_i }{ q_i } }
   {  \displaystyle \frac{ \partial p_j }{ p_j } } =
   \frac{ \partial q_i }{ \partial p_j } \cdot \frac{ p_j }{ q_i } </code>
</p>

<p>Thus, e.g. <code class="reqn">E_{ij}=0.5</code> means that if the price of netput j (<code class="reqn">p_j</code>)
increases by 1%, the quantity of netput i (<code class="reqn">q_i</code>) will
increase by 0.5%.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># just a stupid simple example
snqProfitEla( matrix(101:109,3,3), c(1,1,1), c(1,-1,-1), c(0.4,0.3,0.3) )

# now with real data
if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput   / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time      &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), data=germanFarms )

   estResult$ela  # price elasticities at mean prices and mean quantities

   # price elasticities at the last observation (1994/95)
   snqProfitEla( estResult$coef$beta, estResult$data[ 20, priceNames ],
      estResult$data[ 20, quantNames ], estResult$weights,
      estResult$scalingFactors )
}
</code></pre>

<hr>
<h2 id='snqProfitEst'>Estimation of a SNQ Profit function</h2><span id='topic+snqProfitEst'></span>

<h3>Description</h3>

<p>Estimation of a Symmetric Normalized Quadratic (SNQ) Profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snqProfitEst( priceNames, quantNames, fixNames = NULL, instNames = NULL,
   data, form = 0, base = 1, scalingFactors = NULL,
   weights = snqProfitWeights( priceNames, quantNames, data, "DW92", base = base ),
   method = ifelse( is.null( instNames ), "SUR", "3SLS" ), ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitEst_+3A_pricenames">priceNames</code></td>
<td>
<p>a vector of strings containing the names of netput prices.</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_quantnames">quantNames</code></td>
<td>
<p>a vector of strings containing the names of netput quantities
(inputs must be negative).</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_fixnames">fixNames</code></td>
<td>
<p>an optional vector of strings containing the names of the
quantities of (quasi-)fixed inputs.</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_instnames">instNames</code></td>
<td>
<p>an optional vector of strings containing the names of
instrumental variables (for 3SLS estimation).</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_data">data</code></td>
<td>
<p>a data frame containing the data.</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_form">form</code></td>
<td>
<p>the functional form to be estimated (see details).</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_base">base</code></td>
<td>
<p>the base period(s) for scaling prices (see details).
If argument <code>weights</code> is not specified,
argument <code>base</code> is also used to obtain the weights
for normalizing prices (see <code><a href="#topic+snqProfitWeights">snqProfitWeights</a></code>).</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_scalingfactors">scalingFactors</code></td>
<td>
<p>a vector of factors to scale prices (see details).</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_weights">weights</code></td>
<td>
<p>a vector of weights for normalizing prices.</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_method">method</code></td>
<td>
<p>the estimation method (passed to
<code><a href="systemfit.html#topic+systemfit">systemfit</a></code>).</p>
</td></tr>
<tr><td><code id="snqProfitEst_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="systemfit.html#topic+systemfit">systemfit</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Symmetric Normalized Quadratic (SNQ) profit function is defined as
follows (this functional form is used if argument <code>form</code> equals 0):
</p>
<p style="text-align: center;"><code class="reqn"> \pi \left( p, z \right) =
      \sum_{i=1}^{n} \alpha_{i} p_{i} +
      \frac{1}{2} w^{-1} \sum_{i=1}^{n} \sum_{j=1}^{n} \beta_{ij} p_{i} p_{j} +
      \sum_{i=1}^{n} \sum_{j=1}^{m} \delta_{ij} p_{i} z_{j} +
      \frac{1}{2} w \sum_{i=1}^{m} \sum_{j=1}^{m} \gamma_{ij} z_{i} z_{j}
   </code>
</p>

<p>with <code class="reqn">\pi</code> = profit, <code class="reqn">p_i</code> = netput prices,
<code class="reqn">z_i</code> = quantities of fixed inputs,
<code class="reqn"> w=\sum_{i=1}^{n}\theta_{i}p_{i} </code> = price index for normalization,
<code class="reqn">\theta_i</code> = weights of prices for normalization, and
<code class="reqn">\alpha_i</code>, <code class="reqn">\beta_{ij}</code>, <code class="reqn">\delta_{ij}</code> and
<code class="reqn">\gamma_{ij}</code> = coefficients to be estimated.<br />
The netput equations (output supply in input demand) can be obtained
by Hotelling's Lemma (<code class="reqn"> q_{i} = \left. \partial \pi \right/ \partial p_{i} </code>):
</p>
<p style="text-align: center;"><code class="reqn"> x_{i} = \alpha_{i} +
      w^{-1} \sum_{j=1}^{n} \beta_{ij} p_{j} -
      \frac{1}{2} \theta_{i} w^{-2} \sum_{j=1}^{n} \sum_{k=1}^{n}
      \beta_{jk} p_{j} p_{k} +
      \sum_{j=1}^{m} \delta_{ij} z_{j} +
      \frac{1}{2} \theta_{i} \sum_{j=1}^{m} \sum_{k=1}^{m} \gamma_{jk} z_{j} z_{k}
   </code>
</p>

<p>In my experience the fit of the model is sometimes not very good,
because the effect of the fixed inputs is forced to be proportional
to the weights for price normalization <code class="reqn">\theta_i</code>.
In this cases I use following extended SNQ profit function
(this functional form is used if argument <code>form</code> equals 1):
</p>
<p style="text-align: center;"><code class="reqn"> \pi \left( p, z \right) =
      \sum_{i=1}^{n} \alpha_{i} p_{i} +
      \frac{1}{2} w^{-1} \sum_{i=1}^{n} \sum_{j=1}^{n} \beta_{ij} p_{i} p_{j} +
      \sum_{i=1}^{n} \sum_{j=1}^{m} \delta_{ij} p_{i} z_{j} +
      \frac{1}{2} \sum_{i=1}^{n} \sum_{j=1}^{m} \sum_{k=1}^{m}
      \gamma_{ijk} p_i z_{j} z_{k}
   </code>
</p>

<p>The netput equations are now:
</p>
<p style="text-align: center;"><code class="reqn"> x_{i} = \alpha_{i} +
      w^{-1} \sum_{j=1}^{n} \beta_{ij} p_{j} -
      \frac{1}{2} \theta_{i} w^{-2} \sum_{j=1}^{n} \sum_{k=1}^{n}
      \beta_{jk} p_{j} p_{k} +
      \sum_{j=1}^{m} \delta_{ij} z_{j} +
      \frac{1}{2} \sum_{j=1}^{m} \sum_{k=1}^{m} \gamma_{ijk} z_{j} z_{k}
   </code>
</p>

<p>Argument <code>scalingFactors</code> can be used to scale prices,
e.g. for improving the numerical stability of the estimation
(e.g. if prices are very large or very small numbers)
or for assessing the robustness of the results
when changing the units of measurement.
The prices are multiplied by the scaling factors,
while the quantities are divided my the scaling factors
so that the monetary values of the inputs and outputs
and thus, the profit, remains unchanged.
If argument <code>scalingFactors</code> is <code>NULL</code>,
argument <code>base</code> is used to automatically obtain scaling factors
so that the scaled prices are unity in the base period or - if there
is more than one base period - that the
means of the scaled prices over the base periods are unity.
Argument <code>base</code> can be either <br />
(a) a single number: the row number of the base prices, <br />
(b) a vector indicating several observations: The means of these
observations are used as base prices, <br />
(c) a logical vector with length equal to the number of rows 
of the data set that is specified by argument <code>data</code>: The
means of the observations indicated as 'TRUE' are used as base prices, or<br />
(d) <code>NULL</code>: prices are not scaled. 
If argument <code>base</code> is <code>NULL</code>,
argument <code>weights</code> must be specified,
because the weights cannot be calculated
if the base period is not specified.
An alternative way to use unscaled prices
is to set argument <code>scalingFactors</code> equal to a vector of ones
(see examples below).<br />
If the scaling factors are explicitly specified
by argument <code>scalingFactors</code>,
argument <code>base</code> is not used for obtaining scaling factors
(but it is used for obtaining weights
if argument <code>weights</code> is not specified).
</p>


<h3>Value</h3>

<p>a list of class <code>snqProfitEst</code> containing following objects:
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>a list containing the vectors/matrix of the estimated
coefficients:<br />
* alpha = <code class="reqn">\alpha_i</code>.<br />
* beta = <code class="reqn">\beta_{ij}</code>.<br />
* delta =  <code class="reqn">\delta_{ij}</code> (only if quasi-fix inputs are present).<br />
* gamma = <code class="reqn">\gamma_{ij}</code> (only if quasi-fix inputs are present).<br />
* allCoef = vector of all coefficients.<br />
* allCoefCov = covariance matrix of all coefficients.<br />
* stats = all coefficients with standard errors, t-values and p-values.<br />
* liCoef = vector of linear independent coefficients.<br />
* liCoefCov = covariance matrix of linear independent coefficients.</p>
</td></tr>
<tr><td><code>ela</code></td>
<td>
<p>a list of class <code>snqProfitEla</code> that contains
(amongst others) the price elasticities at mean prices and mean
quantities (see <code><a href="#topic+snqProfitEla">snqProfitEla</a></code>).</p>
</td></tr>
<tr><td><code>fixEla</code></td>
<td>
<p>matrix of the fixed factor elasticities at mean prices and
mean quantities.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>hessian matrix of the profit function with respect to prices
evaluated at mean prices.</p>
</td></tr>
<tr><td><code>convexity</code></td>
<td>
<p>logical. Convexity of the profit function.</p>
</td></tr>
<tr><td><code>r2</code></td>
<td>
<p><code class="reqn">R^2</code>-values of all netput equations.</p>
</td></tr>
<tr><td><code>est</code></td>
<td>
<p>estimation results returned by <code><a href="systemfit.html#topic+systemfit">systemfit</a></code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the weights of prices used for normalization.</p>
</td></tr>
<tr><td><code>normPrice</code></td>
<td>
<p>vector used for normalization of prices.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data frame of originally supplied data.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>data frame that contains the fitted netput quantities and
the fitted profit.</p>
</td></tr>
<tr><td><code>pMeans</code></td>
<td>
<p>means of the scaled netput prices.</p>
</td></tr>
<tr><td><code>qMeans</code></td>
<td>
<p>means of the scaled netput quantities.</p>
</td></tr>
<tr><td><code>fMeans</code></td>
<td>
<p>means of the (quasi-)fixed input quantities.</p>
</td></tr>
<tr><td><code>priceNames</code></td>
<td>
<p>a vector of strings containing the names of netput prices.</p>
</td></tr>
<tr><td><code>quantNames</code></td>
<td>
<p>a vector of strings containing the names of netput quantities
(inputs must be negative).</p>
</td></tr>
<tr><td><code>fixNames</code></td>
<td>
<p>an optional vector of strings containing the names of the
quantities of (quasi-)fixed inputs.</p>
</td></tr>
<tr><td><code>instNames</code></td>
<td>
<p>an optional vector of strings containing the names of
instrumental variables (for 3SLS estimation).</p>
</td></tr>
<tr><td><code>form</code></td>
<td>
<p>the functional form (see details).</p>
</td></tr>
<tr><td><code>base</code></td>
<td>
<p>the base period(s) for scaling prices (see details).</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>vector of weights of the prices for normalization.</p>
</td></tr>
<tr><td><code>scalingFactors</code></td>
<td>
<p>factors to scale prices (and quantities).</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the estimation method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Diewert, W.E. and T.J. Wales (1987)
Flexible functional forms and global curvature conditions.
<em>Econometrica</em>, 55, p. 43-68.
</p>
<p>Diewert, W.E. and T.J. Wales (1992)
Quadratic Spline Models for Producer's Supply and Demand Functions.
<em>International Economic Review</em>, 33, p. 705-722.
</p>
<p>Kohli, U.R. (1993)
A symmetric normalized quadratic GNP function and the US demand
for imports and supply of exports.
<em>International Economic Review</em>, 34, p. 243-255.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEla">snqProfitEla</a></code> and <code><a href="#topic+snqProfitWeights">snqProfitWeights</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, "land", data = germanFarms )
   estResult$ela   # Oh, that looks bad!

   # it it reasonable to account for technological progress
   germanFarms$time &lt;- c( 0:19 )
   estResult2 &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), 
      data = germanFarms )
   estResult2$ela   # Ah, that looks better!
   
   # estimation with unscaled prices
   estResultNoScale &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), 
    data = germanFarms, scalingFactors = rep( 1, 3 ) )
   print( estResultNoScale )
   
   # alternative way of estimation with unscaled prices
   estResultNoScale2 &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), 
      data = germanFarms, base = NULL, 
      weights = snqProfitWeights( priceNames, quantNames, germanFarms ) )
   all.equal( estResultNoScale[-20], estResultNoScale2[] )

   # please note that the SNQ Profit function is not invariant
   # to units of measurement so that different scaling factors 
   # result in different estimates of elasticities:
   all.equal( estResult2$ela, estResultNoScale$ela )
}
</code></pre>

<hr>
<h2 id='snqProfitFixEla'>Fixed Factor Elasticities of SNQ Profit function</h2><span id='topic+snqProfitFixEla'></span>

<h3>Description</h3>

<p>Calculates the Fixed Factor Elasticities of a Symmetric Normalized
Quadratic (SNQ) profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> snqProfitFixEla( delta, gamma, quant, fix, weights,
   scalingFactors = rep( 1, length( weights ) ) )</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitFixEla_+3A_delta">delta</code></td>
<td>
<p>matrix of estimated <code class="reqn">\delta</code> coefficients.</p>
</td></tr>
<tr><td><code id="snqProfitFixEla_+3A_gamma">gamma</code></td>
<td>
<p>matrix of estimated <code class="reqn">\gamma</code> coefficients.</p>
</td></tr>
<tr><td><code id="snqProfitFixEla_+3A_quant">quant</code></td>
<td>
<p>vector of netput quantities at which the elasticities
should be calculated.</p>
</td></tr>
<tr><td><code id="snqProfitFixEla_+3A_fix">fix</code></td>
<td>
<p>vector of quantities of fixed factors at which the elasticities
should be calculated.</p>
</td></tr>
<tr><td><code id="snqProfitFixEla_+3A_weights">weights</code></td>
<td>
<p>vector of weights of prices used for normalization.</p>
</td></tr>
<tr><td><code id="snqProfitFixEla_+3A_scalingfactors">scalingFactors</code></td>
<td>
<p>factors to scale prices (and quantities).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>A fixed factor elasticity is defined as
</p>
<p style="text-align: center;"><code class="reqn">E_{ij} = \frac{ \displaystyle \frac{ \partial q_i }{ q_i } }
   {  \displaystyle \frac{ \partial z_j }{ z_j } } =
   \frac{ \partial q_i }{ \partial z_j } \cdot \frac{ z_j }{ q_i } </code>
</p>

<p>Thus, e.g. <code class="reqn">E_{ij}=0.5</code> means that if the quantity of fixed factor j
(<code class="reqn">z_j</code>) increases by 1%, the quantity of netput i (<code class="reqn">q_i</code>) will
increase by 0.5%.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code> and <code><a href="#topic+snqProfitEla">snqProfitEla</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># just a stupid simple example
snqProfitFixEla( matrix(1:6/6,3,2 ), matrix(4:1/4,2 ), c(1,1,1), c(1,1),
   c(0.4,0.3,0.3) )

# now with real data
if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput   / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time      &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )
   fixNames &lt;- c( "land", "time" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, fixNames, data=germanFarms )

   estResult$fixEla  # price elasticities at mean quantities of netputs
                     # and fixed factors

   # fixed factor elasticities at the last observation (1994/95)
   snqProfitFixEla( estResult$coef$delta, estResult$coef$gamma,
      estResult$data[ 20, quantNames ], estResult$data[ 20, fixNames ],
      estResult$weights, estResult$scalingFactors )
}
</code></pre>

<hr>
<h2 id='snqProfitHessian'>SNQ Profit function: Hessian matrix</h2><span id='topic+snqProfitHessian'></span>

<h3>Description</h3>

<p>Returns the Hessian (substitution) matrix of a Symmetric Normalized
Quadratic (SNQ) Profit Function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snqProfitHessian( beta, prices, weights,
   scalingFactors = rep( 1, length( weights ) ) )</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitHessian_+3A_beta">beta</code></td>
<td>
<p>matrix of the <code class="reqn">beta</code> coefficients.</p>
</td></tr>
<tr><td><code id="snqProfitHessian_+3A_prices">prices</code></td>
<td>
<p>vector of netput prices at which the Hessian
should be calculated.</p>
</td></tr>
<tr><td><code id="snqProfitHessian_+3A_weights">weights</code></td>
<td>
<p>vector of weights of prices for normalization.</p>
</td></tr>
<tr><td><code id="snqProfitHessian_+3A_scalingfactors">scalingFactors</code></td>
<td>
<p>factors to scale prices (and quantities).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code>, <code><a href="#topic+snqProfitEla">snqProfitEla</a></code> and
<code><a href="#topic+snqProfitHessianDeriv">snqProfitHessianDeriv</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># just a stupid simple example
snqProfitHessian( matrix(101:109,3,3), c(1,1,1), c(0.4,0.3,0.3) )

# now with real data
if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput   / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), data=germanFarms )

   estResult$hessian  # the Hessian at mean prices and mean quantities

   # Hessian at the last observation (1994/95)
   snqProfitHessian( estResult$coef$beta, estResult$data[ 20, priceNames ],
      estResult$weights, estResult$scalingFactors )
}
</code></pre>

<hr>
<h2 id='snqProfitHessianDeriv'>SNQ Profit function: Derivatives of the Hessian</h2><span id='topic+snqProfitHessianDeriv'></span>

<h3>Description</h3>

<p>Returns the matrix of derivatives of the vector of linear independent
values of the Hessian with respect to the vector of the linear independent
coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> snqProfitHessianDeriv( prices, weights, nFix = 0, form = 0 )</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitHessianDeriv_+3A_prices">prices</code></td>
<td>
<p>vector of netput prices at which the derivatives
should be calculated.</p>
</td></tr>
<tr><td><code id="snqProfitHessianDeriv_+3A_weights">weights</code></td>
<td>
<p>vector of weights for normalizing prices.</p>
</td></tr>
<tr><td><code id="snqProfitHessianDeriv_+3A_nfix">nFix</code></td>
<td>
<p>number of (quasi-)fix inputs.</p>
</td></tr>
<tr><td><code id="snqProfitHessianDeriv_+3A_form">form</code></td>
<td>
<p>the functional form to be estimated (see
<code><a href="#topic+snqProfitEst">snqProfitEst</a></code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitHessian">snqProfitHessian</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'># just a stupid simple example
snqProfitHessianDeriv( c(1,2,3),c(0.4,0.3,0.3) )

# now with real data
if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput   / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, c("land","time"), data=germanFarms )

   snqProfitHessianDeriv( estResult$pMean, estResult$weights, 2 )
}
</code></pre>

<hr>
<h2 id='snqProfitImposeConvexity'>Imposing Convexity on a SNQ Profit function</h2><span id='topic+snqProfitImposeConvexity'></span>

<h3>Description</h3>

<p>Imposing Convexity on a Symmetric Normalized Quadratic (SNQ) Profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snqProfitImposeConvexity( estResult, rankReduction = 0,
   start = 10, optimMethod = "BFGS", control = list( maxit=5000 ),
   stErMethod = "none", nRep = 1000, verbose = 0 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitImposeConvexity_+3A_estresult">estResult</code></td>
<td>
<p>object returned by <code><a href="#topic+snqProfitEst">snqProfitEst</a></code>.</p>
</td></tr>
<tr><td><code id="snqProfitImposeConvexity_+3A_rankreduction">rankReduction</code></td>
<td>
<p>an integer specifying the reduction of the rank
of the <code class="reqn">\beta</code> matrix.</p>
</td></tr>
<tr><td><code id="snqProfitImposeConvexity_+3A_start">start</code></td>
<td>
<p>starting values of the triangular Cholesky matrix.</p>
</td></tr>
<tr><td><code id="snqProfitImposeConvexity_+3A_optimmethod">optimMethod</code></td>
<td>
<p>method to be used by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="snqProfitImposeConvexity_+3A_control">control</code></td>
<td>
<p>list of control parameters passed to <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code id="snqProfitImposeConvexity_+3A_stermethod">stErMethod</code></td>
<td>
<p>method to compute standard errors, either
'none', 'resample', 'jackknife' or 'coefSim' (see details).</p>
</td></tr>
<tr><td><code id="snqProfitImposeConvexity_+3A_nrep">nRep</code></td>
<td>
<p>number of replications to compute the standard errors
if <code>stErMethod</code> is either 'resample' or 'coefSim'.</p>
</td></tr>
<tr><td><code id="snqProfitImposeConvexity_+3A_verbose">verbose</code></td>
<td>
<p>an integer idicating the verbose level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure proposed by Koebel, Falk and Laisney (2000, 2003) is
applied to impose convexity in prices on an estimated symmetric
normalized quadratic (SNQ) profit function.<br />
The standard errors of the restricted coefficients can be either
calculated by
bootstrap resampling ('resampling'),
jackknife ('jacknife') or
by simulating the distribution of the unrestricted coefficients
using its variance covariance matrix ('coefSim').
</p>


<h3>Value</h3>

<p>a list of class <code>snqProfitImposeConvexity</code> containing the same
objects as an object of class <code><a href="#topic+snqProfitEst">snqProfitEst</a></code>
and additionally the objects:
</p>
<table role = "presentation">
<tr><td><code>mindist</code></td>
<td>
<p>object returned by <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
<tr><td><code>sim</code></td>
<td>
<p>results of the simulation to obtain the standard errors
of the estimated coefficients.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>References</h3>

<p>Koebel, B., M. Falk and F. Laisney (2000),
Imposing and Testing Curvature Conditions on a Box-Cox Cost Function.
Discussion Paper No. 00-70, ZEW, Mannheim,
<a href="https://madoc.bib.uni-mannheim.de/515/1/dp0070.pdf">https://madoc.bib.uni-mannheim.de/515/1/dp0070.pdf</a>.
</p>
<p>Koebel, B., M. Falk and F. Laisney (2003),
Imposing and Testing Curvature Conditions on a Box-Cox Cost Function.
<em>Journal of Business and Economic Statistics</em>, 21, p. 319-335.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )
   estResult &lt;- snqProfitEst( priceNames, quantNames, "land", data = germanFarms )
   estResult  # Note: it is NOT convex in netput prices
   estResultConvex &lt;- snqProfitImposeConvexity( estResult )
   estResultConvex  # now it is convex
}
</code></pre>

<hr>
<h2 id='snqProfitShadowPrices'>Shadow Prices of a SNQ Profit function</h2><span id='topic+snqProfitShadowPrices'></span>

<h3>Description</h3>

<p>Calculates the shadow prices of a Symmetric Normalized Quadratic (SNQ)
profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   snqProfitShadowPrices( priceNames, fixNames, estResult = NULL,
   data = estResult$data, weights = estResult$weights,
   scalingFactors = estResult$scalingFactors,
   coef = estResult$coef, form = estResult$form )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitShadowPrices_+3A_pricenames">priceNames</code></td>
<td>
<p>a vector of strings containing the names of netput prices.</p>
</td></tr>
<tr><td><code id="snqProfitShadowPrices_+3A_fixnames">fixNames</code></td>
<td>
<p>an optional vector of strings containing the names of the
quantities of (quasi-)fix inputs.</p>
</td></tr>
<tr><td><code id="snqProfitShadowPrices_+3A_estresult">estResult</code></td>
<td>
<p>object returned by <code><a href="#topic+snqProfitEst">snqProfitEst</a></code>.</p>
</td></tr>
<tr><td><code id="snqProfitShadowPrices_+3A_data">data</code></td>
<td>
<p>a data frame containing the data.</p>
</td></tr>
<tr><td><code id="snqProfitShadowPrices_+3A_weights">weights</code></td>
<td>
<p>vector of weights of prices used for normalization.</p>
</td></tr>
<tr><td><code id="snqProfitShadowPrices_+3A_scalingfactors">scalingFactors</code></td>
<td>
<p>factors to scale prices (see details).</p>
</td></tr>
<tr><td><code id="snqProfitShadowPrices_+3A_coef">coef</code></td>
<td>
<p>a list containing the coefficients (at least delta and gamma).</p>
</td></tr>
<tr><td><code id="snqProfitShadowPrices_+3A_form">form</code></td>
<td>
<p>the functional form to be estimated (see details).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code>, <code><a href="#topic+snqProfitCalc">snqProfitCalc</a></code> and
<code><a href="#topic+snqProfitEla">snqProfitEla</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput   / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   germanFarms$time      &lt;- c( 0:19 )
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )
   fixNames &lt;- c( "land", "time" )

   estResult &lt;- snqProfitEst( priceNames, quantNames, fixNames, data = germanFarms )

   snqProfitShadowPrices( priceNames, fixNames, estResult )
}
</code></pre>

<hr>
<h2 id='snqProfitWeights'>SNQ Profit function: Weights of prices for normalization</h2><span id='topic+snqProfitWeights'></span>

<h3>Description</h3>

<p>Returns a vector of weights to normalize prices on a
Symmetric Normalized  Quadratic (SNQ) Profit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snqProfitWeights( priceNames, quantNames, data, method = "DW92", base = 1 )</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="snqProfitWeights_+3A_pricenames">priceNames</code></td>
<td>
<p>a vector of strings containing the names of netput prices.</p>
</td></tr>
<tr><td><code id="snqProfitWeights_+3A_quantnames">quantNames</code></td>
<td>
<p>a vector of strings containing the names of netput quantities.</p>
</td></tr>
<tr><td><code id="snqProfitWeights_+3A_data">data</code></td>
<td>
<p>a data frame containing the data.</p>
</td></tr>
<tr><td><code id="snqProfitWeights_+3A_method">method</code></td>
<td>
<p>the method to determine the weights (see details).</p>
</td></tr>
<tr><td><code id="snqProfitWeights_+3A_base">base</code></td>
<td>
<p>the base period(s) for scaling prices (see details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If argument <code>method</code> is 'DW92' the method of Diewert and
Wales (1992) is applied. They predetermine the weights by
</p>
<p style="text-align: center;"><code class="reqn"> \theta_{i} = \frac{
   \displaystyle \left | \overline{x}_{i} \right| p_{i}^{0} }{
   \displaystyle \sum_{i=1}^{n} \left| \overline{x}_{i} \right| p_{i}^{0}}</code>
</p>

<p>Defining the scaled netput quantities as
<code class="reqn">\widetilde{x}_{i}^{t} = x_{i}^{t}\cdot p_{i}^{0}</code>
we get following formula:
</p>
<p style="text-align: center;"><code class="reqn"> \theta_{i} = \frac{
   \displaystyle  \left| \overline{ \widetilde{ x } }_{i} \right|}{
   \displaystyle \sum_{i=1}^{n} \left| \overline{ \widetilde{ x } }_{i} \right|}</code>
</p>

<p>The prices are scaled that they are unity in the base period or - if there
is more than one base period - that the
means of the prices over the base periods are unity.
The argument <code>base</code> can be either <br />
(a) a single number: the row number of the base prices, <br />
(b) a vector indicating several observations: The means of these
observations are used as base prices, <br />
(c) a logical vector with the same length as the <code>data</code>: The
means of the observations indicated as 'TRUE' are used as base prices, or
(d) <code>NULL</code>: prices are not scaled.
</p>


<h3>Author(s)</h3>

<p>Arne Henningsen</p>


<h3>See Also</h3>

<p><code><a href="#topic+snqProfitEst">snqProfitEst</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if( requireNamespace( 'micEcon', quietly = TRUE ) ) {
   data( germanFarms, package = "micEcon" )
   germanFarms$qOutput   &lt;- germanFarms$vOutput   / germanFarms$pOutput
   germanFarms$qVarInput &lt;- -germanFarms$vVarInput / germanFarms$pVarInput
   germanFarms$qLabor    &lt;- -germanFarms$qLabor
   priceNames &lt;- c( "pOutput", "pVarInput", "pLabor" )
   quantNames &lt;- c( "qOutput", "qVarInput", "qLabor" )
   snqProfitWeights( priceNames, quantNames, germanFarms )
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
