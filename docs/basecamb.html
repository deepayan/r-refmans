<!DOCTYPE html><html lang="en"><head><title>Help for package basecamb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {basecamb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.find_NA_coercions'><p>Locate NA values introduced during apply_data_dictionary()</p></a></li>
<li><a href='#.parse_string_to_named_vector'><p>Parse a string to create a named list</p></a></li>
<li><a href='#.scale_variable'><p>Scaling a variable</p></a></li>
<li><a href='#apply_data_dictionary'><p>Clean column names, types and levels</p></a></li>
<li><a href='#apply_function_to_imputed_data'><p>Apply function to dataframes in a mice object</p></a></li>
<li><a href='#assign_factorial_levels'><p>Assign custom values for key levels in factorial columns</p></a></li>
<li><a href='#assign_types_names'><p>Assign tidy types and names to a data.frame</p></a></li>
<li><a href='#build_model_formula'><p>Build formula for statistical models</p></a></li>
<li><a href='#cox.zph.mids'><p>Test cox proportional odds assumption on models using multiple imputation.</p></a></li>
<li><a href='#deconstruct_formula'><p>Deconstruct formula</p></a></li>
<li><a href='#filter_nth_entry'><p>Filter dataframe for nth entry</p></a></li>
<li><a href='#fit_mult_impute_obs_outcome'><p>Fit a model on multiply imputed data using only observations with non-missing</p>
outcome(s)</a></li>
<li><a href='#or_model_summary'><p>Summarise a logistic regression model on the odds ratio scale</p></a></li>
<li><a href='#parse_date_columns'><p>Parse values in date columns as Dates</p></a></li>
<li><a href='#quantile_group'><p>Stratify a numeric vector into quantile groups</p></a></li>
<li><a href='#remove_duplicates'><p>Remove duplicate rows from data.frame</p></a></li>
<li><a href='#remove_missing_from_mids'><p>Remove missing cases from a mids object</p></a></li>
<li><a href='#scale_continuous_predictors'><p>Scale continuous predictors</p></a></li>
<li><a href='#setduplicates'><p>Identify duplicate values in a vector representing a set</p></a></li>
<li><a href='#stratified_boxcox'><p>Box-Cox transformation for stratified data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities for Streamlined Data Import, Imputation and Modelling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions streamlining the data analysis workflow: 
  Outsourcing data import, renaming and type casting to a *.csv.
  Manipulating imputed datasets and fitting models on them. Summarizing models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr, mice, Hmisc, survival, stats, purrr, MASS,
sae</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), rms</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=basecamb">https://CRAN.R-project.org/package=basecamb</a>,
<a href="https://github.com/codeblue-team/basecamb">https://github.com/codeblue-team/basecamb</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/codeblue-team/basecamb/issues">https://github.com/codeblue-team/basecamb/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-21 17:58:45 UTC; Peter</td>
</tr>
<tr>
<td>Author:</td>
<td>J. Peter Marquardt
    <a href="https://orcid.org/0000-0002-5596-1357"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Till D. Best <a href="https://orcid.org/0000-0001-7323-827X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>J. Peter Marquardt &lt;peter@kmarquardt.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-22 19:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='.find_NA_coercions'>Locate NA values introduced during apply_data_dictionary()</h2><span id='topic+.find_NA_coercions'></span>

<h3>Description</h3>

<p>Finds and locates NA values that were introduced by calling <code>apply_data_dictionary()</code>
on a dataframe using a data_dictionary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.find_NA_coercions(data_raw, data, data_dictionary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".find_NA_coercions_+3A_data_raw">data_raw</code></td>
<td>
<p>data.frame that was provided as input to <code>apply_data_dictionary()</code></p>
</td></tr>
<tr><td><code id=".find_NA_coercions_+3A_data">data</code></td>
<td>
<p>data.frame that is returned by <code>apply_data_dictionary()</code></p>
</td></tr>
<tr><td><code id=".find_NA_coercions_+3A_data_dictionary">data_dictionary</code></td>
<td>
<p>the data_dictionary used by <code>apply_data_dictionary()</code>
to turn &quot;data_raw&quot; into &quot;data&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a dataframe with the location of introduced NA's. If no NA's
were introduced an empty dataframe is returned.
</p>


<h3>Author(s)</h3>

<p>Till D. Best, J. Peter Marquardt
</p>

<hr>
<h2 id='.parse_string_to_named_vector'>Parse a string to create a named list</h2><span id='topic+.parse_string_to_named_vector'></span>

<h3>Description</h3>

<p>Create a named list from a standardised string of the following format:
</p>

<ul>
<li><p> key-value pairs are separated from other key-value-pairs by a comma (&quot;,&quot;)
</p>
</li>
<li><p> key and value of the same pair are separated by an equal sign (&quot;=&quot;)
</p>
</li>
<li><p> quotations around individual keys and values are recommended for clarity, but do not affect functionality.
</p>
</li>
<li><p> all values will be coerced to type character, with the exception of &quot;NA&quot;, &quot;TRUE&quot; and &quot;FALSE&quot;
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>.parse_string_to_named_vector(str)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".parse_string_to_named_vector_+3A_str">str</code></td>
<td>
<p>character with standardized pattern to be parsed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>

<hr>
<h2 id='.scale_variable'>Scaling a variable</h2><span id='topic+.scale_variable'></span>

<h3>Description</h3>

<p>A helper function to scale a variable in a dataframe.
Divides 'variable' by 'scaling_denominator'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.scale_variable(data, variable, scaling_denominator)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".scale_variable_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id=".scale_variable_+3A_variable">variable</code></td>
<td>
<p>a char indicating the variable to be scaled</p>
</td></tr>
<tr><td><code id=".scale_variable_+3A_scaling_denominator">scaling_denominator</code></td>
<td>
<p>a numeric indicating the scaling. The variable is
divided by the scaling_denominator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input dataframe with the newly scaled 'variable'
</p>

<hr>
<h2 id='apply_data_dictionary'>Clean column names, types and levels</h2><span id='topic+apply_data_dictionary'></span>

<h3>Description</h3>

<p>Use a data dictionary data.frame to apply the following tidying steps to your data.frame:
</p>

<ul>
<li><p> Remove superfluous columns
</p>
</li>
<li><p> Rename columns
</p>
</li>
<li><p> Ensure/coerce correct data type for each column
</p>
</li>
<li><p> Assign factorial levels, including renaming and grouping
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>apply_data_dictionary(
  data,
  data_dictionary,
  na_action_default = "keep_NA",
  print_coerced_NA = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_data_dictionary_+3A_data">data</code></td>
<td>
<p>data.frame to be cleaned</p>
</td></tr>
<tr><td><code id="apply_data_dictionary_+3A_data_dictionary">data_dictionary</code></td>
<td>
<p>data.frame with the following columns:
</p>

<ul>
<li><p> old_column_name : character with the old column name
</p>
</li>
<li><p> new_data_type : character denoting the tidy data type. Supported types are:
</p>

<ul>
<li><p> character
</p>
</li>
<li><p> integer
</p>
</li>
<li><p> float
</p>
</li>
<li><p> factor
</p>
</li>
<li><p> date
</p>
</li></ul>

</li>
<li><p> new_column_name : tidy column name. Can be left blank to keep the old column name
</p>
</li>
<li><p> coding (factor and date columns only):
</p>

<ul>
<li><p> factor columns: character denoting old value (key) and new value (value) in a standardised fashion:
</p>

<ul>
<li><p> key-value pairs are separated from other key-value-pairs by a comma (&quot;,&quot;)
</p>
</li>
<li><p> key and value of the same pair are separated by an equal sign (&quot;=&quot;)
</p>
</li>
<li><p> quotations around individual keys and values are recommended for clarity, but do not affect functionality.
</p>
</li>
<li><p> all values will be coerced to type character, with the exception of &quot;NA&quot; being parsed as type NA
</p>
</li>
<li><p> using &quot;default&quot; as a key will assign the specified value to all current values that do not match any of the specified keys, excluding NA
</p>
</li>
<li><p> using &quot;NA&quot; as a key will assign the specified value to all current NA values
</p>
</li>
<li><p> example coding: &quot;'key1' = 'val1', 'key2' = 'val2', 'default' = 'Other', 'NA' = NA&quot;
</p>
</li>
<li><p> if no coding is specified for a column, the coding remains unchanged
</p>
</li></ul>

</li>
<li><p> date columns: character denoting coding (see format argument in <code>as.Date</code>)
</p>
</li></ul>

</li>
<li><p> Optional other columns (do not affect behaviour)
</p>
</li></ul>
</td></tr>
<tr><td><code id="apply_data_dictionary_+3A_na_action_default">na_action_default</code></td>
<td>
<p>character: Specify what to do with NA values. Defaults to 'keep_NA'. Options are:
</p>

<ul>
<li><p> 'keep_NA' NA values remain NA values
</p>
</li>
<li><p> 'assign_default' NA values are assigned the value specified as 'default'. Requires a 'default' value to be specified
Can be overwritten for individal columns by specifying a value for key 'NA'
</p>
</li></ul>
</td></tr>
<tr><td><code id="apply_data_dictionary_+3A_print_coerced_na">print_coerced_NA</code></td>
<td>
<p>logical indicating whether a message specifying the
location of NAs that are introduced by apply_data_dictionary() to data
should be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>clean data.frame
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>

<hr>
<h2 id='apply_function_to_imputed_data'>Apply function to dataframes in a mice object</h2><span id='topic+apply_function_to_imputed_data'></span>

<h3>Description</h3>

<p>Wrapper function to apply a function on each dataframe in an imputed dataset
created with <code>mice::mice()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_function_to_imputed_data(mice_data, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_function_to_imputed_data_+3A_mice_data">mice_data</code></td>
<td>
<p>a mids object generated by <code>mice::mice()</code>.</p>
</td></tr>
<tr><td><code id="apply_function_to_imputed_data_+3A_fun">fun</code></td>
<td>
<p>the function to apply to each dataframe. May only take one
positional argument of type data.frame.</p>
</td></tr>
<tr><td><code id="apply_function_to_imputed_data_+3A_...">...</code></td>
<td>
<p>other arguments passed to fun()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a mids object with transformed data.
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>

<hr>
<h2 id='assign_factorial_levels'>Assign custom values for key levels in factorial columns</h2><span id='topic+assign_factorial_levels'></span>

<h3>Description</h3>

<p>Use a named vector of keys (current value) and values for factorial columns
to assign meaningful levels and/or group levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_factorial_levels(
  data,
  factor_keys_values,
  na_action_default = "keep_NA"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_factorial_levels_+3A_data">data</code></td>
<td>
<p>data.frame to modify</p>
</td></tr>
<tr><td><code id="assign_factorial_levels_+3A_factor_keys_values">factor_keys_values</code></td>
<td>
<p>named list with:
</p>

<ul>
<li><p> Keys: Names of factor columns
</p>
</li>
<li><p> values: Named vectors with
</p>

<ul>
<li><p> keys: current value (string representation)
</p>
</li>
<li><p> values: new value to be assigned
</p>
</li>
<li><p> if a 'default' key is passed, all existing values not conforming to the new scheme will be converted to the 'default' value
</p>
</li>
<li><p> if a 'NA' key is passed, all NA values will be converted to the value specified here. Overwrites na_action_default for the specified column.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="assign_factorial_levels_+3A_na_action_default">na_action_default</code></td>
<td>
<p>character: Specify what to do with NA values. Defaults to 'keep_NA'. Options are:
</p>

<ul>
<li><p> 'keep_NA' NA values remain NA values
</p>
</li>
<li><p> 'assign_default' NA values are assigned the value specified as 'default'. Requires a 'default' value to be specified
Can be overwritten for individal columns by specifying a value for key 'NA'
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with new levels
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(col1 = as.factor(rep(c('1', '2', '4'), 5)))
keys_1 &lt;- list('col1' = c('1' = 'One', '2' = 'Two', '4' = 'Four'))
data_1 &lt;- assign_factorial_levels(data, keys_1)
keys_2 &lt;- list('col1' = c('1' = 'One', 'default' = 'Not_One'))
data_2 &lt;- assign_factorial_levels(data, keys_2)

</code></pre>

<hr>
<h2 id='assign_types_names'>Assign tidy types and names to a data.frame</h2><span id='topic+assign_types_names'></span>

<h3>Description</h3>

<p>Verbosely assign tidy name and data type for each column of a data.frame and
get rid of superfluous columns. Uses a .csv file for assignments to
encourage a data dictionary based workflow.
CAVE! Requires 'Date' type columns to already be read in as Date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_types_names(data, meta_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_types_names_+3A_data">data</code></td>
<td>
<p>data.frame to be tidied. Dates must already be of type date.</p>
</td></tr>
<tr><td><code id="assign_types_names_+3A_meta_data">meta_data</code></td>
<td>
<p>data.frame specifying old column names, new column names and
datatypes of data. Has the following columns:
</p>

<ul>
<li><p> old_column_name : character with the old column name.
</p>
</li>
<li><p> new_data_type : character denoting the tidy data type. Supported types are:
</p>

<ul>
<li><p> character (will be coerced using <code>as.character()</code>).
</p>
</li>
<li><p> integer (will be coerced using <code>as.integer()</code>).
</p>
</li>
<li><p> float (will be coerced using <code>as.double()</code>).
</p>
</li>
<li><p> factor (will be coerced using <code>as.factor()</code>).
Will result in a warning if the new factor variable will have more than 10 levels.
</p>
</li>
<li><p> date (can only confirm correct datatype assignment or coerce characters with format '%Y-%m-%d').
</p>
</li></ul>

</li>
<li><p> new_column_name : tidy column name. Can be left blank to keep the old column name.
</p>
</li>
<li><p> Optional other columns (do not affect behavior).
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>clean data.frame
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>

<hr>
<h2 id='build_model_formula'>Build formula for statistical models</h2><span id='topic+build_model_formula'></span>

<h3>Description</h3>

<p>Build formula used in statistical models from vectors of strings with the option to specify an environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_model_formula(
  outcome,
  predictors,
  censor_event = NULL,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_model_formula_+3A_outcome">outcome</code></td>
<td>
<p>character denoting the column with the outcome.</p>
</td></tr>
<tr><td><code id="build_model_formula_+3A_predictors">predictors</code></td>
<td>
<p>vector of characters denoting the columns with the
predictors.</p>
</td></tr>
<tr><td><code id="build_model_formula_+3A_censor_event">censor_event</code></td>
<td>
<p>character denoting the column with the censoring event,
for use in Survival-type models.</p>
</td></tr>
<tr><td><code id="build_model_formula_+3A_env">env</code></td>
<td>
<p>environment to be used in formula creation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formula for use in statistical models
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>build_model_formula("outcome", c("pred_1", "pred_2"))
build_model_formula("outcome", c("pred_1", "pred_2"), censor_event = "cens_event")

</code></pre>

<hr>
<h2 id='cox.zph.mids'>Test cox proportional odds assumption on models using multiple imputation.</h2><span id='topic+cox.zph.mids'></span>

<h3>Description</h3>

<p>Constructs a model and conducts a cox.zph test for each imputation of the data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox.zph.mids(
  model,
  imputations,
  p_level = 0.05,
  global_only = TRUE,
  return_raw = FALSE,
  p_only = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cox.zph.mids_+3A_model">model</code></td>
<td>
<p>cox proportional model to be evaluated</p>
</td></tr>
<tr><td><code id="cox.zph.mids_+3A_imputations">imputations</code></td>
<td>
<p>mids object containing imputations</p>
</td></tr>
<tr><td><code id="cox.zph.mids_+3A_p_level">p_level</code></td>
<td>
<p>value below which violation of proportional odds assumption is assumed. Defaults to .05</p>
</td></tr>
<tr><td><code id="cox.zph.mids_+3A_global_only">global_only</code></td>
<td>
<p>return global p-value only. Implies p_only to be TRUE</p>
</td></tr>
<tr><td><code id="cox.zph.mids_+3A_return_raw">return_raw</code></td>
<td>
<p>return cox.zph objects in a list. If TRUE, function will not return anything else</p>
</td></tr>
<tr><td><code id="cox.zph.mids_+3A_p_only">p_only</code></td>
<td>
<p>returns p-values of test only. If FALSE returns Chi² and degrees of freedom as well</p>
</td></tr>
<tr><td><code id="cox.zph.mids_+3A_verbose">verbose</code></td>
<td>
<p>Set to FALSE to deactivate messages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>depending on specified options, this function can return
</p>

<ul>
<li><p> default: A vector of global p-values
</p>
</li>
<li><p> global_only = FALSE: a data.frame with p-values for all variables plus the global
</p>
</li>
<li><p> return_raw = TRUE: list of cox.zph objects
</p>
</li></ul>



<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(time = 101:200, status = rep(c(0,1), 50), pred = rep(c(1:9, NA), 10))
imputed_data &lt;- mice::mice(data)
cox_mod &lt;- Hmisc::fit.mult.impute(survival::Surv(time, status) ~ pred,
fitter = rms::cph, xtrans = imputed_data)
cox.zph.mids(cox_mod, imputed_data)

</code></pre>

<hr>
<h2 id='deconstruct_formula'>Deconstruct formula</h2><span id='topic+deconstruct_formula'></span>

<h3>Description</h3>

<p>Deconstruct a formula object into strings of its components. Predictors are
split by '+', so interaction terms will be returned as a single string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconstruct_formula(formula)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deconstruct_formula_+3A_formula">formula</code></td>
<td>
<p>formula object for use in statistical models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list with fields:
</p>

<ul>
<li><p> outcome (character)
</p>
</li>
<li><p> predictors (vector of characters)
</p>
</li>
<li><p> censor_event (character) (optional) censor event, only for formulas including a Surv() object
</p>
</li></ul>



<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deconstruct_formula(stats::as.formula("outcome ~ predictor1 + predictor2 + predictor3"))
deconstruct_formula(stats::as.formula("Surv(outcome, censor_event) ~ predictor"))

</code></pre>

<hr>
<h2 id='filter_nth_entry'>Filter dataframe for nth entry</h2><span id='topic+filter_nth_entry'></span>

<h3>Description</h3>

<p>Filter a dataframe for the nth entry of each subject in it.
A typical use cases would be to filter a dataset for the first or last measurement of a subject.#'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_nth_entry(data, ID_column, entry_column, n = 1, reverse_order = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_nth_entry_+3A_data">data</code></td>
<td>
<p>the data.frame to filter</p>
</td></tr>
<tr><td><code id="filter_nth_entry_+3A_id_column">ID_column</code></td>
<td>
<p>character column identifying subjects</p>
</td></tr>
<tr><td><code id="filter_nth_entry_+3A_entry_column">entry_column</code></td>
<td>
<p>character column identifying order of entries.
That column can by of types Date, numeric, or any other type suitable for order()</p>
</td></tr>
<tr><td><code id="filter_nth_entry_+3A_n">n</code></td>
<td>
<p>integer number of entry to keep after ordering</p>
</td></tr>
<tr><td><code id="filter_nth_entry_+3A_reverse_order">reverse_order</code></td>
<td>
<p>logical when TRUE sorts entries last to first before filtering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with &lt;= 1 entry per subject
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(list(ID = rep(1:5, 3), encounter = rep(1:3, each=5), value = rep(4:6, each=5)))
filter_nth_entry(data, 'ID', 'encounter')
filter_nth_entry(data, 'ID', 'encounter', n = 2)
filter_nth_entry(data, 'ID', 'encounter', reverse_order = TRUE)


</code></pre>

<hr>
<h2 id='fit_mult_impute_obs_outcome'>Fit a model on multiply imputed data using only observations with non-missing
outcome(s)</h2><span id='topic+fit_mult_impute_obs_outcome'></span>

<h3>Description</h3>

<p>This function is a wrapper for fitting models with <code>Hmisc::fit.mult.impute()</code> on a
multiply imputed dataset generated with <code>mice::mice()</code>. Cases with a
missing outcome in the original dataset are removed from the mids object
by using the &quot;subset&quot; argument in <code>Hmisc::fit.mult.impute()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mult_impute_obs_outcome(mids, formula, fitter, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_mult_impute_obs_outcome_+3A_mids">mids</code></td>
<td>
<p>a mids object, i.e. the imputed dataset.</p>
</td></tr>
<tr><td><code id="fit_mult_impute_obs_outcome_+3A_formula">formula</code></td>
<td>
<p>a formula that describes the model to be fit. The outcome (y
variable) in the formula will be used to remove missing cases.</p>
</td></tr>
<tr><td><code id="fit_mult_impute_obs_outcome_+3A_fitter">fitter</code></td>
<td>
<p>a modeling function (not in quotes) that is compatible with
<code>Hmisc::fit.mult.impute()</code>.</p>
</td></tr>
<tr><td><code id="fit_mult_impute_obs_outcome_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>Hmisc::fit.mult.impute()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mod a fit.mult.impute object.
</p>


<h3>Author(s)</h3>

<p>Till D. Best
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create an imputed dataset
imputed_data &lt;- mice::mice(airquality)

fit_mult_impute_obs_outcome(mids = imputed_data, formula = Ozone ~ Solar.R + Wind, fitter = glm)

</code></pre>

<hr>
<h2 id='or_model_summary'>Summarise a logistic regression model on the odds ratio scale</h2><span id='topic+or_model_summary'></span>

<h3>Description</h3>

<p>This function summarises regression models that return data on the log-odds
scale and returns a dataframe with estimates, and confidence intervals as
odds ratios. P value are also provided.
Additionally, intercepts can be removed from the summary. This comes in
handy when ordinal logistic regression models are fit. Ordinal regression
models (such as proportional odds models) usually result in many intercepts
that are not really of interest.
This function is also compatible with models obtained from multiply imputed
datasets, for example models fitted with <code>Hmisc::fit.mult.impute()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>or_model_summary(
  model,
  conf_int = 1.96,
  print_intercept = FALSE,
  round_est = 3,
  round_p = 4
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="or_model_summary_+3A_model">model</code></td>
<td>
<p>a model object with estimates on the log-odds scale.</p>
</td></tr>
<tr><td><code id="or_model_summary_+3A_conf_int">conf_int</code></td>
<td>
<p>a numeric used to calculate the confidence intervals. The
default of 1.96 gives the 95% confidence interval.</p>
</td></tr>
<tr><td><code id="or_model_summary_+3A_print_intercept">print_intercept</code></td>
<td>
<p>a logical flag indicating whether intercepts shall
be removed. All variables that start with &quot;y&gt;=&quot; will be removed. If there
is a variable matching this pattern, it will also be removed!</p>
</td></tr>
<tr><td><code id="or_model_summary_+3A_round_est">round_est</code></td>
<td>
<p>the number of decimals returned for estimates (odds ratios)
and confidence intervals.</p>
</td></tr>
<tr><td><code id="or_model_summary_+3A_round_p">round_p</code></td>
<td>
<p>the number of decimals provided for p-values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CAVE! The function does not check whether your estimates are on the
log-odds scale. It will do the transformation no matter what!
</p>


<h3>Value</h3>

<p>a dataframe with the adjusted odds ratio, confidence intervals and
p-values.
</p>


<h3>Author(s)</h3>

<p>Till D. Best
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit a logistic model
mod &lt;- glm(formula = am ~ mpg + cyl, data = mtcars, family = binomial())

or_model_summary(model = mod)

</code></pre>

<hr>
<h2 id='parse_date_columns'>Parse values in date columns as Dates</h2><span id='topic+parse_date_columns'></span>

<h3>Description</h3>

<p>Parse date columns in a data.frame as Date.
Use a named list to specify each date column (key) and the format (value) it is coded in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_date_columns(data, date_formats)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_date_columns_+3A_data">data</code></td>
<td>
<p>data.frame to modify</p>
</td></tr>
<tr><td><code id="parse_date_columns_+3A_date_formats">date_formats</code></td>
<td>
<p>named list with:
</p>

<ul>
<li><p> Keys: Names of date columns
</p>
</li>
<li><p> values: character specifying the format
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with date columns in Date type
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(date = rep('01/23/4567', 5))
data &lt;- parse_date_columns(data, list(date = '%m/%d/%Y'))

</code></pre>

<hr>
<h2 id='quantile_group'>Stratify a numeric vector into quantile groups</h2><span id='topic+quantile_group'></span>

<h3>Description</h3>

<p>Transforms a numeric vector into quantile groups. For each input value, the output value corresponds to the quantile that value is in.
When grouping into n quantiles, the lowest 1/n of values are assigned 1, the highest 1/n are assigned n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_group(data, n, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantile_group_+3A_data">data</code></td>
<td>
<p>a vector of type numeric with values to be grouped into quantiles</p>
</td></tr>
<tr><td><code id="quantile_group_+3A_n">n</code></td>
<td>
<p>integer indicating number of quantiles, minimum of 2. Must be smaller than length(data)</p>
</td></tr>
<tr><td><code id="quantile_group_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if TRUE all NA values will be removed before calculating groups, if FALSE no NA values are permitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tied values will be assigned to the lower quantile group rather than etsimating a distribution. In extreme cases this can mean one or more quantile groups are not represented.
</p>
<p>If uneven group sizes cannot be avoided, values will be assigned the higher quantile group.
</p>


<h3>Value</h3>

<p>vector of length length(data) with the quantile groups
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>quantile_group(10:1, 3)
quantile_group(c(rep(1,3), 10:1, NA), 5)

</code></pre>

<hr>
<h2 id='remove_duplicates'>Remove duplicate rows from data.frame</h2><span id='topic+remove_duplicates'></span>

<h3>Description</h3>

<p>Removes rows that are duplicates of another row in all columns except exclude_columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_duplicates(
  data,
  exclude_columns = NULL,
  ID_column = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_duplicates_+3A_data">data</code></td>
<td>
<p>data.frame to check</p>
</td></tr>
<tr><td><code id="remove_duplicates_+3A_exclude_columns">exclude_columns</code></td>
<td>
<p>character vector, these columns are not considered in determining whether two rows are equal</p>
</td></tr>
<tr><td><code id="remove_duplicates_+3A_id_column">ID_column</code></td>
<td>
<p>character; column with identifiers to scan if possible duplicates remain</p>
</td></tr>
<tr><td><code id="remove_duplicates_+3A_quiet">quiet</code></td>
<td>
<p>logical: Should messages be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wraps unique()
</p>


<h3>Value</h3>

<p>vector of row indices with non-unique data
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(Study_ID = c("A", "B", "C"), ID = c(123, 456, 123), num_cars = c(10, 2, 10))
remove_duplicates(data, exclude_columns = "Study_ID")
remove_duplicates(data, exclude_columns = "Study_ID", ID_column = "ID")

</code></pre>

<hr>
<h2 id='remove_missing_from_mids'>Remove missing cases from a mids object</h2><span id='topic+remove_missing_from_mids'></span>

<h3>Description</h3>

<p>Deprecated, use <code><a href="#topic+apply_function_to_imputed_data">apply_function_to_imputed_data</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_missing_from_mids(mids, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_missing_from_mids_+3A_mids">mids</code></td>
<td>
<p>mids objects that is filtered.</p>
</td></tr>
<tr><td><code id="remove_missing_from_mids_+3A_var">var</code></td>
<td>
<p>a string or vector of strings specifying the variable(s). All
cases (i.e. rows) for which there are missing values are removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remove_missing_from_mids is used to filter a mids object for missing cases
in the original dataset in the variable var. This is useful for situations
where you want to use as many observations as possible for imputation but
only fit your model on a subset of these. Or, if you want to create one
large imputed datset from which multiple analyses with multiple outcomes
are derived.
</p>


<h3>Value</h3>

<p>a mids object filtered for observed cases of var.
</p>


<h3>Author(s)</h3>

<p>Till D. Best
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_function_to_imputed_data">apply_function_to_imputed_data</a></code>
</p>

<hr>
<h2 id='scale_continuous_predictors'>Scale continuous predictors</h2><span id='topic+scale_continuous_predictors'></span>

<h3>Description</h3>

<p>This function linearly scales variables in data objects according to a data dictionary.
The data dictionary has at least two columns, &quot;variable&quot; and &quot;scaling_denominator&quot;.
&quot;Variable&quot; is divided by &quot;scaling_denominator&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_continuous_predictors(data, scaling_dictionary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_continuous_predictors_+3A_data">data</code></td>
<td>
<p>a data object with variables.</p>
</td></tr>
<tr><td><code id="scale_continuous_predictors_+3A_scaling_dictionary">scaling_dictionary</code></td>
<td>
<p>a data.frame with two columns that are called
&quot;variable&quot; and &quot;scaling_denominator&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data with the newly scaled 'variables'.
</p>


<h3>Author(s)</h3>

<p>Till D. Best
</p>

<hr>
<h2 id='setduplicates'>Identify duplicate values in a vector representing a set</h2><span id='topic+setduplicates'></span>

<h3>Description</h3>

<p>Identify duplicate values in a vector representing a set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setduplicates(vect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setduplicates_+3A_vect">vect</code></td>
<td>
<p>a vector of any type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of duplicate elements
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>See Also</h3>

<p><a href="generics.html#topic+setops">setops</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setduplicates(c(1,2,2,3))

</code></pre>

<hr>
<h2 id='stratified_boxcox'>Box-Cox transformation for stratified data</h2><span id='topic+stratified_boxcox'></span>

<h3>Description</h3>

<p>Create Box-Cox transformation using different optimal lambda values for each stratum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratified_boxcox(
  data,
  value_col,
  strat_cols,
  plot = FALSE,
  return = "values",
  buffer = 0,
  inverse = FALSE,
  lambdas = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stratified_boxcox_+3A_data">data</code></td>
<td>
<p>data.frame containing the data</p>
</td></tr>
<tr><td><code id="stratified_boxcox_+3A_value_col">value_col</code></td>
<td>
<p>character, name of column with values to be transformed</p>
</td></tr>
<tr><td><code id="stratified_boxcox_+3A_strat_cols">strat_cols</code></td>
<td>
<p>character (vector), name(s) of columns to stratify by</p>
</td></tr>
<tr><td><code id="stratified_boxcox_+3A_plot">plot</code></td>
<td>
<p>logical, should the lambda distribution be plotted?</p>
</td></tr>
<tr><td><code id="stratified_boxcox_+3A_return">return</code></td>
<td>
<p>character, either &quot;values&quot; or &quot;lambdas&quot;</p>
</td></tr>
<tr><td><code id="stratified_boxcox_+3A_buffer">buffer</code></td>
<td>
<p>numeric, buffer value to be added before transformation, used to ensure all positive values</p>
</td></tr>
<tr><td><code id="stratified_boxcox_+3A_inverse">inverse</code></td>
<td>
<p>logical, if TRUE, the function reverses the transformation given a list of lambdas</p>
</td></tr>
<tr><td><code id="stratified_boxcox_+3A_lambdas">lambdas</code></td>
<td>
<p>if inverse == TRUE: Nested list of lambdas used in original transformation. Can be obtained by using return = &quot;lambdas&quot; on untransformed data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if &quot;values&quot;, vector of transformed values, if &quot;lambdas&quot; nested named list of used lambdas. The buffer will be equal for all strata
</p>


<h3>Author(s)</h3>

<p>J. Peter Marquardt
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame("value" = c(1:50, rnorm(50, 100, 10)),
                   "strat_var" = rep(c(1,2), each = 50),
                   "strat_var2" = rep(c(1, 2), 50))
lambdas &lt;- stratified_boxcox(data = data, value_col = "value",
                             strat_cols = c("strat_var", "strat_var2"),
                             return = "lambdas")
data$value_boxed &lt;- stratified_boxcox(data = data, value_col = "value",
                                      strat_cols = c("strat_var", "strat_var2"),
                                      return = "values")
data$value_unboxed &lt;- stratified_boxcox(data = data, value_col = "value_boxed",
                                        strat_cols = c("strat_var", "strat_var2"),
                                        inverse = TRUE, lambdas = lambdas)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
