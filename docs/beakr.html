<!DOCTYPE html><html><head><title>Help for package beakr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {beakr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beakr-package'><p>A minimalist web framework.</p></a></li>
<li><a href='#.matchPath'><p>Regex path query</p></a></li>
<li><a href='#.parseParameters'><p>Parse the parameters passed by in the request</p></a></li>
<li><a href='#.randomName'><p>Internal random name generator</p></a></li>
<li><a href='#.routeMiddleware'><p>Internal function to add middleware to a Beakr object</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#Beakr'><p>Beakr Application class</p></a></li>
<li><a href='#cors'><p>Allow Cross-Origin-Requests</p></a></li>
<li><a href='#decorate'><p>Decorate a function for use in a web service</p></a></li>
<li><a href='#Error'><p>Error class</p></a></li>
<li><a href='#handleErrors'><p>Error-handling middleware</p></a></li>
<li><a href='#httpDELETE'><p>DELETE-binding middleware</p></a></li>
<li><a href='#httpGET'><p>GET-binding middleware</p></a></li>
<li><a href='#httpPOST'><p>POST-binding middleware</p></a></li>
<li><a href='#httpPUT'><p>PUT-binding middleware</p></a></li>
<li><a href='#jsonError'><p>JSON error function</p></a></li>
<li><a href='#listen'><p>Listen for connections on a Beakr instance</p></a></li>
<li><a href='#Listener'><p>Listener class</p></a></li>
<li><a href='#listServers'><p>List all servers</p></a></li>
<li><a href='#Middleware'><p>Middleware class</p></a></li>
<li><a href='#newBeakr'><p>Create a new Beakr instance</p></a></li>
<li><a href='#Request'><p>Request Class</p></a></li>
<li><a href='#Response'><p>Response Class</p></a></li>
<li><a href='#Router'><p>Router Class</p></a></li>
<li><a href='#serveStaticFiles'><p>File-serving middleware</p></a></li>
<li><a href='#stopAllServers'><p>Stop all servers</p></a></li>
<li><a href='#stopServer'><p>Stop a beakr instance server</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Minimalist Web Framework for R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Hans Martin [aut],
  Jonathan Callahan [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan Callahan &lt;jonathan.s.callahan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A minimalist web framework for developing application programming 
    interfaces in R that provides a flexible framework for handling common 
    HTTP-requests, errors, logging, and an ability to integrate any R code as 
    server middle-ware.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MazamaScience/beakr">https://github.com/MazamaScience/beakr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MazamaScience/beakr/issues">https://github.com/MazamaScience/beakr/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>R6, base64enc, httpuv, jsonlite, magrittr, mime, stringr,
webutils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-04-06 17:04:16 UTC; jonathancallahan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-04-06 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='beakr-package'>A minimalist web framework.</h2><span id='topic+beakr-package'></span><span id='topic+Beakr-Package'></span>

<h3>Description</h3>

<p>The <span class="pkg">beakr</span> package provides a minimalist web framework for for
developing application programming interfaces in R. The package includes
basic functionality for handling common <code>HTTP</code> requests.
</p>
<p><span class="pkg">beakr</span> allows R code to listen for and respond to HTTP requests, so
you can serve web traffic directly from an R process. <span class="pkg">beakr</span> relies heavily
on the <a href="https://github.com/rstudio/httpuv">httpuv</a> package, and therefore
the lower level <a href="https://github.com/joyent/libuv">libuv</a> and
<a href="https://github.com/nodejs/http-parser">http-parser</a> C libraries.
<span class="pkg">beakr</span> is a ground-up rewrite and
continuation of the <span class="pkg">jug</span> package developed by Bart Smeets. The
<span class="pkg">beakr</span> package is supported and maintained by
<a href="http://www.mazamascience.com/">Mazama Science</a>.
</p>


<h3>Author(s)</h3>

<p>Hans Martin <a href="mailto:hans@mazamascience.com">hans@mazamascience.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+newBeakr">newBeakr</a></code>
</p>

<hr>
<h2 id='.matchPath'>Regex path query</h2><span id='topic+.matchPath'></span>

<h3>Description</h3>

<p>This function is used in the <code>Router$invoke()</code>
method to match middleware paths to request paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.matchPath(pattern, path, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".matchPath_+3A_pattern">pattern</code></td>
<td>
<p>String pattern to parse. (A middleware path.)</p>
</td></tr>
<tr><td><code id=".matchPath_+3A_path">path</code></td>
<td>
<p>Path to match to. (A request path.)</p>
</td></tr>
<tr><td><code id=".matchPath_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>regexpr()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List with information on matching paths and URL parameters.
</p>

<hr>
<h2 id='.parseParameters'>Parse the parameters passed by in the request</h2><span id='topic+.parseParameters'></span>

<h3>Description</h3>

<p>Internal function used in the <code>Request$initialize()</code>
method to extract URL parameters from the request path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.parseParameters(req, body, query, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".parseParameters_+3A_req">req</code></td>
<td>
<p>HTTP request object.</p>
</td></tr>
<tr><td><code id=".parseParameters_+3A_body">body</code></td>
<td>
<p>Body text string.</p>
</td></tr>
<tr><td><code id=".parseParameters_+3A_query">query</code></td>
<td>
<p>Url-encoded query string.</p>
</td></tr>
<tr><td><code id=".parseParameters_+3A_type">type</code></td>
<td>
<p>Media mime type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters and values.
</p>

<hr>
<h2 id='.randomName'>Internal random name generator</h2><span id='topic+.randomName'></span>

<h3>Description</h3>

<p>Every instantiated <code>Beakr</code> object is assigned a name generated
with this function. This makes it easy to keep track of multiple instances.
&quot;Hollywood Diva&quot; is unlikely to be confused with &quot;Cajun Bachelor&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.randomName()
</code></pre>


<h3>Value</h3>

<p>An identifying text string.
</p>

<hr>
<h2 id='.routeMiddleware'>Internal function to add middleware to a Beakr object</h2><span id='topic+.routeMiddleware'></span>

<h3>Description</h3>

<p>This function is used in each of the <code>http_~()</code> methods
as well as the <code>cors()</code>, <code>websocket()</code> and <code>use()</code> utility
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.routeMiddleware(beakr, FUN, path = NULL, method = NULL, websocket = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".routeMiddleware_+3A_beakr">beakr</code></td>
<td>
<p>Beakr instance.</p>
</td></tr>
<tr><td><code id=".routeMiddleware_+3A_fun">FUN</code></td>
<td>
<p>Function to route middleware.</p>
</td></tr>
<tr><td><code id=".routeMiddleware_+3A_path">path</code></td>
<td>
<p>Path to route the middleware.</p>
</td></tr>
<tr><td><code id=".routeMiddleware_+3A_method">method</code></td>
<td>
<p>HTTP method to employ.</p>
</td></tr>
<tr><td><code id=".routeMiddleware_+3A_websocket">websocket</code></td>
<td>
<p>Boolean, TRUE if websocket.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with added middleware.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='Beakr'>Beakr Application class</h2><span id='topic+Beakr'></span>

<h3>Description</h3>

<p>A <code>Beakr</code> object defines the server instance utilizing the
<span class="pkg">httpuv</span> package. This class defines an interface for the rest of the
<span class="pkg">beakr</span> package and is therefore meant to be instantiated.
</p>


<h3>Methods</h3>


<dl>
<dt><code>router()</code></dt><dd>
<p>An instantiated <code>Router</code> object.
</p>
</dd>
<dt><code>server()</code></dt><dd>
<p>The instantiated <code>Server</code> object.
</p>
</dd>
<dt><code>appDefinition()</code></dt><dd>
<p>A method to define the functions or middleware of users application.
</p>
</dd>
<dt><code>initialize()</code></dt><dd>
<p>Creates a new <code>Router</code> object for the <code>router</code>
method.
</p>
</dd>
<dt><code>start(host, port, daemon)</code></dt><dd>
<p>Returns a running server. If <code>daemon = TRUE</code>, the server will run
in the background.
</p>
</dd>
<dt><code>print(...)</code></dt><dd>
<p>Returns a console output of the instance and its number of middleware
attached.
</p>
</dd>
</dl>



<h3>Package details</h3>

<p>The <span class="pkg">beakr</span> package provides a minimal web framework for for developing
lightweight APIs in R. The package includes basic functionality for handling
common <code>HTTP</code> requests. <span class="pkg">beakr</span> is a ground-up rewrite and
continuation of the <span class="pkg">jug</span> package developed by Bart Smeets. The
<span class="pkg">beakr</span> package is supported and maintained by
<a href="http://www.mazamascience.com/">Mazama Science</a>.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-appDefinition"><code>Beakr$appDefinition()</code></a>
</p>
</li>
<li> <p><a href="#method-new"><code>Beakr$new()</code></a>
</p>
</li>
<li> <p><a href="#method-start"><code>Beakr$start()</code></a>
</p>
</li>
<li> <p><a href="#method-print"><code>Beakr$print()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Beakr$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-appDefinition"></a>



<h4>Method <code>appDefinition()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Beakr$appDefinition()</pre></div>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Beakr$new()</pre></div>


<hr>
<a id="method-start"></a>



<h4>Method <code>start()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Beakr$start(host, port, daemon)</pre></div>


<hr>
<a id="method-print"></a>



<h4>Method <code>print()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Beakr$print()</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Beakr$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Router">Router</a></code> and <code><a href="#topic+Middleware">Middleware</a></code>
</p>

<hr>
<h2 id='cors'>Allow Cross-Origin-Requests</h2><span id='topic+cors'></span>

<h3>Description</h3>

<p>Allow Cross-Origin Resource Sharing headers as described in
<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">MDN Web Docs</a>.
Cross-origin resource sharing is a mechanism that allows restricted resources
on a web page to be requested from another domain(origin) outside the domain
from which the first resource was served.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cors(
  beakr,
  path = NULL,
  methods = c("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"),
  origin = "*",
  credentials = NULL,
  headers = NULL,
  maxAge = NULL,
  expose = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cors_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance object.</p>
</td></tr>
<tr><td><code id="cors_+3A_path">path</code></td>
<td>
<p>String representing a path for which to specify a CORS policy.
Default <code>NULL</code> applies a single policy for all URL routes.</p>
</td></tr>
<tr><td><code id="cors_+3A_methods">methods</code></td>
<td>
<p>A vector of the request methods to allow. i.e
<code>Access-Control-Allow-Methods</code> parameter, e.g <code>GET, POST</code>.</p>
</td></tr>
<tr><td><code id="cors_+3A_origin">origin</code></td>
<td>
<p>A vector of the request origin(s) for which resource sharing
is enabled. i.e <code>Access-Control-Allow-Origin</code> response header parameter.</p>
</td></tr>
<tr><td><code id="cors_+3A_credentials">credentials</code></td>
<td>
<p>A boolean to enable/disable credentialed requests. i.e
<code>Access-Control-Allow-Credentials</code> response header parameter.</p>
</td></tr>
<tr><td><code id="cors_+3A_headers">headers</code></td>
<td>
<p>A vector of the allowed headers. i.e
<code>Access-Control-Allow-Headers</code> response header parameter.</p>
</td></tr>
<tr><td><code id="cors_+3A_maxage">maxAge</code></td>
<td>
<p>The max age, in seconds. i.e <code>Access-Control-Max-Age</code>
response header parameter.</p>
</td></tr>
<tr><td><code id="cors_+3A_expose">expose</code></td>
<td>
<p>The headers to expose. i.e <code>Access-Control-Expose-Headers</code>
response header parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with CORS enabled
</p>


<h3>Note</h3>

<p>You can verify that CORS is enabled by using the Chrome browser and
opening up the Developer Tools. The &quot;Network&quot; tab allows you to inspect
response headers and see where the <code>Cross-Origin</code> policy is specified.
</p>
<p>If you run the example in the console, be sure to
<code>stopServer(bekar)</code> when you are done.
</p>


<h3>See Also</h3>

<p><a href="#topic+Request">Request</a>, <a href="#topic+Response">Response</a>, <a href="#topic+Error">Error</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beakr)

# Create an new beakr instance
beakr &lt;- newBeakr()

# beakr pipeline
beakr %&gt;%

  # Enable CORS
  cors() %&gt;%

  # Respond to GET requests at the "/hi" route
  httpGET(path = "/hi", function(req, res, err) {
    print("Hello, World!")
  }) %&gt;%

  # Respond to GET requests at the "/bye" route
  httpGET(path = "/bye", function(req, res, err) {
    print("Farewell, my friends.")
  }) %&gt;%

  # Start the server on port 25118
  listen(host = "127.0.0.1", port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# POINT YOUR BROWSER AT:
# * http://127.0.0.1:25118/hi
# * http://127.0.0.1:25118/bye
#
# THEN, STOP THE SERVER WITH stopServer(beakr)
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

</code></pre>

<hr>
<h2 id='decorate'>Decorate a function for use in a web service</h2><span id='topic+decorate'></span>

<h3>Description</h3>

<p>The <code>decorate()</code> function can be used to prepare a function
for easy use in a beakr pipeline.
</p>
<p>Decorating a function associates the specified function and its parameters
with <code>req</code>, <code>res</code>, and <code>err</code> objects and assigns a
content-type to the response object. This prepares a standard R function to
be used in <code>Beakr</code> instances and accept requests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decorate(FUN, content_type = "text/html", strict = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decorate_+3A_fun">FUN</code></td>
<td>
<p>Function to decorate.</p>
</td></tr>
<tr><td><code id="decorate_+3A_content_type">content_type</code></td>
<td>
<p>HTTP &quot;content-type&quot; of the function output.
(<em>e.g.</em> &quot;text/plain&quot;, &quot;text/html&quot; or other mime type)</p>
</td></tr>
<tr><td><code id="decorate_+3A_strict">strict</code></td>
<td>
<p>Boolean, requiring strict parameter matching.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <em>decorated</em> middleware function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beakr)

# Create an new Beakr instance
beakr &lt;- newBeakr()

# Create simple hello and goodbye function
hello &lt;- function(name) { paste0("Hello, ", name, "!") }
goodbye &lt;- function(text = "Adios") { paste0(text, ", dear friend.") }

# Create a web service from these functions
beakr %&gt;%

  httpGET(path = "/hello", decorate(hello)) %&gt;%

  httpGET(path = "/goodbye", decorate(goodbye)) %&gt;%

  handleErrors() %&gt;%

  listen(host = '127.0.0.1', port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# POINT YOUR BROWSER AT:
# * http://127.0.0.1:25118/hello?name=Honeydew
# * http://127.0.0.1:25118/goodbye?text=Sionara
#
# THEN, STOP THE SERVER WITH stopServer(beakr)
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

</code></pre>

<hr>
<h2 id='Error'>Error class</h2><span id='topic+Error'></span>

<h3>Description</h3>

<p>An <code>Error</code> object represents the state and handling of instance
or middleware errors.
</p>


<h3>Fields</h3>


<dl>
<dt><code>errors</code></dt><dd>
<p>Returns a list of errors, if any.
</p>
</dd>
<dt><code>occured</code></dt><dd>
<p>Returns TRUE if any error has occurred, FALSE otherwise.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>set(err)</code></dt><dd>
<p>Sets an error.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-set"><code>Error$set()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Error$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-set"></a>



<h4>Method <code>set()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Error$set(err)</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Error$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+handleErrors">handleErrors</a></code> and <code><a href="#topic+Middleware">Middleware</a></code>
</p>

<hr>
<h2 id='handleErrors'>Error-handling middleware</h2><span id='topic+handleErrors'></span>

<h3>Description</h3>

<p>This default error handler should be added
at the end of the beakr pipeline, right before <code>listen()</code>. Errors
generated by any previous step will be returned within a JSON wrapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>handleErrors(beakr = NULL, FUN = jsonError)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="handleErrors_+3A_beakr">beakr</code></td>
<td>
<p>Beakr instance</p>
</td></tr>
<tr><td><code id="handleErrors_+3A_fun">FUN</code></td>
<td>
<p>a function to handle the error response</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with added middleware.
</p>


<h3>Note</h3>

<p>If you run the example in the console, be sure to
<code>stopServer(bekar)</code> when you are done.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beakr)

# Create an new beakr instance
beakr &lt;- newBeakr()

# beakr pipeline
beakr %&gt;%

  # Respond to GET requests at the "/hi" route
  httpGET(path = "/hi", function(req, res, err) {
    print("Hello, World!")
  }) %&gt;%

  # Respond to GET requests at the "/bye" route
  httpGET(path = "/bye", function(req, res, err) {
    print("Farewell, my friends.")
  }) %&gt;%

  handleErrors() %&gt;%

  # Start the server on port 25118
  listen(host = "127.0.0.1", port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# POINT YOUR BROWSER AT:
# * http://127.0.0.1:25118/NOT_A_ROUTE
#
# THEN, STOP THE SERVER WITH stopServer(beakr)
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

</code></pre>

<hr>
<h2 id='httpDELETE'>DELETE-binding middleware</h2><span id='topic+httpDELETE'></span>

<h3>Description</h3>

<p>Routes HTTP DELETE requests to the specified path with the
specified callback functions or middleware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httpDELETE(beakr, path = NULL, FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httpDELETE_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="httpDELETE_+3A_path">path</code></td>
<td>
<p>String representing a path for which the middleware
function is invoked.</p>
</td></tr>
<tr><td><code id="httpDELETE_+3A_fun">FUN</code></td>
<td>
<p>Middleware function to be invoked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with added middleware.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beakr)

# Create an new Beakr instance
beakr &lt;- newBeakr()

# Create a simple beakr pipeline
beakr %&gt;%
  httpDELETE("/", function(req, res, err) {
    return("Successful DELETE request!\n")
  }) %&gt;%
  listen(host = '127.0.0.1', port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# IN A TERMINAL:
#  curl -X DELETE http://127.0.0.1:25118/
# &gt; Successful DELETE request!
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

## End(Not run)
</code></pre>

<hr>
<h2 id='httpGET'>GET-binding middleware</h2><span id='topic+httpGET'></span>

<h3>Description</h3>

<p>Routes HTTP GET requests to the specified path with the
specified callback functions or middleware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httpGET(beakr, path = NULL, FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httpGET_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="httpGET_+3A_path">path</code></td>
<td>
<p>String representing a path for which the middleware
function is invoked.</p>
</td></tr>
<tr><td><code id="httpGET_+3A_fun">FUN</code></td>
<td>
<p>Middleware function to be invoked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with added middleware.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beakr)

# Create an new Beakr instance
beakr &lt;- newBeakr()

# Create a simple beakr pipeline
beakr %&gt;%
  httpGET("/", function(req, res, err) {
    return("Successful GET request!\n")
  }) %&gt;%
  listen(host = '127.0.0.1', port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# IN A TERMINAL:
#  curl -X GET http://127.0.0.1:25118/
# &gt; Successful GET request!
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

## End(Not run)
</code></pre>

<hr>
<h2 id='httpPOST'>POST-binding middleware</h2><span id='topic+httpPOST'></span>

<h3>Description</h3>

<p>Routes HTTP POST requests to the specified path with the
specified callback functions or middleware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httpPOST(beakr, path = NULL, FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httpPOST_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="httpPOST_+3A_path">path</code></td>
<td>
<p>String representing a path for which the middleware
function is invoked.</p>
</td></tr>
<tr><td><code id="httpPOST_+3A_fun">FUN</code></td>
<td>
<p>Middleware function to be invoked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with added middleware.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beakr)

# Create an new Beakr instance
beakr &lt;- newBeakr()

# Create a simple beakr pipeline
beakr %&gt;%
  httpPOST("/", function(req, res, err) {
    return("Successful POST request!\n")
  }) %&gt;%
  listen(host = '127.0.0.1', port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# IN A TERMINAL:
#  curl -X POST http://127.0.0.1:25118/
# &gt; Successful POST request!
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

## End(Not run)
</code></pre>

<hr>
<h2 id='httpPUT'>PUT-binding middleware</h2><span id='topic+httpPUT'></span>

<h3>Description</h3>

<p>Routes HTTP PUT requests to the specified path with the
specified callback functions or middleware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>httpPUT(beakr, path = NULL, FUN = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="httpPUT_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="httpPUT_+3A_path">path</code></td>
<td>
<p>String representing a path for which the middleware
function is invoked.</p>
</td></tr>
<tr><td><code id="httpPUT_+3A_fun">FUN</code></td>
<td>
<p>Middleware function to be invoked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with added middleware.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(beakr)

# Create an new Beakr instance
beakr &lt;- newBeakr()

# Create a simple beakr pipeline
beakr %&gt;%
  httpPUT("/", function(req, res, err) {
    return("Successful PUT request!\n")
  }) %&gt;%
  listen(host = '127.0.0.1', port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# IN A TERMINAL:
#  curl -X PUT http://127.0.0.1:25118/
# &gt; Successful PUT request!
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

## End(Not run)
</code></pre>

<hr>
<h2 id='jsonError'>JSON error function</h2><span id='topic+jsonError'></span>

<h3>Description</h3>

<p>This function is used to add a JSON error response to the
<code>res</code> object. It is called by the <code>handleErrors()</code> utility
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsonError(req, res, err)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jsonError_+3A_req">req</code></td>
<td>
<p><code>Request</code> object.</p>
</td></tr>
<tr><td><code id="jsonError_+3A_res">res</code></td>
<td>
<p><code>Response</code> object.</p>
</td></tr>
<tr><td><code id="jsonError_+3A_err">err</code></td>
<td>
<p><code>Error</code> Error object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The incoming <code>res</code> object is modified.
</p>


<h3>See Also</h3>

<p><a href="#topic+Request">Request</a>, <a href="#topic+Response">Response</a>, <a href="#topic+Error">Error</a>
</p>

<hr>
<h2 id='listen'>Listen for connections on a Beakr instance</h2><span id='topic+listen'></span>

<h3>Description</h3>

<p>Binds and listens for connections at the specified host and port.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listen(
  beakr = NULL,
  host = "127.0.0.1",
  port = 25118,
  daemon = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listen_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance.</p>
</td></tr>
<tr><td><code id="listen_+3A_host">host</code></td>
<td>
<p>String that is a valid IPv4 or IPv6 address to listen on.
Defaults to the local host (&quot;127.0.0.1&quot;).</p>
</td></tr>
<tr><td><code id="listen_+3A_port">port</code></td>
<td>
<p>Number or integer that indicates the port to listen on. Default
is a port opened on 25118.</p>
</td></tr>
<tr><td><code id="listen_+3A_daemon">daemon</code></td>
<td>
<p>Logical specifying whether the server should be run in the
background.</p>
</td></tr>
<tr><td><code id="listen_+3A_verbose">verbose</code></td>
<td>
<p>Logical specifying whether to print out details of the
<code>Beakr</code> instance now running. This should only be used when running
a beaker app interactively, not in production.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>listen()</code> binds the specified host and port and listens for connections
on a thread. The thread handles incoming requests. when it receives an HTTP
request, it will schedule a call to the user-defined middleware and handle the
request.
</p>
<p>If <code>daemon = TRUE</code>, <code>listen()</code> binds the specified port and listens
for connections on a thread running in the background.
</p>
<p>See the <span class="pkg">httpuv</span> package for more details.
</p>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with an active server.
</p>


<h3>Note</h3>

<p>The default port number 25118 was generated using:
</p>
<pre>
&gt; match(c("b","e","a","k","r"), letters) %% 10
[1] 2 5 1 1 8
</pre>


<h3>Examples</h3>

<pre><code class='language-R'>library(beakr)

# Create an new Beakr instance
beakr &lt;- newBeakr()

# beakr pipeline
beakr %&gt;%

  httpGET("/", function(req, res, err) {
    return("Successful GET request!\n")
  }) %&gt;%

  listen(daemon = TRUE)     # run in the background

# Stop the server
stopServer(beakr)
</code></pre>

<hr>
<h2 id='Listener'>Listener class</h2><span id='topic+Listener'></span>

<h3>Description</h3>

<p>A <code>Listener</code> object provides a simple, programmatically
controlled HTTP protocol listener.
</p>


<h3>Fields</h3>


<dl>
<dt><code>FUN</code></dt><dd>
<p>Returns function response.
</p>
</dd>
<dt><code>event</code></dt><dd>
<p>Returns event type.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>initialize(FUN, event)</code></dt><dd>
<p>Sets instance object function and event state.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Listener$new()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Listener$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Listener$new(event, FUN, ...)</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Listener$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Router">Router</a></code> and <code><a href="#topic+Error">Error</a></code>
</p>

<hr>
<h2 id='listServers'>List all servers</h2><span id='topic+listServers'></span>

<h3>Description</h3>

<p>Lists all <code>Beakr</code> servers currently running (and any other
servers created with the <span class="pkg">httpuv</span> package). This function is included to
encourage experimentation so that users who create multiple <code>Beakr</code>
instances can quickly find and stop them all.
</p>
<p>See <code>httpuv::<a href="httpuv.html#topic+listServers">listServers</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listServers()
</code></pre>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beakr)

beakr1 &lt;- newBeakr()
beakr2 &lt;- newBeakr()
beakr1 %&gt;% listen(daemon = TRUE, port = 1234, verbose = TRUE)
beakr2 %&gt;% listen(daemon = TRUE, port = 4321, verbose = TRUE)
length(listServers())
stopAllServers()
length(listServers())
</code></pre>

<hr>
<h2 id='Middleware'>Middleware class</h2><span id='topic+Middleware'></span>

<h3>Description</h3>

<p>A <code>Middleware</code> object represents middleware functions that have access
to the request (<code>req</code>), response (<code>res</code>) and error (<code>err</code>)
objects in request-response cycle via the <code>Router</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>path</code></dt><dd>
<p>Returns the path for the specified middleware.
</p>
</dd>
<dt><code>FUN</code></dt><dd>
<p>Returns the function response.
</p>
</dd>
<dt><code>method</code></dt><dd>
<p>Returns the HTTP method for the middleware, i.e. &quot;GET&quot;, &quot;POST&quot;, etc.
</p>
</dd>
<dt><code>protocol</code></dt><dd>
<p>Returns the protocol, &quot;http&quot; or &quot;websocket&quot;.
</p>
</dd>
</dl>


<dl>
<dt><code>initialize(FUN, path, method, websocket)</code></dt><dd>
<p>Initializes the state of new middleware.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-new"><code>Middleware$new()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Middleware$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Middleware$new(FUN, path, method, websocket)</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Middleware$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Router">Router</a></code> and <code><a href="#topic+Middleware">Middleware</a></code>
</p>

<hr>
<h2 id='newBeakr'>Create a new Beakr instance</h2><span id='topic+newBeakr'></span>

<h3>Description</h3>

<p>Create a <code>Beakr</code> instance by calling the top-level
<code>newBeakr()</code> function. If <code>name</code> is not supplied, a random name
will be assigned.
</p>
<p>This <code>Beakr</code> instance will then begin a pipeline of separate middleware
steps for routing, serving files and handling errors. The pipeline will
end with the <code>listen()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newBeakr(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newBeakr_+3A_name">name</code></td>
<td>
<p>Optional name assigned to the <code>Beakr</code> instance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new and empty <code>Beakr</code> instance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beakr)

# Create an new beakr instance
beakr &lt;- newBeakr()

# beakr pipeline of hanldlers
beakr %&gt;%

  httpGET(path = "/route_A", function(res, req, err) {
    print("This is route 'A'.")
  }) %&gt;%

  httpGET(path = "/route_B", function(res, req, err) {
    print("This is route 'B'.")
  }) %&gt;%

  handleErrors() %&gt;%

  listen(host = '127.0.0.1', port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# POINT YOUR BROWSER AT:
# * http://127.0.0.1:25118/route_A
# * http://127.0.0.1:25118/route_B
#
# THEN, STOP THE SERVER WITH stopServer(beakr)
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

</code></pre>

<hr>
<h2 id='Request'>Request Class</h2><span id='topic+Request'></span>

<h3>Description</h3>

<p>A <code>Request</code> object represents the HTTP request and has properties for
the request query string, parameters, body, HTTP headers, and so on.
In this documentation and by convention, the object is always referred to as
<code>req</code> (and the HTTP response is <code>res</code>).
</p>


<h3>Fields</h3>


<dl>
<dt><code>parameters</code></dt><dd>
<p>A list containing properties mapped to the named router parameters.
</p>
</dd>
<dt><code>headers</code></dt><dd>
<p>A list of response headers.
</p>
</dd>
<dt><code>path</code></dt><dd>
<p>Contains the path part of the request URL.
</p>
</dd>
<dt><code>method</code></dt><dd>
<p>Contains a string corresponding to the HTTP method of the request:
GET, POST, PUT, and so on.
</p>
</dd>
<dt><code>raw</code></dt><dd>
<p>Returns the raw request (<code>req</code>) object.
</p>
</dd>
<dt><code>type</code></dt><dd>
<p>Contains the body content-type, i.e. &quot;text/html&quot; or &quot;application/json&quot;.
</p>
</dd>
<dt><code>body</code></dt><dd>
<p>Contains the data submitted in the request body.
</p>
</dd>
<dt><code>protocol</code></dt><dd>
<p>Contains the request protocol string.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>attach(key, value)</code></dt><dd>
<p>Returns a key-value.
</p>
</dd>
<dt><code>getHeader(key)</code></dt><dd>
<p>Returns the key element of the <code>headers</code> list.
</p>
</dd>
<dt><code>setHeader(key, value)</code></dt><dd>
<p>Attaches a header to <code>headers</code> list.
</p>
</dd>
<dt><code>addParameters(named_list)</code></dt><dd>
<p>Adds parameters to the named key-value <code>parameters</code> list.
</p>
</dd>
<dt><code>intialize(req)</code></dt><dd>
<p>Creates a new <code>Request</code> object by parsing and extracting features of
<code>req</code> input and populating the object fields.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-attach"><code>Request$attach()</code></a>
</p>
</li>
<li> <p><a href="#method-getHeader"><code>Request$getHeader()</code></a>
</p>
</li>
<li> <p><a href="#method-setHeader"><code>Request$setHeader()</code></a>
</p>
</li>
<li> <p><a href="#method-addParameters"><code>Request$addParameters()</code></a>
</p>
</li>
<li> <p><a href="#method-new"><code>Request$new()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Request$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-attach"></a>



<h4>Method <code>attach()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$attach(key, value)</pre></div>


<hr>
<a id="method-getHeader"></a>



<h4>Method <code>getHeader()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$getHeader(key)</pre></div>


<hr>
<a id="method-setHeader"></a>



<h4>Method <code>setHeader()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$setHeader(key, value)</pre></div>


<hr>
<a id="method-addParameters"></a>



<h4>Method <code>addParameters()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$addParameters(named_list)</pre></div>


<hr>
<a id="method-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Request$new(req)</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Request$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Response">Response</a></code>
</p>

<hr>
<h2 id='Response'>Response Class</h2><span id='topic+Response'></span>

<h3>Description</h3>

<p>A <code>Response</code> object represents represents the HTTP response that a
<code>Beakr</code> sends when it gets an HTTP request. It is by convention, the
object is always referred to as <code>res</code> (and the HTTP request is
<code>req</code>).
</p>


<h3>Fields</h3>


<dl>
<dt><code>headers</code></dt><dd>
<p>A list containing a key-value header list.
</p>
</dd>
<dt><code>status</code></dt><dd>
<p>An integer HTTP status code.
</p>
</dd>
<dt><code>body</code></dt><dd>
<p>Contains the response body.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>setHeader(key, value)</code></dt><dd>
<p>Sets a key-value header, i.e. <code>"Content-Type" = "text/html"</code>.
</p>
</dd>
<dt><code>setContentType(type)</code></dt><dd>
<p>Sets the response content-type.
</p>
</dd>
<dt><code>setStatus(status)</code></dt><dd>
<p>Sets the HTTP status code.
</p>
</dd>
<dt><code>setBody(body)</code></dt><dd>
<p>Sets the body response.
</p>
</dd>
<dt><code>redirect(url)</code></dt><dd>
<p>Sets the HTTP status to 302, &quot;Found&quot; and redirects to <code>url</code>.
</p>
</dd>
<dt><code>json(txt, auto_unbox = TRUE)</code></dt><dd>
<p>Applies a function to text convert to JSON and sets the content-type to
JSON.
</p>
</dd>
<dt><code>text(txt)</code></dt><dd>
<p>Sets the response body text.
</p>
</dd>
<dt><code>structured(protocol)</code></dt><dd>
<p>Sets the response protocol, i.e. &quot;http&quot;
</p>
</dd>
<dt><code>plot(plot_object, base64 = TRUE, ...)</code></dt><dd>
<p>Sets the response type to plot image output.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-setHeader"><code>Response$setHeader()</code></a>
</p>
</li>
<li> <p><a href="#method-setContentType"><code>Response$setContentType()</code></a>
</p>
</li>
<li> <p><a href="#method-setStatus"><code>Response$setStatus()</code></a>
</p>
</li>
<li> <p><a href="#method-setBody"><code>Response$setBody()</code></a>
</p>
</li>
<li> <p><a href="#method-redirect"><code>Response$redirect()</code></a>
</p>
</li>
<li> <p><a href="#method-json"><code>Response$json()</code></a>
</p>
</li>
<li> <p><a href="#method-text"><code>Response$text()</code></a>
</p>
</li>
<li> <p><a href="#method-structured"><code>Response$structured()</code></a>
</p>
</li>
<li> <p><a href="#method-plot"><code>Response$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Response$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-setHeader"></a>



<h4>Method <code>setHeader()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$setHeader(key, value)</pre></div>


<hr>
<a id="method-setContentType"></a>



<h4>Method <code>setContentType()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$setContentType(type)</pre></div>


<hr>
<a id="method-setStatus"></a>



<h4>Method <code>setStatus()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$setStatus(status)</pre></div>


<hr>
<a id="method-setBody"></a>



<h4>Method <code>setBody()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$setBody(body)</pre></div>


<hr>
<a id="method-redirect"></a>



<h4>Method <code>redirect()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$redirect(url)</pre></div>


<hr>
<a id="method-json"></a>



<h4>Method <code>json()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$json(txt, auto_unbox = TRUE)</pre></div>


<hr>
<a id="method-text"></a>



<h4>Method <code>text()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$text(txt)</pre></div>


<hr>
<a id="method-structured"></a>



<h4>Method <code>structured()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$structured(protocol)</pre></div>


<hr>
<a id="method-plot"></a>



<h4>Method <code>plot()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Response$plot(plot_object, base64 = TRUE, ...)</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Response$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Response">Response</a></code>
</p>

<hr>
<h2 id='Router'>Router Class</h2><span id='topic+Router'></span>

<h3>Description</h3>

<p>A <code>Router</code> object represents the handling of routing and middleware
(such as httpGET(), httpPUT(), httpPOST(), and so on). Once a <code>Router</code>
object is instantiated, middleware and HTTP method routes can be added. The
top level <code>Beakr</code> object initializes with the creation of a
<code>Router</code> object.
</p>


<h3>Fields</h3>


<dl>
<dt><code>middleware</code></dt><dd>
<p>A list of specified middleware function or functions.
</p>
</dd>
<dt><code>listeners</code></dt><dd>
<p>A list of specified listeners.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>addMiddleware(middlware)</code></dt><dd>
<p>A method to add middleware function(s) to <code>middleware</code>.
</p>
</dd>
<dt><code>addListener(listener)</code></dt><dd>
<p>A method to add listeners to <code>listeners</code>.
</p>
</dd>
<dt><code>processEvent(event, ...)</code></dt><dd>
<p>Processes the event heard by the <code>Listener</code>.
</p>
</dd>
<dt><code>invoke(req, websocket_msg, websocket_binary)</code></dt><dd>
<p>This method is used to create the request-response cycle objects of the
provided middleware.
</p>
</dd>
</dl>



<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-addMiddleware"><code>Router$addMiddleware()</code></a>
</p>
</li>
<li> <p><a href="#method-addListener"><code>Router$addListener()</code></a>
</p>
</li>
<li> <p><a href="#method-processEvent"><code>Router$processEvent()</code></a>
</p>
</li>
<li> <p><a href="#method-invoke"><code>Router$invoke()</code></a>
</p>
</li>
<li> <p><a href="#method-clone"><code>Router$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-addMiddleware"></a>



<h4>Method <code>addMiddleware()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Router$addMiddleware(middleware)</pre></div>


<hr>
<a id="method-addListener"></a>



<h4>Method <code>addListener()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Router$addListener(listener)</pre></div>


<hr>
<a id="method-processEvent"></a>



<h4>Method <code>processEvent()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Router$processEvent(event, ...)</pre></div>


<hr>
<a id="method-invoke"></a>



<h4>Method <code>invoke()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>Router$invoke(req, websocket_msg = NULL, websocket_binary = NULL)</pre></div>


<hr>
<a id="method-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Router$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p><code><a href="#topic+Response">Response</a></code>
</p>

<hr>
<h2 id='serveStaticFiles'>File-serving middleware</h2><span id='topic+serveStaticFiles'></span>

<h3>Description</h3>

<p>Binds to GET requests that aren't handled by specified paths.
The result is to return files that are found on the host machine at the
requested path. Binary file types like <code>.png</code>, <code>.gif</code> or
<code>.pdf</code> are returned as raw bytes. All others are returned as characters.
</p>
<p>Mime types are guessed using the <span class="pkg">mime</span> package. The <code>rawTypesPattern</code>
parameter is used to match mime types that should be returned as raw bytes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serveStaticFiles(
  beakr = NULL,
  urlPath = NULL,
  rootPath = getwd(),
  rawTypesPattern = "image|json|octet|pdf|video",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serveStaticFiles_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="serveStaticFiles_+3A_urlpath">urlPath</code></td>
<td>
<p>String representing the URL directory underneath which static
file paths will appear.</p>
</td></tr>
<tr><td><code id="serveStaticFiles_+3A_rootpath">rootPath</code></td>
<td>
<p>String representing the absolute path used as the root
directory when searching for files on host machine. Defaults to the directory
in which the script is running.</p>
</td></tr>
<tr><td><code id="serveStaticFiles_+3A_rawtypespattern">rawTypesPattern</code></td>
<td>
<p>String pattern identifying mime types to be returned
as raw bytes.</p>
</td></tr>
<tr><td><code id="serveStaticFiles_+3A_verbose">verbose</code></td>
<td>
<p>Boolean to show a verbose static file information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All files to be served in this manner must exist underneath the
host machine directory specified with <code>rootPath</code>. The directory
structure underneath <code>rootPath</code> will be mapped onto URLs underneath
<code>urlPath</code>. This helps when deploying web services at preordained URLs.
</p>
<p>The example below presents files underneath host machine directory
<code>hostDir/</code> to be accessed at URLS under <code>test/</code>.
</p>


<h3>Value</h3>

<p>A <code>Beakr</code> instance with added middleware.
</p>


<h3>Note</h3>

<p>If you run the example in the console, be sure to
<code>stopServer(bekar)</code> when you are done.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(beakr)

# Create a .txt file in temp directory
hostDir &lt;- tempdir()
file &lt;- paste0(hostDir, "/my_file.txt")
cat("I am a text file.", file = file)

# Create an new beakr instance
beakr &lt;- newBeakr()

# beakr pipeline
beakr %&gt;%

  # Respond to GET requests at the "/hi" route
  httpGET(path = "/hi", function(req, res, err) {
    print("Hello, World!")
  }) %&gt;%

  # Respond to GET requests at the "/bye" route
  httpGET(path = "/bye", function(req, res, err) {
    print("Farewell, my friends.")
  }) %&gt;%

 # Host the directory of static files
 serveStaticFiles("/test", hostDir, verbose = TRUE) %&gt;%

 # Start the server on port 25118
 listen(host = "127.0.0.1", port = 25118, daemon = TRUE)

# ------------------------------------------------------------
# POINT YOUR BROWSER AT:
# * http://127.0.0.1:25118/test/my_file.txt
#
# THEN, STOP THE SERVER WITH stopServer(beakr)
# ------------------------------------------------------------

# Stop the beakr instance server
stopServer(beakr)

</code></pre>

<hr>
<h2 id='stopAllServers'>Stop all servers</h2><span id='topic+stopAllServers'></span>

<h3>Description</h3>

<p>Stops all <code>Beakr</code> servers currently running (and any other
servers created with the <span class="pkg">httpuv</span> package). This function is included to
encourage experimentation so that users who create multiple <code>Beakr</code>
instances can quickly find and stop them all.
</p>
<p>See <code>httpuv::<a href="httpuv.html#topic+stopAllServers">stopAllServers</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopAllServers()
</code></pre>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beakr)

beakr1 &lt;- newBeakr()
beakr2 &lt;- newBeakr()
beakr1 %&gt;% listen(daemon = TRUE, port = 1234, verbose = TRUE)
beakr2 %&gt;% listen(daemon = TRUE, port = 4321, verbose = TRUE)
length(listServers())
stopAllServers()
length(listServers())
</code></pre>

<hr>
<h2 id='stopServer'>Stop a beakr instance server</h2><span id='topic+stopServer'></span>

<h3>Description</h3>

<p>Stops the server associated with a <code>Beakr</code> instance,
closing all open connections and unbinding the port.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopServer(beakr = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stopServer_+3A_beakr">beakr</code></td>
<td>
<p><code>Beakr</code> instance.</p>
</td></tr>
<tr><td><code id="stopServer_+3A_verbose">verbose</code></td>
<td>
<p>Logical specifying whether to print out details of the
<code>Beakr</code> instance just stopped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(beakr)

beakr &lt;- newBeakr()

# beakr pipeline
beakr %&gt;%

  handleErrors() %&gt;%

  listen(daemon = TRUE, verbose = TRUE)

stopServer(beakr, verbose = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
