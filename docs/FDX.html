<!DOCTYPE html><html><head><title>Help for package FDX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FDX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amnesia'><p>Amnesia and other drug reactions in the MHRA pharmacovigilance spontaneous reporting system</p></a></li>
<li><a href='#continuous.GR'><p>Continuous Guo-Romano procedure</p></a></li>
<li><a href='#continuous.LR'><p>Continuous Lehmann-Romano procedure</p></a></li>
<li><a href='#discrete.GR'><p>Discrete Guo-Romano procedure</p></a></li>
<li><a href='#discrete.LR'><p>Discrete Lehmann-Romano procedure</p></a></li>
<li><a href='#discrete.PB'><p>Discrete Poisson-Binomial procedure</p></a></li>
<li><a href='#fast.Discrete'><p>Fast application of discrete procedures</p></a></li>
<li><a href='#FDX-package'><p>False Discovery Exceedance (FDX) Control for Heterogeneous and Discrete Tests</p></a></li>
<li><a href='#hist.FDX'><p>Histogram of Raw p-Values</p></a></li>
<li><a href='#kernel'><p>Kernel functions</p></a></li>
<li><a href='#plot.FDX'><p>Plot Method for <code>FDX</code> objects</p></a></li>
<li><a href='#print.FDX'><p>Printing FDX results</p></a></li>
<li><a href='#rejection.path'><p>Rejection Path Plot (for <code>FDX</code> objects)</p></a></li>
<li><a href='#summary.FDX'><p>Summarizing Discrete FDX Results</p></a></li>
<li><a href='#weighted.GR'><p>Weighted Guo-Romano Procedure</p></a></li>
<li><a href='#weighted.LR'><p>Weighted Lehmann-Romano Procedure</p></a></li>
<li><a href='#weighted.PB'><p>Weighted Poisson-Binomial Procedure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>False Discovery Exceedance Controlling Multiple Testing
Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-17</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Junge &lt;florian.junge@h-da.de&gt;</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple testing procedures for heterogeneous and discrete tests as described in Döhler and Roquain (2019) &lt;<a href="https://arxiv.org/abs/1912.04607v1">arXiv:1912.04607v1</a>&gt;. The main algorithms of the paper are available as continuous, discrete and weighted versions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00), DiscreteFDR</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.3), methods, PoissonBinomial (&ge; 1.2.0), pracma</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, PoissonBinomial</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DISOhda/FDX">https://github.com/DISOhda/FDX</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DISOhda/FDX/issues">https://github.com/DISOhda/FDX/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-17 14:27:34 UTC; fjunge</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Döhler [aut],
  Florian Junge [aut, cre],
  Etienne Roquain [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-18 07:25:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='amnesia'>Amnesia and other drug reactions in the MHRA pharmacovigilance spontaneous reporting system</h2><span id='topic+amnesia'></span>

<h3>Description</h3>

<p>For each of 2446 drugs in the MHRA database (column 1), the number of cases
with amnesia as an adverse event (column 2), and the number of cases with
other adverse event for this drug (column 3). In total, 682648 adverse drug
reactions were reported, among them 2044 cases of amnesia.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amnesia)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2446 rows representing drugs with the following 3 columns:
</p>

<dl>
<dt>DrugName</dt><dd><p>The name of the drug.</p>
</dd>
<dt>AmnesiaCases</dt><dd><p>Number of the amnesia cases reported for the drug.</p>
</dd>
<dt>OtherAdverseCases</dt><dd><p>Number of other adverse drug reactions reported for the drug.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was collected from the Drug Analysis Prints published by the
Medicines and Healthcare products Regulatory Agency (MHRA), by Heller &amp; Gur.
See references for more details.
</p>


<h3>References</h3>

<p>R. Heller and H. Gur (2011). False discovery rate controlling procedures for discrete tests. <a href="https://arxiv.org/abs/1112.4627v2">arXiv:1112.4627v2</a>.
</p>


<h3>Source</h3>

<p><a href="https://yellowcard.mhra.gov.uk/idap">Drug Analysis Prints on MHRA site</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.amnesia &lt;- amnesia[, 2:3]
DGR.amnesia &lt;- fast.Discrete.GR(counts = data.amnesia, input = "HG2011")
summary(DGR.amnesia)
</code></pre>

<hr>
<h2 id='continuous.GR'>Continuous Guo-Romano procedure</h2><span id='topic+continuous.GR'></span><span id='topic+GR'></span><span id='topic+NGR'></span>

<h3>Description</h3>

<p>Apply the usual continuous [GR] procedure, with or without computing the
critical values, to a set of p-values. A non-adaptive version is available as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous.GR(
  raw.pvalues,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE
)

GR(raw.pvalues, alpha = 0.05, zeta = 0.5, critical.values = FALSE)

NGR(raw.pvalues, alpha = 0.05, zeta = 0.5, critical.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuous.GR_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GR</code> and <code>NGR</code> are wrapper functions for <code>continuous.GR</code>. The
first one simply passes all its parameters to <code>continuous.GR</code> with
<code>adaptive = TRUE</code> and <code>NGR</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Adaptive</code></td>
<td>
<p>A boolean specifying whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR</a></code>,
<code><a href="#topic+discrete.LR">discrete.LR</a></code>, <code><a href="#topic+discrete.GR">discrete.GR</a></code>, 
<code><a href="#topic+discrete.PB">discrete.PB</a></code>, <code><a href="#topic+weighted.LR">weighted.LR</a></code>, 
<code><a href="#topic+weighted.GR">weighted.GR</a></code>, <code><a href="#topic+weighted.PB">weighted.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

GR.fast &lt;- GR(raw.pvalues)
summary(GR.fast)

GR.crit &lt;- GR(raw.pvalues, critical.values = TRUE)
summary(GR.crit)

NGR.fast &lt;- NGR(raw.pvalues)
summary(NGR.fast)

NGR.crit &lt;- NGR(raw.pvalues, critical.values = TRUE)
summary(NGR.crit)

</code></pre>

<hr>
<h2 id='continuous.LR'>Continuous Lehmann-Romano procedure</h2><span id='topic+continuous.LR'></span><span id='topic+LR'></span><span id='topic+NLR'></span>

<h3>Description</h3>

<p>Apply the usual (continuous) [LR] procedure, with or without computing the
critical values, to a set of p-values. A non-adaptive version is available as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous.LR(
  raw.pvalues,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE
)

LR(raw.pvalues, alpha = 0.05, zeta = 0.5, critical.values = FALSE)

NLR(raw.pvalues, alpha = 0.05, zeta = 0.5, critical.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuous.LR_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>LR</code> and <code>NLR</code> are wrapper functions for <code>continuous.LR</code>. The
first one simply passes all its parameters to <code>continuous.LR</code> with
<code>adaptive = TRUE</code> and <code>NLR</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Adaptive</code></td>
<td>
<p>A boolean specifying whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.GR">continuous.GR</a></code>,
<code><a href="#topic+discrete.LR">discrete.LR</a></code>, <code><a href="#topic+discrete.GR">discrete.GR</a></code>, 
<code><a href="#topic+discrete.PB">discrete.PB</a></code>, <code><a href="#topic+weighted.LR">weighted.LR</a></code>, 
<code><a href="#topic+weighted.GR">weighted.GR</a></code>, <code><a href="#topic+weighted.PB">weighted.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

LR.fast &lt;- LR(raw.pvalues)
summary(LR.fast)

LR.crit &lt;- LR(raw.pvalues, critical.values = TRUE)
summary(LR.crit)

NLR.fast &lt;- NLR(raw.pvalues)
summary(NLR.fast)

NLR.crit &lt;- NLR(raw.pvalues, critical.values = TRUE)
summary(NLR.crit)

</code></pre>

<hr>
<h2 id='discrete.GR'>Discrete Guo-Romano procedure</h2><span id='topic+discrete.GR'></span><span id='topic+DGR'></span><span id='topic+NDGR'></span>

<h3>Description</h3>

<p>Apply the [DGR] procedure, with or without computing the critical values, to
a set of p-values and their discrete support. A non-adaptive version is
available as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.GR(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE
)

DGR(raw.pvalues, pCDFlist, alpha = 0.05, zeta = 0.5, critical.values = FALSE)

NDGR(raw.pvalues, pCDFlist, alpha = 0.05, zeta = 0.5, critical.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete.GR_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DGR</code> and <code>NDGR</code> are wrapper functions for <code>discrete.GR</code>.
The first one simply passes all its parameters to <code>discrete.GR</code> with
<code>adaptive = TRUE</code> and <code>NDGR</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Adaptive</code></td>
<td>
<p>A boolean specifying whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>The values of <code>pCDFlist</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>S. Döhler and E. Roquain (2019). Controlling False Discovery Exceedance for
Heterogeneous Tests.
<a href="https://arxiv.org/abs/1912.04607v1">arXiv:1912.04607v1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR</a></code>, <code><a href="#topic+discrete.LR">discrete.LR</a></code>, 
<code><a href="#topic+discrete.PB">discrete.PB</a></code>, <code><a href="#topic+weighted.LR">weighted.LR</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR</a></code>, <code><a href="#topic+weighted.PB">weighted.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DGR.fast &lt;- DGR(raw.pvalues, pCDFlist)
summary(DGR.fast)

DGR.crit &lt;- DGR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DGR.crit)

NDGR.fast &lt;- NDGR(raw.pvalues, pCDFlist)
summary(NDGR.fast)

NDGR.crit &lt;- NDGR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(NDGR.crit)

</code></pre>

<hr>
<h2 id='discrete.LR'>Discrete Lehmann-Romano procedure</h2><span id='topic+discrete.LR'></span><span id='topic+DLR'></span><span id='topic+NDLR'></span>

<h3>Description</h3>

<p>Apply the [DLR] procedure, with or without computing the critical values, to
a set of p-values and their discrete support. Both step-down and step-up
procedures can be computed and non-adaptive versions are available as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.LR(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  adaptive = TRUE,
  critical.values = FALSE
)

DLR(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  critical.values = FALSE
)

NDLR(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  critical.values = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete.LR_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_direction">direction</code></td>
<td>
<p>a character string specifying whether to conduct a step-up (<code>direction="su"</code>, the default) or step-down procedure (<code>direction="sd"</code>).</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DLR</code> and <code>NDLR</code> are wrapper functions for <code>discrete.LR</code>.
The first one simply passes all its parameters to <code>discrete.LR</code> with
<code>adaptive = TRUE</code> and <code>NDLR</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>The values of <code>pCDFlist</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>S. Döhler and E. Roquain (2019). Controlling False Discovery Exceedance for
Heterogeneous Tests.
<a href="https://arxiv.org/abs/1912.04607v1">arXiv:1912.04607v1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR</a></code>, <code><a href="#topic+discrete.GR">discrete.GR</a></code>, 
<code><a href="#topic+discrete.PB">discrete.PB</a></code>, <code><a href="#topic+weighted.LR">weighted.LR</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR</a></code>, <code><a href="#topic+weighted.PB">weighted.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DLR.sd.fast &lt;- DLR(raw.pvalues, pCDFlist)
summary(DLR.sd.fast)
DLR.su.fast &lt;- DLR(raw.pvalues, pCDFlist, direction = "su")
summary(DLR.su.fast)

DLR.sd.crit &lt;- DLR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DLR.sd.crit)
DLR.su.crit &lt;- DLR(raw.pvalues, pCDFlist, direction = "su", critical.values = TRUE)
summary(DLR.su.crit)

NDLR.sd.fast &lt;- NDLR(raw.pvalues, pCDFlist)
summary(NDLR.sd.fast)
NDLR.su.fast &lt;- NDLR(raw.pvalues, pCDFlist, direction = "su")
summary(NDLR.su.fast)

NDLR.sd.crit &lt;- NDLR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(NDLR.sd.crit)
NDLR.su.crit &lt;- NDLR(raw.pvalues, pCDFlist, direction = "su", critical.values = TRUE)
summary(NDLR.su.crit)

</code></pre>

<hr>
<h2 id='discrete.PB'>Discrete Poisson-Binomial procedure</h2><span id='topic+discrete.PB'></span><span id='topic+DPB'></span><span id='topic+NDPB'></span>

<h3>Description</h3>

<p>Apply the [DPB] procedure, with or without computing the critical values, to
a set of p-values and their discrete support. A non-adaptive version is
available as well. Additionally, the user can choose between exact
computation of the Poisson-Binomial distribution or a refined normal
approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.PB(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE,
  exact = TRUE
)

DPB(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE
)

NDPB(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete.PB_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="discrete.PB_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="discrete.PB_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="discrete.PB_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="discrete.PB_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.PB_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
<tr><td><code id="discrete.PB_+3A_exact">exact</code></td>
<td>
<p>a boolean specifying whether to compute the Poisson-Binomial distribution exactly or by a normal approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DPB</code> and <code>NDPB</code> are wrapper functions for <code>discrete.PB</code>.
The first one simply passes all its parameters to <code>discrete.PB</code> with
<code>adaptive = TRUE</code> and <code>NDPB</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>The values of <code>pCDFlist</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>S. Döhler and E. Roquain (2019). Controlling False Discovery Exceedance for
Heterogeneous Tests.
<a href="https://arxiv.org/abs/1912.04607v1">arXiv:1912.04607v1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR</a></code>, <code><a href="#topic+discrete.LR">discrete.LR</a></code>, 
<code><a href="#topic+discrete.GR">discrete.GR</a></code>, <code><a href="#topic+weighted.LR">weighted.LR</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR</a></code>, <code><a href="#topic+weighted.PB">weighted.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DPB.fast &lt;- DPB(raw.pvalues, pCDFlist)
summary(DPB.fast)

DPB.crit &lt;- DPB(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DPB.crit)

NDPB.fast &lt;- NDPB(raw.pvalues, pCDFlist)
summary(NDPB.fast)

NDPB.crit &lt;- NDPB(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(NDPB.crit)

</code></pre>

<hr>
<h2 id='fast.Discrete'>Fast application of discrete procedures</h2><span id='topic+fast.Discrete'></span><span id='topic+fast.Discrete.LR'></span><span id='topic+fast.Discrete.PB'></span><span id='topic+fast.Discrete.GR'></span>

<h3>Description</h3>

<p>Applies the [DLR], [DGR] or [DPB] procedures, without computing the critical
values, to a data set of 2 x 2 contingency tables using Fisher's exact test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.Discrete.LR(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  adaptive = TRUE
)

fast.Discrete.PB(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  exact = FALSE
)

fast.Discrete.GR(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.Discrete_+3A_counts">counts</code></td>
<td>
<p>a data frame of 2 or 4 columns and any number of lines,
each line representing a 2 x 2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument, see
Details of <code>fisher.pvalues.support</code>.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <code><a href="stats.html#topic+fisher.test">fisher.test</a></code>. The three
possible values are <code>"greater"</code> (default),
<code>"two.sided"</code> or <code>"less"</code>; may be abbreviated.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_input">input</code></td>
<td>
<p>the format of the input data frame, see Details of
<code><a href="DiscreteFDR.html#topic+fisher.pvalues.support">fisher.pvalues.support</a></code>. The
three possible values are <code>"noassoc"</code> (default),
<code>"marginal"</code> or <code>"HG2011"</code>; may be 
abbreviated.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_direction">direction</code></td>
<td>
<p>a character string specifying whether to conduct a step-up (<code>direction="su"</code>, the default) or step-down procedure (<code>direction="sd"</code>).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_exact">exact</code></td>
<td>
<p>a boolean specifying whether to compute the Poisson-Binomial distribution exactly or by a normal approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Adaptive</code></td>
<td>
<p>A boolean specifying whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

DLR.sd &lt;- fast.Discrete.LR(counts = df, input = "noassoc")
DLR.sd$Adjusted
summary(DLR.sd)
DLR.su &lt;- fast.Discrete.LR(counts = df, input = "noassoc", direction = "su")
summary(DLR.su)

NDLR.sd &lt;- fast.Discrete.LR(counts = df, input = "noassoc", adaptive = FALSE)
NDLR.sd$Adjusted
summary(NDLR.sd)
NDLR.su &lt;- fast.Discrete.LR(counts = df, input = "noassoc", direction = "su", adaptive = FALSE)
summary(NDLR.su)

DGR &lt;- fast.Discrete.GR(counts = df, input = "noassoc")
DGR$Adjusted
summary(DGR)

NDGR &lt;- fast.Discrete.GR(counts = df, input = "noassoc", adaptive = FALSE)
NDGR$Adjusted
summary(NDGR)

DPB &lt;- fast.Discrete.PB(counts = df, input = "noassoc")
DPB$Adjusted
summary(DPB)

NDPB &lt;- fast.Discrete.PB(counts = df, input = "noassoc", adaptive = FALSE)
NDPB$Adjusted
summary(NDPB)

</code></pre>

<hr>
<h2 id='FDX-package'>False Discovery Exceedance (FDX) Control for Heterogeneous and Discrete Tests</h2><span id='topic+FDX-package'></span>

<h3>Description</h3>

<p>This package implements the [HLR], [HGR] and [HPB] procedures for both
heterogeneous and discrete tests (see Reference).
</p>


<h3>Details</h3>

<p>The functions are reorganized from the reference paper in the following way.
<code>discrete.LR</code> (for Discrete Lehmann-Romano) implements [DLR],
<code>discrete.GR</code> (for Discrete Guo-Romano) implements [DGR] and
<code>discrete.PB</code> (for Discrete Poisson-Binomial) implements [DPB].
<code>DLR</code> and <code>NDLR</code> are wrappers for <code>discrete.LR</code> to access
[DLR] and its non-adaptive version directly. Likewise, <code>DGR</code>,
<code>NDGR</code>, <code>DPB</code> and <code>NDPB</code> are wrappers for
<code>discrete.GR</code> and <code>discrete.PB</code>, respectively. Their main
parameters are a vector of raw observed p-values and a list of the same
length, whose elements are the discrete supports of the CDFs of the p-values.
</p>
<p>In the same fashion, <code>weighted.LR</code> (for Weighted Lehmann-Romano),
<code>weighted.GR</code> (for Weighted Guo-Romano) and <code>weighted.PB</code>
(for Weighted Poisson-Binomial) implement [wLR], [wGR] and [wGR],
respectively. They also possess wrapper functions, namely <code>wLR.AM</code>,
<code>wGR.AM</code> and <code>wPB.AM</code> for arithmetic weighting, and <code>wLR.GM</code>,
<code>wPB.GM</code> and <code>wPB.GM</code> for geometric weighting.
</p>
<p>The functions <code>fast.Discrete.LR</code>, <code>fast.Discrete.GR</code>
and <code>fast.Discrete.PB</code> are wrappers for
<code><a href="DiscreteFDR.html#topic+fisher.pvalues.support">fisher.pvalues.support</a></code> and <code>discrete.LR</code>,
<code>discrete.GR</code> and <code>discrete.PB</code>, respectively, which allow to apply
discrete procedures directly to a data set of contingency tables.
</p>


<h3>References</h3>

<p>S. Döhler and E. Roquain (2019). Controlling False Discovery Exceedance for
Heterogeneous Tests.
<a href="https://arxiv.org/abs/1912.04607v1">arXiv:1912.04607v1</a>.
</p>

<hr>
<h2 id='hist.FDX'>Histogram of Raw p-Values</h2><span id='topic+hist.FDX'></span>

<h3>Description</h3>

<p>Computes a histogram of the raw p-values of a <code>FDX</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
hist(x, breaks = "FD", main = NULL, xlab = NULL, ylab = NULL, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.FDX_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_breaks">breaks</code></td>
<td>
<p>as in <code><a href="graphics.html#topic+hist">hist</a></code>; here, the Friedman-Diaconis
algorithm(<code>"FD"</code>) is used as default.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_main">main</code></td>
<td>
<p>main title. If <code>NULL</code> (default), a description string
is used.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_xlab">xlab</code>, <code id="hist.FDX_+3A_ylab">ylab</code></td>
<td>
<p>labels for x and y axis.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_plot">plot</code></td>
<td>
<p>a boolean If <code>TRUE</code> (the default), a histogram is
plotted, otherwise a list of breaks and counts is returned.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+hist">hist</a></code> or
<code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> contains results of a weighted approach, a histogram of the
weighted p-values is constructed. Otherwise, it is constituted by the
raw ones.
</p>


<h3>Value</h3>

<p>An object of class <code>histogram</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DGR &lt;- DGR(raw.pvalues, pCDFlist)
hist(DGR)

</code></pre>

<hr>
<h2 id='kernel'>Kernel functions</h2><span id='topic+kernel'></span><span id='topic+kernel_DLR_fast'></span><span id='topic+kernel_DLR_crit'></span><span id='topic+kernel_DGR_fast'></span><span id='topic+kernel_DGR_crit'></span><span id='topic+kernel_DPB_fast'></span><span id='topic+kernel_DPB_crit'></span><span id='topic+kernel_wLR_fast'></span><span id='topic+kernel_wGR_fast'></span><span id='topic+kernel_wPB_fast'></span>

<h3>Description</h3>

<p>Kernel functions transform observed p-values or their support according to
[HLR], [PB] and [HGR]. The output is used by <code><a href="#topic+discrete.LR">discrete.LR</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB</a></code> and <code><a href="#topic+discrete.GR">discrete.GR</a></code>, respectively.
For each procedure, there is a kernel for fast computation and one for
calculation of critical values. Kernels followed by &quot;.crit&quot;, e.g.
<code>kernel.DGR.crit</code>, compute and return these critical values, while
kernels ending in &quot;.fast&quot; only transform p-values and are therefore faster.
The end user should not use these functions directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_DLR_fast(
  pCDFlist,
  pvalues,
  adaptive = TRUE,
  alpha = 0.05,
  stepUp = FALSE,
  zeta = 0.5,
  support = 0L
)

kernel_DLR_crit(
  pCDFlist,
  pvalues,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  zeta = 0.5,
  stepUp = FALSE
)

kernel_DGR_fast(pCDFlist, pvalues, adaptive = TRUE, alpha = 0.05)

kernel_DGR_crit(
  pCDFlist,
  pvalues,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  zeta = 0.5
)

kernel_DPB_fast(pCDFlist, pvalues, adaptive = TRUE, alpha = 0.05, exact = TRUE)

kernel_DPB_crit(
  pCDFlist,
  pvalues,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  zeta = 0.5,
  exact = TRUE
)

kernel_wLR_fast(qvalues, weights, alpha = 0.05, geom_weighting = FALSE)

kernel_wGR_fast(qvalues, weights, alpha = 0.05, geom_weighting = FALSE)

kernel_wPB_fast(
  qvalues,
  weights,
  alpha = 0.05,
  geom_weighting = FALSE,
  exact = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_pvalues">pvalues</code></td>
<td>
<p>a numeric vector. Contains all values of the p-values supports if we search for the critical constants. If not, contains only the observed p-values. Must be sorted in increasing order!</p>
</td></tr>
<tr><td><code id="kernel_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="kernel_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_stepup">stepUp</code></td>
<td>
<p>a numeric vector. Identical to <code>pvalues</code> for a step-down procedure. Equals <code>c.m</code> for a step-up procedure.</p>
</td></tr>
<tr><td><code id="kernel_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_support">support</code></td>
<td>
<p>a numeric vector. Contains all values of the p-values supports. Ignored, if <code>stepUp = FALSE</code>. Must be sorted in increasing order!</p>
</td></tr>
<tr><td><code id="kernel_+3A_sorted_pv">sorted_pv</code></td>
<td>
<p>a vector of observed p-values, in increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_exact">exact</code></td>
<td>
<p>a boolean specifying whether to compute the Poisson-Binomial distribution exactly or by a normal approximation.</p>
</td></tr>
<tr><td><code id="kernel_+3A_qvalues">qvalues</code></td>
<td>
<p>a numeric vector. Contains weighted raw p-values.</p>
</td></tr>
<tr><td><code id="kernel_+3A_weights">weights</code></td>
<td>
<p>a numeric vector. Contains the weights of the p-values.</p>
</td></tr>
<tr><td><code id="kernel_+3A_geom_weighting">geom_weighting</code></td>
<td>
<p>a boolean specifying whether to conduct geometric
(<code>TRUE</code>) or arithmetic (<code>FALSE</code>)
weighting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For &quot;.fast&quot; kernels, a vector of transformed p-values is returned; &quot;.crit&quot;
kernels return a list object with critical constants (<code>$crit.consts</code>)
and transformed p-values (<code>$pval.transf</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+discrete.LR">discrete.LR</a></code>
<code><a href="#topic+discrete.GR">discrete.GR</a></code>, <code><a href="#topic+discrete.PB">discrete.PB</a></code>,
<code><a href="#topic+weighted.LR">weighted.LR</a></code>, <code><a href="#topic+weighted.GR">weighted.GR</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

alpha &lt;- 0.05

# If not searching for critical constants, we use only the observed p-values
sorted.pvals &lt;- sort(raw.pvalues)
y.DLR.fast &lt;- kernel_DLR_fast(pCDFlist, sorted.pvals, TRUE)
y.NDGR.fast &lt;- kernel_DGR_fast(pCDFlist, sorted.pvals, FALSE)$pval.transf
# transformed values
y.DLR.fast
y.NDGR.fast

# compute support
pv.list &lt;- sort(unique(unlist(pCDFlist)))
y.DGR.crit &lt;- kernel_DGR_crit(pCDFlist, pv.list, sorted.pvals, TRUE)
y.NDPB.crit &lt;- kernel_DPB_crit(pCDFlist, pv.list, sorted.pvals, FALSE)
# critical constants
y.DGR.crit$crit.consts
y.NDPB.crit$crit.consts
# transformed values
y.DGR.crit$pval.transf
y.NDPB.crit$pval.transf

</code></pre>

<hr>
<h2 id='plot.FDX'>Plot Method for <code>FDX</code> objects</h2><span id='topic+plot.FDX'></span>

<h3>Description</h3>

<p>Plots raw p-values of a <code>FDX</code> object and highlights rejected and
accepted p-values. If present, the critical values are plotted, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
plot(
  x,
  col = c(2, 4, 1),
  pch = c(1, 1, 1),
  lwd = c(1, 1, 1),
  type.crit = "b",
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.FDX_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_col">col</code></td>
<td>
<p>a numeric or character vector of length 3 indicating the
colors of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.FDX_+3A_pch">pch</code></td>
<td>
<p>a numeric or character vector of length 3 indicating the
point characters of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present and <code>type.crit</code>
is a plot type like <code>'p'</code>, <code>'b'</code> etc.).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.FDX_+3A_lwd">lwd</code></td>
<td>
<p>a numeric vector of length 3 indicating the thickness of
the points and lines.</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_type.crit">type.crit</code></td>
<td>
<p>1-character string giving the type of plot desired for the
critical values (e.g.: <code>'p'</code>, <code>'l'</code> etc; see
<code><a href="graphics.html#topic+plot">plot</a></code>).</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_legend">legend</code></td>
<td>
<p>if NULL, no legend is plotted; otherwise expecting a
character string like &quot;topleft&quot; etc. or a numeric vector
of two elements indicating (x, y) coordinates.</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> contains results of a weighted approach, the Y-axis of the plot
is derived from the weighted p-values. Otherwise, it is constituted by the
raw ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DLR.sd.fast &lt;- DLR(raw.pvalues, pCDFlist)
DLR.sd.crit &lt;- DLR(raw.pvalues, pCDFlist, critical.values = TRUE)
DLR.su.fast &lt;- DLR(raw.pvalues, pCDFlist, direction = "su")
DLR.su.crit &lt;- DLR(raw.pvalues, pCDFlist, direction = "su", critical.values = TRUE)

plot(DLR.su.fast)
plot(DLR.su.crit, xlim = c(1, 5), ylim = c(0, 0.4))
plot(DLR.sd.fast, col = c(2, 4), pch = c(2, 3), lwd = c(2, 2), 
    legend = "topleft", xlim = c(1, 5), ylim = c(0, 0.4))
plot(DLR.sd.crit, col = c(2, 4, 1), pch = c(1, 1, 4), lwd = c(1, 1, 2), 
    type.crit = 'o', legend = c(1, 0.4), lty = 1, xlim = c(1, 5), 
    ylim = c(0, 0.4))

</code></pre>

<hr>
<h2 id='print.FDX'>Printing FDX results</h2><span id='topic+print.FDX'></span>

<h3>Description</h3>

<p>Prints the results of discrete FDX analysis, stored in a <code>FDX</code>
S3 class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.FDX_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="print.FDX_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
They are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The respective input object is invisibly returned via <code>invisible(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DPB.crit &lt;- DPB(raw.pvalues, pCDFlist, critical.values = TRUE)
print(DPB.crit)

</code></pre>

<hr>
<h2 id='rejection.path'>Rejection Path Plot (for <code>FDX</code> objects)</h2><span id='topic+rejection.path'></span>

<h3>Description</h3>

<p>Displays the number of rejections of the raw p-values in a <code>FDX</code>
object in dependence of the exceedance probability <code>zeta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rejection.path(
  x,
  xlim = NULL,
  ylim = NULL,
  main = NULL,
  xlab = expression(zeta),
  ylab = "Number of Rejections",
  verticals = FALSE,
  pch = 19,
  ref.show = FALSE,
  ref.col = "gray",
  ref.lty = 2,
  ref.lwd = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rejection.path_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot. If <code>NULL</code> (default),
the (0, 1) range is used.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. If <code>NULL</code> (default),
the double of the median of the number of possible
rejections is used as upper limit.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_main">main</code></td>
<td>
<p>main title. If <code>NULL</code> (default), a description
string is used.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_xlab">xlab</code>, <code id="rejection.path_+3A_ylab">ylab</code></td>
<td>
<p>labels for x and y axis.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_verticals">verticals</code></td>
<td>
<p>logical; if <code>TRUE</code>, draw vertical lines at
steps.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_pch">pch</code></td>
<td>
<p>jump point character.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ref.show">ref.show</code></td>
<td>
<p>logical; if <code>TRUE</code> a vertical reference line
is plotted, whose height is the number of
rejections of the original Benjamini-Hochberg (BH)
procedure.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ref.col">ref.col</code></td>
<td>
<p>color of the reference line.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ref.lty">ref.lty</code>, <code id="rejection.path_+3A_ref.lwd">ref.lwd</code></td>
<td>
<p>line type and thickness for the reference line.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="stats.html#topic+plot.stepfun">plot.stepfun</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a <code>stepfun</code> object that computes the number of
rejectionsin dependence on the exceedance probability <code>zeta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DLR &lt;- DLR(raw.pvalues, pCDFlist)
NDLR &lt;- NDLR(raw.pvalues, pCDFlist)

rejection.path(DLR, xlim = c(0, 1), ref.show = TRUE, ref.col = "green", ref.lty = 4)
rejection.path(NDLR, col = "red", add = TRUE)

</code></pre>

<hr>
<h2 id='summary.FDX'>Summarizing Discrete FDX Results</h2><span id='topic+summary.FDX'></span><span id='topic+print.summary.FDX'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;<code>FDX</code>&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
summary(object, ...)

## S3 method for class 'summary.FDX'
print(x, max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.FDX_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="summary.FDX_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.FDX_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>summary.FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="summary.FDX_+3A_max">max</code></td>
<td>
<p>numeric or <code>NULL</code>, specifying the maximal number of
<em>rows</em> of the p-value table to be printed. By
default, when <code>NULL</code>, <code>getOption("max.print")</code>
is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.FDX</code> objects include all data of an <code>FDX</code>
object, but also include an additional table which includes the raw p-values,
their indices, the respective critical values (if present), the adjusted
p-values (if present) and a logical column to indicate rejection. The table
is sorted in ascending order by the raw p-values.
</p>
<p><code>print.summary.FDX</code> simply prints the same output as
<code>print.FDX</code>, but also prints the p-value table.
</p>


<h3>Value</h3>

<p><code>summary.FDX</code> computes and returns a list that includes all the
data of an input <code>FDX</code>, plus
</p>
<table>
<tr><td><code>Table</code></td>
<td>
<p>a <code>data.frame</code>, sorted by the raw p-values, that contains
the indices, that raw p-values themselves, their respective
critical values (if present), their adjusted p-values (if
present) and a logical column to indicate rejection.</p>
</td></tr>
</table>
<p><code>print.summary.FDX</code> returns that object invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports (fisher.pvalues.support
# is from 'DiscreteFDR' package!)
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DGR.crit &lt;- DGR(raw.pvalues, pCDFlist, critical.values = TRUE)
DGR.crit.summary &lt;- summary(DGR.crit)
print(DGR.crit.summary)

</code></pre>

<hr>
<h2 id='weighted.GR'>Weighted Guo-Romano Procedure</h2><span id='topic+weighted.GR'></span><span id='topic+wGR.AM'></span><span id='topic+wGR.GM'></span>

<h3>Description</h3>

<p>Apply the weighted [wGR] procedure, with or without computing the
critical values, to a set of p-values. Both arithmetic and geometric
weighting are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.GR(
  raw.pvalues,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  weighting.method = "AM",
  critical.values = FALSE
)

wGR.AM(raw.pvalues, weights, alpha = 0.05, zeta = 0.5, critical.values = FALSE)

wGR.GM(raw.pvalues, weights, alpha = 0.05, zeta = 0.5, critical.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.GR_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_weights">weights</code></td>
<td>
<p>a numeric vector. Contains the weights of the p-values.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_weighting.method">weighting.method</code></td>
<td>
<p>a character string specifying whether to conduct arithmetic (<code>direction="AM"</code>, the default) or geometric weighting (<code>direction="GM"</code>) of p-values.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wGR.AM</code> and <code>wGR.GM</code> are wrapper functions for <code>weighted.GR</code>.
The first one simply passes all its parameters to <code>weighted.GR</code> with
<code>weighting.method = "AM"</code> and <code>wGR.GM</code> does the same with
<code>weighting.method = "GM"</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Weighted</code></td>
<td>
<p>Weighted p-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Weighting</code></td>
<td>
<p>A character string describing the weighting method.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$weights</code></td>
<td>
<p>The values of <code>weights</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>S. Döhler and E. Roquain (2019). Controlling False Discovery Exceedance for
Heterogeneous Tests.
<a href="https://arxiv.org/abs/1912.04607v1">arXiv:1912.04607v1</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR</a></code>, <code><a href="#topic+discrete.LR">discrete.LR</a></code>, 
<code><a href="#topic+discrete.GR">discrete.GR</a></code>, <code><a href="#topic+discrete.PB">discrete.PB</a></code>, 
<code><a href="#topic+weighted.LR">weighted.LR</a></code>, <code><a href="#topic+weighted.PB">weighted.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construction of the p-values and their supports for weighted methods
raw.pvalues.weighted &lt;- c(0.7389727, 0.1882310, 0.1302457, 0.9513677,
                         0.7592122, 0.0100559, 0.0000027, 0.1651034)
weights &lt;- c(0.7947122, 1.2633867, 2.8097858, 2.2112801,
            2.3878654, 1.2389620, 2.3878654, 0.7947122)

wGR.AM.fast &lt;- wGR.AM(raw.pvalues.weighted, weights)
summary(wGR.AM.fast)

wGR.AM.crit &lt;- wGR.AM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wGR.AM.crit)

wGR.GM.fast &lt;- wGR.GM(raw.pvalues.weighted, weights)
summary(wGR.GM.fast)

wGR.GM.crit &lt;- wGR.GM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wGR.GM.crit)

</code></pre>

<hr>
<h2 id='weighted.LR'>Weighted Lehmann-Romano Procedure</h2><span id='topic+weighted.LR'></span><span id='topic+wLR.AM'></span><span id='topic+wLR.GM'></span>

<h3>Description</h3>

<p>Apply the weighted [wLR] procedure, with or without computing the
critical values, to a set of p-values. Both arithmetic and geometric
weighting are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.LR(
  raw.pvalues,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  weighting.method = "AM",
  critical.values = FALSE
)

wLR.AM(raw.pvalues, weights, alpha = 0.05, zeta = 0.5, critical.values = FALSE)

wLR.GM(raw.pvalues, weights, alpha = 0.05, zeta = 0.5, critical.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.LR_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_weights">weights</code></td>
<td>
<p>a numeric vector. Contains the weights of the p-values.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_weighting.method">weighting.method</code></td>
<td>
<p>a character string specifying whether to conduct arithmetic (<code>direction="AM"</code>, the default) or geometric weighting (<code>direction="GM"</code>) of p-values.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wLR.AM</code> and <code>wLR.GM</code> are wrapper functions for <code>weighted.LR</code>.
The first one simply passes all its parameters to <code>weighted.LR</code> with
<code>weighting.method = "AM"</code> and <code>wLR.GM</code> does the same with
<code>weighting.method = "GM"</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Weighted</code></td>
<td>
<p>Weighted p-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Weighting</code></td>
<td>
<p>A character string describing the weighting method.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$weights</code></td>
<td>
<p>The values of <code>weights</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR</a></code>, <code><a href="#topic+discrete.LR">discrete.LR</a></code>, 
<code><a href="#topic+discrete.GR">discrete.GR</a></code>, <code><a href="#topic+discrete.PB">discrete.PB</a></code>, 
<code><a href="#topic+weighted.GR">weighted.GR</a></code>, <code><a href="#topic+weighted.PB">weighted.PB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construction of the p-values and their supports for weighted methods
raw.pvalues.weighted &lt;- c(0.7389727, 0.1882310, 0.1302457, 0.9513677,
                         0.7592122, 0.0100559, 0.0000027, 0.1651034)
weights &lt;- c(0.7947122, 1.2633867, 2.8097858, 2.2112801,
            2.3878654, 1.2389620, 2.3878654, 0.7947122)

wLR.AM.fast &lt;- wLR.AM(raw.pvalues.weighted, weights)
summary(wLR.AM.fast)

wLR.AM.crit &lt;- wLR.AM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wLR.AM.crit)

wLR.GM.fast &lt;- wLR.GM(raw.pvalues.weighted, weights)
summary(wLR.GM.fast)

wLR.GM.crit &lt;- wLR.GM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wLR.GM.crit)

</code></pre>

<hr>
<h2 id='weighted.PB'>Weighted Poisson-Binomial Procedure</h2><span id='topic+weighted.PB'></span><span id='topic+wPB.AM'></span><span id='topic+wPB.GM'></span>

<h3>Description</h3>

<p>Apply the weighted [wPB] procedure, with or without computing the
critical values, to a set of p-values. Both arithmetic and geometric
weighting are available. Additionally, the user can choose between exact
computation of the Poisson-Binomial distribution or a refined normal
approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.PB(
  raw.pvalues,
  weights,
  alpha = 0.05,
  zeta = 0.05,
  weighting.method = "AM",
  critical.values = FALSE,
  exact = TRUE
)

wPB.AM(raw.pvalues, weights, alpha = 0.05, zeta = 0.5, critical.values = FALSE)

wPB.GM(raw.pvalues, weights, alpha = 0.05, zeta = 0.5, critical.values = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.PB_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_weights">weights</code></td>
<td>
<p>a numeric vector. Contains the weights of the p-values.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_alpha">alpha</code></td>
<td>
<p>the target FDP, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_zeta">zeta</code></td>
<td>
<p>the target probability of not exceeding the desired FDP, a number strictly between 0 and 1. If <code>zeta=NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_weighting.method">weighting.method</code></td>
<td>
<p>a character string specifying whether to conduct arithmetic (<code>direction="AM"</code>, the default) or geometric weighting (<code>direction="GM"</code>) of p-values.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_critical.values">critical.values</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_exact">exact</code></td>
<td>
<p>a boolean specifying whether to compute the Poisson-Binomial distribution exactly or by a normal approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wPB.AM</code> and <code>wPB.GM</code> are wrapper functions for <code>weighted.PB</code>.
The first one simply passes all its parameters to <code>weighted.PB</code> with
<code>weighting.method = "AM"</code> and <code>wPB.GM</code> does the same with
<code>weighting.method = "GM"</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Weighted</code></td>
<td>
<p>Weighted p-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>Critical values (if requested).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>A character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Exceedance.probability</code></td>
<td>
<p>Probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence <code>1 - zeta</code>.</p>
</td></tr>
<tr><td><code>Weighting</code></td>
<td>
<p>A character string describing the weighting method.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code>.</p>
</td></tr>
<tr><td><code>Data$weights</code></td>
<td>
<p>The values of <code>weights</code>.</p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR</a></code>, <code><a href="#topic+discrete.LR">discrete.LR</a></code>, 
<code><a href="#topic+discrete.GR">discrete.GR</a></code>, <code><a href="#topic+discrete.PB">discrete.PB</a></code>, 
<code><a href="#topic+weighted.LR">weighted.LR</a></code>, <code><a href="#topic+weighted.GR">weighted.GR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construction of the p-values and their supports for weighted methods
raw.pvalues.weighted &lt;- c(0.7389727, 0.1882310, 0.1302457, 0.9513677,
                         0.7592122, 0.0100559, 0.0000027, 0.1651034)
weights &lt;- c(0.7947122, 1.2633867, 2.8097858, 2.2112801,
            2.3878654, 1.2389620, 2.3878654, 0.7947122)

wPB.AM.fast &lt;- wPB.AM(raw.pvalues.weighted, weights)
summary(wPB.AM.fast)

wPB.AM.crit &lt;- wPB.AM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wPB.AM.crit)

wPB.GM.fast &lt;- wPB.GM(raw.pvalues.weighted, weights)
summary(wPB.GM.fast)

wPB.GM.crit &lt;- wPB.GM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wPB.GM.crit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
