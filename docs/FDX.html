<!DOCTYPE html><html lang="en-US"><head><title>Help for package FDX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FDX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FDX-package'><p>False Discovery Exceedance (FDX) Control for Heterogeneous and Discrete Tests</p></a></li>
<li><a href='#continuous.GR'><p>Continuous Guo-Romano procedure</p></a></li>
<li><a href='#continuous.LR'><p>Continuous Lehmann-Romano procedure</p></a></li>
<li><a href='#DGR'><p>Wrapper Functions for the Discrete Guo-Romano Procedure</p></a></li>
<li><a href='#direct.discrete'><p>Direct Application of Multiple Testing Procedures to Dataset</p></a></li>
<li><a href='#discrete.GR'><p>Discrete Guo-Romano procedure</p></a></li>
<li><a href='#discrete.LR'><p>Discrete Lehmann-Romano procedure</p></a></li>
<li><a href='#DLR'><p>Wrapper Functions for the Discrete Guo-Romano Procedure</p></a></li>
<li><a href='#DPB'><p>Wrapper Functions for the Discrete Guo-Romano Procedure</p></a></li>
<li><a href='#DPB.DiscreteTestResults'><p>Discrete Poisson-Binomial procedure</p></a></li>
<li><a href='#fast.Discrete'><p>Fast application of discrete procedures</p></a></li>
<li><a href='#hist.FDX'><p>Histogram of Raw P-Values</p></a></li>
<li><a href='#kernel'><p>Kernel functions</p></a></li>
<li><a href='#match.pvals'><p>Matching Raw P-Values with Supports</p></a></li>
<li><a href='#NDGR'><p>Wrapper Functions for the Non-Adaptive Discrete Guo-Romano Procedure</p></a></li>
<li><a href='#NDLR'><p>Wrapper Functions for the Non-Adaptive Discrete Guo-Romano Procedure</p></a></li>
<li><a href='#NDPB'><p>Wrapper Functions for the Non-Adaptive Discrete Guo-Romano Procedure</p></a></li>
<li><a href='#plot.FDX'><p>Plot Method for <code>FDX</code> objects</p></a></li>
<li><a href='#print.FDX'><p>Printing FDX results</p></a></li>
<li><a href='#rejection.path'><p>Rejection Path Plot (for <code>FDX</code> objects)</p></a></li>
<li><a href='#summary.FDX'><p>Summarizing Discrete FDX Results</p></a></li>
<li><a href='#weighted.GR'><p>Weighted Guo-Romano Procedure</p></a></li>
<li><a href='#weighted.LR'><p>Weighted Lehmann-Romano Procedure</p></a></li>
<li><a href='#weighted.PB'><p>Weighted Poisson-Binomial Procedure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>False Discovery Exceedance Controlling Multiple Testing
Procedures</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple testing procedures for heterogeneous and discrete tests as
    described in Döhler and Roquain (2020) &lt;<a href="https://doi.org/10.1214%2F20-EJS1771">doi:10.1214/20-EJS1771</a>&gt;. The main 
    algorithms of the paper are available as continuous, discrete and weighted
    versions. They take as input the results of a test procedure from package
    'DiscreteTests', or a set of observed p-values and their discrete support
    under their nulls. A shortcut function to obtain such p-values and supports
    is also provided, along with wrappers allowing to apply discrete procedures
    directly to data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.12), PoissonBinomial (&ge; 1.2.0), pracma,
DiscreteFDR (&ge; 2.0.0), checkmate, lifecycle, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DiscreteTests (&ge; 0.2.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, PoissonBinomial</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DISOhda/FDX">https://github.com/DISOhda/FDX</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DISOhda/FDX/issues">https://github.com/DISOhda/FDX/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-11 20:38:52 UTC; fjunge</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Döhler <a href="https://orcid.org/0000-0002-0321-6355"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Florian Junge <a href="https://orcid.org/0009-0001-6856-6938"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Etienne Roquain [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Junge &lt;diso.fbmn@h-da.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-11 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='FDX-package'>False Discovery Exceedance (FDX) Control for Heterogeneous and Discrete Tests</h2><span id='topic+FDX'></span><span id='topic+FDX-package'></span>

<h3>Description</h3>

<p>This package implements the [HLR], [HGR] and [HPB] procedures for both
heterogeneous and discrete tests (see Reference).
</p>


<h3>Details</h3>

<p>The functions are reorganized from the reference paper in the following way.
<code><a href="#topic+discrete.LR">discrete.LR()</a></code> (for Discrete Lehmann-Romano) implements [DLR],
<code><a href="#topic+discrete.GR">discrete.GR()</a></code> (for Discrete Guo-Romano) implements [DGR] and
<code><a href="#topic+discrete.PB">discrete.PB()</a></code> (for Discrete Poisson-Binomial) implements [DPB].
<code><a href="#topic+DLR">DLR()</a></code> and <code><a href="#topic+NDLR">NDLR()</a></code> are wrappers for <code><a href="#topic+discrete.LR">discrete.LR()</a></code> to access
[DLR] and its non-adaptive version directly. Likewise, <code><a href="#topic+DGR">DGR()</a></code>,
<code><a href="#topic+NDGR">NDGR()</a></code>, <code><a href="#topic+DPB">DPB()</a></code> and <code><a href="#topic+NDPB">NDPB()</a></code> are wrappers for
<code><a href="#topic+discrete.GR">discrete.GR()</a></code> and <code><a href="#topic+discrete.PB">discrete.PB()</a></code>, respectively. Their main
parameters are a vector of raw observed p-values and a list of the same
length, whose elements are the discrete supports of the CDFs of the p-values.
</p>
<p>In the same fashion, <code><a href="#topic+weighted.LR">weighted.LR()</a></code> (for Weighted Lehmann-Romano),
<code><a href="#topic+weighted.GR">weighted.GR()</a></code> (for Weighted Guo-Romano) and <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
(for Weighted Poisson-Binomial) implement [wLR], [wGR] and [wGR],
respectively. They also possess wrapper functions, namely <code><a href="#topic+wLR.AM">wLR.AM()</a></code>,
<code><a href="#topic+wGR.AM">wGR.AM()</a></code> and <code><a href="#topic+wPB.AM">wPB.AM()</a></code> for arithmetic weighting, and <code><a href="#topic+wLR.GM">wLR.GM()</a></code>,
<code><a href="#topic+wPB.GM">wPB.GM()</a></code> and <code><a href="#topic+wPB.GM">wPB.GM()</a></code> for geometric weighting.
</p>
<p>The functions <code><a href="#topic+fast.Discrete.LR">fast.Discrete.LR()</a></code>, <code><a href="#topic+fast.Discrete.GR">fast.Discrete.GR()</a></code>
and <code><a href="#topic+fast.Discrete.PB">fast.Discrete.PB()</a></code> are wrappers for
<code><a href="DiscreteFDR.html#topic+fisher.pvalues.support">DiscreteFDR::fisher.pvalues.support()</a></code> and <code><a href="#topic+discrete.LR">discrete.LR()</a></code>,
<code><a href="#topic+discrete.GR">discrete.GR()</a></code> and <code><a href="#topic+discrete.PB">discrete.PB()</a></code>, respectively, which allow to apply
discrete procedures directly to a data set of contingency tables.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Junge <a href="mailto:diso.fbmn@h-da.de">diso.fbmn@h-da.de</a> (<a href="https://orcid.org/0009-0001-6856-6938">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Döhler <a href="mailto:sebastian.doehler@h-da.de">sebastian.doehler@h-da.de</a> (<a href="https://orcid.org/0000-0002-0321-6355">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Etienne Roquain [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>
<p>Lehmann, E. L. &amp; Romano, J. P. (2005). Generalizations of the familywise
error rate. <em>The Annals of Statistics</em>, <em>33</em>(3), pp. 1138-1154.
<a href="https://doi.org/10.1214/009053605000000084">doi:10.1214/009053605000000084</a>
</p>
<p>Guo, W. &amp; Romano, J. P. (2007). A generalized Sidak-Holm procedure and
control of generalized error rates under independence.
<em>Statistical Applications in Genetics and Molecular Biology</em>, <em>6</em>(1),
Art. 3, 35 pp. (electronic). <a href="https://doi.org/10.2202/1544-6115.1247">doi:10.2202/1544-6115.1247</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DISOhda/FDX">https://github.com/DISOhda/FDX</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DISOhda/FDX/issues">https://github.com/DISOhda/FDX/issues</a>
</p>
</li></ul>


<hr>
<h2 id='continuous.GR'>Continuous Guo-Romano procedure</h2><span id='topic+continuous.GR'></span><span id='topic+GR'></span><span id='topic+NGR'></span>

<h3>Description</h3>

<p>Apply the usual continuous [GR] procedure, with or without computing the
critical values, to a set of p-values. A non-adaptive version is available as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous.GR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE,
  select.threshold = 1
)

GR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)

NGR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continuous.GR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="continuous.GR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>GR</code> and <code>NGR</code> are wrapper functions for <code>continuous.GR</code>. The
first one simply passes all its arguments to <code>continuous.GR</code> with
<code>adaptive = TRUE</code> and <code>NGR</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Guo, W. &amp; Romano, J. P. (2007). A generalized Sidak-Holm procedure and
control of generalized error rates under independence.
<em>Statistical Applications in Genetics and Molecular Biology</em>, <em>6</em>(1),
Art. 3, 35 pp. (electronic). <a href="https://doi.org/10.2202/1544-6115.1247">doi:10.2202/1544-6115.1247</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX-package</a></code>, <code><a href="#topic+continuous.LR">continuous.LR()</a></code>,
<code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+discrete.GR">discrete.GR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+weighted.LR">weighted.LR()</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR()</a></code>, <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# GR without critical values; using extracted p-values
GR.fast &lt;- GR(raw.pvalues)
summary(GR.fast)

# LR with critical values; using test results object
GR.crit &lt;- GR(test.results, critical.values = TRUE)
summary(GR.crit)

# Non-adaptive GR without critical values; using test results object
NGR.fast &lt;- NGR(test.results)
summary(NGR.fast)

# Non-adaptive GR with critical values; using extracted p-values
NGR.crit &lt;- NGR(raw.pvalues, critical.values = TRUE)
summary(NGR.crit)

</code></pre>

<hr>
<h2 id='continuous.LR'>Continuous Lehmann-Romano procedure</h2><span id='topic+continuous.LR'></span><span id='topic+LR'></span><span id='topic+NLR'></span>

<h3>Description</h3>

<p>Apply the usual (continuous) [LR] procedure, with or without computing the
critical values, to a set of p-values. A non-adaptive version is available as
well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous.LR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE,
  select.threshold = 1
)

LR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)

NLR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="continuous.LR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="continuous.LR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>LR</code> and <code>NLR</code> are wrapper functions for <code>continuous.LR</code>. The
first one simply passes all its arguments to <code>continuous.LR</code> with
<code>adaptive = TRUE</code> and <code>NLR</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lehmann, E. L. &amp; Romano, J. P. (2005). Generalizations of the familywise
error rate. <em>The Annals of Statistics</em>, <em>33</em>(3), pp. 1138-1154.
<a href="https://doi.org/10.1214/009053605000000084">doi:10.1214/009053605000000084</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel()</a></code>, <code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+continuous.GR">continuous.GR()</a></code>,
<code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+discrete.GR">discrete.GR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+weighted.LR">weighted.LR()</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR()</a></code>, <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# LR without critical values; using extracted p-values
LR.fast &lt;- LR(raw.pvalues)
summary(LR.fast)

# LR with critical values; using test results object
LR.crit &lt;- LR(test.results, critical.values = TRUE)
summary(LR.crit)

# Non-adaptive LR without critical values; using test results object
NLR.fast &lt;- NLR(test.results)
summary(NLR.fast)

# Non-adaptive LR with critical values; using extracted p-values
NLR.crit &lt;- NLR(raw.pvalues, critical.values = TRUE)
summary(NLR.crit)

</code></pre>

<hr>
<h2 id='DGR'>Wrapper Functions for the Discrete Guo-Romano Procedure</h2><span id='topic+DGR'></span><span id='topic+DGR.default'></span><span id='topic+DGR.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>DGR()</code> is a wrapper function of <code><a href="#topic+discrete.GR">discrete.GR()</a></code> for computing [DGR]. It
simply passes its arguments to <code><a href="#topic+discrete.GR">discrete.GR()</a></code> with fixed
<code>adaptive = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DGR(test.results, ...)

## Default S3 method:
DGR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
DGR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DGR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DGR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DGR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DGR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="DGR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="DGR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DGR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="DGR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+NDGR">NDGR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+DLR">DLR()</a></code>, <code><a href="#topic+NDLR">NDLR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+DPB">DPB()</a></code>, <code><a href="#topic+NDPB">NDPB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()
 
# DGR without critical values; using extracted p-values and supports
DGR.fast &lt;- DGR(raw.pvalues, pCDFlist)
summary(DGR.fast)

# DGR with critical values; using test results object
DGR.crit &lt;- DGR(test.results, critical.values = TRUE)
summary(DGR.crit)

</code></pre>

<hr>
<h2 id='direct.discrete'>Direct Application of Multiple Testing Procedures to Dataset</h2><span id='topic+direct.discrete'></span><span id='topic+direct.discrete.LR'></span><span id='topic+direct.discrete.GR'></span><span id='topic+direct.discrete.PB'></span>

<h3>Description</h3>

<p>Apply the [DLR], [NDLR], [DGR], [NDGR], [PB] or [NPB] procedure,
with or without computing the critical constants, to a data set of 2x2
contingency tables using a hypothesis test function from package
<a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.discrete.LR(
  dat,
  test.fun,
  test.args = NULL,
  alpha = 0.05,
  zeta = 0.5,
  direction = "su",
  adaptive = FALSE,
  critical.values = FALSE,
  select.threshold = 1,
  preprocess.fun = NULL,
  preprocess.args = NULL
)

direct.discrete.GR(
  dat,
  test.fun,
  test.args = NULL,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = FALSE,
  critical.values = FALSE,
  select.threshold = 1,
  preprocess.fun = NULL,
  preprocess.args = NULL
)

direct.discrete.PB(
  dat,
  test.fun,
  test.args = NULL,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = FALSE,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1,
  preprocess.fun = NULL,
  preprocess.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct.discrete_+3A_dat">dat</code></td>
<td>
<p>input data; must be suitable for the first parameter
of the provided <code>preprocess.fun</code> function or, if
<code>preprocess.fun = NULL</code>, for the first parameter of
the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_test.fun">test.fun</code></td>
<td>
<p>function <strong>from package
<code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code></strong>,
i.e. one whose name ends with <code style="white-space: pre;">&#8288;*_test_pv&#8288;</code> and which
performs hypothesis tests and provides an object
with p-values and their support sets; can be
specified by a single character string (which is
automatically checked for being a suitable function
<strong>from that package</strong> and may be abbreviated) or a
single function object.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_test.args">test.args</code></td>
<td>
<p>optional named list with arguments for <code>test.fun</code>;
the names of the list fields must match the test
function's parameter names. The first parameter of
the test function (i.e. the data) <strong>MUST NOT</strong> be
included!</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform the step-up (<code style="white-space: pre;">&#8288;"su&#8288;</code>) or step-down (<code>"sd"</code>; the default) version of the Lehmann-Romano procedure.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_preprocess.fun">preprocess.fun</code></td>
<td>
<p>optional function for pre-processing the input
<code>data</code>; its result must be suitable for the first
parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_preprocess.args">preprocess.args</code></td>
<td>
<p>optional named list with arguments for
<code>preprocess.fun</code>; the names of the list fields must
match the pre-processing function's parameter names.
The first parameter of the test function (i.e. the
data) <strong>MUST NOT</strong> be included!</p>
</td></tr>
<tr><td><code id="direct.discrete_+3A_exact">exact</code></td>
<td>
<p>single boolean indicating whether to compute the Poisson-Binomial distribution exactly or by normal approximation.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DLR
DLR.sd &lt;- direct.discrete.LR(df, "fisher")
summary(DLR.sd)

# Non-adaptive DLR (step-up variant; adjusted p-values do not exist here!)
NDLR.su &lt;- direct.discrete.LR(df, "fisher", direction = "su", adaptive = FALSE)
summary(NDLR.su)

# DGR
DGR &lt;- direct.discrete.GR(df, "fisher")
summary(DGR)

# Non-adaptive DGR
NDGR &lt;- direct.discrete.GR(df, "fisher", adaptive = FALSE)
summary(NDGR)

# DPB (normal approximation)
PB.approx &lt;- direct.discrete.PB(df, "fisher", exact = FALSE)
summary(DGR)

# Non-adaptive DPB
NPB.exact &lt;- direct.discrete.GR(df, "fisher", adaptive = FALSE)
summary(NDGR)

</code></pre>

<hr>
<h2 id='discrete.GR'>Discrete Guo-Romano procedure</h2><span id='topic+discrete.GR'></span><span id='topic+discrete.GR.default'></span><span id='topic+discrete.GR.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Apply the [DGR] procedure, with or without computing the critical values, to
a set of p-values and their discrete support. A non-adaptive version is
available as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.GR(test.results, ...)

## Default S3 method:
discrete.GR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
discrete.GR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete.GR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="discrete.GR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code>,
<code><a href="#topic+continuous.LR">continuous.LR()</a></code>, <code><a href="#topic+continuous.GR">continuous.GR()</a></code>, <code><a href="#topic+weighted.LR">weighted.LR()</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR()</a></code>, <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DGR without critical values; using test results object
DGR.fast &lt;- discrete.GR(test.results)
summary(DGR.fast)

# DGR with critical values; using extracted p-values and supports
DGR.crit &lt;- discrete.GR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DGR.crit)

# Non-Adaptive DGR without critical values; using extracted p-values and supports
NDGR.fast &lt;- discrete.GR(raw.pvalues, pCDFlist, adaptive = FALSE)
summary(NDGR.fast)

# Non-Adaptive DGR without critical values; using test results object
NDGR.crit &lt;- discrete.GR(test.results, adaptive = FALSE, critical.values = TRUE)
summary(NDGR.crit)

</code></pre>

<hr>
<h2 id='discrete.LR'>Discrete Lehmann-Romano procedure</h2><span id='topic+discrete.LR'></span><span id='topic+discrete.LR.default'></span><span id='topic+discrete.LR.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Apply the [DLR] procedure, with or without computing the critical values,
to a set of p-values and their discrete support. Both step-down and step-up
procedures can be computed and non-adaptive versions are available as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.LR(test.results, ...)

## Default S3 method:
discrete.LR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  adaptive = TRUE,
  critical.values = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
discrete.LR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  adaptive = TRUE,
  critical.values = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete.LR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform the step-up (<code style="white-space: pre;">&#8288;"su&#8288;</code>) or step-down (<code>"sd"</code>; the default) version of the Lehmann-Romano procedure.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="discrete.LR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code>,
<code><a href="#topic+continuous.LR">continuous.LR()</a></code>, <code><a href="#topic+continuous.GR">continuous.GR()</a></code>, <code><a href="#topic+weighted.LR">weighted.LR()</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR()</a></code>, <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DLR without critical values; using results object
DLR.sd.fast &lt;- discrete.LR(test.results)
summary(DLR.sd.fast)

# DLR with critical values; using extracted p-values and supports
DLR.sd.crit &lt;- discrete.LR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DLR.sd.crit)

# DLR (step-up) without critical values; using extracted p-values and supports
DLR.su.fast &lt;- discrete.LR(raw.pvalues, pCDFlist, direction = "su")
summary(DLR.su.fast)

# DLR (step-up) with critical values; using results object
DLR.su.crit &lt;- discrete.LR(test.results, direction = "su",
                           critical.values = TRUE)
summary(DLR.su.crit)

# Non-adaptive DLR without critical values; using results object
NDLR.sd.fast &lt;- discrete.LR(test.results, adaptive = FALSE)
summary(NDLR.sd.fast)

# Non-adaptive DLR with critical values; using extracted p-values and supports
NDLR.sd.crit &lt;- discrete.LR(raw.pvalues, pCDFlist, adaptive = FALSE,
                            critical.values = TRUE)
summary(NDLR.sd.crit)

# Non-adaptive DLR (step-up) without critical values; using extracted p-values and supports
NDLR.su.fast &lt;- discrete.LR(raw.pvalues, pCDFlist, direction = "su",
                            adaptive = FALSE)
summary(NDLR.su.fast)

# Non-adaptive DLR (step-up) with critical values; using results object
NDLR.su.crit &lt;- discrete.LR(test.results, direction = "su",
                            adaptive = FALSE, critical.values = TRUE)
summary(NDLR.su.crit)

</code></pre>

<hr>
<h2 id='DLR'>Wrapper Functions for the Discrete Guo-Romano Procedure</h2><span id='topic+DLR'></span><span id='topic+DLR.default'></span><span id='topic+DLR.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>DLR()</code> is a wrapper function of <code><a href="#topic+discrete.LR">discrete.LR()</a></code> for computing [DLR]. It
simply passes its arguments to <code><a href="#topic+discrete.LR">discrete.LR()</a></code> with fixed
<code>adaptive = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DLR(test.results, ...)

## Default S3 method:
DLR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  critical.values = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
DLR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  critical.values = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DLR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DLR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DLR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DLR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="DLR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="DLR_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform the step-up (<code style="white-space: pre;">&#8288;"su&#8288;</code>) or step-down (<code>"sd"</code>; the default) version of the Lehmann-Romano procedure.</p>
</td></tr>
<tr><td><code id="DLR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DLR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="DLR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+NDLR">NDLR()</a></code>, <code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+DGR">DGR()</a></code>, <code><a href="#topic+NDGR">NDGR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+DPB">DPB()</a></code>, <code><a href="#topic+NDPB">NDPB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DLR without critical values; using results object
DLR.sd.fast &lt;- DLR(test.results)
summary(DLR.sd.fast)

# DLR with critical values; using extracted p-values and supports
DLR.sd.crit &lt;- DLR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DLR.sd.crit)

# DLR (step-up) without critical values; using extracted p-values and supports
DLR.su.fast &lt;- DLR(raw.pvalues, pCDFlist, direction = "su")
summary(DLR.su.fast)

# DLR (step-up) with critical values; using test results object
DLR.su.crit &lt;- DLR(test.results, direction = "su", critical.values = TRUE)
summary(DLR.su.crit)

</code></pre>

<hr>
<h2 id='DPB'>Wrapper Functions for the Discrete Guo-Romano Procedure</h2><span id='topic+DPB'></span><span id='topic+DPB.default'></span>

<h3>Description</h3>

<p><code>DPB()</code> is a wrapper function of <code><a href="#topic+discrete.PB">discrete.PB()</a></code> for computing [DPB]. It
simply passes its arguments to <code><a href="#topic+discrete.PB">discrete.PB()</a></code> with fixed
<code>adaptive = TRUE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DPB(test.results, ...)

## Default S3 method:
DPB(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DPB_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DPB_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DPB_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DPB_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="DPB_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="DPB_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DPB_+3A_exact">exact</code></td>
<td>
<p>single boolean indicating whether to compute the Poisson-Binomial distribution exactly or by normal approximation.</p>
</td></tr>
<tr><td><code id="DPB_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="DPB_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+NDPB">NDPB()</a></code>, <code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+DGR">DGR()</a></code>, <code><a href="#topic+NDGR">NDGR()</a></code>,
<code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+DLR">DLR()</a></code>, <code><a href="#topic+NDLR">NDLR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DPB (exact) without critical values; using results object
DPB.exact.fast &lt;- DPB(test.results)
summary(DPB.exact.fast)

# DPB (exact) with critical values; using extracted p-values and supports
DPB.exact.crit &lt;- DPB(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DPB.exact.crit)

# DPB (normal approximation) without critical values; using extracted p-values and supports
DPB.norm.fast &lt;- DPB(raw.pvalues, pCDFlist, exact = FALSE)
summary(DPB.norm.fast)

# DPB (normal approximation) with critical values; using test results object
DPB.norm.crit &lt;- DPB(test.results, critical.values = TRUE, exact = FALSE)
summary(DPB.norm.crit)

</code></pre>

<hr>
<h2 id='DPB.DiscreteTestResults'>Discrete Poisson-Binomial procedure</h2><span id='topic+DPB.DiscreteTestResults'></span><span id='topic+discrete.PB'></span><span id='topic+discrete.PB.default'></span><span id='topic+discrete.PB.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Apply the [DPB] procedure, with or without computing the critical values,
to a set of p-values and their discrete support. A non-adaptive version is
available as well. Additionally, the user can choose between exact
computation of the Poisson-Binomial distribution or a refined normal
approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteTestResults'
DPB(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1,
  ...
)

discrete.PB(test.results, ...)

## Default S3 method:
discrete.PB(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
discrete.PB(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DPB.DiscreteTestResults_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_exact">exact</code></td>
<td>
<p>single boolean indicating whether to compute the Poisson-Binomial distribution exactly or by normal approximation.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="DPB.DiscreteTestResults_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DPB</code> and <code>NDPB</code> are wrapper functions for <code>discrete.PB</code>.
The first one simply passes all its arguments to <code>discrete.PB</code> with
<code>adaptive = TRUE</code> and <code>NDPB</code> does the same with
<code>adaptive = FALSE</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+continuous.LR">continuous.LR()</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>,
<code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+weighted.LR">weighted.LR()</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR()</a></code>, <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DPB (exact) without critical values; using results object
DPB.exact.fast &lt;- discrete.PB(test.results)
summary(DPB.exact.fast)

# DPB (exact) with critical values; using extracted p-values and supports
DPB.exact.crit &lt;- discrete.PB(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(DPB.exact.crit)

# DPB (normal approximation) without critical values; using extracted p-values and supports
DPB.norm.fast &lt;- discrete.PB(raw.pvalues, pCDFlist, exact = FALSE)
summary(DPB.norm.fast)

# DPB (normal approximation) with critical values; using results object
DPB.norm.crit &lt;- discrete.PB(test.results, critical.values = TRUE,
                             exact = FALSE)
summary(DPB.norm.crit)

# Non-adaptive DPB (exact) without critical values; using results object
NDPB.exact.fast &lt;- discrete.PB(test.results, adaptive = FALSE)
summary(NDPB.exact.fast)

# Non-adaptive DPB (exact) with critical values; using extracted p-values and supports
NDPB.exact.crit &lt;- discrete.PB(raw.pvalues, pCDFlist, adaptive = FALSE,
                               critical.values = TRUE)
summary(NDPB.exact.crit)

# Non-adaptive DPB (normal approx.) without critical values; using extracted p-values and supports
NDPB.norm.fast &lt;- discrete.PB(raw.pvalues, pCDFlist, adaptive = FALSE,
                              exact = FALSE)
summary(NDPB.norm.fast)

# Non-adaptive DPB (normal approx.) with critical values; using results object
NDPB.norm.crit &lt;- discrete.PB(test.results, adaptive = FALSE,
                              critical.values = TRUE, exact = FALSE)
summary(NDPB.norm.crit)

</code></pre>

<hr>
<h2 id='fast.Discrete'>Fast application of discrete procedures</h2><span id='topic+fast.Discrete'></span><span id='topic+fast.Discrete.LR'></span><span id='topic+fast.Discrete.GR'></span><span id='topic+fast.Discrete.PB'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Applies the [DLR], [DGR] or [DPB] procedures, <strong>without</strong> computing the
critical values, to a data set of 2 x 2 contingency tables using Fisher's
exact test.
</p>
<p><strong>Note</strong>: These functions are deprecated and will be removed in a future
version. Please use <code><a href="#topic+direct.discrete">direct.discrete.*()</a></code> with
<code>test.fun = DiscreteTests::fisher.test.pv</code> and (optional)
<code>preprocess.fun = DiscreteDatasets::reconstruct_two</code> or
<code>preprocess.fun = DiscreteDatasets::reconstruct_four</code> instead. Alternatively,
use a pipeline like<br />
<code style="white-space: pre;">&#8288;data |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteDatasets::reconstruct_*(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteTests::*.test.pv(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  discrete.*(&lt;args&gt;)&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.Discrete.LR(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  adaptive = TRUE
)

fast.Discrete.GR(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE
)

fast.Discrete.PB(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  zeta = 0.5,
  adaptive = TRUE,
  exact = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast.Discrete_+3A_counts">counts</code></td>
<td>
<p>a data frame of 2 or 4 columns and any number of lines,
each line representing a 2 x 2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument, see
Details of <code><a href="DiscreteFDR.html#topic+fisher.pvalues.support">DiscreteFDR::fisher.pvalues.support()</a></code>.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <code><a href="stats.html#topic+fisher.test">fisher.test()</a></code>. The three
possible values are <code>"greater"</code> (default),
<code>"two.sided"</code> or <code>"less"</code>; may be abbreviated.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_input">input</code></td>
<td>
<p>the format of the input data frame, see Details of
<code><a href="DiscreteFDR.html#topic+fisher.pvalues.support">DiscreteFDR::fisher.pvalues.support()</a></code>. The
three possible values are <code>"noassoc"</code> (default),
<code>"marginal"</code> or <code>"HG2011"</code>; may be
abbreviated.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform the step-up (<code style="white-space: pre;">&#8288;"su&#8288;</code>) or step-down (<code>"sd"</code>; the default) version of the Lehmann-Romano procedure.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_exact">exact</code></td>
<td>
<p>single boolean indicating whether to compute the Poisson-Binomial distribution exactly or by normal approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# DLR
DLR.sd &lt;- fast.Discrete.LR(counts = df, input = "noassoc")
summary(DLR.sd)

# DLR
DLR.su &lt;- fast.Discrete.LR(counts = df, input = "noassoc", direction = "su")
summary(DLR.su)

# Non-adaptive DLR
NDLR.sd &lt;- fast.Discrete.LR(counts = df, input = "noassoc", adaptive = FALSE)
summary(NDLR.sd)

# Non-adaptive DLR
NDLR.su &lt;- fast.Discrete.LR(counts = df, input = "noassoc", direction = "su", adaptive = FALSE)
summary(NDLR.su)

# DGR
DGR &lt;- fast.Discrete.GR(counts = df, input = "noassoc")
summary(DGR)

# Non-adaptive DGR
NDGR &lt;- fast.Discrete.GR(counts = df, input = "noassoc", adaptive = FALSE)
summary(NDGR)

# DPB
DPB &lt;- fast.Discrete.PB(counts = df, input = "noassoc")
summary(DPB)

# Non-adaptive DPB
NDPB &lt;- fast.Discrete.PB(counts = df, input = "noassoc", adaptive = FALSE)
summary(NDPB)

</code></pre>

<hr>
<h2 id='hist.FDX'>Histogram of Raw P-Values</h2><span id='topic+hist.FDX'></span>

<h3>Description</h3>

<p>Computes a histogram of the raw p-values of a <code>FDX</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
hist(x, breaks = "FD", mode = c("raw", "selected", "weighted"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist.FDX_+3A_x">x</code></td>
<td>
<p>object of class <code>FDX</code>.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_breaks">breaks</code></td>
<td>
<p>as in <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>; here, the Friedman-Diaconis
algorithm (<code>"FD"</code>) is used as default.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_mode">mode</code></td>
<td>
<p>single character string specifying for which $p$-values the
histogram is to be generated; must be one of <code>"raw"</code>,
<code>"selected"</code> or <code>"weighted"</code>.</p>
</td></tr>
<tr><td><code id="hist.FDX_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code> or
<code><a href="graphics.html#topic+plothistogram">graphics::plot.histogram()</a></code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> does not contain results of a weighting or selection approach, a
warning is issued and a histogram of the raw p-values is drawn.
</p>


<h3>Value</h3>

<p>An object of class <code>histogram</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DGR
DGR &lt;- DGR(raw.pvalues, pCDFlist)
# histogram of raw p-values
hist(DGR)

# arithmetic-weighted GR (using 1 - raw.pvalues as weights)
wGR &lt;- wGR.AM(raw.pvalues, 1 - raw.pvalues)
# histogram of raw p-values
hist(wGR)
# histogram of weighted p-values
hist(wGR, mode = "weighted")

</code></pre>

<hr>
<h2 id='kernel'>Kernel functions</h2><span id='topic+kernel'></span><span id='topic+kernel_DLR_fast'></span><span id='topic+kernel_DLR_crit'></span><span id='topic+kernel_wLR_fast'></span><span id='topic+kernel_DGR_fast'></span><span id='topic+kernel_DGR_crit'></span><span id='topic+kernel_wGR_fast'></span><span id='topic+kernel_DPB_fast'></span><span id='topic+kernel_DPB_crit'></span><span id='topic+kernel_wPB_fast'></span>

<h3>Description</h3>

<p>Kernel functions transform observed p-values or their support according to
[HLR], [PB] and [HGR]. The output is used by <code><a href="#topic+discrete.LR">discrete.LR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code> and <code><a href="#topic+discrete.GR">discrete.GR()</a></code>, respectively.
For each procedure, there is a kernel for fast computation and one for
calculation of critical values. Kernel function names followed by <code style="white-space: pre;">&#8288;_crit&#8288;</code>,
e.g. <code>kernel_DGR_crit</code>, compute and return these critical values, while
kernel functions ending with <code style="white-space: pre;">&#8288;_fast&#8288;</code> only transform p-values and are
therefore faster.
</p>
<p><strong>Note</strong>: As of version 2.0, these functions are purely internal functions!
As a consequence, they have to be called directly via <code>:::</code>, e.g.
<code>FDX:::kernel_DGR_fast()</code>. But users should <strong>not</strong> rely on them, as
parameters (including their names, order, etc.) may be changed without
notice!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_DLR_fast(
  pCDFlist,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  stepUp = FALSE,
  zeta = 0.5,
  support = numeric(),
  pCDFcounts = NULL
)

kernel_DLR_crit(
  pCDFlist,
  support,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  zeta = 0.5,
  stepUp = FALSE,
  pCDFcounts = NULL
)

kernel_wLR_fast(sorted_w_pv, weights, alpha = 0.05, geom_weighting = FALSE)

kernel_DGR_fast(
  pCDFlist,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  pCDFcounts = NULL
)

kernel_DGR_crit(
  pCDFlist,
  support,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  zeta = 0.5,
  pCDFcounts = NULL
)

kernel_wGR_fast(sorted_w_pv, weights, alpha = 0.05, geom_weighting = FALSE)

kernel_DPB_fast(
  pCDFlist,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  exact = TRUE,
  pCDFcounts = NULL
)

kernel_DPB_crit(
  pCDFlist,
  support,
  sorted_pv,
  adaptive = TRUE,
  alpha = 0.05,
  zeta = 0.5,
  exact = TRUE,
  pCDFcounts = NULL
)

kernel_wPB_fast(
  sorted_w_pv,
  weights,
  alpha = 0.05,
  geom_weighting = FALSE,
  exact = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="kernel_+3A_sorted_pv">sorted_pv</code></td>
<td>
<p>numeric vector containing the raw p-values, sorted
in increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean indicating whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="kernel_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="kernel_+3A_stepup">stepUp</code></td>
<td>
<p>single boolean specifying whether to conduct the
step-up (<code>TRUE</code>) or step-down (<code>FALSE</code>; the
default) version of the discrete Lehmann-Romano
procedure.</p>
</td></tr>
<tr><td><code id="kernel_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_support">support</code></td>
<td>
<p>numeric vector, sorted in increasing order, that
contains the entirety of all observable values of
the p-value supports; for <code>kernel_DLR_fast()</code>, it
is ignored if <code>stepUp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_pcdfcounts">pCDFcounts</code></td>
<td>
<p>integer vector of counts that indicates to how many
p-values each <strong>unique</strong> p-value distribution
belongs.</p>
</td></tr>
<tr><td><code id="kernel_+3A_sorted_w_pv">sorted_w_pv</code></td>
<td>
<p>numeric vector containing the weighted p-values,
sorted in increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_weights">weights</code></td>
<td>
<p>numeric vector containing the <strong>rescaled</strong> weights,
sorted in <strong>de</strong>creasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_geom_weighting">geom_weighting</code></td>
<td>
<p>a boolean specifying whether to conduct geometric
(<code>TRUE</code>) or arithmetic (<code>FALSE</code>)
weighting.</p>
</td></tr>
<tr><td><code id="kernel_+3A_exact">exact</code></td>
<td>
<p>single boolean indicating whether to compute the Poisson-Binomial distribution exactly or by normal approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code style="white-space: pre;">&#8288;*_fast&#8288;</code> kernels, a vector of transformed p-values is returned; <code style="white-space: pre;">&#8288;*_crit&#8288;</code>
kernels return a list object with critical constants (<code style="white-space: pre;">&#8288;$crit.consts&#8288;</code>) and
transformed p-values (<code style="white-space: pre;">&#8288;$pval.transf&#8288;</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>
<code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code>,
<code><a href="#topic+weighted.LR">weighted.LR()</a></code>, <code><a href="#topic+weighted.GR">weighted.GR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()
## Not run: 

alpha &lt;- 0.05

# If not searching for critical constants, we use only the observed p-values
sorted.pvals &lt;- sort(raw.pvalues)
y.DLR.fast &lt;- FDX:::kernel_DLR_fast(pCDFlist, sorted.pvals, TRUE)
y.NDGR.fast &lt;- FDX:::kernel_DGR_fast(pCDFlist, sorted.pvals, FALSE)$pval.transf
# transformed values
y.DLR.fast
y.NDGR.fast

# compute support
pv.list &lt;- sort(unique(unlist(pCDFlist)))
y.DGR.crit &lt;- FDX:::kernel_DGR_crit(pCDFlist, pv.list, sorted.pvals, TRUE)
y.NDPB.crit &lt;- FDX:::kernel_DPB_crit(pCDFlist, pv.list, sorted.pvals, FALSE)
# critical constants
y.DGR.crit$crit.consts
y.NDPB.crit$crit.consts
# transformed values
y.DGR.crit$pval.transf
y.NDPB.crit$pval.transf

## End(Not run)

</code></pre>

<hr>
<h2 id='match.pvals'>Matching Raw P-Values with Supports</h2><span id='topic+match.pvals'></span>

<h3>Description</h3>

<p>Constructs the observed p-values from the raw observed p-values, by rounding
them to their nearest neighbor matching with the supports of their
respective CDFs (as in function <code>p.discrete.adjust()</code> of package
<code>discreteMTP</code>, which is no longer available on CRAN).
</p>
<p><strong>Note</strong>: This is an internal function and has to be called directly via
<code>:::</code>, i.e. <code>FDX:::match.pvals()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.pvals(test.results, pCDFlist, pCDFlist.indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.pvals_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="match.pvals_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="match.pvals_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Well computed raw p-values should already belong to their respective CDF
support. So this function is called at the beginning of <code><a href="#topic+discrete.GR">discrete.GR()</a></code>,
<code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code> and their respective wrappers, just in
case raw p-values may be biased.
</p>
<p>For each raw p-value that needs to be rounded, a warning is issued.
</p>


<h3>Value</h3>

<p>A vector where each raw p-value has been replaced by its nearest neighbor, if
necessary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
toyList &lt;- list(c(0.3,0.7,1),c(0.1,0.65,1))
toyRaw1 &lt;- c(0.3,0.65)
match.pvals(toyRaw1, toyList)
toyRaw2 &lt;- c(0.31,0.6)
match.pvals(toyRaw2, toyList)

## End(Not run)

</code></pre>

<hr>
<h2 id='NDGR'>Wrapper Functions for the Non-Adaptive Discrete Guo-Romano Procedure</h2><span id='topic+NDGR'></span><span id='topic+NDGR.default'></span><span id='topic+NDGR.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>NDGR()</code> is a wrapper function of <code><a href="#topic+discrete.GR">discrete.GR()</a></code> for computing
non-adaptive [DGR]. It simply passes its arguments to <code><a href="#topic+discrete.GR">discrete.GR()</a></code>
with fixed <code>adaptive = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDGR(test.results, ...)

## Default S3 method:
NDGR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
NDGR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NDGR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="NDGR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="NDGR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="NDGR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="NDGR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="NDGR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="NDGR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="NDGR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+DGR">DGR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+DLR">DLR()</a></code>, <code><a href="#topic+NDLR">NDLR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+DPB">DPB()</a></code>, <code><a href="#topic+NDPB">NDPB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()
 
# Non-adaptive DGR without critical values; using extracted p-values and supports
NDGR.fast &lt;- NDGR(raw.pvalues, pCDFlist)
summary(NDGR.fast)

# Non-adaptive DGR with critical values; using test results object
NDGR.crit &lt;- NDGR(test.results, critical.values = TRUE)
summary(NDGR.crit)

</code></pre>

<hr>
<h2 id='NDLR'>Wrapper Functions for the Non-Adaptive Discrete Guo-Romano Procedure</h2><span id='topic+NDLR'></span><span id='topic+NDLR.default'></span><span id='topic+NDLR.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>NDLR()</code> is a wrapper function of <code><a href="#topic+discrete.LR">discrete.LR()</a></code> for computing
non-adaptive [DLR]. It simply passes its arguments to <code><a href="#topic+discrete.LR">discrete.LR()</a></code>
with fixed <code>adaptive = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDLR(test.results, ...)

## Default S3 method:
NDLR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  critical.values = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
NDLR(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  direction = "sd",
  critical.values = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NDLR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform the step-up (<code style="white-space: pre;">&#8288;"su&#8288;</code>) or step-down (<code>"sd"</code>; the default) version of the Lehmann-Romano procedure.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="NDLR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+DGR">DGR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+DLR">DLR()</a></code>, <code><a href="#topic+NDLR">NDLR()</a></code>,
<code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+DPB">DPB()</a></code>, <code><a href="#topic+NDPB">NDPB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# Non-adaptive DLR without critical values; using results object
NDLR.sd.fast &lt;- NDLR(test.results)
summary(NDLR.sd.fast)

# Non-adaptive DLR with critical values; using extracted p-values and supports
NDLR.sd.crit &lt;- NDLR(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(NDLR.sd.crit)

# Non-adaptive DLR (step-up) without critical values; using extracted p-values and supports
NDLR.su.fast &lt;- NDLR(raw.pvalues, pCDFlist, direction = "su")
summary(NDLR.su.fast)

# Non-adaptive DLR (step-up) with critical values; using test results object
NDLR.su.crit &lt;- NDLR(test.results, direction = "su", critical.values = TRUE)
summary(NDLR.su.crit)

</code></pre>

<hr>
<h2 id='NDPB'>Wrapper Functions for the Non-Adaptive Discrete Guo-Romano Procedure</h2><span id='topic+NDPB'></span><span id='topic+NDPB.default'></span><span id='topic+NDPB.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>NDPB()</code> is a wrapper function of <code><a href="#topic+discrete.PB">discrete.PB()</a></code> for computing
non-adaptive [DPB]. It simply passes its arguments to <code><a href="#topic+discrete.PB">discrete.PB()</a></code>
with fixed <code>adaptive = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NDPB(test.results, ...)

## Default S3 method:
NDPB(
  test.results,
  pCDFlist,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
NDPB(
  test.results,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NDPB_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_exact">exact</code></td>
<td>
<p>single boolean indicating whether to compute the Poisson-Binomial distribution exactly or by normal approximation.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="NDPB_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>critical.values = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Adaptive</code></td>
<td>
<p>boolean indicating whether an adaptive procedure was conducted or not.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.PB">discrete.PB()</a></code>, <code><a href="#topic+DPB">DPB()</a></code>, <code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+DGR">DGR()</a></code>, <code><a href="#topic+NDGR">NDGR()</a></code>,
<code><a href="#topic+discrete.LR">discrete.LR()</a></code>, <code><a href="#topic+DLR">DLR()</a></code>, <code><a href="#topic+NDLR">NDLR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# Non-adaptive DPB (exact) without critical values; using results object
NDPB.exact.fast &lt;- NDPB(test.results)
summary(NDPB.exact.fast)

# Non-adaptive DPB (exact) with critical values; using extracted p-values and supports
NDPB.exact.crit &lt;- NDPB(raw.pvalues, pCDFlist, critical.values = TRUE)
summary(NDPB.exact.crit)

# Non-adaptive DPB (normal approx.) without critical values; using extracted p-values and supports
NDPB.norm.fast &lt;- NDPB(raw.pvalues, pCDFlist, exact = FALSE)
summary(NDPB.norm.fast)

# Non-adaptive DPB (normal approx.) with critical values; using test results object
NDPB.norm.crit &lt;- NDPB(test.results, critical.values = TRUE, exact = FALSE)
summary(NDPB.norm.crit)

</code></pre>

<hr>
<h2 id='plot.FDX'>Plot Method for <code>FDX</code> objects</h2><span id='topic+plot.FDX'></span>

<h3>Description</h3>

<p>Plots raw $p$-values of a <code>FDX</code> object and highlights rejected and
non-rejected $p$-values. If present, the critical values are plotted, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
plot(
  x,
  col = c(2, 4, 1),
  pch = c(20, 20, 17),
  lwd = rep(par()$lwd, 3),
  cex = rep(par()$cex, 3),
  type.crit = "b",
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.FDX_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_col">col</code></td>
<td>
<p>numeric or character vector of length 3 indicating the
colors of the </p>

<ol>
<li><p> rejected $p$-values
</p>
</li>
<li><p> non-rejected $p$-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.FDX_+3A_pch">pch</code></td>
<td>
<p>numeric or character vector of length 3 indicating the
point characters of the </p>

<ol>
<li><p> rejected $p$-values
</p>
</li>
<li><p> non-rejected $p$-values
</p>
</li>
<li><p> critical values (if present and <code>type.crit</code>
is a plot type like <code>'p'</code>, <code>'b'</code> etc.).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.FDX_+3A_lwd">lwd</code></td>
<td>
<p>numeric vector of length 3 indicating the thickness of the
points and lines; defaults to current <code>par()$lwd</code> setting
for all components.</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_cex">cex</code></td>
<td>
<p>numeric vector of length 3 indicating the size of point
characters or lines of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>

<p>defaults to current <code>par()$cex</code> setting for all components.</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_type.crit">type.crit</code></td>
<td>
<p>single character giving the type of plot desired for the
critical values (e.g.: <code>'p'</code>, <code>'l'</code> etc; see
<code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code>).</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_legend">legend</code></td>
<td>
<p>if <code>NULL</code>, no legend is plotted; otherwise expecting a
character string like <code>"topleft"</code> etc. or a numeric vector
of two elements indicating (x, y) coordinates.</p>
</td></tr>
<tr><td><code id="plot.FDX_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+plot.default">graphics::plot.default()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> contains results of a weighted approach, the Y-axis of the plot
is derived from the weighted p-values. Otherwise, it is constituted by the
raw ones.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DLR without critical values; using extracted p-values and supports
DLR.sd.fast &lt;- DLR(raw.pvalues, pCDFlist)
# plot with default settings
plot(DLR.sd.fast)

# DLR (step-up) with critical values; using test results object
DLR.su.crit &lt;- DLR(test.results, direction = "su", critical.values = TRUE)
# limited plot range
plot(DLR.su.crit, xlim = c(1, 5), ylim = c(0, 0.4))

# DPB without critical values; using test results object
DPB.fast &lt;- DPB(test.results)
# limited plot range, custom colors, line widths and point symbols, top-left legend 
plot(DPB.fast, col = c(2, 4), pch = c(2, 3), lwd = c(2, 2), 
     legend = "topleft", xlim = c(1, 5), ylim = c(0, 0.4))

# DGR with critical values; using extracted p-values and supports
DGR.crit &lt;- DGR(raw.pvalues, pCDFlist, critical.values = TRUE)
# additional customized plot parameters
plot(DGR.crit, col = c(2, 4, 1), pch = c(1, 1, 4), lwd = c(1, 1, 2), 
     type.crit = 'o', legend = c(1, 0.4), lty = 1, xlim = c(1, 5), 
     ylim = c(0, 0.4), cex = c(3, 3, 2))

</code></pre>

<hr>
<h2 id='print.FDX'>Printing FDX results</h2><span id='topic+print.FDX'></span>

<h3>Description</h3>

<p>Prints the results of discrete FDX analysis, stored in a <code>FDX</code>
S3 class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.FDX_+3A_x">x</code></td>
<td>
<p>object of class <code>FDX</code>.</p>
</td></tr>
<tr><td><code id="print.FDX_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
They are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The respective input object is invisibly returned via <code>invisible(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DPB with critical values; using test results object
DPB.crit &lt;- DPB(test.results, critical.values = TRUE)
# print results
print(DPB.crit)

</code></pre>

<hr>
<h2 id='rejection.path'>Rejection Path Plot (for <code>FDX</code> objects)</h2><span id='topic+rejection.path'></span>

<h3>Description</h3>

<p>Displays the number of rejections of the raw p-values in a <code>FDX</code>
object in dependence of the exceedance probability <code>zeta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rejection.path(
  x,
  xlim = NULL,
  ylim = NULL,
  main = NULL,
  xlab = expression(zeta),
  ylab = "Number of Rejections",
  verticals = FALSE,
  pch = 19,
  ref.show = FALSE,
  ref.col = "gray",
  ref.lty = 2,
  ref.lwd = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rejection.path_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_xlim">xlim</code></td>
<td>
<p>x axis limits of the plot. If <code>NULL</code> (default),
the [0, 1] range is used.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot. If <code>NULL</code> (default),
the double of the median of the number of possible
rejections is used as upper limit.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_main">main</code></td>
<td>
<p>main title. If <code>NULL</code> (default), a description
string is used.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_xlab">xlab</code>, <code id="rejection.path_+3A_ylab">ylab</code></td>
<td>
<p>labels for x and y axis.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_verticals">verticals</code></td>
<td>
<p>logical; if <code>TRUE</code>, draw vertical lines at
steps.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_pch">pch</code></td>
<td>
<p>jump point character.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ref.show">ref.show</code></td>
<td>
<p>logical; if <code>TRUE</code> a vertical reference line
is plotted, whose height is the number of
rejections of the original Benjamini-Hochberg (BH)
procedure.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ref.col">ref.col</code></td>
<td>
<p>color of the reference line.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_ref.lty">ref.lty</code>, <code id="rejection.path_+3A_ref.lwd">ref.lwd</code></td>
<td>
<p>line type and thickness for the reference line.</p>
</td></tr>
<tr><td><code id="rejection.path_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="stats.html#topic+plot.stepfun">stats::plot.stepfun()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a <code>stepfun</code> object that computes the number of
rejections in dependence on the exceedance probability <code>zeta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DLR without critical values; using extracted p-values and supports
DLR &lt;- DLR(raw.pvalues, pCDFlist)
# plot number of rejections dependent on the exceedance probability zeta
rejection.path(DLR, xlim = c(0, 1), ref.show = TRUE, ref.col = "green", ref.lty = 4)

# None-adaptive DLR without critical values; using test results object
NDLR &lt;- NDLR(test.results)
# add plot for non-adaptive procedure (in red)
rejection.path(NDLR, col = "red", add = TRUE)

</code></pre>

<hr>
<h2 id='summary.FDX'>Summarizing Discrete FDX Results</h2><span id='topic+summary.FDX'></span><span id='topic+print.summary.FDX'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>FDX</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'FDX'
summary(object, ...)

## S3 method for class 'summary.FDX'
print(x, max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.FDX_+3A_object">object</code></td>
<td>
<p>object of class &quot;<code>FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="summary.FDX_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.FDX_+3A_x">x</code></td>
<td>
<p>object of class &quot;<code>summary.FDX</code>&quot;.</p>
</td></tr>
<tr><td><code id="summary.FDX_+3A_max">max</code></td>
<td>
<p>numeric or <code>NULL</code>, specifying the maximum number of
<em>rows</em> of the p-value table to be printed; if <code>NULL</code>
(the default), <code>getOption("max.print")</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.FDX</code> objects include all data of an <code>FDX</code> class
object, but also include an additional table which includes the raw p-values,
their indices, the respective critical values (if present), the adjusted
p-values (if present) and a logical column to indicate rejection. The table
is sorted in ascending order by the raw p-values.
</p>
<p><code>print.summary.FDX</code> simply prints the same output as
<code>print.FDX</code>, but also prints the p-value table.
</p>


<h3>Value</h3>

<p><code>summary.FDX</code> computes and returns a list that includes all the
data of an input <code>FDX</code>, plus
</p>
<table role = "presentation">
<tr><td><code>Table</code></td>
<td>
<p>a <code>data.frame</code>, sorted by the raw p-values, that contains
the indices, that raw p-values themselves, their respective
critical values (if present), their adjusted p-values (if
present) and a logical column to indicate rejection.</p>
</td></tr>
</table>
<p><code>print.summary.FDX</code> returns that object invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Construction of the p-values and their supports with Fisher's exact test
library(DiscreteTests)  # for Fisher's exact test
test.results &lt;- fisher_test_pv(df)
raw.pvalues &lt;- test.results$get_pvalues()
pCDFlist &lt;- test.results$get_pvalue_supports()

# DGR with critical values; using test results object
DGR.crit &lt;- DGR(test.results, critical.values = TRUE)
# create summary
DGR.crit.summary &lt;- summary(DGR.crit)
# print summary
print(DGR.crit.summary)

</code></pre>

<hr>
<h2 id='weighted.GR'>Weighted Guo-Romano Procedure</h2><span id='topic+weighted.GR'></span><span id='topic+wGR.AM'></span><span id='topic+wGR.GM'></span>

<h3>Description</h3>

<p>Apply the weighted [wGR] procedure, with or without computing the
critical values, to a set of p-values. Both arithmetic and geometric
weighting are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.GR(
  test.results,
  weights = NULL,
  alpha = 0.05,
  zeta = 0.5,
  weighting.method = c("AM", "GM"),
  critical.values = FALSE,
  select.threshold = 1
)

wGR.AM(
  test.results,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)

wGR.GM(
  test.results,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted.GR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_weights">weights</code></td>
<td>
<p>numeric vector that contains the weights for the p-values.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_weighting.method">weighting.method</code></td>
<td>
<p>single character string specifying whether to conduct arithmetic (<code>direction = "AM"</code>, the default) or geometric weighting (<code>direction = "GM"</code>) of p-values.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="weighted.GR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wGR.AM</code> and <code>wGR.GM</code> are wrapper functions for <code>weighted.GR</code>.
The first one simply passes all its arguments to <code>weighted.GR</code> with
<code>weighting.method = "AM"</code> and <code>wGR.GM</code> does the same with
<code>weighting.method = "GM"</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Weighted</code></td>
<td>
<p>weighted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$Weights</code></td>
<td>
<p>the weights for the raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Weighting</code></td>
<td>
<p>character string describing the weighting method.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+continuous.LR">continuous.LR()</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>,
<code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code>,
<code><a href="#topic+weighted.LR">weighted.LR()</a></code>, <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construction of the p-values and their supports for weighted methods
raw.pvalues.weighted &lt;- c(0.7389727, 0.1882310, 0.1302457, 0.9513677,
                          0.7592122, 0.0100559, 0.0000027, 0.1651034)
weights &lt;- c(0.7947122, 1.2633867, 2.8097858, 2.2112801,
             2.3878654, 1.2389620, 2.3878654, 0.7947122)

# arithmetic-weighted Guo-Romano procedure without critical values
wGR.AM.fast &lt;- wGR.AM(raw.pvalues.weighted, weights)
summary(wGR.AM.fast)

# arithmetic-weighted Guo-Romano procedure with critical values
wGR.AM.crit &lt;- wGR.AM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wGR.AM.crit)

# geometric-weighted Guo-Romano procedure without critical values
wGR.GM.fast &lt;- wGR.GM(raw.pvalues.weighted, weights)
summary(wGR.GM.fast)

# geometric-weighted Guo-Romano procedure with critical values
wGR.GM.crit &lt;- wGR.GM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wGR.GM.crit)

</code></pre>

<hr>
<h2 id='weighted.LR'>Weighted Lehmann-Romano Procedure</h2><span id='topic+weighted.LR'></span><span id='topic+wLR.AM'></span><span id='topic+wLR.GM'></span>

<h3>Description</h3>

<p>Apply the weighted [wLR] procedure, with or without computing the
critical values, to a set of p-values. Both arithmetic and geometric
weighting are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.LR(
  test.results,
  weights = NULL,
  alpha = 0.05,
  zeta = 0.5,
  weighting.method = c("AM", "GM"),
  critical.values = FALSE,
  select.threshold = 1
)

wLR.AM(
  test.results,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)

wLR.GM(
  test.results,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  select.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted.LR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_weights">weights</code></td>
<td>
<p>numeric vector that contains the weights for the p-values.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_weighting.method">weighting.method</code></td>
<td>
<p>single character string specifying whether to conduct arithmetic (<code>direction = "AM"</code>, the default) or geometric weighting (<code>direction = "GM"</code>) of p-values.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="weighted.LR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wLR.AM</code> and <code>wLR.GM</code> are wrapper functions for <code>weighted.LR</code>.
The first one simply passes all its arguments to <code>weighted.LR</code> with
<code>weighting.method = "AM"</code> and <code>wLR.GM</code> does the same with
<code>weighting.method = "GM"</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Weighted</code></td>
<td>
<p>weighted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$Weights</code></td>
<td>
<p>the weights for the raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Weighting</code></td>
<td>
<p>character string describing the weighting method.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+continuous.LR">continuous.LR()</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>,
<code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code>,
<code><a href="#topic+weighted.GR">weighted.GR()</a></code>, <code><a href="#topic+weighted.PB">weighted.PB()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construction of the p-values and their supports for weighted methods
raw.pvalues.weighted &lt;- c(0.7389727, 0.1882310, 0.1302457, 0.9513677,
                          0.7592122, 0.0100559, 0.0000027, 0.1651034)
weights &lt;- c(0.7947122, 1.2633867, 2.8097858, 2.2112801,
             2.3878654, 1.2389620, 2.3878654, 0.7947122)

# arithmetic-weighted Lehmann-Romano procedure without critical values
wLR.AM.fast &lt;- wLR.AM(raw.pvalues.weighted, weights)
summary(wLR.AM.fast)

# arithmetic-weighted Lehmann-Romano procedure with critical values
wLR.AM.crit &lt;- wLR.AM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wLR.AM.crit)

# geometric-weighted Lehmann-Romano procedure without critical values
wLR.GM.fast &lt;- wLR.GM(raw.pvalues.weighted, weights)
summary(wLR.GM.fast)

# geometric-weighted Lehmann-Romano procedure with critical values
wLR.GM.crit &lt;- wLR.GM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wLR.GM.crit)

</code></pre>

<hr>
<h2 id='weighted.PB'>Weighted Poisson-Binomial Procedure</h2><span id='topic+weighted.PB'></span><span id='topic+wPB.AM'></span><span id='topic+wPB.GM'></span>

<h3>Description</h3>

<p>Apply the weighted [wPB] procedure, with or without computing the
critical values, to a set of p-values. Both arithmetic and geometric
weighting are available. Additionally, the user can choose between exact
computation of the Poisson-Binomial distribution or a refined normal
approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.PB(
  test.results,
  weights = NULL,
  alpha = 0.05,
  zeta = 0.5,
  weighting.method = c("AM", "GM"),
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1
)

wPB.AM(
  test.results,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1
)

wPB.GM(
  test.results,
  weights,
  alpha = 0.05,
  zeta = 0.5,
  critical.values = FALSE,
  exact = TRUE,
  select.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="weighted.PB_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_weights">weights</code></td>
<td>
<p>numeric vector that contains the weights for the p-values.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target FDP.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_zeta">zeta</code></td>
<td>
<p>single real number strictly between 0 and 1 specifying the target probability of not exceeding the desired FDP. If <code>zeta = NULL</code> (the default), then <code>zeta</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_weighting.method">weighting.method</code></td>
<td>
<p>single character string specifying whether to conduct arithmetic (<code>direction = "AM"</code>, the default) or geometric weighting (<code>direction = "GM"</code>) of p-values.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_critical.values">critical.values</code></td>
<td>
<p>single boolean indicating whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_exact">exact</code></td>
<td>
<p>single boolean indicating whether to compute the Poisson-Binomial distribution exactly or by normal approximation.</p>
</td></tr>
<tr><td><code id="weighted.PB_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>wPB.AM</code> and <code>wPB.GM</code> are wrapper functions for <code>weighted.PB</code>.
The first one simply passes all its arguments to <code>weighted.PB</code> with
<code>weighting.method = "AM"</code> and <code>wPB.GM</code> does the same with
<code>weighting.method = "GM"</code>.
</p>


<h3>Value</h3>

<p>A <code>FDX</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Weighted</code></td>
<td>
<p>weighted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.values</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>critical.values = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold.</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Lehmann-Romano procedure (step-up)'.</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>all observed raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$Weights</code></td>
<td>
<p>the weights for the raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$FDP.threshold</code></td>
<td>
<p>FDP threshold <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Exceedance.probability</code></td>
<td>
<p>probability <code>zeta</code> of FDP exceeding <code>alpha</code>; thus, FDP is being controlled at level <code>alpha</code> with confidence 1 - <code>zeta</code>.</p>
</td></tr>
<tr><td><code>Data$Weighting</code></td>
<td>
<p>character string describing the weighting method.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable name(s) of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. &amp; Roquain, E. (2020). Controlling False Discovery Exceedance for
Heterogeneous Tests. <em>Electronic Journal of Statistics</em>, <em>14</em>(2),
pp. 4244-4272. <a href="https://doi.org/10.1214/20-EJS1771">doi:10.1214/20-EJS1771</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kernel">kernel</a></code>, <code><a href="#topic+FDX-package">FDX</a></code>, <code><a href="#topic+continuous.LR">continuous.LR()</a></code>,
<code><a href="#topic+continuous.GR">continuous.GR()</a></code>, <code><a href="#topic+discrete.LR">discrete.LR()</a></code>,
<code><a href="#topic+discrete.GR">discrete.GR()</a></code>, <code><a href="#topic+discrete.PB">discrete.PB()</a></code>,
<code><a href="#topic+weighted.LR">weighted.LR()</a></code>, <code><a href="#topic+weighted.GR">weighted.GR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construction of the p-values and their supports for weighted methods
raw.pvalues.weighted &lt;- c(0.7389727, 0.1882310, 0.1302457, 0.9513677,
                          0.7592122, 0.0100559, 0.0000027, 0.1651034)
weights &lt;- c(0.7947122, 1.2633867, 2.8097858, 2.2112801,
             2.3878654, 1.2389620, 2.3878654, 0.7947122)

# arithmetic-weighted Poisson-binomial procedure without critical values
wPB.AM.fast &lt;- wPB.AM(raw.pvalues.weighted, weights)
summary(wPB.AM.fast)

# arithmetic-weighted Poisson-binomial procedure with critical values
wPB.AM.crit &lt;- wPB.AM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wPB.AM.crit)

# geometric-weighted Poisson-binomial procedure without critical values
wPB.GM.fast &lt;- wPB.GM(raw.pvalues.weighted, weights)
summary(wPB.GM.fast)

# geometric-weighted Poisson-binomial procedure with critical values
wPB.GM.crit &lt;- wPB.GM(raw.pvalues.weighted, weights, critical.values = TRUE)
summary(wPB.GM.crit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
