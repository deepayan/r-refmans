<!DOCTYPE html><html lang="en"><head><title>Help for package sugarbag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sugarbag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sugarbag-package'><p>sugarbag: Create Tessellated Hexagon Maps</p></a></li>
<li><a href='#allocate'><p>Allocate polygon centroids to hexagons in a grid</p></a></li>
<li><a href='#capital_cities'><p>The point locations of Australian capital cities.</p></a></li>
<li><a href='#closest_focal_point'><p>For the polygon provided, find the closest focal point in the set provided</p></a></li>
<li><a href='#create_buffer'><p>Expand points to extend beyond the outermost centroids</p></a></li>
<li><a href='#create_centroids'><p>Create a data frame of longitude and latitude centroids of each polygon.</p></a></li>
<li><a href='#create_grid'><p>Create a grid of evenly spaced points to allow hexagons to tessellate</p></a></li>
<li><a href='#create_hexmap'><p>Create a tessellated hexagon map from a set of polygons</p></a></li>
<li><a href='#filter_grid_points'><p>Filter full set of grid points for those within range of original point</p></a></li>
<li><a href='#fortify_hexagon'><p>Creates the points that define a hexagon polygon for plotting</p></a></li>
<li><a href='#fortify_sfc'><p>Convert a simple features tibble to tibble for plotting.</p></a></li>
<li><a href='#fp19'><p>2019 Australian Federal election data: First preference votes for candidates</p>
(House of Representatives) in each electorate.</a></li>
<li><a href='#homeless'><p>The amount of homeless people in each Statistical Area at Level 2 in 2016.</p></a></li>
<li><a href='#read_shape'><p>Read in the shape file as sf object</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tas_lga'><p>The polygons of Tasmanian Local Government Areas in 2016.</p></a></li>
<li><a href='#tas_lga_hexctr'><p>The hexagon centres for polygons of Tasmanian Local Government Areas in 2016.</p></a></li>
<li><a href='#tas_sa2'><p>The polygons of Tasmanian Statistical Areas in 2016.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Create Tessellated Hexagon Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>Create a hexagon tile map display from spatial polygons. Each 
    polygon is represented by a hexagon tile, placed as close to it's original
    centroid as possible, with a focus on maintaining spatial relationship to
    a focal point. Developed to aid visualisation and analysis of spatial 
    distributions across Australia, which can be challenging due to the 
    concentration of the population on the coast and wide open interior.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://srkobakian.github.io/sugarbag/">https://srkobakian.github.io/sugarbag/</a>,
<a href="https://github.com/srkobakian/sugarbag">https://github.com/srkobakian/sugarbag</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), dplyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>geosphere (&ge; 1.5), progress (&ge; 1.2.2), purrr (&ge; 0.3.4),
rlang (&ge; 1.0.4), rmapshaper (&ge; 0.4.6), sf (&ge; 1.0-8), tibble
(&ge; 3.1.7), tidyr (&ge; 1.2.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2 (&ge; 3.3.6), knitr, pkgdown, rmarkdown, testthat (&ge;
2.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-08 21:29:20 UTC; cookd</td>
</tr>
<tr>
<td>Author:</td>
<td>Dianne Cook [aut, cre, ths],
  Stephanie Kobakian [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dianne Cook &lt;dicook@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-09 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sugarbag-package'>sugarbag: Create Tessellated Hexagon Maps</h2><span id='topic+sugarbag'></span><span id='topic+sugarbag-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Create a hexagon tile map display from spatial polygons. Each polygon is represented by a hexagon tile, placed as close to it's original centroid as possible, with a focus on maintaining spatial relationship to a focal point. Developed to aid visualisation and analysis of spatial distributions across Australia, which can be challenging due to the concentration of the population on the coast and wide open interior.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Dianne Cook <a href="mailto:dicook@monash.edu">dicook@monash.edu</a> [thesis advisor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Stephanie Kobakian
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://srkobakian.github.io/sugarbag/">https://srkobakian.github.io/sugarbag/</a>
</p>
</li>
<li> <p><a href="https://github.com/srkobakian/sugarbag">https://github.com/srkobakian/sugarbag</a>
</p>
</li></ul>


<hr>
<h2 id='allocate'>Allocate polygon centroids to hexagons in a grid</h2><span id='topic+allocate'></span>

<h3>Description</h3>

<p>Chooses a hexagon centroid for each polygon in the shape file, from a grid
spanning the longitudes and latitudes in the expanded bounding box.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allocate(
  centroids,
  hex_grid,
  sf_id = names(centroids)[1],
  hex_size,
  hex_filter,
  focal_points = NULL,
  order_sf_id = NULL,
  width = 30,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allocate_+3A_centroids">centroids</code></td>
<td>
<p>a data frame with centroids of non empty polygons</p>
</td></tr>
<tr><td><code id="allocate_+3A_hex_grid">hex_grid</code></td>
<td>
<p>a data frame containing all possible hexagon points</p>
</td></tr>
<tr><td><code id="allocate_+3A_sf_id">sf_id</code></td>
<td>
<p>a string to indicate the column to identify individual polygons</p>
</td></tr>
<tr><td><code id="allocate_+3A_hex_size">hex_size</code></td>
<td>
<p>a float value in degrees for the diameter of the hexagons</p>
</td></tr>
<tr><td><code id="allocate_+3A_hex_filter">hex_filter</code></td>
<td>
<p>amount of hexagons around centroid to consider</p>
</td></tr>
<tr><td><code id="allocate_+3A_focal_points">focal_points</code></td>
<td>
<p>a data frame of reference locations when allocating
hexagons, capital cities of Australia are used in the example</p>
</td></tr>
<tr><td><code id="allocate_+3A_order_sf_id">order_sf_id</code></td>
<td>
<p>a string to indicate the column used to order polygons</p>
</td></tr>
<tr><td><code id="allocate_+3A_width">width</code></td>
<td>
<p>a numeric indicating the angle used to filter the hexagon grid</p>
</td></tr>
<tr><td><code id="allocate_+3A_verbose">verbose</code></td>
<td>
<p>a boolean to indicate whether to show polygon id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of all allocated hexagon points
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create centroids set
centroids &lt;- create_centroids(tas_lga, sf_id = "lga_code_2016")
# Smaller set for faster example
centroids &lt;- centroids[1:10,] 
# Create hexagon location grid
data(capital_cities)
grid &lt;- create_grid(centroids = centroids, hex_size = 0.2, buffer_dist = 1.2)
# Allocate polygon centroids to hexagon grid points
hex_allocated &lt;- allocate(
  centroids = centroids,
  hex_grid = grid,
  hex_size = 0.2, # same size used in create_grid
  hex_filter = 3,
  focal_points = capital_cities,
  width = 30, 
  verbose = TRUE
)
# NEXT: 
# create a set of hexagon points for plotting
# using fortify_hexagon, and
# plot the hexagons with geom_polygon, see vignette
</code></pre>

<hr>
<h2 id='capital_cities'>The point locations of Australian capital cities.</h2><span id='topic+capital_cities'></span>

<h3>Description</h3>

<p>A dataset containing the longitude and latitude values of Australian
capital cities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capital_cities
</code></pre>


<h3>Format</h3>

<p>A data frame with 8 rows and 3 variables:
</p>

<dl>
<dt>points</dt><dd><p>name of cities</p>
</dd>
<dt>longitude</dt><dd><p>location of point in longitude degrees</p>
</dd>
<dt>latitude</dt><dd><p>location of point in latitude degrees</p>
</dd>
</dl>


<hr>
<h2 id='closest_focal_point'>For the polygon provided, find the closest focal point in the set provided</h2><span id='topic+closest_focal_point'></span>

<h3>Description</h3>

<p>For one row of an sf data frame, calculate the distance to the closest focal
point. Return the name of the focal point, and the angle between focal point and centroid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest_focal_point(centroid, focal_points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closest_focal_point_+3A_centroid">centroid</code></td>
<td>
<p>a data frame describing one centroid</p>
</td></tr>
<tr><td><code id="closest_focal_point_+3A_focal_points">focal_points</code></td>
<td>
<p>a data frame of the longitude and latitude values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing the name and location of the closest focal
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a set of polygon centroids
centroids &lt;- create_centroids(tas_sa2, "sa2_5dig_2016")

# Find the closest capital city for the first centroid
closest_focal_point(centroids[1, ], capital_cities)
</code></pre>

<hr>
<h2 id='create_buffer'>Expand points to extend beyond the outermost centroids</h2><span id='topic+create_buffer'></span>

<h3>Description</h3>

<p>Called from within create_grid function, this function takes the bounding
box of a group of polygons, or a specific table of minimum and maximum
longitudes and latitudes to create points for each polygon to be allocated
to that will tessellate into hexagons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_buffer(centroids, grid, hex_size, buffer_dist, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_buffer_+3A_centroids">centroids</code></td>
<td>
<p>data frame of centroids to be allocated</p>
</td></tr>
<tr><td><code id="create_buffer_+3A_grid">grid</code></td>
<td>
<p>data frame of hexagon centroids</p>
</td></tr>
<tr><td><code id="create_buffer_+3A_hex_size">hex_size</code></td>
<td>
<p>a float value in degrees for the diameter of the hexagons</p>
</td></tr>
<tr><td><code id="create_buffer_+3A_buffer_dist">buffer_dist</code></td>
<td>
<p>distance to extend beyond the geometry provided</p>
</td></tr>
<tr><td><code id="create_buffer_+3A_verbose">verbose</code></td>
<td>
<p>a boolean to indicate whether to show function progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of hexagon centroids
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lga_centroids &lt;- create_centroids(sugarbag::tas_lga, "lga_code_2016")
lga_grid &lt;- create_grid(lga_centroids, hex_size = 0.2, buffer_dist = 1.2)

</code></pre>

<hr>
<h2 id='create_centroids'>Create a data frame of longitude and latitude centroids of each polygon.</h2><span id='topic+create_centroids'></span>

<h3>Description</h3>

<p>Create a data frame of longitude and latitude centroids of each polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_centroids(shp_sf, sf_id, largest = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_centroids_+3A_shp_sf">shp_sf</code></td>
<td>
<p>an sf object, a data set with a simple feature list column</p>
</td></tr>
<tr><td><code id="create_centroids_+3A_sf_id">sf_id</code></td>
<td>
<p>a string to indicate the column to identify individual polygons</p>
</td></tr>
<tr><td><code id="create_centroids_+3A_largest">largest</code></td>
<td>
<p>logical; for <code>st_centroid</code>: if <code>TRUE</code>, return centroid of the
largest subpolygon of a <code>MULTIPOLYGON</code> rather than the whole <code>MULTIPOLYGON</code></p>
</td></tr>
<tr><td><code id="create_centroids_+3A_verbose">verbose</code></td>
<td>
<p>a boolean to indicate whether to show function progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble containing longitude and latitude
</p>


<h3>Examples</h3>

<pre><code class='language-R'>centroids &lt;- create_centroids(tas_lga, "lga_code_2016")
</code></pre>

<hr>
<h2 id='create_grid'>Create a grid of evenly spaced points to allow hexagons to tessellate</h2><span id='topic+create_grid'></span>

<h3>Description</h3>

<p>This function takes the output from the create_centroids function, or a
set of centroids in a table with the columns latitude and longitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_grid(
  centroids,
  hex_size,
  buffer_dist,
  latitude = "latitude",
  longitude = "longitude",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_grid_+3A_centroids">centroids</code></td>
<td>
<p>data frame of centroids to be allocated, this should have
columns for longitude and latitude value of centroids, as</p>
</td></tr>
<tr><td><code id="create_grid_+3A_hex_size">hex_size</code></td>
<td>
<p>a float value in degrees for the diameter of the hexagons</p>
</td></tr>
<tr><td><code id="create_grid_+3A_buffer_dist">buffer_dist</code></td>
<td>
<p>distance to extend beyond the geometry provided</p>
</td></tr>
<tr><td><code id="create_grid_+3A_latitude">latitude</code></td>
<td>
<p>the column name for the latitude values of the centroids</p>
</td></tr>
<tr><td><code id="create_grid_+3A_longitude">longitude</code></td>
<td>
<p>the column name for the longitude values of the centroids</p>
</td></tr>
<tr><td><code id="create_grid_+3A_verbose">verbose</code></td>
<td>
<p>a boolean to indicate whether to show function progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a set of centroids for grid to overlay
centroids &lt;- create_centroids(tas_lga, "lga_code_2016")
# Create the grid
grid &lt;- create_grid(centroids = centroids, hex_size = 0.2, buffer_dist = 1.2, verbose = FALSE)

</code></pre>

<hr>
<h2 id='create_hexmap'>Create a tessellated hexagon map from a set of polygons</h2><span id='topic+create_hexmap'></span>

<h3>Description</h3>

<p>Allocates each polygon in a shape file to a grid point to create a map of
tessellated hexagons. The spatial relationships of areas are preserved while
the geographic shape of each area is lost.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_hexmap(
  shp,
  sf_id,
  hex_size = NULL,
  buffer_dist = NULL,
  hex_filter = 10,
  f_width = 30,
  focal_points = NULL,
  order_sf_id = NULL,
  export_shp = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_hexmap_+3A_shp">shp</code></td>
<td>
<p>a shape file, if class is SPDF, will be converted to sf</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_sf_id">sf_id</code></td>
<td>
<p>name of a unique column that distinguishes areas</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_hex_size">hex_size</code></td>
<td>
<p>a float value in degrees for the diameter of the hexagons</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_buffer_dist">buffer_dist</code></td>
<td>
<p>distance in degrees to extend beyond the geometry provided</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_hex_filter">hex_filter</code></td>
<td>
<p>amount of hexagons around centroid to consider</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_f_width">f_width</code></td>
<td>
<p>the angle used to filter the grid points around a centroid</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_focal_points">focal_points</code></td>
<td>
<p>a data frame of reference locations when allocating
hexagons, capital cities of Australia are used in the example</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_order_sf_id">order_sf_id</code></td>
<td>
<p>a string name of a column to order by for allocating</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_export_shp">export_shp</code></td>
<td>
<p>export the simple features set</p>
</td></tr>
<tr><td><code id="create_hexmap_+3A_verbose">verbose</code></td>
<td>
<p>a boolean to indicate whether to show function progress</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data set containing longitude and latitude of allocated hexagon
points for each non null geometry passed in the shape file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(tas_lga)
# Smaller set for faster example
tas_lga_sub &lt;- tas_lga[1:10,] 
data(capital_cities)
hexmap &lt;- create_hexmap(
  shp = tas_lga_sub,
  sf_id = "lga_code_2016",
  hex_filter = 3,
  focal_points = capital_cities, 
  verbose = TRUE)

</code></pre>

<hr>
<h2 id='filter_grid_points'>Filter full set of grid points for those within range of original point</h2><span id='topic+filter_grid_points'></span>

<h3>Description</h3>

<p>Takes only the closest available gridpoints as possible hexagon centroids
to allocate polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_grid_points(
  f_grid,
  f_centroid,
  focal_points = NULL,
  f_dist = filter_dist,
  angle_width = width,
  h_size = hex_size
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filter_grid_points_+3A_f_grid">f_grid</code></td>
<td>
<p>complete grid of hexagon centroids</p>
</td></tr>
<tr><td><code id="filter_grid_points_+3A_f_centroid">f_centroid</code></td>
<td>
<p>the longitude and latitude values for the current centroid</p>
</td></tr>
<tr><td><code id="filter_grid_points_+3A_focal_points">focal_points</code></td>
<td>
<p>a tibble of focal locations, an optional argument that
allows allocation of polygons to hexagon centroids in ascending order of
the distance to the closest focal point. It also filters the grid points to
those within a 30 degree range of the angle from focal point to centroid.
The default &quot;capitals&quot; uses the locations of the Australian capital cities
as focal points.</p>
</td></tr>
<tr><td><code id="filter_grid_points_+3A_f_dist">f_dist</code></td>
<td>
<p>a distance in degrees, used as a boundary to filter
the hexagon centroids considered for each polygon centroid to be allocated.</p>
</td></tr>
<tr><td><code id="filter_grid_points_+3A_angle_width">angle_width</code></td>
<td>
<p>a numeric used to filter the hexagon grid</p>
</td></tr>
<tr><td><code id="filter_grid_points_+3A_h_size">h_size</code></td>
<td>
<p>a float value in degrees for the diameter of the hexagons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble of filtered grid points
</p>

<hr>
<h2 id='fortify_hexagon'>Creates the points that define a hexagon polygon for plotting</h2><span id='topic+fortify_hexagon'></span>

<h3>Description</h3>

<p>Creates the points that define a hexagon polygon for plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fortify_hexagon(data, sf_id, hex_size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fortify_hexagon_+3A_data">data</code></td>
<td>
<p>a data frame created by the allocate function</p>
</td></tr>
<tr><td><code id="fortify_hexagon_+3A_sf_id">sf_id</code></td>
<td>
<p>a string to indicate the column to identify individual polygons</p>
</td></tr>
<tr><td><code id="fortify_hexagon_+3A_hex_size">hex_size</code></td>
<td>
<p>a float value in degrees for the diameter of the hexagons</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of the seven points used to draw a hexagon
</p>


<h3>Examples</h3>

<pre><code class='language-R'># same column is used in create_centroids
fortify_hexagon(data = tas_lga_hexctr, sf_id = "lga_code_2016", hex_size = 0.2)
</code></pre>

<hr>
<h2 id='fortify_sfc'>Convert a simple features tibble to tibble for plotting.</h2><span id='topic+fortify_sfc'></span>

<h3>Description</h3>

<p>This will contain individual points for plotting the polygon, indicating the
longitude and latitude, order of points, if a hole is present, the piece, id
and group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fortify_sfc(sfc_df, keep = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fortify_sfc_+3A_sfc_df">sfc_df</code></td>
<td>
<p>a simples features data set</p>
</td></tr>
<tr><td><code id="fortify_sfc_+3A_keep">keep</code></td>
<td>
<p>ratio of points to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble point of long lat points used to plot polygons
</p>

<hr>
<h2 id='fp19'>2019 Australian Federal election data: First preference votes for candidates
(House of Representatives) in each electorate.</h2><span id='topic+fp19'></span>

<h3>Description</h3>

<p>A dataset containing first preference vote counts, candidate names, and
other results for the House of Representatives from the 2016 Australian federal election.
The data were obtained from the Australian Electoral Commission, and downloaded
from <a href="https://results.aec.gov.au/24310/Website/Downloads/HouseFirstPrefsByPartyDownload-24310.csv">https://results.aec.gov.au/24310/Website/Downloads/HouseFirstPrefsByPartyDownload-24310.csv</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp19
</code></pre>


<h3>Format</h3>

<p>A data frame with the following variables:
</p>

<ul>
<li><p>StateAbAbbreviation for state name
</p>
</li>
<li><p>UniqueIDnumeric identifier that links the electoral division
with Census and other election datasets.
</p>
</li>
<li><p>DivisionNmElectoral division name
</p>
</li>
<li><p>BallotPositionCandidate's position on the ballot
</p>
</li>
<li><p>CandidateIDCandidate ID
</p>
</li>
<li><p>SurnameCandidate surname
</p>
</li>
<li><p>GivenNmCandidate given name
</p>
</li>
<li><p>PartyAbAbbreviation for political party name
</p>
</li>
<li><p>PartyNmPolitical party name
</p>
</li>
<li><p>ElectedWhether the candidate was elected (Y/N)
</p>
</li>
<li><p>HistoricElectedWhether the candidate is the incumbent member
</p>
</li>
<li><p>OrdinaryVotesNumber of ordinary votes cast at the electorate
for the candidate
</p>
</li>
<li><p>PercentPercentage of ordinary votes for the candidate 
</p>
</li></ul>


<hr>
<h2 id='homeless'>The amount of homeless people in each Statistical Area at Level 2 in 2016.</h2><span id='topic+homeless'></span>

<h3>Description</h3>

<p>A data frame of the Statistical Area at Level 2 names and amount of homeless
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homeless
</code></pre>


<h3>Format</h3>

<p>A data frame with 545 rows and 2 variables:
</p>

<dl>
<dt>homeless</dt><dd><p>amount of homeless people</p>
</dd>
<dt>sa2_name_2016</dt><dd><p>name of the Statistical Area at Level 2</p>
</dd>
</dl>


<hr>
<h2 id='read_shape'>Read in the shape file as sf object</h2><span id='topic+read_shape'></span>

<h3>Description</h3>

<p>read_shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_shape(shp_path, simplify = TRUE, keep = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_shape_+3A_shp_path">shp_path</code></td>
<td>
<p>character vector location of shape file, extension .shp</p>
</td></tr>
<tr><td><code id="read_shape_+3A_simplify">simplify</code></td>
<td>
<p>a boolean to decide whether to simplify the shape file
using rmapshaper, keeping all shapes.</p>
</td></tr>
<tr><td><code id="read_shape_+3A_keep">keep</code></td>
<td>
<p>ratio of points to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an sf data frame, with a column of non null geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of how a shape file is read
shape &lt;- read_shape(shp_path = file.choose())


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tas_lga'>The polygons of Tasmanian Local Government Areas in 2016.</h2><span id='topic+tas_lga'></span>

<h3>Description</h3>

<p>A simple features dataset containing the polygons for all Australian LGAs in
2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tas_lga
</code></pre>


<h3>Format</h3>

<p>A simple features data frame with 39 rows and 6 variables:
</p>

<dl>
<dt>lga_code_2016</dt><dd><p>code for the Local Government Area</p>
</dd>
<dt>lga_name_2016</dt><dd><p>name of the Local Government Area</p>
</dd>
<dt>ste_code_2016</dt><dd><p>code for the state containing the Local Government Area</p>
</dd>
<dt>ste_name_2016</dt><dd><p>name of the state containing the Local Government Area</p>
</dd>
<dt>areasqkm_2016</dt><dd><p>area contained in the polygon</p>
</dd>
<dt>geometry</dt><dd><p>describes where on Earth the polygon is located</p>
</dd>
</dl>


<hr>
<h2 id='tas_lga_hexctr'>The hexagon centres for polygons of Tasmanian Local Government Areas in 2016.</h2><span id='topic+tas_lga_hexctr'></span>

<h3>Description</h3>

<p>A tibble dataset containing the processed data for all Australian LGAs in
2016. Each point corresponds to hexagon centre.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tas_lga_hexctr
</code></pre>


<h3>Format</h3>

<p>A simple features data frame with 39 rows and 6 variables:
</p>

<dl>
<dt>lga_code_2016</dt><dd><p>code for the Local Government Area</p>
</dd>
<dt>longitude, latitude</dt><dd><p>polygon centroid</p>
</dd>
<dt>points, focal_longitude, focal_latitude, focal_dist, focal_angle</dt><dd><p>Focal point (capital city) information used for each polygon/hexagon</p>
</dd>
<dt>rownumber</dt><dd><p>row number, in case it can be useful</p>
</dd>
<dt>hex_long, hex_lat, hex_id</dt><dd><p>hexagon centre and id</p>
</dd>
</dl>


<hr>
<h2 id='tas_sa2'>The polygons of Tasmanian Statistical Areas in 2016.</h2><span id='topic+tas_sa2'></span>

<h3>Description</h3>

<p>A simple features dataset containing the polygons for all Tasmanian SA2s in
2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tas_sa2
</code></pre>


<h3>Format</h3>

<p>A simple features data frame with 99 rows and 15 variables:
</p>

<dl>
<dt>sa2_main_2016</dt><dd><p>complete code of the Statistical Area</p>
</dd>
<dt>sa2_5dig_2016</dt><dd><p>simple code for the Statistical Area</p>
</dd>
<dt>sa2_name_2016</dt><dd><p>name of the Statistical Area</p>
</dd>
<dt>sa3_code_2016</dt><dd><p>code for the SA3 containing the Statistical Area</p>
</dd>
<dt>sa3_name_2016</dt><dd><p>name of the SA3 containing the Statistical Area</p>
</dd>
<dt>sa4_code_2016</dt><dd><p>code for the SA4 containing the Statistical Area</p>
</dd>
<dt>sa4_name_2016</dt><dd><p>name of the SA4 containing the Statistical Area</p>
</dd>
<dt>gcc_code_2016</dt><dd><p>code for the Greater Capital City region containing
the Statistical Area</p>
</dd>
<dt>gcc_name_2016</dt><dd><p>name of the Greater Capital City region containing
the Statistical Area</p>
</dd>
<dt>ste_code_2016</dt><dd><p>code for the state containing the Statistical Area</p>
</dd>
<dt>ste_name_2016</dt><dd><p>name of the state containing the Statistical Area</p>
</dd>
<dt>areasqkm_2016</dt><dd><p>area contained in the polygon</p>
</dd>
<dt>id</dt><dd><p>distinguishes SA2 regions</p>
</dd>
<dt>population</dt><dd><p>amount of people living within the region</p>
</dd>
<dt>sa2_code_2016</dt><dd><p>code of the Statistical Area</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
