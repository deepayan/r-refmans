<!DOCTYPE html><html><head><title>Help for package not</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {not}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#not-package'><p>Narrowest-Over-Threshold Change-Point Detection</p></a></li>
<li><a href='#aic.penalty'><p>Akaike Information Criterion penalty</p></a></li>
<li><a href='#features'><p>Extract locations of features from a 'not' object</p></a></li>
<li><a href='#logLik.not'><p>Extract likelihood from a 'not' object</p></a></li>
<li><a href='#not'><p>Narrowest-Over-Threshold Change-Point Detection</p></a></li>
<li><a href='#plot.not'><p>Plot a 'not' object</p></a></li>
<li><a href='#predict.not'><p>Estimate signal for a 'not' object.</p></a></li>
<li><a href='#random.intervals'><p>Generate random intervals</p></a></li>
<li><a href='#residuals.not'><p>Extract residuals from a 'not' object</p></a></li>
<li><a href='#sic.penalty'><p>Schwarz Information Criterion penalty</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Narrowest-Over-Threshold Change-Point Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-31</td>
</tr>
<tr>
<td>Author:</td>
<td>Rafal Baranowski, Yining Chen, Piotr Fryzlewicz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yining Chen &lt;Y.Chen101@lse.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>graphics, stats, splines</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides efficient implementation of the Narrowest-Over-Threshold methodology for detecting an unknown number of change-points occurring at unknown locations in one-dimensional data following 'deterministic signal + noise' model. Currently implemented scenarios are: piecewise-constant signal, piecewise-constant signal with a heavy-tailed noise, piecewise-linear signal, piecewise-quadratic signal, piecewise-constant signal and with piecewise-constant variance of the noise. For details, see Baranowski, Chen and Fryzlewicz (2019) &lt;<a href="https://doi.org/10.1111%2Frssb.12322">doi:10.1111/rssb.12322</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-01 23:23:32 UTC; chen</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-01 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='not-package'>Narrowest-Over-Threshold Change-Point Detection</h2><span id='topic+not-package'></span>

<h3>Description</h3>

<p>Implements the Narrowest-Over-Threshold approach for general multiple change-point 
detection in one-dimensional data following 'deterministic signal + noise' model. Scenarios that are currently implemented are: piecewise-constant signal, piecewise-constant signal with a heavy tailed noise, piecewise-linear signal, piecewise-quadratic signal, piecewise-constant signal and with piecewise-constant standard deviation of the noise. The main routines of the package are <code><a href="#topic+not">not</a></code> and <code><a href="#topic+features">features</a></code>.
</p>


<h3>References</h3>

<p>R. Baranowski, Y. Chen, and P. Fryzlewicz (2019). Narrowest-Over-Threshold Change-Point Detection.  (<a href="http://stats.lse.ac.uk/fryzlewicz/not/not.pdf">http://stats.lse.ac.uk/fryzlewicz/not/not.pdf</a>)
</p>

<hr>
<h2 id='aic.penalty'>Akaike Information Criterion penalty</h2><span id='topic+aic.penalty'></span>

<h3>Description</h3>

<p>The function evaluates the penalty term for Akaike Information Criterion. 
This routine is typically not called directly by the user; its name can be passed as an argument to <code><a href="#topic+features">features</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aic.penalty(n, n.param, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aic.penalty_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="aic.penalty_+3A_n.param">n.param</code></td>
<td>
<p>The number of parameters in the model for which the penalty is evaluated.</p>
</td></tr>
<tr><td><code id="aic.penalty_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The penalty term <code class="reqn">2 \times \code{n.param}</code>.
</p>


<h3>References</h3>

<p>R. Baranowski, Y. Chen, and P. Fryzlewicz (2019). Narrowest-Over-Threshold Change-Point Detection.  (<a href="http://stats.lse.ac.uk/fryzlewicz/not/not.pdf">http://stats.lse.ac.uk/fryzlewicz/not/not.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#*** a simple example how to use the AIC penalty
x &lt;- rnorm(300) + c(rep(1,50),rep(0,250))
w &lt;- not(x)
w.cpt &lt;- features(w, penalty="aic")
w.cpt$cpt[[1]]
</code></pre>

<hr>
<h2 id='features'>Extract locations of features from a 'not' object</h2><span id='topic+features'></span><span id='topic+features.default'></span>

<h3>Description</h3>

<p>The function applies user-specified stopping criteria to extract change-points from <code>object</code>
generated by <code><a href="#topic+not">not</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>features(object, ...)

## Default S3 method:
features(object, method = c("ic", "threshold"),
  penalty = c("sic", "aic", "user"), q.max = 25, penalty.fun, th, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="features_+3A_object">object</code></td>
<td>
<p>An object of 'not' class returned by <code><a href="#topic+not">not</a></code>.</p>
</td></tr>
<tr><td><code id="features_+3A_...">...</code></td>
<td>
<p>Further arguments that can be passed to the penalty function.</p>
</td></tr>
<tr><td><code id="features_+3A_method">method</code></td>
<td>
<p>A method of choosing the best solution in <code>object$solution.path</code>. 
If <code>method="ic"</code>, model minimising a chosen information criterion is selected. 
If <code>method="threshold"</code>, model is selected based on thresholding (see references for more details).</p>
</td></tr>
<tr><td><code id="features_+3A_penalty">penalty</code></td>
<td>
<p>Name of the penalty function to be used if <code>method="ic"</code>. If <code>penalty="user"</code>,
a user-defined penalty function has to be passed via <code>penalty.fun</code>.</p>
</td></tr>
<tr><td><code id="features_+3A_q.max">q.max</code></td>
<td>
<p>Maximum number of change-points allowed to be detected. Used only for <code>method="ic"</code>.</p>
</td></tr>
<tr><td><code id="features_+3A_penalty.fun">penalty.fun</code></td>
<td>
<p>Used only if <code>penalty="user"</code>. A function includes at least  the following arguments: sample size <code>n</code>, number of parameters used in a model <code>n.param</code>, and <code>...</code>.
For examples of such functions, see <code><a href="#topic+aic.penalty">aic.penalty</a></code> and <code><a href="#topic+sic.penalty">sic.penalty</a></code>.</p>
</td></tr>
<tr><td><code id="features_+3A_th">th</code></td>
<td>
<p>Used only if <code>method="threshold"</code>. A positive real number.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote by <code class="reqn">T_{1}, \ldots, T_{N}</code> the elements on the solution path <code>object$solution.path</code>, 
each representing a set of change-points.
When (<code>method="ic"</code>), the returned set of change-points is the one that minimises
</p>
<p style="text-align: center;"><code class="reqn">-2\mbox{log-likelihood}(\code{object}, \code{cpt}=T_k)+\mbox{penalty}(\code{object\$n}, \code{n.param}, ...),</code>
</p>

<p>over all <code class="reqn">k</code> such that the number of change-points in <code class="reqn">T_k</code> is smaller than or equal <code>q.max</code>. The log-likelihood is computed using the <code><a href="stats.html#topic+logLik">logLik</a></code> routine,
while the penalty function is computed with <code><a href="#topic+sic.penalty">sic.penalty</a></code> (<code>penalty="sic"</code>), <code><a href="#topic+aic.penalty">aic.penalty</a></code> (<code>penalty="aic"</code>) or a user-defined penalty function (<code>penalty="user"</code>).
</p>


<h3>Value</h3>

<table>
<tr><td><code>th</code></td>
<td>
<p>Value of the threshold used (if <code>method="threshold"</code>) or selected on the solution path (if <code>method="ic"</code>).</p>
</td></tr>
<tr><td><code>cpt</code></td>
<td>
<p>Estimated locations of the change-points.</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>Values of the information criterion minimised in order to find an optimal solution on the path (only if <code>method="ic"</code> was used).</p>
</td></tr>
</table>


<h3>References</h3>

<p>R. Baranowski, Y. Chen, and P. Fryzlewicz (2019). Narrowest-Over-Threshold Change-Point Detection.  (<a href="http://stats.lse.ac.uk/fryzlewicz/not/not.pdf">http://stats.lse.ac.uk/fryzlewicz/not/not.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **** Piecewisce-constant mean with Gaussian noise.
x &lt;- c(rep(0, 100), rep(1,100)) + rnorm(100)
# *** identify potential locations of the change-points
w &lt;- not(x, contrast = "pcwsConstMean")
# *** choose change-points using default settings
fo &lt;- features(w)
# *** get the change-points
fo$cpt
# *** plot the SIC curve
plot(fo$ic)
</code></pre>

<hr>
<h2 id='logLik.not'>Extract likelihood from a 'not' object</h2><span id='topic+logLik.not'></span>

<h3>Description</h3>

<p>Calculates the Gaussian log-likelihood for the signal estimated using <code><a href="#topic+predict.not">predict.not</a></code> with the change-points at <code>cpt</code>. The type of the signal depends on 
on the value of <code>contrast</code> that has been passed to <code><a href="#topic+not">not</a></code> (see <code><a href="#topic+predict.not">predict.not</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'not'
logLik(object, cpt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.not_+3A_object">object</code></td>
<td>
<p>An object of class 'not', returned by <code><a href="#topic+not">not</a></code>.</p>
</td></tr>
<tr><td><code id="logLik.not_+3A_cpt">cpt</code></td>
<td>
<p>An integer vector with locations of the change-points.
If missing, the <code><a href="#topic+features">features</a></code> is called internally to extract the change-points from <code>object</code>.</p>
</td></tr>
<tr><td><code id="logLik.not_+3A_...">...</code></td>
<td>
<p>Further parameters that can be passed to <code><a href="#topic+predict.not">predict.not</a></code> and <code><a href="#topic+features">features</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#' # **** Piecewisce-constant mean with Gaussian noise.
x &lt;- c(rep(0, 100), rep(1,100)) + rnorm(100)
# *** identify potential locations of the change-points
w &lt;- not(x, contrast = "pcwsConstMean")
# *** log-likelihood for the model with the change-point estimated  via 'not'
logLik(w)
# *** log-likelihood for the model with the change-point at 100
logLik(w, cpt=100)
</code></pre>

<hr>
<h2 id='not'>Narrowest-Over-Threshold Change-Point Detection</h2><span id='topic+not'></span><span id='topic+not.default'></span>

<h3>Description</h3>

<p>Identifies potential locations of the change-points in the data following 'deterministic signal + noise' model (see details below) in a number of different scenarios.
The object returned by this routine can be further passed to the <code><a href="#topic+features">features</a></code> function,  which finds the final estimate of the change-points based on a chosen stopping criterion. 
It can be also passed to <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+predict">predict</a></code> and <code><a href="stats.html#topic+residuals">residuals</a></code> routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>not(x, ...)

## Default S3 method:
not(x, M = 10000, method = c("not", "max"),
  contrast = c("pcwsConstMean", "pcwsConstMeanHT", "pcwsLinContMean",
  "pcwsLinMean", "pcwsQuadMean", "pcwsConstMeanVar"),
  rand.intervals = TRUE, parallel = FALSE, augmented = FALSE,
  intervals, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="not_+3A_x">x</code></td>
<td>
<p>A numeric vector with data points.</p>
</td></tr>
<tr><td><code id="not_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
<tr><td><code id="not_+3A_m">M</code></td>
<td>
<p>A number of intervals drawn in the procedure.</p>
</td></tr>
<tr><td><code id="not_+3A_method">method</code></td>
<td>
<p>Choice of &quot;not&quot; (recommended) and &quot;max&quot;. If <code>method="not"</code>, the Narrowest-Over-Threshold intervals are used in the algorithm. 
If <code>method="max"</code>, the intervals corresponding to the largest contrast function are used. For an explanation, see the references.</p>
</td></tr>
<tr><td><code id="not_+3A_contrast">contrast</code></td>
<td>
<p>A type of the contrast function used in the NOT algorithm. 
Choice of <code>"pcwsConstMean"</code>, <code>"pcwsConstMeanHT"</code>, <code>"pcwsLinContMean"</code>, <code>"pcwsLinMean"</code>, <code>"pcwsQuadMean"</code>, <code>"pcwsConstMeanVar"</code>. 
For the explanation, see details below.</p>
</td></tr>
<tr><td><code id="not_+3A_rand.intervals">rand.intervals</code></td>
<td>
<p>A logical variable. If <code>rand.intervals=TRUE</code> intervals used in the procedure are drawn uniformly using the <code><a href="#topic+random.intervals">random.intervals</a></code> routine. 
If <code>rand.intervals=FALSE</code>, the intervals need to be passed using the <code>intervals</code> argument.</p>
</td></tr>
<tr><td><code id="not_+3A_parallel">parallel</code></td>
<td>
<p>A logical variable. If TRUE some of computations are run in parallel using OpenMP framework. Currently this option is not supported on Windows.</p>
</td></tr>
<tr><td><code id="not_+3A_augmented">augmented</code></td>
<td>
<p>A logical variable. if TRUE, the entire data are considered when the NOT segmentation tree is constructed (see the solution path algorithm in the references).</p>
</td></tr>
<tr><td><code id="not_+3A_intervals">intervals</code></td>
<td>
<p>A 2-column matrix with the intervals considered in the algorithm, with start- and end- points of the intervals in, respectively, the first and  the second column. 
The intervals are used only if <code>rand.intervals=FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data points provided in <code>x</code> are assumed to follow
</p>
<p style="text-align: center;"><code class="reqn">Y_{t} = f_{t}+\sigma_{t}\varepsilon_{t},</code>
</p>

<p>for <code class="reqn">t=1,\ldots,n</code>, where <code class="reqn">n</code> is the number of observations in <code>x</code>, the signal <code class="reqn">f_{t}</code> and the standard deviation <code class="reqn">\sigma_{t}</code> 
are non-stochastic with structural breaks at unknown locations in time <code class="reqn">t</code>. Currently, thefollowing scenarios for <code class="reqn">f_{t}</code> and <code class="reqn">\sigma_{t}</code> are implemented:
</p>

<ul>
<li><p> Piecewise-constant signal with a Gaussian noise and constant standard deviation. 
</p>
<p>Use <code>contrast="pcwsConstMean"</code> here.
</p>
</li>
<li><p> Piecewise-constant mean with a heavy-tailed noise and constant standard deviation. 
</p>
<p>Use <code>contrast="pcwsConstMeanHT"</code> here.
</p>
</li>
<li><p> Piecewise-linear continuous signal with Gaussian noise and constant standard deviation. 
</p>
<p>Use <code>contrast="pcwsLinContMean"</code> here.
</p>
</li>
<li><p> Piecewise-linear signal with Gaussian noise and constant standard deviation.
</p>
<p>Use <code>contrast="pcwsLinMean"</code> here.
</p>
</li>
<li><p> Piecewise-quadratic signal with Gaussian noise and constant standard deviation. 
</p>
<p>Use <code>contrast="pcwsQuadMean"</code> here.
</p>
</li>
<li><p> Piecewise-constant signal and piecewise-constant standard deviation of the Gaussian noise. 
</p>
<p>Use <code>contrast="pcwsConstMeanVar"</code> here.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &quot;not&quot;, which contains the following fields:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The input vector.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The length of <code>x</code>.</p>
</td></tr>
<tr><td><code>contrast</code></td>
<td>
<p>A scenario for the change-points.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>A 5-column matrix with the values of the contrast function, where 's' and 'e' denote start-
end points of the intervals in which change-points candidates 'arg.max' have been found; 'length' shows the length of the intervals drawn,
column 'max.contrast' contains corresponding value of the contrast statistic.</p>
</td></tr>
<tr><td><code>solution.path</code></td>
<td>
<p>A list with the solution path of the NOT algorithm (see the references) containing three fields of the same length: <code>cpt</code> - a list with consecutive solutions, i.e. s the sets of change-point candidates, 
<code>th</code> - a vector of thresholds corresponding to the solutions, <code>n.cpt</code> - a vector with the number of change-points for each solution.</p>
</td></tr>
</table>


<h3>References</h3>

<p>R. Baranowski, Y. Chen, and P. Fryzlewicz (2019). Narrowest-Over-Threshold Change-Point Detection.  (<a href="http://stats.lse.ac.uk/fryzlewicz/not/not.pdf">http://stats.lse.ac.uk/fryzlewicz/not/not.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **** Piecewisce-constant mean with Gaussian noise.
# *** signal
pcws.const.sig &lt;- c(rep(0, 100), rep(1,100))
# *** data vector
x &lt;- pcws.const.sig + rnorm(100)
# *** identify potential locations of the change-points
w &lt;- not(x, contrast = "pcwsConstMean") 
# *** some examples of how the w object can be used
plot(w)
plot(residuals(w))
plot(predict(w))
# *** this is how to extract the change-points
fo &lt;- features(w)
fo$cpt

# **** Piecewisce-constant mean with a heavy-tailed noise.
# *** data vector, signal the same as in the previous example, but heavy tails
x &lt;- pcws.const.sig + rt(100, 3) 
# *** identify potential locations of the change-points, 
# using a contrast taylored to heavy-tailed data
w &lt;- not(x, contrast = "pcwsConstMeanHT") 
plot(w)

# **** Piecewisce-constant mean and piecewise-constant variance
# *** signal's standard deviation
pcws.const.sd &lt;- c(rep(2, 50), rep(1,150))
# *** data vector with pcws-const mean and variance
x &lt;- pcws.const.sig + pcws.const.sd * rnorm(100)
# *** identify potential locations of the change-points in this model
w &lt;- not(x, contrast = "pcwsConstMeanVar") 
# *** extracting locations of the change-points
fo &lt;- features(w)
fo$cpt

# **** Piecewisce-linear coninuous mean
# *** signal with a change in slope
pcws.lin.cont.sig &lt;- cumsum(c(rep(-1/50, 100), rep(1/50,100)))
# *** data vector 
x &lt;- pcws.lin.cont.sig +  rnorm(100)
# *** identify potential locations of the change-points in the slope coefficient
w &lt;- not(x, contrast = "pcwsLinContMean") 
# *** ploting the results
plot(w)
# *** location(s) of the change-points
fo &lt;- features(w)
fo$cpt

# **** Piecewisce-linear mean with jumps
# *** signal with a change in slope and jumpe
pcws.lin.sig &lt;- pcws.lin.cont.sig + pcws.const.sig
# *** data vector 
x &lt;- pcws.lin.sig +  rnorm(100)
# *** identify potential locations of the change-points in the slope coefficient and the intercept
w &lt;- not(x, contrast = "pcwsLinMean") 
# *** ploting the results
plot(w)
# *** location(s) of the change-points
fo &lt;- features(w)
fo$cpt

# **** Piecewisce-quadratic mean with jumps
# *** Piecewise-quadratic signal
pcws.quad.sig &lt;- 2*c((1:50)^2 /1000, rep(2, 100), 1:50 / 50 )
# *** data vector 
x &lt;- pcws.quad.sig +  rnorm(100)
# *** identify potential locations of the change-points in the slope coefficient and the intercept
w &lt;- not(x, contrast = "pcwsQuadMean") 
# *** ploting the results
plot(w)
# *** location(s) of the change-points
fo &lt;- features(w)
fo$cpt
</code></pre>

<hr>
<h2 id='plot.not'>Plot a 'not' object</h2><span id='topic+plot.not'></span>

<h3>Description</h3>

<p>Plots the input vector used to generate 'not' object <code>x</code> with the signal fitted with <code><a href="#topic+predict.not">predict.not</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'not'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.not_+3A_x">x</code></td>
<td>
<p>An object of class 'not', returned by <code><a href="#topic+not">not</a></code>.</p>
</td></tr>
<tr><td><code id="plot.not_+3A_...">...</code></td>
<td>
<p>Further parameters which may be passed to <code><a href="#topic+predict.not">predict.not</a></code> and <code><a href="#topic+features">features</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict.not">predict.not</a></code> <code><a href="#topic+not">not</a></code>  <code><a href="#topic+features">features</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **** Piecewisce-constant mean with Gaussian noise.
x &lt;- c(rep(0, 100), rep(1,100)) + rnorm(100)
# *** identify potential locations of the change-points
w &lt;- not(x, contrast = "pcwsConstMean")
# *** when 'cpt' is omitted, 'features' function is used internally 
# to choose change-points locations
plot(w)
# *** estimate and plot the signal specifying the location of the change-point
plot(w, cpt=100)
</code></pre>

<hr>
<h2 id='predict.not'>Estimate signal for a 'not' object.</h2><span id='topic+predict.not'></span>

<h3>Description</h3>

<p>Estimates signal in <code>object$x</code> with change-points at <code>cpt</code>. The type of the signal depends on 
on the value of <code>contrast</code> that has been passed to <code><a href="#topic+not">not</a></code> (see details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'not'
predict(object, cpt, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.not_+3A_object">object</code></td>
<td>
<p>An object of class 'not', returned by <code><a href="#topic+not">not</a></code>.</p>
</td></tr>
<tr><td><code id="predict.not_+3A_cpt">cpt</code></td>
<td>
<p>An integer vector with locations of the change-points.
If missing, the <code><a href="#topic+features">features</a></code> is called internally to extract the change-points from <code>object</code>.</p>
</td></tr>
<tr><td><code id="predict.not_+3A_...">...</code></td>
<td>
<p>Further parameters that can be passed to <code><a href="#topic+predict.not">predict.not</a></code> and <code><a href="#topic+features">features</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data points provided in <code>object$x</code> are assumed to follow
</p>
<p style="text-align: center;"><code class="reqn">Y_{t} = f_{t}+\sigma_{t}\varepsilon_{t},</code>
</p>

<p>for <code class="reqn">t=1,\ldots,n</code>, where <code class="reqn">n</code> is the number of observations in <code>object$x</code>, the signal <code class="reqn">f_{t}</code> and the standard deviation <code class="reqn">\sigma_{t}</code> 
are non-stochastic with change-points at locations given in <code>cpt</code> and <code class="reqn">\varepsilon_{t}</code> is a white-noise. Denote by <code class="reqn">\tau_{1}, \ldots, \tau_{q}</code> 
the elements in <code>cpt</code> and set <code class="reqn">\tau_{0}=0</code> and <code class="reqn">\tau_{q+1}=T</code>. Depending on the value of <code>contrast</code> that has been passed to <code><a href="#topic+not">not</a></code> to construct <code>object</code>,  the returned value is calculated as follows.
</p>

<ul>
<li><p> For <code>contrast="pcwsConstantMean"</code> and <code>contrast="pcwsConstantMeanHT"</code>, in each  segment  <code class="reqn">(\tau_{j}+1, \tau_{j+1})</code>,
<code class="reqn">f_{t}</code> for <code class="reqn">t\in(\tau_{j}+1, \tau_{j+1})</code> is approximated by the mean of <code class="reqn">Y_{t}</code> calculated over <code class="reqn">t\in(\tau_{j}+1, \tau_{j+1})</code>. 
</p>
</li>
<li><p> For <code>contrast="pcwsLinContMean"</code>, <code class="reqn">f_{t}</code> is approximated by the linear spline fit with knots at <code class="reqn">\tau_{1}, \ldots, \tau_{q}</code> minimising the l2 distance between the fit and the data.
</p>
</li>
<li><p> For <code>contrast="pcwsLinMean"</code> in each  segment  <code class="reqn">(\tau_{j}+1, \tau_{j+1})</code>, the signal
<code class="reqn">f_{t}</code> for <code class="reqn">t\in(\tau_{j}+1, \tau_{j+1})</code> is approximated by the line <code class="reqn">\alpha_{j} + \beta_{j} t</code>, where the regression coefficients are 
found using the least squares method.
</p>
</li>
<li><p> For <code>contrast="pcwsQuad"</code>, the signal
<code class="reqn">f_{t}</code> for <code class="reqn">t\in(\tau_{j}+1, \tau_{j+1})</code> is approximated by the curve <code class="reqn">\alpha_{j} + \beta_{j} t + \gamma_{j} t^2</code>, where the regression coefficients are 
found using the least squares method.
</p>
</li>
<li><p> For <code>contrast="pcwsConstMeanVar"</code>,  in each  segment  <code class="reqn">(\tau_{j}+1, \tau_{j+1})</code>, 
<code class="reqn">f_{t}</code> and <code class="reqn">\sigma_{t}</code> for <code class="reqn">t\in(\tau_{j}+1, \tau_{j+1})</code> are approximated by, respectively, the mean and the standard deviation of <code class="reqn">Y_{t}</code>, both calculated over <code class="reqn">t\in(\tau_{j}+1, \tau_{j+1})</code>.     
</p>
</li></ul>



<h3>Value</h3>

<p>A vector wit the estimated signal or a two-column matrix with the estimated estimated signal and standard deviation if <code>contrast="pcwsConstMeanVar"</code> was used to construct <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+not">not</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># **** Piecewisce-constant mean with Gaussian noise.
x &lt;- c(rep(0, 100), rep(1,100)) + rnorm(100)
# *** identify potential locations of the change-points
w &lt;- not(x, contrast = "pcwsConstMean")
# *** when 'cpt' is omitted, 'features' function is used internally 
# to choose change-points locations
signal.est &lt;- predict(w)
# *** estimate the signal specifying the location of the change-point
signal.est.known.cpt &lt;- predict(w, cpt=100)
# *** pass arguments of the 'features' function through 'predict'.
signal.est.aic &lt;- predict(w, penalty.type="aic")

# **** Piecewisce-constant mean and variance with Gaussian noise.
x &lt;- c(rep(0, 100), rep(1,100)) + c(rep(2, 100), rep(1,100)) * rnorm(100)
# *** identify potential locations of the change-points
w &lt;- not(x, contrast = "pcwsConstMeanVar")
# *** here signal is two-dimensional
signal.est &lt;- predict(w)
</code></pre>

<hr>
<h2 id='random.intervals'>Generate random intervals</h2><span id='topic+random.intervals'></span>

<h3>Description</h3>

<p>The function generates <code>M</code> intervals of the length smaller or equal than <code>max.length</code>, whose endpoints are 
are drawn uniformly without replacements from <code>1</code>,<code>2</code>,..., <code>n</code>. This routine can be
used inside <code><a href="#topic+not">not</a></code> function and is typically not called directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.intervals(n, M, min.length = 1, max.length = n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.intervals_+3A_n">n</code></td>
<td>
<p>a number of endpoints to choose from</p>
</td></tr>
<tr><td><code id="random.intervals_+3A_m">M</code></td>
<td>
<p>a number of intervals to generate</p>
</td></tr>
<tr><td><code id="random.intervals_+3A_min.length">min.length</code></td>
<td>
<p>an integer specifying minimum interval length</p>
</td></tr>
<tr><td><code id="random.intervals_+3A_max.length">max.length</code></td>
<td>
<p>an integer specifying maximum interval length</p>
</td></tr>
<tr><td><code id="random.intervals_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>M</code> by 2 matrix with start (first column) and end (second column) points of an interval in each row
</p>


<h3>See Also</h3>

<p><code><a href="#topic+not">not</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#*** draw 100 intervals with the endpoints in 1,...,100
intervals &lt;- random.intervals(50, 100)
</code></pre>

<hr>
<h2 id='residuals.not'>Extract residuals from a 'not' object</h2><span id='topic+residuals.not'></span>

<h3>Description</h3>

<p>Returns a difference between <code>x</code> in <code>object</code> and the estimated signal with change-points at <code>cpt</code>.
Type of the signal depends on the value of <code>contrast</code> that has been passed to <code><a href="#topic+not">not</a></code> in order to construct <code>object</code> (see details of <code><a href="#topic+predict.not">predict.not</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'not'
residuals(object, cpt, type = c("raw", "standardised"),
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.not_+3A_object">object</code></td>
<td>
<p>An object of class 'not', returned by <code><a href="#topic+not">not</a></code>.</p>
</td></tr>
<tr><td><code id="residuals.not_+3A_cpt">cpt</code></td>
<td>
<p>An integer vector with locations of the change-points.
If missing, the <code><a href="#topic+features">features</a></code> is called internally to extract the change-points from <code>object</code>.</p>
</td></tr>
<tr><td><code id="residuals.not_+3A_type">type</code></td>
<td>
<p>Choice of &quot;raw&quot; and &quot;standardised&quot;.</p>
</td></tr>
<tr><td><code id="residuals.not_+3A_...">...</code></td>
<td>
<p>Further parameters that can be passed to <code><a href="#topic+predict.not">predict.not</a></code> and <code><a href="#topic+features">features</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type="raw"</code>, the difference between the data and the estimated signal. If <code>type="standardised"</code>, the difference between the data and the estimated signal, divided by the estimated standard deviation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcws.const.sig &lt;- c(rep(0, 100), rep(1,100))
x &lt;- pcws.const.sig + rnorm(100)
w &lt;- not(x, contrast = "pcwsConstMean")
# *** plot residuals obtained via fitting piecewise-constant function with estimated change-points
plot(residuals(w))
# *** plot residuals with obtained via fitting piecewise-constant function with true change-point
plot(residuals(w, cpt=100))
# *** plot standardised residuals
plot(residuals(w, type="standardised"))
</code></pre>

<hr>
<h2 id='sic.penalty'>Schwarz Information Criterion penalty</h2><span id='topic+sic.penalty'></span>

<h3>Description</h3>

<p>The function evaluates the penalty term for Schwarz Information Criterion. 
If <code>alpha</code> is greater than 1,  the strengthen SIC proposed proposed in Fryzlewicz (2014) is calculated. This routine is typically not called directly by the user; 
its name can be passed as an argument to <code><a href="#topic+features">features</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sic.penalty(n, n.param, alpha = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sic.penalty_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="sic.penalty_+3A_n.param">n.param</code></td>
<td>
<p>The number of parameters in the model for which the penalty is evaluated.</p>
</td></tr>
<tr><td><code id="sic.penalty_+3A_alpha">alpha</code></td>
<td>
<p>A scalar greater or equal than one.</p>
</td></tr>
<tr><td><code id="sic.penalty_+3A_...">...</code></td>
<td>
<p>Not in use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the penalty term <code class="reqn">\code{n.param}\times(\log(n))^{\code{alpha}}</code>.
</p>


<h3>References</h3>

<p>R. Baranowski, Y. Chen, and P. Fryzlewicz (2019). Narrowest-Over-Threshold Change-Point Detection.  (<a href="http://stats.lse.ac.uk/fryzlewicz/not/not.pdf">http://stats.lse.ac.uk/fryzlewicz/not/not.pdf</a>)
</p>
<p>P. Fryzlewicz (2014). Wild Binary Segmentation for multiple change-point detection. Annals of Statistics. (<a href="http://stats.lse.ac.uk/fryzlewicz/wbs/wbs.pdf">http://stats.lse.ac.uk/fryzlewicz/wbs/wbs.pdf</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#*** a simple example how to use the AIC penalty
x &lt;- rnorm(300) + c(rep(1,50),rep(0,250))
w &lt;- not(x)
w.cpt &lt;- features(w, penalty="sic")
w.cpt$cpt[[1]]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
