<!DOCTYPE html><html><head><title>Help for package padr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {padr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#center_interval'><p>Shift to the middle of each interval</p></a></li>
<li><a href='#closest_weekday'><p>Retrieve the closest given weekday</p></a></li>
<li><a href='#coffee'><p>Coffee Data Set</p></a></li>
<li><a href='#emergency'><p>Emergency Calls for Montgomery County, PA</p></a></li>
<li><a href='#fill_by_function'><p>Fill missing values by a function of the nonmissings</p></a></li>
<li><a href='#fill_by_prevalent'><p>Fill missing values by the most prevalent nonmissing value</p></a></li>
<li><a href='#fill_by_value'><p>Fill missing values by a single value</p></a></li>
<li><a href='#format_interval'><p>Make a period character vector</p></a></li>
<li><a href='#get_interval'><p>Get the interval of a datetime variable</p></a></li>
<li><a href='#pad'><p>Pad the datetime column of a data frame</p></a></li>
<li><a href='#pad_cust'><p>Pad with a custom spanning</p></a></li>
<li><a href='#pad_int'><p>Pad the integer column of a data frame</p></a></li>
<li><a href='#span_around'><p>Span an equally spaced vector around a datetime variable</p></a></li>
<li><a href='#span_date'><p>Wrapper around <code>seq.Date</code>.</p></a></li>
<li><a href='#span_time'><p>Wrapper around <code>seq.POSIXct</code>.</p></a></li>
<li><a href='#subset_span'><p>Subset a spanned datetime vector</p></a></li>
<li><a href='#thicken'><p>Add a variable of a higher interval to a data frame</p></a></li>
<li><a href='#thicken_cust'><p>Thicken with a custom spanning</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quickly Get Datetime Data Ready for Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Edwin Thoen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edwin Thoen &lt;edwinthoen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Transforms datetime data into a format ready for analysis.
    It offers two core functionalities; aggregating data to a higher level interval
    (thicken) and imputing records where observations were absent (pad). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, dplyr (&ge; 1.0.0), lubridate, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, testthat, knitr, rmarkdown, lazyeval, tidyr,
data.table</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/EdwinTh/padr">https://github.com/EdwinTh/padr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/EdwinTh/padr/issues">https://github.com/EdwinTh/padr/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-23 15:08:44 UTC; edwinthoen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-23 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='center_interval'>Shift to the middle of each interval</h2><span id='topic+center_interval'></span>

<h3>Description</h3>

<p>After thickening all the values are either
shifted to the first or the last value of their interval.
This function creates a vector from <code>x</code>, with the values shifted to
the (approximate) center of the interval. This can give a more accurate
picture of the aggregated data when plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>center_interval(x, shift = c("up", "down"), interval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="center_interval_+3A_x">x</code></td>
<td>
<p>A vector of class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="center_interval_+3A_shift">shift</code></td>
<td>
<p>&quot;up&quot; or &quot;down&quot;.</p>
</td></tr>
<tr><td><code id="center_interval_+3A_interval">interval</code></td>
<td>
<p>The interval to be used for centering. If <code>NULL</code>,
<code>get_interval</code> will be applied on <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interval will be translated to number of days when
<code>x</code> is of class <code>Date</code>, or number of seconds when <code>x</code> is of
class <code>POSIXt</code>. For months and quarters this will be the average
length of the interval. The translated units divided by two
will be added by or subtracted from each value of <code>x</code>.
</p>


<h3>Value</h3>

<p>Vector of the same class as <code>x</code>, with the values shifted to the
(approximate) center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
plot_set &lt;- emergency %&gt;%
  thicken("hour", "h") %&gt;%
  count(h) %&gt;%
  head(24)

ggplot(plot_set, aes(h, n)) + geom_col()

plot_set %&gt;%
  mutate(h_center = center_interval(h)) %&gt;%
  ggplot(aes(h_center, n)) + geom_col()
</code></pre>

<hr>
<h2 id='closest_weekday'>Retrieve the closest given weekday</h2><span id='topic+closest_weekday'></span>

<h3>Description</h3>

<p>Find the closest instance of the requested weekday to <code>min(x)</code>.
Helper function for <code>thicken</code> with the interval &quot;week&quot;, when the user
desires the start day of the weeks to be different from Sundays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest_weekday(x, wday = 1, direction = c("down", "up"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest_weekday_+3A_x">x</code></td>
<td>
<p>A vector of class <code>Date</code>, <code>POSIXct</code>, or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="closest_weekday_+3A_wday">wday</code></td>
<td>
<p>Integer in the range 0-6 specifying the desired weekday start
(0 = Sun, 1 = Mon, 2 = Tue, 3 = Wed, 4 = Thu, 5 = Fri, 6 = Sat).</p>
</td></tr>
<tr><td><code id="closest_weekday_+3A_direction">direction</code></td>
<td>
<p>The first desired weekday before (&quot;down&quot;) or after (&quot;up&quot;)
the first day in <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>Date</code>, reflecting the closest desired weekday
to <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>closest_weekday(coffee$time_stamp)
closest_weekday(coffee$time_stamp, 5)
closest_weekday(coffee$time_stamp, 1, direction = "up")
closest_weekday(coffee$time_stamp, 5, direction = "up")
</code></pre>

<hr>
<h2 id='coffee'>Coffee Data Set</h2><span id='topic+coffee'></span>

<h3>Description</h3>

<p>Made-up data set for demonstrating <code>padr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coffee
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 rows and 2 variables:
</p>

<dl>
<dt>time_stamp</dt><dd><p>YYYY-MM-DD HH:MM:SS</p>
</dd>
<dt>amount</dt><dd><p>Amount spent on coffee</p>
</dd>
</dl>


<hr>
<h2 id='emergency'>Emergency Calls for Montgomery County, PA</h2><span id='topic+emergency'></span>

<h3>Description</h3>

<p>The emergency calls coming in at Montgomery County, PA since 2015-12-10.
Data set was created at 2016-10-17 16:15:40 CEST from the API and contains
events until 2016-10-17 09:47:03 EST. From the original set the columns
desc and e are not included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emergency
</code></pre>


<h3>Format</h3>

<p>A data frame with 120450 rows and 6 variables:
</p>

<dl>
<dt>lat</dt><dd><p>Latitude from Google maps, based on the address</p>
</dd>
<dt>lng</dt><dd><p>Longitude from Google maps, based on the address</p>
</dd>
<dt>zip</dt><dd><p>Zipcode from Google, when possible</p>
</dd>
<dt>title</dt><dd><p>Title, emergency category</p>
</dd>
<dt>time_stamp</dt><dd><p>YYYY-MM-DD HH:MM:SS</p>
</dd>
<dt>twp</dt><dd><p>Township</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://storage.googleapis.com/montco-stats/tzr.csv">https://storage.googleapis.com/montco-stats/tzr.csv</a>
</p>

<hr>
<h2 id='fill_by_function'>Fill missing values by a function of the nonmissings</h2><span id='topic+fill_by_function'></span>

<h3>Description</h3>

<p>For each specified column in <code>x</code> replace the missing values by a
function of the nonmissing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_by_function(x, ..., fun = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_by_function_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fill_by_function_+3A_...">...</code></td>
<td>
<p>The unquoted column names of the variables that should be filled.</p>
</td></tr>
<tr><td><code id="fill_by_function_+3A_fun">fun</code></td>
<td>
<p>The function to apply on the nonmissing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with the altered columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr) # for the pipe operator
x &lt;- seq(as.Date('2016-01-01'), by = 'day', length.out = 366)
x &lt;- x[sample(1:366, 200)] %&gt;% sort
x_df &lt;- data_frame(x  = x,
                   y1 = runif(200, 10, 20) %&gt;% round,
                   y2 = runif(200, 1, 50) %&gt;% round)
x_df %&gt;% pad %&gt;% fill_by_function(y1, y2)
x_df %&gt;% pad %&gt;% fill_by_function(y1, y2, fun = median)
</code></pre>

<hr>
<h2 id='fill_by_prevalent'>Fill missing values by the most prevalent nonmissing value</h2><span id='topic+fill_by_prevalent'></span>

<h3>Description</h3>

<p>For each specified column in <code>x</code> replace the missing values by the most
prevalent nonmissing value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_by_prevalent(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_by_prevalent_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fill_by_prevalent_+3A_...">...</code></td>
<td>
<p>The unquoted column names of the variables that should be filled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with the altered columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr) # for the pipe operator
x &lt;- seq(as.Date('2016-01-01'), by = 'day', length.out = 366)
x &lt;- x[sample(1:366, 200)] %&gt;% sort
x_df &lt;- data_frame(x  = x,
                  y1 = rep(letters[1:3], c(80, 70, 50)) %&gt;% sample,
                  y2 = rep(letters[2:5], c(60, 80, 40, 20)) %&gt;% sample)
x_df %&gt;% pad %&gt;% fill_by_prevalent(y1, y2)
</code></pre>

<hr>
<h2 id='fill_by_value'>Fill missing values by a single value</h2><span id='topic+fill_by_value'></span>

<h3>Description</h3>

<p>Replace all missing values in the specified columns by the same value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_by_value(x, ..., value = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_by_value_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="fill_by_value_+3A_...">...</code></td>
<td>
<p>The unquoted column names of the variables that should be filled.</p>
</td></tr>
<tr><td><code id="fill_by_value_+3A_value">value</code></td>
<td>
<p>The value to replace the missing values by.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>x</code> with the altered columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr) # for the pipe operator
x &lt;- seq(as.Date('2016-01-01'), by = 'day', length.out = 366)
x &lt;- x[sample(1:366, 200)] %&gt;% sort
x_df &lt;- data_frame(x  = x,
                   y1 = runif(200, 10, 20) %&gt;% round,
                   y2 = runif(200, 1, 50) %&gt;% round,
                   y3 = runif(200, 20, 40) %&gt;% round,
                   y4 = sample(letters[1:5], 200, replace = TRUE))
x_padded &lt;- x_df %&gt;% pad
x_padded %&gt;% fill_by_value(y1)
x_df %&gt;% pad %&gt;% fill_by_value(y1, y2, value = 42)
</code></pre>

<hr>
<h2 id='format_interval'>Make a period character vector</h2><span id='topic+format_interval'></span>

<h3>Description</h3>

<p>After applying <code>thicken</code> all the observations of a period are mapped
to a single time point. This function will convert a datetime variable to
a character vector that reflects the period, instead of a single time point.
<code>strftime</code> is used to format the start and the end of the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_interval(
  x,
  start_format = "%Y-%m-%d",
  end_format = start_format,
  sep = " ",
  end_offset = 0,
  units_to_last = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_interval_+3A_x">x</code></td>
<td>
<p>A vector of class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>,
of which the values are unique.</p>
</td></tr>
<tr><td><code id="format_interval_+3A_start_format">start_format</code></td>
<td>
<p>String to format the start values of each period, to be used
in <code>strftime</code>.</p>
</td></tr>
<tr><td><code id="format_interval_+3A_end_format">end_format</code></td>
<td>
<p>String to format the end values of each period, to be used
in <code>strftime</code>.</p>
</td></tr>
<tr><td><code id="format_interval_+3A_sep">sep</code></td>
<td>
<p>Character string that separates the <code>start_format</code> and the
<code>end_format</code>.</p>
</td></tr>
<tr><td><code id="format_interval_+3A_end_offset">end_offset</code></td>
<td>
<p>Units in days if <code>x</code> is <code>Date</code>, or in seconds if
<code>x</code> is <code>POSIXct</code> or <code>POSIXlt</code>.
Will be subtracted from the end of each period.
If 0, the end of the previous period is equal to the start of the next.</p>
</td></tr>
<tr><td><code id="format_interval_+3A_units_to_last">units_to_last</code></td>
<td>
<p>To determine the formatting of the last value in <code>x</code>,
the length of the last period has to be specified. If <code>NULL</code> the
function guesses based on the interval of <code>x</code>.
Specify in days when <code>x</code> is <code>Date</code>, or in seconds when <code>x</code> is
<code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The end of the periods will be determined by the next unique value
in <code>x</code>. It does so without regarding the interval of <code>x</code>. If a specific
interval is desired, <code>thicken</code> and / or <code>pad</code> should first be
applied to create an equally spaced datetime variable.
</p>


<h3>Value</h3>

<p>A character vector showing the interval.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
plot_set &lt;- emergency %&gt;%
  head(500) %&gt;%
  thicken("hour", "h") %&gt;%
  count(h)

# this will show the data on the full hour
ggplot(plot_set, aes(h, n)) + geom_col()

# adding a character to indicate the hours of the interval.
plot_set %&gt;%
  mutate(h_int = format_interval(h, "%H", sep = "-"))
</code></pre>

<hr>
<h2 id='get_interval'>Get the interval of a datetime variable</h2><span id='topic+get_interval'></span>

<h3>Description</h3>

<p>The interval is the highest datetime unit that can explain all instances of a
variable of class <code>Date</code>, class <code>POSIXct</code>, or class <code>POSIXct</code>.
This function will determine what the interval of the variable is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_interval(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_interval_+3A_x">x</code></td>
<td>
<p>A variable of class of class <code>Date</code> or of class <code>POSIXt</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("padr")</code> for more information on intervals.
</p>


<h3>Value</h3>

<p>A character string indicating the interval of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_month &lt;- seq(as.Date('2016-01-01'), as.Date('2016-05-01'), by = 'month')
get_interval(x_month)

x_sec &lt;- seq(as.POSIXct('2016-01-01 00:00:00'), length.out = 100, by = 'sec')
get_interval(x_sec)
get_interval(x_sec[seq(0, length(x_sec), by = 5)])
</code></pre>

<hr>
<h2 id='pad'>Pad the datetime column of a data frame</h2><span id='topic+pad'></span>

<h3>Description</h3>

<p><code>pad</code> will fill the gaps in incomplete datetime variables, by figuring out
what the interval of the data is and what instances are missing. It will insert
a record for each of the missing time points. For all
other variables in the data frame a missing value will be inserted at the padded rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad(
  x,
  interval = NULL,
  start_val = NULL,
  end_val = NULL,
  by = NULL,
  group = NULL,
  break_above = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_+3A_x">x</code></td>
<td>
<p>A data frame containing at least one variable of class <code>Date</code>,
<code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="pad_+3A_interval">interval</code></td>
<td>
<p>The interval of the returned datetime variable.
Any character string that would be accepted by <code>seq.Date()</code> or
<code>seq.POSIXt</code>. The only exceptions is &quot;DSTday&quot;, which is not accepted.
<code>pad</code> will take care of daylight savings time when regular &quot;day&quot; is used.
When NULL the the interval will be equal to the interval of the datetime variable.
When specified it can only be lower than the interval and step size of the input data.
See Details.</p>
</td></tr>
<tr><td><code id="pad_+3A_start_val">start_val</code></td>
<td>
<p>An object of class <code>Date</code>, <code>POSIXct</code> or
<code>POSIXlt</code> that specifies the start of the returned datetime variable.
If NULL it will use the lowest value of the input variable.</p>
</td></tr>
<tr><td><code id="pad_+3A_end_val">end_val</code></td>
<td>
<p>An object of class <code>Date</code>, <code>POSIXct</code> or
<code>POSIXlt</code> that specifies the end of returned datetime variable.
If NULL it will use the highest value of the input variable.</p>
</td></tr>
<tr><td><code id="pad_+3A_by">by</code></td>
<td>
<p>Only needs to be specified when <code>x</code> contains multiple
variables of class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.
Indicates which variable to use for padding.</p>
</td></tr>
<tr><td><code id="pad_+3A_group">group</code></td>
<td>
<p>Optional character vector that specifies the grouping
variable(s). Padding will take place within the different groups. When
interval is not specified, it will be determined applying <code>get_interval</code>
on the datetime variable as a whole, ignoring groups (see last example).</p>
</td></tr>
<tr><td><code id="pad_+3A_break_above">break_above</code></td>
<td>
<p>Numeric value that indicates the number of rows in millions
above which the function will break. Safety net for situations where the
interval is different than expected and padding yields a very large
dataframe, possibly overflowing memory.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The interval of a datetime variable is the time unit at which the
observations occur. The eight intervals in <code>padr</code> are from high to low
<code>year</code>, <code>quarter</code>, <code>month</code>, <code>week</code>, <code>day</code>,
<code>hour</code>, <code>min</code>, and <code>sec</code>. Since <code>padr</code> v.0.3.0 the
interval is no longer limited to be of a single unit.
(Intervals like 5 minutes, 6 hours, 10 days are possible). <code>pad</code> will
figure out the interval of the input variable and the step size, and will
fill the gaps for the instances that would be expected from the interval and
step size, but are missing in the input data.
Note that when <code>start_val</code> and/or <code>end_val</code> are specified, they are
concatenated with the datetime variable before the interval is determined.
</p>
<p>Rows with missing values in the datetime variables will be retained.
However, they will be moved to the end of the returned data frame.
</p>


<h3>Value</h3>

<p>The data frame <code>x</code> with the datetime variable padded. All
non-grouping variables in the data frame will have missing values at the rows
that are padded. The result will always be sorted on the datetime variable.
If <code>group</code> is not <code>NULL</code> result is sorted on grouping variable(s)
first, then on the datetime variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simple_df &lt;- data.frame(day = as.Date(c('2016-04-01', '2016-04-03')),
                        some_value = c(3,4))
pad(simple_df)
pad(simple_df, interval = "day")

library(dplyr) # for the pipe operator
month &lt;- seq(as.Date('2016-04-01'), as.Date('2017-04-01'),
              by = 'month')[c(1, 4, 5, 7, 9, 10, 13)]
month_df &lt;- data.frame(month = month,
                       y = runif(length(month), 10, 20) %&gt;% round)
# forward fill the padded values with tidyr's fill
month_df %&gt;% pad %&gt;% tidyr::fill(y)

# or fill all y with 0
month_df %&gt;% pad %&gt;% fill_by_value(y)

# padding a data.frame on group level
day_var &lt;- seq(as.Date('2016-01-01'), length.out = 12, by = 'month')
x_df_grp &lt;- data.frame(grp1 = rep(LETTERS[1:3], each =4),
                       grp2 = letters[1:2],
                       y    = runif(12, 10, 20) %&gt;% round(0),
                       date = sample(day_var, 12, TRUE)) %&gt;%
 arrange(grp1, grp2, date)

# pad by one grouping var
x_df_grp %&gt;% pad(group = 'grp1')

# pad by two groups vars
x_df_grp %&gt;% pad(group = c('grp1', 'grp2'), interval = "month")

# Using group argument the interval is determined over all the observations,
# ignoring the groups.
x &lt;- data.frame(dt_var = as.Date(c("2017-01-01", "2017-03-01", "2017-05-01",
"2017-01-01", "2017-02-01", "2017-04-01")),
id = rep(1:2, each = 3), val = round(rnorm(6)))
pad(x, group = "id")
# applying pad with do, interval is determined individualle for each group
x %&gt;% group_by(id) %&gt;% do(pad(.))
</code></pre>

<hr>
<h2 id='pad_cust'>Pad with a custom spanning</h2><span id='topic+pad_cust'></span>

<h3>Description</h3>

<p>Pad the datetime variable after <code>thicken_cust</code> is applied, using the same
spanning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_cust(x, spanned, by = NULL, group = NULL, drop_last_spanned = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_cust_+3A_x">x</code></td>
<td>
<p>A data frame containing at least one datetime variable of
class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="pad_cust_+3A_spanned">spanned</code></td>
<td>
<p>A datetime vector to which the the datetime variable in
<code>x</code> should be mapped. See <code>subset_span</code> for quickly spanning
unequally spaced variables.</p>
</td></tr>
<tr><td><code id="pad_cust_+3A_by">by</code></td>
<td>
<p>Only needs to be specified when <code>x</code> contains multiple
variables of class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="pad_cust_+3A_group">group</code></td>
<td>
<p>Optional character vector that specifies the grouping
variable(s). Padding will take place within the different group values.</p>
</td></tr>
<tr><td><code id="pad_cust_+3A_drop_last_spanned">drop_last_spanned</code></td>
<td>
<p>Logical, indicating whether to drop the last value
from <code>spanned</code>. The spanned is typically around the datetime variable.
This would create an empty last record when padding. Setting to <code>TRUE</code>
will drop the last value in <code>spanned</code> and will not create an empty
last record in this situation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame <code>x</code> with the datetime column padded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
# analysis of traffic accidents in traffic jam hours and other hours.
accidents &lt;- emergency %&gt;% filter(title == "Traffic: VEHICLE ACCIDENT -")
spanning &lt;- span_time("20151210 16", "20161017 17", tz = "EST") %&gt;%
  subset_span(list(hour = c(6, 9, 16, 19)))
thicken_cust(accidents, spanning, "period") %&gt;%
  count(period) %&gt;%
  pad_cust(spanning)
</code></pre>

<hr>
<h2 id='pad_int'>Pad the integer column of a data frame</h2><span id='topic+pad_int'></span>

<h3>Description</h3>

<p><code>pad_int</code> fills the gaps in incomplete integer variables. It will insert
a record for each of the missing value. For all
other variables in the data frame a missing value will be inserted at the
padded rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_int(x, by, start_val = NULL, end_val = NULL, group = NULL, step = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_int_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="pad_int_+3A_by">by</code></td>
<td>
<p>The column to be padded.</p>
</td></tr>
<tr><td><code id="pad_int_+3A_start_val">start_val</code></td>
<td>
<p>The first value of the returned variable. If NULL it will
use the lowest value of the input variable.</p>
</td></tr>
<tr><td><code id="pad_int_+3A_end_val">end_val</code></td>
<td>
<p>The last value of the returned variable. If NULL it will use
the highest value of the input variable.</p>
</td></tr>
<tr><td><code id="pad_int_+3A_group">group</code></td>
<td>
<p>Optional character vector that specifies the grouping
variable(s). Padding will take place within the different group values.</p>
</td></tr>
<tr><td><code id="pad_int_+3A_step">step</code></td>
<td>
<p>The step size of the returned variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame <code>x</code> with the specified variable padded. All
non-grouping variables in the data frame will have missing values at the rows
that are padded.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>int_df &lt;- data.frame(x = c(2005, 2007, 2008, 2011),
                     val = c(3, 2, 6, 3))
pad_int(int_df, 'x')
pad_int(int_df, 'x', start_val = 2006, end_val = 2013)

int_df2 &lt;- data.frame(x = c(2005, 2015), val = c(3, 4))
pad_int(int_df2, 'x', step = 2)
pad_int(int_df2, 'x', step = 5)

int_df3 &lt;- data.frame(x = c(2005, 2006, 2008, 2006, 2007, 2009),
                      g = rep(LETTERS[1:2], each = 3),
                      val = c(6, 6, 3, 5, 4, 3))
pad_int(int_df3, 'x', group = 'g')
pad_int(int_df3, 'x', group = 'g', start_val = 2005, end_val = 2009)
</code></pre>

<hr>
<h2 id='span_around'>Span an equally spaced vector around a datetime variable</h2><span id='topic+span_around'></span>

<h3>Description</h3>

<p>Span a vector of specified interval around a variable of class <code>Date</code>,
<code>POSIXct</code>, or <code>POSIXlt</code>..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>span_around(x, interval, start_shift = NULL, end_shift = start_shift)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="span_around_+3A_x">x</code></td>
<td>
<p>A vector of class <code>Date</code>, <code>POSIXct</code>, or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="span_around_+3A_interval">interval</code></td>
<td>
<p>Character, specifying the desired interval.</p>
</td></tr>
<tr><td><code id="span_around_+3A_start_shift">start_shift</code></td>
<td>
<p>Character, indicating the time to shift
back from the first observation.</p>
</td></tr>
<tr><td><code id="span_around_+3A_end_shift">end_shift</code></td>
<td>
<p>Character, indicating the time to shift
forward from the last observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that use of the <code>start_shift</code> and <code>end_shift</code>
arguments change the entire spanning when they are not in line with
the interval. It is not checked for.
</p>


<h3>Value</h3>

<p>A datetime vector, with the first observation smaller or equal than
<code>min(x)</code> and the last observation larger or equal than <code>max(x)</code>.
Spaces between points are equal to <code>interval</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>span_around(coffee$time_stamp, "hour")
span_around(coffee$time_stamp, "hour", end_shift = "2 hour")
span_around(coffee$time_stamp, "2 day")
span_around(coffee$time_stamp, "2 day", start_shift = "2 day")
span_around(emergency$time_stamp, "week")
span_around(emergency$time_stamp, "2 month")
</code></pre>

<hr>
<h2 id='span_date'>Wrapper around <code>seq.Date</code>.</h2><span id='topic+span_date'></span>

<h3>Description</h3>

<p>Quickly create a sequence of dates from minimal specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>span_date(from, to = NULL, len_out = NULL, by = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="span_date_+3A_from">from</code></td>
<td>
<p>Integer or character of length 4 (yyyy), 6 (yyyymm), or 8
(yyymmdd). Indicating the start value of the sequence.</p>
</td></tr>
<tr><td><code id="span_date_+3A_to">to</code></td>
<td>
<p>Integer or character of length 4 (yyyy), 6 (yyyymm), or 8
(yyymmdd). Optional.</p>
</td></tr>
<tr><td><code id="span_date_+3A_len_out">len_out</code></td>
<td>
<p>The desired length of the sequence. Optional.</p>
</td></tr>
<tr><td><code id="span_date_+3A_by">by</code></td>
<td>
<p>The desired interval. Optional.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimal specification of dates, sets unspecified date parts to
default values. These are 01 for both month and day.
</p>
<p>In addition to <code>from</code>, either <code>to</code> or <code>len_out</code> must be specified.
If <code>by</code> is not specified, <code>span_date</code> will set the interval to the
highest of the specified date parts in either <code>from</code> or <code>to</code>.
For example, if they are 2011 and 2015 it will be &quot;year&quot;, if they are 2011
and 201501 it will be &quot;month&quot;.
</p>


<h3>Value</h3>

<p>An object of class Date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using "to" argument
span_date(2011, 2015)
span_date(201101, 201501)
span_date(2011, 2015, by = "month")
span_date(2011, 201501)
span_date(20111225, 2012)

# using "len_out" argument
span_date(2011, len_out = 4)
span_date(201101, len_out = 4)
span_date(20110101, len_out = 4)
span_date(20110101, len_out = 4, by = "month")
</code></pre>

<hr>
<h2 id='span_time'>Wrapper around <code>seq.POSIXct</code>.</h2><span id='topic+span_time'></span>

<h3>Description</h3>

<p>Quickly create a sequence of datetimes from minimal specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>span_time(from, to = NULL, len_out = NULL, by = NULL, tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="span_time_+3A_from">from</code></td>
<td>
<p>Integer or character of length 4 (yyyy), 6 (yyyymm), or 8 (
yyymmdd). Character of length 11 (yyyymmdd hh), 13 (yyyymmdd hhmm), or 15 (
yyyymmdd hhmmss). Indicating the start value of the sequence.</p>
</td></tr>
<tr><td><code id="span_time_+3A_to">to</code></td>
<td>
<p>Integer or character of length 4 (yyyy), 6 (yyyymm), or 8 (
yyymmdd). Character of length 11 (yyyymmdd hh), 13 (yyyymmdd hhmm), or 15 (
yyyymmdd hhmmss). Indicating the end value of the sequence. Optional.</p>
</td></tr>
<tr><td><code id="span_time_+3A_len_out">len_out</code></td>
<td>
<p>The desired length of the sequence. Optional.</p>
</td></tr>
<tr><td><code id="span_time_+3A_by">by</code></td>
<td>
<p>The desired interval. Optional.</p>
</td></tr>
<tr><td><code id="span_time_+3A_tz">tz</code></td>
<td>
<p>The desired timezone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimal specification of datetimes, sets unspecified date parts to
default values. These are 01 for both month and day and 00 for hour, minute,
and second.
</p>
<p>In addition to <code>from</code>, either <code>to</code> or <code>length</code> must be specified.
If the <code>by</code> is not specified, <code>span_time</code> will set the interval to
the highest of the specified datetime parts in either <code>from</code> or
<code>to</code>. For example, if they are &quot;20160103 01&quot; and &quot;20160108 05&quot; it will
be &quot;hour&quot;, if they are &quot;2011&quot; and &quot;20110101 021823&quot; it will be &quot;second&quot;.
</p>


<h3>Value</h3>

<p>An object of class POSIXct.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using to
span_time(2011, 2013)
span_time("2011", "2013")
span_time(2011, 201301)
span_time(2011, 20130101)
span_time(2011, "20110101 0023")
span_time(2011, "20110101 002300")

# using len_out
span_time(2011, len_out = 3)
span_time("2011", len_out = 3)
span_time(2011, len_out = 10, by = "month")
span_time(2011, len_out = 10, by = "day")
span_time(2011, len_out = 10, by = "hour")
span_time("20110101 00", len_out = 10)
span_time("20110101 002300", len_out = 10)

</code></pre>

<hr>
<h2 id='subset_span'>Subset a spanned datetime vector</h2><span id='topic+subset_span'></span>

<h3>Description</h3>

<p>Take a <code>Date</code>, <code>POSIXct</code>, or <code>POSIXlt</code> vector and subset it by
a pattern of date and/or time parts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_span(spanned, pattern_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_span_+3A_spanned">spanned</code></td>
<td>
<p>A vector of class  <code>Date</code>, <code>POSIXct</code>, or
<code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="subset_span_+3A_pattern_list">pattern_list</code></td>
<td>
<p>A list with the desired pattern for each of the following
datetime parts: year, mon, mday, wday, hour, min, sec.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For subsetting weekdays, they run from 0 (Sunday) to 6 (Saturday).
</p>


<h3>Value</h3>

<p>Vector of the same class as <code>spanned</code>, containing all the data points in
<code>spanned</code> that meets the requirements in <code>pattern_list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>date_span &lt;- span_date(20170701, len_out = 100)
subset_span(date_span, list(wday = 1:5))

time_span &lt;- span_time("20170101 00", 201702)
subset_span(time_span, list(hour = 7:17))
subset_span(time_span, list(hour = c(10, 16), mday = seq(5, 30, 5)))
</code></pre>

<hr>
<h2 id='thicken'>Add a variable of a higher interval to a data frame</h2><span id='topic+thicken'></span>

<h3>Description</h3>

<p>Take the datetime variable in a data frame and map this
to a variable of a higher interval. The mapping is added to the data frame
in a new variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thicken(
  x,
  interval,
  colname = NULL,
  rounding = c("down", "up"),
  by = NULL,
  start_val = NULL,
  drop = FALSE,
  ties_to_earlier = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thicken_+3A_x">x</code></td>
<td>
<p>A data frame containing at least one datetime variable of
class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="thicken_+3A_interval">interval</code></td>
<td>
<p>The interval of the added datetime variable.
Any character string that would be accepted by <code>seq.Date</code> or
<code>seq.POSIXt</code>. It can only be higher than the interval and step size of
the input data.</p>
</td></tr>
<tr><td><code id="thicken_+3A_colname">colname</code></td>
<td>
<p>The column name of the added variable. If <code>NULL</code> it will
be the name of the original datetime variable with the interval name added to
it (including the unit), separated by underscores.</p>
</td></tr>
<tr><td><code id="thicken_+3A_rounding">rounding</code></td>
<td>
<p>Should a value in the input datetime variable be mapped to
the closest value that is lower (<code>down</code>) or that is higher (<code>up</code>)
than itself.</p>
</td></tr>
<tr><td><code id="thicken_+3A_by">by</code></td>
<td>
<p>Only needs to be specified when <code>x</code> contains multiple
variables of class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.
Indicates which to use for thickening.</p>
</td></tr>
<tr><td><code id="thicken_+3A_start_val">start_val</code></td>
<td>
<p>By default the first instance of <code>interval</code> that is lower
than the lowest value of the input datetime variable, with all time units on
default value. Specify <code>start_val</code> as an offset if you want the range
to be nonstandard.</p>
</td></tr>
<tr><td><code id="thicken_+3A_drop">drop</code></td>
<td>
<p>Should the original datetime variable be dropped from the
returned data frame? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="thicken_+3A_ties_to_earlier">ties_to_earlier</code></td>
<td>
<p>By default when the original datetime observations is
tied with a value in the added datetime variable, it is assigned to the
current value when rounding is down or to the next value when rounding
is up. When <code>TRUE</code> the ties will be assigned to the previous observation
of the new variable instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the datetime variable contains missing values, they are left
in place in the dataframe. The added column with the new datetime variable,
will have a missing values for these rows as well.
</p>
<p>See <code>vignette("padr")</code> for more information on <code>thicken</code>.
See <code>vignette("padr_implementation")</code> for detailed information on
daylight savings time, different timezones, and the implementation of
<code>thicken</code>.
</p>


<h3>Value</h3>

<p>The data frame <code>x</code> with the variable added to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hour &lt;- seq(lubridate::ymd_hms('20160302 000000'), by = 'hour',
              length.out = 200)
some_df &lt;- data.frame(x_hour = x_hour)
thicken(some_df, 'week')
thicken(some_df, 'month')
thicken(some_df, 'day', start_val = lubridate::ymd_hms('20160301 120000'))

library(dplyr)
x_df &lt;- data.frame(
  x = seq(lubridate::ymd(20130101), by = 'day', length.out = 1000) %&gt;%
    sample(500),
  y = runif(500, 10, 50) %&gt;% round) %&gt;%
  arrange(x)

# get the max per month
x_df %&gt;% thicken('month') %&gt;% group_by(x_month) %&gt;%
  summarise(y_max = max(y))

# get the average per week, but you want your week to start on Mondays
# instead of Sundays
x_df %&gt;% thicken('week',
                 start_val = closest_weekday(x_df$x, 2)) %&gt;%
  group_by(x_week) %&gt;% summarise(y_avg = mean(y))

# rounding up instead of down
x &lt;- data.frame(dt = lubridate::ymd_hms('20171021 160000',
                                        '20171021 163100'))
thicken(x, interval = "hour", rounding = "up")
thicken(x, interval = "hour", rounding = "up", ties_to_earlier = TRUE)
</code></pre>

<hr>
<h2 id='thicken_cust'>Thicken with a custom spanning</h2><span id='topic+thicken_cust'></span>

<h3>Description</h3>

<p>Like <code>thicken</code>, it will find the datetime variable in <code>x</code>
and add a variable of a higher periodicity to it. However, the variable to
which to map the observation is provided by the user. This enables mapping to
time points that are unequally spaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thicken_cust(x, spanned, colname, by = NULL, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thicken_cust_+3A_x">x</code></td>
<td>
<p>A data frame containing at least one datetime variable of
class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.</p>
</td></tr>
<tr><td><code id="thicken_cust_+3A_spanned">spanned</code></td>
<td>
<p>A datetime vector to which the the datetime variable in
<code>x</code> should be mapped.</p>
</td></tr>
<tr><td><code id="thicken_cust_+3A_colname">colname</code></td>
<td>
<p>Character, the column name of the added variable.</p>
</td></tr>
<tr><td><code id="thicken_cust_+3A_by">by</code></td>
<td>
<p>Only needs to be specified when <code>x</code> contains multiple
variables of class <code>Date</code>, <code>POSIXct</code> or <code>POSIXlt</code>.
Indicates which to use for thickening.</p>
</td></tr>
<tr><td><code id="thicken_cust_+3A_drop">drop</code></td>
<td>
<p>Should the original datetime variable be dropped from the
returned data frame? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only rounding down is available for custom thickening.
</p>


<h3>Value</h3>

<p>The data frame <code>x</code> with the variable added to it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
# analysis of traffic accidents in traffic jam hours and other hours.
accidents &lt;- emergency %&gt;% filter(title == "Traffic: VEHICLE ACCIDENT -")
spanning &lt;- span_time("20151210 16", "20161017 17", tz = "EST") %&gt;%
  subset_span(list(hour = c(6, 9, 16, 19)))
thicken_cust(accidents, spanning, "period") %&gt;%
  count(period) %&gt;%
  pad_cust(spanning)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
