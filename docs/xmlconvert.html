<!DOCTYPE html><html lang="en"><head><title>Help for package xmlconvert</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xmlconvert}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#df_to_xml'><p>Converting XML to data frames and vice versa</p></a></li>
<li><a href='#xml_to_df'><p>Converting XML to data frames and vice versa</p></a></li>
<li><a href='#xml_to_list'><p>Converting XML documents to lists</p></a></li>
<li><a href='#xmlconvert'><p>Package 'xmlconvert'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Comfortably Converting XML Documents to Dataframes and Vice
Versa</td>
</tr>
<tr>
<td>Description:</td>
<td>Converts XML documents to R dataframes and dataframes to XML documents.
  A wide variety of options allows for different XML formats and flexible control
  of the conversion process. Results can be exported to CSV and Excel, if desired. 
  Also converts XML data to R lists.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joachim Zuckarelli &lt;joachim@zuckarelli.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>xml2, stringr, readr, tibble, httr, utils, lubridate</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xlsx</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jsugarelli/xmlconvert/issues">https://github.com/jsugarelli/xmlconvert/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jsugarelli/xmlconvert/">https://github.com/jsugarelli/xmlconvert/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-25 21:01:55 UTC; zucka</td>
</tr>
<tr>
<td>Author:</td>
<td>Joachim Zuckarelli
    <a href="https://orcid.org/0000-0002-9280-3016"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-27 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='df_to_xml'>Converting XML to data frames and vice versa</h2><span id='topic+df_to_xml'></span>

<h3>Description</h3>

<p>Converts dataframes to XML documents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_xml(
  df,
  fields = "tags",
  record.tag = "record",
  field.names = NULL,
  only.fields = NULL,
  exclude.fields = NULL,
  root.node = "root",
  xml.file = NULL,
  non.exist = NULL,
  encoding = "UTF-8",
  no.return = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df_to_xml_+3A_df">df</code></td>
<td>
<p>Dataframe to be converted to XML</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_fields">fields</code></td>
<td>
<p>A character value, either <code>"tags"</code> or <code>"attributes"</code>.
Specifies whether the fields of each data record will be represented in the
resulting XML document by XML tags or by attributes. See the <em>Details</em>
section of <code><a href="#topic+df_to_xml">df_to_xml</a>()</code> for more on this topic. Default is
<code>"tags"</code></p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_record.tag">record.tag</code></td>
<td>
<p>Name of the tags that will represent the data records in
the resulting XML (i.e. each record has one element with this tag name).</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_field.names">field.names</code></td>
<td>
<p>Names of the fields in the XML file. If <code>NULL</code> then
the variable names from the dataframe are used. Field names are corrected
automatically to comply with XML naming requirements.</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_only.fields">only.fields</code></td>
<td>
<p>Optional vector variable names from the dataframe that
will be included in the XML document. If <code>NULL</code> then all fields from
the dataframe are included in the XML document.</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_exclude.fields">exclude.fields</code></td>
<td>
<p>Optional vector of variable names from the dataframe
that will not be included in the XML document.</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_root.node">root.node</code></td>
<td>
<p>A character value with the desired name of the root element
of the XML document; <code>"root"</code> by default.</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_xml.file">xml.file</code></td>
<td>
<p>Name of a file the XML document it written to. If <code>NULL</code>
no file will be created.</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_non.exist">non.exist</code></td>
<td>
<p>Value that will be written into the XML document as field
value in case the respective element in the dataframe is <code>NA</code>. If
<code>NULL</code>, which is the default, no XML tag/attribute (depennding on the
<code>fields</code> argument) will be created for this dataframe element. Using a
non-<code>NULL</code> value for <code>non-exist</code> allows to make sure that each
data record tag in the XML document has exactly the same structure even if
some values may be empty (because they are <code>NA</code> in the original data)</p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_encoding">encoding</code></td>
<td>
<p>Encoding of the XML document; default is <code>"UTF-8"</code></p>
</td></tr>
<tr><td><code id="df_to_xml_+3A_no.return">no.return</code></td>
<td>
<p>Logical option to prevent <code>df_to_xml()</code> from returning
the XML document it creates; use this if you are only interested in saving
the XML document to a file using the <code>xml.file</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting XML document that be edited with the functions from the
<span class="pkg">xml2</span> package. There is no return value if the <code>no.return</code>
argument is set to <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other xmlconvert: 
<code><a href="#topic+xml_to_df">xml_to_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a dataframe
soccer.worldcups &lt;- data.frame(list(year=c(2014, 2010, 2006),
    location=c("Brazil", "South Africa", "Germany"),
    goals_scored=c(171, 145, 147),
    average_goals=c(2.7, 2.3, 2.4),
    average_attendance=c(57918, 49669,52491)),
    stringsAsFactors = FALSE)

# Convert to XML with the fields (i.e. dataframe variables/columns) stored in XML tags
xml &lt;- df_to_xml(soccer.worldcups, fields="tags", record.tag = "worldcup")

# Convert to XML with the fields (i.e. dataframe variables/columns) stored in attributes
xml &lt;- df_to_xml(soccer.worldcups, fields="tags", record.tag = "worldcup")

</code></pre>

<hr>
<h2 id='xml_to_df'>Converting XML to data frames and vice versa</h2><span id='topic+xml_to_df'></span>

<h3>Description</h3>

<p><code>xml_to_df()</code> converts XML data to a dataframe. It
provides a lot of flexibility with its arguments but can usually be
used with just a couple of them to achieve the desired results. See the
examples below for simple applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_df(
  file = NULL,
  text = NULL,
  first.records = NULL,
  xml.encoding = "",
  records.tags = NULL,
  records.xpath = NULL,
  fields = "tags",
  field.names = NULL,
  only.fields = NULL,
  exclude.fields = NULL,
  check.datatypes = TRUE,
  data.dec = ".",
  data.thds = ",",
  stringsAsFactors = FALSE,
  na = NA,
  non.exist = na,
  no.hierarchy = FALSE,
  hierarchy.field.delim = "|",
  hierarchy.value.sep = "~",
  no.return = FALSE,
  excel.filename = NULL,
  excel.sheetname = NULL,
  excel.pw = NULL,
  csv.filename = NULL,
  csv.sep = ",",
  csv.dec = ".",
  csv.encoding = "",
  strip.ns = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xml_to_df_+3A_file">file</code></td>
<td>
<p>XML file to be converted. Instead of specifying a file, the XML
code can put in directly via the <code>text</code> argument,</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_text">text</code></td>
<td>
<p>XML code to be converted. Instead of providing the XML code, an
XML file can be specified with the <code>file</code> argument.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_first.records">first.records</code></td>
<td>
<p>Number of records to be converted. If <code>NULL</code>
(default) all records will be converted.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_xml.encoding">xml.encoding</code></td>
<td>
<p>Encoding of the XML file (optional), e.g. (<code>"UTF-8"</code>)</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_records.tags">records.tags</code></td>
<td>
<p>Name (or vector of names) of the tags that represent the
data records in the XML (i.e. each record has one element with this tag
name). All elements with this tag name will be considered data records.
Instead of specifying the tag name, an XPatch expression can be used to
identify the data records (see <code>records.xpath</code>)</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_records.xpath">records.xpath</code></td>
<td>
<p>XPath expression that specifies the XML element to be
selected as data records; can be used instead of specifying the data record
XML tags directly with the <code>data.records</code> argument. If both,
<code>records.tags</code> and <code>records.path</code> are provided, only the XPath
expressions determines the tags to be selected.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_fields">fields</code></td>
<td>
<p>A character value, either <code>"tags"</code> or <code>"attributes"</code>.
Specifies whether the fields of each data record are represented as XML tags
or as attributes. See <em>Details</em> below for more on this topic. Default
is <code>"tags"</code></p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_field.names">field.names</code></td>
<td>
<p>If the data fields are represented by XML elements/tags
(i.e. <code>fields = "tags"</code>) and it is not the tag name that identifies the
name of the data field but an attribute of that field tag then the name of
the attribute that provides the field name can be specified here. If
<code>NULL</code>, the tag names will be used as field names. See <em>Details</em>
for more information.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_only.fields">only.fields</code></td>
<td>
<p>Optional vector of tag or attribute names (depending on the
<code>fields</code> argument) of an XML record that will be included in the
resulting dataframe. <code>NULL</code> means all fields found in the data will end
up as columns in the dataframe.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_exclude.fields">exclude.fields</code></td>
<td>
<p>Optional vector of fields that will be excluded from the
conversion; fields specified here will not end up as columns in the
resulting dataframe</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_check.datatypes">check.datatypes</code></td>
<td>
<p>Logical option that specifies if <code>xml_to_df()</code>
tries to identify the data types of the fields in the XML data. If
<code>TRUE</code> (default), <code>xml_to_df()</code> tries to identify numeric fields
and changes the class of the respective columns in the resulting dataframe
accordingly. Use the <code>data.dec</code> and <code>data.thds</code> arguments to
specify a number format different from the standard US/EN scheme. At this
point, there is no data type identification for logical and time/date values
available. If <code>check.datatypes</code> equals <code>FALSE</code> then all variables
in the resulting dataframe will be of class <code>character</code></p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_data.dec">data.dec</code></td>
<td>
<p>A decimal separator used in the identification of numeric data
when <code>check.datatypes = TRUE</code>. Default is dot (<code>.</code>)</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_data.thds">data.thds</code></td>
<td>
<p>A thousands separator used in the identification of numeric
data when <code>check.datatypes = TRUE</code>. Default is comma (<code>,</code>)</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Logical option specifying if character values will be
converted to factors in the resulting data frame. Is only applied if
<code>check.datatypes = TRUE</code> which is the default</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_na">na</code></td>
<td>
<p>Value that will be put into the resulting dataframe if the XML data
field is <em>empty</em>. Default is <code>NA</code>. If a data record in the XML
does not have a specific field at all it is filled with the value provided
via the <code>non.exist</code> argument</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_non.exist">non.exist</code></td>
<td>
<p>Value that will be put into the resulting dataframe if a data
record in the XML data does not have a specific field at all. Default is the
value of the <code>na</code> (the default of which is <code>NA</code>). If instead a
field is present in the XML data but empty, then it will have the value of
the <code>na</code> argument in the resulting data frame</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_no.hierarchy">no.hierarchy</code></td>
<td>
<p>If the fields in the XML data are represented by XML
elements/tags (i.e. argument <code>fields = "tags"</code>) and there is a
hierarchical structure below a data field element then this hierarchical
structure gets 'flattened', i.e. it will be represented by a single
character value. See <em>Details</em> for an example</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_hierarchy.field.delim">hierarchy.field.delim</code></td>
<td>
<p>One or two-element character vector specifying
the tag delimiters used when 'flattening' a hierarchy in the XML data. If
only one delimiter is specified then this delimiter will be used for both,
the beginning of the tag and the end of the tag. See <em>Details</em> for an
example</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_hierarchy.value.sep">hierarchy.value.sep</code></td>
<td>
<p>Character value that is used as the separator
between the tag name and the value of the tag when 'flattening' a hierarchy
in the XML data. See <em>Details</em> for an example</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_no.return">no.return</code></td>
<td>
<p>Logical option to prevent <code>xml_to_df()</code> from returning
the dataframe it creates; use this if you are only interested in saving the
dataframe as Excel or CSV.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_excel.filename">excel.filename</code></td>
<td>
<p>Name of an Excel file the resulting dataframe will be
exported to. If <code>NULL</code> (default) there will be no Excel export.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_excel.sheetname">excel.sheetname</code></td>
<td>
<p>Name of the worksheet the resulting dataframe will be
exported to when using the Excel export via the <code>excel.filename</code>
argument. If <code>NULL</code>, <code>xml_to_df()</code> will figure out a name,</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_excel.pw">excel.pw</code></td>
<td>
<p>Password that is applied to the Excel workbook when the
resulting data.frame is exported via the <code>excel.filename</code> argument.
Default NULL means the workbook will not be protected with a password</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_csv.filename">csv.filename</code></td>
<td>
<p>Name of a CSV file the resulting dataframe will be
exported to. If <code>NULL</code> there will be no CSV export.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_csv.sep">csv.sep</code></td>
<td>
<p>Separator used to separate fields in the CSV file when
exporting the resulting dataframe via the <code>csv.filename</code> argument.
Default is comma (<code>","</code>)</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_csv.dec">csv.dec</code></td>
<td>
<p>Decimal separator used when exporting the resulting dataframe
via the <code>csv.filename</code> argument, Default is dot (<code>.</code>)</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_csv.encoding">csv.encoding</code></td>
<td>
<p>Text encoding used when exporting the resulting dataframe
via the <code>csv.filename</code> argument</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_strip.ns">strip.ns</code></td>
<td>
<p>Logical option that can be used to strip the namespaces from
the XML data. Default is <code>FALSE</code>. Try this if parsing of your XML data
fails and namespaces are present in your data. Please note: Removing the
namespaces from the XML data may increase the time needed for parsing.</p>
</td></tr>
<tr><td><code id="xml_to_df_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on the <code>write.table()</code> when
exporting the resulting dataframe via the <code>csv.filename</code> argument,
Default is dot (<code>.</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This section provides some more details on how <code>xml_to_df()</code>
works with different ways of representing data fields in the XML (tags
versus attributes) and on working with nested XML field structures.<br /><br />
</p>


<h4>Two ways of representing the data: Tags and attributes</h4>

<p> For
<code>xml_to_df()</code> records are always represented by tags (i.e XML
elements). Data fields within a record, however, can be represented by
either tags or attributes.<br /><br /> In the former case the XML would like like
this:<br /> <code> &lt;xml&gt;</code> <br /> <code>....&lt;record&gt;</code> <br />
<code>........&lt;field1&gt;Value 1-1&lt;/field1&gt;</code> <br /> <code>........&lt;field2&gt;Value
 1-2&lt;/field2&gt;</code> <br /> <code>....&lt;/record&gt;</code> <br /> <code>....&lt;record&gt;</code> <br />
<code>........&lt;field1&gt;Value 2-1&lt;/field1&gt;</code> <br /> <code>........&lt;field2&gt;Value
 2-2&lt;/field2&gt;</code> <br /> <code>....&lt;/record&gt;</code> <br /> <code>....&lt;/xml&gt;</code> <br /><br /> Here,
each data field is represented by its own tag (e.g. <code>field1</code>). In this
case the <code>records.tag</code> argument would need to be <code>"record"</code> (or we
would specify an XPath expression with <code>records.xpath</code> that selects
these elements) as this is the name of the tags that carry the data records;
the <code>fields</code> argument would need to be <code>"tags"</code> because the actual
data fields are represented by tags nested into the record elements.<br /> A
variant of this case would be if the fields are represented by tags but the
field names are not the tag names but are provided by some attribute of
these tags. This is the case in the following example:<br /> <code> &lt;xml&gt;</code> <br />
<code>....&lt;record&gt;</code> <br /> <code>........&lt;data name="field1"&gt;Value 1-1&lt;/data&gt;</code>
<br /> <code>........&lt;data name="field2"&gt;Value 1-2&lt;/data&gt;</code> <br />
<code>....&lt;/record&gt;</code> <br /> <code>....&lt;record&gt;</code> <br /> <code>........&lt;data
 name="field1"&gt;Value 2-1&lt;/data&gt;</code> <br /> <code>........&lt;data name"field2"&gt;Value
 2-2&lt;/data&gt;</code> <br /> <code>....&lt;/record&gt;</code> <br /> <code>....&lt;/xml&gt;</code> <br /><br />  Here, we
would use the optional <code>field.names</code> argument to tell
<code>xml_to_df()</code> with <code>field.names = "name"</code> that each data tag has
an attribute called <code>"name"</code> that specifies the field name for this
data field tag.<br /><br /> In contrast to these cases, data fields can also be
represented by attributes of the record:<br /> <code>&lt;xml&gt;</code><br />
<code>....&lt;record field1="Value 1-1" field2="Value 1-2" /&gt;</code><br />
<code>....&lt;record field1="Value 2-1" field2="Value 2-2" /&gt;</code><br />
<code>&lt;/xml&gt;</code><br /> Here would need to change the <code>fields</code> argument to
<code>"attributes"</code>.</p>
 

<h4>Working with the nested field values</h4>

<p>When data fields are represented by XML elements / tag then there may nested
structures beneath them. If the <code>no.hierarchy</code> argument is <code>FALSE</code>
(default) this nested structure within a field is recursively analyzed and
represented in a single character value for this field. Each nested element
is enclosed in the delimiters provided with the <code>hierarchy.field.delim</code>
argument. By default, there is only one such delimiter (and that is
<code>"|"</code>) which is used mark both, the start and the end of an element in
the resulting value. However, it is possible to specify to different symbols
in order to distinguish start and end of an element. The
<code>hierarchy.value.sep</code> argument is the symbol that separates the name of
the argument from its value. Consider the following example:<br /><br />
<code>&lt;xml&gt;</code><br /> <code>....&lt;ship&gt;</code><br /> <code>........&lt;name&gt;Excelsior&lt;name&gt;</code><br />
<code>........&lt;lastcaptain&gt;Hikaru Sulu&lt;/lastcaptain&gt;</code><br />
<code>....&lt;/ship&gt;</code><br /> <code>....&lt;ship&gt;</code><br /> <code>........One proud ship
 name, many captains</code><br /> <code>........&lt;name&gt;Enterprise&lt;name&gt;</code><br />
<code>........&lt;lastcaptain&gt;</code><br /> <code>............&lt;NCC-1701-A&gt;James Tiberius
 Kirk&lt;/NCC-1701-A&gt;</code><br /> <code>............&lt;NCC-1701-B&gt;John
 Harriman&lt;/NCC-1701-B&gt;</code><br /> <code>............&lt;NCC-1701-C&gt;Rachel
 Garrett&lt;/NCC-1701-C&gt;</code><br /> <code>............&lt;NCC-1701-D&gt;Jean-Luc
 Picard&lt;/NCC-1701-D&gt;</code><br /> <code>........&lt;/lastcaptain&gt;</code><br />
<code>....&lt;/ship&gt;</code><br /> <code>&lt;/xml&gt;</code><br /><br /> Calling <code>xml_to_df()</code> with
the default values for <code>hierarchy.field.delim</code> and
<code>hierarchy.value.sep</code> would result in the following value of the
<code>lastcapatin</code> field for the <code>Enterprise</code> record:<br /> <code>One
 proud name, many captains|NCC-1701-A~James Tiberius Kirk||NCC-1701-B~John
 Harriman||NCC-1701-C~Rachel Garrett||NCC-1701-D~Jean-Luc Picard|</code><br /><br /> If
we would use <code>hierarchy.field.delim = c("[", "]")</code> then we would better
see the start and of end of each element:<br /> <code>One proud name, many
 captains[NCC-1701-A~James Tiberius Kirk][NCC-1701-B~John
 Harriman][NCC-1701-C~Rachel Garrett][NCC-1701-D~Jean-Luc Picard]</code> </p>



<h3>Value</h3>

<p>The resulting dataframe. There is no return value if the
<code>no.return</code> argument is set to <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p>Other xmlconvert: 
<code><a href="#topic+df_to_xml">df_to_xml</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data used: World population figures from the United Nations Statistics Division

# Read in the raw XML; two versions: one with data fields as XML
# elements/tags, one with data fields as attributes
example.tags &lt;- system.file("worldpopulation_tags.xml", package="xmlconvert")
example.attr &lt;- system.file("worldpopulation_attr.xml", package="xmlconvert")

# Convert XML data to dataframe
worldpop.tags &lt;- xml_to_df(text = example.tags, records.tags = c("record"),
    fields = "tags", field.names = "name")
worldpop.attr &lt;- xml_to_df(text = example.attr, records.tags = c("record"),
    fields = "attributes")

</code></pre>

<hr>
<h2 id='xml_to_list'>Converting XML documents to lists</h2><span id='topic+xml_to_list'></span>

<h3>Description</h3>

<p>Converts XML documents to lists. Uses the
<code><a href="xml2.html#topic+as_list">as_list()</a></code> function from the
<code>xml2</code> package but improves its output. As an effect, numbers, dates
and times are converted correctly, unnecessary nested sub-lists with only
element are avoided, and empty XML nodes can be removed altogether. This
makes the resulting list look cleaner and better structured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xml_to_list(
  xml,
  cleanup = TRUE,
  convert.types = TRUE,
  dec = ".",
  thsd = ",",
  num.replace = "",
  datetime.formats = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xml_to_list_+3A_xml">xml</code></td>
<td>
<p>XML document to be converted. Can be read in from a file using
<code>xml2</code>'s <code>read_xml()</code> function.</p>
</td></tr>
<tr><td><code id="xml_to_list_+3A_cleanup">cleanup</code></td>
<td>
<p>If <code>TRUE</code> (default) empty XML nodes (with no sub-nodes or
values) will not appear in the list.</p>
</td></tr>
<tr><td><code id="xml_to_list_+3A_convert.types">convert.types</code></td>
<td>
<p>If <code>TRUE</code> (default) <code>xml_to_list()</code> will try
to infer the data type of value elements in the XML. If <code>FALSE</code>, all
value elements in the resulting list will be of type <code>character</code>.</p>
</td></tr>
<tr><td><code id="xml_to_list_+3A_dec">dec</code></td>
<td>
<p>Decimal separator used in numbers.</p>
</td></tr>
<tr><td><code id="xml_to_list_+3A_thsd">thsd</code></td>
<td>
<p>Thousands separator used in numbers.</p>
</td></tr>
<tr><td><code id="xml_to_list_+3A_num.replace">num.replace</code></td>
<td>
<p>An optional string that will be removed before
<code>xml_to_list()</code> tries to convert values to numbers. Can be used, for
example, to remove currency symbols or other measurement units from values
that are actually numerical.</p>
</td></tr>
<tr><td><code id="xml_to_list_+3A_datetime.formats">datetime.formats</code></td>
<td>
<p>A vector of date and/or time formats that will be
used to recognize the respective datatypes. Formats will need to be written
in the general notation used by <code><a href="base.html#topic+strftime">strftime()</a></code> and
other standard R functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object representing the XML document.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xml &lt;- xml2::read_xml(system.file("customers.xml", package="xmlconvert"))
xml.list &lt;- xml_to_list(xml, num.replace="USD", datetime.formats = "%Y-%m-%d")#'

</code></pre>

<hr>
<h2 id='xmlconvert'>Package 'xmlconvert'</h2><span id='topic+xmlconvert'></span>

<h3>Description</h3>

<p>Tools for converting XML documents to dataframes and vice versa
</p>
<p>Functions available:
</p>

<ul>
<li> <p><code><a href="#topic+xml_to_df">xml_to_df</a>()</code>: Converts an XML document to an R dataframe
</p>
</li>
<li> <p><code><a href="#topic+df_to_xml">df_to_xml</a>()</code>: Converts a dataframe to an XML document
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
