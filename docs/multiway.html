<!DOCTYPE html><html><head><title>Help for package multiway</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multiway}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multiway-package'>
<p>Component Models for Multi-Way Data</p></a></li>
<li><a href='#congru'>
<p>Tucker's Congruence Coefficient</p></a></li>
<li><a href='#const.control'>
<p>Auxiliary for Controlling Multi-Way Constraints</p></a></li>
<li><a href='#corcondia'>
<p>Core Consistency Diagnostic</p></a></li>
<li><a href='#cpd'>
<p>N-way Canonical Polyadic Decomposition</p></a></li>
<li><a href='#fitted'>
<p>Extract Multi-Way Fitted Values</p></a></li>
<li><a href='#fnnls'>
<p>Fast Non-Negative Least Squares</p></a></li>
<li><a href='#indscal'>
<p>Individual Differences Scaling</p></a></li>
<li><a href='#krprod'>
<p>Khatri-Rao Product</p></a></li>
<li><a href='#mcr'>
<p>Multiway Covariates Regression</p></a></li>
<li><a href='#meansq'>
<p>Mean Square of Given Object</p></a></li>
<li><a href='#mpinv'>
<p>Moore-Penrose Pseudoinverse</p></a></li>
<li><a href='#multiway-internal'><p>Internal Multi-Way Functions</p></a></li>
<li><a href='#ncenter'>
<p>Center n-th Dimension of Array</p></a></li>
<li><a href='#nscale'>
<p>Scale n-th Dimension of Array</p></a></li>
<li><a href='#parafac'>
<p>Parallel Factor Analysis-1</p></a></li>
<li><a href='#parafac2'>
<p>Parallel Factor Analysis-2</p></a></li>
<li><a href='#print'>
<p>Print Multi-Way Model Results</p></a></li>
<li><a href='#reorder'>
<p>Reorder Multi-Way Factors</p></a></li>
<li><a href='#rescale'>
<p>Rescales Multi-Way Factors</p></a></li>
<li><a href='#resign'>
<p>Resigns Multi-Way Factors</p></a></li>
<li><a href='#sca'>
<p>Simultaneous Component Analysis</p></a></li>
<li><a href='#smpower'>
<p>Symmetric Matrix Power</p></a></li>
<li><a href='#sumsq'>
<p>Sum-of-Squares of Given Object</p></a></li>
<li><a href='#tucker'>
<p>Tucker Factor Analysis</p></a></li>
<li><a href='#USalcohol'>
<p>United States Alcohol Consumption Data (1970-2013)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Component Models for Multi-Way Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-03-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>CMLS, parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits multi-way component models via alternating least squares algorithms with optional constraints. Fit models include N-way Canonical Polyadic Decomposition, Individual Differences Scaling, Multiway Covariates Regression, Parallel Factor Analysis (1 and 2), Simultaneous Component Analysis, and Tucker Factor Analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-03-12 22:41:29 UTC; Nate</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-03-13 08:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='multiway-package'>
Component Models for Multi-Way Data
</h2><span id='topic+multiway-package'></span><span id='topic+multiway'></span>

<h3>Description</h3>

<p>Fits multi-way component models via alternating least squares algorithms with optional constraints. Fit models include N-way Canonical Polyadic Decomposition, Individual Differences Scaling, Multiway Covariates Regression, Parallel Factor Analysis (1 and 2), Simultaneous Component Analysis, and Tucker Factor Analysis.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> multiway</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Component Models for Multi-Way Data</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-03-12</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Nathaniel E. Helwig &lt;helwig@umn.edu&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> CMLS, parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Fits multi-way component models via alternating least squares algorithms with optional constraints. Fit models include N-way Canonical Polyadic Decomposition, Individual Differences Scaling, Multiway Covariates Regression, Parallel Factor Analysis (1 and 2), Simultaneous Component Analysis, and Tucker Factor Analysis.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
USalcohol               United States Alcohol Consumption Data
                        (1970-2013)
congru                  Tucker's Congruence Coefficient
const.control           Auxiliary for Controlling Multi-Way Constraints
corcondia               Core Consistency Diagnostic
cpd                     N-way Canonical Polyadic Decomposition
fitted.cpd              Extract Multi-Way Fitted Values
fnnls                   Fast Non-Negative Least Squares
indscal                 Individual Differences Scaling
krprod                  Khatri-Rao Product
mcr                     Multiway Covariates Regression
meansq                  Mean Square of Given Object
mpinv                   Moore-Penrose Pseudoinverse
multiway-package        Component Models for Multi-Way Data
ncenter                 Center n-th Dimension of Array
nscale                  Scale n-th Dimension of Array
parafac                 Parallel Factor Analysis-1
parafac2                Parallel Factor Analysis-2
print.cpd               Print Multi-Way Model Results
reorder.cpd             Reorder Multi-Way Factors
rescale                 Rescales Multi-Way Factors
resign                  Resigns Multi-Way Factors
sca                     Simultaneous Component Analysis
smpower                 Symmetric Matrix Power
sumsq                   Sum-of-Squares of Given Object
tucker                  Tucker Factor Analysis
</pre>
<p><code><a href="#topic+cpd">cpd</a></code> computes the N-way Canonical Polyadic Decomposition of a tensor. <code><a href="#topic+indscal">indscal</a></code> fits the Individual Differences Scaling model. <code><a href="#topic+mcr">mcr</a></code> fits the Multiway Covariates Regression model. <code><a href="#topic+parafac">parafac</a></code> fits the 3-way and 4-way Parallel Factor Analysis-1 model. <code><a href="#topic+parafac2">parafac2</a></code> fits the 3-way and 4-way Parallel Factor Analysis-2 model. <code><a href="#topic+sca">sca</a></code> fits the four different Simultaneous Component Analysis models. <code><a href="#topic+tucker">tucker</a></code> fits the 3-way and 4-way Tucker Factor Analysis model.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>
<p>Maintainer: Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bro, R., &amp; De Jong, S. (1997). A fast non-negativity-constrained least squares algorithm. <em>Journal of Chemometrics, 11</em>, 393-401.
</p>
<p>Bro, R., &amp; Kiers, H.A.L. (2003). A new efficient method for determining the number of components in PARAFAC models. <em>Journal of Chemometrics, 17</em>, 274-286.
</p>
<p>Carroll, J. D., &amp; Chang, J-J. (1970). Analysis of individual differences in multidimensional scaling via an n-way generalization of &quot;Eckart-Young&quot; decomposition. <em>Psychometrika, 35</em>, 283-319.
</p>
<p>Harshman, R. A. (1970). Foundations of the PARAFAC procedure: Models and conditions for an &quot;explanatory&quot; multimodal factor analysis. <em>UCLA Working Papers in Phonetics, 16</em>, 1-84.
</p>
<p>Harshman, R. A. (1972). PARAFAC2: Mathematical and technical notes. <em>UCLA Working Papers in Phonetics, 22</em>, 30-44.
</p>
<p>Harshman, R. A., &amp; Lundy, M. E. (1994). PARAFAC: Parallel factor analysis. <em>Computational Statistics and Data Analysis, 18</em>, 39-72.
</p>
<p>Haughwout, S. P., LaVallee, R. A., &amp; Castle, I-J. P. (2015). 
Surveillance Report #102: Apparent Per Capita Alcohol Consumption: 
National, State, and Regional Trends, 1977-2013. Bethesda, MD: NIAAA,
Alcohol Epidemiologic Data System.
</p>
<p>Helwig, N. E. (2013). The special sign indeterminacy of the direct-fitting Parafac2 model: Some implications, cautions, and recommendations, for Simultaneous Component Analysis. <em>Psychometrika, 78</em>, 725-739.
</p>
<p>Helwig, N. E. (2017). Estimating latent trends in multivariate longitudinal data via Parafac2 with functional and structural constraints. <em>Biometrical Journal, 59</em>(4), 783-803.
</p>
<p>Helwig, N. E. (in prep). Constrained parallel factor analysis via the R package multiway.
</p>
<p>Hitchcock, F. L. (1927). The expression of a tensor or a polyadic as a sum of products. <em>Journal of Mathematics and Physics, 6</em>, 164-189.
</p>
<p>Kiers, H. A. L., ten Berge, J. M. F., &amp; Bro, R. (1999). PARAFAC2-part I: A direct-fitting algorithm for the PARAFAC2 model. <em>Journal of Chemometrics, 13</em>, 275-294.
</p>
<p>Kroonenberg, P. M., &amp; de Leeuw, J. (1980). Principal component analysis of three-mode data by means of alternating least squares algorithms. <em>Psychometrika, 45</em>, 69-97.
</p>
<p>Moore, E. H. (1920). On the reciprocal of the general algebraic matrix. Bulletin of the American Mathematical Society 26, 394-395.
</p>
<p>Nephew, T. M., Yi, H., Williams, G. D., Stinson, F. S., &amp; Dufour, M.C., (2004). 
U.S. Alcohol Epidemiologic Data Reference Manual, Vol. 1, 4th ed. 
U.S. Apparent Consumption of Alcoholic Beverages Based on State Sales, 
Taxation, or Receipt Data. Bethesda, MD: NIAAA, Alcohol Epidemiologic Data 
System. NIH Publication No. 04-5563.
</p>
<p>Penrose, R. (1950). A generalized inverse for matrices. Mathematical Proceedings of the Cambridge Philosophical Society 51, 406-413.
</p>
<p>Ramsay, J. O. (1988). Monotone regression splines in action. <em>Statistical Science, 3</em>, 425-441.
</p>
<p>Smilde, A. K., &amp; Kiers, H. A. L. (1999). Multiway covariates regression models. <em>Journal of Chemometrics, 13</em>, 31-48.
</p>
<p>Timmerman, M. E., &amp; Kiers, H. A. L. (2003). Four simultaneous component models for the analysis of multivariate time series from more than one subject to model intraindividual and interindividual differences. <em>Psychometrika, 68</em>, 105-121.
</p>
<p>Tucker, L. R. (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika, 31</em>, 279-311.
</p>


<h3>See Also</h3>

<p><code><a href="CMLS.html#topic+CMLS-package">CMLS</a></code> ~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for... 
#   cpd (Canonical Polyadic Decomposition)
#   indscal (INividual Differences SCALing)
#   mcr (Multiway Covariates Regression)
#   parafac (Parallel Factor Analysis-1)
#   parafac2 (Parallel Factor Analysis-2)
#   sca (Simultaneous Component Analysis)
#   tucker (Tucker Factor Analysis)
</code></pre>

<hr>
<h2 id='congru'>
Tucker's Congruence Coefficient
</h2><span id='topic+congru'></span>

<h3>Description</h3>

<p>Calculates Tucker's congruence coefficient (uncentered correlation) between <code>x</code> and <code>y</code> if these are vectors. If <code>x</code> and <code>y</code> are matrices then the congruence between the columns of <code>x</code> and <code>y</code> are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>congru(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="congru_+3A_x">x</code></td>
<td>

<p>Numeric vector, matrix or data frame.
</p>
</td></tr>
<tr><td><code id="congru_+3A_y">y</code></td>
<td>

<p>NULL (default) or a vector, matrix or data frame with compatible dimensions to <code>x</code>. The default is equivalent to <code>y = x</code> (but more efficient).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tucker's congruence coefficient is defined as </p>
<p style="text-align: center;"><code class="reqn">r = \frac{\sum_{i=1}^{n}x_{i}y_{i}}{ \sqrt{\sum_{i=1}^{n}x_{i}^{2}\sum_{i=1}^{n}y_{i}^{2}} } </code>
</p>

<p>where <code class="reqn">x_{i}</code> and <code class="reqn">y_{i}</code> denote the <code class="reqn">i</code>-th elements of <code>x</code> and <code>y</code>.
</p>


<h3>Value</h3>

<p>Returns a scalar or matrix with congruence coefficient(s).
</p>


<h3>Note</h3>

<p>If <code>x</code> is a vector, you must also enter <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Tucker, L.R. (1951). <em>A method for synthesis of factor analysis studies</em> (Personnel Research Section Report No. 984). Washington, DC: Department of the Army.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########

set.seed(1)
A &lt;- rnorm(100)
B &lt;- rnorm(100)
C &lt;- A*5
D &lt;- A*(-0.5)
congru(A,B)
congru(A,C)
congru(A,D)



##########   EXAMPLE 2   ##########

set.seed(1)
A &lt;- cbind(rnorm(20),rnorm(20))
B &lt;- cbind(A[,1]*-0.5,rnorm(20))
congru(A)
congru(A,B)

</code></pre>

<hr>
<h2 id='const.control'>
Auxiliary for Controlling Multi-Way Constraints
</h2><span id='topic+const.control'></span>

<h3>Description</h3>

<p>Auxiliary function for controlling the <code>const</code> argument of the <code><a href="#topic+mcr">mcr</a></code>, <code><a href="#topic+parafac">parafac</a></code>, and <code><a href="#topic+parafac2">parafac2</a></code> functions. Applicable when using smoothness constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const.control(const, df = NULL, degree = NULL, intercept = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const.control_+3A_const">const</code></td>
<td>

<p>Character vector of length 3 or 4 giving the constraints for each mode. See <code><a href="CMLS.html#topic+const">const</a></code> for the 24 available options.
</p>
</td></tr>
<tr><td><code id="const.control_+3A_df">df</code></td>
<td>

<p>Integer vector of length 3 or 4 giving the degrees of freedom to use for the spline basis in each mode. Can also input a single number giving the common degrees of freedom to use for each mode. Defaults to 7 degrees of freedom for each applicable mode.
</p>
</td></tr>
<tr><td><code id="const.control_+3A_degree">degree</code></td>
<td>

<p>Integer vector of length 3 or 4 giving the polynomial degree to use for the spline basis in each mode. Can also input a single number giving the common polynomial degree to use for each mode. Defaults to degree 3 (cubic) polynomials for each applicable mode.
</p>
</td></tr>
<tr><td><code id="const.control_+3A_intercept">intercept</code></td>
<td>

<p>Logical vector of length 3 or 4 indicating whether the spline basis should contain an intercept. Can also input a single logical giving the common intercept indicator to use for each mode. Defaults to <code>TRUE</code> for each applicable mode.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+mcr">mcr</a></code>, <code><a href="#topic+parafac">parafac</a></code>, and <code><a href="#topic+parafac2">parafac2</a></code> functions pass the input <code>const</code> to this function to determine the fitting options when using smoothness constraints.
</p>
<p>The <code><a href="CMLS.html#topic+const">const</a></code> function (from <b>CMLS</b> package) describes the available constraint options.
</p>


<h3>Value</h3>

<p>Returns a list with elements: <code>const</code>, <code>df</code>, <code>degree</code>, and <code>intercept</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# create random data array with Parafac structure
set.seed(4)
mydim &lt;- c(30, 10, 8, 10)
nf &lt;- 4
aseq &lt;- seq(-3, 3, length.out = mydim[1])
Amat &lt;- cbind(dnorm(aseq), dchisq(aseq+3.1, df=3),
              dt(aseq-2, df=4), dgamma(aseq+3.1, shape=3, rate=1))
Bmat &lt;- svd(matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf), nv = 0)$u
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Cstruc &lt;- Cmat &gt; 0.5
Cmat &lt;- Cmat * Cstruc
Dmat &lt;- matrix(runif(mydim[4]*nf), nrow = mydim[4], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Dmat, krprod(Cmat, Bmat)))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit Parafac model (unimodal and smooth A, orthogonal B, 
#                    non-negative and structured C, non-negative D)
set.seed(123)
pfac &lt;- parafac(X, nfac = nf, nstart = 1, Cstruc = Cstruc, 
                const = c("unismo", "orthog", "nonneg", "nonneg"))
pfac

# same as before, but add some options to the unimodality contraints...
# more knots (df=10), quadratic splines (degree=2), and enforce non-negativity
cvec &lt;- c("unsmno", "orthog", "nonneg", "nonneg")
ctrl &lt;- const.control(cvec, df = 10, degree = 2)
set.seed(123)
pfac &lt;- parafac(X, nfac = nf, nstart = 1, Cstruc = Cstruc,
                const = cvec, control = ctrl)
pfac

</code></pre>

<hr>
<h2 id='corcondia'>
Core Consistency Diagnostic
</h2><span id='topic+corcondia'></span>

<h3>Description</h3>

<p>Calculates Bro and Kiers's core consistency diagnostic (CORCONDIA) for a fit <code><a href="#topic+parafac">parafac</a></code>  or <code><a href="#topic+parafac2">parafac2</a></code> model. For Parafac2, the diagnostic is calculated after transforming the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corcondia(X, object, divisor = c("nfac","core"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corcondia_+3A_x">X</code></td>
<td>

<p>Three-way data array with <code>dim=c(I,J,K)</code> or four-way data array with <code>dim=c(I,J,K,L)</code>. Can also input a list of two-way or three-way arrays (for Parafac2).
</p>
</td></tr>
<tr><td><code id="corcondia_+3A_object">object</code></td>
<td>

<p>Object of class &quot;parafac&quot; (output from <code><a href="#topic+parafac">parafac</a></code>) or class &quot;parafac2&quot; (output from <code><a href="#topic+parafac2">parafac2</a></code>).
</p>
</td></tr>
<tr><td><code id="corcondia_+3A_divisor">divisor</code></td>
<td>

<p>Divide by number of factors (default) or core sum of squares.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core consistency diagnostic is defined as
</p>

<table>
<tr>
 <td style="text-align: center;">
<code> 100 * ( 1 - sum( (G-S)^2 ) / divisor ) </code>
</td>
</tr>

</table>

<p>where <code>G</code> is the least squares estimate of the Tucker core array, <code>S</code> is a super-diagonal core array, and <code>divisor</code> is the sum of squares of either <code>S</code> (&quot;nfac&quot;) or <code>G</code> (&quot;core&quot;). A value of 100 indiciates a perfect multilinear structure, and smaller values indicate greater violations of multilinear structure.
</p>


<h3>Value</h3>

<p>Returns CORCONDIA value.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bro, R., &amp; Kiers, H.A.L. (2003). A new efficient method for determining the number of components in PARAFAC models. <em>Journal of Chemometrics, 17</em>, 274-286.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

# create random data array with Parafac structure
set.seed(3)
mydim &lt;- c(50,20,5)
nf &lt;- 2
Amat &lt;- matrix(rnorm(mydim[1]*nf),mydim[1],nf)
Bmat &lt;- matrix(runif(mydim[2]*nf),mydim[2],nf)
Cmat &lt;- matrix(runif(mydim[3]*nf),mydim[3],nf)
Xmat &lt;- array(tcrossprod(Amat,krprod(Cmat,Bmat)),dim=mydim)
Emat &lt;- array(rnorm(prod(mydim)),dim=mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- Xmat + Emat

# fit Parafac model (1-4 factors)
pfac1 &lt;- parafac(X,nfac=1,nstart=1)
pfac2 &lt;- parafac(X,nfac=2,nstart=1)
pfac3 &lt;- parafac(X,nfac=3,nstart=1)
pfac4 &lt;- parafac(X,nfac=4,nstart=1)

# check corcondia
corcondia(X, pfac1)
corcondia(X, pfac2)
corcondia(X, pfac3)
corcondia(X, pfac4)

</code></pre>

<hr>
<h2 id='cpd'>
N-way Canonical Polyadic Decomposition
</h2><span id='topic+cpd'></span>

<h3>Description</h3>

<p>Fits Frank L. Hitchcock's Canonical Polyadic Decomposition (CPD) to N-way data arrays. Parameters are estimated via alternating least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpd(X, nfac, nstart = 10, maxit = 500, 
    ctol = 1e-4, parallel = FALSE, cl = NULL, 
    output = "best", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpd_+3A_x">X</code></td>
<td>

<p>N-way data array. Missing data are allowed (see Note).
</p>
</td></tr>
<tr><td><code id="cpd_+3A_nfac">nfac</code></td>
<td>

<p>Number of factors.
</p>
</td></tr>
<tr><td><code id="cpd_+3A_nstart">nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td></tr>
<tr><td><code id="cpd_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="cpd_+3A_ctol">ctol</code></td>
<td>

<p>Convergence tolerance (R^2 change).
</p>
</td></tr>
<tr><td><code id="cpd_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if <code><a href="parallel.html#topic+parLapply">parLapply</a></code> should be used. See Examples.
</p>
</td></tr>
<tr><td><code id="cpd_+3A_cl">cl</code></td>
<td>

<p>Cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. Only used when <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="cpd_+3A_output">output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td></tr>
<tr><td><code id="cpd_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an N-way extension of the <code><a href="#topic+parafac">parafac</a></code> function without constraints. The form of the CPD for 3-way and 4-way data is given in the documentation for the <code><a href="#topic+parafac">parafac</a></code> function. For N &gt; 4, the CPD has the form
</p>

<table>
<tr>
 <td style="text-align: center;">
<code> X[i.1, ..., i.N] = sum A.1[i.1,r] * ... * A.N[i.N,r] + E[i.1, ..., i.N] </code>
</td>
</tr>

</table>
 
<p>where <code>A.n</code> are the n-th mode's weights for n = 1, ..., N, and <code>E</code> is the N-way residual array. The summation is for <code>r = seq(1,R)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>List of length N containing the weights for each mode.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td></tr>
</table>


<h3>Warnings </h3>

<p>The algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>


<h3>Note</h3>

<p>Missing data should be specified as <code>NA</code> values in the input <code>X</code>. The missing data are randomly initialized and then iteratively imputed as a part of the algorithm.
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally and <code>cflag = 1</code> if maximum iteration limit was reached before convergence.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Harshman, R. A. (1970). Foundations of the PARAFAC procedure: Models and conditions for an &quot;explanatory&quot; multimodal factor analysis. <em>UCLA Working Papers in Phonetics, 16</em>, 1-84.
</p>
<p>Harshman, R. A., &amp; Lundy, M. E. (1994). PARAFAC: Parallel factor analysis. <em>Computational Statistics and Data Analysis, 18</em>, 39-72.
</p>
<p>Hitchcock, F. L. (1927). The expression of a tensor or a polyadic as a sum of products. <em>Journal of Mathematics and Physics, 6</em>, 164-189.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+parafac">parafac</a></code> function provides a more flexible implemention for 3-way and 4-way arrays.
</p>
<p>The <code><a href="#topic+fitted.cpd">fitted.cpd</a></code> function creates the model-implied fitted values from a fit <code>"cpd"</code> object.
</p>
<p>The <code><a href="#topic+resign.cpd">resign.cpd</a></code> function can be used to resign factors from a fit <code>"cpd"</code> object.
</p>
<p>The <code><a href="#topic+rescale.cpd">rescale.cpd</a></code> function can be used to rescale factors from a fit <code>"cpd"</code> object.
</p>
<p>The <code><a href="#topic+reorder.cpd">reorder.cpd</a></code> function can be used to reorder factors from a fit <code>"cpd"</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   3-way example   ##########

# create random data array with CPD/Parafac structure
set.seed(3)
mydim &lt;- c(50, 20, 5)
nf &lt;- 3
Amat &lt;- matrix(rnorm(mydim[1]*nf), nrow = mydim[1], ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit CPD model
set.seed(0)
cano &lt;- cpd(X, nfac = nf, nstart = 1)
cano

# fit Parafac model
set.seed(0)
pfac &lt;- parafac(X, nfac = nf, nstart = 1)
pfac


##########   4-way example   ##########

# create random data array with CPD/Parafac structure
set.seed(4)
mydim &lt;- c(30,10,8,10)
nf &lt;- 4
aseq &lt;- seq(-3, 3, length.out = mydim[1])
Amat &lt;- cbind(dnorm(aseq), dchisq(aseq+3.1, df=3),
              dt(aseq-2, df=4), dgamma(aseq+3.1, shape=3, rate=1))
Bmat &lt;- svd(matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf), nv = 0)$u
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Cstruc &lt;- Cmat &gt; 0.5
Cmat &lt;- Cmat * Cstruc
Dmat &lt;- matrix(runif(mydim[4]*nf), nrow = mydim[4], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Dmat, krprod(Cmat, Bmat)))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit CPD model
set.seed(0)
cano &lt;- cpd(X, nfac = nf, nstart = 1)
cano

# fit Parafac model
set.seed(0)
pfac &lt;- parafac(X, nfac = nf, nstart = 1)
pfac


##########   5-way example   ##########

# create random data array with CPD/Parafac structure
set.seed(5)
mydim &lt;- c(5, 6, 7, 8, 9)
nmode &lt;- length(mydim)
nf &lt;- 3
Amat &lt;- vector("list", nmode)
for(n in 1:nmode) {
  Amat[[n]] &lt;- matrix(rnorm(mydim[n] * nf), mydim[n], nf)
}
Zmat &lt;- krprod(Amat[[3]], Amat[[2]])
for(n in 4:5) Zmat &lt;- krprod(Amat[[n]], Zmat)
Xmat &lt;- tcrossprod(Amat[[1]], Zmat)
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit CPD model
set.seed(0)
cano &lt;- cpd(X, nfac = nf, nstart = 1)
cano


</code></pre>

<hr>
<h2 id='fitted'>
Extract Multi-Way Fitted Values
</h2><span id='topic+fitted.cpd'></span><span id='topic+fitted.indscal'></span><span id='topic+fitted.mcr'></span><span id='topic+fitted.parafac'></span><span id='topic+fitted.parafac2'></span><span id='topic+fitted.sca'></span><span id='topic+fitted.tucker'></span>

<h3>Description</h3>

<p>Calculates fitted array (or list of arrays) from a <code>multiway</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpd'
fitted(object, ...)
## S3 method for class 'indscal'
fitted(object, ...)
## S3 method for class 'mcr'
fitted(object, type = c("X", "Y"), ...)
## S3 method for class 'parafac'
fitted(object, ...)
## S3 method for class 'parafac2'
fitted(object, simplify = TRUE, ...)
## S3 method for class 'sca'
fitted(object, ...)
## S3 method for class 'tucker'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted_+3A_object">object</code></td>
<td>

<p>Object of class &quot;cpd&quot; (output from <code><a href="#topic+cpd">cpd</a></code>), &quot;indscal&quot; (output from <code><a href="#topic+indscal">indscal</a></code>), class &quot;mcr&quot; (output from <code><a href="#topic+mcr">mcr</a></code>), class &quot;parafac&quot; (output from <code><a href="#topic+parafac">parafac</a></code>), class &quot;parafac2&quot; (output from <code><a href="#topic+parafac2">parafac2</a></code>), class &quot;sca&quot; (output from <code><a href="#topic+sca">sca</a></code>), or class &quot;tucker&quot; (output from <code><a href="#topic+tucker">tucker</a></code>).
</p>
</td></tr>
<tr><td><code id="fitted_+3A_simplify">simplify</code></td>
<td>

<p>For &quot;parafac2&quot;, setting <code>simplify = FALSE</code> will always return a list of fitted arrays. Default of <code>simplify = TRUE</code> returns a fitted array if all levels of the nesting mode have the same number of observations (and a list of fitted arrays otherwise).
</p>
</td></tr>
<tr><td><code id="fitted_+3A_type">type</code></td>
<td>

<p>For &quot;mcr&quot;, setting <code>type = "X"</code> returns the fitted predictor array (default), whereas setting <code>type = "Y"</code> retuns the fitted response array.
</p>
</td></tr>
<tr><td><code id="fitted_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+cpd">cpd</a></code>, <code><a href="#topic+indscal">indscal</a></code>, <code><a href="#topic+mcr">mcr</a></code>, <code><a href="#topic+parafac">parafac</a></code>, <code><a href="#topic+parafac2">parafac2</a></code>, <code><a href="#topic+sca">sca</a></code>, and <code><a href="#topic+tucker">tucker</a></code> for more details.
</p>


<h3>Value</h3>

<p>&quot;cpd&quot; objects: N-way array.
</p>
<p>&quot;indscal&quot; objects: 3-way array.
</p>
<p>&quot;mcr&quot; objects: 3-way (X) or 2-way (Y) array.
</p>
<p>&quot;parafac&quot; objects: 3-way or 4-way array.
</p>
<p>&quot;parafac2&quot; objects: 3-way or 4-way array (if possible and simplify=TRUE); otherwise list of 2-way or 3-way arrays.
</p>
<p>&quot;sca&quot; objects: list of 2-way arrays.
</p>
<p>&quot;tucker&quot; objects: 3-way or 4-way array.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for... 
#   cpd (Canonical Polyadic Decomposition)
#   indscal (INividual Differences SCALing)
#   mcr (Multiway Covariates Regression)
#   parafac (Parallel Factor Analysis-1)
#   parafac2 (Parallel Factor Analysis-2)
#   sca (Simultaneous Component Analysis)
#   tucker (Tucker Factor Analysis)
</code></pre>

<hr>
<h2 id='fnnls'>
Fast Non-Negative Least Squares
</h2><span id='topic+fnnls'></span>

<h3>Description</h3>

<p>Finds the vector <code>b</code> minimizing 
</p>

<table>
<tr>
 <td style="text-align: center;">
 <code>sum( (y - X %*% b)^2 )</code>
 </td>
</tr>

</table>

<p>subject to <code>b[j] &gt;= 0</code> for all <code>j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnnls(XtX, Xty, ntol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnnls_+3A_xtx">XtX</code></td>
<td>

<p>Crossproduct matrix <code>crossprod(X)</code> of dimension p-by-p.
</p>
</td></tr> 
<tr><td><code id="fnnls_+3A_xty">Xty</code></td>
<td>

<p>Crossproduct vector <code>crossprod(X,y)</code> of length p-by-1.
</p>
</td></tr>
<tr><td><code id="fnnls_+3A_ntol">ntol</code></td>
<td>

<p>Tolerance for non-negativity.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector <code>b</code> such that <code>b[j] &gt;= 0</code> for all <code>j</code>.
</p>


<h3>Note</h3>

<p>Default non-negativity tolerance: <code>ntol=10*(.Machine$double.eps)*max(colSums(abs(XtX)))*p</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Bro, R., &amp; De Jong, S. (1997). A fast non-negativity-constrained least squares algorithm. <em>Journal of Chemometrics, 11</em>, 393-401.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########
X &lt;- matrix(1:100,50,2)
y &lt;- matrix(101:150,50,1)
beta &lt;- solve(crossprod(X))%*%crossprod(X,y)
beta
beta &lt;- fnnls(crossprod(X),crossprod(X,y))
beta


##########   EXAMPLE 2   ##########
X &lt;- cbind(-(1:50),51:100)
y &lt;- matrix(101:150,50,1)
beta &lt;- solve(crossprod(X))%*%crossprod(X,y)
beta
beta &lt;- fnnls(crossprod(X),crossprod(X,y))
beta


##########   EXAMPLE 3   ##########
X &lt;- matrix(rnorm(400),100,4)
btrue &lt;- c(1,2,0,7)
y &lt;- X%*%btrue + rnorm(100)
fnnls(crossprod(X),crossprod(X,y))


##########   EXAMPLE 4   ##########
X &lt;- matrix(rnorm(2000),100,20)
btrue &lt;- runif(20)
y &lt;- X%*%btrue + rnorm(100)
beta &lt;- fnnls(crossprod(X),crossprod(X,y))
crossprod(btrue-beta)/20

</code></pre>

<hr>
<h2 id='indscal'>
Individual Differences Scaling
</h2><span id='topic+indscal'></span>

<h3>Description</h3>

<p>Fits Carroll and Chang's Individual Differences Scaling (INDSCAL) model to 3-way dissimilarity or similarity data. Parameters are estimated via alternating least squares with optional constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indscal(X, nfac, nstart = 10, const = NULL, control = NULL,
        type = c("dissimilarity", "similarity"),
        Bfixed = NULL, Bstart = NULL, Bstruc = NULL, Bmodes = NULL,
        Cfixed = NULL, Cstart = NULL, Cstruc = NULL, Cmodes = NULL,
        maxit = 500, ctol = 1e-4, parallel = FALSE, cl = NULL,
        output = c("best", "all"), verbose = TRUE, backfit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indscal_+3A_x">X</code></td>
<td>

<p>Three-way data array with <code>dim=c(J,J,K)</code> where <code>X[,,k]</code> is dissimilarity matrix. Can also input a list of (dis)similarity matrices or objects output by <code><a href="stats.html#topic+dist">dist</a></code>.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_nfac">nfac</code></td>
<td>

<p>Number of factors.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_nstart">nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_const">const</code></td>
<td>

<p>Character vector of length 2 giving the constraints for modes B and C (defaults to unconstrained for B and non-negative for C). See <code><a href="CMLS.html#topic+const">const</a></code> for the 24 available options. Constraints for Mode C weights are limited to one of the 8 possible non-negative options.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_control">control</code></td>
<td>

<p>List of parameters controlling options for smoothness constraints. This is passed to <code><a href="#topic+const.control">const.control</a></code>, which describes the available options.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_type">type</code></td>
<td>

<p>Character indicating if <code>X</code> contains dissimilarity data (default) or similarity data.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_bfixed">Bfixed</code></td>
<td>

<p>Used to fit model with fixed Mode B weights.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_bstart">Bstart</code></td>
<td>

<p>Starting Mode B weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_bstruc">Bstruc</code></td>
<td>

<p>Structure constraints for Mode B weights. See Note.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_bmodes">Bmodes</code></td>
<td>

<p>Mode ranges for Mode B weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_cfixed">Cfixed</code></td>
<td>

<p>Used to fit model with fixed Mode C weights.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_cstart">Cstart</code></td>
<td>

<p>Starting Mode C weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_cstruc">Cstruc</code></td>
<td>

<p>Structure constraints for Mode C weights. See Note.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_cmodes">Cmodes</code></td>
<td>

<p>Mode ranges for Mode C weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_ctol">ctol</code></td>
<td>

<p>Convergence tolerance.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if <code><a href="parallel.html#topic+parLapply">parLapply</a></code> should be used. See Examples.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_cl">cl</code></td>
<td>

<p>Cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. Only used when <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_output">output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="indscal_+3A_backfit">backfit</code></td>
<td>

<p>Should backfitting algorithm be used for <code><a href="CMLS.html#topic+cmls">cmls</a></code>? 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a 3-way array <code>X = array(x,dim=c(J,J,K))</code> with <code>X[,,k]</code> denoting the <code>k</code>-th subject's dissimilarity matrix rating <code>J</code> objects, the INDSCAL model can be written as 
</p>

<table>
<tr>
 <td style="text-align: center;">
<code> Z[i,j,k] = sum B[i,r]*B[j,r]*C[k,r] + E[i,j,k] </code>
</td>
</tr>

</table>
 
<p>where <code>Z</code> is the array of scalar products obtained from <code>X</code>, <code>B = matrix(b,J,R)</code> are the object weights, <code>C = matrix(c,K,R)</code> are the non-negative subject weights, and <code>E = array(e,dim=c(J,J,K))</code> is the 3-way residual array. The summation is for <code>r = seq(1,R)</code>.
</p>
<p>Weight matrices are estimated using an alternating least squares algorithm with optional constraints.
</p>


<h3>Value</h3>

<p>If <code>output="best"</code>, returns an object of class <code>"indscal"</code> with the following elements:
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>Mode B weight matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Mode C weight matrix.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>See argument <code>const</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>See argument <code>control</code>.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>Logical vector indicating whether 'fixed' weights were used for each mode.</p>
</td></tr>
<tr><td><code>struc</code></td>
<td>
<p>Logical vector indicating whether 'struc' constraints were used for each mode.</p>
</td></tr>
</table>
<p>Otherwise returns a list of length <code>nstart</code> where each element is an object of class <code>"indscal"</code>.
</p>


<h3>Warnings </h3>

<p>The algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>


<h3>Note</h3>

<p>Structure constraints should be specified with a matrix of logicals (TRUE/FALSE), such that FALSE elements indicate a weight should be constrained to be zero. Default uses unstructured weights, i.e., a matrix of all TRUE values.
</p>
<p>When using unimodal constraints, the <code>*modes</code> inputs can be used to specify the mode search range for each factor. These inputs should be matrices with dimension <code>c(2,nfac)</code> where the first row gives the minimum mode value and the second row gives the maximum mode value (with respect to the indicies of the given corresponding matrix).
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally, <code>cflag = 1</code> if maximum iteration limit was reached before convergence, and <code>cflag = 2</code> if algorithm terminated abnormally due to a problem with the constraints.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Carroll, J. D., &amp; Chang, J-J. (1970). Analysis of individual differences in multidimensional scaling via an n-way generalization of &quot;Eckart-Young&quot; decomposition. <em>Psychometrika, 35</em>, 283-319.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+fitted.indscal">fitted.indscal</a></code> function creates the model-implied fitted values from a fit <code>"indscal"</code> object.
</p>
<p>The <code><a href="#topic+resign.indscal">resign.indscal</a></code> function can be used to resign factors from a fit <code>"indscal"</code> object.
</p>
<p>The <code><a href="#topic+rescale.indscal">rescale.indscal</a></code> function can be used to rescale factors from a fit <code>"indscal"</code> object.
</p>
<p>The <code><a href="#topic+reorder.indscal">reorder.indscal</a></code> function can be used to reorder factors from a fit <code>"indscal"</code> object.
</p>
<p>The <code><a href="CMLS.html#topic+cmls">cmls</a></code> function (from <b>CMLS</b> package) is called as a part of the alternating least squares algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   array example   ##########

# create random data array with INDSCAL structure
set.seed(3)
mydim &lt;- c(50,5,10)
nf &lt;- 2
X &lt;- array(0, dim = c(rep(mydim[2],2), mydim[3]))
for(k in 1:mydim[3]) {
  X[,,k] &lt;- as.matrix(dist(t(matrix(rnorm(prod(mydim[1:2])), mydim[1], mydim[2]))))
}

# fit INDSCAL model
imod &lt;- indscal(X, nfac = nf, nstart = 1)
imod

# check solution
Xhat &lt;- fitted(imod)
sum((array(apply(X,3,ed2sp), dim = dim(X)) - Xhat)^2)
imod$SSE

# reorder and resign factors
imod$B[1:4,]
imod &lt;- reorder(imod, 2:1)
imod$B[1:4,]
imod &lt;- resign(imod, newsign = c(1,-1))
imod$B[1:4,]
sum((array(apply(X,3,ed2sp), dim = dim(X)) - Xhat)^2)
imod$SSE

# rescale factors
colSums(imod$B^2)
colSums(imod$C^2)
imod &lt;- rescale(imod, mode = "C")
colSums(imod$B^2)
colSums(imod$C^2)
sum((array(apply(X,3,ed2sp), dim = dim(X)) - Xhat)^2)
imod$SSE


##########   list example   ##########

# create random data array with INDSCAL structure
set.seed(4)
mydim &lt;- c(100, 8, 20)
nf &lt;- 3
X &lt;- vector("list", mydim[3])
for(k in 1:mydim[3]) {
  X[[k]] &lt;- dist(t(matrix(rnorm(prod(mydim[1:2])), mydim[1], mydim[2])))
}

# fit INDSCAL model (orthogonal B, non-negative C)
imod &lt;- indscal(X, nfac = nf, nstart = 1, const = c("orthog", "nonneg"))
imod

# check solution
Xhat &lt;- fitted(imod)
sum((array(unlist(lapply(X,ed2sp)), dim = mydim[c(2,2,3)]) - Xhat)^2)
imod$SSE
crossprod(imod$B)


## Not run: 

##########   parallel computation   ##########

# create random data array with INDSCAL structure
set.seed(3)
mydim &lt;- c(50,5,10)
nf &lt;- 2
X &lt;- array(0,dim=c(rep(mydim[2],2), mydim[3]))
for(k in 1:mydim[3]) {
  X[,,k] &lt;- as.matrix(dist(t(matrix(rnorm(prod(mydim[1:2])), mydim[1], mydim[2]))))
}

# fit INDSCAL model (10 random starts -- sequential computation)
set.seed(1)
system.time({imod &lt;- indscal(X, nfac = nf)})
imod

# fit INDSCAL model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl,library(multiway))
clusterSetRNGStream(cl, 1)
system.time({imod &lt;- indscal(X, nfac = nf, parallel = TRUE, cl = cl)})
imod
stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='krprod'>
Khatri-Rao Product
</h2><span id='topic+krprod'></span>

<h3>Description</h3>

<p>Calculates the Khatri-Rao product (i.e., columnwise Kronecker product) between two matrices with the same number of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krprod(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krprod_+3A_x">X</code></td>
<td>

<p>Matrix of order n-by-p.
</p>
</td></tr>
<tr><td><code id="krprod_+3A_y">Y</code></td>
<td>

<p>Matrix of order m-by-p.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code>X</code> (n-by-p) and <code>Y</code> (m-by-p), the Khatri-Rao product <code>Z = krprod(X,Y)</code> is defined as 
</p>

<table>
<tr>
 <td style="text-align: center;">
 <code> Z[,j] = kronecker(X[,j],Y[,j]) </code>
 </td>
</tr>

</table>

<p>which is the mn-by-p matrix containing Kronecker products of corresponding columns of <code>X</code> and <code>Y</code>.
</p>


<h3>Value</h3>

<p>The mn-by-p matrix of columnwise Kronecker products.
</p>


<h3>Note</h3>

<p><code>X</code> and <code>Y</code> must have the same number of columns.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########
X &lt;- matrix(1,4,2)
Y &lt;- matrix(1:4,2,2)
krprod(X,Y)


##########   EXAMPLE 2   ##########
X &lt;- matrix(1:2,4,2)
Y &lt;- matrix(1:4,2,2)
krprod(X,Y)


##########   EXAMPLE 3   ##########
X &lt;- matrix(1:2,4,2,byrow=TRUE)
Y &lt;- matrix(1:4,2,2)
krprod(X,Y)

</code></pre>

<hr>
<h2 id='mcr'>
Multiway Covariates Regression
</h2><span id='topic+mcr'></span>

<h3>Description</h3>

<p>Fits Smilde and Kiers's Multiway Covariates Regression (MCR) model to connect a 3-way predictor array and a 2-way response array that share a common mode. Parameters are estimated via alternating least squares with optional constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcr(X, Y, nfac = 1, alpha = 0.5, nstart = 10, 
    model = c("parafac", "parafac2", "tucker"),
    const = NULL, control = NULL, weights = NULL,
    Afixed = NULL, Bfixed = NULL, Cfixed = NULL, Dfixed = NULL,
    Astart = NULL, Bstart = NULL, Cstart = NULL, Dstart = NULL,
    Astruc = NULL, Bstruc = NULL, Cstruc = NULL, Dstruc = NULL,
    Amodes = NULL, Bmodes = NULL, Cmodes = NULL, Dmodes = NULL,
    maxit = 500, ctol = 1e-4, parallel = FALSE, cl = NULL, 
    output = c("best", "all"), verbose = TRUE, backfit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcr_+3A_x">X</code></td>
<td>

<p>Three-way predictor array with <code>dim = c(I,J,K)</code>.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_y">Y</code></td>
<td>

<p>Two-way response array with <code>dim = c(K,L)</code>.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_nfac">nfac</code></td>
<td>

<p>Number of factors.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_alpha">alpha</code></td>
<td>

<p>Tuning parameter between 0 and 1. 
</p>
</td></tr>
<tr><td><code id="mcr_+3A_nstart">nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_model">model</code></td>
<td>

<p>Model for <code>X</code>. Defaults to &quot;parafac&quot;.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_const">const</code></td>
<td>

<p>Character vector of length 4 giving the constraints for <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> (defaults to unconstrained). See <code><a href="CMLS.html#topic+const">const</a></code> for the 24 available options. Ignored if <code>model = "tucker"</code>.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_control">control</code></td>
<td>

<p>List of parameters controlling options for smoothness constraints. This is passed to <code><a href="#topic+const.control">const.control</a></code>, which describes the available options.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_weights">weights</code></td>
<td>

<p>Vector of length <code>K</code> giving non-negative weights for fitting via weighted least squares. Defaults to vector of ones.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_afixed">Afixed</code></td>
<td>

<p>Used to fit model with fixed Mode A weights.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_bfixed">Bfixed</code></td>
<td>

<p>Used to fit model with fixed Mode B weights.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_cfixed">Cfixed</code></td>
<td>

<p>Used to fit model with fixed Mode C weights.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_dfixed">Dfixed</code></td>
<td>

<p>Used to fit model with fixed Mode D weights. 
</p>
</td></tr>
<tr><td><code id="mcr_+3A_astart">Astart</code></td>
<td>

<p>Starting Mode A weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_bstart">Bstart</code></td>
<td>

<p>Starting Mode B weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_cstart">Cstart</code></td>
<td>

<p>Starting Mode C weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_dstart">Dstart</code></td>
<td>

<p>Starting Mode D weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_astruc">Astruc</code></td>
<td>

<p>Structure constraints for Mode A weights. See Note.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_bstruc">Bstruc</code></td>
<td>

<p>Structure constraints for Mode B weights. See Note.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_cstruc">Cstruc</code></td>
<td>

<p>Structure constraints for Mode C weights. Ignored.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_dstruc">Dstruc</code></td>
<td>

<p>Structure constraints for Mode D weights. See Note.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_amodes">Amodes</code></td>
<td>

<p>Mode ranges for Mode A weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_bmodes">Bmodes</code></td>
<td>

<p>Mode ranges for Mode B weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_cmodes">Cmodes</code></td>
<td>

<p>Mode ranges for Mode C weights (for unimodality constraints). Ignored.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_dmodes">Dmodes</code></td>
<td>

<p>Mode ranges for Mode D weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_ctol">ctol</code></td>
<td>

<p>Convergence tolerance (R^2 change).
</p>
</td></tr>
<tr><td><code id="mcr_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if <code><a href="parallel.html#topic+parLapply">parLapply</a></code> should be used. See Examples.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_cl">cl</code></td>
<td>

<p>Cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. Only used when <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_output">output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mcr_+3A_backfit">backfit</code></td>
<td>

<p>Should backfitting algorithm be used for <code><a href="CMLS.html#topic+cmls">cmls</a></code>?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a predictor array <code>X = array(x, dim=c(I,J,K))</code> and a response matrix <code>Y = matrix(y, nrow=K, ncol=L)</code>, the multiway covariates regression (MCR) model assumes a tensor model for <code>X</code> and a bilinear model for <code>Y</code>, which are linked through a common <code>C</code> weight matrix. For example, using the Parafac model for <code>X</code>, the MCR model has the form
</p>

<table>
<tr>
 <td style="text-align: left;">
<code> X[i,j,k] = sum A[i,r]*B[j,r]*C[k,r] + Ex[i,j,k] </code> </td>
</tr>
<tr>
 <td style="text-align: left;">
and </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>   Y[k,l] = sum C[k,r]*D[l,r] + Ey[k,l] </code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Parameter matrices are estimated by minimizing the loss function
</p>

<table>
<tr>
 <td style="text-align: center;">
<code>LOSS = alpha * (SSE.X / SSX) + (1 - alpha) * (SSE.Y / SSY)</code>
</td>
</tr>

</table>

<p>where 
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>SSE.X = sum((X - Xhat)^2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>SSE.Y = sum((Y - Yhat)^2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>SSX = sum(X^2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>SSY = sum(Y^2)</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When <code>weights</code> are input, <code>SSE.X</code>, <code>SSE.Y</code>, <code>SSX</code>, and <code>SSY</code> are replaced by the corresponding weighted versions.
</p>


<h3>Value</h3>

<table>
<tr><td><code>A</code></td>
<td>
<p>Predictor A weight matrix.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Predictor B weight matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Common C weight matrix.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Response D weight matrix.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>Coefficients. See Note.</p>
</td></tr>
<tr><td><code>LOSS</code></td>
<td>
<p>Value of <code>LOSS</code> function.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors for <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared value for <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>See argument <code>model</code>.</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>See argument <code>const</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>See argument <code>control</code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>See argument <code>weights</code>.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>See argument <code>alpha</code>.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>Logical vector indicating whether 'fixed' weights were used for each matrix.</p>
</td></tr>
<tr><td><code>struc</code></td>
<td>
<p>Logical vector indicating whether 'struc' constraints were used for each matrix.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>Mode A crossproduct matrix. Only if <code>model = "parafac2"</code>.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Core array. Only if <code>model = "tucker"</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When <code>model = "parafac2"</code>, the arguments <code>Afixed</code>, <code>Astart</code>, and <code>Astruc</code> are treated as the arguments <code>Gfixed</code>, <code>Gstart</code>, and <code>Gstruc</code> from the <code><a href="#topic+parafac2">parafac2</a></code> function.
</p>
<p>Structure constraints should be specified with a matrix of logicals (TRUE/FALSE), such that FALSE elements indicate a weight should be constrained to be zero. Default uses unstructured weights, i.e., a matrix of all TRUE values. Structure constraints are ignored if <code>model = "tucker"</code>.
</p>
<p>When using unimodal constraints, the <code>*modes</code> inputs can be used to specify the mode search range for each factor. These inputs should be matrices with dimension <code>c(2,nfac)</code> where the first row gives the minimum mode value and the second row gives the maximum mode value (with respect to the indicies of the corresponding weight matrix).
</p>
<p><code>C = Xc %*% W</code> where <code>Xc = matrix(aperm(X,c(3,1,2)),K)</code>
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally, <code>cflag = 1</code> if maximum iteration limit was reached before convergence, and <code>cflag = 2</code> if algorithm terminated abnormally due to a problem with the constraints.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Smilde, A. K., &amp; Kiers, H. A. L. (1999). Multiway covariates regression models, <em>Journal of Chemometrics, 13</em>, 31-48.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+fitted.mcr">fitted.mcr</a></code> function creates the model-implied fitted values from a fit <code>"mcr"</code> object.
</p>
<p>The <code><a href="#topic+resign.mcr">resign.mcr</a></code> function can be used to resign factors from a fit <code>"mcr"</code> object.
</p>
<p>The <code><a href="#topic+rescale.mcr">rescale.mcr</a></code> function can be used to rescale factors from a fit <code>"mcr"</code> object.
</p>
<p>The <code><a href="#topic+reorder.mcr">reorder.mcr</a></code> function can be used to reorder factors from a fit <code>"mcr"</code> object.
</p>
<p>The <code><a href="CMLS.html#topic+cmls">cmls</a></code> function (from <b>CMLS</b> package) is called as a part of the alternating least squares algorithm.
</p>
<p>See <code><a href="#topic+parafac">parafac</a></code>, <code><a href="#topic+parafac2">parafac2</a></code>, and <code><a href="#topic+tucker">tucker</a></code> for more information about the Parafac, Parafac2, and Tucker models. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########   multiway covariates regression   ##########

# create random data array with Parafac structure
set.seed(3)
mydim &lt;- c(10, 20, 100)
nf &lt;- 2
Amat &lt;- matrix(rnorm(mydim[1]*nf), mydim[1], nf)
Bmat &lt;- matrix(rnorm(mydim[2]*nf), mydim[2], nf)
Cmat &lt;- matrix(rnorm(mydim[3]*nf), mydim[3], nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
EX &lt;- array(rnorm(prod(mydim)), dim = mydim)
EX &lt;- nscale(EX, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + EX

# create response array
ydim &lt;- c(mydim[3], 4)
Dmat &lt;- matrix(rnorm(ydim[2]*nf), ydim[2], nf)
Ymat &lt;- tcrossprod(Cmat, Dmat)
EY &lt;- array(rnorm(prod(ydim)), dim = ydim)
EY &lt;- nscale(EY, 0, ssnew = sumsq(Ymat))   # SNR = 1
Y &lt;- Ymat + EY

# fit MCR model
mcr(X, Y, nfac = nf, nstart = 1)
mcr(X, Y, nfac = nf, nstart = 1, model = "parafac2")
mcr(X, Y, nfac = nf, nstart = 1, model = "tucker")



## Not run: 

##########   parallel computation   ##########

# create random data array with Parafac structure
set.seed(3)
mydim &lt;- c(10, 20, 100)
nf &lt;- 2
Amat &lt;- matrix(rnorm(mydim[1]*nf), mydim[1], nf)
Bmat &lt;- matrix(rnorm(mydim[2]*nf), mydim[2], nf)
Cmat &lt;- matrix(rnorm(mydim[3]*nf), mydim[3], nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
EX &lt;- array(rnorm(prod(mydim)), dim = mydim)
EX &lt;- nscale(EX, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + EX

# create response array
ydim &lt;- c(mydim[3], 4)
Dmat &lt;- matrix(rnorm(ydim[2]*nf), ydim[2], nf)
Ymat &lt;- tcrossprod(Cmat, Dmat)
EY &lt;- array(rnorm(prod(ydim)), dim = ydim)
EY &lt;- nscale(EY, 0, ssnew = sumsq(Ymat))   # SNR = 1
Y &lt;- Ymat + EY

# fit MCR-Parafac model (10 random starts -- sequential computation)
set.seed(1)
system.time({mod &lt;- mcr(X, Y, nfac = nf)})
mod

# fit MCR-Parafac model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl, library(multiway))
clusterSetRNGStream(cl, 1)
system.time({mod &lt;- mcr(X, Y, nfac = nf, parallel = TRUE, cl = cl)})
mod
stopCluster(cl)


## End(Not run)


</code></pre>

<hr>
<h2 id='meansq'>
Mean Square of Given Object
</h2><span id='topic+meansq'></span>

<h3>Description</h3>

<p>Calculates the mean square of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meansq(X, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meansq_+3A_x">X</code></td>
<td>

<p>Numeric scalar, vector, list, matrix, or array.
</p>
</td></tr> 
<tr><td><code id="meansq_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. Should missing values (including <code>NaN</code>) be removed?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean square of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########
X &lt;- 10
meansq(X)


##########   EXAMPLE 2   ##########
X &lt;- 1:10
meansq(X)


##########   EXAMPLE 3   ##########
X &lt;- matrix(1:10,5,2)
meansq(X)


##########   EXAMPLE 4   ##########
X &lt;- array(matrix(1:10,5,2),dim=c(5,2,2))
meansq(X)


##########   EXAMPLE 5   ##########
X &lt;- vector("list",5)
for(k in 1:5){ X[[k]] &lt;- matrix(1:10,5,2) }
meansq(X)

</code></pre>

<hr>
<h2 id='mpinv'>
Moore-Penrose Pseudoinverse
</h2><span id='topic+mpinv'></span>

<h3>Description</h3>

<p>Calculates the Moore-Penrose pseudoinverse of the input matrix using a truncated singular value decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpinv(X, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpinv_+3A_x">X</code></td>
<td>

<p>Real-valued matrix.
</p>
</td></tr>
<tr><td><code id="mpinv_+3A_tol">tol</code></td>
<td>

<p>Stability tolerance for singular values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically returns <code>Y$v %*% diag(1/Y$d) %*% t(Y$u)</code> where <code>Y = svd(X)</code>.
</p>


<h3>Value</h3>

<p>Returns pseudoinverse of <code>X</code>.
</p>


<h3>Note</h3>

<p>Default tolerance is <code>tol = max(dim(X)) * .Machine$double.eps</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Moore, E. H. (1920). On the reciprocal of the general algebraic matrix. Bulletin of the American Mathematical Society 26, 394-395.
</p>
<p>Penrose, R. (1950). A generalized inverse for matrices. Mathematical Proceedings of the Cambridge Philosophical Society 51, 406-413.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

set.seed(1)
X &lt;- matrix(rnorm(2000),100,20)
Xi &lt;- mpinv(X)
sum( ( X - X %*% Xi %*% X )^2 )
sum( ( Xi - Xi %*% X %*% Xi )^2 )
isSymmetric(X %*% Xi)
isSymmetric(Xi %*% X)

</code></pre>

<hr>
<h2 id='multiway-internal'>Internal Multi-Way Functions</h2><span id='topic+cpd_nway'></span><span id='topic+cpd_nwayna'></span><span id='topic+ed2sp'></span><span id='topic+initcmls'></span><span id='topic+mcr_parafac'></span><span id='topic+mcr_parafac2'></span><span id='topic+mcr_tucker'></span><span id='topic+parafac_3way'></span><span id='topic+parafac_3wayna'></span><span id='topic+parafac_4way'></span><span id='topic+parafac_4wayna'></span><span id='topic+parafac2_3way'></span><span id='topic+parafac2_3wayna'></span><span id='topic+parafac2_4way'></span><span id='topic+parafac2_4wayna'></span><span id='topic+tucker_3way'></span><span id='topic+tucker_3wayna'></span><span id='topic+tucker_4way'></span><span id='topic+tucker_4wayna'></span>

<h3>Description</h3>

<p>Internal Multi-Way Functions
</p>


<h3>Details</h3>

<p>These functions are not to be called by the user.
</p>

<hr>
<h2 id='ncenter'>
Center n-th Dimension of Array
</h2><span id='topic+ncenter'></span>

<h3>Description</h3>

<p>Fiber-center across the levels of the specified mode. Can input 2-way, 3-way, and 4-way arrays, or input a list containing array elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncenter(X, mode = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncenter_+3A_x">X</code></td>
<td>

<p>Array (2-way, 3-way, or 4-way) or a list containing array elements.
</p>
</td></tr>
<tr><td><code id="ncenter_+3A_mode">mode</code></td>
<td>

<p>Mode to center across.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>X</code> a matrix (I-by-J) there are two options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j] - mean(x[,j]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j] - mean(x[i,]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>With <code>X</code> a 3-way array (I-by-J-by-K) there are three options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] - mean(x[,j,k]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] - mean(x[i,,k]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=3: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] - mean(x[i,j,]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>With <code>X</code> a 4-way array (I-by-J-by-K-by-L) there are four options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] - mean(x[,j,k,l]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] - mean(x[i,,k,l]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=3: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] - mean(x[i,j,,l]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=4: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] - mean(x[i,j,k,]) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Value</h3>

<p>Returns centered version of <code>X</code>.
</p>


<h3>Note</h3>

<p>When entering a list with array elements, each element must be an array (2-way, 3-way, or 4-way) that contains the specified <code>mode</code> to center across.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########
X &lt;- matrix(rnorm(2000),100,20)
Xc &lt;- ncenter(X)          # center across rows
sum(colSums(Xc))
Xc &lt;- ncenter(Xc,mode=2) # recenter across columns
sum(colSums(Xc)) 
sum(rowSums(Xc))


##########   EXAMPLE 2   ##########
X &lt;- array(rnorm(20000),dim=c(100,20,10))
Xc &lt;- ncenter(X,mode=2)   # center across columns
sum(rowSums(Xc))


##########   EXAMPLE 3   ##########
X &lt;- array(rnorm(100000),dim=c(100,20,10,5))
Xc &lt;- ncenter(X,mode=4)   # center across 4-th mode
sum(rowSums(Xc))


##########   EXAMPLE 4   ##########
X &lt;- replicate(5,array(rnorm(20000),dim=c(100,20,10)),simplify=FALSE)
Xc &lt;- ncenter(X)
sum(colSums(Xc[[1]]))

</code></pre>

<hr>
<h2 id='nscale'>
Scale n-th Dimension of Array
</h2><span id='topic+nscale'></span>

<h3>Description</h3>

<p>Slab-scale within each level of the specified mode. Can input 2-way, 3-way, and 4-way arrays, or input a list containing array elements (see Note).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nscale(X, mode = 1, ssnew = NULL, newscale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nscale_+3A_x">X</code></td>
<td>

<p>Array (2-way, 3-way, or 4-way) or a list containing array elements.
</p>
</td></tr>
<tr><td><code id="nscale_+3A_mode">mode</code></td>
<td>

<p>Mode to scale within (set <code>mode = 0</code> to scale across all modes).
</p>
</td></tr>
<tr><td><code id="nscale_+3A_ssnew">ssnew</code></td>
<td>

<p>Desired sum-of-squares for each level of scaled mode.
</p>
</td></tr>
<tr><td><code id="nscale_+3A_newscale">newscale</code></td>
<td>

<p>Desired root-mean-square for each level of scaled mode. Ignored if <code>ssnew</code> is supplied.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default (as of ver 1.0-5) uses <code>newscale</code> argument...
</p>
<p>With <code>X</code> a matrix (I-by-J) there are two options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j] * newscale / sqrt(meansq(x[i,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j] * newscale / sqrt(meansq(x[,j])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>With <code>X</code> a 3-way array (I-by-J-by-K) there are three options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] * newscale / sqrt(meansq(x[i,,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] * newscale / sqrt(meansq(x[,j,]))) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=3: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] * newscale / sqrt(meansq(x[,,k])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>With <code>X</code> a 4-way array (I-by-J-by-K-by-L) there are four options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * newscale / sqrt(meansq(x[i,,,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * newscale / sqrt(meansq(x[,j,,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=3: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * newscale / sqrt(meansq(x[,,k,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=4: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * newscale / sqrt(meansq(x[,,,l])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>If argument <code>ssnew</code> is provided...
</p>
<p>With <code>X</code> a matrix (I-by-J) there are two options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j] * sqrt(ssnew / sumsq(x[i,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j] * sqrt(ssnew / sumsq(x[,j])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>With <code>X</code> a 3-way array (I-by-J-by-K) there are three options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] * sqrt(ssnew / sumsq(x[i,,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] * sqrt(ssnew / sumsq(x[,j,]))) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=3: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k] * sqrt(ssnew / sumsq(x[,,k])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>With <code>X</code> a 4-way array (I-by-J-by-K-by-L) there are four options:
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code> mode=1: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * sqrt(ssnew / sumsq(x[i,,,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=2: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * sqrt(ssnew / sumsq(x[,j,,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=3: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * sqrt(ssnew / sumsq(x[,,k,])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code> mode=4: </code> </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code> x[i,j,k,l] * sqrt(ssnew / sumsq(x[,,,l])) </code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>



<h3>Value</h3>

<p>Returns scaled version of <code>X</code>.
</p>


<h3>Note</h3>

<p>When entering a list with array elements, each element must be a 2-way or 3-way array. The list elements are treated as the 3rd mode (for list of 2-way arrays) or the 4th mode (for list of 3-way arrays) in the formulas provided in the Description.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########
X &lt;- matrix(rnorm(2000), nrow = 100, ncol = 20)
Xr &lt;- nscale(X, mode = 2)                # scale columns to newscale=1
sqrt(colMeans(Xr^2))
Xr &lt;- nscale(X, mode = 2, newscale = 2)  # scale columns to newscale=2
sqrt(colMeans(Xr^2))


##########   EXAMPLE 2   ##########
Xold &lt;- X &lt;- matrix(rnorm(400), nrow = 20, ncol = 20)
iter &lt;- 0
chk &lt;- 1
# iterative scaling of modes 1 and 2
while(iter&lt;500 &amp; chk&gt;=10^-9){
  Xr &lt;- nscale(Xold, mode = 1)
  Xr &lt;- nscale(Xr, mode = 2)
  chk &lt;- sum((Xold-Xr)^2)
  Xold &lt;- Xr
  iter &lt;- iter + 1
}
iter
sqrt(rowMeans(Xr^2))
sqrt(colMeans(Xr^2))


##########   EXAMPLE 3   ##########
X &lt;- array(rnorm(20000), dim = c(100,20,10))
Xc &lt;- nscale(X, mode = 2)   # scale within columns
sqrt(rowMeans(aperm(Xc, perm = c(2,1,3))^2))


##########   EXAMPLE 4   ##########
X &lt;- array(rnorm(100000), dim = c(100,20,10,5))
Xc &lt;- nscale(X, mode = 4)   # scale across 4-th mode
sqrt(rowMeans(aperm(Xc, perm = c(4,1,2,3))^2))


##########   EXAMPLE 5   ##########
X &lt;- replicate(5, array(rnorm(20000), dim = c(100,20,10)), simplify = FALSE)
# mean square of 1 (new way)
Xc &lt;- nscale(X)
rowSums(sapply(Xc, function(x) rowSums(x^2))) / (20*10*5)
# mean square of 1 (old way)
Xc &lt;- nscale(X, ssnew = (20*10*5))
rowSums(sapply(Xc, function(x) rowSums(x^2))) / (20*10*5)



</code></pre>

<hr>
<h2 id='parafac'>
Parallel Factor Analysis-1
</h2><span id='topic+parafac'></span>

<h3>Description</h3>

<p>Fits Richard A. Harshman's Parallel Factors (Parafac) model to 3-way or 4-way data arrays. Parameters are estimated via alternating least squares with optional constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parafac(X, nfac, nstart = 10, const = NULL, control = NULL,
        Afixed = NULL, Bfixed = NULL, Cfixed = NULL, Dfixed = NULL,
        Astart = NULL, Bstart = NULL, Cstart = NULL, Dstart = NULL,
        Astruc = NULL, Bstruc = NULL, Cstruc = NULL, Dstruc = NULL,
        Amodes = NULL, Bmodes = NULL, Cmodes = NULL, Dmodes = NULL,
        maxit = 500, ctol = 1e-4, parallel = FALSE, cl = NULL,
        output = c("best", "all"), verbose = TRUE, backfit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parafac_+3A_x">X</code></td>
<td>

<p>Three-way data array with <code>dim=c(I,J,K)</code> or four-way data array with <code>dim=c(I,J,K,L)</code>. Missing data are allowed (see Note).
</p>
</td></tr>
<tr><td><code id="parafac_+3A_nfac">nfac</code></td>
<td>

<p>Number of factors.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_nstart">nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_const">const</code></td>
<td>

<p>Character vector of length 3 or 4 giving the constraints for each mode (defaults to unconstrained). See <code><a href="CMLS.html#topic+const">const</a></code> for the 24 available options.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_control">control</code></td>
<td>

<p>List of parameters controlling options for smoothness constraints. This is passed to <code><a href="#topic+const.control">const.control</a></code>, which describes the available options.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_afixed">Afixed</code></td>
<td>

<p>Used to fit model with fixed Mode A weights.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_bfixed">Bfixed</code></td>
<td>

<p>Used to fit model with fixed Mode B weights.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_cfixed">Cfixed</code></td>
<td>

<p>Used to fit model with fixed Mode C weights.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_dfixed">Dfixed</code></td>
<td>

<p>Used to fit model with fixed Mode D weights. 
</p>
</td></tr>
<tr><td><code id="parafac_+3A_astart">Astart</code></td>
<td>

<p>Starting Mode A weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_bstart">Bstart</code></td>
<td>

<p>Starting Mode B weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_cstart">Cstart</code></td>
<td>

<p>Starting Mode C weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_dstart">Dstart</code></td>
<td>

<p>Starting Mode D weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_astruc">Astruc</code></td>
<td>

<p>Structure constraints for Mode A weights. See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_bstruc">Bstruc</code></td>
<td>

<p>Structure constraints for Mode B weights. See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_cstruc">Cstruc</code></td>
<td>

<p>Structure constraints for Mode C weights. See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_dstruc">Dstruc</code></td>
<td>

<p>Structure constraints for Mode D weights. See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_amodes">Amodes</code></td>
<td>

<p>Mode ranges for Mode A weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_bmodes">Bmodes</code></td>
<td>

<p>Mode ranges for Mode B weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_cmodes">Cmodes</code></td>
<td>

<p>Mode ranges for Mode C weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_dmodes">Dmodes</code></td>
<td>

<p>Mode ranges for Mode D weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_ctol">ctol</code></td>
<td>

<p>Convergence tolerance (R^2 change).
</p>
</td></tr>
<tr><td><code id="parafac_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if <code><a href="parallel.html#topic+parLapply">parLapply</a></code> should be used. See Examples.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_cl">cl</code></td>
<td>

<p>Cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. Only used when <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_output">output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="parafac_+3A_backfit">backfit</code></td>
<td>

<p>Should backfitting algorithm be used for <code><a href="CMLS.html#topic+cmls">cmls</a></code>?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a 3-way array <code>X = array(x, dim = c(I,J,K))</code>, the 3-way Parafac model can be written as 
</p>

<table>
<tr>
 <td style="text-align: center;">
<code> X[i,j,k] = sum A[i,r]*B[j,r]*C[k,r] + E[i,j,k] </code>
</td>
</tr>

</table>
 
<p>where <code>A = matrix(a,I,R)</code> are the Mode A (first mode) weights, <code>B = matrix(b,J,R)</code> are the Mode B (second mode) weights, <code>C = matrix(c,K,R)</code> are the Mode C (third mode) weights, and <code>E = array(e,dim=c(I,J,K))</code> is the 3-way residual array. The summation is for <code>r = seq(1,R)</code>.
</p>
<p>Given a 4-way array <code>X = array(x, dim = c(I,J,K,L))</code>, the 4-way Parafac model can be written as 
</p>

<table>
<tr>
 <td style="text-align: center;">
<code> X[i,j,k,l] = sum A[i,r]*B[j,r]*C[k,r]*D[l,r] + E[i,j,k,l] </code>
</td>
</tr>

</table>
 
<p>where <code>D = matrix(d,L,R)</code> are the Mode D (fourth mode) weights, <code>E = array(e,dim=c(I,J,K,L))</code> is the 4-way residual array, and the other terms can be interprered as previously described.
</p>
<p>Weight matrices are estimated using an alternating least squares algorithm with optional constraints.
</p>


<h3>Value</h3>

<p>If <code>output = "best"</code>, returns an object of class <code>"parafac"</code> with the following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Mode A weight matrix.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Mode B weight matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Mode C weight matrix.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Mode D weight matrix.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>See argument <code>const</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>See argument <code>control</code>.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>Logical vector indicating whether 'fixed' weights were used for each mode.</p>
</td></tr>
<tr><td><code>struc</code></td>
<td>
<p>Logical vector indicating whether 'struc' constraints were used for each mode.</p>
</td></tr>
</table>
<p>Otherwise returns a list of length <code>nstart</code> where each element is an object of class <code>"parafac"</code>.
</p>


<h3>Warnings </h3>

<p>The algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>


<h3>Note</h3>

<p>Missing data should be specified as <code>NA</code> values in the input <code>X</code>. The missing data are randomly initialized and then iteratively imputed as a part of the algorithm.
</p>
<p>Structure constraints should be specified with a matrix of logicals (TRUE/FALSE), such that FALSE elements indicate a weight should be constrained to be zero. Default uses unstructured weights, i.e., a matrix of all TRUE values. 
</p>
<p>When using unimodal constraints, the <code>*modes</code> inputs can be used to specify the mode search range for each factor. These inputs should be matrices with dimension <code>c(2,nfac)</code> where the first row gives the minimum mode value and the second row gives the maximum mode value (with respect to the indicies of the corresponding weight matrix).
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally, <code>cflag = 1</code> if maximum iteration limit was reached before convergence, and <code>cflag = 2</code> if algorithm terminated abnormally due to a problem with the constraints.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Harshman, R. A. (1970). Foundations of the PARAFAC procedure: Models and conditions for an &quot;explanatory&quot; multimodal factor analysis. <em>UCLA Working Papers in Phonetics, 16</em>, 1-84.
</p>
<p>Harshman, R. A., &amp; Lundy, M. E. (1994). PARAFAC: Parallel factor analysis. <em>Computational Statistics and Data Analysis, 18</em>, 39-72.
</p>
<p>Helwig, N. E. (2017). Estimating latent trends in multivariate longitudinal data via Parafac2 with functional and structural constraints. <em>Biometrical Journal, 59</em>(4), 783-803.
</p>
<p>Helwig, N. E. (in prep). Constrained parallel factor analysis via the R package multiway.
</p>
<p>Hitchcock, F. L. (1927). The expression of a tensor or a polyadic as a sum of products. <em>Journal of Mathematics and Physics, 6</em>, 164-189.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+cpd">cpd</a></code> function implements an N-way extension without constraints.
</p>
<p>The <code><a href="#topic+fitted.parafac">fitted.parafac</a></code> function creates the model-implied fitted values from a fit <code>"parafac"</code> object.
</p>
<p>The <code><a href="#topic+resign.parafac">resign.parafac</a></code> function can be used to resign factors from a fit <code>"parafac"</code> object.
</p>
<p>The <code><a href="#topic+rescale.parafac">rescale.parafac</a></code> function can be used to rescale factors from a fit <code>"parafac"</code> object.
</p>
<p>The <code><a href="#topic+reorder.parafac">reorder.parafac</a></code> function can be used to reorder factors from a fit <code>"parafac"</code> object.
</p>
<p>The <code><a href="CMLS.html#topic+cmls">cmls</a></code> function (from <b>CMLS</b> package) is called as a part of the alternating least squares algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   3-way example   ##########

# create random data array with Parafac structure
set.seed(3)
mydim &lt;- c(50, 20, 5)
nf &lt;- 3
Amat &lt;- matrix(rnorm(mydim[1]*nf), nrow = mydim[1], ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit Parafac model (unconstrained)
pfac &lt;- parafac(X, nfac = nf, nstart = 1)
pfac

# fit Parafac model (non-negativity on Modes B and C)
pfacNN &lt;- parafac(X, nfac = nf, nstart = 1, 
                  const = c("uncons", "nonneg", "nonneg"))
pfacNN

# check solution
Xhat &lt;- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)

# reorder and resign factors
pfac$B[1:4,]
pfac &lt;- reorder(pfac, c(3,1,2))
pfac$B[1:4,]
pfac &lt;- resign(pfac, mode="B")
pfac$B[1:4,]
Xhat &lt;- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)

# rescale factors
colSums(pfac$B^2)
colSums(pfac$C^2)
pfac &lt;- rescale(pfac, mode = "C", absorb = "B")
colSums(pfac$B^2)
colSums(pfac$C^2)
Xhat &lt;- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)


##########   4-way example   ##########

# create random data array with Parafac structure
set.seed(4)
mydim &lt;- c(30,10,8,10)
nf &lt;- 4
aseq &lt;- seq(-3, 3, length.out = mydim[1])
Amat &lt;- cbind(dnorm(aseq), dchisq(aseq+3.1, df=3),
              dt(aseq-2, df=4), dgamma(aseq+3.1, shape=3, rate=1))
Bmat &lt;- svd(matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf), nv = 0)$u
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Cstruc &lt;- Cmat &gt; 0.5
Cmat &lt;- Cmat * Cstruc
Dmat &lt;- matrix(runif(mydim[4]*nf), nrow = mydim[4], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Dmat, krprod(Cmat, Bmat)))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit Parafac model (unimodal and smooth A, orthogonal B, 
#                    non-negative and structured C, non-negative D)
pfac &lt;- parafac(X, nfac = nf, nstart = 1, Cstruc = Cstruc, 
                const = c("unismo", "orthog", "nonneg", "nonneg"))
pfac

# check solution
Xhat &lt;- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)
congru(Amat, pfac$A)
crossprod(pfac$B)
pfac$C
Cstruc

## Not run: 

##########   parallel computation   ##########

# create random data array with Parafac structure
set.seed(3)
mydim &lt;- c(50,20,5)
nf &lt;- 3
Amat &lt;- matrix(rnorm(mydim[1]*nf), nrow = mydim[1], ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- Xmat + Emat

# fit Parafac model (10 random starts -- sequential computation)
set.seed(1)
system.time({pfac &lt;- parafac(X, nfac = nf)})
pfac

# fit Parafac model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl, library(multiway))
clusterSetRNGStream(cl, 1)
system.time({pfac &lt;- parafac(X, nfac = nf, parallel = TRUE, cl = cl)})
pfac
stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='parafac2'>
Parallel Factor Analysis-2
</h2><span id='topic+parafac2'></span>

<h3>Description</h3>

<p>Fits Richard A. Harshman's Parallel Factors-2 (Parafac2) model to 3-way or 4-way ragged data arrays. Parameters are estimated via alternating least squares with optional constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parafac2(X, nfac, nstart = 10, const = NULL, control = NULL,
         Gfixed = NULL, Bfixed = NULL, Cfixed = NULL, Dfixed = NULL,
         Gstart = NULL, Bstart = NULL, Cstart = NULL, Dstart = NULL,
         Gstruc = NULL, Bstruc = NULL, Cstruc = NULL, Dstruc = NULL,
         Gmodes = NULL, Bmodes = NULL, Cmodes = NULL, Dmodes = NULL,
         maxit = 500, ctol = 1e-4, parallel = FALSE, cl = NULL,
         output = c("best", "all"), verbose = TRUE, backfit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parafac2_+3A_x">X</code></td>
<td>

<p>For 3-way Parafac2: list of length <code>K</code> where <code>k</code>-th element is <code>I[k]</code>-by-<code>J</code> matrix or three-way data array with <code>dim=c(I,J,K)</code>. For 4-way Parafac2: list of length <code>L</code> where <code>l</code>-th element is <code>I[l]</code>-by-<code>J</code>-by-<code>K</code> array or four-way data array with <code>dim=c(I,J,K,L)</code>. Missing data are allowed (see Note).
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_nfac">nfac</code></td>
<td>

<p>Number of factors.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_nstart">nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_const">const</code></td>
<td>

<p>Character vector of length 3 or 4 giving the constraints for each mode (defaults to unconstrained). See <code><a href="CMLS.html#topic+const">const</a></code> for the 24 available options. 
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_control">control</code></td>
<td>

<p>List of parameters controlling options for smoothness constraints. This is passed to <code><a href="#topic+const.control">const.control</a></code>, which describes the available options.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_gfixed">Gfixed</code></td>
<td>

<p>Used to fit model with fixed Phi matrix: <code>crossprod(Gfixed) = Phi</code>.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_bfixed">Bfixed</code></td>
<td>

<p>Used to fit model with fixed Mode B weights.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_cfixed">Cfixed</code></td>
<td>

<p>Used to fit model with fixed Mode C weights.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_dfixed">Dfixed</code></td>
<td>

<p>Used to fit model with fixed Mode D weights.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_gstart">Gstart</code></td>
<td>

<p>Starting Mode A crossproduct matrix: <code>crossprod(Gstart) = Phi</code>. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_bstart">Bstart</code></td>
<td>

<p>Starting Mode B weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_cstart">Cstart</code></td>
<td>

<p>Starting Mode C weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_dstart">Dstart</code></td>
<td>

<p>Starting Mode D weights. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_gstruc">Gstruc</code></td>
<td>

<p>Structure constraints for Mode A crossproduct matrix: <code>crossprod(Gstruc) = Phistruc</code>. See Note.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_bstruc">Bstruc</code></td>
<td>

<p>Structure constraints for Mode B weights. See Note.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_cstruc">Cstruc</code></td>
<td>

<p>Structure constraints for Mode C weights. See Note.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_dstruc">Dstruc</code></td>
<td>

<p>Structure constraints for Mode D weights. See Note.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_gmodes">Gmodes</code></td>
<td>

<p>Mode ranges for Mode A weights (for unimodality constraints). Ignored.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_bmodes">Bmodes</code></td>
<td>

<p>Mode ranges for Mode B weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_cmodes">Cmodes</code></td>
<td>

<p>Mode ranges for Mode C weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_dmodes">Dmodes</code></td>
<td>

<p>Mode ranges for Mode D weights (for unimodality constraints). See Note.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_ctol">ctol</code></td>
<td>

<p>Convergence tolerance (R^2 change).
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if <code><a href="parallel.html#topic+parLapply">parLapply</a></code> should be used. See Examples.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_cl">cl</code></td>
<td>

<p>Cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. Only used when <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_output">output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="parafac2_+3A_backfit">backfit</code></td>
<td>

<p>Should backfitting algorithm be used for <code><a href="CMLS.html#topic+cmls">cmls</a></code>?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of matrices <code>X[[k]] = matrix(xk,I[k],J)</code> for <code>k = seq(1,K)</code>, the 3-way Parafac2 model (with Mode A nested in Mode C) can be written as
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>X[[k]] = tcrossprod(A[[k]] %*% diag(C[k,]), B) + E[[k]]</code> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
subject to <code>crossprod(A[[k]]) = Phi</code> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>

<p>where <code>A[[k]] = matrix(ak,I[k],R)</code> are the Mode A (first mode) weights for the <code>k</code>-th level of Mode C (third mode), <code>Phi</code> is the common crossproduct matrix shared by all <code>K</code> levels of Mode C, <code>B = matrix(b,J,R)</code> are the Mode B (second mode) weights, <code>C = matrix(c,K,R)</code> are the Mode C (third mode) weights, and <code>E[[k]] = matrix(ek,I[k],J)</code> is the residual matrix corresponding to <code>k</code>-th level of Mode C.
</p>
<p>Given a list of arrays <code>X[[l]] = array(xl, dim = c(I[l],J,K))</code> for <code>l = seq(1,L)</code>, the 4-way Parafac2 model (with Mode A nested in Mode D) can be written as
</p>

<table>
<tr>
 <td style="text-align: right;">
<code>X[[l]][,,k] = tcrossprod(A[[l]] %*% diag(D[l,]*C[k,]), B) + E[[l]][,,k]</code> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
subject to <code>crossprod(A[[l]]) = Phi</code> </td>
</tr>
<tr>
 <td style="text-align: right;"> 
</td>
</tr>

</table>

<p>where <code>A[[l]] = matrix(al,I[l],R)</code> are the Mode A (first mode) weights for the <code>l</code>-th level of Mode D (fourth mode), <code>Phi</code> is the common crossproduct matrix shared by all <code>L</code> levels of Mode D, <code>D = matrix(d,L,R)</code> are the Mode D (fourth mode) weights, and <code>E[[l]] = array(el, dim = c(I[l],J,K))</code> is the residual array corresponding to <code>l</code>-th level of Mode D.
</p>
<p>Weight matrices are estimated using an alternating least squares algorithm with optional constraints.
</p>


<h3>Value</h3>

<p>If <code>output = "best"</code>, returns an object of class <code>"parafac2"</code> with the following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>List of Mode A weight matrices.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Mode B weight matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Mode C weight matrix.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Mode D weight matrix.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>Mode A crossproduct matrix.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code>cflag</code></td>
<td>
<p>Convergence flag. See Note.</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>See argument <code>const</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>See argument <code>control</code>.</p>
</td></tr>
<tr><td><code>fixed</code></td>
<td>
<p>Logical vector indicating whether 'fixed' weights were used for each mode.</p>
</td></tr>
<tr><td><code>struc</code></td>
<td>
<p>Logical vector indicating whether 'struc' constraints were used for each mode.</p>
</td></tr>
</table>
<p>Otherwise returns a list of length <code>nstart</code> where each element is an object of class <code>"parafac2"</code>.
</p>


<h3>Warnings </h3>

<p>The algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>


<h3>Note</h3>

<p>Missing data should be specified as <code>NA</code> values in the input <code>X</code>. The missing data are randomly initialized and then iteratively imputed as a part of the algorithm.
</p>
<p>Structure constraints should be specified with a matrix of logicals (TRUE/FALSE), such that FALSE elements indicate a weight should be constrained to be zero. Default uses unstructured weights, i.e., a matrix of all TRUE values. 
</p>
<p>When using unimodal constraints, the <code>*modes</code> inputs can be used to specify the mode search range for each factor. These inputs should be matrices with dimension <code>c(2,nfac)</code> where the first row gives the minimum mode value and the second row gives the maximum mode value (with respect to the indicies of the corresponding weight matrix).
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag = 0</code> if algorithm converged normally, <code>cflag = 1</code> if maximum iteration limit was reached before convergence, and <code>cflag = 2</code> if algorithm terminated abnormally due to a problem with the constraints.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Harshman, R. A. (1972). PARAFAC2: Mathematical and technical notes. <em>UCLA Working Papers in Phonetics, 22</em>, 30-44.
</p>
<p>Helwig, N. E. (2013). The special sign indeterminacy of the direct-fitting Parafac2 model: Some implications, cautions, and recommendations, for Simultaneous Component Analysis. <em>Psychometrika, 78</em>, 725-739.
</p>
<p>Helwig, N. E. (2017). Estimating latent trends in multivariate longitudinal data via Parafac2 with functional and structural constraints. <em>Biometrical Journal, 59</em>(4), 783-803.
</p>
<p>Helwig, N. E. (in prep). Constrained parallel factor analysis via the R package multiway.
</p>
<p>Kiers, H. A. L., ten Berge, J. M. F., &amp; Bro, R. (1999). PARAFAC2-part I: A direct-fitting algorithm for the PARAFAC2 model. <em>Journal of Chemometrics, 13</em>, 275-294.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+fitted.parafac2">fitted.parafac2</a></code> function creates the model-implied fitted values from a fit <code>"parafac2"</code> object.
</p>
<p>The <code><a href="#topic+resign.parafac2">resign.parafac2</a></code> function can be used to resign factors from a fit <code>"parafac2"</code> object.
</p>
<p>The <code><a href="#topic+rescale.parafac2">rescale.parafac2</a></code> function can be used to rescale factors from a fit <code>"parafac2"</code> object.
</p>
<p>The <code><a href="#topic+reorder.parafac2">reorder.parafac2</a></code> function can be used to reorder factors from a fit <code>"parafac2"</code> object.
</p>
<p>The <code><a href="CMLS.html#topic+cmls">cmls</a></code> function (from <b>CMLS</b> package) is called as a part of the alternating least squares algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   3-way example   ##########

# create random data list with Parafac2 structure
set.seed(3)
mydim &lt;- c(NA, 10, 20)
nf &lt;- 2
nk &lt;- rep(c(50, 100, 200), length.out = mydim[3])
Gmat &lt;- matrix(rnorm(nf^2), nrow = nf, ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- Emat &lt;- Amat &lt;- vector("list", mydim[3])
for(k in 1:mydim[3]){
  Amat[[k]] &lt;- matrix(rnorm(nk[k]*nf), nrow = nk[k], ncol = nf)
  Amat[[k]] &lt;- svd(Amat[[k]], nv = 0)$u %*% Gmat
  Xmat[[k]] &lt;- tcrossprod(Amat[[k]] %*% diag(Cmat[k,]), Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k]*mydim[2]), nrow = nk[k], ncol = mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- mapply("+", Xmat, Emat)

# fit Parafac2 model (unconstrained)
pfac &lt;- parafac2(X, nfac = nf, nstart = 1)
pfac

# check solution
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2])
crossprod(pfac$A[[1]])
crossprod(pfac$A[[2]])
pfac$Phi

# reorder and resign factors
pfac$B[1:4,]
pfac &lt;- reorder(pfac, 2:1)
pfac$B[1:4,]
pfac &lt;- resign(pfac, mode="B")
pfac$B[1:4,]
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2])

# rescale factors
colSums(pfac$B^2)
colSums(pfac$C^2)
pfac &lt;- rescale(pfac, mode = "C", absorb = "B")
colSums(pfac$B^2)
colSums(pfac$C^2)
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2])


##########   4-way example   ##########

# create random data list with Parafac2 structure
set.seed(4)
mydim &lt;- c(NA, 10, 20, 5)
nf &lt;- 3
nk &lt;- rep(c(50,100,200), length.out = mydim[4])
Gmat &lt;- matrix(rnorm(nf^2), nrow = nf, ncol = nf)
Bmat &lt;- scale(matrix(rnorm(mydim[2]*nf), nrow = mydim[2], ncol = nf), center = FALSE)
cseq &lt;- seq(-3, 3, length=mydim[3])
Cmat &lt;- cbind(pnorm(cseq), pgamma(cseq+3.1, shape=1, rate=1)*(3/4), pt(cseq-2, df=4)*2)
Dmat &lt;- scale(matrix(runif(mydim[4]*nf)*2, nrow = mydim[4], ncol = nf), center = FALSE)
Xmat &lt;- Emat &lt;- Amat &lt;- vector("list",mydim[4])
for(k in 1:mydim[4]){
  aseq &lt;- seq(-3, 3, length.out = nk[k])
  Amat[[k]] &lt;- cbind(sin(aseq), sin(abs(aseq)), exp(-aseq^2))
  Amat[[k]] &lt;- svd(Amat[[k]], nv = 0)$u %*% Gmat
  Xmat[[k]] &lt;- array(tcrossprod(Amat[[k]] %*% diag(Dmat[k,]),
                                krprod(Cmat, Bmat)), dim = c(nk[k], mydim[2], mydim[3]))
  Emat[[k]] &lt;- array(rnorm(nk[k] * mydim[2] * mydim[3]), dim = c(nk[k], mydim[2], mydim[3]))
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- mapply("+", Xmat, Emat)

# fit Parafac model (smooth A, unconstrained B, monotonic C, non-negative D)
pfac &lt;- parafac2(X, nfac = nf, nstart = 1, 
                 const = c("smooth", "uncons", "moninc", "nonneg"))
pfac

# check solution
Xhat &lt;- fitted(pfac)
sse &lt;- sumsq(mapply("-", Xmat, Xhat))
sse / (sum(nk) * mydim[2] * mydim[3])
crossprod(pfac$A[[1]])
crossprod(pfac$A[[2]])
pfac$Phi


## Not run: 

##########   parallel computation   ##########

# create random data list with Parafac2 structure
set.seed(3)
mydim &lt;- c(NA, 10, 20)
nf &lt;- 2
nk &lt;- rep(c(50, 100, 200), length.out = mydim[3])
Gmat &lt;- matrix(rnorm(nf^2), nrow = nf, ncol = nf)
Bmat &lt;- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat &lt;- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat &lt;- Emat &lt;- Hmat &lt;- vector("list", mydim[3])
for(k in 1:mydim[3]){
  Hmat[[k]] &lt;- svd(matrix(rnorm(nk[k] * nf), nrow = nk[k], ncol = nf), nv = 0)$u
  Xmat[[k]] &lt;- tcrossprod(Hmat[[k]] %*% Gmat %*% diag(Cmat[k,]), Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k] * mydim[2]), nrow = nk[k], mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X &lt;- mapply("+", Xmat, Emat)

# fit Parafac2 model (10 random starts -- sequential computation)
set.seed(1)
system.time({pfac &lt;- parafac2(X, nfac = nf)})
pfac

# fit Parafac2 model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl, library(multiway))
clusterSetRNGStream(cl, 1)
system.time({pfac &lt;- parafac2(X, nfac = nf, parallel = TRUE, cl = cl)})
pfac
stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='print'>
Print Multi-Way Model Results
</h2><span id='topic+print.cpd'></span><span id='topic+print.indscal'></span><span id='topic+print.mcr'></span><span id='topic+print.parafac'></span><span id='topic+print.parafac2'></span><span id='topic+print.sca'></span><span id='topic+print.tucker'></span>

<h3>Description</h3>

<p>Prints constraint, fit, and convergence details for a fit <code>multiway</code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpd'
print(x,...)
## S3 method for class 'indscal'
print(x,...)
## S3 method for class 'mcr'
print(x,...)
## S3 method for class 'parafac'
print(x,...)
## S3 method for class 'parafac2'
print(x,...)
## S3 method for class 'sca'
print(x,...)
## S3 method for class 'tucker'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>

<p>Object of class &quot;cpd&quot; (output from <code><a href="#topic+cpd">cpd</a></code>), class &quot;indscal&quot; (output from <code><a href="#topic+indscal">indscal</a></code>), class &quot;mcr&quot; (output from <code><a href="#topic+mcr">mcr</a></code>), class &quot;parafac&quot; (output from <code><a href="#topic+parafac">parafac</a></code>), class &quot;parafac2&quot; (output from <code><a href="#topic+parafac2">parafac2</a></code>), class &quot;sca&quot; (output from <code><a href="#topic+sca">sca</a></code>), or class &quot;tucker&quot; (output from <code><a href="#topic+tucker">tucker</a></code>).
</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+cpd">cpd</a></code>, <code><a href="#topic+indscal">indscal</a></code>, <code><a href="#topic+mcr">mcr</a></code>, <code><a href="#topic+parafac">parafac</a></code>, <code><a href="#topic+parafac2">parafac2</a></code>, <code><a href="#topic+sca">sca</a></code>, and <code><a href="#topic+tucker">tucker</a></code> for examples.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for... 
#   cpd (Canonical Polyadic Decomposition)
#   indscal (INividual Differences SCALing)
#   mcr (Multiway Covariates Regression)
#   parafac (Parallel Factor Analysis-1)
#   parafac2 (Parallel Factor Analysis-2)
#   sca (Simultaneous Component Analysis)
#   tucker (Tucker Factor Analysis)
</code></pre>

<hr>
<h2 id='reorder'>
Reorder Multi-Way Factors
</h2><span id='topic+reorder.cpd'></span><span id='topic+reorder.indscal'></span><span id='topic+reorder.mcr'></span><span id='topic+reorder.parafac'></span><span id='topic+reorder.parafac2'></span><span id='topic+reorder.sca'></span><span id='topic+reorder.tucker'></span>

<h3>Description</h3>

<p>Reorders factors from a <code>multiway</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpd'
reorder(x, neworder, ...)
## S3 method for class 'indscal'
reorder(x, neworder, ...)
## S3 method for class 'mcr'
reorder(x, neworder, mode = "A", ...)
## S3 method for class 'parafac'
reorder(x, neworder, ...)
## S3 method for class 'parafac2'
reorder(x, neworder, ...)
## S3 method for class 'sca'
reorder(x, neworder, ...)
## S3 method for class 'tucker'
reorder(x, neworder, mode = "A", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_+3A_x">x</code></td>
<td>

<p>Object of class &quot;cpd&quot; (output from <code><a href="#topic+cpd">cpd</a></code>), &quot;indscal&quot; (output from <code><a href="#topic+indscal">indscal</a></code>), class &quot;mcr&quot; (output from <code><a href="#topic+mcr">mcr</a></code>), class &quot;parafac&quot; (output from <code><a href="#topic+parafac">parafac</a></code>), class &quot;parafac2&quot; (output from <code><a href="#topic+parafac2">parafac2</a></code>), class &quot;sca&quot; (output from <code><a href="#topic+sca">sca</a></code>), or class &quot;tucker&quot; (output from <code><a href="#topic+tucker">tucker</a></code>).
</p>
</td></tr>
<tr><td><code id="reorder_+3A_neworder">neworder</code></td>
<td>

<p>Vector specifying the new factor ordering. Must be a permutation of the integers 1 to <code>nfac</code>.
</p>
</td></tr>
<tr><td><code id="reorder_+3A_mode">mode</code></td>
<td>

<p>Character indicating which mode to reorder (only for <code>tucker</code> models). For 3-way Tucker options include &quot;A&quot;, &quot;B&quot;, and &quot;C&quot;. For 4-way Tucker, options are &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, and &quot;D&quot;. 
</p>
</td></tr>
<tr><td><code id="reorder_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+cpd">cpd</a></code>, <code><a href="#topic+indscal">indscal</a></code>, <code><a href="#topic+mcr">mcr</a></code>, <code><a href="#topic+parafac">parafac</a></code>, <code><a href="#topic+parafac2">parafac2</a></code>, <code><a href="#topic+sca">sca</a></code>, and <code><a href="#topic+tucker">tucker</a></code> for more details.
</p>


<h3>Value</h3>

<p>Same as input.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for... 
#   cpd (Canonical Polyadic Decomposition)
#   indscal (INividual Differences SCALing)
#   mcr (Multiway Covariates Regression)
#   parafac (Parallel Factor Analysis-1)
#   parafac2 (Parallel Factor Analysis-2)
#   sca (Simultaneous Component Analysis)
#   tucker (Tucker Factor Analysis)
</code></pre>

<hr>
<h2 id='rescale'>
Rescales Multi-Way Factors
</h2><span id='topic+rescale'></span><span id='topic+rescale.cpd'></span><span id='topic+rescale.indscal'></span><span id='topic+rescale.mcr'></span><span id='topic+rescale.parafac'></span><span id='topic+rescale.parafac2'></span><span id='topic+rescale.sca'></span><span id='topic+rescale.tucker'></span>

<h3>Description</h3>

<p>Rescales factors from a <code>multiway</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpd'
rescale(x, mode = 1, newscale = 1, absorb = 3, ...)
## S3 method for class 'indscal'
rescale(x, mode = "B", newscale = 1, ...)
## S3 method for class 'mcr'
rescale(x, mode = "A", newscale = 1, absorb = "C", ...)
## S3 method for class 'parafac'
rescale(x, mode = "A", newscale = 1, absorb = "C", ...)
## S3 method for class 'parafac2'
rescale(x, mode = "A", newscale = 1, absorb = "C", ...)
## S3 method for class 'sca'
rescale(x, mode = "B", newscale = 1, ...)
## S3 method for class 'tucker'
rescale(x, mode = "A", newscale = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>

<p>Object of class &quot;indscal&quot; (output from <code><a href="#topic+indscal">indscal</a></code>), class &quot;mcr&quot; (output from <code><a href="#topic+mcr">mcr</a></code>), class &quot;parafac&quot; (output from <code><a href="#topic+parafac">parafac</a></code>), class &quot;parafac2&quot; (output from <code><a href="#topic+parafac2">parafac2</a></code>), class &quot;sca&quot; (output from <code><a href="#topic+sca">sca</a></code>), or class &quot;tucker&quot; (output from <code><a href="#topic+tucker">tucker</a></code>).
</p>
</td></tr>
<tr><td><code id="rescale_+3A_mode">mode</code></td>
<td>

<p>Character indicating which mode to rescale. For &quot;cpd&quot; objects, should be an integer between 1 and N.
</p>
</td></tr>
<tr><td><code id="rescale_+3A_newscale">newscale</code></td>
<td>

<p>Desired root mean-square for each column of rescaled mode. Can input a scalar or a vector with length equal to the number of factors for the given mode.
</p>
</td></tr>
<tr><td><code id="rescale_+3A_absorb">absorb</code></td>
<td>

<p>Character indicating which mode should absorb the inverse of the rescalings applied to <code>mode</code> (cannot be equal to <code>mode</code>). For &quot;cpd&quot; objects, should be an integer between 1 and N.
</p>
</td></tr>
<tr><td><code id="rescale_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+cpd">cpd</a></code>, <code><a href="#topic+indscal">indscal</a></code>, <code><a href="#topic+mcr">mcr</a></code>, <code><a href="#topic+parafac">parafac</a></code>, <code><a href="#topic+parafac2">parafac2</a></code>, <code><a href="#topic+sca">sca</a></code>, and <code><a href="#topic+tucker">tucker</a></code> for more details.
</p>


<h3>Value</h3>

<p>Same as input.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2013). The special sign indeterminacy of the direct-fitting Parafac2 model: Some implications, cautions, and recommendations, for Simultaneous Component Analysis. <em>Psychometrika, 78</em>, 725-739.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for... 
#   cpd (Canonical Polyadic Decomposition)
#   indscal (INividual Differences SCALing)
#   mcr (Multiway Covariates Regression)
#   parafac (Parallel Factor Analysis-1)
#   parafac2 (Parallel Factor Analysis-2)
#   sca (Simultaneous Component Analysis)
#   tucker (Tucker Factor Analysis)
</code></pre>

<hr>
<h2 id='resign'>
Resigns Multi-Way Factors
</h2><span id='topic+resign'></span><span id='topic+resign.cpd'></span><span id='topic+resign.indscal'></span><span id='topic+resign.mcr'></span><span id='topic+resign.parafac'></span><span id='topic+resign.parafac2'></span><span id='topic+resign.sca'></span><span id='topic+resign.tucker'></span>

<h3>Description</h3>

<p>Resigns factors from a <code>multiway</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cpd'
resign(x, mode = 1, newsign = 1, absorb = 3, ...)
## S3 method for class 'indscal'
resign(x, mode = "B", newsign = 1, ...)
## S3 method for class 'mcr'
resign(x, mode = "A", newsign = 1, absorb = "C", ...)
## S3 method for class 'parafac'
resign(x, mode = "A", newsign = 1, absorb = "C", ...)
## S3 method for class 'parafac2'
resign(x, mode = "A", newsign = 1, absorb = "C", method = "pearson", ...)
## S3 method for class 'sca'
resign(x, mode = "B", newsign = 1, ...)
## S3 method for class 'tucker'
resign(x, mode = "A",newsign = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resign_+3A_x">x</code></td>
<td>

<p>Object of class &quot;cpd&quot; (output from <code><a href="#topic+cpd">cpd</a></code>), &quot;indscal&quot; (output from <code><a href="#topic+indscal">indscal</a></code>), class &quot;mcr&quot; (output from <code><a href="#topic+mcr">mcr</a></code>), class &quot;parafac&quot; (output from <code><a href="#topic+parafac">parafac</a></code>), class &quot;parafac2&quot; (output from <code><a href="#topic+parafac2">parafac2</a></code>), class &quot;sca&quot; (output from <code><a href="#topic+sca">sca</a></code>), or class &quot;tucker&quot; (output from <code><a href="#topic+tucker">tucker</a></code>).
</p>
</td></tr>
<tr><td><code id="resign_+3A_mode">mode</code></td>
<td>

<p>Character indicating which mode to resign. For &quot;cpd&quot; objects, should be an integer between 1 and N.
</p>
</td></tr>
<tr><td><code id="resign_+3A_newsign">newsign</code></td>
<td>

<p>Desired resigning for each column of specified mode. Can input a scalar or a vector with length equal to the number of factors for the given mode. If <code>x</code> is of class &quot;parafac2&quot; and <code>mode="A"</code> you can input a list of covariates (see Details).
</p>
</td></tr>
<tr><td><code id="resign_+3A_absorb">absorb</code></td>
<td>

<p>Character indicating which mode should absorb the inverse of the rescalings applied to <code>mode</code> (cannot be equal to <code>mode</code>). For &quot;cpd&quot; objects, should be an integer between 1 and N.
</p>
</td></tr>
<tr><td><code id="resign_+3A_method">method</code></td>
<td>

<p>Correlation method to use if <code>newsign</code> is a list input (see Details).
</p>
</td></tr>
<tr><td><code id="resign_+3A_...">...</code></td>
<td>

<p>Ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is of class &quot;parafac2&quot; and <code>mode="A"</code>, the input <code>newsign</code> can be a list where each element contains a covariate vector for resigning Mode A. You need <code>length(newsign[[k]]) = nrow(x$A[[k]])</code> for all <code>k</code> when <code>newsign</code> is a list. In this case, the resigning is implemented according to the sign of <code>cor(newsign[[k]], x$A[[k]][,1], method)</code>. See Helwig (2013) for details.
</p>
<p>See <code><a href="#topic+cpd">cpd</a></code>, <code><a href="#topic+indscal">indscal</a></code>, <code><a href="#topic+mcr">mcr</a></code>, <code><a href="#topic+parafac">parafac</a></code>, <code><a href="#topic+parafac2">parafac2</a></code>, <code><a href="#topic+sca">sca</a></code>, and <code><a href="#topic+tucker">tucker</a></code> for more details.
</p>


<h3>Value</h3>

<p>Same as input.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2013). The special sign indeterminacy of the direct-fitting Parafac2 model: Some implications, cautions, and recommendations, for Simultaneous Component Analysis. <em>Psychometrika, 78</em>, 725-739.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See examples for... 
#   cpd (Canonical Polyadic Decomposition)
#   indscal (INividual Differences SCALing)
#   mcr (Multiway Covariates Regression)
#   parafac (Parallel Factor Analysis-1)
#   parafac2 (Parallel Factor Analysis-2)
#   sca (Simultaneous Component Analysis)
#   tucker (Tucker Factor Analysis)
</code></pre>

<hr>
<h2 id='sca'>
Simultaneous Component Analysis
</h2><span id='topic+sca'></span>

<h3>Description</h3>

<p>Fits Timmerman and Kiers's four Simultaneous Component Analysis (SCA) models to a 3-way data array or a list of 2-way arrays with the same number of columns. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sca(X, nfac, nstart = 10, maxit = 500,
    type = c("sca-p", "sca-pf2", "sca-ind", "sca-ecp"),
    rotation = c("none", "varimax", "promax"),
    ctol = 1e-4, parallel = FALSE, cl = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sca_+3A_x">X</code></td>
<td>

<p>List of length <code>K</code> where the <code>k</code>-th element contains the <code>I[k]</code>-by-<code>J</code> data matrix <code>X[[k]]</code>. If <code>I[k]=I[1]</code> for all <code>k</code>, can input 3-way data array with <code>dim=c(I,J,K)</code>.
</p>
</td></tr>
<tr><td><code id="sca_+3A_nfac">nfac</code></td>
<td>

<p>Number of factors.
</p>
</td></tr>
<tr><td><code id="sca_+3A_nstart">nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td></tr>
<tr><td><code id="sca_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="sca_+3A_type">type</code></td>
<td>

<p>Type of SCA model to fit. 
</p>
</td></tr>
<tr><td><code id="sca_+3A_rotation">rotation</code></td>
<td>

<p>Rotation to use for <code>type="sca-p"</code> or <code>type="sca-ecp"</code>.
</p>
</td></tr>
<tr><td><code id="sca_+3A_ctol">ctol</code></td>
<td>

<p>Convergence tolerance.
</p>
</td></tr>
<tr><td><code id="sca_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if <code><a href="parallel.html#topic+parLapply">parLapply</a></code> should be used. See Examples.
</p>
</td></tr>
<tr><td><code id="sca_+3A_cl">cl</code></td>
<td>

<p>Cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. Only used when <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="sca_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of matrices <code>X[[k]] = matrix(xk,I[k],J)</code> for <code>k = seq(1,K)</code>, the SCA model is 
</p>

<table>
<tr>
 <td style="text-align: center;">
X[[k]] = tcrossprod(D[[k]],B) + E[[k]]
</td>
</tr>

</table>

<p>where <code>D[[k]] = matrix(dk,I[k],R)</code> are the Mode A (first mode) weights for the <code>k</code>-th level of Mode C (third mode), <code>B = matrix(b,J,R)</code> are the Mode B (second mode) weights, and <code>E[[k]] = matrix(ek,I[k],J)</code> is the residual matrix corresponding to <code>k</code>-th level of Mode C. 
</p>
<p>There are four different versions of the SCA model: SCA with invariant pattern (SCA-P), SCA with Parafac2 constraints (SCA-PF2), SCA with INDSCAL constraints (SCA-IND), and SCA with equal average crossproducts (SCA-ECP). These four models differ with respect to the assumed crossproduct structure of the <code>D[[k]]</code> weights:
</p>

<table>
<tr>
 <td style="text-align: right;">
  SCA-P: </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code>crossprod(D[[k]])/I[k] = Phi[[k]]</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  SCA-PF2: </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code>crossprod(D[[k]])/I[k] = diag(C[k,])%*%Phi%*%diag(C[k,])</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  SCA-IND: </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code>crossprod(D[[k]])/I[k] = diag(C[k,]*C[k,])</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  SCA-ECP: </td><td style="text-align: center;"> </td><td style="text-align: left;"> <code>crossprod(D[[k]])/I[k] = Phi</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  </td>
</tr>

</table>

<p>where <code>Phi[[k]]</code> is specific to the <code>k</code>-th level of Mode C, <code>Phi</code> is common to all <code>K</code> levels of Mode C, and <code>C = matrix(c,K,R)</code> are the Mode C (third mode) weights. This function estimates the weight matrices <code>D[[k]]</code> and <code>B</code> (and <code>C</code> if applicable) using alternating least squares. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>D</code></td>
<td>
<p>List of length <code>K</code> where <code>k</code>-th element contains <code>D[[k]]</code>.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Mode B weight matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Mode C weight matrix.</p>
</td></tr>
<tr><td><code>Phi</code></td>
<td>
<p>Mode A common crossproduct matrix (if <code>type!="sca-p"</code>).</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code>cflag</code></td>
<td>
<p>Convergence flag.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Same as input <code>type</code>.</p>
</td></tr>
<tr><td><code>rotation</code></td>
<td>
<p>Same as input <code>rotation</code>.</p>
</td></tr>
</table>


<h3>Warnings </h3>

<p>The ALS algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>


<h3>Computational Details </h3>

<p>The least squares SCA-P solution can be obtained from the singular value decomposition of the stacked matrix <code>rbind(X[[1]],...,X[[K]])</code>.
</p>
<p>The least squares SCA-PF2 solution can be obtained using the uncontrained Parafac2 ALS algorithm (see <code><a href="#topic+parafac2">parafac2</a></code>).
</p>
<p>The least squares SCA-IND solution can be obtained using the Parafac2 ALS algorithm with orthogonality constraints on Mode A.
</p>
<p>The least squares SCA-ECP solution can be obtained using the Parafac2 ALS algorithm with orthogonality constraints on Mode A and the Mode C weights fixed at <code>C[k,] = rep(I[k]^0.5,R)</code>.
</p>


<h3>Note</h3>

<p>Default use is 10 random strarts (<code>nstart=10</code>) with 500 maximum iterations of the ALS algorithm for each start (<code>maxit=500</code>) using a convergence tolerance of 1e-4 (<code>ctol=1e-4</code>). The algorithm is determined to have converged once the change in R^2 is less than or equal to <code>ctol</code>.
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag=0</code> if ALS algorithm converged normally, <code>cflag=1</code> if maximum iteration limit was reached before convergence, and <code>cflag=2</code> if ALS algorithm terminated abnormally due to problem with non-negativity constraints.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Helwig, N. E. (2013). The special sign indeterminacy of the direct-fitting Parafac2 model: Some implications, cautions, and recommendations, for Simultaneous Component Analysis. <em>Psychometrika, 78</em>, 725-739.
</p>
<p>Timmerman, M. E., &amp; Kiers, H. A. L. (2003). Four simultaneous component models for the analysis of multivariate time series from more than one subject to model intraindividual and interindividual differences. <em>Psychometrika, 68</em>, 105-121.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   sca-p   ##########

# create random data list with SCA-P structure
set.seed(3)
mydim &lt;- c(NA,10,20)
nf &lt;- 2
nk &lt;- rep(c(50,100,200), length.out = mydim[3])
Dmat &lt;- matrix(rnorm(sum(nk)*nf),sum(nk),nf)
Bmat &lt;- matrix(runif(mydim[2]*nf),mydim[2],nf)
Dmats &lt;- vector("list",mydim[3])
Xmat &lt;- Emat &lt;- vector("list",mydim[3])
dfc &lt;- 0
for(k in 1:mydim[3]){
  dinds &lt;- 1:nk[k] + dfc
  Dmats[[k]] &lt;- Dmat[dinds,]
  dfc &lt;- dfc + nk[k]
  Xmat[[k]] &lt;- tcrossprod(Dmats[[k]],Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k]*mydim[2]),nk[k],mydim[2])
}
rm(Dmat)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- mapply("+",Xmat,Emat)

# fit SCA-P model (no rotation)
scamod &lt;- sca(X,nfac=nf,nstart=1)
scamod

# check solution
crossprod(scamod$D[[1]] %*% diag(scamod$C[1,]^-1) ) / nk[1]
crossprod(scamod$D[[5]] %*% diag(scamod$C[5,]^-1) ) / nk[5]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# reorder and resign factors
scamod$B[1:4,]
scamod &lt;- reorder(scamod, 2:1)
scamod$B[1:4,]
scamod &lt;- resign(scamod, mode="B", newsign=c(1,-1))
scamod$B[1:4,]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# rescale factors
colSums(scamod$B^2)
colSums(scamod$C^2)
scamod &lt;- rescale(scamod, mode="C")
colSums(scamod$B^2)
colSums(scamod$C^2)
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])


##########   sca-pf2   ##########

# create random data list with SCA-PF2 (Parafac2) structure
set.seed(3)
mydim &lt;- c(NA,10,20)
nf &lt;- 2
nk &lt;- rep(c(50,100,200), length.out = mydim[3])
Gmat &lt;- 10*matrix(rnorm(nf^2),nf,nf)
Bmat &lt;- matrix(runif(mydim[2]*nf),mydim[2],nf)
Cmat &lt;- matrix(runif(mydim[3]*nf),mydim[3],nf)
Xmat &lt;- Emat &lt;- Fmat &lt;- vector("list",mydim[3])
for(k in 1:mydim[3]){
  Fmat[[k]] &lt;- svd(matrix(rnorm(nk[k]*nf),nk[k],nf),nv=0)$u
  Xmat[[k]] &lt;- tcrossprod(Fmat[[k]]%*%Gmat%*%diag(Cmat[k,]),Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k]*mydim[2]),nk[k],mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- mapply("+",Xmat,Emat)

# fit SCA-PF2 model
scamod &lt;- sca(X,nfac=nf,nstart=1,type="sca-pf2")
scamod

# check solution
scamod$Phi
crossprod(scamod$D[[1]] %*% diag(scamod$C[1,]^-1) ) / nk[1]
crossprod(scamod$D[[5]] %*% diag(scamod$C[5,]^-1) ) / nk[5]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# reorder and resign factors
scamod$B[1:4,]
scamod &lt;- reorder(scamod, 2:1)
scamod$B[1:4,]
scamod &lt;- resign(scamod, mode="B", newsign=c(1,-1))
scamod$B[1:4,]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# rescale factors
colSums(scamod$B^2)
colSums(scamod$C^2)
scamod &lt;- rescale(scamod, mode="C")
colSums(scamod$B^2)
colSums(scamod$C^2)
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])


##########   sca-ind   ##########

# create random data list with SCA-IND structure
set.seed(3)
mydim &lt;- c(NA,10,20)
nf &lt;- 2
nk &lt;- rep(c(50,100,200), length.out = mydim[3])
Gmat &lt;- diag(nf)  # SCA-IND is Parafac2 with Gmat=identity
Bmat &lt;- matrix(runif(mydim[2]*nf),mydim[2],nf)
Cmat &lt;- 10*matrix(runif(mydim[3]*nf),mydim[3],nf)
Xmat &lt;- Emat &lt;- Fmat &lt;- vector("list",mydim[3])
for(k in 1:mydim[3]){
  Fmat[[k]] &lt;- svd(matrix(rnorm(nk[k]*nf),nk[k],nf),nv=0)$u
  Xmat[[k]] &lt;- tcrossprod(Fmat[[k]]%*%Gmat%*%diag(Cmat[k,]),Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k]*mydim[2]),nk[k],mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- mapply("+",Xmat,Emat)

# fit SCA-IND model
scamod &lt;- sca(X,nfac=nf,nstart=1,type="sca-ind")
scamod

# check solution
scamod$Phi
crossprod(scamod$D[[1]] %*% diag(scamod$C[1,]^-1) ) / nk[1]
crossprod(scamod$D[[5]] %*% diag(scamod$C[5,]^-1) ) / nk[5]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# reorder and resign factors
scamod$B[1:4,]
scamod &lt;- reorder(scamod, 2:1)
scamod$B[1:4,]
scamod &lt;- resign(scamod, mode="B", newsign=c(1,-1))
scamod$B[1:4,]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# rescale factors
colSums(scamod$B^2)
colSums(scamod$C^2)
scamod &lt;- rescale(scamod, mode="C")
colSums(scamod$B^2)
colSums(scamod$C^2)
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])


##########   sca-ecp   ##########

# create random data list with SCA-ECP structure
set.seed(3)
mydim &lt;- c(NA,10,20)
nf &lt;- 2
nk &lt;- rep(c(50,100,200), length.out = mydim[3])
Gmat &lt;- diag(nf)
Bmat &lt;- matrix(runif(mydim[2]*nf),mydim[2],nf)
Cmat &lt;- matrix(sqrt(nk),mydim[3],nf)
Xmat &lt;- Emat &lt;- Fmat &lt;- vector("list",mydim[3])
for(k in 1:mydim[3]){
  Fmat[[k]] &lt;- svd(matrix(rnorm(nk[k]*nf),nk[k],nf),nv=0)$u
  Xmat[[k]] &lt;- tcrossprod(Fmat[[k]]%*%Gmat%*%diag(Cmat[k,]),Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k]*mydim[2]),nk[k],mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- mapply("+",Xmat,Emat)

# fit SCA-ECP model
scamod &lt;- sca(X,nfac=nf,nstart=1,type="sca-ecp")
scamod

# check solution
scamod$Phi
crossprod(scamod$D[[1]] %*% diag(scamod$C[1,]^-1) ) / nk[1]
crossprod(scamod$D[[5]] %*% diag(scamod$C[5,]^-1) ) / nk[5]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# reorder and resign factors
scamod$B[1:4,]
scamod &lt;- reorder(scamod, 2:1)
scamod$B[1:4,]
scamod &lt;- resign(scamod, mode="B", newsign=c(-1,1))
scamod$B[1:4,]
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])

# rescale factors
colSums(scamod$B^2)
colSums(scamod$C^2)
scamod &lt;- rescale(scamod, mode="B")
colSums(scamod$B^2)
colSums(scamod$C^2)
Xhat &lt;- fitted(scamod)
sse &lt;- sumsq(mapply("-",Xmat,Xhat))
sse/(sum(nk)*mydim[2])


## Not run: 

##########   parallel computation   ##########

# create random data list with SCA-IND structure
set.seed(3)
mydim &lt;- c(NA,10,20)
nf &lt;- 2
nk &lt;- rep(c(50,100,200), length.out = mydim[3])
Gmat &lt;- diag(nf)  # SCA-IND is Parafac2 with Gmat=identity
Bmat &lt;- matrix(runif(mydim[2]*nf),mydim[2],nf)
Cmat &lt;- 10*matrix(runif(mydim[3]*nf),mydim[3],nf)
Xmat &lt;- Emat &lt;- Fmat &lt;- vector("list",mydim[3])
for(k in 1:mydim[3]){
  Fmat[[k]] &lt;- svd(matrix(rnorm(nk[k]*nf),nk[k],nf),nv=0)$u
  Xmat[[k]] &lt;- tcrossprod(Fmat[[k]]%*%Gmat%*%diag(Cmat[k,]),Bmat)
  Emat[[k]] &lt;- matrix(rnorm(nk[k]*mydim[2]),nk[k],mydim[2])
}
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- mapply("+",Xmat,Emat)

# fit SCA-PF2 model (10 random starts -- sequential computation)
set.seed(1)
system.time({scamod &lt;- sca(X,nfac=nf,type="sca-pf2")})
scamod

# fit SCA-PF2 model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl,library(multiway))
clusterSetRNGStream(cl, 1)
system.time({scamod &lt;- sca(X,nfac=nf,type="sca-pf2",parallel=TRUE,cl=cl)})
scamod
stopCluster(cl)

# fit SCA-IND model (10 random starts -- sequential computation)
set.seed(1)
system.time({scamod &lt;- sca(X,nfac=nf,type="sca-ind")})
scamod

# fit SCA-IND model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl,library(multiway))
clusterSetRNGStream(cl, 1)
system.time({scamod &lt;- sca(X,nfac=nf,type="sca-ind",parallel=TRUE,cl=cl)})
scamod
stopCluster(cl)

# fit SCA-ECP model (10 random starts -- sequential computation)
set.seed(1)
system.time({scamod &lt;- sca(X,nfac=nf,type="sca-ecp")})
scamod

# fit SCA-ECP model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl,library(multiway))
clusterSetRNGStream(cl, 1)
system.time({scamod &lt;- sca(X,nfac=nf,type="sca-ecp",parallel=TRUE,cl=cl)})
scamod
stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='smpower'>
Symmetric Matrix Power
</h2><span id='topic+smpower'></span>

<h3>Description</h3>

<p>Raise symmetric matrix to specified power. Default calculates symmetric square root.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smpower(X, power = 0.5, tol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smpower_+3A_x">X</code></td>
<td>

<p>Symmetric real-valued matrix.
</p>
</td></tr>
<tr><td><code id="smpower_+3A_power">power</code></td>
<td>

<p>Power to apply to eigenvalues of <code>X</code>.
</p>
</td></tr>
<tr><td><code id="smpower_+3A_tol">tol</code></td>
<td>

<p>Stability tolerance for eigenvalues.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically returns <code>tcrossprod(Y$vec%*%diag(Y$val^power),Y$vec)</code> where <code>Y = eigen(X,symmetric=TRUE)</code>.
</p>


<h3>Value</h3>

<p>Returns <code>X</code> raised to specified power.
</p>


<h3>Note</h3>

<p>Default tolerance is <code>tol = max(dim(X)) * .Machine$double.eps</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE   ##########

X &lt;- crossprod(matrix(rnorm(2000),100,20))
Xsqrt &lt;- smpower(X)         # square root
Xinv &lt;- smpower(X,-1)       # inverse
Xisqrt &lt;- smpower(X,-0.5)   # inverse square root

</code></pre>

<hr>
<h2 id='sumsq'>
Sum-of-Squares of Given Object
</h2><span id='topic+sumsq'></span>

<h3>Description</h3>

<p>Calculates the sum-of-squares of <code>X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumsq(X, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumsq_+3A_x">X</code></td>
<td>

<p>Numeric scalar, vector, list, matrix, or array.
</p>
</td></tr>
<tr><td><code id="sumsq_+3A_na.rm">na.rm</code></td>
<td>

<p>logical. Should missing values (including <code>NaN</code>) be removed?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sum-of-squares of <code>X</code>.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   EXAMPLE 1   ##########
X &lt;- 10
sumsq(X)


##########   EXAMPLE 2   ##########
X &lt;- 1:10
sumsq(X)


##########   EXAMPLE 3   ##########
X &lt;- matrix(1:10,5,2)
sumsq(X)


##########   EXAMPLE 4   ##########
X &lt;- array(matrix(1:10,5,2),dim=c(5,2,2))
sumsq(X)


##########   EXAMPLE 5   ##########
X &lt;- vector("list",5)
for(k in 1:5){ X[[k]] &lt;- matrix(1:10,5,2) }
sumsq(X)

</code></pre>

<hr>
<h2 id='tucker'>
Tucker Factor Analysis
</h2><span id='topic+tucker'></span>

<h3>Description</h3>

<p>Fits Ledyard R. Tucker's factor analysis model to 3-way or 4-way data arrays. Parameters are estimated via alternating least squares.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tucker(X, nfac, nstart = 10, Afixed = NULL,
       Bfixed = NULL, Cfixed = NULL, Dfixed = NULL,
       Bstart = NULL, Cstart = NULL, Dstart = NULL,
       maxit = 500, ctol = 1e-4, parallel = FALSE, cl = NULL, 
       output = c("best", "all"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tucker_+3A_x">X</code></td>
<td>

<p>Three-way data array with <code>dim=c(I,J,K)</code> or four-way data array with <code>dim=c(I,J,K,L)</code>. Missing data are allowed (see Note).
</p>
</td></tr>
<tr><td><code id="tucker_+3A_nfac">nfac</code></td>
<td>

<p>Number of factors in each mode.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_nstart">nstart</code></td>
<td>

<p>Number of random starts.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_afixed">Afixed</code></td>
<td>

<p>Fixed Mode A weights. Only used to fit model with fixed weights in Mode A.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_bfixed">Bfixed</code></td>
<td>

<p>Fixed Mode B weights. Only used to fit model with fixed weights in Mode B.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_cfixed">Cfixed</code></td>
<td>

<p>Fixed Mode C weights. Only used to fit model with fixed weights in Mode C.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_dfixed">Dfixed</code></td>
<td>

<p>Fixed Mode D weights. Only used to fit model with fixed weights in Mode D.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_bstart">Bstart</code></td>
<td>

<p>Starting Mode B weights for ALS algorithm. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_cstart">Cstart</code></td>
<td>

<p>Starting Mode C weights for ALS algorithm. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_dstart">Dstart</code></td>
<td>

<p>Starting Mode D weights for ALS algorithm. Default uses random weights.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_ctol">ctol</code></td>
<td>

<p>Convergence tolerance.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_parallel">parallel</code></td>
<td>

<p>Logical indicating if <code><a href="parallel.html#topic+parLapply">parLapply</a></code> should be used. See Examples.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_cl">cl</code></td>
<td>

<p>Cluster created by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>. Only used when <code>parallel=TRUE</code>.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_output">output</code></td>
<td>

<p>Output the best solution (default) or output all <code>nstart</code> solutions.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, fitting progress is printed via <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>. Ignored if <code>parallel=TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a 3-way array <code>X = array(x,dim=c(I,J,K))</code>, the 3-way Tucker model can be written as 
</p>

<table>
<tr>
 <td style="text-align: center;">
<code> X[i,j,k] = sum sum sum A[i,p]*B[j,q]*C[k,r]*G[p,q,r] + E[i,j,k] </code>
</td>
</tr>

</table>
 
<p>where <code>A = matrix(a,I,P)</code> are the Mode A (first mode) weights, <code>B = matrix(b,J,Q)</code> are the Mode B (second mode) weights, <code>C = matrix(c,K,R)</code> are the Mode C (third mode) weights, <code>G = array(g,dim=c(P,Q,R))</code> is the 3-way core array, and <code>E = array(e,dim=c(I,J,K))</code> is the 3-way residual array. The summations are for <code>p = seq(1,P)</code>, <code>q = seq(1,Q)</code>, and <code>r = seq(1,R)</code>.
</p>
<p>Given a 4-way array <code>X = array(x,dim=c(I,J,K,L))</code>, the 4-way Tucker model can be written as 
</p>

<table>
<tr>
 <td style="text-align: center;">
<code> X[i,j,k,l] = sum sum sum sum A[i,p]*B[j,q]*C[k,r]*D[l,s]*G[p,q,r,s] + E[i,j,k,l] </code>
</td>
</tr>

</table>
 
<p>where <code>D = matrix(d,L,S)</code> are the Mode D (fourth mode) weights, <code>G = array(g,dim=c(P,Q,R,S))</code> is the 4-way residual array, <code>E = array(e,dim=c(I,J,K,L))</code> is the 4-way residual array, and the other terms can be interprered as previously described.
</p>
<p>Weight matrices are estimated using an alternating least squares algorithm.
</p>


<h3>Value</h3>

<p>If <code>output="best"</code>, returns an object of class <code>"tucker"</code> with the following elements:
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p>Mode A weight matrix.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>Mode B weight matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Mode C weight matrix.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Mode D weight matrix.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Core array.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of Squared Errors.</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared value.</p>
</td></tr>
<tr><td><code>GCV</code></td>
<td>
<p>Generalized Cross-Validation.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>Effective degrees of freedom.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations.</p>
</td></tr>
<tr><td><code>cflag</code></td>
<td>
<p>Convergence flag.</p>
</td></tr>
</table>
<p>Otherwise returns a list of length <code>nstart</code> where each element is an object of class <code>"tucker"</code>.
</p>


<h3>Warnings </h3>

<p>The ALS algorithm can perform poorly if the number of factors <code>nfac</code> is set too large.
</p>
<p>Input matrices in <code>Afixed</code>, <code>Bfixed</code>, <code>Cfixed</code>, <code>Dfixed</code>, <code>Bstart</code>, <code>Cstart</code>, and <code>Dstart</code> must be columnwise orthonormal.
</p>


<h3>Note</h3>

<p>Default use is 10 random strarts (<code>nstart=10</code>) with 500 maximum iterations of the ALS algorithm for each start (<code>maxit=500</code>) using a convergence tolerance of 1e-4 (<code>ctol=1e-4</code>). The algorithm is determined to have converged once the change in R^2 is less than or equal to <code>ctol</code>.
</p>
<p>Output <code>cflag</code> gives convergence information: <code>cflag=0</code> if ALS algorithm converged normally, and <code>cflag=1</code> if maximum iteration limit was reached before convergence.
</p>
<p>Missing data should be specified as <code>NA</code> values in the input <code>X</code>. The missing data are randomly initialized and then iteratively imputed as a part of the ALS algorithm.
</p>


<h3>Author(s)</h3>

<p>Nathaniel E. Helwig &lt;helwig@umn.edu&gt;
</p>


<h3>References</h3>

<p>Kroonenberg, P. M., &amp; de Leeuw, J. (1980). Principal component analysis of three-mode data by means of alternating least squares algorithms. <em>Psychometrika, 45</em>, 69-97.
</p>
<p>Tucker, L. R. (1966). Some mathematical notes on three-mode factor analysis. <em>Psychometrika, 31</em>, 279-311.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##########   3-way example   ##########

####****####   TUCKER3   ####****####

# create random data array with Tucker3 structure
set.seed(3)
mydim &lt;- c(50,20,5)
nf &lt;- c(3,2,3)
Amat &lt;- matrix(rnorm(mydim[1]*nf[1]), mydim[1], nf[1])
Amat &lt;- svd(Amat, nu = nf[1], nv = 0)$u
Bmat &lt;- matrix(rnorm(mydim[2]*nf[2]), mydim[2], nf[2])
Bmat &lt;- svd(Bmat, nu = nf[2], nv = 0)$u
Cmat &lt;- matrix(rnorm(mydim[3]*nf[3]), mydim[3], nf[3])
Cmat &lt;- svd(Cmat, nu = nf[3], nv = 0)$u
Gmat &lt;- matrix(rnorm(prod(nf)), nf[1], prod(nf[2:3]))
Xmat &lt;- tcrossprod(Amat %*% Gmat, kronecker(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- Xmat + Emat

# fit Tucker3 model
tuck &lt;- tucker(X, nfac = nf, nstart = 1)
tuck

# check solution
Xhat &lt;- fitted(tuck)
sum((Xmat-Xhat)^2) / prod(mydim)

# reorder mode="A"
tuck$A[1:4,]
tuck$G
tuck &lt;- reorder(tuck, neworder = c(3,1,2), mode = "A")
tuck$A[1:4,]
tuck$G
Xhat &lt;- fitted(tuck)
sum((Xmat-Xhat)^2)/prod(mydim)

# reorder mode="B"
tuck$B[1:4,]
tuck$G
tuck &lt;- reorder(tuck, neworder=2:1, mode="B")
tuck$B[1:4,]
tuck$G
Xhat &lt;- fitted(tuck)
sum((Xmat-Xhat)^2)/prod(mydim)

# resign mode="C"
tuck$C[1:4,]
tuck &lt;- resign(tuck, mode="C")
tuck$C[1:4,]
Xhat &lt;- fitted(tuck)
sum((Xmat-Xhat)^2)/prod(mydim)


####****####   TUCKER2   ####****####

# create random data array with Tucker2 structure
set.seed(3)
mydim &lt;- c(50, 20, 5)
nf &lt;- c(3, 2, mydim[3])
Amat &lt;- matrix(rnorm(mydim[1]*nf[1]), mydim[1], nf[1])
Amat &lt;- svd(Amat, nu = nf[1], nv = 0)$u
Bmat &lt;- matrix(rnorm(mydim[2]*nf[2]), mydim[2], nf[2])
Bmat &lt;- svd(Bmat, nu = nf[2], nv = 0)$u
Cmat &lt;- diag(nf[3])
Gmat &lt;- matrix(rnorm(prod(nf)), nf[1], prod(nf[2:3]))
Xmat &lt;- tcrossprod(Amat %*% Gmat, kronecker(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- Xmat + Emat

# fit Tucker2 model
tuck &lt;- tucker(X, nfac = nf, nstart = 1, Cfixed = diag(nf[3]))
tuck

# check solution
Xhat &lt;- fitted(tuck)
sum((Xmat-Xhat)^2) / prod(mydim)


####****####   TUCKER1   ####****####

# create random data array with Tucker1 structure
set.seed(3)
mydim &lt;- c(50, 20, 5)
nf &lt;- c(3, mydim[2:3])
Amat &lt;- matrix(rnorm(mydim[1]*nf[1]), mydim[1], nf[1])
Amat &lt;- svd(Amat, nu = nf[1], nv = 0)$u
Bmat &lt;- diag(nf[2])
Cmat &lt;- diag(nf[3])
Gmat &lt;- matrix(rnorm(prod(nf)), nf[1], prod(nf[2:3]))
Xmat &lt;- tcrossprod(Amat %*% Gmat, kronecker(Cmat, Bmat))
Xmat &lt;- array(Xmat, dim = mydim)
Emat &lt;- array(rnorm(prod(mydim)), dim = mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- Xmat + Emat

# fit Tucker1 model
tuck &lt;- tucker(X, nfac = nf, nstart = 1,
               Bfixed = diag(nf[2]), Cfixed = diag(nf[3]))
tuck

# check solution
Xhat &lt;- fitted(tuck)
sum((Xmat-Xhat)^2) / prod(mydim)

# closed-form Tucker1 solution via SVD
tsvd &lt;- svd(matrix(X, nrow = mydim[1]), nu = nf[1], nv = nf[1])
Gmat0 &lt;- t(tsvd$v %*% diag(tsvd$d[1:nf[1]]))
Xhat0 &lt;- array(tsvd$u %*% Gmat0, dim = mydim)
sum((Xmat-Xhat0)^2) / prod(mydim)

# get Mode A weights and core array 
tuck0 &lt;- NULL
tuck0$A &lt;- tsvd$u                   # A weights
tuck0$G &lt;- array(Gmat0, dim = nf)   # core array



##########   4-way example   ##########

# create random data array with Tucker structure
set.seed(4)
mydim &lt;- c(30,10,8,10)
nf &lt;- c(2,3,4,3)
Amat &lt;- svd(matrix(rnorm(mydim[1]*nf[1]),mydim[1],nf[1]),nu=nf[1])$u
Bmat &lt;- svd(matrix(rnorm(mydim[2]*nf[2]),mydim[2],nf[2]),nu=nf[2])$u
Cmat &lt;- svd(matrix(rnorm(mydim[3]*nf[3]),mydim[3],nf[3]),nu=nf[3])$u
Dmat &lt;- svd(matrix(rnorm(mydim[4]*nf[4]),mydim[4],nf[4]),nu=nf[4])$u
Gmat &lt;- array(rnorm(prod(nf)),dim=nf)
Xmat &lt;- array(tcrossprod(Amat%*%matrix(Gmat,nf[1],prod(nf[2:4])),
                      kronecker(Dmat,kronecker(Cmat,Bmat))),dim=mydim)
Emat &lt;- array(rnorm(prod(mydim)),dim=mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- Xmat + Emat

# fit Tucker model
tuck &lt;- tucker(X,nfac=nf,nstart=1)
tuck

# check solution
Xhat &lt;- fitted(tuck)
sum((Xmat-Xhat)^2)/prod(mydim)


## Not run: 

##########   parallel computation   ##########

# create random data array with Tucker structure
set.seed(3)
mydim &lt;- c(50,20,5)
nf &lt;- c(3,2,3)
Amat &lt;- svd(matrix(rnorm(mydim[1]*nf[1]),mydim[1],nf[1]),nu=nf[1])$u
Bmat &lt;- svd(matrix(rnorm(mydim[2]*nf[2]),mydim[2],nf[2]),nu=nf[2])$u
Cmat &lt;- svd(matrix(rnorm(mydim[3]*nf[3]),mydim[3],nf[3]),nu=nf[3])$u
Gmat &lt;- array(rnorm(prod(nf)),dim=nf)
Xmat &lt;- array(tcrossprod(Amat%*%matrix(Gmat,nf[1],nf[2]*nf[3]),kronecker(Cmat,Bmat)),dim=mydim)
Emat &lt;- array(rnorm(prod(mydim)),dim=mydim)
Emat &lt;- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR=1
X &lt;- Xmat + Emat

# fit Tucker model (10 random starts -- sequential computation)
set.seed(1)
system.time({tuck &lt;- tucker(X,nfac=nf)})
tuck$Rsq

# fit Tucker model (10 random starts -- parallel computation)
cl &lt;- makeCluster(detectCores())
ce &lt;- clusterEvalQ(cl,library(multiway))
clusterSetRNGStream(cl, 1)
system.time({tuck &lt;- tucker(X,nfac=nf,parallel=TRUE,cl=cl)})
tuck$Rsq
stopCluster(cl)

## End(Not run)

</code></pre>

<hr>
<h2 id='USalcohol'>
United States Alcohol Consumption Data (1970-2013)
</h2><span id='topic+USalcohol'></span>

<h3>Description</h3>

<p>This dataset contains yearly (1970-2013) consumption data from the 50 United States and the District of Columbia for three types of alcoholic beverages: spirits, wine, and beer. The data were obtained from the National Institute on Alcohol Abuse and Alcoholism (NIAAA) Surveillance Report #102 (see below link).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("USalcohol")</code></pre>


<h3>Format</h3>

<p>A data frame with 6732 observations on the following 8 variables.
</p>

<dl>
<dt><code>year</code></dt><dd><p>integer Year (1970-2013)</p>
</dd>
<dt><code>state</code></dt><dd><p>factor State Name (51 levels)</p>
</dd>
<dt><code>region</code></dt><dd><p>factor Region Name (4 levels)</p>
</dd>
<dt><code>type</code></dt><dd><p>factor Beverage Type (3 levels)</p>
</dd>
<dt><code>beverage</code></dt><dd><p>numeric Beverage Consumed (thousands of gallons)</p>
</dd>
<dt><code>ethanol</code></dt><dd><p>numeric Absolute Alcohol Consumed (thousands of gallons)</p>
</dd>
<dt><code>pop14</code></dt><dd><p>numeric Population Age 14 and Older (thousands of people)</p>
</dd>
<dt><code>pop21</code></dt><dd><p>numeric Population Age 21 and Older (thousands of people)</p>
</dd>
</dl>



<h3>Details</h3>

<p>In the data source, the population age 21 and older for Mississippi in year 1989 is reported to be 3547.839 thousand, which is incorrect. In this dataset, the miscoded population value has been replaced with the average of the corresponding 1988 population (1709 thousand) and the 1990 population (1701.527 thousand). 
</p>


<h3>Source</h3>

<p><a href="https://pubs.niaaa.nih.gov/publications/surveillance102/pcyr19702013.txt">https://pubs.niaaa.nih.gov/publications/surveillance102/pcyr19702013.txt</a>
</p>


<h3>References</h3>

<p>Haughwout, S. P., LaVallee, R. A., &amp; Castle, I-J. P. (2015). 
Surveillance Report #102: Apparent Per Capita Alcohol Consumption: 
National, State, and Regional Trends, 1977-2013. Bethesda, MD: NIAAA,
Alcohol Epidemiologic Data System.
</p>
<p>Helwig, N. E. (2017). Estimating latent trends in multivariate longitudinal data via Parafac2 with functional and structural constraints. <em>Biometrical Journal, 59</em>(4), 783-803.
</p>
<p>Nephew, T. M., Yi, H., Williams, G. D., Stinson, F. S., &amp; Dufour, M.C., (2004). 
U.S. Alcohol Epidemiologic Data Reference Manual, Vol. 1, 4th ed. 
U.S. Apparent Consumption of Alcoholic Beverages Based on State Sales, 
Taxation, or Receipt Data. Bethesda, MD: NIAAA, Alcohol Epidemiologic Data 
System. NIH Publication No. 04-5563.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data and print first six rows
data(USalcohol)
head(USalcohol)

# form tensor (time x variables x state)
Xbev &lt;- with(USalcohol, tapply(beverage/pop21, list(year, type, state), c))
Xeth &lt;- with(USalcohol, tapply(ethanol/pop21, list(year, type, state), c))
X &lt;- array(0, dim=c(44, 6, 51))
X[, c(1,3,5) ,] &lt;- Xbev
X[, c(2,4,6) ,] &lt;- Xeth
dnames &lt;- dimnames(Xbev)
dnames[[2]] &lt;- c(paste0(dnames[[2]],".bev"), paste0(dnames[[2]],".eth"))[c(1,4,2,5,3,6)]
dimnames(X) &lt;- dnames

# center each variable across time (within state)
Xc &lt;- ncenter(X, mode = 1)

# scale each variable to have mean square of 1 (across time and states)
Xs &lt;- nscale(Xc, mode = 2)

# fit parafac model with 3 factors
set.seed(1)
pfac &lt;- parafac(Xs, nfac = 3, nstart = 1)

# fit parafac model with functional constraints
set.seed(1)
pfacF &lt;- parafac(Xs, nfac = 3, nstart = 1, 
                 const = c("smooth", NA, NA))

# fit parafac model with functional and structural constraints
Bstruc &lt;- matrix(c(rep(c(TRUE,FALSE), c(2,4)), 
                   rep(c(FALSE,TRUE,FALSE), c(2,2,2)),
                   rep(c(FALSE,TRUE), c(4,2))), nrow=6, ncol=3)
set.seed(1)
pfacFS &lt;- parafac(Xs, nfac = 3, nstart = 1, 
                  const = c("smooth", NA, NA), Bstruc = Bstruc)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
