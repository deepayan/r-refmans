<!DOCTYPE html><html lang="en"><head><title>Help for package mcparallelDo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mcparallelDo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mcparallelDo-package'><p>mcparallelDo-package placeholder</p></a></li>
<li><a href='#checkIfJobStillRunning'><p>checkIfJobStillRunning</p></a></li>
<li><a href='#jobCompleteSelfDestructingHandler'><p>jobCompleteDestructingHandler</p></a></li>
<li><a href='#mcparallelDo'><p>mcparallelDo</p></a></li>
<li><a href='#mcparallelDoCheck'><p>mcparallelDoCheck</p></a></li>
<li><a href='#mcparallelDoManagerClass'><p>The mcparallelDoManager Class and Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Simplified Interface for Running Commands on Parallel
Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-07-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Russell S. Pierce</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Russell S. Pierce &lt;russell.s.pierce@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a function that wraps 
    mcparallel() and mccollect() from 'parallel' with temporary variables and a 
    task handler.  Wrapped in this way the results of an mcparallel() call 
    can be returned to the R session when the fork is complete 
    without explicitly issuing a specific mccollect() to retrieve the value.
    Outside of top-level tasks, multiple mcparallel() jobs can be retrieved with 
    a single call to mcparallelDoCheck().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, R.utils, checkmate (&ge; 1.6.3), R6</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/drknexus/mcparallelDo">https://github.com/drknexus/mcparallelDo</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/drknexus/mcparallelDo/issues">https://github.com/drknexus/mcparallelDo/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-07-24 16:50:52 UTC; russellpierce</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-07-24 19:43:57</td>
</tr>
</table>
<hr>
<h2 id='mcparallelDo-package'>mcparallelDo-package placeholder</h2><span id='topic+mcparallelDo-package'></span>

<h3>Description</h3>

<p>Asynchronous Exploritory Data Analysis
</p>


<h3>Details</h3>

<p>The primary function of this package is mcparallelDo().  
To use mcparallelDo(), simply invoke the function with a curly braced wrapped code and the character element name to which you want to assign the results.
</p>

<hr>
<h2 id='checkIfJobStillRunning'>checkIfJobStillRunning</h2><span id='topic+checkIfJobStillRunning'></span>

<h3>Description</h3>

<p>checkIfJobStillRunning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkIfJobStillRunning(targetJob, targetValue, verbose, targetEnvironment)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkIfJobStillRunning_+3A_targetjob">targetJob</code></td>
<td>
<p>(character) The job name</p>
</td></tr>
<tr><td><code id="checkIfJobStillRunning_+3A_targetvalue">targetValue</code></td>
<td>
<p>(character) The return variable name</p>
</td></tr>
<tr><td><code id="checkIfJobStillRunning_+3A_verbose">verbose</code></td>
<td>
<p>(logical) Whether a message will be generated when complete</p>
</td></tr>
<tr><td><code id="checkIfJobStillRunning_+3A_targetenvironment">targetEnvironment</code></td>
<td>
<p>(environment) Target environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical; TRUE if still running; FALSE if not running
</p>

<hr>
<h2 id='jobCompleteSelfDestructingHandler'>jobCompleteDestructingHandler</h2><span id='topic+jobCompleteSelfDestructingHandler'></span>

<h3>Description</h3>

<p>Creates a callback handler function that can be added via addTaskCallback().
These functions run at the end of each completed R statement.
This particular handler watches for the completion of the target job, which is created via mcparallel()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jobCompleteSelfDestructingHandler(targetJob, targetValue, verbose,
  targetEnvironment)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jobCompleteSelfDestructingHandler_+3A_targetjob">targetJob</code></td>
<td>
<p>(character) Name of the mcparallel job variable that is waiting for a result</p>
</td></tr>
<tr><td><code id="jobCompleteSelfDestructingHandler_+3A_targetvalue">targetValue</code></td>
<td>
<p>A character element indicating the variable that the result of that job should be assigned to targetEnvironment</p>
</td></tr>
<tr><td><code id="jobCompleteSelfDestructingHandler_+3A_verbose">verbose</code></td>
<td>
<p>A boolean element; if TRUE the completion of the fork expr will be accompanied by a message</p>
</td></tr>
<tr><td><code id="jobCompleteSelfDestructingHandler_+3A_targetenvironment">targetEnvironment</code></td>
<td>
<p>The environment in which you want targetValue to be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>callback handler function
</p>

<hr>
<h2 id='mcparallelDo'>mcparallelDo</h2><span id='topic++25mcpDo+25'></span><span id='topic+mcparallelDo'></span>

<h3>Description</h3>

<p>This function creates a fork, 
sets the variable named <code>targetValue</code> in the <code>targetEnvironment</code> to NULL,
evaluates a segment of code evaluated in the fork, 
and the result of the fork returned in a variable named <code>targetValue</code> in the <code>targetEnvironment</code> after the next top-level command completes.
If there is an error in the code, the returned variable will be a <code>try-error</code>.
These effects are accomplished via the automatic creation and destruction of a taskCallback and other functions inside the mcparallelDoManager.
If job results have to be collected before you return to the top level, use <a href="#topic+mcparallelDoCheck">mcparallelDoCheck</a>.
</p>
<p>%mdpDo% Is an alternate form of calling the function, as if it were an assignment operator.  See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcparallelDo(code, targetValue, verbose = TRUE,
  targetEnvironment = .GlobalEnv)

targetValue %mcpDo% code
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcparallelDo_+3A_code">code</code></td>
<td>
<p>The code to evaluate within a fork wrapped in </p>
</td></tr>
<tr><td><code id="mcparallelDo_+3A_targetvalue">targetValue</code></td>
<td>
<p>A character element indicating the variable that the result of that job should be assigned to targetEnvironment</p>
</td></tr>
<tr><td><code id="mcparallelDo_+3A_verbose">verbose</code></td>
<td>
<p>A boolean element; if TRUE the completion of the fork expr will be accompanied by a message</p>
</td></tr>
<tr><td><code id="mcparallelDo_+3A_targetenvironment">targetEnvironment</code></td>
<td>
<p>The environment in which you want targetValue to be created</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>verbose</code> is set to TRUE, then the <code>character</code> variable name of the job. This can be manually collected via mccollect or, if on Windows, an empty string.  If <code>verbose</code> is set to FALSE, then NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create data
data(ToothGrowth)
## Trigger mcparallelDo to perform analysis on a fork
mcparallelDo({glm(len ~ supp * dose, data=ToothGrowth)},"interactionPredictorModel")
## Do other things
binaryPredictorModel &lt;- glm(len ~ supp, data=ToothGrowth)
gaussianPredictorModel &lt;- glm(len ~ dose, data=ToothGrowth)
## The result from mcparallelDo returns in your targetEnvironment, 
## e.g. .GlobalEnv, when it is complete with a message (by default)
summary(interactionPredictorModel)

# Example of not returning a value until we return to the top level
for (i in 1:10) {
  if (i == 1) {
    mcparallelDo({2+2}, targetValue = "output")
  }
  if (exists("output")) print(i)
}

# Example of getting a value without returning to the top level
for (i in 1:10) {
  if (i == 1) {
    mcparallelDo({2+2}, targetValue = "output")
  }
  mcparallelDoCheck()
  if (exists("output")) print(i)
}

# Example of dispatching as assignment
targetValueWithoutQuotes %mcpDo% sample(LETTERS, 10)

</code></pre>

<hr>
<h2 id='mcparallelDoCheck'>mcparallelDoCheck</h2><span id='topic+mcparallelDoCheck'></span>

<h3>Description</h3>

<p>Forces a check on all mcparallelDo() jobs and returns their values to the target environment if they are complete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcparallelDoCheck()
</code></pre>


<h3>Value</h3>

<p>A named logical vector, TRUE if complete, FALSE if not complete, and an empty logical vector if on Windows
</p>

<hr>
<h2 id='mcparallelDoManagerClass'>The mcparallelDoManager Class and Object</h2><span id='topic+mcparallelDoManager'></span><span id='topic+mcparallelDoManagerClass'></span>

<h3>Description</h3>

<p>The mcparallelDoManager Class and Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcparallelDoManagerClass
</code></pre>


<h3>Format</h3>

<p>An object of class <code>R6ClassGenerator</code> of length 24.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
