<!DOCTYPE html><html><head><title>Help for package simstudy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simstudy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#simstudy-package'><p>simstudy: Simulation of Study Data</p></a></li>
<li><a href='#addColumns'><p>Add columns to existing data set</p></a></li>
<li><a href='#addCompRisk'><p>Generating single competing risk survival variable</p></a></li>
<li><a href='#addCondition'><p>Add a single column to existing data set based on a condition</p></a></li>
<li><a href='#addCorData'><p>Add correlated data to existing data.table</p></a></li>
<li><a href='#addCorFlex'><p>Create multivariate (correlated) data - for general distributions</p></a></li>
<li><a href='#addCorGen'><p>Create multivariate (correlated) data - for general distributions</p></a></li>
<li><a href='#addMarkov'><p>Add Markov chain</p></a></li>
<li><a href='#addMultiFac'><p>Add multi-factorial data</p></a></li>
<li><a href='#addPeriods'><p>Create longitudinal/panel data</p></a></li>
<li><a href='#addSynthetic'><p>Add synthetic data to existing data set</p></a></li>
<li><a href='#betaGetShapes'><p>Convert beta mean and precision parameters to two shape parameters</p></a></li>
<li><a href='#blockDecayMat'><p>Create a block correlation matrix</p></a></li>
<li><a href='#blockExchangeMat'><p>Create a block correlation matrix with exchangeable structure</p></a></li>
<li><a href='#catProbs'><p>Generate Categorical Formula</p></a></li>
<li><a href='#defCondition'><p>Add single row to definitions table of conditions that will be used to add data to an</p>
existing definitions table</a></li>
<li><a href='#defData'><p>Add single row to definitions table</p></a></li>
<li><a href='#defDataAdd'><p>Add single row to definitions table that will be used to add data to an</p>
existing data.table</a></li>
<li><a href='#defMiss'><p>Definitions for missing data</p></a></li>
<li><a href='#defRead'><p>Read external csv data set definitions</p></a></li>
<li><a href='#defReadAdd'><p>Read external csv data set definitions for adding columns</p></a></li>
<li><a href='#defReadCond'><p>Read external csv data set definitions for adding columns</p></a></li>
<li><a href='#defRepeat'><p>Add multiple (similar) rows to definitions table</p></a></li>
<li><a href='#defRepeatAdd'><p>Add multiple (similar) rows to definitions table that will be used to add data to an</p>
existing data.table</a></li>
<li><a href='#defSurv'><p>Add single row to survival definitions</p></a></li>
<li><a href='#delColumns'><p>Delete columns from existing data set</p></a></li>
<li><a href='#distributions'><p>Distributions for Data Definitions</p></a></li>
<li><a href='#gammaGetShapeRate'><p>Convert gamma mean and dispersion parameters to shape and rate parameters</p></a></li>
<li><a href='#genCatFormula'><p>Generate Categorical Formula</p></a></li>
<li><a href='#genCluster'><p>Simulate clustered data</p></a></li>
<li><a href='#genCorData'><p>Create correlated data</p></a></li>
<li><a href='#genCorFlex'><p>Create multivariate (correlated) data - for general distributions</p></a></li>
<li><a href='#genCorGen'><p>Create multivariate (correlated) data - for general distributions</p></a></li>
<li><a href='#genCorMat'><p>Create a correlation matrix</p></a></li>
<li><a href='#genCorOrdCat'><p>Generate correlated ordinal categorical data</p></a></li>
<li><a href='#genData'><p>Calling function to simulate data</p></a></li>
<li><a href='#genDummy'><p>Create dummy variables from a factor or integer variable</p></a></li>
<li><a href='#genFactor'><p>Create factor variable from an existing (non-double) variable</p></a></li>
<li><a href='#genFormula'><p>Generate a linear formula</p></a></li>
<li><a href='#genMarkov'><p>Generate Markov chain</p></a></li>
<li><a href='#genMiss'><p>Generate missing data</p></a></li>
<li><a href='#genMixFormula'><p>Generate Mixture Formula</p></a></li>
<li><a href='#genMultiFac'><p>Generate multi-factorial data</p></a></li>
<li><a href='#genNthEvent'><p>Generate event data using longitudinal data, and restrict output to time</p>
until the nth event.</a></li>
<li><a href='#genObs'><p>Create an observed data set that includes missing data</p></a></li>
<li><a href='#genOrdCat'><p>Generate ordinal categorical data</p></a></li>
<li><a href='#genSpline'><p>Generate spline curves</p></a></li>
<li><a href='#genSurv'><p>Generate survival data</p></a></li>
<li><a href='#genSynthetic'><p>Generate synthetic data</p></a></li>
<li><a href='#iccRE'><p>Generate variance for random effects that produce desired intra-class</p>
coefficients (ICCs) for clustered data.</a></li>
<li><a href='#logisticCoefs'><p>Determine intercept, treatment/exposure and covariate coefficients that can</p>
be used for binary data generation with a logit link and a set of covariates</a></li>
<li><a href='#mergeData'><p>Merge two data tables</p></a></li>
<li><a href='#negbinomGetSizeProb'><p>Convert negative binomial mean and dispersion parameters to size and prob parameters</p></a></li>
<li><a href='#simstudy-deprecated'><p>Deprecated functions in simstudy</p></a></li>
<li><a href='#survGetParams'><p>Get survival curve parameters</p></a></li>
<li><a href='#survParamPlot'><p>Plot survival curves</p></a></li>
<li><a href='#trimData'><p>Trim longitudinal data file once an event has occurred</p></a></li>
<li><a href='#trtAssign'><p>Assign treatment</p></a></li>
<li><a href='#trtObserve'><p>Observed exposure or treatment</p></a></li>
<li><a href='#trtStepWedge'><p>Assign treatment for stepped-wedge design</p></a></li>
<li><a href='#updateDef'><p>Update definition table</p></a></li>
<li><a href='#updateDefAdd'><p>Update definition table</p></a></li>
<li><a href='#viewBasis'><p>Plot basis spline functions</p></a></li>
<li><a href='#viewSplines'><p>Plot spline curves</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation of Study Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulates data sets in order to explore modeling
    techniques or better understand data generating processes. The user
    specifies a set of relationships between covariates, and generates
    data based on these specifications. The final data sets can represent
    data from randomized control trials, repeated measure (longitudinal)
    designs, and cluster randomized trials. Missingness can be generated
    using various mechanisms (MCAR, MAR, NMAR).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kgoldfeld/simstudy">https://github.com/kgoldfeld/simstudy</a>,
<a href="https://kgoldfeld.github.io/simstudy/">https://kgoldfeld.github.io/simstudy/</a>,
<a href="https://kgoldfeld.github.io/simstudy/dev/">https://kgoldfeld.github.io/simstudy/dev/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kgoldfeld/simstudy/issues">https://github.com/kgoldfeld/simstudy/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, glue, methods, mvnfast, Rcpp, backports, fastglm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, formatR, gee, ggplot2, grid, gridExtra,
hedgehog, knitr, magrittr, Matrix, mgcv, ordinal, pracma,
rmarkdown, scales, splines, survival, testthat, gtsummary,
survminer, katex, dirmult, rms</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, pbv (&ge; 0.4-22), fastglm</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-14 19:26:12 UTC; keith</td>
</tr>
<tr>
<td>Author:</td>
<td>Keith Goldfeld <a href="https://orcid.org/0000-0002-0292-8780"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jacob Wujciak-Jens
    <a href="https://orcid.org/0000-0002-7281-3989"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Keith Goldfeld &lt;keith.goldfeld@nyulangone.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-15 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='simstudy-package'>simstudy: Simulation of Study Data</h2><span id='topic+simstudy'></span><span id='topic+simstudy-package'></span>

<h3>Description</h3>

<p>Simulates data sets in order to explore modeling techniques or better understand data generating processes. The user specifies a set of relationships between covariates, and generates data based on these specifications. The final data sets can represent data from randomized control trials, repeated measure (longitudinal) designs, and cluster randomized trials. Missingness can be generated using various mechanisms (MCAR, MAR, NMAR).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Keith Goldfeld <a href="mailto:keith.goldfeld@nyulangone.org">keith.goldfeld@nyulangone.org</a> (<a href="https://orcid.org/0000-0002-0292-8780">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jacob Wujciak-Jens <a href="mailto:jacob@wujciak.de">jacob@wujciak.de</a> (<a href="https://orcid.org/0000-0002-7281-3989">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/kgoldfeld/simstudy">https://github.com/kgoldfeld/simstudy</a>
</p>
</li>
<li> <p><a href="https://kgoldfeld.github.io/simstudy/">https://kgoldfeld.github.io/simstudy/</a>
</p>
</li>
<li> <p><a href="https://kgoldfeld.github.io/simstudy/dev/">https://kgoldfeld.github.io/simstudy/dev/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/kgoldfeld/simstudy/issues">https://github.com/kgoldfeld/simstudy/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addColumns'>Add columns to existing data set</h2><span id='topic+addColumns'></span>

<h3>Description</h3>

<p>Add columns to existing data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addColumns(dtDefs, dtOld, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addColumns_+3A_dtdefs">dtDefs</code></td>
<td>
<p>name of definitions for added columns</p>
</td></tr>
<tr><td><code id="addColumns_+3A_dtold">dtOld</code></td>
<td>
<p>name of data table that is to be updated</p>
</td></tr>
<tr><td><code id="addColumns_+3A_envir">envir</code></td>
<td>
<p>Environment the data definitions are evaluated in.
Defaults to <a href="base.html#topic+sys.parent">base::parent.frame</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated data.table that contains the added simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New data set

def &lt;- defData(varname = "xNr", dist = "nonrandom", formula = 7, id = "idnum")
def &lt;- defData(def, varname = "xUni", dist = "uniform", formula = "10;20")

dt &lt;- genData(10, def)

# Add columns to dt

def2 &lt;- defDataAdd(varname = "y1", formula = 10, variance = 3)
def2 &lt;- defDataAdd(def2, varname = "y2", formula = .5, dist = "binary")
def2

dt &lt;- addColumns(def2, dt)
dt
</code></pre>

<hr>
<h2 id='addCompRisk'>Generating single competing risk survival variable</h2><span id='topic+addCompRisk'></span>

<h3>Description</h3>

<p>Generating single competing risk survival variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCompRisk(
  dtName,
  events,
  timeName,
  censorName = NULL,
  eventName = "event",
  typeName = "type",
  keepEvents = FALSE,
  idName = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCompRisk_+3A_dtname">dtName</code></td>
<td>
<p>Name of complete data set to be updated</p>
</td></tr>
<tr><td><code id="addCompRisk_+3A_events">events</code></td>
<td>
<p>Vector of column names that include
time-to-event outcome measures</p>
</td></tr>
<tr><td><code id="addCompRisk_+3A_timename">timeName</code></td>
<td>
<p>A string to indicate the name of the combined competing risk
time-to-event outcome that reflects the minimum observed value of all 
time-to-event outcomes.</p>
</td></tr>
<tr><td><code id="addCompRisk_+3A_censorname">censorName</code></td>
<td>
<p>The name of a time-to-event variable that is the censoring
variable. Must be one of the &quot;events&quot; names. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="addCompRisk_+3A_eventname">eventName</code></td>
<td>
<p>The name of the new numeric/integer column representing the
competing event outcomes. If censorName is specified, the integer value for
that event will be 0. Defaults to &quot;event&quot;, but will be ignored 
if timeName is NULL.</p>
</td></tr>
<tr><td><code id="addCompRisk_+3A_typename">typeName</code></td>
<td>
<p>The name of the new character column that will indicate the
event type. The type will be the unique variable names in survDefs. Defaults
to &quot;type&quot;, but will be ignored if timeName is NULL.</p>
</td></tr>
<tr><td><code id="addCompRisk_+3A_keepevents">keepEvents</code></td>
<td>
<p>Indicator to retain original &quot;events&quot; columns. Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="addCompRisk_+3A_idname">idName</code></td>
<td>
<p>Name of id field in existing data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- defData(varname = "x1", formula = .5, dist = "binary")
d1 &lt;- defData(d1, "x2", .5, dist = "binary")

dS &lt;- defSurv(varname = "reinc", formula = "-10 - 0.6*x1 + 0.4*x2", shape = 0.3)
dS &lt;- defSurv(dS, "death", "-6.5 + 0.3*x1 - 0.5*x2", shape = 0.5)
dS &lt;- defSurv(dS, "censor", "-7", shape = 0.55)

dd &lt;- genData(10, d1)
dd &lt;- genSurv(dd, dS)

addCompRisk(dd, c("reinc","death", "censor"), timeName = "time",
   censorName = "censor", keepEvents = FALSE)

</code></pre>

<hr>
<h2 id='addCondition'>Add a single column to existing data set based on a condition</h2><span id='topic+addCondition'></span>

<h3>Description</h3>

<p>Add a single column to existing data set based on a condition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCondition(condDefs, dtOld, newvar, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCondition_+3A_conddefs">condDefs</code></td>
<td>
<p>Name of definitions for added column</p>
</td></tr>
<tr><td><code id="addCondition_+3A_dtold">dtOld</code></td>
<td>
<p>Name of data table that is to be updated</p>
</td></tr>
<tr><td><code id="addCondition_+3A_newvar">newvar</code></td>
<td>
<p>Name of new column to add</p>
</td></tr>
<tr><td><code id="addCondition_+3A_envir">envir</code></td>
<td>
<p>Environment the data definitions are evaluated in.
Defaults to <a href="base.html#topic+sys.parent">base::parent.frame</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data.table that contains the added simulated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# New data set

def &lt;- defData(varname = "x", dist = "categorical", formula = ".33;.33")
def &lt;- defData(def, varname = "y", dist = "uniform", formula = "-5;5")

dt &lt;- genData(1000, def)

# Define conditions

defC &lt;- defCondition(
  condition = "x == 1", formula = "5 + 2*y-.5*y^2",
  variance = 1, dist = "normal"
)
defC &lt;- defCondition(defC,
  condition = "x == 2",
  formula = "3 - 3*y + y^2", variance = 2, dist = "normal"
)
defC &lt;- defCondition(defC,
  condition = "x == 3",
  formula = "abs(y)", dist = "poisson"
)

# Add column

dt &lt;- addCondition(defC, dt, "NewVar")

# Plot data

library(ggplot2)

ggplot(data = dt, aes(x = y, y = NewVar, group = x)) +
  geom_point(aes(color = factor(x)))
</code></pre>

<hr>
<h2 id='addCorData'>Add correlated data to existing data.table</h2><span id='topic+addCorData'></span>

<h3>Description</h3>

<p>Add correlated data to existing data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCorData(
  dtOld,
  idname,
  mu,
  sigma,
  corMatrix = NULL,
  rho,
  corstr = "ind",
  cnames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCorData_+3A_dtold">dtOld</code></td>
<td>
<p>Data table that is the new columns will be appended to.</p>
</td></tr>
<tr><td><code id="addCorData_+3A_idname">idname</code></td>
<td>
<p>Character name of id field, defaults to &quot;id&quot;.</p>
</td></tr>
<tr><td><code id="addCorData_+3A_mu">mu</code></td>
<td>
<p>A vector of means. The length of mu must be nvars.</p>
</td></tr>
<tr><td><code id="addCorData_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of variables. If standard deviation differs
for each variable, enter as a vector with the same length as the mean vector
mu. If the standard deviation is constant across variables, as single value
can be entered.</p>
</td></tr>
<tr><td><code id="addCorData_+3A_cormatrix">corMatrix</code></td>
<td>
<p>Correlation matrix can be entered directly. It must be
symmetrical and positive semi-definite. It is not a required field; if a
matrix is not provided, then a structure and correlation coefficient rho must
be specified.</p>
</td></tr>
<tr><td><code id="addCorData_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, -1 &lt;= rho &lt;= 1. Use if corMatrix is not
provided.</p>
</td></tr>
<tr><td><code id="addCorData_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure of the variance-covariance matrix
defined by sigma and rho. Options include &quot;ind&quot; for an independence
structure, &quot;cs&quot; for a compound symmetry structure, and &quot;ar1&quot; for an
autoregressive structure.</p>
</td></tr>
<tr><td><code id="addCorData_+3A_cnames">cnames</code></td>
<td>
<p>Explicit column names. A single string with names separated
by commas. If no string is provided, the default names will be V#, where #
represents the column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original data table with the additional correlated columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def &lt;- defData(varname = "xUni", dist = "uniform", formula = "10;20", id = "myID")
def &lt;- defData(def,
  varname = "xNorm", formula = "xUni * 2", dist = "normal",
  variance = 8
)

dt &lt;- genData(250, def)

mu &lt;- c(3, 8, 15)
sigma &lt;- c(1, 2, 3)

dtAdd &lt;- addCorData(dt, "myID",
  mu = mu, sigma = sigma,
  rho = .7, corstr = "cs"
)
dtAdd

round(var(dtAdd[, .(V1, V2, V3)]), 3)
round(cor(dtAdd[, .(V1, V2, V3)]), 2)

dtAdd &lt;- addCorData(dt, "myID",
  mu = mu, sigma = sigma,
  rho = .7, corstr = "ar1"
)
round(cor(dtAdd[, .(V1, V2, V3)]), 2)

corMat &lt;- matrix(c(1, .2, .8, .2, 1, .6, .8, .6, 1), nrow = 3)

dtAdd &lt;- addCorData(dt, "myID",
  mu = mu, sigma = sigma,
  corMatrix = corMat
)
round(cor(dtAdd[, .(V1, V2, V3)]), 2)
</code></pre>

<hr>
<h2 id='addCorFlex'>Create multivariate (correlated) data - for general distributions</h2><span id='topic+addCorFlex'></span>

<h3>Description</h3>

<p>Create multivariate (correlated) data - for general distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCorFlex(
  dt,
  defs,
  rho = 0,
  tau = NULL,
  corstr = "cs",
  corMatrix = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCorFlex_+3A_dt">dt</code></td>
<td>
<p>Data table that will be updated.</p>
</td></tr>
<tr><td><code id="addCorFlex_+3A_defs">defs</code></td>
<td>
<p>Field definition table created by function <code>defDataAdd</code>.</p>
</td></tr>
<tr><td><code id="addCorFlex_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, -1 &lt;= rho &lt;= 1. Use if corMatrix is not
provided.</p>
</td></tr>
<tr><td><code id="addCorFlex_+3A_tau">tau</code></td>
<td>
<p>Correlation based on Kendall's tau. If tau is specified, then it
is used as the correlation even if rho is specified. If tau is NULL, then the
specified value of rho is used, or rho defaults to 0.</p>
</td></tr>
<tr><td><code id="addCorFlex_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure of the variance-covariance matrix defined
by sigma and rho. Options include &quot;cs&quot; for a compound symmetry structure
and &quot;ar1&quot; for an autoregressive structure. Defaults to &quot;cs&quot;.</p>
</td></tr>
<tr><td><code id="addCorFlex_+3A_cormatrix">corMatrix</code></td>
<td>
<p>Correlation matrix can be entered directly. It must be
symmetrical and positive semi-definite. It is not a required field; if a
matrix is not provided, then a structure and correlation coefficient rho must
be specified.</p>
</td></tr>
<tr><td><code id="addCorFlex_+3A_envir">envir</code></td>
<td>
<p>Environment the data definitions are evaluated in.
Defaults to <a href="base.html#topic+sys.parent">base::parent.frame</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with added column(s) of correlated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>defC &lt;- defData(
  varname = "nInds", formula = 50, dist = "noZeroPoisson",
  id = "idClust"
)

dc &lt;- genData(10, defC)
#### Normal only

dc &lt;- addCorData(dc,
  mu = c(0, 0, 0, 0), sigma = c(2, 2, 2, 2), rho = .2,
  corstr = "cs", cnames = c("a", "b", "c", "d"),
  idname = "idClust"
)

di &lt;- genCluster(dc, "idClust", "nInds", "id")

defI &lt;- defDataAdd(
  varname = "A", formula = "-1 + a", variance = 3,
  dist = "normal"
)
defI &lt;- defDataAdd(defI,
  varname = "B", formula = "4.5 + b", variance = .5,
  dist = "normal"
)
defI &lt;- defDataAdd(defI,
  varname = "C", formula = "5*c", variance = 3,
  dist = "normal"
)
defI &lt;- defDataAdd(defI,
  varname = "D", formula = "1.6 + d", variance = 1,
  dist = "normal"
)

#### Generate new data

di &lt;- addCorFlex(di, defI, rho = 0.4, corstr = "cs")

# Check correlations by cluster

for (i in 1:nrow(dc)) {
  print(cor(di[idClust == i, list(A, B, C, D)]))
}

# Check global correlations - should not be as correlated
cor(di[, list(A, B, C, D)])
</code></pre>

<hr>
<h2 id='addCorGen'>Create multivariate (correlated) data - for general distributions</h2><span id='topic+addCorGen'></span>

<h3>Description</h3>

<p>Create multivariate (correlated) data - for general distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCorGen(
  dtOld,
  nvars = NULL,
  idvar = "id",
  rho = NULL,
  corstr = NULL,
  corMatrix = NULL,
  dist,
  param1,
  param2 = NULL,
  cnames = NULL,
  method = "copula",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addCorGen_+3A_dtold">dtOld</code></td>
<td>
<p>The data set that will be augmented. If the data set includes a
single record per id, the new data table will be created as a &quot;wide&quot; data set.
If the original data set includes multiple records per id, the new data set will 
be in &quot;long&quot; format.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_nvars">nvars</code></td>
<td>
<p>The number of new variables to create for each id. This is only applicable
when the data are generated from a data set that includes one record per id.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_idvar">idvar</code></td>
<td>
<p>String variable name of column represents individual level id for correlated
data.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, -1 &lt;= rho &lt;= 1. Use if corMatrix is not provided.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure of the variance-covariance matrix
defined by sigma and rho. Options include &quot;cs&quot; for a compound symmetry structure
and &quot;ar1&quot; for an autoregressive structure.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_cormatrix">corMatrix</code></td>
<td>
<p>Correlation matrix can be entered directly. It must be symmetrical and
positive semi-definite. It is not a required field; if a matrix is not provided, then a
structure and correlation coefficient rho must be specified.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_dist">dist</code></td>
<td>
<p>A string indicating &quot;normal&quot;, &quot;binary&quot;, &quot;poisson&quot; or &quot;gamma&quot;.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_param1">param1</code></td>
<td>
<p>A string that represents the column in dtOld that contains the parameter
for the mean of the distribution. In the case of the uniform distribution the column
specifies the minimum.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_param2">param2</code></td>
<td>
<p>A string that represents the column in dtOld that contains a possible second
parameter for the distribution. For the normal distribution, this will be the variance;
for the gamma distribution, this will be the dispersion; and for the uniform distribution,
this will be the maximum.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_cnames">cnames</code></td>
<td>
<p>Explicit column names. A single string with names separated
by commas. If no string is provided, the default names will be V#, where #
represents the column.</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_method">method</code></td>
<td>
<p>Two methods are available to generate correlated data. (1) &quot;copula&quot; uses
the multivariate Gaussian copula method that is applied to all other distributions; this
applies to all available distributions. (2) &quot;ep&quot; uses an algorithm developed by
Emrich and Piedmonte (1991).</p>
</td></tr>
<tr><td><code id="addCorGen_+3A_...">...</code></td>
<td>
<p>May include additional arguments that have been deprecated and are
no longer used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Original data.table with added column(s) of correlated data
</p>


<h3>References</h3>

<p>Emrich LJ, Piedmonte MR. A Method for Generating High-Dimensional
Multivariate Binary Variates. The American Statistician 1991;45:302-4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Wide example

def &lt;- defData(varname = "xbase", formula = 5, variance = .4, dist = "gamma", id = "cid")
def &lt;- defData(def, varname = "lambda", formula = ".5 + .1*xbase", dist = "nonrandom", link = "log")

dt &lt;- genData(100, def)

addCorGen(
  dtOld = dt, idvar = "cid", nvars = 3, rho = .7, corstr = "cs",
  dist = "poisson", param1 = "lambda"
)

# Long example

def &lt;- defData(varname = "xbase", formula = 5, variance = .4, dist = "gamma", id = "cid")

def2 &lt;- defDataAdd(
  varname = "p", formula = "-3+.2*period + .3*xbase",
  dist = "nonrandom", link = "logit"
)

dt &lt;- genData(100, def)

dtLong &lt;- addPeriods(dt, idvars = "cid", nPeriods = 3)
dtLong &lt;- addColumns(def2, dtLong)

addCorGen(
  dtOld = dtLong, idvar = "cid", nvars = NULL, rho = .7, corstr = "cs",
  dist = "binary", param1 = "p"
)

</code></pre>

<hr>
<h2 id='addMarkov'>Add Markov chain</h2><span id='topic+addMarkov'></span>

<h3>Description</h3>

<p>Generate a Markov chain for n individuals or units by
specifying a transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMarkov(
  dd,
  transMat,
  chainLen,
  wide = FALSE,
  id = "id",
  pername = "period",
  varname = "state",
  widePrefix = "S",
  start0lab = NULL,
  trimvalue = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMarkov_+3A_dd">dd</code></td>
<td>
<p>data.table with a unique identifier</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_transmat">transMat</code></td>
<td>
<p>Square transition matrix where the sum of each row
must equal 1. The dimensions of the matrix equal the number of possible
states.</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_chainlen">chainLen</code></td>
<td>
<p>Length of each chain that will be generated for each
chain; minimum chain length is 2.</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_wide">wide</code></td>
<td>
<p>Logical variable (TRUE or FALSE) indicating whether the
resulting data table should be returned in wide or long format. The
wide format includes all elements of a chain on a single row; the long
format includes each element of a chain in its own row. The default is
wide = FALSE, so the long format is returned by default.</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_id">id</code></td>
<td>
<p>Character string that represents name of &quot;id&quot; field.
Defaults to &quot;id&quot;.</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_pername">pername</code></td>
<td>
<p>Character string that represents the variable name of the
chain sequence in the long format. Defaults &quot;period&quot;,</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_varname">varname</code></td>
<td>
<p>Character string that represents the variable name of the
state in the long format. Defaults to &quot;state&quot;.</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_wideprefix">widePrefix</code></td>
<td>
<p>Character string that represents the variable name
prefix for the state fields in the wide format. Defaults to &quot;S&quot;.</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_start0lab">start0lab</code></td>
<td>
<p>Character string that represents name of the integer
field containing starting state (State 0) of the chain for each individual.
If it is NULL, starting state defaults to 1. Default is NULL.</p>
</td></tr>
<tr><td><code id="addMarkov_+3A_trimvalue">trimvalue</code></td>
<td>
<p>Integer value indicating end state. If trimvalue is not NULL,
all records after the first instance of state = trimvalue will be deleted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table with n rows if in wide format, or n by chainLen rows
if in long format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def1 &lt;- defData(varname = "x1", formula = 0, variance = 1)
def1 &lt;- defData(def1, varname = "x2", formula = 0, variance = 1)
def1 &lt;- defData(def1,
  varname = "S0", formula = ".6;.3;.1",
  dist = "categorical"
)

dd &lt;- genData(20, def1)

# Transition matrix P

P &lt;- t(matrix(c(
  0.7, 0.2, 0.1,
  0.5, 0.3, 0.2,
  0.0, 0.7, 0.3
),
nrow = 3
))

d1 &lt;- addMarkov(dd, P, chainLen = 3)
d2 &lt;- addMarkov(dd, P, chainLen = 5, wide = TRUE)
d3 &lt;- addMarkov(dd, P, chainLen = 5, wide = TRUE, start0lab = "S0")
d4 &lt;- addMarkov(dd, P, chainLen = 5, start0lab = "S0", trimvalue = 3)
</code></pre>

<hr>
<h2 id='addMultiFac'>Add multi-factorial data</h2><span id='topic+addMultiFac'></span>

<h3>Description</h3>

<p>Add multi-factorial data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addMultiFac(dtOld, nFactors, levels = 2, coding = "dummy", colNames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addMultiFac_+3A_dtold">dtOld</code></td>
<td>
<p>data.table that is to be modified</p>
</td></tr>
<tr><td><code id="addMultiFac_+3A_nfactors">nFactors</code></td>
<td>
<p>Number of factors (columns) to generate.</p>
</td></tr>
<tr><td><code id="addMultiFac_+3A_levels">levels</code></td>
<td>
<p>Vector or scalar. If a vector is specified, it must be
the same length as nFatctors. Each value of the vector represents the
number of levels of each corresponding factor. If a scalar is specified,
each factor will have the same number of levels. The default is 2 levels
for each factor.</p>
</td></tr>
<tr><td><code id="addMultiFac_+3A_coding">coding</code></td>
<td>
<p>String value to specify if &quot;dummy&quot; or &quot;effect&quot; coding is used.
Defaults to &quot;dummy&quot;.</p>
</td></tr>
<tr><td><code id="addMultiFac_+3A_colnames">colNames</code></td>
<td>
<p>A vector of strings, with a length of nFactors. The strings
represent the name for each factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table that contains the added simulated data. Each new column contains
an integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>defD &lt;- defData(varname = "x", formula = 0, variance = 1)

DT &lt;- genData(360, defD)
DT &lt;- addMultiFac(DT, nFactors = 3, levels = c(2, 3, 3), colNames = c("A", "B", "C"))
DT
DT[, .N, keyby = .(A, B, C)]

DT &lt;- genData(300, defD)
DT &lt;- addMultiFac(DT, nFactors = 3, levels = 2)
DT[, .N, keyby = .(Var1, Var2, Var3)]
</code></pre>

<hr>
<h2 id='addPeriods'>Create longitudinal/panel data</h2><span id='topic+addPeriods'></span>

<h3>Description</h3>

<p>Create longitudinal/panel data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addPeriods(
  dtName,
  nPeriods = NULL,
  idvars = "id",
  timevars = NULL,
  timevarName = "timevar",
  timeid = "timeID",
  perName = "period",
  periodVec = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addPeriods_+3A_dtname">dtName</code></td>
<td>
<p>Name of existing data table</p>
</td></tr>
<tr><td><code id="addPeriods_+3A_nperiods">nPeriods</code></td>
<td>
<p>Number of time periods for each record</p>
</td></tr>
<tr><td><code id="addPeriods_+3A_idvars">idvars</code></td>
<td>
<p>Names of index variables (in a string vector) that will be
repeated during each time period</p>
</td></tr>
<tr><td><code id="addPeriods_+3A_timevars">timevars</code></td>
<td>
<p>Names of time dependent variables. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="addPeriods_+3A_timevarname">timevarName</code></td>
<td>
<p>Name of new time dependent variable</p>
</td></tr>
<tr><td><code id="addPeriods_+3A_timeid">timeid</code></td>
<td>
<p>Variable name for new index field. Defaults to &quot;timevar&quot;</p>
</td></tr>
<tr><td><code id="addPeriods_+3A_pername">perName</code></td>
<td>
<p>Variable name for period field. Defaults to &quot;period&quot;</p>
</td></tr>
<tr><td><code id="addPeriods_+3A_periodvec">periodVec</code></td>
<td>
<p>Vector of period times. Defaults to NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to generate longitudinal data with varying 
numbers of measurement periods as well as varying time intervals between 
each measurement period. This is done by defining specific variables <em>in</em> the 
data set that define the number of observations per subject and the average 
interval time between each observation. <b><em>nCount</em></b> defines the number of 
measurements for an individual; <b><em>mInterval</em></b> specifies the average time between 
intervals for a subject; and <b><em>vInterval</em></b> specifies the variance of those 
interval times. If <b><em>mInterval</em></b> is not defined, no intervals are used. If <b><em>vInterval</em></b> is set to 0 or is not defined, the interval for
a subject is determined entirely by the mean interval. If <b><em>vInterval</em></b> is 
greater than 0, time intervals are generated using a gamma distribution 
with specified mean and dispersion. If either <b><em>nPeriods</em></b> or <b><em>timevars</em></b> 
is specified, that will override any <b><em>nCount</em></b>, <b><em>mInterval</em></b>, and 
<b><em>vInterval</em></b> data.
</p>
<p><b><em>periodVec</em></b> is used to specify measurement periods that are different
the default counting variables. If <b><em>periodVec</em></b> is not specified, 
the periods default to <em>0, 1, ... n-1</em>, with <em>n</em> periods. If 
<b><em>periodVec</em></b> is specified as <em>c(x_1, x_2, ... x_n)</em>, then
<em>x_1, x_2, ... x_n</em> represent the measurement periods.
</p>


<h3>Value</h3>

<p>An updated data.table that that has multiple rows
per observation in dtName
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tdef &lt;- defData(varname = "T", dist = "binary", formula = 0.5)
tdef &lt;- defData(tdef, varname = "Y0", dist = "normal", formula = 10, variance = 1)
tdef &lt;- defData(tdef, varname = "Y1", dist = "normal", formula = "Y0 + 5 + 5 * T", variance = 1)
tdef &lt;- defData(tdef, varname = "Y2", dist = "normal", formula = "Y0 + 10 + 5 * T", variance = 1)

dtTrial &lt;- genData(5, tdef)
dtTrial

dtTime &lt;- addPeriods(dtTrial,
  nPeriods = 3, idvars = "id",
  timevars = c("Y0", "Y1", "Y2"), timevarName = "Y"
)
dtTime

# Varying # of periods and intervals - need to have variables
# called nCount and mInterval

def &lt;- defData(varname = "xbase", dist = "normal", formula = 20, variance = 3)
def &lt;- defData(def, varname = "nCount", dist = "noZeroPoisson", formula = 6)
def &lt;- defData(def, varname = "mInterval", dist = "gamma", formula = 30, variance = .01)
def &lt;- defData(def, varname = "vInterval", dist = "nonrandom", formula = .07)

dt &lt;- genData(200, def)
dt[id %in% c(8, 121)]

dtPeriod &lt;- addPeriods(dt)
dtPeriod[id %in% c(8, 121)] # View individuals 8 and 121 only
</code></pre>

<hr>
<h2 id='addSynthetic'>Add synthetic data to existing data set</h2><span id='topic+addSynthetic'></span>

<h3>Description</h3>

<p>This function generates synthetic data from an existing 
data.table and adds it to another (simstudy) data.table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addSynthetic(dtOld, dtFrom, vars = NULL, id = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addSynthetic_+3A_dtold">dtOld</code></td>
<td>
<p>data.table that is to be modified</p>
</td></tr>
<tr><td><code id="addSynthetic_+3A_dtfrom">dtFrom</code></td>
<td>
<p>Data table that contains the source data</p>
</td></tr>
<tr><td><code id="addSynthetic_+3A_vars">vars</code></td>
<td>
<p>A vector of string names specifying the fields that will be
sampled. The default is that all variables will be selected.</p>
</td></tr>
<tr><td><code id="addSynthetic_+3A_id">id</code></td>
<td>
<p>A string specifying the field that serves as the record id. The
default field is &quot;id&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Add synthetic data
</p>


<h3>Value</h3>

<p>A data.table that contains the added synthetic data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Create fake "real" data set - this is the source of the synthetic data

d &lt;- defData(varname = "a", formula = 3, variance = 1, dist = "normal")
d &lt;- defData(d, varname = "b", formula = 5, dist = "poisson")
d &lt;- defData(d, varname = "c", formula = 0.3, dist = "binary")
d &lt;- defData(d, varname = "d", formula = "a + b + 3*c", variance = 2, dist = "normal")

### Create synthetic data set from "observed" data set A (normally this
### would be an actual external data set):

A &lt;- genData(1000, d)

### Generate new simstudy data set (using 'def')

def &lt;- defData(varname = "x", formula = 0, variance = 5)
S &lt;- genData(120, def)

### Create synthetic data from 'A' and add to simulated data in 'S'

S &lt;- addSynthetic(dtOld = S, dtFrom = A, vars = c("b", "d"))
</code></pre>

<hr>
<h2 id='betaGetShapes'>Convert beta mean and precision parameters to two shape parameters</h2><span id='topic+betaGetShapes'></span>

<h3>Description</h3>

<p>Convert beta mean and precision parameters to two shape parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betaGetShapes(mean, precision)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betaGetShapes_+3A_mean">mean</code></td>
<td>
<p>The mean of a beta distribution</p>
</td></tr>
<tr><td><code id="betaGetShapes_+3A_precision">precision</code></td>
<td>
<p>The precision parameter (phi) of a beta distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simstudy, users specify the beta distribution as a function of
two parameters - a mean and precision, where 0 &lt; mean &lt; 1 and precision &gt; 0.
In this case, the variance of the specified distribution is
(mean)*(1-mean)/(1+precision). The base R function rbeta uses the two shape
parameters to specify the beta distribution. This function converts the mean
and precision into the shape1 and shape2 parameters.
</p>


<h3>Value</h3>

<p>A list that includes the shape parameters of the beta distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
mean &lt;- 0.3
precision &lt;- 1.6
rs &lt;- betaGetShapes(mean, precision)
c(rs$shape1, rs$shape2)
vec &lt;- rbeta(1000, shape1 = rs$shape1, shape2 = rs$shape2)
(estMoments &lt;- c(mean(vec), var(vec)))
(theoryMoments &lt;- c(mean, mean * (1 - mean) / (1 + precision)))
(theoryMoments &lt;- with(rs, c(
  shape1 / (shape1 + shape2),
  (shape1 * shape2) / ((shape1 + shape2)^2 * (1 + shape1 + shape2))
)))
</code></pre>

<hr>
<h2 id='blockDecayMat'>Create a block correlation matrix</h2><span id='topic+blockDecayMat'></span>

<h3>Description</h3>

<p>The function genBlockMat() generates correlation matrices that 
can accommodate clustered observations over time where the within-cluster 
between-individual correlation in the same time period can be different from the 
within-cluster between-individual correlation across time periods.The matrix
generated here can be used in function addCorGen().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockDecayMat(ninds, nperiods, rho_w, r, pattern = "xsection", nclusters = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockDecayMat_+3A_ninds">ninds</code></td>
<td>
<p>The number of units (individuals) in each cluster in each period.</p>
</td></tr>
<tr><td><code id="blockDecayMat_+3A_nperiods">nperiods</code></td>
<td>
<p>The number periods that data are observed.</p>
</td></tr>
<tr><td><code id="blockDecayMat_+3A_rho_w">rho_w</code></td>
<td>
<p>The within-period/between-individual correlation coefficient between -1 and 1.</p>
</td></tr>
<tr><td><code id="blockDecayMat_+3A_r">r</code></td>
<td>
<p>The decay parameter if correlation declines over time, and can have values of
&quot;exp&quot; or &quot;prop&quot;. See details.</p>
</td></tr>
<tr><td><code id="blockDecayMat_+3A_pattern">pattern</code></td>
<td>
<p>A string argument with options &quot;xsection&quot; (default) or &quot;cohort&quot;.</p>
</td></tr>
<tr><td><code id="blockDecayMat_+3A_nclusters">nclusters</code></td>
<td>
<p>An integer that indicates the number of matrices that will be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two general decay correlation structures are currently supported: a *cross-sectional* 
exchangeable structure and a *closed cohort* exchangeable structure. In the *cross-sectional* 
case, individuals or units in each time period are distinct. In the *closed cohort* structure, 
individuals or units are repeated in each time period. The desired structure is specified 
using <code>pattern</code>, which defaults to &quot;xsection&quot; if not specified. 
</p>
<p>This function can generate correlation matrices of different sizes, depending on the 
combination of arguments provided. A single matrix will be generated when 
<code>nclusters == 1</code> (the default), and a list of matrices of matrices will be generated when
<code>nclusters &gt; 1</code>.
</p>
<p>If <code>nclusters &gt; 1</code>, the length of <code>ninds</code> will depend on if sample sizes will vary by cluster
and/or period. There are three scenarios,  and function evaluates the length of <code>ninds</code> to 
determine which approach to take:
</p>

<ul>
<li><p>if the sample size is the same for all clusters in all periods, <code>ninds</code> will be
a single value (i.e., length = 1).
</p>
</li>
<li><p>if the sample size differs by cluster but is the same for each period within each cluster
each period, then <code>ninds</code> will have a value for each cluster (i.e., length = <code>nclusters</code>). 
</p>
</li>
<li><p>if the sample size differs across clusters and across periods within clusters, <code>ninds</code> will have a
value for each cluster-period combination (i.e., length = <code>nclusters x nperiods</code>). This option is
only valid when <code>pattern = "xsection"</code>.
</p>
</li></ul>

<p>In addition, <code>rho_w</code> and <code>r</code> can be specified as a single value (in which case they are consistent
across all clusters) or as a vector of length <code>nclusters</code>, in which case either one or 
both of these parameters can vary by cluster.
</p>
<p>See vignettes for more details.
</p>


<h3>Value</h3>

<p>A single correlation matrix of size <code>nvars x nvars</code>, or a list of matrices of potentially
different sizes with length indicated by <code>nclusters</code>.
</p>
<p>A single correlation matrix or a list of matrices of potentially
different sizes with length indicated by <code>nclusters</code>.
</p>


<h3>References</h3>

<p>Li et al. Mixed-effects models for the design and analysis of stepped wedge 
cluster randomized trials: An overview. Statistical Methods in Medical Research. 
2021;30(2):612-639. doi:10.1177/0962280220932962
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blockExchangeMat">blockExchangeMat</a></code> and <code><a href="#topic+addCorGen">addCorGen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blockDecayMat(ninds = 4, nperiods = 3, rho_w = .8, r = .9)
blockDecayMat(ninds = 4, nperiods = 3, rho_w = .8, r = .9, pattern = "cohort")

blockDecayMat(ninds = 2, nperiods = 3, rho_w = .8, r = .9, pattern = "cohort", nclusters=2)
blockDecayMat(ninds = c(2, 3), nperiods = 3, rho_w = c(.8,0.7), r = c(.9,.8), 
  pattern = "cohort", nclusters=2)
blockDecayMat(ninds = c(2, 3, 4, 4, 2, 1), nperiods = 3, rho_w = .8, r = .9, nclusters=2)

</code></pre>

<hr>
<h2 id='blockExchangeMat'>Create a block correlation matrix with exchangeable structure</h2><span id='topic+blockExchangeMat'></span>

<h3>Description</h3>

<p>The function <code>blockExchangeMat</code> generates exchangeable correlation matrices that 
can accommodate clustered observations over time where the within-cluster 
between-individual correlation in the same time period can be different from the 
within-cluster between-individual correlation across time periods. The matrix
generated here can be used in function <code>addCorGen</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockExchangeMat(
  ninds,
  nperiods,
  rho_w,
  rho_b = 0,
  rho_a = NULL,
  pattern = "xsection",
  nclusters = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockExchangeMat_+3A_ninds">ninds</code></td>
<td>
<p>The number of units (individuals) in each cluster in each period.</p>
</td></tr>
<tr><td><code id="blockExchangeMat_+3A_nperiods">nperiods</code></td>
<td>
<p>The number periods that data are observed.</p>
</td></tr>
<tr><td><code id="blockExchangeMat_+3A_rho_w">rho_w</code></td>
<td>
<p>The within-period/between-individual correlation coefficient between -1 and 1.</p>
</td></tr>
<tr><td><code id="blockExchangeMat_+3A_rho_b">rho_b</code></td>
<td>
<p>The between-period/between-individual correlation coefficient between -1 and 1.</p>
</td></tr>
<tr><td><code id="blockExchangeMat_+3A_rho_a">rho_a</code></td>
<td>
<p>The between-period/within-individual auto-correlation coefficient
between -1 and 1.</p>
</td></tr>
<tr><td><code id="blockExchangeMat_+3A_pattern">pattern</code></td>
<td>
<p>A string argument with options &quot;xsection&quot; (default) or &quot;cohort&quot;.</p>
</td></tr>
<tr><td><code id="blockExchangeMat_+3A_nclusters">nclusters</code></td>
<td>
<p>An integer that indicates the number of matrices that will be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two general exchangeable correlation structures are currently supported: a *cross-sectional* exchangeable
structure and a *closed cohort* exchangeable structure. In the *cross-sectional* case, individuals or units in each time period are distinct.
In the *closed cohort* structure, individuals or units are repeated in each time period. 
The desired structure is specified using <code>pattern</code>, which defaults to &quot;xsection&quot; if not specified. <code>rho_a</code> is the within-individual/unit 
exchangeable correlation over time, and can only be used when <code>xsection = FALSE</code>.
</p>
<p>This function can generate correlation matrices of different sizes, depending on the combination of arguments provided. 
A single matrix will be generated when <code>nclusters == 1</code> (the default), and a list of matrices of matrices will be generated when
<code>nclusters &gt; 1</code>.
</p>
<p>If <code>nclusters &gt; 1</code>, the length of <code>ninds</code> will depend on if sample sizes will vary by cluster
and/or period. There are three scenarios,  and function evaluates the length of <code>ninds</code> to determine which approach 
to take:
</p>

<ul>
<li><p>if the sample size is the same for all clusters in all periods, <code>ninds</code> will be
a single value (i.e., length = 1).
</p>
</li>
<li><p>if the sample size differs by cluster but is the same for each period within each cluster
each period, then <code>ninds</code> will have a value for each cluster (i.e., length = <code>nclusters</code>). 
</p>
</li>
<li><p>if the sample size differs across clusters and across periods within clusters, <code>ninds</code> will have a
value for each cluster-period combination (i.e., length = <code>nclusters x nperiods</code>). This option is
only valid when <code>pattern = "xsection"</code>.
</p>
</li></ul>

<p>In addition, <code>rho_w</code>, <code>rho_b</code>, and <code>rho_a</code> can be specified as a single value (in which case they are consistent
across all clusters) or as a vector of length <code>nclusters</code>, in which case any or all of these parameters can vary by cluster.
</p>
<p>See vignettes for more details.
</p>


<h3>Value</h3>

<p>A single correlation matrix or a list of matrices of potentially
different sizes with length indicated by <code>nclusters</code>.
</p>


<h3>References</h3>

<p>Li et al. Mixed-effects models for the design and analysis of stepped wedge cluster randomized trials: An overview. 
Statistical Methods in Medical Research. 2021;30(2):612-639. doi:10.1177/0962280220932962
</p>


<h3>See Also</h3>

<p><code><a href="#topic+blockDecayMat">blockDecayMat</a></code> and <code><a href="#topic+addCorGen">addCorGen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blockExchangeMat(ninds = 4, nperiods = 3, rho_w = .8)
blockExchangeMat(ninds = 4, nperiods = 3, rho_w = .8, rho_b = 0.5)
blockExchangeMat(ninds = 4, nperiods = 3, rho_w = .8, rho_b = 0.5, rho_a = 0.7, 
    pattern = "cohort")
blockExchangeMat(ninds = 2, nperiods = 3, rho_w = .8, rho_b = 0.5, rho_a = 0.7, 
    nclusters = 3, pattern = "cohort")
blockExchangeMat(ninds = c(2, 3), nperiods = 3, rho_w = .8, rho_b = 0.5, rho_a = 0.7, 
    nclusters = 2, pattern="cohort")
blockExchangeMat(ninds = c(2, 3, 4, 4, 2, 1), nperiods = 3, rho_w = .8, rho_b = 0.5, 
    nclusters = 2)
</code></pre>

<hr>
<h2 id='catProbs'>Generate Categorical Formula</h2><span id='topic+catProbs'></span>

<h3>Description</h3>

<p>This function is deprecated, please use <a href="#topic+genCatFormula">genCatFormula</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catProbs(..., n = 0)
</code></pre>

<hr>
<h2 id='defCondition'>Add single row to definitions table of conditions that will be used to add data to an
existing definitions table</h2><span id='topic+defCondition'></span>

<h3>Description</h3>

<p>Add single row to definitions table of conditions that will be used to add data to an
existing definitions table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defCondition(
  dtDefs = NULL,
  condition,
  formula,
  variance = 0,
  dist = "normal",
  link = "identity"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defCondition_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Name of definition table to be modified. Null if this is a new definition.</p>
</td></tr>
<tr><td><code id="defCondition_+3A_condition">condition</code></td>
<td>
<p>Formula specifying condition to be checked</p>
</td></tr>
<tr><td><code id="defCondition_+3A_formula">formula</code></td>
<td>
<p>An R expression for mean (string)</p>
</td></tr>
<tr><td><code id="defCondition_+3A_variance">variance</code></td>
<td>
<p>Number</p>
</td></tr>
<tr><td><code id="defCondition_+3A_dist">dist</code></td>
<td>
<p>Distribution. For possibilities, see details</p>
</td></tr>
<tr><td><code id="defCondition_+3A_link">link</code></td>
<td>
<p>The link function for the mean, see details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table named dtName that is an updated data definitions table
</p>


<h3>See Also</h3>

<p><a href="#topic+distributions">distributions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New data set

def &lt;- defData(varname = "x", dist = "noZeroPoisson", formula = 5)
def &lt;- defData(def, varname = "y", dist = "normal", formula = 0, variance = 9)

dt &lt;- genData(10, def)

# Add columns to dt

defC &lt;- defCondition(
  condition = "x == 1", formula = "5 + 2*y",
  variance = 1, dist = "normal"
)

defC &lt;- defCondition(defC,
  condition = "x &lt;= 5 &amp; x &gt;= 2", formula = "3 - 2*y",
  variance = 1, dist = "normal"
)

defC &lt;- defCondition(defC,
  condition = "x &gt;= 6", formula = 1,
  variance = 1, dist = "normal"
)

defC

# Add conditional column with field name "z"

dt &lt;- addCondition(defC, dt, "z")
dt
</code></pre>

<hr>
<h2 id='defData'>Add single row to definitions table</h2><span id='topic+defData'></span>

<h3>Description</h3>

<p>Add single row to definitions table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defData(
  dtDefs = NULL,
  varname,
  formula,
  variance = 0,
  dist = "normal",
  link = "identity",
  id = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defData_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Definition data.table to be modified</p>
</td></tr>
<tr><td><code id="defData_+3A_varname">varname</code></td>
<td>
<p>Name (string) of new variable</p>
</td></tr>
<tr><td><code id="defData_+3A_formula">formula</code></td>
<td>
<p>An R expression for mean (string)</p>
</td></tr>
<tr><td><code id="defData_+3A_variance">variance</code></td>
<td>
<p>Number</p>
</td></tr>
<tr><td><code id="defData_+3A_dist">dist</code></td>
<td>
<p>Distribution. For possibilities, see details</p>
</td></tr>
<tr><td><code id="defData_+3A_link">link</code></td>
<td>
<p>The link function for the mean, see details</p>
</td></tr>
<tr><td><code id="defData_+3A_id">id</code></td>
<td>
<p>A string indicating the field name for the unique record identifier</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible data distributions are: normal, binary, binomial, poisson, noZeroPoisson, uniform, categorical, gamma, beta, nonrandom, uniformInt, negBinomial, exponential, mixture, trtAssign, clusterSize, custom.
</p>


<h3>Value</h3>

<p>A data.table named dtName that is an updated data definitions table
</p>


<h3>See Also</h3>

<p><a href="#topic+distributions">distributions</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extVar &lt;- 2.3
def &lt;- defData(varname = "xNr", dist = "nonrandom", formula = 7, id = "idnum")
def &lt;- defData(def, varname = "xUni", dist = "uniform", formula = "10;20")
def &lt;- defData(def,
  varname = "xNorm", formula = "xNr + xUni * 2", dist = "normal",
  variance = 8
)
def &lt;- defData(def,
  varname = "xPois", dist = "poisson", formula = "xNr - 0.2 * xUni",
  link = "log"
)
def &lt;- defData(def, varname = "xCat", formula = "0.3;0.2;0.5", dist = "categorical")
def &lt;- defData(def,
  varname = "xGamma", dist = "gamma", formula = "5+xCat",
  variance = 1, link = "log"
)
def &lt;- defData(def,
  varname = "xBin", dist = "binary", formula = "-3 + xCat",
  link = "logit"
)
def &lt;- defData(def,
  varname = "external", dist = "nonrandom",
  formula = "xBin * log(..extVar)"
)
def
</code></pre>

<hr>
<h2 id='defDataAdd'>Add single row to definitions table that will be used to add data to an
existing data.table</h2><span id='topic+defDataAdd'></span>

<h3>Description</h3>

<p>Add single row to definitions table that will be used to add data to an
existing data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defDataAdd(
  dtDefs = NULL,
  varname,
  formula,
  variance = 0,
  dist = "normal",
  link = "identity"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defDataAdd_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Name of definition table to be modified. Null if this is a new definition.</p>
</td></tr>
<tr><td><code id="defDataAdd_+3A_varname">varname</code></td>
<td>
<p>Name (string) of new variable</p>
</td></tr>
<tr><td><code id="defDataAdd_+3A_formula">formula</code></td>
<td>
<p>An R expression for mean (string)</p>
</td></tr>
<tr><td><code id="defDataAdd_+3A_variance">variance</code></td>
<td>
<p>Number</p>
</td></tr>
<tr><td><code id="defDataAdd_+3A_dist">dist</code></td>
<td>
<p>Distribution. For possibilities, see details</p>
</td></tr>
<tr><td><code id="defDataAdd_+3A_link">link</code></td>
<td>
<p>The link function for the mean, see details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table named dtName that is an updated data definitions table
</p>


<h3>See Also</h3>

<p>[distributions]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New data set

def &lt;- defData(varname = "xNr", dist = "nonrandom", formula = 7, id = "idnum")
def &lt;- defData(def, varname = "xUni", dist = "uniform", formula = "10;20")

dt &lt;- genData(10, def)

# Add columns to dt

def2 &lt;- defDataAdd(varname = "y1", formula = 10, variance = 3)
def2 &lt;- defDataAdd(def2, varname = "y2", formula = .5, dist = "binary")
def2

dt &lt;- addColumns(def2, dt)
dt
</code></pre>

<hr>
<h2 id='defMiss'>Definitions for missing data</h2><span id='topic+defMiss'></span>

<h3>Description</h3>

<p>Add single row to definitions table for missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defMiss(
  dtDefs = NULL,
  varname,
  formula,
  logit.link = FALSE,
  baseline = FALSE,
  monotonic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defMiss_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Definition data.table to be modified</p>
</td></tr>
<tr><td><code id="defMiss_+3A_varname">varname</code></td>
<td>
<p>Name of variable with missingness</p>
</td></tr>
<tr><td><code id="defMiss_+3A_formula">formula</code></td>
<td>
<p>Formula to describe pattern of missingness</p>
</td></tr>
<tr><td><code id="defMiss_+3A_logit.link">logit.link</code></td>
<td>
<p>Indicator set to TRUE when the probability of missingness
is based on a logit model.</p>
</td></tr>
<tr><td><code id="defMiss_+3A_baseline">baseline</code></td>
<td>
<p>Indicator is set to TRUE if the variable is a baseline
measure and should be missing throughout an entire observation period. This
is applicable to repeated measures/longitudinal data.</p>
</td></tr>
<tr><td><code id="defMiss_+3A_monotonic">monotonic</code></td>
<td>
<p>Indicator set to TRUE if missingness at time t is followed
by missingness at all follow-up times &gt; t.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table named dtName that is an updated data definitions table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genMiss">genMiss</a></code>, <code><a href="#topic+genObs">genObs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def1 &lt;- defData(varname = "m", dist = "binary", formula = .5)
def1 &lt;- defData(def1, "u", dist = "binary", formula = .5)
def1 &lt;- defData(def1, "x1", dist = "normal", formula = "20*m + 20*u", variance = 2)
def1 &lt;- defData(def1, "x2", dist = "normal", formula = "20*m + 20*u", variance = 2)
def1 &lt;- defData(def1, "x3", dist = "normal", formula = "20*m + 20*u", variance = 2)

dtAct &lt;- genData(1000, def1)

defM &lt;- defMiss(varname = "x1", formula = .15, logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "x2", formula = ".05 + m * 0.25", logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "x3", formula = ".05 + u * 0.25", logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "u", formula = 1, logit.link = FALSE) # not observed
defM

# Generate missing data matrix

missMat &lt;- genMiss(dtName = dtAct, missDefs = defM, idvars = "id")
missMat

# Generate observed data from actual data and missing data matrix

dtObs &lt;- genObs(dtAct, missMat, idvars = "id")
dtObs
</code></pre>

<hr>
<h2 id='defRead'>Read external csv data set definitions</h2><span id='topic+defRead'></span>

<h3>Description</h3>

<p>Read external csv data set definitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defRead(filen, id = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defRead_+3A_filen">filen</code></td>
<td>
<p>String file name, including full path. Must be a csv file.</p>
</td></tr>
<tr><td><code id="defRead_+3A_id">id</code></td>
<td>
<p>string that includes name of id field. Defaults to &quot;id&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with data set definitions
</p>


<h3>See Also</h3>

<p>[distributions]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary external "csv" file

test1 &lt;- c(
  "varname,formula,variance,dist,link",
  "nr,7, 0,nonrandom,identity",
  "x1,.4, 0,binary,identity",
  "y1,nr + x1 * 2,8,normal,identity",
  "y2,nr - 0.2 * x1,0,poisson, log"
)

tfcsv &lt;- tempfile()
writeLines(test1, tfcsv)

# Read external csv file stored in file "tfcsv"

defs &lt;- defRead(tfcsv, id = "myID")
defs

unlink(tfcsv)

# Generate data based on external definition

genData(5, defs)
</code></pre>

<hr>
<h2 id='defReadAdd'>Read external csv data set definitions for adding columns</h2><span id='topic+defReadAdd'></span>

<h3>Description</h3>

<p>Read external csv data set definitions for adding columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defReadAdd(filen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defReadAdd_+3A_filen">filen</code></td>
<td>
<p>String file name, including full path. Must be a csv file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with data set definitions
</p>


<h3>See Also</h3>

<p>[distributions]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary external "csv" files

test1 &lt;- c(
  "varname,formula,variance,dist,link",
  "nr,7, 0,nonrandom,identity"
)

tfcsv1 &lt;- tempfile()
writeLines(test1, tfcsv1)

test2 &lt;- c(
  "varname,formula,variance,dist,link",
  "x1,.4, 0,binary,identity",
  "y1,nr + x1 * 2,8,normal,identity",
  "y2,nr - 0.2 * x1,0,poisson, log"
)

tfcsv2 &lt;- tempfile()
writeLines(test2, tfcsv2)

# Generate data based on external definitions

defs &lt;- defRead(tfcsv1)
dt &lt;- genData(5, defs)
dt

# Add additional data based on external definitions

defs2 &lt;- defReadAdd(tfcsv2)
dt &lt;- addColumns(defs2, dt)
dt

unlink(tfcsv1)
unlink(tfcsv2)
</code></pre>

<hr>
<h2 id='defReadCond'>Read external csv data set definitions for adding columns</h2><span id='topic+defReadCond'></span>

<h3>Description</h3>

<p>Read external csv data set definitions for adding columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defReadCond(filen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defReadCond_+3A_filen">filen</code></td>
<td>
<p>String file name, including full path. Must be a csv file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with data set definitions
</p>


<h3>See Also</h3>

<p>[distributions]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary external "csv" files

test1 &lt;- c(
  "varname,formula,variance,dist,link",
  "x,0.3;0.4;0.3,0,categorical,identity"
)

tfcsv1 &lt;- tempfile()
writeLines(test1, tfcsv1)

test2 &lt;- c(
  "condition,formula,variance,dist,link",
  "x == 1, 0.4,0,binary,identity",
  "x == 2, 0.6,0,binary,identity",
  "x &gt;= 3, 0.8,0,binary,identity"
)

tfcsv2 &lt;- tempfile()
writeLines(test2, tfcsv2)

# Generate data based on external definitions

defs &lt;- defRead(tfcsv1)
dt &lt;- genData(2000, defs)
dt

# Add column based on

defsCond &lt;- defReadCond(tfcsv2)
dt &lt;- addCondition(defsCond, dt, "y")
dt

dt[, mean(y), keyby = x]

unlink(tfcsv1)
unlink(tfcsv2)
</code></pre>

<hr>
<h2 id='defRepeat'>Add multiple (similar) rows to definitions table</h2><span id='topic+defRepeat'></span>

<h3>Description</h3>

<p>Add multiple (similar) rows to definitions table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defRepeat(
  dtDefs = NULL,
  nVars,
  prefix,
  formula,
  variance = 0,
  dist = "normal",
  link = "identity",
  id = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defRepeat_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Definition data.table to be modified</p>
</td></tr>
<tr><td><code id="defRepeat_+3A_nvars">nVars</code></td>
<td>
<p>Number of new variables to define</p>
</td></tr>
<tr><td><code id="defRepeat_+3A_prefix">prefix</code></td>
<td>
<p>Prefix (character) for new variables</p>
</td></tr>
<tr><td><code id="defRepeat_+3A_formula">formula</code></td>
<td>
<p>An R expression for mean (string)</p>
</td></tr>
<tr><td><code id="defRepeat_+3A_variance">variance</code></td>
<td>
<p>Number or formula</p>
</td></tr>
<tr><td><code id="defRepeat_+3A_dist">dist</code></td>
<td>
<p>Distribution. For possibilities, see details</p>
</td></tr>
<tr><td><code id="defRepeat_+3A_link">link</code></td>
<td>
<p>The link function for the mean, see details</p>
</td></tr>
<tr><td><code id="defRepeat_+3A_id">id</code></td>
<td>
<p>A string indicating the field name for the unique record identifier</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible data distributions are: 'r paste0(.getDists(),collapse = &quot;, &quot;)'.
</p>


<h3>Value</h3>

<p>A data.table named dtName that is an updated data definitions table
</p>


<h3>See Also</h3>

<p>[distributions]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def &lt;- defRepeat(
  nVars = 4, prefix = "g", formula = "1/3;1/3;1/3",
  variance = 0, dist = "categorical"
)
def &lt;- defData(def, varname = "a", formula = "1;1", dist = "trtAssign")
def &lt;- defRepeat(def, 8, "b", formula = "5 + a", variance = 3, dist = "normal")
def &lt;- defData(def, "y", formula = "0.10", dist = "binary")

def
</code></pre>

<hr>
<h2 id='defRepeatAdd'>Add multiple (similar) rows to definitions table that will be used to add data to an
existing data.table</h2><span id='topic+defRepeatAdd'></span>

<h3>Description</h3>

<p>Add multiple (similar) rows to definitions table that will be used to add data to an
existing data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defRepeatAdd(
  dtDefs = NULL,
  nVars,
  prefix,
  formula,
  variance = 0,
  dist = "normal",
  link = "identity",
  id = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defRepeatAdd_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Definition data.table to be modified</p>
</td></tr>
<tr><td><code id="defRepeatAdd_+3A_nvars">nVars</code></td>
<td>
<p>Number of new variables to define</p>
</td></tr>
<tr><td><code id="defRepeatAdd_+3A_prefix">prefix</code></td>
<td>
<p>Prefix (character) for new variables</p>
</td></tr>
<tr><td><code id="defRepeatAdd_+3A_formula">formula</code></td>
<td>
<p>An R expression for mean (string)</p>
</td></tr>
<tr><td><code id="defRepeatAdd_+3A_variance">variance</code></td>
<td>
<p>Number or formula</p>
</td></tr>
<tr><td><code id="defRepeatAdd_+3A_dist">dist</code></td>
<td>
<p>Distribution. For possibilities, see details</p>
</td></tr>
<tr><td><code id="defRepeatAdd_+3A_link">link</code></td>
<td>
<p>The link function for the mean, see details</p>
</td></tr>
<tr><td><code id="defRepeatAdd_+3A_id">id</code></td>
<td>
<p>A string indicating the field name for the unique record identifier</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The possible data distributions are: 'r paste0(.getDists(),collapse = &quot;, &quot;)'.
</p>


<h3>Value</h3>

<p>A data.table named dtName that is an updated data definitions table
</p>


<h3>See Also</h3>

<p>[distributions]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def &lt;- defRepeatAdd(
  nVars = 4, prefix = "g", formula = "1/3;1/3;1/3",
  variance = 0, dist = "categorical"
)
def &lt;- defDataAdd(def, varname = "a", formula = "1;1", dist = "trtAssign")
def &lt;- defRepeatAdd(def, 8, "b", formula = "5 + a", variance = 3, dist = "normal")
def &lt;- defDataAdd(def, "y", formula = "0.10", dist = "binary")

def
</code></pre>

<hr>
<h2 id='defSurv'>Add single row to survival definitions</h2><span id='topic+defSurv'></span>

<h3>Description</h3>

<p>Add single row to survival definitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defSurv(
  dtDefs = NULL,
  varname,
  formula = 0,
  scale = 1,
  shape = 1,
  transition = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defSurv_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Definition data.table to be modified</p>
</td></tr>
<tr><td><code id="defSurv_+3A_varname">varname</code></td>
<td>
<p>Variable name</p>
</td></tr>
<tr><td><code id="defSurv_+3A_formula">formula</code></td>
<td>
<p>Covariates predicting survival</p>
</td></tr>
<tr><td><code id="defSurv_+3A_scale">scale</code></td>
<td>
<p>Scale parameter for the Weibull distribution.</p>
</td></tr>
<tr><td><code id="defSurv_+3A_shape">shape</code></td>
<td>
<p>The shape of the Weibull distribution. Shape = 1 for
an exponential distribution</p>
</td></tr>
<tr><td><code id="defSurv_+3A_transition">transition</code></td>
<td>
<p>An integer value indicating the starting point for a new
specification of the hazard function. It will default to 0 (and must be 0)
for the first instance of a &quot;varname&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table named dtName that is an updated data definitions table
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Baseline data definitions

def &lt;- defData(varname = "x1", formula = .5, dist = "binary")
def &lt;- defData(def, varname = "x2", formula = .5, dist = "binary")
def &lt;- defData(def, varname = "grp", formula = .5, dist = "binary")

# Survival data definitions

sdef &lt;- defSurv(
  varname = "survTime", formula = "1.5*x1",
  scale = "grp*50 + (1-grp)*25", shape = "grp*1 + (1-grp)*1.5"
)

sdef &lt;- defSurv(sdef, varname = "censorTime", scale = 80, shape = 1)

sdef

# Baseline data definitions

dtSurv &lt;- genData(300, def)

# Add survival times

dtSurv &lt;- genSurv(dtSurv, sdef)

head(dtSurv)
</code></pre>

<hr>
<h2 id='delColumns'>Delete columns from existing data set</h2><span id='topic+delColumns'></span>

<h3>Description</h3>

<p>Delete columns from existing data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delColumns(dtOld, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delColumns_+3A_dtold">dtOld</code></td>
<td>
<p>Name of data table that is to be updated.</p>
</td></tr>
<tr><td><code id="delColumns_+3A_vars">vars</code></td>
<td>
<p>Vector of column names (as strings).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated data.table without <code>vars</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># New data set

def &lt;- defData(varname = "x", dist = "noZeroPoisson", formula = 7, id = "idnum")
def &lt;- defData(def, varname = "xUni", dist = "uniformInt", formula = "x-3;x+3")

dt &lt;- genData(10, def)
dt

# Delete column

dt &lt;- delColumns(dt, "x")
dt
</code></pre>

<hr>
<h2 id='distributions'>Distributions for Data Definitions</h2><span id='topic+distributions'></span><span id='topic+normal'></span><span id='topic+poisson'></span><span id='topic+noZeroPoisson'></span><span id='topic+binary'></span><span id='topic+binomial'></span><span id='topic+uniform'></span><span id='topic+categorical'></span><span id='topic+gamma'></span><span id='topic+beta'></span><span id='topic+negBinomial'></span><span id='topic+nonrandom'></span><span id='topic+exponential'></span><span id='topic+mixture'></span>

<h3>Description</h3>

<p>This help file describes the distributions used for data creation in
<code>simstudy</code>.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="distributions_+3A_formula">formula</code></td>
<td>
<p>Desired mean as a Number or an R expression for mean as a
String. Variables defined via <code><a href="#topic+defData">defData()</a></code> and variables within the
parent environment (prefixed with <code>..</code>) can be used within the formula.
Functions from the parent environment can be used without a prefix.</p>
</td></tr>
<tr><td><code id="distributions_+3A_variance">variance</code></td>
<td>
<p>Number. Default is <code>0</code>.</p>
</td></tr>
<tr><td><code id="distributions_+3A_link">link</code></td>
<td>
<p>String identifying the link function to be used. Default is
<code>identity</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the statistical distributions please see
<a href="stats.html#topic+Distributions">stats::distributions</a>, any non-statistical distributions will be
explained below. Required variables and expected pattern for each
distribution can be found in this table:</p>

<table>
<tr>
 <td style="text-align: left;">
   <strong>name</strong> </td><td style="text-align: left;"> <strong>formula</strong> </td><td style="text-align: left;"> <strong>format</strong> </td><td style="text-align: left;"> <strong>variance</strong> </td><td style="text-align: left;"> <strong>link</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   beta </td><td style="text-align: left;"> mean </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> dispersion value </td><td style="text-align: left;"> identity or logit </td>
</tr>
<tr>
 <td style="text-align: left;">
   binary </td><td style="text-align: left;"> probability for 1 </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> identity or logit </td>
</tr>
<tr>
 <td style="text-align: left;">
   binomial </td><td style="text-align: left;"> probability of success </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> number of trials </td><td style="text-align: left;"> identity or logit </td>
</tr>
<tr>
 <td style="text-align: left;">
   categorical </td><td style="text-align: left;"> probabilities </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;p_1;p_2;..;p_n&#8288;</code> </td><td style="text-align: left;"> category labels: <code style="white-space: pre;">&#8288;a;b;c&#8288;</code> , <code style="white-space: pre;">&#8288;50;130;20&#8288;</code> </td><td style="text-align: left;"> identity or logit </td>
</tr>
<tr>
 <td style="text-align: left;">
   exponential </td><td style="text-align: left;"> mean (lambda) </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> identity or log </td>
</tr>
<tr>
 <td style="text-align: left;">
   gamma </td><td style="text-align: left;"> mean </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> dispersion value </td><td style="text-align: left;"> identity or log </td>
</tr>
<tr>
 <td style="text-align: left;">
   mixture </td><td style="text-align: left;"> formula </td><td style="text-align: left;"> <code>x_1 </code>|<code>p_1 + x_2</code>|<code style="white-space: pre;">&#8288;p_2 ... x_n&#8288;</code>|<code> p_n</code> </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td>
</tr>
<tr>
 <td style="text-align: left;">
   negBinomial </td><td style="text-align: left;"> mean </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> dispersion value </td><td style="text-align: left;"> identity or log </td>
</tr>
<tr>
 <td style="text-align: left;">
   nonrandom </td><td style="text-align: left;"> formula </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td>
</tr>
<tr>
 <td style="text-align: left;">
   normal </td><td style="text-align: left;"> mean </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> variance </td><td style="text-align: left;"> NA </td>
</tr>
<tr>
 <td style="text-align: left;">
   noZeroPoisson </td><td style="text-align: left;"> mean </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> identity or log </td>
</tr>
<tr>
 <td style="text-align: left;">
   poisson </td><td style="text-align: left;"> mean </td><td style="text-align: left;"> String or Number </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> identity or log </td>
</tr>
<tr>
 <td style="text-align: left;">
   trtAssign </td><td style="text-align: left;"> ratio </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;r_1;r_2;..;r_n&#8288;</code> </td><td style="text-align: left;"> stratification </td><td style="text-align: left;"> identity or nonbalanced </td>
</tr>
<tr>
 <td style="text-align: left;">
   uniform </td><td style="text-align: left;"> range </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;from;to&#8288;</code> </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td>
</tr>
<tr>
 <td style="text-align: left;">
   uniformInt </td><td style="text-align: left;"> range </td><td style="text-align: left;"> <code style="white-space: pre;">&#8288;from;to&#8288;</code> </td><td style="text-align: left;"> NA </td><td style="text-align: left;"> NA </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Mixture</h3>

<p>The mixture distribution makes it possible to mix to
previously defined distributions/variables. Each variable that should be
part of the new distribution <code style="white-space: pre;">&#8288;x_1,...,X_n&#8288;</code> is assigned a probability
<code style="white-space: pre;">&#8288;p_1,...,p_n&#8288;</code>. For more information see
<a href="https://www.rdatagen.net/post/adding-mixture-distributions-to-simstudy/">rdatagen.net</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ext_var &lt;- 2.9
def &lt;- defData(varname = "external", formula = "3 + log(..ext_var)", variance = .5)
def
genData(5, def)
</code></pre>

<hr>
<h2 id='gammaGetShapeRate'>Convert gamma mean and dispersion parameters to shape and rate parameters</h2><span id='topic+gammaGetShapeRate'></span>

<h3>Description</h3>

<p>Convert gamma mean and dispersion parameters to shape and rate parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaGetShapeRate(mean, dispersion)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaGetShapeRate_+3A_mean">mean</code></td>
<td>
<p>The mean of a gamma distribution</p>
</td></tr>
<tr><td><code id="gammaGetShapeRate_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion parameter of a gamma distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simstudy, users specify the gamma distribution as a function of two parameters - a mean
and dispersion. In this case, the variance of the specified distribution is (mean^2)*dispersion.
The base R function rgamma uses the shape and rate parameters to specify the gamma distribution.
This function converts the mean and dispersion into the shape and rate.
</p>


<h3>Value</h3>

<p>A list that includes the shape and rate parameters of the gamma distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
mean &lt;- 5
dispersion &lt;- 1.5
rs &lt;- gammaGetShapeRate(mean, dispersion)
c(rs$shape, rs$rate)
vec &lt;- rgamma(1000, shape = rs$shape, rate = rs$rate)
(estMoments &lt;- c(mean(vec), var(vec)))
(theoryMoments &lt;- c(mean, mean^2 * dispersion))
(theoryMoments &lt;- c(rs$shape / rs$rate, rs$shape / rs$rate^2))
</code></pre>

<hr>
<h2 id='genCatFormula'>Generate Categorical Formula</h2><span id='topic+genCatFormula'></span>

<h3>Description</h3>

<p>Create a semi-colon delimited string of probabilities to be used
to define categorical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCatFormula(..., n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCatFormula_+3A_...">...</code></td>
<td>
<p>one or more numeric values to be concatenated, delimited by &quot;;&quot;.</p>
</td></tr>
<tr><td><code id="genCatFormula_+3A_n">n</code></td>
<td>
<p>Number of probabilities (categories) to be generated - all with
equal probability.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function accepts a number of probabilities or a value of n, but
not both.
</p>
<p>If probabilities are passed, the string that is returned depends on the
nature of those probabilities. If the sum of the probabilities is less than
1, an additional category is created with the probability 1 - sum(provided
probabilities). If the sum of the probabilities is equal to 1, then the
number of categories is set to the number of probabilities provided. If the
sum of the probabilities exceeds one (and there is more than one
probability), the probabilities are standardized by dividing by the sum of
the probabilities provided.
</p>
<p>If n is provided, n probabilities are included in the string, each with a probability equal to 1/n.
</p>


<h3>Value</h3>

<p>string with multinomial probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genCatFormula(0.25, 0.25, 0.50)
genCatFormula(1 / 3, 1 / 2)
genCatFormula(1, 2, 3)
genCatFormula(n = 5)
</code></pre>

<hr>
<h2 id='genCluster'>Simulate clustered data</h2><span id='topic+genCluster'></span>

<h3>Description</h3>

<p>Simulate data set that is one level down in a multilevel data context. The
level &quot;2&quot; data set must contain a field that specifies the number of
individual records in a particular cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCluster(dtClust, cLevelVar, numIndsVar, level1ID, allLevel2 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCluster_+3A_dtclust">dtClust</code></td>
<td>
<p>Name of existing data set that contains the level &quot;2&quot; data</p>
</td></tr>
<tr><td><code id="genCluster_+3A_clevelvar">cLevelVar</code></td>
<td>
<p>Variable name (string) of cluster id in dtClust</p>
</td></tr>
<tr><td><code id="genCluster_+3A_numindsvar">numIndsVar</code></td>
<td>
<p>Variable name (string) of number of observations
per cluster in dtClust. Can also be a single integer value that will
be used for all clusters.</p>
</td></tr>
<tr><td><code id="genCluster_+3A_level1id">level1ID</code></td>
<td>
<p>Name of id field in new level &quot;1&quot; data set</p>
</td></tr>
<tr><td><code id="genCluster_+3A_alllevel2">allLevel2</code></td>
<td>
<p>Indicator: if set to TRUE (default), the returned data set
includes all of the Level 2 data columns. If FALSE, the returned data set
only includes the Levels 1 and 2 ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulated data table with level &quot;1&quot; data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen.school &lt;- defData(
  varname = "s0", dist = "normal",
  formula = 0, variance = 3, id = "idSchool"
)
gen.school &lt;- defData(gen.school,
  varname = "nClasses",
  dist = "noZeroPoisson", formula = 3
)

dtSchool &lt;- genData(3, gen.school) #'
dtSchool

dtClass &lt;- genCluster(dtSchool,
  cLevelVar = "idSchool",
  numIndsVar = "nClasses", level1ID = "idClass"
)
dtClass

dtClass &lt;- genCluster(dtSchool,
  cLevelVar = "idSchool",
  numIndsVar = 3, level1ID = "idClass"
)
dtClass
</code></pre>

<hr>
<h2 id='genCorData'>Create correlated data</h2><span id='topic+genCorData'></span>

<h3>Description</h3>

<p>Create correlated data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCorData(
  n,
  mu,
  sigma,
  corMatrix = NULL,
  rho,
  corstr = "ind",
  cnames = NULL,
  idname = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCorData_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="genCorData_+3A_mu">mu</code></td>
<td>
<p>A vector of means. The length of mu must be nvars.</p>
</td></tr>
<tr><td><code id="genCorData_+3A_sigma">sigma</code></td>
<td>
<p>Standard deviation of variables. If standard deviation differs for
each variable, enter as a vector with the same length as the mean vector mu. If
the standard deviation is constant across variables, as single value can be entered.</p>
</td></tr>
<tr><td><code id="genCorData_+3A_cormatrix">corMatrix</code></td>
<td>
<p>Correlation matrix can be entered directly. It must be symmetrical and
positive semi-definite. It is not a required field; if a matrix is not provided, then a
structure and correlation coefficient rho must be specified.</p>
</td></tr>
<tr><td><code id="genCorData_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, -1 &lt;= rho &lt;= 1. Use if corMatrix is not provided.</p>
</td></tr>
<tr><td><code id="genCorData_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure of the variance-covariance matrix
defined by sigma and rho. Options include &quot;ind&quot; for an independence
structure, &quot;cs&quot; for a compound symmetry structure, and &quot;ar1&quot; for an
autoregressive structure.</p>
</td></tr>
<tr><td><code id="genCorData_+3A_cnames">cnames</code></td>
<td>
<p>Explicit column names. A single string with names separated
by commas. If no string is provided, the default names will be V#, where #
represents the column.</p>
</td></tr>
<tr><td><code id="genCorData_+3A_idname">idname</code></td>
<td>
<p>The name of the index id name. Defaults to &quot;id.&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with n rows and the k + 1 columns, where k is the number of
means in the vector mu.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- c(3, 8, 15)
sigma &lt;- c(1, 2, 3)

corMat &lt;- matrix(c(1, .2, .8, .2, 1, .6, .8, .6, 1), nrow = 3)

dtcor1 &lt;- genCorData(1000, mu = mu, sigma = sigma, rho = .7, corstr = "cs")
dtcor2 &lt;- genCorData(1000, mu = mu, sigma = sigma, corMatrix = corMat)

dtcor1
dtcor2

round(var(dtcor1[, .(V1, V2, V3)]), 3)
round(cor(dtcor1[, .(V1, V2, V3)]), 2)

round(var(dtcor2[, .(V1, V2, V3)]), 3)
round(cor(dtcor2[, .(V1, V2, V3)]), 2)
</code></pre>

<hr>
<h2 id='genCorFlex'>Create multivariate (correlated) data - for general distributions</h2><span id='topic+genCorFlex'></span>

<h3>Description</h3>

<p>Create multivariate (correlated) data - for general distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCorFlex(n, defs, rho = 0, tau = NULL, corstr = "cs", corMatrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCorFlex_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="genCorFlex_+3A_defs">defs</code></td>
<td>
<p>Field definition table created by function 'defData'. All definitions
must be scalar. Definition specifies distribution, mean, and variance, with all
caveats for each of the distributions. (See defData).</p>
</td></tr>
<tr><td><code id="genCorFlex_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, -1 &lt;= rho &lt;= 1. Use if corMatrix is not provided.</p>
</td></tr>
<tr><td><code id="genCorFlex_+3A_tau">tau</code></td>
<td>
<p>Correlation based on Kendall's tau. If tau is specified, then it is
used as the correlation even if rho is specified. If tau is NULL, then the specified
value of rho is used, or rho defaults to 0.</p>
</td></tr>
<tr><td><code id="genCorFlex_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure of the variance-covariance matrix
defined by sigma and rho. Options include &quot;cs&quot; for a compound symmetry structure
and &quot;ar1&quot; for an autoregressive structure. Defaults to &quot;cs&quot;.</p>
</td></tr>
<tr><td><code id="genCorFlex_+3A_cormatrix">corMatrix</code></td>
<td>
<p>Correlation matrix can be entered directly. It must be symmetrical and
positive semi-definite. It is not a required field; if a matrix is not provided, then a
structure and correlation coefficient rho must be specified. This is only used if tau
is not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with added column(s) of correlated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
def &lt;- defData(varname = "xNorm", formula = 0, variance = 4, dist = "normal")
def &lt;- defData(def, varname = "xGamma1", formula = 15, variance = 2, dist = "gamma")
def &lt;- defData(def, varname = "xBin", formula = 0.5, dist = "binary")
def &lt;- defData(def, varname = "xUnif1", formula = "0;10", dist = "uniform")
def &lt;- defData(def, varname = "xPois", formula = 15, dist = "poisson")
def &lt;- defData(def, varname = "xUnif2", formula = "23;28", dist = "uniform")
def &lt;- defData(def, varname = "xUnif3", formula = "100;150", dist = "uniform")
def &lt;- defData(def, varname = "xGamma2", formula = 150, variance = 0.003, dist = "gamma")
def &lt;- defData(def, varname = "xNegBin", formula = 5, variance = .8, dist = "negBinomial")

dt &lt;- genCorFlex(1000, def, tau = 0.3, corstr = "cs")

cor(dt[, -"id"])
cor(dt[, -"id"], method = "kendall")
var(dt[, -"id"])
apply(dt[, -"id"], 2, mean)

## End(Not run)
</code></pre>

<hr>
<h2 id='genCorGen'>Create multivariate (correlated) data - for general distributions</h2><span id='topic+genCorGen'></span>

<h3>Description</h3>

<p>Create multivariate (correlated) data - for general distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCorGen(
  n,
  nvars,
  params1,
  params2 = NULL,
  dist,
  rho,
  corstr,
  corMatrix = NULL,
  wide = FALSE,
  cnames = NULL,
  method = "copula",
  idname = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCorGen_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_nvars">nvars</code></td>
<td>
<p>Number of variables</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_params1">params1</code></td>
<td>
<p>A single vector specifying the mean of the distribution. The vector is of
length 1 if the mean is the same across all observations, otherwise the vector is of length
nvars. In the case of the uniform distribution the vector specifies the minimum.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_params2">params2</code></td>
<td>
<p>A single vector specifying a possible second parameter for the distribution.
For the normal distribution, this will be the variance; for the gamma distribution, this
will be the dispersion; and for the uniform distribution, this will be the maximum. The
vector is of length 1 if the mean is the same across all observations, otherwise the vector
is of length nvars.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_dist">dist</code></td>
<td>
<p>A string indicating &quot;binary&quot;, &quot;poisson&quot; or &quot;gamma&quot;, &quot;normal&quot;, or &quot;uniform&quot;.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, -1 &lt;= rho &lt;= 1. Use if corMatrix is not provided.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure of the variance-covariance matrix
defined by sigma and rho. Options include &quot;cs&quot; for a compound symmetry structure
and &quot;ar1&quot; for an autoregressive structure.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_cormatrix">corMatrix</code></td>
<td>
<p>Correlation matrix can be entered directly. It must be symmetrical and
positive semi-definite. It is not a required field; if a matrix is not provided, then a
structure and correlation coefficient rho must be specified.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_wide">wide</code></td>
<td>
<p>The layout of the returned file - if wide = TRUE, all new correlated
variables will be returned in a single record, if wide = FALSE, each new variable
will be its own record (i.e. the data will be in long form). Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_cnames">cnames</code></td>
<td>
<p>Explicit column names. A single string with names separated
by commas. If no string is provided, the default names will be V#, where #
represents the column.</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_method">method</code></td>
<td>
<p>Two methods are available to generate correlated data. (1) &quot;copula&quot; uses
the multivariate Gaussian copula method that is applied to all other distributions; this
applies to all available distributions. (2) &quot;ep&quot; uses an algorithm developed by
Emrich and Piedmonte (1991).</p>
</td></tr>
<tr><td><code id="genCorGen_+3A_idname">idname</code></td>
<td>
<p>Character value that specifies the name of the id variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table with added column(s) of correlated data
</p>


<h3>References</h3>

<p>Emrich LJ, Piedmonte MR. A Method for Generating High-Dimensional
Multivariate Binary Variates. The American Statistician 1991;45:302-4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(23432)
lambda &lt;- c(8, 10, 12)

genCorGen(100, nvars = 3, params1 = lambda, dist = "poisson", rho = .7, corstr = "cs")
genCorGen(100, nvars = 3, params1 = 5, dist = "poisson", rho = .7, corstr = "cs")
genCorGen(100, nvars = 3, params1 = lambda, dist = "poisson", rho = .7, corstr = "cs", wide = TRUE)
genCorGen(100, nvars = 3, params1 = 5, dist = "poisson", rho = .7, corstr = "cs", wide = TRUE)

genCorGen(100,
  nvars = 3, params1 = lambda, dist = "poisson", rho = .7, corstr = "cs",
  cnames = "new_var"
)
genCorGen(100,
  nvars = 3, params1 = lambda, dist = "poisson", rho = .7, corstr = "cs",
  wide = TRUE, cnames = "a, b, c"
)
</code></pre>

<hr>
<h2 id='genCorMat'>Create a correlation matrix</h2><span id='topic+genCorMat'></span>

<h3>Description</h3>

<p>Create a correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCorMat(nvars, cors = NULL, rho = NULL, corstr = "cs", nclusters = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCorMat_+3A_nvars">nvars</code></td>
<td>
<p>number of rows and columns (i.e. number of variables) for correlation matrix. It can be
a scalar or vector (see details).</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_cors">cors</code></td>
<td>
<p>vector of correlations.</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, <code>-1 &lt;= rho &lt;= 1</code>. Use if corMatrix is not provided. It can
be a scalar or vector (see details).</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure. Options include &quot;cs&quot; for a compound symmetry structure, &quot;ar1&quot; 
for an autoregressive structure of order 1, &quot;arx&quot; for an autoregressive structure 
that has a general decay pattern, and &quot;structured&quot; that imposes a prescribed
pattern between observation based on distance (see details).</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_nclusters">nclusters</code></td>
<td>
<p>An integer that indicates the number of matrices that will be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can generate correlation matrices randomly or deterministically, 
depending on the combination of arguments provided. A single matrix will be
generated when <code>nclusters == 1</code> (the default), and a list of matrices of matrices will be generated when
<code>nclusters &gt; 1</code>.
</p>
<p>If the vector 'cors' is specified with length 'nvars - 1' then 'corstr' must be &quot;structured&quot;. If
'cors' is specified with length 'choose(nvars, 2)' then 'corstr' should not be specified as
&quot;structured&quot;. In this case the 'cors' vector should be interpreted as the lower triangle of the correlation
matrix, and is specified by reading down the columns. For example, if <b>CM</b> is the correlation matrix and
<code>nvars = 3</code>, then <code>CM[2,1] = CM[1,2] = cors[1]</code>,  <code>CM[3,1] = CM[1,3] = cors[2]</code>, 
and <code>CM[3,2] = CM[2,3] = cors[3]</code>.
</p>
<p>If the vector <code>cors</code> and <code>rho</code> are not specified, random correlation matrices are generated
based on the specified <code>corstr</code>. If the structure is &quot;arx&quot;, then a random vector of 
length <code>nvars - 1</code> is randomly generated and sorted in descending order; the correlation matrix
will be generated base on this set of structured correlations. If the structure is <em>not</em> specified
as &quot;arx&quot; then a random positive definite of dimensions nvars x nvars with no structural 
assumptions is generated.
</p>
<p>If <code>cors</code> is not specified but <code>rho</code> is specified, then a matrix with either a &quot;cs&quot; or &quot;ar1&quot; 
structure is generated.
</p>
<p>If <code>nclusters &gt; 1</code>, <code>nvars</code> can be of length 1 or <code>nclusters</code>. If it is of length 1,
each cluster will have correlation matrices with the same dimension. Likewise, if <code>nclusters &gt; 1</code>, 
<code>rho</code> can be of length 1 or <code>nclusters</code>. If length of <code>rho</code> is 1,
each cluster will have correlation matrices with the same autocorrelation.
</p>


<h3>Value</h3>

<p>A single correlation matrix of size <code>nvars x nvars</code>, or a list of matrices of potentially
different sizes with length indicated by <code>nclusters</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genCorMat(nvars = 3, cors = c(.3, -.2, .1))
genCorMat(nvars = 3)

genCorMat(nvars = 4, c(.3, -.2, .1, .2, .5, .2))
genCorMat(4)

genCorMat(nvars = 4, cors = c(.3, .2, .1), corstr = "structured") 
genCorMat(nvars = 4, corstr = "arx") 

genCorMat(nvars = 4, rho = .4, corstr = "cs") 
genCorMat(nvars = 4, rho = .4, corstr = "ar1") 

genCorMat(nvars = c(3, 2, 5), rho = c(.4, .8, .7), corstr = "ar1", nclusters = 3) 

</code></pre>

<hr>
<h2 id='genCorOrdCat'>Generate correlated ordinal categorical data</h2><span id='topic+genCorOrdCat'></span>

<h3>Description</h3>

<p>This function is deprecated, please use <a href="#topic+genOrdCat">genOrdCat</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCorOrdCat(
  dtName,
  idname = "id",
  adjVar = NULL,
  baseprobs,
  prefix = "grp",
  rho,
  corstr,
  corMatrix = NULL
)
</code></pre>

<hr>
<h2 id='genData'>Calling function to simulate data</h2><span id='topic+genData'></span>

<h3>Description</h3>

<p>Calling function to simulate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genData(n, dtDefs = NULL, id = "id", envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genData_+3A_n">n</code></td>
<td>
<p>the number of observations required in the data set.</p>
</td></tr>
<tr><td><code id="genData_+3A_dtdefs">dtDefs</code></td>
<td>
<p>name of definitions data.table/data.frame. If no definitions
are provided
a data set with ids only is generated.</p>
</td></tr>
<tr><td><code id="genData_+3A_id">id</code></td>
<td>
<p>The string defining the id of the record. Will override previously
set id name with a warning (unless the old value is 'id'). If the
id attribute in dtDefs is NULL will default to 'id'.</p>
</td></tr>
<tr><td><code id="genData_+3A_envir">envir</code></td>
<td>
<p>Environment the data definitions are evaluated in.
Defaults to <a href="base.html#topic+sys.parent">base::parent.frame</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table that contains the simulated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genData(5)
genData(5, id = "grpID")

def &lt;- defData(
  varname = "xNr", dist = "nonrandom", formula = 7,
  id = "idnum"
)
def &lt;- defData(def,
  varname = "xUni", dist = "uniform",
  formula = "10;20"
)
def &lt;- defData(def,
  varname = "xNorm", formula = "xNr + xUni * 2",
  dist = "normal", variance = 8
)
def &lt;- defData(def,
  varname = "xPois", dist = "poisson",
  formula = "xNr - 0.2 * xUni", link = "log"
)
def &lt;- defData(def,
  varname = "xCat", formula = "0.3;0.2;0.5",
  dist = "categorical"
)
def &lt;- defData(def,
  varname = "xGamma", dist = "gamma", formula = "5+xCat",
  variance = 1, link = "log"
)
def &lt;- defData(def,
  varname = "xBin", dist = "binary", formula = "-3 + xCat",
  link = "logit"
)
def

genData(5, def)
</code></pre>

<hr>
<h2 id='genDummy'>Create dummy variables from a factor or integer variable</h2><span id='topic+genDummy'></span>

<h3>Description</h3>

<p>Create dummy variables from a factor or integer variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genDummy(dtName, varname, sep = ".", replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genDummy_+3A_dtname">dtName</code></td>
<td>
<p>Data table with column</p>
</td></tr>
<tr><td><code id="genDummy_+3A_varname">varname</code></td>
<td>
<p>Name of factor</p>
</td></tr>
<tr><td><code id="genDummy_+3A_sep">sep</code></td>
<td>
<p>Character to be used in creating new name for dummy fields.
Valid characters include all letters and &quot;_&quot;. Will default to &quot;.&quot;. If
an invalid character is provided, it will be replaced by default.</p>
</td></tr>
<tr><td><code id="genDummy_+3A_replace">replace</code></td>
<td>
<p>If replace is set to TRUE (defaults to FALSE) the field
referenced varname will be removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# First example:

def &lt;- defData(varname = "cat", formula = ".2;.3;.5", dist = "categorical")
def &lt;- defData(def, varname = "x", formula = 5, variance = 2)

dx &lt;- genData(200, def)
dx

dx &lt;- genFactor(dx, "cat", labels = c("one", "two", "three"), replace = TRUE)
dx &lt;- genDummy(dx, varname = "fcat", sep = "_")

dx

# Second example:

dx &lt;- genData(15)
dx &lt;- trtAssign(dtName = dx, 3, grpName = "arm")
dx &lt;- genDummy(dx, varname = "arm")
dx
</code></pre>

<hr>
<h2 id='genFactor'>Create factor variable from an existing (non-double) variable</h2><span id='topic+genFactor'></span>

<h3>Description</h3>

<p>Create factor variable from an existing (non-double) variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genFactor(dtName, varname, labels = NULL, prefix = "f", replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genFactor_+3A_dtname">dtName</code></td>
<td>
<p>Data table with columns.</p>
</td></tr>
<tr><td><code id="genFactor_+3A_varname">varname</code></td>
<td>
<p>Name of field(s) to be converted.</p>
</td></tr>
<tr><td><code id="genFactor_+3A_labels">labels</code></td>
<td>
<p>Factor level labels. If not provided, the generated factor
levels will be used as the labels. Can be a vector (if only one new factor or
all factors have the same labels) or a list of character vectors of the same
length as varname.</p>
</td></tr>
<tr><td><code id="genFactor_+3A_prefix">prefix</code></td>
<td>
<p>By default, the new field name will be a concatenation of &quot;f&quot;
and the old field name. A prefix string can be provided.</p>
</td></tr>
<tr><td><code id="genFactor_+3A_replace">replace</code></td>
<td>
<p>If replace is set to TRUE (defaults to FALSE) the field
referenced varname will be removed.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# First example:

def &lt;- defData(varname = "cat", formula = ".2;.3;.5", dist = "categorical")
def &lt;- defData(def, varname = "x", formula = 5, variance = 2)

dx &lt;- genData(200, def)
dx

dx &lt;- genFactor(dx, "cat", labels = c("one", "two", "three"))
dx

# Second example:

dx &lt;- genData(10)
dx &lt;- trtAssign(dtName = dx, 2, grpName = "studyArm")
dx &lt;- genFactor(dx, varname = "studyArm", labels = c("control", "treatment"), prefix = "t_")
dx
</code></pre>

<hr>
<h2 id='genFormula'>Generate a linear formula</h2><span id='topic+genFormula'></span>

<h3>Description</h3>

<p>Formulas for additive linear models can be generated
with specified coefficient values and variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genFormula(coefs, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genFormula_+3A_coefs">coefs</code></td>
<td>
<p>A vector that contains the values of the
coefficients. Coefficients can also be defined as character for use with 
double dot notation. If length(coefs) == length(vars), then no intercept
is assumed. Otherwise, an intercept is assumed.</p>
</td></tr>
<tr><td><code id="genFormula_+3A_vars">vars</code></td>
<td>
<p>A vector of strings that specify the names of the
explanatory variables in the equation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string that represents the desired formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
genFormula(c(.5, 2, 4), c("A", "B", "C"))
genFormula(c(.5, 2, 4), c("A", "B"))

genFormula(c(.5, "..x", 4), c("A", "B", "C"))
genFormula(c(.5, 2, "..z"), c("A", "B"))

changeX &lt;- c(7, 10)
genFormula(c(.5, 2, changeX[1]), c("A", "B"))
genFormula(c(.5, 2, changeX[2]), c("A", "B"))
genFormula(c(.5, 2, changeX[2]), c("A", "B", "C"))

newForm &lt;- genFormula(c(-2, 1), c("A"))

def1 &lt;- defData(varname = "A", formula = 0, variance = 3, dist = "normal")
def1 &lt;- defData(def1, varname = "B", formula = newForm, dist = "binary", link = "logit")

set.seed(2001)
dt &lt;- genData(500, def1)
summary(glm(B ~ A, data = dt, family = binomial))
</code></pre>

<hr>
<h2 id='genMarkov'>Generate Markov chain</h2><span id='topic+genMarkov'></span>

<h3>Description</h3>

<p>Generate a Markov chain for n individuals or units by
specifying a transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMarkov(
  n,
  transMat,
  chainLen,
  wide = FALSE,
  id = "id",
  pername = "period",
  varname = "state",
  widePrefix = "S",
  trimvalue = NULL,
  startProb = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMarkov_+3A_n">n</code></td>
<td>
<p>number of individual chains to generate</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_transmat">transMat</code></td>
<td>
<p>Square transition matrix where the sum of each row
must equal 1. The dimensions of the matrix equal the number of possible
states.</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_chainlen">chainLen</code></td>
<td>
<p>Length of each chain that will be generated for each
chain; minimum chain length is 2.</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_wide">wide</code></td>
<td>
<p>Logical variable (TRUE or FALSE) indicating whether the
resulting data table should be returned in wide or long format. The
wide format includes all elements of a chain on a single row; the long
format includes each element of a chain in its own row. The default is
wide = FALSE, so the long format is returned by default.</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_id">id</code></td>
<td>
<p>Character string that represents name of &quot;id&quot; field.
Defaults to &quot;id&quot;.</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_pername">pername</code></td>
<td>
<p>Character string that represents the variable name of the
chain sequence in the long format. Defaults &quot;period&quot;,</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_varname">varname</code></td>
<td>
<p>Character string that represents the variable name of the
state in the long format. Defaults to &quot;state&quot;.</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_wideprefix">widePrefix</code></td>
<td>
<p>Character string that represents the variable name
prefix for the state fields in the wide format. Defaults to &quot;S&quot;.</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_trimvalue">trimvalue</code></td>
<td>
<p>Integer value indicating end state. If trimvalue is not NULL,
all records after the first instance of state = trimvalue will be deleted.</p>
</td></tr>
<tr><td><code id="genMarkov_+3A_startprob">startProb</code></td>
<td>
<p>A string that contains the probability distribution of the 
starting state, separated by a &quot;;&quot;. Length of start probabilities must match
the number of rows of the transition matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table with n rows if in wide format, or n by chainLen rows
if in long format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Transition matrix P

P &lt;- t(matrix(c(
  0.7, 0.2, 0.1,
  0.5, 0.3, 0.2,
  0.0, 0.1, 0.9
), nrow = 3, ncol = 3))

d1 &lt;- genMarkov(n = 10, transMat = P, chainLen = 5)
d2 &lt;- genMarkov(n = 10, transMat = P, chainLen = 5, wide = TRUE)
d3 &lt;- genMarkov(
  n = 10, transMat = P, chainLen = 5,
  pername = "seq", varname = "health",
  trimvalue = 3
)
</code></pre>

<hr>
<h2 id='genMiss'>Generate missing data</h2><span id='topic+genMiss'></span>

<h3>Description</h3>

<p>Generate missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMiss(
  dtName,
  missDefs,
  idvars,
  repeated = FALSE,
  periodvar = "period",
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMiss_+3A_dtname">dtName</code></td>
<td>
<p>Name of complete data set</p>
</td></tr>
<tr><td><code id="genMiss_+3A_missdefs">missDefs</code></td>
<td>
<p>Definitions of missingness</p>
</td></tr>
<tr><td><code id="genMiss_+3A_idvars">idvars</code></td>
<td>
<p>Index variables</p>
</td></tr>
<tr><td><code id="genMiss_+3A_repeated">repeated</code></td>
<td>
<p>Indicator for longitudinal data</p>
</td></tr>
<tr><td><code id="genMiss_+3A_periodvar">periodvar</code></td>
<td>
<p>Name of variable that contains period</p>
</td></tr>
<tr><td><code id="genMiss_+3A_envir">envir</code></td>
<td>
<p>parent.frame() by default, allows functionality with double-dot
notation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Missing data matrix indexed by idvars (and period if relevant)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defMiss">defMiss</a></code>, <code><a href="#topic+genObs">genObs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def1 &lt;- defData(varname = "m", dist = "binary", formula = .5)
def1 &lt;- defData(def1, "u", dist = "binary", formula = .5)
def1 &lt;- defData(def1, "x1", dist = "normal", formula = "20*m + 20*u", variance = 2)
def1 &lt;- defData(def1, "x2", dist = "normal", formula = "20*m + 20*u", variance = 2)
def1 &lt;- defData(def1, "x3", dist = "normal", formula = "20*m + 20*u", variance = 2)

dtAct &lt;- genData(1000, def1)

defM &lt;- defMiss(varname = "x1", formula = .15, logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "x2", formula = ".05 + m * 0.25", logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "x3", formula = ".05 + u * 0.25", logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "u", formula = 1, logit.link = FALSE) # not observed
defM

# Generate missing data matrix

missMat &lt;- genMiss(dtAct, defM, idvars = "id")
missMat

# Generate observed data from actual data and missing data matrix

dtObs &lt;- genObs(dtAct, missMat, idvars = "id")
dtObs
</code></pre>

<hr>
<h2 id='genMixFormula'>Generate Mixture Formula</h2><span id='topic+genMixFormula'></span>

<h3>Description</h3>

<p>Generates a mixture formula from a vector of variable names and
an optional vector of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMixFormula(vars, probs = NULL, varLength = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMixFormula_+3A_vars">vars</code></td>
<td>
<p>Character vector/list of variable names.</p>
</td></tr>
<tr><td><code id="genMixFormula_+3A_probs">probs</code></td>
<td>
<p>Numeric vector/list of probabilities. Has to be same length as
vars or NULL. Probabilities will be normalized if the sum to &gt; 1.</p>
</td></tr>
<tr><td><code id="genMixFormula_+3A_varlength">varLength</code></td>
<td>
<p>If <code>vars</code> is of length one and varLength is set to any
integer &gt; 0, <code>vars</code> will be interpreted as array of length <code>varLength</code> and
all elements will used in sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mixture formula as a string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genMixFormula(c("a", "..b[..i]", "c"))
genMixFormula(c("a", "..b", "c"), c(.2, .5, .3))

# Shorthand to use external vectors/lists
genMixFormula("..arr", varLength = 5)
</code></pre>

<hr>
<h2 id='genMultiFac'>Generate multi-factorial data</h2><span id='topic+genMultiFac'></span>

<h3>Description</h3>

<p>Generate multi-factorial data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMultiFac(
  nFactors,
  each,
  levels = 2,
  coding = "dummy",
  colNames = NULL,
  idName = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genMultiFac_+3A_nfactors">nFactors</code></td>
<td>
<p>Number of factors (columns) to generate.</p>
</td></tr>
<tr><td><code id="genMultiFac_+3A_each">each</code></td>
<td>
<p>Number of replications for each combination of factors. Must be specified.</p>
</td></tr>
<tr><td><code id="genMultiFac_+3A_levels">levels</code></td>
<td>
<p>Vector or scalar. If a vector is specified, it must be
the same length as nFatctors. Each value of the vector represents the
number of levels of each corresponding factor. If a scalar is specified,
each factor will have the same number of levels. The default is 2 levels
for each factor.</p>
</td></tr>
<tr><td><code id="genMultiFac_+3A_coding">coding</code></td>
<td>
<p>String value to specify if &quot;dummy&quot; or &quot;effect&quot; coding is used.
Defaults to &quot;dummy&quot;.</p>
</td></tr>
<tr><td><code id="genMultiFac_+3A_colnames">colNames</code></td>
<td>
<p>A vector of strings, with a length of nFactors. The strings
represent the name for each factor.</p>
</td></tr>
<tr><td><code id="genMultiFac_+3A_idname">idName</code></td>
<td>
<p>A string that specifies the id of the record. Defaults to &quot;id&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table that contains the added simulated data. Each column contains
an integer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>genMultiFac(nFactors = 2, each = 5)
genMultiFac(nFactors = 2, each = 4, levels = c(2, 3))
genMultiFac(
  nFactors = 3, each = 1, coding = "effect",
  colNames = c("Fac1", "Fac2", "Fac3"), id = "block"
)
</code></pre>

<hr>
<h2 id='genNthEvent'>Generate event data using longitudinal data, and restrict output to time
until the nth event.</h2><span id='topic+genNthEvent'></span>

<h3>Description</h3>

<p>Generate event data using longitudinal data, and restrict output to time
until the nth event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genNthEvent(dtName, defEvent, nEvents = 1, perName = "period", id = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genNthEvent_+3A_dtname">dtName</code></td>
<td>
<p>name of existing data table</p>
</td></tr>
<tr><td><code id="genNthEvent_+3A_defevent">defEvent</code></td>
<td>
<p>data definition table (created with defDataAdd) that
determines the event generating process.</p>
</td></tr>
<tr><td><code id="genNthEvent_+3A_nevents">nEvents</code></td>
<td>
<p>maximum number of events that will be generated (the nth
event).</p>
</td></tr>
<tr><td><code id="genNthEvent_+3A_pername">perName</code></td>
<td>
<p>variable name for period field. Defaults to &quot;period&quot;</p>
</td></tr>
<tr><td><code id="genNthEvent_+3A_id">id</code></td>
<td>
<p>string representing name of the id
field in table specified by dtName</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.table that stops after &quot;nEvents&quot; are reached.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>defD &lt;- defData(
  varname = "effect", formula = 0, variance = 1,
  dist = "normal"
)
defE &lt;- defDataAdd(
  varname = "died", formula = "-2.5 + 0.3*period + effect",
  dist = "binary", link = "logit"
)

d &lt;- genData(1000, defD)
d &lt;- addPeriods(d, 10)
dx &lt;- genNthEvent(d, defEvent = defE, nEvents = 3)
</code></pre>

<hr>
<h2 id='genObs'>Create an observed data set that includes missing data</h2><span id='topic+genObs'></span>

<h3>Description</h3>

<p>Create an observed data set that includes missing data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genObs(dtName, dtMiss, idvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genObs_+3A_dtname">dtName</code></td>
<td>
<p>Name of complete data set</p>
</td></tr>
<tr><td><code id="genObs_+3A_dtmiss">dtMiss</code></td>
<td>
<p>Name of missing data matrix</p>
</td></tr>
<tr><td><code id="genObs_+3A_idvars">idvars</code></td>
<td>
<p>Index variables that cannot be missing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table that represents observed data, including
missing data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defMiss">defMiss</a></code>, <code><a href="#topic+genMiss">genMiss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def1 &lt;- defData(varname = "m", dist = "binary", formula = .5)
def1 &lt;- defData(def1, "u", dist = "binary", formula = .5)
def1 &lt;- defData(def1, "x1", dist = "normal", formula = "20*m + 20*u", variance = 2)
def1 &lt;- defData(def1, "x2", dist = "normal", formula = "20*m + 20*u", variance = 2)
def1 &lt;- defData(def1, "x3", dist = "normal", formula = "20*m + 20*u", variance = 2)

dtAct &lt;- genData(1000, def1)

defM &lt;- defMiss(varname = "x1", formula = .15, logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "x2", formula = ".05 + m * 0.25", logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "x3", formula = ".05 + u * 0.25", logit.link = FALSE)
defM &lt;- defMiss(defM, varname = "u", formula = 1, logit.link = FALSE) # not observed
defM

# Generate missing data matrix

missMat &lt;- genMiss(dtAct, defM, idvars = "id")
missMat

# Generate observed data from actual data and missing data matrix

dtObs &lt;- genObs(dtAct, missMat, idvars = "id")
dtObs
</code></pre>

<hr>
<h2 id='genOrdCat'>Generate ordinal categorical data</h2><span id='topic+genOrdCat'></span>

<h3>Description</h3>

<p>Ordinal categorical data is added to an existing data set.
Correlations can be added via correlation matrix or <code>rho</code> and <code>corstr</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genOrdCat(
  dtName,
  adjVar = NULL,
  baseprobs,
  catVar = "cat",
  asFactor = TRUE,
  idname = "id",
  prefix = "grp",
  rho = 0,
  corstr = "ind",
  corMatrix = NULL,
  npVar = NULL,
  npAdj = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genOrdCat_+3A_dtname">dtName</code></td>
<td>
<p>Name of complete data set</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_adjvar">adjVar</code></td>
<td>
<p>Adjustment variable  name in dtName - determines
logistic shift. This is specified assuming a cumulative logit
link.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_baseprobs">baseprobs</code></td>
<td>
<p>Baseline probability expressed as a vector or matrix of
probabilities. The values (per row) must sum to &lt;= 1. If <code>rowSums(baseprobs) &lt; 1</code>, an additional category is added with probability <code>1 - rowSums(baseprobs)</code>. The number of rows represents the number of new
categorical variables. The number of columns represents the number of
possible responses - if an particular category has fewer possible responses,
assign zero probability to non-relevant columns.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_catvar">catVar</code></td>
<td>
<p>Name of the new categorical field. Defaults to &quot;cat&quot;. Can be a
character vector with a name for each new variable defined via <code>baseprobs</code>.
Will be overridden by <code>prefix</code> if more than one variable is defined and
<code>length(catVar) == 1</code>.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_asfactor">asFactor</code></td>
<td>
<p>If <code>asFactor == TRUE</code> (default), new field is returned
as a factor. If <code>asFactor == FALSE</code>, new field is returned as an integer.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_idname">idname</code></td>
<td>
<p>Name of the id column in <code>dtName</code>.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_prefix">prefix</code></td>
<td>
<p>A string. The names of the new variables will be a
concatenation of the prefix and a sequence of integers indicating the
variable number.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_rho">rho</code></td>
<td>
<p>Correlation coefficient, -1 &lt; rho &lt; 1. Use if corMatrix is not
provided.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_corstr">corstr</code></td>
<td>
<p>Correlation structure of the variance-covariance matrix defined
by sigma and rho. Options include &quot;ind&quot; for an independence structure, &quot;cs&quot;
for a compound symmetry structure, and &quot;ar1&quot; for an autoregressive structure.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_cormatrix">corMatrix</code></td>
<td>
<p>Correlation matrix can be entered directly. It must be
symmetrical and positive definite. It is not a required field; if a matrix is
not provided, then a structure and correlation coefficient rho must be
specified. (The matrix created via <code>rho</code> and <code>corstr</code> must also be positive
definite.)</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_npvar">npVar</code></td>
<td>
<p>Vector of variable names that indicate which variables are to
violate the proportionality assumption.</p>
</td></tr>
<tr><td><code id="genOrdCat_+3A_npadj">npAdj</code></td>
<td>
<p>Matrix with a row for each npVar and a column for each category.
Each value represents the deviation from the proportional odds assumption on
the logistic scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Original data.table with added categorical field.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ordinal Categorical Data ----

def1 &lt;- defData(
  varname = "male",
  formula = 0.45, dist = "binary", id = "idG"
)
def1 &lt;- defData(def1,
  varname = "z",
  formula = "1.2*male", dist = "nonrandom"
)
def1

## Generate data

set.seed(20)

dx &lt;- genData(1000, def1)

probs &lt;- c(0.40, 0.25, 0.15)

dx &lt;- genOrdCat(dx,
  adjVar = "z", idname = "idG", baseprobs = probs,
  catVar = "grp"
)
dx

# Correlated Ordinal Categorical Data ----

baseprobs &lt;- matrix(c(
  0.2, 0.1, 0.1, 0.6,
  0.7, 0.2, 0.1, 0,
  0.5, 0.2, 0.3, 0,
  0.4, 0.2, 0.4, 0,
  0.6, 0.2, 0.2, 0
),
nrow = 5, byrow = TRUE
)

set.seed(333)
dT &lt;- genData(1000)

dX &lt;- genOrdCat(dT,
  adjVar = NULL, baseprobs = baseprobs,
  prefix = "q", rho = .125, corstr = "cs", asFactor = FALSE
)
dX

dM &lt;- data.table::melt(dX, id.vars = "id")
dProp &lt;- dM[, prop.table(table(value)), by = variable]
dProp[, response := c(1:4, 1:3, 1:3, 1:3, 1:3)]

data.table::dcast(dProp, variable ~ response,
  value.var = "V1", fill = 0
)

# proportional odds assumption violated

d1 &lt;- defData(varname = "rx", formula = "1;1", dist = "trtAssign")
d1 &lt;- defData(d1, varname = "z", formula = "0 - 1.2*rx", dist = "nonrandom")

dd &lt;- genData(1000, d1)

baseprobs &lt;- c(.4, .3, .2, .1)
npAdj &lt;- c(0, 1, 0, 0)

dn &lt;- genOrdCat(
  dtName = dd, adjVar = "z",
  baseprobs = baseprobs,
  npVar = "rx", npAdj = npAdj
)

</code></pre>

<hr>
<h2 id='genSpline'>Generate spline curves</h2><span id='topic+genSpline'></span>

<h3>Description</h3>

<p>Generate spline curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSpline(
  dt,
  newvar,
  predictor,
  theta,
  knots = c(0.25, 0.5, 0.75),
  degree = 3,
  newrange = NULL,
  noise.var = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSpline_+3A_dt">dt</code></td>
<td>
<p>data.table that will be modified</p>
</td></tr>
<tr><td><code id="genSpline_+3A_newvar">newvar</code></td>
<td>
<p>Name of new variable to be created</p>
</td></tr>
<tr><td><code id="genSpline_+3A_predictor">predictor</code></td>
<td>
<p>Name of field in old data.table that is predicting new value</p>
</td></tr>
<tr><td><code id="genSpline_+3A_theta">theta</code></td>
<td>
<p>A vector or matrix of values between 0 and 1. Each column of the matrix
represents the weights/coefficients that will be applied to the basis functions
determined by the knots and degree. Each column of theta represents a separate
spline curve.</p>
</td></tr>
<tr><td><code id="genSpline_+3A_knots">knots</code></td>
<td>
<p>A vector of values between 0 and 1, specifying quantile
cut-points for splines. Defaults to c(0.25, 0.50, 0.75).</p>
</td></tr>
<tr><td><code id="genSpline_+3A_degree">degree</code></td>
<td>
<p>Integer specifying polynomial degree of curvature.</p>
</td></tr>
<tr><td><code id="genSpline_+3A_newrange">newrange</code></td>
<td>
<p>Range of the spline function , specified as a string
with two values separated by a semi-colon. The first value represents the
minimum, and the second value represents the maximum. Defaults to NULL, which
sets the range to be between 0 and 1.</p>
</td></tr>
<tr><td><code id="genSpline_+3A_noise.var">noise.var</code></td>
<td>
<p>Add to normally distributed noise to observation - where mean
is value of spline curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified data.table with an added column named newvar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ddef &lt;- defData(varname = "age", formula = "0;1", dist = "uniform")

theta1 &lt;- c(0.1, 0.8, 0.6, 0.4, 0.6, 0.9, 0.9)
knots &lt;- c(0.25, 0.5, 0.75)

viewSplines(knots = knots, theta = theta1, degree = 3)

set.seed(234)
dt &lt;- genData(1000, ddef)

dt &lt;- genSpline(
  dt = dt, newvar = "weight",
  predictor = "age", theta = theta1,
  knots = knots, degree = 3,
  noise.var = .025
)

dt
</code></pre>

<hr>
<h2 id='genSurv'>Generate survival data</h2><span id='topic+genSurv'></span>

<h3>Description</h3>

<p>Survival data is added to an existing data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSurv(
  dtName,
  survDefs,
  digits = 3,
  timeName = NULL,
  censorName = NULL,
  eventName = "event",
  typeName = "type",
  keepEvents = FALSE,
  idName = "id"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSurv_+3A_dtname">dtName</code></td>
<td>
<p>Name of data set</p>
</td></tr>
<tr><td><code id="genSurv_+3A_survdefs">survDefs</code></td>
<td>
<p>Definitions of survival</p>
</td></tr>
<tr><td><code id="genSurv_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding</p>
</td></tr>
<tr><td><code id="genSurv_+3A_timename">timeName</code></td>
<td>
<p>A string to indicate the name of a combined competing risk
time-to-event outcome that reflects the minimum observed value of all 
time-to-event outcomes. Defaults to NULL, indicating that each time-to-event
outcome will be included in dataset.</p>
</td></tr>
<tr><td><code id="genSurv_+3A_censorname">censorName</code></td>
<td>
<p>The name of a time to event variable that is the censoring
variable. Will be ignored if timeName is NULL.</p>
</td></tr>
<tr><td><code id="genSurv_+3A_eventname">eventName</code></td>
<td>
<p>The name of the new numeric/integer column representing the
competing event outcomes. If censorName is specified, the integer value for
that event will be 0. Defaults to &quot;event&quot;, but will be ignored 
if timeName is NULL.</p>
</td></tr>
<tr><td><code id="genSurv_+3A_typename">typeName</code></td>
<td>
<p>The name of the new character column that will indicate the
event type. The type will be the unique variable names in survDefs. Defaults
to &quot;type&quot;, but will be ignored if timeName is NULL.</p>
</td></tr>
<tr><td><code id="genSurv_+3A_keepevents">keepEvents</code></td>
<td>
<p>Indicator to retain original &quot;events&quot; columns. Defaults
to FALSE.</p>
</td></tr>
<tr><td><code id="genSurv_+3A_idname">idName</code></td>
<td>
<p>Name of id field in existing data set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Original data table with survival time
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Baseline data definitions

def &lt;- defData(varname = "x1", formula = .5, dist = "binary")
def &lt;- defData(def, varname = "x2", formula = .5, dist = "binary")
def &lt;- defData(def, varname = "grp", formula = .5, dist = "binary")

# Survival data definitions

sdef &lt;- defSurv(
  varname = "survTime", formula = "1.5*x1",
  scale = "grp*50 + (1-grp)*25", shape = "grp*1 + (1-grp)*1.5"
)

sdef &lt;- defSurv(sdef, varname = "censorTime", scale = 80, shape = 1)

sdef

# Baseline data definitions

dtSurv &lt;- genData(300, def)

# Add survival times

dtSurv &lt;- genSurv(dtSurv, sdef)

head(dtSurv)
</code></pre>

<hr>
<h2 id='genSynthetic'>Generate synthetic data</h2><span id='topic+genSynthetic'></span>

<h3>Description</h3>

<p>Synthetic data is generated from an existing data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSynthetic(dtFrom, n = nrow(dtFrom), vars = NULL, id = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSynthetic_+3A_dtfrom">dtFrom</code></td>
<td>
<p>Data table that contains the source data</p>
</td></tr>
<tr><td><code id="genSynthetic_+3A_n">n</code></td>
<td>
<p>Number of samples to draw from the source data. The default
is number of records that are in the source data file.</p>
</td></tr>
<tr><td><code id="genSynthetic_+3A_vars">vars</code></td>
<td>
<p>A vector of string names specifying the fields that will be
sampled. The default is that all variables will be selected.</p>
</td></tr>
<tr><td><code id="genSynthetic_+3A_id">id</code></td>
<td>
<p>A string specifying the field that serves as the record id. The
default field is &quot;id&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data table with the generated data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Create fake "real" data set

d &lt;- defData(varname = "a", formula = 3, variance = 1, dist = "normal")
d &lt;- defData(d, varname = "b", formula = 5, dist = "poisson")
d &lt;- defData(d, varname = "c", formula = 0.3, dist = "binary")
d &lt;- defData(d, varname = "d", formula = "a + b + 3*c", variance = 2, dist = "normal")

A &lt;- genData(100, d, id = "index")

### Create synthetic data set from "observed" data set A:

def &lt;- defDataAdd(varname = "x", formula = "2*b + 2*d", variance = 2)

S &lt;- genSynthetic(dtFrom = A, n = 120, vars = c("b", "d"), id = "index")
S &lt;- addColumns(def, S)

</code></pre>

<hr>
<h2 id='iccRE'>Generate variance for random effects that produce desired intra-class
coefficients (ICCs) for clustered data.</h2><span id='topic+iccRE'></span>

<h3>Description</h3>

<p>Generate variance for random effects that produce desired intra-class
coefficients (ICCs) for clustered data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iccRE(ICC, dist, varTotal = NULL, varWithin = NULL, lambda = NULL, disp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iccRE_+3A_icc">ICC</code></td>
<td>
<p>Vector of values between 0 and 1 that represent the
target ICC levels</p>
</td></tr>
<tr><td><code id="iccRE_+3A_dist">dist</code></td>
<td>
<p>The distribution that describes the outcome data at the
individual level. Possible distributions include &quot;normal&quot;, &quot;binary&quot;,
&quot;poisson&quot;, or &quot;gamma&quot;</p>
</td></tr>
<tr><td><code id="iccRE_+3A_vartotal">varTotal</code></td>
<td>
<p>Numeric value that represents the total variation for a
normally distributed model. If &quot;normal&quot; distribution is specified, either
varTotal or varWithin must be specified, but not both.</p>
</td></tr>
<tr><td><code id="iccRE_+3A_varwithin">varWithin</code></td>
<td>
<p>Numeric value that represents the variation within a
cluster for a normally distributed model. If &quot;normal&quot; distribution is
specified, either varTotal or varWithin must be specified, but not both.</p>
</td></tr>
<tr><td><code id="iccRE_+3A_lambda">lambda</code></td>
<td>
<p>Numeric value that represents the grand mean. Must be specified
when distribution is &quot;poisson&quot; or &quot;negative binomial&quot;.</p>
</td></tr>
<tr><td><code id="iccRE_+3A_disp">disp</code></td>
<td>
<p>Numeric value that represents the dispersion parameter that is used
to define a gamma or negative binomial distribution with a log link. Must be
specified when distribution is &quot;gamma&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values that represents the variances of random effects
at the cluster level that correspond to the ICC vector.
</p>


<h3>References</h3>

<p>Nakagawa, Shinichi, and Holger Schielzeth. &quot;A general and simple 
method for obtaining R2 from generalized linear mixedeffects models.&quot; 
Methods in ecology and evolution 4, no. 2 (2013): 133-142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>targetICC &lt;- seq(0.05, 0.20, by = .01)

iccRE(targetICC, "poisson", lambda = 30)

iccRE(targetICC, "binary")

iccRE(targetICC, "normal", varTotal = 100)
iccRE(targetICC, "normal", varWithin = 100)

iccRE(targetICC, "gamma", disp = .5)

iccRE(targetICC, "negBinomial", lambda = 40, disp = .5)
</code></pre>

<hr>
<h2 id='logisticCoefs'>Determine intercept, treatment/exposure and covariate coefficients that can 
be used for binary data generation with a logit link and a set of covariates</h2><span id='topic+logisticCoefs'></span>

<h3>Description</h3>

<p>This is an implementation of an iterative bisection procedure 
that can be used to determine coefficient values for a target population 
prevalence as well as a target risk ratio, risk difference, or AUC. These 
coefficients can be used in a subsequent data generation process to simulate
data with these desire characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logisticCoefs(
  defCovar,
  coefs,
  popPrev,
  rr = NULL,
  rd = NULL,
  auc = NULL,
  tolerance = 0.001,
  sampleSize = 1e+05,
  trtName = "A"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logisticCoefs_+3A_defcovar">defCovar</code></td>
<td>
<p>A definition table for the covariates in the underlying
population. This tables specifies the distribution of the covariates.</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_coefs">coefs</code></td>
<td>
<p>A vector of coefficients that reflect the relationship between 
each of the covariates and the log-odds of the outcome.</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_popprev">popPrev</code></td>
<td>
<p>The target population prevalence of the outcome. 
A value between 0 and 1.</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_rr">rr</code></td>
<td>
<p>The target risk ratio, which must be a value between 0 and
1/popPrev. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_rd">rd</code></td>
<td>
<p>The target risk difference, which must be between
-(popPrev) and (1 - popPrev). Defaults to NULL</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_auc">auc</code></td>
<td>
<p>The target AUC, which must be a value between 0.5 and 1.0 . 
Defaults to NULL.</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_tolerance">tolerance</code></td>
<td>
<p>The minimum stopping distance between the adjusted low and high
endpoints. Defaults to 0.001.</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_samplesize">sampleSize</code></td>
<td>
<p>The number of units to generate for the bisection algorithm. 
The default is 1e+05. To get a reliable estimate, the value 
should be no smaller than the default, though larger values can be used, though
computing time will increase.</p>
</td></tr>
<tr><td><code id="logisticCoefs_+3A_trtname">trtName</code></td>
<td>
<p>If either a risk ratio or risk difference is the target statistic,
a treatment/exposure variable name can be provided. Defaults to &quot;A&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no specific target statistic is specified, then only the intercept
is returned along with the original coefficients. Only one target statistic (risk ratio, risk
difference or AUC) can be specified with a single function call; in all three cases, a target
prevalence is still required.
</p>


<h3>Value</h3>

<p>A vector of parameters including the intercept and covariate 
coefficients for the logistic model data generating process.
</p>


<h3>References</h3>

<p>Austin, Peter C. &quot;The iterative bisection procedure: a useful 
tool for determining parameter values in data-generating processes in 
Monte Carlo simulations.&quot; BMC Medical Research Methodology 23, 
no. 1 (2023): 1-10.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
d1 &lt;- defData(varname = "x1", formula = 0, variance = 1)
d1 &lt;- defData(d1, varname = "b1", formula = 0.5, dist = "binary")

coefs &lt;- log(c(1.2, 0.8))

logisticCoefs(d1, coefs, popPrev = 0.20) 
logisticCoefs(d1, coefs, popPrev = 0.20, rr = 1.50, trtName = "rx") 
logisticCoefs(d1, coefs, popPrev = 0.20, rd = 0.30, trtName = "rx")
logisticCoefs(d1, coefs, popPrev = 0.20, auc = 0.80)

## End(Not run)
</code></pre>

<hr>
<h2 id='mergeData'>Merge two data tables</h2><span id='topic+mergeData'></span>

<h3>Description</h3>

<p>Merge two data tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeData(dt1, dt2, idvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeData_+3A_dt1">dt1</code></td>
<td>
<p>Name of first data.table</p>
</td></tr>
<tr><td><code id="mergeData_+3A_dt2">dt2</code></td>
<td>
<p>Name of second data.table</p>
</td></tr>
<tr><td><code id="mergeData_+3A_idvars">idvars</code></td>
<td>
<p>Vector of string names to merge on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new data table that merges dt2 with dt1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def1 &lt;- defData(varname = "x", formula = 0, variance = 1)
def1 &lt;- defData(varname = "xcat", formula = ".3;.2", dist = "categorical")

def2 &lt;- defData(varname = "yBin", formula = 0.5, dist = "binary", id = "xcat")
def2 &lt;- defData(def2, varname = "yNorm", formula = 5, variance = 2)

dt1 &lt;- genData(20, def1)
dt2 &lt;- genData(3, def2)

dtMerge &lt;- mergeData(dt1, dt2, "xcat")
dtMerge
</code></pre>

<hr>
<h2 id='negbinomGetSizeProb'>Convert negative binomial mean and dispersion parameters to size and prob parameters</h2><span id='topic+negbinomGetSizeProb'></span>

<h3>Description</h3>

<p>Convert negative binomial mean and dispersion parameters to size and prob parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negbinomGetSizeProb(mean, dispersion)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negbinomGetSizeProb_+3A_mean">mean</code></td>
<td>
<p>The mean of a gamma distribution</p>
</td></tr>
<tr><td><code id="negbinomGetSizeProb_+3A_dispersion">dispersion</code></td>
<td>
<p>The dispersion parameter of a gamma distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In simstudy, users specify the negative binomial distribution as a
function of two parameters - a mean and dispersion. In this case, the
variance of the specified distribution is mean + (mean^2)*dispersion. The
base R function rnbinom uses the size and prob parameters to specify the
negative binomial distribution. This function converts the mean and
dispersion into the size and probability parameters.
</p>


<h3>Value</h3>

<p>A list that includes the size and prob parameters of the neg binom
distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
mean &lt;- 5
dispersion &lt;- 0.5
sp &lt;- negbinomGetSizeProb(mean, dispersion)
c(sp$size, sp$prob)
vec &lt;- rnbinom(1000, size = sp$size, prob = sp$prob)
(estMoments &lt;- c(mean(vec), var(vec)))
(theoryMoments &lt;- c(mean, mean + mean^2 * dispersion))
(theoryMoments &lt;- c(sp$size * (1 - sp$prob) / sp$prob, sp$size * (1 - sp$prob) / sp$prob^2))
</code></pre>

<hr>
<h2 id='simstudy-deprecated'>Deprecated functions in simstudy</h2><span id='topic+simstudy-deprecated'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older versions
of simstudy only, and will be defunct in the future.
</p>


<h3>Details</h3>


<ul>
<li> <p><a href="#topic+genCorOrdCat">genCorOrdCat</a>: This function is deprecated, and will
be removed in the future. Use <a href="#topic+genOrdCat">genOrdCat</a> with <code>asFactor = FALSE</code> instead.
</p>
</li>
<li> <p><a href="#topic+catProbs">catProbs</a>: This function is deprecated, and will be removed in the future.
Use <a href="#topic+genCatFormula">genCatFormula</a> with the same functionality instead.
</p>
</li></ul>


<hr>
<h2 id='survGetParams'>Get survival curve parameters</h2><span id='topic+survGetParams'></span>

<h3>Description</h3>

<p>Get survival curve parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survGetParams(points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survGetParams_+3A_points">points</code></td>
<td>
<p>A list of two-element vectors specifying the desired time and 
probability pairs that define the desired survival curve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of parameters that define the survival curve optimized for
the target points. The first element of the vector represents the &quot;f&quot;
parameter and the second element represents the &quot;shape&quot; parameter.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points &lt;- list(c(60, 0.90), c(100, .75), c(200, .25), c(250, .10))
survGetParams(points)
</code></pre>

<hr>
<h2 id='survParamPlot'>Plot survival curves</h2><span id='topic+survParamPlot'></span>

<h3>Description</h3>

<p>Plot survival curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survParamPlot(formula, shape, points = NULL, n = 100, scale = 1, limits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survParamPlot_+3A_formula">formula</code></td>
<td>
<p>This is the &quot;formula&quot; parameter of the Weibull-based survival curve
that can be used to define the scale of the distribution.</p>
</td></tr>
<tr><td><code id="survParamPlot_+3A_shape">shape</code></td>
<td>
<p>The parameter that defines the shape of the distribution.</p>
</td></tr>
<tr><td><code id="survParamPlot_+3A_points">points</code></td>
<td>
<p>An optional list of two-element vectors specifying the desired 
time and probability pairs that define the desired survival curve. If no list
is specified then the plot will not include any points.</p>
</td></tr>
<tr><td><code id="survParamPlot_+3A_n">n</code></td>
<td>
<p>The number of points along the curve that will be used to 
define the line. Defaults to 100.</p>
</td></tr>
<tr><td><code id="survParamPlot_+3A_scale">scale</code></td>
<td>
<p>An optional scale parameter that defaults to 1. If the value is 
1, the scale of the distribution is determined entirely by the argument &quot;f&quot;.</p>
</td></tr>
<tr><td><code id="survParamPlot_+3A_limits">limits</code></td>
<td>
<p>A vector of length 2 that specifies x-axis limits for the plot. 
The default is NULL, in which case no limits are imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot of the survival curve defined by the specified parameters.
If the argument points is specified, the plot will include them
</p>


<h3>Examples</h3>

<pre><code class='language-R'>points &lt;- list(c(60, 0.90), c(100, .75), c(200, .25), c(250, .10))
r &lt;- survGetParams(points)
survParamPlot(r[1], r[2])
survParamPlot(r[1], r[2], points = points)
survParamPlot(r[1], r[2], points = points, limits = c(0, 100))
</code></pre>

<hr>
<h2 id='trimData'>Trim longitudinal data file once an event has occurred</h2><span id='topic+trimData'></span>

<h3>Description</h3>

<p>Trim longitudinal data file once an event has occurred
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimData(dtOld, seqvar, eventvar, idvar = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimData_+3A_dtold">dtOld</code></td>
<td>
<p>name of data table to be trimmed</p>
</td></tr>
<tr><td><code id="trimData_+3A_seqvar">seqvar</code></td>
<td>
<p>string referencing column that indexes the sequence or period</p>
</td></tr>
<tr><td><code id="trimData_+3A_eventvar">eventvar</code></td>
<td>
<p>string referencing event data column</p>
</td></tr>
<tr><td><code id="trimData_+3A_idvar">idvar</code></td>
<td>
<p>string referencing id column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated data.table removes all rows following the first event for each
individual
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eDef &lt;- defDataAdd(varname = "e", formula = "u==4", dist = "nonrandom")

P &lt;- t(matrix(c(
  0.4, 0.3, 0.2, 0.1,
  0.0, 0.4, 0.3, 0.3,
  0.0, 0.0, 0.5, 0.5,
  0.0, 0.0, 0.0, 1.0
),
nrow = 4
))

dp &lt;- genMarkov(
  n = 100, transMat = P,
  chainLen = 8, id = "id",
  pername = "period",
  varname = "u"
)

dp &lt;- addColumns(eDef, dp)
dp &lt;- trimData(dp, seqvar = "period", eventvar = "e", idvar = "id")

dp
</code></pre>

<hr>
<h2 id='trtAssign'>Assign treatment</h2><span id='topic+trtAssign'></span>

<h3>Description</h3>

<p>Assign treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trtAssign(
  dtName,
  nTrt = 2,
  balanced = TRUE,
  strata = NULL,
  grpName = "trtGrp",
  ratio = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trtAssign_+3A_dtname">dtName</code></td>
<td>
<p>data table</p>
</td></tr>
<tr><td><code id="trtAssign_+3A_ntrt">nTrt</code></td>
<td>
<p>number of treatment groups</p>
</td></tr>
<tr><td><code id="trtAssign_+3A_balanced">balanced</code></td>
<td>
<p>indicator for treatment assignment process</p>
</td></tr>
<tr><td><code id="trtAssign_+3A_strata">strata</code></td>
<td>
<p>vector of strings representing stratifying variables</p>
</td></tr>
<tr><td><code id="trtAssign_+3A_grpname">grpName</code></td>
<td>
<p>string representing variable name for treatment or
exposure group</p>
</td></tr>
<tr><td><code id="trtAssign_+3A_ratio">ratio</code></td>
<td>
<p>vector of values indicating relative proportion of group
assignment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer (group) ranging from 1 to length of the
probability vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtObserve">trtObserve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt &lt;- genData(15)

dt1 &lt;- trtAssign(dt, nTrt = 3, balanced = TRUE)
dt1[, .N, keyby = trtGrp]

dt2 &lt;- trtAssign(dt, nTrt = 3, balanced = FALSE)
dt2[, .N, keyby = trtGrp]

def &lt;- defData(varname = "male", formula = .4, dist = "binary")
dt &lt;- genData(1000, def)
dt

dt3 &lt;- trtAssign(dt, nTrt = 5, strata = "male", balanced = TRUE, grpName = "Group")
dt3
dt3[, .N, keyby = .(male, Group)]
dt3[, .N, keyby = .(Group)]

dt4 &lt;- trtAssign(dt, nTrt = 5, strata = "male", balanced = FALSE, grpName = "Group")
dt4[, .N, keyby = .(male, Group)]
dt4[, .N, keyby = .(Group)]

dt5 &lt;- trtAssign(dt, nTrt = 5, balanced = TRUE, grpName = "Group")
dt5[, .N, keyby = .(male, Group)]
dt5[, .N, keyby = .(Group)]

dt6 &lt;- trtAssign(dt, nTrt = 3, ratio = c(1, 2, 2), grpName = "Group")
dt6[, .N, keyby = .(Group)]
</code></pre>

<hr>
<h2 id='trtObserve'>Observed exposure or treatment</h2><span id='topic+trtObserve'></span>

<h3>Description</h3>

<p>Observed exposure or treatment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trtObserve(dt, formulas, logit.link = FALSE, grpName = "trtGrp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trtObserve_+3A_dt">dt</code></td>
<td>
<p>data table</p>
</td></tr>
<tr><td><code id="trtObserve_+3A_formulas">formulas</code></td>
<td>
<p>collection of formulas that determine probabilities</p>
</td></tr>
<tr><td><code id="trtObserve_+3A_logit.link">logit.link</code></td>
<td>
<p>indicator that specifies link. If TRUE, then logit link
is used. If FALSE, the identity link is used.</p>
</td></tr>
<tr><td><code id="trtObserve_+3A_grpname">grpName</code></td>
<td>
<p>character string representing name of treatment/exposure group
variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer (group) ranging from 1 to length of the probability vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtAssign">trtAssign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>def &lt;- defData(varname = "male", dist = "binary", formula = .5, id = "cid")
def &lt;- defData(def, varname = "over65", dist = "binary", formula = "-1.7 + .8*male", link = "logit")
def &lt;- defData(def, varname = "baseDBP", dist = "normal", formula = 70, variance = 40)

dtstudy &lt;- genData(1000, def)
dtstudy

formula1 &lt;- c("-2 + 2*male - .5*over65", "-1 + 2*male + .5*over65")
dtObs &lt;- trtObserve(dtstudy, formulas = formula1, logit.link = TRUE, grpName = "exposure")
dtObs

# Check actual distributions

dtObs[, .(pctMale = round(mean(male), 2)), keyby = exposure]
dtObs[, .(pctMale = round(mean(over65), 2)), keyby = exposure]

dtSum &lt;- dtObs[, .N, keyby = .(male, over65, exposure)]
dtSum[, grpPct := round(N / sum(N), 2), keyby = .(male, over65)]
dtSum
</code></pre>

<hr>
<h2 id='trtStepWedge'>Assign treatment for stepped-wedge design</h2><span id='topic+trtStepWedge'></span>

<h3>Description</h3>

<p>Assign treatment for stepped-wedge design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trtStepWedge(
  dtName,
  clustID,
  nWaves,
  lenWaves,
  startPer,
  perName = "period",
  grpName = "rx",
  lag = 0,
  xrName = "xr"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trtStepWedge_+3A_dtname">dtName</code></td>
<td>
<p>data table</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_clustid">clustID</code></td>
<td>
<p>string representing name of column of cluster level ids</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_nwaves">nWaves</code></td>
<td>
<p>number of treatment waves</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_lenwaves">lenWaves</code></td>
<td>
<p>the number of periods between waves</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_startper">startPer</code></td>
<td>
<p>the starting period of the first wave</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_pername">perName</code></td>
<td>
<p>string representing name of column of time periods</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_grpname">grpName</code></td>
<td>
<p>string representing variable name for treatment or
exposure group</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_lag">lag</code></td>
<td>
<p>integer representing length of transition period</p>
</td></tr>
<tr><td><code id="trtStepWedge_+3A_xrname">xrName</code></td>
<td>
<p>string representing name of the field that
indicates whether the cluster status is in transition status</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the added treatment assignment
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trtObserve">trtObserve</a> <a href="#topic+trtAssign">trtAssign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>defc &lt;- defData(
  varname = "ceffect", formula = 0, variance = 0.10,
  dist = "normal", id = "cluster"
)
defc &lt;- defData(defc, "m", formula = 10, dist = "nonrandom")

# Will generate 3 waves of 4 clusters each - starting 2, 5, and 8

dc &lt;- genData(12, defc)
dp &lt;- addPeriods(dc, 12, "cluster")
dp &lt;- trtStepWedge(dp, "cluster",
  nWaves = 3,
  lenWaves = 3, startPer = 2
)
dp

dp &lt;- addPeriods(dc, 12, "cluster")
dp &lt;- trtStepWedge(dp, "cluster",
  nWaves = 2,
  lenWaves = 1, startPer = 4, lag = 3
)
dp
</code></pre>

<hr>
<h2 id='updateDef'>Update definition table</h2><span id='topic+updateDef'></span>

<h3>Description</h3>

<p>Updates row definition table created by function
defData or defRead. (For tables created using defDataAdd
and defReadAdd use updateDefAdd.) Does not modify in-place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateDef(
  dtDefs,
  changevar,
  newformula = NULL,
  newvariance = NULL,
  newdist = NULL,
  newlink = NULL,
  remove = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateDef_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Definition table that will be modified</p>
</td></tr>
<tr><td><code id="updateDef_+3A_changevar">changevar</code></td>
<td>
<p>Name of field definition that will be changed</p>
</td></tr>
<tr><td><code id="updateDef_+3A_newformula">newformula</code></td>
<td>
<p>New formula definition (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDef_+3A_newvariance">newvariance</code></td>
<td>
<p>New variance specification (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDef_+3A_newdist">newdist</code></td>
<td>
<p>New distribution definition (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDef_+3A_newlink">newlink</code></td>
<td>
<p>New link specification (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDef_+3A_remove">remove</code></td>
<td>
<p>If set to TRUE, remove 'changevar'from
definition (defaults to FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated data definition table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1

defs &lt;- defData(varname = "x", formula = 0, variance = 3, dist = "normal")
defs &lt;- defData(defs, varname = "y", formula = "2 + 3*x", variance = 1, dist = "normal")
defs &lt;- defData(defs, varname = "z", formula = "4 + 3*x - 2*y", variance = 1, dist = "normal")

defs

updateDef(dtDefs = defs, changevar = "y", newformula = "x + 5", newvariance = 2)
updateDef(dtDefs = defs, changevar = "z", newdist = "poisson", newlink = "log")

# Example 2

defs &lt;- defData(varname = "w", formula = 0, variance = 3, dist = "normal")
defs &lt;- defData(defs, varname = "x", formula = "1 + w", variance = 1, dist = "normal")
defs &lt;- defData(defs, varname = "z", formula = 4, variance = 1, dist = "normal")

defs

updateDef(dtDefs = defs, changevar = "x", remove = TRUE)
updateDef(dtDefs = defs, changevar = "z", remove = TRUE)

# No changes to original definition:
defs
</code></pre>

<hr>
<h2 id='updateDefAdd'>Update definition table</h2><span id='topic+updateDefAdd'></span>

<h3>Description</h3>

<p>Updates row definition table created by functions
defDataAdd and defReadAdd. (For tables created using defData
or defRead use updateDef.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateDefAdd(
  dtDefs,
  changevar,
  newformula = NULL,
  newvariance = NULL,
  newdist = NULL,
  newlink = NULL,
  remove = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateDefAdd_+3A_dtdefs">dtDefs</code></td>
<td>
<p>Definition table that will be modified</p>
</td></tr>
<tr><td><code id="updateDefAdd_+3A_changevar">changevar</code></td>
<td>
<p>Name of field definition that will be changed</p>
</td></tr>
<tr><td><code id="updateDefAdd_+3A_newformula">newformula</code></td>
<td>
<p>New formula definition (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDefAdd_+3A_newvariance">newvariance</code></td>
<td>
<p>New variance specification (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDefAdd_+3A_newdist">newdist</code></td>
<td>
<p>New distribution definition (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDefAdd_+3A_newlink">newlink</code></td>
<td>
<p>New link specification (defaults to NULL)</p>
</td></tr>
<tr><td><code id="updateDefAdd_+3A_remove">remove</code></td>
<td>
<p>If set to TRUE, remove definition (defaults to FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string that represents the desired formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define original data

defs &lt;- defData(varname = "w", formula = 0, variance = 3, dist = "normal")
defs &lt;- defData(defs, varname = "x", formula = "1 + w", variance = 1, dist = "normal")
defs &lt;- defData(defs, varname = "z", formula = 4, variance = 1, dist = "normal")

# Define additional columns

defsA &lt;- defDataAdd(varname = "a", formula = "w + x + z", variance = 2, dist = "normal")

set.seed(2001)
dt &lt;- genData(10, defs)
dt &lt;- addColumns(defsA, dt)
dt

# Modify definition of additional column

defsA &lt;- updateDefAdd(dtDefs = defsA, changevar = "a", newformula = "w+z", newvariance = 1)

set.seed(2001)
dt &lt;- genData(10, defs)
dt &lt;- addColumns(defsA, dt)
dt
</code></pre>

<hr>
<h2 id='viewBasis'>Plot basis spline functions</h2><span id='topic+viewBasis'></span>

<h3>Description</h3>

<p>Plot basis spline functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewBasis(knots, degree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewBasis_+3A_knots">knots</code></td>
<td>
<p>A vector of values between 0 and 1, specifying cut-points for splines</p>
</td></tr>
<tr><td><code id="viewBasis_+3A_degree">degree</code></td>
<td>
<p>Integer specifying degree of curvature.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that contains a plot of the basis functions. In total, there
will be length(knots) + degree + 1 functions plotted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knots &lt;- c(0.25, 0.50, 0.75)
viewBasis(knots, degree = 1)

knots &lt;- c(0.25, 0.50, 0.75)
viewBasis(knots, degree = 2)

knots &lt;- c(0.25, 0.50, 0.75)
viewBasis(knots, degree = 3)
</code></pre>

<hr>
<h2 id='viewSplines'>Plot spline curves</h2><span id='topic+viewSplines'></span>

<h3>Description</h3>

<p>Plot spline curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewSplines(knots, degree, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewSplines_+3A_knots">knots</code></td>
<td>
<p>A vector of values between 0 and 1, specifying cut-points for splines</p>
</td></tr>
<tr><td><code id="viewSplines_+3A_degree">degree</code></td>
<td>
<p>Integer specifying degree of curvature.</p>
</td></tr>
<tr><td><code id="viewSplines_+3A_theta">theta</code></td>
<td>
<p>A vector or matrix of values between 0 and 1. Each column of the matrix
represents the weights/coefficients that will be applied to the basis functions
determined by the knots and degree. Each column of theta represents a separate
spline curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object that contains a plot of the spline curves. The number of
spline curves in the plot will equal the number of columns in the matrix (or it
will equal 1 if theta is a vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knots &lt;- c(0.25, 0.5, 0.75)
theta1 &lt;- c(0.1, 0.8, 0.4, 0.9, 0.2, 1.0)

viewSplines(knots, degree = 2, theta1)

theta2 &lt;- matrix(c(
  0.1, 0.2, 0.4, 0.9, 0.2, 0.3,
  0.1, 0.3, 0.3, 0.8, 1.0, 0.9,
  0.1, 0.4, 0.3, 0.8, 0.7, 0.5,
  0.1, 0.9, 0.8, 0.2, 0.1, 0.6
),
ncol = 4
)

viewSplines(knots, degree = 2, theta2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
