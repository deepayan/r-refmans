<!DOCTYPE html><html><head><title>Help for package multiview</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multiview}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multiview-package'><p>Cooperative learning for multiple views using generalized linear models</p></a></li>
<li><a href='#coef_ordered'><p>Extract an ordered list of standardized coefficients from a <code>multiview</code> or <code>cv.multiview</code> object</p></a></li>
<li><a href='#coef_ordered.cv.multiview'><p>Extract an ordered list of standardized coefficients from a cv.multiview object</p></a></li>
<li><a href='#coef_ordered.multiview'><p>Extract an ordered list of standardized coefficients from a multiview object</p></a></li>
<li><a href='#coef.cv.multiview'><p>Extract coefficients from a cv.multiview object</p></a></li>
<li><a href='#coef.multiview'><p>Extract coefficients from a multiview object</p></a></li>
<li><a href='#collapse_named_lists'><p>Collapse a list of named lists into one list with the same name</p></a></li>
<li><a href='#cox_obj_function'><p>Elastic net objective function value for Cox regression model</p></a></li>
<li><a href='#cv.multiview'><p>Perform k-fold cross-validation for cooperative learning</p></a></li>
<li><a href='#dev_function'><p>Elastic net deviance value</p></a></li>
<li><a href='#elnet.fit'><p>Solve weighted least squares (WLS) problem for a single lambda value</p></a></li>
<li><a href='#get_cox_lambda_max'><p>Get lambda max for Cox regression model</p></a></li>
<li><a href='#get_eta'><p>Helper function to get etas (linear predictions)</p></a></li>
<li><a href='#get_start'><p>Get null deviance, starting mu and lambda max</p></a></li>
<li><a href='#make_row'><p>Build a block row matrix for multiview</p></a></li>
<li><a href='#multiview'><p>Perform cooperative learning using the direct algorithm for</p>
two or more views.</a></li>
<li><a href='#multiview.control'><p>Internal multiview parameters</p></a></li>
<li><a href='#multiview.cox.fit'><p>Fit a Cox regression model with elastic net regularization for a single</p>
value of lambda</a></li>
<li><a href='#multiview.cox.path'><p>Fit a Cox regression model with elastic net regularization for a path of</p>
lambda values</a></li>
<li><a href='#multiview.fit'><p>Fit a GLM with elastic net regularization for a single value of</p>
lambda</a></li>
<li><a href='#multiview.path'><p>Fit a GLM with elastic net regularization for a path of lambda values</p></a></li>
<li><a href='#obj_function'><p>Elastic net objective function value</p></a></li>
<li><a href='#pen_function'><p>Elastic net penalty value</p></a></li>
<li><a href='#plot.multiview'><p>Plot coefficients from a &quot;multiview&quot; object</p></a></li>
<li><a href='#predict.cv.multiview'><p>Make predictions from a &quot;cv.multiview&quot; object.</p></a></li>
<li><a href='#predict.multiview'><p>Get predictions from a <code>multiview</code> fit object</p></a></li>
<li><a href='#reshape_x_to_xlist'><p>Return a new list of x matrices of same shapes as those in x_list</p></a></li>
<li><a href='#response.coxnet'><p>Make response for coxnet</p></a></li>
<li><a href='#select_matrix_list_columns'><p>Select x_list columns specified by (conformable) list of indices</p></a></li>
<li><a href='#to_nvar_index'><p>Translate from column indices in list of x matrices to indices in</p>
<code>1:nvars</code>. No sanity checks for efficiency</a></li>
<li><a href='#to_xlist_index'><p>Translate indices in <code>1:nvars</code> to column indices in list of x</p>
matrices. No sanity checks</a></li>
<li><a href='#view.contribution'><p>Evaluate the contribution of data views in making prediction</p></a></li>
<li><a href='#weighted_mean_sd'><p>Helper function to compute weighted mean and standard deviation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cooperative Learning for Multi-View Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-30</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Cooperative learning combines the usual squared error loss of predictions with an agreement penalty to encourage the predictions from different data views to agree. By varying the weight of the agreement penalty, we get a continuum of solutions that include the well-known early and late fusion approaches. Cooperative learning chooses the degree of agreement (or fusion) in an adaptive manner, using a validation set or cross-validation to estimate test set prediction error. In the setting of cooperative regularized linear regression, the method combines the lasso penalty with the agreement penalty (Ding, D., Li, S., Narasimhan, B., Tibshirani, R. (2021) &lt;<a href="https://doi.org/10.1073%2Fpnas.2202113119">doi:10.1073/pnas.2202113119</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0), xfun</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, Matrix, methods, RColorBrewer, Rcpp, stats, survival,
utils</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-31 19:06:09 UTC; naras</td>
</tr>
<tr>
<td>Author:</td>
<td>Daisy Yi Ding [aut],
  Robert J. Tibshirani [aut],
  Balasubramanian Narasimhan [aut, cre],
  Trevor Hastie [aut],
  Kenneth Tay [aut],
  James Yang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Balasubramanian Narasimhan &lt;naras@stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-31 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='multiview-package'>Cooperative learning for multiple views using generalized linear models</h2><span id='topic+multiview-package'></span>

<h3>Description</h3>

<p>This package performs a version of early and late fusion of multiple views using penalized generalized regression.
</p>

<hr>
<h2 id='coef_ordered'>Extract an ordered list of standardized coefficients from a <code>multiview</code> or <code>cv.multiview</code> object</h2><span id='topic+coef_ordered'></span>

<h3>Description</h3>

<p>This function extracts a ranked list of coefficients after the coefficients are
standardized by the standard deviation of the corresponding features. The ranking
is based on the magnitude of the standardized coefficients. It also outputs
the data view to which each coefficient belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_ordered(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_ordered_+3A_object">object</code></td>
<td>
<p>Fitted <code>"multiview"</code> or <code>"cv.multiview"</code> object.
coefficients are required.</p>
</td></tr>
<tr><td><code id="coef_ordered_+3A_...">...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code style="white-space: pre;">&#8288;x=&#8288;</code> when
<code>exact=TRUE</code>; see <code>exact</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output table shows from left to right the data view each coefficient comes from,
the column index of the feature in the corresponding data view, the coefficient
after being standardized by the standard deviation of the corresponding feature,
and the original fitted coefficient.
</p>


<h3>Value</h3>

<p>data frame of consisting of view name, view column,
coefficient and standardized coefficient ordered by rank of
standardized coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
z = matrix(rnorm(100 * 10), 100, 10)
y = rnorm(100)
fit1 = multiview(list(x=x,z=z), y, rho = 0)
coef_ordered(fit1, s=0.1)

# Binomial
by = sample(c(0,1), 100, replace = TRUE)
fit2 = multiview(list(x=x,z=z), by, family = binomial(), rho=0.5)
coef_ordered(fit2, s=0.1)

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = multiview(list(x=x,z=z), py, family = poisson(), rho=0.5)
coef_ordered(fit3, s=0.1)
</code></pre>

<hr>
<h2 id='coef_ordered.cv.multiview'>Extract an ordered list of standardized coefficients from a cv.multiview object</h2><span id='topic+coef_ordered.cv.multiview'></span>

<h3>Description</h3>

<p>This function extracts a ranked list of coefficients after the coefficients are
standardized by the standard deviation of the corresponding features. The ranking
is based on the magnitude of the standardized coefficients. It also outputs
the data view to which each coefficient belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.multiview'
coef_ordered(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_ordered.cv.multiview_+3A_object">object</code></td>
<td>
<p>Fitted <code>"cv.multiview"</code> object.</p>
</td></tr>
<tr><td><code id="coef_ordered.cv.multiview_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code> stored
on the CV <code>object</code>. Alternatively <code>s="lambda.min"</code> can be used. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used. (For historical reasons we use the symbol 's' rather than 'lambda' to
reference this parameter.)</p>
</td></tr>
<tr><td><code id="coef_ordered.cv.multiview_+3A_...">...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code style="white-space: pre;">&#8288;x=&#8288;</code> when
<code>exact=TRUE</code>; see <code>exact</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output table shows from left to right the data view each coefficient comes from,
the column index of the feature in the corresponding data view, the coefficient
after being standardized by the standard deviation of the corresponding feature,
and the original fitted coefficient.
</p>


<h3>Value</h3>

<p>data frame of consisting of view name, view column,
coefficient and standardized coefficient ordered by rank of
standardized coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100*20), 100, 20)
z = matrix(rnorm(100*20), 100, 20)
U = matrix(rnorm(100*5), 100, 5)
for (m in seq(5)){
    u = rnorm(100)
    x[, m] = x[, m] + u
    z[, m] = z[, m] + u
    U[, m] = U[, m] + u}
x = scale(x, center = TRUE, scale = FALSE)
z = scale(z, center = TRUE, scale = FALSE)
beta_U = c(rep(0.1, 5))
y = U %*% beta_U + 0.1 * rnorm(100)
fit1 = cv.multiview(list(x=x,z=z), y, rho = 0.3)
coef_ordered(fit1, s="lambda.min")

# Binomial

by = 1 * (y &gt; median(y)) 
fit2 = cv.multiview(list(x=x,z=z), by, family = binomial(), rho = 0.9)
coef_ordered(fit2, s="lambda.min")

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = cv.multiview(list(x=x,z=z), py, family = poisson(), rho = 0.6)
coef_ordered(fit3, s="lambda.min")

</code></pre>

<hr>
<h2 id='coef_ordered.multiview'>Extract an ordered list of standardized coefficients from a multiview object</h2><span id='topic+coef_ordered.multiview'></span>

<h3>Description</h3>

<p>This function extracts a ranked list of coefficients after the coefficients are
standardized by the standard deviation of the corresponding features. The ranking
is based on the magnitude of the standardized coefficients. It also outputs
the data view to which each coefficient belongs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiview'
coef_ordered(object, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_ordered.multiview_+3A_object">object</code></td>
<td>
<p>Fitted <code>"multiview"</code> object.</p>
</td></tr>
<tr><td><code id="coef_ordered.multiview_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
coefficients are required.</p>
</td></tr>
<tr><td><code id="coef_ordered.multiview_+3A_...">...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code style="white-space: pre;">&#8288;x=&#8288;</code> when
<code>exact=TRUE</code>; see <code>exact</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output table shows from left to right the data view each coefficient comes from,
the column index of the feature in the corresponding data view, the coefficient
after being standardized by the standard deviation of the corresponding feature,
and the original fitted coefficient.
</p>


<h3>Value</h3>

<p>data frame of consisting of view name, view column,
coefficient and standardized coefficient ordered by rank of
standardized coefficient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
z = matrix(rnorm(100 * 10), 100, 10)
y = rnorm(100)
fit1 = multiview(list(x=x,z=z), y, rho = 0)
coef_ordered(fit1, s=0.1)

# Binomial
by = sample(c(0,1), 100, replace = TRUE)
fit2 = multiview(list(x=x,z=z), by, family = binomial(), rho=0.5)
coef_ordered(fit2, s=0.1)

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = multiview(list(x=x,z=z), py, family = poisson(), rho=0.5)
coef_ordered(fit3, s=0.1)

</code></pre>

<hr>
<h2 id='coef.cv.multiview'>Extract coefficients from a cv.multiview object</h2><span id='topic+coef.cv.multiview'></span>

<h3>Description</h3>

<p>Extract coefficients from a cv.multiview object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.multiview'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cv.multiview_+3A_object">object</code></td>
<td>
<p>Fitted <code>"cv.multiview"</code> object.</p>
</td></tr>
<tr><td><code id="coef.cv.multiview_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code>
stored on the CV <code>object</code>. Alternatively <code>s="lambda.min"</code> can be
used. If <code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code>
to be used. (For historical reasons we use the symbol 's' rather
than 'lambda' to reference this parameter.)</p>
</td></tr>
<tr><td><code id="coef.cv.multiview_+3A_...">...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code style="white-space: pre;">&#8288;x=&#8288;</code> when
<code>exact=TRUE</code>; see <code>exact</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix of coefficients for specified lambda.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = matrix(rnorm(100*20), 100, 20)
z = matrix(rnorm(100*20), 100, 20)
U = matrix(rnorm(100*5), 100, 5)
for (m in seq(5)){
    u = rnorm(100)
    x[, m] = x[, m] + u
    z[, m] = z[, m] + u
    U[, m] = U[, m] + u}
x = scale(x, center = TRUE, scale = FALSE)
z = scale(z, center = TRUE, scale = FALSE)
beta_U = c(rep(0.1, 5))
y = U %*% beta_U + 0.1 * rnorm(100)
fit1 = cv.multiview(list(x=x,z=z), y, rho = 0.3)
coef(fit1, s="lambda.min")

# Binomial

by = 1 * (y &gt; median(y)) 
fit2 = cv.multiview(list(x=x,z=z), by, family = binomial(), rho = 0.9)
coef(fit2, s="lambda.min")

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = cv.multiview(list(x=x,z=z), py, family = poisson(), rho = 0.6)
coef(fit3, s="lambda.min")

</code></pre>

<hr>
<h2 id='coef.multiview'>Extract coefficients from a multiview object</h2><span id='topic+coef.multiview'></span>

<h3>Description</h3>

<p>Extract coefficients from a multiview object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiview'
coef(object, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.multiview_+3A_object">object</code></td>
<td>
<p>Fitted &quot;multiview&quot; object.</p>
</td></tr>
<tr><td><code id="coef.multiview_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter lambda at which predictions are
required. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="coef.multiview_+3A_...">...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code style="white-space: pre;">&#8288;x=&#8288;</code> when
<code>exact=TRUE</code>; see <code>exact</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of coefficients for specified lambda.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
z = matrix(rnorm(100 * 10), 100, 10)
y = rnorm(100)
fit1 = multiview(list(x=x,z=z), y, rho = 0)
coef(fit1, s=0.1)

# Binomial
by = sample(c(0,1), 100, replace = TRUE)
fit2 = multiview(list(x=x,z=z), by, family = binomial(), rho=0.5)
coef(fit2, s=0.1)

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = multiview(list(x=x,z=z), py, family = poisson(), rho=0.5)
coef(fit3, s=0.1)

</code></pre>

<hr>
<h2 id='collapse_named_lists'>Collapse a list of named lists into one list with the same name</h2><span id='topic+collapse_named_lists'></span>

<h3>Description</h3>

<p>Collapse a list of named lists into one list with the same name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_named_lists(in_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_named_lists_+3A_in_list">in_list</code></td>
<td>
<p>a list of named lists all with same names (not checked for efficiency)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single list with named components all concatenated
</p>

<hr>
<h2 id='cox_obj_function'>Elastic net objective function value for Cox regression model</h2><span id='topic+cox_obj_function'></span>

<h3>Description</h3>

<p>Returns the elastic net objective function value for Cox regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox_obj_function(
  y,
  pred,
  weights,
  lambda,
  alpha,
  coefficients,
  vp,
  view_components,
  rho
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox_obj_function_+3A_y">y</code></td>
<td>
<p>Survival response variable, must be a <code>Surv</code> or
<code>stratifySurv</code> object.</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_pred">pred</code></td>
<td>
<p>Model's predictions for <code>y</code>.</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_lambda">lambda</code></td>
<td>
<p>A single value for the <code>lambda</code> hyperparameter.</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \le \alpha \le 1</code>.</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_coefficients">coefficients</code></td>
<td>
<p>The model's coefficients.</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_vp">vp</code></td>
<td>
<p>Penalty factors for each of the coefficients.</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_view_components">view_components</code></td>
<td>
<p>a list of lists containing indices of coefficients and associated covariate (view) pairs</p>
</td></tr>
<tr><td><code id="cox_obj_function_+3A_rho">rho</code></td>
<td>
<p>the fusion parameter</p>
</td></tr>
</table>

<hr>
<h2 id='cv.multiview'>Perform k-fold cross-validation for cooperative learning</h2><span id='topic+cv.multiview'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation (CV) for multiview and produces a CV curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.multiview(
  x_list,
  y,
  family = gaussian(),
  rho = 0,
  weights = NULL,
  offset = NULL,
  lambda = NULL,
  type.measure = c("default", "mse", "deviance", "class", "auc", "mae", "C"),
  nfolds = 10,
  foldid = NULL,
  alignment = c("lambda", "fraction"),
  grouped = TRUE,
  keep = FALSE,
  trace.it = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.multiview_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_y">y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is <a href="stats.html#topic+family">stats::gaussian</a>. (See
<a href="stats.html#topic+family">stats::family</a> for details on family functions.)</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_rho">rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_offset">offset</code></td>
<td>
<p>Offset vector (matrix) as in <code>multiview</code></p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> call (named <code>lambda</code>). Note
that this is done for the full model (master sequence), and
separately for each fold.  The fits are then aligned using the
glmnet lambda sequence associated with the master sequence (see
the <code>alignment</code> argument for additional details). Adapting
<code>lambda</code> for each fold leads to better convergence. When
<code>lambda</code> is supplied, the same sequence is used everywhere, but
in some GLMs can lead to convergence issues.</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_type.measure">type.measure</code></td>
<td>
<p>loss to use for cross-validation. Currently
five options, not all available for all models. The default is
<code>type.measure="deviance"</code>, which uses squared-error for gaussian
models (a.k.a <code>type.measure="mse"</code> there), deviance for logistic
and poisson regression, and partial-likelihood for the Cox model.
<code>type.measure="class"</code> applies to binomial and multinomial
logistic regression only, and gives misclassification error.
<code>type.measure="auc"</code> is for two-class logistic regression only,
and gives area under the ROC curve. <code>type.measure="mse"</code> or
<code>type.measure="mae"</code> (mean absolute error) can be used by all
models except the <code>"cox"</code>; they measure the deviation from the
fitted mean to the response.  <code>type.measure="C"</code> is Harrel's
concordance measure, only available for <code>cox</code> models.</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds - default is 10. Although <code>nfolds</code>
can be as large as the sample size (leave-one-out CV), it is not
recommended for large datasets. Smallest value allowable is
<code>nfolds=3</code></p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing.</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_alignment">alignment</code></td>
<td>
<p>This is an experimental argument, designed to fix
the problems users were having with CV, with possible values
<code>"lambda"</code> (the default) else <code>"fraction"</code>. With <code>"lambda"</code> the
<code>lambda</code> values from the master fit (on all the data) are used to
line up the predictions from each of the folds. In some cases
this can give strange values, since the effective <code>lambda</code> values
in each fold could be quite different. With <code>"fraction"</code> we line
up the predictions in each fold according to the fraction of
progress along the regularization. If in the call a <code>lambda</code>
argument is also provided, <code>alignment="fraction"</code> is ignored
(with a warning).</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_grouped">grouped</code></td>
<td>
<p>This is an experimental argument, with default
<code>TRUE</code>, and can be ignored by most users. For all models except
the <code>"cox"</code>, this refers to computing <code>nfolds</code> separate
statistics, and then using their mean and estimated standard
error to describe the CV curve. If <code>grouped=FALSE</code>, an error
matrix is built up at the observation level from the predictions
from the <code>nfold</code> fits, and then summarized (does not apply to
<code>type.measure="auc"</code>). For the <code>"cox"</code> family, <code>grouped=TRUE</code>
obtains the CV partial likelihood for the Kth fold by
<em>subtraction</em>; by subtracting the log partial likelihood
evaluated on the full dataset from that evaluated on the on the
(K-1)/K dataset. This makes more efficient use of risk sets. With
<code>grouped=FALSE</code> the log partial likelihood is computed only on
the Kth fold</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_keep">keep</code></td>
<td>
<p>If <code>keep=TRUE</code>, a <em>prevalidated</em> array is returned
containing fitted values for each observation and each value of
<code>lambda</code>. This means these fits are computed with this
observation and the rest of its fold omitted. The <code>foldid</code> vector
is also returned.  Default is keep=FALSE.</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_trace.it">trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then progress bars are displayed;
useful for big models that take a long time to fit.</p>
</td></tr>
<tr><td><code id="cv.multiview_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>multiview</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current code can be slow for &quot;large&quot; data sets, e.g. when the
number of features is larger than 1000.  It can be helpful to see
the progress of multiview as it runs; to do this, set trace.it = 1
in the call to multiview or cv.multiview.  With this, multiview
prints out its progress along the way.  One can also pre-filter the
features to a smaller set, using the exclude option, with a filter
function.
</p>
<p>If there are missing values in the feature matrices:
we recommend that you center the columns of each feature matrix, and then fill in the missing values with 0.
</p>
<p>For example, <br />
<code>x &lt;- scale(x,TRUE,FALSE)</code> <br />
<code>x[is.na(x)] &lt;- 0</code> <br />
<code>z &lt;- scale(z,TRUE,FALSE)</code> <br />
<code>z[is.na(z)] &lt;- 0</code> <br />
</p>
<p>Then run multiview in the usual way. It will exploit the assumed shared latent factors
to make efficient use of the available data.
</p>
<p>The function runs <code>multiview</code> <code>nfolds+1</code> times; the first to get the
<code>lambda</code> sequence, and then the remainder to compute the fit with each
of the folds omitted. The error is accumulated, and the average error and
standard deviation over the folds is computed.  Note that <code>cv.multiview</code>
does NOT search for values for <code>rho</code>. A specific value should be
supplied, else <code>rho=0</code> is assumed by default. If users would like to
cross-validate <code>rho</code> as well, they should call <code>cv.multiview</code> with
a pre-computed vector <code>foldid</code>, and then use this same fold vector in
separate calls to <code>cv.multiview</code> with different values of <code>rho</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.multiview"</code> is returned, which is a
list with the ingredients of the cross-validation
fit. </p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the values of <code>lambda</code> used in the fits.</p>
</td></tr>
<tr><td><code>cvm</code></td>
<td>
<p>The mean cross-validated error - a vector of length
<code>length(lambda)</code>.</p>
</td></tr> <tr><td><code>cvsd</code></td>
<td>
<p>estimate of standard error of
<code>cvm</code>.</p>
</td></tr> <tr><td><code>cvup</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr> <tr><td><code>cvlo</code></td>
<td>
<p>lower
curve = <code>cvm-cvsd</code>.</p>
</td></tr> <tr><td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients
at each <code>lambda</code>.</p>
</td></tr> <tr><td><code>name</code></td>
<td>
<p>a text string indicating type of
measure (for plotting purposes).</p>
</td></tr> <tr><td><code>multiview.fit</code></td>
<td>
<p>a fitted
multiview object for the full data.</p>
</td></tr> <tr><td><code>lambda.min</code></td>
<td>
<p>value of
<code>lambda</code> that gives minimum <code>cvm</code>.</p>
</td></tr> <tr><td><code>lambda.1se</code></td>
<td>
<p>largest
value of <code>lambda</code> such that error is within 1 standard error of
the minimum.</p>
</td></tr> <tr><td><code>fit.preval</code></td>
<td>
<p>if <code>keep=TRUE</code>, this is the array
of prevalidated fits. Some entries can be <code>NA</code>, if that and
subsequent values of <code>lambda</code> are not reached for that fold</p>
</td></tr>
<tr><td><code>foldid</code></td>
<td>
<p>if <code>keep=TRUE</code>, the fold assignments used</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>a one column matrix with the indices of <code>lambda.min</code>
and <code>lambda.1se</code> in the sequence of coefficients, fits etc.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
# Generate data based on a factor model
set.seed(1)
x = matrix(rnorm(100*20), 100, 20)
z = matrix(rnorm(100*20), 100, 20)
U = matrix(rnorm(100*5), 100, 5)
for (m in seq(5)){
    u = rnorm(100)
    x[, m] = x[, m] + u
    z[, m] = z[, m] + u
    U[, m] = U[, m] + u}
x = scale(x, center = TRUE, scale = FALSE)
z = scale(z, center = TRUE, scale = FALSE)
beta_U = c(rep(0.1, 5))
y = U %*% beta_U + 0.1 * rnorm(100)
fit1 = cv.multiview(list(x=x,z=z), y, rho = 0.3)

# plot the cross-validation curve
plot(fit1)

# extract coefficients
coef(fit1, s="lambda.min")

# extract ordered coefficients
coef_ordered(fit1, s="lambda.min")

# make predictions
predict(fit1, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min")

# Binomial

by = 1 * (y &gt; median(y)) 
fit2 = cv.multiview(list(x=x,z=z), by, family = binomial(), rho = 0.9)
predict(fit2, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response")
plot(fit2)
coef(fit2, s="lambda.min")
coef_ordered(fit2, s="lambda.min")

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = cv.multiview(list(x=x,z=z), py, family = poisson(), rho = 0.6)
predict(fit3, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response") 
plot(fit3)
coef(fit3, s="lambda.min")
coef_ordered(fit3, s="lambda.min")

</code></pre>

<hr>
<h2 id='dev_function'>Elastic net deviance value</h2><span id='topic+dev_function'></span>

<h3>Description</h3>

<p>Returns the elastic net deviance value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dev_function(y, mu, weights, family)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dev_function_+3A_y">y</code></td>
<td>
<p>Quantitative response variable.</p>
</td></tr>
<tr><td><code id="dev_function_+3A_mu">mu</code></td>
<td>
<p>Model's predictions for <code>y</code>.</p>
</td></tr>
<tr><td><code id="dev_function_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="dev_function_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link function to be
used in the model. This is the result of a call to a family function.</p>
</td></tr>
</table>

<hr>
<h2 id='elnet.fit'>Solve weighted least squares (WLS) problem for a single lambda value</h2><span id='topic+elnet.fit'></span>

<h3>Description</h3>

<p>Solves the weighted least squares (WLS) problem for a single lambda value. Internal
function that users should not call directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elnet.fit(
  x,
  y,
  weights,
  lambda,
  alpha = 1,
  intercept = TRUE,
  thresh = 1e-07,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = c(),
  lower.limits = -Inf,
  upper.limits = Inf,
  warm = NULL,
  from.glmnet.fit = FALSE,
  save.fit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elnet.fit_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension <code>nobs x nvars</code>; each row is an
observation vector. If it is a sparse matrix, it is assumed to be unstandardized.
It should have attributes <code>xm</code> and <code>xs</code>, where <code>xm(j)</code> and
<code>xs(j)</code> are the centering and scaling factors for variable j respsectively.
If it is not a sparse matrix, it is assumed that any standardization needed
has already been done.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_y">y</code></td>
<td>
<p>Quantitative response variable.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_weights">weights</code></td>
<td>
<p>Observation weights. <code>elnet.fit</code> does NOT standardize
these weights.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_lambda">lambda</code></td>
<td>
<p>A single value for the <code>lambda</code> hyperparameter.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \le \alpha \le 1</code>.
The penalty is defined as </p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge penalty.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept be fitted (default=TRUE) or set to zero (FALSE)?</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each inner
coordinate-descent loop continues until the maximum change in the objective
after any coefficient update is less than thresh times the null deviance.
Default value is <code>1e-7</code>.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data; default is <code>10^5</code>.
(If a warm start object is provided, the number of passes the warm start object
performed is included.)</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to each
coefficient. This is a number that multiplies <code>lambda</code> to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and that
variable is always included in the model. Default is 1 for all variables (and
implicitly infinity for variables listed in exclude). Note: the penalty
factors are internally rescaled to sum to <code>nvars</code>.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the model. Default is
none. Equivalent to an infinite penalty factor.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_lower.limits">lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient; default
<code>-Inf</code>. Each of these must be non-positive. Can be presented as a single
value (which will then be replicated), else a vector of length <code>nvars</code>.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_upper.limits">upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient; default
<code>Inf</code>. See <code>lower.limits</code>.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_warm">warm</code></td>
<td>
<p>Either a <code>glmnetfit</code> object or a list (with names <code>beta</code>
and <code>a0</code> containing coefficients and intercept respectively) which can
be used as a warm start. Default is <code>NULL</code>, indicating no warm start.
For internal use only.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_from.glmnet.fit">from.glmnet.fit</code></td>
<td>
<p>Was <code>elnet.fit()</code> called from <code>glmnet.fit()</code>?
Default is FALSE.This has implications for computation of the penalty factors.</p>
</td></tr>
<tr><td><code id="elnet.fit_+3A_save.fit">save.fit</code></td>
<td>
<p>Return the warm start object? Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: Users should not call <code>elnet.fit</code> directly. Higher-level functions
in this package call <code>elnet.fit</code> as a subroutine. If a warm start object
is provided, some of the other arguments in the function may be overriden.
</p>
<p><code>elnet.fit</code> is essentially a wrapper around a C++ subroutine which
minimizes
</p>
<p style="text-align: center;"><code class="reqn">1/2 \sum w_i (y_i - X_i^T \beta)^2 + \sum \lambda \gamma_j
[(1-\alpha)/2 \beta^2+\alpha|\beta|],</code>
</p>

<p>over <code class="reqn">\beta</code>, where <code class="reqn">\gamma_j</code> is the relative penalty factor on the
jth variable. If <code>intercept = TRUE</code>, then the term in the first sum is
<code class="reqn">w_i (y_i - \beta_0 - X_i^T \beta)^2</code>, and we are minimizing over both
<code class="reqn">\beta_0</code> and <code class="reqn">\beta</code>.
</p>
<p>None of the inputs are standardized except for <code>penalty.factor</code>, which
is standardized so that they sum up to <code>nvars</code>.
</p>


<h3>Value</h3>

<p>An object with class &quot;glmnetfit&quot; and &quot;glmnet&quot;. The list returned has
the same keys as that of a <code>glmnet</code> object, except that it might have an
additional <code>warm_fit</code> key.
</p>
<table>
<tr><td><code>a0</code></td>
<td>
<p>Intercept value.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x 1</code> matrix of coefficients, stored in sparse matrix
format.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Lambda value used.</p>
</td></tr>
<tr><td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the intercept model.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total passes over the data.</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>Always FALSE, since offsets do not appear in the WLS problem.
Included for compability with glmnet output.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>warm_fit</code></td>
<td>
<p>If <code>save.fit=TRUE</code>, output of C++ routine, used for
warm starts. For internal use only.</p>
</td></tr>
</table>

<hr>
<h2 id='get_cox_lambda_max'>Get lambda max for Cox regression model</h2><span id='topic+get_cox_lambda_max'></span>

<h3>Description</h3>

<p>Return the lambda max value for Cox regression model, used for computing
initial lambda values. For internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cox_lambda_max(
  x,
  y,
  alpha,
  weights = rep(1, nrow(x)),
  offset = rep(0, nrow(x)),
  exclude = c(),
  vp = rep(1, ncol(x))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cox_lambda_max_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension <code>nobs x nvars</code>; each row is an
observation vector. If it is a sparse matrix, it is assumed to be unstandardized.
It should have attributes <code>xm</code> and <code>xs</code>, where <code>xm(j)</code> and
<code>xs(j)</code> are the centering and scaling factors for variable j respsectively.
If it is not a sparse matrix, it is assumed to be standardized.</p>
</td></tr>
<tr><td><code id="get_cox_lambda_max_+3A_y">y</code></td>
<td>
<p>Survival response variable, must be a <code>Surv</code> or
<code>stratifySurv</code> object.</p>
</td></tr>
<tr><td><code id="get_cox_lambda_max_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \le \alpha \le 1</code>.</p>
</td></tr>
<tr><td><code id="get_cox_lambda_max_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="get_cox_lambda_max_+3A_offset">offset</code></td>
<td>
<p>Offset for the model. Default is a zero vector of length
<code>nrow(y)</code>.</p>
</td></tr>
<tr><td><code id="get_cox_lambda_max_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the model.</p>
</td></tr>
<tr><td><code id="get_cox_lambda_max_+3A_vp">vp</code></td>
<td>
<p>Separate penalty factors can be applied to each coefficient.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code>cox.path</code> for the value of lambda max.
</p>
<p>When <code>x</code> is not sparse, it is expected to already by centered and scaled.
When <code>x</code> is sparse, the function will get its attributes <code>xm</code> and
<code>xs</code> for its centering and scaling factors. The value of
<code>lambda_max</code> changes depending on whether <code>x</code> is centered and
scaled or not, so we need <code>xm</code> and <code>xs</code> to get the correct value.
</p>

<hr>
<h2 id='get_eta'>Helper function to get etas (linear predictions)</h2><span id='topic+get_eta'></span>

<h3>Description</h3>

<p>Given x, coefficients and intercept, return linear predictions. Wrapper that
works with both regular and sparse x. Only works for single set of coefficients
and intercept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_eta(x, beta, a0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_eta_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension <code>nobs x nvars</code>; each row is an
observation vector. If it is a sparse matrix, it is assumed to be unstandardized.
It should have attributes <code>xm</code> and <code>xs</code>, where <code>xm(j)</code> and
<code>xs(j)</code> are the centering and scaling factors for variable j respsectively.
If it is not a sparse matrix, it is assumed to be standardized.</p>
</td></tr>
<tr><td><code id="get_eta_+3A_beta">beta</code></td>
<td>
<p>Feature coefficients.</p>
</td></tr>
<tr><td><code id="get_eta_+3A_a0">a0</code></td>
<td>
<p>Intercept.</p>
</td></tr>
</table>

<hr>
<h2 id='get_start'>Get null deviance, starting mu and lambda max</h2><span id='topic+get_start'></span>

<h3>Description</h3>

<p>Return the null deviance, starting mu and lambda max values for
initialization. For internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_start(
  x,
  y,
  weights,
  family,
  intercept,
  is.offset,
  offset,
  exclude,
  vp,
  alpha
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_start_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension <code>nobs x nvars</code>; each row is an
observation vector. If it is a sparse matrix, it is assumed to be unstandardized.
It should have attributes <code>xm</code> and <code>xs</code>, where <code>xm(j)</code> and
<code>xs(j)</code> are the centering and scaling factors for variable j respsectively.
If it is not a sparse matrix, it is assumed to be standardized.</p>
</td></tr>
<tr><td><code id="get_start_+3A_y">y</code></td>
<td>
<p>Quantitative response variable.</p>
</td></tr>
<tr><td><code id="get_start_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="get_start_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link function to be
used in the model. This is the result of a call to a family function.
(See <code><a href="stats.html#topic+family">family</a></code> for details on family functions.)</p>
</td></tr>
<tr><td><code id="get_start_+3A_intercept">intercept</code></td>
<td>
<p>Does the model we are fitting have an intercept term or not?</p>
</td></tr>
<tr><td><code id="get_start_+3A_is.offset">is.offset</code></td>
<td>
<p>Is the model being fit with an offset or not?</p>
</td></tr>
<tr><td><code id="get_start_+3A_offset">offset</code></td>
<td>
<p>Offset for the model. If <code>is.offset=FALSE</code>, this should be
a zero vector of the same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="get_start_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the model.</p>
</td></tr>
<tr><td><code id="get_start_+3A_vp">vp</code></td>
<td>
<p>Separate penalty factors can be applied to each coefficient.</p>
</td></tr>
<tr><td><code id="get_start_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \le \alpha \le 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code>glmnet.path</code> for null deviance, starting mu
and lambda max values. It is also called by <code>glmnet.fit</code> when used
without warmstart, but they only use the null deviance and starting mu values.
</p>
<p>When <code>x</code> is not sparse, it is expected to already by centered and scaled.
When <code>x</code> is sparse, the function will get its attributes <code>xm</code> and
<code>xs</code> for its centering and scaling factors.
</p>
<p>Note that whether <code>x</code> is centered &amp; scaled or not, the values of <code>mu</code>
and <code>nulldev</code> don't change. However, the value of <code>lambda_max</code> does
change, and we need <code>xm</code> and <code>xs</code> to get the correct value.
</p>

<hr>
<h2 id='make_row'>Build a block row matrix for multiview</h2><span id='topic+make_row'></span>

<h3>Description</h3>

<p>Build a block row matrix for multiview
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_row(x_list, p_x, pair, rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_row_+3A_x_list">x_list</code></td>
<td>
<p>list of x matrices</p>
</td></tr>
<tr><td><code id="make_row_+3A_p_x">p_x</code></td>
<td>
<p>a list of ncol of elements in x_list</p>
</td></tr>
<tr><td><code id="make_row_+3A_pair">pair</code></td>
<td>
<p>an integer vector of two indices</p>
</td></tr>
<tr><td><code id="make_row_+3A_rho">rho</code></td>
<td>
<p>the rho value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a block row of matrix for multiview
</p>

<hr>
<h2 id='multiview'>Perform cooperative learning using the direct algorithm for
two or more views.</h2><span id='topic+multiview'></span>

<h3>Description</h3>

<p><code>multiview</code> uses <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> to do most of its work and
therefore takes many of the same parameters, but an intercept is
always included and several other parameters do not
apply. Such inapplicable arguments are overridden and warnings issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview(
  x_list,
  y,
  rho = 0,
  family = gaussian(),
  weights = NULL,
  offset = NULL,
  alpha = 1,
  nlambda = 100,
  lambda.min.ratio = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  standardize = TRUE,
  intercept = TRUE,
  thresh = 1e-07,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = list(),
  lower.limits = -Inf,
  upper.limits = Inf,
  trace.it = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="multiview_+3A_y">y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td></tr>
<tr><td><code id="multiview_+3A_rho">rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td></tr>
<tr><td><code id="multiview_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is <a href="stats.html#topic+family">stats::gaussian</a>. (See
<a href="stats.html#topic+family">stats::family</a> for details on family functions.)</p>
</td></tr>
<tr><td><code id="multiview_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td></tr>
<tr><td><code id="multiview_+3A_offset">offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td></tr>
<tr><td><code id="multiview_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td></tr>
<tr><td><code id="multiview_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td></tr>
<tr><td><code id="multiview_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a
fraction of <code>lambda.max</code>, the (data derived) entry value
(i.e. the smallest value for which all coefficients are
zero). The default depends on the sample size <code>nobs</code>
relative to the number of variables <code>nvars</code>. If <code>nobs &gt;
  nvars</code>, the default is <code>0.0001</code>, close to zero.  If
<code>nobs &lt; nvars</code>, the default is <code>0.01</code>.  A very small
value of <code>lambda.min.ratio</code> will lead to a saturated fit in
the <code>nobs &lt; nvars</code> case. This is undefined for
<code>"binomial"</code> and <code>"multinomial"</code> models, and
<code>glmnet</code> will exit gracefully when the percentage deviance
explained is almost 1.</p>
</td></tr>
<tr><td><code id="multiview_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> call (named <code>lambda</code>)
Supplying a value of <code>lambda</code> overrides this. WARNING: use with
care. Avoid supplying a single value for <code>lambda</code> (for
predictions after CV use <code><a href="stats.html#topic+predict">stats::predict()</a></code> instead.  Supply
instead a decreasing sequence of <code>lambda</code> values as <code>multiview</code>
relies on its warms starts for speed, and its often faster to fit
a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="multiview_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for x variable standardization,
prior to fitting the model sequence. The coefficients are always
returned on the original scale. Default is
<code>standardize=TRUE</code>.  If variables are in the same units
already, you might not wish to standardize. See details below for
y standardization with <code>family="gaussian"</code>.</p>
</td></tr>
<tr><td><code id="multiview_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="multiview_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td></tr>
<tr><td><code id="multiview_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td></tr>
<tr><td><code id="multiview_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td></tr>
<tr><td><code id="multiview_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">&#8288;function(x_list, y, ...)&#8288;</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td></tr>
<tr><td><code id="multiview_+3A_lower.limits">lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td></tr>
<tr><td><code id="multiview_+3A_upper.limits">upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td></tr>
<tr><td><code id="multiview_+3A_trace.it">trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current code can be slow for &quot;large&quot; data sets, e.g. when the
number of features is larger than 1000.  It can be helpful to see
the progress of multiview as it runs; to do this, set trace.it = 1
in the call to multiview or cv.multiview.  With this, multiview
prints out its progress along the way.  One can also pre-filter the
features to a smaller set, using the exclude option, with a filter
function.
</p>
<p>If there are missing values in the feature matrices: we recommend
that you center the columns of each feature matrix, and then fill
in the missing values with 0.
</p>
<p>For example, <br />
<code>x &lt;- scale(x,TRUE,FALSE)</code> <br />
<code>x[is.na(x)] &lt;- 0</code> <br />
<code>z &lt;- scale(z,TRUE,FALSE)</code> <br />
<code>z[is.na(z)] &lt;- 0</code> <br />
</p>
<p>Then run multiview in the usual way. It will exploit the assumed shared latent factors
to make efficient use of the available data.
</p>


<h3>Value</h3>

<p>An object with S3 class <code style="white-space: pre;">&#8288;"multiview","*" &#8288;</code>, where <code>"*"</code> is
<code>"elnet"</code>, <code>"lognet"</code>, <code>"multnet"</code>, <code>"fishnet"</code> (poisson),
<code>"coxnet"</code> or <code>"mrelnet"</code> for the various types of models.
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call that produced this object</p>
</td></tr>
<tr><td><code>a0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code></p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>For <code>"elnet"</code>, <code>"lognet"</code>, <code>"fishnet"</code> and <code>"coxnet"</code>
models, a <code style="white-space: pre;">&#8288;nvars x length(lambda)&#8288;</code> matrix of coefficients, stored
in sparse column format (<code>"CsparseMatrix"</code>). For <code>"multnet"</code> and
<code>"mgaussian"</code>, a list of <code>nc</code> such matrices, one for each class.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> <code>lambda</code>
values used. When <code>alpha=0</code>, the largest lambda reported does not
quite give the zero coefficients reported (<code>lambda=inf</code> would in
principle).  Instead, the largest <code>lambda</code> for <code>alpha=0.001</code> is
used, and the sequence of <code>lambda</code> values is derived from this.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The sequence of lambda values</p>
</td></tr> <tr><td><code>mvlambda</code></td>
<td>
<p>The
corresponding sequence of multiview lambda values</p>
</td></tr>
<tr><td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained (for
<code>"elnet"</code>, this is the R-square). The deviance calculations
incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the
log-likelihood for the saturated model (a model with a free
parameter per observation). Hence dev.ratio=1-dev/nulldev.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined
to be 2*(loglike_sat -loglike(Null)); The NULL model refers to
the intercept model, except for the Cox, where it is the 0
model.</p>
</td></tr> <tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each
value of <code>lambda</code>. For <code>"multnet"</code>, this is the number of
variables with a nonzero coefficient for <em>any</em> class.</p>
</td></tr>
<tr><td><code>dfmat</code></td>
<td>
<p>For <code>"multnet"</code> and <code>"mrelnet"</code> only. A matrix
consisting of the number of nonzero coefficients per class</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of coefficient matrix (ices)</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>number of observations</p>
</td></tr> <tr><td><code>npasses</code></td>
<td>
<p>total passes
over the data summed over all lambda values</p>
</td></tr> <tr><td><code>offset</code></td>
<td>
<p>a
logical variable indicating whether an offset was included in the
model</p>
</td></tr> <tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors (largely
for internal debugging).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>print</code>, <code>coef</code>, <code>coef_ordered</code>, <code>predict</code>, and <code>plot</code>
methods for <code>"multiview"</code>, and the <code>"cv.multiview"</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
z = matrix(rnorm(100 * 10), 100, 10)
y = rnorm(100)
fit1 = multiview(list(x=x,z=z), y, rho = 0)
print(fit1)

# extract coefficients at a single value of lambda
coef(fit1, s = 0.01) 

# extract ordered (standardized) coefficients at a single value of lambda
coef_ordered(fit1, s = 0.01) 

# make predictions
predict(fit1, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005))

# make a path plot of features for the fit
plot(fit1, label=TRUE)

# Binomial
by = sample(c(0,1), 100, replace = TRUE)
fit2 = multiview(list(x=x,z=z), by, family = binomial(), rho=0.5)
predict(fit2, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005), type="response")
coef_ordered(fit2, s = 0.01) 
plot(fit2, label=TRUE)

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = multiview(list(x=x,z=z), py, family = poisson(), rho=0.5)
predict(fit3, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005), type="response")
coef_ordered(fit3, s = 0.01) 
plot(fit3, label=TRUE)

</code></pre>

<hr>
<h2 id='multiview.control'>Internal multiview parameters</h2><span id='topic+multiview.control'></span>

<h3>Description</h3>

<p>View and/or change the factory default parameters in multiview
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview.control(
  fdev = 1e-05,
  devmax = 0.999,
  eps = 1e-06,
  big = 9.9e+35,
  mnlam = 5,
  pmin = 1e-09,
  exmx = 250,
  prec = 1e-10,
  mxit = 100,
  itrace = 0,
  epsnr = 1e-06,
  mxitnr = 25,
  factory = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview.control_+3A_fdev">fdev</code></td>
<td>
<p>minimum fractional change in deviance for stopping path; factory
default = 1.0e-5</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_devmax">devmax</code></td>
<td>
<p>maximum fraction of explained deviance for stopping path;
factory default = 0.999</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_eps">eps</code></td>
<td>
<p>minimum value of lambda.min.ratio (see multiview); factory default=
1.0e-6</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_big">big</code></td>
<td>
<p>large floating point number; factory default = 9.9e35. Inf in
definition of upper.limit is set to big</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_mnlam">mnlam</code></td>
<td>
<p>minimum number of path points (lambda values) allowed; factory
default = 5</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_pmin">pmin</code></td>
<td>
<p>minimum probability for any class. factory default = 1.0e-9.
Note that this implies a pmax of 1-pmin.</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_exmx">exmx</code></td>
<td>
<p>maximum allowed exponent. factory default = 250.0</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_prec">prec</code></td>
<td>
<p>convergence threshold for multi response bounds adjustment
solution. factory default = 1.0e-10</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_mxit">mxit</code></td>
<td>
<p>maximum iterations for multiresponse bounds adjustment solution.
factory default = 100</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_itrace">itrace</code></td>
<td>
<p>If 1 then progress bar is displayed when running <code>multiview</code>
and <code>cv.multiview</code>. factory default = 0</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_epsnr">epsnr</code></td>
<td>
<p>convergence threshold for <code>multiview.fit</code>. factory default =
1.0e-6</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_mxitnr">mxitnr</code></td>
<td>
<p>maximum iterations for the IRLS loop in <code>multiview.fit</code>. factory
default = 25</p>
</td></tr>
<tr><td><code id="multiview.control_+3A_factory">factory</code></td>
<td>
<p>If <code>TRUE</code>, reset all the parameters to the factory
default; default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If called with no arguments, <code>multiview.control()</code> returns a list with the
current settings of these parameters. Any arguments included in the call
sets those parameters to the new values, and then silently returns. The
values set are persistent for the duration of the R session.
</p>


<h3>Value</h3>

<p>A list with named elements as in the argument list
</p>


<h3>See Also</h3>

<p><code>multiview</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
multiview.control(fdev = 0)  #continue along path even though not much changes
multiview.control()  # view current settings
multiview.control(factory = TRUE)  # reset all the parameters to their default

</code></pre>

<hr>
<h2 id='multiview.cox.fit'>Fit a Cox regression model with elastic net regularization for a single
value of lambda</h2><span id='topic+multiview.cox.fit'></span>

<h3>Description</h3>

<p>Fit a Cox regression model via penalized maximum likelihood for a single
value of lambda. Can deal with (start, stop] data and strata, as well as
sparse design matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview.cox.fit(
  x_list,
  x,
  y,
  rho,
  weights,
  lambda,
  alpha = 1,
  offset = rep(0, nobs),
  thresh = 1e-10,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = c(),
  lower.limits = -Inf,
  upper.limits = Inf,
  warm = NULL,
  from.cox.path = FALSE,
  save.fit = FALSE,
  trace.it = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview.cox.fit_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_x">x</code></td>
<td>
<p>the <code>cbind</code>ed matrices in <code>x_list</code></p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_y">y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_rho">rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_lambda">lambda</code></td>
<td>
<p>A single value for the <code>lambda</code> hyperparameter.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_offset">offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">&#8288;function(x_list, y, ...)&#8288;</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_lower.limits">lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_upper.limits">upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_warm">warm</code></td>
<td>
<p>Either a <code>glmnetfit</code> object or a list (with names <code>beta</code>
and <code>a0</code> containing coefficients and intercept respectively) which can
be used as a warm start. Default is <code>NULL</code>, indicating no warm start.
For internal use only.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_from.cox.path">from.cox.path</code></td>
<td>
<p>Was <code>multiview.cox.fit()</code> called from <code>multiview.path()</code>?
Default is FALSE.This has implications for computation of the penalty factors.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_save.fit">save.fit</code></td>
<td>
<p>Return the warm start object? Default is FALSE.</p>
</td></tr>
<tr><td><code id="multiview.cox.fit_+3A_trace.it">trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: Users should not call <code>multiview.cox.fit</code> directly. Higher-level
functions in this package call <code>multiview.cox.fit</code> as a subroutine. If a
warm start object is provided, some of the other arguments in the function
may be overriden.
</p>
<p><code>multiview.cox.fit</code> solves the elastic net problem for a single, user-specified
value of lambda. <code>multiview.cox.fit</code> works for Cox regression models, including
(start, stop] data and strata. It solves the problem using iteratively
reweighted least squares (IRLS). For each IRLS iteration, <code>multiview.cox.fit</code>
makes a quadratic (Newton) approximation of the log-likelihood, then calls
<code>elnet.fit</code> to minimize the resulting approximation.
</p>
<p>In terms of standardization: <code>multiview.cox.fit</code> does not standardize <code>x</code>
and <code>weights</code>. <code>penalty.factor</code> is standardized so that they sum
up to <code>nvars</code>.
</p>


<h3>Value</h3>

<p>An object with class &quot;coxnet&quot;, &quot;glmnetfit&quot; and &quot;glmnet&quot;. The list
returned contains more keys than that of a &quot;glmnet&quot; object.
</p>
<table>
<tr><td><code>a0</code></td>
<td>
<p>Intercept value, <code>NULL</code> for &quot;cox&quot; family.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x 1</code> matrix of coefficients, stored in sparse matrix
format.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Lambda value used.</p>
</td></tr>
<tr><td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the 0 model.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total passes over the data.</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>warm_fit</code></td>
<td>
<p>If <code>save.fit=TRUE</code>, output of C++ routine, used for
warm starts. For internal use only.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Family used for the model, always &quot;cox&quot;.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A logical variable: was the algorithm judged to have
converged?</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>A logical variable: is the fitted value on the boundary of
the attainable values?</p>
</td></tr>
<tr><td><code>obj_function</code></td>
<td>
<p>Objective function value at the solution.</p>
</td></tr>
</table>

<hr>
<h2 id='multiview.cox.path'>Fit a Cox regression model with elastic net regularization for a path of
lambda values</h2><span id='topic+multiview.cox.path'></span>

<h3>Description</h3>

<p>Fit a Cox regression model via penalized maximum likelihood for a path of
lambda values. Can deal with (start, stop] data and strata, as well as
sparse design matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview.cox.path(
  x_list,
  x,
  y,
  rho = 0,
  weights = NULL,
  lambda = NULL,
  offset = NULL,
  alpha = 1,
  nlambda = 100,
  lambda.min.ratio = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  standardize = TRUE,
  intercept = TRUE,
  thresh = 1e-07,
  exclude = integer(0),
  penalty.factor = rep(1, nvars),
  lower.limits = -Inf,
  upper.limits = Inf,
  maxit = 1e+05,
  trace.it = 0,
  nvars,
  nobs,
  xm,
  xs,
  control,
  vp,
  vnames,
  is.offset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview.cox.path_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_x">x</code></td>
<td>
<p>the <code>cbind</code>ed matrices in <code>x_list</code></p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_y">y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_rho">rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> call (named <code>lambda</code>)
Supplying a value of <code>lambda</code> overrides this. WARNING: use with
care. Avoid supplying a single value for <code>lambda</code> (for
predictions after CV use <code><a href="stats.html#topic+predict">stats::predict()</a></code> instead.  Supply
instead a decreasing sequence of <code>lambda</code> values as <code>multiview</code>
relies on its warms starts for speed, and its often faster to fit
a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_offset">offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_lambda.min.ratio">lambda.min.ratio</code></td>
<td>
<p>Smallest value for <code>lambda</code>, as a
fraction of <code>lambda.max</code>, the (data derived) entry value
(i.e. the smallest value for which all coefficients are
zero). The default depends on the sample size <code>nobs</code>
relative to the number of variables <code>nvars</code>. If <code>nobs &gt;
  nvars</code>, the default is <code>0.0001</code>, close to zero.  If
<code>nobs &lt; nvars</code>, the default is <code>0.01</code>.  A very small
value of <code>lambda.min.ratio</code> will lead to a saturated fit in
the <code>nobs &lt; nvars</code> case. This is undefined for
<code>"binomial"</code> and <code>"multinomial"</code> models, and
<code>glmnet</code> will exit gracefully when the percentage deviance
explained is almost 1.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for x variable standardization,
prior to fitting the model sequence. The coefficients are always
returned on the original scale. Default is
<code>standardize=TRUE</code>.  If variables are in the same units
already, you might not wish to standardize. See details below for
y standardization with <code>family="gaussian"</code>.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">&#8288;function(x_list, y, ...)&#8288;</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_lower.limits">lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_upper.limits">upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_trace.it">trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_nvars">nvars</code></td>
<td>
<p>the number of variables (total)</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_xm">xm</code></td>
<td>
<p>the column means vector (could be zeros if <code>standardize = FALSE</code>)</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_xs">xs</code></td>
<td>
<p>the column std dev vector (could be 1s if <code>standardize = FALSE</code>)</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_control">control</code></td>
<td>
<p>the multiview control object</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_vp">vp</code></td>
<td>
<p>the variable penalities (processed)</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_vnames">vnames</code></td>
<td>
<p>the variable names</p>
</td></tr>
<tr><td><code id="multiview.cox.path_+3A_is.offset">is.offset</code></td>
<td>
<p>a flag indicating if offset is supplied or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes the sequence is truncated before <code>nlambda</code> values of lambda
have been used. This happens when <code>cox.path</code> detects that the
decrease in deviance is marginal (i.e. we are near a saturated fit).
</p>


<h3>Value</h3>

<p>An object of class &quot;coxnet&quot; and &quot;glmnet&quot;.
</p>
<table>
<tr><td><code>a0</code></td>
<td>
<p>Intercept value, <code>NULL</code> for &quot;cox&quot; family.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars x length(lambda)</code> matrix of coefficients, stored in
sparse matrix format.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of lambda.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of lambda values used. When alpha=0, the
largest lambda reported does not quite give the zero coefficients reported
(lambda=inf would in principle). Instead, the largest lambda for alpha=0.001
is used, and the sequence of lambda values is derived from this.</p>
</td></tr>
<tr><td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the 0 model.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total passes over the data summed over all lambda values.</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2)
nobs &lt;- 100; nvars &lt;- 15
xvec &lt;- rnorm(nobs * nvars)
xvec[sample.int(nobs * nvars, size = 0.4 * nobs * nvars)] &lt;- 0
x &lt;- matrix(xvec, nrow = nobs)
beta &lt;- rnorm(nvars / 3)
fx &lt;- x[, seq(nvars / 3)] %*% beta / 3
ty &lt;- rexp(nobs, exp(fx))
tcens &lt;- rbinom(n = nobs, prob = 0.3, size = 1)
jsurv &lt;- survival::Surv(ty, tcens)
fit1 &lt;- glmnet:::cox.path(x, jsurv)

# works with sparse x matrix
x_sparse &lt;- Matrix::Matrix(x, sparse = TRUE)
fit2 &lt;- glmnet:::cox.path(x_sparse, jsurv)

# example with (start, stop] data
set.seed(2)
start_time &lt;- runif(100, min = 0, max = 5)
stop_time &lt;- start_time + runif(100, min = 0.1, max = 3)
status &lt;- rbinom(n = nobs, prob = 0.3, size = 1)
jsurv_ss &lt;- survival::Surv(start_time, stop_time, status)
fit3 &lt;- glmnet:::cox.path(x, jsurv_ss)

# example with strata
jsurv_ss2 &lt;- glmnet::stratifySurv(jsurv_ss, rep(1:2, each = 50))
fit4 &lt;- glmnet:::cox.path(x, jsurv_ss2)
</code></pre>

<hr>
<h2 id='multiview.fit'>Fit a GLM with elastic net regularization for a single value of
lambda</h2><span id='topic+multiview.fit'></span>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood for
a single value of lambda. Can deal with any GLM family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview.fit(
  x_list,
  x,
  y,
  rho,
  weights,
  lambda,
  alpha = 1,
  offset = rep(0, nobs),
  family = gaussian(),
  intercept = TRUE,
  thresh = 1e-07,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = c(),
  lower.limits = -Inf,
  upper.limits = Inf,
  warm = NULL,
  from.multiview.path = FALSE,
  save.fit = FALSE,
  trace.it = 0,
  user_lambda = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview.fit_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_x">x</code></td>
<td>
<p>the column-binded entries of <code>x_list</code></p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_y">y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_rho">rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_lambda">lambda</code></td>
<td>
<p>A single value for the <code>lambda</code> hyperparameter.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_offset">offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is <a href="stats.html#topic+family">stats::gaussian</a>. (See
<a href="stats.html#topic+family">stats::family</a> for details on family functions.)</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data; default is
<code>10^5</code>.  (If a warm start object is provided, the number of
passes the warm start object performed is included.)</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">&#8288;function(x_list, y, ...)&#8288;</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_lower.limits">lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_upper.limits">upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_warm">warm</code></td>
<td>
<p>Either a <code>multiview</code> object or a list (with names
<code>beta</code> and <code>a0</code> containing coefficients and intercept
respectively) which can be used as a warm start. Default is
<code>NULL</code>, indicating no warm start.  For internal use only.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_from.multiview.path">from.multiview.path</code></td>
<td>
<p>Was <code>multiview.fit()</code> called from
<code>multiview.path()</code>?  Default is <code>FALSE</code>.This has implications for
computation of the penalty factors.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_save.fit">save.fit</code></td>
<td>
<p>Return the warm start object? Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_trace.it">trace.it</code></td>
<td>
<p>Controls how much information is printed to
screen. If <code>trace.it = 2</code>, some information about the fitting
procedure is printed to the console as the model is being
fitted. Default is <code>trace.it = 0</code> (no information
printed). (<code>trace.it = 1</code> not used for compatibility with
<code>multiview.path</code>.)</p>
</td></tr>
<tr><td><code id="multiview.fit_+3A_user_lambda">user_lambda</code></td>
<td>
<p>a flag indicating if user supplied the lambda sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: Users should not call <code>multiview.fit</code>
directly. Higher-level functions in this package call
<code>multiview.fit</code> as a subroutine. If a warm start object is
provided, some of the other arguments in the function may be
overriden.
</p>
<p><code>multiview.fit</code> solves the elastic net problem for a <em>single,
user-specified</em> value of lambda. <code>multiview.fit</code> works for any GLM
family. It solves the problem using iteratively reweighted least
squares (IRLS). For each IRLS iteration, <code>multiview.fit</code> makes a
quadratic (Newton) approximation of the log-likelihood, then calls
<code>elnet.fit</code> to minimize the resulting approximation.
</p>
<p>In terms of standardization: <code>multiview.fit</code> does not standardize
<code>x</code> and <code>weights</code>. <code>penalty.factor</code> is standardized so that to sum
to <code>nvars</code>.
</p>


<h3>Value</h3>

<p>An object with class <code>"multiview"</code>. The list
returned contains more keys than that of a <code>"multiview"</code> object.
</p>
<table>
<tr><td><code>a0</code></td>
<td>
<p>Intercept value.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code>nvars</code> by <code>1</code> matrix of coefficients, stored in sparse matrix
format.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Lambda value used.</p>
</td></tr>
<tr><td><code>lambda_scale</code></td>
<td>
<p>The multiview lambda scale factor</p>
</td></tr>
<tr><td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the intercept model.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total passes over the data.</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
<tr><td><code>warm_fit</code></td>
<td>
<p>If <code>save.fit = TRUE</code>, output of C++ routine, used for
warm starts. For internal use only.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Family used for the model.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A logical variable: was the algorithm judged to have
converged?</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>A logical variable: is the fitted value on the boundary of
the attainable values?</p>
</td></tr>
<tr><td><code>obj_function</code></td>
<td>
<p>Objective function value at the solution.</p>
</td></tr>
</table>

<hr>
<h2 id='multiview.path'>Fit a GLM with elastic net regularization for a path of lambda values</h2><span id='topic+multiview.path'></span>

<h3>Description</h3>

<p>Fit a generalized linear model via penalized maximum likelihood for a path of
lambda values. Can deal with any GLM family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiview.path(
  x_list,
  y,
  rho = 0,
  weights = NULL,
  lambda,
  nlambda,
  user_lambda = FALSE,
  alpha = 1,
  offset = NULL,
  family = gaussian(),
  standardize = TRUE,
  intercept = TRUE,
  thresh = 1e-07,
  maxit = 1e+05,
  penalty.factor = rep(1, nvars),
  exclude = integer(0),
  lower.limits = -Inf,
  upper.limits = Inf,
  trace.it = 0,
  x,
  nvars,
  nobs,
  xm,
  xs,
  control,
  vp,
  vnames,
  start_val,
  is.offset
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiview.path_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="multiview.path_+3A_y">y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_rho">rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_weights">weights</code></td>
<td>
<p>observation weights. Can be total counts if
responses are proportion matrices. Default is 1 for each
observation</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_lambda">lambda</code></td>
<td>
<p>A user supplied <code>lambda</code> sequence, default
<code>NULL</code>. Typical usage is to have the program compute its own
<code>lambda</code> sequence. This sequence, in general, is different from
that used in the <code><a href="glmnet.html#topic+glmnet">glmnet::glmnet()</a></code> call (named <code>lambda</code>)
Supplying a value of <code>lambda</code> overrides this. WARNING: use with
care. Avoid supplying a single value for <code>lambda</code> (for
predictions after CV use <code><a href="stats.html#topic+predict">stats::predict()</a></code> instead.  Supply
instead a decreasing sequence of <code>lambda</code> values as <code>multiview</code>
relies on its warms starts for speed, and its often faster to fit
a whole path than compute a single fit.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_nlambda">nlambda</code></td>
<td>
<p>The number of <code>lambda</code> values - default is 100.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_user_lambda">user_lambda</code></td>
<td>
<p>a flag indicating if user supplied the lambda sequence</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with
<code class="reqn">0\le\alpha\le 1</code>.  The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2||\beta||_2^2+\alpha||\beta||_1.</code>
</p>

<p><code>alpha=1</code> is the lasso penalty, and <code>alpha=0</code> the ridge
penalty.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_offset">offset</code></td>
<td>
<p>A vector of length <code>nobs</code> that is included in
the linear predictor (a <code>nobs x nc</code> matrix for the
<code>"multinomial"</code> family).  Useful for the <code>"poisson"</code>
family (e.g. log of exposure time), or for refining a model by
starting at a current fit. Default is <code>NULL</code>. If supplied,
then values must also be supplied to the <code>predict</code> function.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is <a href="stats.html#topic+family">stats::gaussian</a>. (See
<a href="stats.html#topic+family">stats::family</a> for details on family functions.)</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_standardize">standardize</code></td>
<td>
<p>Logical flag for x variable standardization,
prior to fitting the model sequence. The coefficients are always
returned on the original scale. Default is
<code>standardize=TRUE</code>.  If variables are in the same units
already, you might not wish to standardize. See details below for
y standardization with <code>family="gaussian"</code>.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_intercept">intercept</code></td>
<td>
<p>Should intercept(s) be fitted (default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_thresh">thresh</code></td>
<td>
<p>Convergence threshold for coordinate descent. Each
inner coordinate-descent loop continues until the maximum change
in the objective after any coefficient update is less than
<code>thresh</code> times the null deviance. Defaults value is
<code>1E-7</code>.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of passes over the data for all lambda
values; default is 10^5.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>Separate penalty factors can be applied to
each coefficient. This is a number that multiplies <code>lambda</code>
to allow differential shrinkage. Can be 0 for some variables,
which implies no shrinkage, and that variable is always included
in the model. Default is 1 for all variables (and implicitly
infinity for variables listed in <code>exclude</code>). Note: the
penalty factors are internally rescaled to sum to nvars, and the
lambda sequence will reflect this change.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_exclude">exclude</code></td>
<td>
<p>Indices of variables to be excluded from the
model. Default is none. Equivalent to an infinite penalty factor
for the variables excluded (next item).  Users can supply instead
an <code>exclude</code> function that generates the list of indices.  This
function is most generally defined as <code style="white-space: pre;">&#8288;function(x_list, y, ...)&#8288;</code>,
and is called inside <code>multiview</code> to generate the indices for
excluded variables.  The <code>...</code> argument is required, the others
are optional.  This is useful for filtering wide data, and works
correctly with <code>cv.multiview</code>. See the vignette 'Introduction'
for examples.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_lower.limits">lower.limits</code></td>
<td>
<p>Vector of lower limits for each coefficient;
default <code>-Inf</code>. Each of these must be non-positive. Can be
presented as a single value (which will then be replicated), else
a vector of length <code>nvars</code></p>
</td></tr>
<tr><td><code id="multiview.path_+3A_upper.limits">upper.limits</code></td>
<td>
<p>Vector of upper limits for each coefficient;
default <code>Inf</code>. See <code>lower.limits</code></p>
</td></tr>
<tr><td><code id="multiview.path_+3A_trace.it">trace.it</code></td>
<td>
<p>If <code>trace.it=1</code>, then a progress bar is
displayed; useful for big models that take a long time to fit.</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_x">x</code></td>
<td>
<p>the <code>cbind</code>ed matrices in <code>x_list</code></p>
</td></tr>
<tr><td><code id="multiview.path_+3A_nvars">nvars</code></td>
<td>
<p>the number of variables (total)</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_nobs">nobs</code></td>
<td>
<p>the number of observations</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_xm">xm</code></td>
<td>
<p>the column means vector (could be zeros if <code>standardize = FALSE</code>)</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_xs">xs</code></td>
<td>
<p>the column std dev vector (could be 1s if <code>standardize = FALSE</code>)</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_control">control</code></td>
<td>
<p>the multiview control object</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_vp">vp</code></td>
<td>
<p>the variable penalities (processed)</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_vnames">vnames</code></td>
<td>
<p>the variable names</p>
</td></tr>
<tr><td><code id="multiview.path_+3A_start_val">start_val</code></td>
<td>
<p>the result of first call to <code>get_start</code></p>
</td></tr>
<tr><td><code id="multiview.path_+3A_is.offset">is.offset</code></td>
<td>
<p>a flag indicating if offset is supplied or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>multiview.path</code> solves the elastic net problem for a path of lambda values.
It generalizes <code>multiview::multiview</code> in that it works for any GLM family.
</p>
<p>Sometimes the sequence is truncated before <code>nlam</code> values of lambda
have been used. This happens when <code>multiview.path</code> detects that the decrease
in deviance is marginal (i.e. we are near a saturated fit).
</p>


<h3>Value</h3>

<p>An object with class <code>"multiview"</code> <code>"glmnetfit"</code> and <code>"glmnet"</code>
</p>
<table>
<tr><td><code>a0</code></td>
<td>
<p>Intercept sequence of length <code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;nvars x length(lambda)&#8288;</code> matrix of coefficients, stored in
sparse matrix format.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of nonzero coefficients for each value of lambda.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>Dimension of coefficient matrix.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The actual sequence of lambda values used. When alpha=0, the
largest lambda reported does not quite give the zero coefficients reported
(lambda=inf would in principle). Instead, the largest lambda for alpha=0.001
is used, and the sequence of lambda values is derived from this.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>The sequence of lambda values</p>
</td></tr>
<tr><td><code>mvlambda</code></td>
<td>
<p>The corresponding sequence of multiview lambda values</p>
</td></tr>
<tr><td><code>dev.ratio</code></td>
<td>
<p>The fraction of (null) deviance explained. The deviance
calculations incorporate weights if present in the model. The deviance is
defined to be 2*(loglike_sat - loglike), where loglike_sat is the log-likelihood
for the saturated model (a model with a free parameter per observation).
Hence dev.ratio=1-dev/nulldev.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>Null deviance (per observation). This is defined to be
2*(loglike_sat -loglike(Null)). The null model refers to the intercept model.</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>Total passes over the data summed over all lambda values.</p>
</td></tr>
<tr><td><code>jerr</code></td>
<td>
<p>Error flag, for warnings and errors (largely for internal
debugging).</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>A logical variable indicating whether an offset was included
in the model.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call that produced this object.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Family used for the model.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations.</p>
</td></tr>
</table>

<hr>
<h2 id='obj_function'>Elastic net objective function value</h2><span id='topic+obj_function'></span>

<h3>Description</h3>

<p>Returns the elastic net objective function value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_function(
  y,
  mu,
  weights,
  family,
  lambda,
  alpha,
  coefficients,
  vp,
  view_components,
  rho
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_function_+3A_y">y</code></td>
<td>
<p>Quantitative response variable.</p>
</td></tr>
<tr><td><code id="obj_function_+3A_mu">mu</code></td>
<td>
<p>Model's predictions for <code>y</code>.</p>
</td></tr>
<tr><td><code id="obj_function_+3A_weights">weights</code></td>
<td>
<p>Observation weights.</p>
</td></tr>
<tr><td><code id="obj_function_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link function to be
used in the model. This is the result of a call to a family function.</p>
</td></tr>
<tr><td><code id="obj_function_+3A_lambda">lambda</code></td>
<td>
<p>A single value for the <code>lambda</code> hyperparameter.</p>
</td></tr>
<tr><td><code id="obj_function_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \le \alpha \le 1</code>.</p>
</td></tr>
<tr><td><code id="obj_function_+3A_coefficients">coefficients</code></td>
<td>
<p>The model's coefficients (excluding intercept).</p>
</td></tr>
<tr><td><code id="obj_function_+3A_vp">vp</code></td>
<td>
<p>Penalty factors for each of the coefficients.</p>
</td></tr>
<tr><td><code id="obj_function_+3A_view_components">view_components</code></td>
<td>
<p>a list of lists containing indices of coefficients and associated covariate (view) pairs</p>
</td></tr>
<tr><td><code id="obj_function_+3A_rho">rho</code></td>
<td>
<p>the fusion parameter</p>
</td></tr>
</table>

<hr>
<h2 id='pen_function'>Elastic net penalty value</h2><span id='topic+pen_function'></span>

<h3>Description</h3>

<p>Returns the elastic net penalty value without the <code>lambda</code> factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pen_function(coefficients, alpha = 1, vp = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pen_function_+3A_coefficients">coefficients</code></td>
<td>
<p>The model's coefficients (excluding intercept).</p>
</td></tr>
<tr><td><code id="pen_function_+3A_alpha">alpha</code></td>
<td>
<p>The elasticnet mixing parameter, with <code class="reqn">0 \le \alpha \le 1</code>.</p>
</td></tr>
<tr><td><code id="pen_function_+3A_vp">vp</code></td>
<td>
<p>Penalty factors for each of the coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The penalty is defined as
</p>
<p style="text-align: center;"><code class="reqn">(1-\alpha)/2 \sum vp_j \beta_j^2 + \alpha \sum vp_j |\beta|.</code>
</p>

<p>Note the omission of the multiplicative <code>lambda</code> factor.
</p>

<hr>
<h2 id='plot.multiview'>Plot coefficients from a &quot;multiview&quot; object</h2><span id='topic+plot.multiview'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a fitted
<code>"multiview"</code> object. The paths are colored by the data views, from which the features come.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiview'
plot(x, col_palette = NULL, label = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.multiview_+3A_x">x</code></td>
<td>
<p>A fitted <code>"multiview"</code> model.</p>
</td></tr>
<tr><td><code id="plot.multiview_+3A_col_palette">col_palette</code></td>
<td>
<p>A set of colors to use for indicating different views. If <code>NULL</code>,
the function will use the color palette &quot;Set1&quot; from the <code>RColorBrewer</code> package.</p>
</td></tr>
<tr><td><code id="plot.multiview_+3A_label">label</code></td>
<td>
<p>If <code>TRUE</code>, label the curves with variable sequence.
numbers.</p>
</td></tr>
<tr><td><code id="plot.multiview_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>NULL</code> value as this function is really meant for its side-effect of generating a plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
z = matrix(rnorm(100 * 10), 100, 10)
y = rnorm(100)
fit1 = multiview(list(x=x,z=z), y, rho = 0)
plot(fit1, label = TRUE)

# Binomial
by = sample(c(0,1), 100, replace = TRUE)
fit2 = multiview(list(x=x,z=z), by, family = binomial(), rho=0.5)
plot(fit2, label=FALSE)

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = multiview(list(x=x,z=z), py, family = poisson(), rho=0.5)
plot(fit3, label=TRUE)

</code></pre>

<hr>
<h2 id='predict.cv.multiview'>Make predictions from a &quot;cv.multiview&quot; object.</h2><span id='topic+predict.cv.multiview'></span>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated multiview model, using
the stored <code>"multiview"</code> object, and the optimal value chosen for
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.multiview'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.multiview_+3A_object">object</code></td>
<td>
<p>Fitted <code>"cv.multiview"</code> or object.</p>
</td></tr>
<tr><td><code id="predict.cv.multiview_+3A_newx">newx</code></td>
<td>
<p>List of new view matrices at which predictions are to be made.</p>
</td></tr>
<tr><td><code id="predict.cv.multiview_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code> stored
on the CV <code>object</code>. Alternatively <code>s="lambda.min"</code> can be used. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used. (For historical reasons we use the symbol 's' rather than 'lambda' to
reference this parameter)</p>
</td></tr>
<tr><td><code id="predict.cv.multiview_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation to make
a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends on the ... argument which is passed
on to the <code>predict</code> method for <code>multiview</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
# Generate data based on a factor model
set.seed(1)
x = matrix(rnorm(100*10), 100, 10)
z = matrix(rnorm(100*10), 100, 10)
U = matrix(rnorm(100*5), 100, 5)
for (m in seq(5)){
    u = rnorm(100)
    x[, m] = x[, m] + u
    z[, m] = z[, m] + u
    U[, m] = U[, m] + u}
x = scale(x, center = TRUE, scale = FALSE)
z = scale(z, center = TRUE, scale = FALSE)
beta_U = c(rep(0.1, 5))
y = U %*% beta_U + 0.1 * rnorm(100)
fit1 = cv.multiview(list(x=x,z=z), y, rho = 0.3)
predict(fit1, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min")

# Binomial

by = 1 * (y &gt; median(y)) 
fit2 = cv.multiview(list(x=x,z=z), by, family = binomial(), rho = 0.9)
predict(fit2, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response")

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = cv.multiview(list(x=x,z=z), py, family = poisson(), rho = 0.6)
predict(fit3, newx = list(x[1:5, ],z[1:5,]), s = "lambda.min", type = "response")

</code></pre>

<hr>
<h2 id='predict.multiview'>Get predictions from a <code>multiview</code> fit object</h2><span id='topic+predict.multiview'></span>

<h3>Description</h3>

<p>Gives fitted values, linear predictors, coefficients and number of non-zero
coefficients from a fitted <code>multiview</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiview'
predict(
  object,
  newx,
  s = NULL,
  type = c("link", "response", "coefficients", "class", "nonzero"),
  exact = FALSE,
  newoffset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.multiview_+3A_object">object</code></td>
<td>
<p>Fitted &quot;multiview&quot; object.</p>
</td></tr>
<tr><td><code id="predict.multiview_+3A_newx">newx</code></td>
<td>
<p>list of new matrices for  <code>x</code> at which predictions are to be
made. Must be a list of matrices. This argument is not used for <code>type = c("coefficients","nonzero")</code>.</p>
</td></tr>
<tr><td><code id="predict.multiview_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter lambda at which predictions are
required. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="predict.multiview_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type &quot;link&quot; gives the linear
predictors (eta scale); Type &quot;response&quot; gives the fitted values (mu scale).
Type &quot;coefficients&quot; computes the coefficients at the requested values for s.
Type &quot;nonzero&quot; returns a list of the indices of the nonzero coefficients for
each value of s. Type &quot;class&quot; returns class labels for binomial family only.</p>
</td></tr>
<tr><td><code id="predict.multiview_+3A_exact">exact</code></td>
<td>
<p>This argument is relevant only when predictions are made at values
of <code>s</code> (<code>lambda</code>) <em>different</em> from those used in the fitting of the
original model. If <code>exact=FALSE</code> (default), then the predict function
uses linear interpolation to make predictions for values of <code>s</code> (lambda)
that do not coincide with those used in the fitting algorithm. While this is
often a good approximation, it can sometimes be a bit coarse. With
<code>exact=TRUE</code>, these different values of <code>s</code> are merged (and sorted)
with <code>object$lambda</code>, and the model is refit before predictions are made.
In this case, it is required to supply the original data x= and y= as additional
named arguments to predict() or coef(). The workhorse <code>predict.multiview()</code>
needs to update the model, and so needs the data used to create it. The same
is true of weights, offset, penalty.factor, lower.limits, upper.limits if
these were used in the original call. Failure to do so will result in an error.</p>
</td></tr>
<tr><td><code id="predict.multiview_+3A_newoffset">newoffset</code></td>
<td>
<p>If an offset is used in the fit, then one must be supplied for
making predictions (except for type=&quot;coefficients&quot; or type=&quot;nonzero&quot;).</p>
</td></tr>
<tr><td><code id="predict.multiview_+3A_...">...</code></td>
<td>
<p>This is the mechanism for passing arguments like <code style="white-space: pre;">&#8288;x=&#8288;</code> when
<code>exact=TRUE</code>; see <code>exact</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Gaussian
x = matrix(rnorm(100 * 20), 100, 20)
z = matrix(rnorm(100 * 20), 100, 20)
y = rnorm(100)
fit1 = multiview(list(x=x,z=z), y, rho = 0)
predict(fit1, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005))

# Binomial
by = sample(c(0,1), 100, replace = TRUE)
fit2 = multiview(list(x=x,z=z), by, family = binomial(), rho=0.5)
predict(fit2, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005), type = "response")

# Poisson
py = matrix(rpois(100, exp(y))) 
fit3 = multiview(list(x=x,z=z), py, family = poisson(), rho=0.5)
predict(fit3, newx = list(x[1:10, ],z[1:10, ]), s = c(0.01, 0.005), type = "response")

</code></pre>

<hr>
<h2 id='reshape_x_to_xlist'>Return a new list of x matrices of same shapes as those in x_list</h2><span id='topic+reshape_x_to_xlist'></span>

<h3>Description</h3>

<p>Return a new list of x matrices of same shapes as those in x_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_x_to_xlist(x, x_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_x_to_xlist_+3A_x">x</code></td>
<td>
<p>the column-binded entries of <code>x_list</code></p>
</td></tr>
<tr><td><code id="reshape_x_to_xlist_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
</table>

<hr>
<h2 id='response.coxnet'>Make response for coxnet</h2><span id='topic+response.coxnet'></span>

<h3>Description</h3>

<p>Internal function to make the response y passed to glmnet suitable
for coxnet (i.e. glmnet with family = &quot;cox&quot;). Sanity checks are performed
here too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response.coxnet(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response.coxnet_+3A_y">y</code></td>
<td>
<p>Response variable. Either a class &quot;Surv&quot; object or a two-column
matrix with columns named 'time' and 'status'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If y is a class &quot;Surv&quot; object, this function returns y with no changes. If
y is a two-column matrix with columns named 'time' and 'status', it is
converted into a &quot;Surv&quot; object.
</p>


<h3>Value</h3>

<p>A class &quot;Surv&quot; object.
</p>

<hr>
<h2 id='select_matrix_list_columns'>Select x_list columns specified by (conformable) list of indices</h2><span id='topic+select_matrix_list_columns'></span>

<h3>Description</h3>

<p>Select x_list columns specified by (conformable) list of indices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_matrix_list_columns(x_list, indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_matrix_list_columns_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="select_matrix_list_columns_+3A_indices">indices</code></td>
<td>
<p>a vector of indices in <code>1:nvars</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of x matrices
</p>

<hr>
<h2 id='to_nvar_index'>Translate from column indices in list of x matrices to indices in
<code>1:nvars</code>. No sanity checks for efficiency</h2><span id='topic+to_nvar_index'></span>

<h3>Description</h3>

<p>Translate from column indices in list of x matrices to indices in
<code>1:nvars</code>. No sanity checks for efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_nvar_index(x_list, index_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_nvar_index_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="to_nvar_index_+3A_index_list">index_list</code></td>
<td>
<p>a list of column indices for each matrix,
including possibly column indices of length 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of indices between 1 and nvars = sum of <code>ncol(x)</code>
for x in x_list
</p>

<hr>
<h2 id='to_xlist_index'>Translate indices in <code>1:nvars</code> to column indices in list of x
matrices. No sanity checks</h2><span id='topic+to_xlist_index'></span>

<h3>Description</h3>

<p>Translate indices in <code>1:nvars</code> to column indices in list of x
matrices. No sanity checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_xlist_index(x_list, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_xlist_index_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="to_xlist_index_+3A_index">index</code></td>
<td>
<p>vector of indices between 1 and nvars = sum of
<code>ncol(x)</code> for x in x_list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a conformed list of column indices for each matrix,
including possibly column indices of length 0
</p>

<hr>
<h2 id='view.contribution'>Evaluate the contribution of data views in making prediction</h2><span id='topic+view.contribution'></span>

<h3>Description</h3>

<p>Evaluate the contribution of each data view in making prediction. The function has two options.
If <code>force</code> is set to <code>NULL</code>, the data view contribution is benchmarked by the null model.
If <code>force</code> is set to a list of data views, the contribution is benchmarked by the model fit on
this list of data views, and the function evaluates the marginal contribution of each additional data
view on top of this benchmarking list of views.
The function returns a table showing the percentage improvement in reducing error as compared to the bechmarking model
made by each data view.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view.contribution(
  x_list,
  y,
  family = gaussian(),
  rho,
  s = c("lambda.min", "lambda.1se"),
  eval_data = c("train", "test"),
  weights = NULL,
  type.measure = c("default", "mse", "deviance", "class", "auc", "mae", "C"),
  x_list_test = NULL,
  test_y = NULL,
  nfolds = 10,
  foldid = NULL,
  force = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view.contribution_+3A_x_list">x_list</code></td>
<td>
<p>a list of <code>x</code> matrices with same number of rows
<code>nobs</code></p>
</td></tr>
<tr><td><code id="view.contribution_+3A_y">y</code></td>
<td>
<p>the quantitative response with length equal to <code>nobs</code>, the
(same) number of rows in each <code>x</code> matrix</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link
function to be used in the model. This is the result of a call to
a family function. Default is <a href="stats.html#topic+family">stats::gaussian</a>. (See
<a href="stats.html#topic+family">stats::family</a> for details on family functions.)</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_rho">rho</code></td>
<td>
<p>the weight on the agreement penalty, default 0. <code>rho=0</code>
is a form of early fusion, and <code>rho=1</code> is a form of late fusion.
We recommend trying a few values of <code>rho</code> including 0, 0.1, 0.25,
0.5, and 1 first; sometimes <code>rho</code> larger than 1 can also be
helpful.</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code> stored
on the CV <code>object</code>. Alternatively <code>s="lambda.min"</code> can be used. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used. (For historical reasons we use the symbol 's' rather than 'lambda' to
reference this parameter)</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_eval_data">eval_data</code></td>
<td>
<p>If <code>train</code>, we evaluate the contribution of data views based on training data
using cross validation error; if <code>test</code>, we evaluate the contribution of data views based on test data.
Default is <code>train</code>. If set to <code>test</code>, users need to provide the test data, i.e.
<code>x_list_test</code> and <code>y_test</code>.</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_weights">weights</code></td>
<td>
<p>Observation weights; defaults to 1 per observation</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_type.measure">type.measure</code></td>
<td>
<p>loss to use for cross-validation. Currently
five options, not all available for all models. The default is
<code>type.measure="deviance"</code>, which uses squared-error for gaussian
models (a.k.a <code>type.measure="mse"</code> there), deviance for logistic
and poisson regression, and partial-likelihood for the Cox model.
<code>type.measure="class"</code> applies to binomial and multinomial
logistic regression only, and gives misclassification error.
<code>type.measure="auc"</code> is for two-class logistic regression only,
and gives area under the ROC curve. <code>type.measure="mse"</code> or
<code>type.measure="mae"</code> (mean absolute error) can be used by all
models except the <code>"cox"</code>; they measure the deviation from the
fitted mean to the response.  <code>type.measure="C"</code> is Harrel's
concordance measure, only available for <code>cox</code> models.</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_x_list_test">x_list_test</code></td>
<td>
<p>A list of <code>x</code> matrices in the test data for evaluation.</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_test_y">test_y</code></td>
<td>
<p>The quantitative response in the test data with length equal to the
number of rows in each <code>x</code> matrix of the test data.</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds - default is 10. Although <code>nfolds</code>
can be as large as the sample size (leave-one-out CV), it is not
recommended for large datasets. Smallest value allowable is
<code>nfolds=3</code></p>
</td></tr>
<tr><td><code id="view.contribution_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,
<code>nfold</code> can be missing.</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_force">force</code></td>
<td>
<p>If <code>NULL</code>, the data view contribution is benchmarked by the null model.
If users want to benchmark by the model fit on a specified list of data views, <code>force</code> needs to
be set to this list of benchmarking data views, i.e. a list of <code>x</code> matrices. The function then
evaluates the marginal contribution of each additional data, i.e. the data views in <code>x_list</code> but not in
<code>force</code>, on top of the benchmarking views.</p>
</td></tr>
<tr><td><code id="view.contribution_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>multiview</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame consisting of the view, error metric, and percentage improvement.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(3)
# Simulate data based on the factor model
x = matrix(rnorm(200*20), 200, 20)
z = matrix(rnorm(200*20), 200, 20)
w = matrix(rnorm(200*20), 200, 20)
U = matrix(rep(0, 200*10), 200, 10) # latent factors
for (m in seq(10)){
    u = rnorm(200)
    x[, m] = x[, m] + u
    z[, m] = z[, m] + u
    w[, m] = w[, m] + u
    U[, m] = U[, m] + u}
beta_U = c(rep(2, 5),rep(-2, 5))
y = U %*% beta_U + 3 * rnorm(100)

# Split training and test sets
smp_size_train = floor(0.9 * nrow(x))
train_ind = sort(sample(seq_len(nrow(x)), size = smp_size_train))
test_ind = setdiff(seq_len(nrow(x)), train_ind)
train_X = scale(x[train_ind, ])
test_X = scale(x[test_ind, ])
train_Z &lt;- scale(z[train_ind, ])
test_Z &lt;- scale(z[test_ind, ])
train_W &lt;- scale(w[train_ind, ])
test_W &lt;- scale(w[test_ind, ])
train_y &lt;- y[train_ind, ]
test_y &lt;- y[test_ind, ]
foldid = sample(rep_len(1:10, dim(train_X)[1]))

# Benchmarked by the null model:
rho = 0.3
view.contribution(x_list=list(x=train_X,z=train_Z), train_y, rho = rho,
                  eval_data = 'train', family = gaussian())
view.contribution(x_list=list(x=train_X,z=train_Z), train_y, rho = rho,
                  eval_data = 'test', family = gaussian(),
                  x_list_test=list(x=test_X,z=test_Z), test_y=test_y)

# Force option -- benchmarked by the model train on a specified list of data views:
view.contribution(x_list=list(x=train_X,z=train_Z,w=train_W), train_y, rho = rho,
                  eval_data = 'train', family = gaussian(), force=list(x=train_X))

</code></pre>

<hr>
<h2 id='weighted_mean_sd'>Helper function to compute weighted mean and standard deviation</h2><span id='topic+weighted_mean_sd'></span>

<h3>Description</h3>

<p>Helper function to compute weighted mean and standard deviation.
Deals gracefully whether x is sparse matrix or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_mean_sd(x, weights = rep(1, nrow(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_mean_sd_+3A_x">x</code></td>
<td>
<p>Observation matrix.</p>
</td></tr>
<tr><td><code id="weighted_mean_sd_+3A_weights">weights</code></td>
<td>
<p>Optional weight vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components.
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>vector of weighted means of columns of x</p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>vector of weighted standard deviations of columns of x</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
