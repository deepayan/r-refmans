<!DOCTYPE html><html><head><title>Help for package wrapr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wrapr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wrapr-package'><p>wrapr: Wrap R Tools for Debugging and Parametric Programming</p></a></li>
<li><a href='#+5B.Unpacker'><p>Prepare for unpack or bind values into the calling environment.</p></a></li>
<li><a href='#+5B+26lt+3B-.Unpacker'><p>Unpack or bind values into the calling environment.</p></a></li>
<li><a href='#+25+26lt+3Bs+25'><p>Dot substitution string interpolation.</p></a></li>
<li><a href='#+25c+25'><p>Inline list/array concatenate.</p></a></li>
<li><a href='#+25dot+25'><p>Inline dot product.</p></a></li>
<li><a href='#+25in_block+25'><p>Inline let-block notation.</p></a></li>
<li><a href='#+25p+25'><p>Inline character paste0.</p></a></li>
<li><a href='#+25qc+25'><p>Inline quoting list/array concatenate.</p></a></li>
<li><a href='#+25s+26gt+3B+25'><p>Dot substitution string interpolation.</p></a></li>
<li><a href='#add_name_column'><p>Add list name as a column to a list of data.frames.</p></a></li>
<li><a href='#apply_left'><p>S3 dispatch on class of pipe_left_arg.</p></a></li>
<li><a href='#apply_left_default'><p>S3 dispatch on class of pipe_left_arg.</p></a></li>
<li><a href='#apply_left.default'><p>S3 dispatch on class of pipe_left_arg.</p></a></li>
<li><a href='#apply_right'><p>S3 dispatch on class of pipe_right_argument.</p></a></li>
<li><a href='#apply_right_S4'><p>S4 dispatch method for apply_right.</p></a></li>
<li><a href='#apply_right.default'><p>Default apply_right implementation.</p></a></li>
<li><a href='#as_named_list'><p>Capture named objects as a named list.</p></a></li>
<li><a href='#bc'><p>Blank Concatenate. Parse argument as a vector of values allowing &quot;blank separators&quot;.</p></a></li>
<li><a href='#bquote_call'><p>Treat call argument as bquoted-values.</p></a></li>
<li><a href='#bquote_call_args'><p>Treat ... argument as bquoted-values.</p></a></li>
<li><a href='#bquote_function'><p>Adapt a function to use bquote on its arguments.</p></a></li>
<li><a href='#build_frame'><p>Build a data.frame from the user's description.</p></a></li>
<li><a href='#buildNameCallback'><p>Build a custom writeback function that writes state into a user named variable.</p></a></li>
<li><a href='#check_equiv_frames'><p>Check two data.frames are equivalent after sorting columns and rows.</p></a></li>
<li><a href='#checkColsFormUniqueKeys'><p>Check that a set of columns form unique keys.</p></a></li>
<li><a href='#clean_fit_glm'><p>Fit a stats::glm without carying back large structures.</p></a></li>
<li><a href='#clean_fit_lm'><p>Fit a stats::lm without carying back large structures.</p></a></li>
<li><a href='#coalesce'><p>Coalesce values (NULL/NA on left replaced by values on the right).</p></a></li>
<li><a href='#DebugFn'><p>Capture arguments of exception throwing function call for later debugging.</p></a></li>
<li><a href='#DebugFnE'><p>Capture arguments and environment of exception throwing function call for later debugging.</p></a></li>
<li><a href='#DebugFnW'><p>Wrap a function for debugging.</p></a></li>
<li><a href='#DebugFnWE'><p>Wrap function to capture arguments and environment of exception throwing function call for later debugging.</p></a></li>
<li><a href='#DebugPrintFn'><p>Capture arguments of exception throwing function call for later debugging.</p></a></li>
<li><a href='#DebugPrintFnE'><p>Capture arguments and environment of exception throwing function call for later debugging.</p></a></li>
<li><a href='#defineLambda'><p>Define lambda function building function.</p></a></li>
<li><a href='#dot_arrow'><p>Pipe operator (&quot;dot arrow&quot;, &quot;dot pipe&quot; or &quot;dot arrow pipe&quot;).</p></a></li>
<li><a href='#draw_frame'><p>Render a simple data.frame in build_frame format.</p></a></li>
<li><a href='#draw_framec'><p>Render a simple data.frame in qchar_frame format.</p></a></li>
<li><a href='#evalb'><p>Near <code>eval(bquote(expr))</code> shortcut.</p></a></li>
<li><a href='#execute_parallel'><p>Execute f in parallel partitioned by partition_column.</p></a></li>
<li><a href='#f.'><p>Build an anonymous function of dot.</p></a></li>
<li><a href='#grab_assignments_from_dots'><p>Re-write captured <code>...</code> arguments as assignments.</p></a></li>
<li><a href='#grepdf'><p>Grep for column names from a <code>data.frame</code></p></a></li>
<li><a href='#grepv'><p>Return a vector of matches.</p></a></li>
<li><a href='#has_no_dup_rows'><p>Check for duplicate rows.</p></a></li>
<li><a href='#invert_perm'><p>Invert a permutation.</p></a></li>
<li><a href='#lambda'><p>Build an anonymous function.</p></a></li>
<li><a href='#lapplym'><p>Memoizing wrapper for lapply.</p></a></li>
<li><a href='#let'><p>Execute expr with name substitutions specified in alias.</p></a></li>
<li><a href='#makeFunction_se'><p>Build an anonymous function.</p></a></li>
<li><a href='#map_to_char'><p>format a map.</p></a></li>
<li><a href='#map_upper'><p>Map up-cased symbol names to referenced values if those values are string scalars (else throw).</p></a></li>
<li><a href='#mapsyms'><p>Map symbol names to referenced values if those values are string scalars (else throw).</p></a></li>
<li><a href='#match_order'><p>Match one order to another.</p></a></li>
<li><a href='#mk_formula'><p>Construct a formula.</p></a></li>
<li><a href='#mk_tmp_name_source'><p>Produce a temp name generator with a given prefix.</p></a></li>
<li><a href='#named_map_builder'><p>Named map builder.</p></a></li>
<li><a href='#orderv'><p>Order by a list of vectors.</p></a></li>
<li><a href='#pack'><p>Pack values into a named list.</p></a></li>
<li><a href='#parLapplyLBm'><p>Memoizing wrapper for parLapplyLB</p></a></li>
<li><a href='#partition_tables'><p>Partition as set of tables into a list.</p></a></li>
<li><a href='#pipe_impl'><p>Pipe dispatch implementation.</p></a></li>
<li><a href='#psagg'><p>Pseudo aggregator.</p></a></li>
<li><a href='#qae'><p>Quote assignment expressions (name = expr, name := expr, name %:=% expr).</p></a></li>
<li><a href='#qc'><p>Quoting version of c() array concatenate.</p></a></li>
<li><a href='#qchar_frame'><p>Build a quoted data.frame.</p></a></li>
<li><a href='#qe'><p>Quote expressions.</p></a></li>
<li><a href='#qs'><p>Quote argument as a string.</p></a></li>
<li><a href='#reduceexpand'><p>Use function to reduce or expand arguments.</p></a></li>
<li><a href='#restrictToNameAssignments'><p>Restrict an alias mapping list to things that look like name assignments</p></a></li>
<li><a href='#returnCapture'><p>Return an error to a file, environment (no names) or callback</p></a></li>
<li><a href='#seqi'><p>Increasing whole-number sequence.</p></a></li>
<li><a href='#si'><p>Dot substitution string interpolation.</p></a></li>
<li><a href='#sinterp'><p>Dot substitution string interpolation.</p></a></li>
<li><a href='#sortv'><p>Sort a data.frame.</p></a></li>
<li><a href='#split_at_brace_pairs'><p>Split strings at -pairs.</p></a></li>
<li><a href='#stop_if_dot_args'><p>Stop with message if dot_args is a non-trivial list.</p></a></li>
<li><a href='#strsplit_capture'><p>Split a string, keeping separator regions</p></a></li>
<li><a href='#sx'><p>String eXplode. Parse argument as a vector of string allowing &quot;blank separators&quot;.</p></a></li>
<li><a href='#to'><p>Unpack or bind values by names into the calling environment, eager eval (no-dot) variation.</p></a></li>
<li><a href='#uniques'><p>Strict version of unique (without ...).</p></a></li>
<li><a href='#unpack'><p>Unpack or bind values by names into the calling environment.</p></a></li>
<li><a href='#UnpackerF'><p>Create a value unpacking object (function version).</p></a></li>
<li><a href='#UnpackerP'><p>Create a value unpacking object (eager pipe version).</p></a></li>
<li><a href='#vapplym'><p>Memoizing wrapper for vapply.</p></a></li>
<li><a href='#VectorizeM'><p>Memoizing wrapper to base::Vectorize()</p></a></li>
<li><a href='#view'><p>Invoke a spreadsheet like viewer when appropriate.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wrap R Tools for Debugging and Parametric Programming</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/WinVector/wrapr">https://github.com/WinVector/wrapr</a>,
<a href="https://winvector.github.io/wrapr/">https://winvector.github.io/wrapr/</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Mount &lt;jmount@win-vector.com&gt;</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/WinVector/wrapr/issues">https://github.com/WinVector/wrapr/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for writing and debugging R code. Provides: 
    '%.&gt;%' dot-pipe (an 'S3' configurable pipe), unpack/to (R style multiple assignment/return),
    'build_frame()'/'draw_frame()' ('data.frame' example tools),
    'qc()' (quoting concatenate), 
    ':=' (named map builder), 'let()' (converts non-standard evaluation interfaces to parametric standard
    evaluation interfaces, inspired by 'gtools::strmacro()' and 'base::bquote()'), and more.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, methods, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>parallel, knitr, graphics, rmarkdown, R.rsp, tinytest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 17:10:13 UTC; johnmount</td>
</tr>
<tr>
<td>Author:</td>
<td>John Mount [aut, cre],
  Nina Zumel [aut],
  Win-Vector LLC [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wrapr-package'>wrapr: Wrap R Tools for Debugging and Parametric Programming</h2><span id='topic+wrapr'></span><span id='topic+wrapr-package'></span>

<h3>Description</h3>

<p><code>wrapr</code>: Wrap R Functions for Debugging and Parametric Programming
</p>
<p>Provides <code>DebugFnW()</code> to capture function context on error for
debugging, and <code>let()</code> which converts non-standard evaluation interfaces to
parametric standard evaluation interfaces.
<code>DebugFnW()</code> captures the calling function and arguments prior to the
call causing the exception, while
the classic <code>options(error=dump.frames)</code> form captures at the
moment of the exception
itself (thus function arguments may not be at their starting values).
<code>let()</code> rebinds (possibly unbound) names to names.
</p>
<p>For more information:
</p>

<ul>
<li> <p><code>vignette('DebugFnW', package='wrapr')</code>
</p>
</li>
<li> <p><code>vignette('let', package='wrapr')</code>
</p>
</li>
<li> <p><code>vignette(package='wrapr')</code>
</p>
</li>
<li><p> Website: <a href="https://github.com/WinVector/wrapr">https://github.com/WinVector/wrapr</a>
</p>
</li>
<li> <p><code>let</code> video: <a href="https://youtu.be/iKLGxzzm9Hk?list=PLAKBwakacHbQp_Z66asDnjn-0qttTO-o9">https://youtu.be/iKLGxzzm9Hk?list=PLAKBwakacHbQp_Z66asDnjn-0qttTO-o9</a>
</p>
</li>
<li><p> Debug wrapper video: <a href="https://youtu.be/zFEC9-1XSN8?list=PLAKBwakacHbQT51nPHex1on3YNCCmggZA">https://youtu.be/zFEC9-1XSN8?list=PLAKBwakacHbQT51nPHex1on3YNCCmggZA</a>.</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Mount <a href="mailto:jmount@win-vector.com">jmount@win-vector.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Nina Zumel <a href="mailto:nzumel@win-vector.com">nzumel@win-vector.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p>  Win-Vector LLC [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/WinVector/wrapr">https://github.com/WinVector/wrapr</a>
</p>
</li>
<li> <p><a href="https://winvector.github.io/wrapr/">https://winvector.github.io/wrapr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/WinVector/wrapr/issues">https://github.com/WinVector/wrapr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.Unpacker'>Prepare for unpack or bind values into the calling environment.</h2><span id='topic++5B.Unpacker'></span>

<h3>Description</h3>

<p>Prepare for unpack or bind values into the calling environment.  This makes pipe to behavior very
close to assign to behavior for the Unpacker class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Unpacker'
wrapr_private_self[...]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.Unpacker_+3A_wrapr_private_self">wrapr_private_self</code></td>
<td>
<p>object implementing the feature, wrapr::unpack</p>
</td></tr>
<tr><td><code id="+2B5B.Unpacker_+3A_...">...</code></td>
<td>
<p>names of to unpack to (can be escaped with bquote <code>.()</code> notation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prepared unpacking object
</p>

<hr>
<h2 id='+5B+26lt+3B-.Unpacker'>Unpack or bind values into the calling environment.</h2><span id='topic++5B+3C-.Unpacker'></span>

<h3>Description</h3>

<p>Unpacks or binds values into the calling environment. Uses <code>bquote</code> escaping.
NULL is a special case that is unpacked to all targets. NA targets are skipped.
All non-NA target names must be unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'Unpacker'
wrapr_private_self[...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B26lt+2B3B-.Unpacker_+3A_wrapr_private_self">wrapr_private_self</code></td>
<td>
<p>object implementing the feature, wrapr::unpack</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.Unpacker_+3A_...">...</code></td>
<td>
<p>names of to unpack to (can be escaped with bquote <code>.()</code> notation).</p>
</td></tr>
<tr><td><code id="+2B5B+2B26lt+2B3B-.Unpacker_+3A_value">value</code></td>
<td>
<p>list to unpack into values, must have a number of entries equal to number of <code>...</code> arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: when using <code>[]&lt;-</code> notation, a reference to the unpacker object is written into the unpacking environment as a side-effect
of the implied array assignment. <code>:=</code> assigment does not have this side-effect.
Array-assign form can not use the names: <code>.</code>, <code>wrapr_private_self</code>, <code>value</code>, or the name of the unpacker itself.
For more details please see here <a href="https://win-vector.com/2020/01/20/unpack-your-values-in-r/">https://win-vector.com/2020/01/20/unpack-your-values-in-r/</a>.
</p>
<p>Related work includes <code>Python</code> tuple unpacking, <code>zeallot</code>'s arrow, and <code>vadr::bind</code>.
</p>


<h3>Value</h3>

<p>wrapr_private_self
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# named unpacking
# looks like assignment: DESTINATION = NAME_VALUE_USING
d &lt;- data.frame(x = 1:2,
                g=c('test', 'train'),
                stringsAsFactors = FALSE)
to[train_set = train, test_set = test] := split(d, d$g)
# train_set and test_set now correctly split
print(train_set)
print(test_set)
rm(list = c('train_set', 'test_set'))

# named unpacking NEWNAME = OLDNAME implicit form
# values are matched by name, not index
to[train, test] := split(d, d$g)
print(train)
print(test)
rm(list = c('train', 'test'))

# bquote example
train_col_name &lt;- 'train'
test_col_name &lt;- 'test'
to[train = .(train_col_name), test = .(test_col_name)] := split(d, d$g)
print(train)
print(test)
rm(list = c('train', 'test'))

</code></pre>

<hr>
<h2 id='+25+26lt+3Bs+25'>Dot substitution string interpolation.</h2><span id='topic++25+3Cs+25'></span>

<h3>Description</h3>

<p>String interpolation using <code>bquote</code>-stype .() notation. Pure R, no C/C++ code called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>str %&lt;s% envir
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26lt+2B3Bs+2B25_+3A_str">str</code></td>
<td>
<p>charater string to be substituted into</p>
</td></tr>
<tr><td><code id="+2B25+2B26lt+2B3Bs+2B25_+3A_envir">envir</code></td>
<td>
<p>environemnt to look for values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also
<a href="https://CRAN.R-project.org/package=R.utils">https://CRAN.R-project.org/package=R.utils</a>,
<a href="https://CRAN.R-project.org/package=rprintf">https://CRAN.R-project.org/package=rprintf</a>,
and <a href="https://CRAN.R-project.org/package=glue">https://CRAN.R-project.org/package=glue</a>.
</p>


<h3>Value</h3>

<p>modified strings
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strsplit_capture">strsplit_capture</a></code>, <code><a href="#topic+si">si</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
"x is .(x)" %&lt;s% list(x = 7)


</code></pre>

<hr>
<h2 id='+25c+25'>Inline list/array concatenate.</h2><span id='topic++25c+25'></span>

<h3>Description</h3>

<p>Inline list/array concatenate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %c% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25c+2B25_+3A_e1">e1</code></td>
<td>
<p>first, or left argument.</p>
</td></tr>
<tr><td><code id="+2B25c+2B25_+3A_e2">e2</code></td>
<td>
<p>second, or right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>c(e1, c2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:2 %c% 5:6

c("a", "b") %c% "d"

</code></pre>

<hr>
<h2 id='+25dot+25'>Inline dot product.</h2><span id='topic++25dot+25'></span>

<h3>Description</h3>

<p>Inline dot product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %dot% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25dot+2B25_+3A_e1">e1</code></td>
<td>
<p>first, or left argument.</p>
</td></tr>
<tr><td><code id="+2B25dot+2B25_+3A_e2">e2</code></td>
<td>
<p>second, or right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>c(e1, c2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
c(1,2) %dot% c(3, 5)


</code></pre>

<hr>
<h2 id='+25in_block+25'>Inline let-block notation.</h2><span id='topic++25in_block+25'></span>

<h3>Description</h3>

<p>Inline version of <code>let</code>-block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a %in_block% b
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25in_block+2B25_+3A_a">a</code></td>
<td>
<p>(left argument) named character vector with target names as names, and replacement names as values.</p>
</td></tr>
<tr><td><code id="+2B25in_block+2B25_+3A_b">b</code></td>
<td>
<p>(right argument) expression or block to evaluate under let substitution rules.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>evaluated block.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+let">let</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(
  Sepal_Length=c(5.8,5.7),
  Sepal_Width=c(4.0,4.4),
  Species='setosa')

# let-block notation
let(
  qc(
    AREA_COL = Sepal_area,
    LENGTH_COL = Sepal_Length,
    WIDTH_COL = Sepal_Width
  ),
  d %.&gt;%
    transform(., AREA_COL = LENGTH_COL * WIDTH_COL)
)

# %in_block% notation
qc(
  AREA_COL = Sepal_area,
  LENGTH_COL = Sepal_Length,
  WIDTH_COL = Sepal_Width
) %in_block% {
  d %.&gt;%
    transform(., AREA_COL = LENGTH_COL * WIDTH_COL)
}

# Note: in packages can make assignment such as:
#   AREA_COL &lt;- LENGTH_COL &lt;- WIDTH_COL &lt;- NULL
# prior to code so targets don't look like unbound names.

</code></pre>

<hr>
<h2 id='+25p+25'>Inline character paste0.</h2><span id='topic++25p+25'></span>

<h3>Description</h3>

<p>Inline character paste0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %p% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25p+2B25_+3A_e1">e1</code></td>
<td>
<p>first, or left argument.</p>
</td></tr>
<tr><td><code id="+2B25p+2B25_+3A_e2">e2</code></td>
<td>
<p>second, or right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>c(e1, c2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
"a" %p% "b"

c("a", "b") %p% "_d"

</code></pre>

<hr>
<h2 id='+25qc+25'>Inline quoting list/array concatenate.</h2><span id='topic++25qc+25'></span>

<h3>Description</h3>

<p>Inline quoting list/array concatenate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %qc% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25qc+2B25_+3A_e1">e1</code></td>
<td>
<p>first, or left argument.</p>
</td></tr>
<tr><td><code id="+2B25qc+2B25_+3A_e2">e2</code></td>
<td>
<p>second, or right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>qc(e1, c2)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:2 %qc% 5:6

c("a", "b") %qc% d

a %qc% b %qc% c

</code></pre>

<hr>
<h2 id='+25s+26gt+3B+25'>Dot substitution string interpolation.</h2><span id='topic++25s+3E+25'></span>

<h3>Description</h3>

<p>String interpolation using <code>bquote</code>-stype .() notation. Pure R, no C/C++ code called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>envir %s&gt;% str
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25s+2B26gt+2B3B+2B25_+3A_envir">envir</code></td>
<td>
<p>environemnt to look for values</p>
</td></tr>
<tr><td><code id="+2B25s+2B26gt+2B3B+2B25_+3A_str">str</code></td>
<td>
<p>charater string to be substituted into</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also
<a href="https://CRAN.R-project.org/package=R.utils">https://CRAN.R-project.org/package=R.utils</a>,
<a href="https://CRAN.R-project.org/package=rprintf">https://CRAN.R-project.org/package=rprintf</a>,
and <a href="https://CRAN.R-project.org/package=glue">https://CRAN.R-project.org/package=glue</a>.
</p>


<h3>Value</h3>

<p>modified strings
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strsplit_capture">strsplit_capture</a></code>, <code><a href="#topic+si">si</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
list(x = 7) %s&gt;% "x is .(x)"


</code></pre>

<hr>
<h2 id='add_name_column'>Add list name as a column to a list of data.frames.</h2><span id='topic+add_name_column'></span>

<h3>Description</h3>

<p>Add list name as a column to a list of data.frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_name_column(dlist, destinationColumn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_name_column_+3A_dlist">dlist</code></td>
<td>
<p>named list of data.frames</p>
</td></tr>
<tr><td><code id="add_name_column_+3A_destinationcolumn">destinationColumn</code></td>
<td>
<p>character, name of new column to add</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of data frames, each of which as the new destinationColumn.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dlist &lt;- list(a = data.frame(x = 1), b = data.frame(x = 2))
add_name_column(dlist, 'name')

</code></pre>

<hr>
<h2 id='apply_left'>S3 dispatch on class of pipe_left_arg.</h2><span id='topic+apply_left'></span>

<h3>Description</h3>

<p>For formal documentation please see <a href="https://github.com/WinVector/wrapr/blob/master/extras/wrapr_pipe.pdf">https://github.com/WinVector/wrapr/blob/master/extras/wrapr_pipe.pdf</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_left(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_left_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument.</p>
</td></tr>
<tr><td><code id="apply_left_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>substitute(pipe_right_arg) argument.</p>
</td></tr>
<tr><td><code id="apply_left_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in.</p>
</td></tr>
<tr><td><code id="apply_left_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_left_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_left_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_left.default">apply_left.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
apply_left.character &lt;- function(pipe_left_arg,
                                 pipe_right_arg,
                                 pipe_environment,
                                 left_arg_name,
                                 pipe_string,
                                 right_arg_name) {
  if(is.language(pipe_right_arg)) {
    wrapr::apply_left_default(pipe_left_arg,
                              pipe_right_arg,
                              pipe_environment,
                              left_arg_name,
                              pipe_string,
                              right_arg_name)
  } else {
    paste(pipe_left_arg, pipe_right_arg)
  }
}
setMethod(
  wrapr::apply_right_S4,
  signature = c(pipe_left_arg = "character", pipe_right_arg = "character"),
  function(pipe_left_arg,
           pipe_right_arg,
           pipe_environment,
           left_arg_name,
           pipe_string,
           right_arg_name) {
    paste(pipe_left_arg, pipe_right_arg)
  })

"a" %.&gt;% 5 %.&gt;% 7

"a" %.&gt;% toupper(.)

q &lt;- "z"
"a" %.&gt;% q


</code></pre>

<hr>
<h2 id='apply_left_default'>S3 dispatch on class of pipe_left_arg.</h2><span id='topic+apply_left_default'></span>

<h3>Description</h3>

<p>Place evaluation of left argument in <code>.</code> and then evaluate right argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_left_default(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_left_default_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument</p>
</td></tr>
<tr><td><code id="apply_left_default_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>substitute(pipe_right_arg) argument</p>
</td></tr>
<tr><td><code id="apply_left_default_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
<tr><td><code id="apply_left_default_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_left_default_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_left_default_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_left">apply_left</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
5 %.&gt;% sin(.)

</code></pre>

<hr>
<h2 id='apply_left.default'>S3 dispatch on class of pipe_left_arg.</h2><span id='topic+apply_left.default'></span>

<h3>Description</h3>

<p>Place evaluation of left argument in <code>.</code> and then evaluate right argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
apply_left(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_left.default_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument</p>
</td></tr>
<tr><td><code id="apply_left.default_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>substitute(pipe_right_arg) argument</p>
</td></tr>
<tr><td><code id="apply_left.default_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
<tr><td><code id="apply_left.default_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_left.default_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_left.default_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_left">apply_left</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
5 %.&gt;% sin(.)

</code></pre>

<hr>
<h2 id='apply_right'>S3 dispatch on class of pipe_right_argument.</h2><span id='topic+apply_right'></span>

<h3>Description</h3>

<p>Triggered if right hand side of pipe stage was a name that does not resolve to a function.
For formal documentation please see <a href="https://github.com/WinVector/wrapr/blob/master/extras/wrapr_pipe.pdf">https://github.com/WinVector/wrapr/blob/master/extras/wrapr_pipe.pdf</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_right(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_right_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument</p>
</td></tr>
<tr><td><code id="apply_right_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>right argument</p>
</td></tr>
<tr><td><code id="apply_right_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
<tr><td><code id="apply_right_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_right_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_right_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_left">apply_left</a></code>, <code><a href="#topic+apply_right_S4">apply_right_S4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate a function pointer
apply_right.list &lt;- function(pipe_left_arg,
                             pipe_right_arg,
                             pipe_environment,
                             left_arg_name,
                             pipe_string,
                             right_arg_name) {
  pipe_right_arg$f(pipe_left_arg)
}

f &lt;- list(f=sin)
2 %.&gt;% f
f$f &lt;- cos
2 %.&gt;% f

</code></pre>

<hr>
<h2 id='apply_right_S4'>S4 dispatch method for apply_right.</h2><span id='topic+apply_right_S4'></span>

<h3>Description</h3>

<p>Intended to be generic on first two arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_right_S4(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_right_S4_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument</p>
</td></tr>
<tr><td><code id="apply_right_S4_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>pipe_right_arg argument</p>
</td></tr>
<tr><td><code id="apply_right_S4_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
<tr><td><code id="apply_right_S4_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_right_S4_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_right_S4_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_left">apply_left</a></code>, <code><a href="#topic+apply_right">apply_right</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- data.frame(x = 1)
b &lt;- data.frame(x = 2)

# a %.&gt;% b # will (intentionally) throw

setMethod(
  "apply_right_S4",
  signature("data.frame", "data.frame"),
  function(pipe_left_arg,
           pipe_right_arg,
           pipe_environment,
           left_arg_name,
           pipe_string,
           right_arg_name) {
    rbind(pipe_left_arg, pipe_right_arg)
  })


a %.&gt;% b # should equal data.frame(x = c(1, 2))

</code></pre>

<hr>
<h2 id='apply_right.default'>Default apply_right implementation.</h2><span id='topic+apply_right.default'></span>

<h3>Description</h3>

<p>Default apply_right implementation: S4 dispatch to apply_right_S4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
apply_right(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_right.default_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument</p>
</td></tr>
<tr><td><code id="apply_right.default_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>pipe_right_arg argument</p>
</td></tr>
<tr><td><code id="apply_right.default_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
<tr><td><code id="apply_right.default_+3A_left_arg_name">left_arg_name</code></td>
<td>
<p>name, if not NULL name of left argument.</p>
</td></tr>
<tr><td><code id="apply_right.default_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
<tr><td><code id="apply_right.default_+3A_right_arg_name">right_arg_name</code></td>
<td>
<p>name, if not NULL name of right argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apply_left">apply_left</a></code>, <code><a href="#topic+apply_right">apply_right</a></code>, <code><a href="#topic+apply_right_S4">apply_right_S4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate a function pointer
apply_right.list &lt;- function(pipe_left_arg,
                             pipe_right_arg,
                             pipe_environment,
                             left_arg_name,
                             pipe_string,
                             right_arg_name) {
  pipe_right_arg$f(pipe_left_arg)
}

f &lt;- list(f=sin)
2 %.&gt;% f
f$f &lt;- cos
2 %.&gt;% f

</code></pre>

<hr>
<h2 id='as_named_list'>Capture named objects as a named list.</h2><span id='topic+as_named_list'></span>

<h3>Description</h3>

<p>Build a named list from a sequence of named arguments of the form NAME, or NAME = VALUE.
This is intended to shorten forms such as <code>list(a = a, b = b)</code> to <code>as_named_list(a, b)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_named_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_named_list_+3A_...">...</code></td>
<td>
<p>argument names (must be names, not strings or values) plus possible assigned values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list mapping argument names to argument values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- data.frame(x = 1)
b &lt;- 2

str(as_named_list(a, b))

as_named_list(a, x = b, c = 1 + 1)

# an example application for this function is managing saving and
# loading values into the workspace.
if(FALSE) {
  # remotes::install_github("WinVector/wrapr")
  library(wrapr)

  a &lt;- 5
  b &lt;- 7
  do_not_want &lt;- 13

  # save the elements of our workspace we want
  saveRDS(as_named_list(a, b), 'example_data.RDS')

  # clear values out of our workspace for the example
  rm(list = ls())
  ls()
  # notice workspace environemnt now empty

  # read back while documenting what we expect to
  # read in
  unpack[a, b] &lt;- readRDS('example_data.RDS')

  # confirm what we have, the extra unpack is a side
  # effect of the []&lt;- notation. To avoid this instead
  # use one of:
  #   unpack(readRDS('example_data.RDS'), a, b)
  #   readRDS('example_data.RDS') %.&gt;% unpack(., a, b)
  #   readRDS('example_data.RDS') %.&gt;% unpack[a, b]
  ls()
  # notice do_not_want is not present

  print(a)

  print(b)
}

</code></pre>

<hr>
<h2 id='bc'>Blank Concatenate. Parse argument as a vector of values allowing &quot;blank separators&quot;.</h2><span id='topic+bc'></span>

<h3>Description</h3>

<p>Separates string data on whitespace and separating symbols into an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc(s, ..., sep_symbols = ",|", strict = TRUE, convert = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc_+3A_s">s</code></td>
<td>
<p>string to parse</p>
</td></tr>
<tr><td><code id="bc_+3A_...">...</code></td>
<td>
<p>force later arguments to be set by name</p>
</td></tr>
<tr><td><code id="bc_+3A_sep_symbols">sep_symbols</code></td>
<td>
<p>characters to consider separators</p>
</td></tr>
<tr><td><code id="bc_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE throw exception on confusing input</p>
</td></tr>
<tr><td><code id="bc_+3A_convert">convert</code></td>
<td>
<p>logical, if TRUE try to convert from string type to other types</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can throw exception on lack of explicit value separators, example: <code>bc('"a""b"')</code> and  non-matching portions.
Whitespace is normalized to spaces. Attempts to split on obvious number format boundaries.
Suggested by Emil Erik Pula Bellamy Begtrup-Bright <a href="https://github.com/WinVector/wrapr/issues/12">https://github.com/WinVector/wrapr/issues/12</a>.
</p>


<h3>Value</h3>

<p>vector of values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qc">qc</a></code>, <code><a href="#topic+qe">qe</a></code>, <code><a href="#topic+qae">qae</a></code>, <code><a href="base.html#topic+bquote">bquote</a></code>, <code><a href="#topic+sx">sx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
bc('1 2 "c", d') # returns c("1", "2", "c", "d")
bc('1 2 3') # returns c(1, 2, 3)
bc('1 2 "3"') # returns c("1", "2", "3")
bc('1,2|3.4') # returns c(1, 2, 3.4)
bc('01 02', convert=FALSE) # returns c("01", "02")

</code></pre>

<hr>
<h2 id='bquote_call'>Treat call argument as bquoted-values.</h2><span id='topic+bquote_call'></span>

<h3>Description</h3>

<p>Re-write call to evaluate <code>expr</code> with <code>bquote</code> <code>.()</code> substitution.
Uses convetion that := is considered a alias for =.
Including <code>.(-x)</code> promoting <code>x</code>'s value from character to a name,
which is called &quot;quote negation&quot; (hence the minus-sign).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bquote_call(call, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bquote_call_+3A_call">call</code></td>
<td>
<p>result of match.call()</p>
</td></tr>
<tr><td><code id="bquote_call_+3A_env">env</code></td>
<td>
<p>environment to perform lookups in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>altered call
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bquote_function">bquote_function</a></code>, <code><a href="#topic+bquote_call_args">bquote_call_args</a></code>
</p>

<hr>
<h2 id='bquote_call_args'>Treat ... argument as bquoted-values.</h2><span id='topic+bquote_call_args'></span>

<h3>Description</h3>

<p>bquote_call_args is a helper to allow the user to write functions with bquote-enabled argument substitution.
Uses convetion that := is considered a alias for =.
Re-writes call args to evaluate <code>expr</code> with <code>bquote</code> <code>.()</code> substitution.
Including <code>.(-x)</code> promoting <code>x</code>'s value from character to a name,
which is called &quot;quote negation&quot; (hence the minus-sign).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bquote_call_args(call, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bquote_call_args_+3A_call">call</code></td>
<td>
<p>result of match.call()</p>
</td></tr>
<tr><td><code id="bquote_call_args_+3A_env">env</code></td>
<td>
<p>environment to perform lookups in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>name list of values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bquote_function">bquote_function</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(q, ...) {
  env = parent.frame()
  # match.call() best called in function context.
  captured_call &lt;- match.call()
  captured_args &lt;- bquote_call_args(captured_call, env)
  captured_args
}

z &lt;- "x"
y &lt;- 5
qv &lt;- 3

# equivalent to f(3, x = 5)
f(.(qv), .(z) := .(y))

# equivalent to f(q = 7)
qname &lt;- 'q'
f(.(qname) := 7)


</code></pre>

<hr>
<h2 id='bquote_function'>Adapt a function to use bquote on its arguments.</h2><span id='topic+bquote_function'></span>

<h3>Description</h3>

<p>bquote_function is for adapting a function defined elsewhere for bquote-enabled argument substitution.
Re-write call to evaluate <code>expr</code> with <code>bquote</code> <code>.()</code> substitution.
Uses convetion that := is considered a alias for =.
Including <code>.(-x)</code> promoting <code>x</code>'s value from character to a name,
which is called &quot;quote negation&quot; (hence the minus-sign).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bquote_function(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bquote_function_+3A_fn">fn</code></td>
<td>
<p>function to adapt, must have non-empty formals().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bquote_call_args">bquote_call_args</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if(requireNamespace('graphics', quietly = TRUE)) {
  angle = 1:10
  variable &lt;- as.name("angle")
  plotb &lt;- bquote_function(graphics::plot)
  plotb(x = .(variable), y = sin(.(variable)))
}



f1 &lt;- function(x) { substitute(x) }
f2 &lt;- bquote_function(f1)
arg &lt;- "USER_ARG"
f2(arg)    # returns arg
f2(.(arg)) # returns "USER_ARG" (character)
f2(.(-arg)) # returns USER_ARG (name)


</code></pre>

<hr>
<h2 id='build_frame'>Build a data.frame from the user's description.</h2><span id='topic+build_frame'></span>

<h3>Description</h3>

<p>A convenient way to build a data.frame in legible transposed form.  Position of
first &quot;|&quot; (or other infix operator) determines number of columns
(all other infix operators are aliases for &quot;,&quot;).
Names are de-referenced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_frame(..., cf_eval_environment = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_frame_+3A_...">...</code></td>
<td>
<p>cell names, first infix operator denotes end of header row of column names.</p>
</td></tr>
<tr><td><code id="build_frame_+3A_cf_eval_environment">cf_eval_environment</code></td>
<td>
<p>environment to evaluate names in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_frame">draw_frame</a></code>, <code><a href="#topic+qchar_frame">qchar_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tc_name &lt;- "training"
x &lt;- build_frame(
   "measure",                   tc_name, "validation" |
   "minus binary cross entropy",      5, -7           |
   "accuracy",                      0.8, 0.6          )
print(x)
str(x)
cat(draw_frame(x))

build_frame(
  "x" |
  -1  |
  2   )

</code></pre>

<hr>
<h2 id='buildNameCallback'>Build a custom writeback function that writes state into a user named variable.</h2><span id='topic+buildNameCallback'></span>

<h3>Description</h3>

<p>Build a custom writeback function that writes state into a user named variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildNameCallback(varName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildNameCallback_+3A_varname">varName</code></td>
<td>
<p>character where to write captured state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>writeback function for use with functions such as <code><a href="#topic+DebugFnW">DebugFnW</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# user function
f &lt;- function(i) { (1:10)[[i]] }
# capture last error in variable called "lastError"
writeBack &lt;- buildNameCallback('lastError')
# wrap function with writeBack
df &lt;- DebugFnW(writeBack,f)
# capture error (Note: tryCatch not needed for user code!)
tryCatch(
  df(12),
   error = function(e) { print(e) })
# examine error
str(lastError)
# redo call, perhaps debugging
tryCatch(
 do.call(lastError$fn_name, lastError$args),
   error = function(e) { print(e) })

</code></pre>

<hr>
<h2 id='check_equiv_frames'>Check two data.frames are equivalent after sorting columns and rows.</h2><span id='topic+check_equiv_frames'></span>

<h3>Description</h3>

<p>Confirm two dataframes are equivalent after reordering columns and rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_equiv_frames(d1, d2, ..., tolerance = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_equiv_frames_+3A_d1">d1</code></td>
<td>
<p>data.frame 1</p>
</td></tr>
<tr><td><code id="check_equiv_frames_+3A_d2">d2</code></td>
<td>
<p>data.frame 2</p>
</td></tr>
<tr><td><code id="check_equiv_frames_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="check_equiv_frames_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric comparision tolerance</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if equivalent
</p>

<hr>
<h2 id='checkColsFormUniqueKeys'>Check that a set of columns form unique keys.</h2><span id='topic+checkColsFormUniqueKeys'></span>

<h3>Description</h3>

<p>For local data.frame only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkColsFormUniqueKeys(data, keyColNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkColsFormUniqueKeys_+3A_data">data</code></td>
<td>
<p>data.frame to work with.</p>
</td></tr>
<tr><td><code id="checkColsFormUniqueKeys_+3A_keycolnames">keyColNames</code></td>
<td>
<p>character array of column names to check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if the rows of data are unique addressable by the columns named in keyColNames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(key = c('a','a', 'b'), k2 = c(1 ,2, 2))
checkColsFormUniqueKeys(d, 'key') # should be FALSE
checkColsFormUniqueKeys(d, c('key', 'k2')) # should be TRUE

</code></pre>

<hr>
<h2 id='clean_fit_glm'>Fit a stats::glm without carying back large structures.</h2><span id='topic+clean_fit_glm'></span>

<h3>Description</h3>

<p>Please see <a href="https://win-vector.com/2014/05/30/trimming-the-fat-from-glm-models-in-r/">https://win-vector.com/2014/05/30/trimming-the-fat-from-glm-models-in-r/</a> for discussion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_fit_glm(
  outcome,
  variables,
  data,
  ...,
  family,
  intercept = TRUE,
  outcome_target = NULL,
  outcome_comparator = "==",
  weights = NULL,
  env = baseenv()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_fit_glm_+3A_outcome">outcome</code></td>
<td>
<p>character, name of outcome column.</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_variables">variables</code></td>
<td>
<p>character, names of varaible columns.</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_data">data</code></td>
<td>
<p>data.frame, training data.</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to be used by name</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_family">family</code></td>
<td>
<p>passed to stats::glm()</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_intercept">intercept</code></td>
<td>
<p>logical, if TRUE allow an intercept term.</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_outcome_target">outcome_target</code></td>
<td>
<p>scalar, if not NULL write outcome==outcome_target in formula.</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_outcome_comparator">outcome_comparator</code></td>
<td>
<p>one of &quot;==&quot;, &quot;!=&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, only use of outcome_target is not NULL.</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_weights">weights</code></td>
<td>
<p>passed to stats::glm()</p>
</td></tr>
<tr><td><code id="clean_fit_glm_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(model=model, summary=summary)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mk_data_example &lt;- function(k) {
  data.frame(
    x1 = rep(c("a", "a", "b", "b"), k),
    x2 = rep(c(0, 0, 0, 1), k),
    y = rep(1:4, k),
    yC = rep(c(FALSE, TRUE, TRUE, TRUE), k),
    stringsAsFactors = FALSE)
}

res_glm &lt;- clean_fit_glm("yC", c("x1", "x2"),
                         mk_data_example(1),
                         family = binomial)
length(serialize(res_glm$model, NULL))

res_glm &lt;- clean_fit_glm("yC", c("x1", "x2"),
                         mk_data_example(10000),
                         family = binomial)
length(serialize(res_glm$model, NULL))

predict(res_glm$model,
        newdata = mk_data_example(1),
        type = "response")

</code></pre>

<hr>
<h2 id='clean_fit_lm'>Fit a stats::lm without carying back large structures.</h2><span id='topic+clean_fit_lm'></span>

<h3>Description</h3>

<p>Please see <a href="https://win-vector.com/2014/05/30/trimming-the-fat-from-glm-models-in-r/">https://win-vector.com/2014/05/30/trimming-the-fat-from-glm-models-in-r/</a> for discussion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_fit_lm(
  outcome,
  variables,
  data,
  ...,
  intercept = TRUE,
  weights = NULL,
  env = baseenv()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_fit_lm_+3A_outcome">outcome</code></td>
<td>
<p>character, name of outcome column.</p>
</td></tr>
<tr><td><code id="clean_fit_lm_+3A_variables">variables</code></td>
<td>
<p>character, names of varaible columns.</p>
</td></tr>
<tr><td><code id="clean_fit_lm_+3A_data">data</code></td>
<td>
<p>data.frame, training data.</p>
</td></tr>
<tr><td><code id="clean_fit_lm_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to be used by name</p>
</td></tr>
<tr><td><code id="clean_fit_lm_+3A_intercept">intercept</code></td>
<td>
<p>logical, if TRUE allow an intercept term.</p>
</td></tr>
<tr><td><code id="clean_fit_lm_+3A_weights">weights</code></td>
<td>
<p>passed to stats::glm()</p>
</td></tr>
<tr><td><code id="clean_fit_lm_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(model=model, summary=summary)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mk_data_example &lt;- function(k) {
  data.frame(
    x1 = rep(c("a", "a", "b", "b"), k),
    x2 = rep(c(0, 0, 0, 1), k),
    y = rep(1:4, k),
    yC = rep(c(FALSE, TRUE, TRUE, TRUE), k),
    stringsAsFactors = FALSE)
}

res_lm &lt;- clean_fit_lm("y", c("x1", "x2"),
                       mk_data_example(1))
length(serialize(res_lm$model, NULL))

res_lm &lt;- clean_fit_lm("y", c("x1", "x2"),
                       mk_data_example(10000))
length(serialize(res_lm$model, NULL))

predict(res_lm$model,
        newdata = mk_data_example(1))

</code></pre>

<hr>
<h2 id='coalesce'>Coalesce values (NULL/NA on left replaced by values on the right).</h2><span id='topic+coalesce'></span><span id='topic++25+3F+25'></span>

<h3>Description</h3>

<p>This is a simple &quot;try to take values on the left, but fall back
to the right if they are not available&quot; operator.  It is inspired
by SQL coalesce and the notation is designed to
evoke the idea of testing and the <code>C#</code> <code>??</code> null coalescing operator.
<code>NA</code> and <code>NULL</code> are treated roughly equally: both are
replaced regardless of available replacement value (with some exceptions).
The exceptions are: if the left hand side is a non-zero length vector
we preserve the vector type of the left-hand side and do not assign
any values that vectors can not hold (NULLs and complex structures) and do not
replace with a right argument list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce(coalesce_left_arg, coalesce_right_arg)

coalesce_left_arg %?% coalesce_right_arg
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesce_+3A_coalesce_left_arg">coalesce_left_arg</code></td>
<td>
<p>vector or list.</p>
</td></tr>
<tr><td><code id="coalesce_+3A_coalesce_right_arg">coalesce_right_arg</code></td>
<td>
<p>vector or list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This operator represents a compromise between the desire to replace
length zero structures and NULL/NA values and the desire to preserve
the first argument's structure (vector versus list).  The order of
operations has been chosen to be safe, convenient, and useful.  Length zero
lists are not treated as NULL (which is consistent with R in general).
Note for non-vector operations on conditions we recommend looking into
<code><a href="base.html#topic+Logic">isTRUE</a></code>, which solves some problems even faster
than coalesce style operators.
</p>
<p>When length(coalesce_left_arg)&lt;=0 then
return coalesce_right_arg if length(coalesce_right_arg)&gt;0, otherwise
return coalesce_left_arg.
When length(coalesce_left_arg)&gt;0:
assume coalesce_left_arg is a list or vector and coalesce_right_arg
is a list or vector that is either the same length as coalesce_left_arg
or length 1.  In this case replace NA/NULL elements of coalesce_left_arg
with corresponding elements of coalesce_right_arg (re-cycling coalesce_right_arg
when it is length 1).
</p>


<h3>Value</h3>

<p>coalesce_left_arg with NA elements replaced.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>coalesce_left_arg %?% coalesce_right_arg</code>: coalesce operator
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
c(NA, NA, NA) %?% 5            # returns c(5, 5, 5)
c(1, NA, NA) %?% list(5)       # returns c(1, 5, 5)
c(1, NA, NA) %?% list(list(5)) # returns c(1, NA, NA)
c(1, NA, NA) %?% c(NA, 20, NA) # returns c(1, 20, NA)
NULL %?% list()    # returns NULL
NULL %?% c(1, NA) # returns c(1, NA)
list(1, NULL, NULL) %?% c(3, 4, NA)                         # returns list(1, 4, NA_real_)
list(1, NULL, NULL, NA, NA) %?% list(2, NULL, NA, NULL, NA) # returns list(1, NULL, NA, NULL, NA)
c(1, NA, NA) %?% list(1, 2, list(3)) # returns c(1, 2, NA)
c(1, NA) %?% list(1, NULL)           # returns c(1, NA)
c() %?% list(1, NA, NULL)    # returns list(1, NA, NULL)
c() %?% c(1, NA, 2)          # returns c(1, NA, 2)

</code></pre>

<hr>
<h2 id='DebugFn'>Capture arguments of exception throwing function call for later debugging.</h2><span id='topic+DebugFn'></span>

<h3>Description</h3>

<p>Run fn, save arguments on failure.
Please see: <code>vignette("DebugFnW", package="wrapr")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DebugFn(saveDest, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DebugFn_+3A_savedest">saveDest</code></td>
<td>
<p>where to write captured state (determined by type): NULL random temp file, character temp file, name globalenv() variable, and function triggers callback.</p>
</td></tr>
<tr><td><code id="DebugFn_+3A_fn">fn</code></td>
<td>
<p>function to call</p>
</td></tr>
<tr><td><code id="DebugFn_+3A_...">...</code></td>
<td>
<p>arguments for fn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fn(...) normally, but if fn(...) throws an exception save to saveDest RDS of list r such that do.call(r$fn,r$args) repeats the call to fn with args.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+debugger">dump.frames</a></code>, <code><a href="#topic+DebugFn">DebugFn</a></code>, <code><a href="#topic+DebugFnW">DebugFnW</a></code>,  <code><a href="#topic+DebugFnWE">DebugFnWE</a></code>, <code><a href="#topic+DebugPrintFn">DebugPrintFn</a></code>, <code><a href="#topic+DebugFnE">DebugFnE</a></code>, <code><a href="#topic+DebugPrintFnE">DebugPrintFnE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
saveDest &lt;- paste0(tempfile('debug'),'.RDS')
f &lt;- function(i) { (1:10)[[i]] }
# correct run
DebugFn(saveDest, f, 5)
# now re-run
# capture error on incorrect run
tryCatch(
   DebugFn(saveDest, f, 12),
   error = function(e) { print(e) })
# examine details
situation &lt;- readRDS(saveDest)
str(situation)
# fix and re-run
situation$args[[1]] &lt;- 6
do.call(situation$fn_name,situation$args)
# clean up
file.remove(saveDest)

</code></pre>

<hr>
<h2 id='DebugFnE'>Capture arguments and environment of exception throwing function call for later debugging.</h2><span id='topic+DebugFnE'></span>

<h3>Description</h3>

<p>Run fn, save arguments, and environment on failure.
Please see: <code>vignette("DebugFnW", package="wrapr")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DebugFnE(saveDest, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DebugFnE_+3A_savedest">saveDest</code></td>
<td>
<p>where to write captured state (determined by type): NULL random temp file, character temp file, name globalenv() variable, and function triggers callback.</p>
</td></tr>
<tr><td><code id="DebugFnE_+3A_fn">fn</code></td>
<td>
<p>function to call</p>
</td></tr>
<tr><td><code id="DebugFnE_+3A_...">...</code></td>
<td>
<p>arguments for fn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fn(...) normally, but if fn(...) throws an exception save to saveDest RDS of list r such that do.call(r$fn,r$args) repeats the call to fn with args.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+debugger">dump.frames</a></code>, <code><a href="#topic+DebugFn">DebugFn</a></code>, <code><a href="#topic+DebugFnW">DebugFnW</a></code>,  <code><a href="#topic+DebugFnWE">DebugFnWE</a></code>, <code><a href="#topic+DebugPrintFn">DebugPrintFn</a></code>, <code><a href="#topic+DebugFnE">DebugFnE</a></code>, <code><a href="#topic+DebugPrintFnE">DebugPrintFnE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
saveDest &lt;- paste0(tempfile('debug'),'.RDS')
f &lt;- function(i) { (1:10)[[i]] }
# correct run
DebugFnE(saveDest, f, 5)
# now re-run
# capture error on incorrect run
tryCatch(
   DebugFnE(saveDest, f, 12),
   error = function(e) { print(e) })
# examine details
situation &lt;- readRDS(saveDest)
str(situation)
# fix and re-run
situation$args[[1]] &lt;- 6
do.call(situation$fn, situation$args, envir=situation$env)
# clean up
file.remove(saveDest)

</code></pre>

<hr>
<h2 id='DebugFnW'>Wrap a function for debugging.</h2><span id='topic+DebugFnW'></span>

<h3>Description</h3>

<p>Wrap fn, so it will save arguments on failure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DebugFnW(saveDest, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DebugFnW_+3A_savedest">saveDest</code></td>
<td>
<p>where to write captured state (determined by type): NULL random temp file, character temp file, name globalenv() variable, and function triggers callback.</p>
</td></tr>
<tr><td><code id="DebugFnW_+3A_fn">fn</code></td>
<td>
<p>function to call</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wrapped function that saves state on error.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+debugger">dump.frames</a></code>, <code><a href="#topic+DebugFn">DebugFn</a></code>, <code><a href="#topic+DebugFnW">DebugFnW</a></code>,  <code><a href="#topic+DebugFnWE">DebugFnWE</a></code>, <code><a href="#topic+DebugPrintFn">DebugPrintFn</a></code>, <code><a href="#topic+DebugFnE">DebugFnE</a></code>, <code><a href="#topic+DebugPrintFnE">DebugPrintFnE</a></code>
Operator idea from: https://gist.github.com/nassimhaddad/c9c327d10a91dcf9a3370d30dff8ac3d .
Please see: <code>vignette("DebugFnW", package="wrapr")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
saveDest &lt;- paste0(tempfile('debug'),'.RDS')
f &lt;- function(i) { (1:10)[[i]] }
df &lt;- DebugFnW(saveDest,f)
# correct run
df(5)
# now re-run
# capture error on incorrect run
tryCatch(
   df(12),
   error = function(e) { print(e) })
# examine details
situation &lt;- readRDS(saveDest)
str(situation)
# fix and re-run
situation$args[[1]] &lt;- 6
do.call(situation$fn,situation$args)
# clean up
file.remove(saveDest)


f &lt;- function(i) { (1:10)[[i]] }
curEnv &lt;- environment()
writeBack &lt;- function(sit) {
   assign('lastError', sit, envir=curEnv)
}
attr(writeBack,'name') &lt;- 'writeBack'
df &lt;- DebugFnW(writeBack,f)
tryCatch(
   df(12),
   error = function(e) { print(e) })
str(lastError)


</code></pre>

<hr>
<h2 id='DebugFnWE'>Wrap function to capture arguments and environment of exception throwing function call for later debugging.</h2><span id='topic+DebugFnWE'></span>

<h3>Description</h3>

<p>Wrap fn, so it will save arguments and environment on failure.
Please see: <code>vignette("DebugFnW", package="wrapr")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DebugFnWE(saveDest, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DebugFnWE_+3A_savedest">saveDest</code></td>
<td>
<p>where to write captured state (determined by type): NULL random temp file, character temp file, name globalenv() variable, and function triggers callback.</p>
</td></tr>
<tr><td><code id="DebugFnWE_+3A_fn">fn</code></td>
<td>
<p>function to call</p>
</td></tr>
<tr><td><code id="DebugFnWE_+3A_...">...</code></td>
<td>
<p>arguments for fn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wrapped function that captures state on error.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+debugger">dump.frames</a></code>, <code><a href="#topic+DebugFn">DebugFn</a></code>, <code><a href="#topic+DebugFnW">DebugFnW</a></code>,  <code><a href="#topic+DebugFnWE">DebugFnWE</a></code>, <code><a href="#topic+DebugPrintFn">DebugPrintFn</a></code>, <code><a href="#topic+DebugFnE">DebugFnE</a></code>, <code><a href="#topic+DebugPrintFnE">DebugPrintFnE</a></code>
</p>
<p>Idea from: https://gist.github.com/nassimhaddad/c9c327d10a91dcf9a3370d30dff8ac3d
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
saveDest &lt;- paste0(tempfile('debug'),'.RDS')
f &lt;- function(i) { (1:10)[[i]] }
df &lt;- DebugFnWE(saveDest, f)
# correct run
df(5)
# now re-run
# capture error on incorrect run
tryCatch(
   df(12),
   error = function(e) { print(e) })
# examine details
situation &lt;- readRDS(saveDest)
str(situation)
# fix and re-run
situation$args[[1]] &lt;- 6
do.call(situation$fn, situation$args, envir=situation$env)
# clean up
file.remove(saveDest)

</code></pre>

<hr>
<h2 id='DebugPrintFn'>Capture arguments of exception throwing function call for later debugging.</h2><span id='topic+DebugPrintFn'></span>

<h3>Description</h3>

<p>Run fn and print result, save arguments on failure.  Use on systems like <code>ggplot()</code>
where some calculation is delayed until <code>print()</code>.
Please see: <code>vignette("DebugFnW", package="wrapr")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DebugPrintFn(saveDest, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DebugPrintFn_+3A_savedest">saveDest</code></td>
<td>
<p>where to write captured state (determined by type): NULL random temp file, character temp file, name globalenv() variable, and function triggers callback.</p>
</td></tr>
<tr><td><code id="DebugPrintFn_+3A_fn">fn</code></td>
<td>
<p>function to call</p>
</td></tr>
<tr><td><code id="DebugPrintFn_+3A_...">...</code></td>
<td>
<p>arguments for fn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fn(...) normally, but if fn(...) throws an exception save to saveDest RDS of list r such that do.call(r$fn,r$args) repeats the call to fn with args.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+debugger">dump.frames</a></code>, <code><a href="#topic+DebugFn">DebugFn</a></code>, <code><a href="#topic+DebugFnW">DebugFnW</a></code>,  <code><a href="#topic+DebugFnWE">DebugFnWE</a></code>, <code><a href="#topic+DebugPrintFn">DebugPrintFn</a></code>, <code><a href="#topic+DebugFnE">DebugFnE</a></code>, <code><a href="#topic+DebugPrintFnE">DebugPrintFnE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
saveDest &lt;- paste0(tempfile('debug'),'.RDS')
f &lt;- function(i) { (1:10)[[i]] }
# correct run
DebugPrintFn(saveDest, f, 5)
# now re-run
# capture error on incorrect run
tryCatch(
   DebugPrintFn(saveDest, f, 12),
   error = function(e) { print(e) })
# examine details
situation &lt;- readRDS(saveDest)
str(situation)
# fix and re-run
situation$args[[1]] &lt;- 6
do.call(situation$fn,situation$args)
# clean up
file.remove(saveDest)

</code></pre>

<hr>
<h2 id='DebugPrintFnE'>Capture arguments and environment of exception throwing function call for later debugging.</h2><span id='topic+DebugPrintFnE'></span>

<h3>Description</h3>

<p>Run fn and print result, save arguments and environment on failure.  Use on systems like ggplot()
where some calculation is delayed until print().
Please see: <code>vignette("DebugFnW", package="wrapr")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DebugPrintFnE(saveDest, fn, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DebugPrintFnE_+3A_savedest">saveDest</code></td>
<td>
<p>where to write captured state (determined by type): NULL random temp file, character temp file, name globalenv() variable, and function triggers callback.</p>
</td></tr>
<tr><td><code id="DebugPrintFnE_+3A_fn">fn</code></td>
<td>
<p>function to call</p>
</td></tr>
<tr><td><code id="DebugPrintFnE_+3A_...">...</code></td>
<td>
<p>arguments for fn</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fn(...) normally, but if fn(...) throws an exception save to saveDest RDS of list r such that do.call(r$fn,r$args) repeats the call to fn with args.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+debugger">dump.frames</a></code>, <code><a href="#topic+DebugFn">DebugFn</a></code>, <code><a href="#topic+DebugFnW">DebugFnW</a></code>,  <code><a href="#topic+DebugFnWE">DebugFnWE</a></code>, <code><a href="#topic+DebugPrintFn">DebugPrintFn</a></code>, <code><a href="#topic+DebugFnE">DebugFnE</a></code>, <code><a href="#topic+DebugPrintFnE">DebugPrintFnE</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
saveDest &lt;- paste0(tempfile('debug'),'.RDS')
f &lt;- function(i) { (1:10)[[i]] }
# correct run
DebugPrintFnE(saveDest, f, 5)
# now re-run
# capture error on incorrect run
tryCatch(
   DebugPrintFnE(saveDest, f, 12),
   error = function(e) { print(e) })
# examine details
situation &lt;- readRDS(saveDest)
str(situation)
# fix and re-run
situation$args[[1]] &lt;- 6
do.call(situation$fn, situation$args, envir=situation$env)
# clean up
file.remove(saveDest)

</code></pre>

<hr>
<h2 id='defineLambda'>Define lambda function building function.</h2><span id='topic+defineLambda'></span>

<h3>Description</h3>

<p>Use this to place a copy of the lambda-symbol
function builder in your workspace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defineLambda(envir = parent.frame(), name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defineLambda_+3A_envir">envir</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
<tr><td><code id="defineLambda_+3A_name">name</code></td>
<td>
<p>character, name to assign to (defaults to Greek lambda).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lambda">lambda</a></code>, <code><a href="#topic+makeFunction_se">makeFunction_se</a></code>, <code><a href="#topic+named_map_builder">named_map_builder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
defineLambda()
# ls()

</code></pre>

<hr>
<h2 id='dot_arrow'>Pipe operator (&quot;dot arrow&quot;, &quot;dot pipe&quot; or &quot;dot arrow pipe&quot;).</h2><span id='topic+dot_arrow'></span><span id='topic++25.+3E+25'></span><span id='topic++25+3E.+25'></span><span id='topic++25.+25'></span>

<h3>Description</h3>

<p>Defined as roughly : <code>a %&gt;.% b</code> ~ <code>{ . &lt;- a; b };</code>
(with visible .-side effects).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_left_arg %.&gt;% pipe_right_arg

pipe_left_arg %&gt;.% pipe_right_arg

pipe_left_arg %.% pipe_right_arg
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dot_arrow_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>left argument expression (substituted into .)</p>
</td></tr>
<tr><td><code id="dot_arrow_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>right argument expression (presumably including .)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pipe operator has a couple of special cases. First: if the right hand side is a name,
then we try to de-reference it and apply it as a function or surrogate function.
</p>
<p>The pipe operator checks for and throws an exception for a number of &quot;piped into
nothing cases&quot; such as <code>5 %.&gt;% sin()</code>, many of these checks can be turned
off by adding braces.
</p>
<p>For some discussion, please see <a href="https://win-vector.com/2017/07/07/in-praise-of-syntactic-sugar/">https://win-vector.com/2017/07/07/in-praise-of-syntactic-sugar/</a>.
For some more examples, please see the package README <a href="https://github.com/WinVector/wrapr">https://github.com/WinVector/wrapr</a>.
For formal documentation please see <a href="https://github.com/WinVector/wrapr/blob/master/extras/wrapr_pipe.pdf">https://github.com/WinVector/wrapr/blob/master/extras/wrapr_pipe.pdf</a>.
For a base-R step-debuggable pipe please try the Bizarro Pipe <a href="https://win-vector.com/2017/01/29/using-the-bizarro-pipe-to-debug-magrittr-pipelines-in-r/">https://win-vector.com/2017/01/29/using-the-bizarro-pipe-to-debug-magrittr-pipelines-in-r/</a>.
<code>%&gt;.%</code> and <code>%.&gt;%</code> are synonyms.
</p>
<p>The dot arrow pipe has S3/S4 dispatch (please see <a href="https://journal.r-project.org/archive/2018/RJ-2018-042/index.html">https://journal.r-project.org/archive/2018/RJ-2018-042/index.html</a>).
However as the right-hand side of the pipe is normally held unevaluated, we don't know the type except in special
cases (such as the rigth-hand side being referred to by a name or variable).  To force the evaluation of a pipe term,
simply wrap it in .().
</p>


<h3>Value</h3>

<p>eval({ . &lt;- pipe_left_arg; pipe_right_arg };)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pipe_left_arg %.&gt;% pipe_right_arg</code>: dot arrow
</p>
</li>
<li> <p><code>pipe_left_arg %&gt;.% pipe_right_arg</code>: alias for dot arrow
</p>
</li>
<li> <p><code>pipe_left_arg %.% pipe_right_arg</code>: alias for dot arrow
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# both should be equal:
cos(exp(sin(4)))
4 %.&gt;% sin(.) %.&gt;% exp(.) %.&gt;% cos(.)

f &lt;- function() { sin }
# returns f() ignoring dot, not what we want
5 %.&gt;% f()
# evaluates f() early then evaluates result with .-substitution rules
5 %.&gt;% .(f())

</code></pre>

<hr>
<h2 id='draw_frame'>Render a simple data.frame in build_frame format.</h2><span id='topic+draw_frame'></span>

<h3>Description</h3>

<p>Render a simple data.frame in build_frame format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_frame(
  x,
  ...,
  time_format = "%Y-%m-%d %H:%M:%S",
  formatC_options = list(),
  adjust_for_auto_indent = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_frame_+3A_x">x</code></td>
<td>
<p>data.frame (with atomic types).</p>
</td></tr>
<tr><td><code id="draw_frame_+3A_...">...</code></td>
<td>
<p>not used for values, forces later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="draw_frame_+3A_time_format">time_format</code></td>
<td>
<p>character, format for &quot;POSIXt&quot; classes.</p>
</td></tr>
<tr><td><code id="draw_frame_+3A_formatc_options">formatC_options</code></td>
<td>
<p>named list, options for formatC()- used on numerics.</p>
</td></tr>
<tr><td><code id="draw_frame_+3A_adjust_for_auto_indent">adjust_for_auto_indent</code></td>
<td>
<p>integer additional after first row padding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_frame">build_frame</a></code>,  <code><a href="#topic+qchar_frame">qchar_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tc_name &lt;- "training"
x &lt;- build_frame(
  "measure"                   , tc_name, "validation", "idx" |
  "minus binary cross entropy", 5      , 7           , 1L    |
  "accuracy"                  , 0.8    , 0.6         , 2L    )
print(x)
cat(draw_frame(x))


</code></pre>

<hr>
<h2 id='draw_framec'>Render a simple data.frame in qchar_frame format.</h2><span id='topic+draw_framec'></span>

<h3>Description</h3>

<p>Render a simple data.frame in qchar_frame format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_framec(x, ..., unquote_cols = character(0), adjust_for_auto_indent = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_framec_+3A_x">x</code></td>
<td>
<p>data.frame (with character types).</p>
</td></tr>
<tr><td><code id="draw_framec_+3A_...">...</code></td>
<td>
<p>not used for values, forces later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="draw_framec_+3A_unquote_cols">unquote_cols</code></td>
<td>
<p>character, columns to elide quotes from.</p>
</td></tr>
<tr><td><code id="draw_framec_+3A_adjust_for_auto_indent">adjust_for_auto_indent</code></td>
<td>
<p>integer additional after first row padding.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_frame">build_frame</a></code>,  <code><a href="#topic+qchar_frame">qchar_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
controlTable &lt;- wrapr::qchar_frame(
  "flower_part", "Length"     , "Width"     |
    "Petal"    , Petal.Length , Petal.Width |
    "Sepal"    , Sepal.Length , Sepal.Width )
cat(draw_framec(controlTable, unquote_cols = qc(Length, Width)))


</code></pre>

<hr>
<h2 id='evalb'>Near <code>eval(bquote(expr))</code> shortcut.</h2><span id='topic+evalb'></span>

<h3>Description</h3>

<p>Evaluate <code>expr</code> with <code>bquote</code> <code>.()</code> substitution.
Including <code>.(-x)</code> promoting <code>x</code>'s value from character to a name,
which is called &quot;quote negation&quot; (hence the minus-sign).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalb(expr, where = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalb_+3A_expr">expr</code></td>
<td>
<p>expression to evaluate.</p>
</td></tr>
<tr><td><code id="evalb_+3A_where">where</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>evaluated substituted expression.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace('graphics', quietly = TRUE)) {
   angle = 1:10
   variable &lt;- as.name("angle")
   fn_name &lt;- 'sin'
   evalb(  plot(x = .(variable), y = .(-fn_name)(.(variable))) )
}

</code></pre>

<hr>
<h2 id='execute_parallel'>Execute f in parallel partitioned by partition_column.</h2><span id='topic+execute_parallel'></span>

<h3>Description</h3>

<p>Execute f in parallel partitioned by <code>partition_column</code>, see
<code><a href="#topic+partition_tables">partition_tables</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>execute_parallel(
  tables,
  f,
  partition_column,
  ...,
  cl = NULL,
  debug = FALSE,
  env = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="execute_parallel_+3A_tables">tables</code></td>
<td>
<p>named map of tables to use.</p>
</td></tr>
<tr><td><code id="execute_parallel_+3A_f">f</code></td>
<td>
<p>function to apply to each tableset signature is function takes a single argument that is a named list of data.frames.</p>
</td></tr>
<tr><td><code id="execute_parallel_+3A_partition_column">partition_column</code></td>
<td>
<p>character name of column to partition on</p>
</td></tr>
<tr><td><code id="execute_parallel_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="execute_parallel_+3A_cl">cl</code></td>
<td>
<p>parallel cluster.</p>
</td></tr>
<tr><td><code id="execute_parallel_+3A_debug">debug</code></td>
<td>
<p>logical if TRUE use lapply instead of parallel::clusterApplyLB.</p>
</td></tr>
<tr><td><code id="execute_parallel_+3A_env">env</code></td>
<td>
<p>environment to look for values in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of f evaluations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+partition_tables">partition_tables</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("parallel", quietly = TRUE)) {
  cl &lt;- parallel::makeCluster(2)

  d &lt;- data.frame(x = 1:5, g = c(1, 1, 2, 2 ,2))
  f &lt;- function(dl) {
    d &lt;- dl$d
    d$s &lt;- sqrt(d$x)
    d
  }
  r &lt;- execute_parallel(list(d = d), f,
                        partition_column = "g",
                        cl = cl) %.&gt;%
    do.call(rbind, .) %.&gt;%
    print(.)

  parallel::stopCluster(cl)
}

</code></pre>

<hr>
<h2 id='f.'>Build an anonymous function of dot.</h2><span id='topic+f.'></span>

<h3>Description</h3>

<p>Build an anonymous function of dot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.(body, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f._+3A_body">body</code></td>
<td>
<p>function body</p>
</td></tr>
<tr><td><code id="f._+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>user defined function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambda">lambda</a></code>, <code><a href="#topic+defineLambda">defineLambda</a></code>, <code><a href="#topic+named_map_builder">named_map_builder</a></code>, <code><a href="#topic+makeFunction_se">makeFunction_se</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- f.(sin(.) %.&gt;% cos(.))
7 %.&gt;% f


</code></pre>

<hr>
<h2 id='grab_assignments_from_dots'>Re-write captured <code>...</code> arguments as assignments.</h2><span id='topic+grab_assignments_from_dots'></span>

<h3>Description</h3>

<p>Re-write captured <code>...</code> arguments as a <code>c(DESTINATION = TARGET)</code> character vector.
Suggested capture code is: <code>substitute(list(...))</code>. Allows <code>bquote</code> <code>.()</code> substitution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grab_assignments_from_dots(
  captured_args,
  unpack_environment = parent.frame(),
  allow_dot_on_left = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grab_assignments_from_dots_+3A_captured_args">captured_args</code></td>
<td>
<p>captured <code>...</code>.</p>
</td></tr>
<tr><td><code id="grab_assignments_from_dots_+3A_unpack_environment">unpack_environment</code></td>
<td>
<p>environment to look in</p>
</td></tr>
<tr><td><code id="grab_assignments_from_dots_+3A_allow_dot_on_left">allow_dot_on_left</code></td>
<td>
<p>logical if TRUE allow forms like <code>.(a) = a</code> and <code>.(a)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character vector describing the desired mapping.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(...) {
  unpack_environment &lt;- parent.frame(n = 1)
  orig_args &lt;- substitute(list(...))
  grab_assignments_from_dots(orig_args, unpack_environment)
}
f(a, c = d, e := f, g &lt;- h, i -&gt; j)
# should equal c('a', 'c' = 'd', 'e' = 'f', 'g' = 'h', 'j' = 'i')

</code></pre>

<hr>
<h2 id='grepdf'>Grep for column names from a <code>data.frame</code></h2><span id='topic+grepdf'></span>

<h3>Description</h3>

<p>Grep for column names from a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grepdf(
  pattern,
  x,
  ...,
  ignore.case = FALSE,
  perl = FALSE,
  value = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grepdf_+3A_pattern">pattern</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
<tr><td><code id="grepdf_+3A_x">x</code></td>
<td>
<p>data.frame to work with</p>
</td></tr>
<tr><td><code id="grepdf_+3A_...">...</code></td>
<td>
<p>force later arguments to be passed by name</p>
</td></tr>
<tr><td><code id="grepdf_+3A_ignore.case">ignore.case</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
<tr><td><code id="grepdf_+3A_perl">perl</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
<tr><td><code id="grepdf_+3A_value">value</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
<tr><td><code id="grepdf_+3A_fixed">fixed</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
<tr><td><code id="grepdf_+3A_usebytes">useBytes</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
<tr><td><code id="grepdf_+3A_invert">invert</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>column names of x matching grep condition.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+grepv">grepv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

d &lt;- data.frame(xa=1, yb=2)

# starts with
grepdf('^x', d)

# ends with
grepdf('b$', d)

</code></pre>

<hr>
<h2 id='grepv'>Return a vector of matches.</h2><span id='topic+grepv'></span>

<h3>Description</h3>

<p>Return a vector of matches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grepv(
  pattern,
  x,
  ...,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grepv_+3A_pattern">pattern</code></td>
<td>
<p>character scalar, pattern to match, passed to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="grepv_+3A_x">x</code></td>
<td>
<p>character vector to match to, passed to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="grepv_+3A_...">...</code></td>
<td>
<p>not used, forced later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="grepv_+3A_ignore.case">ignore.case</code></td>
<td>
<p>logical, passed to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="grepv_+3A_perl">perl</code></td>
<td>
<p>logical, passed to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="grepv_+3A_fixed">fixed</code></td>
<td>
<p>logical, passed to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="grepv_+3A_usebytes">useBytes</code></td>
<td>
<p>logical, passed <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
<tr><td><code id="grepv_+3A_invert">invert</code></td>
<td>
<p>passed to <code><a href="base.html#topic+grep">grep</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of matching values.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, <code><a href="#topic+grepdf">grepdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
grepv("x$", c("sox", "xor"))

</code></pre>

<hr>
<h2 id='has_no_dup_rows'>Check for duplicate rows.</h2><span id='topic+has_no_dup_rows'></span>

<h3>Description</h3>

<p>Check a simple data.frame (no list or exotic rows) for duplicate rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_no_dup_rows(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_no_dup_rows_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if there are no duplicate rows, else FALSE.
</p>

<hr>
<h2 id='invert_perm'>Invert a permutation.</h2><span id='topic+invert_perm'></span>

<h3>Description</h3>

<p>For a permutation p build q such that p[q] == q[p] == seq_len(length(p)).
Please see <a href="https://win-vector.com/2017/05/18/on-indexing-operators-and-composition/">https://win-vector.com/2017/05/18/on-indexing-operators-and-composition/</a>
and <a href="https://win-vector.com/2017/09/02/permutation-theory-in-action/">https://win-vector.com/2017/09/02/permutation-theory-in-action/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_perm(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invert_perm_+3A_p">p</code></td>
<td>
<p>vector of length n containing each of seq_len(n) exactly once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector q such that p[q] == q[p] == seq_len(length(p))
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p &lt;- c(4, 5, 7, 8, 9, 6, 1, 3, 2, 10)
q &lt;- invert_perm(p)
p[q]
all.equal(p[q], seq_len(length(p)))
q[p]
all.equal(q[p], seq_len(length(p)))

</code></pre>

<hr>
<h2 id='lambda'>Build an anonymous function.</h2><span id='topic+lambda'></span>

<h3>Description</h3>

<p>Mostly just a place-holder so lambda-symbol form has somewhere safe to hang its help entry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(..., env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_+3A_...">...</code></td>
<td>
<p>formal parameters of function, unbound names, followed by function body (code/language).</p>
</td></tr>
<tr><td><code id="lambda_+3A_env">env</code></td>
<td>
<p>environment to work in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>user defined function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+defineLambda">defineLambda</a></code>, <code><a href="#topic+makeFunction_se">makeFunction_se</a></code>, <code><a href="#topic+named_map_builder">named_map_builder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#lambda-syntax: lambda(arg [, arg]*, body [, env=env])
# also works with lambda character as function name
# print(intToUtf8(0x03BB))

# example: square numbers
sapply(1:4, lambda(x, x^2))

# example more than one argument
f &lt;- lambda(x, y, x+y)
f(2,4)


</code></pre>

<hr>
<h2 id='lapplym'>Memoizing wrapper for lapply.</h2><span id='topic+lapplym'></span>

<h3>Description</h3>

<p>Memoizing wrapper for lapply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapplym(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapplym_+3A_x">X</code></td>
<td>
<p>list or vector of inputs</p>
</td></tr>
<tr><td><code id="lapplym_+3A_fun">FUN</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="lapplym_+3A_...">...</code></td>
<td>
<p>additional arguments passed to lapply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VectorizeM">VectorizeM</a></code>, <code><a href="#topic+vapplym">vapplym</a></code>, <code><a href="#topic+parLapplyLBm">parLapplyLBm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fs &lt;- function(x) { x &lt;- x[[1]]; print(paste("see", x)); sin(x) }
# should only print "see" twice, not 6 times
lapplym(c(0, 1, 1, 0, 0, 1), fs)

</code></pre>

<hr>
<h2 id='let'>Execute expr with name substitutions specified in alias.</h2><span id='topic+let'></span>

<h3>Description</h3>

<p><code>let</code> implements a mapping from desired names (names used directly in the expr code) to names used in the data.
Mnemonic: &quot;expr code symbols are on the left, external data and function argument names are on the right.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>let(
  alias,
  expr,
  ...,
  envir = parent.frame(),
  subsMethod = "langsubs",
  strict = TRUE,
  eval = TRUE,
  debugPrint = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="let_+3A_alias">alias</code></td>
<td>
<p>mapping from free names in expr to target names to use (mapping have both unique names and unique values).</p>
</td></tr>
<tr><td><code id="let_+3A_expr">expr</code></td>
<td>
<p>block to prepare for execution.</p>
</td></tr>
<tr><td><code id="let_+3A_...">...</code></td>
<td>
<p>force later arguments to be bound by name.</p>
</td></tr>
<tr><td><code id="let_+3A_envir">envir</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
<tr><td><code id="let_+3A_subsmethod">subsMethod</code></td>
<td>
<p>character substitution method, one of  'langsubs' (preferred), 'subsubs', or 'stringsubs'.</p>
</td></tr>
<tr><td><code id="let_+3A_strict">strict</code></td>
<td>
<p>logical if TRUE names and values must be valid un-quoted names, and not dot.</p>
</td></tr>
<tr><td><code id="let_+3A_eval">eval</code></td>
<td>
<p>logical if TRUE execute the re-mapped expression (else return it).</p>
</td></tr>
<tr><td><code id="let_+3A_debugprint">debugPrint</code></td>
<td>
<p>logical if TRUE print debugging information when in stringsubs mode.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please see the <code>wrapr</code> <code>vignette</code> for some discussion of let and crossing function call boundaries: <code>vignette('wrapr','wrapr')</code>.
For formal documentation please see <a href="https://github.com/WinVector/wrapr/blob/master/extras/wrapr_let.pdf">https://github.com/WinVector/wrapr/blob/master/extras/wrapr_let.pdf</a>.
Transformation is performed by substitution, so please be wary of unintended name collisions or aliasing.
</p>
<p>Something like <code>let</code> is only useful to get control of a function that is parameterized
(in the sense it take column names) but non-standard (in that it takes column names from
non-standard evaluation argument name capture, and not as simple variables or parameters).  So  <code>wrapr:let</code> is not
useful for non-parameterized functions (functions that work only over values such as <code>base::sum</code>),
and not useful for functions take parameters in straightforward way (such as <code>base::merge</code>'s &quot;<code>by</code>&quot; argument).
<code>dplyr::mutate</code> is an example where
we can use a <code>let</code> helper.   <code>dplyr::mutate</code> is
parameterized (in the sense it can work over user supplied columns and expressions), but column names are captured through non-standard evaluation
(and it rapidly becomes unwieldy to use complex formulas with the standard evaluation equivalent <code>dplyr::mutate_</code>).
<code>alias</code> can not include the symbol &quot;<code>.</code>&quot;.
</p>
<p>The intent from is from the user perspective to have (if
<code>a &lt;- 1; b &lt;- 2</code>):
<code>let(c(z = 'a'), z+b)</code> to behave a lot like
<code>eval(substitute(z+b, c(z=quote(a))))</code>.
</p>
<p><code>let</code> deliberately checks that it is mapping only to legal <code>R</code> names;
this is to discourage the use of <code>let</code> to make names to arbitrary values, as
that is the more properly left to <code>R</code>'s environment systems.
<code>let</code> is intended to transform
&quot;tame&quot; variable and column names to &quot;tame&quot; variable and column names.  Substitution
outcomes that are not valid simple <code>R</code> variable names (produced with out use of
back-ticks) are forbidden.  It is suggested that substitution targets be written
<code>ALL_CAPS</code> style to make them stand out.
</p>
<p><code>let</code> was inspired by <code>gtools:strmacro()</code>.
Please see <a href="https://github.com/WinVector/wrapr/blob/master/extras/MacrosInR.md">https://github.com/WinVector/wrapr/blob/master/extras/MacrosInR.md</a> for a discussion of macro tools in <code>R</code>.
</p>


<h3>Value</h3>

<p>result of expr executed in calling environment (or expression if eval==FALSE).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+bquote">bquote</a></code>, <code><a href="base.html#topic+do.call">do.call</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(
  Sepal_Length=c(5.8,5.7),
  Sepal_Width=c(4.0,4.4),
  Species='setosa')

mapping &lt;- qc(
  AREA_COL = Sepal_area,
  LENGTH_COL = Sepal_Length,
  WIDTH_COL = Sepal_Width
)

# let-block notation
let(
  mapping,
  d %.&gt;%
    transform(., AREA_COL = LENGTH_COL * WIDTH_COL)
)


# Note: in packages can make assignment such as:
#   AREA_COL &lt;- LENGTH_COL &lt;- WIDTH_COL &lt;- NULL
# prior to code so targets don't look like unbound names.


</code></pre>

<hr>
<h2 id='makeFunction_se'>Build an anonymous function.</h2><span id='topic+makeFunction_se'></span>

<h3>Description</h3>

<p>Build an anonymous function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeFunction_se(params, body, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeFunction_se_+3A_params">params</code></td>
<td>
<p>formal parameters of function, unbound names.</p>
</td></tr>
<tr><td><code id="makeFunction_se_+3A_body">body</code></td>
<td>
<p>substituted body of function to map arguments into.</p>
</td></tr>
<tr><td><code id="makeFunction_se_+3A_env">env</code></td>
<td>
<p>environment to work in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>user defined function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambda">lambda</a></code>, <code><a href="#topic+defineLambda">defineLambda</a></code>, <code><a href="#topic+named_map_builder">named_map_builder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- makeFunction_se(as.name('x'), substitute({x*x}))
f(7)


g &lt;- makeFunction_se(c(as.name('x'), as.name('y')), substitute({ x + 3*y }))
g(1,100)


</code></pre>

<hr>
<h2 id='map_to_char'>format a map.</h2><span id='topic+map_to_char'></span>

<h3>Description</h3>

<p>format a map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_to_char(mp, ..., sep = " ", assignment = "=", quote_fn = base::shQuote)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_to_char_+3A_mp">mp</code></td>
<td>
<p>named vector or list</p>
</td></tr>
<tr><td><code id="map_to_char_+3A_...">...</code></td>
<td>
<p>not used, foce later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="map_to_char_+3A_sep">sep</code></td>
<td>
<p>separator suffix, what to put after commas</p>
</td></tr>
<tr><td><code id="map_to_char_+3A_assignment">assignment</code></td>
<td>
<p>assignment string</p>
</td></tr>
<tr><td><code id="map_to_char_+3A_quote_fn">quote_fn</code></td>
<td>
<p>string quoting function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character formatted representation
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dput">dput</a></code>, <code><a href="utils.html#topic+capture.output">capture.output</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cat(map_to_char(c('a' = 'b', 'c' = 'd')))
cat(map_to_char(c('a' = 'b', 'd', 'e' = 'f')))
cat(map_to_char(c('a' = 'b', 'd' = NA, 'e' = 'f')))
cat(map_to_char(c(1, NA, 2)))

</code></pre>

<hr>
<h2 id='map_upper'>Map up-cased symbol names to referenced values if those values are string scalars (else throw).</h2><span id='topic+map_upper'></span>

<h3>Description</h3>

<p>Map up-cased symbol names to referenced values if those values are string scalars (else throw).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_upper(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_upper_+3A_...">...</code></td>
<td>
<p>symbol names mapping to string scalars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map from original symbol names to new names (names found in the current environment)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+let">let</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 'a'
print(map_upper(x))
d &lt;- data.frame(a = "a_val")
let(map_upper(x), paste(d$X, x))

</code></pre>

<hr>
<h2 id='mapsyms'>Map symbol names to referenced values if those values are string scalars (else throw).</h2><span id='topic+mapsyms'></span>

<h3>Description</h3>

<p>Map symbol names to referenced values if those values are string scalars (else throw).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapsyms(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapsyms_+3A_...">...</code></td>
<td>
<p>symbol names mapping to string scalars</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map from original symbol names to new names (names found in the current environment)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+let">let</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 'a'
y &lt;- 'b'
print(mapsyms(x, y))
d &lt;- data.frame(a = 1, b = 2)
let(mapsyms(x, y), d$x + d$y)

</code></pre>

<hr>
<h2 id='match_order'>Match one order to another.</h2><span id='topic+match_order'></span>

<h3>Description</h3>

<p>Build a permutation p such that ids1[p] == ids2.  See <a href="https://win-vector.com/2017/09/02/permutation-theory-in-action/">https://win-vector.com/2017/09/02/permutation-theory-in-action/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_order(ids1, ids2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_order_+3A_ids1">ids1</code></td>
<td>
<p>unique vector of ids.</p>
</td></tr>
<tr><td><code id="match_order_+3A_ids2">ids2</code></td>
<td>
<p>unique vector of ids with sort(ids1)==sort(ids2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>p integers such that ids1[p] == ids2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ids1 &lt;- c(4, 5, 7, 8, 9, 6, 1, 3, 2, 10)
ids2 &lt;- c(3, 6, 4, 8, 5, 7, 1, 9,10, 2)
p &lt;- match_order(ids1, ids2)
ids1[p]
all.equal(ids1[p], ids2)
# note base::match(ids2, ids1) also solves this problem

</code></pre>

<hr>
<h2 id='mk_formula'>Construct a formula.</h2><span id='topic+mk_formula'></span>

<h3>Description</h3>

<p>Safely construct a simple Wilkinson notation formula from the outcome (dependent variable) name
and vector of input (independent variable) names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_formula(
  outcome,
  variables,
  ...,
  intercept = TRUE,
  outcome_target = NULL,
  outcome_comparator = "==",
  env = baseenv(),
  extra_values = NULL,
  as_character = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mk_formula_+3A_outcome">outcome</code></td>
<td>
<p>character scalar, name of outcome or dependent variable.</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_variables">variables</code></td>
<td>
<p>character vector, names of input or independent variables.</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_intercept">intercept</code></td>
<td>
<p>logical, if TRUE allow an intercept term.</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_outcome_target">outcome_target</code></td>
<td>
<p>scalar, if not NULL write outcome==outcome_target in formula.</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_outcome_comparator">outcome_comparator</code></td>
<td>
<p>one of &quot;==&quot;, &quot;!=&quot;, &quot;&gt;=&quot;, &quot;&lt;=&quot;, &quot;&gt;&quot;, &quot;&lt;&quot;, only use of outcome_target is not NULL.</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_env">env</code></td>
<td>
<p>environment to use in formula (unless extra_values is non empty, then this is a parent environemnt).</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_extra_values">extra_values</code></td>
<td>
<p>if not empty extra values to be added to a new formula environment containing env.</p>
</td></tr>
<tr><td><code id="mk_formula_+3A_as_character">as_character</code></td>
<td>
<p>if TRUE return formula as a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: outcome and variables
are each intended to be simple variable names or column names (or .). They are not
intended to specify
interactions, I()-terms, transforms, general experessions or other complex formula terms.
Essentially the same effect as <code><a href="stats.html#topic+delete.response">reformulate</a></code>, but trying to avoid the
<code>paste</code> currently in <code><a href="stats.html#topic+delete.response">reformulate</a></code> by calling <code><a href="stats.html#topic+update.formula">update.formula</a></code>
(which appears to work over terms).
Another reasonable way to do this is just <code>paste(outcome, paste(variables, collapse = " + "), sep = " ~ ")</code>.
</p>
<p>Care must be taken with later arguments to functions like <code>lm()</code> whose help states:
&quot;All of weights, subset and offset are evaluated in the same way as variables in formula, that is first in data and then in the environment of formula.&quot;
Also note <code>env</code> defaults to <code>baseenv()</code> to try and minimize refence leaks produced by the environemnt
captured by the formal ending up stored in the resulting model for <code>lm()</code> and <code>glm()</code>.  For
behavior closer to <code>as.formula()</code> please set the <code>env</code> argument to <code>parent.frame()</code>.
</p>


<h3>Value</h3>

<p>a formula object
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+delete.response">reformulate</a></code>, <code><a href="stats.html#topic+update.formula">update.formula</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- mk_formula("mpg", c("cyl", "disp"))
print(f)
(model &lt;- lm(f, mtcars))
format(model$terms)

f &lt;- mk_formula("cyl", c("wt", "gear"), outcome_target = 8, outcome_comparator = "&gt;=")
print(f)
(model &lt;- glm(f, mtcars, family = binomial))
format(model$terms)

</code></pre>

<hr>
<h2 id='mk_tmp_name_source'>Produce a temp name generator with a given prefix.</h2><span id='topic+mk_tmp_name_source'></span>

<h3>Description</h3>

<p>Returns a function f where: f() returns a new temporary name,
f(remove=vector) removes names in vector and returns what was removed,
f(dumpList=TRUE) returns the list of names generated and clears the list,
f(peek=TRUE) returns the list without altering anything.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_tmp_name_source(
  prefix = "tmpnam",
  ...,
  alphabet = as.character(0:9),
  size = 20,
  sep = "_"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mk_tmp_name_source_+3A_prefix">prefix</code></td>
<td>
<p>character, string to prefix temp names with.</p>
</td></tr>
<tr><td><code id="mk_tmp_name_source_+3A_...">...</code></td>
<td>
<p>force later argument to be bound by name.</p>
</td></tr>
<tr><td><code id="mk_tmp_name_source_+3A_alphabet">alphabet</code></td>
<td>
<p>character, characters to choose from in building ids.</p>
</td></tr>
<tr><td><code id="mk_tmp_name_source_+3A_size">size</code></td>
<td>
<p>character, number of characters to build id portion of names from.</p>
</td></tr>
<tr><td><code id="mk_tmp_name_source_+3A_sep">sep</code></td>
<td>
<p>character, separator between temp name fields.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>name generator function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- mk_tmp_name_source('ex')
print(f())
nm2 &lt;- f()
print(nm2)
f(remove=nm2)
print(f(dumpList=TRUE))

</code></pre>

<hr>
<h2 id='named_map_builder'>Named map builder.</h2><span id='topic+named_map_builder'></span><span id='topic++3A+3D'></span><span id='topic++25+3A+3D+25'></span>

<h3>Description</h3>

<p>Set names of right-argument to be left-argument, and return right argument.
Called from <code>:=</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_map_builder(targets, values)

`:=`(targets, values)

targets %:=% values
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="named_map_builder_+3A_targets">targets</code></td>
<td>
<p>names to set.</p>
</td></tr>
<tr><td><code id="named_map_builder_+3A_values">values</code></td>
<td>
<p>values to assign to names (and return).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>values with names set.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lambda">lambda</a></code>, <code><a href="#topic+defineLambda">defineLambda</a></code>, <code><a href="#topic+makeFunction_se">makeFunction_se</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

c('a' := '4', 'b' := '5')
# equivalent to: c(a = '4', b = '5')

c('a', 'b') := c('1', '2')
# equivalent to: c(a = '1', b = '2')

# the important example
name &lt;- 'a'
name := '5'
# equivalent to: c('a' = '5')

</code></pre>

<hr>
<h2 id='orderv'>Order by a list of vectors.</h2><span id='topic+orderv'></span>

<h3>Description</h3>

<p>Produce an ordering permutation from a list of vectors.  Essentially a non-<code>...</code> interface to <code><a href="base.html#topic+order">order</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderv(
  columns,
  ...,
  na.last = TRUE,
  decreasing = FALSE,
  method = c("auto", "shell", "radix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orderv_+3A_columns">columns</code></td>
<td>
<p>list of atomic columns to order on, can be a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="orderv_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="orderv_+3A_na.last">na.last</code></td>
<td>
<p>(passed to <code><a href="base.html#topic+order">order</a></code>) for controlling the treatment of NAs. If TRUE, missing values in the data are put last; if FALSE, they are put first; if NA, they are removed.</p>
</td></tr>
<tr><td><code id="orderv_+3A_decreasing">decreasing</code></td>
<td>
<p>(passed to <code><a href="base.html#topic+order">order</a></code>) logical. Should the sort order be increasing or decreasing? For the &quot;radix&quot; method, this can be a vector of length equal to the number of arguments in <code>...</code>. For the other methods, it must be length one.</p>
</td></tr>
<tr><td><code id="orderv_+3A_method">method</code></td>
<td>
<p>(passed to <code><a href="base.html#topic+order">order</a></code>) the method to be used: partial matches are allowed. The default (&quot;auto&quot;) implies &quot;radix&quot; for short numeric vectors, integer vectors, logical vectors and factors. Otherwise, it implies &quot;shell&quot;. For details of methods &quot;shell&quot;, &quot;quick&quot;, and &quot;radix&quot;, see the help for <code><a href="base.html#topic+sort">sort</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ordering permutation
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+order">order</a></code>, <code><a href="#topic+sortv">sortv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(x = c(2, 2, 3, 3, 1, 1), y = 6:1)
d[order(d$x, d$y), , drop = FALSE]
d[orderv(d), , drop = FALSE]

</code></pre>

<hr>
<h2 id='pack'>Pack values into a named list.</h2><span id='topic+pack'></span>

<h3>Description</h3>

<p>This function packs values given by name into a named list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pack(..., .wrapr_private_var_env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack_+3A_...">...</code></td>
<td>
<p>values to pack, these should be specified by name (not as constants).</p>
</td></tr>
<tr><td><code id="pack_+3A_.wrapr_private_var_env">.wrapr_private_var_env</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list of values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unpack">unpack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 1
y &lt;- 2
pack(x, y)  # list(x = 1, y = 2)

pack(a = x, y)  # list(a = 1, y = 2)

pack(a = 5, y)  # list(a = 5, y = 2)

pack(1, 2)  # list('1' = 1, '2' = 2)

v &lt;- pack(x = 8, y = 9)  # list(x = 8, y = 9)
v -&gt; unpack[x, y]
print(x)  # 8
print(y)  # 9

</code></pre>

<hr>
<h2 id='parLapplyLBm'>Memoizing wrapper for parLapplyLB</h2><span id='topic+parLapplyLBm'></span>

<h3>Description</h3>

<p>Memoizing wrapper for parLapplyLB
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parLapplyLBm(cl = NULL, X, fun, ..., chunk.size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parLapplyLBm_+3A_cl">cl</code></td>
<td>
<p>cluster object</p>
</td></tr>
<tr><td><code id="parLapplyLBm_+3A_x">X</code></td>
<td>
<p>list or vector of inputs</p>
</td></tr>
<tr><td><code id="parLapplyLBm_+3A_fun">fun</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="parLapplyLBm_+3A_...">...</code></td>
<td>
<p>additional arguments passed to lapply</p>
</td></tr>
<tr><td><code id="parLapplyLBm_+3A_chunk.size">chunk.size</code></td>
<td>
<p>passed to <code>parallel::parLapplyLB</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of results.
</p>


<h3>See Also</h3>

<p><code><a href="parallel.html#topic+clusterApply">parLapplyLB</a></code>, <code><a href="#topic+lapplym">lapplym</a></code>, <code><a href="#topic+VectorizeM">VectorizeM</a></code>, <code><a href="#topic+vapplym">vapplym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(requireNamespace("parallel", quietly = TRUE)) {
  cl &lt;- parallel::makeCluster(2)
  fs &lt;- function(x) { x &lt;- x[[1]]; Sys.sleep(1); sin(x) }
  # without memoization should take 1000 seconds
  lst &lt;- parLapplyLBm(cl, c(rep(0, 1000), rep(1, 1000)), fs)
  parallel::stopCluster(cl)
}

</code></pre>

<hr>
<h2 id='partition_tables'>Partition as set of tables into a list.</h2><span id='topic+partition_tables'></span>

<h3>Description</h3>

<p>Partition a set of tables into a list of sets of tables.  Note: removes rownames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_tables(
  tables_used,
  partition_column,
  ...,
  source_usage = NULL,
  source_limit = NULL,
  tables = NULL,
  env = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_tables_+3A_tables_used">tables_used</code></td>
<td>
<p>character, names of tables to look for.</p>
</td></tr>
<tr><td><code id="partition_tables_+3A_partition_column">partition_column</code></td>
<td>
<p>character, name of column to partition by (tables should not have NAs in this column).</p>
</td></tr>
<tr><td><code id="partition_tables_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="partition_tables_+3A_source_usage">source_usage</code></td>
<td>
<p>optional named map from tables_used names to sets of columns used.</p>
</td></tr>
<tr><td><code id="partition_tables_+3A_source_limit">source_limit</code></td>
<td>
<p>optional numeric scalar limit on rows wanted every source.</p>
</td></tr>
<tr><td><code id="partition_tables_+3A_tables">tables</code></td>
<td>
<p>named map from tables_used names to data.frames.</p>
</td></tr>
<tr><td><code id="partition_tables_+3A_env">env</code></td>
<td>
<p>environment to also look for tables named by tables_used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of names maps of data.frames partitioned by partition_column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+execute_parallel">execute_parallel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d1 &lt;- data.frame(a = 1:5, g = c(1, 1, 2, 2, 2))
d2 &lt;- data.frame(x = 1:3, g = 1:3)
d3 &lt;- data.frame(y = 1)
partition_tables(c("d1", "d2", "d3"), "g", tables = list(d1 = d1, d2 = d2, d3 = d3))

</code></pre>

<hr>
<h2 id='pipe_impl'>Pipe dispatch implementation.</h2><span id='topic+pipe_impl'></span>

<h3>Description</h3>

<p>This is a helper for implementing additional pipes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pipe_impl(pipe_left_arg, pipe_right_arg, pipe_environment, pipe_string = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pipe_impl_+3A_pipe_left_arg">pipe_left_arg</code></td>
<td>
<p>possibily unevaluated left argument.</p>
</td></tr>
<tr><td><code id="pipe_impl_+3A_pipe_right_arg">pipe_right_arg</code></td>
<td>
<p>possibly unevaluated right argument.</p>
</td></tr>
<tr><td><code id="pipe_impl_+3A_pipe_environment">pipe_environment</code></td>
<td>
<p>environment to evaluate in.</p>
</td></tr>
<tr><td><code id="pipe_impl_+3A_pipe_string">pipe_string</code></td>
<td>
<p>character, name of pipe operator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example: how wrapr pipe is implemented

print(`%.&gt;%`)




# Example: create a value that causes pipelines to record steps.

# inject raw values into wrapped/annotated world
unit_recording &lt;- function(x, recording = paste(as.expression(substitute(x)), collapse = '\n')) {
  res &lt;- list(value = x, recording = recording)
  class(res) &lt;- "recording_value"
  res
}

# similar to bind or &gt;&gt;=
# (takes U, f:U -&gt; V to M(f(U)), instead of
#        U, f:U -&gt; M(V) to M(f(U)))
# so similar to a functor taking
#   f:U -&gt; V to f':M(U) -&gt; M(V)
# followed by application.
apply_left.recording_value &lt;- function(
  pipe_left_arg,
  pipe_right_arg,
  pipe_environment,
  left_arg_name,
  pipe_string,
  right_arg_name) {
  force(pipe_environment)
  tmp &lt;- wrapr::pipe_impl(
    pipe_left_arg = pipe_left_arg$value,
    pipe_right_arg = pipe_right_arg,
    pipe_environment = pipe_environment,
    pipe_string = pipe_string)
  unit_recording(
    tmp,
    paste0(pipe_left_arg$recording,
           ' %.&gt;% ',
           paste(as.expression(pipe_right_arg), collapse = '\n')))
}

# make available on standard S3 search path
assign('apply_left.recording_value',
       apply_left.recording_value,
       envir = .GlobalEnv)

unpack[value, recording] := 3 %.&gt;%
  unit_recording(.) %.&gt;%
  sin(.) %.&gt;%
  cos(.)

print(value)
print(recording)

# clean up
rm(envir = .GlobalEnv, list = 'apply_left.recording_value')

</code></pre>

<hr>
<h2 id='psagg'>Pseudo aggregator.</h2><span id='topic+psagg'></span>

<h3>Description</h3>

<p>Take a vector or list and return the first element (pseudo-aggregation or projection).
If the argument length is zero or there are different items throw in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psagg(x, ..., strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psagg_+3A_x">x</code></td>
<td>
<p>should be a vector or list of items.</p>
</td></tr>
<tr><td><code id="psagg_+3A_...">...</code></td>
<td>
<p>force later arguments to be passed by name</p>
</td></tr>
<tr><td><code id="psagg_+3A_strict">strict</code></td>
<td>
<p>logical, should we check value uniqueness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful in some split by column situations as a safe and legible
way to convert vectors to scalars.
</p>


<h3>Value</h3>

<p>x[[1]] (or throw if not all items are equal or this is an empty vector).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(
  group = c("a", "a", "b"),
  stringsAsFactors = FALSE)
dl &lt;- lapply(
  split(d, d$group),
  function(di) {
    data.frame(
      # note: di$group is a possibly length&gt;1 vector!
      # pseudo aggregate it to the value that is
      # constant for each group, confirming it is constant.
      group_label = psagg(di$group),
      group_count = nrow(di),
      stringsAsFactors = FALSE
    )
  })
do.call(rbind, dl)

</code></pre>

<hr>
<h2 id='qae'>Quote assignment expressions (name = expr, name := expr, name %:=% expr).</h2><span id='topic+qae'></span>

<h3>Description</h3>

<p>Accepts arbitrary un-parsed expressions as
assignments to allow forms such as &quot;Sepal_Long := Sepal.Length &gt;= 2 * Sepal.Width&quot;.
(without the quotes).
Terms are expressions of the form &quot;lhs := rhs&quot;, &quot;lhs = rhs&quot;, &quot;lhs %:=% rhs&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qae(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qae_+3A_...">...</code></td>
<td>
<p>assignment expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qae()</code> uses
<code>bquote()</code> <code>.()</code> quasiquotation escaping notation,
and <code>.(-)</code> &quot;string quotes, string to name&quot; notation.
</p>


<h3>Value</h3>

<p>array of quoted assignment expressions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qc">qc</a></code>, <code><a href="#topic+qe">qe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ratio &lt;- 2

exprs &lt;- qae(Sepal_Long := Sepal.Length &gt;= ratio * Sepal.Width,
             Petal_Short = Petal.Length &lt;= 3.5)
print(exprs)

exprs &lt;- qae(Sepal_Long := Sepal.Length &gt;= .(ratio) * Sepal.Width,
             Petal_Short = Petal.Length &lt;= 3.5)
print(exprs)

# library("rqdatatable")
# datasets::iris %.&gt;%
#  extend_se(., exprs) %.&gt;%
#  summary(.)

</code></pre>

<hr>
<h2 id='qc'>Quoting version of c() array concatenate.</h2><span id='topic+qc'></span>

<h3>Description</h3>

<p>The qc() function is intended to help quote user inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qc(..., .wrapr_private_var_env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qc_+3A_...">...</code></td>
<td>
<p>items to place into an array</p>
</td></tr>
<tr><td><code id="qc_+3A_.wrapr_private_var_env">.wrapr_private_var_env</code></td>
<td>
<p>environment to evaluate in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>qc() a convenience function allowing the user to elide
excess quotation marks.  It quotes its arguments instead
of evaluating them, except in the case of a nested
call to qc() or c().  Please see the examples for
typical uses both for named and un-named character vectors.
</p>
<p>qc() uses bquote() .() quasiquotation escaping notation.
Also take care: argumetns are parsed by R before being passed to
qc(). This means 01 is interpreted as 1 and a string such as 0z1
is a syntax error. Some notes on this can be found here:
https://github.com/WinVector/wrapr/issues/15#issuecomment-962092462
</p>


<h3>Value</h3>

<p>quoted array of character items
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qe">qe</a></code>, <code><a href="#topic+qae">qae</a></code>, <code><a href="base.html#topic+bquote">bquote</a></code>, <code><a href="#topic+bc">bc</a></code>, <code><a href="#topic+sx">sx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- "x"

qc(a) # returns the string "a" (not "x")

qc(.(a)) # returns the string "x" (not "a")

qc(.(a) := a) # returns c("x" = "a")

qc("a") # return the string "a" (not "\"a\"")

qc(sin(x))  # returns the string "sin(x)"

qc(a, qc(b, c)) # returns c("a", "b", "c")

qc(a, c("b", "c")) # returns c("a", "b", "c")

qc(x=a, qc(y=b, z=c)) # returns c(x="a", y="b", z="c")

qc('x'='a', wrapr::qc('y'='b', 'z'='c')) # returns c(x="a", y="b", z="c")

c(a = c(a="1", b="2")) # returns c(a.a = "1", a.b = "2")
qc(a = c(a=1, b=2)) # returns c(a.a = "1", a.b = "2")
qc(a := c(a=1, b=2)) # returns c(a.a = "1", a.b = "2")


</code></pre>

<hr>
<h2 id='qchar_frame'>Build a quoted data.frame.</h2><span id='topic+qchar_frame'></span>

<h3>Description</h3>

<p>A convenient way to build a character data.frame in legible transposed form.  Position of
first &quot;|&quot; (or other infix operator) determines number of columns
(all other infix operators are aliases for &quot;,&quot;).
Names are treated as character types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qchar_frame(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qchar_frame_+3A_...">...</code></td>
<td>
<p>cell names, first infix operator denotes end of header row of column names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>qchar_frame() uses bquote() .() quasiquotation escaping notation.  Because of this using dot
as a name in some places may fail if the dot looks like a function call.
</p>


<h3>Value</h3>

<p>character data.frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+draw_frame">draw_frame</a></code>, <code><a href="#topic+build_frame">build_frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
loss_name &lt;- "loss"
x &lt;- qchar_frame(
   measure,                      training,     validation |
   "minus binary cross entropy", .(loss_name), val_loss   |
   accuracy,                     acc,          val_acc    )
print(x)
str(x)
cat(draw_frame(x))

qchar_frame(
  x |
  1 |
  2 ) %.&gt;% str(.)

</code></pre>

<hr>
<h2 id='qe'>Quote expressions.</h2><span id='topic+qe'></span>

<h3>Description</h3>

<p>Accepts arbitrary un-parsed expressions as
to allow forms such as &quot;Sepal.Length &gt;= 2 * Sepal.Width&quot;.
(without the quotes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qe(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qe_+3A_...">...</code></td>
<td>
<p>assignment expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qe()</code> uses
<code>bquote()</code> <code>.()</code> quasiquotation escaping notation,
and <code>.(-)</code> &quot;string quotes, string to name&quot; notation.
</p>


<h3>Value</h3>

<p>array of quoted assignment expressions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qc">qc</a></code>, <code><a href="#topic+qae">qae</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ratio &lt;- 2

exprs &lt;- qe(Sepal.Length &gt;= ratio * Sepal.Width,
             Petal.Length &lt;= 3.5)
print(exprs)

exprs &lt;- qe(Sepal.Length &gt;= .(ratio) * Sepal.Width,
             Petal.Length &lt;= 3.5)
print(exprs)

</code></pre>

<hr>
<h2 id='qs'>Quote argument as a string.</h2><span id='topic+qs'></span>

<h3>Description</h3>

<p>qs() uses bquote() .() quasiquotation escaping notation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qs_+3A_s">s</code></td>
<td>
<p>expression to be quoted as a string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 7

qs(a == x)

qs(a == .(x))

</code></pre>

<hr>
<h2 id='reduceexpand'>Use function to reduce or expand arguments.</h2><span id='topic+reduceexpand'></span><span id='topic++25+7C.+25'></span><span id='topic++25.+7C+25'></span>

<h3>Description</h3>

<p><code>x %.|% f</code> stands for <code>f(x[[1]], x[[2]], ..., x[[length(x)]])</code>.
<code>v %|.% x</code> also stands for <code>f(x[[1]], x[[2]], ..., x[[length(x)]])</code>.
The two operators are the same, the variation just allowing the user to choose the order they write things.
The mnemonic is: &quot;data goes on the dot-side of the operator.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f %|.% args

args %.|% f
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceexpand_+3A_f">f</code></td>
<td>
<p>function.</p>
</td></tr>
<tr><td><code id="reduceexpand_+3A_args">args</code></td>
<td>
<p>argument list or vector, entries expanded as function arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the reduce operation is implemented by <code>do.call()</code>, so has
standard R named argument semantics.
</p>


<h3>Value</h3>

<p>f(args) where args elements become individual arguments of f.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>f %|.% args</code>: f reduce args
</p>
</li>
<li> <p><code>args %.|% f</code>: args expand f
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="base.html#topic+do.call">do.call</a></code>, <code><a href="base.html#topic+list">list</a></code>, <code><a href="base.html#topic+c">c</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
args &lt;- list('prefix_', c(1:3), '_suffix')
args %.|% paste0
# prefix_1_suffix" "prefix_2_suffix" "prefix_3_suffix"
paste0 %|.% args
# prefix_1_suffix" "prefix_2_suffix" "prefix_3_suffix"

</code></pre>

<hr>
<h2 id='restrictToNameAssignments'>Restrict an alias mapping list to things that look like name assignments</h2><span id='topic+restrictToNameAssignments'></span>

<h3>Description</h3>

<p>Restrict an alias mapping list to things that look like name assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrictToNameAssignments(alias, restrictToAllCaps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrictToNameAssignments_+3A_alias">alias</code></td>
<td>
<p>mapping list</p>
</td></tr>
<tr><td><code id="restrictToNameAssignments_+3A_restricttoallcaps">restrictToAllCaps</code></td>
<td>
<p>logical, if true only use all-capitalized keys</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string to string mapping
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
alias &lt;- list(region= 'east', str= "'seven'")
aliasR &lt;- restrictToNameAssignments(alias)
print(aliasR)


</code></pre>

<hr>
<h2 id='returnCapture'>Return an error to a file, environment (no names) or callback</h2><span id='topic+returnCapture'></span>

<h3>Description</h3>

<p>Return an error to a file, environment (no names) or callback
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnCapture(
  e,
  saveDest,
  cap,
  wrapperName,
  recallString = "do.call(p$fn, p$args)"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="returnCapture_+3A_e">e</code></td>
<td>
<p>caught exception</p>
</td></tr>
<tr><td><code id="returnCapture_+3A_savedest">saveDest</code></td>
<td>
<p>where to save</p>
</td></tr>
<tr><td><code id="returnCapture_+3A_cap">cap</code></td>
<td>
<p>saved arguments</p>
</td></tr>
<tr><td><code id="returnCapture_+3A_wrappername">wrapperName</code></td>
<td>
<p>name of wrapper</p>
</td></tr>
<tr><td><code id="returnCapture_+3A_recallstring">recallString</code></td>
<td>
<p>how to call function again</p>
</td></tr>
</table>

<hr>
<h2 id='seqi'>Increasing whole-number sequence.</h2><span id='topic+seqi'></span>

<h3>Description</h3>

<p>Return an in increaing whole-number sequence from a to b inclusive (return integer(0) if none such). Allows for safe iteraton.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqi(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqi_+3A_a">a</code></td>
<td>
<p>scalar lower bound</p>
</td></tr>
<tr><td><code id="seqi_+3A_b">b</code></td>
<td>
<p>scalar upper bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>whole number sequence
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# print 3, 4, and then 5
for(i in seqi(3, 5)) {
   print(i)
}

# empty
for(i in seqi(5, 2)) {
   print(i)
}

</code></pre>

<hr>
<h2 id='si'>Dot substitution string interpolation.</h2><span id='topic+si'></span>

<h3>Description</h3>

<p>String interpolation using <code>bquote</code>-stype .() notation. Pure R, no C/C++ code called.
<code>sinterp</code> and <code>si</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>si(
  str,
  ...,
  envir = parent.frame(),
  enclos = parent.frame(),
  match_pattern = "\\.\\((([^()]+)|(\\([^()]*\\)))+\\)",
  removal_patterns = c("^\\.\\(", "\\)$")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="si_+3A_str">str</code></td>
<td>
<p>charater string to be substituted into</p>
</td></tr>
<tr><td><code id="si_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="si_+3A_envir">envir</code></td>
<td>
<p>environemnt to look for values</p>
</td></tr>
<tr><td><code id="si_+3A_enclos">enclos</code></td>
<td>
<p>enclosing evaluation environment</p>
</td></tr>
<tr><td><code id="si_+3A_match_pattern">match_pattern</code></td>
<td>
<p>regexp to find substitution targets.</p>
</td></tr>
<tr><td><code id="si_+3A_removal_patterns">removal_patterns</code></td>
<td>
<p>regexps to remove markers from substitution targets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also
<a href="https://CRAN.R-project.org/package=R.utils">https://CRAN.R-project.org/package=R.utils</a>,
<a href="https://CRAN.R-project.org/package=rprintf">https://CRAN.R-project.org/package=rprintf</a>,
and <a href="https://CRAN.R-project.org/package=glue">https://CRAN.R-project.org/package=glue</a>.
</p>


<h3>Value</h3>

<p>modified strings
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strsplit_capture">strsplit_capture</a></code>, <code><a href="#topic+sinterp">sinterp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 7
si("x is .(x), x+1 is .(x+1)\n.(x) is odd is .(x%%2 == 1)")

# Because matching is done by a regular expression we
# can not use arbitrary depths of nested parenthesis inside
# the interpolation region.  The default regexp allows
# one level of nesting (and one can use {} in place
# of parens in many places).
si("sin(x*(x+1)) is .(sin(x*{x+1}))")

# We can also change the delimiters,
# in this case to !! through the first whitespace.
si(c("x is !!x , x+1 is !!x+1 \n!!x  is odd is !!x%%2==1"),
   match_pattern = '!![^[:space:]]+[[:space:]]?',
   removal_patterns = c("^!!", "[[:space:]]?$"))


</code></pre>

<hr>
<h2 id='sinterp'>Dot substitution string interpolation.</h2><span id='topic+sinterp'></span>

<h3>Description</h3>

<p>String interpolation using <code>bquote</code>-stype .() notation. Pure R, no C/C++ code called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sinterp(
  str,
  ...,
  envir = parent.frame(),
  enclos = parent.frame(),
  match_pattern = "\\.\\((([^()]+)|(\\([^()]*\\)))+\\)",
  removal_patterns = c("^\\.\\(", "\\)$")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sinterp_+3A_str">str</code></td>
<td>
<p>charater string(s) to be substituted into</p>
</td></tr>
<tr><td><code id="sinterp_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="sinterp_+3A_envir">envir</code></td>
<td>
<p>environemnt to look for values</p>
</td></tr>
<tr><td><code id="sinterp_+3A_enclos">enclos</code></td>
<td>
<p>enclosing evaluation environment</p>
</td></tr>
<tr><td><code id="sinterp_+3A_match_pattern">match_pattern</code></td>
<td>
<p>regexp to find substitution targets.</p>
</td></tr>
<tr><td><code id="sinterp_+3A_removal_patterns">removal_patterns</code></td>
<td>
<p>regexps to remove markers from substitution targets.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See also
<a href="https://CRAN.R-project.org/package=R.utils">https://CRAN.R-project.org/package=R.utils</a>,
<a href="https://CRAN.R-project.org/package=rprintf">https://CRAN.R-project.org/package=rprintf</a>,
and <a href="https://CRAN.R-project.org/package=glue">https://CRAN.R-project.org/package=glue</a>.
</p>


<h3>Value</h3>

<p>modified strings
</p>


<h3>See Also</h3>

<p><code><a href="#topic+strsplit_capture">strsplit_capture</a></code>, <code><a href="#topic+si">si</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- 7
sinterp("x is .(x), x+1 is .(x+1)\n.(x) is odd is .(x%%2 == 1)")

# Because matching is done by a regular expression we
# can not use arbitrary depths of nested parenthesis inside
# the interpolation region.  The default regexp allows
# one level of nesting (and one can use {} in place
# of parens in many places).
sinterp("sin(x*(x+1)) is .(sin(x*{x+1}))")

# We can also change the delimiters,
# in this case to !! through the first whitespace.
sinterp(c("x is !!x , x+1 is !!x+1 \n!!x  is odd is !!x%%2==1"),
        match_pattern = '!![^[:space:]]+[[:space:]]?',
        removal_patterns = c("^!!", "[[:space:]]?$"))

</code></pre>

<hr>
<h2 id='sortv'>Sort a data.frame.</h2><span id='topic+sortv'></span>

<h3>Description</h3>

<p>Sort a data.frame by a set of columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortv(
  data,
  colnames,
  ...,
  na.last = TRUE,
  decreasing = FALSE,
  method = c("auto", "shell", "radix")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortv_+3A_data">data</code></td>
<td>
<p>data.frame to sort.</p>
</td></tr>
<tr><td><code id="sortv_+3A_colnames">colnames</code></td>
<td>
<p>column names to sort on.</p>
</td></tr>
<tr><td><code id="sortv_+3A_...">...</code></td>
<td>
<p>not used, force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="sortv_+3A_na.last">na.last</code></td>
<td>
<p>(passed to <code><a href="base.html#topic+order">order</a></code>) for controlling the treatment of NAs. If TRUE, missing values in the data are put last; if FALSE, they are put first; if NA, they are removed.</p>
</td></tr>
<tr><td><code id="sortv_+3A_decreasing">decreasing</code></td>
<td>
<p>(passed to <code><a href="base.html#topic+order">order</a></code>) logical. Should the sort order be increasing or decreasing? For the &quot;radix&quot; method, this can be a vector of length equal to the number of arguments in <code>...</code>. For the other methods, it must be length one.</p>
</td></tr>
<tr><td><code id="sortv_+3A_method">method</code></td>
<td>
<p>(passed to <code><a href="base.html#topic+order">order</a></code>) the method to be used: partial matches are allowed. The default (&quot;auto&quot;) implies &quot;radix&quot; for short numeric vectors, integer vectors, logical vectors and factors. Otherwise, it implies &quot;shell&quot;. For details of methods &quot;shell&quot;, &quot;quick&quot;, and &quot;radix&quot;, see the help for <code><a href="base.html#topic+sort">sort</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ordering permutation
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderv">orderv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- data.frame(x = c(2, 2, 3, 3, 1, 1), y = 6:1)
sortv(d, c("x", "y"))

</code></pre>

<hr>
<h2 id='split_at_brace_pairs'>Split strings at -pairs.</h2><span id='topic+split_at_brace_pairs'></span>

<h3>Description</h3>

<p>Split strings at -pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_at_brace_pairs(s, open_symbol = "{", close_symbol = "}")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_at_brace_pairs_+3A_s">s</code></td>
<td>
<p>string or list of strings to split.</p>
</td></tr>
<tr><td><code id="split_at_brace_pairs_+3A_open_symbol">open_symbol</code></td>
<td>
<p>symbol to start marking.</p>
</td></tr>
<tr><td><code id="split_at_brace_pairs_+3A_close_symbol">close_symbol</code></td>
<td>
<p>symbol to end marking.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array or list of split strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
split_at_brace_pairs("{x} + y + {z}")

</code></pre>

<hr>
<h2 id='stop_if_dot_args'>Stop with message if dot_args is a non-trivial list.</h2><span id='topic+stop_if_dot_args'></span>

<h3>Description</h3>

<p>Generate a stop with a good error message if the dots argument was a non-trivial list.
Useful in writing functions that force named arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_if_dot_args(dot_args, msg = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stop_if_dot_args_+3A_dot_args">dot_args</code></td>
<td>
<p>substitute(list(...)) from another function.</p>
</td></tr>
<tr><td><code id="stop_if_dot_args_+3A_msg">msg</code></td>
<td>
<p>character, optional message to prepend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL or stop()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(x, ..., inc = 1) {
   stop_if_dot_args(substitute(list(...)), "f")
   x + inc
}
f(7)
f(7, inc = 2)
tryCatch(
  f(7, 2),
  error = function(e) { print(e) }
)

</code></pre>

<hr>
<h2 id='strsplit_capture'>Split a string, keeping separator regions</h2><span id='topic+strsplit_capture'></span>

<h3>Description</h3>

<p>Split a string, keeping separator regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplit_capture(
  x,
  split,
  ...,
  ignore.case = FALSE,
  fixed = FALSE,
  perl = FALSE,
  useBytes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strsplit_capture_+3A_x">x</code></td>
<td>
<p>character string to split (length 1 vector)</p>
</td></tr>
<tr><td><code id="strsplit_capture_+3A_split">split</code></td>
<td>
<p>split pattern</p>
</td></tr>
<tr><td><code id="strsplit_capture_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name</p>
</td></tr>
<tr><td><code id="strsplit_capture_+3A_ignore.case">ignore.case</code></td>
<td>
<p>passed to <code>gregexpr</code></p>
</td></tr>
<tr><td><code id="strsplit_capture_+3A_fixed">fixed</code></td>
<td>
<p>passed to <code>gregexpr</code></p>
</td></tr>
<tr><td><code id="strsplit_capture_+3A_perl">perl</code></td>
<td>
<p>passed to <code>gregexpr</code></p>
</td></tr>
<tr><td><code id="strsplit_capture_+3A_usebytes">useBytes</code></td>
<td>
<p>passed to <code>gregexpr</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of string segments annotated with is_sep.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sinterp">sinterp</a></code>, <code><a href="#topic+si">si</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
strsplit_capture("x is .(x) and x+1 is .(x+1)", "\\.\\([^()]+\\)")

</code></pre>

<hr>
<h2 id='sx'>String eXplode. Parse argument as a vector of string allowing &quot;blank separators&quot;.</h2><span id='topic+sx'></span>

<h3>Description</h3>

<p>Separates string data on whitespace and separating symbols into an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sx(s, ..., sep_symbols = ",|", strict = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sx_+3A_s">s</code></td>
<td>
<p>string to parse</p>
</td></tr>
<tr><td><code id="sx_+3A_...">...</code></td>
<td>
<p>force later arguments to be set by name</p>
</td></tr>
<tr><td><code id="sx_+3A_sep_symbols">sep_symbols</code></td>
<td>
<p>characters to consider separators</p>
</td></tr>
<tr><td><code id="sx_+3A_strict">strict</code></td>
<td>
<p>logical, if TRUE throw exception on confusing input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can throw exception on lack of explicit value separators, example: <code>bc('"a""b"')</code> and  non-matching portions.
Whitespace is normalized to spaces.
Suggested by Emil Erik Pula Bellamy Begtrup-Bright <a href="https://github.com/WinVector/wrapr/issues/15">https://github.com/WinVector/wrapr/issues/15</a>.
</p>


<h3>Value</h3>

<p>vector of values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qc">qc</a></code>, <code><a href="#topic+qe">qe</a></code>, <code><a href="#topic+qae">qae</a></code>, <code><a href="base.html#topic+bquote">bquote</a></code>, <code><a href="#topic+bc">bc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sx('1 2 "c", d') # returns c("1", "2", "c", "d")
sx('1 2 3') # returns c("1", "2", "3")
sx('1 2 "3"') # returns c("1", "2", "3")
sx('1,2|3.4') # returns c("1", "2", "3.4")
sx('01 02') # returns c("01", "02")

</code></pre>

<hr>
<h2 id='to'>Unpack or bind values by names into the calling environment, eager eval (no-dot) variation.</h2><span id='topic+to'></span>

<h3>Description</h3>

<p>Unpacks or binds values into the calling environment, eager eval (no-dot) variation. Uses <code>bquote</code> escaping.
NULL is a special case that is unpacked to all targets. NA targets are skipped.
All non-NA target names must be unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_+3A_...">...</code></td>
<td>
<p>argument names to write to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: when using <code>[]&lt;-</code> notation, a reference to the unpacker object is written into the unpacking environment as a side-effect
of the implied array assignment. <code>:=</code> assigment does not have this side-effect.
Array-assign form can not use the names: <code>.</code>, <code>wrapr_private_self</code>, <code>value</code>, or <code>to</code>.
function form can not use the names: <code>.</code> or <code>wrapr_private_value</code>.
For more detials please see here <a href="https://win-vector.com/2020/01/20/unpack-your-values-in-r/">https://win-vector.com/2020/01/20/unpack-your-values-in-r/</a>.
</p>
<p>Related work includes <code>Python</code> tuple unpacking, <code>zeallot</code>'s arrow, and <code>vadr::bind</code>.
</p>


<h3>Value</h3>

<p>a UnpackTarget
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# named unpacking
# looks like assignment: DESTINATION = NAME_VALUE_USING
d &lt;- data.frame(x = 1:2,
                g=c('test', 'train'),
                stringsAsFactors = FALSE)
to[train_set = train, test_set = test] := split(d, d$g)
# train_set and test_set now correctly split
print(train_set)
print(test_set)
rm(list = c('train_set', 'test_set'))

# named unpacking NEWNAME = OLDNAME implicit form
# values are matched by name, not index
to[train, test] := split(d, d$g)
print(train)
print(test)
rm(list = c('train', 'test'))

# pipe version (notice no dot)
split(d, d$g) %.&gt;% to(train, test)
print(train)
print(test)
rm(list = c('train', 'test'))
# Note: above is wrapr dot-pipe, piping does not currently work with
# magrittr pipe due to magrittr's introduction of temporary
# intermediate environments during evaluation.

# bquote example
train_col_name &lt;- 'train'
test_col_name &lt;- 'test'
to[train = .(train_col_name), test = .(test_col_name)] := split(d, d$g)
print(train)
print(test)
rm(list = c('train', 'test'))

</code></pre>

<hr>
<h2 id='uniques'>Strict version of unique (without ...).</h2><span id='topic+uniques'></span>

<h3>Description</h3>

<p>Check that <code>...</code> is empty and if so call
<code>base::unique(x, incomparables = incomparables, MARGIN = MARGIN, fromLast = fromLast)</code>
(else throw an error)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniques(x, ..., incomparables = FALSE, MARGIN = 1, fromLast = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniques_+3A_x">x</code></td>
<td>
<p>items to be compared.</p>
</td></tr>
<tr><td><code id="uniques_+3A_...">...</code></td>
<td>
<p>not used, checked to be empty to prevent errors.</p>
</td></tr>
<tr><td><code id="uniques_+3A_incomparables">incomparables</code></td>
<td>
<p>passed to base::unique.</p>
</td></tr>
<tr><td><code id="uniques_+3A_margin">MARGIN</code></td>
<td>
<p>passed to base::unique.</p>
</td></tr>
<tr><td><code id="uniques_+3A_fromlast">fromLast</code></td>
<td>
<p>passed to base::unique.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>base::unique(x, incomparables = incomparables, MARGIN = MARGIN, fromLast = fromLast)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c("a", "b")
y = c("b", "c")

# task: get unique items in x plus y
unique(c(x, y))   # correct answer
unique(x, y)      # oops forgot to wrap arguments, quietly get wrong answer
tryCatch(
   uniques(x, y), # uniques catches the error
   error = function(e) { e })
uniques(c(x, y))  # uniques works like base::unique in most case

</code></pre>

<hr>
<h2 id='unpack'>Unpack or bind values by names into the calling environment.</h2><span id='topic+unpack'></span>

<h3>Description</h3>

<p>Unpacks or binds values into the calling environment. Uses <code>bquote</code> escaping.
NULL is a special case that is unpacked to all targets. NA targets are skipped.
All non-NA target names must be unique.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unpack(wrapr_private_value, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unpack_+3A_wrapr_private_value">wrapr_private_value</code></td>
<td>
<p>list of values to copy</p>
</td></tr>
<tr><td><code id="unpack_+3A_...">...</code></td>
<td>
<p>argument names to write to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: when using <code>[]&lt;-</code> notation, a reference to the unpacker object is written into the unpacking environment as a side-effect
of the implied array assignment. <code>:=</code> assigment does not have this side-effect.
Array-assign form can not use the names: <code>.</code>, <code>wrapr_private_self</code>, <code>value</code>, or <code>unpack</code>.
Function form can not use the names: <code>.</code> or <code>wrapr_private_value</code>.
For more details please see here <a href="https://win-vector.com/2020/01/20/unpack-your-values-in-r/">https://win-vector.com/2020/01/20/unpack-your-values-in-r/</a>.
</p>
<p>Related work includes <code>Python</code> tuple unpacking, <code>zeallot</code>'s arrow, and <code>vadr::bind</code>.
</p>


<h3>Value</h3>

<p>value passed in (invisible)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pack">pack</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# named unpacking
# looks like assignment: DESTINATION = NAME_VALUE_USING
d &lt;- data.frame(x = 1:2,
                g=c('test', 'train'),
                stringsAsFactors = FALSE)
unpack[train_set = train, test_set = test] := split(d, d$g)
# train_set and test_set now correctly split
print(train_set)
print(test_set)
rm(list = c('train_set', 'test_set'))

# named unpacking NEWNAME = OLDNAME implicit form
# values are matched by name, not index
unpack[train, test] := split(d, d$g)
print(train)
print(test)
rm(list = c('train', 'test'))

# function version
unpack(split(d, d$g), train, test)
print(train)
print(test)
rm(list = c('train', 'test'))

# pipe version
split(d, d$g) %.&gt;% unpack(., train, test)
print(train)
print(test)
rm(list = c('train', 'test'))
# Note: above is wrapr dot-pipe, piping does not currently work with
# magrittr pipe due to magrittr's introduction of temporary
# intermediate environments during evaluation.

# bquote example
train_col_name &lt;- 'train'
test_col_name &lt;- 'test'
unpack(split(d, d$g), train = .(train_col_name), test = .(test_col_name))
print(train)
print(test)
rm(list = c('train', 'test'))

</code></pre>

<hr>
<h2 id='UnpackerF'>Create a value unpacking object (function version).</h2><span id='topic+UnpackerF'></span>

<h3>Description</h3>

<p>Create a value unplacking object that records it is stored by name <code>object_name</code> (function version).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnpackerF(object_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnpackerF_+3A_object_name">object_name</code></td>
<td>
<p>character, name the object is stored as</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Array-assign form can not use the names: <code>.</code>, <code>wrapr_private_self</code>, <code>value</code>, or the name stored in <code>object_name</code>.
function form can not use the names: <code>.</code> or <code>wrapr_private_value</code>.
Array-form with <code>=</code>, <code>&lt;-</code>, <code>-&gt;</code> will write own name into working environment
as a side-effect. Array-form with <code>:=</code> does not have the side-effect.
</p>


<h3>Value</h3>

<p>an unpacker
</p>

<hr>
<h2 id='UnpackerP'>Create a value unpacking object (eager pipe version).</h2><span id='topic+UnpackerP'></span>

<h3>Description</h3>

<p>Create a value unplacking object that records it is stored by name <code>object_name</code> (eager pipe version).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnpackerP(object_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnpackerP_+3A_object_name">object_name</code></td>
<td>
<p>character, name the object is stored as</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Array-assign form can not use the names: <code>.</code>, <code>wrapr_private_self</code>, <code>value</code>, or the name stored in <code>object_name</code>.
function form can not use the names: <code>.</code> or <code>wrapr_private_value</code>.
Array-form with <code>=</code>, <code>&lt;-</code>, <code>-&gt;</code> will write own name into working environment
as a side-effect. Array-form with <code>:=</code> does not have the side-effect.
</p>


<h3>Value</h3>

<p>an unpacker
</p>

<hr>
<h2 id='vapplym'>Memoizing wrapper for vapply.</h2><span id='topic+vapplym'></span>

<h3>Description</h3>

<p>Memoizing wrapper for vapply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vapplym(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vapplym_+3A_x">X</code></td>
<td>
<p>list or vector of inputs</p>
</td></tr>
<tr><td><code id="vapplym_+3A_fun">FUN</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="vapplym_+3A_fun.value">FUN.VALUE</code></td>
<td>
<p>type of vector to return</p>
</td></tr>
<tr><td><code id="vapplym_+3A_...">...</code></td>
<td>
<p>additional arguments passed to lapply</p>
</td></tr>
<tr><td><code id="vapplym_+3A_use.names">USE.NAMES</code></td>
<td>
<p>passed to vapply</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of results.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VectorizeM">VectorizeM</a></code>, <code><a href="#topic+lapplym">lapplym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fs &lt;- function(x) { x &lt;- x[[1]]; print(paste("see", x)); sin(x) }
# should only print "see" twice, not 6 times
vapplym(c(0, 1, 1, 0, 0, 1), fs, numeric(1))

</code></pre>

<hr>
<h2 id='VectorizeM'>Memoizing wrapper to base::Vectorize()</h2><span id='topic+VectorizeM'></span>

<h3>Description</h3>

<p>Build a wrapped function that applies to each unique argument in a vector of arguments once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VectorizeM(
  FUN,
  vectorize.args = arg.names,
  SIMPLIFY = TRUE,
  USE.NAMES = TRUE,
  UNLIST = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VectorizeM_+3A_fun">FUN</code></td>
<td>
<p>function to apply</p>
</td></tr>
<tr><td><code id="VectorizeM_+3A_vectorize.args">vectorize.args</code></td>
<td>
<p>a character vector of arguments which should be vectorized. Defaults to first argument of FUN.  If set must be length 1.</p>
</td></tr>
<tr><td><code id="VectorizeM_+3A_simplify">SIMPLIFY</code></td>
<td>
<p>logical or character string; attempt to reduce the result to a vector, matrix or higher dimensional array; see the simplify argument of sapply.</p>
</td></tr>
<tr><td><code id="VectorizeM_+3A_use.names">USE.NAMES</code></td>
<td>
<p>logical; use names if the first ... argument has names, or if it is a character vector, use that character vector as the names.</p>
</td></tr>
<tr><td><code id="VectorizeM_+3A_unlist">UNLIST</code></td>
<td>
<p>logical; if TRUE try to unlist the result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only sensible for pure side-effect free deterministic functions.
</p>


<h3>Value</h3>

<p>adapted function (vectorized with one call per different value).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Vectorize">Vectorize</a></code>, <code><a href="#topic+vapplym">vapplym</a></code>, <code><a href="#topic+lapplym">lapplym</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fs &lt;- function(x) { x &lt;- x[[1]]; print(paste("see", x)); sin(x) }
fv &lt;- VectorizeM(fs)
# should only print "see" twice, not 6 times
fv(c(0, 1, 1, 0, 0, 1))

</code></pre>

<hr>
<h2 id='view'>Invoke a spreadsheet like viewer when appropriate.</h2><span id='topic+view'></span>

<h3>Description</h3>

<p>Invoke a spreadsheet like viewer when appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view(x, ..., title = wrapr_deparse(substitute(x)), n = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_+3A_x">x</code></td>
<td>
<p>R object to view</p>
</td></tr>
<tr><td><code id="view_+3A_...">...</code></td>
<td>
<p>force later arguments to bind by name.</p>
</td></tr>
<tr><td><code id="view_+3A_title">title</code></td>
<td>
<p>title for viewer</p>
</td></tr>
<tr><td><code id="view_+3A_n">n</code></td>
<td>
<p>number of rows to show</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invoke view or format object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
view(mtcars)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
