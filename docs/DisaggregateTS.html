<!DOCTYPE html><html lang="en"><head><title>Help for package DisaggregateTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DisaggregateTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARcov'><p>Function to generate an AR(1) variance-covariance matrix with parameter rho s.t. <code class="reqn">\lvert \rho\rvert  &lt; 1</code>.</p></a></li>
<li><a href='#ARcov_lit'><p>Function to generate an ARIMA(1,1,0) variance-covariance matrix for the Litterman method with parameter <code class="reqn">\rho</code> such that <code class="reqn">\lvert \rho \rvert &lt; 1</code>.</p></a></li>
<li><a href='#chowlin'><p>Function to perform Chow-Lin temporal disaggregation from Chow and Lin (1971)</p>
and its special case counterpart, Litterman Litterman (1983).</a></li>
<li><a href='#chowlin_likelihood'><p>Likelihood function for Chow-Lin or Litterman temporal disaggregation.</p></a></li>
<li><a href='#Data'><p>GHG Emissions and Financial Data for IBM</p></a></li>
<li><a href='#disaggregate'><p>Temporal Disaggregation Methods</p></a></li>
<li><a href='#hdBIC'><p>High-dimensional BIC score</p></a></li>
<li><a href='#k.index'><p>Index of support for LARS algorithm in high-dimensional settings</p></a></li>
<li><a href='#refit'><p>Refit LASSO estimate into GLS</p></a></li>
<li><a href='#simulDiagnosis'><p>Simulation Diagnostics</p></a></li>
<li><a href='#sptd'><p>Sparse Temporal Disaggregation</p></a></li>
<li><a href='#sptd_BIC'><p>BIC Score for Sparse Temporal Disaggregation</p></a></li>
<li><a href='#TempDisaggDGP'><p>High and Low-Frequency Data Generating Processes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Temporal Disaggregation</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for temporal disaggregation, including:
    (1) High-dimensional and low-dimensional series generation for simulation studies;
    (2) A toolkit for temporal disaggregation and benchmarking using low-dimensional indicator series 
        as proposed by Dagum and Cholette (2006, ISBN:978-0-387-35439-2);
    (3) Novel techniques by Mosley, Gibberd, and Eckley (2022, &lt;<a href="https://doi.org/10.1111%2Frssa.12952">doi:10.1111/rssa.12952</a>&gt;)
        for disaggregating low-frequency series in the presence of high-dimensional indicator matrices.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rdpack, stats, Matrix, lars, zoo, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, readxl, corrplot,
ggplot2</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-31 05:35:23 UTC; ksalehza</td>
</tr>
<tr>
<td>Author:</td>
<td>Kaveh Salehzadeh Nobari [aut, cre],
  Luke Mosley [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kaveh Salehzadeh Nobari &lt;k.salehzadeh-nobari@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-31 12:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARcov'>Function to generate an AR(1) variance-covariance matrix with parameter rho s.t. <code class="reqn">\lvert \rho\rvert  &lt; 1</code>.</h2><span id='topic+ARcov'></span>

<h3>Description</h3>

<p>Function to generate an AR(1) variance-covariance matrix with parameter rho s.t. <code class="reqn">\lvert \rho\rvert  &lt; 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARcov(rho, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARcov_+3A_rho">rho</code></td>
<td>
<p>Numeric value representing the autocorrelation parameter. Must satisfy |rho| &lt; 1.</p>
</td></tr>
<tr><td><code id="ARcov_+3A_n">n</code></td>
<td>
<p>Integer representing the size of the matrix (n x n).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix of size n x n based on the AR(1) process.
</p>

<hr>
<h2 id='ARcov_lit'>Function to generate an ARIMA(1,1,0) variance-covariance matrix for the Litterman method with parameter <code class="reqn">\rho</code> such that <code class="reqn">\lvert \rho \rvert &lt; 1</code>.</h2><span id='topic+ARcov_lit'></span>

<h3>Description</h3>

<p>Function to generate an ARIMA(1,1,0) variance-covariance matrix for the Litterman method with parameter <code class="reqn">\rho</code> such that <code class="reqn">\lvert \rho \rvert &lt; 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARcov_lit(rho, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARcov_lit_+3A_rho">rho</code></td>
<td>
<p>Numeric value representing the autocorrelation parameter. Must satisfy <code class="reqn">\lvert \rho \rvert &lt; 1</code>.</p>
</td></tr>
<tr><td><code id="ARcov_lit_+3A_n">n</code></td>
<td>
<p>Integer representing the size of the matrix <code class="reqn">(n x n)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variance-covariance matrix of size <code class="reqn">(n x n)</code> for the ARIMA(1,1,0) process, used in the Litterman method.
</p>

<hr>
<h2 id='chowlin'>Function to perform Chow-Lin temporal disaggregation from Chow and Lin (1971)
and its special case counterpart, Litterman Litterman (1983).</h2><span id='topic+chowlin'></span>

<h3>Description</h3>

<p>Used in <code><a href="#topic+disaggregate">disaggregate</a></code> to find estimates given the optimal <code class="reqn">rho</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chowlin(Y, X, rho, aggMat = "sum", aggRatio = 4, litterman = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chowlin_+3A_y">Y</code></td>
<td>
<p>The low-frequency response series (a <code class="reqn">n_l \times 1</code> matrix).</p>
</td></tr>
<tr><td><code id="chowlin_+3A_x">X</code></td>
<td>
<p>The high-frequency indicator series (a <code class="reqn">n \times p</code> matrix).</p>
</td></tr>
<tr><td><code id="chowlin_+3A_rho">rho</code></td>
<td>
<p>The AR(1) residual parameter. Must be strictly between <code class="reqn">-1</code> and <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="chowlin_+3A_aggmat">aggMat</code></td>
<td>
<p>Aggregation matrix method: 'first', 'sum', 'average', 'last'. Default is 'sum'.</p>
</td></tr>
<tr><td><code id="chowlin_+3A_aggratio">aggRatio</code></td>
<td>
<p>Aggregation ratio, e.g. 4 for annual-to-quarterly, 3 for quarterly-to-monthly. Default is 4.</p>
</td></tr>
<tr><td><code id="chowlin_+3A_litterman">litterman</code></td>
<td>
<p>Boolean. If TRUE, use Litterman variance-covariance method, otherwise use Chow-Lin. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li> <p><code>y</code>: Estimated high-frequency response series (an <code class="reqn">n \times 1</code> matrix).
</p>
</li>
<li> <p><code>betaHat</code>: Estimated coefficient vector (a <code class="reqn">p \times 1</code> matrix).
</p>
</li>
<li> <p><code>u_l</code>: Estimated aggregate residual series (an <code class="reqn">n_l \times 1</code> matrix).
</p>
</li></ul>



<h3>References</h3>

<p>Chow GC, Lin A (1971).
&ldquo;Best Linear Unbiased Interpolation, Distribution, and Extrapolation of Time Series by Related Series.&rdquo;
<em>The review of Economics and Statistics</em>, <b>53</b>(4), 372&ndash;375.<br /><br /> Litterman RB (1983).
&ldquo;A random walk, Markov model for the distribution of time series.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>1</b>(2), 169&ndash;173.
</p>

<hr>
<h2 id='chowlin_likelihood'>Likelihood function for Chow-Lin or Litterman temporal disaggregation.</h2><span id='topic+chowlin_likelihood'></span>

<h3>Description</h3>

<p>This function computes the likelihood function used in temporal disaggregation to find the optimal <code class="reqn">\rho</code> parameter.
It is used in conjunction with <code><a href="#topic+disaggregate">disaggregate</a></code> to estimate the autocorrelation coefficient <code class="reqn">\rho</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chowlin_likelihood(Y, X, vcov)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chowlin_likelihood_+3A_y">Y</code></td>
<td>
<p>The low-frequency response series (an <code class="reqn">n_l \times 1</code> matrix).</p>
</td></tr>
<tr><td><code id="chowlin_likelihood_+3A_x">X</code></td>
<td>
<p>The aggregated high-frequency indicator series (an <code class="reqn">n_l \times p</code> matrix).</p>
</td></tr>
<tr><td><code id="chowlin_likelihood_+3A_vcov">vcov</code></td>
<td>
<p>Aggregated variance-covariance matrix for the Chow-Lin or Litterman residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<div class="sourceCode"><pre>    The log-likelihood value for the given parameters.
</pre></div>

<hr>
<h2 id='Data'>GHG Emissions and Financial Data for IBM</h2><span id='topic+Data'></span>

<h3>Description</h3>

<p>This dataset contains time series data on greenhouse gas (GHG) emissions
and financial variables for IBM covering the period from Q3 2005 to Q3 2021.
It is designed for use in demonstrating temporal disaggregation and adaptive LASSO methods
for estimating high-frequency GHG emissions from low-frequency data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Data
</code></pre>


<h3>Format</h3>

<p>A data frame with 68 rows (representing quarters) and 113 variables:
</p>

<dl>
<dt>time</dt><dd><p>Numeric vector representing the time index, spanning from Q3 2005 to Q3 2021</p>
</dd>
<dt>GHG</dt><dd><p>Numeric vector of annual greenhouse gas emissions for IBM, recorded annually and repeated quarterly</p>
</dd>
<dt>financial_variables</dt><dd><p>A matrix or data frame of 112 financial variables, extracted from quarterly balance sheets, income statements, and cash flow statements for each company</p>
</dd>
</dl>



<h3>Source</h3>

<p>Original data collected from financial statements and GHG reports of IBM.
</p>

<hr>
<h2 id='disaggregate'>Temporal Disaggregation Methods</h2><span id='topic+disaggregate'></span>

<h3>Description</h3>

<p>This function contains the traditional standard-dimensional temporal disaggregation methods proposed by Denton (1971), Dagum and Cholette (2006),
Chow and Lin (1971), Fernández (1981) and Litterman (1983),
and the high-dimensional methods of Mosley et al. (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disaggregate(
  Y,
  X = matrix(data = rep(1, times = (nrow(Y) * aggRatio)), nrow = (nrow(Y) * aggRatio)),
  aggMat = "sum",
  aggRatio = 4,
  method = "Chow-Lin",
  Denton = "additive-first-diff"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disaggregate_+3A_y">Y</code></td>
<td>
<p>The low-frequency response series (<code class="reqn">n_l \times 1</code> matrix).</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_x">X</code></td>
<td>
<p>The high-frequency indicator series (<code class="reqn">n \times p</code> matrix).</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_aggmat">aggMat</code></td>
<td>
<p>Aggregation matrix according to 'first', 'sum', 'average', 'last' (default is 'sum').</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_aggratio">aggRatio</code></td>
<td>
<p>Aggregation ratio e.g. 4 for annual-to-quarterly, 3 for quarterly-to-monthly (default is 4).</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_method">method</code></td>
<td>
<p>Disaggregation method using 'Denton', 'Denton-Cholette', 'Chow-Lin', 'Fernandez', 'Litterman', 'spTD' or 'adaptive-spTD' (default is 'Chow-Lin').</p>
</td></tr>
<tr><td><code id="disaggregate_+3A_denton">Denton</code></td>
<td>
<p>Type of differencing for Denton method: 'simple-diff', 'additive-first-diff', 'additive-second-diff', 'proportional-first-diff' and 'proportional-second-diff' (default is 'additive-first-diff'). For instance, 'simple-diff' differencing refers to the differences between the original and revised values, whereas 'additive-first-diff' differencing refers to the differences between the first differenced original and revised values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Takes in a <code class="reqn">n_l \times 1</code> low-frequency series to be disaggregated <code class="reqn">Y</code> and a <code class="reqn">n \times p</code> high-frequency matrix of p indicator series <code class="reqn">X</code>. If <code class="reqn">n &gt; n_l \times aggRatio</code> where <code class="reqn">aggRatio</code>
is the aggregation ratio (e.g. <code class="reqn">aggRatio = 4</code> if annual-to-quarterly disagg, or <code class="reqn">aggRatio = 3</code> if quarterly-to-monthly disagg) then extrapolation is done
to extrapolate up to <code class="reqn">n</code>.
</p>


<h3>Value</h3>

<p><code>y_Est</code>:	  Estimated high-frequency response series (output is an <code class="reqn">n \times 1</code> matrix).
</p>
<p><code>beta_Est</code>:	Estimated coefficient vector (output is a <code class="reqn">p \times 1</code> matrix).
</p>
<p><code>rho_Est</code>:	Estimated residual AR(1) autocorrelation parameter.
</p>
<p><code>ul_Est</code>:	  Estimated aggregate residual series (output is an <code class="reqn">n_l \times 1</code> matrix).
</p>


<h3>References</h3>

<p>Chow GC, Lin A (1971).
&ldquo;Best Linear Unbiased Interpolation, Distribution, and Extrapolation of Time Series by Related Series.&rdquo;
<em>The review of Economics and Statistics</em>, <b>53</b>(4), 372&ndash;375.<br /><br /> Dagum EB, Cholette PA (2006).
<em>Benchmarking, Temporal Distribution, and Reconciliation Methods for Time Series</em>.
Springer.<br /><br /> Denton FT (1971).
&ldquo;Adjustment of monthly or quarterly series to annual totals: an approach based on quadratic minimization.&rdquo;
<em>Journal of the american statistical association</em>, <b>66</b>(333), 99&ndash;102.<br /><br /> Fernández RB (1981).
&ldquo;A methodological note on the estimation of time series.&rdquo;
<em>The Review of Economics and Statistics</em>, <b>63</b>(3), 471&ndash;476.<br /><br /> Litterman RB (1983).
&ldquo;A random walk, Markov model for the distribution of time series.&rdquo;
<em>Journal of Business &amp; Economic Statistics</em>, <b>1</b>(2), 169&ndash;173.<br /><br /> Mosley L, Eckley IA, Gibberd A (2022).
&ldquo;Sparse Temporal Disaggregation.&rdquo;
<em>Journal of the Royal Statistical Society Series A: Statistics in Society</em>, <b>185</b>(4), 2203-2233.
ISSN 0964-1998, <a href="https://doi.org/10.1111/rssa.12952">doi:10.1111/rssa.12952</a>, https://academic.oup.com/jrsssa/article-pdf/185/4/2203/49420183/jrsssa_185_4_2203.pdf.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- TempDisaggDGP(n_l=25,n=100,p=10,rho=0.5)
X &lt;- data$X_Gen
Y &lt;- data$Y_Gen
fit_chowlin &lt;- disaggregate(Y=Y,X=X,method='Chow-Lin')
y_hat = fit_chowlin$y_Est
</code></pre>

<hr>
<h2 id='hdBIC'>High-dimensional BIC score</h2><span id='topic+hdBIC'></span>

<h3>Description</h3>

<p>This function calculates a BIC score that performs better than the ordinary BIC in high-dimensional scenarios.
It uses the variance estimator given in Yu and Bien (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdBIC(X, Y, covariance, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdBIC_+3A_x">X</code></td>
<td>
<p>Aggregated indicator series matrix that has been GLS rotated (an <code class="reqn">n_l \times p</code> matrix).</p>
</td></tr>
<tr><td><code id="hdBIC_+3A_y">Y</code></td>
<td>
<p>Low-frequency response vector that has been GLS rotated (an <code class="reqn">n_l \times 1</code> vector).</p>
</td></tr>
<tr><td><code id="hdBIC_+3A_covariance">covariance</code></td>
<td>
<p>Aggregated AR covariance matrix (an <code class="reqn">n_l \times n_l</code> matrix).</p>
</td></tr>
<tr><td><code id="hdBIC_+3A_beta">beta</code></td>
<td>
<p>Estimate of the regression coefficients (a <code class="reqn">p \times 1</code> vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<div class="sourceCode"><pre>      The BIC score for model comparison.
</pre></div>


<h3>References</h3>

<p>Yu G, Bien J (2019).
&ldquo;Estimating the error variance in a high-dimensional linear model.&rdquo;
<em>Biometrika</em>, <b>106</b>(3), 533&ndash;546.
</p>

<hr>
<h2 id='k.index'>Index of support for LARS algorithm in high-dimensional settings</h2><span id='topic+k.index'></span>

<h3>Description</h3>

<p>This function returns the index where the support of beta coefficients exceeds <code class="reqn">n_l/2</code>,
preventing the BIC from becoming erratic in high-dimensional scenarios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k.index(coef_matrix, n_l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="k.index_+3A_coef_matrix">coef_matrix</code></td>
<td>
<p>A matrix of beta coefficients, where rows represent different models.</p>
</td></tr>
<tr><td><code id="k.index_+3A_n_l">n_l</code></td>
<td>
<p>The length of the low-frequency response series.</p>
</td></tr>
</table>


<h3>Value</h3>

<div class="sourceCode"><pre>       The index where the support of beta exceeds \eqn{n_l/2}, or the number of rows of the matrix if no such index is found.
</pre></div>

<hr>
<h2 id='refit'>Refit LASSO estimate into GLS</h2><span id='topic+refit'></span>

<h3>Description</h3>

<p>This function reduces the bias in LASSO estimates by re-fitting the
active set of coefficients back into GLS (Generalized Least Squares).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refit(X, Y, beta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refit_+3A_x">X</code></td>
<td>
<p>Aggregated indicator series matrix that has been GLS rotated (an <code class="reqn">n_l \times p</code> matrix).</p>
</td></tr>
<tr><td><code id="refit_+3A_y">Y</code></td>
<td>
<p>Low-frequency response vector that has been GLS rotated (an <code class="reqn">n_l \times 1</code> vector).</p>
</td></tr>
<tr><td><code id="refit_+3A_beta">beta</code></td>
<td>
<p>Estimated beta coefficients from the LARS algorithm (a <code class="reqn">p \times 1</code> vector).</p>
</td></tr>
</table>


<h3>Value</h3>

<div class="sourceCode"><pre> A debiased estimate of the beta coefficients (a \eqn{p \times 1} vector).
</pre></div>

<hr>
<h2 id='simulDiagnosis'>Simulation Diagnostics</h2><span id='topic+simulDiagnosis'></span>

<h3>Description</h3>

<p>This function provides diagnostics for evaluating the accuracy of simulated data. Specifically, it computes the Mean Squared Error (MSE) between the true and estimated response vectors, and optionally, the sign recovery percentage of the coefficient vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulDiagnosis(data_Hat, data_True, sgn = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulDiagnosis_+3A_data_hat">data_Hat</code></td>
<td>
<p>List containing the estimated high-frequency data, with components <code>y_Est</code> (estimated response vector) and <code>beta_Est</code> (estimated coefficient vector).</p>
</td></tr>
<tr><td><code id="simulDiagnosis_+3A_data_true">data_True</code></td>
<td>
<p>List containing the true high-frequency data, with components <code>y_Gen</code> (true response vector) and <code>Beta_Gen</code> (true coefficient vector).</p>
</td></tr>
<tr><td><code id="simulDiagnosis_+3A_sgn">sgn</code></td>
<td>
<p>Logical value indicating whether to compute the sign recovery percentage. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes in the generated high-frequency data (<code>data_True</code>) and the estimated high-frequency data (<code>data_Hat</code>), and returns the Mean Squared Error (MSE) between the true and estimated values of the response vector. If the <code>sgn</code> parameter is set to <code>TRUE</code>, the function additionally computes the percentage of correctly recovered signs of the coefficient vector.
</p>


<h3>Value</h3>

<p>If <code>sgn</code> is <code>FALSE</code>, the function returns the Mean Squared Error (MSE) between the true and estimated response vectors. If <code>sgn</code> is <code>TRUE</code>, the function returns a list containing both the MSE and the sign recovery percentage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true_data &lt;- list(y_Gen = c(1, 2, 3), Beta_Gen = c(1, -1, 0))
est_data &lt;- list(y_Est = c(1.1, 1.9, 2.8), beta_Est = c(1, 1, 0))
mse &lt;- simulDiagnosis(est_data, true_data)
results &lt;- simulDiagnosis(est_data, true_data, sgn = TRUE)

</code></pre>

<hr>
<h2 id='sptd'>Sparse Temporal Disaggregation</h2><span id='topic+sptd'></span>

<h3>Description</h3>

<p>This function performs sparse temporal disaggregation as described in Mosley et al. (2022).
It estimates the high-frequency response series using LARS (Least Angle Regression) and applies either a LASSO or adaptive LASSO penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sptd(Y, X, rho, aggMat = "sum", aggRatio = 4, adaptive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sptd_+3A_y">Y</code></td>
<td>
<p>The low-frequency response series (<code class="reqn">n_l \times 1</code> matrix).</p>
</td></tr>
<tr><td><code id="sptd_+3A_x">X</code></td>
<td>
<p>The high-frequency indicator series (<code class="reqn">n \times p</code> matrix).</p>
</td></tr>
<tr><td><code id="sptd_+3A_rho">rho</code></td>
<td>
<p>The AR(<code class="reqn">1</code>) residual parameter (must be strictly between <code class="reqn">-1</code> and <code class="reqn">1</code>).</p>
</td></tr>
<tr><td><code id="sptd_+3A_aggmat">aggMat</code></td>
<td>
<p>Aggregation matrix method ('first', 'sum', 'average', 'last'). Default is 'sum'.</p>
</td></tr>
<tr><td><code id="sptd_+3A_aggratio">aggRatio</code></td>
<td>
<p>Aggregation ratio (e.g., 4 for annual-to-quarterly, 3 for quarterly-to-monthly). Default is 4.</p>
</td></tr>
<tr><td><code id="sptd_+3A_adaptive">adaptive</code></td>
<td>
<p>Logical. If <code>TRUE</code>, use adaptive LASSO penalty. If <code>FALSE</code>, use standard LASSO penalty. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>y</code>: Estimated high-frequency response series (<code class="reqn">n \times 1</code> matrix).
</p>
</li>
<li> <p><code>betaHat</code>: Estimated coefficient vector (<code class="reqn">p \times 1</code> matrix).
</p>
</li>
<li> <p><code>u_l</code>: Estimated aggregate residual series (<code class="reqn">n_l \times 1</code> matrix).
</p>
</li></ul>



<h3>References</h3>

<p>Mosley L, Eckley IA, Gibberd A (2022).
&ldquo;Sparse Temporal Disaggregation.&rdquo;
<em>Journal of the Royal Statistical Society Series A: Statistics in Society</em>, <b>185</b>(4), 2203-2233.
ISSN 0964-1998, <a href="https://doi.org/10.1111/rssa.12952">doi:10.1111/rssa.12952</a>, https://academic.oup.com/jrsssa/article-pdf/185/4/2203/49420183/jrsssa_185_4_2203.pdf.
</p>

<hr>
<h2 id='sptd_BIC'>BIC Score for Sparse Temporal Disaggregation</h2><span id='topic+sptd_BIC'></span>

<h3>Description</h3>

<p>This function calculates the BIC score for sparse temporal disaggregation, as described in
Mosley et al. (2022). It uses the LARS algorithm to find the
optimal beta coefficients and refits the models to compute BIC scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sptd_BIC(Y, X, vcov)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sptd_BIC_+3A_y">Y</code></td>
<td>
<p>The low-frequency response series (<code class="reqn">n_l \times 1</code> matrix).</p>
</td></tr>
<tr><td><code id="sptd_BIC_+3A_x">X</code></td>
<td>
<p>The aggregated high-frequency indicator series (<code class="reqn">n_l \times p</code> matrix).</p>
</td></tr>
<tr><td><code id="sptd_BIC_+3A_vcov">vcov</code></td>
<td>
<p>Aggregated variance-covariance matrix of AR(<code class="reqn">1</code>) residuals (<code class="reqn">n_l \times n_l</code> matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<div class="sourceCode"><pre>    The minimum BIC score from the refitted models.
</pre></div>

<hr>
<h2 id='TempDisaggDGP'>High and Low-Frequency Data Generating Processes</h2><span id='topic+TempDisaggDGP'></span>

<h3>Description</h3>

<p>This function generates a high-frequency response vector <code class="reqn">y</code>, following the relationship <code class="reqn">y = X\beta + \epsilon</code>, where <code class="reqn">X</code> is a matrix of indicator series and <code class="reqn">\beta</code> is a potentially sparse coefficient vector. The low-frequency vector <code class="reqn">Y</code> is generated by aggregating <code class="reqn">y</code> according to a specified aggregation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TempDisaggDGP(
  n_l,
  n,
  aggRatio = 4,
  p = 1,
  beta = 1,
  sparsity = 1,
  method = "Chow-Lin",
  aggMat = "sum",
  rho = 0,
  mean_X = 0,
  sd_X = 1,
  sd_e = 1,
  simul = FALSE,
  sparse_option = "random",
  setSeed = 42
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TempDisaggDGP_+3A_n_l">n_l</code></td>
<td>
<p>Integer. Size of the low-frequency series.</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_n">n</code></td>
<td>
<p>Integer. Size of the high-frequency series.</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_aggratio">aggRatio</code></td>
<td>
<p>Integer. Aggregation ratio between low and high frequency (default is 4).</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_p">p</code></td>
<td>
<p>Integer. Number of high-frequency indicator series to include.</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_beta">beta</code></td>
<td>
<p>Numeric. Value for the positive and negative elements of the coefficient vector.</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_sparsity">sparsity</code></td>
<td>
<p>Numeric. Sparsity percentage of the coefficient vector (value between 0 and 1).</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_method">method</code></td>
<td>
<p>Character. The DGP of residuals to use ('Denton', 'Denton-Cholette', 'Chow-Lin', 'Fernandez', 'Litterman').</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_aggmat">aggMat</code></td>
<td>
<p>Character. Aggregation matrix type ('first', 'sum', 'average', 'last').</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_rho">rho</code></td>
<td>
<p>Numeric. Residual autocorrelation coefficient (default is 0).</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_mean_x">mean_X</code></td>
<td>
<p>Numeric. Mean of the design matrix (default is 0).</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_sd_x">sd_X</code></td>
<td>
<p>Numeric. Standard deviation of the design matrix (default is 1).</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_sd_e">sd_e</code></td>
<td>
<p>Numeric. Standard deviation of the errors (default is 1).</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_simul">simul</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the design matrix and the coefficient vector are fixed (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_sparse_option">sparse_option</code></td>
<td>
<p>Character or Integer. Option to specify sparsity in the coefficient vector ('random' or integer value). Default is &quot;random&quot;.</p>
</td></tr>
<tr><td><code id="TempDisaggDGP_+3A_setseed">setSeed</code></td>
<td>
<p>Integer. Seed value for reproducibility when <code>simul</code> is set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation ratio (<code>aggRatio</code>) determines the ratio between the low and high-frequency series (e.g., <code>aggRatio = 4</code> for annual-to-quarterly). If the number of observations <code class="reqn">n</code> exceeds <code class="reqn">aggRatio \times n_l</code>, the aggregation matrix will include zero columns for the extrapolated values.
</p>
<p>The function supports several data generating processes (DGP) for the residuals, including 'Denton', 'Denton-Cholette', 'Chow-Lin', 'Fernandez', and 'Litterman'. These methods differ in how they generate the high-frequency data and residuals, with optional autocorrelation specified by <code>rho</code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li> <p><code>y_Gen</code>: Generated high-frequency response series (an <code class="reqn">n \times 1</code> matrix).
</p>
</li>
<li> <p><code>Y_Gen</code>: Generated low-frequency response series (an <code class="reqn">n_l \times 1</code> matrix).
</p>
</li>
<li> <p><code>X_Gen</code>: Generated high-frequency indicator series (an <code class="reqn">n \times p</code> matrix).
</p>
</li>
<li> <p><code>Beta_Gen</code>: Generated coefficient vector (a <code class="reqn">p \times 1</code> matrix).
</p>
</li>
<li> <p><code>e_Gen</code>: Generated high-frequency residual series (an <code class="reqn">n \times 1</code> matrix).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- TempDisaggDGP(n_l=25,n=100,p=10,rho=0.5)
X &lt;- data$X_Gen
Y &lt;- data$Y_Gen
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
