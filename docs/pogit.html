<!DOCTYPE html><html><head><title>Help for package pogit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pogit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#pogit-package'><p>Bayesian variable selection for a Poisson-Logistic model</p></a></li>
<li><a href='#cervical'><p>Cervical cancer data</p></a></li>
<li><a href='#cervical_validation'><p>Cervical cancer valiation data</p></a></li>
<li><a href='#logitBvs'><p>Bayesian variable selection for the binomial logit model</p></a></li>
<li><a href='#negbinBvs'><p>Bayesian variable selection for the negative binomial model</p></a></li>
<li><a href='#plot.pogit'><p>Plot an object of class <code>pogit</code></p></a></li>
<li><a href='#pogitBvs'><p>Bayesian variable selection for the Pogit model</p></a></li>
<li><a href='#poissonBvs'><p>Bayesian variable selection for the Poisson model</p></a></li>
<li><a href='#print.pogit'><p>Print an object of class <code>pogit</code></p></a></li>
<li><a href='#simul_binomial'><p>Simulated data set</p></a></li>
<li><a href='#simul_pois1'><p>Simulated data set</p></a></li>
<li><a href='#simul_pois2'><p>Simulated data set</p></a></li>
<li><a href='#simul1'><p>Simulated data set</p></a></li>
<li><a href='#simul2'><p>Simulated data set</p></a></li>
<li><a href='#summary.pogit'><p>Summary for posterior of a <code>pogit</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Variable Selection for a Poisson-Logistic Model</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Michaela Dvorzak [aut, cre],
  Helga Wagner [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian variable selection for regression models of under-reported
    count data as well as for (overdispersed) Poisson, negative binomal and
    binomial logit regression models using spike and slab priors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.10.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, logistf, plyr, stats, utils, grDevices</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>COUNT</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-24 18:22:17 UTC; michi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-25 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='pogit-package'>Bayesian variable selection for a Poisson-Logistic model</h2><span id='topic+pogit-package'></span>

<h3>Description</h3>

<p>This package provides Bayesian variable selection 
for regression models of under-reported count data as well as for (overdispersed) 
Poisson, negative binomial and binomial logit regression models using spike and slab priors. 
For posterior inference, MCMC sampling schemes are used that rely on data 
augmentation and/or auxiliary mixture sampling techniques. 
Details can be found in Dvorzak and Wagner (2016). 
</p>


<h3>Details</h3>

<p>The main function is <code><a href="#topic+pogitBvs">pogitBvs</a></code> which provides Bayesian variable
selection for a Poisson-Logistic (Pogit) model to account for potential 
under-reporting of count data. The Pogit model, introduced by Winkelmann 
and Zimmermann (1993), is specified by combining a Poisson model for the data 
generating process of counts and a logit model for the fallible reporting 
process, where the outcomes of both processes may depend on a set of 
potential covariates. 
By augmenting the observed data with the unobserved counts, the model 
can be factorized into a Poisson and a binomial logit model part. Hence, 
the MCMC sampling algorithm for this two-part model is based on  
data augmentation and sampling schemes for a Poisson and a binomial
logit model. 
</p>
<p>Though part of the main function, the functions <code><a href="#topic+poissonBvs">poissonBvs</a></code> 
and <code><a href="#topic+logitBvs">logitBvs</a></code> can be used separately to perform 
Bayesian variable selection for Poisson or binomial logit regression models. 
An alternative to <code><a href="#topic+poissonBvs">poissonBvs</a></code> is provided by the function 
<code><a href="#topic+negbinBvs">negbinBvs</a></code> to deal with overdispersion of count data.  
The sampling algorithms are based on auxiliary mixture sampling 
techniques. 
</p>
<p>All functions return an object of class &quot;<code>pogit</code>&quot; with methods
<code><a href="#topic+print.pogit">print.pogit</a></code>, <code><a href="#topic+summary.pogit">summary.pogit</a></code> and 
<code><a href="#topic+plot.pogit">plot.pogit</a></code> to summarize and display the results.  
</p>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;, Helga Wagner
</p>
<p>Maintainer: Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;
</p>


<h3>References</h3>

<p>Dvorzak, M. and Wagner, H. (2016). Sparse Bayesian modelling of underreported
count data. <em>Statistical Modelling</em>, <strong>16</strong>(1), 24 - 46, 
<a href="https://doi.org/10.1177/1471082x15588398">doi:10.1177/1471082x15588398</a>.
</p>
<p>Winkelmann, R. and Zimmermann, K. F. (1993). Poisson-Logistic regression. 
Department of Economics, University of Munich, Working Paper No. 93 - 18.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pogitBvs">pogitBvs</a></code>, <code><a href="#topic+logitBvs">logitBvs</a></code>, <code><a href="#topic+poissonBvs">poissonBvs</a></code>, 
<code><a href="#topic+negbinBvs">negbinBvs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for pogitBvs, logitBvs, poissonBvs and negbinBvs
</code></pre>

<hr>
<h2 id='cervical'>Cervical cancer data</h2><span id='topic+cervical'></span>

<h3>Description</h3>

<p>The data set contains the number of cervical cancer deaths (ICD 180) and 
woman-years at risk for four age groups in four different European countries 
during 1969-1973.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cervical)
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and 19 variables: 
</p>

<dl>
<dt><code>y</code></dt><dd><p>number of cervical cancer deaths for different age categories
and European countries between 1969-1973</p>
</dd>
<dt><code>E</code></dt><dd><p>number of woman-years at risk (given in thousands)</p>
</dd>
<dt><code>country</code></dt><dd><p>factor variable of European countries</p>
</dd>
<dt><code>agegroup</code></dt><dd><p>factor variable of age categories</p>
</dd>
<dt><code>X.1</code>, <code>X.2</code>, <code>X.3</code></dt><dd><p>predictor variables for country effects
using dummy coding (i.e. England, France, Italy)</p>
</dd>
<dt><code>X.4</code>, <code>X.5</code>, <code>X.6</code></dt><dd><p>predictor variables for age effects
using dummy coding (i.e. 35-44, 45-54, 55-64, in years)</p>
</dd>
<dt><code>X.7</code>, <code>X.8</code>, <code>X.9</code>, <code>X.10</code>, <code>X.11</code>, <code>X.12</code>, <code>X.13</code>, <code>X.14</code>, <code>X.15</code></dt><dd><p>predictor
variables for interaction effects of age and country</p>
</dd>
</dl>



<h3>Note</h3>

<p>The lowest age category (25-34) in Belgium is used as the reference category.
</p>


<h3>Source</h3>

<p>World Health Organization (1976). World Health Statistics Annual: 1969-1976,
Vol. I, <em>Vital Statistics and Causes of Death</em>. Geneva: WHO.
</p>
<p>Whittemore, A. S. and Gong, G. (1991). Poisson regression 
with missclassified counts: Application to cervical cancer mortality rates. 
<em>Applied Statistics</em>, <strong>40</strong>, 81-93.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cervical_validation">cervical_validation</a></code>, <code><a href="#topic+pogitBvs">pogitBvs</a></code>
</p>

<hr>
<h2 id='cervical_validation'>Cervical cancer valiation data</h2><span id='topic+cervical_validation'></span>

<h3>Description</h3>

<p>Additionally to the main study sample (see <code><a href="#topic+cervical">cervical</a></code>), 
validation data are available that give information on how likely physicians 
from different countries are to identify and correctly report a true cervical 
cancer death. In that study, a sample of physicians in each country completed 
a death certificate for one specific patient who had died of cervical cancer 
and the number of correct death certificates in each country was recorded. 
Validation data are therefore available on country level but provide no 
information on the reporting probability specific for age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cervical_validation)
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 rows and 6 variables: 
</p>
 
<dl>
<dt><code>v</code></dt><dd><p>number of correct death certificates in each country 
in the validation sample </p>
</dd> 
<dt><code>m</code></dt><dd><p>size of validation sample in each country</p>
</dd> 
<dt><code>country</code></dt><dd><p>factor variable of European countries</p>
</dd> 
<dt><code>W.1</code>, <code>W.2</code>, <code>W.3</code></dt><dd><p>predictor variables for country effects 
using dummy coding (i.e. England, France, Italy)</p>
</dd> 
</dl>



<h3>Note</h3>

<p>Belgium is used as the reference category.
</p>


<h3>Source</h3>

<p>Kelson, M. and Farebrother, M. (1987). The Effect of Inaccuracies in 
Death Certification and Coding Practices in the European Economic Community
(EEC) on International Cancer Mortality Statistics. <em>International
Journal of Epidemiology</em>, 16, <strong>3</strong>, 411-414.
</p>
<p>Whittemore, A. S. and Gong, G. (1991). Poisson regression with
missclassified counts: Application to cervical cancer mortality rates. 
<em>Applied Statistics</em>, <strong>40</strong>, 81-93.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cervical">cervical</a></code>, <code><a href="#topic+pogitBvs">pogitBvs</a></code>
</p>

<hr>
<h2 id='logitBvs'>Bayesian variable selection for the binomial logit model</h2><span id='topic+logitBvs'></span>

<h3>Description</h3>

<p>This function performs Bayesian variable selection for binomial logit regression
models via spike and slab priors. A cluster-specific random intercept can be included 
in the model to account for within-cluster dependence with variance selection of 
the random intercept to determine whether there is between-cluster variation 
in the model. For posterior inference, a MCMC sampling algorithm is used which 
is based on data augmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logitBvs(
  y,
  N,
  X,
  model = list(),
  prior = list(),
  mcmc = list(),
  start = NULL,
  BVS = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logitBvs_+3A_y">y</code></td>
<td>
<p>an integer vector of binomial counts</p>
</td></tr>
<tr><td><code id="logitBvs_+3A_n">N</code></td>
<td>
<p>an integer vector containing the number of trials</p>
</td></tr>
<tr><td><code id="logitBvs_+3A_x">X</code></td>
<td>
<p>a design matrix (including an intercept term)</p>
</td></tr>
<tr><td><code id="logitBvs_+3A_model">model</code></td>
<td>
<p>an (optional) list specifying the structure of the model 
(see details)</p>
</td></tr>
<tr><td><code id="logitBvs_+3A_prior">prior</code></td>
<td>
<p>an (optional) list of prior settings and hyper-parameters 
controlling the priors (see details)</p>
</td></tr>
<tr><td><code id="logitBvs_+3A_mcmc">mcmc</code></td>
<td>
<p>an (optional) list of MCMC sampling options (see details)</p>
</td></tr>
<tr><td><code id="logitBvs_+3A_start">start</code></td>
<td>
<p>an (optional), numeric vector containing starting values for the 
regression effects (including an intercept term); defaults to <code>NULL</code>
(i.e. a vector of zeros is used).</p>
</td></tr>
<tr><td><code id="logitBvs_+3A_bvs">BVS</code></td>
<td>
<p>if <code>TRUE</code> (default), Bayesian variable selection is performed
to identify regressors with a non-zero effect; otherwise, an unrestricted 
model is estimated (without variable selection).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method provides Bayesian variable selection for binomial logit models 
using mixture priors with a spike and a slab component to identify regressors 
with a non-zero effect. More specifically, a Dirac spike is used, i.e. a 
point mass at zero and (by default), the slab component is specified as a scale 
mixture of normal distributions, resulting in a Student-t distribution with 
2<code>psi.nu</code> degrees of freedom. 
In the more general random intercept model, variance selection of the random
intercept is based on the non-centered parameterization of the model, where
the signed standard deviation <code class="reqn">\theta_\alpha</code> of the random intercept term 
appears as a further regression effect in the model equation. 
For details, see Wagner and Duller (2012). 
</p>
<p>The implementation of Bayesian variable selection further relies on the 
representation of the binomial logit model as a Gaussian regression model 
in auxiliary variables. Data augmentation is based on Fussl et 
al. (2013), who show that the binomial logit model can be represented as a 
linear regression model in the latent variable, which has an interpretation as 
the difference of aggregated utilities. The error distribution in the auxiliary 
model is approximated by a finite scale mixture of normal distributions, where
the mixture parameters are taken from the R package <code>binomlogit</code>. 
See Fussl (2014) for details. 
</p>
<p>For details concerning the sampling algorithm see Dvorzak and Wagner (2016) 
and Wagner and Duller (2012). 
</p>
<p>Details for model specification (see arguments): 
</p>
 
<dl>
<dt><code>model</code>:</dt><dd>

<dl>
<dt><code>deltafix</code></dt><dd><p>an indicator vector of length <code>ncol(X)-1</code> 
specifying which regression effects are subject to selection (i.e., 0 =
subject to selection, 1 = fix in the model); defaults to a vector of zeros.</p>
</dd> 
<dt><code>gammafix</code></dt><dd><p>an indicator for variance selection of the random 
intercept term (i.e., 0 = with variance selection (default), 1 = no
variance selection); only used if a random intercept is includued in the 
model (see <code>ri</code>).</p>
</dd> 
<dt><code>ri</code></dt><dd><p>logical. If <code>TRUE</code>, a cluster-specific
random intercept is included in the model; defaults to <code>FALSE</code>.</p>
</dd> 
<dt><code>clusterID</code></dt><dd><p>a numeric vector of length equal to the number
of observations containing the cluster ID c = 1,...,C for each observation 
(required if <code>ri=TRUE</code>).</p>
</dd> 
</dl>
</dd>
<dt><code>prior</code>:</dt><dd>

<dl>
<dt><code>slab</code></dt><dd><p>distribution of the slab component, i.e. &quot;<code>Student</code>&quot; 
(default) or &quot;<code>Normal</code>&quot;.</p>
</dd>
<dt><code>psi.nu</code></dt><dd><p>hyper-parameter of the Student-t slab (used for a 
&quot;<code>Student</code>&quot; slab); defaults to 5.</p>
</dd>
<dt><code>m0</code></dt><dd><p>prior mean for the intercept parameter; defaults to 0.</p>
</dd>
<dt><code>M0</code></dt><dd><p>prior variance for the intercept parameter; defaults to 100.</p>
</dd>
<dt><code>aj0</code></dt><dd><p>a vector of prior means for the regression effects (which
is encoded in a normal distribution, see notes); defaults to vector of zeros.</p>
</dd>
<dt><code>V</code></dt><dd><p>variance of the slab; defaults to 5.</p>
</dd>
<dt><code>w</code></dt><dd><p>hyper-parameters of the Beta-prior for the mixture weight
<code class="reqn">\omega</code>; defaults to <code>c(wa0=1, wb0=1)</code>, i.e. a uniform
distribution.</p>
</dd>
<dt><code>pi</code></dt><dd><p>hyper-parameters of the Beta-prior for the mixture weight 
<code class="reqn">\pi</code>; defaults to <code>c(pa0=1, pb0=1)</code>, i.e. a uniform 
distribution.</p>
</dd>
</dl>
</dd>
<dt><code>mcmc</code>:</dt><dd>

<dl>
<dt><code>M</code></dt><dd><p>number of MCMC iterations after the burn-in phase; defaults 
to 8000.</p>
</dd> 
<dt><code>burnin</code></dt><dd><p>number of MCMC iterations discarded as burn-in; 
defaults to 2000.</p>
</dd> 
<dt><code>thin</code></dt><dd><p>thinning parameter; defaults to 1.</p>
</dd> 
<dt><code>startsel</code></dt><dd><p>number of MCMC iterations drawn from the unrestricted
model (e.g., <code>burnin/2</code>); defaults to 1000.</p>
</dd> 
<dt><code>verbose</code></dt><dd><p>MCMC progress report in each <code>verbose</code>-th 
iteration step; defaults to 500. If <code>verbose=0</code>, no output is 
generated.</p>
</dd> 
<dt><code>msave</code></dt><dd><p>returns additional output with variable 
selection details (i.e. posterior samples for <code class="reqn">\omega</code>, 
<code class="reqn">\delta</code>, <code class="reqn">\pi</code>, <code class="reqn">\gamma</code>); defaults to <code>FALSE</code>.</p>
</dd> 
</dl>
</dd></dl>



<h3>Value</h3>

<p>The function returns an object of class &quot;<code>pogit</code>&quot; with methods
<code><a href="#topic+print.pogit">print.pogit</a></code>, <code><a href="#topic+summary.pogit">summary.pogit</a></code> and 
<code><a href="#topic+plot.pogit">plot.pogit</a></code>. 
</p>
<p>The returned object is a list containing the following elements: 
</p>
<table>
<tr><td><code>samplesL</code></td>
<td>
<p>a named list containing the samples from the posterior
distribution of the parameters in the binomial logit model 
(see also <code>msave</code>): 
</p>

<dl>
<dt><code>alpha, thetaAlpha</code></dt><dd><p>regression coefficients <code class="reqn">\alpha</code> and
<code class="reqn">\theta_\alpha</code></p>
</dd>
<dt><code>pdeltaAlpha</code></dt><dd><p>P(<code class="reqn">\delta_\alpha</code>=1)</p>
</dd>
<dt><code>psiAlpha</code></dt><dd><p>scale parameter <code class="reqn">\psi_\alpha</code> of the slab component</p>
</dd>
<dt><code>pgammaAlpha</code></dt><dd><p>P(<code class="reqn">\gamma_\alpha</code>=1)</p>
</dd>
<dt><code>ai</code></dt><dd><p>cluster-specific random intercept</p>
</dd>
</dl>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list containing the data <code>y</code>, <code>N</code> and <code>X</code></p>
</td></tr>
<tr><td><code>model.logit</code></td>
<td>
<p>a list containing details on the model specification, 
see details for <code>model</code></p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>
<p>see details for <code>mcmc</code></p>
</td></tr>
<tr><td><code>prior.logit</code></td>
<td>
<p>see details for <code>prior</code></p>
</td></tr>
<tr><td><code>dur</code></td>
<td>
<p>a list containing the total runtime (<code>total</code>) 
and the runtime after burn-in (<code>durM</code>), in seconds</p>
</td></tr>
<tr><td><code>BVS</code></td>
<td>
<p>see arguments</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>a list containing starting values, see arguments</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>&quot;logit&quot;</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If prior information on the regression parameters is available, this
information is encoded in a normal distribution instead of the 
spike and slab prior (<code>BVS</code> is set to <code>FALSE</code>). 
</p>
<p>For binary observations, a vector of ones for the number of trials <code>N</code>
is required.
</p>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;, Helga Wagner
</p>


<h3>References</h3>

<p>Dvorzak, M. and Wagner, H. (2016). Sparse Bayesian modelling
of underreported count data. <em>Statistical Modelling</em>, <strong>16</strong>(1),
24 - 46, <a href="https://doi.org/10.1177/1471082x15588398">doi:10.1177/1471082x15588398</a>.
</p>
<p>Fussl, A., Fruehwirth-Schnatter, S. and Fruehwirth, R. (2013). 
Efficient MCMC for Binomial Logit Models. <em>ACM Transactions on 
Modeling and Computer Simulation</em>, 23, <strong>1</strong>, Article 3, 1-21.
</p>
<p>Fussl, A. (2014). <code>binomlogit</code>: Efficient MCMC for Binomial 
Logit Models. R package version 1.2, 
<a href="https://CRAN.R-project.org/package=binomlogit">https://CRAN.R-project.org/package=binomlogit</a>.
</p>
<p>Wagner, H. and Duller, C. (2012). Bayesian model selection for 
logistic regression models with random intercept. <em>Computational 
Statistics and Data Analysis</em>, <strong>56</strong>, 1256-1274.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pogitBvs">pogitBvs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Examples below should take about 1-2 minutes.

# load simulated data set 'simul_binomial'
data(simul_binomial)
y &lt;- simul_binomial$y
N &lt;- simul_binomial$N
X &lt;- as.matrix(simul_binomial[, -c(1, 2)])

# Bayesian variable selection for simulated data set
m1 &lt;- logitBvs(y = y, N = N, X = X)

# print, summarize and plot results
print(m1)
summary(m1)
plot(m1)

# MCMC sampling without BVS with specific MCMC and prior settings
m2 &lt;- logitBvs(y = y, N = N, X = X, prior = list(slab = "Normal"), 
               mcmc = list(M = 4000, burnin = 1000, thin = 5),
               BVS = FALSE)
print(m2)    
summary(m2)
plot(m2, maxPlots = 4) 

# BVS with specification of regression effects subject to selection
m3 &lt;- logitBvs(y = y, N = N, X = X, mcmc = list(M = 4000, burnin = 1000), 
               model = list(deltafix = c(1, 1, 1, 0, 0, 0, 1, 0, 0)))   
print(m3)   
summary(m3)
plot(m3, burnin = FALSE, maxPlots = 4)
plot(m3, type = "acf", maxPlots = 4)       

## End(Not run)
</code></pre>

<hr>
<h2 id='negbinBvs'>Bayesian variable selection for the negative binomial model</h2><span id='topic+negbinBvs'></span>

<h3>Description</h3>

<p>This function performs Bayesian regression modelling of overdispersed count 
data including variable selection via spike and slab priors. 
Posterior inference is based on MCMC sampling techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negbinBvs(
  y,
  offset = NULL,
  X,
  model = list(),
  prior = list(),
  mcmc = list(),
  start = NULL,
  BVS = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negbinBvs_+3A_y">y</code></td>
<td>
<p>an integer vector of count data</p>
</td></tr>
<tr><td><code id="negbinBvs_+3A_offset">offset</code></td>
<td>
<p>an (optional) offset term; should be <code>NULL</code> or an integer 
vector of length equal to the number of counts.</p>
</td></tr>
<tr><td><code id="negbinBvs_+3A_x">X</code></td>
<td>
<p>a design matrix (including an intercept term)</p>
</td></tr>
<tr><td><code id="negbinBvs_+3A_model">model</code></td>
<td>
<p>an (optional) list specifying the structure of the model (see 
details)</p>
</td></tr>
<tr><td><code id="negbinBvs_+3A_prior">prior</code></td>
<td>
<p>an (optional) list of prior settings and hyper-parameters 
controlling the priors (see details)</p>
</td></tr>
<tr><td><code id="negbinBvs_+3A_mcmc">mcmc</code></td>
<td>
<p>an (optional) list of MCMC sampling options (see details)</p>
</td></tr>
<tr><td><code id="negbinBvs_+3A_start">start</code></td>
<td>
<p>an (optional), numeric vector containing starting values for the
regression effects (including an intercept term); defaults to <code>NULL</code> 
(i.e. a vector of zeros is used).</p>
</td></tr>
<tr><td><code id="negbinBvs_+3A_bvs">BVS</code></td>
<td>
<p>if <code>TRUE</code> (default), Bayesian variable selection is performed
to identify regressors with a non-zero effect; otherwise, an unrestricted 
model is estimated (without variable selection).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method provides Bayesian variable selection in regression modelling 
of overdispersed count data. The negative binomial 
distribution is derived marginally from a Poisson-Gamma (mixture) model, 
which can be interpreted as an overdispersed Poisson model with 
observation-specific random intercept log <code class="reqn">\gamma</code>, where 
<code class="reqn">\gamma|\rho \sim \Gamma(\rho,\rho)</code>. A hyper-prior for <code class="reqn">\rho</code> is
specified as <code class="reqn">\rho \sim \Gamma(c_0,C_0)</code>, see details for <code>prior</code> 
below. 
By default, variable selection is incorporated in the model based on mixture 
priors with a spike and a slab component for the regression effects 
<code class="reqn">\beta</code>. More specifically, a Dirac spike is used, i.e. a point mass at 
zero, and (by default), the slab component is specified as a scale mixture 
of normal distributions, resulting in a Student-t distribution with 
2<code>psi.nu</code> degrees of freedom. 
</p>
<p>The MCMC sampling scheme relies on the representation of the conditional 
Poisson model as a Gaussian regression model in auxiliary variables, 
as described in <code><a href="#topic+poissonBvs">poissonBvs</a></code>. Data augmentation is based
on the auxiliary mixture sampling algorithm of Fruehwirth-Schnatter 
et al. (2009). For details concerning the algorithm, see 
Dvorzak and Wagner (2016b), available on request from the authors.   
</p>
<p>Details for model specification (see arguments): 
</p>
 
<dl>
<dt><code>model</code>:</dt><dd>

<dl>
<dt><code>deltafix</code></dt><dd><p>an indicator vector of length 
<code>ncol(X)-1</code> specifying which regression effects are subject to selection
(i.e., 0 = subject to selection, 1 = fix in the model); defaults to a vector 
of zeros.</p>
</dd> 
</dl>
</dd>
<dt><code>prior</code>:</dt><dd>
      
<dl>
<dt><code>slab</code></dt><dd><p>distribution of the slab component, i.e. &quot;<code>Student</code>&quot; 
(default) or &quot;<code>Normal</code>&quot;.</p>
</dd> 
<dt><code>psi.nu</code></dt><dd><p>hyper-parameter of the Student-t slab (used for a 
&quot;<code>Student</code>&quot; slab); defaults to 5.</p>
</dd> 
<dt><code>m0</code></dt><dd><p>prior mean for the intercept parameter; defaults to 0.</p>
</dd> 
<dt><code>M0</code></dt><dd><p>prior variance for the intercept parameter; defaults to 100.</p>
</dd> 
<dt><code>aj0</code></dt><dd><p>a vector of prior means for the regression effects 
(which is encoded in a normal distribution, see notes); defaults to vector of 
zeros.</p>
</dd> 
<dt><code>V</code></dt><dd><p>variance of the slab; defaults to 5.</p>
</dd> 
<dt><code>w</code></dt><dd><p>hyper-parameters of the Beta-prior for the mixture weight
<code class="reqn">\omega</code>; defaults to <code>c(wa0=1, wb0=1)</code>, i.e. a uniform distribution.</p>
</dd> 
<dt><code>c0, C0</code></dt><dd><p>scale and rate of the gamma prior for the 
hyper-parameter <code class="reqn">\rho</code>; defaults to 2 and 1.</p>
</dd> 
<dt><code>eps</code></dt><dd><p>tuning parameter in the MH-step to sample <code class="reqn">\rho</code>; 
defaults to 0.05.</p>
</dd> 
</dl>
</dd>
<dt><code>mcmc</code>:</dt><dd>

<dl>
<dt><code>M</code></dt><dd><p>number of MCMC iterations after the burn-in phase; defaults
to 8000.</p>
</dd> 
<dt><code>burnin</code></dt><dd><p>number of MCMC iterations discarded as burn-in; defaults 
to 2000.</p>
</dd> 
<dt><code>thin</code></dt><dd><p>thinning parameter; defaults to 1.</p>
</dd> 
<dt><code>startsel</code></dt><dd><p>number of MCMC iterations drawn from the unrestricted 
model (e.g., <code>burnin/2</code>); defaults to 1000.</p>
</dd> 
<dt><code>verbose</code></dt><dd><p>MCMC progress report in each <code>verbose</code>-th iteration 
step; defaults to 500. If <code>verbose=0</code>, no output is generated.</p>
</dd> 
<dt><code>msave</code></dt><dd><p>returns additional output with variable selection details 
(i.e. posterior samples for <code class="reqn">\omega</code>, <code class="reqn">\delta</code>); defaults to <code>FALSE</code>.</p>
</dd>
</dl>
</dd></dl>



<h3>Value</h3>

<p>The function returns an object of class &quot;<code>pogit</code>&quot; with methods
<code><a href="#topic+print.pogit">print.pogit</a></code>, <code><a href="#topic+summary.pogit">summary.pogit</a></code> and 
<code><a href="#topic+plot.pogit">plot.pogit</a></code>. 
</p>
<p>The returned object is a list containing the following elements: 
</p>
<table>
<tr><td><code>samplesNB</code></td>
<td>
<p>a named list containing the samples from the posterior
distribution of the parameters in the negative binomial model 
(see also <code>msave</code>): 
</p>

<dl>
<dt><code>beta, rho</code></dt><dd><p>regression coefficients <code class="reqn">\beta</code> and <code class="reqn">\rho</code></p>
</dd>
<dt><code>pdeltaBeta</code></dt><dd><p>P(<code class="reqn">\delta_\beta</code>=1)</p>
</dd>
<dt><code>psiBeta</code></dt><dd><p>scale parameter <code class="reqn">\psi_\beta</code> of the slab component</p>
</dd>
</dl>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list containing the data <code>y</code>, <code>offset</code> and <code>X</code></p>
</td></tr>
<tr><td><code>model.nb</code></td>
<td>
<p>a list containing details on the model specification, 
see details for <code>model</code></p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>
<p>see details for <code>mcmc</code></p>
</td></tr>
<tr><td><code>prior.nb</code></td>
<td>
<p>see details for <code>prior</code></p>
</td></tr>
<tr><td><code>dur</code></td>
<td>
<p>a list containing the total runtime (<code>total</code>) 
and the runtime after burn-in (<code>durM</code>), in seconds</p>
</td></tr>
<tr><td><code>acc.rho</code></td>
<td>
<p>acceptance rate of parameter <code class="reqn">\rho</code></p>
</td></tr>
<tr><td><code>BVS</code></td>
<td>
<p>see arguments</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>a list containing starting values, see arguments</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>&quot;negbin&quot;</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Alternatively, a Poisson model with observation-specific normal 
random intercept (i.e., a Poisson-log-normal mixture model) can be used 
to deal with overdispersion of count data, which is provided in the 
function <code><a href="#topic+poissonBvs">poissonBvs</a></code>.
</p>
<p>If prior information on the regression parameters is available, this 
information is encoded in a normal distribution instead of the spike 
and slab prior (consequently, <code>BVS</code> is set to <code>FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;
</p>


<h3>References</h3>

<p>Dvorzak, M. and Wagner, H. (2016b). Bayesian inference for 
overdispersed count data subject to underreporting - An application to
norovirus illness in Germany. (Unpublished) working paper.
</p>
<p>Fruehwirth-Schnatter, S., Fruehwirth, R., Held, L. and Rue, H. 
(2009). Improved auxiliary mixture sampling for hierarchical models of 
non-Gaussian data. <em>Statistics and Computing</em>, <strong>19</strong>, 479 - 492.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+poissonBvs">poissonBvs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Examples below should take about 1-2 minutes.

## ------ (use simul_pois1) ------
data(simul_pois1)
y &lt;- simul_pois1$y
X &lt;- as.matrix(simul_pois1[, -1])

# Bayesian variable selection for simulated data set
m1 &lt;- negbinBvs(y = y, X = X)

# print results (check acceptance rate for 'rho')
print(m1)

# re-run with adapted tuning parameter 'eps'
m2 &lt;- negbinBvs(y = y, X = X, prior = list(eps = 0.4)) 

# print and summarize results
print(m2)
summary(m2)

# alternatively, compare results to overdispersed Poisson model with 
# normal random intercept (subject to selection), provided in 'poissonBvs' 

# specify observation-specific random intercept
cID &lt;- seq_along(y)
m3  &lt;- poissonBvs(y = y, X = X, model = list(ri = TRUE, clusterID = cID))

# print, summarize and plot results
print(m3)
summary(m3) 
# note that thetaB is not selected (!)

plot(m3, burnin = FALSE, thin = FALSE)


## ------ (use data set "azdrg112" from package "COUNT") ------

if (!requireNamespace("COUNT", quietly = TRUE)){
 stop("package 'COUNT' is needed for this example to work. 
       Please install it.")
}

library(COUNT)
# load data set 'azdrg112' 
# (Arizona Medicare data for DRG (Diagnostic Related Group) 112)
data(azdrg112) 

y &lt;- as.numeric(azdrg112$los) # hospital length of stay: 1-53 days
X &lt;- as.matrix(azdrg112[,-1]) # covariates (gender, type1, age75)
m4 &lt;- negbinBvs(y = y, X = X, mcmc = list(M = 4000))  

# print results (check acceptance rate for 'rho')
print(m4)
summary(m4)
plot(m4, burnin = FALSE)

# adapte tuning parameter eps (and set BVS to FALSE)
prior &lt;- list(eps = 0.1)
m5 &lt;- negbinBvs(y = y, X = X, mcmc = list(M = 4000), prior = prior, 
                BVS = FALSE)  

# print, summarize and plot results
print(m5)
summary(m5)
plot(m5, burnin = FALSE, thin = FALSE)
plot(m5, type = "acf", lag.max = 50)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.pogit'>Plot an object of class <code>pogit</code></h2><span id='topic+plot.pogit'></span>

<h3>Description</h3>

<p>This function provides traceplots, autocorrelation plots and density plots 
of the MCMC samples for an object of class &quot;<code>pogit</code>&quot; to graphically assess
convergence of the MCMC simulations. It also displays the (model averaged) 
posterior means and 95%-HPD intervals for the regression effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pogit'
plot(
  x,
  type = "traceplot",
  burnin = TRUE,
  thin = TRUE,
  lag.max = NULL,
  ci = TRUE,
  maxPlots = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pogit_+3A_x">x</code></td>
<td>
<p>an object of class <code>pogit</code></p>
</td></tr>
<tr><td><code id="plot.pogit_+3A_type">type</code></td>
<td>
<p>type of plot: &quot;<code>traceplot</code>&quot; (default) for traceplots of the 
MCMC draws, &quot;<code>acf</code>&quot; for autocorrelation plots of the MCMC draws, 
&quot;<code>density</code>&quot; for density plots and &quot;<code>hpd</code>&quot; to display 
(model averaged) posterior means with 95%-HPD intervals for the regression 
effects.</p>
</td></tr>
<tr><td><code id="plot.pogit_+3A_burnin">burnin</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), burn-in draws (as specified 
in <code>x</code>) are discarded.</p>
</td></tr>
<tr><td><code id="plot.pogit_+3A_thin">thin</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), thinning (as specified in 
<code>x</code>) is considered for diagnostic MCMC plots.</p>
</td></tr>
<tr><td><code id="plot.pogit_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag for autocorrelation plot; if <code>NULL</code> (default), 
the default of <code><a href="stats.html#topic+acf">acf</a></code> is used.</p>
</td></tr>
<tr><td><code id="plot.pogit_+3A_ci">ci</code></td>
<td>
<p>logical. If <code>TRUE</code> (default), the confidence interval in the
autocorrelation plot is shown (see <code><a href="stats.html#topic+acf">acf</a></code> for details).</p>
</td></tr>
<tr><td><code id="plot.pogit_+3A_maxplots">maxPlots</code></td>
<td>
<p>maximum number of plots on a single page; if <code>NULL</code> (default),
the number of plots dispayed on a single page is specified according to the
used model.</p>
</td></tr>
<tr><td><code id="plot.pogit_+3A_...">...</code></td>
<td>
<p>further arguments (not used)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see examples for pogitBvs, logitBvs, poissonBvs and negbinBvs
</code></pre>

<hr>
<h2 id='pogitBvs'>Bayesian variable selection for the Pogit model</h2><span id='topic+pogitBvs'></span>

<h3>Description</h3>

<p>This function performs Bayesian variable selection for a Poisson-Logistic (Pogit) 
model via spike and slab priors. For posterior inference, a MCMC sampling scheme 
is used that relies on augmenting the observed data by the unobserved counts and 
involves only Gibbs sampling steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pogitBvs(
  y,
  E = NULL,
  X,
  W = NULL,
  validation = NULL,
  method = "val",
  model = list(),
  prior = list(),
  mcmc = list(),
  start = list(),
  BVS = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pogitBvs_+3A_y">y</code></td>
<td>
<p>an integer vector of observed counts for units i = 1,...,I</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_e">E</code></td>
<td>
<p>an (optional) vector containing total exposure times (offset); 
should be <code>NULL</code> or an integer vector of length equal to the number of 
counts.</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_x">X</code></td>
<td>
<p>a design matrix in the Poisson part of the joint model</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_w">W</code></td>
<td>
<p>a design matrix in the logit part of the joint model (can be a subset
of <code>X</code>) or <code>NULL</code>, if the same design matrix is used in both 
sub-models, i.e. <code>W</code> = <code>X</code>.</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_validation">validation</code></td>
<td>
<p>a two-column data frame or list with the number of 
reported cases (= <code>v</code>) in the validation sample and the number of 
total cases (= <code>m</code>) subject to the fallible reporting process 
(i.e. validation sample size) for each unit (or sub-category); 
required if <code>method =</code> &quot;<code>val</code>&quot;, otherwise <code>NULL</code>. 
The number of rows must conform with the number of rows in <code>W</code> or with 
the number of units I (if <code>X = W</code>), respectively.</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_method">method</code></td>
<td>
<p>the method to be used to obtain parameter identification: 
The default method &quot;<code>val</code>&quot; requires a small sample of validation data 
(see <code>validation</code>). If the information on all or some parameters
of the reporting process is not provided by validation data, an informative
prior distribution for the regression effects in the logit sub-model 
can be used (<code>method</code> = &quot;<code>infprior</code>&quot;). This prior information is encoded 
in a normal distribution instead of the spike and slab prior (see the details 
for <code>prior</code>).</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_model">model</code></td>
<td>
<p>a list specifying the structure of the model (see details)</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_prior">prior</code></td>
<td>
<p>an (optional) list of prior settings and hyper-parameters 
controlling the priors (see details)</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_mcmc">mcmc</code></td>
<td>
<p>an (optional) list of MCMC sampling options (see details)</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_start">start</code></td>
<td>
<p>an (optional) list containing starting values for the 
regression effects in both sub-models (see details)</p>
</td></tr>
<tr><td><code id="pogitBvs_+3A_bvs">BVS</code></td>
<td>
<p>if <code>TRUE</code> (default), Bayesian variable selection 
(in at least one part of the joint model) is performed to identify 
regressors with a non-zero effect; otherwise, an unrestricted model is 
estimated (without variable selection).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method provides Bayesian variable selection for regression
models of count data subject to under-reporting using mixture priors with a spike 
and a slab component. 
By augmenting the observed count data with the unobserved counts, the resulting 
model can be factorized into a Poisson and a binomial logit model part. Hence, 
for this two-part model, sampling algorithms for a Poisson and a binomial 
logit model can be used which are described in <code><a href="#topic+poissonBvs">poissonBvs</a></code> and 
<code><a href="#topic+logitBvs">logitBvs</a></code>. 
Bayesian variable selection is incorporated in both parts of the joint model 
using mixture priors with a Dirac spike and (by default) a Student-t slab. 
The implementation relies on the representation of the respective model as a 
Gaussian regression model in auxiliary variables (see again the help for the 
respective function). Though variable selection is primarily used to identify 
regressors with a non-zero effect, it can also be useful for identification of
the Pogit model. 
</p>
<p>By default, identification of the Pogit model is achieved by additional
information on the reporting process through validation data and 
incorporation of variable selection. If the information on the parameters
of the reporting process is not provided by validation data, the
identification of the model parameters has to be guaranteed by specifying an 
informative prior distribution (see arguments).  
</p>
<p>To model under-reported clustered data, a cluster-specific random intercept can
be included in both model parts of the Pogit model to account for dependence
within clusters. Bayesian variance selection is applied to determine whether
there is within-cluster dependence in either part of the model.  
Note that an observation-specific random intercept in the
Poisson sub-model yields an overdispersed Pogit model for unobserved
heterogeneity.   
</p>
<p>For details concerning the sampling algorithm see Dvorzak and Wagner (2016).
</p>
<p>Details for model specification (see arguments):  
</p>
 
<dl>
<dt><code>model</code>:</dt><dd>

<dl>
<dt><code>deltaBetafix, deltaAlphafix</code></dt><dd><p>indicator vectors of length 
<code>ncol(X)-1</code> and <code>ncol(W)-1</code>, respectively, for the Poisson and the 
logit sub-model, to specify which regression effects are subject to selection 
(i.e., 0 = subject to selection, 1 = fix in the model); defaults to vectors 
of zeros.</p>
</dd> 
<dt><code>gammaBetafix, gammaAlphafix</code></dt><dd><p>indicators for variance selection 
of the random intercept term in the Poisson and the logit sub-model 
(i.e., 0 = with variance selection (default), 1 = no variance selection); 
only used if a random intercept is included in either part of the joint 
model (see <code>riBeta</code> and <code>riAlpha</code>, respectively).</p>
</dd> 
<dt><code>riBeta, riAlpha</code></dt><dd><p>logical. If <code>TRUE</code>, a cluster-specific
random intercept is included in the respective part of the joint model;
defaults to <code>FALSE</code>.</p>
</dd> 
<dt><code>clBetaID, clAlphaID</code></dt><dd><p>numeric vectors of length equal to the 
number of observations containing the cluster ID c = 1,...,C for each unit
(or sub-category) in the respective sub-model (required if 
<code>riBeta=TRUE</code> or <code>riAlpha=TRUE</code>, respectively).</p>
</dd> 
<dt><code>subcat</code></dt><dd><p>a factor variable of length equal to the number of
units that specifies for which sub-category validation data are available 
(is required if <code>W</code> is a subset of <code>X</code>). 
If <code>NULL</code> (default), it is presumed that validation data are available 
for each unit (see also examples).</p>
</dd>
</dl>
</dd>
<dt><code>prior</code>:</dt><dd>

<dl>
<dt><code>slabP, slabL</code></dt><dd><p>distribution of the slab component in the
Poisson and logit sub-model, i.e. &quot;<code>Student</code>&quot; (default) or &quot;<code>Normal</code>&quot;.</p>
</dd>
<dt><code>psi.nuP, psi.nuL</code></dt><dd><p>hyper-parameter of the Student-t slab in
the respective sub-model (used for a Student-t slab); defaults to 5.</p>
</dd>
<dt><code>m0b, m0a</code></dt><dd><p>prior mean for the intercept parameter in the 
Poisson and the logit model; defaults to 0. If the argument <code>method</code> = 
&quot;<code>infprior</code>&quot;, the specification of <code>m0a</code> is required.</p>
</dd>
<dt><code>M0b, M0a</code></dt><dd><p>prior variance for the intercept parameter in the
Poisson and the logit model; defaults to 100.</p>
</dd>
<dt><code>bj0, aj0</code></dt><dd><p>a vector of prior means for the regression effects 
in the Poisson and the logit sub-model (which is encoded in a normal distribution, 
see notes); defaults to a vector of zeros. If the argument <code>method</code> = 
&quot;<code>infprior</code>&quot;, the specification of <code>aj0</code> is mandatory.</p>
</dd>
<dt><code>VP, VL</code></dt><dd><p>variance of the slab in the respective sub-model; 
defaults to 5.</p>
</dd>
<dt><code>wBeta, wAlpha</code></dt><dd><p>hyper-parameters of the Beta-prior for the mixture 
weights <code class="reqn">\omega_\beta</code> and <code class="reqn">\omega_\alpha</code> in the respective sub-model; 
defaults to <code>c(wa0=1, wb0=1)</code>, i.e. a uniform distribution.</p>
</dd>
<dt><code>piBeta, piAlpha</code></dt><dd><p>hyper-parameters of the Beta-prior for the mixture 
weights <code class="reqn">\pi_\beta</code> and <code class="reqn">\pi_\alpha</code> in the respective sub-model; 
defaults to <code>c(pa0=1, pb0=1)</code>, i.e. a uniform distribution.</p>
</dd>
</dl>
</dd>
<dt><code>mcmc</code>:</dt><dd>

<dl>
<dt><code>M</code></dt><dd><p>number of MCMC iterations after the burn-in phase; 
defaults to 8000.</p>
</dd> 
<dt><code>burnin</code></dt><dd><p>number of MCMC iterations discarded as burn-in; 
defaults to 2000.</p>
</dd> 
<dt><code>thin</code></dt><dd><p>thinning parameter; defaults to 1.</p>
</dd> 
<dt><code>startsel</code></dt><dd><p>number of MCMC iterations drawn from the unrestricted
model (e.g., <code>burnin/2</code>); defaults to 1000.</p>
</dd> 
<dt><code>verbose</code></dt><dd><p>MCMC progress report in each <code>verbose</code>-th 
iteration step; defaults to 500. If <code>verbose=0</code>, no output is 
generated.</p>
</dd> 
<dt><code>msave</code></dt><dd><p>returns additional output with variable 
selection details (i.e. posterior samples for <code class="reqn">\omega_\beta</code>, 
<code class="reqn">\omega_\alpha</code>, <code class="reqn">\delta_\beta</code>, <code class="reqn">\delta_\alpha</code>, 
<code class="reqn">\pi_\beta</code>, <code class="reqn">\pi_\alpha</code>, <code class="reqn">\gamma_\beta</code>,
<code class="reqn">\gamma_\alpha</code>); defaults to <code>FALSE</code>.</p>
</dd> 
</dl>
</dd>
<dt><code>start</code>:</dt><dd>

<dl>
<dt><code>beta</code></dt><dd><p>a vector of length <code>ncol(X)</code> containing starting 
values for the regression parameters <code class="reqn">\beta</code> in the Poisson model part.
By default, a Poisson glm is fitted to the observed counts.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>a vector of length <code>ncol(W)</code> containing starting
values for the regression parameters <code class="reqn">\alpha</code> in the logit model part. 
By default, a binomial glm is fitted to the validation data for 
<code>method</code> = &quot;<code>val</code>&quot;. If <code>method</code> = &quot;<code>infprior</code>&quot;, 
starting values for <code class="reqn">\alpha</code> are sampled from the (informative) prior 
distribution.</p>
</dd>
<dt><code>firth</code></dt><dd><p>logical. If <code>TRUE</code>, a logistic regression model 
applying Firth's correction to the likelihood using 
<code><a href="logistf.html#topic+logistf">logistf</a></code> is fitted to the validation data
(only used if <code>method</code> = &quot;<code>val</code>&quot;).</p>
</dd>
</dl>
</dd></dl>



<h3>Value</h3>

<p>The function returns an object of class &quot;<code>pogit</code>&quot; with methods
<code><a href="#topic+print.pogit">print.pogit</a></code>, <code><a href="#topic+summary.pogit">summary.pogit</a></code> and 
<code><a href="#topic+plot.pogit">plot.pogit</a></code>. 
</p>
<p>An object of class &quot;<code>pogit</code>&quot; is a list containing the following elements:
</p>
<table>
<tr><td><code>samplesL</code></td>
<td>
<p>a named list containing the samples from the posterior
distribution of the parameters in the logit part of the joint model 
(see also <code>msave</code>):
</p>

<dl>
<dt><code>alpha, thetaAlpha</code></dt><dd><p>regression coefficients <code class="reqn">\alpha</code> and
<code class="reqn">\theta_\alpha</code></p>
</dd>
<dt><code>pdeltaAlpha</code></dt><dd><p>P(<code class="reqn">\delta_\alpha</code>=1)</p>
</dd>
<dt><code>psiAlpha</code></dt><dd><p>scale parameter <code class="reqn">\psi_\alpha</code> of the slab component</p>
</dd>
<dt><code>pgammaAlpha</code></dt><dd><p>P(<code class="reqn">\gamma_\alpha</code>=1)</p>
</dd>
<dt><code>ai</code></dt><dd><p>cluster-specific random intercept</p>
</dd>
</dl>
</td></tr>
<tr><td><code>samplesP</code></td>
<td>
<p>a named list containing the samples from the posterior
distribution of the parameters in the Poisson part of the joint model 
(see also <code>msave</code>):
</p>

<dl>
<dt><code>beta, thetaBeta</code></dt><dd><p>regression coefficients <code class="reqn">\beta</code> and
<code class="reqn">\theta_\beta</code></p>
</dd>
<dt><code>pdeltaBeta</code></dt><dd><p>P(<code class="reqn">\delta_\beta</code>=1)</p>
</dd>
<dt><code>psiBeta</code></dt><dd><p>scale parameter <code class="reqn">\psi_\beta</code> of the slab component</p>
</dd>
<dt><code>pgammaBeta</code></dt><dd><p>P(<code class="reqn">\gamma_\beta</code>=1)</p>
</dd>
<dt><code>bi</code></dt><dd><p>cluster-specific random intercept</p>
</dd>
</dl>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list containing the data <code>y</code>, <code>E</code>, 
<code>X</code>, <code>W</code>, <code>val</code> and <code>subcat</code></p>
</td></tr>
<tr><td><code>model.logit</code></td>
<td>
<p>a list containing details on the model specification in
the logit sub-model, see details for <code>model</code></p>
</td></tr>
<tr><td><code>model.pois</code></td>
<td>
<p>a list containing details on the model specification in
the Poisson sub-model, see details for <code>model</code></p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>
<p>see details for <code>mcmc</code></p>
</td></tr>
<tr><td><code>prior.logit</code></td>
<td>
<p>see details for <code>prior</code></p>
</td></tr>
<tr><td><code>prior.pois</code></td>
<td>
<p>see details for <code>prior</code></p>
</td></tr>
<tr><td><code>dur</code></td>
<td>
<p>a list containing the total runtime (<code>total</code>) 
and the runtime after burn-in (<code>durM</code>), in seconds</p>
</td></tr>
<tr><td><code>BVS</code></td>
<td>
<p>see arguments</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>see arguments</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>a list containing starting values, see arguments</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>&quot;pogit&quot;</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>method</code> = &quot;<code>infprior</code>&quot;, an 
informative prior for the regression parameters in the logit model is 
required to guarantee identification of the model parameters. 
Otherwise, identification of the Pogit model may be weak and inference
will be biased.
</p>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;, Helga Wagner
</p>


<h3>References</h3>

<p>Dvorzak, M. and Wagner, H. (2016). Sparse Bayesian modelling
of underreported count data. <em>Statistical Modelling</em>, <strong>16</strong>(1),
24 - 46, <a href="https://doi.org/10.1177/1471082x15588398">doi:10.1177/1471082x15588398</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+logitBvs">logitBvs</a></code>, <code><a href="#topic+poissonBvs">poissonBvs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Examples below (except for m3) should take 3-4 minutes. 

## ------ (use simul1) ------
# load simulated data set 'simul1'
data(simul1)
y &lt;- simul1$y
E &lt;- simul1$E
X &lt;- as.matrix(simul1[, -c(1,2,8,9)]) # W = X
validation &lt;- simul1[, c("m", "v"), drop = FALSE]

# function call (with specific MCMC settings)
m1 &lt;- pogitBvs(y = y, E = E, X = X, validation = validation, 
               mcmc = list(M = 4000, thin = 5, verbose = 1000))

# print, summarize and plot results
print(m1)
summary(m1)
plot(m1)

# show traceplots disregarding burn-in and thinning
plot(m1, burnin = FALSE, thin = FALSE)
# show density plot of MCMC draws
plot(m1, type = "density")

# informative prior instead of validation data (change prior settings)
# e.g. available prior information on reporting probabilities 
p.a0 &lt;- 0.9 
p.a  &lt;- c(0.125, 0.5, 0.5, 0.5)
m0a_inf &lt;- log(p.a0/(1 - p.a0))  # prior information for alpha_0
aj0_inf &lt;- log(p.a/(1 - p.a))    # prior information for alpha

prior.set &lt;- list(m0a = m0a_inf, aj0 = aj0_inf, VL = 0.005, slabL = "Normal")
m2 &lt;- pogitBvs(y = y, E = E, X = X, method = "infprior", prior = prior.set, 
               mcmc = list(M = 4000, burnin = 2000, thin = 2), BVS = FALSE)
print(m2)
summary(m2)
plot(m2)
plot(m2, type = "acf", lag.max = 30)

## ------ (use simul2) ------
# complex model (with a long (!) runtime)

# load simulated data set 'simul2'
data(simul2)
y &lt;- simul2$y
E &lt;- simul2$E
cID &lt;- simul2$cID
X &lt;- as.matrix(simul2[, -c(1:3,9,10)])
validation &lt;- simul2[, c("v", "m"), drop = FALSE]
 
# function call (with random intercept in both sub-models)
model &lt;- list(riBeta = 1, riAlpha = 1, clBetaID = cID, clAlphaID = cID)
m3 &lt;- pogitBvs(y = y, E = E, X = X, validation = validation, model = model, 
               mcmc = list(M = 6000, burnin = 200, thin = 10), BVS = TRUE)
print(m3)
summary(m3)
plot(m3)

## ------ (use cervical cancer data) ------
# load cervical cancer data
data(cervical)
data(cervical_validation)
y &lt;- cervical$y
E &lt;- cervical$E
X &lt;- as.matrix(cervical[, -c(1:4)])
validation &lt;- cervical_validation[, c(1, 2), drop = FALSE]
W          &lt;- as.matrix(cervical_validation[, -c(1:3)])
subcat     &lt;- factor(as.numeric(cervical$country))

# function call 
m4 &lt;- pogitBvs(y = y, E = E, X = X, W = W, validation = validation, 
               model = list(subcat = subcat), mcmc = list(M = 10000, 
               burnin = 2000, thin = 10), start = list(firth = TRUE), 
               BVS = TRUE)             
print(m4)
# additionally compute estimated risks and reporting probabilities
summary(m4, printRes = TRUE) 
plot(m4, burnin = FALSE, thin = FALSE)
plot(m4, type = "acf", lag.max = 50)

# informative prior instead of validation data (change prior settings)
# e.g. prior information on country-specific reporting probabilities 
p.a0 &lt;- 0.85
p.a  &lt;- c(0.99, 0.70, 0.85)
m0a_inf &lt;- log(p.a0/(1 - p.a0))  # prior information for alpha_0
aj0_inf &lt;- log(p.a/(1 - p.a))    # prior information for alpha

prior.set &lt;- list(m0a = m0a_inf, aj0 = aj0_inf, VL = 0.005, slabL = "Normal")
m5 &lt;- pogitBvs(y = y, X = X, W = W, E = E, method = "infprior", 
               model = list(subcat = subcat), prior = prior.set, 
               mcmc = list(M = 10000, burnin = 2000, thin = 10))
print(m5)
summary(m5, printRes = TRUE)
plot(m5, burnin = FALSE, thin = FALSE)
plot(m5, type = "acf", lag.max = 50)

## End(Not run)
</code></pre>

<hr>
<h2 id='poissonBvs'>Bayesian variable selection for the Poisson model</h2><span id='topic+poissonBvs'></span>

<h3>Description</h3>

<p>This function performs Bayesian variable selection for Poisson regression models 
via spike and slab priors. A cluster- (or observation-) specific 
random intercept can be included in the model to account for within-cluster 
dependence (or overdispersion) with variance selection of the random intercept. 
For posterior inference, a MCMC sampling scheme is used
which relies on data augmentation and involves only Gibbs sampling steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poissonBvs(
  y,
  offset = NULL,
  X,
  model = list(),
  mcmc = list(),
  prior = list(),
  start = NULL,
  BVS = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poissonBvs_+3A_y">y</code></td>
<td>
<p>an integer vector of count data</p>
</td></tr>
<tr><td><code id="poissonBvs_+3A_offset">offset</code></td>
<td>
<p>an (optional) offset term; should be <code>NULL</code> or an integer 
vector of length equal to the number of counts.</p>
</td></tr>
<tr><td><code id="poissonBvs_+3A_x">X</code></td>
<td>
<p>a design matrix (including an intercept term)</p>
</td></tr>
<tr><td><code id="poissonBvs_+3A_model">model</code></td>
<td>
<p>an (optional) list specifying the structure of the model (see 
details)</p>
</td></tr>
<tr><td><code id="poissonBvs_+3A_mcmc">mcmc</code></td>
<td>
<p>an (optional) list of MCMC sampling options (see details)</p>
</td></tr>
<tr><td><code id="poissonBvs_+3A_prior">prior</code></td>
<td>
<p>an (optional) list of prior settings and hyper-parameters 
controlling the priors (see details)</p>
</td></tr>
<tr><td><code id="poissonBvs_+3A_start">start</code></td>
<td>
<p>an (optional), numeric vector containing starting values for the
regression effects (including an intercept term); defaults to <code>NULL</code> 
(i.e. a vector of zeros is used).</p>
</td></tr>
<tr><td><code id="poissonBvs_+3A_bvs">BVS</code></td>
<td>
<p>if <code>TRUE</code> (default), Bayesian variable selection is performed
to identify regressors with a non-zero effect; otherwise, an unrestricted 
model is estimated (without variable selection).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method provides a Bayesian framework for variable selection in regression
modelling of count data using mixture priors with a spike and a slab 
component to identify regressors with a non-zero effect. More specifically, a
Dirac spike is used, i.e. a point mass at zero, and (by default), the slab 
component is specified as a scale mixture of normal distributions, resulting 
in a Student-t distribution with 2<code>psi.nu</code> degrees of freedom. 
In the more general random intercept model, variance selection of the random 
intercept is based on the non-centered parameterization of the model, where 
the signed standard deviation <code class="reqn">\theta_\beta</code> of the random intercept term 
appears as a further regression effect in the model equation. For further 
details, see Wagner and Duller (2012).
</p>
<p>The implementation of Bayesian variable selection further relies on the 
representation of the Poisson model as a Gaussian regression model in 
auxiliary variables. Data augmentation is based on the auxiliary mixture 
sampling algorithm of Fruehwirth-Schnatter et al. (2009), where the
inter-arrival times of an assumed Poisson process are introduced as latent
variables. The error distribution, a negative log-Gamma distribution, 
in the auxiliary model is approximated by a finite mixture of normal 
distributions where the mixture parameters of the matlab package 
<code>bayesf</code>, Version 2.0 of Fruehwirth-Schnatter (2007) are used.  
See Fruehwirth-Schnatter et al. (2009) for details.
</p>
<p>For details concerning the sampling algorithm, see Dvorzak and Wagner (2016) 
and Wagner and Duller (2012). 
</p>
<p>Details for model specification (see arguments): 
</p>
 
<dl>
<dt><code>model</code>:</dt><dd>

<dl>
<dt><code>deltafix</code></dt><dd><p>an indicator vector of length 
<code>ncol(X)-1</code> specifying which regression effects are subject to selection
(i.e., 0 = subject to selection, 1 = fix in the model); defaults to a vector 
of zeros.</p>
</dd> 
<dt><code>gammafix</code></dt><dd><p>an indicator for variance selection of 
the random intercept term (i.e., 0 = with variance selection (default), 1 = no 
variance selection); only used if a random intercept is includued in the model 
(see <code>ri</code>).</p>
</dd> 
<dt><code>ri</code></dt><dd><p>logical. If <code>TRUE</code>, a cluster- (or observation-) specific 
random intercept is included in the model; defaults to <code>FALSE</code>.</p>
</dd> 
<dt><code>clusterID</code></dt><dd><p>a numeric vector of length equal to the number
of observations containing the cluster ID c = 1,...,C for each observation 
(required if <code>ri=TRUE</code>). Note that <code>seq_along(y)</code> specifies an
overdispersed Poisson model with observation-specific (normal) random intercept 
(see note).</p>
</dd> 
</dl>
</dd>
<dt><code>prior</code>:</dt><dd>

<dl>
<dt><code>slab</code></dt><dd><p>distribution of the slab component, i.e. &quot;<code>Student</code>&quot; 
(default) or &quot;<code>Normal</code>&quot;.</p>
</dd> 
<dt><code>psi.nu</code></dt><dd><p>hyper-parameter of the Student-t slab (used for a 
&quot;<code>Student</code>&quot; slab); defaults to 5.</p>
</dd> 
<dt><code>m0</code></dt><dd><p>prior mean for the intercept parameter; defaults to 0.</p>
</dd> 
<dt><code>M0</code></dt><dd><p>prior variance for the intercept parameter; defaults to 100.</p>
</dd> 
<dt><code>aj0</code></dt><dd><p>a vector of prior means for the regression effects 
(which is encoded in a normal distribution, see note); defaults to vector of 
zeros.</p>
</dd> 
<dt><code>V</code></dt><dd><p>variance of the slab; defaults to 5.</p>
</dd> 
<dt><code>w</code></dt><dd><p>hyper-parameters of the Beta-prior for the mixture weight
<code class="reqn">\omega</code>; defaults to <code>c(wa0=1, wb0=1)</code>, i.e. a uniform distribution.</p>
</dd> 
<dt><code>pi</code></dt><dd><p>hyper-parameters of the Beta-prior for the mixture weight 
<code class="reqn">\pi</code>; defaults to <code>c(pa0=1, pb0=1)</code>, i.e. a uniform distribution.</p>
</dd> 
</dl>
</dd>
<dt><code>mcmc</code>:</dt><dd>

<dl>
<dt><code>M</code></dt><dd><p>number of MCMC iterations after the burn-in phase; defaults
to 8000.</p>
</dd> 
<dt><code>burnin</code></dt><dd><p>number of MCMC iterations discarded as burn-in; defaults 
to 2000.</p>
</dd> 
<dt><code>thin</code></dt><dd><p>thinning parameter; defaults to 1.</p>
</dd> 
<dt><code>startsel</code></dt><dd><p>number of MCMC iterations drawn from the unrestricted 
model (e.g., <code>burnin/2</code>); defaults to 1000.</p>
</dd> 
<dt><code>verbose</code></dt><dd><p>MCMC progress report in each <code>verbose</code>-th iteration 
step; defaults to 500. If <code>verbose=0</code>, no output is generated.</p>
</dd> 
<dt><code>msave</code></dt><dd><p>returns additional output with variable selection details 
(i.e. posterior samples for <code class="reqn">\omega</code>, <code class="reqn">\delta</code>, <code class="reqn">\pi</code>, 
<code class="reqn">\gamma</code>); defaults to <code>FALSE</code>.</p>
</dd>
</dl>
</dd></dl>



<h3>Value</h3>

<p>The function returns an object of class &quot;<code>pogit</code>&quot; with methods
<code><a href="#topic+print.pogit">print.pogit</a></code>, <code><a href="#topic+summary.pogit">summary.pogit</a></code> and 
<code><a href="#topic+plot.pogit">plot.pogit</a></code>. 
</p>
<p>The returned object is a list containing the following elements: 
</p>
<table>
<tr><td><code>samplesP</code></td>
<td>
<p>a named list containing the samples from the posterior
distribution of the parameters in the Poisson model 
(see also <code>msave</code>): 
</p>

<dl>
<dt><code>beta, thetaBeta</code></dt><dd><p>regression coefficients <code class="reqn">\beta</code> and
<code class="reqn">\theta_\beta</code></p>
</dd>
<dt><code>pdeltaBeta</code></dt><dd><p>P(<code class="reqn">\delta_\beta</code>=1)</p>
</dd>
<dt><code>psiBeta</code></dt><dd><p>scale parameter <code class="reqn">\psi_\beta</code> of the slab component</p>
</dd>
<dt><code>pgammaBeta</code></dt><dd><p>P(<code class="reqn">\gamma_\beta</code>=1)</p>
</dd>
<dt><code>bi</code></dt><dd><p>cluster- (or observation-) specific random intercept</p>
</dd>
</dl>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list containing the data <code>y</code>, <code>offset</code> and <code>X</code></p>
</td></tr>
<tr><td><code>model.pois</code></td>
<td>
<p>a list containing details on the model specification, 
see details for <code>model</code></p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>
<p>see details for <code>mcmc</code></p>
</td></tr>
<tr><td><code>prior.pois</code></td>
<td>
<p>see details for <code>prior</code></p>
</td></tr>
<tr><td><code>dur</code></td>
<td>
<p>a list containing the total runtime (<code>total</code>) 
and the runtime after burn-in (<code>durM</code>), in seconds</p>
</td></tr>
<tr><td><code>BVS</code></td>
<td>
<p>see arguments</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>a list containing starting values, see arguments</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>&quot;poisson&quot;</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If prior information on the regression parameters is available, this 
information is encoded in a normal distribution instead of the spike 
and slab prior (consequently, <code>BVS</code> is set to <code>FALSE</code>).
</p>
<p>This function can also be used to accommodate overdispersion in 
count data by specifying an observation-specific random intercept
(see details for <code>model</code>). The resulting model is an alternative 
to the negative binomial model, see <code><a href="#topic+negbinBvs">negbinBvs</a></code>. 
Variance selection of the random intercept may be useful to examine 
whether overdispersion is present in the data.
</p>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;, Helga Wagner
</p>


<h3>References</h3>

<p>Dvorzak, M. and Wagner, H. (2016). Sparse Bayesian modelling
of underreported count data. <em>Statistical Modelling</em>, <strong>16</strong>(1),
24 - 46, <a href="https://doi.org/10.1177/1471082x15588398">doi:10.1177/1471082x15588398</a>.
</p>
<p>Fruehwirth-Schnatter, S. (2007). Matlab package <code>bayesf</code> 2.0
on <em>Finite Mixture and Markov Switching Models</em>, Springer. 
<a href="https://statmath.wu.ac.at/~fruehwirth/monographie/">https://statmath.wu.ac.at/~fruehwirth/monographie/</a>.
</p>
<p>Fruehwirth-Schnatter, S., Fruehwirth, R., Held, L. and Rue, H. 
(2009). Improved auxiliary mixture sampling for hierarchical models of 
non-Gaussian data. <em>Statistics and Computing</em>, <strong>19</strong>, 479 - 492.
</p>
<p>Wagner, H. and Duller, C. (2012). Bayesian model selection for 
logistic regression models with random intercept. <em>Computational 
Statistics and Data Analysis</em>, <strong>56</strong>, 1256 - 1274.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pogitBvs">pogitBvs</a></code>, <code><a href="#topic+negbinBvs">negbinBvs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Examples below should take about 1-2 minutes.

## ------ (use simul_pois1) ------
# load simulated data set 'simul_pois1'
data(simul_pois1)
y &lt;- simul_pois1$y
X &lt;- as.matrix(simul_pois1[, -1])

# Bayesian variable selection for simulated data set
m1 &lt;- poissonBvs(y = y, X = X)

# print, summarize and plot results
print(m1)
summary(m1)
plot(m1, maxPlots = 4)
plot(m1, burnin = FALSE, thin = FALSE, maxPlots = 4)
plot(m1, type = "acf")

# MCMC sampling without BVS with specific MCMC and prior settings
m2 &lt;- poissonBvs(y = y, X = X, prior = list(slab = "Normal"), 
                 mcmc = list(M = 6000, thin = 10), BVS = FALSE)
print(m2)
summary(m2, IAT = TRUE)
plot(m2)
# show traceplots disregarding thinning
plot(m2, thin = FALSE)

# specification of an overdispersed Poisson model with observation-specific 
# (normal) random intercept
cID &lt;- seq_along(y)
m3  &lt;- poissonBvs(y = y, X = X, model = list(ri = TRUE, clusterID = cID))

# print, summarize and plot results
print(m3)
summary(m3) 
# note that variance selection of the random intercept indicates that 
# overdispersion is not present in the data
plot(m3, burnin = FALSE, thin = FALSE)

## ------ (use simul_pois2) ------
# load simulated data set 'simul_pois2'
data(simul_pois2)
y &lt;- simul_pois2$y
X &lt;- as.matrix(simul_pois2[, -c(1,2)])
cID &lt;- simul_pois2$cID

# BVS for a Poisson model with cluster-specific random intercept
m4 &lt;- poissonBvs(y = y, X = X, model = list(ri = TRUE, clusterID = cID),
                 mcmc = list(M = 4000, burnin = 2000))
print(m4)
summary(m4)
plot(m4)
                               
# similar to m4, but without variance selection of the random intercept term
model &lt;- list(gammafix = 1, ri = 1, clusterID = cID)
m5 &lt;- poissonBvs(y = y, X = X, model = model, mcmc = list(M = 4000, thin = 5))
print(m5)       
summary(m5)          
plot(m5)

# MCMC sampling without BVS for clustered observations
m6 &lt;- poissonBvs(y = y, X = X, model = list(ri = 1, clusterID = cID), 
                 BVS = FALSE)
print(m6)         
summary(m6)        
plot(m6, maxPlots = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.pogit'>Print an object of class <code>pogit</code></h2><span id='topic+print.pogit'></span>

<h3>Description</h3>

<p>The default print method for a <code>pogit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pogit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pogit_+3A_x">x</code></td>
<td>
<p>an object of class <code>pogit</code></p>
</td></tr>
<tr><td><code id="print.pogit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns basic information about the model, the number of observations and 
covariates used, the number of regression effects subject to selection, 
MCMC options and the runtime used for the sampling algorithm. See
<code><a href="#topic+summary.pogit">summary.pogit</a></code> for more details.
</p>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;
</p>

<hr>
<h2 id='simul_binomial'>Simulated data set</h2><span id='topic+simul_binomial'></span>

<h3>Description</h3>

<p>The data set <code>simul_binomial</code> contains simulated binomial data with 
9 binary covariates. The design matrix is built by computing all 2^9 possible 
0/1 combinations. The regression effects are set to 
<code>alpha = {-0.5,0.2,-0.15,0.1,-1.1,0,0,1.2,-0.1,0.3}</code>. 
The number of trials <code>N</code> are simulated from a Poisson distribution with 
parameter <code class="reqn">\exp(\alpha)/(1+\exp(\alpha))</code>*100.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simul_binomial)
</code></pre>


<h3>Format</h3>

<p>A data frame with 512 rows and the following 12 variables: 
</p>

<dl>
<dt><code>y</code></dt><dd><p>number of successes for each covariate pattern</p>
</dd>
<dt><code>N</code></dt><dd><p>number of trials for each covariate pattern</p>
</dd>
<dt><code>X.0</code></dt><dd><p>intercept</p>
</dd>
<dt><code>X.1</code>, <code>X.2</code>, <code>X.3</code>, <code>X.4</code>, <code>X.5</code>, <code>X.6</code>, <code>X.7</code>, <code>X.8</code>, <code>X.9</code></dt><dd><p>binary covariates</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+logitBvs">logitBvs</a></code>
</p>

<hr>
<h2 id='simul_pois1'>Simulated data set</h2><span id='topic+simul_pois1'></span>

<h3>Description</h3>

<p>The data set <code>simul_pois1</code> contains 300 simulated Poisson counts. 
10 regressors are generated, six of them continuous N(0,1)-variables
and four binary with <code class="reqn">p(x_i)=0.5</code>. The regression effects are set to
<code>beta = {2,1,0.6,0,0,1.2,0,0,0.4,-0.2,0.3}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simul_pois1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows and the following 12 variables: 
</p>

<dl>
<dt><code>y</code></dt><dd><p>number of counts for each covariate pattern</p>
</dd>
<dt><code>X.0</code></dt><dd><p>intercept</p>
</dd>
<dt><code>X.1</code>, <code>X.2</code>, <code>X.3</code>, <code>X.4</code>, <code>X.5</code>, <code>X.6</code>, <code>X.7</code>, <code>X.8</code>, <code>X.9</code>, <code>X.10</code></dt><dd><p>covariates</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+poissonBvs">poissonBvs</a></code>
</p>

<hr>
<h2 id='simul_pois2'>Simulated data set</h2><span id='topic+simul_pois2'></span>

<h3>Description</h3>

<p>The same simulation setup is used as in <code><a href="#topic+simul_pois1">simul_pois1</a></code> but considers 
clustered observations. 10 regressors are generated, six of them continuous 
N(0,1)-variables and four binary with <code class="reqn">p(x_i)=0.5</code>. 
The regression effects are set to <code>beta = {2,1,0.6,0,0,1.2,0,0,0.4,-0.2,0.3}</code>.
To simulate clustering, it is assumed that each of 
C=10 clusters is formed of 30 subjects and 10 random intercepts are generated 
from a normal distribution with zero mean and standard deviation 
<code class="reqn">\theta</code> = 0.1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simul_pois2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 300 rows and the following 12 variables: 
</p>

<dl>
<dt><code>y</code></dt><dd><p>number of counts for each covariate pattern in each cluster</p>
</dd>
<dt><code>cID</code></dt><dd><p>cluster ID of each count</p>
</dd>
<dt><code>X.0</code></dt><dd><p>intercept</p>
</dd>
<dt><code>X.1</code>, <code>X.2</code>, <code>X.3</code>, <code>X.4</code>, <code>X.5</code>, <code>X.6</code>, <code>X.7</code>, <code>X.8</code>, <code>X.9</code>, <code>X.10</code></dt><dd><p>covariates</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+simul_pois1">simul_pois1</a></code>, <code><a href="#topic+poissonBvs">poissonBvs</a></code>
</p>

<hr>
<h2 id='simul1'>Simulated data set</h2><span id='topic+simul1'></span>

<h3>Description</h3>

<p>The simulated data set <code>simul1</code> considers a situation with four
binary covariates in both sub-models of the Pogit model, 
i.e. <code>X</code> = <code>W</code>.
The respective design matrix is built by computing all 2^4 possible 0/1 
combinations and one observation is generated for each covariate pattern. 
The regression effects are set to <code>beta = {0.75,0.5,-2,0,0}</code> in the 
Poisson and to <code>alpha = {2.2,-1.9,0,0,0}</code> in the logit model.
Additionally to the main study sample, validation data are available for
each covariate pattern. For details concerning the simulation setup, see 
Dvorzak and Wagner (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simul1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 16 rows and the following 9 variables: 
</p>

<dl>
<dt><code>y</code></dt><dd><p>number of observed counts for each covariate pattern</p>
</dd>
<dt><code>E</code></dt><dd><p>total exposure time</p>
</dd>
<dt><code>X.0</code></dt><dd><p>intercept</p>
</dd>
<dt><code>X.1</code>, <code>X.2</code>, <code>X.3</code>, <code>X.4</code></dt><dd><p>binary covariates</p>
</dd>
<dt><code>v</code></dt><dd><p>number of reported cases for each covariate pattern in 
the validation sample</p>
</dd>
<dt><code>m</code></dt><dd><p>number of true cases subject to the fallible reporting
process (sample size of validation data)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dvorzak, M. and Wagner, H. (2016). Sparse Bayesian modelling
of underreported count data. <em>Statistical Modelling</em>, <strong>16</strong>(1),
24 - 46, <a href="https://doi.org/10.1177/1471082x15588398">doi:10.1177/1471082x15588398</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pogitBvs">pogitBvs</a></code>
</p>

<hr>
<h2 id='simul2'>Simulated data set</h2><span id='topic+simul2'></span>

<h3>Description</h3>

<p>The simulated data set <code>simul2</code> considers a situation with clustered 
observations and four binary covariates in both sub-models of the Pogit
model, i.e. 
<code>X</code> = <code>W</code>. The respective design matrix is
built by computing all 2^4 possible 0/1 combinations and one observation 
is generated for each covariate pattern. C=50 clusters are built containing 
one unit with each of the resulting 16 covariate patterns, i.e. a total of 
I=800 units. The regression effects are set to <code>beta = {0.75,0.1,0.1,0,0}</code>
in the Poisson and to <code>alpha = {2.2,-0.3,0,-0.3,0}</code> in the logit model. 
Random intercepts in both sub-models are simulated from a normal distribution
with standard deviations <code class="reqn">\theta_\beta</code>=<code>0.1</code> and 
<code class="reqn">\theta_\alpha</code>=<code>0.3</code>. Additionally to the main study sample, 
validation data are available for each covariate pattern and cluster. 
For details concerning the simulation setup, see Dvorzak and Wagner (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simul2)
</code></pre>


<h3>Format</h3>

<p>A data frame with 800 rows and the following 10 variables: 
</p>

<dl>
<dt><code>y</code></dt><dd><p>number of observed counts for each covariate pattern 
in each cluster</p>
</dd>
<dt><code>E</code></dt><dd><p>total exposure times for each unit</p>
</dd>
<dt><code>cID</code></dt><dd><p>cluster ID for each unit</p>
</dd>
<dt><code>X.0</code></dt><dd><p>intercept</p>
</dd>
<dt><code>X.1</code>, <code>X.2</code>, <code>X.3</code>, <code>X.4</code></dt><dd><p>binary covariates</p>
</dd>
<dt><code>v</code></dt><dd><p>number of reported cases for each covariate pattern in each
cluster in the validation sample</p>
</dd>
<dt><code>m</code></dt><dd><p>number of true cases subject to the fallible reporting
process (sample size of validation data)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dvorzak, M. and Wagner, H. (2016). Sparse Bayesian modelling
of underreported count data. <em>Statistical Modelling</em>, <strong>16</strong>(1),
24 - 46, <a href="https://doi.org/10.1177/1471082x15588398">doi:10.1177/1471082x15588398</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pogitBvs">pogitBvs</a></code>
</p>

<hr>
<h2 id='summary.pogit'>Summary for posterior of a <code>pogit</code> object</h2><span id='topic+summary.pogit'></span><span id='topic+print.summary.pogit'></span>

<h3>Description</h3>

<p>Returns basic information about the model and the priors, MCMC details and 
(model averaged) posterior means with 95%-HPD intervals for the regression 
effects and estimated posterior inclusion probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pogit'
summary(object, IAT = FALSE, printRes = FALSE, ...)

## S3 method for class 'summary.pogit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pogit_+3A_object">object</code></td>
<td>
<p>an object of class <code>pogit</code></p>
</td></tr>
<tr><td><code id="summary.pogit_+3A_iat">IAT</code></td>
<td>
<p>if <code>TRUE</code>, integrated autocorrelation times (IAT) and 
effective samples sizes (ESS) of the MCMC samples are computed (see 
details); defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.pogit_+3A_printres">printRes</code></td>
<td>
<p>if <code>TRUE</code>, model averaged posterior means for the 
reporting probabilities and risks are computed for the Pogit model; 
defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.pogit_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods (not used)</p>
</td></tr>
<tr><td><code id="summary.pogit_+3A_x">x</code></td>
<td>
<p>a <code>summary.pogit</code> object produced by <code>summary.pogit()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To assess mixing and efficiency of MCMC sampling, the effective sample size 
(ESS) and the integrated autocorrelation time (IAT) are computed. ESS 
estimates the equivalent number of independent draws corresponding to the 
dependent MCMC draws and is defined as ESS = <code class="reqn">M</code>/<code class="reqn">\tau</code>, where <code class="reqn">\tau</code> 
is the IAT and <code class="reqn">M</code> is the number of MCMC iterations after the burn-in phase. 
IAT is computed as <code class="reqn">\tau = 1 + 2 \sum_{k=1}^K \rho(k)</code>
using the initial monotone sequence estimator (Geyer, 1992) for K and 
<code class="reqn">\rho(k)</code> is the empirical autocorrelation at lag <code class="reqn">k</code>.
</p>


<h3>Value</h3>

<p>an object of class <code>summary.pogit</code>
</p>


<h3>Author(s)</h3>

<p>Michaela Dvorzak &lt;m.dvorzak@gmx.at&gt;
</p>


<h3>References</h3>

<p>Geyer, C. J. (1992). Practical Markov Chain Monte Carlo. 
<em>Statistical Science</em>, <strong>7</strong>, 473-483.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
