<!DOCTYPE html><html><head><title>Help for package alcyon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {alcyon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#agentAnalysis'><p>Agent Analysis</p></a></li>
<li><a href='#AgentLookMode'><p>Agent look modes.</p></a></li>
<li><a href='#AllLineShapeGraph-class'><p>All-line Axial ShapeGraph</p></a></li>
<li><a href='#allToAllTraverse'><p>All-to-all traversal</p></a></li>
<li><a href='#as'><p>as(&quot;sf&quot;, &quot;ShapeMap&quot;)</p></a></li>
<li><a href='#axialAnalysisLocal'><p>Axial analysis - local metrics</p></a></li>
<li><a href='#AxialShapeGraph_subset'><p>Subset AxialShapeGraph objects</p></a></li>
<li><a href='#AxialShapeGraph-class'><p>Axial ShapeGraph</p></a></li>
<li><a href='#axialToSegmentShapeGraph'><p>Axial to Segment ShapeGraph</p></a></li>
<li><a href='#blockLines'><p>Block lines on a PointMap</p></a></li>
<li><a href='#connections'><p>Get map connections</p></a></li>
<li><a href='#connections+2CAxialShapeGraph-method'><p>Get the Axial ShapeGraph connections</p></a></li>
<li><a href='#connections+2CPointMap-method'><p>Get the PointMap connections</p></a></li>
<li><a href='#connections+2CSegmentShapeGraph-method'><p>Get the Segment ShapeGraph connections</p></a></li>
<li><a href='#createGrid'><p>Create a PointMap through a grid</p></a></li>
<li><a href='#fillGrid'><p>Fill a PointMap's grid starting from one or more points</p></a></li>
<li><a href='#getTopFeatures'><p>Extract top x percent of features</p></a></li>
<li><a href='#isovist'><p>Create isovists at point and direction angle</p></a></li>
<li><a href='#isovist2pts'><p>Create isovists using two points</p></a></li>
<li><a href='#linkCoords'><p>Link map points/lines as if selecting them using points</p></a></li>
<li><a href='#linkCoords+2CAxialShapeGraph-method'><p>Link two Axial Lines (coordinates)</p></a></li>
<li><a href='#linkCoords+2CPointMap-method'><p>Link two PointMap Cells (coordinates)</p></a></li>
<li><a href='#linkRefs'><p>Link map points/lines using their refs</p></a></li>
<li><a href='#linkRefs+2CAxialShapeGraph-method'><p>Link two Axial Lines (refs)</p></a></li>
<li><a href='#linkRefs+2CPointMap-method'><p>Link two PointMap Cells (refs)</p></a></li>
<li><a href='#links'><p>Get map links</p></a></li>
<li><a href='#links+2CAxialShapeGraph-method'><p>Get the Axial ShapeGraph links</p></a></li>
<li><a href='#links+2CPointMap-method'><p>Get the PointMap links</p></a></li>
<li><a href='#makeAllLineMap'><p>Create an All-line Map</p></a></li>
<li><a href='#makeColour'><p>Single Colour from depthmapX's Palettes</p></a></li>
<li><a href='#makeVGAGraph'><p>Create a graph between visible cells in the PointMap</p></a></li>
<li><a href='#makeVGAPointMap'><p>Create a PointMap grid, fill it and make the graph</p></a></li>
<li><a href='#matchPointsToLines'><p>Match points to lines</p></a></li>
<li><a href='#name'><p>Get map name</p></a></li>
<li><a href='#name+2CPointMap-method'><p>Get the PointMap name</p></a></li>
<li><a href='#name+2CShapeMap-method'><p>Get the ShapeMap name</p></a></li>
<li><a href='#oneToAllTraverse'><p>One-to-all traversal</p></a></li>
<li><a href='#palettes'><p>Colour Palettes from depthmapX</p></a></li>
<li><a href='#plot.PointMap'><p>plot a PointMap</p></a></li>
<li><a href='#PointMap_subset'><p>Subset PointMap objects</p></a></li>
<li><a href='#PointMap-class'><p>PointMap</p></a></li>
<li><a href='#readMetaGraph'><p>Read MetaGraph</p></a></li>
<li><a href='#reduceToFewest'><p>Reduce an All-line Map to two types of fewest-line maps</p></a></li>
<li><a href='#refIdToIndexAndBack'><p>Ref ID to index and vice-versa</p></a></li>
<li><a href='#SegmentShapeGraph_subset'><p>Subset SegmentShapeGraph objects</p></a></li>
<li><a href='#SegmentShapeGraph-class'><p>Segment ShapeGraph</p></a></li>
<li><a href='#shapegraphToIGraph'><p>Conversion of shapegraph to igraph</p></a></li>
<li><a href='#ShapeMap_subset'><p>Subset ShapeMap objects</p></a></li>
<li><a href='#ShapeMap-class'><p>ShapeMap class</p></a></li>
<li><a href='#shapeMapToPolygonSf'><p>ShapeMap to sf Polygon map</p></a></li>
<li><a href='#TraversalType'><p>Traversal types</p></a></li>
<li><a href='#unlinkAtCrossPoint'><p>Unlink map lines at their crossing point</p></a></li>
<li><a href='#unlinkAtCrossPoint+2CAxialShapeGraph-method'><p>Unlink two Axial Lines (crosspoint)</p></a></li>
<li><a href='#unlinkCoords'><p>Unlink map points/lines as if selecting them using points</p></a></li>
<li><a href='#unlinkCoords+2CAxialShapeGraph-method'><p>Unlink two Axial Lines (coordinates)</p></a></li>
<li><a href='#unlinkCoords+2CPointMap-method'><p>Unlink two PointMap Cells (coordinates)</p></a></li>
<li><a href='#unlinkRefs'><p>Unlink map points/lines using their refs</p></a></li>
<li><a href='#unlinkRefs+2CAxialShapeGraph-method'><p>Unlink two Axial Lines (refs)</p></a></li>
<li><a href='#unlinkRefs+2CPointMap-method'><p>Unlink two PointMap Cells (refs)</p></a></li>
<li><a href='#unmakeVGAGraph'><p>Unmake the graph in a PointMap</p></a></li>
<li><a href='#vgaIsovist'><p>Visibility Graph Analysis - isovist metrics</p></a></li>
<li><a href='#vgaThroughVision'><p>Visibility Graph Analysis - Through Vision</p></a></li>
<li><a href='#vgaVisualLocal'><p>Visibility Graph Analysis - Visual local metrics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Network Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Interface package for 'sala', the spatial network analysis library
    from the 'depthmapX' software application. The R parts of the code are based
    on the 'rdepthmap' package. Allows for the analysis of urban and
    building-scale networks and provides metrics and methods usually found
    within the Space Syntax domain. Methods in this package are described by K.
    Al-Sayed, A. Turner, B. Hillier, S. Iida and A. Penn (2014) "Space Syntax
    methodology", and also by A. Turner (2004)
    <a href="https://discovery.ucl.ac.uk/id/eprint/2651">https://discovery.ucl.ac.uk/id/eprint/2651</a> "Depthmap 4: a researcher's
    handbook".</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>sf, stars, igraph</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'generics.R' 'rcppRoxygen.R' 'helper-loadMapsRoxygen.R'
'helper-processResult.R' 'ShapeMap.R' 'AxialShapeGraph.R'
'AllLineShapeGraph.R' 'SegmentShapeGraph.R' 'PointMap.R'
'TraversalType.R' 'AgentLookMode.R' 'RcppExports.R'
'agentAnalysis.R' 'allFewestLineMap.R' 'axialAnalysis.R'
'generateRandomCapString.R' 'getTopFeatures.R' 'isovist.R'
'matchPointsToLines.R' 'palettes.R' 'prepareVGA.R'
'readMetaGraph.R' 'refIDtoIndex.R' 'segmentAnalysis.R'
'sfConversions.R' 'shapegraphToIGraph.R' 'oneToAllTraverse.R'
'allToAllTraverse.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-16 21:41:36 UTC; petros</td>
</tr>
<tr>
<td>Author:</td>
<td>Petros Koutsolampros
    <a href="https://orcid.org/0000-0003-2842-9899"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut,
    cph] ('sala' library contributor through 'depthmapX'),
  Fani Kostourou <a href="https://orcid.org/0000-0002-6544-7693"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb, cph],
  Kimon Krenz <a href="https://orcid.org/0000-0001-6077-7282"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb,
    cph],
  Alasdair Turner [ctb, cph] ('sala' library contributor through
    'depthmapX'),
  Tasos Varoudis <a href="https://orcid.org/0000-0001-7790-5623"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph] ('sala' library contributor through 'depthmapX'),
  Christian Sailer [ctb, cph] ('sala' library contributor through
    'depthmapX'),
  Eva Friedrich [ctb, cph] ('sala' library contributor through
    'depthmapX'),
  University College London [fnd],
  Spacelab UK [fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Petros Koutsolampros &lt;r-devel@pklampros.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-19 07:30:17 UTC</td>
</tr>
</table>
<hr>
<h2 id='agentAnalysis'>Agent Analysis</h2><span id='topic+agentAnalysis'></span>

<h3>Description</h3>

<p>Runs Agent Analysis on the given PointMap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agentAnalysis(
  pointMap,
  timesteps,
  releaseRate,
  agentLifeTimesteps,
  agentFov,
  agentStepsToDecision,
  agentLookMode,
  originX = NA,
  originY = NA,
  locationSeed = 0L,
  numberOfTrails = NA,
  getGateCounts = FALSE,
  copyMap = TRUE,
  verbose = FALSE,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="agentAnalysis_+3A_pointmap">pointMap</code></td>
<td>
<p>A PointMap, used as an exosomatic visual map for agents to
take exploratory information</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_timesteps">timesteps</code></td>
<td>
<p>Number of total system timesteps.</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_releaserate">releaseRate</code></td>
<td>
<p>Agent release rate (likelihood of release per timestep).</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_agentlifetimesteps">agentLifeTimesteps</code></td>
<td>
<p>Agent total lifetime (in timesteps)</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_agentfov">agentFov</code></td>
<td>
<p>Agent field-of-view (out of 32 bins = 360).</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_agentstepstodecision">agentStepsToDecision</code></td>
<td>
<p>Agent steps before turn decision.</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_agentlookmode">agentLookMode</code></td>
<td>
<p>The agent look mode. See <a href="#topic+AgentLookMode">AgentLookMode</a></p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_originx">originX</code></td>
<td>
<p>Agent starting points (x coordinates).</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_originy">originY</code></td>
<td>
<p>Agent starting point (y coordinates).</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_locationseed">locationSeed</code></td>
<td>
<p>Agents to start at random locations with specific seed (0
to 10). Default is 0.</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_numberoftrails">numberOfTrails</code></td>
<td>
<p>Record trails for this amount of agents (set to 0 to
record all, with max possible currently = 50).</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_getgatecounts">getGateCounts</code></td>
<td>
<p>Get values at gates</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
<tr><td><code id="agentAnalysis_+3A_progress">progress</code></td>
<td>
<p>Optional. Show process progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with:
</p>

<ul>
<li><p>newAttributes: The new attributes that were created during the
process
</p>
</li>
<li><p>trailMap: A ShapeMap with trails if numberOfTrails was set over 0
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.5,
    fillX = 3.0,
    fillY = 6.0,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
agentAnalysis(
  pointMap,
  timesteps = 3000L,
  releaseRate = 0.1,
  agentStepsToDecision = 3L,
  agentFov = 11L,
  agentLife = 1000L,
  agentLookMode = AgentLookMode$Standard,
  originX = NA,
  originY = NA,
  locationSeed = 1L,
  numberOfTrails = 50L,
  getGateCounts = FALSE,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='AgentLookMode'>Agent look modes.</h2><span id='topic+AgentLookMode'></span>

<h3>Description</h3>

<p>These are meant to be used to indicate what kind of look function
the agents use to look around and decide where to go next. Possible values:
</p>

<ul>
<li><p>AgentLookMode$None
</p>
</li>
<li><p>AgentLookMode$Standard
</p>
</li>
<li><p>AgentLookMode$LineOfSightLength
</p>
</li>
<li><p>AgentLookMode$OcclusionLength
</p>
</li>
<li><p>AgentLookMode$OcclusionAny
</p>
</li>
<li><p>AgentLookMode$OcclusionGroup45 (Occlusion group bins - 45 degrees)
</p>
</li>
<li><p>AgentLookMode$OcclusionGroup60 (Occlusion group bins - 60 degrees)
</p>
</li>
<li><p>AgentLookMode$OcclusionFurthest (Furthest occlusion per bin)
</p>
</li>
<li><p>AgentLookMode$BinFarDistance (Per bin far distance weighted)
</p>
</li>
<li><p>AgentLookMode$BinAngle (Per bin angle weighted)
</p>
</li>
<li><p>AgentLookMode$BinFarDistanceAngle (Per bin far-distance and angle
weighted)
</p>
</li>
<li><p>AgentLookMode$BinMemory (Per bin memory)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>AgentLookMode
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 12.
</p>


<h3>Value</h3>

<p>A list of numbers representing each agent look mode
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TraversalType$Angular
TraversalType$Topological
TraversalType$Metric
</code></pre>

<hr>
<h2 id='AllLineShapeGraph-class'>All-line Axial ShapeGraph</h2><span id='topic+AllLineShapeGraph-class'></span>

<h3>Description</h3>

<p>A representation of sala's All-line ShapeGraph in R. Holds onto a sala
All-line ShapeGraph pointer and operates on that
</p>

<hr>
<h2 id='allToAllTraverse'>All-to-all traversal</h2><span id='topic+allToAllTraverse'></span>

<h3>Description</h3>

<p>Runs all-to-all traversal on a map with a graph. This is applicable to:
</p>

<ul>
<li><p>PointMaps (Visibility Graph Analysis)
</p>
</li>
<li><p>Axial ShapeGraphs (Axial analysis)
</p>
</li>
<li><p>Segment ShapeGraphs (Segment analysis)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>allToAllTraverse(
  map,
  traversalType,
  radii,
  radiusTraversalType,
  weightByAttribute = NULL,
  includeBetweenness = FALSE,
  quantizationWidth = NA,
  gatesOnly = FALSE,
  copyMap = TRUE,
  verbose = FALSE,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allToAllTraverse_+3A_map">map</code></td>
<td>
<p>A PointMap, Axial ShapeGraph or Segment ShapeGraph</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_traversaltype">traversalType</code></td>
<td>
<p>The traversal type. See <a href="#topic+TraversalType">TraversalType</a></p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_radii">radii</code></td>
<td>
<p>A list of radii</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_radiustraversaltype">radiusTraversalType</code></td>
<td>
<p>The traversal type to keep track of whether the
analysis is within the each radius limit. See <a href="#topic+TraversalType">TraversalType</a></p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_weightbyattribute">weightByAttribute</code></td>
<td>
<p>The attribute to weigh the analysis with</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_includebetweenness">includeBetweenness</code></td>
<td>
<p>Set to TRUE to also calculate betweenness (known as
Choice in the Space Syntax domain)</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_quantizationwidth">quantizationWidth</code></td>
<td>
<p>Set this to use chunks of this width instead of
continuous values for the cost of traversal. This is equivalent to the &quot;tulip
bins&quot; for depthmapX's tulip analysis (1024 tulip bins = pi/1024
quantizationWidth). Only works for Segment ShapeGraphs</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_gatesonly">gatesOnly</code></td>
<td>
<p>Optional. Only calculate results at particular gate pixels.
Only works for PointMaps</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
<tr><td><code id="allToAllTraverse_+3A_progress">progress</code></td>
<td>
<p>Optional. Enable progress display</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new map with the results included
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pointmap analysis (VGA)
mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.5,
    fillX = 3.0,
    fillY = 6.0,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
allToAllTraverse(pointMap,
  traversalType = TraversalType$Angular,
  radii = -1L,
  radiusTraversalType = TraversalType$None
)

# Axial analysis
mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
allToAllTraverse(
  shapeGraph,
  traversalType = TraversalType$Topological,
  radii = c("n", "3"),
  includeBetweenness = TRUE
)

# Segment analysis
mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_segment_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "SegmentShapeGraph")
allToAllTraverse(
  shapeGraph,
  radii = c("n", "100"),
  radiusTraversalType = TraversalType$Metric,
  traversalType = TraversalType$Angular,
  weightByAttribute = "Segment Length",
  includeBetweenness = TRUE,
  quantizationWidth = pi / 1024L,
  verbose = FALSE,
  progress = FALSE
)
</code></pre>

<hr>
<h2 id='as'>as(&quot;sf&quot;, &quot;ShapeMap&quot;)</h2><span id='topic+as'></span>

<h3>Description</h3>

<p>This is a direct conversion, for ShapeMap -&gt; Axial -&gt; Segment see
<a href="#topic+axialToSegmentShapeGraph">axialToSegmentShapeGraph</a>
</p>
<p>This is a direct conversion, for ShapeMap -&gt; Axial -&gt; Segment see
<a href="#topic+axialToSegmentShapeGraph">axialToSegmentShapeGraph</a>
</p>


<h3>See Also</h3>

<p>Other ShapeMap: 
<code><a href="#topic+ShapeMap-class">ShapeMap-class</a></code>
</p>
<p>Other ShapeMap: 
<code><a href="#topic+ShapeMap-class">ShapeMap-class</a></code>
</p>
<p>Other AxialShapeGraph: 
<code><a href="#topic+AxialShapeGraph-class">AxialShapeGraph-class</a></code>
</p>
<p>Other AxialShapeGraph: 
<code><a href="#topic+AxialShapeGraph-class">AxialShapeGraph-class</a></code>
</p>
<p>Other SegmentShapeGraph: 
<code><a href="#topic+SegmentShapeGraph-class">SegmentShapeGraph-class</a></code>
</p>
<p>Other SegmentShapeGraph: 
<code><a href="#topic+SegmentShapeGraph-class">SegmentShapeGraph-class</a></code>
</p>

<hr>
<h2 id='axialAnalysisLocal'>Axial analysis - local metrics</h2><span id='topic+axialAnalysisLocal'></span>

<h3>Description</h3>

<p>Runs axial analysis to get the local metrics Control and Controllability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axialAnalysisLocal(shapeGraph, copyMap = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axialAnalysisLocal_+3A_shapegraph">shapeGraph</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
<tr><td><code id="axialAnalysisLocal_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="axialAnalysisLocal_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with:
</p>

<ul>
<li><p>completed: Whether the analysis completed
</p>
</li>
<li><p>newAttributes: The new attributes that were created during the
process
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
axialAnalysisLocal(shapeGraph)
</code></pre>

<hr>
<h2 id='AxialShapeGraph_subset'>Subset AxialShapeGraph objects</h2><span id='topic+AxialShapeGraph_subset'></span><span id='topic++5B.AxialShapeGraph'></span><span id='topic++5B+3C-.AxialShapeGraph'></span>

<h3>Description</h3>

<p>Subsetting AxialShapeGraph objects essentially passes the data to sf.
See <a href="sf.html#topic+sf">sf</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AxialShapeGraph'
x[...]

## S3 replacement method for class 'AxialShapeGraph'
x[...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AxialShapeGraph_subset_+3A_x">x</code></td>
<td>
<p>object of class <code>AxialShapeGraph</code> passed to <code>stars[]</code></p>
</td></tr>
<tr><td><code id="AxialShapeGraph_subset_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>stars[] &lt;- </code></p>
</td></tr>
<tr><td><code id="AxialShapeGraph_subset_+3A_value">value</code></td>
<td>
<p>value to be passed to <code>sf[] &lt;- </code></p>
</td></tr>
</table>

<hr>
<h2 id='AxialShapeGraph-class'>Axial ShapeGraph</h2><span id='topic+AxialShapeGraph-class'></span><span id='topic+AxialShapeGraph'></span>

<h3>Description</h3>

<p>A representation of sala's Axial ShapeGraph in R. Holds onto a sala Axial
ShapeGraph pointer and operates on that
</p>


<h3>See Also</h3>

<p>Other AxialShapeGraph: 
<code><a href="#topic+as">as</a>()</code>
</p>

<hr>
<h2 id='axialToSegmentShapeGraph'>Axial to Segment ShapeGraph</h2><span id='topic+axialToSegmentShapeGraph'></span>

<h3>Description</h3>

<p>Convert an Axial ShapeGraph to a Segment ShapeGraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>axialToSegmentShapeGraph(axialShapeGraph, stubRemoval = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="axialToSegmentShapeGraph_+3A_axialshapegraph">axialShapeGraph</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
<tr><td><code id="axialToSegmentShapeGraph_+3A_stubremoval">stubRemoval</code></td>
<td>
<p>Remove stubs of axial lines shorter than this
percentage (for example provide 0.4 for 40%)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new Segment ShapeGraph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
axialToSegmentShapeGraph(shapeGraph, stubRemoval = 0.4)
</code></pre>

<hr>
<h2 id='blockLines'>Block lines on a PointMap</h2><span id='topic+blockLines'></span>

<h3>Description</h3>

<p>Takes a PointMap and a ShapeMap with lines and blocks the cells on the
PointMap where the lines pass.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockLines(pointMap, lineStringMap, copyMap = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockLines_+3A_pointmap">pointMap</code></td>
<td>
<p>The input PointMap</p>
</td></tr>
<tr><td><code id="blockLines_+3A_linestringmap">lineStringMap</code></td>
<td>
<p>Map of lines, either a ShapeMap, or an sf lineString map</p>
</td></tr>
<tr><td><code id="blockLines_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="blockLines_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with points as they have been blocked by the lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
lineStringMap &lt;- as(sfMap, "sf")
mapRegion &lt;- sf::st_bbox(lineStringMap)
pointMap &lt;- createGrid(
  minX = mapRegion[["xmin"]],
  minY = mapRegion[["ymin"]],
  maxX = mapRegion[["xmax"]],
  maxY = mapRegion[["ymax"]],
  gridSize = 0.04
)
blockLines(
  pointMap = pointMap,
  lineStringMap = lineStringMap[vector()]
)
</code></pre>

<hr>
<h2 id='connections'>Get map connections</h2><span id='topic+connections'></span>

<h3>Description</h3>

<p>Get map connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connections(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connections_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the connected refs
</p>

<hr>
<h2 id='connections+2CAxialShapeGraph-method'>Get the Axial ShapeGraph connections</h2><span id='topic+connections+2CAxialShapeGraph-method'></span>

<h3>Description</h3>

<p>Get the Axial ShapeGraph connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxialShapeGraph'
connections(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connections+2B2CAxialShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the connected refs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
connections(shapeGraph)
</code></pre>

<hr>
<h2 id='connections+2CPointMap-method'>Get the PointMap connections</h2><span id='topic+connections+2CPointMap-method'></span>

<h3>Description</h3>

<p>Get the PointMap connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointMap'
connections(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connections+2B2CPointMap-method_+3A_map">map</code></td>
<td>
<p>A PointMap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the connected refs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "gallery",
    "gallery_lines.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.04,
    fillX = 3.01,
    fillY = 6.7,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
# plot the first 100 connections only
head(connections(pointMap), 100)
</code></pre>

<hr>
<h2 id='connections+2CSegmentShapeGraph-method'>Get the Segment ShapeGraph connections</h2><span id='topic+connections+2CSegmentShapeGraph-method'></span>

<h3>Description</h3>

<p>Get the Segment ShapeGraph connections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SegmentShapeGraph'
connections(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connections+2B2CSegmentShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Segment ShapeGraph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the connected refs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_segment_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "SegmentShapeGraph")
connections(shapeGraph)
</code></pre>

<hr>
<h2 id='createGrid'>Create a PointMap through a grid</h2><span id='topic+createGrid'></span>

<h3>Description</h3>

<p>Create a PointMap through a grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createGrid(minX, minY, maxX, maxY, gridSize, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createGrid_+3A_minx">minX</code></td>
<td>
<p>Minimum X of the bounding region</p>
</td></tr>
<tr><td><code id="createGrid_+3A_miny">minY</code></td>
<td>
<p>Minimum Y of the bounding region</p>
</td></tr>
<tr><td><code id="createGrid_+3A_maxx">maxX</code></td>
<td>
<p>Maximum X of the bounding region</p>
</td></tr>
<tr><td><code id="createGrid_+3A_maxy">maxY</code></td>
<td>
<p>Maximum Y of the bounding region</p>
</td></tr>
<tr><td><code id="createGrid_+3A_gridsize">gridSize</code></td>
<td>
<p>Size of the cells</p>
</td></tr>
<tr><td><code id="createGrid_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
lineStringMap &lt;- as(sfMap, "sf")
mapRegion &lt;- sf::st_bbox(lineStringMap)
createGrid(
  minX = mapRegion[["xmin"]],
  minY = mapRegion[["ymin"]],
  maxX = mapRegion[["xmax"]],
  maxY = mapRegion[["ymax"]],
  gridSize = 0.04
)
</code></pre>

<hr>
<h2 id='fillGrid'>Fill a PointMap's grid starting from one or more points</h2><span id='topic+fillGrid'></span>

<h3>Description</h3>

<p>Fill a PointMap's grid starting from one or more points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fillGrid(pointMap, fillX, fillY, copyMap = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fillGrid_+3A_pointmap">pointMap</code></td>
<td>
<p>The input PointMap</p>
</td></tr>
<tr><td><code id="fillGrid_+3A_fillx">fillX</code></td>
<td>
<p>X coordinate of the fill points</p>
</td></tr>
<tr><td><code id="fillGrid_+3A_filly">fillY</code></td>
<td>
<p>Y coordinate of the fill points</p>
</td></tr>
<tr><td><code id="fillGrid_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="fillGrid_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with filled points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
lineStringMap &lt;- as(sfMap, "sf")
mapRegion &lt;- sf::st_bbox(lineStringMap)
pointMap &lt;- createGrid(
  minX = mapRegion[["xmin"]],
  minY = mapRegion[["ymin"]],
  maxX = mapRegion[["xmax"]],
  maxY = mapRegion[["ymax"]],
  gridSize = 0.04
)
pointMap &lt;- blockLines(
  pointMap = pointMap,
  lineStringMap = lineStringMap[vector()]
)
fillGrid(
  pointMap = pointMap,
  fillX = 3.01,
  fillY = 6.7
)
</code></pre>

<hr>
<h2 id='getTopFeatures'>Extract top x percent of features</h2><span id='topic+getTopFeatures'></span>

<h3>Description</h3>

<p>Sorts features by a specific column and extracts the top x percent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTopFeatures(lineStringMap, column, percent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTopFeatures_+3A_linestringmap">lineStringMap</code></td>
<td>
<p>An sf lineString map</p>
</td></tr>
<tr><td><code id="getTopFeatures_+3A_column">column</code></td>
<td>
<p>The column to use to extract the features from</p>
</td></tr>
<tr><td><code id="getTopFeatures_+3A_percent">percent</code></td>
<td>
<p>Percentage of features (to total) to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The lineString map filtered and sorted
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
shapeGraph &lt;- allToAllTraverse(
  shapeGraph,
  traversalType = TraversalType$Topological,
  radii = c("n", "3"),
  includeBetweenness = TRUE
)
getTopFeatures(shapeGraph, "Connectivity", 0.1)
</code></pre>

<hr>
<h2 id='isovist'>Create isovists at point and direction angle</h2><span id='topic+isovist'></span>

<h3>Description</h3>

<p>Create one or more isovists at particular points, given angle and field of
view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isovist(boundaryMap, x, y, angle = NA, viewAngle = NA, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isovist_+3A_boundarymap">boundaryMap</code></td>
<td>
<p>A ShapeMap with lines designating the isovist boundaries</p>
</td></tr>
<tr><td><code id="isovist_+3A_x">x</code></td>
<td>
<p>X coordinate of the origin points</p>
</td></tr>
<tr><td><code id="isovist_+3A_y">y</code></td>
<td>
<p>Y coordinate of the origin points</p>
</td></tr>
<tr><td><code id="isovist_+3A_angle">angle</code></td>
<td>
<p>The angle (from the X axis) of the isovist look direction</p>
</td></tr>
<tr><td><code id="isovist_+3A_viewangle">viewAngle</code></td>
<td>
<p>The angle signifying the isovist's field of view</p>
</td></tr>
<tr><td><code id="isovist_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ShapeMap with the isovist polygons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
isovist(
  shapeMap,
  x = c(3.01, 1.3),
  y = c(6.70, 5.2),
  angle = 0.01,
  viewAngle = 3.14,
  FALSE
)
</code></pre>

<hr>
<h2 id='isovist2pts'>Create isovists using two points</h2><span id='topic+isovist2pts'></span>

<h3>Description</h3>

<p>Create one or more isovists at particular points, given another point for
direction and an angle for field of view
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isovist2pts(boundaryMap, x, y, toX, toY, viewAngle, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isovist2pts_+3A_boundarymap">boundaryMap</code></td>
<td>
<p>A ShapeMap with lines designating the isovist boundaries</p>
</td></tr>
<tr><td><code id="isovist2pts_+3A_x">x</code></td>
<td>
<p>X coordinate of the origin points</p>
</td></tr>
<tr><td><code id="isovist2pts_+3A_y">y</code></td>
<td>
<p>Y coordinate of the origin points</p>
</td></tr>
<tr><td><code id="isovist2pts_+3A_tox">toX</code></td>
<td>
<p>X coordinate of the target points</p>
</td></tr>
<tr><td><code id="isovist2pts_+3A_toy">toY</code></td>
<td>
<p>Y coordinate of the target points</p>
</td></tr>
<tr><td><code id="isovist2pts_+3A_viewangle">viewAngle</code></td>
<td>
<p>The angle signifying the isovist's field of view</p>
</td></tr>
<tr><td><code id="isovist2pts_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ShapeMap with the isovist polygons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
isovist2pts(
  shapeMap,
  x = c(3.01, 1.3),
  y = c(6.70, 5.2),
  toX = c(3.40, 1.1),
  toY = c(6.50, 5.6),
  viewAngle = 3.14,
  FALSE
)
</code></pre>

<hr>
<h2 id='linkCoords'>Link map points/lines as if selecting them using points</h2><span id='topic+linkCoords'></span>

<h3>Description</h3>

<p>Link map points/lines as if selecting them using points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkCoords(map, fromX, fromY, toX, toY, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkCoords_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
<tr><td><code id="linkCoords_+3A_fromx">fromX</code></td>
<td>
<p>X coordinate of the origin point</p>
</td></tr>
<tr><td><code id="linkCoords_+3A_fromy">fromY</code></td>
<td>
<p>Y coordinate of the origin point</p>
</td></tr>
<tr><td><code id="linkCoords_+3A_tox">toX</code></td>
<td>
<p>X coordinate of the target point</p>
</td></tr>
<tr><td><code id="linkCoords_+3A_toy">toY</code></td>
<td>
<p>Y coordinate of the target point</p>
</td></tr>
<tr><td><code id="linkCoords_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new map with linked points/lines
</p>

<hr>
<h2 id='linkCoords+2CAxialShapeGraph-method'>Link two Axial Lines (coordinates)</h2><span id='topic+linkCoords+2CAxialShapeGraph-method'></span>

<h3>Description</h3>

<p>Link two locations on an Axial ShapeGraph using the point coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxialShapeGraph'
linkCoords(map, fromX, fromY, toX, toY, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkCoords+2B2CAxialShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CAxialShapeGraph-method_+3A_fromx">fromX</code></td>
<td>
<p>X coordinate of the first link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CAxialShapeGraph-method_+3A_fromy">fromY</code></td>
<td>
<p>Y coordinate of the first link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CAxialShapeGraph-method_+3A_tox">toX</code></td>
<td>
<p>X coordinate of the second link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CAxialShapeGraph-method_+3A_toy">toY</code></td>
<td>
<p>Y coordinate of the second link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CAxialShapeGraph-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new Axial ShapeGraph with linked lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
linkCoords(shapeGraph, 982.8, -1620.3, 1217.1, -1977.3)
</code></pre>

<hr>
<h2 id='linkCoords+2CPointMap-method'>Link two PointMap Cells (coordinates)</h2><span id='topic+linkCoords+2CPointMap-method'></span>

<h3>Description</h3>

<p>Link two cells on a PointMap using the point coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointMap'
linkCoords(map, fromX, fromY, toX, toY, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkCoords+2B2CPointMap-method_+3A_map">map</code></td>
<td>
<p>A PointMap</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CPointMap-method_+3A_fromx">fromX</code></td>
<td>
<p>X coordinate of the first link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CPointMap-method_+3A_fromy">fromY</code></td>
<td>
<p>Y coordinate of the first link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CPointMap-method_+3A_tox">toX</code></td>
<td>
<p>X coordinate of the second link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CPointMap-method_+3A_toy">toY</code></td>
<td>
<p>Y coordinate of the second link point</p>
</td></tr>
<tr><td><code id="linkCoords+2B2CPointMap-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with linked points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "gallery",
    "gallery_lines.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.04,
    fillX = 3.01,
    fillY = 6.7,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
linkCoords(pointMap, 1.74, 6.7, 5.05, 5.24)
</code></pre>

<hr>
<h2 id='linkRefs'>Link map points/lines using their refs</h2><span id='topic+linkRefs'></span>

<h3>Description</h3>

<p>Link map points/lines using their refs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkRefs(map, fromRef, toRef, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkRefs_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
<tr><td><code id="linkRefs_+3A_fromref">fromRef</code></td>
<td>
<p>The ref of the origin element</p>
</td></tr>
<tr><td><code id="linkRefs_+3A_toref">toRef</code></td>
<td>
<p>The ref of the target element</p>
</td></tr>
<tr><td><code id="linkRefs_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new map with linked points/lines
</p>

<hr>
<h2 id='linkRefs+2CAxialShapeGraph-method'>Link two Axial Lines (refs)</h2><span id='topic+linkRefs+2CAxialShapeGraph-method'></span>

<h3>Description</h3>

<p>Link two lines on an Axial ShapeGraph using their refs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxialShapeGraph'
linkRefs(map, fromRef, toRef, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkRefs+2B2CAxialShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
<tr><td><code id="linkRefs+2B2CAxialShapeGraph-method_+3A_fromref">fromRef</code></td>
<td>
<p>Ref of the first link line</p>
</td></tr>
<tr><td><code id="linkRefs+2B2CAxialShapeGraph-method_+3A_toref">toRef</code></td>
<td>
<p>Ref of the second link line</p>
</td></tr>
<tr><td><code id="linkRefs+2B2CAxialShapeGraph-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new Axial ShapeGraph with linked lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
linkRefs(shapeGraph, 0L, 9L)
</code></pre>

<hr>
<h2 id='linkRefs+2CPointMap-method'>Link two PointMap Cells (refs)</h2><span id='topic+linkRefs+2CPointMap-method'></span>

<h3>Description</h3>

<p>Link two cells on an PointMap using their refs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointMap'
linkRefs(map, fromRef, toRef, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkRefs+2B2CPointMap-method_+3A_map">map</code></td>
<td>
<p>A PointMap</p>
</td></tr>
<tr><td><code id="linkRefs+2B2CPointMap-method_+3A_fromref">fromRef</code></td>
<td>
<p>Ref of the first link line</p>
</td></tr>
<tr><td><code id="linkRefs+2B2CPointMap-method_+3A_toref">toRef</code></td>
<td>
<p>Ref of the second link line</p>
</td></tr>
<tr><td><code id="linkRefs+2B2CPointMap-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with linked points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "gallery",
    "gallery_lines.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.04,
    fillX = 3.01,
    fillY = 6.7,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
pointMap &lt;- linkRefs(pointMap, 1835056L, 7208971L)
</code></pre>

<hr>
<h2 id='links'>Get map links</h2><span id='topic+links'></span>

<h3>Description</h3>

<p>Get map links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>links(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="links_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the linked refs
</p>

<hr>
<h2 id='links+2CAxialShapeGraph-method'>Get the Axial ShapeGraph links</h2><span id='topic+links+2CAxialShapeGraph-method'></span>

<h3>Description</h3>

<p>Get the Axial ShapeGraph links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxialShapeGraph'
links(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="links+2B2CAxialShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the linked refs
</p>


<h3>Examples</h3>

<pre><code class='language-R'># links of an axial map
mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
linkRefs(shapeGraph, 0L, 9L)
unlinkCoords(shapeGraph, 530923.0, 184041.0, 530956.0, 183887.0)
links(shapeGraph)
</code></pre>

<hr>
<h2 id='links+2CPointMap-method'>Get the PointMap links</h2><span id='topic+links+2CPointMap-method'></span>

<h3>Description</h3>

<p>Get the PointMap links
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointMap'
links(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="links+2B2CPointMap-method_+3A_map">map</code></td>
<td>
<p>A PointMap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the linked refs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "gallery",
    "gallery_lines.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.04,
    fillX = 3.01,
    fillY = 6.7,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
linkRefs(pointMap, 1835056L, 7208971L)
links(pointMap)
</code></pre>

<hr>
<h2 id='makeAllLineMap'>Create an All-line Map</h2><span id='topic+makeAllLineMap'></span>

<h3>Description</h3>

<p>Create an All-line Map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAllLineMap(boundsMap, seedX, seedY, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeAllLineMap_+3A_boundsmap">boundsMap</code></td>
<td>
<p>The boundary ShapeMap to create the all-line map in</p>
</td></tr>
<tr><td><code id="makeAllLineMap_+3A_seedx">seedX</code></td>
<td>
<p>X coordinate of the seed (the point that initiates the process)</p>
</td></tr>
<tr><td><code id="makeAllLineMap_+3A_seedy">seedY</code></td>
<td>
<p>Y coordinate of the seed (the point that initiates the process)</p>
</td></tr>
<tr><td><code id="makeAllLineMap_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An All-line Axial ShapeGraph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
makeAllLineMap(
  shapeMap,
  seedX = 3.01,
  seedY = 6.7
)
</code></pre>

<hr>
<h2 id='makeColour'>Single Colour from depthmapX's Palettes</h2><span id='topic+makeColour'></span><span id='topic+makeDepthmapClassicColour'></span><span id='topic+makeAxmanesqueColour'></span><span id='topic+makePurpleOrangeColour'></span><span id='topic+makeBlueRedColour'></span><span id='topic+makeGreyScaleColour'></span><span id='topic+makeNiceHSBColour'></span>

<h3>Description</h3>

<p>Create a single colour from depthmapX's palettes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDepthmapClassicColour(value, rangeMin = 0, rangeMax = 1)

makeAxmanesqueColour(value, rangeMin = 0, rangeMax = 1)

makePurpleOrangeColour(value, rangeMin = 0, rangeMax = 1)

makeBlueRedColour(value, rangeMin = 0, rangeMax = 1)

makeGreyScaleColour(value, rangeMin = 0, rangeMax = 1)

makeNiceHSBColour(value, rangeMin = 0, rangeMax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeColour_+3A_value">value</code></td>
<td>
<p>Value within the min/max range to take</p>
</td></tr>
<tr><td><code id="makeColour_+3A_rangemin">rangeMin</code></td>
<td>
<p>The min value of the range</p>
</td></tr>
<tr><td><code id="makeColour_+3A_rangemax">rangeMax</code></td>
<td>
<p>The max value of the range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a single colour.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeDepthmapClassicColour(0.2, 0, 1)
makeAxmanesqueColour(0.2, 0, 1)
makePurpleOrangeColour(0.2, 0, 1)
makeBlueRedColour(0.2, 0, 1)
makeGreyScaleColour(0.2, 0, 1)
makeNiceHSBColour(0.2, 0, 1)
</code></pre>

<hr>
<h2 id='makeVGAGraph'>Create a graph between visible cells in the PointMap</h2><span id='topic+makeVGAGraph'></span>

<h3>Description</h3>

<p>Create a graph between visible cells in the PointMap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeVGAGraph(
  pointMap,
  boundaryGraph = FALSE,
  maxVisibility = NA,
  copyMap = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeVGAGraph_+3A_pointmap">pointMap</code></td>
<td>
<p>The input PointMap</p>
</td></tr>
<tr><td><code id="makeVGAGraph_+3A_boundarygraph">boundaryGraph</code></td>
<td>
<p>Only create a graph on the boundary cells</p>
</td></tr>
<tr><td><code id="makeVGAGraph_+3A_maxvisibility">maxVisibility</code></td>
<td>
<p>Limit how far two cells can be to be connected</p>
</td></tr>
<tr><td><code id="makeVGAGraph_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="makeVGAGraph_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with a graph between points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
lineStringMap &lt;- as(sfMap, "sf")
mapRegion &lt;- sf::st_bbox(lineStringMap)
pointMap &lt;- createGrid(
  minX = mapRegion[["xmin"]],
  minY = mapRegion[["ymin"]],
  maxX = mapRegion[["xmax"]],
  maxY = mapRegion[["ymax"]],
  gridSize = 0.5
)
pointMap &lt;- blockLines(
  pointMap = pointMap,
  lineStringMap = lineStringMap[vector()]
)
pointMap &lt;- fillGrid(
  pointMap = pointMap,
  fillX = 3.01,
  fillY = 6.7
)
makeVGAGraph(
  pointMap = pointMap,
  boundaryGraph = FALSE,
  maxVisibility = NA
)
</code></pre>

<hr>
<h2 id='makeVGAPointMap'>Create a PointMap grid, fill it and make the graph</h2><span id='topic+makeVGAPointMap'></span>

<h3>Description</h3>

<p>This is intended to be a single command to get from the lines to a PointMap
ready for analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeVGAPointMap(
  lineStringMap,
  gridSize,
  fillX,
  fillY,
  maxVisibility = NA,
  boundaryGraph = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeVGAPointMap_+3A_linestringmap">lineStringMap</code></td>
<td>
<p>Map of lines, either a ShapeMap, or an sf lineString map</p>
</td></tr>
<tr><td><code id="makeVGAPointMap_+3A_gridsize">gridSize</code></td>
<td>
<p>Size of the cells</p>
</td></tr>
<tr><td><code id="makeVGAPointMap_+3A_fillx">fillX</code></td>
<td>
<p>X coordinate of the fill points</p>
</td></tr>
<tr><td><code id="makeVGAPointMap_+3A_filly">fillY</code></td>
<td>
<p>Y coordinate of the fill points</p>
</td></tr>
<tr><td><code id="makeVGAPointMap_+3A_maxvisibility">maxVisibility</code></td>
<td>
<p>Limit how far two cells can be to be connected</p>
</td></tr>
<tr><td><code id="makeVGAPointMap_+3A_boundarygraph">boundaryGraph</code></td>
<td>
<p>Only create a graph on the boundary cells</p>
</td></tr>
<tr><td><code id="makeVGAPointMap_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
makeVGAPointMap(
  sfMap,
  gridSize = 0.5,
  fillX = 3.01,
  fillY = 6.7,
  maxVisibility = NA,
  boundaryGraph = FALSE,
  verbose = FALSE
)
</code></pre>

<hr>
<h2 id='matchPointsToLines'>Match points to lines</h2><span id='topic+matchPointsToLines'></span>

<h3>Description</h3>

<p>Match points to their closest line. Matches (spatial-join) points to lines.
Finds the point closest to a line. One point is attached to one line, thus if
fewer points than lines are given then some lines will have no point
attached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchPointsToLines(points, lines, getIndex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchPointsToLines_+3A_points">points</code></td>
<td>
<p>Points to attach.</p>
</td></tr>
<tr><td><code id="matchPointsToLines_+3A_lines">lines</code></td>
<td>
<p>Lines to attach to.</p>
</td></tr>
<tr><td><code id="matchPointsToLines_+3A_getindex">getIndex</code></td>
<td>
<p>Get the index returned and not the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If getIndex is TRUE then the index of the points as they relate to
the matching lines are given. If not, then the data from the points dataframe
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>segmentsMif = system.file(
  "extdata", "testdata", "barnsbury",
  "barnsbury_small_segment_original.mif",
  package = "alcyon"
)
segmentsSf &lt;- st_read(
  segmentsMif,
  geometry_column = 1L, quiet = TRUE
)
gateCountsMif = system.file(
  "extdata", "testdata", "barnsbury",
  "barnsbury_ped_gatecounts.mif",
  package = "alcyon"
)
gateCountsSf &lt;- st_read(
  gateCountsMif,
  geometry_column = 1L, quiet = TRUE
)
matchPointsToLines(gateCountsSf, segmentsSf)
</code></pre>

<hr>
<h2 id='name'>Get map name</h2><span id='topic+name'></span>

<h3>Description</h3>

<p>Get map name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the object as a string
</p>

<hr>
<h2 id='name+2CPointMap-method'>Get the PointMap name</h2><span id='topic+name+2CPointMap-method'></span>

<h3>Description</h3>

<p>Get the PointMap name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointMap'
name(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name+2B2CPointMap-method_+3A_map">map</code></td>
<td>
<p>A PointMap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the PointMap as a string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "gallery",
    "gallery_lines.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.04,
    fillX = 3.01,
    fillY = 6.7,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
name(pointMap)
</code></pre>

<hr>
<h2 id='name+2CShapeMap-method'>Get the ShapeMap name</h2><span id='topic+name+2CShapeMap-method'></span>

<h3>Description</h3>

<p>Get the ShapeMap name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'ShapeMap'
name(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name+2B2CShapeMap-method_+3A_map">map</code></td>
<td>
<p>A ShapeMap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The name of the ShapeMap as a string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
name(shapeMap)
</code></pre>

<hr>
<h2 id='oneToAllTraverse'>One-to-all traversal</h2><span id='topic+oneToAllTraverse'></span>

<h3>Description</h3>

<p>Runs one-to-all traversal on a map with a graph. This is applicable to:
</p>

<ul>
<li><p>PointMaps (Visibility Graph Analysis)
</p>
</li>
<li><p>Axial ShapeGraphs (Axial analysis)
</p>
</li>
<li><p>Segment ShapeGraphs (Segment analysis)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>oneToAllTraverse(
  map,
  traversalType,
  fromX,
  fromY,
  quantizationWidth = NA,
  copyMap = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneToAllTraverse_+3A_map">map</code></td>
<td>
<p>A PointMap, Axial ShapeGraph or Segment ShapeGraph</p>
</td></tr>
<tr><td><code id="oneToAllTraverse_+3A_traversaltype">traversalType</code></td>
<td>
<p>The traversal type. See <a href="#topic+TraversalType">TraversalType</a></p>
</td></tr>
<tr><td><code id="oneToAllTraverse_+3A_fromx">fromX</code></td>
<td>
<p>X coordinate of the point to start the traversal from</p>
</td></tr>
<tr><td><code id="oneToAllTraverse_+3A_fromy">fromY</code></td>
<td>
<p>X coordinate of the point to start the traversal from</p>
</td></tr>
<tr><td><code id="oneToAllTraverse_+3A_quantizationwidth">quantizationWidth</code></td>
<td>
<p>Set this to use chunks of this width instead of
continuous values for the cost of traversal. This is equivalent to the &quot;tulip
bins&quot; for depthmapX's tulip analysis (1024 tulip bins = pi/1024
quantizationWidth). Only works for Segment ShapeGraphs</p>
</td></tr>
<tr><td><code id="oneToAllTraverse_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="oneToAllTraverse_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with:
</p>

<ul>
<li><p>completed: Whether the analysis completed
</p>
</li>
<li><p>newAttributes: The new attributes that were created during the
process
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Pointmap analysis (VGA)
mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.5,
    fillX = 3.0,
    fillY = 6.0,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
oneToAllTraverse(
  pointMap,
  traversalType = TraversalType$Metric,
  fromX = 3.01,
  fromY = 6.7
)

# Axial analysis
mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
oneToAllTraverse(
  shapeGraph,
  traversalType = TraversalType$Topological,
  fromX = 1217.1,
  fromY = -1977.3
)

# Segment analysis
mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_segment_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "SegmentShapeGraph")
oneToAllTraverse(
  shapeGraph,
  traversalType = TraversalType$Topological,
  fromX = 1217.1,
  fromY = -1977.3
)
</code></pre>

<hr>
<h2 id='palettes'>Colour Palettes from depthmapX</h2><span id='topic+palettes'></span><span id='topic+depthmap.classic.colour'></span><span id='topic+depthmap.axmanesque.colour'></span><span id='topic+depthmap.purpleorange.colour'></span><span id='topic+depthmap.bluered.colour'></span><span id='topic+depthmap.grayscale.colour'></span><span id='topic+depthmap.nicehsb.colour'></span>

<h3>Description</h3>

<p>Create n contiguous colours taken from depthmapX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthmap.classic.colour(n, rangeMin = 0, rangeMax = 1)

depthmap.axmanesque.colour(n, rangeMin = 0, rangeMax = 1)

depthmap.purpleorange.colour(n, rangeMin = 0, rangeMax = 1)

depthmap.bluered.colour(n, rangeMin = 0, rangeMax = 1)

depthmap.grayscale.colour(n, rangeMin = 0, rangeMax = 1)

depthmap.nicehsb.colour(n, rangeMin = 0, rangeMax = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="palettes_+3A_n">n</code></td>
<td>
<p>Number of colours to generate</p>
</td></tr>
<tr><td><code id="palettes_+3A_rangemin">rangeMin</code></td>
<td>
<p>The min value of the range</p>
</td></tr>
<tr><td><code id="palettes_+3A_rangemax">rangeMax</code></td>
<td>
<p>The max value of the range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of colours.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depthmap.classic.colour(100, 0, 1)
depthmap.axmanesque.colour(100, 0, 1)
depthmap.purpleorange.colour(100, 0, 1)
depthmap.bluered.colour(100, 0, 1)
depthmap.grayscale.colour(100, 0, 1)
depthmap.nicehsb.colour(100, 0, 1)
</code></pre>

<hr>
<h2 id='plot.PointMap'>plot a PointMap</h2><span id='topic+plot.PointMap'></span>

<h3>Description</h3>

<p>Calls a standard plot.stars, but flips the first argument around the x axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PointMap'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PointMap_+3A_x">x</code></td>
<td>
<p>object of class <code>PointMap</code></p>
</td></tr>
<tr><td><code id="plot.PointMap_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>stars[]</code></p>
</td></tr>
</table>

<hr>
<h2 id='PointMap_subset'>Subset PointMap objects</h2><span id='topic+PointMap_subset'></span><span id='topic++5B.PointMap'></span><span id='topic++5B+3C-.PointMap'></span>

<h3>Description</h3>

<p>Subsetting PointMap objects essentially passes the data to stars
See <a href="stars.html#topic+stars_subset">stars_subset</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PointMap'
x[...]

## S3 replacement method for class 'PointMap'
x[...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PointMap_subset_+3A_x">x</code></td>
<td>
<p>object of class <code>PointMap</code> passed to <code>stars[]</code></p>
</td></tr>
<tr><td><code id="PointMap_subset_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>stars[] &lt;- </code></p>
</td></tr>
<tr><td><code id="PointMap_subset_+3A_value">value</code></td>
<td>
<p>value to be passed to <code>stars[] &lt;- </code></p>
</td></tr>
</table>

<hr>
<h2 id='PointMap-class'>PointMap</h2><span id='topic+PointMap-class'></span><span id='topic+PointMap'></span>

<h3>Description</h3>

<p>A representation of sala's PointMap in R. Holds onto a sala PointMap pointer
and operates on that
</p>

<hr>
<h2 id='readMetaGraph'>Read MetaGraph</h2><span id='topic+readMetaGraph'></span>

<h3>Description</h3>

<p>Reads a metagraph into a bunch of ShapeMaps/ShapeGraphs/PointMaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMetaGraph(fileName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMetaGraph_+3A_filename">fileName</code></td>
<td>
<p>The metagraph file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ShapeMaps, ShapeGraphs and PointMaps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fileName &lt;- system.file(
  "extdata", "testdata", "barnsbury", "barnsburySmall.graph",
  package = "alcyon"
)
readMetaGraph(fileName)
</code></pre>

<hr>
<h2 id='reduceToFewest'>Reduce an All-line Map to two types of fewest-line maps</h2><span id='topic+reduceToFewest'></span>

<h3>Description</h3>

<p>Reduce an All-line Map to two types of fewest-line maps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceToFewest(allLineMap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceToFewest_+3A_alllinemap">allLineMap</code></td>
<td>
<p>An AllLineShapeGraph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two fewest-line axial ShapeGraphs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
allLineMap &lt;- makeAllLineMap(
  shapeMap,
  seedX = 3.01,
  seedY = 6.7
)
reduceToFewest(allLineMap)
</code></pre>

<hr>
<h2 id='refIdToIndexAndBack'>Ref ID to index and vice-versa</h2><span id='topic+refIdToIndexAndBack'></span><span id='topic+refIDtoIndex'></span><span id='topic+indexToRefID'></span>

<h3>Description</h3>

<p>Converts a depthmapX &quot;Ref&quot; ID to the indices (x, y) of a cell, or the reverse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refIDtoIndex(refID)

indexToRefID(i, j)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refIdToIndexAndBack_+3A_refid">refID</code></td>
<td>
<p>The Ref ID</p>
</td></tr>
<tr><td><code id="refIdToIndexAndBack_+3A_i">i</code></td>
<td>
<p>The x-axis index of the cell</p>
</td></tr>
<tr><td><code id="refIdToIndexAndBack_+3A_j">j</code></td>
<td>
<p>The y-axis index of the cell</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pair of indices (x, y) or a Ref ID
</p>


<h3>Examples</h3>

<pre><code class='language-R'>idx &lt;- refIDtoIndex(852645)
# outputs:
#    i   j
# 1 13 677

idx &lt;- indexToRefID(13, 667)
# outputs:
# 852645
</code></pre>

<hr>
<h2 id='SegmentShapeGraph_subset'>Subset SegmentShapeGraph objects</h2><span id='topic+SegmentShapeGraph_subset'></span><span id='topic++5B.SegmentShapeGraph'></span><span id='topic++5B+3C-.SegmentShapeGraph'></span>

<h3>Description</h3>

<p>Subsetting SegmentShapeGraph objects essentially passes the data to sf.
See <a href="sf.html#topic+sf">sf</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SegmentShapeGraph'
x[...]

## S3 replacement method for class 'SegmentShapeGraph'
x[...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SegmentShapeGraph_subset_+3A_x">x</code></td>
<td>
<p>object of class <code>SegmentShapeGraph</code> passed to <code>stars[]</code></p>
</td></tr>
<tr><td><code id="SegmentShapeGraph_subset_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>stars[] &lt;- </code></p>
</td></tr>
<tr><td><code id="SegmentShapeGraph_subset_+3A_value">value</code></td>
<td>
<p>value to be passed to <code>sf[] &lt;- </code></p>
</td></tr>
</table>

<hr>
<h2 id='SegmentShapeGraph-class'>Segment ShapeGraph</h2><span id='topic+SegmentShapeGraph-class'></span><span id='topic+SegmentShapeGraph'></span>

<h3>Description</h3>

<p>A representation of sala's Segment ShapeGraph in R. Holds onto a sala Segment
ShapeGraph pointer and operates on that
</p>


<h3>See Also</h3>

<p>Other SegmentShapeGraph: 
<code><a href="#topic+as">as</a>()</code>
</p>

<hr>
<h2 id='shapegraphToIGraph'>Conversion of shapegraph to igraph</h2><span id='topic+shapegraphToIGraph'></span>

<h3>Description</h3>

<p>Creates igraph based on the connections and the x,y coordinates of the
centroids of shapes in a shapegraph (axial,segment, convex). Specify
weightColumn to assign weight to graph edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapegraphToIGraph(shapeGraph, weightColumn = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapegraphToIGraph_+3A_shapegraph">shapeGraph</code></td>
<td>
<p>A ShapeGraph</p>
</td></tr>
<tr><td><code id="shapegraphToIGraph_+3A_weightcolumn">weightColumn</code></td>
<td>
<p>Optional.The variable used to assign weight to graph
edges</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If weightColumn is provided, edge connections weight is calculated by taking
the average of the variable of the connected nodes.
</p>


<h3>Value</h3>

<p>Returns graph.data.frame.
</p>

<hr>
<h2 id='ShapeMap_subset'>Subset ShapeMap objects</h2><span id='topic+ShapeMap_subset'></span><span id='topic++5B.ShapeMap'></span><span id='topic++5B+3C-.ShapeMap'></span>

<h3>Description</h3>

<p>Subsetting ShapeMap objects essentially passes the data to sf.
See <a href="sf.html#topic+sf">sf</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ShapeMap'
x[...]

## S3 replacement method for class 'ShapeMap'
x[...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ShapeMap_subset_+3A_x">x</code></td>
<td>
<p>object of class <code>ShapeMap</code> passed to <code>sf[]</code></p>
</td></tr>
<tr><td><code id="ShapeMap_subset_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>sf[] &lt;- </code></p>
</td></tr>
<tr><td><code id="ShapeMap_subset_+3A_value">value</code></td>
<td>
<p>value to be passed to <code>sf[] &lt;- </code></p>
</td></tr>
</table>

<hr>
<h2 id='ShapeMap-class'>ShapeMap class</h2><span id='topic+ShapeMap-class'></span><span id='topic+ShapeMap'></span>

<h3>Description</h3>

<p>A representation of sala's ShapeMap in R. Holds onto a sala ShapeMap
pointer and operates on that
</p>


<h3>See Also</h3>

<p>Other ShapeMap: 
<code><a href="#topic+as">as</a>()</code>
</p>

<hr>
<h2 id='shapeMapToPolygonSf'>ShapeMap to sf Polygon map</h2><span id='topic+shapeMapToPolygonSf'></span>

<h3>Description</h3>

<p>Convert a ShapeMap to an sf Polygon map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapeMapToPolygonSf(shapeMap)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapeMapToPolygonSf_+3A_shapemap">shapeMap</code></td>
<td>
<p>A ShapeMap</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new sf Polygon map
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
isovistMap &lt;- isovist(
  shapeMap,
  x = c(3.01, 1.3),
  y = c(6.70, 5.2),
  angle = 0.01,
  viewAngle = 3.14,
  FALSE
)
shapeMapToPolygonSf(isovistMap)
</code></pre>

<hr>
<h2 id='TraversalType'>Traversal types</h2><span id='topic+TraversalType'></span>

<h3>Description</h3>

<p>These are meant to be used to indicate what kind of analysis
is meant to be carried out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TraversalType
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Value</h3>

<p>A list of numbers representing each particular analysis type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TraversalType$Angular
TraversalType$Topological
TraversalType$Metric
</code></pre>

<hr>
<h2 id='unlinkAtCrossPoint'>Unlink map lines at their crossing point</h2><span id='topic+unlinkAtCrossPoint'></span>

<h3>Description</h3>

<p>Unlink map lines at their crossing point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlinkAtCrossPoint(map, x, y, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkAtCrossPoint_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
<tr><td><code id="unlinkAtCrossPoint_+3A_x">x</code></td>
<td>
<p>X coordinate of the crossing point</p>
</td></tr>
<tr><td><code id="unlinkAtCrossPoint_+3A_y">y</code></td>
<td>
<p>Y coordinate of the crossing point</p>
</td></tr>
<tr><td><code id="unlinkAtCrossPoint_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new map with linked lines
</p>

<hr>
<h2 id='unlinkAtCrossPoint+2CAxialShapeGraph-method'>Unlink two Axial Lines (crosspoint)</h2><span id='topic+unlinkAtCrossPoint+2CAxialShapeGraph-method'></span>

<h3>Description</h3>

<p>Unlink two crossing lines on an Axial ShapeGraph at the crossing point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxialShapeGraph'
unlinkAtCrossPoint(map, x, y, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkAtCrossPoint+2B2CAxialShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
<tr><td><code id="unlinkAtCrossPoint+2B2CAxialShapeGraph-method_+3A_x">x</code></td>
<td>
<p>X coordinate of the unlink crossing point</p>
</td></tr>
<tr><td><code id="unlinkAtCrossPoint+2B2CAxialShapeGraph-method_+3A_y">y</code></td>
<td>
<p>Y coordinate of the unlink crossing point</p>
</td></tr>
<tr><td><code id="unlinkAtCrossPoint+2B2CAxialShapeGraph-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new Axial ShapeGraph with unlinked lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
unlinkAtCrossPoint(shapeGraph, 530925.0, 184119.0)
</code></pre>

<hr>
<h2 id='unlinkCoords'>Unlink map points/lines as if selecting them using points</h2><span id='topic+unlinkCoords'></span>

<h3>Description</h3>

<p>Unlink map points/lines as if selecting them using points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlinkCoords(map, fromX, fromY, toX, toY, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkCoords_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
<tr><td><code id="unlinkCoords_+3A_fromx">fromX</code></td>
<td>
<p>X coordinate of the origin point</p>
</td></tr>
<tr><td><code id="unlinkCoords_+3A_fromy">fromY</code></td>
<td>
<p>Y coordinate of the origin point</p>
</td></tr>
<tr><td><code id="unlinkCoords_+3A_tox">toX</code></td>
<td>
<p>X coordinate of the target point</p>
</td></tr>
<tr><td><code id="unlinkCoords_+3A_toy">toY</code></td>
<td>
<p>Y coordinate of the target point</p>
</td></tr>
<tr><td><code id="unlinkCoords_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new map with unlinked points/lines
</p>

<hr>
<h2 id='unlinkCoords+2CAxialShapeGraph-method'>Unlink two Axial Lines (coordinates)</h2><span id='topic+unlinkCoords+2CAxialShapeGraph-method'></span>

<h3>Description</h3>

<p>Unlink two locations on an Axial ShapeGraph using the point coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxialShapeGraph'
unlinkCoords(map, fromX, fromY, toX, toY, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkCoords+2B2CAxialShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CAxialShapeGraph-method_+3A_fromx">fromX</code></td>
<td>
<p>X coordinate of the first unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CAxialShapeGraph-method_+3A_fromy">fromY</code></td>
<td>
<p>Y coordinate of the first unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CAxialShapeGraph-method_+3A_tox">toX</code></td>
<td>
<p>X coordinate of the second unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CAxialShapeGraph-method_+3A_toy">toY</code></td>
<td>
<p>Y coordinate of the second unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CAxialShapeGraph-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new Axial ShapeGraph with unlinked lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
unlinkCoords(shapeGraph, 982.8, -1620.3, 1080.4, -1873.5)
</code></pre>

<hr>
<h2 id='unlinkCoords+2CPointMap-method'>Unlink two PointMap Cells (coordinates)</h2><span id='topic+unlinkCoords+2CPointMap-method'></span>

<h3>Description</h3>

<p>Unlink two cells on a PointMap using the point coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointMap'
unlinkCoords(map, fromX, fromY, toX, toY, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkCoords+2B2CPointMap-method_+3A_map">map</code></td>
<td>
<p>A PointMap</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CPointMap-method_+3A_fromx">fromX</code></td>
<td>
<p>X coordinate of the first unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CPointMap-method_+3A_fromy">fromY</code></td>
<td>
<p>Y coordinate of the first unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CPointMap-method_+3A_tox">toX</code></td>
<td>
<p>X coordinate of the second unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CPointMap-method_+3A_toy">toY</code></td>
<td>
<p>Y coordinate of the second unlink point</p>
</td></tr>
<tr><td><code id="unlinkCoords+2B2CPointMap-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with unlinked points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "gallery",
    "gallery_lines.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.04,
    fillX = 3.01,
    fillY = 6.7,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
pointMap &lt;- linkCoords(pointMap, 1.74, 6.7, 5.05, 5.24)
pointMap &lt;- unlinkCoords(pointMap, 1.74, 6.7, 5.05, 5.24)
</code></pre>

<hr>
<h2 id='unlinkRefs'>Unlink map points/lines using their refs</h2><span id='topic+unlinkRefs'></span>

<h3>Description</h3>

<p>Unlink map points/lines using their refs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlinkRefs(map, fromRef, toRef, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkRefs_+3A_map">map</code></td>
<td>
<p>A sala map</p>
</td></tr>
<tr><td><code id="unlinkRefs_+3A_fromref">fromRef</code></td>
<td>
<p>The ref of the origin element</p>
</td></tr>
<tr><td><code id="unlinkRefs_+3A_toref">toRef</code></td>
<td>
<p>The ref of the target element</p>
</td></tr>
<tr><td><code id="unlinkRefs_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new map with unlinked points/lines
</p>

<hr>
<h2 id='unlinkRefs+2CAxialShapeGraph-method'>Unlink two Axial Lines (refs)</h2><span id='topic+unlinkRefs+2CAxialShapeGraph-method'></span>

<h3>Description</h3>

<p>Unlink two lines on an Axial ShapeGraph using their refs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'AxialShapeGraph'
unlinkRefs(map, fromRef, toRef, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkRefs+2B2CAxialShapeGraph-method_+3A_map">map</code></td>
<td>
<p>An Axial ShapeGraph</p>
</td></tr>
<tr><td><code id="unlinkRefs+2B2CAxialShapeGraph-method_+3A_fromref">fromRef</code></td>
<td>
<p>Ref of the first unlink line</p>
</td></tr>
<tr><td><code id="unlinkRefs+2B2CAxialShapeGraph-method_+3A_toref">toRef</code></td>
<td>
<p>Ref of the second unlink line</p>
</td></tr>
<tr><td><code id="unlinkRefs+2B2CAxialShapeGraph-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new Axial ShapeGraph with unlinked lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "barnsbury",
    "barnsbury_small_axial_original.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeGraph &lt;- as(sfMap, "AxialShapeGraph")
unlinkRefs(shapeGraph, 12L, 34L)
</code></pre>

<hr>
<h2 id='unlinkRefs+2CPointMap-method'>Unlink two PointMap Cells (refs)</h2><span id='topic+unlinkRefs+2CPointMap-method'></span>

<h3>Description</h3>

<p>Unlink two cells on an PointMap using their refs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PointMap'
unlinkRefs(map, fromRef, toRef, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unlinkRefs+2B2CPointMap-method_+3A_map">map</code></td>
<td>
<p>A PointMap</p>
</td></tr>
<tr><td><code id="unlinkRefs+2B2CPointMap-method_+3A_fromref">fromRef</code></td>
<td>
<p>Ref of the first unlink line</p>
</td></tr>
<tr><td><code id="unlinkRefs+2B2CPointMap-method_+3A_toref">toRef</code></td>
<td>
<p>Ref of the second unlink line</p>
</td></tr>
<tr><td><code id="unlinkRefs+2B2CPointMap-method_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with unlinked points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "gallery",
    "gallery_lines.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.04,
    fillX = 3.01,
    fillY = 6.7,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
pointMap &lt;- linkRefs(pointMap, 1835056L, 7208971L)
pointMap &lt;- unlinkRefs(pointMap, 1835056L, 7208971L)
</code></pre>

<hr>
<h2 id='unmakeVGAGraph'>Unmake the graph in a PointMap</h2><span id='topic+unmakeVGAGraph'></span>

<h3>Description</h3>

<p>Unmake the graph in a PointMap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmakeVGAGraph(pointMap, removeLinks = FALSE, copyMap = TRUE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmakeVGAGraph_+3A_pointmap">pointMap</code></td>
<td>
<p>The input PointMap</p>
</td></tr>
<tr><td><code id="unmakeVGAGraph_+3A_removelinks">removeLinks</code></td>
<td>
<p>Also remove the links</p>
</td></tr>
<tr><td><code id="unmakeVGAGraph_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="unmakeVGAGraph_+3A_verbose">verbose</code></td>
<td>
<p>Optional. Show more information of the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap without the points graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  shapeMap &lt;- as(sfMap[, vector()], "ShapeMap")
pointMap &lt;- makeVGAPointMap(
  sfMap,
  gridSize = 0.5,
  fillX = 3.01,
  fillY = 6.7,
  maxVisibility = NA,
  boundaryGraph = FALSE,
  verbose = FALSE
)
unmakeVGAGraph(
  pointMap = pointMap,
  removeLinks = FALSE
)
</code></pre>

<hr>
<h2 id='vgaIsovist'>Visibility Graph Analysis - isovist metrics</h2><span id='topic+vgaIsovist'></span>

<h3>Description</h3>

<p>Runs axial analysis to get the local metrics Control and Controllability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgaIsovist(pointMap, boundaryMap, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgaIsovist_+3A_pointmap">pointMap</code></td>
<td>
<p>A PointMap</p>
</td></tr>
<tr><td><code id="vgaIsovist_+3A_boundarymap">boundaryMap</code></td>
<td>
<p>A ShapeMap of lines</p>
</td></tr>
<tr><td><code id="vgaIsovist_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with the results included
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.5,
    fillX = 3.0,
    fillY = 6.0,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
boundaryMap &lt;- as(sfMap[, c()], "ShapeMap")
vgaIsovist(pointMap, boundaryMap)
</code></pre>

<hr>
<h2 id='vgaThroughVision'>Visibility Graph Analysis - Through Vision</h2><span id='topic+vgaThroughVision'></span>

<h3>Description</h3>

<p>Runs Visibility Graph Analysis to get the Through Vision metric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgaThroughVision(pointMap, copyMap = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgaThroughVision_+3A_pointmap">pointMap</code></td>
<td>
<p>A PointMap</p>
</td></tr>
<tr><td><code id="vgaThroughVision_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with the results included
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.5,
    fillX = 3.0,
    fillY = 6.0,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
vgaThroughVision(pointMap)
</code></pre>

<hr>
<h2 id='vgaVisualLocal'>Visibility Graph Analysis - Visual local metrics</h2><span id='topic+vgaVisualLocal'></span>

<h3>Description</h3>

<p>Runs Visibility Graph Analysis to get visual local metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgaVisualLocal(pointMap, copyMap = TRUE, gatesOnly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgaVisualLocal_+3A_pointmap">pointMap</code></td>
<td>
<p>A PointMap</p>
</td></tr>
<tr><td><code id="vgaVisualLocal_+3A_copymap">copyMap</code></td>
<td>
<p>Optional. Copy the internal sala map</p>
</td></tr>
<tr><td><code id="vgaVisualLocal_+3A_gatesonly">gatesOnly</code></td>
<td>
<p>Optional. Only keep the values at specific gates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new PointMap with the results included
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mifFile &lt;- system.file(
    "extdata", "testdata", "simple",
    "simple_interior.mif",
    package = "alcyon"
  )
  sfMap &lt;- st_read(mifFile,
    geometry_column = 1L, quiet = TRUE
  )
  pointMap &lt;- makeVGAPointMap(
    sfMap,
    gridSize = 0.5,
    fillX = 3.0,
    fillY = 6.0,
    maxVisibility = NA,
    boundaryGraph = FALSE,
    verbose = FALSE
  )
vgaVisualLocal(pointMap, FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
