<!DOCTYPE html><html><head><title>Help for package cfr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cfr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cfr-package'><p>cfr: Estimate Disease Severity and Case Ascertainment</p></a></li>
<li><a href='#.estimate_severity'><p>Estimate the corrected case fatality risk</p></a></li>
<li><a href='#.select_func_likelihood'><p>Select a likelihood function for severity estimation</p></a></li>
<li><a href='#cfr_rolling'><p>Estimate static severity for an expanding time series</p></a></li>
<li><a href='#cfr_static'><p>Estimate a static disease severity measure</p></a></li>
<li><a href='#cfr_time_varying'><p>Estimate a severity measure that varies over time</p></a></li>
<li><a href='#covid_data'><p>Daily Covid-19 case and death data for countries with 100,000 or more deaths</p></a></li>
<li><a href='#delay_density_helpers'><p>Check delay density functions passed to exported functions</p></a></li>
<li><a href='#ebola1976'><p>Ebola 1976 outbreak case data</p></a></li>
<li><a href='#estimate_ascertainment'><p>Estimate the ascertainment ratio of a disease</p></a></li>
<li><a href='#estimate_outcomes'><p>Estimate known outcomes of cases using a delay distribution</p></a></li>
<li><a href='#prepare_data'><p>Prepare common epidemiological data formats for CFR estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimate Disease Severity and Case Ascertainment</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate the severity of a disease and ascertainment of
    cases, as discussed in Nishiura et al. (2009)
    &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0006852">doi:10.1371/journal.pone.0006852</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/epiverse-trace/cfr">https://github.com/epiverse-trace/cfr</a>,
<a href="https://epiverse-trace.github.io/cfr/">https://epiverse-trace.github.io/cfr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/epiverse-trace/cfr/issues">https://github.com/epiverse-trace/cfr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, data.table, distcrete, distributional, dplyr,
forcats, ggplot2, incidence2, knitr, purrr, rmarkdown, scales,
spelling, testthat (&ge; 3.0.0), tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>epiverse-trace/epiversetheme</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-12 11:32:48 UTC; lshpg6</td>
</tr>
<tr>
<td>Author:</td>
<td>Pratik R. Gupte <a href="https://orcid.org/0000-0001-5294-7819"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Adam Kucharski <a href="https://orcid.org/0000-0001-8814-9421"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph, cre],
  Tim Russell <a href="https://orcid.org/0000-0001-5610-6080"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Joshua W. Lambert <a href="https://orcid.org/0000-0001-5218-3046"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Hugo Gruson <a href="https://orcid.org/0000-0002-4094-1476"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  James M. Azam <a href="https://orcid.org/0000-0001-5782-7330"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Abdoelnaser M. Degoot
    <a href="https://orcid.org/0000-0001-8788-2496"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Sebastian Funk <a href="https://orcid.org/0000-0002-2842-3406"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Kucharski &lt;adam.kucharski@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-12 21:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='cfr-package'>cfr: Estimate Disease Severity and Case Ascertainment</h2><span id='topic+cfr'></span><span id='topic+cfr-package'></span>

<h3>Description</h3>

<p>Estimate the severity of a disease and ascertainment of cases, as discussed in Nishiura et al. (2009) <a href="https://doi.org/10.1371/journal.pone.0006852">doi:10.1371/journal.pone.0006852</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Adam Kucharski <a href="mailto:adam.kucharski@lshtm.ac.uk">adam.kucharski@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-8814-9421">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Pratik R. Gupte <a href="mailto:pratik.gupte@lshtm.ac.uk">pratik.gupte@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5294-7819">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Tim Russell <a href="mailto:timothy.russell@lshtm.ac.uk">timothy.russell@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5610-6080">ORCID</a>) [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Joshua W. Lambert <a href="mailto:joshua.lambert@lshtm.ac.uk">joshua.lambert@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5218-3046">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Hugo Gruson <a href="mailto:hugo.gruson@data.org">hugo.gruson@data.org</a> (<a href="https://orcid.org/0000-0002-4094-1476">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Tim Taylor <a href="mailto:tim.taylor@hiddenelephants.co.uk">tim.taylor@hiddenelephants.co.uk</a> (<a href="https://orcid.org/0000-0002-8587-7113">ORCID</a>) [reviewer]
</p>
</li>
<li><p> James M. Azam <a href="mailto:james.azam@lshtm.ac.uk">james.azam@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-5782-7330">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Abdoelnaser M. Degoot <a href="mailto:abdoelnaser-mahmood.degoot@lshtm.ac.uk">abdoelnaser-mahmood.degoot@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0001-8788-2496">ORCID</a>) [reviewer]
</p>
</li>
<li><p> Sebastian Funk <a href="mailto:sebastian.funk@lshtm.ac.uk">sebastian.funk@lshtm.ac.uk</a> (<a href="https://orcid.org/0000-0002-2842-3406">ORCID</a>) [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/epiverse-trace/cfr">https://github.com/epiverse-trace/cfr</a>
</p>
</li>
<li> <p><a href="https://epiverse-trace.github.io/cfr/">https://epiverse-trace.github.io/cfr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/epiverse-trace/cfr/issues">https://github.com/epiverse-trace/cfr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.estimate_severity'>Estimate the corrected case fatality risk</h2><span id='topic+.estimate_severity'></span>

<h3>Description</h3>

<p>Estimates the maximum likelihood estimate and 95% confidence
interval of a corrected severity, using the total cases and total cases with
known outcomes, where the latter replaces the total number of deaths in the
standard (naive) severity definition. We use a binomial likelihood,
approximated by a Poisson likelihood for large samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.estimate_severity(
  total_cases,
  total_deaths,
  total_outcomes,
  poisson_threshold,
  p_mid = total_deaths/round(total_outcomes)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".estimate_severity_+3A_total_cases">total_cases</code></td>
<td>
<p>The total number of cases observed over the period of an
outbreak of interest. The total number of cases must be greater than or equal
to the total number of deaths.</p>
</td></tr>
<tr><td><code id=".estimate_severity_+3A_total_deaths">total_deaths</code></td>
<td>
<p>The total number of deaths observed over the period of an
outbreak of interest. The total number of deaths must be less than or equal
to the total number of cases.</p>
</td></tr>
<tr><td><code id=".estimate_severity_+3A_total_outcomes">total_outcomes</code></td>
<td>
<p>The total number of outcomes expected to be observed
over the period of an outbreak of interest. See <code><a href="#topic+estimate_outcomes">estimate_outcomes()</a></code>.</p>
</td></tr>
<tr><td><code id=".estimate_severity_+3A_poisson_threshold">poisson_threshold</code></td>
<td>
<p>The case count above which to use Poisson
approximation. Set to 100 by default. Must be &gt; 0.</p>
</td></tr>
<tr><td><code id=".estimate_severity_+3A_p_mid">p_mid</code></td>
<td>
<p>The initial severity estimate, which is used to determine the
likelihood approximation used when <code>total_cases</code> &gt; <code>poisson_threshold</code>.
Defaults to <code>total_deaths / round(total_outcomes)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Special cases</h4>


<ul>
<li><p> When any two of <code>total_cases</code>, <code>total_deaths</code>, or <code>total_outcomes</code> are 0,
the estimate and confidence intervals cannot be calculated and the output
<code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> contains only <code>NA</code>s.
</p>
</li>
<li><p> When <code>total_cases == total_deaths</code> <em>and</em> <code>total_outcomes &lt;= total_deaths</code>,
while <code>total_cases &lt; poisson_threshold</code>, the confidence intervals cannot be
calculated and are returned as <code>NA</code>. The severity is returned as the lowest
possible value for the method used when cases are below the Poisson
threshold, which is 0.001.
</p>
</li>
<li><p> When <code>total_outcomes == total_deaths</code> while
<code>total_cases &lt; poisson_threshold</code> the confidence intervals cannot be
calculated and are returned as <code>NA</code>s while the severity estimate is returned
as <code>0.999</code>.
</p>
</li></ul>




<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with one row and three columns for the maximum
likelihood estimate and 95% confidence interval of the corrected severity
estimates, named &quot;severity_estimate&quot;, &quot;severity_low&quot;, and &quot;severity_high&quot;.
</p>

<hr>
<h2 id='.select_func_likelihood'>Select a likelihood function for severity estimation</h2><span id='topic+.select_func_likelihood'></span>

<h3>Description</h3>

<p>Switches between Binomial, Poisson, and Normal approximation based on the
total number of cases and an initial estimate of the severity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.select_func_likelihood(total_cases, poisson_threshold, p_mid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".select_func_likelihood_+3A_total_cases">total_cases</code></td>
<td>
<p>A single count for the total number of cases in the
outbreak.</p>
</td></tr>
<tr><td><code id=".select_func_likelihood_+3A_poisson_threshold">poisson_threshold</code></td>
<td>
<p>A single count for the threshold of cases above
which a Poisson or Normal approximation is returned.</p>
</td></tr>
<tr><td><code id=".select_func_likelihood_+3A_p_mid">p_mid</code></td>
<td>
<p>A single positive number bounded 0 &ndash; 1, representing an initial
estimate of the severity, which is used to determine whether a Poisson or
Normal approximation is returned.
determine whether</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a likelihood function as follows:
</p>

<ul>
<li><p> Binomial approximation: when <code>total_cases &lt; poisson_threshold</code>,
used when there are few cases, such as in a small outbreak;
</p>
</li>
<li><p> Poisson approximation: when <code>total_cases &gt;= poisson_threshold</code> but
when <code>p_mid</code> &lt; 0.05;
</p>
</li>
<li><p> Normal approximation: when <code>total_cases &gt;= poisson_threshold</code> and
<code style="white-space: pre;">&#8288;p_mid &gt;=&#8288;</code> 0.05.
</p>
</li></ul>



<h3>Value</h3>

<p>A function with three arguments, <code>total_outcomes</code>, <code>total_deaths</code>,
and <code>pp</code>, which is used to generate the profile likelihood.
Also prints messages to the screen when a Poisson or Normal approximation
function is returned.
</p>

<hr>
<h2 id='cfr_rolling'>Estimate static severity for an expanding time series</h2><span id='topic+cfr_rolling'></span>

<h3>Description</h3>

<p>Calculates the CFR at each time point in the case and death time
series supplied, using an expanding window of time. The static CFR is
calculated for each time point, using the time series from the start to each
time point, and increasing the number of time points included by one in each
iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfr_rolling(data, delay_density = NULL, poisson_threshold = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfr_rolling_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="cfr_rolling_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
<tr><td><code id="cfr_rolling_+3A_poisson_threshold">poisson_threshold</code></td>
<td>
<p>The case count above which to use Poisson
approximation. Set to 100 by default. Must be &gt; 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When delay correction is applied by passing a delay distribution
density function to <code>delay_density</code>, the internal function
<code><a href="#topic+.estimate_severity">.estimate_severity()</a></code> is used to calculate the rolling severity.
</p>
<p>Note that in the naive method the severity estimate and confidence intervals
cannot be calculated for days on which the cumulative number of cases since
the start of the time-series, and for days on which the cumulative number of
deaths reported exceeds the cumulative reported cases, and is returned as
<code>NA</code>.
</p>
<p><code>cfr_rolling()</code> applies the internal function <code>.estimate_severity()</code> to an
expanding time-series of total cases, total estimated outcomes, and total
deaths. The method used to generate a profile likelihood for each day depends
on the outbreak size and initial severity estimate for that day. This is
essentially the same as running <code><a href="#topic+cfr_static">cfr_static()</a></code> on each new day. The method
used for each day is not communicated to the user, in order to prevent
cluttering the terminal with messages.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the date, maximum likelihood estimate and 95%
confidence interval of the daily severity estimates, named
&quot;severity_estimate&quot;, &quot;severity_low&quot;, and &quot;severity_high&quot;, with one row for
each day in the original data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load package data
data("ebola1976")

# estimate severity without correcting for delays
cfr_static(ebola1976)

# estimate severity for each day while correcting for delays
# obtain onset-to-death delay distribution parameters from Barry et al. 2018
# The Lancet. &lt;https://doi.org/10.1016/S0140-6736(18)31387-4&gt;
# view only the first values
estimate &lt;- cfr_rolling(
  ebola1976,
  delay_density = function(x) dgamma(x, shape = 2.40, scale = 3.33)
)

head(estimate)

</code></pre>

<hr>
<h2 id='cfr_static'>Estimate a static disease severity measure</h2><span id='topic+cfr_static'></span>

<h3>Description</h3>

<p>Calculates the severity of a disease, while optionally
correcting for reporting delays using an epidemiological delay distribution
of the time between symptom onset and death (onset-to-death).
</p>
<p>Other delay distributions may be passed to calculate different disease
severity measures such as the hospitalisation fatality risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfr_static(data, delay_density = NULL, poisson_threshold = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfr_static_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="cfr_static_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
<tr><td><code id="cfr_static_+3A_poisson_threshold">poisson_threshold</code></td>
<td>
<p>The case count above which to use Poisson
approximation. Set to 100 by default. Must be &gt; 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the maximum likelihood estimate and 95%
confidence interval of the severity estimates, named &quot;severity_estimate&quot;,
&quot;severity_low&quot;, and &quot;severity_high&quot;.
</p>


<h3>Details: Adjusting for delays between two time series</h3>

<p>The method used in <code>cfr_static()</code> follows Nishiura et al.
(2009).
The function calculates a quantity <code class="reqn">u_t</code> for each day within the input
data, which represents the proportion of cases estimated to have
a known outcome on day <code class="reqn">t</code>.
Following Nishiura et al., <code class="reqn">u_t</code> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">u_t = \dfrac{\sum_{i = 0}^t
        \sum_{j = 0}^\infty c_i f_{j - i}}{\sum_{i = 0} c_i}</code>
</p>

<p>where <code class="reqn">f_t</code> is the value of the probability mass function at time <code class="reqn">t</code>
and <code class="reqn">c_t</code>, <code class="reqn">d_t</code> are the number of new cases and new deaths at time
<code class="reqn">t</code>, (respectively).
We then use <code class="reqn">u_t</code> at the end of the outbreak in the following likelihood
function to estimate the severity of the disease in question.
</p>
<p style="text-align: center;"><code class="reqn">{\sf L}({\theta \mid y}) = \log{\dbinom{u_tC}{D}} + D \log{\theta} +
  (u_tC - D)\log{(1.0 - \theta)}</code>
</p>

<p><code class="reqn">C</code> and <code class="reqn">D</code> are the cumulative number of cases and deaths
(respectively) up until time <code class="reqn">t</code>.
<code class="reqn">\theta</code> is the parameter we wish to estimate, the severity of the
disease. We estimate <code class="reqn">\theta</code> using simple maximum-likelihood methods,
allowing the functions within this package to be quick and easy tools to use.
</p>
<p>The precise severity measure — CFR, IFR, HFR, etc — that <code class="reqn">\theta</code>
represents depends upon the input data given by the user.
</p>
<p>The epidemiological delay-distribution density function passed to
<code>delay_density</code> is used to evaluate the probability mass function
parameterised by time; i.e. <code class="reqn">f(t)</code> which
gives the probability that a case has a known outcome (usually death) at time
<code class="reqn">t</code>, parameterised with disease-specific parameters before it is supplied
here.
</p>


<h4>Profile likelihood methods</h4>

<p>The naive CFR estimate (without delay correction) is the outcome of a
Binomial test on deaths and cases using <code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>.
The confidence intervals around the estimate are also taken from the test.
</p>
<p>The delay-corrected CFR estimates are however obtained by generating a
profile likelihood over the sequence <code>seq(1e-4, 1.0, 1e-4)</code>. The method used
depends on the outbreak size and the initial expectation of disease severity.
This is implemented in the internal function <code>.estimate_severity()</code>.
</p>

<ul>
<li> <p><strong>Delay correction, small outbreaks</strong>: For outbreaks where the total cases
are below the user-specified 'Poisson threshold' (<code>poisson_threshold</code>,
default = 100), the CFR and uncertainty around it is taken from a profile
likelihood generated from a Binomial model of deaths (successes) and
estimated known outcomes (trials).
</p>

<ul>
<li> <p><strong>Delay correction, large outbreaks with low severity</strong>: For outbreaks
with total cases greater than the Poisson threshold (default = 100) and with
initial severity estimates &lt; 0.05, the CFR and uncertainty are taken from a
Poisson approximation of the Binomial profile likelihood (taking
<code class="reqn">\lambda = np</code> for <code class="reqn">n</code> estimated outcomes and <code class="reqn">p</code> as the severity
estimate).
</p>
</li></ul>

</li>
<li> <p><strong>Delay correction, large outbreaks with higher severity</strong>: For outbreaks
with total cases greater than the Poisson threshold (default = 100) and with
initial severity estimates <code class="reqn">\geq</code> 0.05, the CFR and uncertainty are taken
from a Normal approximation of the Binomial profile likelihood.
</p>
</li></ul>




<h3>References</h3>

<p>Nishiura, H., Klinkenberg, D., Roberts, M., &amp; Heesterbeek, J. A. P. (2009).
Early Epidemiological Assessment of the Virulence of Emerging Infectious
Diseases: A Case Study of an Influenza Pandemic. PLOS ONE, 4(8), e6852.
<a href="https://doi.org/10.1371/journal.pone.0006852">doi:10.1371/journal.pone.0006852</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load package data
data("ebola1976")

# estimate severity without correcting for delays
cfr_static(ebola1976)

# estimate severity for each day while correcting for delays
# obtain onset-to-death delay distribution parameters from Barry et al. 2018
# The Lancet. &lt;https://doi.org/10.1016/S0140-6736(18)31387-4&gt;
cfr_static(
  ebola1976,
  delay_density = function(x) dgamma(x, shape = 2.40, scale = 3.33)
)

</code></pre>

<hr>
<h2 id='cfr_time_varying'>Estimate a severity measure that varies over time</h2><span id='topic+cfr_time_varying'></span>

<h3>Description</h3>

<p>Calculates how the severity of a disease changes over time
while optionally correcting for reporting delays using an epidemiological
delay distribution of the time between symptom onset and outcome
(e.g. onset-to-death for the fatality risk).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfr_time_varying(
  data,
  delay_density = NULL,
  burn_in = 7,
  smoothing_window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfr_time_varying_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="cfr_time_varying_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
<tr><td><code id="cfr_time_varying_+3A_burn_in">burn_in</code></td>
<td>
<p>A single integer-like value for the number of time-points
(typically days) to disregard at the start of the time-series, if a burn-in
period is desired.
</p>
<p>Defaults to 7, which is a sensible default value that disregards the first
week of cases and deaths, assuming daily data.
</p>
<p>To consider all case data including the start of the time-series, set this
argument to 0.</p>
</td></tr>
<tr><td><code id="cfr_time_varying_+3A_smoothing_window">smoothing_window</code></td>
<td>
<p>An <em>odd</em> number determining the smoothing window size
to use when smoothing the case and death time-series, using a rolling median
procedure (as the <code>k</code> argument to <code><a href="stats.html#topic+runmed">stats::runmed()</a></code>) before calculating the
time-varying severity.
</p>
<p>The default behaviour is to apply no smoothing. The minimum value of this
argument is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the date, maximum likelihood estimate and 95%
confidence interval of the daily severity estimates, named
&quot;severity_estimate&quot;, &quot;severity_low&quot;, and &quot;severity_high&quot;, with one row for
each day in the original data.frame.
</p>


<h3>Details: Adjusting for delays between two time series</h3>

<p>This function estimates the number of cases which have a known outcome over
time, following Nishiura et al. (2009).
The function calculates a quantity <code class="reqn">k_t</code> for each day within the input
data, which represents the number of cases estimated to have a known outcome,
on day <code class="reqn">t</code>. <code class="reqn">k_t</code> is calculated in the following way:
</p>
<p style="text-align: center;"><code class="reqn">k_t = \sum_{j = 0}^t c_t f_{j - t}</code>
</p>

<p>We then assume that the severity measure, for example CFR, of interest is
binomially distributed, in the following way:
</p>
<p style="text-align: center;"><code class="reqn">d_t \sim {\sf Binomial}(k_t, \theta_t)</code>
</p>

<p>We use maximum likelihood estimation to determine the value of <code class="reqn">\theta_t</code>
for each <code class="reqn">t</code>, where <code class="reqn">\theta</code> represents the severity measure of
interest.
</p>
<p>The epidemiological delay distribution passed to <code>delay_density</code> is used to
obtain a probability mass function parameterised by time; i.e. <code class="reqn">f(t)</code>
which gives the probability of the binary outcome of a case (survival or
death) being known by time <code class="reqn">t</code>. The delay distribution is parameterised
with disease-specific parameters before it is supplied here.
</p>
<p><strong>Note</strong> that the function arguments <code>burn_in</code> and <code>smoothing_window</code> are not
explicitly used in this calculation. <code>burn_in</code> controls how many estimates at
the beginning of the outbreak are replaced with <code>NA</code>s &mdash; the calculation
above is not applied to the first <code>burn_in</code> data points.
The calculation is applied to the smoothed data, if a <code>smoothing_window</code>
is specified.
</p>


<h3>References</h3>

<p>Nishiura, H., Klinkenberg, D., Roberts, M., &amp; Heesterbeek, J. A. P. (2009).
Early Epidemiological Assessment of the Virulence of Emerging Infectious
Diseases: A Case Study of an Influenza Pandemic. PLOS ONE, 4(8), e6852.
<a href="https://doi.org/10.1371/journal.pone.0006852">doi:10.1371/journal.pone.0006852</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get data pre-loaded with the package
data("covid_data")
df_covid_uk &lt;- covid_data[covid_data$country == "United Kingdom", ]

# estimate time varying severity without correcting for delays
cfr_time_varying &lt;- cfr_time_varying(
  data = df_covid_uk,
  burn_in = 7L
)
# View
tail(cfr_time_varying)

# estimate time varying severity while correcting for delays
# obtain onset-to-death delay distribution parameters from Linton et al. 2020
# J. Clinical Medicine: &lt;https://doi.org/10.3390/jcm9020538&gt;
# view only the first values
cfr_time_varying &lt;- cfr_time_varying(
  data = df_covid_uk,
  delay_density = function(x) dlnorm(x, meanlog = 2.577, sdlog = 0.440),
  burn_in = 7L
)
tail(cfr_time_varying)

</code></pre>

<hr>
<h2 id='covid_data'>Daily Covid-19 case and death data for countries with 100,000 or more deaths</h2><span id='topic+covid_data'></span>

<h3>Description</h3>

<p>Data adapted from the {covidregionaldata} package of daily cases and
deaths from the 19 countries with 100,000 or more deaths over the period
2020-01-01 to 2022-12-31. See the <strong>References</strong> for the publication which
links to data sources made available through {covidregionaldata}.
Included as {covidregionaldata} is no longer on CRAN.
Data are provided as a <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covid_data
</code></pre>


<h3>Format</h3>



<h4><code>covid_data</code></h4>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with 20,786 rows and 4 columns:
</p>

<dl>
<dt>date</dt><dd><p>Calendar date in the format %Y-%m-%d</p>
</dd>
<dt>country</dt><dd><p>The country name in simple format, e.g. &quot;United States&quot;
rather than &quot;United States of America&quot;</p>
</dd>
<dt>cases</dt><dd><p>Number of cases reported on each date</p>
</dd>
<dt>deaths</dt><dd><p>Number of deaths reported on each date</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://doi.org/10.21105/joss.03290">doi:10.21105/joss.03290</a>.
</p>


<h3>References</h3>

<p>Joseph Palmer, Katharine Sherratt, Richard Martin-Nielsen, Jonnie Bevan,
Hamish Gibbs, Sebastian Funk and Sam Abbott (2021). covidregionaldata:
Subnational data for COVID-19 epidemiology. <a href="https://doi.org/10.21105/joss.03290">doi:10.21105/joss.03290</a>
</p>

<hr>
<h2 id='delay_density_helpers'>Check delay density functions passed to exported functions</h2><span id='topic+delay_density_helpers'></span><span id='topic+test_fn_req_args'></span><span id='topic+test_fn_num_out'></span>

<h3>Description</h3>

<p>Internal helper function that check whether a function passed to
the <code>delay_density</code> argument in <code style="white-space: pre;">&#8288;cfr_*()&#8288;</code> or <code><a href="#topic+estimate_outcomes">estimate_outcomes()</a></code> meet the
requirements of package methods.
</p>
<p><code>test_fn_req_args()</code> checks whether the function has only the expected number
of required arguments, i.e., arguments without default values. Defaults to
checking for a single required argument.
</p>
<p><code>test_fn_num_out()</code> checks whether the function returns a numeric output
consistent with evaluating the probability density or probability mass
function of a distribution over a sequence of values.
Expects that the function returns a numeric vector of finite values
<code class="reqn">\geq</code> 0.0, that no values are missing, and that the output vector
is the same length as the input vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_fn_req_args(fn, n_req_args = 1)

test_fn_num_out(fn, n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delay_density_helpers_+3A_fn">fn</code></td>
<td>
<p>A function. This is expected to be a function evaluating the
density of a distribution at numeric values, and suitable to be passed to
<code>delay_density</code> in <code style="white-space: pre;">&#8288;cfr_*()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="delay_density_helpers_+3A_n_req_args">n_req_args</code></td>
<td>
<p>The number of required arguments, i.e., arguments without
default values.</p>
</td></tr>
<tr><td><code id="delay_density_helpers_+3A_n">n</code></td>
<td>
<p>The number of elements over which to evaluate the function <code>fn</code>.
Defaults to 10, and <code>fn</code> is evaluated over <code>seq(n)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical for whether the function <code>fn</code> fulfils conditions specified
in the respective checks.
</p>

<hr>
<h2 id='ebola1976'>Ebola 1976 outbreak case data</h2><span id='topic+ebola1976'></span>

<h3>Description</h3>

<p>An example epidemic outbreak dataset for use with the <code>cfr</code> package.
This dataset comes from the first Ebola outbreak in Zaire in 1976 as analysed
in Camacho et al. (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebola1976
</code></pre>


<h3>Format</h3>



<h4><code>ebola1976</code></h4>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with 73 rows and 3 columns:
</p>

<dl>
<dt>date</dt><dd><p>Calendar date</p>
</dd>
<dt>cases</dt><dd><p>Number of cases reported</p>
</dd>
<dt>deaths</dt><dd><p>Number of deaths reported</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.epidem.2014.09.003">doi:10.1016/j.epidem.2014.09.003</a>
</p>


<h3>References</h3>

<p>Camacho, A., Kucharski, A. J., Funk, S., Breman, J., Piot, P., &amp;
Edmunds, W. J. (2014). Potential for large outbreaks of Ebola virus disease.
Epidemics, 9, 70–78. <a href="https://doi.org/10.1016/j.epidem.2014.09.003">doi:10.1016/j.epidem.2014.09.003</a>
</p>

<hr>
<h2 id='estimate_ascertainment'>Estimate the ascertainment ratio of a disease</h2><span id='topic+estimate_ascertainment'></span>

<h3>Description</h3>

<p>Estimates the proportion of cases or infections that have been
ascertained, given a time-series of cases and deaths, a delay distribution
and a baseline severity estimate. The resulting ascertainment estimate is
calculated as the ratio of the baseline severity estimate, which is assumed
to be the 'true' disease severity, and the delay-adjusted severity estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_ascertainment(data, severity_baseline, delay_density = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_ascertainment_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="estimate_ascertainment_+3A_severity_baseline">severity_baseline</code></td>
<td>
<p>A single number in the range 0.0 &ndash; 1.0 for the
assumed true baseline severity estimate used to estimate the overall
ascertainment ratio. Missing by default, which causes the function to error;
must be supplied by the user.</p>
</td></tr>
<tr><td><code id="estimate_ascertainment_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>estimate_ascertainment()</code> uses <code><a href="#topic+cfr_static">cfr_static()</a></code> internally to obtain a
severity estimate that is compared against the user-specified baseline
severity. The profile likelihood method used to obtain the severity estimate
is decided by the internal function <code>.estimate_severity()</code> as used in
<code><a href="#topic+cfr_static">cfr_static()</a></code>, when delay correction is applied. See the <code><a href="#topic+cfr_static">cfr_static()</a></code>
documentation for an explanation of the methods used depending on outbreak
size and initial severity guess.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the maximum likelihood estimate estimate
and 95% confidence interval of the corrected severity, named
&quot;ascertainment_estimate&quot; (for the central estimate), and &quot;ascertainment_low&quot;
and &quot;ascertainment_high&quot; for the lower and upper interval limits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get data pre-loaded with the package
data("covid_data")
df_covid_uk &lt;- covid_data[covid_data$country == "United Kingdom", ]

df_covid_uk_subset &lt;- subset(df_covid_uk, date &lt;= "2020-05-31")

# use a severity baseline of 1.4% (0.014) taken from Verity et al. (2020)
# Lancet Infectious Diseases: &lt;https://doi.org/10.1016/S1473-3099(20)30243-7&gt;

# use onset-to-death distribution from Linton et al. (2020)
# J. Clinical Medicine: &lt;https://doi.org/10.3390/jcm9020538&gt;

# subset data until 30th June 2020
data &lt;- df_covid_uk[df_covid_uk$date &lt;= "2020-06-30", ]
estimate_ascertainment(
  data = data,
  delay_density = function(x) dlnorm(x, meanlog = 2.577, sdlog = 0.440),
  severity_baseline = 0.014
)

</code></pre>

<hr>
<h2 id='estimate_outcomes'>Estimate known outcomes of cases using a delay distribution</h2><span id='topic+estimate_outcomes'></span>

<h3>Description</h3>

<p>Estimates the expected number of individuals with known outcomes
from a case and outcome time series of outbreak data, and an epidemiological
delay distribution of symptom onset to outcome.
When calculating a case fatality risk, the outcomes must be deaths, the delay
distribution must be an onset-to-death distribution, and the function returns
estimates of the known death outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_outcomes(data, delay_density)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_outcomes_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="estimate_outcomes_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ratio <code>u_t</code> represents, for the outbreak, the overall proportion of
cases whose outcomes are expected to be known by each day $i$. For an ongoing
outbreak with relatively long delays between symptom onset and case outcome,
a <code>u_t</code> value of 1.0 may indicate that the outbreak has ended, as the
outcomes of all cases are expected to be known.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the columns in <code>data</code>, and with two additional
columns:
</p>

<ul>
<li> <p><code>"estimated_outcomes"</code> for the number of cases with an outcome of interest
(usually, death) estimated to be known on the dates specified in <code>data</code>, and
</p>
</li>
<li> <p><code>u_t</code> for the ratio of cumulative number of estimated known outcomes
and the cumulative number of cases reported until each date specified in
<code>data</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load Ebola 1976 outbreak data
data("ebola1976")

# estimate severity for each day while correcting for delays
# obtain onset-to-death delay distribution parameters from Barry et al. 2018
# examine the first few rows of the output
estimated_outcomes &lt;- estimate_outcomes(
  data = ebola1976,
  delay_density = function(x) dgamma(x, shape = 2.40, scale = 3.33)
)

head(estimated_outcomes)
</code></pre>

<hr>
<h2 id='prepare_data'>Prepare common epidemiological data formats for CFR estimation</h2><span id='topic+prepare_data'></span><span id='topic+prepare_data.incidence2'></span>

<h3>Description</h3>

<p>This S3 generic has methods for classes commonly used for epidemiological
data.
</p>
<p>Currently, the only supported data format is <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> from the
<span class="pkg">incidence2</span> package. See <code><a href="incidence2.html#topic+incidence">incidence2::incidence()</a></code>. Grouped
<code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> data are supported, see <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(data, ...)

## S3 method for class 'incidence2'
prepare_data(
  data,
  cases_variable = "cases",
  deaths_variable = "deaths",
  fill_NA = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_data_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code>-like object. Currently, only <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code>
objects are supported. These may be grouped.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_...">...</code></td>
<td>
<p>Currently unused. Passing extra arguments will throw a warning.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_cases_variable">cases_variable</code></td>
<td>
<p>A string for the name of the cases variable in the
&quot;count_variable&quot; column of <code>data</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_deaths_variable">deaths_variable</code></td>
<td>
<p>A string for the name of the deaths variable in the
&quot;count_variable&quot; column of <code>data</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_fill_na">fill_NA</code></td>
<td>
<p>A logical indicating whether <code>NA</code>s in the cases and deaths
data should be replaced by 0s. The default value is <code>TRUE</code>, with a message
to make users aware of the replacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> data can replace <code>NA</code>s in the case and death
data with 0s using the <code>fill_NA</code> argument, which is <code>TRUE</code> by default,
meaning that <code>NA</code>s are replaced.
</p>
<p>Keeping <code>NA</code>s will cause downstream issues when calling functions such as
<code><a href="#topic+cfr_static">cfr_static()</a></code> on the data, as they cannot handle <code>NA</code>s.
Setting <code>fill_NA = TRUE</code> resolves this issue.
</p>
<p>Passing a grouped <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object to <code>data</code> will result in the function
respecting the grouping and returning grouping variables in separate columns.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> suitable for disease severity estimation functions
provided in <span class="pkg">cfr</span>, with the columns &quot;date&quot;, &quot;cases&quot;, and &quot;deaths&quot;.
</p>
<p>Additionally, for grouped <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> data, columns representing the
grouping variables will also be present.
</p>
<p>The result has a continuous sequence of dates between the start and end date
of <code>data</code>; this is required if the data is to be passed to functions such as
<code><a href="#topic+cfr_static">cfr_static()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### For &lt;incidence2&gt; data ####
# load Covid-19 data from incidence2
covid_uk &lt;- incidence2::covidregionaldataUK

# convert to incidence2 object
covid_uk_incidence &lt;- incidence2::incidence(
  covid_uk,
  date_index = "date",
  counts = c("cases_new", "deaths_new"),
  count_names_to = "count_variable"
)

# View tail of prepared data
data &lt;- prepare_data(
  covid_uk_incidence,
  cases_variable = "cases_new",
  deaths_variable = "deaths_new"
)

tail(data)

#### For grouped &lt;incidence2&gt; data ####
# convert data to incidence2 object grouped by region
covid_uk_incidence &lt;- incidence2::incidence(
  covid_uk,
  date_index = "date",
  counts = c("cases_new", "deaths_new"),
  count_names_to = "count_variable",
  groups = "region"
)

# View tail of prepared data
data &lt;- prepare_data(
  covid_uk_incidence,
  cases_variable = "cases_new",
  deaths_variable = "deaths_new"
)

tail(data)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
