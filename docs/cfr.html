<!DOCTYPE html><html><head><title>Help for package cfr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cfr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cfr_rolling'><p>Estimate static severity for an expanding time series</p></a></li>
<li><a href='#cfr_static'><p>Estimate a static disease severity measure</p></a></li>
<li><a href='#cfr_time_varying'><p>Estimate a severity measure that varies over time</p></a></li>
<li><a href='#covid_data'><p>Daily Covid-19 case and death data for countries with 100,000 or more deaths</p></a></li>
<li><a href='#delay_density_helpers'><p>Check delay density functions passed to exported functions</p></a></li>
<li><a href='#ebola1976'><p>Ebola 1976 outbreak case data</p></a></li>
<li><a href='#estimate_ascertainment'><p>Estimate the ascertainment ratio of a disease</p></a></li>
<li><a href='#estimate_outcomes'><p>Estimate known outcomes of cases using a delay distribution</p></a></li>
<li><a href='#estimate_severity'><p>Estimate the corrected case fatality risk</p></a></li>
<li><a href='#prepare_data'><p>Prepare common epidemiological data formats for CFR estimation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimate Disease Severity and Case Ascertainment</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate the severity of a disease and ascertainment of cases, as discussed in Nishiura et al. (2009) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0006852">doi:10.1371/journal.pone.0006852</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/epiverse-trace/cfr">https://github.com/epiverse-trace/cfr</a>,
<a href="https://epiverse-trace.github.io/cfr/">https://epiverse-trace.github.io/cfr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/epiverse-trace/cfr/issues">https://github.com/epiverse-trace/cfr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, tidyr, purrr, scales, forcats, ggplot2, testthat (&ge;
3.0.0), knitr, bookdown, spelling, incidence2, data.table,
distributional, distcrete</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>epiverse-trace/epiversetheme</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-21 14:50:15 UTC; lshpg6</td>
</tr>
<tr>
<td>Author:</td>
<td>Pratik R. Gupte <a href="https://orcid.org/0000-0001-5294-7819"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Adam Kucharski <a href="https://orcid.org/0000-0001-8814-9421"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Tim Russell <a href="https://orcid.org/0000-0001-5610-6080"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Joshua W. Lambert <a href="https://orcid.org/0000-0001-5218-3046"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Hugo Gruson <a href="https://orcid.org/0000-0002-4094-1476"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  James M. Azam <a href="https://orcid.org/0000-0001-5782-7330"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Abdoelnaser M. Degoot
    <a href="https://orcid.org/0000-0001-8788-2496"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [rev],
  Sebastian Funk <a href="https://orcid.org/0000-0002-2842-3406"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pratik R. Gupte &lt;pratik.gupte@lshtm.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-21 18:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cfr_rolling'>Estimate static severity for an expanding time series</h2><span id='topic+cfr_rolling'></span>

<h3>Description</h3>

<p>Calculates the CFR at each time point in the case and death time
series supplied, using an expanding window of time. The static CFR is
calculated for each time point, using the time series from the start to each
time point, and increasing the number of time points included by one in each
iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfr_rolling(data, delay_density = NULL, poisson_threshold = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfr_rolling_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="cfr_rolling_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
<tr><td><code id="cfr_rolling_+3A_poisson_threshold">poisson_threshold</code></td>
<td>
<p>The case count above which to use Poisson
approximation. Set to 100 by default. Must be &gt; 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When delay correction is applied by passing a delay distribution
density function to <code>delay_density</code>, the internal function
<code><a href="#topic+estimate_severity">estimate_severity()</a></code> is used to calculate the rolling severity.
</p>
<p>Note that in the naive method the severity estimate and confidence intervals
cannot be calculated for days on which the cumulative number of cases since
the start of the time-series, and for days on which the cumulative number of
deaths reported exceeds the cumulative reported cases, and is returned as
<code>NA</code>.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the date, maximum likelihood estimate and 95%
confidence interval of the daily severity estimates, named
&quot;severity_mean&quot;, &quot;severity_low&quot;, and &quot;severity_high&quot;, with one row for each
day in the original data.frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load package data
data("ebola1976")

# estimate severity without correcting for delays
cfr_static(ebola1976)

# estimate severity for each day while correcting for delays
# obtain onset-to-death delay distribution parameters from Barry et al. 2018
# The Lancet. &lt;https://doi.org/10.1016/S0140-6736(18)31387-4&gt;
# view only the first values
estimate &lt;- cfr_rolling(
  ebola1976,
  delay_density = function(x) dgamma(x, shape = 2.40, scale = 3.33)
)

head(estimate)

</code></pre>

<hr>
<h2 id='cfr_static'>Estimate a static disease severity measure</h2><span id='topic+cfr_static'></span>

<h3>Description</h3>

<p>Calculates the severity of a disease, while optionally
correcting for reporting delays using an epidemiological delay distribution
of the time between symptom onset and death (onset-to-death).
</p>
<p>Other delay distributions may be passed to calculate different disease
severity measures such as the hospitalisation fatality risk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfr_static(data, delay_density = NULL, poisson_threshold = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfr_static_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="cfr_static_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
<tr><td><code id="cfr_static_+3A_poisson_threshold">poisson_threshold</code></td>
<td>
<p>The case count above which to use Poisson
approximation. Set to 100 by default. Must be &gt; 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the maximum likelihood estimate and 95%
confidence interval of the severity estimates, named &quot;severity_mean&quot;,
&quot;severity_low&quot;, and &quot;severity_high&quot;.
</p>


<h3>Details: Adjusting for delays between two time series</h3>

<p>The method used in <code>cfr_static()</code> follows Nishiura et al.
(2009).
The function calculates a quantity <code class="reqn">u_t</code> for each day within the input
data, which represents the proportion of cases estimated to have
a known outcome on day <code class="reqn">t</code>.
Following Nishiura et al., <code class="reqn">u_t</code> is calculated as:
</p>
<p style="text-align: center;"><code class="reqn">u_t = \dfrac{\sum_{i = 0}^t
        \sum_{j = 0}^\infty c_i f_{j - i}}{\sum_{i = 0} c_i}</code>
</p>

<p>where <code class="reqn">f_t</code> is the value of the probability mass function at time <code class="reqn">t</code>
and <code class="reqn">c_t</code>, <code class="reqn">d_t</code> are the number of new cases and new deaths at time
<code class="reqn">t</code>, (respectively).
We then use <code class="reqn">u_t</code> at the end of the outbreak in the following likelihood
function to estimate the severity of the disease in question.
</p>
<p style="text-align: center;"><code class="reqn">{\sf L}({\theta \mid y}) = \log{\dbinom{u_tC}{D}} + D \log{\theta} +
  (u_tC - D)\log{(1.0 - \theta)}</code>
</p>

<p><code class="reqn">C</code> and <code class="reqn">D</code> are the cumulative number of cases and deaths
(respectively) up until time <code class="reqn">t</code>.
<code class="reqn">\theta</code> is the parameter we wish to estimate, the severity of the
disease. We estimate <code class="reqn">\theta</code> using simple maximum-likelihood methods,
allowing the functions within this package to be quick and easy tools to use.
</p>
<p>The precise severity measure — CFR, IFR, HFR, etc — that <code class="reqn">\theta</code>
represents depends upon the input data given by the user.
</p>
<p>The epidemiological delay-distribution density function passed to
<code>delay_density</code> is used to evaluate the probability mass function
parameterised by time; i.e. <code class="reqn">f(t)</code> which
gives the probability that a case has a known outcome (usually death) at time
<code class="reqn">t</code>, parameterised with disease-specific parameters before it is supplied
here.
</p>


<h3>References</h3>

<p>Nishiura, H., Klinkenberg, D., Roberts, M., &amp; Heesterbeek, J. A. P. (2009).
Early Epidemiological Assessment of the Virulence of Emerging Infectious
Diseases: A Case Study of an Influenza Pandemic. PLOS ONE, 4(8), e6852.
<a href="https://doi.org/10.1371/journal.pone.0006852">doi:10.1371/journal.pone.0006852</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load package data
data("ebola1976")

# estimate severity without correcting for delays
cfr_static(ebola1976)

# estimate severity for each day while correcting for delays
# obtain onset-to-death delay distribution parameters from Barry et al. 2018
# The Lancet. &lt;https://doi.org/10.1016/S0140-6736(18)31387-4&gt;
cfr_static(
  ebola1976,
  delay_density = function(x) dgamma(x, shape = 2.40, scale = 3.33)
)

</code></pre>

<hr>
<h2 id='cfr_time_varying'>Estimate a severity measure that varies over time</h2><span id='topic+cfr_time_varying'></span>

<h3>Description</h3>

<p>Calculates how the severity of a disease changes over time
while optionally correcting for reporting delays using an epidemiological
delay distribution of the time between symptom onset and outcome
(e.g. onset-to-death for the fatality risk).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cfr_time_varying(
  data,
  delay_density = NULL,
  burn_in = 7,
  smoothing_window = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cfr_time_varying_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="cfr_time_varying_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
<tr><td><code id="cfr_time_varying_+3A_burn_in">burn_in</code></td>
<td>
<p>A single integer-like value for the number of time-points
(typically days) to disregard at the start of the time-series, if a burn-in
period is desired.
</p>
<p>Defaults to 7, which is a sensible default value that disregards the first
week of cases and deaths, assuming daily data.
</p>
<p>To consider all case data including the start of the time-series, set this
argument to 0.</p>
</td></tr>
<tr><td><code id="cfr_time_varying_+3A_smoothing_window">smoothing_window</code></td>
<td>
<p>An <em>odd</em> number determining the smoothing window size
to use when smoothing the case and death time-series, using a rolling median
procedure (as the <code>k</code> argument to <code><a href="stats.html#topic+runmed">stats::runmed()</a></code>) before calculating the
time-varying severity.
</p>
<p>The default behaviour is to apply no smoothing. The minimum value of this
argument is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the date, maximum likelihood estimate and 95%
confidence interval of the daily severity estimates, named
&quot;severity_mean&quot;, &quot;severity_low&quot;, and &quot;severity_high&quot;, with one row for each
day in the original data.frame.
</p>


<h3>Details: Adjusting for delays between two time series</h3>

<p>This function estimates the number of cases which have a known outcome over
time, following Nishiura et al. (2009).
The function calculates a quantity <code class="reqn">k_t</code> for each day within the input
data, which represents the number of cases estimated to have a known outcome,
on day <code class="reqn">t</code>. <code class="reqn">k_t</code> is calculated in the following way:
</p>
<p style="text-align: center;"><code class="reqn">k_t = \sum_{j = 0}^t c_t f_{j - t}</code>
</p>

<p>We then assume that the severity measure, for example CFR, of interest is
binomially distributed, in the following way:
</p>
<p style="text-align: center;"><code class="reqn">d_t \sim {\sf Binomial}(k_t, \theta_t)</code>
</p>

<p>We use maximum likelihood estimation to determine the value of <code class="reqn">\theta_t</code>
for each <code class="reqn">t</code>, where <code class="reqn">\theta</code> represents the severity measure of
interest.
</p>
<p>The epidemiological delay distribution passed to <code>epidist</code> is used to obtain
a probability mass function parameterised by time; i.e. <code class="reqn">f(t)</code> which
gives the probability a case has a known outcomes (usually, death) at time
<code class="reqn">t</code>, parameterised with disease-specific parameters before it is supplied
here.
</p>
<p><strong>Note</strong> that the function arguments <code>burn_in</code> and <code>smoothing_window</code> are not
explicitly used in this calculation. <code>burn_in</code> controls how many estimates at
the beginning of the outbreak are replaced with <code>NA</code>s &mdash; the calculation
above is not applied to the first <code>burn_in</code> data points.
The calculation is applied to the smoothed data, if a <code>smoothing_window</code>
is specified.
</p>


<h3>References</h3>

<p>Nishiura, H., Klinkenberg, D., Roberts, M., &amp; Heesterbeek, J. A. P. (2009).
Early Epidemiological Assessment of the Virulence of Emerging Infectious
Diseases: A Case Study of an Influenza Pandemic. PLOS ONE, 4(8), e6852.
<a href="https://doi.org/10.1371/journal.pone.0006852">doi:10.1371/journal.pone.0006852</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get data pre-loaded with the package
data("covid_data")
df_covid_uk &lt;- covid_data[covid_data$country == "United Kingdom", ]

# estimate time varying severity without correcting for delays
cfr_time_varying &lt;- cfr_time_varying(
  data = df_covid_uk,
  burn_in = 7L
)
# View
tail(cfr_time_varying)

# estimate time varying severity while correcting for delays
# obtain onset-to-death delay distribution parameters from Linton et al. 2020
# J. Clinical Medicine: &lt;https://doi.org/10.3390/jcm9020538&gt;
# view only the first values
cfr_time_varying &lt;- cfr_time_varying(
  data = df_covid_uk,
  delay_density = function(x) dlnorm(x, meanlog = 2.577, sdlog = 0.440),
  burn_in = 7L
)
tail(cfr_time_varying)

</code></pre>

<hr>
<h2 id='covid_data'>Daily Covid-19 case and death data for countries with 100,000 or more deaths</h2><span id='topic+covid_data'></span>

<h3>Description</h3>

<p>Data adapted from the {covidregionaldata} package of daily cases and
deaths from the 19 countries with 100,000 or more deaths over the period
2020-01-01 to 2022-12-31. See the <strong>References</strong> for the publication which
links to data sources made available through {covidregionaldata}.
Included as {covidregionaldata} is no longer on CRAN.
Data are provided as a <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covid_data
</code></pre>


<h3>Format</h3>



<h4><code>covid_data</code></h4>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with 20,786 rows and 4 columns:
</p>

<dl>
<dt>date</dt><dd><p>Calendar date in the format %Y-%m-%d</p>
</dd>
<dt>country</dt><dd><p>The country name in simple format, e.g. &quot;United States&quot;
rather than &quot;United States of America&quot;</p>
</dd>
<dt>cases</dt><dd><p>Number of cases reported on each date</p>
</dd>
<dt>deaths</dt><dd><p>Number of deaths reported on each date</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://doi.org/10.21105/joss.03290">doi:10.21105/joss.03290</a>.
</p>


<h3>References</h3>

<p>Joseph Palmer, Katharine Sherratt, Richard Martin-Nielsen, Jonnie Bevan,
Hamish Gibbs, Sebastian Funk and Sam Abbott (2021). covidregionaldata:
Subnational data for COVID-19 epidemiology. <a href="https://doi.org/10.21105/joss.03290">doi:10.21105/joss.03290</a>
</p>

<hr>
<h2 id='delay_density_helpers'>Check delay density functions passed to exported functions</h2><span id='topic+delay_density_helpers'></span><span id='topic+test_fn_req_args'></span><span id='topic+test_fn_num_out'></span>

<h3>Description</h3>

<p>Internal helper function that check whether a function passed to
the <code>delay_density</code> argument in <code style="white-space: pre;">&#8288;cfr_*()&#8288;</code> or <code><a href="#topic+estimate_outcomes">estimate_outcomes()</a></code> meet the
requirements of package methods.
</p>
<p><code>test_fn_req_args()</code> checks whether the function has only the expected number
of required arguments, i.e., arguments without default values. Defaults to
checking for a single required argument.
</p>
<p><code>test_fn_num_out()</code> checks whether the function returns a numeric output
consistent with evaluating the probability density or probability mass
function of a distribution over a sequence of values.
Expects that the function returns a numeric vector of finite values
<code class="reqn">\geq</code> 0.0, that no values are missing, and that the output vector
is the same length as the input vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_fn_req_args(fn, n_req_args = 1)

test_fn_num_out(fn, n = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delay_density_helpers_+3A_fn">fn</code></td>
<td>
<p>A function. This is expected to be a function evaluating the
density of a distribution at numeric values, and suitable to be passed to
<code>delay_density</code> in <code style="white-space: pre;">&#8288;cfr_*()&#8288;</code>.</p>
</td></tr>
<tr><td><code id="delay_density_helpers_+3A_n_req_args">n_req_args</code></td>
<td>
<p>The number of required arguments, i.e., arguments without
default values.</p>
</td></tr>
<tr><td><code id="delay_density_helpers_+3A_n">n</code></td>
<td>
<p>The number of elements over which to evaluate the function <code>fn</code>.
Defaults to 10, and <code>fn</code> is evaluated over <code>seq(n)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical for whether the function <code>fn</code> fulfils conditions specified
in the respective checks.
</p>

<hr>
<h2 id='ebola1976'>Ebola 1976 outbreak case data</h2><span id='topic+ebola1976'></span>

<h3>Description</h3>

<p>An example epidemic outbreak dataset for use with the <code>cfr</code> package.
This dataset comes from the first Ebola outbreak in Zaire in 1976 as analysed
in Camacho et al. (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ebola1976
</code></pre>


<h3>Format</h3>



<h4><code>ebola1976</code></h4>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with 73 rows and 3 columns:
</p>

<dl>
<dt>date</dt><dd><p>Calendar date</p>
</dd>
<dt>cases</dt><dd><p>Number of cases reported</p>
</dd>
<dt>deaths</dt><dd><p>Number of deaths reported</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.epidem.2014.09.003">doi:10.1016/j.epidem.2014.09.003</a>
</p>


<h3>References</h3>

<p>Camacho, A., Kucharski, A. J., Funk, S., Breman, J., Piot, P., &amp;
Edmunds, W. J. (2014). Potential for large outbreaks of Ebola virus disease.
Epidemics, 9, 70–78. <a href="https://doi.org/10.1016/j.epidem.2014.09.003">doi:10.1016/j.epidem.2014.09.003</a>
</p>

<hr>
<h2 id='estimate_ascertainment'>Estimate the ascertainment ratio of a disease</h2><span id='topic+estimate_ascertainment'></span>

<h3>Description</h3>

<p>Estimates the proportion of cases or infections that have been
ascertained, given a time-series of cases and deaths, a delay distribution
and a baseline severity estimate. The resulting ascertainment estimate is
calculated as the ratio of the baseline severity estimate, which is assumed
to be the 'true' disease severity, and the delay-adjusted severity estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_ascertainment(data, severity_baseline, delay_density = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_ascertainment_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="estimate_ascertainment_+3A_severity_baseline">severity_baseline</code></td>
<td>
<p>A single number in the range 0.0 &ndash; 1.0 for the
assumed true baseline severity estimate used to estimate the overall
ascertainment ratio. Missing by default, which causes the function to error;
must be supplied by the user.</p>
</td></tr>
<tr><td><code id="estimate_ascertainment_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the maximum likelihood estimate estimate
and 95% confidence interval of the corrected severity, named
&quot;ascertainment_mean&quot; (for the central estimate), and &quot;ascertainment_low&quot; and
&quot;ascertainment_high&quot; for the lower and upper interval limits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get data pre-loaded with the package
data("covid_data")
df_covid_uk &lt;- covid_data[covid_data$country == "United Kingdom", ]

df_covid_uk_subset &lt;- subset(df_covid_uk, date &lt;= "2020-05-31")

# use a severity baseline of 1.4% (0.014) taken from Verity et al. (2020)
# Lancet Infectious Diseases: &lt;https://doi.org/10.1016/S1473-3099(20)30243-7&gt;

# use onset-to-death distribution from Linton et al. (2020)
# J. Clinical Medicine: &lt;https://doi.org/10.3390/jcm9020538&gt;

# subset data until 30th June 2020
data &lt;- df_covid_uk[df_covid_uk$date &lt;= "2020-06-30", ]
estimate_ascertainment(
  data = data,
  delay_density = function(x) dlnorm(x, meanlog = 2.577, sdlog = 0.440),
  severity_baseline = 0.014
)

</code></pre>

<hr>
<h2 id='estimate_outcomes'>Estimate known outcomes of cases using a delay distribution</h2><span id='topic+estimate_outcomes'></span>

<h3>Description</h3>

<p>Estimates the expected number of individuals with known outcomes
from a case and outcome time series of outbreak data, and an epidemiological
delay distribution of symptom onset to outcome.
When calculating a case fatality risk, the outcomes must be deaths, the delay
distribution must be an onset-to-death distribution, and the function returns
estimates of the known death outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_outcomes(data, delay_density)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_outcomes_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> containing the outbreak data. A daily time
series with dates or some other absolute indicator of time (e.g. epiday or
epiweek) and the numbers of new cases and new deaths at each time point.
Note that the required columns are &quot;date&quot; (for the date), &quot;cases&quot; (for the
number of reported cases), and &quot;deaths&quot; (for the number of reported deaths)
on each day of the outbreak.
</p>
<p>Note that the <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> is required to have an unbroken sequence of
dates with no missing dates in between. The &quot;date&quot; column must be of class
<code>Date</code> (see <code><a href="base.html#topic+as.Date">as.Date()</a></code>).
</p>
<p>Note also that the total number of cases must be greater than the total
number of reported deaths.</p>
</td></tr>
<tr><td><code id="estimate_outcomes_+3A_delay_density">delay_density</code></td>
<td>
<p>An optional argument that controls whether delay
correction is applied in the severity estimation.
May be <code>NULL</code>, for no delay correction, or a function that returns the
density function of a distribution to evaluate
density at user-specified values, e.g.
<code>function(x) stats::dgamma(x = x, shape = 5, scale = 1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with the columns in <code>data</code>, and with two additional
columns:
</p>

<ul>
<li> <p><code>"estimated_outcomes"</code> for the number of cases with an outcome of interest
(usually, death) estimated to be known on the dates specified in <code>data</code>, and
</p>
</li>
<li> <p><code>"u_t"</code> for the ratio of cumulative number of estimated known outcomes
and the cumulative number of cases reported until each date specified in
<code>data</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load Ebola 1976 outbreak data
data("ebola1976")

# estimate severity for each day while correcting for delays
# obtain onset-to-death delay distribution parameters from Barry et al. 2018
# examine the first few rows of the output
estimated_outcomes &lt;- estimate_outcomes(
  data = ebola1976,
  delay_density = function(x) dgamma(x, shape = 2.40, scale = 3.33)
)

head(estimated_outcomes)
</code></pre>

<hr>
<h2 id='estimate_severity'>Estimate the corrected case fatality risk</h2><span id='topic+estimate_severity'></span>

<h3>Description</h3>

<p>Estimates the maximum likelihood estimate and 95% confidence
interval of a corrected severity, using the total cases and total cases with
known outcomes, where the latter replaces the total number of deaths in the
standard (naive) severity definition. We use a binomial likelihood,
approximated by a Poisson likelihood for large samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_severity(
  total_cases,
  total_deaths,
  total_outcomes,
  poisson_threshold = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_severity_+3A_total_cases">total_cases</code></td>
<td>
<p>The total number of cases observed over the period of an
outbreak of interest. The total number of cases must be greater than or equal
to the total number of deaths.</p>
</td></tr>
<tr><td><code id="estimate_severity_+3A_total_deaths">total_deaths</code></td>
<td>
<p>The total number of deaths observed over the period of an
outbreak of interest. The total number of deaths must be less than or equal
to the total number of cases.</p>
</td></tr>
<tr><td><code id="estimate_severity_+3A_total_outcomes">total_outcomes</code></td>
<td>
<p>The total number of outcomes expected to be observed
over the period of an outbreak of interest. See <code><a href="#topic+estimate_outcomes">estimate_outcomes()</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_severity_+3A_poisson_threshold">poisson_threshold</code></td>
<td>
<p>The case count above which to use Poisson
approximation. Set to 100 by default. Must be &gt; 0.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Special cases</h4>


<ul>
<li><p> When any two of <code>total_cases</code>, <code>total_deaths</code>, or <code>total_outcomes</code> are 0,
the estimate and confidence intervals cannot be calculated and the output
<code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> contains only <code>NA</code>s.
</p>
</li>
<li><p> When <code>total_cases == total_deaths</code> <em>and</em> <code>total_outcomes &lt;= total_deaths</code>,
while <code>total_cases &lt; poisson_threshold</code>, the confidence intervals cannot be
calculated and are returned as <code>NA</code>. The severity is returned as the lowest
possible value for the method used when cases are below the Poisson
threshold, which is 0.001.
</p>
</li>
<li><p> When <code>total_outcomes == total_deaths</code> while
<code>total_cases &lt; poisson_threshold</code> the confidence intervals cannot be
calculated and are returned as <code>NA</code>s while the severity estimate is returned
as <code>0.999</code>.
</p>
</li></ul>




<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> with one row and three columns for the maximum
likelihood estimate and 95% confidence interval of the corrected severity
estimates, named &quot;severity_mean&quot;, &quot;severity_low&quot;, and &quot;severity_high&quot;.
</p>

<hr>
<h2 id='prepare_data'>Prepare common epidemiological data formats for CFR estimation</h2><span id='topic+prepare_data'></span><span id='topic+prepare_data.incidence2'></span>

<h3>Description</h3>

<p>This S3 generic has methods for classes commonly used for epidemiological
data.
</p>
<p>Currently, the only supported data format is <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> from the
<span class="pkg">incidence2</span> package. See <code><a href="incidence2.html#topic+incidence">incidence2::incidence()</a></code>. Grouped
<code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> data are supported, see <strong>Details</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(data, ...)

## S3 method for class 'incidence2'
prepare_data(
  data,
  cases_variable = "cases",
  deaths_variable = "deaths",
  fill_NA = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_data_+3A_data">data</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code>-like object. Currently, only <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code>
objects are supported. These may be grouped.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_...">...</code></td>
<td>
<p>Currently unused. Passing extra arguments will throw a warning.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_cases_variable">cases_variable</code></td>
<td>
<p>A string for the name of the cases variable in the
&quot;count_variable&quot; column of <code>data</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_deaths_variable">deaths_variable</code></td>
<td>
<p>A string for the name of the deaths variable in the
&quot;count_variable&quot; column of <code>data</code>.</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_fill_na">fill_NA</code></td>
<td>
<p>A logical indicating whether <code>NA</code>s in the cases and deaths
data should be replaced by 0s. The default value is <code>TRUE</code>, with a message
to make users aware of the replacement.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> data can replace <code>NA</code>s in the case and death
data with 0s using the <code>fill_NA</code> argument, which is <code>TRUE</code> by default,
meaning that <code>NA</code>s are replaced.
</p>
<p>Keeping <code>NA</code>s will cause downstream issues when calling functions such as
<code><a href="#topic+cfr_static">cfr_static()</a></code> on the data, as they cannot handle <code>NA</code>s.
Setting <code>fill_NA = TRUE</code> resolves this issue.
</p>
<p>Passing a grouped <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> object to <code>data</code> will result in the function
respecting the grouping and returning grouping variables in separate columns.
</p>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;&lt;data.frame&gt;&#8288;</code> suitable for disease severity estimation functions
provided in <span class="pkg">cfr</span>, with the columns &quot;date&quot;, &quot;cases&quot;, and &quot;deaths&quot;.
</p>
<p>Additionally, for grouped <code style="white-space: pre;">&#8288;&lt;incidence2&gt;&#8288;</code> data, columns representing the
grouping variables will also be present.
</p>
<p>The result has a continuous sequence of dates between the start and end date
of <code>data</code>; this is required if the data is to be passed to functions such as
<code><a href="#topic+cfr_static">cfr_static()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### For &lt;incidence2&gt; data ####
# load Covid-19 data from incidence2
covid_uk &lt;- incidence2::covidregionaldataUK

# convert to incidence2 object
covid_uk_incidence &lt;- incidence2::incidence(
  covid_uk,
  date_index = "date",
  counts = c("cases_new", "deaths_new"),
  count_names_to = "count_variable"
)

# View tail of prepared data
data &lt;- prepare_data(
  covid_uk_incidence,
  cases_variable = "cases_new",
  deaths_variable = "deaths_new"
)

tail(data)

#### For grouped &lt;incidence2&gt; data ####
# convert data to incidence2 object grouped by region
covid_uk_incidence &lt;- incidence2::incidence(
  covid_uk,
  date_index = "date",
  counts = c("cases_new", "deaths_new"),
  count_names_to = "count_variable",
  groups = "region"
)

# View tail of prepared data
data &lt;- prepare_data(
  covid_uk_incidence,
  cases_variable = "cases_new",
  deaths_variable = "deaths_new"
)

tail(data)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
