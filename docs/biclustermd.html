<!DOCTYPE html><html><head><title>Help for package biclustermd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {biclustermd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biclustermd-package'><p>biclustermd: A package to bicluster data with missing values</p></a></li>
<li><a href='#as.Biclust'><p>Convert a <code>biclustermd</code> object to a <code>Biclust</code> object</p></a></li>
<li><a href='#autoplot.biclustermd'><p>Make a heatmap of sparse biclustering results</p></a></li>
<li><a href='#autoplot.biclustermd_sim'><p>Plot similarity measures between two consecutive biclusterings.</p></a></li>
<li><a href='#autoplot.biclustermd_sse'><p>Plot sums of squared errors (SSEs) consecutive biclustering iterations.</p></a></li>
<li><a href='#biclustermd'><p>Bicluster data with non-random missing values</p></a></li>
<li><a href='#binary_vector_gen'><p>Make a binary vector with all values equal to zero except for one</p></a></li>
<li><a href='#cell_heatmap'><p>Make a heat map of bicluster cell sizes.</p></a></li>
<li><a href='#cell_mse'><p>Make a data frame containing the MSE for each bicluster cell</p></a></li>
<li><a href='#cluster_iteration_sum_sse'><p>Calculate the sum cluster SSE in each iteration</p></a></li>
<li><a href='#col_cluster_names'><p>Get column names in each column cluster</p></a></li>
<li><a href='#col.names'><p>A generic to gather column names</p></a></li>
<li><a href='#col.names.biclustermd'><p>Get data matrix column names and their corresponding column cluster membership</p></a></li>
<li><a href='#compare_biclusters'><p>Compare two biclusterings or a pair of partition matrices</p></a></li>
<li><a href='#fill_empties_P'><p>Randomly select a column prototype to fill an empty column prototype with</p></a></li>
<li><a href='#fill_empties_Q'><p>Randomly select a row prototype to fill an empty row prototype with</p></a></li>
<li><a href='#format_partition'><p>Format a partition matrix</p></a></li>
<li><a href='#gather.biclustermd'><p>Gather a biclustermd object</p></a></li>
<li><a href='#jaccard_similarity'><p>Compute the Jaccard similarity coefficient for two clusterings</p></a></li>
<li><a href='#mse_heatmap'><p>Make a heatmap of cell MSEs</p></a></li>
<li><a href='#part_matrix_to_vector'><p>Convert a partition matrix to a vector</p></a></li>
<li><a href='#partition_gen'><p>Generate an intial, random partition matrix with N objects into K subsets/groups.</p></a></li>
<li><a href='#partition_gen_by_p'><p>Create a partition matrix with a partition vector p</p></a></li>
<li><a href='#position_finder'><p>Find the index of the first nonzero value in a vector</p></a></li>
<li><a href='#print.biclustermd'><p>Print an object of class biclustermd</p></a></li>
<li><a href='#reorder_biclust'><p>Reorder a bicluster object for making a heat map</p></a></li>
<li><a href='#rep_biclustermd'><p>Repeat a biclustering to achieve a minimum SSE solution</p></a></li>
<li><a href='#results_heatmap'><p>Make a heatmap of sparse biclustering results</p></a></li>
<li><a href='#row_cluster_names'><p>Get row names in each row cluster</p></a></li>
<li><a href='#row.names.biclustermd'><p>Get data matrix row names and their corresponding row cluster membership</p></a></li>
<li><a href='#runtimes'><p>Algorithm run time data</p></a></li>
<li><a href='#synthetic'><p>Synthetic data for examples.</p></a></li>
<li><a href='#tune_biclustermd'><p>Bicluster data over a grid of tuning parameters</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Biclustering with Missing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Reisner &lt;johntreisner@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Biclustering is a statistical learning technique that simultaneously 
    partitions and clusters rows and columns of a data matrix. Since the solution 
    space of biclustering is in infeasible to completely search with current 
    computational mechanisms, this package uses a greedy heuristic. The algorithm 
    featured in this package is, to the best our knowledge, the first biclustering 
    algorithm to work on data with missing values. Li, J., Reisner, J., Pham, H., 
    Olafsson, S., and Vardeman, S. (2020) Biclustering with Missing Data. Information 
    Sciences, 510, 304â€“316.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jreisner/biclustermd">https://github.com/jreisner/biclustermd</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jreisner/biclustermd/issues">https://github.com/jreisner/biclustermd/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>ggplot2 (&ge; 3.0.0), R (&ge; 3.5.0), tidyr (&ge; 0.8.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>biclust (&ge; 2.0.1), doParallel (&ge; 1.0.14), dplyr (&ge; 0.7.6),
foreach (&ge; 1.4.4), magrittr (&ge; 1.5), nycflights13 (&ge; 1.0.0),
phyclust (&ge; 0.1-24)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-17 14:40:03 UTC; johnreisner</td>
</tr>
<tr>
<td>Author:</td>
<td>John Reisner [cre, aut, cph],
  Hieu Pham [ctb, cph],
  Jing Li [ctb, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-17 15:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='biclustermd-package'>biclustermd: A package to bicluster data with missing values</h2><span id='topic+biclustermd-package'></span>

<h3>Description</h3>

<p>The main function is <code>biclustermd()</code>. Results can be plotted with <code>autoplot()</code>
and <code>as.Biclust()</code> converts results to Biclust objects.
</p>

<hr>
<h2 id='as.Biclust'>Convert a <code>biclustermd</code> object to a <code>Biclust</code> object</h2><span id='topic+as.Biclust'></span>

<h3>Description</h3>

<p>Convert a <code>biclustermd</code> object to a <code>Biclust</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.Biclust(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.Biclust_+3A_object">object</code></td>
<td>
<p>The <code>biclustermd</code> object to convert to a <code>Biclust</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Biclust</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")

bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
bc

as.Biclust(bc)

# biclust::drawHeatmap won't work since it doesn't exclude NAs
## Not run: biclust::drawHeatmap(synthetic, as.Biclust(bc), 6)

# bicluster 6 is in the top right-hand corner here:
autoplot(bc)
# compare with bicust::drawHeatmap2:
biclust::drawHeatmap2(synthetic, as.Biclust(bc), 6)

# bicluster 3 is in the bottom right-hand corner here:
autoplot(bc)
# compare with bicust::drawHeatmap2:
biclust::drawHeatmap2(synthetic, as.Biclust(bc), 3)
</code></pre>

<hr>
<h2 id='autoplot.biclustermd'>Make a heatmap of sparse biclustering results</h2><span id='topic+autoplot.biclustermd'></span>

<h3>Description</h3>

<p>Make a heatmap of sparse biclustering results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biclustermd'
autoplot(
  object,
  axis.text = NULL,
  reorder = FALSE,
  transform_colors = FALSE,
  c = 1/6,
  cell_alpha = 1/5,
  col_clusts = NULL,
  row_clusts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.biclustermd_+3A_object">object</code></td>
<td>
<p>An object of class &quot;biclustermd&quot;.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_axis.text">axis.text</code></td>
<td>
<p>A character vector specifying for which axes text should be
drawn. Can be any of <code>"x"</code>, <code>"col"</code> for columns, <code>"y"</code>, <code>"row"</code> for rows,
or any combination of the four. By default this is <code>NULL</code>; no axis text
is drawn.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_reorder">reorder</code></td>
<td>
<p>A logical. If <code>TRUE</code>, heatmap will be sorted according to the cell-average matrix, <code>A</code>.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_transform_colors">transform_colors</code></td>
<td>
<p>If equals <code>TRUE</code> then the data is scaled by
<code>c</code> and run through a standard normal cdf before plotting. If <code>FALSE</code> (default), raw data
values are used in the heat map.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_c">c</code></td>
<td>
<p>Value to scale the data by before running it through a standard normal CDF.
Default is 1/6.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_cell_alpha">cell_alpha</code></td>
<td>
<p>A scalar defining the transparency of shading over a cell and by default this equals 1/5.
The color corresponds to the cell mean.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_col_clusts">col_clusts</code></td>
<td>
<p>A vector of column cluster indices to display. If <code>NULL</code> (default), all are displayed.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_row_clusts">row_clusts</code></td>
<td>
<p>A vector of row cluster indices to display. If <code>NULL</code> (default), all are displayed.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>geom_vline()</code> and <code>geom_hline()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")

bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
bc
autoplot(bc)

autoplot(bc, axis.text = c('x', 'row')) +
    ggplot2::scale_fill_distiller(palette = "Spectral", na.value = "white")

# Complete shading
autoplot(bc, axis.text = c('col', 'row'), cell_alpha = 1)

# Transformed values and no shading
autoplot(bc, transform_colors = TRUE, c = 1/20, cell_alpha = 0)

# Focus on row cluster 1 and column cluster 2
autoplot(bc, col_clusts = 2, row_clusts = 1)

</code></pre>

<hr>
<h2 id='autoplot.biclustermd_sim'>Plot similarity measures between two consecutive biclusterings.</h2><span id='topic+autoplot.biclustermd_sim'></span>

<h3>Description</h3>

<p>Creates a ggplot of the three similarity measures used in <code>biclustermd::bicluster()</code>
for both row and column dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biclustermd_sim'
autoplot(object, similarity = NULL, facet = TRUE, ncol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.biclustermd_sim_+3A_object">object</code></td>
<td>
<p>Object of class &quot;biclustermd_sim&quot;</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_sim_+3A_similarity">similarity</code></td>
<td>
<p>A character vector indicating which similarity measure to plot.
Can be any of <code>"Rand"</code>, <code>"HA"</code>, <code>"Jaccard"</code>, or <code>"used"</code>. If <code>"used"</code>,
plot only the measure used as the stopping condition in the algorithm).
By default (<code>NULL</code>) all three are plotted. When plotted, the used measure
will have an asterisk.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_sim_+3A_facet">facet</code></td>
<td>
<p>If <code>TRUE</code> (default), each similarity measure will be in its own plot.
if <code>FALSE</code>, all three similarity measures for rows and columns are
given in one plot.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_sim_+3A_ncol">ncol</code></td>
<td>
<p>If faceting, the number of columns to arrange the plots in.</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_sim_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>ggplot2::geom_point()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")

bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
bc
autoplot(bc$Similarities, ncol = 1)
</code></pre>

<hr>
<h2 id='autoplot.biclustermd_sse'>Plot sums of squared errors (SSEs) consecutive biclustering iterations.</h2><span id='topic+autoplot.biclustermd_sse'></span>

<h3>Description</h3>

<p>Creates a ggplot of the decrease in SSE recorded in <code>biclustermd::bicluster()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biclustermd_sse'
autoplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.biclustermd_sse_+3A_object">object</code></td>
<td>
<p>Object of class &quot;biclustermd_sse&quot; with columns &quot;Iteration&quot; and &quot;SSE&quot;</p>
</td></tr>
<tr><td><code id="autoplot.biclustermd_sse_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>ggplot2::geom_point()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")

bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
bc
autoplot(bc$SSE)
</code></pre>

<hr>
<h2 id='biclustermd'>Bicluster data with non-random missing values</h2><span id='topic+biclustermd'></span>

<h3>Description</h3>

<p>Bicluster data with non-random missing values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biclustermd(
  data,
  row_clusters = floor(sqrt(nrow(data))),
  col_clusters = floor(sqrt(ncol(data))),
  miss_val = mean(data, na.rm = TRUE),
  miss_val_sd = 1,
  similarity = "Rand",
  row_min_num = floor(nrow(data)/row_clusters),
  col_min_num = floor(ncol(data)/col_clusters),
  row_num_to_move = 1,
  col_num_to_move = 1,
  row_shuffles = 1,
  col_shuffles = 1,
  max.iter = 100,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biclustermd_+3A_data">data</code></td>
<td>
<p>Dataset to bicluster. Must to be a data matrix with only numbers
and missing values in the data set. It should have row names and column names.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_row_clusters">row_clusters</code></td>
<td>
<p>The number of clusters to partition the rows into. The
default is <code>floor(sqrt(nrow(data)))</code>.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_col_clusters">col_clusters</code></td>
<td>
<p>The number of clusters to partition the columns into. The
default is <code>floor(sqrt(ncol(data)))</code>.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_miss_val">miss_val</code></td>
<td>
<p>Value or function to put in empty cells of the prototype matrix.
If a value, a random normal variable with sd = <code>miss_val_sd</code> is used each
iteration. By default, this equals the mean of <code>data</code>.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_miss_val_sd">miss_val_sd</code></td>
<td>
<p>Standard deviation of the normal distribution <code>miss_val</code> follows
if <code>miss_val</code> is a number. By default this equals 1.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_similarity">similarity</code></td>
<td>
<p>The metric used to compare two successive clusterings. Can be
&quot;Rand&quot; (default), &quot;HA&quot; for the Hubert and Arabie adjusted Rand index or &quot;Jaccard&quot;.
See <a href="phyclust.html#topic+RRand">RRand</a> for details.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_row_min_num">row_min_num</code></td>
<td>
<p>Minimum row prototype size in order to be eligible to be
chosen when filling an empty row prototype. Default is <code>floor(nrow(data) / row_clusters)</code>.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_col_min_num">col_min_num</code></td>
<td>
<p>Minimum column prototype size in order to be eligible to be
chosen when filling an empty row prototype. Default is <code>floor(ncol(data) / col_clusters)</code>.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_row_num_to_move">row_num_to_move</code></td>
<td>
<p>Number of rows to remove from the sampled prototype to
put in the empty row prototype. Default is 1.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_col_num_to_move">col_num_to_move</code></td>
<td>
<p>Number of columns to remove from the sampled prototype to
put in the empty column prototype. Default is 1.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_row_shuffles">row_shuffles</code></td>
<td>
<p>Number of times to shuffle rows in each iteration. Default is 1.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_col_shuffles">col_shuffles</code></td>
<td>
<p>Number of times to shuffle columns in each iteration. Default is 1.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations to let the algorithm run for.</p>
</td></tr>
<tr><td><code id="biclustermd_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If TRUE, will report progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>biclustermd</code>:
</p>
<table>
<tr><td><code>params</code></td>
<td>
<p>a list of all arguments passed to the function, including defaults.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the inputted two way table of data.</p>
</td></tr>
<tr><td><code>P0</code></td>
<td>
<p>the initial column partition matrix.</p>
</td></tr>
<tr><td><code>Q0</code></td>
<td>
<p>the initial row partition matrix.</p>
</td></tr>
<tr><td><code>InitialSSE</code></td>
<td>
<p>the SSE of the original partitioning.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>the final column partition matrix.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the final row partition matrix.</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>a matrix of class biclustermd_sse detailing the SSE recorded at the end of each iteration.</p>
</td></tr>
<tr><td><code>Similarities</code></td>
<td>
<p>a data frame of class biclustermd_sim detailing the
value of row and column similarity measures recorded at the end of each
iteration. Contains information for all three similarity measures.
This carries an attribute <code>"used"</code> which provides the similarity
measure used as the stopping condition for the algorithm.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>the number of iterations the algorithm ran for, whether <code>max.iter</code> was reached or convergence was achieved.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>the final prototype matrix which gives the average of each bicluster.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Li, J., Reisner, J., Pham, H., Olafsson, S., and Vardeman, S. (2020) <em>Biclustering with Missing Data. Information Sciences, 510, 304â€“316.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rep_biclustermd">rep_biclustermd</a></code>, <code><a href="#topic+tune_biclustermd">tune_biclustermd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
# default parameters
bc &lt;- biclustermd(synthetic)
bc
autoplot(bc)

# providing the true number of row and column clusters
bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2)
bc
autoplot(bc)

# an example with the nycflights13::flights dataset
library(nycflights13)
data("flights")

library(dplyr)
flights_bcd &lt;- flights %&gt;%
  select(month, dest, arr_delay)

flights_bcd &lt;- flights_bcd %&gt;%
  group_by(month, dest) %&gt;%
  summarise(mean_arr_delay = mean(arr_delay, na.rm = TRUE)) %&gt;%
  spread(dest, mean_arr_delay) %&gt;%
  as.data.frame()

rownames(flights_bcd) &lt;- flights_bcd$month
flights_bcd &lt;- as.matrix(flights_bcd[, -1])

flights_bc &lt;- biclustermd(data = flights_bcd, col_clusters = 6, row_clusters = 4,
                  row_min_num = 3, col_min_num = 5,
                  max.iter = 20, verbose = TRUE)
flights_bc

</code></pre>

<hr>
<h2 id='binary_vector_gen'>Make a binary vector with all values equal to zero except for one</h2><span id='topic+binary_vector_gen'></span>

<h3>Description</h3>

<p>Make a binary vector with all values equal to zero except for one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary_vector_gen(n, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_vector_gen_+3A_n">n</code></td>
<td>
<p>Desired vector length.</p>
</td></tr>
<tr><td><code id="binary_vector_gen_+3A_i">i</code></td>
<td>
<p>Index whose value is one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector
</p>

<hr>
<h2 id='cell_heatmap'>Make a heat map of bicluster cell sizes.</h2><span id='topic+cell_heatmap'></span>

<h3>Description</h3>

<p>Make a heat map of bicluster cell sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_heatmap(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_heatmap_+3A_x">x</code></td>
<td>
<p>An object of class <code>biclustermd</code>.</p>
</td></tr>
<tr><td><code id="cell_heatmap_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>geom_tile()</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")

bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)

cell_heatmap(bc)

cell_heatmap(bc) + ggplot2::scale_fill_viridis_c()
</code></pre>

<hr>
<h2 id='cell_mse'>Make a data frame containing the MSE for each bicluster cell</h2><span id='topic+cell_mse'></span>

<h3>Description</h3>

<p>Make a data frame containing the MSE for each bicluster cell
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_mse(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_mse_+3A_x">x</code></td>
<td>
<p>An object of class <code>biclustermd</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame giving the row cluster, column cluster, the number of
data points in each row and column cluster, the number of data points missing
in the cell, and the cell MSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
cell_mse(bc)
</code></pre>

<hr>
<h2 id='cluster_iteration_sum_sse'>Calculate the sum cluster SSE in each iteration</h2><span id='topic+cluster_iteration_sum_sse'></span>

<h3>Description</h3>

<p>Calculate the sum cluster SSE in each iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_iteration_sum_sse(data, P, Q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_iteration_sum_sse_+3A_data">data</code></td>
<td>
<p>The data being biclustered. Must to be a data matrix with only numbers and missing values in the data set. It should have row names and column names.</p>
</td></tr>
<tr><td><code id="cluster_iteration_sum_sse_+3A_p">P</code></td>
<td>
<p>Matrix for column prototypes.</p>
</td></tr>
<tr><td><code id="cluster_iteration_sum_sse_+3A_q">Q</code></td>
<td>
<p>Matrix for row prototypes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The SSE for the parameters specified.
</p>

<hr>
<h2 id='col_cluster_names'>Get column names in each column cluster</h2><span id='topic+col_cluster_names'></span>

<h3>Description</h3>

<p>Get column names in each column cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col_cluster_names(x, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col_cluster_names_+3A_x">x</code></td>
<td>
<p>Biclustering object to extract column cluster designation from</p>
</td></tr>
<tr><td><code id="col_cluster_names_+3A_data">data</code></td>
<td>
<p>Data that contains the column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: <code>cluster</code> corresponds to the column
cluster and <code>name</code> gives the column names in each cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
rownames(synthetic) &lt;- letters[1:nrow(synthetic)]
colnames(synthetic) &lt;- letters[1:ncol(synthetic)]
bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
bc
</code></pre>

<hr>
<h2 id='col.names'>A generic to gather column names</h2><span id='topic+col.names'></span>

<h3>Description</h3>

<p>A generic to gather column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col.names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col.names_+3A_x">x</code></td>
<td>
<p>an object to retrieve column names from</p>
</td></tr>
</table>

<hr>
<h2 id='col.names.biclustermd'>Get data matrix column names and their corresponding column cluster membership</h2><span id='topic+col.names.biclustermd'></span>

<h3>Description</h3>

<p>Get data matrix column names and their corresponding column cluster membership
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biclustermd'
col.names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="col.names.biclustermd_+3A_x">x</code></td>
<td>
<p>and object of class <code>biclustermd</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with column names of the shuffled matrix and corresponding column cluster names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
# default parameters
bc &lt;- biclustermd(synthetic)
bc
col.names(bc)
# this is a simplified version of the output for gather(bc):
library(dplyr)
gather(bc) %&gt;% distinct(col_cluster, col_name)
</code></pre>

<hr>
<h2 id='compare_biclusters'>Compare two biclusterings or a pair of partition matrices</h2><span id='topic+compare_biclusters'></span>

<h3>Description</h3>

<p>Compare two biclusterings or a pair of partition matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_biclusters(bc1, bc2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_biclusters_+3A_bc1">bc1</code></td>
<td>
<p>the first biclustering or partition matrix. Must be either of class
<code>biclustermd</code> or <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="compare_biclusters_+3A_bc2">bc2</code></td>
<td>
<p>the second biclustering or partition matrix. Must be either of class
<code>biclustermd</code> or <code>matrix</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If comparing a pair of biclusterings, a list containing the column
similarity indices and the row similarity indices, in that order. If a pair of matrices,
a vector of similarity indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2)
bc2 &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2)

# compare the two biclusterings
compare_biclusters(bc, bc2)

# determine the similarity between initial and final row clusterings
compare_biclusters(bc$Q0, bc$Q)

</code></pre>

<hr>
<h2 id='fill_empties_P'>Randomly select a column prototype to fill an empty column prototype with</h2><span id='topic+fill_empties_P'></span>

<h3>Description</h3>

<p>Randomly select a column prototype to fill an empty column prototype with
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_empties_P(data, obj, col_min_num = 10, col_num_to_move = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_empties_P_+3A_data">data</code></td>
<td>
<p>The data being biclustered. Must to be a data matrix with only numbers and missing values in the data set. It should have row names and column names.</p>
</td></tr>
<tr><td><code id="fill_empties_P_+3A_obj">obj</code></td>
<td>
<p>A matrix for column clusters, typically named P.</p>
</td></tr>
<tr><td><code id="fill_empties_P_+3A_col_min_num">col_min_num</code></td>
<td>
<p>Minimum column prototype size in order to be eligible to be chosen when filling an empty column prototype. Default is 10.</p>
</td></tr>
<tr><td><code id="fill_empties_P_+3A_col_num_to_move">col_num_to_move</code></td>
<td>
<p>Number of columns to remove from the sampled prototype to put in the empty column prototype. Default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix for column clusters, i.e., a P matrix.
</p>

<hr>
<h2 id='fill_empties_Q'>Randomly select a row prototype to fill an empty row prototype with</h2><span id='topic+fill_empties_Q'></span>

<h3>Description</h3>

<p>Randomly select a row prototype to fill an empty row prototype with
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_empties_Q(data, obj, row_min_num = 10, row_num_to_move = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_empties_Q_+3A_data">data</code></td>
<td>
<p>The data being biclustered. Must to be a data matrix with only numbers and missing values in the data set. It should have row names and column names.</p>
</td></tr>
<tr><td><code id="fill_empties_Q_+3A_obj">obj</code></td>
<td>
<p>A matrix for row clusters, typically named Q</p>
</td></tr>
<tr><td><code id="fill_empties_Q_+3A_row_min_num">row_min_num</code></td>
<td>
<p>Minimum row prototype size in order to be eligible to be chosen when filling an empty row prototype. Default is 10.</p>
</td></tr>
<tr><td><code id="fill_empties_Q_+3A_row_num_to_move">row_num_to_move</code></td>
<td>
<p>Number of rows to remove from the sampled prototype to put in the empty row prototype. Default is 5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix for row clusters, i.e., a Q matrix.
</p>

<hr>
<h2 id='format_partition'>Format a partition matrix</h2><span id='topic+format_partition'></span>

<h3>Description</h3>

<p>Formats a partition matrix so that subsets in a partition will be ordered by the value of the smallest in each subset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_partition(P1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_partition_+3A_p1">P1</code></td>
<td>
<p>A partition matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formatted partition matrix.
</p>

<hr>
<h2 id='gather.biclustermd'>Gather a biclustermd object</h2><span id='topic+gather.biclustermd'></span>

<h3>Description</h3>

<p>Gather a biclustermd object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biclustermd'
gather(
  data,
  key = NULL,
  value = NULL,
  ...,
  na.rm = FALSE,
  convert = FALSE,
  factor_key = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather.biclustermd_+3A_data">data</code></td>
<td>
<p>a <code>biclustermd</code> object to gather.</p>
</td></tr>
<tr><td><code id="gather.biclustermd_+3A_key">key</code></td>
<td>
<p>unused; included for consistency with <code>tidyr</code> generic</p>
</td></tr>
<tr><td><code id="gather.biclustermd_+3A_value">value</code></td>
<td>
<p>unused; included for consistency with <code>tidyr</code> generic</p>
</td></tr>
<tr><td><code id="gather.biclustermd_+3A_...">...</code></td>
<td>
<p>unused; included for consistency with <code>tidyr</code> generic</p>
</td></tr>
<tr><td><code id="gather.biclustermd_+3A_na.rm">na.rm</code></td>
<td>
<p>unused; included for consistency with <code>tidyr</code> generic</p>
</td></tr>
<tr><td><code id="gather.biclustermd_+3A_convert">convert</code></td>
<td>
<p>unused; included for consistency with <code>tidyr</code> generic</p>
</td></tr>
<tr><td><code id="gather.biclustermd_+3A_factor_key">factor_key</code></td>
<td>
<p>unused; included for consistency with <code>tidyr</code> generic</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the row names and column names of both the
two-way table of data biclustered and the cell-average matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")

bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
gather(bc)

# bicluster 6 is in the top right-hand corner here:
autoplot(bc)

# bicluster 3 is in the bottom right-hand corner here:
autoplot(bc)

</code></pre>

<hr>
<h2 id='jaccard_similarity'>Compute the Jaccard similarity coefficient for two clusterings</h2><span id='topic+jaccard_similarity'></span>

<h3>Description</h3>

<p>Compute the Jaccard similarity coefficient for two clusterings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard_similarity(clus1, clus2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jaccard_similarity_+3A_clus1">clus1</code></td>
<td>
<p>vector giving the first set of clusters</p>
</td></tr>
<tr><td><code id="jaccard_similarity_+3A_clus2">clus2</code></td>
<td>
<p>vector giving the second set of clusters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric
</p>


<h3>References</h3>

<p>Milligan, G.W. and Cooper, M. C. (1986) <em>A study of the comparability of external criteria for hierarchical cluster analysis.
Multivariate Behavioral Research, 21, 441-458.</em>
</p>

<hr>
<h2 id='mse_heatmap'>Make a heatmap of cell MSEs</h2><span id='topic+mse_heatmap'></span>

<h3>Description</h3>

<p>Make a heatmap of cell MSEs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse_heatmap(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_heatmap_+3A_x">x</code></td>
<td>
<p>An object of class <code>biclustermd</code>.</p>
</td></tr>
<tr><td><code id="mse_heatmap_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code>geom_tile()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)

mse_heatmap(bc)

mse_heatmap(bc) + ggplot2::scale_fill_viridis_c()
</code></pre>

<hr>
<h2 id='part_matrix_to_vector'>Convert a partition matrix to a vector</h2><span id='topic+part_matrix_to_vector'></span>

<h3>Description</h3>

<p>For each row in a partition matrix, this function gets the column index for which the row is equal to one.
That is, for row i, this function returns the index of the row entry that is equal to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_matrix_to_vector(P0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="part_matrix_to_vector_+3A_p0">P0</code></td>
<td>
<p>A partition matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector
</p>

<hr>
<h2 id='partition_gen'>Generate an intial, random partition matrix with N objects into K subsets/groups.</h2><span id='topic+partition_gen'></span>

<h3>Description</h3>

<p>This function is used to randomly generate a partition matrix and assign rows or columns to prototypes. Must be the case that N &gt; K.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_gen(N, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_gen_+3A_n">N</code></td>
<td>
<p>Number of objects/rows in a partition matrix</p>
</td></tr>
<tr><td><code id="partition_gen_+3A_k">K</code></td>
<td>
<p>Desired number of partitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A partition matrix.
</p>

<hr>
<h2 id='partition_gen_by_p'>Create a partition matrix with a partition vector p</h2><span id='topic+partition_gen_by_p'></span>

<h3>Description</h3>

<p>Create a partition matrix with a partition vector p
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_gen_by_p(N, K, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_gen_by_p_+3A_n">N</code></td>
<td>
<p>Rows in a partition matrix</p>
</td></tr>
<tr><td><code id="partition_gen_by_p_+3A_k">K</code></td>
<td>
<p>Number of prototypes to create</p>
</td></tr>
<tr><td><code id="partition_gen_by_p_+3A_p">p</code></td>
<td>
<p>Integer vector containing the cluster each row in a partition matrix is to be assigned to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A partition matrix.
</p>

<hr>
<h2 id='position_finder'>Find the index of the first nonzero value in a vector</h2><span id='topic+position_finder'></span>

<h3>Description</h3>

<p>Find the index of the first nonzero value in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position_finder(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="position_finder_+3A_vec">vec</code></td>
<td>
<p>A binary vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Position of the first nonzero value in a vector.
</p>

<hr>
<h2 id='print.biclustermd'>Print an object of class biclustermd</h2><span id='topic+print.biclustermd'></span>

<h3>Description</h3>

<p>Print an object of class biclustermd
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biclustermd'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.biclustermd_+3A_x">x</code></td>
<td>
<p>a <code>biclustermd</code> object.</p>
</td></tr>
<tr><td><code id="print.biclustermd_+3A_...">...</code></td>
<td>
<p>arguments passed to or from other methods</p>
</td></tr>
</table>

<hr>
<h2 id='reorder_biclust'>Reorder a bicluster object for making a heat map</h2><span id='topic+reorder_biclust'></span>

<h3>Description</h3>

<p>Reorder a bicluster object for making a heat map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_biclust(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reorder_biclust_+3A_x">x</code></td>
<td>
<p>A bicluster object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the two partition matrices used by gg_bicluster.
</p>

<hr>
<h2 id='rep_biclustermd'>Repeat a biclustering to achieve a minimum SSE solution</h2><span id='topic+rep_biclustermd'></span>

<h3>Description</h3>

<p>Repeat a biclustering to achieve a minimum SSE solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_biclustermd(
  data,
  nrep = 10,
  parallel = FALSE,
  ncores = 2,
  col_clusters = floor(sqrt(ncol(data))),
  row_clusters = floor(sqrt(nrow(data))),
  miss_val = mean(data, na.rm = TRUE),
  miss_val_sd = 1,
  similarity = "Rand",
  row_min_num = 5,
  col_min_num = 5,
  row_num_to_move = 1,
  col_num_to_move = 1,
  row_shuffles = 1,
  col_shuffles = 1,
  max.iter = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_biclustermd_+3A_data">data</code></td>
<td>
<p>Dataset to bicluster. Must to be a data matrix with only numbers and missing values in the data set. It should have row names and column names.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_nrep">nrep</code></td>
<td>
<p>The number of times to repeat the biclustering. Default 10.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating if the user would like to utilize the
<code>foreach</code> parallel backend. Default is FALSE.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to use if parallel computing. Default 2.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_col_clusters">col_clusters</code></td>
<td>
<p>The number of clusters to partition the columns into.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_row_clusters">row_clusters</code></td>
<td>
<p>The number of clusters to partition the rows into.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_miss_val">miss_val</code></td>
<td>
<p>Value or function to put in empty cells of the prototype matrix.
If a value, a random normal variable with sd = <code>miss_val_sd</code> is used each iteration.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_miss_val_sd">miss_val_sd</code></td>
<td>
<p>Standard deviation of the normal distribution <code>miss_val</code> follows
if <code>miss_val</code> is a number. By default this equals 1.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_similarity">similarity</code></td>
<td>
<p>The metric used to compare two successive clusterings. Can be
&quot;Rand&quot; (default), &quot;HA&quot; for the Hubert and Arabie adjusted Rand index or &quot;Jaccard&quot;.
See <a href="phyclust.html#topic+RRand">RRand</a> and for details.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_row_min_num">row_min_num</code></td>
<td>
<p>Minimum row prototype size in order to be eligible to be chosen when filling an empty row prototype. Default is 5.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_col_min_num">col_min_num</code></td>
<td>
<p>Minimum column prototype size in order to be eligible to be chosen when filling an empty row prototype. Default is 5.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_row_num_to_move">row_num_to_move</code></td>
<td>
<p>Number of rows to remove from the sampled prototype to put in the empty row prototype. Default is 1.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_col_num_to_move">col_num_to_move</code></td>
<td>
<p>Number of columns to remove from the sampled prototype to put in the empty column prototype. Default is 1.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_row_shuffles">row_shuffles</code></td>
<td>
<p>Number of times to shuffle rows in each iteration. Default is 1.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_col_shuffles">col_shuffles</code></td>
<td>
<p>Number of times to shuffle columns in each iteration. Default is 1.</p>
</td></tr>
<tr><td><code id="rep_biclustermd_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations to let the algorithm run for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the minimum SSE biclustering, a vector containing
the final SSE of each repeat, and the time it took the function to run.
</p>


<h3>References</h3>

<p>Li, J., Reisner, J., Pham, H., Olafsson, S., and Vardeman, S. (2019) <em>Biclustering for Missing Data. Information Sciences, Submitted</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biclustermd">biclustermd</a></code>, <code><a href="#topic+tune_biclustermd">tune_biclustermd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")

# 20 repeats without parallelization
repeat_bc &lt;- rep_biclustermd(synthetic, nrep = 20,
                             col_clusters = 3, row_clusters = 2,
                             miss_val = mean(synthetic, na.rm = TRUE),
                             miss_val_sd = sd(synthetic, na.rm = TRUE),
                             col_min_num = 2, row_min_num = 2,
                             col_num_to_move = 1, row_num_to_move = 1,
                             max.iter = 10)
repeat_bc
autoplot(repeat_bc$best_bc)
plot(repeat_bc$rep_sse, type = 'b', pch = 20)
repeat_bc$runtime

# 20 repeats with parallelization over 2 cores
repeat_bc &lt;- rep_biclustermd(synthetic, nrep = 20, parallel = TRUE, ncores = 2,
                             col_clusters = 3, row_clusters = 2,
                             miss_val = mean(synthetic, na.rm = TRUE),
                             miss_val_sd = sd(synthetic, na.rm = TRUE),
                             col_min_num = 2, row_min_num = 2,
                             col_num_to_move = 1, row_num_to_move = 1,
                             max.iter = 10)
repeat_bc$runtime
</code></pre>

<hr>
<h2 id='results_heatmap'>Make a heatmap of sparse biclustering results</h2><span id='topic+results_heatmap'></span>

<h3>Description</h3>

<p>Make a heatmap of sparse biclustering results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results_heatmap(
  x,
  reorder = FALSE,
  transform_colors = FALSE,
  c = 1/6,
  cell_alpha = 1/5,
  col_clusts = NULL,
  row_clusts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="results_heatmap_+3A_x">x</code></td>
<td>
<p>A <code>biclustermd</code> object.</p>
</td></tr>
<tr><td><code id="results_heatmap_+3A_reorder">reorder</code></td>
<td>
<p>A logical. If TRUE, heatmap will be sorted according to the cell-average matrix, <code>A</code>.</p>
</td></tr>
<tr><td><code id="results_heatmap_+3A_transform_colors">transform_colors</code></td>
<td>
<p>If equals <code>TRUE</code> then the data is scaled by
<code>c</code> and run through a standard normal cdf before plotting. If <code>FALSE</code> (default), raw data
values are used in the heat map.</p>
</td></tr>
<tr><td><code id="results_heatmap_+3A_c">c</code></td>
<td>
<p>Value to scale the data by before running it through a standard normal CDF.
Default is 1/6.</p>
</td></tr>
<tr><td><code id="results_heatmap_+3A_cell_alpha">cell_alpha</code></td>
<td>
<p>A scalar defining the transparency of shading over a cell and by default this equals 1/5.
The color corresponds to the cell mean.</p>
</td></tr>
<tr><td><code id="results_heatmap_+3A_col_clusts">col_clusts</code></td>
<td>
<p>A vector of column cluster indices to display. If NULL (default), all are displayed.</p>
</td></tr>
<tr><td><code id="results_heatmap_+3A_row_clusts">row_clusts</code></td>
<td>
<p>A vector of row cluster indices to display. If NULL (default), all are displayed.</p>
</td></tr>
<tr><td><code id="results_heatmap_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>geom_vline()</code> and <code>geom_hline()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class ggplot.
</p>

<hr>
<h2 id='row_cluster_names'>Get row names in each row cluster</h2><span id='topic+row_cluster_names'></span>

<h3>Description</h3>

<p>Get row names in each row cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_cluster_names(x, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_cluster_names_+3A_x">x</code></td>
<td>
<p>Biclustering object to extract row cluster designation from</p>
</td></tr>
<tr><td><code id="row_cluster_names_+3A_data">data</code></td>
<td>
<p>Data that contains the row names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: <code>cluster</code> corresponds to the row
cluster and <code>name</code> gives the row names in each cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
rownames(synthetic) &lt;- letters[1:nrow(synthetic)]
colnames(synthetic) &lt;- letters[1:ncol(synthetic)]
bc &lt;- biclustermd(synthetic, col_clusters = 3, row_clusters = 2,
                miss_val = mean(synthetic, na.rm = TRUE),
                miss_val_sd = sd(synthetic, na.rm = TRUE),
                col_min_num = 2, row_min_num = 2,
                col_num_to_move = 1, row_num_to_move = 1,
                max.iter = 10)
bc
</code></pre>

<hr>
<h2 id='row.names.biclustermd'>Get data matrix row names and their corresponding row cluster membership</h2><span id='topic+row.names.biclustermd'></span>

<h3>Description</h3>

<p>Get data matrix row names and their corresponding row cluster membership
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'biclustermd'
row.names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row.names.biclustermd_+3A_x">x</code></td>
<td>
<p>and object of class <code>biclustermd</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with row names of the shuffled matrix and corresponding row cluster names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("synthetic")
# default parameters
bc &lt;- biclustermd(synthetic)
bc
row.names(bc)
# this is a simplified version of the output for gather(bc):
library(dplyr)
gather(bc) %&gt;% distinct(row_cluster, row_name)
</code></pre>

<hr>
<h2 id='runtimes'>Algorithm run time data</h2><span id='topic+runtimes'></span>

<h3>Description</h3>

<p>This dataset stems from the R journal article introducing <code>biclustermd</code>
to R users. It describes the data attributes and run time for varying data
sizes and structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runtimes
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 2400 rows and 13 columns.
</p>


<h3>Details</h3>

<p>A data frame of 2400 rows and 13 variables (defined range, inclusive):
</p>

<dl>
<dt>combination_no</dt><dd><p>Unique identifier of a combination of parameters.</p>
</dd>
<dt>rows</dt><dd><p>Number of rows in the data matrix. (50, 1500)</p>
</dd>
<dt>cols</dt><dd><p>Number of columns in the data matrix. (50, 1500)</p>
</dd>
<dt>N</dt><dd><p>Product of the dimensions of the data. (2500, 2250000)</p>
</dd>
<dt>row_clusts</dt><dd><p>Number of clusters to partition the rows into. (4, 300)</p>
</dd>
<dt>col_clusts</dt><dd><p>Number of clusters to partition the columns into. (4, 300)</p>
</dd>
<dt>avg_row_clust_size</dt><dd><p>Average row cluster size. <code>rows / row_clusts</code></p>
</dd>
<dt>avg_col_clust_size</dt><dd><p>Average column cluster size. <code>cols / col_clusts</code></p>
</dd>
<dt>sparsity</dt><dd><p>Percent of data values which are missing.</p>
</dd>
<dt>user.self</dt><dd><p>CPU time used executing instructions to calls (from <code>?proc.time</code>.</p>
</dd>
<dt>sys.self</dt><dd><p>CPU time used executing calls (from <code>?proc.time</code>.</p>
</dd>
<dt>elapsed</dt><dd><p>Amount of time in seconds it took the algorithm to converge.</p>
</dd>
<dt>iterations</dt><dd><p>Number of iterations to convergence.</p>
</dd>
</dl>


<hr>
<h2 id='synthetic'>Synthetic data for examples.</h2><span id='topic+synthetic'></span>

<h3>Description</h3>

<p>This simple dataset allows users to use data that are easy to understand while learning
<code>biclustermd</code>. This is a matrix with 6 rows and 12 columns. 50% of values are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synthetic
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> with 6 rows and 12 columns.
</p>

<hr>
<h2 id='tune_biclustermd'>Bicluster data over a grid of tuning parameters</h2><span id='topic+tune_biclustermd'></span>

<h3>Description</h3>

<p>Bicluster data over a grid of tuning parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tune_biclustermd(
  data,
  nrep = 10,
  parallel = FALSE,
  ncores = 2,
  tune_grid = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tune_biclustermd_+3A_data">data</code></td>
<td>
<p>Dataset to bicluster. Must to be a data matrix with only numbers and missing values in the data set. It should have row names and column names.</p>
</td></tr>
<tr><td><code id="tune_biclustermd_+3A_nrep">nrep</code></td>
<td>
<p>The number of times to repeat the biclustering for each set of parameters. Default 10.</p>
</td></tr>
<tr><td><code id="tune_biclustermd_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating if the user would like to utilize the
<code>foreach</code> parallel backend. Default is FALSE.</p>
</td></tr>
<tr><td><code id="tune_biclustermd_+3A_ncores">ncores</code></td>
<td>
<p>The number of cores to use if parallel computing. Default 2.</p>
</td></tr>
<tr><td><code id="tune_biclustermd_+3A_tune_grid">tune_grid</code></td>
<td>
<p>A data frame of parameters to tune over. The column names of
this must match the arguments passed to <code>biclustermd()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of:
</p>
<table>
<tr><td><code>best_combn</code></td>
<td>
<p>The best combination of parameters,</p>
</td></tr>
<tr><td><code>best_bc</code></td>
<td>
<p>The minimum SSE biclustering using the parameters in
<code>best_combn</code>,</p>
</td></tr> <tr><td><code>grid</code></td>
<td>
<p><code>tune_grid</code> with columns giving the
minimum, mean, and standard deviation of the final SSE for each parameter
combination, and</p>
</td></tr> <tr><td><code>runtime</code></td>
<td>
<p>CPU runtime &amp; elapsed time.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Li, J., Reisner, J., Pham, H., Olafsson, S., and Vardeman, S. (2019) <em>Biclustering for Missing Data. Information Sciences, Submitted</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biclustermd">biclustermd</a></code>, <code><a href="#topic+rep_biclustermd">rep_biclustermd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)
data("synthetic")
tg &lt;- expand.grid(
miss_val = fivenum(synthetic),
similarity = c("Rand", "HA", "Jaccard"),
col_min_num = 2,
row_min_num = 2,
col_clusters = 3:5,
row_clusters = 2
)
tg

# in parallel: two cores:
tbc &lt;- tune_biclustermd(synthetic, nrep = 2, parallel = TRUE, ncores = 2, tune_grid = tg)
tbc

tbc$grid %&gt;%
  group_by(miss_val, col_clusters) %&gt;%
  summarise(avg_sd = mean(sd_sse)) %&gt;%
  ggplot(aes(miss_val, avg_sd, color = col_clusters, group = col_clusters)) +
  geom_line() +
  geom_point()

tbc &lt;- tune_biclustermd(synthetic, nrep = 2, tune_grid = tg)
tbc

boxplot(tbc$grid$mean_sse ~ tbc$grid$similarity)
boxplot(tbc$grid$sd_sse ~ tbc$grid$similarity)

# nycflights13::flights dataset

library(nycflights13)
data("flights")

library(dplyr)
flights_bcd &lt;- flights %&gt;%
  select(month, dest, arr_delay)

flights_bcd &lt;- flights_bcd %&gt;%
  group_by(month, dest) %&gt;%
  summarise(mean_arr_delay = mean(arr_delay, na.rm = TRUE)) %&gt;%
  spread(dest, mean_arr_delay) %&gt;%
  as.data.frame()

# months as rows
rownames(flights_bcd) &lt;- flights_bcd$month
flights_bcd &lt;- as.matrix(flights_bcd[, -1])

flights_grid &lt;- expand.grid(
row_clusters = 4,
col_clusters = c(6, 9, 12),
miss_val = fivenum(flights_bcd),
similarity = c("Rand", "Jaccard")
)

# RUN TIME: approximately 40 seconds across two cores.
flights_tune &lt;- tune_biclustermd(
  flights_bcd,
  nrep = 10,
  parallel = TRUE,
  ncores = 2,
  tune_grid = flights_grid
)
flights_tune

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
