<!DOCTYPE html><html><head><title>Help for package DEBBI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DEBBI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AlgoParamsDEMAP'><p>AlgoParamsDEMAP</p></a></li>
<li><a href='#AlgoParamsDEMCMC'><p>AlgoParamsDEMCMC</p></a></li>
<li><a href='#AlgoParamsDEVI'><p>AlgoParamsDEVI</p></a></li>
<li><a href='#DEMAP'><p>DEMAP</p></a></li>
<li><a href='#DEMCMC'><p>DEMCMC</p></a></li>
<li><a href='#DEVI'><p>DEVI</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Differential Evolution-Based Bayesian Inference</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian inference algorithms based on the population-based "differential evolution" (DE) algorithm. Users can obtain posterior mode (MAP) estimates via DEMAP, posterior samples via DEMCMC, and variational approximations via DEVI. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bmgaldo/DEBBI">https://github.com/bmgaldo/DEBBI</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bmgaldo/DEBBI">https://github.com/bmgaldo/DEBBI</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, doParallel, randtoolbox, numDeriv</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-12 22:16:44 UTC; brendan</td>
</tr>
<tr>
<td>Author:</td>
<td>Brendan Matthew Galdo
    <a href="https://orcid.org/0000-0002-1279-3859"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brendan Matthew Galdo &lt;Brendan.m.galdo@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-17 09:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='AlgoParamsDEMAP'>AlgoParamsDEMAP</h2><span id='topic+AlgoParamsDEMAP'></span>

<h3>Description</h3>

<p>get control parameters for DEMAP function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlgoParamsDEMAP(
  n_params,
  n_chains = NULL,
  n_iter = 1000,
  init_sd = 0.01,
  init_center = 0,
  n_cores_use = 1,
  step_size = NULL,
  jitter_size = 1e-06,
  crossover_rate = 1,
  parallel_type = "none",
  return_trace = FALSE,
  thin = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlgoParamsDEMAP_+3A_n_params">n_params</code></td>
<td>
<p>number of free parameters estimated</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_n_chains">n_chains</code></td>
<td>
<p>number of particle chains, 3*n_params is the default value</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_n_iter">n_iter</code></td>
<td>
<p>number of iterations to run the sampling algorithm, 1000 is default</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_init_sd">init_sd</code></td>
<td>
<p>positive scalar or n_params-dimensional numeric vector, determines the standard deviation of the Gaussian initialization distribution</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_init_center">init_center</code></td>
<td>
<p>scalar or n_params-dimensional numeric vector that determines the mean of the Gaussian initialization distribution</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_n_cores_use">n_cores_use</code></td>
<td>
<p>number of cores used when using parallelization.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_step_size">step_size</code></td>
<td>
<p>positive scalar, jump size in DE crossover step, default is 2.38/sqrt(2*n_params).</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_jitter_size">jitter_size</code></td>
<td>
<p>positive scalar, noise is added during crossover step from Uniform(-jitter_size,jitter_size) distribution. 1e-6 is the default value.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_crossover_rate">crossover_rate</code></td>
<td>
<p>number on the interval (0,1]. Determines the probability a parameter on a chain is updated on a given crossover step, sampled from a Bernoulli distribution.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_parallel_type">parallel_type</code></td>
<td>
<p>string specifying parallelization type. 'none','FORK', or 'PSOCK' are valid values. 'none' is default value.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_return_trace">return_trace</code></td>
<td>
<p>logical, if true, function returns particle trajectories. This is helpful for diagnosing convergence or debugging model code. Function will return an iteration/thin $x$ n_chains $x$ n_params array and the estimated ELBO of each particle in a iteration/thin x n_chains array.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMAP_+3A_thin">thin</code></td>
<td>
<p>positive integer, only every 'thin'-th iteration will be stored. Default value is 1. Increasing thin will reduce the memory required, while running chains for longer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of control parameters for the DEMAP function
</p>

<hr>
<h2 id='AlgoParamsDEMCMC'>AlgoParamsDEMCMC</h2><span id='topic+AlgoParamsDEMCMC'></span>

<h3>Description</h3>

<p>AlgoParamsDEMCMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlgoParamsDEMCMC(
  n_params,
  n_chains = NULL,
  param_names = NULL,
  n_iter = 1000,
  init_sd = 0.01,
  init_center = 0,
  n_cores_use = 1,
  step_size = NULL,
  jitter_size = 1e-06,
  parallel_type = "none",
  burnin = 0,
  thin = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlgoParamsDEMCMC_+3A_n_params">n_params</code></td>
<td>
<p>number of free parameters estimated</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_n_chains">n_chains</code></td>
<td>
<p>number of MCMC chains, 3*n_params is the default value</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_param_names">param_names</code></td>
<td>
<p>optional vector of parameter names</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_n_iter">n_iter</code></td>
<td>
<p>number of iterations to run the sampling algorithm, 1000 is default</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_init_sd">init_sd</code></td>
<td>
<p>positive scalar or n_params-dimensional numeric vector, determines the standard deviation of the Gaussian initialization distribution</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_init_center">init_center</code></td>
<td>
<p>scalar or n_params-dimensional numeric vector, determines the mean of the Gaussian initialization distribution</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_n_cores_use">n_cores_use</code></td>
<td>
<p>number of cores used when using parallelization.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_step_size">step_size</code></td>
<td>
<p>positive scalar, jump size in DE crossover step, default is 2.38/sqrt(2*n_params) which is optimal for multivariate Gaussian target distribution (ter Braak, 2006)</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_jitter_size">jitter_size</code></td>
<td>
<p>positive scalar, noise is added during crossover step from Uniform(-jitter_size,jitter_size) distribution. 1e-6 is the default value.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_parallel_type">parallel_type</code></td>
<td>
<p>string specifying parallelization type. 'none','FORK', or 'PSOCK' are valid values. 'none' is default value.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_burnin">burnin</code></td>
<td>
<p>number of initial iterations to discard. Default value is 0.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEMCMC_+3A_thin">thin</code></td>
<td>
<p>positive integer, only every 'thin'-th iteration will be stored. Default value is 1. Increasing thin will reduce the memory required, while running chains for longer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of control parameters for the DEMCMC function
</p>

<hr>
<h2 id='AlgoParamsDEVI'>AlgoParamsDEVI</h2><span id='topic+AlgoParamsDEVI'></span>

<h3>Description</h3>

<p>get control parameters for DEVI function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlgoParamsDEVI(
  n_params,
  param_names = NULL,
  n_chains = NULL,
  n_iter = 1000,
  init_sd = 0.01,
  init_center = 0,
  n_cores_use = 1,
  step_size = NULL,
  jitter_size = 1e-06,
  parallel_type = "none",
  use_QMC = TRUE,
  purify = NULL,
  quasi_rand_seq = "halton",
  n_samples_ELBO = 10,
  LRVB_correction = TRUE,
  n_samples_LRVB = 25,
  neg_inf = -750,
  thin = 1,
  burnin = 0,
  return_trace = FALSE,
  crossover_rate = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlgoParamsDEVI_+3A_n_params">n_params</code></td>
<td>
<p>number of free parameters estimated</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_param_names">param_names</code></td>
<td>
<p>optional vector of parameter names</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_n_chains">n_chains</code></td>
<td>
<p>number of particle chains used for optimization, 3*n_params is the default value</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_n_iter">n_iter</code></td>
<td>
<p>number of iterations to run the sampling algorithm, 1000 is default</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_init_sd">init_sd</code></td>
<td>
<p>positive scalar or n_params-dimensional numeric vector, determines the standard deviation of the Gaussian initialization distribution</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_init_center">init_center</code></td>
<td>
<p>scalar or n_params-dimensional numeric vector, determines the mean of the Gaussian initialization distribution</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_n_cores_use">n_cores_use</code></td>
<td>
<p>number of cores used when using parallelization.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_step_size">step_size</code></td>
<td>
<p>positive scalar, jump size in DE crossover step, default is 2.38/sqrt(2*n_params).</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_jitter_size">jitter_size</code></td>
<td>
<p>positive scalar, noise is added during crossover step from Uniform(-jitter_size,jitter_size) distribution. 1e-6 is the default value.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_parallel_type">parallel_type</code></td>
<td>
<p>string specifying parallelization type. 'none','FORK', or 'PSOCK' are valid values. 'none' is default value.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_use_qmc">use_QMC</code></td>
<td>
<p>logical, if true, a quasi-Monte Carlo estimator is used to estimate ELBO during optimization. default is TRUE.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_purify">purify</code></td>
<td>
<p>an integer, every 'purify'-th iteration, the Monte Carlo estimator of the ELBO is recalculated. This can help deal with noisy and outlier estimates of the ELBO. Default value is 25. If use_QMC is TRUE, purification is disabled as it is redundant.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_quasi_rand_seq">quasi_rand_seq</code></td>
<td>
<p>type of low discrepancy sequence used for quasi Monte Carlo integration, either 'sobol' or 'halton'. LRVB correction always use QMC. Default is 'sobol'.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_n_samples_elbo">n_samples_ELBO</code></td>
<td>
<p>number of samples used for the Monte Carlo estimator of the ELBO (the objective function). default is 10.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_lrvb_correction">LRVB_correction</code></td>
<td>
<p>logical, if true, LRVB covariance correction (Giordano, Brodderick, &amp; Jordan 2018; Galdo, Bahg, &amp; Turner 2020) is attempted.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_n_samples_lrvb">n_samples_LRVB</code></td>
<td>
<p>number of samples used for LRVB correction. default is 25.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_neg_inf">neg_inf</code></td>
<td>
<p>if density for a given value of theta is numerically 0 for q, this value is assigned for log density. This helps with numeric stability of algorithm. Default value is -750.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_thin">thin</code></td>
<td>
<p>positive integer, only every 'thin'-th iteration will be stored. Default value is 1. Increasing thin will reduce the memory required, while running algorithm for longer.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_burnin">burnin</code></td>
<td>
<p>number of initial iterations to discard. Default value is 0.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_return_trace">return_trace</code></td>
<td>
<p>logical, if true, function returns particle trajectories. This is helpful for diagnosing convergence or debugging model code. Function will return an iteration/thin $x$ n_chains $x$ n_params array and the estimated ELBO of each particle in a iteration/thin x n_chains array.</p>
</td></tr>
<tr><td><code id="AlgoParamsDEVI_+3A_crossover_rate">crossover_rate</code></td>
<td>
<p>number on the interval (0,1]. Determines the probability a parameter on a chain is updated on a given crossover step, sampled from a Bernoulli distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of control parameters for the DEVI function
</p>

<hr>
<h2 id='DEMAP'>DEMAP</h2><span id='topic+DEMAP'></span>

<h3>Description</h3>

<p>DE optimization for maximum a posteriori (MAP) estimation; his function tries to find the posterior mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEMAP(LogPostLike, control_params = AlgoParamsDEMAP(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEMAP_+3A_logpostlike">LogPostLike</code></td>
<td>
<p>function whose first argument is an n_params-dimensional model parameter vector and returns (scalar) sum of log prior density and log likelihood for the parameter vector.</p>
</td></tr>
<tr><td><code id="DEMAP_+3A_control_params">control_params</code></td>
<td>
<p>control parameters for DE algorithm. see <code><a href="#topic+AlgoParamsDEMAP">AlgoParamsDEMAP</a></code> function documentation for more details.</p>
</td></tr>
<tr><td><code id="DEMAP_+3A_...">...</code></td>
<td>
<p>additional arguments to pass LogPostLike</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list contain posterior samples from DEMCMC in a n_iters_per_chain by n_chains by n_params array and the log likelihood of each sample in a n_iters_per_chain by n_chains array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate from model
dataExample &lt;- matrix(stats::rnorm(100, c(-1, 1), c(1, 1)), nrow = 50, ncol = 2, byrow = TRUE)

# list parameter names
param_names_example &lt;- c("mu_1", "mu_2")

# log posterior likelihood function = log likelihood + log prior | returns a scalar
LogPostLikeExample &lt;- function(x, data, param_names) {
  out &lt;- 0

  names(x) &lt;- param_names

  # log prior
  out &lt;- out + sum(dnorm(x["mu_1"], 0, sd = 1, log = TRUE))
  out &lt;- out + sum(dnorm(x["mu_2"], 0, sd = 1, log = TRUE))

  # log likelihoods
  out &lt;- out + sum(dnorm(data[, 1], x["mu_1"], sd = 1, log = TRUE))
  out &lt;- out + sum(dnorm(data[, 2], x["mu_2"], sd = 1, log = TRUE))

  return(out)
}

# Get map estimates
DEMAP(
  LogPostLike = LogPostLikeExample,
  control_params = AlgoParamsDEMAP(
    n_params = length(param_names_example),
    n_iter = 1000,
    n_chains = 12
  ),
  data = dataExample,
  param_names = param_names_example
)

</code></pre>

<hr>
<h2 id='DEMCMC'>DEMCMC</h2><span id='topic+DEMCMC'></span>

<h3>Description</h3>

<p>Sample from posterior using Differential Evolution Markov Chain Monte Carlo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEMCMC(LogPostLike, control_params = AlgoParamsDEMCMC(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEMCMC_+3A_logpostlike">LogPostLike</code></td>
<td>
<p>function whose first argument is an n_params-dimensional model parameter vector and returns (scalar) sum of log prior density and log likelihood for the parameter vector.</p>
</td></tr>
<tr><td><code id="DEMCMC_+3A_control_params">control_params</code></td>
<td>
<p>control parameters for DEMCMC algorithm. see <code><a href="#topic+AlgoParamsDEMCMC">AlgoParamsDEMCMC</a></code> function documentation for more details. You must specify 'n_params' here.</p>
</td></tr>
<tr><td><code id="DEMCMC_+3A_...">...</code></td>
<td>
<p>additional arguments to pass LogPostLike</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list contain posterior samples from DEMCMC in a 'n_samples_per_chain' by 'n_chains' by n_params array and the log posterior likelihood of each sample in a 'n_samples_per_chain' by 'n_chains' array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate from model
dataExample &lt;- matrix(stats::rnorm(100, c(-1, 1), c(1, 1)), nrow = 50, ncol = 2, byrow = TRUE)
#
# list parameter names
param_names_example &lt;- c("mu_1", "mu_2")

# log posterior likelihood function = log likelihood + log prior | returns a scalar
LogPostLikeExample &lt;- function(x, data, param_names) {
  out &lt;- 0

  names(x) &lt;- param_names

  # log prior
  out &lt;- out + sum(dnorm(x["mu_1"], 0, sd = 1, log = TRUE))
  out &lt;- out + sum(dnorm(x["mu_2"], 0, sd = 1, log = TRUE))

  # log likelihoods
  out &lt;- out + sum(dnorm(data[, 1], x["mu_1"], sd = 1, log = TRUE))
  out &lt;- out + sum(dnorm(data[, 2], x["mu_2"], sd = 1, log = TRUE))

  return(out)
}

# Sample from posterior
DEMCMC(
  LogPostLike = LogPostLikeExample,
  control_params = AlgoParamsDEMCMC(
    n_params = length(param_names_example),
    n_iter = 1000,
    n_chains = 12
  ),
  data = dataExample,
  param_names = param_names_example
)
</code></pre>

<hr>
<h2 id='DEVI'>DEVI</h2><span id='topic+DEVI'></span>

<h3>Description</h3>

<p>DE optimization for mean-field variational inference. Minimizes the KL divergence (maximizes the ELBO) between $q(theta|lambda)$ and the target posterior $p(theta|data)$ For a tutorial on variational inference check out Galdo, Bahg, &amp; Turner 2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEVI(LogPostLike, control_params = AlgoParamsDEVI(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEVI_+3A_logpostlike">LogPostLike</code></td>
<td>
<p>function whose first argument is an n_params-dimensional model parameter vector and returns (scalar) sum of log prior density and log likelihood for the parameter vector.</p>
</td></tr>
<tr><td><code id="DEVI_+3A_control_params">control_params</code></td>
<td>
<p>control parameters for DE algorithm. see <code><a href="#topic+AlgoParamsDEVI">AlgoParamsDEVI</a></code> function documentation for more details.</p>
</td></tr>
<tr><td><code id="DEVI_+3A_...">...</code></td>
<td>
<p>additional arguments to pass LogPostLike</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list contain mean in a n_iters_per_chain by n_chains by 2*n_params_model array and the ELBO of each sample in a n_iters_per_chain by n_chains array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate from model
dataExample &lt;- matrix(stats::rnorm(100, c(-1, 1), c(1, 1)), nrow = 50, ncol = 2, byrow = TRUE)
## list parameter names
param_names_example &lt;- c("mu_1", "mu_2")

# log posterior likelihood function = log likelihood + log prior | returns a scalar
LogPostLikeExample &lt;- function(x, data, param_names) {
  out &lt;- 0

  names(x) &lt;- param_names

  # log prior
  out &lt;- out + sum(dnorm(x["mu_1"], 0, sd = 1, log = TRUE))
  out &lt;- out + sum(dnorm(x["mu_2"], 0, sd = 1, log = TRUE))

  # log likelihoods
  out &lt;- out + sum(dnorm(data[, 1], x["mu_1"], sd = 1, log = TRUE))
  out &lt;- out + sum(dnorm(data[, 2], x["mu_2"], sd = 1, log = TRUE))

  return(out)
}

# Get variational approximation
DEVI(
  LogPostLike = LogPostLikeExample,
  control_params = AlgoParamsDEVI(
    n_params = length(param_names_example),
    n_iter = 200,
    n_chains = 12
  ),
  data = dataExample,
  param_names = param_names_example
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
