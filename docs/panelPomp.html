<!DOCTYPE html><html><head><title>Help for package panelPomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {panelPomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#panelPomp-package'><p>Inference for PanelPOMPs (Panel Partially Observed Markov Processes)</p></a></li>
<li><a href='#as'><p>Coercing <code>panelPomp</code> objects as <code>list</code>, <code>pompList</code> or</p>
<code>data.frame</code></a></li>
<li><a href='#contacts'><p>Contacts model</p></a></li>
<li><a href='#get_dim'><p>Get single column or row without dropping names</p></a></li>
<li><a href='#mif2'><p>PIF: Panel iterated filtering</p></a></li>
<li><a href='#panel_loglik'><p>Handling of loglikelihood replicates</p></a></li>
<li><a href='#panel_logmeanexp'><p>Log-mean-exp for panels</p></a></li>
<li><a href='#panelGompertz'><p>Panel Gompertz model</p></a></li>
<li><a href='#panelGompertzLikelihood'><p>Likelihood for a panel Gompertz model via a Kalman filter</p></a></li>
<li><a href='#panelPomp'><p>Constructing <code>panelPomp</code> objects</p></a></li>
<li><a href='#panelPomp_methods'><p>Manipulating <code>panelPomp</code> objects</p></a></li>
<li><a href='#panelRandomWalk'><p>Panel random walk model</p></a></li>
<li><a href='#params'><p>Convert to and from a <code>panelPomp</code> object <code>pParams</code> slot format and a one-row <code>data.frame</code></p></a></li>
<li><a href='#pfilter'><p>Particle filtering for panel data</p></a></li>
<li><a href='#plot'><p>panelPomp plotting facilities</p></a></li>
<li><a href='#pparams'><p>Extract parameters (coefficients) of a panel model</p></a></li>
<li><a href='#simulate'><p>Simulations of a panel of partially observed Markov process</p></a></li>
<li><a href='#unitlogLik'><p>Extract log likelihood of units of panel models</p></a></li>
<li><a href='#unitobjects'><p>Extract units of a panel model</p></a></li>
<li><a href='#wQuotes'><p>Interpret shortcuts for <code>sQuote()</code>s and <code>dQuote()</code>s in</p>
character objects</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference for Panel Partially Observed Markov Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-28</td>
</tr>
<tr>
<td>Description:</td>
<td>Data analysis based on panel partially-observed Markov process (PanelPOMP) models. To implement such models, simulate them and fit them to panel data, 'panelPomp' extends some of the facilities provided for time series data by the 'pomp' package. Implemented methods include filtering (panel particle filtering) and maximum likelihood estimation (Panel Iterated Filtering) as proposed in Breto, Ionides and King (2020) "Panel Data Analysis via Mechanistic Models" &lt;<a href="https://doi.org/10.1080%2F01621459.2019.1604367">doi:10.1080/01621459.2019.1604367</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.1.0), pomp(&ge; 4.5.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Collate:</td>
<td>'package.R' 'aaa.R' 'contacts.R' 'generics.R' 'get_col_row.R'
'panel_loglik.R' 'panel_logmeanexp.R' 'panelPomp.R'
'panelPomp_methods.R' 'params.R' 'pfilter.R'
'pfilter_methods.R' 'mif2.R' 'mif2_methods.R' 'panelGompertz.R'
'panelGompertzLikelihood.R' 'panelRandomWalk.R' 'plot.R'
'simulate.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-28 17:43:13 UTC; cbreto</td>
</tr>
<tr>
<td>Author:</td>
<td>Carles Breto <a href="https://orcid.org/0000-0003-4695-4902"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Edward L. Ionides <a href="https://orcid.org/0000-0002-4190-0174"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Aaron A. King <a href="https://orcid.org/0000-0001-6159-3207"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carles Breto &lt;carles.breto@uv.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-29 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='panelPomp-package'>Inference for PanelPOMPs (Panel Partially Observed Markov Processes)</h2><span id='topic+panelPomp-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">panelPomp</span> package provides facilities for inference
on panel data using panel partially-observed Markov process
(<abbr><span class="acronym">PanelPOMP</span></abbr>) models. To do so, it relies on and extends a number
of facilities that the <span class="pkg">pomp</span> package provides for inference on time
series data using partially-observed Markov process (<abbr><span class="acronym">POMP</span></abbr>) models.
</p>
<p>The <span class="pkg">panelPomp</span> package extends to panel data some of the capabilities
of the <span class="pkg">pomp</span> package to fit nonlinear, non-Gaussian dynamic models.
This is done accomodating both fixed and random effects. Currently, the
focus is on likelihood-based approaches. In addition to these
likelihood-based tools, <span class="pkg">panelPomp</span> also provides a framework under
which alternative statistical methods for <abbr><span class="acronym">PanelPOMP</span></abbr> models can be
developed (very much like <span class="pkg">pomp</span> provides a platform upon which
statistical inference methods for <abbr><span class="acronym">POMP</span></abbr> models can be implemented).
</p>


<h3>Data analysis using <span class="pkg">panelPomp</span></h3>

<p>The first step in using <span class="pkg">panelPomp</span> is to encode one's model(s) and data
in objects of class <code>panelPomp</code>.
One does this via a call to the <a href="#topic+panelPomp">panelPomp</a> constructor
function.
</p>
<p><span class="pkg">panelPomp</span> version
1.1
provides algorithms for
</p>

<ol>
<li><p> particle filtering of panel data (AKA sequential Monte Carlo or
sequential importance sampling), as proposed in Bret&oacute;, Ionides and King
(2020). This reference provides the fundamental theoretical support for the
averaging of Monte Carlo replicates of panel unit likelihoods as implemented
in <span class="pkg">panelPomp</span>; see <code><a href="#topic+pfilter">pfilter</a></code>
</p>
</li>
<li><p> the panel iterated filtering method of Bret&oacute;, Ionides and King
(2020). This reference provides the fundamental theoretical support for the
extensions of the iterated filtering ideas of Ionides et al. (2006, 2011,
2015) to panel data as implemented in <span class="pkg">panelPomp</span>; see
<code><a href="#topic+mif2">mif2</a></code>
</p>
</li></ol>

<p>The package also provides various tools for handling and extracting
information on models and data.
</p>


<h3>Extending the <span class="pkg">pomp</span> platform for developing inference tools</h3>

<p><span class="pkg">panelPomp</span> extends to panel data the general interface to the
components of <abbr><span class="acronym">POMP</span></abbr> models provided by <span class="pkg">pomp</span>. In doing so, it
contributes to the goal of the <span class="pkg">pomp</span> project of facilitating the
development of new algorithms in an environment where they can be tested
and compared on a growing body of models and datasets.
</p>


<h3>Comments, bug reports, and requests</h3>

<p>Contributions are welcome, as are suggestions for improvement, feature
requests, and bug reports.
Please submit these via the <a href="https://github.com/cbreto/panelPomp/issues">panelPomp issues page</a>.
We particularly welcome minimal working examples displaying uninformative,
misleading or inacurate error messages. We also welcome suggestions for
clarifying obscure passages in the documentation. Help requests are welcome,
but please consider before sending requests whether they are regarding the
use of <span class="pkg">panelPomp</span> or that of <span class="pkg">pomp</span>. For help with <span class="pkg">pomp</span>,
please visit
<a href="https://kingaa.github.io/pomp/FAQ.html#how-can-i-submit-an-effective-request-for-help"><span class="pkg">pomp</span>'s FAQ</a>.
</p>


<h3>Documentation</h3>

<p>Examples are provided via the <code>contacts()</code>, <code>panelGompertz()</code>
and <code>panelRandomWalk()</code> functions.
</p>


<h3>License</h3>

<p><span class="pkg">panelPomp</span> is provided under the GPL-3 License.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>References</h3>

<p>Bret&oacute;, C., Ionides, E. L. and King, A. A. (2020) Panel Data Analysis via Mechanistic Models. <em>Journal of the American Statistical Association</em>, <b>115</b>(531), 1178&ndash;1188. <a href="https://doi.org/10.1080/01621459.2019.1604367">doi:10.1080/01621459.2019.1604367</a>
</p>


<h3>See Also</h3>

<p><a href="pomp.html#topic+pomp-package">pomp package</a>, <a href="#topic+panelPomp">panelPomp</a>
</p>

<hr>
<h2 id='as'>Coercing <code>panelPomp</code> objects as <code>list</code>, <code>pompList</code> or
<code>data.frame</code></h2><span id='topic+as'></span>

<h3>Description</h3>

<p>When coercing to a <code>data.frame</code>, it coerces a
<code>panelPomp</code> into a <code>data.frame</code>, assuming units share common
variable names.
</p>
<p>When coercing to a <code>list</code>, it extracts the
<code>unit.objects</code> slot of <code>panelPomp</code> objects and attaches
associated parameters.
</p>
<p>When coercing to a <code>pompList</code>, it extracts the
<code>unit.objects</code> slot of <code>panelPomp</code> objects and attaches
associated parameters, converting the resulting list to a <code>pompList</code> to
help the assignment of pomp methods.
</p>


<h3>Value</h3>

<p>An object of class matching that specified in the second argument (<code>to=</code>).
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>See Also</h3>

<p>Other panelPomp methods: 
<code><a href="#topic+panelPomp_methods">panelPomp_methods</a></code>
</p>

<hr>
<h2 id='contacts'>Contacts model</h2><span id='topic+contacts'></span>

<h3>Description</h3>

<p>A panel model for dynamic variation in sexual contacts, with
data from Vittinghof et al (1999). The model was developed by
Romero-Severson et al (2015) and discussed by Bret&oacute; et al (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contacts(
  params = c(mu_X = 1.75, sigma_X = 2.67, mu_D = 3.81, sigma_D = 4.42, mu_R = 0.04,
    sigma_R = 0, alpha = 0.9)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contacts_+3A_params">params</code></td>
<td>
<p>parameter vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>panelPomp</code> object.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>References</h3>

<p>Bret&oacute;, C., Ionides, E. L. and King, A. A. (2020) Panel Data Analysis via Mechanistic Models. <em>Journal of the American Statistical Association</em>, <b>115</b>(531), 1178&ndash;1188. <a href="https://doi.org/10.1080/01621459.2019.1604367">doi:10.1080/01621459.2019.1604367</a>
</p>
<p>Romero-Severson, E.O., Volz, E., Koopman, J.S., Leitner, T. and Ionides, E.L. (2015) Dynamic variation in sexual contact rates in a cohort of HIV-negative gay men. <em>American journal of epidemiology</em>, <b>182</b>(3), 255&ndash;262. <a href="https://doi.org/10.1093/aje/kwv044">doi:10.1093/aje/kwv044</a>
</p>
<p>Vitinghoff, E., Douglas, J., Judon, F., McKiman, D., MacQueen, K. and Buchinder, S.P. (1999) Per-contact risk of human immunodificiency virus tramnsmision between male sexual partners. <em>American journal of epidemiology</em>, <b>150</b>(3), 306&ndash;311. <a href="https://doi.org/10.1093/oxfordjournals.aje.a010003">doi:10.1093/oxfordjournals.aje.a010003</a>
</p>


<h3>See Also</h3>

<p>Other panelPomp examples: 
<code><a href="#topic+panelGompertz">panelGompertz</a>()</code>,
<code><a href="#topic+panelRandomWalk">panelRandomWalk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
contacts()

</code></pre>

<hr>
<h2 id='get_dim'>Get single column or row without dropping names</h2><span id='topic+get_dim'></span><span id='topic+get_col'></span><span id='topic+get_row'></span>

<h3>Description</h3>

<p>Subset matrix dropping dimension but without dropping dimname
(as done by <code>`[`</code> by default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_col(matrix, rows, col)

get_row(matrix, row, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dim_+3A_matrix">matrix</code></td>
<td>
<p>matrix.</p>
</td></tr>
<tr><td><code id="get_dim_+3A_rows">rows</code></td>
<td>
<p>numeric; rows to subset; like with <code>`[`</code>, this argument can be left empty to designate all rows.</p>
</td></tr>
<tr><td><code id="get_dim_+3A_col">col</code></td>
<td>
<p>integer; single column to subset.</p>
</td></tr>
<tr><td><code id="get_dim_+3A_row">row</code></td>
<td>
<p>integer; single row to subset.</p>
</td></tr>
<tr><td><code id="get_dim_+3A_cols">cols</code></td>
<td>
<p>numeric; columns to subset; like with <code>`[`</code>, this argument can be left empty to designate all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>vector</code> object.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(NA,dimnames=list('r1','c1'))
m[1,1] # = NA; R removes both names
get_col(m,rows=1,col=1) # = c(r1=NA) keeps colname
get_row(m,row=1,cols=1) # = c(c1=NA) keeps rowname
</code></pre>

<hr>
<h2 id='mif2'>PIF: Panel iterated filtering</h2><span id='topic+mif2'></span><span id='topic+mif2d.ppomp-class'></span><span id='topic+mif2+2CpanelPomp-method'></span><span id='topic+mif2+2Cmif2d.ppomp-method'></span><span id='topic+traces+2Cmif2d.ppomp-method'></span>

<h3>Description</h3>

<p>Tools for applying iterated filtering algorithms to panel data.
The panel iterated filtering of Bret&oacute; et al. (2020) extends to
panel models the improved iterated filtering algorithm (Ionides et al.,
2015) for estimating parameters of a partially observed Markov process.
Iterated filtering algorithms rely on extending a partially observed Markov
process model of interest by introducing random perturbations to the model
parameters. The space where the original parameters live is then explored
at each iteration by running a particle filter. Convergence to a maximum
likelihood estimate has been established for appropriately constructed
procedures that iterate this search over the parameter space while
diminishing the intensity of perturbations (Ionides et al. 2006, 2011, 2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'panelPomp'
mif2(
  data,
  Nmif = 1,
  shared.start,
  specific.start,
  start,
  Np,
  rw.sd,
  cooling.type = c("hyperbolic", "geometric"),
  cooling.fraction.50,
  block = FALSE,
  verbose = getOption("verbose"),
  ...
)

## S4 method for signature 'mif2d.ppomp'
mif2(
  data,
  Nmif,
  shared.start,
  specific.start,
  start,
  Np,
  rw.sd,
  cooling.type,
  cooling.fraction.50,
  block,
  ...
)

## S4 method for signature 'mif2d.ppomp'
traces(object, pars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mif2_+3A_data">data</code></td>
<td>
<p>An object of class <code>panelPomp</code> or inheriting class.</p>
</td></tr>
<tr><td><code id="mif2_+3A_nmif">Nmif</code></td>
<td>
<p>The number of filtering iterations to perform.</p>
</td></tr>
<tr><td><code id="mif2_+3A_shared.start">shared.start</code></td>
<td>
<p>named numerical vector; the starting guess of the shared parameters.</p>
</td></tr>
<tr><td><code id="mif2_+3A_specific.start">specific.start</code></td>
<td>
<p>matrix with row parameter names and column unit names;
the starting guess of the specific parameters.</p>
</td></tr>
<tr><td><code id="mif2_+3A_start">start</code></td>
<td>
<p>A named numeric vector of parameters at which to start the IF2 procedure.</p>
</td></tr>
<tr><td><code id="mif2_+3A_np">Np</code></td>
<td>
<p>the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify <code>Np</code> either as a vector of positive integers of length </p>
<pre>length(time(object,t0=TRUE))</pre><p> or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on,
while when <code>T=length(time(object))</code>, <code>Np(T)</code> is the number of particles to sample at the end of the time-series.</p>
</td></tr>
<tr><td><code id="mif2_+3A_rw.sd">rw.sd</code></td>
<td>
<p>An unevaluated expression of the form <code>quote(rw.sd())</code> to
be used for all panel units. If a <code>list</code> of such expressions of the
same length as the <code>object</code> argument is provided, each list element
will be used for the corresponding panel unit.</p>
</td></tr>
<tr><td><code id="mif2_+3A_cooling.type">cooling.type</code>, <code id="mif2_+3A_cooling.fraction.50">cooling.fraction.50</code></td>
<td>
<p>specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
<code>cooling.type</code> specifies the nature of the cooling schedule.
See below (under &ldquo;Specifying the perturbations&rdquo;) for more detail.</p>
</td></tr>
<tr><td><code id="mif2_+3A_block">block</code></td>
<td>
<p>A logical variable determining whther to carry out block
resampling of unit-specific parameters.</p>
</td></tr>
<tr><td><code id="mif2_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
<tr><td><code id="mif2_+3A_...">...</code></td>
<td>
<p>....</p>
</td></tr>
<tr><td><code id="mif2_+3A_object">object</code></td>
<td>
<p>an object resulting from the application of IF2 (i.e., of
class <code>mif2d.ppomp</code>)</p>
</td></tr>
<tr><td><code id="mif2_+3A_pars">pars</code></td>
<td>
<p>names of parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mif2()</code> returns an object of class <code>mif2d.ppomp</code>.
</p>
<p><code>traces()</code> returns a <code>matrix</code> with estimated parameter values at
different iterations of the IF2 algorithm in the natural scale. The default
is to return values for all parameters but a subset of parameters can be
passed via the optional argument <code>pars</code>.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>References</h3>

<p>Bret&oacute;, C., Ionides, E. L. and King, A. A. (2020) Panel Data Analysis via Mechanistic Models. <em>Journal of the American Statistical Association</em>, <b>115</b>(531), 1178&ndash;1188. <a href="https://doi.org/10.1080/01621459.2019.1604367">doi:10.1080/01621459.2019.1604367</a>
</p>
<p>Ionides, E. L., Bret&oacute;, C. and King, A. A. (2006) Inference for nonlinear dynamical systems. <em>Proceedings of the National Academy of Sciences</em>, <b>103</b>(49), 18438&ndash;18443. <a href="https://doi.org/10.1073/pnas.0603181103">doi:10.1073/pnas.0603181103</a>
</p>
<p>Ionides, E. L., Bhadra, A., Atchad&eacute;, Y. and King, A. A. (2011) Iterated filtering. <em>Annals of Statistics</em>, <b>39</b>(3), 1776&ndash;1802. <a href="https://doi.org/10.1214/11-AOS886">doi:10.1214/11-AOS886</a>
</p>
<p>Ionides, E. L., Nguyen, D., Atchad&eacute;, Y., Stoev, S. and King, A. A. (2015) Inference via iterated, perturbed Bayes maps. <em>Proceedings of the National Academy of Sciences</em>, <b>112</b>(3), 719&ndash;724. <a href="https://doi.org/10.1073/pnas.1410597112">doi:10.1073/pnas.1410597112</a>
</p>
<p>King, A. A., Nguyen, D. and Ionides, E. L. (2016) Statistical inference for partially observed Markov processes via the package <span class="pkg">pomp</span>. <em>Journal of Statistical Software</em> <b>69</b>(12), 1&ndash;43. <abbr><span class="acronym">DOI</span></abbr>: 10.18637/jss.v069.i12. An updated version of this paper is available on the <a href="https://kingaa.github.io/pomp/docs.html">package website</a>.
</p>


<h3>See Also</h3>

<p><span class="pkg">pomp</span>'s mif2 at <a href="pomp.html#topic+mif2+2Cpomp-method">mif2</a>,
<a href="#topic+panel_loglik">panel_loglik</a>
</p>
<p>Other panelPomp workhorse functions: 
<code><a href="#topic+panelPomp">panelPomp</a></code>,
<code><a href="#topic+panel_loglik">panel_loglik</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## start with a panelPomp object
p &lt;- panelRandomWalk()
## specify which parameters to estimate via rw_sd() and how fast to cool
mp &lt;- mif2(p,Np=10,rw.sd=rw_sd(X.0=0.2),cooling.fraction.50=0.5,cooling.type="geometric")
mp
## the object resulting from an initial estimation can be used as a new starting point
mmp &lt;- mif2(mp,Np=10,rw.sd=rw_sd(X.0=0.2),cooling.fraction.50=0.5,cooling.type="geometric")
mmp
## convergence can be partly diagnosed by checking estimates and likelihoods at different iterations
traces(mmp)
</code></pre>

<hr>
<h2 id='panel_loglik'>Handling of loglikelihood replicates</h2><span id='topic+panel_loglik'></span><span id='topic+logLik+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Handling of loglikelihood replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix'
logLik(object, repMargin, first = "aver", aver = "logmeanexp", se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel_loglik_+3A_object">object</code></td>
<td>
<p>Matrix with the same number of replicated estimates for each
panel unit loglikelihood.</p>
</td></tr>
<tr><td><code id="panel_loglik_+3A_repmargin">repMargin</code></td>
<td>
<p>The margin of the matrix having the replicates (1 for rows,
2 for columns).</p>
</td></tr>
<tr><td><code id="panel_loglik_+3A_first">first</code></td>
<td>
<p>Wether to <code>"aver"</code>(age replicates) or <code>"aggr"</code>(egate
units) before performing the other action.</p>
</td></tr>
<tr><td><code id="panel_loglik_+3A_aver">aver</code></td>
<td>
<p>How to average: <code>'logmeanexp'</code> to average on the likelihood
scale before taking logs or <code>'mean'</code> to average after taking logs (in
which case, which action is performed first does not change the result).</p>
</td></tr>
<tr><td><code id="panel_loglik_+3A_se">se</code></td>
<td>
<p>logical; whether to give standard errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>se = TRUE</code>, the jackknife se's from
<code>pomp::logmeanexp</code> are squared, summed and the squared root is taken.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector with the average panel log likelihood and, when
<code>se = TRUE</code>, the corresponding standard error.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>See Also</h3>

<p>Other panelPomp workhorse functions: 
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+panelPomp">panelPomp</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ulls &lt;- matrix(c(1,1.1,10.1,10),nr=2)
# when combining log likelihood estimates, the order in which aggregation and
# averaging are done can make a difference: panel_logmeanexp() implements the best
logLik(ulls,repMargin=1,first="aver",aver="logmeanexp")
logLik(ulls,repMargin=1,first="aggr",aver="mean",se=TRUE)
</code></pre>

<hr>
<h2 id='panel_logmeanexp'>Log-mean-exp for panels</h2><span id='topic+panel_logmeanexp'></span>

<h3>Description</h3>

<p><code>se = TRUE</code>, the jackknife se's from <code>logmeanexp</code> are
squared, summed and the squared root is taken.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel_logmeanexp(x, MARGIN, se = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel_logmeanexp_+3A_x">x</code></td>
<td>
<p>Matrix with the same number of replicated estimates for each panel
unit loglikelihood.</p>
</td></tr>
<tr><td><code id="panel_logmeanexp_+3A_margin">MARGIN</code></td>
<td>
<p>The dimension of the matrix that corresponds to a panel unit
and over which averaging occurs (1 indicates rows, 2 indicates columns).</p>
</td></tr>
<tr><td><code id="panel_logmeanexp_+3A_se">se</code></td>
<td>
<p>logical; whether to give standard errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value with the average panel log likelihood or, when
<code>se = TRUE</code>, a <code>numeric</code> vector adding the corresponding standard error.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>See Also</h3>

<p>panel_loglik
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ulls &lt;- matrix(c(1,1,10,10),nr=2)
panel_logmeanexp(ulls,MARGIN=2,se=TRUE)
</code></pre>

<hr>
<h2 id='panelGompertz'>Panel Gompertz model</h2><span id='topic+panelGompertz'></span>

<h3>Description</h3>

<p>Builds a collection of independent realizations from the
Gompertz model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panelGompertz(
  N = 100,
  U = 50,
  params = c(K = 1, r = 0.1, sigma = 0.1, tau = 0.1, X.0 = 1),
  seed = 12345678
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelGompertz_+3A_n">N</code></td>
<td>
<p>number of observations for each unit.</p>
</td></tr>
<tr><td><code id="panelGompertz_+3A_u">U</code></td>
<td>
<p>number of units.</p>
</td></tr>
<tr><td><code id="panelGompertz_+3A_params">params</code></td>
<td>
<p>parameter vector, assuming all units have the same parameters.</p>
</td></tr>
<tr><td><code id="panelGompertz_+3A_seed">seed</code></td>
<td>
<p>passed to the random number generator for simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>panelPomp</code> object.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides, Carles Bret&oacute;
</p>


<h3>References</h3>

<p>Bret&oacute;, C., Ionides, E. L. and King, A. A. (2020) Panel Data Analysis via Mechanistic Models. <em>Journal of the American Statistical Association</em>, <b>115</b>(531), 1178&ndash;1188. <a href="https://doi.org/10.1080/01621459.2019.1604367">doi:10.1080/01621459.2019.1604367</a>
</p>
<p>King, A. A., Nguyen, D. and Ionides, E. L. (2016) Statistical inference for partially observed Markov processes via the package <span class="pkg">pomp</span>. <em>Journal of Statistical Software</em> <b>69</b>(12), 1&ndash;43. <abbr><span class="acronym">DOI</span></abbr>: 10.18637/jss.v069.i12. An updated version of this paper is available on the <a href="https://kingaa.github.io/pomp/docs.html">package website</a>.
</p>


<h3>See Also</h3>

<p>Other panelPomp examples: 
<code><a href="#topic+contacts">contacts</a>()</code>,
<code><a href="#topic+panelRandomWalk">panelRandomWalk</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>panelGompertz()
</code></pre>

<hr>
<h2 id='panelGompertzLikelihood'>Likelihood for a panel Gompertz model via a Kalman filter</h2><span id='topic+panelGompertzLikelihood'></span>

<h3>Description</h3>

<p>Evaluates the likelihood function for a panel Gompertz model,
using a format convenient for maximization by optim() to obtain a maximum
likelihood estimate. Specifically, estimated and fixed parameters are
supplied by two different arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panelGompertzLikelihood(x, panelPompObject, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelGompertzLikelihood_+3A_x">x</code></td>
<td>
<p>named vector for a subset of parameters, corresponding to
those being estimated.</p>
</td></tr>
<tr><td><code id="panelGompertzLikelihood_+3A_panelpompobject">panelPompObject</code></td>
<td>
<p>a panel Gompertz model.</p>
</td></tr>
<tr><td><code id="panelGompertzLikelihood_+3A_params">params</code></td>
<td>
<p>named vector containing all the parameters of the panel Gompertz model. Estimated parameters are overwritten by x.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pg &lt;- panelGompertz(N=2,U=2)
panelGompertzLikelihood(coef(pg),pg,coef(pg))
</code></pre>

<hr>
<h2 id='panelPomp'>Constructing <code>panelPomp</code> objects</h2><span id='topic+panelPomp'></span><span id='topic+panelPomp-class'></span>

<h3>Description</h3>

<p>This function constructs <code>panelPomp</code> objects, representing
PanelPOMP models (as defined in Bret&oacute; et al., 2020). PanelPOMP models
involve multiple units, each of which can in turn be modeled by a POMP
model. Such POMP models can be encoded as a <code>list</code> of <code>pomp</code>
objects, a cornerstone that the <code>panelPomp</code> function can use to
construct the corresponding <code>panelPomp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panelPomp(object, shared, specific, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelPomp_+3A_object">object</code></td>
<td>
<p>required; either (i) a <code>list</code> of <code>pomp</code> objects; or
(ii) an object of class <code>panelPomp</code> or inheriting class
<code>panelPomp</code>.
</p>
<p>If <code>object</code> is a <code>list</code> of <code>pomp</code>s, the list must be named.
All these <code>pomp</code>s must either have no parameters or have the same
parameter names. (This is just a format requirement. <code>pomp</code> codes can
ignore any parameter that is irrelevant to any given panel unit.)
</p>
<p>If <code>object</code> is a <code>panelPomp</code> object, the function allows modifying
the shared and unit-specific configuration of <code>object</code>.</p>
</td></tr>
<tr><td><code id="panelPomp_+3A_shared">shared</code>, <code id="panelPomp_+3A_specific">specific</code></td>
<td>
<p>optional; these arguments depend on the type
of <code>object</code>.
</p>
<p>If <code>object</code> is a <code>list</code> of <code>pomp</code>s, <code>shared</code> must be a
numeric vector specifying parameter values shared among panel units.
<code>specific</code> must be a <code>matrix</code> with parameter values that are
unit-specific with rows naming parameters and columns naming units (these
names must match those of <code>object</code>). If no values are specified and
<code>object</code> has parameter values, these are set to be all unit-specific.
</p>
<p>If <code>object</code> is a <code>panelPomp</code> object, these arguments can still be
used as described above to modify the parameters of <code>object</code>.
Alternatively, the parameter configuration of <code>object</code> can be modified
providing only a character <code>shared</code> naming parameters of <code>object</code>
that should be shared (with values for parameters not originally shared
taken from the unit-specific parameters of the first panel unit of
<code>object</code>). <code>shared=NULL</code> sets all parameters as unit-specific.</p>
</td></tr>
<tr><td><code id="panelPomp_+3A_params">params</code></td>
<td>
<p>optional; a named numeric vector. In this case, the nature of
parameters is determined via a naming convention: names ending in
&ldquo;<code>[unit_name]</code>&rdquo; are assumed to denote unit-specific parameters;
all other names specify shared parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>panelPomp</code> object.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>References</h3>

<p>Bret&oacute;, C., Ionides, E. L. and King, A. A. (2020) Panel Data Analysis via Mechanistic Models. <em>Journal of the American Statistical Association</em>, <b>115</b>(531), 1178&ndash;1188. <a href="https://doi.org/10.1080/01621459.2019.1604367">doi:10.1080/01621459.2019.1604367</a>
</p>
<p>King, A. A., Nguyen, D. and Ionides, E. L. (2016) Statistical inference for partially observed Markov processes via the package <span class="pkg">pomp</span>. <em>Journal of Statistical Software</em> <b>69</b>(12), 1&ndash;43. <abbr><span class="acronym">DOI</span></abbr>: 10.18637/jss.v069.i12. An updated version of this paper is available on the <a href="https://kingaa.github.io/pomp/docs.html">package website</a>.
</p>


<h3>See Also</h3>

<p><span class="pkg">pomp</span>'s constructor at <a href="pomp.html#topic+pomp">pomp</a>
</p>
<p>Other panelPomp workhorse functions: 
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+panel_loglik">panel_loglik</a></code>,
<code><a href="#topic+pfilter">pfilter</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## recreate the 'panelRandomWalk()' example
prw &lt;- panelRandomWalk()
prw2 &lt;- panelPomp(unitobjects(prw),params=coef(prw))
identical(prw,prw2) # TRUE
</code></pre>

<hr>
<h2 id='panelPomp_methods'>Manipulating <code>panelPomp</code> objects</h2><span id='topic+panelPomp_methods'></span><span id='topic+coef+2CpanelPomp-method'></span><span id='topic+coef+3C-+2CpanelPomp-method'></span><span id='topic+length+2CpanelPomp-method'></span><span id='topic+names+2CpanelPomp-method'></span><span id='topic+pparams+2CpanelPomp-method'></span><span id='topic+pParams'></span><span id='topic+print+2CpanelPomp-method'></span><span id='topic+show+2CpanelPomp-method'></span><span id='topic+unitobjects+2CpanelPomp-method'></span><span id='topic+window+2CpanelPomp-method'></span><span id='topic++5B+2CpanelPomp-method'></span><span id='topic++5B+5B+2CpanelPomp-method'></span>

<h3>Description</h3>

<p>Tools for manipulating <code>panelPomp</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'panelPomp'
coef(object)

## S4 replacement method for signature 'panelPomp'
coef(object, ...) &lt;- value

## S4 method for signature 'panelPomp'
length(x)

## S4 method for signature 'panelPomp'
names(x)

## S4 method for signature 'panelPomp'
pparams(object)

pParams(value)

## S4 method for signature 'panelPomp'
print(x, ...)

## S4 method for signature 'panelPomp'
show(object)

## S4 method for signature 'panelPomp'
unitobjects(object)

## S4 method for signature 'panelPomp'
window(x, start, end)

## S4 method for signature 'panelPomp'
x[i]

## S4 method for signature 'panelPomp'
x[[i]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelPomp_methods_+3A_object">object</code>, <code id="panelPomp_methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>panelPomp</code> or inheriting class
<code>panelPomp</code>.</p>
</td></tr>
<tr><td><code id="panelPomp_methods_+3A_...">...</code></td>
<td>
<p>....</p>
</td></tr>
<tr><td><code id="panelPomp_methods_+3A_value">value</code></td>
<td>
<p>value to be assigned.</p>
</td></tr>
<tr><td><code id="panelPomp_methods_+3A_start">start</code>, <code id="panelPomp_methods_+3A_end">end</code></td>
<td>
<p>position in original <code>times(pomp)</code> at which to start.</p>
</td></tr>
<tr><td><code id="panelPomp_methods_+3A_i">i</code></td>
<td>
<p>unit index (indices) or name (names).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef()</code> returns a <code>numeric</code> vector.
</p>
<p><code>length()</code> returns an <code>integer</code>.
</p>
<p><code>names()</code> returns a <code>character</code> vector.
</p>
<p>When given objects of class <code>panelPomp</code>, <code>pparams()</code> returns a named list with two elements: <code>shared</code>, which is a named <code>numeric</code> vector, and <code>specific</code>, which is a <code>matrix</code> with parameter names in its row names and panel unit names in its column names.
</p>
<p><code>pParams()</code> returns a <code>list</code> with the model parameters in list form.
</p>
<p>When given objects of class <code>panelPomp</code>, <code>unitobjects()</code> returns a <code>list</code> of <code>pomp</code> objects.
</p>
<p><code>window()</code> returns a <code>panelPomp</code> object with adjusted times.
</p>
<p><code>`[`</code> returns a <code>panelPomp</code> object.
</p>
<p><code>`[[`</code> returns a <code>pomp</code> object.
</p>


<h3>Methods</h3>


<dl>
<dt>coef</dt><dd><p>Extracts coefficients of <code>panelPomp</code> objects.</p>
</dd>
<dt>coef&lt;-</dt><dd><p>Assign coefficients to <code>panelPomp</code> objects.</p>
</dd>
<dt>length</dt><dd><p>Count the number of units in <code>panelPomp</code> objects.</p>
</dd>
<dt>names</dt><dd><p>Get the unit names of <code>panelPomp</code> objects.</p>
</dd>
<dt>pparams</dt><dd><p>Extracts coefficients from <code>panelPomp</code> objects in list form.</p>
</dd>
<dt>pParams</dt><dd><p>Converts panel coefficients from vector form to list form.</p>
</dd>
<dt>window</dt><dd><p>Subset <code>panelPomp</code> objects by changing start time and
end time.</p>
</dd>
<dt><code>[]</code></dt><dd><p>Take a subset of units.</p>
</dd>
<dt><code>[[]]</code></dt><dd><p>Select the pomp object for a single unit.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Carles Bret&oacute;, Aaron A. King.
</p>


<h3>See Also</h3>

<p>Other panelPomp methods: 
<code><a href="#topic+as">as</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## access and manipulate model parameters and other features
prw &lt;- panelRandomWalk()
coef(prw)
# replace coefficients
coef(prw) &lt;- c(sigmaX=2,coef(prw)[-1])
coef(prw)
length(prw)
names(prw)
# extract parameters in list form
pparams(prw)
# convert vector-form parameters to list-form parameters
pParams(coef(prw))
## summaries of objects
print(prw)
show(prw)
## access underlying pomp objects
unitobjects(prw)
## select windows of time
window(prw,start=2,end=4)
## subsetting panelPomp objects
prw[1] # panelPomp of 1 unit (first unit of prw)
prw[[2]] # pomp object corresponding to unit 2 of prw
</code></pre>

<hr>
<h2 id='panelRandomWalk'>Panel random walk model</h2><span id='topic+panelRandomWalk'></span>

<h3>Description</h3>

<p>Builds a collection of independent realizations from a random
walk model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panelRandomWalk(
  N = 5,
  U = 2,
  params = c(sigmaY = 1, sigmaX = 1, X.0 = 1),
  seed = 3141592
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panelRandomWalk_+3A_n">N</code></td>
<td>
<p>number of observations for each unit.</p>
</td></tr>
<tr><td><code id="panelRandomWalk_+3A_u">U</code></td>
<td>
<p>number of units.</p>
</td></tr>
<tr><td><code id="panelRandomWalk_+3A_params">params</code></td>
<td>
<p>parameter vector, assuming all units have the same parameters.</p>
</td></tr>
<tr><td><code id="panelRandomWalk_+3A_seed">seed</code></td>
<td>
<p>passed to the random number generator for simulation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>panelPomp</code> object.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides, Carles Bret&oacute;
</p>


<h3>See Also</h3>

<p>Other panelPomp examples: 
<code><a href="#topic+contacts">contacts</a>()</code>,
<code><a href="#topic+panelGompertz">panelGompertz</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>panelRandomWalk()
</code></pre>

<hr>
<h2 id='params'>Convert to and from a <code>panelPomp</code> object <code>pParams</code> slot format and a one-row <code>data.frame</code></h2><span id='topic+params'></span><span id='topic+toVectorPparams'></span><span id='topic+fromVectorPparams'></span><span id='topic+toMatrixPparams'></span>

<h3>Description</h3>

<p>These facilitate keeping a record of evaluated log likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toVectorPparams(pParams)

fromVectorPparams(vec_pars)

toMatrixPparams(listPparams)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_+3A_pparams">pParams</code></td>
<td>
<p>A list with the format of the <code>pParams</code> slot of <code>panelPomp</code> objects.</p>
</td></tr>
<tr><td><code id="params_+3A_vec_pars">vec_pars</code></td>
<td>
<p>A one-row <code>data.frame</code> with format matching that of the
output of <a href="#topic+toVectorPparams">toVectorPparams</a>.</p>
</td></tr>
<tr><td><code id="params_+3A_listpparams">listPparams</code></td>
<td>
<p>PanelPomp parameters in list format</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>toVectorPparams()</code> returns an object of class <code>data.frame</code>.
</p>
<p><code>fromVectorPparams()</code> returns an object of class <code>list</code> with the
model parameters in list form.
</p>
<p><code>toMatrixPparams()</code> returns an object of class <code>matrix</code> with the
model parameters in matrix form.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prw &lt;- panelRandomWalk()
toVectorPparams(pparams(prw))
fromVectorPparams(toVectorPparams(pparams(prw)))
toMatrixPparams(pparams(prw))
</code></pre>

<hr>
<h2 id='pfilter'>Particle filtering for panel data</h2><span id='topic+pfilter'></span><span id='topic+pfilterd.ppomp-class'></span><span id='topic+pfilter+2CpanelPomp-method'></span><span id='topic+logLik+2Cpfilterd.ppomp-method'></span><span id='topic+unitlogLik+2Cpfilterd.ppomp-method'></span>

<h3>Description</h3>

<p>Tools for applying particle filtering algorithms to panel data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'panelPomp'
pfilter(
  data,
  shared,
  specific,
  params,
  Np,
  verbose = getOption("verbose"),
  ...
)

## S4 method for signature 'pfilterd.ppomp'
logLik(object, ...)

## S4 method for signature 'pfilterd.ppomp'
unitlogLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pfilter_+3A_data">data</code></td>
<td>
<p>An object of class <code>panelPomp</code> or inheriting class
<code>panelPomp</code>.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_shared">shared</code>, <code id="pfilter_+3A_specific">specific</code></td>
<td>
<p>optional; these arguments depend on the type
of <code>object</code>.
</p>
<p>If <code>object</code> is a <code>list</code> of <code>pomp</code>s, <code>shared</code> must be a
numeric vector specifying parameter values shared among panel units.
<code>specific</code> must be a <code>matrix</code> with parameter values that are
unit-specific with rows naming parameters and columns naming units (these
names must match those of <code>object</code>). If no values are specified and
<code>object</code> has parameter values, these are set to be all unit-specific.
</p>
<p>If <code>object</code> is a <code>panelPomp</code> object, these arguments can still be
used as described above to modify the parameters of <code>object</code>.
Alternatively, the parameter configuration of <code>object</code> can be modified
providing only a character <code>shared</code> naming parameters of <code>object</code>
that should be shared (with values for parameters not originally shared
taken from the unit-specific parameters of the first panel unit of
<code>object</code>). <code>shared=NULL</code> sets all parameters as unit-specific.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_params">params</code></td>
<td>
<p>optional; a named numeric vector. In this case, the nature of
parameters is determined via a naming convention: names ending in
&ldquo;<code>[unit_name]</code>&rdquo; are assumed to denote unit-specific parameters;
all other names specify shared parameters.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_np">Np</code></td>
<td>
<p>the number of particles to use.
This may be specified as a single positive integer, in which case the same number of particles will be used at each timestep.
Alternatively, if one wishes the number of particles to vary across timesteps, one may specify <code>Np</code> either as a vector of positive integers of length </p>
<pre>length(time(object,t0=TRUE))</pre><p> or as a function taking a positive integer argument.
In the latter case, <code>Np(k)</code> must be a single positive integer, representing the number of particles to be used at the <code>k</code>-th timestep:
<code>Np(0)</code> is the number of particles to use going from <code>timezero(object)</code> to <code>time(object)[1]</code>,
<code>Np(1)</code>, from <code>timezero(object)</code> to <code>time(object)[1]</code>,
and so on,
while when <code>T=length(time(object))</code>, <code>Np(T)</code> is the number of particles to sample at the end of the time-series.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to the <code>pfilter</code> method of <span class="pkg">pomp</span>.</p>
</td></tr>
<tr><td><code id="pfilter_+3A_object">object</code></td>
<td>
<p>required; either (i) a <code>list</code> of <code>pomp</code> objects; or
(ii) an object of class <code>panelPomp</code> or inheriting class
<code>panelPomp</code>.
</p>
<p>If <code>object</code> is a <code>list</code> of <code>pomp</code>s, the list must be named.
All these <code>pomp</code>s must either have no parameters or have the same
parameter names. (This is just a format requirement. <code>pomp</code> codes can
ignore any parameter that is irrelevant to any given panel unit.)
</p>
<p>If <code>object</code> is a <code>panelPomp</code> object, the function allows modifying
the shared and unit-specific configuration of <code>object</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>pfilter()</code> returns an object of class <code>pfilterd.ppomp</code> that is also
a <code>panelPomp</code> object (with the additional filtering details).
</p>
<p>When applied to an object of class <code>pfilterd.ppomp</code>, <code>logLik()</code>
returns a <code>numeric</code> value.
</p>
<p>When given objects of class <code>pfilterd.ppomp</code>, <code>unitloglik()</code> returns a <code>numeric</code> vector.
</p>


<h3>Methods</h3>


<dl>
<dt>logLik</dt><dd><p>Extracts the estimated log likelihood for the entire panel.</p>
</dd>
<dt>unitlogLik</dt><dd><p>Extracts the estimated log likelihood for each panel unit.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>References</h3>

<p>Arulampalam, M. S., Maskell, S., Gordon, N. and Clapp, T. (2002) A Tutorial on Particle Filters for Online Nonlinear/Non-Gaussian Bayesian Tracking. <em>IEEE Trans. Sig. Proc.</em>, <b>50</b>(2), 174&ndash;188. <a href="https://doi.org/10.1109/78.978374">doi:10.1109/78.978374</a>
</p>
<p>Bret&oacute;, C., Ionides, E. L. and King, A. A. (2020) Panel Data Analysis via Mechanistic Models. <em>Journal of the American Statistical Association</em>, <b>115</b>(531), 1178&ndash;1188. <a href="https://doi.org/10.1080/01621459.2019.1604367">doi:10.1080/01621459.2019.1604367</a>
</p>


<h3>See Also</h3>

<p><span class="pkg">pomp</span>'s pfilter at <a href="pomp.html#topic+pfilter+2Cpomp-method">pfilter</a>, <a href="#topic+panel_loglik">panel_loglik</a>
</p>
<p>Other panelPomp workhorse functions: 
<code><a href="#topic+mif2">mif2</a>()</code>,
<code><a href="#topic+panelPomp">panelPomp</a></code>,
<code><a href="#topic+panel_loglik">panel_loglik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># filter, which generates log likelihoods
pfrw &lt;- pfilter(panelRandomWalk(),Np=10)
class(pfrw) # "pfilterd.ppomp"
is(pfrw,"panelPomp") # TRUE
pfrw
# extract single log likelihood for the entire panel
logLik(pfrw)
# extract log likelihood for each panel unit
unitlogLik(pfrw)
</code></pre>

<hr>
<h2 id='plot'>panelPomp plotting facilities</h2><span id='topic+plot'></span><span id='topic+plot+2CpanelPomp_plottable-method'></span>

<h3>Description</h3>

<p>Diagnostic plots for each unit in a panelPomp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'panelPomp_plottable'
plot(
  x,
  variables,
  panel = lines,
  nc = NULL,
  yax.flip = FALSE,
  mar = c(0, 5.1, 0, if (yax.flip) 5.1 else 2.1),
  oma = c(6, 0, 5, 0),
  axes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>the object to plot</p>
</td></tr>
<tr><td><code id="plot_+3A_variables">variables</code></td>
<td>
<p>optional character; names of variables to be displayed</p>
</td></tr>
<tr><td><code id="plot_+3A_panel">panel</code></td>
<td>
<p>function of prototype <code>panel(x, col, bg, pch, type, ...)</code> which gives the action to be carried out in each panel of the display.</p>
</td></tr>
<tr><td><code id="plot_+3A_nc">nc</code></td>
<td>
<p>the number of columns to use.
Defaults to 1 for up to 4 series, otherwise to 2.</p>
</td></tr>
<tr><td><code id="plot_+3A_yax.flip">yax.flip</code></td>
<td>
<p>logical;
if TRUE, the y-axis (ticks and numbering) should flip from side 2 (left) to 4 (right) from series to series.</p>
</td></tr>
<tr><td><code id="plot_+3A_mar">mar</code>, <code id="plot_+3A_oma">oma</code></td>
<td>
<p>the <code><a href="graphics.html#topic+par">par</a></code> <code>mar</code> and <code>oma</code> settings.
Modify with care!</p>
</td></tr>
<tr><td><code id="plot_+3A_axes">axes</code></td>
<td>
<p>logical; indicates if x- and y- axes should be drawn</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>ignored or passed to low-level plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value (the function returns <code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(panelRandomWalk())
</code></pre>

<hr>
<h2 id='pparams'>Extract parameters (coefficients) of a panel model</h2><span id='topic+pparams'></span>

<h3>Description</h3>

<p><code>pparams()</code> is a generic function that extracts parameter
(coefficient) values from objects returned by panel modeling functions. While
the named <code>numeric</code> vector format is useful and possible via S4 methods
for <code>coef()</code>, alternative formats capturing the panel structure can be
implemented via <code>pparams()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pparams(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pparams_+3A_object">object</code></td>
<td>
<p>an object for which extraction of panel model parameter
(coefficient) values is meaningful.</p>
</td></tr>
<tr><td><code id="pparams_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function: methods can be defined for it.
</p>


<h3>Value</h3>

<p>Parameter (coefficient) values extracted from the panel model
<code>object</code>.
</p>
<p>When given objects of class <code>panelPomp</code>, <code>pparams()</code> returns a named list with two elements: <code>shared</code>, which is a named <code>numeric</code> vector, and <code>specific</code>, which is a <code>matrix</code> with parameter names in its row names and panel unit names in its column names.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>See Also</h3>

<p><a href="#topic+panelPomp_methods">panelPomp_methods</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prw &lt;- panelRandomWalk()
# extract parameters in list form
pparams(prw)
</code></pre>

<hr>
<h2 id='simulate'>Simulations of a panel of partially observed Markov process</h2><span id='topic+simulate'></span><span id='topic+simulate+2CpanelPomp-method'></span>

<h3>Description</h3>

<p><code>simulate</code> generates simulations of the state and measurement
processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'panelPomp'
simulate(object, nsim = 1, shared, specific)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>a <code>panelPomp</code> object.</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to perform. Unlike the pomp
simulate method, all simulations share the same parameters.</p>
</td></tr>
<tr><td><code id="simulate_+3A_shared">shared</code></td>
<td>
<p>Named vector of the shared parameters.</p>
</td></tr>
<tr><td><code id="simulate_+3A_specific">specific</code></td>
<td>
<p>Matrix of unit-specific parameters, with a column
for each unit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single panelPomp object (if nsim=1) or a list of <code>panelPomp</code> objects
(if nsim&gt;1).
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simulate(panelRandomWalk())
</code></pre>

<hr>
<h2 id='unitlogLik'>Extract log likelihood of units of panel models</h2><span id='topic+unitlogLik'></span>

<h3>Description</h3>

<p><code>unitlogLik()</code> is a generic function that extracts the log
likelihood for each unit of panel objects returned by panel modeling functions.
While the <code>numeric</code> value with the log likelihood for the entire panel
is useful and possible via S4 methods <code>logLik()</code>, the contributions to it
by panel units can be implemented via <code>unitlogLik()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitlogLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitlogLik_+3A_object">object</code></td>
<td>
<p>an object for which log likelihood values for units can be extracted.</p>
</td></tr>
<tr><td><code id="unitlogLik_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function: methods can be defined for it.
</p>


<h3>Value</h3>

<p>Log likelihood extracted for each unit of the panel model <code>object</code>.
</p>
<p>When given objects of class <code>pfilterd.ppomp</code>, <code>unitloglik()</code> returns a <code>numeric</code> vector.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>See Also</h3>

<p><a href="#topic+pfilter">pfilter</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># filter, which generates log likelihoods
pfrw &lt;- pfilter(panelRandomWalk(),Np=10)
# extract log likelihood for each panel unit
unitlogLik(pfrw)
</code></pre>

<hr>
<h2 id='unitobjects'>Extract units of a panel model</h2><span id='topic+unitobjects'></span>

<h3>Description</h3>

<p><code>unitobjects()</code> is a generic function that extracts a list
of objects corresponding to units of panel objects returned by panel modeling
functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitobjects(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitobjects_+3A_object">object</code></td>
<td>
<p>an object for which extraction of panel units is meaningful.</p>
</td></tr>
<tr><td><code id="unitobjects_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function: methods can be defined for it.
</p>


<h3>Value</h3>

<p>Units extracted from the panel model <code>object</code>.
</p>
<p>When given objects of class <code>panelPomp</code>, <code>unitobjects()</code> returns a <code>list</code> of <code>pomp</code> objects.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>See Also</h3>

<p><a href="#topic+panelPomp_methods">panelPomp_methods</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prw &lt;- panelRandomWalk()
## access underlying pomp objects
unitobjects(prw)
</code></pre>

<hr>
<h2 id='wQuotes'>Interpret shortcuts for <code>sQuote()</code>s and <code>dQuote()</code>s in
character objects</h2><span id='topic+wQuotes'></span>

<h3>Description</h3>

<p>Concatenate character objects and replace double quotes with
<code>sQuote()</code> (write <code>''x''</code> instead of <code>dQuote("x")</code>) and
replace asterisks with <code>dQuote()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wQuotes(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wQuotes_+3A_...">...</code></td>
<td>
<p>objects to be passed to <code>strsplit</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> object.
</p>


<h3>Author(s)</h3>

<p>Carles Bret&oacute;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>paste0("in ",sQuote("fn_name"),": ",dQuote("object")," is 'a' required argument")
wQuotes("in ''fn_name'': *object* is 'a' required argument") # same but shorter
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
