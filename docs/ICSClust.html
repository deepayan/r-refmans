<!DOCTYPE html><html><head><title>Help for package ICSClust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICSClust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ICSClust-package'><p>Tandem Clustering with Invariant Coordinate Selection</p></a></li>
<li><a href='#component_plot'><p>Scatterplot Matrix with densities on the diagonal</p></a></li>
<li><a href='#discriminatory_crit'><p>Selection of ICS components based on discriminatory power</p></a></li>
<li><a href='#ICS_lcov'><p>Local Shape Scatter Estimates for ICS</p></a></li>
<li><a href='#ICS_mcd'><p>MCD location and Scatter Estimates for ICS</p></a></li>
<li><a href='#ICS_mlc'><p>Cauchy location and Scatter Estimates for ICS</p></a></li>
<li><a href='#ICS_tcov'><p>Pairwise one-step M-estimate of scatter for ICS</p></a></li>
<li><a href='#ICS_ucov'><p>Simple robust estimates of scatter for ICS</p></a></li>
<li><a href='#ICSClust'><p>Tandem clustering with ICS</p></a></li>
<li><a href='#kmeans_clust'><p><em>k</em>-means clustering</p></a></li>
<li><a href='#mclust_clust'><p>Model-Based Clustering</p></a></li>
<li><a href='#med_crit'><p>Selection of Invariant components using the med criterion</p></a></li>
<li><a href='#mixture_sim'><p>Simulation of a mixture of Gaussian distributions</p></a></li>
<li><a href='#normal_crit'><p>Selection of Non-normal Invariant Components Using Marginal</p>
Normality Tests</a></li>
<li><a href='#pam_clust'><p>Partitioning Around Medoids clustering</p></a></li>
<li><a href='#plot.ICSClust'><p>Scatterplot Matrix with densities on the diagonal</p></a></li>
<li><a href='#print.ICSClust_summary'><p>Print of an <code>ICSClust_summary</code> object</p></a></li>
<li><a href='#rimle_clust'><p>Robust Improper Maximum Likelihood Clustering</p></a></li>
<li><a href='#runif_outside_range'><p>Uniform distribution outside a given range</p></a></li>
<li><a href='#select_plot'><p>Plot of the Generalized Kurtosis Values of the ICS Transformation</p></a></li>
<li><a href='#summary.ICSClust'><p>Summary of an <code>ICSClust</code> object</p></a></li>
<li><a href='#tcov'><p>Pairwise one-step M-estimate of scatter</p></a></li>
<li><a href='#tkmeans_clust'><p>Trimmed k-means clustering</p></a></li>
<li><a href='#ucov'><p>Simple robust estimates of scatter</p></a></li>
<li><a href='#var_crit'><p>Selection of Invariant components using the var criterion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tandem Clustering with Invariant Coordinate Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of tandem clustering with invariant coordinate 
              selection with different scatter matrices and several choices for the 
              selection of components as described in Alfons, A., Archimbaud, A., Nordhausen, K.and Ruiz-Gazen, A. (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2212.06108">doi:10.48550/arXiv.2212.06108</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>ICS (&ge; 1.4-0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, fpc, GGally, heplots, mclust, moments, mvtnorm,
otrimle, RcppRoll, rrcov, scales, tclust</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/AuroreAA/ICSClust">https://github.com/AuroreAA/ICSClust</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/AuroreAA/ICSClust/issues">https://github.com/AuroreAA/ICSClust/issues</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Aurore Archimbaud <a href="https://orcid.org/0000-0002-6511-9091"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Andreas Alfons <a href="https://orcid.org/0000-0002-2513-3788"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Anne Ruiz-Gazen <a href="https://orcid.org/0000-0001-8970-8061"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aurore Archimbaud &lt;aurore.archimbaud@live.fr&gt;</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-20 16:53:56 UTC; auror</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-21 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ICSClust-package'>Tandem Clustering with Invariant Coordinate Selection</h2><span id='topic+ICSClust-package'></span>

<h3>Description</h3>

<p>Implementation of tandem clustering with invariant coordinate 
              selection with different scatter matrices and several choices for the 
              selection of components as described in Alfons, A., Archimbaud, A., Nordhausen, K.and Ruiz-Gazen, A. (2022) &lt;arXiv:2212.06108&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ICSClust</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Tandem Clustering with Invariant Coordinate Selection</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-20</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementation of tandem clustering with invariant coordinate 
              selection with different scatter matrices and several choices for the 
              selection of components as described in Alfons, A., Archimbaud, A., Nordhausen, K.and Ruiz-Gazen, A. (2022) &lt;arXiv:2212.06108&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> ICS (&gt;= 1.4-0), ggplot2</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> cluster, fpc, GGally, heplots, mclust, moments, mvtnorm,
otrimle, RcppRoll, rrcov, scales, tclust</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> testthat (&gt;= 3.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/AuroreAA/ICSClust</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/AuroreAA/ICSClust/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person("Aurore", "Archimbaud", 
             email = "aurore.archimbaud@live.fr", 
             role = c("aut", "cre"),
             comment = c(ORCID = "0000-0002-6511-9091")),
      person("Andreas", "Alfons", 
             email = "alfons@ese.eur.nl", 
             role = "aut",
             comment = c(ORCID = "0000-0002-2513-3788")),
      person("Klaus", "Nordhausen", 
             email = "klausnordhausenR@jyu.fi",
             role = "aut", 
             comment = c(ORCID = "0000-0002-3758-8501")),
      person("Anne", "Ruiz-Gazen", 
             email = "anne.ruiz-gazen@tse-fr.eu",
             role = "aut", 
             comment = c(ORCID = "0000-0001-8970-8061")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> 
    Aurore Archimbaud [aut, cre] (&lt;https://orcid.org/0000-0002-6511-9091&gt;),
    Andreas Alfons [aut] (&lt;https://orcid.org/0000-0002-2513-3788&gt;), 
    Klaus Nordhausen [aut] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Aurore Archimbaud &lt;aurore.archimbaud@live.fr&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Roxygen: </td><td style="text-align: left;"> list(markdown = TRUE)</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Config/testthat/edition: </td><td style="text-align: left;"> 3</td>
</tr>
<tr>
 <td style="text-align: left;">
Archs: </td><td style="text-align: left;"> x64</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
ICSClust                Tandem clustering with ICS
ICSClust-package        Tandem Clustering with Invariant Coordinate
                        Selection
ICS_lcov                Local Shape Scatter Estimates for ICS
ICS_mcd                 MCD location and Scatter Estimates for ICS
ICS_mlc                 Cauchy location and Scatter Estimates for ICS
ICS_tcov                Pairwise one-step M-estimate of scatter for ICS
ICS_ucov                Simple robust estimates of scatter for ICS
component_plot          Scatterplot Matrix with densities on the
                        diagonal
discriminatory_crit     Selection of ICS components based on
                        discriminatory power
kmeans_clust            _k_-means clustering
mclust_clust            Model-Based Clustering
med_crit                Selection of Invariant components using the med
                        criterion
mixture_sim             Simulation of a mixture of Gaussian
                        distributions
normal_crit             Selection of Non-normal Invariant Components
                        Using Marginal Normality Tests
pam_clust               Partitioning Around Medoids clustering
plot.ICSClust           Scatterplot Matrix with densities on the
                        diagonal
print.ICSClust_summary
                        Print of an 'ICSClust_summary' object
rimle_clust             Robust Improper Maximum Likelihood Clustering
runif_outside_range     Uniform distribution outside a given range
select_plot             Plot of the Generalized Kurtosis Values of the
                        ICS Transformation
summary.ICSClust        Summary of an 'ICSClust' object
tcov                    Pairwise one-step M-estimate of scatter
tkmeans_clust           Trimmed k-means clustering
ucov                    Simple robust estimates of scatter
var_crit                Selection of Invariant components using the var
                        criterion
</pre>


<h3>Author(s)</h3>


<p>    Aurore Archimbaud [aut, cre] (&lt;https://orcid.org/0000-0002-6511-9091&gt;),
    Andreas Alfons [aut] (&lt;https://orcid.org/0000-0002-2513-3788&gt;), 
    Klaus Nordhausen [aut] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Anne Ruiz-Gazen [aut] (&lt;https://orcid.org/0000-0001-8970-8061&gt;)
</p>
<p>Maintainer: Aurore Archimbaud &lt;aurore.archimbaud@live.fr&gt;
</p>


<h3>References</h3>

<p>Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>.
</p>

<hr>
<h2 id='component_plot'>Scatterplot Matrix with densities on the diagonal</h2><span id='topic+component_plot'></span>

<h3>Description</h3>

<p>Produces a gg-scatterplot matrix of the variables of a given dataframe
or an invariant coordinate system obtained via an ICS transformation with
densities on the diagonal for each cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component_plot(
  object,
  select = TRUE,
  clusters = NULL,
  text_size_factor = 8/6.5,
  colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="component_plot_+3A_object">object</code></td>
<td>
<p>a dataframe or <code><a href="ICS.html#topic+ICS-S3">ICS</a></code> class object.</p>
</td></tr>
<tr><td><code id="component_plot_+3A_select">select</code></td>
<td>
<p>a vector of indexes of variables to plot. If <code>NULL</code> or
<code>FALSE</code>, all variables are selected. If <code>TRUE</code> only the first three and
last three are considered.</p>
</td></tr>
<tr><td><code id="component_plot_+3A_clusters">clusters</code></td>
<td>
<p>a vector indicating the clusters of the data to color the
plot. By default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="component_plot_+3A_text_size_factor">text_size_factor</code></td>
<td>
<p>a numeric factor for controlling the <code>axis.text</code>
and <code>strip.text</code>.</p>
</td></tr>
<tr><td><code id="component_plot_+3A_colors">colors</code></td>
<td>
<p>a vector of colors to use. One color for each cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="GGally.html#topic+ggmatrix">&quot;ggmatrix&quot;</a></code> (see
<code><a href="GGally.html#topic+ggpairs">GGally::ggpairs()</a></code>).
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,1:4]
component_plot(X)
out &lt;- ICS(X)
component_plot(out, select = c(1,4))

</code></pre>

<hr>
<h2 id='discriminatory_crit'>Selection of ICS components based on discriminatory power</h2><span id='topic+discriminatory_crit'></span><span id='topic+discriminatory_crit.ICS'></span><span id='topic+discriminatory_crit.default'></span>

<h3>Description</h3>

<p>Identifies invariant coordinates associated to the highest discriminatory
power (by default &quot;eta2&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discriminatory_crit(object, ...)

## S3 method for class 'ICS'
discriminatory_crit(
  object,
  clusters,
  method = "eta2",
  nb_select = NULL,
  select_only = FALSE,
  ...
)

## Default S3 method:
discriminatory_crit(
  object,
  clusters,
  method = "eta2",
  nb_select = NULL,
  select_only = FALSE,
  gen_kurtosis = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discriminatory_crit_+3A_object">object</code></td>
<td>
<p>dataframe or object of class <code>"ICS"</code>.</p>
</td></tr>
<tr><td><code id="discriminatory_crit_+3A_...">...</code></td>
<td>
<p>additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="discriminatory_crit_+3A_clusters">clusters</code></td>
<td>
<p>a vector of the same length as the number of
observations, indicating the true clusters. It is used to compute
the discriminatory power based on it.</p>
</td></tr>
<tr><td><code id="discriminatory_crit_+3A_method">method</code></td>
<td>
<p>the name of the discriminatory power.
Only <code>"eta2"</code> is implemented.</p>
</td></tr>
<tr><td><code id="discriminatory_crit_+3A_nb_select">nb_select</code></td>
<td>
<p>the exact number of components to select.
By default it is set to <code>NULL</code>, i.e the number
of components to select is the number of clusters minus one.</p>
</td></tr>
<tr><td><code id="discriminatory_crit_+3A_select_only">select_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the vector names of the selected
invariant components are returned. If <code>FALSE</code> additional details are returned.</p>
</td></tr>
<tr><td><code id="discriminatory_crit_+3A_gen_kurtosis">gen_kurtosis</code></td>
<td>
<p>vector of generalized kurtosis values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The discriminatory power <code class="reqn">\eta^{2} = 1 - \Lambda</code>, where <code class="reqn">\Lambda</code>
denotes Wilks' lambda, is evaluated for each combination of the
first and/or last combinations of <code>nb_select</code> components. The combination
achieving the highest discriminatory power is selected.
</p>
<p>More specifically, we compute
</p>
<p style="text-align: center;"><code class="reqn">
\eta^{2} = 1 - \frac{\det(E)}{\det(T)},
</code>
</p>

<p>where <code class="reqn">E</code> is the within-group sum of squares and cross-products matrix
and <code class="reqn">T</code> is the total sum of squares and cross-products matrix.
</p>


<h3>Value</h3>

<p>If <code>select_only</code> is <code>TRUE</code> a vector of the names of the invariant
components or variables to select.
If <code>FALSE</code> an object of class <code>"ICS_crit"</code>
is returned with the following objects:
</p>

<ul>
<li> <p><code>crit</code>: the name of the criterion &quot;discriminatory&quot;.
</p>
</li>
<li> <p><code>method</code>: the name of the discriminatory power.
</p>
</li>
<li> <p><code>nb_select</code>: the number of components to select.
</p>
</li>
<li> <p><code>select</code>: the names of the invariant components or variables to select.
</p>
</li>
<li> <p><code>power_combinations</code>: the discriminatory values for each of the considered
combinations of <code>nb_select</code> components.
</p>
</li>
<li> <p><code>gen_kurtosis</code>: the vector of generalized kurtosis values in case of
<code>ICS</code> object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aurore Archimbaud and Anne Ruiz-Gazen
</p>


<h3>References</h3>

<p>Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normal_crit">normal_crit()</a></code>, <code><a href="#topic+med_crit">med_crit()</a></code>, <code><a href="#topic+var_crit">var_crit()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,-5]
out &lt;- ICS(X)
discriminatory_crit(out, clusters = iris[,5], select_only = FALSE)
</code></pre>

<hr>
<h2 id='ICS_lcov'>Local Shape Scatter Estimates for ICS</h2><span id='topic+ICS_lcov'></span>

<h3>Description</h3>

<p>It is a wrapper for the local shape estimator of scatter
as computed by <code><a href="fpc.html#topic+localshape">fpc::localshape()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS_lcov(x, mscatter = "cov", proportion = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICS_lcov_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="ICS_lcov_+3A_mscatter">mscatter</code></td>
<td>
<p><code>"mcd"</code> or <code>"cov"</code> (default); specified minimum covariance
determinant or classical covariance matrix to be used for Mahalanobis
distance computation.</p>
</td></tr>
<tr><td><code id="ICS_lcov_+3A_proportion">proportion</code></td>
<td>
<p>proportion of points to be considered as neighbourhood.</p>
</td></tr>
<tr><td><code id="ICS_lcov_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to <code><a href="fpc.html#topic+localshape">fpc::localshape()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ICS_scatter"</code> with the following
components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>this is NULL as the estimator does not use a
location estimate.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>a numeric matrix giving the estimate of the scatter matrix.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>a character string providing a label for the scatter matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="fpc.html#topic+localshape">fpc::localshape()</a></code>
</p>

<hr>
<h2 id='ICS_mcd'>MCD location and Scatter Estimates for ICS</h2><span id='topic+ICS_mcd'></span><span id='topic+ICS_mcd_raw'></span><span id='topic+ICS_mcd_rwt'></span>

<h3>Description</h3>

<p>It is a wrapper for the (reweighted) MCD estimators of location and scatter
as computed by <code><a href="rrcov.html#topic+CovMcd">rrcov::CovMcd()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS_mcd_raw(x, location = FALSE, nsamp = "deterministic", alpha = 0.5, ...)

ICS_mcd_rwt(x, location = FALSE, nsamp = "deterministic", alpha = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICS_mcd_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="ICS_mcd_+3A_location">location</code></td>
<td>
<p>a logical indicating whether to include the MCD-estimate of
location (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="ICS_mcd_+3A_nsamp">nsamp</code></td>
<td>
<p>number of subsets used for initial estimates or <code>"best"</code>,
<code>"exact"</code> or <code>"deterministic"</code> (default).</p>
</td></tr>
<tr><td><code id="ICS_mcd_+3A_alpha">alpha</code></td>
<td>
<p>numeric parameter controlling the size of the subsets over
which the determinant is minimized as in <code><a href="rrcov.html#topic+CovMcd">rrcov::CovMcd()</a></code>.</p>
</td></tr>
<tr><td><code id="ICS_mcd_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to <code><a href="rrcov.html#topic+CovMcd">rrcov::CovMcd()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+ICS_mcd_raw">ICS_mcd_raw()</a></code>: computes the raw MCD estimates.
</p>
</li>
<li> <p><code><a href="#topic+ICS_mcd_rwt">ICS_mcd_rwt()</a></code>: computes the reweighted MCD estimates.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"ICS_scatter"</code> with the following
components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>if requested, a numeric vector giving the location
estimate.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>a numeric matrix giving the estimate of the scatter matrix.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>a character string providing a label for the scatter matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="rrcov.html#topic+CovMcd">rrcov::CovMcd()</a></code>
</p>

<hr>
<h2 id='ICS_mlc'>Cauchy location and Scatter Estimates for ICS</h2><span id='topic+ICS_mlc'></span>

<h3>Description</h3>

<p>It is a wrapper for the Cauchy estimator of location and scatter
for a multivariate t-distribution, as computed by <code><a href="ICS.html#topic+tM">ICS::tM()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS_mlc(x, location = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICS_mlc_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="ICS_mlc_+3A_location">location</code></td>
<td>
<p>a logical indicating whether to include the M-estimate of
location (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="ICS_mlc_+3A_...">...</code></td>
<td>
<p>potential further arguments passed to <code><a href="ICS.html#topic+ICS_scatter">ICS::ICS_tM()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ICS_scatter"</code> with the following
components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>if requested, a numeric vector giving the location
estimate.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>a numeric matrix giving the estimate of the scatter matrix.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>a character string providing a label for the scatter matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+tM">ICS::tM()</a></code>, <code><a href="ICS.html#topic+ICS_scatter">ICS::ICS_tM()</a></code>
</p>

<hr>
<h2 id='ICS_tcov'>Pairwise one-step M-estimate of scatter for ICS</h2><span id='topic+ICS_tcov'></span>

<h3>Description</h3>

<p>Wrapper function for the pairwise one-step M-estimator of scatter with
weights based on pairwise Mahalanobis distances, as computed by
<code><a href="#topic+tcov">tcov</a>()</code>. Note that this estimator is based on pairwise
differences and therefore no location estimate is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS_tcov(x, beta = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICS_tcov_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="ICS_tcov_+3A_beta">beta</code></td>
<td>
<p>a positive numeric value specifying the tuning parameter of the
pairwise one-step M-estimator (default to 2), see <code><a href="#topic+tcov">tcov</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ICS_scatter"</code> with the following
components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>this is <code>NULL</code> as the estimator is based on pairwise
differences and does not use a location estimate.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>a numeric matrix giving the estimate of the scatter matrix.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>a character string providing a label for the scatter matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+tcov">tcov</a>()</code>, <code><a href="#topic+ucov">ucov</a>()</code>, <code><a href="#topic+ICS_ucov">ICS_ucov</a>()</code>
</p>

<hr>
<h2 id='ICS_ucov'>Simple robust estimates of scatter for ICS</h2><span id='topic+ICS_ucov'></span><span id='topic+ICS_scov'></span>

<h3>Description</h3>

<p>Wrapper functions for the one-step M-estimator of scatter with weights based
on Mahalanobis distances as computed by <code><a href="#topic+scov">scov</a>()</code>, or the simple
related estimator that is based on a transformation as computed by
<code><a href="#topic+ucov">ucov</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICS_scov(x, location = TRUE, beta = 0.2)

ICS_ucov(x, location = TRUE, beta = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICS_ucov_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="ICS_ucov_+3A_location">location</code></td>
<td>
<p>a logical indicating whether to include the sample
mean as location estimate (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="ICS_ucov_+3A_beta">beta</code></td>
<td>
<p>a positive numeric value specifying the tuning parameter of the
estimator (default to 0.2), see <code><a href="#topic+ucov">ucov</a>()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ICS_scatter"</code> with the following
components:
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p>if requested, a numeric vector giving the location estimate.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>a numeric matrix giving the estimate of the scatter matrix.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>a character string providing a label for the scatter matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ICS">ICS</a>()</code>
</p>
<p><code><a href="#topic+tcov">tcov</a>()</code>, <code><a href="#topic+ICS_tcov">ICS_tcov</a>()</code>, <code><a href="#topic+ucov">ucov</a>()</code>
</p>

<hr>
<h2 id='ICSClust'>Tandem clustering with ICS</h2><span id='topic+ICSClust'></span>

<h3>Description</h3>

<p>Sequential clustering approach: (i) dimension reduction through the Invariant
Coordinate Selection method using the <code><a href="ICS.html#topic+ICS-S3">ICS</a></code> function and (ii)
clustering of the transformed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICSClust(
  X,
  nb_select = NULL,
  nb_clusters = NULL,
  ICS_args = list(),
  criterion = c("med_crit", "normal_crit", "var_crit", "discriminatory_crit"),
  ICS_crit_args = list(),
  method = c("kmeans_clust", "tkmeans_clust", "pam_clust", "mclust_clust",
    "rmclust_clust", "rimle_clust"),
  clustering_args = list(),
  clusters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICSClust_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame containing the data.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_nb_select">nb_select</code></td>
<td>
<p>the number of components to select.
It is used only in case <code>criterion</code> is either <code>"med_crit"</code>, <code>"var_crit"</code>
or <code>"discriminatory_crit"</code>.  By default it is set to <code>NULL</code>, i.e the number
of components to select is the number of clusters minus one.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_nb_clusters">nb_clusters</code></td>
<td>
<p>the number of clusters searched for.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_ics_args">ICS_args</code></td>
<td>
<p>list of <code><a href="ICS.html#topic+ICS-S3">ICS-S3</a></code> arguments. Otherwise, default
values of <code><a href="ICS.html#topic+ICS-S3">ICS-S3</a></code> are used.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_criterion">criterion</code></td>
<td>
<p>criterion to automatically decide which invariant components
to keep. Possible values are <code>"med_crit"</code>, <code>"normal_crit"</code>, <code>"var_crit"</code> and
<code>"discriminatory_crit"</code>. The default value is <code>"med_crit"</code>.
See <code><a href="#topic+med_crit">med_crit()</a></code>, <code><a href="#topic+normal_crit">normal_crit()</a></code>, <code><a href="#topic+var_crit">var_crit()</a></code> or
<code><a href="#topic+discriminatory_crit">discriminatory_crit()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_ics_crit_args">ICS_crit_args</code></td>
<td>
<p>list of arguments passed to <code><a href="#topic+med_crit">med_crit()</a></code>, <code><a href="#topic+normal_crit">normal_crit()</a></code>,
<code><a href="#topic+var_crit">var_crit()</a></code> or <br /> <code><a href="#topic+discriminatory_crit">discriminatory_crit()</a></code> for choosing the components to keep.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_method">method</code></td>
<td>
<p>clustering method to perform. Currently implemented wrapper
functions are <code>"kmeans_clust"</code>, <code>"tkmeans_clust"</code>, <code>"pam_clust"</code>,
<code>"mclust_clust"</code>, <code>"rmclust_clust"</code> or <code>"rimle_clust"</code>.
The default value is <code>"kmeans_clust"</code>.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_clustering_args">clustering_args</code></td>
<td>
<p>list of <code><a href="#topic+kmeans_clust">kmeans_clust()</a></code>,
<code><a href="#topic+tkmeans_clust">tkmeans_clust()</a></code>,  <code><a href="#topic+pam_clust">pam_clust()</a></code>, <code><a href="#topic+rimle_clust">rimle_clust()</a></code>, <code><a href="#topic+mclust_clust">mclust_clust()</a></code> or
<code><a href="#topic+rmclust_clust">rmclust_clust()</a></code>
arguments for performing cluster analysis.</p>
</td></tr>
<tr><td><code id="ICSClust_+3A_clusters">clusters</code></td>
<td>
<p>a vector indicating the true clusters of the data. By default,
it is <code>NULL</code> but it is required to choose the components based on the
discriminatory criterion <code><a href="#topic+discriminatory_crit">discriminatory_crit</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tandem clustering with ICS is a sequential method:
</p>

<ul>
<li> <p><code><a href="ICS.html#topic+ICS-S3">ICS</a></code> is performed.
</p>
</li>
<li><p> only a subset of the first and/or the last few components are
selected based on a criterion.
</p>
</li>
<li><p> the clustering method is performed only on the subspace
of the selected components.
</p>
</li>
<li><p> wrapper for several different clustering methods are provided. Users can however
also write wrappers for other clustering methods.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>"ICSClust"</code> with the following components:
</p>

<ul>
<li> <p><code>ICS_out</code>: An object of class <code>"ICS"</code>.
See <code><a href="ICS.html#topic+ICS-S3">ICS</a></code>
</p>
</li>
<li> <p><code>select</code>: a vector of the names of the selected invariant
coordinates.
</p>
</li>
<li> <p><code>clusters</code>: a vector of the new partition of the data, i.e a vector
of integers (from <code>1:k</code>) indicating the cluster to which each
observation is allocated. 0 indicates outlying observations.
</p>
</li></ul>

<p><a href="#topic+summary.ICSClust">summary()</a> and <a href="#topic+plot.ICSClust">plot()</a> methods are available.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>


<h3>References</h3>

<p>Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+med_crit">med_crit()</a></code>, <code><a href="#topic+normal_crit">normal_crit()</a></code>,
<code><a href="#topic+var_crit">var_crit()</a></code>, <a href="ICS.html#topic+ICS-S3">ICS</a>,
<code><a href="#topic+discriminatory_crit">discriminatory_crit()</a></code>, <code><a href="#topic+kmeans_clust">kmeans_clust()</a></code>,
<code><a href="#topic+tkmeans_clust">tkmeans_clust()</a></code>, <code><a href="#topic+pam_clust">pam_clust()</a></code>,
<code><a href="#topic+rimle_clust">rimle_clust()</a></code>, <code><a href="#topic+mclust_clust">mclust_clust()</a></code>
<code><a href="base.html#topic+summary">summary()</a></code> and <code><a href="base.html#topic+plot">plot()</a></code> methods
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,1:4]

# indicating the number of components to retain for the dimension reduction
# step as well as the number of clusters searched for.
out &lt;- ICSClust(X, nb_select = 2, nb_clusters = 3)
summary(out)
plot(out)

# changing the scatter pair to consider in ICS
out &lt;- ICSClust(X, nb_select = 1, nb_clusters = 3,
ICS_args = list(S1 = ICS_mcd_raw, S2 = ICS_cov,S1_args = list(alpha = 0.5)))
summary(out)
plot(out)
 
# changing the criterion for choosing the invariant coordinates
out &lt;- ICSClust(X, nb_clusters = 3, criterion = "normal_crit",
ICS_crit_args = list(level = 0.1, test = "anscombe.test", max_select = NULL))
summary(out)
plot(out)

# changing the clustering method
out &lt;- ICSClust(X, nb_clusters = 3, method  = "tkmeans_clust", 
clustering_args = list(alpha = 0.1))
summary(out)
plot(out)
</code></pre>

<hr>
<h2 id='kmeans_clust'><em>k</em>-means clustering</h2><span id='topic+kmeans_clust'></span>

<h3>Description</h3>

<p>Wrapper for performing k-means clustering from <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans_clust(X, k, clusters_only = FALSE, iter.max = 100, nstart = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmeans_clust_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame of the data. It corresponds to the
argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="kmeans_clust_+3A_k">k</code></td>
<td>
<p>the number of clusters searched for. It corresponds to the argument
<code>centers</code>.</p>
</td></tr>
<tr><td><code id="kmeans_clust_+3A_clusters_only">clusters_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the partition of the data
is returned as a vector. If <code>FALSE</code> the usual output of
the <a href="stats.html#topic+kmeans">kmeans</a> function is returned.</p>
</td></tr>
<tr><td><code id="kmeans_clust_+3A_iter.max">iter.max</code></td>
<td>
<p>the maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="kmeans_clust_+3A_nstart">nstart</code></td>
<td>
<p>if <code>centers</code> is a number, how many random sets should be
chosen.</p>
</td></tr>
<tr><td><code id="kmeans_clust_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>clusters_only</code> is <code>TRUE</code> a vector of the new partition
of the data is returned, i.e a vector of integers (from <code>1:k</code>)
indicating the cluster to which each observation is allocated.
</p>
<p>Otherwise a list is returned with the following components:
</p>
<table>
<tr><td><code>clust_method</code></td>
<td>
<p>the name of the clustering method, i.e. &quot;kmeans&quot;.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>the vector of the new partition of the data, i.e. a vector of
integers (from <code>1:k</code>) indicating the cluster to which each observation
is allocated.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>an object of class <code>"kmeans"</code></p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kmeans_clust(iris[,1:4], k = 3, clusters_only = TRUE)

</code></pre>

<hr>
<h2 id='mclust_clust'>Model-Based Clustering</h2><span id='topic+mclust_clust'></span><span id='topic+rmclust_clust'></span>

<h3>Description</h3>

<p>Wrapper for performing Model-Based Clustering from <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>
allowing noise or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mclust_clust(X, k, clusters_only = FALSE, ...)

rmclust_clust(X, k, clusters_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mclust_clust_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame of the data. It corresponds to the
argument <code>data</code>.</p>
</td></tr>
<tr><td><code id="mclust_clust_+3A_k">k</code></td>
<td>
<p>the number of clusters searched for. It corresponds to the argument
<code>G</code> of function <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>.</p>
</td></tr>
<tr><td><code id="mclust_clust_+3A_clusters_only">clusters_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the partition of the data
is returned as a vector. If <code>FALSE</code> the usual output of the
<code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code> function is returned.</p>
</td></tr>
<tr><td><code id="mclust_clust_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+mclust_clust">mclust_clust()</a></code>: does not allow noise
</p>
</li>
<li> <p><code><a href="#topic+rmclust_clust">rmclust_clust()</a></code>: allows noise
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>clusters_only</code> is <code>TRUE</code> a vector of the new partition
of the data is returned, i.e a vector of integers (from <code>1:k</code>)
indicating the cluster to which each observation is allocated.
0 indicates trimmed observations.
</p>
<p>Otherwise a list is returned with the following components:
</p>
<table>
<tr><td><code>clust_method</code></td>
<td>
<p>the name of the clustering method, i.e &quot;rimle&quot;.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>the vector of the new partition of the data, i.e a vector of
integers (from <code>1:k</code>) indicating the cluster to which each observation
is allocated.
0 indicates outlying observations for <code><a href="#topic+rmclust_clust">rmclust_clust()</a></code> only.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>an object of class &quot;<code>mclust</code>&quot;</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="mclust.html#topic+Mclust">mclust::Mclust()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mclust_clust(iris[,1:4], k = 3, clusters_only = TRUE)
</code></pre>

<hr>
<h2 id='med_crit'>Selection of Invariant components using the med criterion</h2><span id='topic+med_crit'></span><span id='topic+med_crit.ICS'></span><span id='topic+med_crit.default'></span>

<h3>Description</h3>

<p>Identifies as interesting invariant coordinates whose generalized eigenvalues are the furthermost away
from the median of all generalized eigenvalues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>med_crit(object, ...)

## S3 method for class 'ICS'
med_crit(object, nb_select = NULL, select_only = FALSE, ...)

## Default S3 method:
med_crit(object, nb_select = NULL, select_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="med_crit_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICS"</code>.</p>
</td></tr>
<tr><td><code id="med_crit_+3A_...">...</code></td>
<td>
<p>additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="med_crit_+3A_nb_select">nb_select</code></td>
<td>
<p>the exact number of components to select. By default it is set to
<code>NULL</code>, i.e the number of components to select is the number of variables minus one.</p>
</td></tr>
<tr><td><code id="med_crit_+3A_select_only">select_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the vector names of the selected
invariant components is returned. If <code>FALSE</code> additional details are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If more than half of the components are &quot;uninteresting&quot; and have the same generalized eigenvalue then the median
of all generalized eigenvalues corresponds
to the uninteresting component generalized eigenvalue. The components of interest are the ones whose generalized eigenvalues differ
the most from the median. The motivation of this criterion depends therefore on the assumption that at least half of the
components have equal generalized eigenvalues.
</p>


<h3>Value</h3>

<p>If <code>select_only</code> is  <code>TRUE</code> a vector of the names of the invariant
components or variables to select. If <code>FALSE</code> an object of class <code>"ICS_crit"</code>
is returned with the following objects:
</p>

<ul>
<li> <p><code>crit</code>: the name of the criterion &quot;med&quot;.
</p>
</li>
<li> <p><code>nb_select</code>: the number of components to select.
</p>
</li>
<li> <p><code>gen_kurtosis</code>: the vector of generalized kurtosis values.
</p>
</li>
<li> <p><code>med_gen_kurtosis</code>: the median of the generalized kurtosis values.
</p>
</li>
<li> <p><code>gen_kurtosis_diff_med</code>: the absolute differences between the generalized
kurtosis values and the median.
</p>
</li>
<li> <p><code>select</code>: the names of the invariant components or variables to select.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Andreas Alfons, Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>..
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normal_crit">normal_crit()</a></code>, <code><a href="#topic+var_crit">var_crit()</a></code>, <code><a href="#topic+discriminatory_crit">discriminatory_crit()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,-5]
out &lt;- ICS(X)
med_crit(out, nb_select = 2, select_only = FALSE)
</code></pre>

<hr>
<h2 id='mixture_sim'>Simulation of a mixture of Gaussian distributions</h2><span id='topic+mixture_sim'></span>

<h3>Description</h3>

<p>Simulation of a <code class="reqn">n \times p</code> data frame according to a mixture of <code class="reqn">q</code>
Gaussian distributions with <code class="reqn">q &lt; p</code>, different location parameters
<code class="reqn">\mu_1, \dots, \mu_q</code>, and the identity matrix as the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture_sim(pct_clusters = c(0.5, 0.5), n = 500, p = 10, delta = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixture_sim_+3A_pct_clusters">pct_clusters</code></td>
<td>
<p>a vector of marginal probabilities for each group, i.e
mixture weights.
Default is two
balanced clusters.</p>
</td></tr>
<tr><td><code id="mixture_sim_+3A_n">n</code></td>
<td>
<p>integer. The number of observations.</p>
</td></tr>
<tr><td><code id="mixture_sim_+3A_p">p</code></td>
<td>
<p>integer. The number of variables.</p>
</td></tr>
<tr><td><code id="mixture_sim_+3A_delta">delta</code></td>
<td>
<p>integer. The location shift.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> be a <code class="reqn">p</code>-variate real random vector distributed according to
a mixture of <code class="reqn">q</code> Gaussian distributions with <code class="reqn">q &lt; p</code>,
different location parameters <code class="reqn">\mu_1, \dots, \mu_q</code>, and the same positive
definite covariance matrix <code class="reqn">I_p</code>:
</p>
<p style="text-align: center;"><code class="reqn">X \sim \sum_{h=1}^{q} \epsilon_h \, {\cal N}(\mu_h,I_p),</code>
</p>

<p>where <code class="reqn">\epsilon_{1}, \dots, \epsilon_{q}</code> are mixture weights with
<code class="reqn">\epsilon_1 + \cdots + \epsilon_q = 1</code>,  <code class="reqn">\mu_1 = 0_p</code>,
and  <code class="reqn">\mu_{h+1} = \delta e_h</code> with <code class="reqn">h = 1, \dots, q-1</code>.
</p>


<h3>Value</h3>

<p>A dataframe of <em>n</em> observations and <em>p+1</em> variables with the first
variable
indicating the cluster assignment using a character string.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>


<h3>References</h3>

<p>Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>..
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- mixture_sim()
summary(X)
</code></pre>

<hr>
<h2 id='normal_crit'>Selection of Non-normal Invariant Components Using Marginal
Normality Tests</h2><span id='topic+normal_crit'></span><span id='topic+normal_crit.ICS'></span><span id='topic+normal_crit.default'></span>

<h3>Description</h3>

<p>Identifies invariant coordinates that are non normal using univariate
normality tests as in the <code>comp.norm.test</code> function from the
<code>ICSOutlier</code> package, with the difference that both the
first and last few components are investigated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_crit(object, ...)

## S3 method for class 'ICS'
normal_crit(
  object,
  level = 0.05,
  test = c("agostino.test", "jarque.test", "anscombe.test", "bonett.test",
    "shapiro.test"),
  max_select = NULL,
  select_only = FALSE,
  ...
)

## Default S3 method:
normal_crit(
  object,
  level = 0.05,
  test = c("agostino.test", "jarque.test", "anscombe.test", "bonett.test",
    "shapiro.test"),
  max_select = NULL,
  select_only = FALSE,
  gen_kurtosis = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_crit_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICS"</code> or a data frame or matrix.</p>
</td></tr>
<tr><td><code id="normal_crit_+3A_...">...</code></td>
<td>
<p>additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="normal_crit_+3A_level">level</code></td>
<td>
<p>the initial level used to make a decision based on the test
p-values. See details. Default is 0.05.</p>
</td></tr>
<tr><td><code id="normal_crit_+3A_test">test</code></td>
<td>
<p>name of the normality test to be used. Possibilities are
<code>"jarque.test"</code>, <code>"anscombe.test"</code>, <code>"bonett.test"</code>, <code>"agostino.test"</code>,
<code>"shapiro.test"</code>.
Default is <code>"agostino.test"</code>.</p>
</td></tr>
<tr><td><code id="normal_crit_+3A_max_select">max_select</code></td>
<td>
<p>the maximal number of components to select.</p>
</td></tr>
<tr><td><code id="normal_crit_+3A_select_only">select_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the vector names of the selected
invariant components is returned. If <code>FALSE</code> additional details are returned.</p>
</td></tr>
<tr><td><code id="normal_crit_+3A_gen_kurtosis">gen_kurtosis</code></td>
<td>
<p>vector of generalized kurtosis values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure sequentially tests the first and the last components until
finding no additional components as non-normal. The quantile levels are
adjusted for multiple testing by taking the level as <code>level</code>/<em>j</em> for the
<em>j</em>th component.
</p>


<h3>Value</h3>

<p>If <code>select_only</code> is  <code>TRUE</code> a vector of the names of the invariant
components or variables to select. If <code>FALSE</code> an object of class <code>"ICS_crit"</code>
is returned with the following objects:
</p>

<ul>
<li> <p><code>crit</code>: the name of the criterion &quot;normal&quot;.
</p>
</li>
<li> <p><code>level</code>: the level of the test.
</p>
</li>
<li> <p><code>max_select</code>: the maximal number of components to select.
</p>
</li>
<li> <p><code>test</code>: name of the normality test to be used.
</p>
</li>
<li> <p><code>pvalues</code>: the p-values of the tests.
</p>
</li>
<li> <p><code>adjusted_levels</code>: the adjusted levels.
</p>
</li>
<li> <p><code>select</code>: the names of the invariant components or variables to select.
</p>
</li>
<li> <p><code>gen_kurtosis</code>: the vector of generalized kurtosis values in case of
<code>ICS</code> object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Andreas Alfons, Aurore Archimbaud, Klaus Nordhausen and Anne Ruiz-Gazen
</p>


<h3>References</h3>

<p>Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>..
</p>
<p>Archimbaud, A., Nordhausen, K., and Ruiz-Gazen, A. (2018).
ICSOutlier: Unsupervised Outlier Detection for Low-Dimensional Contamination Structure,
The RJournal, Vol. 10(1):234–250. <a href="https://doi.org/10.32614/RJ-2018-034">doi:10.32614/RJ-2018-034</a>
</p>
<p>Archimbaud, A., Nordhausen, K., and Ruiz-Gazen, A. (2016).
ICSOutlier: Outlier Detection Using Invariant Coordinate Selection.
R package version 0.3-0
</p>


<h3>See Also</h3>

<p><code><a href="#topic+med_crit">med_crit()</a></code>, <code><a href="#topic+var_crit">var_crit()</a></code>, <code><a href="#topic+discriminatory_crit">discriminatory_crit()</a></code>,
<code><a href="moments.html#topic+jarque.test">jarque.test()</a></code>, <code><a href="moments.html#topic+anscombe.test">anscombe.test()</a></code>,
<code><a href="moments.html#topic+bonett.test">bonett.test()</a></code>, <code><a href="moments.html#topic+agostino.test">agostino.test()</a></code>, <code><a href="stats.html#topic+shapiro.test">stats::shapiro.test()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,-5]
out &lt;- ICS(X)
normal_crit(out, level = 0.1, select_only = FALSE)

</code></pre>

<hr>
<h2 id='pam_clust'>Partitioning Around Medoids clustering</h2><span id='topic+pam_clust'></span>

<h3>Description</h3>

<p>Wrapper for performing Partitioning Around Medoids clustering from
<code><a href="cluster.html#topic+pam">cluster::pam()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pam_clust(X, k, clusters_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pam_clust_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame of the data. It corresponds to the
argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="pam_clust_+3A_k">k</code></td>
<td>
<p>the number of clusters searched for. It corresponds to the argument
<code>k</code>.</p>
</td></tr>
<tr><td><code id="pam_clust_+3A_clusters_only">clusters_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the partition of the data
is returned as a vector. If <code>FALSE</code> the usual output of the
<code><a href="cluster.html#topic+pam">cluster::pam()</a></code> function is returned.</p>
</td></tr>
<tr><td><code id="pam_clust_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the <code><a href="cluster.html#topic+pam">cluster::pam()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>clusters_only</code> is <code>TRUE</code> a vector of the new partition
of the data is returned, i.e a vector of integers (from <code>1:k</code>)
indicating the cluster to which each observation is allocated.
0 indicates trimmed observations.
</p>
<p>Otherwise a list is returned with the following components:
</p>
<table>
<tr><td><code>clust_method</code></td>
<td>
<p>the name of the clustering method, i.e &quot;clara_pam&quot;.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>the vector of the new partition of the data, i.e a vector of
integers (from <code>1:k</code>) indicating the cluster to which each observation
is allocated.
0 indicates outlying observations.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>an object of class <code>"pam"</code></p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="cluster.html#topic+pam">cluster::pam()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pam_clust(iris[,1:4], k = 3, clusters_only = TRUE)
 
</code></pre>

<hr>
<h2 id='plot.ICSClust'>Scatterplot Matrix with densities on the diagonal</h2><span id='topic+plot.ICSClust'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="#topic+component_plot">component_plot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICSClust'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ICSClust_+3A_x">x</code></td>
<td>
<p>an object of class <code>"ICSClust"</code>.</p>
</td></tr>
<tr><td><code id="plot.ICSClust_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed down to <code><a href="#topic+component_plot">component_plot()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="GGally.html#topic+ggmatrix">&quot;ggmatrix&quot;</a></code> (see
<code><a href="GGally.html#topic+ggpairs">GGally::ggpairs()</a></code>).
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>

<hr>
<h2 id='print.ICSClust_summary'>Print of an <code>ICSClust_summary</code> object</h2><span id='topic+print.ICSClust_summary'></span>

<h3>Description</h3>

<p>Prints an <code>ICSClust_summary</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICSClust_summary'
print(x, info = FALSE, digits = 4L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ICSClust_summary_+3A_x">x</code></td>
<td>
<p>object of class <code>"ICSClust_summary"</code>.</p>
</td></tr>
<tr><td><code id="print.ICSClust_summary_+3A_info">info</code></td>
<td>
<p>logical, either TRUE or FALSE. If TRUE, prints additional
information on arguments used for computing scatter matrices
(only named arguments that contain numeric, character, or logical scalars)
and information on the parameters of the algorithm.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="print.ICSClust_summary_+3A_digits">digits</code></td>
<td>
<p>number of digits for the numeric output.</p>
</td></tr>
<tr><td><code id="print.ICSClust_summary_+3A_...">...</code></td>
<td>
<p>additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The supplied object of class <code>"ICSClust_summary"</code> is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>

<hr>
<h2 id='rimle_clust'>Robust Improper Maximum Likelihood Clustering</h2><span id='topic+rimle_clust'></span>

<h3>Description</h3>

<p>Wrapper for performing Robust Improper Maximum Likelihood Clustering
clustering from <code><a href="otrimle.html#topic+rimle">otrimle::rimle()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rimle_clust(X, k, clusters_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rimle_clust_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame of the data. It corresponds to the
argument <code>data</code>.</p>
</td></tr>
<tr><td><code id="rimle_clust_+3A_k">k</code></td>
<td>
<p>the number of clusters searched for. It corresponds to the argument
<code>G</code>.</p>
</td></tr>
<tr><td><code id="rimle_clust_+3A_clusters_only">clusters_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the partition of the data
is returned as a vector. If <code>FALSE</code> the usual output of the
<code><a href="otrimle.html#topic+rimle">otrimle::rimle()</a></code> function is returned.</p>
</td></tr>
<tr><td><code id="rimle_clust_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code><a href="otrimle.html#topic+rimle">otrimle::rimle()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>clusters_only</code> is <code>TRUE</code> a vector of the new partition
of the data is returned, i.e a vector of integers (from <code>1:k</code>)
indicating the cluster to which each observation is allocated.
0 indicates trimmed observations.
</p>
<p>Otherwise a list is returned with the following components:
</p>
<table>
<tr><td><code>clust_method</code></td>
<td>
<p>the name of the clustering method, i.e, &quot;rimle&quot;.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>the vector of the new partition of the data, i.e. a vector of
integers (from <code>1:k</code>) indicating the cluster to which each observation
is allocated.
0 indicates outlying observations.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>an object of class <code>"rimle"</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="otrimle.html#topic+rimle">otrimle::rimle()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rimle_clust(iris[,1:4], k = 3, clusters_only = TRUE)
</code></pre>

<hr>
<h2 id='runif_outside_range'>Uniform distribution outside a given range</h2><span id='topic+runif_outside_range'></span>

<h3>Description</h3>

<p>Draw from a multivariate uniform distribution outside a given range.
Intuitively speaking, the observations are drawn from a multivariate
uniform distribution on a hyperrectangle with a hole in the middle (in the
shape of a smaller hyperrectangle). This is useful, e.g., for adding random
noise to a data set such that the noise consists of large values that do not
overlap the initial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_outside_range(n, min = 0, max = 1, mult = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif_outside_range_+3A_n">n</code></td>
<td>
<p>an integer giving the number of observations to generate.</p>
</td></tr>
<tr><td><code id="runif_outside_range_+3A_min">min</code></td>
<td>
<p>a numeric vector giving the minimum of each variable of the
initial data set (outside of which to generate random noise).</p>
</td></tr>
<tr><td><code id="runif_outside_range_+3A_max">max</code></td>
<td>
<p>a numeric vector giving the maximum of each variable of the
initial data set (outside of which to generate random noise).</p>
</td></tr>
<tr><td><code id="runif_outside_range_+3A_mult">mult</code></td>
<td>
<p>multiplication factor (larger than 1) to expand the
hyperrectangle around the initial data (which is given by <code>min</code> and <code>max</code>).
For instance, the default value 2 gives a hyperrectangle for which each
side is twice as long as the range of the initial data.  The data are then
drawn from a uniform distribution on the expanded hyperrectangle from which
the smaller hyperrectangle around the data is cut out. See the examples for
an illustration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of generated points.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons
</p>


<h3>References</h3>

<p>#' Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## illustrations for argument 'mult'

# draw observations with argument 'mult = 2'
xy2 &lt;- runif_outside_range(1000, min = rep(-1, 2), max = rep(1, 2), 
                           mult = 2)
# each side of the larger hyperrectangle is twice as long as 
# the corresponding side of the smaller rectanglar cut-out
df2 &lt;- data.frame(x = xy2[, 1], y = xy2[, 2])
ggplot(data = df2, mapping = aes(x = x, y = y)) + 
  geom_point()

# draw observations with argument 'mult = 4'
xy4 &lt;- runif_outside_range(1000, min = rep(-1, 2), max = rep(1, 2), 
                           mult = 4)
# each side of the larger hyperrectangle is four times as long 
# as the corresponding side of the smaller rectanglar cut-out
df4 &lt;- data.frame(x = xy4[, 1], y = xy4[, 2])
ggplot(data = df4, mapping = aes(x = x, y = y)) + 
  geom_point()

</code></pre>

<hr>
<h2 id='select_plot'>Plot of the Generalized Kurtosis Values of the ICS Transformation</h2><span id='topic+select_plot'></span><span id='topic+select_plot.default'></span><span id='topic+select_plot.data.frame'></span><span id='topic+select_plot.ICS_crit'></span>

<h3>Description</h3>

<p>Extracts the generalized kurtosis values of the components obtained via an
ICS transformation and draws either a screeplot or a specific plot for a
given criterion. If an object of class <code>"ICS_crit"</code> is given, then the
selected components are shaded on the plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_plot(object, ...)

## Default S3 method:
select_plot(
  object,
  select = NULL,
  scale = FALSE,
  screeplot = TRUE,
  type = c("dots", "lines"),
  width = 0.2,
  color = "grey",
  alpha = 0.3,
  size = 3,
  ...
)

## S3 method for class 'data.frame'
select_plot(
  object,
  type = c("dots", "lines"),
  width = 0.2,
  color = "grey",
  alpha = 0.3,
  ...
)

## S3 method for class 'ICS_crit'
select_plot(
  object,
  type = c("dots", "lines"),
  width = 0.2,
  color = "grey",
  alpha = 0.3,
  size = 3,
  screeplot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_plot_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>"ICS"</code> and containing
results from an ICS transformation or from class <code>"ICS_crit"</code>.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_...">...</code></td>
<td>
<p>additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_select">select</code></td>
<td>
<p>an integer, character, or logical vector specifying for
which components to extract the generalized kurtosis values, or
<code>NULL</code> for extracting the generalized kurtosis values of all
components.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_scale">scale</code></td>
<td>
<p>a logical indicating whether to scale the generalized
kurtosis values to have product 1 (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="select_plot_+3A_screeplot">screeplot</code></td>
<td>
<p>boolean. If <code>TRUE</code> a plot of the generalized kurtosis
values is drawn. Otherwise it is context specific to the <code>ICS_crit</code> object.
For &quot;med&quot; criterion, the differences between the kurtosis values and the
median are plotted in absolute values. For &quot;discriminatory&quot; the
discriminatory power associated to the evaluated combinations are drawn.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_type">type</code></td>
<td>
<p>either <code>"dots"</code> or <code>"lines"</code> for the type of plot.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_width">width</code></td>
<td>
<p>the width for shading the selected components in case an
<code>ICS_crit</code> object is given.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_color">color</code></td>
<td>
<p>the color for shading the selected components in case an
<code>ICS_crit</code> object is given.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_alpha">alpha</code></td>
<td>
<p>the transparency for shading the selected components in case
an <code>ICS_crit</code> object is given.</p>
</td></tr>
<tr><td><code id="select_plot_+3A_size">size</code></td>
<td>
<p>size of the points. Only relevant for &quot;discriminatory&quot; criteria.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ggplot"</code> (see <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code>).
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,-5]
out &lt;- ICS(X)

# on an ICS object
select_plot(out)
select_plot(out, type = "lines")

# on an ICS_crit object 
# median criterion
out_med &lt;- med_crit(out, nb_select = 1, select_only = FALSE)
select_plot(out_med, type = "lines")
select_plot(out_med, screeplot = FALSE, type = "lines", 
color = "lightblue")

# discriminatory criterion
out_disc &lt;- discriminatory_crit(out, clusters = iris[,5], 
 select_only = FALSE)
select_plot(out_disc)


</code></pre>

<hr>
<h2 id='summary.ICSClust'>Summary of an <code>ICSClust</code> object</h2><span id='topic+summary.ICSClust'></span>

<h3>Description</h3>

<p>Summarizes an <code>ICSClust</code> object in an informative way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ICSClust'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ICSClust_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICSClust"</code>.</p>
</td></tr>
<tr><td><code id="summary.ICSClust_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+summary">summary()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"ICSClust_summary"</code> with the following components:
</p>

<ul>
<li> <p><code>ICS_out</code>: <code>ICS_out</code> object
</p>
</li>
<li> <p><code>nb_comp</code>: number of selected components
</p>
</li>
<li> <p><code>select</code>: vector of names of selected components
</p>
</li>
<li> <p><code>nb_clusters</code>: number of clusters
</p>
</li>
<li> <p><code>table_clusters</code>: frequency table of clusters
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>

<hr>
<h2 id='tcov'>Pairwise one-step M-estimate of scatter</h2><span id='topic+tcov'></span>

<h3>Description</h3>

<p>Computes a pairwise one-step M-estimate of scatter with weights based on
pairwise Mahalanobis distances. Note that it is based on pairwise
differences and therefore does not require a location estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcov(x, beta = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcov_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="tcov_+3A_beta">beta</code></td>
<td>
<p>a positive numeric value specifying the tuning parameter of the
pairwise one-step M-estimator (defaults to 2), see &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a sample <code class="reqn">\boldsymbol{X}_{n} = (\mathbf{x}_{1}, \dots, 
\mathbf{x}_n)^{\top}</code>, a positive and decreasing weight function <code class="reqn">w</code>,
and a tuning parameter <code class="reqn">\beta &gt; 0</code>, the pairwise one-step M-estimator
of scatter is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{TCOV}_{\beta}(\boldsymbol{X}_{n}) =
\frac{\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} 
w(\beta \, r^{2}(\mathbf{x}_{i}, \mathbf{x}_{j})) 
(\mathbf{x}_{i} - \mathbf{x}_{j}) 
(\mathbf{x}_{i} - \mathbf{x}_{j})^{\top}}{\sum_{i=1}^{n-1} \sum_{j=i+1}^{n} 
w(\beta \, r^{2}(\mathbf{x}_{i}, \mathbf{x}_{j}))},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">r^{2}(\mathbf{x}_{i}, \mathbf{x}_{j}) = 
(\mathbf{x}_{i} - \mathbf{x}_{j})^{\top}
\mathrm{COV}(\boldsymbol{X}_n)^{-1} 
(\mathbf{x}_{i} - \mathbf{x}_{j})</code>
</p>

<p>denotes the squared pairwise Mahalanobis distance between observations
<code class="reqn">\mathbf{x}_{i}</code> and <code class="reqn">\mathbf{x}_{j}</code> based on the sample
covariance matrix <code class="reqn">\mathrm{COV}(\boldsymbol{X}_n)</code>. Here, the weight
function <code class="reqn">w(x) = \exp(-x/2)</code> is used.
</p>


<h3>Value</h3>

<p>A numeric matrix giving the pairwise one-step M-estimate of scatter.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>References</h3>

<p>Caussinus, H. and Ruiz-Gazen, A. (1993) Projection Pursuit and Generalized
Principal Component Analysis. In Morgenthaler, S., Ronchetti, E., Stahel,
W.A. (eds.) <em>New Directions in Statistical Data Analysis and Robustness</em>,
35-46. Monte Verita, Proceedings of the Centro Stefano Franciscini Ascona
Series. Springer-Verlag.
</p>
<p>Caussinus, H. and Ruiz-Gazen, A. (1995) Metrics for Finding Typical
Structures by Means of Principal Component Analysis. In <em>Data Science and
its Applications</em>, 177-192. Academic Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS_tcov">ICS_tcov</a>()</code>, <code><a href="#topic+ucov">ucov</a>()</code>, <code><a href="#topic+ICS_ucov">ICS_ucov</a>()</code>
</p>

<hr>
<h2 id='tkmeans_clust'>Trimmed k-means clustering</h2><span id='topic+tkmeans_clust'></span>

<h3>Description</h3>

<p>Wrapper for performing trimmed k-means clustering from
<code><a href="tclust.html#topic+tkmeans">tclust::tkmeans()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkmeans_clust(X, k, clusters_only = FALSE, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkmeans_clust_+3A_x">X</code></td>
<td>
<p>a numeric matrix or data frame of the data. It corresponds to the
argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="tkmeans_clust_+3A_k">k</code></td>
<td>
<p>the number of clusters searched for. It corresponds to the argument
<code>k</code>.</p>
</td></tr>
<tr><td><code id="tkmeans_clust_+3A_clusters_only">clusters_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the partition of the data
is returned as a vector. If <code>FALSE</code> the usual output of the
<a href="tclust.html#topic+tkmeans">tkmeans</a> function is returned.</p>
</td></tr>
<tr><td><code id="tkmeans_clust_+3A_alpha">alpha</code></td>
<td>
<p>the proportion of observations to be trimmed.</p>
</td></tr>
<tr><td><code id="tkmeans_clust_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the <code><a href="tclust.html#topic+tkmeans">tclust::tkmeans()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>clusters_only</code> is <code>TRUE</code> a vector of the new partition
of the data is returned, i.e a vector of integers (from <code>1:k</code>)
indicating the cluster to which each observation is allocated.
0 indicates trimmed observations.
</p>
<p>Otherwise a list is returned with the following components:
</p>
<table>
<tr><td><code>clust_method</code></td>
<td>
<p>the name of the clustering method, i.e. &quot;tkmeans&quot;.</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>the vector of the new partition of the data, i.e. a vector of
integers (from <code>1:k</code>) indicating the cluster to which each observation
is allocated. 0 indicates trimmed observations.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>an object of class <code>"tkmeans"</code></p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p>Aurore Archimbaud
</p>


<h3>See Also</h3>

<p><code><a href="tclust.html#topic+tkmeans">tclust::tkmeans()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tkmeans_clust(iris[,1:4], k = 3, alpha = 0.1, clusters_only = TRUE)
</code></pre>

<hr>
<h2 id='ucov'>Simple robust estimates of scatter</h2><span id='topic+ucov'></span><span id='topic+scov'></span>

<h3>Description</h3>

<p>Compute a one-step M-estimator of scatter with weights based on Mahalanobis
distances, or a simple related estimator that is based on a transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scov(x, beta = 0.2)

ucov(x, beta = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ucov_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame.</p>
</td></tr>
<tr><td><code id="ucov_+3A_beta">beta</code></td>
<td>
<p>a positive numeric value specifying the tuning parameter of the
estimator (defaults to 0.2), see &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a sample <code class="reqn">\boldsymbol{X}_{n} = (\mathbf{x}_{1}, \dots, 
\mathbf{x}_n)^{\top}</code>, a positive and decreasing weight function <code class="reqn">w</code>,
and a tuning parameter <code class="reqn">\beta &gt; 0</code>, the one-step M-estimator
of scatter is defined as
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{SCOV}_{\beta}(\boldsymbol{X}_{n}) =
\frac{\sum_{i=1}^{n} 
w(\beta \, r^{2}(\mathbf{x}_{i})) 
(\mathbf{x}_{i} - \mathbf{\bar{x}}_{n}) 
(\mathbf{x}_{i} -  \mathbf{\bar{x}}_{n})^{\top}}{\sum_{i=1}^{n} 
w(\beta \, r^{2}(\mathbf{x}_{i}))},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">r^{2}(\mathbf{x}_{i}) = 
(\mathbf{x}_{i} -  \mathbf{\bar{x}}_{n})^{\top}
\mathrm{COV}(\boldsymbol{X}_n)^{-1} 
(\mathbf{x}_{i} -  \mathbf{\bar{x}}_{n})</code>
</p>

<p>denotes the squared Mahalanobis distance of observation <code class="reqn">\mathbf{x}_{i}</code>
from the sample mean <code class="reqn">\mathbf{\bar{x}}_{n}</code> based on the sample
covariance matrix <code class="reqn">\mathrm{COV}(\boldsymbol{X}_n)</code>. Here, the weight
function <code class="reqn">w(x) = \exp(-x/2)</code> is used.
</p>
<p>A simple robust estimator that is consistent under normality is obtained via
the transformation
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{UCOV}_{\beta}(\boldsymbol{X}_{n}) = 
(\mathrm{SCOV}_{\beta}(\boldsymbol{X}_{n})^{-1} - 
\beta \, \mathrm{COV}(\boldsymbol{X}_{n})^{-1})^{-1}.</code>
</p>



<h3>Value</h3>

<p>A numeric matrix giving the estimate of the scatter matrix.
</p>


<h3>Author(s)</h3>

<p>Andreas Alfons and Aurore Archimbaud
</p>


<h3>References</h3>

<p>Caussinus, H. and Ruiz-Gazen, A. (1993) Projection Pursuit and Generalized
Principal Component Analysis. In Morgenthaler, S., Ronchetti, E., Stahel,
W.A. (eds.) <em>New Directions in Statistical Data Analysis and Robustness</em>,
35-46. Monte Verita, Proceedings of the Centro Stefano Franciscini Ascona
Series. Springer-Verlag.
</p>
<p>Caussinus, H. and Ruiz-Gazen, A. (1995) Metrics for Finding Typical
Structures by Means of Principal Component Analysis. In <em>Data Science and
its Applications</em>, 177-192. Academic Press.
</p>
<p>Ruiz-Gazen, A. (1996) A Very Simple Robust Estimator of a Dispersion Matrix.
<em>Computational Statistics &amp; Data Analysis</em>, <strong>21</strong>(2), 149-162.
<a href="https://doi.org/10.1016/0167-9473%2895%2900009-7">doi:10.1016/0167-9473(95)00009-7</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICS_ucov">ICS_ucov</a>()</code>, <code><a href="#topic+tcov">tcov</a>()</code>, <code><a href="#topic+ICS_tcov">ICS_tcov</a>()</code>
</p>

<hr>
<h2 id='var_crit'>Selection of Invariant components using the var criterion</h2><span id='topic+var_crit'></span><span id='topic+var_crit.ICS'></span><span id='topic+var_crit.default'></span>

<h3>Description</h3>

<p>Identifies the interesting invariant coordinates based on the rolling
variance criterion as used in the <code>ICSboot</code> function of the <code>ICtest</code>
package. It computes rolling variances on the generalized eigenvalues
obtained through <code><a href="ICS.html#topic+ICS-S3">ICS::ICS()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_crit(object, ...)

## S3 method for class 'ICS'
var_crit(object, nb_select = NULL, select_only = FALSE, ...)

## Default S3 method:
var_crit(object, nb_select = NULL, select_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_crit_+3A_object">object</code></td>
<td>
<p>object of class <code>"ICS"</code>.</p>
</td></tr>
<tr><td><code id="var_crit_+3A_...">...</code></td>
<td>
<p>additional arguments are currently ignored.</p>
</td></tr>
<tr><td><code id="var_crit_+3A_nb_select">nb_select</code></td>
<td>
<p>the exact number of components to select. By default it is set to
<code>NULL</code>, i.e the number of components to select is the number of variables minus one.</p>
</td></tr>
<tr><td><code id="var_crit_+3A_select_only">select_only</code></td>
<td>
<p>boolean. If <code>TRUE</code> only the vector names of the selected
invariant components is returned. If <code>FALSE</code> additional details are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assuming that the generalized eigenvalues of the uninformative components are all the same
means that the variance of these generalized eigenvalues must be minimal.
Therefore when <code>nb_select</code> components should be selected, the method identifies
the <code>p - nb_select</code> neighboring generalized eigenvalues with minimal variance,
where <code>p</code> is the total number of components. The number of interesting components should be at
most <code>p-2</code> as at least two uninteresting components are needed to compute a variance.
</p>


<h3>Value</h3>

<p>If <code>select_only</code> is <code>TRUE</code> a vector of the names of the invariant
components or variables to select. If <code>FALSE</code> an object of class <code>"ICS_crit"</code>
is returned with the following objects:
</p>

<ul>
<li> <p><code>crit</code>: the name of the criterion &quot;var&quot;.
</p>
</li>
<li> <p><code>nb_select</code>: the number of components to select.
</p>
</li>
<li> <p><code>gen_kurtosis</code>: the vector of generalized kurtosis values.
</p>
</li>
<li> <p><code>select</code>: the names of the invariant components or variables to select.
</p>
</li>
<li> <p><code>RollVarX</code>: the rolling variances of order d-<code>nb_select</code>.
</p>
</li>
<li> <p><code>Order</code>: indexes of the ordered invariant components such that the
ones associated to the smallest variances of the eigenvalues are at the
end.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Andreas Alfons, Aurore Archimbaud and Klaus Nordhausen
</p>


<h3>References</h3>

<p>Alfons, A., Archimbaud, A., Nordhausen, K., &amp; Ruiz-Gazen, A. (2022).
Tandem clustering with invariant coordinate selection.
<em>arXiv preprint arXiv:2212.06108</em>..
</p>
<p>Radojicic, U., &amp; Nordhausen, K. (2019).
Non-gaussian component analysis: Testing the dimension of the signal subspace.
In Workshop on Analytical Methods in Statistics (pp. 101–123). Springer.
<a href="https://doi.org/10.1007/978-3-030-48814-7_6">doi:10.1007/978-3-030-48814-7_6</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normal_crit">normal_crit()</a></code>, <code><a href="#topic+med_crit">med_crit()</a></code>, <code><a href="#topic+discriminatory_crit">discriminatory_crit()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[,-5]
out &lt;- ICS(X)
var_crit(out, nb_select = 2, select_only = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
