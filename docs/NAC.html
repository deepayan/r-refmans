<!DOCTYPE html><html><head><title>Help for package NAC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NAC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CAclustering'><p>Covariate Assisted Spectral Clustering.</p></a></li>
<li><a href='#Cov_based'><p>Covariates-based Spectral Clustering.</p></a></li>
<li><a href='#NAC'><p>Spectral Clustering on Network-Adjusted Covariates.</p></a></li>
<li><a href='#Net_based'><p>Network-based Regularized Spectral Clustering.</p></a></li>
<li><a href='#SCORE'><p>Spectral Clustering On Ratios-of-Eigenvectors.</p></a></li>
<li><a href='#SDP'><p>Semidefinite programming for Community Detection in Networks with Covariates.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network-Adjusted Covariates for Community Detection</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Yaofang Hu [aut, cre],
  Wanjie Wang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yaofang Hu &lt;yaofangh@smu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Incorporating node-level covariates for community detection has gained increasing attention these years. This package provides the function for implementing the novel community detection algorithm known as Network-Adjusted Covariates for Community Detection (NAC), which is designed to detect latent community structure in graphs with node-level information, i.e., covariates. This algorithm can handle models such as the degree-corrected stochastic block model (DCSBM) with covariates. NAC specifically addresses the discrepancy between the community structure inferred from the adjacency information and the community structure inferred from the covariates information. For more detailed information, please refer to the reference paper: Yaofang Hu and Wanjie Wang (2023) &lt;<a href="https://arxiv.org/abs/2306.15616">arXiv:2306.15616</a>&gt;. In addition to NAC, this package includes several other existing community detection algorithms that are compared to NAC in the reference paper. These algorithms are Spectral Clustering On Ratios-of Eigenvectors (SCORE), network-based regularized spectral clustering (Net-based), covariate-based spectral clustering (Cov-based), covariate-assisted spectral clustering (CAclustering) and semidefinite programming (SDP). </td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, pracma</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/2306.15616">https://arxiv.org/abs/2306.15616</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, igraph</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.2.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-02 00:59:40 UTC; lu936</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-04 16:40:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='CAclustering'>Covariate Assisted Spectral Clustering.</h2><span id='topic+CAclustering'></span>

<h3>Description</h3>

<p><em>CAclustering</em> clusters graph nodes by applying spectral clustering with the assistance from
node covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAclustering(Adj, Covariate, K, alphan = 5, itermax = 100, startn = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAclustering_+3A_adj">Adj</code></td>
<td>
<p>An <code class="reqn">n \times n</code> symmetric adjacency matrix with diagonals being <code class="reqn">0</code> and positive entries
being <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="CAclustering_+3A_covariate">Covariate</code></td>
<td>
<p>An <code class="reqn">n \times p</code> covariate matrix. The rows correspond to nodes and the columns correspond
to covariates.</p>
</td></tr>
<tr><td><code id="CAclustering_+3A_k">K</code></td>
<td>
<p>A positive integer which is no larger than <code class="reqn">n</code>. This is the predefined number of communities.</p>
</td></tr>
<tr><td><code id="CAclustering_+3A_alphan">alphan</code></td>
<td>
<p>The number of candidate <code class="reqn">\alpha</code>'s to try within the range <code class="reqn">(\alpha_{min}, \alpha_{max})</code> given in
Binkiewicz et al. (2017). An optimal <code class="reqn">\alpha</code> is expected to achieve a balance between <code class="reqn">L_{\tau}</code>
and <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="CAclustering_+3A_itermax">itermax</code></td>
<td>
<p><code>k-means</code> parameter, indicating the maximum number of iterations allowed.
The default value is 100.</p>
</td></tr>
<tr><td><code id="CAclustering_+3A_startn">startn</code></td>
<td>
<p><code>k-means</code> parameter. The number of times the algorithm should be run with different initial
centroids. The default value is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CAclustering</code> is an algorithm designed for community detection in networks with node covariates,
as introduced in the paper <em>Covariate-assisted spectral clustering</em> of Binkiewicz et al. (2017).
<code>CAclustering</code> applies
<code>k-means</code> on the first <code class="reqn">K</code> leading eigenvectors of <code class="reqn">L_{\tau}+\alpha XX^{\prime}</code>, where
<code class="reqn">L_{\tau}</code> is the regularized graph Laplacian, <code class="reqn">X</code> is the covariates matrix, and <code class="reqn">\alpha</code> is
a tuning parameter.
</p>


<h3>Value</h3>

<table>
<tr><td><code>estall</code></td>
<td>
<p>A factor indicating nodes' labels. Items sharing the same label are in the same community.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Binkiewicz, N., Vogelstein, J. T., &amp; Rohe, K. (2017). Covariate-assisted spectral clustering.
<em>Biometrika</em>, 104(2), 361-377. <br /><a href="https://doi.org/10.1093/biomet/asx008">doi:10.1093/biomet/asx008</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate the Network
n = 10; K = 2; p =5; prob1 = 0.9;
theta = 0.4 + (0.45-0.05)*(seq(1:n)/n)^2; Theta = diag(theta);
P  = matrix(c(0.8, 0.2, 0.2, 0.8), byrow = TRUE, nrow = K)
set.seed(2022)
l = sample(1:K, n, replace=TRUE); # node labels
Pi = matrix(0, n, K) # label matrix
for (k in 1:K){
  Pi[l == k, k] = 1
}
Omega = Theta %*% Pi %*% P %*% t(Pi) %*% Theta;
Adj = matrix(runif(n*n, 0, 1), nrow = n);
Adj = Omega - Adj;
Adj = 1*(Adj &gt;= 0)
diag(Adj) = 0
Adj[lower.tri(Adj)] = t(Adj)[lower.tri(Adj)]
Q = 0.1*matrix(sign(runif(p*K) - 0.5), nrow = p);
for(i in 1:K){
  Q[(i-1)*(p/K)+(1:(p/K)), i] = 0.3; #remark. has a change here
}
W = matrix(0, nrow = n, ncol = K);
for(jj in 1:n) {
  pp = rep(1/(K-1), K); pp[l[jj]] = 0;
  if(runif(1) &lt;= prob1) {W[jj, 1:K] = Pi[jj, ];}
  else
  W[jj, sample(K, 1, prob = pp)] = 1;
  }
W = t(W)
D0 = Q %*% W
D = matrix(0, n, p)
for (i in 1:n){
  D[i,] = rnorm(p, mean = D0[,i], sd = 1);
}
CAclustering(Adj, D, 2)
</code></pre>

<hr>
<h2 id='Cov_based'>Covariates-based Spectral Clustering.</h2><span id='topic+Cov_based'></span>

<h3>Description</h3>

<p><em>Covariates-based Spectral Clustering</em> is a spectral clustering
method that focuses solely on the covariates structure, i.e., the <code class="reqn">XX^{\prime}</code> where <code class="reqn">X</code> is the
covariates matrix, as introduced in Lee et al. (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cov_based(Covariate, K, itermax = 100, startn = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cov_based_+3A_covariate">Covariate</code></td>
<td>
<p>An <code class="reqn">n \times p</code> covariate matrix. The rows correspond to nodes and the columns
correspond to covariates.</p>
</td></tr>
<tr><td><code id="Cov_based_+3A_k">K</code></td>
<td>
<p>A positive integer which is no larger than <code class="reqn">n</code>. This is the predefined number of communities.</p>
</td></tr>
<tr><td><code id="Cov_based_+3A_itermax">itermax</code></td>
<td>
<p><code>k-means</code> parameter, indicating the maximum number of
iterations allowed. The default value is 100.</p>
</td></tr>
<tr><td><code id="Cov_based_+3A_startn">startn</code></td>
<td>
<p><code>k-means</code> parameter. The number of times the algorithm should be run with different initial
centroids. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>estall</code></td>
<td>
<p>A factor indicating nodes' labels. Items sharing the same label are in the same community.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, A. B., Luca, D., Klei, L., Devlin, B., &amp; Roeder, K. (2010).
Discovering genetic ancestry using spectral graph theory.
<em>Genetic Epidemiology: The Official Publication of the International Genetic Epidemiology Society</em>,
34(1), 51-59. <br /><a href="https://doi.org/10.1002/gepi.20434">doi:10.1002/gepi.20434</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate the Covariate Matrix
n = 10; p = 5; K = 2; prob1 = 0.9;
set.seed(2022)
l = sample(1:K, n, replace=TRUE); # node labels
Pi = matrix(0, n, K) # label matrix
for (k in 1:K){
  Pi[l == k, k] = 1
}
Q = 0.1*matrix(sign(runif(p*K) - 0.5), nrow = p);
for(i in 1:K){
  Q[(i-1)*(p/K)+(1:(p/K)), i] = 0.3; #remark. has a change here
}
W = matrix(0, nrow = n, ncol = K);
for(jj in 1:n) {
  pp = rep(1/(K-1), K); pp[l[jj]] = 0;
  if(runif(1) &lt;= prob1) {W[jj, 1:K] = Pi[jj, ];}
  else
  W[jj, sample(K, 1, prob = pp)] = 1;
  }
W = t(W)
D0 = Q %*% W
D = matrix(0, n, p)
for (i in 1:n){
  D[i,] = rnorm(p, mean = D0[,i], sd = 1);
}
Cov_based(D, 2)
</code></pre>

<hr>
<h2 id='NAC'>Spectral Clustering on Network-Adjusted Covariates.</h2><span id='topic+NAC'></span>

<h3>Description</h3>

<p>Using network-adjusted covariates to detect underlying communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NAC(Adj, Covariate, K, alpha = NULL, beta = 0, itermax = 100, startn = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NAC_+3A_adj">Adj</code></td>
<td>
<p>An <code class="reqn">n \times n</code> symmetric adjacency matrix with diagonals being <code class="reqn">0</code> and positive entries being
<code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="NAC_+3A_covariate">Covariate</code></td>
<td>
<p>An <code class="reqn">n\times p</code> covariate matrix. The rows correspond to nodes and the columns correspond to
covariates.</p>
</td></tr>
<tr><td><code id="NAC_+3A_k">K</code></td>
<td>
<p>A positive integer which is no larger than <code class="reqn">n</code>. This is the predefined number of communities.</p>
</td></tr>
<tr><td><code id="NAC_+3A_alpha">alpha</code></td>
<td>
<p>An optional numeric vector to tune the weight of covariate matrix. The default value is
<code class="reqn">\dfrac{\bar{d}/2}{d_i/\text{log}n+1}</code>, where <code class="reqn">d_i</code> is the degree of node <code class="reqn">i</code> and <code class="reqn">\bar{d}</code> is the
average degree.</p>
</td></tr>
<tr><td><code id="NAC_+3A_beta">beta</code></td>
<td>
<p>An optional parameter used when the covariate matrix <code class="reqn">X</code> is uninformative. By default, <code class="reqn">\beta</code>
is set as 0 assuming <code class="reqn">X</code> carries meaningful information. Otherwise, users can manually specify a positive value
to weigh network information.</p>
</td></tr>
<tr><td><code id="NAC_+3A_itermax">itermax</code></td>
<td>
<p><code>k-means</code> parameter, indicating the maximum number of iterations allowed. The default value is 100.</p>
</td></tr>
<tr><td><code id="NAC_+3A_startn">startn</code></td>
<td>
<p><code>k-means</code> parameter. The number of times the algorithm should be run with different initial
centroids. The default value is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Spectral Clustering Network-Adjusted Covariates (NAC)</em> is fully established in
<em>Network-Adjusted Covariates for Community Detection</em>
of Hu &amp; Wang (2023). This method is particularly effective in the analysis of multiscale networks with
covariates, addressing the challenge of misspecification between networks and covariates. <code>NAC</code>
relies on the construction of network-adjusted
covariate vectors <code class="reqn">y_i = \alpha_ix_i + \sum_{j: A_{ij}=1}x_j, i \in 1, \cdots, n</code>, where the first part has
the nodal covariate information and the second part conveys network information.
By constructing <code class="reqn">Y = (y_1, \cdots, y_n)^{\prime} = AX + D_{\alpha}X</code> where <code class="reqn">A</code> is the adjacency matrix,
<code class="reqn">X</code> is the covariate matrix, and <code class="reqn">D_{\alpha}</code> is the diagonal matrix with diagonals
as <code class="reqn">\alpha_1, \cdots, \alpha_n</code>, <code>NAC</code> applies <code>K-means</code> on the first <code class="reqn">K</code> normalized left
singular vectors, treating each row as a data point.
A notable feature of <code>NAC</code> is its tuning-free nature, where node-specific coefficient <code class="reqn">\alpha_i</code> is
computed given the <code class="reqn">i</code>-th node's degree. <code>NAC</code> allows for
user-specified <code class="reqn">\alpha_i</code> as well. A generalization with uninformative covariates is considered by adjusting
parameter <code class="reqn">\beta</code>. As long as the covariates do provide information, the specification of <code class="reqn">\beta</code> can be
ignored.
</p>


<h3>Value</h3>

<table>
<tr><td><code>estall</code></td>
<td>
<p>A factor indicating nodes' labels. Items sharing the same label are in the same community.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hu, Y., &amp; Wang, W. (2023). Network-Adjusted Covariates for Community Detection.
<em>arXiv preprint arXiv:2306.15616</em>. <br /><a href="https://arxiv.org/abs/2306.15616">https://arxiv.org/abs/2306.15616</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate the Network
n = 10; K = 2; p =5; prob1 = 0.9;
theta = 0.4 + (0.45-0.05)*(seq(1:n)/n)^2; Theta = diag(theta);
P  = matrix(c(0.8, 0.2, 0.2, 0.8), byrow = TRUE, nrow = K)
set.seed(2022)
l = sample(1:K, n, replace=TRUE); # node labels
Pi = matrix(0, n, K) # label matrix
for (k in 1:K){
  Pi[l == k, k] = 1
}
Omega = Theta %*% Pi %*% P %*% t(Pi) %*% Theta;
Adj = matrix(runif(n*n, 0, 1), nrow = n);
Adj = Omega - Adj;
Adj = 1*(Adj &gt;= 0)
diag(Adj) = 0
Adj[lower.tri(Adj)] = t(Adj)[lower.tri(Adj)]
Q = 0.1*matrix(sign(runif(p*K) - 0.5), nrow = p);
for(i in 1:K){
  Q[(i-1)*(p/K)+(1:(p/K)), i] = 0.3; #remark. has a change here
}
W = matrix(0, nrow = n, ncol = K);
for(jj in 1:n) {
  pp = rep(1/(K-1), K); pp[l[jj]] = 0;
  if(runif(1) &lt;= prob1) {W[jj, 1:K] = Pi[jj, ];}
  else
  W[jj, sample(K, 1, prob = pp)] = 1;
  }
W = t(W)
D0 = Q %*% W
D = matrix(0, n, p)
for (i in 1:n){
  D[i,] = rnorm(p, mean = D0[,i], sd = 1);
}
NAC(Adj, D, 2)
</code></pre>

<hr>
<h2 id='Net_based'>Network-based Regularized Spectral Clustering.</h2><span id='topic+Net_based'></span>

<h3>Description</h3>

<p><em>Network-based Regularized Spectral Clustering</em> is a spectral clustering with regularized
Laplacian method, fully established in fully established in <em>Impact of Regularization on Spectral Clustering</em>
of Joseph &amp; Yu (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Net_based(Adj, K, tau = NULL, itermax = 100, startn = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Net_based_+3A_adj">Adj</code></td>
<td>
<p>An <code class="reqn">n \times n</code> symmetric adjacency matrix with diagonals being <code class="reqn">0</code> and positive entries
being <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="Net_based_+3A_k">K</code></td>
<td>
<p>A positive positive integer which is no larger than <code class="reqn">n</code>. This is the predefined number
of communities.</p>
</td></tr>
<tr><td><code id="Net_based_+3A_tau">tau</code></td>
<td>
<p>An optional tuning parameter to add <code class="reqn">J</code> to the adjacency matrix <code class="reqn">A</code>, where <code class="reqn">J</code> is a
constant matrix with all entries equal to <code class="reqn">1/n</code>. The default value is the mean of nodes' degrees.</p>
</td></tr>
<tr><td><code id="Net_based_+3A_itermax">itermax</code></td>
<td>
<p><code>k-means</code> parameter, indicating the maximum number of
iterations allowed. The default value is 100.</p>
</td></tr>
<tr><td><code id="Net_based_+3A_startn">startn</code></td>
<td>
<p><code>k-means</code> parameter. The number of times the algorithm should be run with different initial
centroids. The default value is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>estall</code></td>
<td>
<p>A factor indicating nodes' labels. Items sharing the same label are in the same community.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Joseph, A., &amp; Yu, B. (2016). Impact of Regularization on Spectral Clustering.
<em>The Annals of Statistics</em>, 44(4), 1765-1791. <br /><a href="https://doi.org/10.1214/16-AOS1447">doi:10.1214/16-AOS1447</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate the Network
n = 10; K = 2;
theta = 0.4 + (0.45-0.05)*(seq(1:n)/n)^2; Theta = diag(theta);
P  = matrix(c(0.8, 0.2, 0.2, 0.8), byrow = TRUE, nrow = K)
set.seed(2022)
l = sample(1:K, n, replace=TRUE); # node labels
Pi = matrix(0, n, K) # label matrix
for (k in 1:K){
  Pi[l == k, k] = 1
}
Omega = Theta %*% Pi %*% P %*% t(Pi) %*% Theta;
Adj = matrix(runif(n*n, 0, 1), nrow = n);
Adj = Omega - Adj;
Adj = 1*(Adj &gt;= 0)
diag(Adj) = 0
Adj[lower.tri(Adj)] = t(Adj)[lower.tri(Adj)]
Net_based(Adj, 2)
</code></pre>

<hr>
<h2 id='SCORE'>Spectral Clustering On Ratios-of-Eigenvectors.</h2><span id='topic+SCORE'></span>

<h3>Description</h3>

<p>Using ratios-of-eigenvectors to detect underlying communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCORE(G, K, itermax = 100, startn = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCORE_+3A_g">G</code></td>
<td>
<p>An <code class="reqn">n \times n</code> symmetric adjacency matrix with diagonals being <code class="reqn">0</code> and positive
entries being <code class="reqn">1</code>, where isolated nodes are not allowed.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_k">K</code></td>
<td>
<p>A positive integer which is no larger than <code class="reqn">n</code>. This is the predefined number of communities.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_itermax">itermax</code></td>
<td>
<p><code>k-means</code> parameter, indicating the maximum number of
iterations allowed. The default value is 100.</p>
</td></tr>
<tr><td><code id="SCORE_+3A_startn">startn</code></td>
<td>
<p><code>k-means</code> parameter. The number of times the algorithm should be run with different initial
centroids. The default value is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SCORE</code> is fully established in <em>Fast community detection by
SCORE</em> of Jin (2015). <code>SCORE</code> uses the entrywise ratios between the
first leading eigenvector and each of the other <code class="reqn">K-1</code> leading eigenvectors for
clustering. It is noteworthy that SCORE only works on connected graphs.
In other words, it does not allow for isolated vertices.
</p>


<h3>Value</h3>

<table>
<tr><td><code>estall</code></td>
<td>
<p>A factor indicating nodes' labels. Items sharing the same label are in the same community.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jin, J. (2015). Fast community detection by score.
<em>The Annals of Statistics</em>, 43 (1), 57â€“89.<br /><a href="https://doi.org/10.1214/14-AOS1265">doi:10.1214/14-AOS1265</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate the Network
n = 10; K = 2;
theta = 0.4 + (0.45-0.05)*(seq(1:n)/n)^2; Theta = diag(theta);
P  = matrix(c(0.8, 0.2, 0.2, 0.8), byrow = TRUE, nrow = K)
set.seed(2022)
l = sample(1:K, n, replace=TRUE); # node labels
Pi = matrix(0, n, K) # label matrix
for (k in 1:K){
  Pi[l == k, k] = 1
}
Omega = Theta %*% Pi %*% P %*% t(Pi) %*% Theta;
Adj = matrix(runif(n*n, 0, 1), nrow = n);
Adj = Omega - Adj;
Adj = 1*(Adj &gt;= 0)
diag(Adj) = 0
Adj[lower.tri(Adj)] = t(Adj)[lower.tri(Adj)]
library(igraph)
is.igraph(Adj) # [1] FALSE
ix = components(graph.adjacency(Adj))
componentLabel = ix$membership
giantLabel = which(componentLabel == which.max(ix$csize))
Giant = Adj[giantLabel, giantLabel]
SCORE(Giant, 2)

</code></pre>

<hr>
<h2 id='SDP'>Semidefinite programming for Community Detection in Networks with Covariates.</h2><span id='topic+SDP'></span>

<h3>Description</h3>

<p>Semidefinite programming (SDP) for optimizing the inner product between combined network and the
solution matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SDP(
  Adj,
  Covariate,
  lambda,
  K,
  alpha,
  rho,
  TT,
  tol,
  quiet = NULL,
  report_interval = NULL,
  r = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SDP_+3A_adj">Adj</code></td>
<td>
<p>An <code class="reqn">n \times n</code> symmetric adjacency matrix with diagonals being <code class="reqn">0</code> and positive entries
being <code class="reqn">1</code>.</p>
</td></tr>
<tr><td><code id="SDP_+3A_covariate">Covariate</code></td>
<td>
<p>An <code class="reqn">n \times p</code> covariate matrix. The rows correspond to nodes and the columns correspond to
covariates.</p>
</td></tr>
<tr><td><code id="SDP_+3A_lambda">lambda</code></td>
<td>
<p>A tuning parameter to weigh the covariate matrix.</p>
</td></tr>
<tr><td><code id="SDP_+3A_k">K</code></td>
<td>
<p>A positive integer which is no larger than <code class="reqn">n</code>. This is the predefined number of communities.</p>
</td></tr>
<tr><td><code id="SDP_+3A_alpha">alpha</code></td>
<td>
<p>The element-wise upper bound in the <code>SDP</code>.</p>
</td></tr>
<tr><td><code id="SDP_+3A_rho">rho</code></td>
<td>
<p>The learning rate of <code>SDP</code>.</p>
</td></tr>
<tr><td><code id="SDP_+3A_tt">TT</code></td>
<td>
<p>The maximum of iteration.</p>
</td></tr>
<tr><td><code id="SDP_+3A_tol">tol</code></td>
<td>
<p>The tolerance for stopping criterion.</p>
</td></tr>
<tr><td><code id="SDP_+3A_quiet">quiet</code></td>
<td>
<p>An optional input, indicating whether to print result at each step.</p>
</td></tr>
<tr><td><code id="SDP_+3A_report_interval">report_interval</code></td>
<td>
<p>An optional input. The frequency to print intermediate result.</p>
</td></tr>
<tr><td><code id="SDP_+3A_r">r</code></td>
<td>
<p>An optional input. The expected rank of the solution, leave <code>NULL</code> if no constraint is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SDP</code> is proposed in <em>Covariate Regularized Community Detection in Sparse Graphs</em>
of Yan &amp; Sarkar (2021). This method relies on semidefinite programming relaxations for detecting
the community structure in sparse networks with covariates.
</p>


<h3>Value</h3>

<table>
<tr><td><code>estall</code></td>
<td>
<p>A factor indicating nodes' labels. Items sharing the same label are in the same community.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Yan, B., &amp; Sarkar, P. (2021). Covariate Regularized Community Detection in Sparse Graphs.
<em>Journal of the American Statistical Association</em>, 116(534), 734-745.
<br /><a href="https://doi.org/10.1080/01621459.2019.1706541">doi:10.1080/01621459.2019.1706541</a><br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate the Network
n = 10; K = 2; p =5; prob1 = 0.9;
theta = 0.4 + (0.45-0.05)*(seq(1:n)/n)^2; Theta = diag(theta);
P  = matrix(c(0.8, 0.2, 0.2, 0.8), byrow = TRUE, nrow = K)
set.seed(2022)
l = sample(1:K, n, replace=TRUE); # node labels
Pi = matrix(0, n, K) # label matrix
for (k in 1:K){
  Pi[l == k, k] = 1
}
Omega = Theta %*% Pi %*% P %*% t(Pi) %*% Theta;
Adj = matrix(runif(n*n, 0, 1), nrow = n);
Adj = Omega - Adj;
Adj = 1*(Adj &gt;= 0)
diag(Adj) = 0
Adj[lower.tri(Adj)] = t(Adj)[lower.tri(Adj)]
Q = 0.1*matrix(sign(runif(p*K) - 0.5), nrow = p);
for(i in 1:K){
  Q[(i-1)*(p/K)+(1:(p/K)), i] = 0.3; #remark. has a change here
}
W = matrix(0, nrow = n, ncol = K);
for(jj in 1:n) {
  pp = rep(1/(K-1), K); pp[l[jj]] = 0;
  if(runif(1) &lt;= prob1) {W[jj, 1:K] = Pi[jj, ];}
  else
  W[jj, sample(K, 1, prob = pp)] = 1;
  }
W = t(W)
D0 = Q %*% W
D = matrix(0, n, p)
for (i in 1:n){
  D[i,] = rnorm(p, mean = D0[,i], sd = 1);
}
SDP(Adj, D, lambda = 0.2, K = 2, alpha = 0.5, rho = 2, TT = 100, tol = 5)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
