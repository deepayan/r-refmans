<!DOCTYPE html><html lang="en"><head><title>Help for package FlexRL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FlexRL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cartesianProduct'><p>cartesianProduct</p></a></li>
<li><a href='#createDataAlpha'><p>createDataAlpha</p></a></li>
<li><a href='#DataCreation'><p>DataCreation</p></a></li>
<li><a href='#Deltafind'><p>Deltafind()</p></a></li>
<li><a href='#ExpandGrid'><p>ExpandGrid</p></a></li>
<li><a href='#F2'><p>F2</p></a></li>
<li><a href='#F33'><p>F33</p></a></li>
<li><a href='#FlexRL'><p>FlexRL</p></a></li>
<li><a href='#generateSequence'><p>generateSequence</p></a></li>
<li><a href='#initDeltaMap'><p>initDeltaMap</p></a></li>
<li><a href='#launchNaive'><p>launchNaive</p></a></li>
<li><a href='#loglik'><p>loglik</p></a></li>
<li><a href='#loglikSurvival'><p>The log likelihood of the survival function with exponential model (-)</p></a></li>
<li><a href='#logPossibleConfig'><p>logPossibleConfig</p></a></li>
<li><a href='#sampleD'><p>sampleD</p></a></li>
<li><a href='#sampleH'><p>sampleH</p></a></li>
<li><a href='#sampleL'><p>sampleNL</p></a></li>
<li><a href='#sampleNL'><p>sampleNL</p></a></li>
<li><a href='#simulateD'><p>simulateD</p></a></li>
<li><a href='#simulateH'><p>simulateH</p></a></li>
<li><a href='#sspaste2'><p>sspaste2</p></a></li>
<li><a href='#stEM'><p>Stochastic Expectation Maximisation (StEM) for Record Linkage</p></a></li>
<li><a href='#SurvivalUnstable'><p>The survival function with exponential model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Flexible Model for Record Linkage</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of the Stochastic Expectation Maximisation (StEM) approach to Record Linkage described in the paper by K. Robach, S. L. van der Pas, M. A. van de Wiel and M. H. Hof (2024, &lt;<a href="https://doi.org/10.48550%2FarXiv.2407.06835">doi:10.48550/arXiv.2407.06835</a>&gt;); see 'citation("FlexRL")' for details. This is a record linkage method, for finding the common set of records among 2 data sources based on Partially Identifying Variables (PIVs) available in both sources. It includes modelling of dynamic Partially Identifying Variables (e.g. postal code) that may evolve over time and registration errors (missing values and mistakes in the registration). Low memory footprint.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.7), progress(&ge; 1.2.3), testit(&ge; 0.13), Rcpp(&ge;
1.0.13)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-06 12:59:19 UTC; kayane</td>
</tr>
<tr>
<td>Author:</td>
<td>Kayané ROBACH <a href="https://orcid.org/0000-0002-5725-623X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kayané ROBACH &lt;k.c.robach@amsterdamumc.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-09 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cartesianProduct'>cartesianProduct</h2><span id='topic+cartesianProduct'></span>

<h3>Description</h3>

<p>cartesianProduct
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cartesianProduct(vec1, vec2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cartesianProduct_+3A_vec1">vec1</code></td>
<td>
<p>first IntegerVector of values to compute the cartesian product</p>
</td></tr>
<tr><td><code id="cartesianProduct_+3A_vec2">vec2</code></td>
<td>
<p>second IntegerVector of values to compute the cartesian product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IntegerMatrix: of 2 columns with the cartesian product of vec1 and vec2
</p>

<hr>
<h2 id='createDataAlpha'>createDataAlpha</h2><span id='topic+createDataAlpha'></span>

<h3>Description</h3>

<p>createDataAlpha
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDataAlpha(nCoefUnstable, stable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createDataAlpha_+3A_ncoefunstable">nCoefUnstable</code></td>
<td>
<p>An integer value with the number of covariates (including the intercept): number of cov from A + number of cov from B + 1.</p>
</td></tr>
<tr><td><code id="createDataAlpha_+3A_stable">stable</code></td>
<td>
<p>A boolean value indicating whether the Partially Identifying Variable (PIV) concerned is stable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An empty data frame (if stable=FALSE) with nCoefUnstable + 2 columns for book keeping of the elements necessary to update the parameter for instability. There are
nCoefUnstable + 2 of those elements: number of cov from A + number of cov from B + intercept + boolean vector indicating where the true values of the records (for the concerned PIV) are equal, vector of time gaps between records
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PIVs_config = list( V1 = list(stable = TRUE),
                    V2 = list(stable = TRUE),
                    V3 = list(stable = TRUE),
                    V4 = list(stable = TRUE),
                    V5 = list( stable = FALSE,
                               conditionalHazard = FALSE,
                               pSameH.cov.A = c(),
                               pSameH.cov.B = c()) )

PIVs_stable = sapply(PIVs_config, function(x) x$stable)

nCoefUnstable = c(0,0,0,0,1)

Valpha = mapply( createDataAlpha,
                 nCoefUnstable = nCoefUnstable,
                 stable = PIVs_stable,
                 SIMPLIFY=FALSE)
</code></pre>

<hr>
<h2 id='DataCreation'>DataCreation</h2><span id='topic+DataCreation'></span>

<h3>Description</h3>

<p>This function is used to synthesise data for record linkage. It creates 2 data sources of specific sizes, with a common set of records of a specific size, with a certain amount of Partially Identifying Variables (PIVs).
For each PIV, we specify the number of unique values, the desired proportion of mistakes and missing values. They can be stable or evolving over time (e.g. representing the postal code).
For the unstable PIVs, we can specify the parameter(s) to be used in the survival exponential model that generates changes over time between the records referring to the same entities.
When a PIV is unstable, it is later harder to estimate its parameters (probability of mistake vs. probability of change across time). Therefore we may want to enforce estimability in the synthetic data, which we do by
enforcing half of the links to have a near-zero time gaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DataCreation(
  PIVs_config,
  Nval,
  NRecords,
  Nlinks,
  PmistakesA,
  PmistakesB,
  PmissingA,
  PmissingB,
  moving_params,
  enforceEstimability
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DataCreation_+3A_pivs_config">PIVs_config</code></td>
<td>
<p>A list (of size number of PIVs) where element names are the PIVs and element values are lists with elements: stable (boolean for whether the PIV is stable), conditionalHazard (boolean for whether there are external covariates available to model instability, only required if stable is FALSE), pSameH.cov.A and pSameH.covB (vectors with strings corresponding to the names of the covariates to use to model instability from file A and file B, only required if stable is FALSE, empty vectors may be provided if conditionalHazard is FALSE)</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_nval">Nval</code></td>
<td>
<p>A vector (of size number of PIVs) with the number fo unique values per PIVs (in the order of the PIVs defined in PIVs_config)</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_nrecords">NRecords</code></td>
<td>
<p>A vector (of size 2) with the number of records to be generated in file A and in file B</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_nlinks">Nlinks</code></td>
<td>
<p>An integer with the number of links (record referring to the same entities) to be generated</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_pmistakesa">PmistakesA</code></td>
<td>
<p>A vector (of size number of PIVs) with the proportion of mistakes to be generated per PIVs in file A (in the order of the PIVs defined in PIVs_config)</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_pmistakesb">PmistakesB</code></td>
<td>
<p>A vector (of size number of PIVs) with the proportion of mistakes to be generated per PIVs in file B (in the order of the PIVs defined in PIVs_config)</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_pmissinga">PmissingA</code></td>
<td>
<p>A vector (of size number of PIVs) with the proportion of missing to be generated per PIVs in file A (in the order of the PIVs defined in PIVs_config)</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_pmissingb">PmissingB</code></td>
<td>
<p>A vector (of size number of PIVs) with the proportion of missing to be generated per PIVs in file A (in the order of the PIVs defined in PIVs_config)</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_moving_params">moving_params</code></td>
<td>
<p>A list (of size number of PIVs) where element names are the PIVs and element values are vectors (of size: 1 + number of covariates to use from A + number of covariates to use from B) with the log hazards coefficient (1st one: log baseline hazard, then: the coefficients for conditional hazard covariates from A, then: the coefficients for conditional hazard covariates from B)</p>
</td></tr>
<tr><td><code id="DataCreation_+3A_enforceestimability">enforceEstimability</code></td>
<td>
<p>A boolean value for whether half of the links should have near-0 time gaps (useful for modeling instability and avoiding estimability issues as discussed in the paper)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are more details to understand the method in our paper, or on the experiments repository of our paper, or in the vignettes.
</p>


<h3>Value</h3>

<p>A list with generated
</p>

<ul>
<li><p> dataframe A (encoded: the categorical values of the PIVs are matched to sets of natural numbers),
</p>
</li>
<li><p> dataframe B (encoded),
</p>
</li>
<li><p> vector of Nvalues (Nval),
</p>
</li>
<li><p> vector of TimeDifference (for the links, when thewre is instability),
</p>
</li>
<li><p> matrix proba_same_H (number of links, number fo PIVs) with the proba that true values coincide (e.g. 1 - proba of moving)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>PIVs_config = list( V1 = list(stable = TRUE),
                    V2 = list(stable = TRUE),
                    V3 = list(stable = TRUE),
                    V4 = list(stable = TRUE),
                    V5 = list( stable = FALSE,
                               conditionalHazard = FALSE,
                               pSameH.cov.A = c(),
                               pSameH.cov.B = c()) )
Nval = c(6, 7, 8, 9, 15)
NRecords = c(500, 800)
Nlinks = 300
PmistakesA = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmistakesB = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmissingA = c(0.007, 0.007, 0.007, 0.007, 0.007)
PmissingB = c(0.007, 0.007, 0.007, 0.007, 0.007)
moving_params = list(V1=c(),V2=c(),V3=c(),V4=c(),V5=c(0.28))
enforceEstimability = TRUE
DataCreation( PIVs_config,
              Nval,
              NRecords,
              Nlinks,
              PmistakesA,
              PmistakesB,
              PmissingA,
              PmissingB,
              moving_params,
              enforceEstimability)
</code></pre>

<hr>
<h2 id='Deltafind'>Deltafind()</h2><span id='topic+Deltafind'></span>

<h3>Description</h3>

<p>Deltafind()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Deltafind()
</code></pre>


<h3>Value</h3>

<p>IntegerMatrix: find the indices of the elements in the cpp map _DeltaMap representing the sparse linkage matrix Delta.
</p>

<hr>
<h2 id='ExpandGrid'>ExpandGrid</h2><span id='topic+ExpandGrid'></span>

<h3>Description</h3>

<p>ExpandGrid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpandGrid(vector1, vector2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpandGrid_+3A_vector1">vector1</code></td>
<td>
<p>first IntegerVector of values to compute the cartesian product</p>
</td></tr>
<tr><td><code id="ExpandGrid_+3A_vector2">vector2</code></td>
<td>
<p>second IntegerVector of values to compute the cartesian product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IntegerMatrix: of 2 columns with the cartesian product of vec1 and vec2
</p>

<hr>
<h2 id='F2'>F2</h2><span id='topic+F2'></span>

<h3>Description</h3>

<p>F2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F2(U, nvals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F2_+3A_u">U</code></td>
<td>
<p>IntegerVector with factor values corresponding to the patterns of Partially Identifying Variables (PIVs) observed among records in the concerned source</p>
</td></tr>
<tr><td><code id="F2_+3A_nvals">nvals</code></td>
<td>
<p>integer for the total number of possible patterns (among all sources)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List: for each pattern in value, count of the records having the pattern in the concerned source
</p>

<hr>
<h2 id='F33'>F33</h2><span id='topic+F33'></span>

<h3>Description</h3>

<p>F33
</p>


<h3>Usage</h3>

<pre><code class='language-R'>F33(A, B, nvals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="F33_+3A_a">A</code></td>
<td>
<p>List with for each pattern in value, count of the records having the pattern in the concerned source</p>
</td></tr>
<tr><td><code id="F33_+3A_b">B</code></td>
<td>
<p>List with for each pattern in value, count of the records having the pattern in the concerned source</p>
</td></tr>
<tr><td><code id="F33_+3A_nvals">nvals</code></td>
<td>
<p>integer for the total number of possible patterns (among all sources)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IntegerMatrix: nrow=nbr of potential links, ncol = 2, indicates the indices (of records from A, records from B) of records with matching patterns to be considered in the likelihood as potential links. It represents the cartesian product of both lists passed as parameters to represent all possible linked pairs of records.
</p>

<hr>
<h2 id='FlexRL'>FlexRL</h2><span id='topic+FlexRL'></span>

<h3>Description</h3>

<p>A Flexible Model For Record Linkage
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FlexRL_+3A_data">data</code></td>
<td>
<p>is a list gathering information on the data to be linked
</p>

<ul>
<li><p> sources 'A' and 'B',
</p>
</li>
<li><p> a vector 'Nvalues' gathering the number of unique values in each PIV,
</p>
</li>
<li><p> 'PIVs_config' the list of PIVs to use for Record Linkage and details on how each should be handled by the algorithm,
</p>
</li>
<li><p> potential bounds on the mistakes probabilities for each PIV: 'controlOnMistakes',
</p>
</li>
<li><p> 'sameMistakes' whether there should be one parameter for the mistakes in A and B or whether each source should have its own (in case of small data sources it is recommended to set sameMistakes=TRUE)
</p>
</li>
<li><p> whether the parameters for mistakes should be fixed in case of instability 'phiMistakesAFixed' and 'phiMistakesBFixed',
</p>
</li>
<li><p> as well as the values they should be fixed to 'phiForMistakesA' and 'phiForMistakesB'
</p>
</li></ul>
</td></tr>
<tr><td><code id="FlexRL_+3A_stemiter">StEMIter</code></td>
<td>
<p>The total number of iterations of the Stochastic Expectation Maximisation (StEM) algorithm (including the period to discard as burn-in)</p>
</td></tr>
<tr><td><code id="FlexRL_+3A_stemburnin">StEMBurnin</code></td>
<td>
<p>The number of iterations to discard as burn-in</p>
</td></tr>
<tr><td><code id="FlexRL_+3A_gibbsiter">GibbsIter</code></td>
<td>
<p>The total number of iterations of the Gibbs sampler
(run in each iteration of the StEM) (including the period to discard as burn-in)</p>
</td></tr>
<tr><td><code id="FlexRL_+3A_gibbsburnin">GibbsBurnin</code></td>
<td>
<p>The number of iterations to discard as burn-in</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The example below aims to link 2 synthetic data sources, with 5 PIVs (4 stable ones and 1 unstable, which evolve over time).
PIVs may be considered stable if there is not enough information to model their dynamics. Since we synthesise the data we can model it.
We may not give a bound on some PIVs in real settings, since there may be a lot of disagreements among the links for those variables (in situations where we would have liked to model their dynamics otherwise but we do not have enough information for this).
Here we bound all the mistakes parameters since we know that the mistakes probabilities are inferior to 10%.
For a small example we prefer having one parameter for the probabilities of mistakes over the 2 data sources.
We do need to fix the mistake parameter of the 5th PIV to avoid estimability problems here (since it is an 'unstable' variable).
We know the true linkage structure in this example so we can compute performances of the method at the end.
</p>
<p>There are more details to understand the method in our paper, or on the experiments repository of our paper, or in the vignettes, or in the documentation of the main algorithm ?FlexRL::StEM.
</p>


<h3>Value</h3>

<p>The Stochastic Expectation Maximisation (StEM) function returns w list with:
</p>

<ul>
<li><p> Delta, the (sparse) matrix with the pairs of records linked and their posterior probabilities to be linked (select the pairs where the proba&gt;0.5 to get a valid set of linked records),
</p>
</li>
<li><p> as well as the model parameters chains:
</p>

<ul>
<li><p> gamma,
</p>
</li>
<li><p> eta,
</p>
</li>
<li><p> alpha,
</p>
</li>
<li><p> phi.
</p>
</li></ul>

</li></ul>



<h3>Author(s)</h3>

<p>Kayané Robach
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PIVs_config = list( V1 = list(stable = TRUE),
                    V2 = list(stable = TRUE),
                    V3 = list(stable = TRUE),
                    V4 = list(stable = TRUE),
                    V5 = list( stable = FALSE,
                               conditionalHazard = FALSE,
                               pSameH.cov.A = c(),
                               pSameH.cov.B = c()) )
PIVs = names(PIVs_config)
PIVs_stable = sapply(PIVs_config, function(x) x$stable)
Nval = c(6, 7, 8, 9, 15)
NRecords = c(500, 800)
Nlinks = 300
PmistakesA = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmistakesB = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmissingA = c(0.007, 0.007, 0.007, 0.007, 0.007)
PmissingB = c(0.007, 0.007, 0.007, 0.007, 0.007)
moving_params = list(V1=c(),V2=c(),V3=c(),V4=c(),V5=c(0.28))
enforceEstimability = TRUE
DATA = DataCreation( PIVs_config,
                     Nval,
                     NRecords,
                     Nlinks,
                     PmistakesA,
                     PmistakesB,
                     PmissingA,
                     PmissingB,
                     moving_params,
                     enforceEstimability)
A                    = DATA$A
B                    = DATA$B
Nvalues              = DATA$Nvalues
TimeDifference       = DATA$TimeDifference
proba_same_H         = DATA$proba_same_H

# the first 1:Nlinks records of each files created are links
TrueDelta = base::data.frame( matrix(0, nrow=0, ncol=2) )
for (i in 1:Nlinks)
{
  TrueDelta = rbind(TrueDelta, cbind(rownames(A[i,]),rownames(B[i,])))
}
true_pairs = do.call(paste, c(TrueDelta, list(sep="_")))

encodedA = A
encodedB = B

encodedA[,PIVs][ is.na(encodedA[,PIVs]) ] = 0
encodedB[,PIVs][ is.na(encodedB[,PIVs]) ] = 0

data = list( A                    = encodedA,
             B                    = encodedB,
             Nvalues              = Nvalues,
             PIVs_config          = PIVs_config,
             controlOnMistakes    = c(TRUE, TRUE, TRUE, TRUE, TRUE),
             sameMistakes         = TRUE,
             phiMistakesAFixed    = TRUE,
             phiMistakesBFixed    = TRUE,
             phiForMistakesA      = c(NA, NA, NA, NA, 0),
             phiForMistakesB      = c(NA, NA, NA, NA, 0)
           )

fit = FlexRL::stEM(  data                 = data,
                     StEMIter             = 50,
                     StEMBurnin           = 30,
                     GibbsIter            = 50,
                     GibbsBurnin          = 30,
                     musicOn              = TRUE,
                     newDirectory         = NULL,
                     saveInfoIter         = FALSE
                  )

DeltaResult = fit$Delta
colnames(DeltaResult) = c("idxA","idxB","probaLink")
DeltaResult = DeltaResult[DeltaResult$probaLink&gt;0.5,]

results = base::data.frame( Results=matrix(NA, nrow=6, ncol=1) )
rownames(results) = c("tp","fp","fn","f1score","fdr","sens.")
if(nrow(DeltaResult)&gt;1){
  linked_pairs    = do.call(paste, c(DeltaResult[,c("idxA","idxB")], list(sep="_")))
  truepositive    = length( intersect(linked_pairs, true_pairs) )
  falsepositive   = length( setdiff(linked_pairs, true_pairs) )
  falsenegative   = length( setdiff(true_pairs, linked_pairs) )
  precision       = truepositive / (truepositive + falsepositive)
  fdr             = 1 - precision
  sensitivity     = truepositive / (truepositive + falsenegative)
  f1score         = 2 * (precision * sensitivity) / (precision + sensitivity)
  results[,"FlexRL"] = c(truepositive,falsepositive,falsenegative,f1score,fdr,sensitivity)
}


</code></pre>

<hr>
<h2 id='generateSequence'>generateSequence</h2><span id='topic+generateSequence'></span>

<h3>Description</h3>

<p>generateSequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSequence(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateSequence_+3A_n">n</code></td>
<td>
<p>integer superior to 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IntegerVector: with n values from 1 to n
</p>

<hr>
<h2 id='initDeltaMap'>initDeltaMap</h2><span id='topic+initDeltaMap'></span>

<h3>Description</h3>

<p>initDeltaMap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initDeltaMap()
</code></pre>


<h3>Value</h3>

<p>void: Initialise the cpp map _DeltaMap representing the sparse linkage matrix Delta.
</p>

<hr>
<h2 id='launchNaive'>launchNaive</h2><span id='topic+launchNaive'></span>

<h3>Description</h3>

<p>launchNaive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launchNaive(PIVs, encodedA, encodedB)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="launchNaive_+3A_pivs">PIVs</code></td>
<td>
<p>A vector of size the number of Partially Identifying Variables (PIVs) with their names (as columns names in the data sources).</p>
</td></tr>
<tr><td><code id="launchNaive_+3A_encodeda">encodedA</code></td>
<td>
<p>One data source (encoded: the categorical values of the PIVs have to be mapped to sets of natural numbers and missing values are encoded as 0).</p>
</td></tr>
<tr><td><code id="launchNaive_+3A_encodedb">encodedB</code></td>
<td>
<p>The other data source (encoded).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The linkage set, a dataframe of 2 columns with indices from the first data source (A) and the second one (B) for which all the PIVs (when non-missing) matches in their values. When a PIV is missing, this method will match the record to all the records in the other file for which all other values of the PIVs match.
Therefore, this 'naive' (or 'simplistic') method does not enforce the one-to-one assignment constraint of record linkage (one record in one file can at most be linked to one record in the other file).
This method should only be used to judge the difficulty of the record linkage task: it gives information about the amount of duplicates between files and the discriminative power of all the PIVs together as a way to link the records.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PIVs_config = list( V1 = list(stable = TRUE),
                    V2 = list(stable = TRUE),
                    V3 = list(stable = TRUE),
                    V4 = list(stable = TRUE),
                    V5 = list( stable = FALSE,
                               conditionalHazard = FALSE,
                               pSameH.cov.A = c(),
                               pSameH.cov.B = c()) )
PIVs = names(PIVs_config)
PIVs_stable = sapply(PIVs_config, function(x) x$stable)
Nval = c(6, 7, 8, 9, 15)
NRecords = c(500, 800)
Nlinks = 300
PmistakesA = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmistakesB = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmissingA = c(0.007, 0.007, 0.007, 0.007, 0.007)
PmissingB = c(0.007, 0.007, 0.007, 0.007, 0.007)
moving_params = list(V1=c(),V2=c(),V3=c(),V4=c(),V5=c(0.28))
enforceEstimability = TRUE
DATA = DataCreation( PIVs_config,
                     Nval,
                     NRecords,
                     Nlinks,
                     PmistakesA,
                     PmistakesB,
                     PmissingA,
                     PmissingB,
                     moving_params,
                     enforceEstimability)
A                    = DATA$A
B                    = DATA$B
Nvalues              = DATA$Nvalues
TimeDifference       = DATA$TimeDifference
proba_same_H         = DATA$proba_same_H

TrueDelta = base::data.frame( matrix(0, nrow=0, ncol=2) )
for (i in 1:Nlinks)
{
  TrueDelta = rbind(TrueDelta, cbind(rownames(A[i,]),rownames(B[i,])))
}
true_pairs = do.call(paste, c(TrueDelta, list(sep="_")))

encodedA = A
encodedB = B

encodedA[,PIVs][ is.na(encodedA[,PIVs]) ] = 0
encodedB[,PIVs][ is.na(encodedB[,PIVs]) ] = 0

DeltaResult = launchNaive(PIVs, encodedA, encodedB)

results = base::data.frame( Results=matrix(NA, nrow=6, ncol=1) )
rownames(results) = c("tp","fp","fn","f1score","fdr","sens.")
if(nrow(DeltaResult)&gt;1){
  linked_pairs    = do.call(paste, c(DeltaResult[,c("idxA","idxB")], list(sep="_")))
  truepositive    = length( intersect(linked_pairs, true_pairs) )
  falsepositive   = length( setdiff(linked_pairs, true_pairs) )
  falsenegative   = length( setdiff(true_pairs, linked_pairs) )
  precision       = truepositive / (truepositive + falsepositive)
  fdr             = 1 - precision
  sensitivity     = truepositive / (truepositive + falsenegative)
  f1score         = 2 * (precision * sensitivity) / (precision + sensitivity)
  results[,"Naive"] = c(truepositive,falsepositive,falsenegative,f1score,fdr,sensitivity)
}
results
</code></pre>

<hr>
<h2 id='loglik'>loglik</h2><span id='topic+loglik'></span>

<h3>Description</h3>

<p>Log(likelihood) of the linkage matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik(LLL, LLA, LLB, links, sumRowD, sumColD, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_+3A_lll">LLL</code></td>
<td>
<p>A (sparse) matrix with contributions to the complete likelihood of the linked records.</p>
</td></tr>
<tr><td><code id="loglik_+3A_lla">LLA</code></td>
<td>
<p>A vector with contributions to the complete likelihood of the non linked records from A.</p>
</td></tr>
<tr><td><code id="loglik_+3A_llb">LLB</code></td>
<td>
<p>A vector with contributions to the complete likelihood of the non linked records from B.</p>
</td></tr>
<tr><td><code id="loglik_+3A_links">links</code></td>
<td>
<p>A matrix of 2 columns with indices of the linked records.</p>
</td></tr>
<tr><td><code id="loglik_+3A_sumrowd">sumRowD</code></td>
<td>
<p>A boolean vector indicating, for each row of the linkage matrix, i.e. for each record in the smallest file A, whether the record has a link in B or not.</p>
</td></tr>
<tr><td><code id="loglik_+3A_sumcold">sumColD</code></td>
<td>
<p>A boolean vector indicating, for each column of the linkage matrix, i.e. for each record in the largest file B, whether the record has a link in A or not.</p>
</td></tr>
<tr><td><code id="loglik_+3A_gamma">gamma</code></td>
<td>
<p>The proportion of linked records as a fraction of the smallest file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Log(likelihood) of the linkage matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LLL = Matrix::Matrix(0, nrow=13, ncol=15, sparse=TRUE)
LLA = c(0.001,0.001,0.001,0.001,1.43,0.02,0.007,0.001,2.1,0.0003,1.67,1.5,10)
LLB = c(0.001,0.001,0.001,0.001,1.22,0.008,0.01,0.04,3.9,0.0002,1.99,0,2.4,0.009,12)
linksR = as.matrix(base::data.frame(list(idxA=c(5,9,11,12,13), idxB=c(5,9,11,13,15))))
LLL[linksR] = 0.67
sumRowD = c(0,0,0,0,1,0,0,0,1,0,1,1,1)
sumColD = c(0,0,0,0,1,0,0,0,1,0,1,0,1,0,1)
gamma = 0.5
LL0 = loglik(LLL=LLL, LLA=LLA, LLB=LLB, links=linksR, sumRowD=sumRowD, sumColD=sumColD,
             gamma=gamma)
</code></pre>

<hr>
<h2 id='loglikSurvival'>The log likelihood of the survival function with exponential model (-)</h2><span id='topic+loglikSurvival'></span>

<h3>Description</h3>

<p>Log(likelihood) of the survival function with exponential model (as proposed in our paper), representing the probability that true values of a pair of records referring to the same entity coincide. See ?FlexRL::SurvivalUnstable.
This function is only used if the PIV is unstable and evolve over time. If so the true values of a linked pair of records may not coincide.
If you want to use a different survival function to model instability, you can change the function 'SurvivalUnstable' as well as this function 'loglikSurvival'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikSurvival(alphas, X, times, Hequal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglikSurvival_+3A_alphas">alphas</code></td>
<td>
<p>A vector of size 1+cov in A+cov in B with coefficients of the hazard (baseline hazard and conditional hazard)</p>
</td></tr>
<tr><td><code id="loglikSurvival_+3A_x">X</code></td>
<td>
<p>A matrix with number of linked records rows and 1+cov in A+cov in B columns (first column: intercept, following columns: covariates from A and then from B to model instability) (used for optimisation: X concatenate the X obtained in each iteration of the Gibbs sampler)</p>
</td></tr>
<tr><td><code id="loglikSurvival_+3A_times">times</code></td>
<td>
<p>A vector of size number of linked records with the time gaps between the record from each sources (used for optimisation: times concatenate the times vectors obtained in each iteration of the Gibbs sampler)</p>
</td></tr>
<tr><td><code id="loglikSurvival_+3A_hequal">Hequal</code></td>
<td>
<p>A vector of size number of linked records with boolean values indicating wether the values in A and in B coincide (used for optimisation: times concatenate the times vectors obtained in each iteration of the Gibbs sampler)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In our Stochastic Expectation Maximisation (StEM) algorithm (see ?FlexRL::StEM) we minimise - log(likelihood), which is equivalent to maximise log(likelihood). Therefore this function actually returns (and should return if you create your own) the opposite (-) of the log(likelihood) associated with the survival function defining the probabilities that true values coincide.
</p>


<h3>Value</h3>

<p>The value of the opposite (-) of the log(likelihood) associated with the survival function defining the probabilities that true values coincide (as defined in the paper) (the algorithm minimises -log(likelihood) i.e. maximises the log(likelihood)).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nCoefUnstable = 1
alphaInit = rep(-0.05, nCoefUnstable)
Valpha = base::data.frame(list(cov=c(2,2.1,3.4,2.5,2.9),
                               times=c(0.001,0.2,1.3,1.5,2),
                               Hequal=c(TRUE, TRUE, TRUE, FALSE, FALSE)))
X = Valpha[,1:nCoefUnstable]
times = Valpha$times
Hequal = Valpha$Hequal
optim = stats::nlminb(alphaInit, loglikSurvival, control=list(trace=FALSE),
                      X=X, times=times, Hequal=Hequal)
alpha = optim$par
</code></pre>

<hr>
<h2 id='logPossibleConfig'>logPossibleConfig</h2><span id='topic+logPossibleConfig'></span>

<h3>Description</h3>

<p>This function helps calculating the number of possible designs for Delta given by nB!/(nB-nLinks)! Needed to compute the log likelihood of the linkage matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logPossibleConfig(Brecords, sumD)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logPossibleConfig_+3A_brecords">Brecords</code></td>
<td>
<p>Number of records in data source B (the largest).</p>
</td></tr>
<tr><td><code id="logPossibleConfig_+3A_sumd">sumD</code></td>
<td>
<p>Number of linked records (at a specific time point of the algorithm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sum of logs of the vector going from nB - nLinks + 1 to nB.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sumColD = c(0,0,0,0,1,0,0,0,1,0,1,0,1,0,1)
links = base::data.frame(list(idxA=c(5,9,11,12,13), idxB=c(5,9,11,13,15)))
possconfig = logPossibleConfig(length(sumColD),nrow(links))
</code></pre>

<hr>
<h2 id='sampleD'>sampleD</h2><span id='topic+sampleD'></span>

<h3>Description</h3>

<p>sampleD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleD(S, LLA, LLB, LLL, gamma, loglik, nlinkrec, sumRowD, sumColD)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleD_+3A_s">S</code></td>
<td>
<p>IntegerMatrix where each row correspond to the indices (from source A and source B) of records for which the true values matches (representing the potential links)</p>
</td></tr>
<tr><td><code id="sampleD_+3A_lla">LLA</code></td>
<td>
<p>NumericVector gives the likelihood contribution of each non linked record from A</p>
</td></tr>
<tr><td><code id="sampleD_+3A_llb">LLB</code></td>
<td>
<p>NumericVector gives the likelihood contribution of each non linked record from B</p>
</td></tr>
<tr><td><code id="sampleD_+3A_lll">LLL</code></td>
<td>
<p>NumericVector gives the likelihood contribution of each potential linked records (from select)</p>
</td></tr>
<tr><td><code id="sampleD_+3A_gamma">gamma</code></td>
<td>
<p>NumericVector repeats the value of the parameter gamma (proportion of linked records) number of potential linked records (nrow of S) times</p>
</td></tr>
<tr><td><code id="sampleD_+3A_loglik">loglik</code></td>
<td>
<p>double for the value of the current complete log likelihood of the model</p>
</td></tr>
<tr><td><code id="sampleD_+3A_nlinkrec">nlinkrec</code></td>
<td>
<p>integer for the current number of linked records</p>
</td></tr>
<tr><td><code id="sampleD_+3A_sumrowd">sumRowD</code></td>
<td>
<p>A LogicalVector vector indicating, for each row of the linkage matrix, i.e. for each record in the smallest file A, whether the record has a link in B or not.</p>
</td></tr>
<tr><td><code id="sampleD_+3A_sumcold">sumColD</code></td>
<td>
<p>A LogicalVector vector indicating, for each column of the linkage matrix, i.e. for each record in the largest file B, whether the record has a link in A or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>

<ul>
<li><p> new set of links
</p>
</li>
<li><p> new sumRowD
</p>
</li>
<li><p> new sumColD
</p>
</li>
<li><p> new value of the complete log likelihood
</p>
</li>
<li><p> new number fo linked records
</p>
</li></ul>


<hr>
<h2 id='sampleH'>sampleH</h2><span id='topic+sampleH'></span>

<h3>Description</h3>

<p>sampleH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleH(
  nA,
  nB,
  links,
  survivalpSameH,
  pivs_stable,
  pivsA,
  pivsB,
  nvalues,
  nonlinkedA,
  nonlinkedB,
  eta,
  phi
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleH_+3A_na">nA</code></td>
<td>
<p>IntegerVector of dimensions of registered values of the Partially Identifying Variables (PIVs) in A</p>
</td></tr>
<tr><td><code id="sampleH_+3A_nb">nB</code></td>
<td>
<p>IntegerVector of dimensions of registered values of the PIVs in B</p>
</td></tr>
<tr><td><code id="sampleH_+3A_links">links</code></td>
<td>
<p>IntegerMatrix of 2 columns with the indices of the linked records</p>
</td></tr>
<tr><td><code id="sampleH_+3A_survivalpsameh">survivalpSameH</code></td>
<td>
<p>NumericMatrix with for each PIV the probability that true values coincide (if stable: filled with 1)</p>
</td></tr>
<tr><td><code id="sampleH_+3A_pivs_stable">pivs_stable</code></td>
<td>
<p>LogicalVector indicating for each PIV whether it is stable of not (if not we expect survivalpSameH for that same element to not be filled with 1 but with lower values)</p>
</td></tr>
<tr><td><code id="sampleH_+3A_pivsa">pivsA</code></td>
<td>
<p>List ith registered data from A</p>
</td></tr>
<tr><td><code id="sampleH_+3A_pivsb">pivsB</code></td>
<td>
<p>List with registered data from B</p>
</td></tr>
<tr><td><code id="sampleH_+3A_nvalues">nvalues</code></td>
<td>
<p>IntegerVector with number of unique values of each PIV</p>
</td></tr>
<tr><td><code id="sampleH_+3A_nonlinkeda">nonlinkedA</code></td>
<td>
<p>LogicalVector indicating for all records in A whether they are linked or not</p>
</td></tr>
<tr><td><code id="sampleH_+3A_nonlinkedb">nonlinkedB</code></td>
<td>
<p>LogicalVector indicating for all records in B whether they are linked or not</p>
</td></tr>
<tr><td><code id="sampleH_+3A_eta">eta</code></td>
<td>
<p>List parameters of the PIVs distributions</p>
</td></tr>
<tr><td><code id="sampleH_+3A_phi">phi</code></td>
<td>
<p>List parameters of the PIVs registration errors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>

<ul>
<li><p> truePIVsA, true values underlying data in A
</p>
</li>
<li><p> truePIVsB, true values underlying data in B
</p>
</li></ul>


<hr>
<h2 id='sampleL'>sampleNL</h2><span id='topic+sampleL'></span>

<h3>Description</h3>

<p>sampleNL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleL(
  GA,
  GB,
  survivalpSameH,
  choice_set,
  choice_equal,
  nval,
  phikA,
  phikB,
  eta
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleL_+3A_ga">GA</code></td>
<td>
<p>IntegerVector of registered values for a certain Partially Identifying Variable (PIV) for linked records from A</p>
</td></tr>
<tr><td><code id="sampleL_+3A_gb">GB</code></td>
<td>
<p>IntegerVector of registered values for a certain PIV for linked records from B</p>
</td></tr>
<tr><td><code id="sampleL_+3A_survivalpsameh">survivalpSameH</code></td>
<td>
<p>NumericVector of probabilities that the concerned PIV values coincide between file A and file B</p>
</td></tr>
<tr><td><code id="sampleL_+3A_choice_set">choice_set</code></td>
<td>
<p>IntegerMatrix of 2 columns (for A and for B) with possible joint true values underlying GA and GB</p>
</td></tr>
<tr><td><code id="sampleL_+3A_choice_equal">choice_equal</code></td>
<td>
<p>IntegerVector of booleans indicating whether the 2 true values (from A and B) in the choice set are equal</p>
</td></tr>
<tr><td><code id="sampleL_+3A_nval">nval</code></td>
<td>
<p>integer for the number of unique values in the PIV concerned</p>
</td></tr>
<tr><td><code id="sampleL_+3A_phika">phikA</code></td>
<td>
<p>NumericVector parameter for the registration errors in A for the PIV concerned</p>
</td></tr>
<tr><td><code id="sampleL_+3A_phikb">phikB</code></td>
<td>
<p>NumericVector parameter for the registration errors in B for the PIV concerned</p>
</td></tr>
<tr><td><code id="sampleL_+3A_eta">eta</code></td>
<td>
<p>NumericVector parameter for the distribution of the PIV concerned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IntegerVector: of indices from the joint latent true values choice set underlying GA and GB
</p>

<hr>
<h2 id='sampleNL'>sampleNL</h2><span id='topic+sampleNL'></span>

<h3>Description</h3>

<p>sampleNL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleNL(G, eta, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleNL_+3A_g">G</code></td>
<td>
<p>IntegerVector of registered values for a certain Partially Identifying Variable (PIV) for non linked records</p>
</td></tr>
<tr><td><code id="sampleNL_+3A_eta">eta</code></td>
<td>
<p>NumericVector parameter for the distribution of the PIV concerned</p>
</td></tr>
<tr><td><code id="sampleNL_+3A_phi">phi</code></td>
<td>
<p>NumericVector parameter for the registration errors for the PIV concerned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>IntegerVector: of latent true values underlying G
</p>

<hr>
<h2 id='simulateD'>simulateD</h2><span id='topic+simulateD'></span>

<h3>Description</h3>

<p>simulateD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateD(
  data,
  linksR,
  sumRowD,
  sumColD,
  truepivsA,
  truepivsB,
  gamma,
  eta,
  alpha,
  phi
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateD_+3A_data">data</code></td>
<td>
<p>A list with elements:
</p>

<ul>
<li><p> A: the smallest data source (encoded: the categorical values of the PIVs have to be mapped to sets of natural numbers and missing values are encoded as 0).
</p>
</li>
<li><p> B: the largest data source (encoded).
</p>
</li>
<li><p> Nvalues: A vector (of size number of PIVs) with the number fo unique values per PIVs (in the order of the PIVs defined in PIVs_config).
</p>
</li>
<li><p> PIVs_config: A list (of size number of PIVs) where element names are the PIVs and element values are lists with elements: stable (boolean for whether the PIV is stable), conditionalHazard (boolean for whether there are external covariates available to model instability, only required if stable is FALSE), pSameH.cov.A and pSameH.covB (vectors with strings corresponding to the names of the covariates to use to model instability from file A and file B, only required if stable is FALSE, empty vectors may be provided if conditionalHazard is FALSE).
</p>
</li>
<li><p> controlOnMistakes: A vector (of size number of PIVs) of booleans indicating potential bounds on the mistakes probabilities for each PIV. For each PIV, if TRUE there will be control on mistake and the mistake probability will not go above 10%. If FALSE there is no bound on the probability of mistake. WATCH OUT, if you suspect that a variable is unstable but you do not have data to model its dynamics the boolean value should be set to FALSE to allow the parameter for mistake to adapt for the instability. However if you model this instability, the boolean value should be set to TRUE to help the algorithm differenciate the mistakes from the changes over time.
</p>
</li>
<li><p> sameMistakes: A boolean value for whether there should be one parameter for the mistakes in A and B or whether each source should have its own parameter. Setting sameMistakes=TRUE is recommended in case of small data sources; the estimation with 2 parameters in that case will fail to capture the mistakes correctly while 1 parameter will be more adapted.
</p>
</li>
<li><p> phiMistakesAFixed A vector (of size number of PIVs) of booleans indicating whether the parameters for mistakes should be fixed in case of instability. It should be FALSE, except for unstable PIVs for which it may be set to TRUE in order to avoid estimability problems between the parameter for mistake and the parameter for changes across time.
</p>
</li>
<li><p> phiMistakesBFixed A vector (of size number of PIVs) of booleans indicating whether the parameters for mistakes should be fixed in case of instability. It should be FALSE, except for unstable PIVs for which it may be set to TRUE in order to avoid estimability problems between the parameter for mistake and the parameter for changes across time.
</p>
</li>
<li><p> phiForMistakesA A vector (of size number of PIVs) of NA or fixed values for the parameters for mistakes. It should be NA, except for unstable PIVs for which one wants to fix the parameter to avoid estimability problem (as indicated with the boolean values in phiMistakesAFixed). In that case it should be set the the expected value for the probability of mistake. If you have no idea: you can put it to 0, the algorithm is quite robust to wrongly fixed parameters.
</p>
</li>
<li><p> phiForMistakesB A vector (of size number of PIVs) of NA or fixed values for the parameters for mistakes. It should be NA, except for unstable PIVs for which one wants to fix the parameter to avoid estimability problem (as indicated with the boolean values in phiMistakesBFixed). In that case it should be set the the expected value for the probability of mistake. If you have no idea: you can put it to 0, the algorithm is quite robust to wrongly fixed parameters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulateD_+3A_linksr">linksR</code></td>
<td>
<p>A matrix of 2 columns with indices of the linked records.</p>
</td></tr>
<tr><td><code id="simulateD_+3A_sumrowd">sumRowD</code></td>
<td>
<p>A boolean vector indicating, for each row of the linkage matrix, i.e. for each record in the smallest file A, whether the record has a link in B or not.</p>
</td></tr>
<tr><td><code id="simulateD_+3A_sumcold">sumColD</code></td>
<td>
<p>A boolean vector indicating, for each column of the linkage matrix, i.e. for each record in the largest file B, whether the record has a link in A or not.</p>
</td></tr>
<tr><td><code id="simulateD_+3A_truepivsa">truepivsA</code></td>
<td>
<p>A matrix of the shape of data source A, representing the true values of the PIVs underlying the registered values present in A.</p>
</td></tr>
<tr><td><code id="simulateD_+3A_truepivsb">truepivsB</code></td>
<td>
<p>A matrix of the shape of data source B, representing the true values of the PIVs underlying the registered values present in B.</p>
</td></tr>
<tr><td><code id="simulateD_+3A_gamma">gamma</code></td>
<td>
<p>The proportion of linked records as a fraction of the smallest file.</p>
</td></tr>
<tr><td><code id="simulateD_+3A_eta">eta</code></td>
<td>
<p>The distribution weights for the PIVs.</p>
</td></tr>
<tr><td><code id="simulateD_+3A_alpha">alpha</code></td>
<td>
<p>The parameter involved in the survival model for the probability of true values to coincide (parameter for instability).</p>
</td></tr>
<tr><td><code id="simulateD_+3A_phi">phi</code></td>
<td>
<p>The proportion of mistakes and missing for the PIVs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li><p> new set of links
</p>
</li>
<li><p> new sumRowD
</p>
</li>
<li><p> new sumColD
</p>
</li>
<li><p> new value of the complete log likelihood
</p>
</li>
<li><p> new number fo linked records
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>PIVs_config = list( V1 = list(stable = TRUE),
                    V2 = list(stable = TRUE),
                    V3 = list(stable = TRUE),
                    V4 = list(stable = TRUE),
                    V5 = list( stable = FALSE,
                               conditionalHazard = FALSE,
                               pSameH.cov.A = c(),
                               pSameH.cov.B = c()) )
PIVs = names(PIVs_config)
PIVs_stable = sapply(PIVs_config, function(x) x$stable)
Nval = c(6, 7, 8, 9, 15)
NRecords = c(13, 15)
Nlinks = 6
PmistakesA = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmistakesB = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmissingA = c(0.007, 0.007, 0.007, 0.007, 0.007)
PmissingB = c(0.007, 0.007, 0.007, 0.007, 0.007)
moving_params = list(V1=c(),V2=c(),V3=c(),V4=c(),V5=c(0.28))
enforceEstimability = TRUE
DATA = DataCreation( PIVs_config,
                     Nval,
                     NRecords,
                     Nlinks,
                     PmistakesA,
                     PmistakesB,
                     PmissingA,
                     PmissingB,
                     moving_params,
                     enforceEstimability)
A                    = DATA$A
B                    = DATA$B
Nvalues              = DATA$Nvalues

encodedA = A
encodedB = B

encodedA[,PIVs][ is.na(encodedA[,PIVs]) ] = 0
encodedB[,PIVs][ is.na(encodedB[,PIVs]) ] = 0

dataForStEM = list( A                    = encodedA,
                    B                    = encodedB,
                    Nvalues              = Nvalues,
                    PIVs_config          = PIVs_config,
                    controlOnMistakes    = c(TRUE, TRUE, TRUE, TRUE, TRUE),
                    sameMistakes         = TRUE,
                    phiMistakesAFixed    = TRUE,
                    phiMistakesBFixed    = TRUE,
                    phiForMistakesA      = c(NA, NA, NA, NA, 0),
                    phiForMistakesB      = c(NA, NA, NA, NA, 0)
)

initDeltaMap()
linksR = base::matrix(0,0,2)
linksCpp = linksR
sumRowD = rep(0, nrow(dataForStEM$A))
sumColD = rep(0, nrow(dataForStEM$B))
nlinkrec = 0
survivalpSameH = base::matrix(1, nrow(linksR), length(dataForStEM$Nvalues))
gamma = 0.5
eta = lapply(dataForStEM$Nvalues, function(x) rep(1/x,x))
phi = lapply(dataForStEM$Nvalues, function(x)  c(0.9,0.9,0.1,0.1))
nCoefUnstable = lapply( seq_along(PIVs_stable),
                        function(idx)
                        if(PIVs_stable[idx]){ 0 }
                        else{
                        ncol(dataForStEM$A[, dataForStEM$PIVs_config[[idx]]$pSameH.cov.A,
                             drop=FALSE]) +
                        ncol(dataForStEM$B[, dataForStEM$PIVs_config[[idx]]$pSameH.cov.B,
                             drop=FALSE]) +
                        1 } )
alpha = lapply( seq_along(PIVs_stable),
                function(idx) if(PIVs_stable[idx]){ c(-Inf) }else{
                  rep(log(0.05), nCoefUnstable[[idx]]) })
newTruePivs = simulateH(data=dataForStEM, links=linksCpp, survivalpSameH=survivalpSameH,
                        sumRowD=sumRowD, sumColD=sumColD, eta=eta, phi=phi)
truepivsA = newTruePivs$truepivsA
truepivsB = newTruePivs$truepivsB
Dsample = simulateD(data=dataForStEM, linksR=linksR, sumRowD=sumRowD, sumColD=sumColD,
                    truepivsA=truepivsA, truepivsB=truepivsB,
                    gamma=gamma, eta=eta, alpha=alpha, phi=phi)
linksCpp = Dsample$links
linksR = linksCpp + 1
</code></pre>

<hr>
<h2 id='simulateH'>simulateH</h2><span id='topic+simulateH'></span>

<h3>Description</h3>

<p>simulateH
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateH(data, links, survivalpSameH, sumRowD, sumColD, eta, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateH_+3A_data">data</code></td>
<td>
<p>A list with elements:
</p>

<ul>
<li><p> A: the smallest data source (encoded: the categorical values of the PIVs have to be mapped to sets of natural numbers and missing values are encoded as 0).
</p>
</li>
<li><p> B: the largest data source (encoded).
</p>
</li>
<li><p> Nvalues: A vector (of size number of PIVs) with the number fo unique values per PIVs (in the order of the PIVs defined in PIVs_config).
</p>
</li>
<li><p> PIVs_config: A list (of size number of PIVs) where element names are the PIVs and element values are lists with elements: stable (boolean for whether the PIV is stable), conditionalHazard (boolean for whether there are external covariates available to model instability, only required if stable is FALSE), pSameH.cov.A and pSameH.covB (vectors with strings corresponding to the names of the covariates to use to model instability from file A and file B, only required if stable is FALSE, empty vectors may be provided if conditionalHazard is FALSE).
</p>
</li>
<li><p> controlOnMistakes: A vector (of size number of PIVs) of booleans indicating potential bounds on the mistakes probabilities for each PIV. For each PIV, if TRUE there will be control on mistake and the mistake probability will not go above 10%. If FALSE there is no bound on the probability of mistake. WATCH OUT, if you suspect that a variable is unstable but you do not have data to model its dynamics the boolean value should be set to FALSE to allow the parameter for mistake to adapt for the instability. However if you model this instability, the boolean value should be set to TRUE to help the algorithm differenciate the mistakes from the changes over time.
</p>
</li>
<li><p> sameMistakes: A boolean value for whether there should be one parameter for the mistakes in A and B or whether each source should have its own parameter. Setting sameMistakes=TRUE is recommended in case of small data sources; the estimation with 2 parameters in that case will fail to capture the mistakes correctly while 1 parameter will be more adapted.
</p>
</li>
<li><p> phiMistakesAFixed A vector (of size number of PIVs) of booleans indicating whether the parameters for mistakes should be fixed in case of instability. It should be FALSE, except for unstable PIVs for which it may be set to TRUE in order to avoid estimability problems between the parameter for mistake and the parameter for changes across time.
</p>
</li>
<li><p> phiMistakesBFixed A vector (of size number of PIVs) of booleans indicating whether the parameters for mistakes should be fixed in case of instability. It should be FALSE, except for unstable PIVs for which it may be set to TRUE in order to avoid estimability problems between the parameter for mistake and the parameter for changes across time.
</p>
</li>
<li><p> phiForMistakesA A vector (of size number of PIVs) of NA or fixed values for the parameters for mistakes. It should be NA, except for unstable PIVs for which one wants to fix the parameter to avoid estimability problem (as indicated with the boolean values in phiMistakesAFixed). In that case it should be set the the expected value for the probability of mistake. If you have no idea: you can put it to 0, the algorithm is quite robust to wrongly fixed parameters.
</p>
</li>
<li><p> phiForMistakesB A vector (of size number of PIVs) of NA or fixed values for the parameters for mistakes. It should be NA, except for unstable PIVs for which one wants to fix the parameter to avoid estimability problem (as indicated with the boolean values in phiMistakesBFixed). In that case it should be set the the expected value for the probability of mistake. If you have no idea: you can put it to 0, the algorithm is quite robust to wrongly fixed parameters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulateH_+3A_links">links</code></td>
<td>
<p>A matrix of 2 columns with indices of the linked records.</p>
</td></tr>
<tr><td><code id="simulateH_+3A_survivalpsameh">survivalpSameH</code></td>
<td>
<p>a matrix of size (nrow=number of linked records, ncol=number of PIVs), filled for each PIV in column, with 1 if the PIV is stable and with the probability for true values of the records to coincide as calculate by survival function if the PIV is unstable.</p>
</td></tr>
<tr><td><code id="simulateH_+3A_sumrowd">sumRowD</code></td>
<td>
<p>A boolean vector indicating, for each row of the linkage matrix, i.e. for each record in the smallest file A, whether the record has a link in B or not.</p>
</td></tr>
<tr><td><code id="simulateH_+3A_sumcold">sumColD</code></td>
<td>
<p>A boolean vector indicating, for each column of the linkage matrix, i.e. for each record in the largest file B, whether the record has a link in A or not.</p>
</td></tr>
<tr><td><code id="simulateH_+3A_eta">eta</code></td>
<td>
<p>The distribution weights for the PIVs.</p>
</td></tr>
<tr><td><code id="simulateH_+3A_phi">phi</code></td>
<td>
<p>The proportion of mistakes and missing for the PIVs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 2 matrices of the shapes of both data sources, representing the true values of the PIVs underlying the registered values present in the data sources.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PIVs_config = list( V1 = list(stable = TRUE),
                    V2 = list(stable = TRUE),
                    V3 = list(stable = TRUE),
                    V4 = list(stable = TRUE),
                    V5 = list( stable = FALSE,
                               conditionalHazard = FALSE,
                               pSameH.cov.A = c(),
                               pSameH.cov.B = c()) )
PIVs = names(PIVs_config)
PIVs_stable = sapply(PIVs_config, function(x) x$stable)
Nval = c(6, 7, 8, 9, 15)
NRecords = c(13, 15)
Nlinks = 6
PmistakesA = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmistakesB = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmissingA = c(0.007, 0.007, 0.007, 0.007, 0.007)
PmissingB = c(0.007, 0.007, 0.007, 0.007, 0.007)
moving_params = list(V1=c(),V2=c(),V3=c(),V4=c(),V5=c(0.28))
enforceEstimability = TRUE
DATA = DataCreation( PIVs_config,
                     Nval,
                     NRecords,
                     Nlinks,
                     PmistakesA,
                     PmistakesB,
                     PmissingA,
                     PmissingB,
                     moving_params,
                     enforceEstimability)
A                    = DATA$A
B                    = DATA$B
Nvalues              = DATA$Nvalues

encodedA = A
encodedB = B

encodedA[,PIVs][ is.na(encodedA[,PIVs]) ] = 0
encodedB[,PIVs][ is.na(encodedB[,PIVs]) ] = 0

dataForStEM = list( A                    = encodedA,
                    B                    = encodedB,
                    Nvalues              = Nvalues,
                    PIVs_config          = PIVs_config,
                    controlOnMistakes    = c(TRUE, TRUE, TRUE, TRUE, TRUE),
                    sameMistakes         = TRUE,
                    phiMistakesAFixed    = TRUE,
                    phiMistakesBFixed    = TRUE,
                    phiForMistakesA      = c(NA, NA, NA, NA, 0),
                    phiForMistakesB      = c(NA, NA, NA, NA, 0)
)

initDeltaMap()
linksR = base::matrix(0,0,2)
linksCpp = linksR
sumRowD = rep(0, nrow(dataForStEM$A))
sumColD = rep(0, nrow(dataForStEM$B))
nlinkrec = 0
survivalpSameH = base::matrix(1, nrow(linksR), length(dataForStEM$Nvalues))
gamma = 0.5
eta = lapply(dataForStEM$Nvalues, function(x) rep(1/x,x))
phi = lapply(dataForStEM$Nvalues, function(x)  c(0.9,0.9,0.1,0.1))
nCoefUnstable = lapply( seq_along(PIVs_stable),
                        function(idx)
                        if(PIVs_stable[idx]){ 0 }
                        else{
                        ncol(dataForStEM$A[, dataForStEM$PIVs_config[[idx]]$pSameH.cov.A,
                             drop=FALSE]) +
                        ncol(dataForStEM$B[, dataForStEM$PIVs_config[[idx]]$pSameH.cov.B,
                             drop=FALSE]) +
                        1 } )
alpha = lapply( seq_along(PIVs_stable),
                function(idx) if(PIVs_stable[idx]){ c(-Inf) }else{
                  rep(log(0.05), nCoefUnstable[[idx]]) })
newTruePivs = simulateH(data=dataForStEM, links=linksCpp, survivalpSameH=survivalpSameH,
                        sumRowD=sumRowD, sumColD=sumColD, eta=eta, phi=phi)
truepivsA = newTruePivs$truepivsA
truepivsB = newTruePivs$truepivsB
</code></pre>

<hr>
<h2 id='sspaste2'>sspaste2</h2><span id='topic+sspaste2'></span>

<h3>Description</h3>

<p>sspaste2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sspaste2(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sspaste2_+3A_a">A</code></td>
<td>
<p>IntegerMatrix with values to form patterns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CharacterVector: &quot;sspaste2(A)&quot; is a faster version in Rcpp of &quot;do.call(paste, c(as.data.frame(A), list(sep=&quot;_&quot;)))&quot;
</p>

<hr>
<h2 id='stEM'>Stochastic Expectation Maximisation (StEM) for Record Linkage</h2><span id='topic+stEM'></span>

<h3>Description</h3>

<p>Stochastic Expectation Maximisation (StEM) for Record Linkage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stEM(
  data,
  StEMIter,
  StEMBurnin,
  GibbsIter,
  GibbsBurnin,
  musicOn = TRUE,
  newDirectory = NULL,
  saveInfoIter = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stEM_+3A_data">data</code></td>
<td>
<p>A list with elements:
</p>

<ul>
<li><p> A: the smallest data source (encoded: the categorical values of the Partially Identifying Variables (PIVs) have to be mapped to sets of natural numbers and missing values are encoded as 0).
</p>
</li>
<li><p> B: the largest data source (encoded).
</p>
</li>
<li><p> Nvalues: A vector (of size number of PIVs) with the number fo unique values per PIVs (in the order of the PIVs defined in PIVs_config).
</p>
</li>
<li><p> PIVs_config: A list (of size number of PIVs) where element names are the PIVs and element values are lists with elements: stable (boolean for whether the PIV is stable), conditionalHazard (boolean for whether there are external covariates available to model instability, only required if stable is FALSE), pSameH.cov.A and pSameH.covB (vectors with strings corresponding to the names of the covariates to use to model instability from file A and file B, only required if stable is FALSE, empty vectors may be provided if conditionalHazard is FALSE).
</p>
</li>
<li><p> controlOnMistakes: A vector (of size number of PIVs) of booleans indicating potential bounds on the mistakes probabilities for each PIV. For each PIV, if TRUE there will be control on mistake and the mistake probability will not go above 10%. If FALSE there is no bound on the probability of mistake. WATCH OUT, if you suspect that a variable is unstable but you do not have data to model its dynamics the boolean value should be set to FALSE to allow the parameter for mistake to adapt for the instability. However if you model this instability, the boolean value should be set to TRUE to help the algorithm differenciate the mistakes from the changes over time.
</p>
</li>
<li><p> sameMistakes: A boolean value for whether there should be one parameter for the mistakes in A and B or whether each source should have its own parameter. Setting sameMistakes=TRUE is recommended in case of small data sources; the estimation with 2 parameters in that case will fail to capture the mistakes correctly while 1 parameter will be more adapted.
</p>
</li>
<li><p> phiMistakesAFixed A vector (of size number of PIVs) of booleans indicating whether the parameters for mistakes should be fixed in case of instability. It should be FALSE, except for unstable PIVs for which it may be set to TRUE in order to avoid estimability problems between the parameter for mistake and the parameter for changes across time.
</p>
</li>
<li><p> phiMistakesBFixed A vector (of size number of PIVs) of booleans indicating whether the parameters for mistakes should be fixed in case of instability. It should be FALSE, except for unstable PIVs for which it may be set to TRUE in order to avoid estimability problems between the parameter for mistake and the parameter for changes across time.
</p>
</li>
<li><p> phiForMistakesA A vector (of size number of PIVs) of NA or fixed values for the parameters for mistakes. It should be NA, except for unstable PIVs for which one wants to fix the parameter to avoid estimability problem (as indicated with the boolean values in phiMistakesAFixed). In that case it should be set the the expected value for the probability of mistake. If you have no idea: you can put it to 0, the algorithm is quite robust to wrongly fixed parameters.
</p>
</li>
<li><p> phiForMistakesB A vector (of size number of PIVs) of NA or fixed values for the parameters for mistakes. It should be NA, except for unstable PIVs for which one wants to fix the parameter to avoid estimability problem (as indicated with the boolean values in phiMistakesBFixed). In that case it should be set the the expected value for the probability of mistake. If you have no idea: you can put it to 0, the algorithm is quite robust to wrongly fixed parameters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stEM_+3A_stemiter">StEMIter</code></td>
<td>
<p>An integer with the total number of iterations of the Stochastic
EM algorithm (including the period to discard as burn-in)</p>
</td></tr>
<tr><td><code id="stEM_+3A_stemburnin">StEMBurnin</code></td>
<td>
<p>An integer with the number of iterations to discard as burn-in</p>
</td></tr>
<tr><td><code id="stEM_+3A_gibbsiter">GibbsIter</code></td>
<td>
<p>An integer with the total number of iterations of the Gibbs sampler
(done in each iteration of the StEM) (including the period to discard as burn-in)</p>
</td></tr>
<tr><td><code id="stEM_+3A_gibbsburnin">GibbsBurnin</code></td>
<td>
<p>An integer with the number of iterations to discard as burn-in</p>
</td></tr>
<tr><td><code id="stEM_+3A_musicon">musicOn</code></td>
<td>
<p>A boolean value, if TRUE the algorithm will play music at the end of
the algorithm, useful if you have to wait for the record linkage to run and to act as
an alarm when record linkage is done</p>
</td></tr>
<tr><td><code id="stEM_+3A_newdirectory">newDirectory</code></td>
<td>
<p>A NULL value or: A string with the name of (or path to) the directory
(which should already exist) where to save the environment variables at the end of each
iteration (useful when record linkage is very long, to not loose everything and not restart
from scratch in case your computer shut downs before record linkage is finished)</p>
</td></tr>
<tr><td><code id="stEM_+3A_saveinfoiter">saveInfoIter</code></td>
<td>
<p>A boolean value to indicate whether you want the environment variables
to be saved at the end of each iteration (useful when record linkage is very long, to not
loose everything and not restart from scratch in case your computer shut downs before
record linkage is finished)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with:
</p>

<ul>
<li><p> Delta, the summarry of a sparse matrix, i.e. a dataframe with 3 columns: the indices from the first data source A, the indices from the second data source B, the non-zero probability that the records associated with this pair of indices are linked (i.e. the
posterior probabilities to be linked). One has to select the pairs where this proba&gt;0.5 to get a valid set of linked records, (this threshold on the linkage probability is necessary to ensure the one-to-one assignment constraint of record linkage stating that one record in one file can at most be linked to one record in the other file).
</p>
</li>
<li><p> gamma, a vector with the chain of the parameter gamma representing
the proportion of linked records as a fraction of the smallest file,
</p>
</li>
<li><p> eta, a vector with the
chain of the parameter eta representing the distribution of the PIVs,
</p>
</li>
<li><p> alpha, a vector with
the chain of the parameter alpha representing the hazard coefficient of the model for instability,
</p>
</li>
<li><p> phi, a vector with the chain of the parameter phi representing the registration errors parameters).
</p>
</li></ul>

<p>There are more details to understand the method in our paper, or on the experiments repository of our paper, or in the vignettes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PIVs_config = list( V1 = list(stable = TRUE),
                    V2 = list(stable = TRUE),
                    V3 = list(stable = TRUE),
                    V4 = list(stable = TRUE),
                    V5 = list( stable = FALSE,
                               conditionalHazard = FALSE,
                               pSameH.cov.A = c(),
                               pSameH.cov.B = c()) )
PIVs = names(PIVs_config)
PIVs_stable = sapply(PIVs_config, function(x) x$stable)
Nval = c(6, 7, 8, 9, 15)
NRecords = c(500, 800)
Nlinks = 300
PmistakesA = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmistakesB = c(0.02, 0.02, 0.02, 0.02, 0.02)
PmissingA = c(0.007, 0.007, 0.007, 0.007, 0.007)
PmissingB = c(0.007, 0.007, 0.007, 0.007, 0.007)
moving_params = list(V1=c(),V2=c(),V3=c(),V4=c(),V5=c(0.28))
enforceEstimability = TRUE
DATA = DataCreation( PIVs_config,
                     Nval,
                     NRecords,
                     Nlinks,
                     PmistakesA,
                     PmistakesB,
                     PmissingA,
                     PmissingB,
                     moving_params,
                     enforceEstimability)
A                    = DATA$A
B                    = DATA$B
Nvalues              = DATA$Nvalues

encodedA = A
encodedB = B

encodedA[,PIVs][ is.na(encodedA[,PIVs]) ] = 0
encodedB[,PIVs][ is.na(encodedB[,PIVs]) ] = 0

data = list( A = encodedA,
             B = encodedB,
             Nvalues = Nvalues,
             PIVs_config = PIVs_config,
             controlOnMistakes = c(TRUE,TRUE,FALSE,FALSE,FALSE),
             sameMistakes = TRUE,
             phiMistakesAFixed = FALSE,
             phiMistakesBFixed = FALSE,
             phiForMistakesA = c(NA,NA,NA,NA,NA),
             phiForMistakesB = c(NA,NA,NA,NA,NA))
 fit = stEM( data = data,
             StEMIter = 50,
             StEMBurnin = 30,
             GibbsIter = 50,
             GibbsBurnin = 30,
             musicOn = TRUE,
             newDirectory = NULL,
             saveInfoIter = FALSE )

</code></pre>

<hr>
<h2 id='SurvivalUnstable'>The survival function with exponential model</h2><span id='topic+SurvivalUnstable'></span>

<h3>Description</h3>

<p>The survival function with exponential model (as proposed in our paper) is representing the probability that true values of a pair of records referring to the same entity coincide. For a linked pair of record (i,j) from sources A, B respectively, P(HAik = HBjk | t_ij, ...) = exp( - exp(X.ALPHA) t_ij ).
This function is only used if the PIV is unstable and evolve over time. If so the true values of a linked pair of records may not coincide.
If you want to use a different survival function to model instability, you can change this function 'SurvivalUnstable' as well as the associated log(likelihood) function 'loglikSurvival'.
Also see ?FlexRL::loglikSurvival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SurvivalUnstable(Xlinksk, alphask, times)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SurvivalUnstable_+3A_xlinksk">Xlinksk</code></td>
<td>
<p>A matrix with number of linked records rows and 1+cov in A+cov in B columns, with a first column filled with 1 (intercept), and following columns filled with the values of the covariates useful for modelling instability for the linked records</p>
</td></tr>
<tr><td><code id="SurvivalUnstable_+3A_alphask">alphask</code></td>
<td>
<p>A vector of size 1+cov in A+cov in B, with as first element the baseline hazard and following elements being the coefficient of the conditional hazard associated with the covariates given in X</p>
</td></tr>
<tr><td><code id="SurvivalUnstable_+3A_times">times</code></td>
<td>
<p>A vector of size number of linked records with the time gaps between the record from each sources</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The simplest model (without covariates) just writes P(HAik = HBjk | t_ij, ...) = exp( - exp(alpha) . t_ij )
The more complex model (with covariates) writes P(HAik = HBjk | t_ij, ...) = exp( - exp(X.ALPHA) . t_ij ) and uses a matrix X (nrow=nbr of linked records, ncol=1 + nbr of cov from A + nbr of cov from B) where the first column is filled with 1 (intercept) and the subsequent columns are the covariates values from source A and/or from source B to be used. The ALPHA in this case is a vector of parameters, the first one being associated with the intercept is the same one than for the simplest model, the subsequent ones are associated with the covariates from A and/or from B.
</p>


<h3>Value</h3>

<p>A vector (for an unstable PIV) of size number of linked records with the probabilities that true values coincide (e.g. 1 - proba to move if the PIV is postal code) defined according to the survival function with exponential model proposed in the paper
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nCoefUnstable = 1
intercept = rep(1,5)
cov_k = cbind( intercept )
times = c(0.001,0.2,1.3,1.5,2)
survivalpSameH = SurvivalUnstable(cov_k, log(0.28), times)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
