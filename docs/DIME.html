<!DOCTYPE html><html><head><title>Help for package DIME</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DIME}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DIME'>
<p>DIME (Differential Identification using Mixtures Ensemble)</p></a></li>
<li><a href='#DIME-package'>
<p>DIME (Differential Identification using Mixtures Ensemble)</p></a></li>
<li><a href='#DIME.classify'>
<p>Classification Based on The Best Model</p></a></li>
<li><a href='#DIME.plot.fit'>
<p>Plot Best Model Goodness of Fit</p></a></li>
<li><a href='#gng.classify'>
<p>Classification Based on GNG Model</p></a></li>
<li><a href='#gng.fit'>
<p>Function for Fitting GNG model parameters</p></a></li>
<li><a href='#gng.plot.comp'>
<p>Plot GNG Individual Components</p></a></li>
<li><a href='#gng.plot.fit'>
<p>Plot GNG Goodness of Fit</p></a></li>
<li><a href='#gng.plot.mix'>
<p>Plot GNG Mixture Component Function</p></a></li>
<li><a href='#gng.plot.qq'>
<p>QQ-plot of GNG model vs. observed data</p></a></li>
<li><a href='#gng.qq.plot.internal'>
<p>Internal function for QQ-plot of GNG model.</p></a></li>
<li><a href='#huber'><p> Huber's weight function</p></a></li>
<li><a href='#inudge.classify'>
<p>Classification Based on iNUDGE Model</p></a></li>
<li><a href='#inudge.fit'>
<p>Function for Fitting iNUDGE model parameters</p></a></li>
<li><a href='#inudge.plot.comp'>
<p>Plot iNUDGE Individual Components</p></a></li>
<li><a href='#inudge.plot.fit'>
<p>Plot iNUDGE Goodness of Fit</p></a></li>
<li><a href='#inudge.plot.mix'>
<p>Plot iNUDGE Mixture Component Function</p></a></li>
<li><a href='#inudge.plot.qq'>
<p>QQ-plot of GNG model vs. observed data</p></a></li>
<li><a href='#inudge.qq.plot.internal'>
<p>Internal function for QQ-plot of iNUDGE model</p></a></li>
<li><a href='#nudge.classify'>
<p>Classification Based on NUDGE Model</p></a></li>
<li><a href='#nudge.fit'>
<p>Function for Fitting NUDGE model parameters</p></a></li>
<li><a href='#nudge.plot.comp'>
<p>Plot NUDGE Individual Components</p></a></li>
<li><a href='#nudge.plot.fit'>
<p>Plot NUDGE Goodness of Fit</p></a></li>
<li><a href='#nudge.plot.mix'>
<p>Plot NUDGE Mixture Component Function</p></a></li>
<li><a href='#nudge.plot.qq'>
<p>QQ-plot of GNG model vs. observed data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Differential Identification using Mixture Ensemble</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-07</td>
</tr>
<tr>
<td>Author:</td>
<td>Cenny Taslim &lt;taslim.2@osu.edu&gt;, with contributions from  Dustin Potter, Abbasali Khalili and Shili Lin &lt;shili@stat.osu.edu&gt;. </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cenny Taslim &lt;taslim.2@osu.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Description:</td>
<td>A robust identification of differential binding sites method for analyzing ChIP-seq (Chromatin Immunoprecipitation Sequencing) 
    comparing two samples that considers an ensemble of finite mixture models combined with a local false discovery rate (fdr) 
    allowing for flexible modeling of data. Methods for Differential Identification using Mixture Ensemble (DIME) is described in: 
    Taslim et al., (2011) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtr165">doi:10.1093/bioinformatics/btr165</a>&gt;.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-09 12:42:54 UTC; cxt050</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-09 14:50:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='DIME'>
DIME (Differential Identification using Mixtures Ensemble) 
</h2><span id='topic+DIME'></span><span id='topic+DIME'></span>

<h3>Description</h3>

<p>A robust differential identification method that considers ensemble of finite 
mixture models combined with a local false discovery rate <em>(fdr)</em> for 
analyzing ChIP-seq data comparing two samples. <br />
This package can also be used to identify differential
in other high throughput data such as microarray, methylation etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIME(data, avg = NULL, gng.K = 2, gng.weights = NULL, gng.weights.cutoff= -1.345,
  gng.pi = NULL, gng.mu = NULL, 
  gng.sigma = NULL, gng.beta = NULL, gng.tol = 1e-05, gng.max.iter = 2000, 
  gng.th = NULL, gng.rep = 15, gng.fdr.cutoff = 0.1, 
  gng.sigma.diff.cutoff = NULL, gng.mu.diff.cutoff = NULL, 
  gng.var.thres = 1e2, gng.min.sd = NULL,
  inudge.K = 2, inudge.weights = NULL, inudge.weights.cutoff = -1.345, 
  inudge.pi = NULL, inudge.mu = NULL,
  inudge.sigma = NULL, inudge.tol = 1e-05, inudge.max.iter = 2000,
  inudge.z = NULL, inudge.rep = 15, inudge.fdr.cutoff = 0.1, 
  inudge.sigma.diff.cutoff = NULL, inudge.mu.diff.cutoff = NULL, 
  inudge.var.thres = 1e2, inudge.min.sd = NULL,
  nudge.z = NULL, nudge.tol = 1e-05, nudge.max.iter = 2000, 
  nudge.mu = NULL, nudge.sigma = NULL, nudge.rep = 15, 
  nudge.fdr.cutoff = 0.1, nudge.weights = NULL, nudge.weights.cutoff = -1.345, 
  nudge.pi = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIME_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized difference (log ratios). Each element 
can correspond to a particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_avg">avg</code></td>
<td>

<p>optional <strong>R list</strong> of vector of mean data (or log intensities). 
Each element can correspond to a particular chromosome in data. 
Only required when any one of huber weight (lower, upper or full) is selected.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.k">gng.K</code></td>
<td>

<p>optional maximum number of normal component that will be fitted in GNG model. 
For example: gng.K=2 will fit a model with 1 and 2 normal components and select 
the best k.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.weights">gng.weights</code></td>
<td>

<p>optional weights to be used for robust fitting. Can be a matrix the same 
length as data with each row correspond to weights to be used in each 
repetition or a character description of the huber-type method to be 
employed:
&quot;lower&quot; - only value below cutoff are weighted,\ 
&quot;upper&quot; - only value above cutoff are weighted,\
&quot;full&quot;  - both values above and below the cutoff are weighted,\ 
If selected, mean of data (avg) is required. 
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.weights.cutoff">gng.weights.cutoff</code></td>
<td>

<p>optional cutoff to be used with the Huber weighting scheme.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.pi">gng.pi</code></td>
<td>

<p>optional matrix containing initial estimates for proportion of the GNG mixture 
components. Each row is the initial pi to be used in each repetition. 
Each row must have gng.K+2 entries. The first and last entries are for the 
estimates of negative and positive exponentials, respectively. The middle k 
entries are for normal components. 
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.mu">gng.mu</code></td>
<td>

<p>optional matrix containing initial estimates of the Gaussian means in GNG model. 
Each row is the initial means to be used in each repetition. Each row must 
have gng.K entries.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.sigma">gng.sigma</code></td>
<td>

<p>optional maxtrix containing initial estimates of the Gaussian standard deviation
in GNG model. Each row is the initial means to be used in each repetition. 
Each row must have gng.K entries.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.beta">gng.beta</code></td>
<td>

<p>optional maxtrix containing initial estimates for the shape parameter in 
exponential components in GNG model. Each row is the initial beta's to be used 
in each repetition. Each row must have 2 entries, one for negative exponential 
followed by another for positive exponential.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.tol">gng.tol</code></td>
<td>

<p>optional threshold for convergence for EM algorithm to estimate GNG parameters.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.max.iter">gng.max.iter</code></td>
<td>

<p>optional maximum number of iterations for EM algorithm to estimate GNG parameters.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.th">gng.th</code></td>
<td>

<p>optional 2-column matrix of threshold for the two location exponential components.
First column is the initial estimates for negative exponential and the second 
column is the initial estimates for positive exponential.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.rep">gng.rep</code></td>
<td>

<p>optional number of times to repeat the GNG parameter estimation using different 
starting estimates.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.fdr.cutoff">gng.fdr.cutoff</code></td>
<td>

<p>optional cut-off for local <em>fdr</em> for classifying regions into differential
and non-differential using GNG mixture.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.sigma.diff.cutoff">gng.sigma.diff.cutoff</code></td>
<td>

<p>optional cut-off for sigma of the normal component in GNG to be declared as 
representing differential. For example: gng.sigma.diff.cutoff = 2 then if a 
normal component has sigma &gt; 2 then this component is considered as differential
component. Default = (1.5*iqr(data)-gng$mu)/2.
Where gng$mu is mean of non-differential normal components in iNUDGE.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.mu.diff.cutoff">gng.mu.diff.cutoff</code></td>
<td>

<p>optional cut-off for mu of the normal component in GNG to be declared as 
representing differential. For example: gng.mu.diff.cutoff = 2 then if a normal 
component has mean &gt; 2 then this component is considered as differential 
component.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.var.thres">gng.var.thres</code></td>
<td>

<p>optional threshold to detect huge imbalance in variance. 
max(gng.variance)/min(gng.variance) &lt;= gng.var.thres.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_gng.min.sd">gng.min.sd</code></td>
<td>

<p>optional threshold to detect very small sigma. 
all normal components in GNG model has to have sigma &gt; gng.min.sd.
Default = 0.1 * sd(data)
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.k">inudge.K</code></td>
<td>

<p>optional maximum number of normal component that will be fitted in iNUDGE model. 
For example: inudge.K=2 will fit a model with 1 and 2 normal components and select 
the best k.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.weights">inudge.weights</code></td>
<td>

<p>optional weights to be used for robust fitting. Can be a matrix the same 
length as data with each row correspond to weights to be used in each 
repetition or a character description of the huber-type method to be 
employed:
&quot;lower&quot; - only value below cutoff are weighted,\ 
&quot;upper&quot; - only value above cutoff are weighted,\
&quot;full&quot;  - both values above and below the cutoff\ 
are weighted, 
any other character - &quot;lower&quot; are used (default). \
If selected, mean of data (avg) is required.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.weights.cutoff">inudge.weights.cutoff</code></td>
<td>

<p>optional cutoff to be used with the Huber weighting scheme.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.pi">inudge.pi</code></td>
<td>

<p>optional matrix of initial estimates for proportion of the iNUDGE mixture components.
Each row correspond to the intial proportion to be used in each repetition. Each 
row must have inudge.K+1 entries corresponding to proportion of negative 
exponential, proportion of k-normal and proportion of exponential, respectively.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.mu">inudge.mu</code></td>
<td>

<p>optional maxtrix of initial estimates of the Gaussian means in iNUDGE model. 
Each row correspond to the intial means to be used in each repetition. Each row 
must have inudge.K entries.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.sigma">inudge.sigma</code></td>
<td>

<p>optional matrix of initial estimates for Gaussian standard deviation in iNUDGE model. 
Each row correspond to the intial means to be used in each repetition. Each row 
must have inudge.K entries.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.tol">inudge.tol</code></td>
<td>

<p>optional threshold for convergence for EM algorithm to estimate iNUDGE parameters.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.max.iter">inudge.max.iter</code></td>
<td>

<p>optional maximum number of iterations for EM algorithm to estimate iNUDGE parameters.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.z">inudge.z</code></td>
<td>

<p>optional 2-column matrix with each row giving initial estimate of probability of
the region being non-differential and a starting estimate for the probability of
the region being differential. Each row must sum to 1. Number of row must be 
equal to data length.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.rep">inudge.rep</code></td>
<td>

<p>optional number of times to repeat the iNUDGE parameter estimation using different 
starting estimates.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.fdr.cutoff">inudge.fdr.cutoff</code></td>
<td>

<p>optional cut-off for local <em>fdr</em> for classifying regions into differential
and non-differential based on iNUDGE mixture.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.sigma.diff.cutoff">inudge.sigma.diff.cutoff</code></td>
<td>

<p>optional cut-off for sigma of the normal component in GNG to be declared as 
representing differential. For example: gng.sigma.diff.cutoff = 2 then if a 
normal component has sigma &gt; 2 then this component is considered as 
differential component. Default = (1.5*iqr(data)-inudge$mu^)/2.
Where inudge$mu^ is mean of non-differential normal components in iNUDGE.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.mu.diff.cutoff">inudge.mu.diff.cutoff</code></td>
<td>

<p>optional cut-off for mu of the normal component in GNG to be declared as
representing differential. For example: gng.mu.diff.cutoff = 2 then if a 
normal component has mean &gt; 2 then this component is considered as 
differential component.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.var.thres">inudge.var.thres</code></td>
<td>

<p>optional threshold to detect huge imbalance in variance. 
max(inudge.variance)/min(inudge.variance) &lt;= inudge.var.thres.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_inudge.min.sd">inudge.min.sd</code></td>
<td>

<p>optional threshold to detect very small sigma. 
all normal components in iNUDGE model has to have sigma &gt; inudge.min.sd.
Default = 0.1 * sd(data)
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.z">nudge.z</code></td>
<td>

<p>optional 2-column matrix with each row giving initial estimate of probability of
the region being non-differential and a starting estimate for the probability of
the region being differential. Each row must sum to 1. Number of row must be 
equal to data length.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.tol">nudge.tol</code></td>
<td>

<p>optional threshold for convergence for EM algorithm to estimate NUDGE parameters.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.max.iter">nudge.max.iter</code></td>
<td>

<p>optional maximum number of iterations for EM algorithm to estimate iNUDGE 
parameters.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.mu">nudge.mu</code></td>
<td>

<p>optional maxtrix of initial estimates of the Gaussian means in NUDGE model. 
Each row correspond to the intial means to be used in each repetition. Each row 
must have 1 entry.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.sigma">nudge.sigma</code></td>
<td>

<p>optional initial estimates of the Gaussian standard deviation in NUDGE model. 
Each row correspond to the intial standard deviation to be used in each 
repetition. Each row must have 1 entry.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.rep">nudge.rep</code></td>
<td>

<p>optional number of times to repeat the NUDGE parameter estimation using 
different starting estimates.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.fdr.cutoff">nudge.fdr.cutoff</code></td>
<td>

<p>optional cut-off for local <em>fdr</em> for classifying regions into differential
and non-differential based on NUDGE mixture.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.weights">nudge.weights</code></td>
<td>

<p>optional weights to be used for robust fitting. Can be a matrix the same 
length as data with each row correspond to weights to be used in each 
repetition or a character description of the huber-type method to be 
employed:
&quot;lower&quot; - only value below cutoff are weighted,\ 
&quot;upper&quot; - only value above cutoff are weighted,\
&quot;full&quot;  - both values above and below the cutoff\ 
are weighted, 
any other character - &quot;lower&quot; are used (default). \
If selected, mean of data (avg) is required. 
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.weights.cutoff">nudge.weights.cutoff</code></td>
<td>

<p>optional cutoff to be used with the Huber weighting scheme.
</p>
</td></tr>
<tr><td><code id="DIME_+3A_nudge.pi">nudge.pi</code></td>
<td>

<p>optional initial estimates for proportion of the NUDGE mixture components.
Each row is the initial pi to be used in each repetition. Each row must have 2 
entries: proportion of uniform and proportion of normal components, respectively . 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After normalization, a Gamma-Normal(k)-Gamma (GNG), a Uniform-Normal(k) (iNUDGE)
and a Uniform-Normal (NUDGE) mixture are fitted to the data. Two-phase selection
method is used to choose the best model. 
The (k)-normal component can represent either differential
regions or non-differential regions depending on their location and shape, 
making the model more robust to different underlying distributions. The
exponential or uniform represents differential sites. Local <em>(fdr)</em> is
computed from the best fitted model. Parameters estimation is performed 
using EM algorithm.
</p>


<h3>Value</h3>

<p>A list with 4 components (i.e. best, gng, inudge and nudge) which in itself is 
another list containing the estimated parameters of each model fitted 
correspondingly. &quot;best&quot; lists the model chosen as the best overall model, 
i.e. if the best model is inudge then best$name = &quot;iNUDGE&quot; and its content 
is the same as inudge. Thus, depending on the model, the components are:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>the name of the model &quot;GNG&quot;, &quot;iNUDGE&quot;,&quot;NUDGE&quot; where
GNG: normal(k)-exponential (a special case of gamma), iNUDGE: normal(k)-uniform, 
or NUDGE: normal-uniform models</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>a vector of estimated proportion of each components in the model</p>
</td></tr>  
<tr><td><code>mu</code></td>
<td>
<p>a vector of estimated Gaussian means for k-normal components.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector of estimated Gaussian standard deviation for k-normal 
components.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a vector of estimated exponential shape values. Only available in gng. </p>
</td></tr>
<tr><td><code>th1</code></td>
<td>
<p>negative location parameter used to fit the negative exponential model.
Only available in gng.</p>
</td></tr>
<tr><td><code>th2</code></td>
<td>
<p>positive location parameter used to fit the positive exponential model.
Only available in gng.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>the minimum value of the normalized data. Only available in (i)nudge.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>the maximum value of the normalized data. Only available in (i)nudge.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of normal components in the corresponding mixture model. For
inudge, K=1.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the log likelihood for the fitted mixture model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations run by the EM algorithm until either 
convergence or iteration limit was reached.</p>
</td></tr>
<tr><td><code>fdr</code></td>
<td>
<p>the local false discover rate estimated based on the corresponding 
model.</p>
</td></tr>
<tr><td><code>class</code></td>
<td>
<p>a vector of classifications for the observations in data. 
A classification of 0 denotes that the regions could not be classified as 
differential with fdr &lt; &lt;model&gt;.fdr.cutoff, 1 denotes differential.</p>
</td></tr>
<tr><td><code>diffPiIdx</code></td>
<td>
<p>a vector of index of the normal components that are defined as
capturing differential regions based on their shape and locations.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a vector of estimated mixture function</p>
</td></tr>
<tr><td><code>mu.diff.cutoff</code></td>
<td>
<p>normal component with mean &gt; mu.diff.cutoff
will be used to represent differential component.</p>
</td></tr>
<tr><td><code>sigma.diff.cutoff</code></td>
<td>
<p>normal component with standard deviation &gt; 
sigma.diff.cutoff will be used to represent differential component.</p>
</td></tr>     
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.fit">gng.fit</a></code>, <code><a href="#topic+inudge.fit">inudge.fit</a></code>, <code><a href="#topic+nudge.fit">nudge.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234)
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);

# run DIME
set.seed(1234)
test &lt;- DIME(data,gng.max.iter=10,gng.rep=1,inudge.max.iter=10,inudge.rep=1,
 nudge.max.iter=10,nudge.rep=1)

# Getting the best fitted model (parameters)
test$best$name # name of the best fitted model
test$best$pi # estimated proportion of each component in the best model
test$best$mu # estimated mean of the normal component(s) the best model
# estimated standard deviation of the normal component(s) in best model
test$best$sigma 
# estimated shape parameter of the exponential components in best model  
test$best$beta
# class indicator inferred using best model chosen. 1 means differential, 0 o.w
bestClass = test$best$class 

# plot best model
DIME.plot.fit(data,test)

# Eg. getting Gaussian mean from iNUDGE model
test$inudge$mu

# Eg. getting Gaussian mean from NUDGE model
test$nudge$mu

# Eg. getting parameters from GNG model
test$gng$mu

# provide initial estimates means of Gaussian in GNG model
test &lt;- DIME(data,gng.max.iter=5,gng.rep=1,inudge.max.iter=5,inudge.rep=1,
 nudge.max.iter=5,nudge.rep=1,gng.K=2,gng.mu=rbind(c(1,2)))
</code></pre>

<hr>
<h2 id='DIME-package'>
DIME (Differential Identification using Mixtures Ensemble) 
</h2><span id='topic+DIME_package'></span><span id='topic+DIME.package'></span>

<h3>Description</h3>

<p>A robust differential identification method that considers an ensemble of finite 
mixture models combined with a local false discovery rate <em>(fdr)</em> for 
analyzing ChIP-seq data comparing two samples. <br />
This package can also be used to identify differential
in other high throughput data such as microarray, methylation etc.<br />
After normalization, an Exponential-Normal(k) or a Uniform-Normal(k) mixture is
fitted to the data. The (k)-normal component can represent either differential
regions or non-differential regions depending on their location and spread. The
exponential or uniform represent differentially sites. local <em>(fdr)</em> are
computed from the fitted model.
Unique features of the package: 
</p>
<ol>
<li><p>Accurate modeling of data that comes from 
any distribution by the use of multiple normal components (any distribution can be
accurately represented by mixture of normal).
</p>
</li>
<li><p>Using ensemble of mixture models
allowing data to be accurately &amp; efficiently represented. Then two-phase selection ensure the 
selection of the best overall model. 
</p>
</li>
<li><p>This method can be used as a general
program to fit a mixture of uniform-normal or uniform-k-normal or exponential-k-normal 
</p>
</li></ol>



<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> DIME</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2010-11-19</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions 
from Abbas Khalili <a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, 
Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, and 
Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a><br />
Maintainer: Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a> or 
Shili Lin  <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>References</h3>


<ul>
<li><p>Khalili, A., Huang, T., and Lin, S. (2009). A robust unified approach to 
analyzing methylation and gene expression data. <em>Computational Statistics 
and Data Analysis</em>, 53(5), 1701-1710.
</p>
</li>
<li><p>Dean, N. and Raftery, A. E. (2005). Normal uniform mixture differential 
gene expression detection for cDNA microarrays. <em>BMC Bioinformatics</em>, 6, 173.
</p>
</li>
<li><p>Taslim, C., Wu, J., Yan, P., Singer, G., Parvin, J., Huang, T., Lin, S., 
and Huang, K. (2009). Comparative study on chip-seq data: normalization and 
binding pattern characterization. <em>Bioinformatics</em>, 25(18), 2334-2340.
</p>
</li></ul>


<hr>
<h2 id='DIME.classify'>
Classification Based on The Best Model
</h2><span id='topic+DIME.classify'></span>

<h3>Description</h3>

<p>Classifies observed data into differential and non-differential groups based on 
the model selected as the best fit to the observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIME.classify(data, obj, obj.cutoff = 0.1, obj.sigma.diff.cutoff = NULL, 
  obj.mu.diff.cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIME.classify_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="DIME.classify_+3A_obj">obj</code></td>
<td>

<p>a list object returned by DIME function.
</p>
</td></tr>
<tr><td><code id="DIME.classify_+3A_obj.cutoff">obj.cutoff</code></td>
<td>

<p>optional local <em>fdr</em> cutoff for classifying data into differential
and non-differential groups based on the best mixture model.
</p>
</td></tr>
<tr><td><code id="DIME.classify_+3A_obj.sigma.diff.cutoff">obj.sigma.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in the best 
model to be declared as representing differential.
</p>
</td></tr>
<tr><td><code id="DIME.classify_+3A_obj.mu.diff.cutoff">obj.mu.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in the best 
model to be declared as representing differential.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object passed as input with additional element $class containing vector 
of classifications for all the observations in data. A classification of 1
denotes that the data is classified as differential with fdr &lt; obj.cutoff.
</p>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DIME">DIME</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234)
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);
 
# run DIME with small maximum iteration and repetitions
set.seed(1234);
test &lt;- DIME(data,gng.max.iter=10,gng.rep=1,inudge.max.iter=10,inudge.rep=1,
 nudge.max.iter=10,nudge.rep=1)
# get classification based on inudge  
test$inudge &lt;- DIME.classify(data,test$inudge,obj.cutoff=0.1);
# vector of classification. 1 represents differential, 0 denotes non-differential
inudgeClass &lt;- test$inudge$class;

</code></pre>

<hr>
<h2 id='DIME.plot.fit'>
Plot Best Model Goodness of Fit
</h2><span id='topic+DIME.plot.fit'></span><span id='topic+DIME.plot'></span>

<h3>Description</h3>

<p>Plot the best mixture model fitted using <code><a href="#topic+DIME">DIME</a></code> along with their 
estimated individual components, superimposed on the histogram of the 
observation data. This plot shows how good the fit of the estimated model to the
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIME.plot.fit(data, obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIME.plot.fit_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="DIME.plot.fit_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+DIME">DIME</a></code> function.
</p>
</td></tr>
<tr><td><code id="DIME.plot.fit_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components representing differential data are denoted by asterisk (*)
symbol on the plot legend.
</p>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DIME">DIME</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>,<code><a href="#topic+inudge.plot.fit">inudge.plot.fit</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1) 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10)
set.seed(1234)
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
data &lt;- list(chr1,chr3);

# run DIME with small maximum iterations and repetitions
set.seed(1234);
test &lt;- DIME(data,gng.max.iter=10,gng.rep=1,inudge.max.iter=10,inudge.rep=1,
 nudge.max.iter=10,nudge.rep=1);
 
# plot best model
DIME.plot.fit(data,test); 
</code></pre>

<hr>
<h2 id='gng.classify'>
Classification Based on GNG Model
</h2><span id='topic+gng.classify'></span>

<h3>Description</h3>

<p>Classifies observed data into differential and non-differential groups based on 
GNG model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gng.classify(data, obj, obj.cutoff = 0.1, obj.sigma.diff.cutoff = NULL, 
  obj.mu.diff.cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gng.classify_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="gng.classify_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="gng.classify_+3A_obj.cutoff">obj.cutoff</code></td>
<td>

<p>optional local <em>fdr</em> cutoff for classifying data into differential
and non-differential groups based on GNG model.
</p>
</td></tr>
<tr><td><code id="gng.classify_+3A_obj.sigma.diff.cutoff">obj.sigma.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in the best 
model to be declared as representing differential.
</p>
</td></tr>
<tr><td><code id="gng.classify_+3A_obj.mu.diff.cutoff">obj.mu.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in the best 
model to be declared as representing differential.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object passed as input with additional element $class containing vector 
of classifications for all the observations in data. A classification of 1
denotes that the data is classified as differential with fdr &lt; obj.cutoff.
</p>
<table>
<tr><td><code>mu.diff.cutoff</code></td>
<td>
<p>normal component with mean &gt; mu.diff.cutoff
will be used to represent differential component.</p>
</td></tr>
<tr><td><code>sigma.diff.cutoff</code></td>
<td>
<p>normal component with standard deviation &gt; 
sigma.diff.cutoff will be used to represent differential component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.fit">gng.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234);
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);

# fit GNG model with 2 normal components
test &lt;- gng.fit(data, K = 2);
# vector of classification. 1 represents differential, 0 denotes non-differential
gngClass &lt;- test$class;
</code></pre>

<hr>
<h2 id='gng.fit'>
Function for Fitting GNG model parameters
</h2><span id='topic+gng.fit'></span>

<h3>Description</h3>

<p>Function to estimate parameters for GNG model, mixture of exponential and 
<em>k</em>-normal. Parameters are estimated using EM algorithm.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gng.fit(data, avg = NULL, K = 2, weights = NULL, weights.cutoff = -1.345, 
  pi = NULL, mu = NULL, sigma = NULL, beta = NULL, tol = 1e-05, 
  max.iter = 2000, th = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gng.fit_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_avg">avg</code></td>
<td>

<p>optional vector of mean data (or log intensities). Only required when any one
of huber weight (lower, upper or full) is selected.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_k">K</code></td>
<td>

<p>optional number of normal component that will be fitted in GNG model.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_weights">weights</code></td>
<td>

<p>optional weights to be used for robust fitting. Can be a matrix the same 
length as data, or a character description of the huber weight method to be 
employed:
&quot;lower&quot; - only value below weights.cutoff are weighted,\ 
&quot;upper&quot; - only value above weights.cutoff are weighted,\
&quot;full&quot;  - both values above and below weights.cutoff are weighted,\ 
If selected, mean of data (avg) is required. 
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_weights.cutoff">weights.cutoff</code></td>
<td>

<p>optional cutoff to be used with the Huber weighting scheme.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_pi">pi</code></td>
<td>

<p>optional vector containing initial estimates for proportion of the GNG mixture 
components. The first and last entries are for the 
estimates of negative and positive exponentials, respectively. The middle k entries
are for normal components.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_mu">mu</code></td>
<td>

<p>optional vector containing initial estimates of the Gaussian means in GNG model.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_sigma">sigma</code></td>
<td>

<p>optional vector containing initial estimates of the Gaussian standard deviation
in GNG model. Must have K entries. 
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_beta">beta</code></td>
<td>

<p>optional vector containing initial estimates for the shape parameter in 
exponential components in GNG model. Must have 2 entries, one for negative 
exponential the other for positive exponential components.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_tol">tol</code></td>
<td>

<p>optional threshold for convergence for EM algorithm to estimate GNG parameters.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_max.iter">max.iter</code></td>
<td>

<p>optional maximum number of iterations for EM algorithm to estimate GNG parameters.
</p>
</td></tr>
<tr><td><code id="gng.fit_+3A_th">th</code></td>
<td>

<p>optional location parameter used to fit the negative and positive exponential model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of object:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>the name of the model &quot;GNG&quot;</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>a vector of estimated proportion of each components in the model</p>
</td></tr>  
<tr><td><code>mu</code></td>
<td>
<p>a vector of estimated Gaussian means for k-normal components.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector of estimated Gaussian standard deviation for k-normal 
components.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>a vector of estimated exponential shape values.</p>
</td></tr>
<tr><td><code>th1</code></td>
<td>
<p>negative location parameter used to fit the negative exponential model.</p>
</td></tr>
<tr><td><code>th2</code></td>
<td>
<p>positive location parameter used to fit the positive exponential model.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of normal components in the corresponding mixture model.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the log likelihood for the fitted mixture model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the actual number of iterations run by the EM algorithm.</p>
</td></tr>
<tr><td><code>fdr</code></td>
<td>
<p>the local false discover rate estimated based on GNG model.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a matrix of estimated GNG mixture component function.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike Information Criteria.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criteria.</p>
</td></tr>     
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DIME">DIME</a></code>, <code><a href="#topic+inudge.fit">inudge.fit</a></code>, <code><a href="#topic+nudge.fit">nudge.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234)
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);

# fit GNG model with 2 normal components
test &lt;- gng.fit(data, K = 2);

# Getting the best fitted GNG model (parameters)
test$pi # estimated proportion of each component in GNG
test$mu # estimated mean of the normal component(s) GNG
# estimated standard deviation of the normal component(s) in GNG
test$sigma 
# estimated shape parameter of the exponential components in best model  
test$beta
</code></pre>

<hr>
<h2 id='gng.plot.comp'>
Plot GNG Individual Components
</h2><span id='topic+gng.plot.comp'></span>

<h3>Description</h3>

<p>Plot each estimated individual components of GNG model 
(mixture of exponential and <em>k</em>-normal) fitted using <code><a href="#topic+gng.fit">gng.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gng.plot.comp(data, obj, new.plot = TRUE, legpos = NULL, xlim=NULL,
  ylim=NULL, xlab=NULL, ylab=NULL, main=NULL,lwd=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gng.plot.comp_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to a particular chromosome. User can construct 
their own list containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_new.plot">new.plot</code></td>
<td>

<p>optional logical variable on whether to create new plot.
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_legpos">legpos</code></td>
<td>

<p>optional vector of (x,y) location for the legend position
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_xlim">xlim</code></td>
<td>

<p>optional x-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_ylim">ylim</code></td>
<td>

<p>optional y-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_xlab">xlab</code></td>
<td>

<p>optional x-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_ylab">ylab</code></td>
<td>

<p>optional y-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_lwd">lwd</code></td>
<td>

<p>optional line width for lines in the plot (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.comp_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components representing differential data are denoted by asterisk (*)
symbol on the plot legend.
</p>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.plot.mix">gng.plot.mix</a></code>, <code><a href="#topic+gng.plot.comp">gng.plot.comp</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>,
<code><a href="#topic+gng.plot.qq">gng.plot.qq</a></code>, <code><a href="#topic+DIME.plot.fit">DIME.plot.fit</a></code>, <code><a href="#topic+inudge.plot.fit">inudge.plot.fit</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234);
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);

# Fitting a GNG model with 2-normal component
bestGng &lt;- gng.fit(data,K=2);

# plot individual components of GNG
gng.plot.comp(data,bestGng);
# plot mixture component on top of the individual components plot
gng.plot.mix(bestGng,resolution=1000,new.plot=FALSE);

</code></pre>

<hr>
<h2 id='gng.plot.fit'>
Plot GNG Goodness of Fit
</h2><span id='topic+gng.plot.fit'></span>

<h3>Description</h3>

<p>Plot the estimated GNG mixture model fitted using <code><a href="#topic+gng.fit">gng.fit</a></code> along with 
it's estimated individual components, superimposed on the histogram of the 
observation data. This plot shows how good the fit of the estimated model to the
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gng.plot.fit(data, obj, resolution = 100, breaks = 100, legpos = NULL,
  xlim = NULL, main=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gng.plot.fit_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to a particular chromosome. User can construct  their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="gng.plot.fit_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="gng.plot.fit_+3A_resolution">resolution</code></td>
<td>

<p>optional bandwidth used to estimate the density function. Higher number smoother 
curve.
</p>
</td></tr>
<tr><td><code id="gng.plot.fit_+3A_breaks">breaks</code></td>
<td>

<p>optional see <code><a href="graphics.html#topic+hist">hist</a></code>, breaks parameters for histogram plot.
</p>
</td></tr>
<tr><td><code id="gng.plot.fit_+3A_legpos">legpos</code></td>
<td>

<p>optional vector of (x,y) location for the legend position
</p>
</td></tr>
<tr><td><code id="gng.plot.fit_+3A_xlim">xlim</code></td>
<td>

<p>optional x-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.fit_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.fit_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components representing differential data are denoted by asterisk (*)
symbol on the plot legend.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.plot.comp">gng.plot.comp</a></code>, <code><a href="#topic+gng.plot.mix">gng.plot.mix</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234);
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);

# Fitting a GNG model only with 2-normal components
bestGng &lt;- gng.fit(data,K=2);

# Goodness of fit plot
gng.plot.fit(data,bestGng);
</code></pre>

<hr>
<h2 id='gng.plot.mix'>
Plot GNG Mixture Component Function
</h2><span id='topic+gng.plot.mix'></span>

<h3>Description</h3>

<p>Plot each estimated individual components of GNG mixture model fitted using 
<code><a href="#topic+gng.fit">gng.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gng.plot.mix(obj, amplify = 1, resolution = 100, new.plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gng.plot.mix_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="gng.plot.mix_+3A_amplify">amplify</code></td>
<td>

<p>optional scaling factor for visualization purposes.
</p>
</td></tr>
<tr><td><code id="gng.plot.mix_+3A_resolution">resolution</code></td>
<td>

<p>optional bandwidth used to estimate the density function. Higher number makes a
smoother curve.
</p>
</td></tr>
<tr><td><code id="gng.plot.mix_+3A_new.plot">new.plot</code></td>
<td>

<p>optional logical variable on whether to create new plot.
</p>
</td></tr>
<tr><td><code id="gng.plot.mix_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.plot.mix">gng.plot.mix</a></code>, <code><a href="#topic+gng.plot.comp">gng.plot.comp</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>,
<code><a href="#topic+gng.plot.qq">gng.plot.qq</a></code>, <code><a href="#topic+DIME.plot.fit">DIME.plot.fit</a></code>, <code><a href="#topic+inudge.plot.fit">inudge.plot.fit</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234);
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);

# Fitting a GNG model only
bestGng &lt;- gng.fit(data,K=2);

# Plot the estimated GNG model imposed on the histogram of the observed data
hist(unlist(data),freq=FALSE,breaks=100,xlim=c(-20,20))
gng.plot.mix(bestGng,resolution=1000,new.plot=FALSE,col="red");
</code></pre>

<hr>
<h2 id='gng.plot.qq'>
QQ-plot of GNG model vs. observed data
</h2><span id='topic+gng.plot.qq'></span>

<h3>Description</h3>

<p>Produces a QQ-plot for visual inspection of quality of fit with regards to 
the exponential Gaussian (GNG) mixture model estimated using the function 
<code><a href="#topic+gng.fit">gng.fit</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gng.plot.qq(data, obj, resolution=10, xlab=NULL, ylab=NULL, 
  main=NULL, pch=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gng.plot.qq_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to a particular chromosome. User can construct 
their own list containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="gng.plot.qq_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="gng.plot.qq_+3A_resolution">resolution</code></td>
<td>

<p>optional number of points used to sample the estimated density function.
</p>
</td></tr>
<tr><td><code id="gng.plot.qq_+3A_xlab">xlab</code></td>
<td>

<p>optional x-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.qq_+3A_ylab">ylab</code></td>
<td>

<p>optional y-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.qq_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.qq_+3A_pch">pch</code></td>
<td>

<p>optional plotting symbol to use (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="gng.plot.qq_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.fit">gng.fit</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)
# generate simulated datasets with underlying exponential-normal components
N1 &lt;- 1500; N2 &lt;- 500; K &lt;- 4; rmu &lt;- c(-2.25,1.50); rsigma &lt;- c(1,1); 
rpi &lt;- c(.05,.45,.45,.05); rbeta &lt;- c(12,10);
set.seed(1234);
chr1 &lt;- c(-rgamma(ceiling(rpi[1]*N1),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N1),shape = 1,scale = rbeta[2]));
chr2 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2])); 
chr3 &lt;- c(-rgamma(ceiling(rpi[1]*N2),shape = 1,scale = rbeta[1]), 
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2]), 
  rgamma(ceiling(rpi[4]*N2),shape = 1,scale = rbeta[2]));
# analyzing only chromosome 1 and chromosome 3
data &lt;- list(chr1,chr3);

# Fitting a GNG model only
bestGng &lt;- gng.fit(data,K=2);

# QQ-plot
gng.plot.qq(data,bestGng)
</code></pre>

<hr>
<h2 id='gng.qq.plot.internal'>
Internal function for QQ-plot of GNG model.
</h2><span id='topic+gng.qq.plot.internal'></span>

<h3>Description</h3>

<p>Internal function needed to generate a QQ-plot for GNG model. 
<code><a href="#topic+gng.plot.qq">gng.plot.qq</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gng.qq.plot.internal(i, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gng.qq.plot.internal_+3A_i">i</code></td>
<td>

<p>a number which is used to generate random sample of GNG model.
</p>
</td></tr>
<tr><td><code id="gng.qq.plot.internal_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.fit">gng.fit</a></code>, <code><a href="#topic+gng.plot.qq">gng.plot.qq</a></code>
</p>

<hr>
<h2 id='huber'> Huber's weight function </h2><span id='topic+huber'></span>

<h3>Description</h3>

<p>A weight functions used to downweigh outliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>huber(input, co, shape = c("full", "lower", "upper"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="huber_+3A_input">input</code></td>
<td>
<p> an <strong>R list</strong> of vector of normalized mean 
(log intensities). </p>
</td></tr>
<tr><td><code id="huber_+3A_co">co</code></td>
<td>
<p> cutoff used in determining weights.  </p>
</td></tr>
<tr><td><code id="huber_+3A_shape">shape</code></td>
<td>
<p> parameter determining which outliers are weighted: 
&quot;full&quot;  - both values above and below -threshold are downweighted;\
&quot;lower&quot; - only values below threshold are downweighted; \
&quot;upper&quot; - only values above threshold are downweighted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of weights.	
</p>


<h3>Author(s)</h3>

<p> Dustin Potter </p>


<h3>References</h3>

<p> Huber, P. J. (1981) Robust Statistics. John Wiley &amp; Sons </p>

<hr>
<h2 id='inudge.classify'>
Classification Based on iNUDGE Model
</h2><span id='topic+inudge.classify'></span>

<h3>Description</h3>

<p>Classifies observed data into differential and non-differential groups based on
iNUDGE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inudge.classify(data, obj, obj.cutoff = 0.1, obj.sigma.diff.cutoff = NULL,
  obj.mu.diff.cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inudge.classify_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="inudge.classify_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+inudge.fit">inudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="inudge.classify_+3A_obj.cutoff">obj.cutoff</code></td>
<td>

<p>optional local <em>fdr</em> cutoff for classifying data into differential
and non-differential groups based on iNUDGE model.
</p>
</td></tr>
<tr><td><code id="inudge.classify_+3A_obj.sigma.diff.cutoff">obj.sigma.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in iNUDGE
model to be designated as representing differential.
</p>
</td></tr>
<tr><td><code id="inudge.classify_+3A_obj.mu.diff.cutoff">obj.mu.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in iNUDGE
model to be designated as representing differential.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object passed as input with additional element $class containing vector
of classifications for all the observations in data. A classification of 1
denotes that the data is classified as differential with fdr &lt; obj.cutoff.
</p>
<table>
<tr><td><code>mu.diff.cutoff</code></td>
<td>
<p>normal component with mean &gt; mu.diff.cutoff
was used to represent differential component.</p>
</td></tr>
<tr><td><code>sigma.diff.cutoff</code></td>
<td>
<p>normal component with standard deviation &gt;
sigma.diff.cutoff was used to represent differential component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>,
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inudge.fit">inudge.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 2-normal distributions
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(-2.25,1.5); rsigma &lt;- c(1,1);
rpi &lt;- c(.10,.45,.45); a &lt;- (-6); b &lt;- 6;
chr4 &lt;- list(c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]),
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2])));
chr9 &lt;- list(c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]),
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2])));
# analyzing chromosome 4 and 9
data &lt;- list(chr4,chr9);

# fit iNUDGE model with 2 normal components and maximum iterations = 20
set.seed(1234);
test &lt;- inudge.fit(data, K = 2, max.iter=20);
# vector of classification. 1 represents differential, 0 denotes non-differential
inudgeClass &lt;- test$class;
</code></pre>

<hr>
<h2 id='inudge.fit'>
Function for Fitting iNUDGE model parameters
</h2><span id='topic+inudge.fit'></span>

<h3>Description</h3>

<p>Function to estimate parameters for NUDGE model, mixture of 
uniform and <em>k</em>-normal. Parameters are estimated using EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inudge.fit(data, avg = NULL, K = 2, weights = NULL, weights.cutoff = -1.345,
 pi = NULL, mu = NULL, sigma = NULL, tol = 1e-5, max.iter = 2000, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inudge.fit_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_avg">avg</code></td>
<td>

<p>optional vector of mean data (or log intensities). Only required when any one
of huber weight (lower, upper or full) is selected.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_k">K</code></td>
<td>

<p>optional number of normal component that will be fitted in iNUDGE model.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_weights">weights</code></td>
<td>

<p>optional weights to be used for robust fitting. Can be a matrix the same 
length as data, or a character description of the huber weight method to be 
employed:
&quot;lower&quot; - only value below weights.cutoff are weighted,\ 
&quot;upper&quot; - only value above weights.cutoff are weighted,\
&quot;full&quot;  - both values above and below weights.cutoff are weighted,\ 
If selected, mean of data (avg) is required. 
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_weights.cutoff">weights.cutoff</code></td>
<td>

<p>optional cutoff to be used with the Huber weighting scheme.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_pi">pi</code></td>
<td>

<p>optional vector containing initial estimates for proportion of the iNUDGE mixture 
components. The first entry is for the uniform component, the middle <em>k</em> entries
are for normal components.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_mu">mu</code></td>
<td>

<p>optional vector containing initial estimates of the Gaussian means in iNUDGE model.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_sigma">sigma</code></td>
<td>

<p>optional vector containing initial estimates of the Gaussian standard deviation
in (i)NUDGE model. Must have K entries. 
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_tol">tol</code></td>
<td>

<p>optional threshold for convergence for EM algorithm to estimate iNUDGE parameters.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_max.iter">max.iter</code></td>
<td>

<p>optional maximum number of iterations for EM algorithm to estimate iNUDGE parameters.
</p>
</td></tr>
<tr><td><code id="inudge.fit_+3A_z">z</code></td>
<td>

<p>optional 2-column matrix with each row giving initial estimate of probability of
the region being non-differential and a starting estimate for the probability of
the region being differential. Each row must sum to 1. Number of row must be 
equal to data length.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of object:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>the name of the model &quot;iNUDGE&quot;</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>a vector of estimated proportion of each components in the model</p>
</td></tr>  
<tr><td><code>mu</code></td>
<td>
<p>a vector of estimated Gaussian means for k-normal components.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector of estimated Gaussian standard deviation for k-normal 
components.</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>the number of normal components in the corresponding mixture model.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the log likelihood for the fitted mixture model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the actual number of iterations run by the EM algorithm.</p>
</td></tr>
<tr><td><code>fdr</code></td>
<td>
<p>the local false discover rate estimated based on iNUDGE model.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a matrix of estimated iNUDGE mixture component function.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike Information Criteria.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criteria.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DIME">DIME</a></code>, <code><a href="#topic+gng.fit">gng.fit</a></code>, <code><a href="#topic+nudge.fit">nudge.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);

# generate simulated datasets with underlying uniform and 2-normal distributions
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(-2.25,1.5); rsigma &lt;- c(1,1); 
rpi &lt;- c(.10,.45,.45); a &lt;- (-6); b &lt;- 6; 
chr4 &lt;- list(c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2])));
chr9 &lt;- list(c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2])));
# analyzing chromosome 4 and 9
data &lt;- list(chr4,chr9);

# fit iNUDGE model with 2 normal components and maximum iterations = 20
set.seed(1234);
test &lt;- inudge.fit(data, K = 2, max.iter=20);

# Getting the best fitted iNUDGE model (parameters)
test$best$pi # estimated proportion of each component in iNUDGE
test$best$mu # estimated mean of the normal component(s) in iNUDGE
# estimated standard deviation of the normal component(s) in iNUDGE
test$best$sigma 
</code></pre>

<hr>
<h2 id='inudge.plot.comp'>
Plot iNUDGE Individual Components
</h2><span id='topic+inudge.plot.comp'></span>

<h3>Description</h3>

<p>Plot each estimated individual components of iNUDGE model 
(mixture of uniform and <em>k</em>-normal) fitted using <code><a href="#topic+inudge.fit">inudge.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inudge.plot.comp(data, obj, new.plot = TRUE, legpos = NULL, xlim = NULL,
  ylim = NULL, xlab = NULL, ylab = NULL, main = NULL, lwd = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inudge.plot.comp_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+inudge.fit">inudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_new.plot">new.plot</code></td>
<td>

<p>optional logical variable on whether to create new plot.
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_legpos">legpos</code></td>
<td>

<p>optional vector of (x,y) location for the legend position
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_xlim">xlim</code></td>
<td>

<p>optional x-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_ylim">ylim</code></td>
<td>

<p>optional y-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_xlab">xlab</code></td>
<td>

<p>optional x-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_ylab">ylab</code></td>
<td>

<p>optional y-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_lwd">lwd</code></td>
<td>

<p>optional line width for lines in the plot (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.comp_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components representing differential data are denoted by asterisk (*)
symbol on the plot legend.
</p>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inudge.plot.mix">inudge.plot.mix</a></code>, <code><a href="#topic+inudge.plot.comp">inudge.plot.comp</a></code>,
<code><a href="#topic+inudge.plot.fit">inudge.plot.fit</a></code>, <code><a href="#topic+inudge.plot.qq">inudge.plot.qq</a></code>, 
<code><a href="#topic+DIME.plot.fit">DIME.plot.fit</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 2-normal distributions
set.seed(12);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(-2.25,1.5); rsigma &lt;- c(1,1); 
rpi &lt;- c(.10,.45,.45); a &lt;- (-6); b &lt;- 6; 
chr4 &lt;- list(c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2])));
chr9 &lt;- list(c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2])));
# analyzing chromosome 4 and 9
data &lt;- list(chr4,chr9);

# fit iNUDGE model with 2-normal components and maximum iterations = 20
set.seed(12);
bestInudge &lt;- inudge.fit(data, K = 2, max.iter=20);

# plot individual components of iNUDGE
inudge.plot.comp(data,bestInudge);
# plot individual components of iNUDGE an it's mixture component on the same plot
inudge.plot.mix(bestInudge,resolution=1000,new.plot=FALSE);
</code></pre>

<hr>
<h2 id='inudge.plot.fit'>
Plot iNUDGE Goodness of Fit
</h2><span id='topic+inudge.plot.fit'></span>

<h3>Description</h3>

<p>Plot the estimated iNUDGE mixture model fitted using <code><a href="#topic+inudge.fit">inudge.fit</a></code> 
along with it's estimated individual components, superimposed on the histogram 
of the observation data. This plot shows how good the fit of the estimated model
to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inudge.plot.fit(data, obj, resolution = 100, breaks = 100, 
legpos = NULL, xlim = NULL, main = NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inudge.plot.fit_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="inudge.plot.fit_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+inudge.fit">inudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="inudge.plot.fit_+3A_resolution">resolution</code></td>
<td>

<p>optional bandwidth used to estimate the density function. Higher number smoother 
curve.
</p>
</td></tr>
<tr><td><code id="inudge.plot.fit_+3A_breaks">breaks</code></td>
<td>

<p>optional see <code><a href="graphics.html#topic+hist">hist</a></code>, breaks parameters for histogram plot.
</p>
</td></tr>
<tr><td><code id="inudge.plot.fit_+3A_legpos">legpos</code></td>
<td>

<p>optional vector of (x,y) location for the legend position
</p>
</td></tr>
<tr><td><code id="inudge.plot.fit_+3A_xlim">xlim</code></td>
<td>

<p>optional x-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.fit_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.fit_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components representing differential data are denoted by asterisk (*)
symbol on the plot legend.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gng.plot.comp">gng.plot.comp</a></code>, <code><a href="#topic+gng.plot.mix">gng.plot.mix</a></code>, 
<code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 2-normal distributions
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(-2.25,1.5); rsigma &lt;- c(1,1); 
rpi &lt;- c(.10,.45,.45); a &lt;- (-6); b &lt;- 6; 
chr4 &lt;- list(c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2])));
chr9 &lt;- list(c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2])));
# analyzing chromosome 4 and 9
data &lt;- list(chr4,chr9);

# fit iNUDGE model with 2-normal components and maximum iterations = 20
set.seed(1234);
bestInudge &lt;- inudge.fit(data, K = 2, max.iter=20);

# Goodness of fit plot
inudge.plot.fit(data,bestInudge,legpos=c(-6,0.3),ylim=c(0,0.3),breaks=40);

</code></pre>

<hr>
<h2 id='inudge.plot.mix'>
Plot iNUDGE Mixture Component Function
</h2><span id='topic+inudge.plot.mix'></span>

<h3>Description</h3>

<p>Plot each estimated individual components of iNUDGE mixture model fitted using 
<code><a href="#topic+inudge.fit">inudge.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inudge.plot.mix(obj, amplify = 1, resolution = 100, new.plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inudge.plot.mix_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+inudge.fit">inudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="inudge.plot.mix_+3A_amplify">amplify</code></td>
<td>

<p>optional scaling factor for visualization purposes.
</p>
</td></tr>
<tr><td><code id="inudge.plot.mix_+3A_resolution">resolution</code></td>
<td>

<p>optional bandwidth used to estimate the density function. Higher number makes a
smoother curve.
</p>
</td></tr>
<tr><td><code id="inudge.plot.mix_+3A_new.plot">new.plot</code></td>
<td>

<p>optional logical variable on whether to create new plot.
</p>
</td></tr>
<tr><td><code id="inudge.plot.mix_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inudge.plot.comp">inudge.plot.comp</a></code>, <code><a href="#topic+inudge.plot.fit">inudge.plot.fit</a></code>,
<code><a href="#topic+inudge.plot.qq">inudge.plot.qq</a></code>, <code><a href="#topic+DIME.plot.fit">DIME.plot.fit</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)

# generate simulated datasets with underlying uniform and 2-normal distributions
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(-2.25,1.5); rsigma &lt;- c(1,1); 
rpi &lt;- c(.10,.45,.45); a &lt;- (-6); b &lt;- 6; 
chr4 &lt;- list(c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2])));
chr9 &lt;- list(c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2])));
# analyzing chromosome 4 and 9
data &lt;- list(chr4,chr9);

# fit iNUDGE model
set.seed(1234);
bestInudge &lt;- inudge.fit(data, K = 2, max.iter=20);

# plot estimated iNUDGE model imposed on the histogram of observed data
hist(unlist(data),freq=FALSE,breaks=40);
inudge.plot.mix(bestInudge,resolution=1000,new.plot=FALSE,col="red");
</code></pre>

<hr>
<h2 id='inudge.plot.qq'>
QQ-plot of GNG model vs. observed data
</h2><span id='topic+inudge.plot.qq'></span>

<h3>Description</h3>

<p>Produces a QQ-plot for visual inspection of quality of fit with regards to 
the uniform Gaussian (iNUDGE) mixture model estimated using the function 
<code><a href="#topic+inudge.fit">inudge.fit</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inudge.plot.qq(data, obj, resolution = 10, xlab = NULL, ylab = NULL,
  main = NULL, pch = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inudge.plot.qq_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="inudge.plot.qq_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="inudge.plot.qq_+3A_resolution">resolution</code></td>
<td>

<p>optional number of points used to sample the estimated density function.
</p>
</td></tr>
<tr><td><code id="inudge.plot.qq_+3A_xlab">xlab</code></td>
<td>

<p>optional x-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.qq_+3A_ylab">ylab</code></td>
<td>

<p>optional y-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.qq_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.qq_+3A_pch">pch</code></td>
<td>

<p>optional plotting symbol to use (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="inudge.plot.qq_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+inudge.fit">inudge.fit</a></code>, <code><a href="stats.html#topic+qqplot">qqplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);

# generate simulated datasets with underlying uniform and 2-normal distributions
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(-2.25,1.5); rsigma &lt;- c(1,1); 
rpi &lt;- c(.10,.45,.45); a &lt;- (-6); b &lt;- 6; 
chr4 &lt;- list(c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N1),rmu[2],rsigma[2])));
chr9 &lt;- list(c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]), 
  rnorm(ceiling(rpi[3]*N2),rmu[2],rsigma[2])));
# analyzing chromosome 4 and 9
data &lt;- list(chr4,chr9);

# fit iNUDGE model with 2-normal components and maximum iteration =20 
set.seed(1234);
bestInudge &lt;- inudge.fit(data, K=2, max.iter=20)

# QQ-plot
inudge.plot.qq(data,bestInudge);

</code></pre>

<hr>
<h2 id='inudge.qq.plot.internal'>
Internal function for QQ-plot of iNUDGE model
</h2><span id='topic+inudge.qq.plot.internal'></span>

<h3>Description</h3>

<p>Internal function needed to generate a QQ-plot for iNUDGE model. 
<code><a href="#topic+inudge.plot.qq">inudge.plot.qq</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inudge.qq.plot.internal(i, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inudge.qq.plot.internal_+3A_i">i</code></td>
<td>

<p>a number which is used to generate random sample of inudge model.
</p>
</td></tr>
<tr><td><code id="inudge.qq.plot.internal_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+inudge.fit">inudge.fit</a></code> function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inudge.fit">inudge.fit</a></code>, <code><a href="#topic+inudge.plot.qq">inudge.plot.qq</a></code>
</p>

<hr>
<h2 id='nudge.classify'>
Classification Based on NUDGE Model
</h2><span id='topic+nudge.classify'></span>

<h3>Description</h3>

<p>Classifies observed data into differential and non-differential groups based on
NUDGE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nudge.classify(data, obj, obj.cutoff = 0.1, obj.sigma.diff.cutoff = NULL,
  obj.mu.diff.cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nudge.classify_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to particular chromosome. User can construct their own list
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="nudge.classify_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+nudge.fit">nudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="nudge.classify_+3A_obj.cutoff">obj.cutoff</code></td>
<td>

<p>optional local <em>fdr</em> cutoff for classifying data into differential
and non-differential groups based on NUDGE model.
</p>
</td></tr>
<tr><td><code id="nudge.classify_+3A_obj.sigma.diff.cutoff">obj.sigma.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in NUDGE
model to be designated as representing differential.
</p>
</td></tr>
<tr><td><code id="nudge.classify_+3A_obj.mu.diff.cutoff">obj.mu.diff.cutoff</code></td>
<td>

<p>optional cut-off for standard deviation of the normal component in NUDGE
model to be designated as representing differential.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object passed as input with additional element $class containing vector
of classifications for all the observations in data. A classification of 1
denotes that the data is classified as differential with fdr &lt; obj.cutoff.
</p>
<table>
<tr><td><code>mu.diff.cutoff</code></td>
<td>
<p>normal component with mean &gt; mu.diff.cutoff
was used to represent differential component.</p>
</td></tr>
<tr><td><code>sigma.diff.cutoff</code></td>
<td>
<p>normal component with standard deviation &gt;
sigma.diff.cutoff was used to represent differential component.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>,
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nudge.fit">nudge.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 1-normal components
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(1.5); rsigma &lt;- c(1); 
rpi &lt;- c(.10,.90); a &lt;- (-6); b &lt;- 6; 
chr1 &lt;- c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]));
chr4 &lt;- c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]));  
# analyzing chromosome 1 and 4
data &lt;- list(chr1,chr4);

# fit NUDGE model with maximum iterations = 20 only
set.seed(1234);
test &lt;- nudge.fit(data, max.iter=20)
# vector of classification. 1 represents differential, 0 denotes non-differential
nudgeClass &lt;- test$class;
</code></pre>

<hr>
<h2 id='nudge.fit'>
Function for Fitting NUDGE model parameters
</h2><span id='topic+nudge.fit'></span>

<h3>Description</h3>

<p>Function to estimate parameters for both NUDGE model, mixture of 
uniform and 1-normal. Parameters are estimated using EM algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nudge.fit(data, avg = NULL, weights = NULL, weights.cutoff = -1.345,
  pi = NULL, mu = NULL, sigma = NULL, tol = 1e-5, max.iter = 2000, z = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nudge.fit_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to a particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_avg">avg</code></td>
<td>

<p>optional vector of mean data (or log intensities). Only required when any one
of huber weight (lower, upper or full) is selected.
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_weights">weights</code></td>
<td>

<p>optional weights to be used for robust fitting. Can be a matrix the same 
length as data, or a character description of the huber weight method to be 
employed:
&quot;lower&quot; - only value below weights.cutoff are weighted,\ 
&quot;upper&quot; - only value above weights.cutoff are weighted,\
&quot;full&quot;  - both values above and below weights.cutoff are weighted,\ 
If selected, mean of data (avg) is required. 
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_weights.cutoff">weights.cutoff</code></td>
<td>

<p>optional cutoff to be used with the Huber weighting scheme.
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_pi">pi</code></td>
<td>

<p>optional vector containing initial estimates for proportion of the NUDGE mixture 
components. The first entry is for the uniform component, the middle <em>k</em> entries
are for normal components.
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_mu">mu</code></td>
<td>

<p>optional vector containing initial estimates of the Gaussian means in NUDGE model.
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_sigma">sigma</code></td>
<td>

<p>optional vector containing initial estimates of the Gaussian standard deviation
in (i)NUDGE model. Must have K entries. 
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_tol">tol</code></td>
<td>

<p>optional threshold for convergence for EM algorithm to estimate NUDGE parameters.
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_max.iter">max.iter</code></td>
<td>

<p>optional maximum number of iterations for EM algorithm to estimate NUDGE parameters.
</p>
</td></tr>
<tr><td><code id="nudge.fit_+3A_z">z</code></td>
<td>

<p>optional 2-column matrix with each row giving initial estimate of probability of
the region being non-differential and a starting estimate for the probability of
the region being differential. Each row must sum to 1. Number of row must be 
equal to data length.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of object:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>the name of the model &quot;NUDGE&quot;</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>a vector of estimated proportion of each components in the model</p>
</td></tr>  
<tr><td><code>mu</code></td>
<td>
<p>a vector of estimated Gaussian means for k-normal components.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>a vector of estimated Gaussian standard deviation for k-normal 
components.</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>the log likelihood for the fitted mixture model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the actual number of iterations run by the EM algorithm.</p>
</td></tr>
<tr><td><code>fdr</code></td>
<td>
<p>the local false discover rate estimated based on NUDGE model.</p>
</td></tr>
<tr><td><code>phi</code></td>
<td>
<p>a matrix of estimated NUDGE mixture component function.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>Akaike Information Criteria.</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>Bayesian Information Criteria.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cenny Taslim <a href="mailto:taslim.2@osu.edu">taslim.2@osu.edu</a>, with contributions from Abbas Khalili
<a href="mailto:khalili@stat.ubc.ca">khalili@stat.ubc.ca</a>, Dustin Potter <a href="mailto:potterdp@gmail.com">potterdp@gmail.com</a>, 
and Shili Lin <a href="mailto:shili@stat.osu.edu">shili@stat.osu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DIME">DIME</a></code>, <code><a href="#topic+gng.fit">gng.fit</a></code>, <code><a href="#topic+inudge.fit">inudge.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 1-normal components
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(1.5); rsigma &lt;- c(1); 
rpi &lt;- c(.10,.90); a &lt;- (-6); b &lt;- 6; 
chr1 &lt;- c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]));
chr4 &lt;- c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]));  
# analyzing chromosome 1 and 4
data &lt;- list(chr1,chr4);

# fit NUDGE model with maximum iterations = 20 only
set.seed(1234);
bestNudge &lt;- nudge.fit(data, max.iter=20);

# Getting the best fitted NUDGE model (parameters)
bestNudge$pi # estimated proportion of each component in NUDGE
bestNudge$mu # estimated mean of the normal component(s) in NUDGE
# estimated standard deviation of the normal component(s) in NUDGE
bestNudge$sigma 
</code></pre>

<hr>
<h2 id='nudge.plot.comp'>
Plot NUDGE Individual Components
</h2><span id='topic+nudge.plot.comp'></span>

<h3>Description</h3>

<p>Plot each estimated individual components of NUDGE model 
(mixture of uniform and 1-normal) fitted using <code><a href="#topic+nudge.fit">nudge.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nudge.plot.comp(data, obj, new.plot = TRUE, legpos = NULL, xlim = NULL,
  ylim = NULL, xlab = NULL, ylab = NULL, main = NULL, lwd = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nudge.plot.comp_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to a particular chromosome. User can construct 
their own list containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+nudge.fit">nudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_new.plot">new.plot</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each object can correspond to
particular chromosome that one want to fit.
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_legpos">legpos</code></td>
<td>

<p>optional vector of (x,y) location for the legend position
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_xlim">xlim</code></td>
<td>

<p>optional x-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_ylim">ylim</code></td>
<td>

<p>optional y-axis limit (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_xlab">xlab</code></td>
<td>

<p>optional x-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_ylab">ylab</code></td>
<td>

<p>optional y-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_lwd">lwd</code></td>
<td>

<p>optional line width for lines in the plot (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.comp_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components representing differential data are denoted by asterisk (*)
symbol on the plot legend.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nudge.plot.mix">nudge.plot.mix</a></code>, <code><a href="#topic+inudge.plot.comp">inudge.plot.comp</a></code>, 
<code><a href="#topic+nudge.plot.fit">nudge.plot.fit</a></code>, <code><a href="#topic+nudge.plot.qq">nudge.plot.qq</a></code>, 
<code><a href="#topic+DIME.plot.fit">DIME.plot.fit</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 1-normal components
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(1.5); rsigma &lt;- c(1); 
rpi &lt;- c(.10,.90); a &lt;- (-6); b &lt;- 6; 
chr1 &lt;- c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]));
chr4 &lt;- c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]));  
# analyzing chromosome 1 and 4
data &lt;- list(chr1,chr4);

# fit NUDGE model with maximum iterations = 20
set.seed(1234);
bestNudge &lt;- nudge.fit(data, max.iter=20);

# plot individual components of NUDGE
nudge.plot.comp(data,bestNudge);

</code></pre>

<hr>
<h2 id='nudge.plot.fit'>
Plot NUDGE Goodness of Fit
</h2><span id='topic+nudge.plot.fit'></span>

<h3>Description</h3>

<p>Plot the estimated NUDGE mixture model fitted using <code><a href="#topic+nudge.fit">nudge.fit</a></code> 
along with it's estimated individual components, superimposed on the histogram 
of the observation data. This plot shows how good the fit of the estimated model
to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nudge.plot.fit(data, obj, resolution = 100, breaks = 100, 
xlim = NULL, legpos = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nudge.plot.fit_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to a particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="nudge.plot.fit_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+nudge.fit">nudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="nudge.plot.fit_+3A_resolution">resolution</code></td>
<td>

<p>optional bandwidth used to estimate the density function. Higher number smoother 
curve.
</p>
</td></tr>
<tr><td><code id="nudge.plot.fit_+3A_breaks">breaks</code></td>
<td>

<p>optional see <code><a href="graphics.html#topic+hist">hist</a></code>, breaks parameters for histogram plot.
</p>
</td></tr>
<tr><td><code id="nudge.plot.fit_+3A_xlim">xlim</code></td>
<td>

<p>optional limit for the x-axis.
</p>
</td></tr>
<tr><td><code id="nudge.plot.fit_+3A_legpos">legpos</code></td>
<td>

<p>optional vector of (x,y) location for the legend position
</p>
</td></tr>
<tr><td><code id="nudge.plot.fit_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The components representing differential data are denoted by asterisk (*)
symbol on the plot legend.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nudge.plot.comp">nudge.plot.comp</a></code>, <code><a href="#topic+nudge.plot.mix">nudge.plot.mix</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 1-normal components
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(1.5); rsigma &lt;- c(1); 
rpi &lt;- c(.10,.90); a &lt;- (-6); b &lt;- 6; 
chr1 &lt;- c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]));
chr4 &lt;- c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]));  
# analyzing chromosome 1 and 4
data &lt;- list(chr1,chr4);

# fit NUDGE model with maximum iterations = 20
set.seed(1234);
bestNudge &lt;- nudge.fit(data, max.iter=20);

# goodness of fit plot
nudge.plot.fit(data,bestNudge,breaks=40);

</code></pre>

<hr>
<h2 id='nudge.plot.mix'>
Plot NUDGE Mixture Component Function
</h2><span id='topic+nudge.plot.mix'></span>

<h3>Description</h3>

<p>Plot each estimated individual components of NUDGE mixture model fitted using 
<code><a href="#topic+nudge.fit">nudge.fit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nudge.plot.mix(obj, amplify = 1, resolution = 100, new.plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nudge.plot.mix_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+nudge.fit">nudge.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="nudge.plot.mix_+3A_amplify">amplify</code></td>
<td>

<p>optional scaling factor for visualization purposes.
</p>
</td></tr>
<tr><td><code id="nudge.plot.mix_+3A_resolution">resolution</code></td>
<td>

<p>optional bandwidth used to estimate the density function. Higher number makes a
smoother curve.
</p>
</td></tr>
<tr><td><code id="nudge.plot.mix_+3A_new.plot">new.plot</code></td>
<td>

<p>optional logical variable on whether to create new plot.
</p>
</td></tr>
<tr><td><code id="nudge.plot.mix_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nudge.plot.comp">nudge.plot.comp</a></code>, <code><a href="#topic+nudge.plot.fit">nudge.plot.fit</a></code>,
<code><a href="#topic+nudge.plot.qq">nudge.plot.qq</a></code>, <code><a href="#topic+DIME.plot.fit">DIME.plot.fit</a></code>, <code><a href="#topic+gng.plot.fit">gng.plot.fit</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME);
# generate simulated datasets with underlying uniform and 1-normal components
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(1.5); rsigma &lt;- c(1); 
rpi &lt;- c(.10,.90); a &lt;- (-6); b &lt;- 6; 
chr1 &lt;- c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]));
chr4 &lt;- c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]));  
# analyzing chromosome 1 and 4
data &lt;- list(chr1,chr4);

# fit NUDGE model with maximum iterations = 20 only
bestNudge &lt;- nudge.fit(data, max.iter=20);

# plot estimated iNUDGE model imposed on the histogram of observed data
hist(unlist(data),freq=FALSE,breaks=40);
nudge.plot.mix(bestNudge,resolution=1000,new.plot=FALSE,col="red");

</code></pre>

<hr>
<h2 id='nudge.plot.qq'>
QQ-plot of GNG model vs. observed data
</h2><span id='topic+nudge.plot.qq'></span>

<h3>Description</h3>

<p>Produces a QQ-plot for visual inspection of quality of fit with regards to 
the uniform Gaussian (NUDGE) mixture model estimated using the function 
<code><a href="#topic+nudge.fit">nudge.fit</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nudge.plot.qq(data, obj, resolution = 10, xlab = NULL, ylab = NULL, 
  main = NULL, pch = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nudge.plot.qq_+3A_data">data</code></td>
<td>

<p>an <strong>R list</strong> of vector of normalized intensities (counts). Each element can
correspond to a particular chromosome. User can construct their own list 
containing only the chromosome(s) they want to analyze.
</p>
</td></tr>
<tr><td><code id="nudge.plot.qq_+3A_obj">obj</code></td>
<td>

<p>a list object returned by <code><a href="#topic+gng.fit">gng.fit</a></code> function.
</p>
</td></tr>
<tr><td><code id="nudge.plot.qq_+3A_resolution">resolution</code></td>
<td>

<p>optional number of points used to sample the estimated density function.
</p>
</td></tr>
<tr><td><code id="nudge.plot.qq_+3A_xlab">xlab</code></td>
<td>

<p>optional x-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.qq_+3A_ylab">ylab</code></td>
<td>

<p>optional y-axis label (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.qq_+3A_main">main</code></td>
<td>

<p>optional plot title (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.qq_+3A_pch">pch</code></td>
<td>

<p>optional plotting character, i.e., symbol to use (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
<tr><td><code id="nudge.plot.qq_+3A_...">...</code></td>
<td>

<p>additional graphical arguments to be passed to methods (see <code><a href="graphics.html#topic+par">par</a></code>).
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+nudge.fit">nudge.fit</a></code>, <code><a href="stats.html#topic+qqplot">qqplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DIME)

# generate simulated datasets with underlying uniform and 1-normal components
set.seed(1234);
N1 &lt;- 1500; N2 &lt;- 500; rmu &lt;- c(1.5); rsigma &lt;- c(1); 
rpi &lt;- c(.10,.90); a &lt;- (-6); b &lt;- 6; 
chr1 &lt;- c(-runif(ceiling(rpi[1]*N1),min = a,max =b),
  rnorm(ceiling(rpi[2]*N1),rmu[1],rsigma[1]));
chr4 &lt;- c(-runif(ceiling(rpi[1]*N2),min = a,max =b),
  rnorm(ceiling(rpi[2]*N2),rmu[1],rsigma[1]));  
# analyzing chromosome 1 and 4
data &lt;- list(chr1,chr4);

# fit NUDGE model with maximum iterations = 20
set.seed(1234);
bestNudge &lt;- nudge.fit(data, max.iter=20);

# QQ-plot
nudge.plot.qq(data,bestNudge);
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
