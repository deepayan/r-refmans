<!DOCTYPE html><html><head><title>Help for package seqest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seqest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A_optimal_cat'><p>Get the most informative subjects from unlabeled dataset for the</p>
categorical case</a></li>
<li><a href='#A_optimal_ord'><p>Get the most informative subjects from unlabeled dataset for the</p>
ordinal case</a></li>
<li><a href='#ase_seq_logit'><p>variable selection and stopping criterion</p></a></li>
<li><a href='#D_optimal'><p>Get the most informative subjects for the clustered data</p></a></li>
<li><a href='#evaluateGEEModel'><p>The adaptive shrinkage estimate for generalized estimating equations</p></a></li>
<li><a href='#gen_bin_data'><p>generate the data used for the model experiment</p></a></li>
<li><a href='#gen_GEE_data'><p>Generate the datasets with clusters</p></a></li>
<li><a href='#gen_multi_data'><p>Generate the training data and testing data for the categorical and</p>
ordinal case.</a></li>
<li><a href='#genBin'><p>Generate the correlated binary response data for discrete case</p></a></li>
<li><a href='#genCorMat'><p>Generate the correlation matrix for the clusteded data</p></a></li>
<li><a href='#getMH'><p>Get the matrices M and H for the clustered data for the GEE case</p></a></li>
<li><a href='#getWH'><p>Get the matrices W and H for the categorical case</p></a></li>
<li><a href='#getWH_ord'><p>Get the matrices W and H for the ordinal case</p></a></li>
<li><a href='#init_multi_data'><p>Generate the labeled and unlabeled datasets</p></a></li>
<li><a href='#is_stop_ASE'><p>Determining whether to stop choosing sample</p></a></li>
<li><a href='#logit_model'><p>the individualized binary logistic regression for categorical response</p>
data.</a></li>
<li><a href='#logit_model_ord'><p>the individualized binary logistic regression for ordinal response</p>
data.</a></li>
<li><a href='#print.seqbin'><p>Print the results by the binary logistic regression model</p></a></li>
<li><a href='#print.seqGEE'><p>Print the results by the generalized estimating equations.</p></a></li>
<li><a href='#print.seqmulti'><p>Print the results by the multi-logistic regression model</p></a></li>
<li><a href='#QIC'><p>Calculate quasi-likelihood under the independence model criterion</p>
(QIC) for Generalized Estimating Equations.</a></li>
<li><a href='#seq_bin_model'><p>The sequential logistic regression model for binary classification</p>
problem.</a></li>
<li><a href='#seq_cat_model'><p>The sequential logistic regression model for multi-classification</p>
problem under the categorical case.</a></li>
<li><a href='#seq_GEE_model'><p>The The sequential method for generalized estimating equations case.</p></a></li>
<li><a href='#seq_ord_model'><p>The sequential logistic regression model for multi-classification</p>
problem under the ordinal case.</a></li>
<li><a href='#update_data_cat'><p>Add the new sample into labeled dataset from unlabeled dataset for the</p>
categorical case</a></li>
<li><a href='#update_data_ord'><p>Add the new sample into labeled dataset from unlabeled dataset for the</p>
ordinal case</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sequential Method for Classification and Generalized Estimating
Equations Problem</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiaoba Pan &lt;july666@mail.ustc.edu.cn&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Sequential method to solve the the binary classification problem 
    by Wang (2019) &lt;arXiv:arXiv:1901.10079&gt;, multi-class 
    classification problem by Li (2020) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2020.106911">doi:10.1016/j.csda.2020.106911</a>&gt;
    and the highly stratified multiple-response problem by Chen (2019)
    &lt;<a href="https://doi.org/10.1111%2Fbiom.13160">doi:10.1111/biom.13160</a>&gt;.</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.2), geepack, mvtnorm, nnet, VGAM, MASS, foreach,
stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-06-10 07:55:10 UTC</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-17 03:11:11 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiaoba Pan [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-17 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='A_optimal_cat'>Get the most informative subjects from unlabeled dataset for the
categorical case</h2><span id='topic+A_optimal_cat'></span>

<h3>Description</h3>

<p>Get the most informative subjects from unlabeled dataset under
the categorical case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A_optimal_cat(X, beta, W, unlabeledIDs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A_optimal_cat_+3A_x">X</code></td>
<td>
<p>A matrix containing all the samples except their labels including
the labeled samples and the unlabeled samples.</p>
</td></tr>
<tr><td><code id="A_optimal_cat_+3A_beta">beta</code></td>
<td>
<p>A matrix contains the estimated coefficient. Note that the beta
is a n * k matrix which n is the number of the explanatory variables and
k+1 is the number of categories</p>
</td></tr>
<tr><td><code id="A_optimal_cat_+3A_w">W</code></td>
<td>
<p>A matrix denotes the inverse information matrix of the coefficient
beta.</p>
</td></tr>
<tr><td><code id="A_optimal_cat_+3A_unlabeledids">unlabeledIDs</code></td>
<td>
<p>A numeric vector for the unique identification of the
unlabeled. dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A_optimal_cat uses the A optimality criterion from the experimental design
to choose the most informative subjects under the the categorical case. We
have obtained the variance-covariance matrix based on the current labeled
samples which indicates how much information there is. Then we should
repeatly calculate the information matrix after we choose a sample from the
unlabeled dataset. Once we finish the iteration, we pick the sample which
has the most information.
</p>


<h3>Value</h3>

<p>a index of the most informative subjects from unlabeled dataset for
the categorical case
</p>

<hr>
<h2 id='A_optimal_ord'>Get the most informative subjects from unlabeled dataset for the
ordinal case</h2><span id='topic+A_optimal_ord'></span>

<h3>Description</h3>

<p>Get the most informative subjects from unlabeled dataset under
the ordinal case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A_optimal_ord(X, beta, W, unlabeledIDs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="A_optimal_ord_+3A_x">X</code></td>
<td>
<p>A matrix containing all the samples except their labels including
the labeled samples and the unlabeled samples.</p>
</td></tr>
<tr><td><code id="A_optimal_ord_+3A_beta">beta</code></td>
<td>
<p>A matrix contains the estimated coefficient. Note that the beta
is a n * k matrix which n is the number of the explanatory variables and
k+1 is the number of categories</p>
</td></tr>
<tr><td><code id="A_optimal_ord_+3A_w">W</code></td>
<td>
<p>A matrix denotes the inverse information matrix of the coefficient
beta.</p>
</td></tr>
<tr><td><code id="A_optimal_ord_+3A_unlabeledids">unlabeledIDs</code></td>
<td>
<p>A numeric vector for the unique identification of the
unlabeled. dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A_optimal_ord uses the A optimality criterion from the experimental design
to choose the most informative subjects under the the ordinal case. We have
obtained the variance-covariance matrix based on the current labeled samples
which indicates how much information there is. Then we should repeatly
calculate the information matrix after we choose a sample from the unlabeled
dataset. Once we finish the iteration, we pick the sample which has the most
information.
</p>


<h3>Value</h3>

<p>a index of the most informative subjects from unlabeled dataset for
the ordinal case
</p>

<hr>
<h2 id='ase_seq_logit'>variable selection and stopping criterion</h2><span id='topic+ase_seq_logit'></span>

<h3>Description</h3>

<p><code>ase_seq_logit</code> determine the effective variables and whether to stop
selecting samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ase_seq_logit(X, Y, intercept = FALSE, criterion = "BIC", d = 0.5,
  alpha = 0.95, gamma = 1, eta = 0.75, upper = 2, lower = 0.1,
  divid.num = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ase_seq_logit_+3A_x">X</code></td>
<td>
<p>A dataframe that each row is a sample,each column represents an
independent variable.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_y">Y</code></td>
<td>
<p>Numeric vector consists of 0 or 1. The length of Y must be the same
as the X.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_intercept">intercept</code></td>
<td>
<p>A logical value indicating whether add intercept to model.
The default value is FALSE.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_criterion">criterion</code></td>
<td>
<p>For the &quot;chosfun&quot; methods, a character string that
determines the model selection criterion to be used, matching one of 'BIC'
or 'AIC. The default value is 'BIC'.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_d">d</code></td>
<td>
<p>A numeric number specifying the length of the fixed size
confidence set for our model. Note that the smaller the d, the larger
the sample size and the longer the time costs. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_alpha">alpha</code></td>
<td>
<p>A numeric number used in the chi-square distribution. The
default value is 0.95.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_gamma">gamma</code></td>
<td>
<p>A numeric number to determine the effective variables with eta.
The default value is 1.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_eta">eta</code></td>
<td>
<p>A numeric number to determine the effective variables with gamma.
The default value is 0.75.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_upper">upper</code></td>
<td>
<p>A numeric number to choose the right epsilon with params lower
and divide.num. The value of upper should be larger than lower. The default
value is 2.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_lower">lower</code></td>
<td>
<p>A numeric number to choose the right epsilon with params upper
and divide.num. The default value is 0.1.</p>
</td></tr>
<tr><td><code id="ase_seq_logit_+3A_divid.num">divid.num</code></td>
<td>
<p>A numeric number to choose the right epsilon with params
upper and lower. Note that it should be a integer. The default value is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ase_seq_logit estimates the logistic regression coefficient and determines
the effecrive variables and decides whether to stop selecting samples based
on the current sample and its corresponding label. The parameters 'upper',
'lower' and 'divid.num' is used to get different epsilons. If different
epsilons get the same value, we choose the smallest epsilon.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>N</code></td>
<td>
<p>current sample size</p>
</td></tr>
<tr><td><code>is_stopped</code></td>
<td>
<p>the label of sequential stop or not. When the value of
is_stopped is 1, it means the iteration stops</p>
</td></tr>
<tr><td><code>betahat</code></td>
<td>
<p>the estimated coefficients based on current X and Y. Note that
some coefficient will be zero. These are the non-effectiva variables should
be ignored.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the covariance matrix between variables</p>
</td></tr>
<tr><td><code>phat</code></td>
<td>
<p>the number of effective varriables.</p>
</td></tr>
<tr><td><code>ak</code></td>
<td>
<p>1-alpha quantile of chisquare distribution with degree of freedom
phat</p>
</td></tr>
<tr><td><code>lamdmax</code></td>
<td>
<p>the maximum eigenvalue based on the covariance of data</p>
</td></tr>
</table>

<hr>
<h2 id='D_optimal'>Get the most informative subjects for the clustered data</h2><span id='topic+D_optimal'></span>

<h3>Description</h3>

<p>Get the most informative subjects for the highly stratified
response data by the D-optimility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>D_optimal(X, id, beta, nonZeroSet, M, rho, linkv, corstrv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="D_optimal_+3A_x">X</code></td>
<td>
<p>A data frame contains all the random samples which we will choose
subject from.</p>
</td></tr>
<tr><td><code id="D_optimal_+3A_id">id</code></td>
<td>
<p>The id for each subject in the X</p>
</td></tr>
<tr><td><code id="D_optimal_+3A_beta">beta</code></td>
<td>
<p>The paramters that we estimate under the current samples</p>
</td></tr>
<tr><td><code id="D_optimal_+3A_nonzeroset">nonZeroSet</code></td>
<td>
<p>The set of the index of the non zero coefficient</p>
</td></tr>
<tr><td><code id="D_optimal_+3A_m">M</code></td>
<td>
<p>A numeric matrix calculated by the <code><a href="#topic+getMH">getMH</a></code> function</p>
</td></tr>
<tr><td><code id="D_optimal_+3A_rho">rho</code></td>
<td>
<p>A numeric number indicating the estimate of correlation
coefficient</p>
</td></tr>
<tr><td><code id="D_optimal_+3A_linkv">linkv</code></td>
<td>
<p>A specification for the model link function.</p>
</td></tr>
<tr><td><code id="D_optimal_+3A_corstrv">corstrv</code></td>
<td>
<p>A character string specifying the correlation structure. The
following are permitted: &quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>D_optimal uses the D-optimality criterion from the experimental design to
choose the most informative subjects for the highly stratified response
data.
</p>


<h3>Value</h3>

<p>a index of the most informative subject
</p>

<hr>
<h2 id='evaluateGEEModel'>The adaptive shrinkage estimate for generalized estimating equations</h2><span id='topic+evaluateGEEModel'></span>

<h3>Description</h3>

<p><code>evaluateGEEModel</code> is used to get a generalized estimating equation of the
data by the adaptive shrinkage estimate method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateGEEModel(family, corstr, y, x, clusterID, criterion = "QIC",
  theta = 0.75, gamma = 1, leastVar = 3, mostVar = ncol(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateGEEModel_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link function to be
used in the model. See family for details of <code><a href="stats.html#topic+family">family</a></code>
functions.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_corstr">corstr</code></td>
<td>
<p>A character string specifying the correlation structure. The
following are permitted: &quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_y">y</code></td>
<td>
<p>The response data.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_x">x</code></td>
<td>
<p>A data frame contains the covariate vectors.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_clusterid">clusterID</code></td>
<td>
<p>The id for each subject in the initial samples. Note that
the subjects in the same cluster will have identical id.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_criterion">criterion</code></td>
<td>
<p>The model selection criteria, one of the 'PWD' or 'QIC'.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_theta">theta</code></td>
<td>
<p>The parameters of the adaptive shrinkage estimate.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_gamma">gamma</code></td>
<td>
<p>The parameters of the adaptive shrinkage estimate.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_leastvar">leastVar</code></td>
<td>
<p>The minimum number of variables.</p>
</td></tr>
<tr><td><code id="evaluateGEEModel_+3A_mostvar">mostVar</code></td>
<td>
<p>The maximum number of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>evaluateGEEModel fits the current data by generalized estimating equations(GEE)
according to the value of the family argument and the corstr argument. We
should notice that this is not the ordinary generalized estimating equations.
It can determine the variables that have an impact on the response which
called effective variables. We use model selection criteria like the QIC
criterion to choose the optimal value.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>rho</code></td>
<td>
<p>the correlation coefficient of the clusters</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>parameters that we estimate under the current samples</p>
</td></tr>
<tr><td><code>sandwich</code></td>
<td>
<p>the sandwich information matrix for covariance</p>
</td></tr>
<tr><td><code>nonZeroIdx</code></td>
<td>
<p>the index of the non zero coefficients</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>a list containing several matrices including the sandwich matrix</p>
</td></tr>
</table>

<hr>
<h2 id='gen_bin_data'>generate the data used for the model experiment</h2><span id='topic+gen_bin_data'></span>

<h3>Description</h3>

<p><code>gen_bin_data</code> generate the data used for the model experiment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_bin_data(beta, N, nclass, seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_bin_data_+3A_beta">beta</code></td>
<td>
<p>A numeric vector that represents the true coefficients that used to
generate the synthesized data.</p>
</td></tr>
<tr><td><code id="gen_bin_data_+3A_n">N</code></td>
<td>
<p>A numeric number specifying the number of the synthesized data. It
should be an integer.</p>
</td></tr>
<tr><td><code id="gen_bin_data_+3A_nclass">nclass</code></td>
<td>
<p>A numeric number used to specify how many clusters the original
data would be transformed into. It should be an integer.</p>
</td></tr>
<tr><td><code id="gen_bin_data_+3A_seed">seed</code></td>
<td>
<p>Set random number seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function gen_bin_data generates N points. That is,the first column of the
design matrix is 1 and the second column has a normal distribution with a
mean of 1 and a variance of 1 and the rest columns with a mean of 0 and a
variance of 1. Next, they are clustered into classes to decrease the
computation cost. You should specify the number of classes. In the function,
it's the parameter nclass.
</p>


<h3>Value</h3>

<p>a list of seven elements:
</p>
<table>
<tr><td><code>data.clust</code></td>
<td>
<p>list with clustering results. Samples in the same list
element are closer with each other</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the samples with the smallest variance from each cluster. Note that
the length of X is the same as the number of data.clust</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the target value of 0 or 1 corresponding to X</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wang Z, Kwon Y, Chang YcI (2019). Active learning for binary classification
with variable selection. arXiv preprint arXiv:1901.10079.

</p>


<h3>See Also</h3>


<p><code><a href="#topic+gen_multi_data">gen_multi_data</a></code> for categorical and ordinal case
</p>
<p><code><a href="#topic+gen_GEE_data">gen_GEE_data</a></code> for generalized estimating equations case.

</p>


<h3>Examples</h3>

<pre><code class='language-R'># For an example, see example(seq_bin_model)
</code></pre>

<hr>
<h2 id='gen_GEE_data'>Generate the datasets with clusters</h2><span id='topic+gen_GEE_data'></span>

<h3>Description</h3>

<p><code>gen_GEE_data</code> generates the clustered data used for the generalized
estimating equations with sequential method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_GEE_data(numClusters, clusterSize, clusterRho, clusterCorstr, beta,
  family, intercept = TRUE, xCorstr = "ar1", xCorRho = 0.5,
  xVariance = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_GEE_data_+3A_numclusters">numClusters</code></td>
<td>
<p>A numeric number represents the number of clusters we will
generated. Note that each cluster has several similar subjects. It should
be a integer.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_clustersize">clusterSize</code></td>
<td>
<p>A numeric number specifying the number of subjects in
each cluster. The subject in the same cluster is highly correlated to each
other which can be regarded as the longitudinal data.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_clusterrho">clusterRho</code></td>
<td>
<p>A numeric parameter in correlation structure for the
clusters. It will be ignored when responseCorstr is independence.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_clustercorstr">clusterCorstr</code></td>
<td>
<p>A character string specifying the correlation structure
for the clusters. Allowed structures are: &quot;independence&quot;, &quot;exchangeable&quot;
and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_beta">beta</code></td>
<td>
<p>A nummeric vector denotes the true parameter in GEE model.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_family">family</code></td>
<td>
<p>The type of response data, matching one of 'gaussian()' or
'binomial()'. The 'gaussian()' corresponds to the continuous case and
'binomial' corresponds to the discrete case.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_intercept">intercept</code></td>
<td>
<p>A logical value indicating whether to add intercept term.
The default value is TRUE.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_xcorstr">xCorstr</code></td>
<td>
<p>A character string specifying the correlation structure for
the covariate. The default value is 'ar1'.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_xcorrho">xCorRho</code></td>
<td>
<p>A numeric parameter indicating the correlation coefficient in
covariables. It does something similar to what the argument clusterRho
does. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="gen_GEE_data_+3A_xvariance">xVariance</code></td>
<td>
<p>A numeric number specifying the marginal variance in the
correlation matrix in one clusters. The default value is 0.2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gen_GEE_data function is used to generate data. We can get data from two
different distributions, corresponding to continuous and discrete cases. In
the continuous case, the covariates vector x is created from a multivariate
normal distribution with mean 0 and an AR(1) correlation matrix with
autocorrelation coefficient and marginal variance. The value of
autocorrelation coefficient and marginal variance are two arguments which we
need specified. Then, the response y is generated by the equation: y = wx + e
where the random error vector e follows a normal distribution with mean 0 and
three different covariance structures with corresponding dimensional numbers.
These three covariance matrices are the identity matrix, the exchangeable,
and the AR(1) autoregressive correlation structure. In the discrete case, we
use a logistic model. The covariates vectors x is the same as the continuous
case. The binary response vector for each cluster has  an AR(1) correlation
structure with correlation coefficient alpha, and the marginal expectation u
satisfies the following equation: logit(u) = wx
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the covariate matrices. Note that the number of rows is numClusters
*  clusterSize and the number of columns is the length of beta + 1 if
intercept is TRUE.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the response data which has the same number of rows to x</p>
</td></tr>
<tr><td><code>clusterID</code></td>
<td>
<p>the id for each sample. Note that the subjects in the same
cluster will have identical id. </p>
</td></tr>
</table>


<h3>References</h3>


<p>Chen, Z., Wang, Z., &amp; Chang, Y. I. (2019). Sequential adaptive variables and
subject selection for GEE methods. <em>Biometrics</em>. doi:10.1111/biom.13160

</p>


<h3>See Also</h3>


<p><code><a href="#topic+gen_multi_data">gen_multi_data</a></code> for categorical and ordinal case
</p>
<p><code><a href="#topic+gen_bin_data">gen_bin_data</a></code> for binary classification case.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>initialSampleSize &lt;-  75
clusterSize &lt;-  5
responseCorstr &lt;-  "ar1"
responseCorRho &lt;-  0.3
response &lt;-  gaussian()
beta0 &lt;-  c(1, -1.1, 1.5, -2, rep(0, 50))
xVariance &lt;-  0.2
xCorRho &lt;-  0.5
xCorstr &lt;-  "ar1"
data &lt;- gen_GEE_data(numClusters = initialSampleSize,
                     clusterSize = clusterSize,
                     clusterCorstr = responseCorstr,
                     clusterRho = responseCorRho,
                     beta = beta0,
                     family = response,
                     intercept = TRUE,
                     xVariance = xVariance,
                     xCorstr = xCorstr,
                     xCorRho = xCorRho)
</code></pre>

<hr>
<h2 id='gen_multi_data'>Generate the training data and testing data for the categorical and
ordinal case.</h2><span id='topic+gen_multi_data'></span>

<h3>Description</h3>

<p><code>gen_multi_data</code> generate the data used for multiple-class
classification problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_multi_data(beta0, N, type, test_ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_multi_data_+3A_beta0">beta0</code></td>
<td>
<p>A numeric matrix that represent the true coefficient that used
to generate the synthesized data.</p>
</td></tr>
<tr><td><code id="gen_multi_data_+3A_n">N</code></td>
<td>
<p>A numeric number specifying the number of the synthesized data. It
should be a integer. Note that the value shouldn't be too small. We
recommend that the value be 10000.</p>
</td></tr>
<tr><td><code id="gen_multi_data_+3A_type">type</code></td>
<td>
<p>A character string that determines which type of data will be
generated, matching one of 'ord' or 'cat'.</p>
</td></tr>
<tr><td><code id="gen_multi_data_+3A_test_ratio">test_ratio</code></td>
<td>
<p>A numeric number specifying proportion of test sets in all
data. It should be a number between 0 and 1. Note that the value of the
test_ratio should not be too large, it is best if this value is equal to
0.2-0.3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>gen_multi_data creates training dataset and testing datasets. The beta0 is a
p * k matrix which p is the length of true coefficient and (k + 1) represents
the number of categories. The value of 'type' can be 'ord' or 'cat' . If it
equals to 'ord', it means the data has an ordinal relation among classes
,which is common in applications (e.g., the label indicates the severity of a
disease or product preference). If it is 'cat', it represents there is no
such ordinal relations among classes. In addition, the response variable y
are then generated from a multinomial distribution with the explanatory
variables x generated from a multivariate normal distribution with mean
vector equal to 0 and the identity covariance matrix.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>train_id</code></td>
<td>
<p>The id of the training samples</p>
</td></tr>
<tr><td><code>train</code></td>
<td>
<p>the training datasets. Note that the id of the data in the train
dataset is the same as the train_id</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>the testing datasets</p>
</td></tr>
</table>


<h3>References</h3>


<p>Li, J., Chen, Z., Wang, Z., &amp; Chang, Y. I. (2020). Active learning in
multiple-class classification problems via individualized binary models.
<em>Computational Statistics &amp; Data Analysis</em>, 145, 106911.
doi:10.1016/j.csda.2020.106911

</p>


<h3>See Also</h3>


<p><code><a href="#topic+gen_bin_data">gen_bin_data</a></code> for binary classification case
</p>
<p><code><a href="#topic+gen_GEE_data">gen_GEE_data</a></code> for generalized estimating equations case.
</p>



<h3>Examples</h3>

<pre><code class='language-R'># For an example, see example(seq_ord_model)
</code></pre>

<hr>
<h2 id='genBin'>Generate the correlated binary response data for discrete case</h2><span id='topic+genBin'></span>

<h3>Description</h3>

<p><code>genBin</code> generate the data used for discrete case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genBin(corstr, mu = NULL, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genBin_+3A_corstr">corstr</code></td>
<td>
<p>A character string specifying the correlation structure for the
clusters. Allowed structures are: &quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="genBin_+3A_mu">mu</code></td>
<td>
<p>A numeric parameter denotes the value of the link function</p>
</td></tr>
<tr><td><code id="genBin_+3A_size">size</code></td>
<td>
<p>A numeric number indicating the size of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>genBin returns the correlated binary response according to the value of the
corstr argument.
</p>


<h3>Value</h3>

<p>a function to get the correlated binary response data
</p>

<hr>
<h2 id='genCorMat'>Generate the correlation matrix for the clusteded data</h2><span id='topic+genCorMat'></span>

<h3>Description</h3>

<p><code>genCorMat</code> generate the data with specified correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genCorMat(corstr, rho, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genCorMat_+3A_corstr">corstr</code></td>
<td>
<p>A character string specifying the correlation structure for the
clusters. Allowed structures are: &quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_rho">rho</code></td>
<td>
<p>A numeric parameter in correlation structure for the
autocorrelation coefficient.</p>
</td></tr>
<tr><td><code id="genCorMat_+3A_size">size</code></td>
<td>
<p>A numeric number indicating the size of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>genCorMat returns the corresponding correlation matrix according to the value
of the corstr argument.
</p>


<h3>Value</h3>

<p>a matrix which represents the diffetent correlation matrix.
</p>

<hr>
<h2 id='getMH'>Get the matrices M and H for the clustered data for the GEE case</h2><span id='topic+getMH'></span>

<h3>Description</h3>

<p>Get the matrices M and H to approximate the true covariance
matrix of the GEE case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMH(y, X, id, beta, rho, linkv, corstrv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMH_+3A_y">y</code></td>
<td>
<p>A matrix containing current response variable</p>
</td></tr>
<tr><td><code id="getMH_+3A_x">X</code></td>
<td>
<p>A data frame containing the covariate for the current samples</p>
</td></tr>
<tr><td><code id="getMH_+3A_id">id</code></td>
<td>
<p>The id for each subject in the X</p>
</td></tr>
<tr><td><code id="getMH_+3A_beta">beta</code></td>
<td>
<p>The paramters that we estimate when we use the current samples</p>
</td></tr>
<tr><td><code id="getMH_+3A_rho">rho</code></td>
<td>
<p>A numeric number indicating the estimate of correlation
coefficient</p>
</td></tr>
<tr><td><code id="getMH_+3A_linkv">linkv</code></td>
<td>
<p>A specification for the model link function.</p>
</td></tr>
<tr><td><code id="getMH_+3A_corstrv">corstrv</code></td>
<td>
<p>A character string specifying the correlation structure. The
following are permitted: &quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getMH uses the current samples to obtain the covariance matrix.
</p>


<h3>Value</h3>

<p>a list contains several components
</p>
<table>
<tr><td><code>sandwich</code></td>
<td>
<p>the sandwich information matrix for covariance</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the matrix for calculating the sandwich information matrix for covariance</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the matrix for calculating the sandwich information matrix for covariance</p>
</td></tr>
</table>

<hr>
<h2 id='getWH'>Get the matrices W and H for the categorical case</h2><span id='topic+getWH'></span>

<h3>Description</h3>

<p>Get the matrices W and H using the Rcpp package for the
categorical case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWH(data, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWH_+3A_data">data</code></td>
<td>
<p>A matrix containing the training samples which we will use in
the categorical case.</p>
</td></tr>
<tr><td><code id="getWH_+3A_beta">beta</code></td>
<td>
<p>A matrix contains the estimated coefficient. Note that the
beta_mat is a n * k matrix which n is the number of the explanatory
variables and k+1 is the number of categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getWH uses the current training data and the estimated coefficient under the
categorical case to obtain the matrices W and H to further get the
variance-covariance matrix and minimum eigenvalue. The variance-covariance
matrix and minimum eigenvalue will be used in the process of selecting the
new sampling and determining whether to stop the iteration. Note that using
the Rcpp package can significantly reduce the time of operation and get
conclusions faster.
</p>


<h3>Value</h3>

<p>a list contains several components including the variance-covariance
matrix, minimum eigenvalue, W and H.
</p>

<hr>
<h2 id='getWH_ord'>Get the matrices W and H for the ordinal case</h2><span id='topic+getWH_ord'></span>

<h3>Description</h3>

<p>Get the matrices W and H using the Rcpp package for the ordinal case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWH_ord(data, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getWH_ord_+3A_data">data</code></td>
<td>
<p>A matrix containing the training samples which we will use in
the ordinal case.</p>
</td></tr>
<tr><td><code id="getWH_ord_+3A_beta">beta</code></td>
<td>
<p>A matrix contains the estimated coefficient. Note that the
beta_mat is a n * k matrix which n is the number of the explanatory
variables and k+1 is the number of categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>getWH_ord uses the current training data and the estimated coefficient under
the ordinal case to obtain the matrices W and H to further get the
variance-covariance matrix and minimum eigenvalue. Note that using the Rcpp
package can significantly reduce the time of operation and get conclusions
faster.
</p>


<h3>Value</h3>

<p>a list contains several components including the variance-covariance
matrix, minimum eigenvalue, W and H.
</p>

<hr>
<h2 id='init_multi_data'>Generate the labeled and unlabeled datasets</h2><span id='topic+init_multi_data'></span>

<h3>Description</h3>

<p><code>init_multi_data</code> creates the labeled and unlabeled datasets for the
categorical and ordinal case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_multi_data(train_id, train, init_N, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_multi_data_+3A_train_id">train_id</code></td>
<td>
<p>A numeric vector denotes the id of the all training samples.
Each sample corresponds to a unique identification from 1 to the length of
all the samples.</p>
</td></tr>
<tr><td><code id="init_multi_data_+3A_train">train</code></td>
<td>
<p>A numeric matrix denote the training datasets. The length of the
train's row is the number of the training samples and the first column
represents the labels and the rest columns are the explanatory variables.
Note that the id of the sample in the train dataset is the same as the
train_id.</p>
</td></tr>
<tr><td><code id="init_multi_data_+3A_init_n">init_N</code></td>
<td>
<p>A numeric value that determine the number of the initial
labeled samples. Note that it shouldn't be too large or too small.</p>
</td></tr>
<tr><td><code id="init_multi_data_+3A_type">type</code></td>
<td>
<p>A character string that determines which type of data will be
generated, matching one of 'ord' or 'cat'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>init_multi_data generates the initial labeled dataset and the unlabeled
datasets which we will select a most informative sample from the unlabeled
datasets into the labeled dataset. The number of samples in the initial
labeled datasets is specified the init_N argument. The value of 'type' should
be'ord' or 'cat'. If it equals to 'ord', the element of the splitted will be
composed of samples from Classes K and Classes K+1. Otherwise, the element of
the splitted will be composed of samples from  Classes 0 and Classes K.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>splitted</code></td>
<td>
<p>a list containing the datasets which we will use</p>
</td></tr>
<tr><td><code>train</code></td>
<td>
<p>the initial labeled datasets. The number of the datasets is
specified by the init_N</p>
</td></tr>
<tr><td><code>newY</code></td>
<td>
<p>the value of the labels from 0 to K which denotes the number of
categories</p>
</td></tr>
<tr><td><code>labeled_ids</code></td>
<td>
<p>the unique id of the initial labeled dataset </p>
</td></tr>
<tr><td><code>unlabeled_ids</code></td>
<td>
<p>the unique id of the unlabeled
dataset</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the all training samples which is composed of the samples
corresponding to labeled_ids and samples corresponding to unlabeled_ids</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## For an example, see example(seq_ord_model)
</code></pre>

<hr>
<h2 id='is_stop_ASE'>Determining whether to stop choosing sample</h2><span id='topic+is_stop_ASE'></span>

<h3>Description</h3>

<p><code>is_stop_ASE</code> determines whether to stop choosing sample based on the
current estimator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stop_ASE(sandwich, d, nonZeroIdx, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_stop_ASE_+3A_sandwich">sandwich</code></td>
<td>
<p>A numeric matrix that represent the sandwich information
matrix for covariance</p>
</td></tr>
<tr><td><code id="is_stop_ASE_+3A_d">d</code></td>
<td>
<p>A numeric number specifying the length of the fixed size confidence
set that we specify</p>
</td></tr>
<tr><td><code id="is_stop_ASE_+3A_nonzeroidx">nonZeroIdx</code></td>
<td>
<p>A numeric number specifying the index of the non zero
coefficient</p>
</td></tr>
<tr><td><code id="is_stop_ASE_+3A_verbose">verbose</code></td>
<td>
<p>A A logical value to determine whether to get the full
information about the iteration
situation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>is_stop_ASE determines if the iteration stop condition is met based on the
current estimator
</p>


<h3>Value</h3>

<p>a list of these elements:
</p>
<table>
<tr><td><code>stop</code></td>
<td>
<p>a logical value. If TRUE, it means we have choosen enough
samples.</p>
</td></tr>
<tr><td><code>eigen</code></td>
<td>
<p>the maximum eighevalue covariance matrix</p>
</td></tr>
</table>

<hr>
<h2 id='logit_model'>the individualized binary logistic regression for categorical response
data.</h2><span id='topic+logit_model'></span>

<h3>Description</h3>

<p><code>logit_model</code> fit the categorical data by the individualized binary
logistic regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit_model(splitted, newY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_model_+3A_splitted">splitted</code></td>
<td>
<p>A list containing the datasets which we will use in the
categorical case. Note that the element of the splitted is the collections
of samples from Classes 0 and Classes k.</p>
</td></tr>
<tr><td><code id="logit_model_+3A_newy">newY</code></td>
<td>
<p>A numeric number denotes the value of the labels from 0 to K
which is the number of categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>logit_model fits the splitted data by using the the individualized binary
logistic regression according to the value of newY. Because we use use Class
0 as the baseline for modeling the probability ratio of Class k to Class 0 by
fitting K individual logistic models, if newY equal to 0, it means we need
fit all elements of the splitted data. Otherwise, we only fit the samples
from class 0 and class newY.
</p>


<h3>Value</h3>

<table>
<tr><td><code>beta_mat</code></td>
<td>
<p>a matrix contains the estimated coefficient. Note that the
beta_mat is a n * p matrix which n is the number of the explanatory variables
and p+1 is the number of categories</p>
</td></tr>
</table>


<h3>References</h3>


<p>Li, J., Chen, Z., Wang, Z., &amp; Chang, Y. I. (2020). Active learning in
multiple-class classification problems via individualized binary models.
<em>Computational Statistics &amp; Data Analysis</em>, 145, 106911.
doi:10.1016/j.csda.2020.106911

</p>


<h3>See Also</h3>


<p><code><a href="#topic+logit_model_ord">logit_model_ord</a></code> for ordinal case.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## For an example, see example(seq_cat_model)
</code></pre>

<hr>
<h2 id='logit_model_ord'>the individualized binary logistic regression for ordinal response
data.</h2><span id='topic+logit_model_ord'></span>

<h3>Description</h3>

<p><code>logit_model_ord</code> fit the ordinal data by the individualized binary
logistic regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit_model_ord(splitted, newY, beta_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_model_ord_+3A_splitted">splitted</code></td>
<td>
<p>A list containing the datasets which we will use in the
categorical case. Note that the element of the splitted is the collections
of samples from Classes 0 and Classes k.</p>
</td></tr>
<tr><td><code id="logit_model_ord_+3A_newy">newY</code></td>
<td>
<p>a numeric number denotes the value of the labels from 0 to K
which is the number of categories</p>
</td></tr>
<tr><td><code id="logit_model_ord_+3A_beta_mat">beta_mat</code></td>
<td>
<p>the initial estimate for the coefficient. Note that the
values may be not accurate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>logit_model_ord fits the splitted data by using the the individualized binary
logistic regression according to the value of newY. Under the ordinal case,
we don't use the all training samples. Instead, we use two consecutive
subgroups, such as Classes k - 1 and k , at a time for each individual model.
Hence, we need fit the model acrroding to the value of newY. param splitted a
list containing the datasets which we will use in the cordinl case. Note that
the element of the splitted is the collections of samples from Classes 0k -
1and Classes k.
</p>


<h3>Value</h3>

<table>
<tr><td><code>beta_mat</code></td>
<td>
<p>a matrix contains the estimated coefficient. Note that the
beta_mat is a n * p matrix which n is the number of the explanatory variables
and p+1 is the number of categories</p>
</td></tr>
</table>


<h3>References</h3>


<p>Li, J., Chen, Z., Wang, Z., &amp; Chang, Y. I. (2020). Active learning in
multiple-class classification problems via individualized binary models.
<em>Computational Statistics &amp; Data Analysis</em>, 145, 106911.
doi:10.1016/j.csda.2020.106911

</p>


<h3>See Also</h3>


<p><code><a href="#topic+logit_model">logit_model</a></code> for categorical case.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## For an example, see example(seq_ord_model)
</code></pre>

<hr>
<h2 id='print.seqbin'>Print the results by the binary logistic regression model</h2><span id='topic+print.seqbin'></span>

<h3>Description</h3>

<p><code>print.seqbin</code> print the result of the binary logistic regression model
used by the method of adaptive shrinkage estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqbin'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.seqbin_+3A_x">x</code></td>
<td>
<p>A variable of type <code>seqbin</code></p>
</td></tr>
<tr><td><code id="print.seqbin_+3A_...">...</code></td>
<td>
<p>Additional variables to be transferred to functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to present results in a concise way. If we select
enough samples that satisfy the stopping criterion, then we show several
messages to report the conclusion including the length of fixed size
confidence set, the number of samples we choose, the value of coefficient and
the time have elapsed. Otherwise, the sample selection process is failed. We
need to reduce the length of fixed size confidence set because the smaller
the dlen, the larger the sample size we need.
</p>


<h3>Value</h3>

<p>print.seqbin returns several messages to show the conclusion.
</p>

<hr>
<h2 id='print.seqGEE'>Print the results by the generalized estimating equations.</h2><span id='topic+print.seqGEE'></span>

<h3>Description</h3>

<p><code>print.seqGEE</code> print the result of the logistic regression model used by
the method of adaptive shrinkage estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqGEE'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.seqGEE_+3A_x">x</code></td>
<td>
<p>A variable of type <code>seqGEE</code></p>
</td></tr>
<tr><td><code id="print.seqGEE_+3A_...">...</code></td>
<td>
<p>Additional variables to be transferred to functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to present results in a concise way. If we select
enough samples that satisfy the stopping criterion, then we show several
messages to report the conclusion including the length of fixed size
confidence set, the number of samples we choose, the value of coefficient and
the index of the non zero coefficient
</p>


<h3>Value</h3>

<p>print.seqGEE returns several messages to show the conclusion.
</p>

<hr>
<h2 id='print.seqmulti'>Print the results by the multi-logistic regression model</h2><span id='topic+print.seqmulti'></span>

<h3>Description</h3>

<p><code>print.seqmulti</code> print the result of the multi-logistic regression model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'seqmulti'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.seqmulti_+3A_x">x</code></td>
<td>
<p>A variable of type <code>seqmulti</code></p>
</td></tr>
<tr><td><code id="print.seqmulti_+3A_...">...</code></td>
<td>
<p>Additional variables to be transferred to functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to present results in a concise way. If we select
enough samples that satisfy the stopping criterion, then we show several
messages to report the conclusion including the length of fixed size
confidence set, the number of samples we choose and the value of coefficient.
</p>


<h3>Value</h3>

<p>print.seqmulti returns several messages to show the conclusion.
</p>

<hr>
<h2 id='QIC'>Calculate quasi-likelihood under the independence model criterion
(QIC) for Generalized Estimating Equations.</h2><span id='topic+QIC'></span>

<h3>Description</h3>

<p>Select the optimal model according to the QIC criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QIC(y, X, id, beta, nonZeroSet, rho, linkv, corstrv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QIC_+3A_y">y</code></td>
<td>
<p>A matrix containing current response variable</p>
</td></tr>
<tr><td><code id="QIC_+3A_x">X</code></td>
<td>
<p>A data frame containing the covariate for the current samples</p>
</td></tr>
<tr><td><code id="QIC_+3A_id">id</code></td>
<td>
<p>The id for each subject in the X</p>
</td></tr>
<tr><td><code id="QIC_+3A_beta">beta</code></td>
<td>
<p>The paramters that we estimate when we use the current samples</p>
</td></tr>
<tr><td><code id="QIC_+3A_nonzeroset">nonZeroSet</code></td>
<td>
<p>The set of the index of the non zero coefficient</p>
</td></tr>
<tr><td><code id="QIC_+3A_rho">rho</code></td>
<td>
<p>A numeric number indicating the estimate of correlation coefficient</p>
</td></tr>
<tr><td><code id="QIC_+3A_linkv">linkv</code></td>
<td>
<p>A specification for the model link function.</p>
</td></tr>
<tr><td><code id="QIC_+3A_corstrv">corstrv</code></td>
<td>
<p>A character string specifying the correlation structure. The
following are permitted: &quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>QIC calculates the value of the quasi-likelihood under the independence
model criterion for Generalized Estimating Equations. The QIC criterion is
actually a generalization of the AIC criterion in the statistical inference
of parameters in the longitudinal data analysis framework.
</p>


<h3>Value</h3>

<p>a value indicating how well the model fits
</p>

<hr>
<h2 id='seq_bin_model'>The sequential logistic regression model for binary classification
problem.</h2><span id='topic+seq_bin_model'></span>

<h3>Description</h3>

<p><code>seq_bin_model</code> estimates the the effective variables and chooses the
subjects sequentially by the logistic regression model for the binary
classification case with adaptive shrinkage estimate method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_bin_model(startnum, data.clust, xfix, yfix, d = 0.5,
  criterion = "BIC", pho = 0.05, ptarget = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_bin_model_+3A_startnum">startnum</code></td>
<td>
<p>The initial number of subjects from original dataset.</p>
</td></tr>
<tr><td><code id="seq_bin_model_+3A_data.clust">data.clust</code></td>
<td>
<p>Large list obtained through k-means clustering. The samples
of the element(data.clust[[1]]) in the data.clust is closer to each other
compared to another element.</p>
</td></tr>
<tr><td><code id="seq_bin_model_+3A_xfix">xfix</code></td>
<td>
<p>A dataframe that each row is a sample,each column represents an
independent variable. The sample has the minimum variance from each cluster
of the data.clust to represent the all samples for the corresponding
cluster.</p>
</td></tr>
<tr><td><code id="seq_bin_model_+3A_yfix">yfix</code></td>
<td>
<p>Numeric vector consists of 0 or 1. The length of yfix must be the
same as the xfix.</p>
</td></tr>
<tr><td><code id="seq_bin_model_+3A_d">d</code></td>
<td>
<p>A numeric number specifying the length of the fixed size
confidence set for our model. Note that the smaller the d, the larger
the sample size and the longer the time costs. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="seq_bin_model_+3A_criterion">criterion</code></td>
<td>
<p>A character string that determines the model selection
criterion to be used, matching one of 'BIC' or 'AIC. The default value is
'BIC'.</p>
</td></tr>
<tr><td><code id="seq_bin_model_+3A_pho">pho</code></td>
<td>
<p>A numeric number used in subject selection according to the
D-optimality. That is, select the  first (rho * length(data)) data from the
unlabeled data set and add it to the uncertainty set. The default value is
0.05.</p>
</td></tr>
<tr><td><code id="seq_bin_model_+3A_ptarget">ptarget</code></td>
<td>
<p>A numeric number that help to choose the samples. The default
value is 0.5</p>
</td></tr>
</table>


<h3>Details</h3>

<p>seq_bin_model is a binary logistic regression model that estimetes the
effective variables and determines the samples sequentially from original
training data set using adaptive shrinkage estimate given the fixed size
confidence set. It's a sequential method that we select sample one by one
from data pool. Once it stops, it means we select the enough samples that
satisfy the stopping criterion and we can conclude which are the effective
variables and its corresponding values and the number of the samples we
select.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>the length of the fixed size confidence set that we specify</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the current sample size when the stopping criterion is satisfied</p>
</td></tr>
<tr><td><code>is_stopped</code></td>
<td>
<p>the label of sequential iterations stop or not. When the value
of is_stopped is 1, it means the iteration stops</p>
</td></tr>
<tr><td><code>beta_est</code></td>
<td>
<p>the parameters that we estimate when the the iteration is
finished</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the covariance matrix between the estimated parameters</p>
</td></tr>
</table>


<h3>References</h3>


<p>Wang Z, Kwon Y, Chang YcI (2019). Active learning for binary classification
with variable selection.  arXiv preprint arXiv:1901.10079.

</p>


<h3>See Also</h3>


<p><code><a href="#topic+seq_GEE_model">seq_GEE_model</a></code> for generalized estimating equations case
</p>
<p><code><a href="#topic+seq_bin_model">seq_bin_model</a></code> for binary classification case
</p>
<p><code><a href="#topic+seq_ord_model">seq_ord_model</a></code> for ordinal case.

</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate the toy example. You should remove '#' to
# run the following command.
# library(doMC)
# registerDoMC(9)
# library(foreach)
beta &lt;- c(-1,1,0,0)
N &lt;- 10000
nclass &lt;- 1000
seed &lt;- 123
data  &lt;- gen_bin_data(beta,N,nclass,seed)
xfix &lt;- data[['X']]
yfix &lt;- data[['y']]
data.clust &lt;- data[['data.clust']]
startnum &lt;- 24
d &lt;- 0.75

# use seq_bin_model to binary classification problem. You can remove '#' to
# run the command.
# results &lt;- seq_bin_model(startnum, data.clust, xfix, yfix, d,
#                          criterion = "BIC", pho = 0.05, ptarget = 0.5)
</code></pre>

<hr>
<h2 id='seq_cat_model'>The sequential logistic regression model for multi-classification
problem under the categorical case.</h2><span id='topic+seq_cat_model'></span>

<h3>Description</h3>

<p><code>seq_cat_model</code> chooses the subjects sequentially by the logistic
regression model for the categorical case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_cat_model(labeled_ids, unlabeled_ids, splitted, newY, train, data,
  d = 0.8, adaptive = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_cat_model_+3A_labeled_ids">labeled_ids</code></td>
<td>
<p>A numeric vector for the unique identification of the
labeled dataset.</p>
</td></tr>
<tr><td><code id="seq_cat_model_+3A_unlabeled_ids">unlabeled_ids</code></td>
<td>
<p>A numeric vector for the unique identification of the
unlabeled dataset.</p>
</td></tr>
<tr><td><code id="seq_cat_model_+3A_splitted">splitted</code></td>
<td>
<p>A list containing the datasets which we will use in the
categorical case. Note that the element of the splitted is the collections
of samples from Classes 0 and Classes k.</p>
</td></tr>
<tr><td><code id="seq_cat_model_+3A_newy">newY</code></td>
<td>
<p>A numeric number denotes the value of the labels from 0 to K
which is the number of categories.</p>
</td></tr>
<tr><td><code id="seq_cat_model_+3A_train">train</code></td>
<td>
<p>A matrix for the labeled samples. Note that the indices of the
samples in the train dataset is the same as the labeled_ids.</p>
</td></tr>
<tr><td><code id="seq_cat_model_+3A_data">data</code></td>
<td>
<p>A matrix denotes all the data including the labeled samples and
the unlabeled samples. Note that the first column of the dataset is the
response variable, that's the labels and the rest is the explanatory
variables.</p>
</td></tr>
<tr><td><code id="seq_cat_model_+3A_d">d</code></td>
<td>
<p>A numeric number specifying the length of the fixed size confidence
set for our model. The default value is 0.8.</p>
</td></tr>
<tr><td><code id="seq_cat_model_+3A_adaptive">adaptive</code></td>
<td>
<p>A character string that determines the sample selection
criterion to be used, matching one of 'random' or 'A_optimal The default
value is 'random'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>seq_cat_model is a multinomial logistic regression model that estimate the
coefficient of the explanatory variables and determines the samples
sequentially from original training data set given the fixed size confidence
set under the categorical case. Note that there are two methods to select the
samples. One sampling method is random sampling while another is the
A-optimality criterion which seeks to minimize the trace of the inverse of
the information matrix. In addition, we will use the special model: the
individualized binary logistic regression. We will use the specific model to
only fit two subgroups of the all dataset and get the estimated coefficient
and decide whether to stop sampling. If it shows that we need to continue, we
will use one of the samepling method above to pick the sample. Note that if
the method is A-optimality, we will pick the most informative subjects.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>the length of the fixed size confidence set that we specify</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the current sample size when the stopping criterion is satisfied</p>
</td></tr>
<tr><td><code>is_stopped</code></td>
<td>
<p>the label of sequential iterations stop or not. When the
value of is_stopped is TRUE, it means the iteration stops</p>
</td></tr>
<tr><td><code>beta_est</code></td>
<td>
<p>the estimated coeffificent when the criterion is safisfied</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the covariance matrix between the estimated parameters</p>
</td></tr>
<tr><td><code>adaptive</code></td>
<td>
<p>the sample selection criterion we used </p>
</td></tr>
</table>


<h3>References</h3>


<p>Li, J., Chen, Z., Wang, Z., &amp; Chang, Y. I. (2020). Active learning in
multiple-class classification problems via individualized binary models.
<em>Computational Statistics &amp; Data Analysis</em>, 145, 106911.
doi:10.1016/j.csda.2020.106911

</p>


<h3>See Also</h3>


<p><code><a href="#topic+seq_GEE_model">seq_GEE_model</a></code> for generalized estimating equations case
</p>
<p><code><a href="#topic+seq_bin_model">seq_bin_model</a></code> for binary classification case
</p>
<p><code><a href="#topic+seq_ord_model">seq_ord_model</a></code> for ordinal case.
</p>



<h3>Examples</h3>

<pre><code class='language-R'># generate the toy example
beta &lt;- matrix(c(1,2,1,-1,1,2), ncol=2)
res &lt;-  gen_multi_data(beta, N = 10000, type = 'cat', test_ratio = 0.3)
train_id &lt;- res$train_id
train &lt;- res$train
test &lt;- res$test
res &lt;- init_multi_data(train_id, train, init_N = 300, type = 'cat')
splitted &lt;- res$splitted
train &lt;- res$train
newY &lt;- res$newY
labeled_ids &lt;- res$labeled_ids
unlabeled_ids &lt;- res$unlabeled_ids
data &lt;- res$data

# use seq_cat_model to multi-classification problem under the categorical case.
# You can remove '#' to run the command.
# start_time &lt;- Sys.time()
# logitA_cat &lt;- seq_cat_model(labeled_ids, unlabeled_ids, splitted, newY,
#                             train, data, d = 0.5, adaptive = "A_optimal")
# logitA_cat$time &lt;- as.numeric(Sys.time() - start_time, units = "mins")
# print(logitA_cat)
</code></pre>

<hr>
<h2 id='seq_GEE_model'>The The sequential method for generalized estimating equations case.</h2><span id='topic+seq_GEE_model'></span>

<h3>Description</h3>

<p><code>seq_GEE_model</code> estimates the the effective variables and chooses the
subjects sequentially by the generalized estimating equations with adaptive
shrinkage estimate method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_GEE_model(formula, data = list(), clusterID, data_pool = list(),
  clusterID_pool, strategy, d = 0.4, family = stats::gaussian(link =
  "identity"), corstr = "independence", contrasts = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_GEE_model_+3A_formula">formula</code></td>
<td>
<p>An object of class &quot;formula&quot; (or one that can be coerced to
that class): a symbolic description of the model to be fitted.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_data">data</code></td>
<td>
<p>A data frame containing the initial random samples to obtain the
initial estimate of the coefficient. Note that the first column of the data
frame is the response variable, and the rest is the explanatory variables.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_clusterid">clusterID</code></td>
<td>
<p>The id for each subject in the initial samples. Note that
the subjects in the same cluster will have identical id.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_data_pool">data_pool</code></td>
<td>
<p>A data frame containing all the random samples which we will
choose subject from. The first column of the data frame is the response
variable, and the rest is the explanatory variables.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_clusterid_pool">clusterID_pool</code></td>
<td>
<p>The id for each subject in the data_pool. Note that the
subjects in the same cluster will have identical id.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_strategy">strategy</code></td>
<td>
<p>A character string that determines the sample selection
criterion to be used, matching one of 'random' or 'D_optimal. The default
value is 'D_optimal'.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_d">d</code></td>
<td>
<p>A numeric number specifying the length of the fixed size confidence set for our model.
The default value is 0.4.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_family">family</code></td>
<td>
<p>A description of the error distribution and link function to be
used in the model. See family for details of <code><a href="stats.html#topic+family">family</a></code>
functions. Matching one of 'gaussian' or 'binomial'</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_corstr">corstr</code></td>
<td>
<p>A character string specifying the correlation structure. The
following are permitted: &quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. See the contrasts.arg of
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="seq_GEE_model_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>seq_GEE_model fits the clustered data sequentially by generalized estimating
equations with adaptive shrinkage estimate. It can detect the effective
variables which have the impact on the response and choose the most
representative sample point at the same time. Specifically, we fit a initial
sample data and determine if the stop condition is reached. If not, we will
select the most informative subjects by some criterion. Iteration stops once
it meets our requirements.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>the length of the fixed size confidence set that we specify</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the current sample size when the stopping criterion is satisfied</p>
</td></tr>
<tr><td><code>is_stopped</code></td>
<td>
<p>the label of sequential iterations stop or not. When the
value of is_stopped is TRUE, it means the iteration stops</p>
</td></tr>
<tr><td><code>beta_est</code></td>
<td>
<p>the parameters that we estimate when the the iteration is
finished</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the covariance matrix between the estimated parameters</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>estimate of correlation coefficient</p>
</td></tr>
<tr><td><code>nonZeroIdx</code></td>
<td>
<p>the index of the non zero coefficient</p>
</td></tr>
<tr><td><code>corstr</code></td>
<td>
<p>the correlation structure. The following are permitted:
&quot;independence&quot;, &quot;exchangeable&quot; and &quot;ar1&quot;</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model</p>
</td></tr>
</table>


<h3>References</h3>


<p>Chen, Z., Wang, Z., &amp; Chang, Y. I. (2019). Sequential adaptive variables and
subject selection for GEE methods. <em>Biometrics</em>. doi:10.1111/biom.13160

</p>


<h3>See Also</h3>


<p><code><a href="#topic+seq_cat_model">seq_cat_model</a></code> for categorical case
</p>
<p><code><a href="#topic+seq_bin_model">seq_bin_model</a></code> for binary classification case
</p>
<p><code><a href="#topic+seq_ord_model">seq_ord_model</a></code> for ordinal case.
</p>



<h3>Examples</h3>

<pre><code class='language-R'># generate the toy example
data &lt;- gen_GEE_data(numClusters = 75, clusterSize = 5,
                    clusterCorstr = 'ar1', clusterRho = 0.3,
                    beta = c(1, -1.1, 1.5, -2, rep(0, 50)), family = gaussian(),
                    intercept = TRUE, xCorstr = 'ar1',
                    xCorRho = 0.5, xVariance = 0.2)
df &lt;- data.frame(y = data$y, data$x)
clusterID &lt;- data$clusterID
pool &lt;- gen_GEE_data(numClusters = 8000, clusterSize = 5,
                     clusterCorstr = 'ar1', clusterRho = 0.3,
                     beta = c(1, -1.1, 1.5, -2, rep(0, 50)), family = gaussian(),
                     intercept = TRUE, xCorstr = 'ar1',
                     xCorRho = 0.5, xVariance = 0.2)
df_pool &lt;- data.frame(y = pool$y, pool$x)
clusterID_pool &lt;- pool$clusterID
d&lt;- 0.25

# use seq_GEE_model to generalized estimating equations case.
# You can remove #' to run the command.
# seqRes.ASED &lt;- seq_GEE_model(y ~ .-1, data = df, clusterID = clusterID,
#                             data_pool = df_pool,  clusterID_pool = clusterID_pool,
#                             strategy = "D-optimal",  d = d, family = gaussian(), corstr = 'ar1')
</code></pre>

<hr>
<h2 id='seq_ord_model'>The sequential logistic regression model for multi-classification
problem under the ordinal case.</h2><span id='topic+seq_ord_model'></span>

<h3>Description</h3>

<p><code>seq_ord_model</code> chooses the subjects sequentially by the
logistic regression model for ordinal case
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_ord_model(labeled_ids, unlabeled_ids, splitted, newY, train, data,
  d = 0.8, adaptive = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_ord_model_+3A_labeled_ids">labeled_ids</code></td>
<td>
<p>A numeric vector for the unique identification of the
labeled dataset</p>
</td></tr>
<tr><td><code id="seq_ord_model_+3A_unlabeled_ids">unlabeled_ids</code></td>
<td>
<p>A numeric vector for the unique identification of the
unlabeled dataset</p>
</td></tr>
<tr><td><code id="seq_ord_model_+3A_splitted">splitted</code></td>
<td>
<p>A list containing the datasets which we will use in the
cordinl case. Note that the element of the data_split is the samples from
Classes k-1and Classes k</p>
</td></tr>
<tr><td><code id="seq_ord_model_+3A_newy">newY</code></td>
<td>
<p>A numeric number denotes the value of the labels from 0 to K
which is the number of categories</p>
</td></tr>
<tr><td><code id="seq_ord_model_+3A_train">train</code></td>
<td>
<p>A matrix for the labeled samples. Note that the indices of the
samples in the train dataset is the same as the labeled_ids</p>
</td></tr>
<tr><td><code id="seq_ord_model_+3A_data">data</code></td>
<td>
<p>A matrix denotes all the data including the labeled samples and
the unlabeled samples. Note that the first column of the dataset is the
response variable, that's the labels and the rest is the explanatory
variables.</p>
</td></tr>
<tr><td><code id="seq_ord_model_+3A_d">d</code></td>
<td>
<p>A numeric number specifying the length of the fixed size confidence
set for our model. The default value is 0.8.</p>
</td></tr>
<tr><td><code id="seq_ord_model_+3A_adaptive">adaptive</code></td>
<td>
<p>A character string that determines the sample selection
criterion to be used, matching one of 'random' or 'A_optimal'. The default
value is 'random'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+seq_ord_model">seq_ord_model</a></code> function and
<code><a href="#topic+seq_cat_model">seq_cat_model</a></code> function are very similar. seq_ord_model is
also a multinomial logistic regression model but under the ordinal case
that estimate the coefficient variables and determines the samples given
the fixed size confidence set. seq_ord_model selects the sample in the same
way as seq_cat_model: both are two methods. The details about the selecting
methoed in seq_ord_model please refer to the <code><a href="#topic+seq_cat_model">seq_cat_model</a></code>
function.
</p>


<h3>Value</h3>

<p>a list containing the following components
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>the length of the fixed size confidence set that we specify</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the current sample size when the stopping criterion is satisfied</p>
</td></tr>
<tr><td><code>is_stopped</code></td>
<td>
<p>the label of sequential iterations stop or not. When the
value of is_stopped is TRUE, it means the iteration stops</p>
</td></tr>
<tr><td><code>beta_est</code></td>
<td>
<p>the estimated coeffificent when the criterion is safisfied</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>the covariance matrix between the estimated parameters</p>
</td></tr>
<tr><td><code>adaptive</code></td>
<td>
<p>the sample selection criterion we used </p>
</td></tr>
</table>


<h3>References</h3>


<p>Li, J., Chen, Z., Wang, Z., &amp; Chang, Y. I. (2020). Active learning in
multiple-class classification problems via individualized binary models.
<em>Computational Statistics &amp; Data Analysis</em>, 145, 106911.
doi:10.1016/j.csda.2020.106911

</p>


<h3>See Also</h3>


<p><code><a href="#topic+seq_cat_model">seq_cat_model</a></code> for categorical case
</p>
<p><code><a href="#topic+seq_bin_model">seq_bin_model</a></code> for binary classification case
</p>
<p><code><a href="#topic+seq_GEE_model">seq_GEE_model</a></code> for generalized estimating equations case.
</p>



<h3>Examples</h3>

<pre><code class='language-R'># generate the toy example
beta &lt;- matrix(c(1,2,1,-1,1,2), ncol=2)
res &lt;-  gen_multi_data(beta, N = 10000, type = 'ord', test_ratio = 0.3)
train_id &lt;- res$train_id
train &lt;- res$train
test &lt;- res$test
res &lt;- init_multi_data(train_id, train, init_N = 300, type = 'ord')
splitted &lt;- res$splitted
train &lt;- res$train
newY &lt;- res$newY
labeled_ids &lt;- res$labeled_ids
unlabeled_ids &lt;- res$unlabeled_ids
data &lt;- res$data

# use seq_ord_model to multi-classification problem under the ordinal case.
# You can remove '#' to run the command.
# start_time &lt;- Sys.time()
# logitA_ord &lt;- seq_ord_model(labeled_ids, unlabeled_ids, splitted, newY,
#                             train, data, d = 0.5, adaptive = "A_optimal")
# logitA_ord$time &lt;- as.numeric(Sys.time() - start_time, units = "mins")
# print(logitA_ord)
</code></pre>

<hr>
<h2 id='update_data_cat'>Add the new sample into labeled dataset from unlabeled dataset for the
categorical case</h2><span id='topic+update_data_cat'></span>

<h3>Description</h3>

<p><code>update_data_cat</code> selects the sample to the labeled dataset according to
it's index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_data_cat(ind, splitted, data, train, labeled_ids, unlabeled_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_data_cat_+3A_ind">ind</code></td>
<td>
<p>A numeric value denotes the index of selected sample.</p>
</td></tr>
<tr><td><code id="update_data_cat_+3A_splitted">splitted</code></td>
<td>
<p>A list containing the datasets which we will use in the
categorical case. Note that the element of the splitted is the collections
of samples from Classes 0 and Classes k.</p>
</td></tr>
<tr><td><code id="update_data_cat_+3A_data">data</code></td>
<td>
<p>A matrix  denotes all the data including the labeled samples and
the unlabeled samples. Note that the first column of the dataset is the
response variable, that's the labels and the rest is the explanatory
variables.</p>
</td></tr>
<tr><td><code id="update_data_cat_+3A_train">train</code></td>
<td>
<p>A matrix for the labeled samples.</p>
</td></tr>
<tr><td><code id="update_data_cat_+3A_labeled_ids">labeled_ids</code></td>
<td>
<p>A numeric vector for the unique identification of the
labeled dataset</p>
</td></tr>
<tr><td><code id="update_data_cat_+3A_unlabeled_ids">unlabeled_ids</code></td>
<td>
<p>A numeric vector for the unique identification of the
unlabeled dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>update_data_cat chooses the sample based on the index from all the training
dataset if the data has no ordinal relation.  Specifically, we remove the
index of the choosed sample from the unlabeled dataset and add the index to
the labeled dataset. Then, combine the selected sample with the existing
training data set.
</p>


<h3>Value</h3>

<table>
<tr><td><code>splitted</code></td>
<td>
<p>a list containing the datasets which we add a new sample into
it</p>
</td></tr>
<tr><td><code>newY</code></td>
<td>
<p>the label of the choosed sample</p>
</td></tr>
<tr><td><code>train</code></td>
<td>
<p>the dataset used for training the model after adding the new
sample</p>
</td></tr>
<tr><td><code>labeled_ids</code></td>
<td>
<p>the id of the labeled dataset after updating</p>
</td></tr>
<tr><td><code>unlabeled_ids</code></td>
<td>
<p>the id of the unlabeled dataset after updating</p>
</td></tr>
</table>


<h3>References</h3>


<p>Li, J., Chen, Z., Wang, Z., &amp; Chang, Y. I. (2020). Active learning in
multiple-class classification problems via individualized binary models.
<em>Computational Statistics &amp; Data Analysis</em>, 145, 106911.
doi:10.1016/j.csda.2020.106911

</p>


<h3>See Also</h3>


<p><code><a href="#topic+update_data_ord">update_data_ord</a></code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## For an example, see example(seq_cat_model)
</code></pre>

<hr>
<h2 id='update_data_ord'>Add the new sample into labeled dataset from unlabeled dataset for the
ordinal case</h2><span id='topic+update_data_ord'></span>

<h3>Description</h3>

<p><code>update_data_ord</code> selects the sample to the labeled dataset according to
it's index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_data_ord(ind, splitted, data, train, labeled_ids, unlabeled_ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_data_ord_+3A_ind">ind</code></td>
<td>
<p>A numeric value denotes the index of selected sample.</p>
</td></tr>
<tr><td><code id="update_data_ord_+3A_splitted">splitted</code></td>
<td>
<p>A list containing the datasets which we will use in the
cordinl case. Note that the element of the data_split is the samples from
Classes k-1and Classes k</p>
</td></tr>
<tr><td><code id="update_data_ord_+3A_data">data</code></td>
<td>
<p>A matrix  denotes all the data including the labeled samples and
the unlabeled samples. Note that the first column of the dataset is the
response variable, that's the labels and the rest is the explanatory
variables.</p>
</td></tr>
<tr><td><code id="update_data_ord_+3A_train">train</code></td>
<td>
<p>A matrix for the labeled samples.</p>
</td></tr>
<tr><td><code id="update_data_ord_+3A_labeled_ids">labeled_ids</code></td>
<td>
<p>The unique identification of the labeled dataset</p>
</td></tr>
<tr><td><code id="update_data_ord_+3A_unlabeled_ids">unlabeled_ids</code></td>
<td>
<p>The unique identification of the unlabeled dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>update_data_ord chooses the sample based on the index from all the training
ordinal dataset. We record the corresponding label of the selected sample and
update the data of the unlabeled dataset and the labeled dataset.
Specifically, we remove the index of the choosed sample from the unlabeled
dataset and add the sample to the labeled dataset.
</p>


<h3>Value</h3>

<table>
<tr><td><code>splitted</code></td>
<td>
<p>a list containing the new datasets which we add a new sample
into it</p>
</td></tr>
<tr><td><code>newY</code></td>
<td>
<p>the label of the choosed sample</p>
</td></tr>
<tr><td><code>train</code></td>
<td>
<p>the dataset used for training the model after adding the new
sample</p>
</td></tr>
<tr><td><code>labeled_ids</code></td>
<td>
<p>the id of the labeled dataset after updating</p>
</td></tr>
<tr><td><code>unlabeled_ids</code></td>
<td>
<p>the id of the unlabeled dataset after updating</p>
</td></tr>
</table>


<h3>References</h3>


<p>Li, J., Chen, Z., Wang, Z., &amp; Chang, Y. I. (2020). Active learning in
multiple-class classification problems via individualized binary models.
<em>Computational Statistics &amp; Data Analysis</em>, 145, 106911.
doi:10.1016/j.csda.2020.106911

</p>


<h3>See Also</h3>


<p><code><a href="#topic+update_data_cat">update_data_cat</a></code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>## For an example, see example(seq_ord_model)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
