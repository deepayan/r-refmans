<!DOCTYPE html><html><head><title>Help for package gcdnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gcdnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef'><p>Extract Model Coefficients</p></a></li>
<li><a href='#coef.cv.gcdnet'><p>Get coefficients or make coefficient predictions from a &quot;cv.gcdnet&quot; object.</p></a></li>
<li><a href='#coef.gcdnet'><p>Get coefficients or make coefficient predictions from a &quot;gcdnet&quot; object.</p></a></li>
<li><a href='#cv.gcdnet'><p>Cross-validation for gcdnet</p></a></li>
<li><a href='#FHT'><p>FHT data introduced in Friedman et al. (2010).</p></a></li>
<li><a href='#gcdnet'><p>Fits the regularization paths for large margin classifiers</p></a></li>
<li><a href='#plot.cv.gcdnet'><p>Plot the cross-validation curve produced by cv.gcdnet</p></a></li>
<li><a href='#plot.gcdnet'><p>Plot coefficients from a &quot;gcdnet&quot; object</p></a></li>
<li><a href='#predict'><p>Model predictions</p></a></li>
<li><a href='#predict.cv.gcdnet'><p>Make predictions from a &quot;cv.gcdnet&quot; object.</p></a></li>
<li><a href='#predict.gcdnet'><p>Make predictions from a &quot;gcdnet&quot; object</p></a></li>
<li><a href='#print.gcdnet'><p>Print a gcdnet object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The (Adaptive) LASSO and Elastic Net Penalized Least Squares,
Logistic Regression, Hybrid Huberized Support Vector Machines,
Squared Hinge Loss Support Vector Machines and Expectile
Regression using a Fast Generalized Coordinate Descent
Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Yi Yang &lt;yi.yang6@mcgill.ca&gt;, Yuwen Gu &lt;yuwen.gu@uconn.edu&gt;, Hui Zou
    &lt;hzou@stat.umn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yi Yang &lt;yi.yang6@mcgill.ca&gt;</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, methods, Matrix</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a generalized coordinate descent (GCD) algorithm
    for computing the solution paths of the hybrid Huberized support vector
    machine (HHSVM) and its generalizations. Supported models include the
    (adaptive) LASSO and elastic net penalized least squares, logistic
    regression, HHSVM, squared hinge loss SVM and expectile regression.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-14 02:30:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-14 01:06:43 UTC; yuwen</td>
</tr>
</table>
<hr>
<h2 id='coef'>Extract Model Coefficients</h2><span id='topic+coef'></span>

<h3>Description</h3>

<p><code>coef</code> is a generic function which extracts model coefficients from
objects returned by modeling functions. <code>coefficients</code> is an
<em>alias</em> for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object for which the extraction of model coefficients is
meaningful.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Coefficients extracted from the model object <code>object</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.gcdnet">coef.gcdnet</a></code>, <code><a href="#topic+coef.erpath">coef.erpath</a></code>,
<code><a href="#topic+coef.lspath">coef.lspath</a></code>, <code><a href="#topic+coef.hsvmpath">coef.hsvmpath</a></code>,
<code><a href="#topic+coef.logitpath">coef.logitpath</a></code>, <code><a href="#topic+coef.sqsvmpath">coef.sqsvmpath</a></code>.
</p>

<hr>
<h2 id='coef.cv.gcdnet'>Get coefficients or make coefficient predictions from a &quot;cv.gcdnet&quot; object.</h2><span id='topic+coef.cv.gcdnet'></span>

<h3>Description</h3>

<p>This function gets coefficients or makes coefficient predictions from a
cross-validated gcdnet model, using the stored <code>"gcdnet.fit"</code> object,
and the optimal value chosen for <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.gcdnet'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.cv.gcdnet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.gcdnet">cv.gcdnet</a></code> object.</p>
</td></tr>
<tr><td><code id="coef.cv.gcdnet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code>
stored on the CV <code>object</code>, it is the largest value of <code>lambda</code>
such that error is within 1 standard error of the minimum. Alternatively
<code>s="lambda.min"</code> can be used, it is the optimal value of
<code>lambda</code> that gives minimum cross validation error <code>cvm</code>. If
<code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used.</p>
</td></tr>
<tr><td><code id="coef.cv.gcdnet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation to get
coefficients or make coefficient predictions.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on
to the <code><a href="#topic+predict">predict</a></code> method for <code><a href="#topic+gcdnet">gcdnet</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yi Yang &lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.gcdnet">cv.gcdnet</a></code>, and <code><a href="#topic+predict.cv.gcdnet">predict.cv.gcdnet</a></code>
methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)
set.seed(2011)
cv &lt;- cv.gcdnet(FHT$x, FHT$y, lambda2 = 1, nfolds = 5)
coef(cv, s = "lambda.min")

</code></pre>

<hr>
<h2 id='coef.gcdnet'>Get coefficients or make coefficient predictions from a &quot;gcdnet&quot; object.</h2><span id='topic+coef.gcdnet'></span><span id='topic+coef.hsvmpath'></span><span id='topic+coef.sqsvmpath'></span><span id='topic+coef.logitpath'></span><span id='topic+coef.lspath'></span><span id='topic+coef.erpath'></span>

<h3>Description</h3>

<p>Computes the coefficients or returns a list of the indices of the nonzero
coefficients at the requested values for <code>lambda</code> from a fitted
<code><a href="#topic+gcdnet">gcdnet</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcdnet'
coef(object, s = NULL, type = c("coefficients", "nonzero"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.gcdnet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+gcdnet">gcdnet</a></code> model object.</p>
</td></tr>
<tr><td><code id="coef.gcdnet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the entire sequence used to create
the model.</p>
</td></tr>
<tr><td><code id="coef.gcdnet_+3A_type">type</code></td>
<td>
<p>type <code>"coefficients"</code> computes the coefficients at the
requested values for <code>s</code>. Type <code>"nonzero"</code> returns a list of the
indices of the nonzero coefficients for each value of <code>s</code>. Default is
<code>"coefficients"</code>.</p>
</td></tr>
<tr><td><code id="coef.gcdnet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are requested. If <code>s</code>
is not in the lambda sequence used for fitting the model, the <code>coef</code>
function will use linear interpolation to make predictions. The new values
are interpolated using a fraction of coefficients from both left and right
<code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yi Yang &lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.gcdnet">predict.gcdnet</a></code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)
fit1 &lt;- gcdnet(x = FHT$x,y = FHT$y)
coef(fit1, type = "coef", s = c(0.1,0.005))
coef(fit1, type = "nonzero")

</code></pre>

<hr>
<h2 id='cv.gcdnet'>Cross-validation for gcdnet</h2><span id='topic+cv.gcdnet'></span><span id='topic+cv.hsvmpath'></span><span id='topic+cv.sqsvmpath'></span><span id='topic+cv.logitpath'></span><span id='topic+cv.lspath'></span><span id='topic+cv.erpath'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for gcdnet, produces a plot, and returns a
value for <code>lambda</code>. This function is modified based on the <code>cv</code>
function from the <code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.gcdnet(
  x,
  y,
  lambda = NULL,
  pred.loss = c("misclass", "loss"),
  nfolds = 5,
  foldid,
  delta = 2,
  omega = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.gcdnet_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code><a href="#topic+gcdnet">gcdnet</a></code>.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_y">y</code></td>
<td>
<p>response variable or class label <code>y</code> as in
<code><a href="#topic+gcdnet">gcdnet</a></code>.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_lambda">lambda</code></td>
<td>
<p>optional user-supplied lambda sequence; default is
<code>NULL</code>, and <code><a href="#topic+gcdnet">gcdnet</a></code> chooses its own sequence.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_pred.loss">pred.loss</code></td>
<td>
<p>loss function to use for cross-validation error. Valid
options are: </p>
 <ul>
<li> <p><code>"loss"</code> Margin based loss function.
When use least square loss <code>"ls"</code>, it gives mean square error (MSE).
When use expectile regression loss <code>"er"</code>, it gives asymmetric mean
square error (AMSE). </p>
</li>
<li> <p><code>"misclass"</code> only available for
classification: it gives misclassification error. </p>
</li></ul>
<p> Default is
<code>"loss"</code>.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds - default is 5. Although <code>nfolds</code> can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is <code>nfolds=3</code>.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied, <code>nfold</code>
can be missing.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_delta">delta</code></td>
<td>
<p>parameter <code class="reqn">\delta</code> only used in HHSVM for computing
margin based loss function, only available for <code>pred.loss = "loss"</code>.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_omega">omega</code></td>
<td>
<p>parameter <code class="reqn">\omega</code> only used in expectile
regression. Only available for <code>pred.loss = "loss"</code>.</p>
</td></tr>
<tr><td><code id="cv.gcdnet_+3A_...">...</code></td>
<td>
<p>other arguments that can be passed to gcdnet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code><a href="#topic+gcdnet">gcdnet</a></code> <code>nfolds</code>+1 times; the first to
get the <code>lambda</code> sequence, and then the remainder to compute the fit
with each of the folds omitted. The average error and standard deviation
over the folds are computed.
</p>


<h3>Value</h3>

<p>an object of class <code><a href="#topic+cv.gcdnet">cv.gcdnet</a></code> is returned, which is a
list with the ingredients of the cross-validation fit. </p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the
values of <code>lambda</code> used in the fits.</p>
</td></tr> <tr><td><code>cvm</code></td>
<td>
<p>the mean
cross-validated error - a vector of length <code>length(lambda)</code>.</p>
</td></tr>
<tr><td><code>cvsd</code></td>
<td>
<p>estimate of standard error of <code>cvm</code>.</p>
</td></tr>
<tr><td><code>cvupper</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr> <tr><td><code>cvlower</code></td>
<td>
<p>lower curve
= <code>cvm-cvsd</code>.</p>
</td></tr> <tr><td><code>nzero</code></td>
<td>
<p>number of non-zero coefficients at each
<code>lambda</code>.</p>
</td></tr> <tr><td><code>name</code></td>
<td>
<p>a text string indicating type of measure (for
plotting purposes).</p>
</td></tr> <tr><td><code>gcdnet.fit</code></td>
<td>
<p>a fitted <code><a href="#topic+gcdnet">gcdnet</a></code>
object for the full data.</p>
</td></tr> <tr><td><code>lambda.min</code></td>
<td>
<p>The optimal value of
<code>lambda</code> that gives minimum cross validation error <code>cvm</code>.</p>
</td></tr>
<tr><td><code>lambda.1se</code></td>
<td>
<p>The largest value of <code>lambda</code> such that error is
within 1 standard error of the minimum.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br /> Maintainer: Yi Yang
&lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gcdnet">gcdnet</a></code>, <code><a href="#topic+plot.cv.gcdnet">plot.cv.gcdnet</a></code>,
<code><a href="#topic+predict.cv.gcdnet">predict.cv.gcdnet</a></code>, and <code><a href="#topic+coef.cv.gcdnet">coef.cv.gcdnet</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit an elastic net penalized HHSVM with lambda2 = 0.1 for the L2 penalty.
# Use the misclassification rate as the cross validation prediction loss.
# Use five-fold CV to choose the optimal lambda for the L1 penalty.

data(FHT)
set.seed(2011)
cv &lt;- cv.gcdnet(FHT$x, FHT$y, method = "hhsvm",
                lambda2 = 0.1, pred.loss = "misclass",
                nfolds = 5, delta = 1.5)
plot(cv)

# fit an elastic net penalized least squares
# with lambda2 = 0.1 for the L2 penalty. Use the
# least square loss as the cross validation
# prediction loss. Use five-fold CV to choose
# the optimal lambda for the L1 penalty.

set.seed(2011)
cv1 &lt;- cv.gcdnet(FHT$x, FHT$y_reg, method ="ls",
                 lambda2 = 0.1, pred.loss = "loss",
                 nfolds = 5)
plot(cv1)

# To fit a LASSO penalized logistic regression
# we set lambda2 = 0 to disable the L2 penalty. Use the
# logistic loss as the cross validation
# prediction loss. Use five-fold CV to choose
# the optimal lambda for the L1 penalty.

set.seed(2011)
cv2 &lt;- cv.gcdnet(FHT$x, FHT$y, method ="logit",
                 lambda2 = 0, pred.loss="loss",
                 nfolds=5)
plot(cv2)

</code></pre>

<hr>
<h2 id='FHT'>FHT data introduced in Friedman et al. (2010).</h2><span id='topic+FHT'></span>

<h3>Description</h3>

<p>The <code>FHT</code> data set has n = 50 observations and p = 100 predictors. The
covariance between predictors Xj and Xj' has the same correlation 0.5. See
details in Friedman et al. (2010).
</p>


<h3>Format</h3>

<p>This data frame contains the following columns: </p>

<dl>
<dt>x</dt><dd><p>a matrix with 100 rows and 5000 columns</p>
</dd> <dt>y</dt><dd><p>class labels</p>
</dd>
<dt>y_reg</dt><dd><p>response variable for regression</p>
</dd> </dl>



<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)

</code></pre>

<hr>
<h2 id='gcdnet'>Fits the regularization paths for large margin classifiers</h2><span id='topic+gcdnet'></span>

<h3>Description</h3>

<p>Fits a regularization path for large margin classifiers at a sequence of
regularization parameters lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcdnet(
  x,
  y,
  nlambda = 100,
  method = c("hhsvm", "logit", "sqsvm", "ls", "er"),
  lambda.factor = ifelse(nobs &lt; nvars, 0.01, 1e-04),
  lambda = NULL,
  lambda2 = 0,
  pf = rep(1, nvars),
  pf2 = rep(1, nvars),
  exclude,
  dfmax = nvars + 1,
  pmax = min(dfmax * 1.2, nvars),
  standardize = FALSE,
  intercept = TRUE,
  eps = 1e-08,
  maxit = 1e+06,
  delta = 2,
  omega = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcdnet_+3A_x">x</code></td>
<td>
<p>matrix of predictors, of dimension <code class="reqn">N \times p</code>; each row
is an observation vector.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_y">y</code></td>
<td>
<p>response variable. This argument should be a two-level factor for
classification.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of <code>lambda</code> values - default is 100.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_method">method</code></td>
<td>
<p>a character string specifying the loss function to use, valid
options are: </p>
 <ul>
<li> <p><code>"hhsvm"</code> Huberized squared hinge loss,
</p>
</li>
<li> <p><code>"sqsvm"</code> Squared hinge loss, </p>
</li>
<li> <p><code>"logit"</code> logistic
loss, </p>
</li>
<li> <p><code>"ls"</code> least square loss. </p>
</li>
<li> <p><code>"er"</code> expectile
regression loss. </p>
</li></ul>
<p> Default is <code>"hhsvm"</code>.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>The factor for getting the minimal lambda in
<code>lambda</code> sequence, where <code>min(lambda)</code> = <code>lambda.factor</code> *
<code>max(lambda)</code>, where <code>max(lambda)</code> is the smallest value of
<code>lambda</code> for which all coefficients are zero. The default depends on
the relationship between <code class="reqn">N</code> (the number of rows in the matrix of
predictors) and <code class="reqn">p</code> (the number of predictors). If <code class="reqn">N &gt; p</code>, the
default is <code>0.0001</code>, close to zero. If <code class="reqn">N&lt;p</code>, the default is
<code>0.01</code>. A very small value of <code>lambda.factor</code> will lead to a
saturated fit. It takes no effect if there is user-defined <code>lambda</code>
sequence.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_lambda">lambda</code></td>
<td>
<p>a user supplied <code>lambda</code> sequence. Typically, by leaving
this option unspecified users can have the program compute its own
<code>lambda</code> sequence based on <code>nlambda</code> and <code>lambda.factor</code>.
Supplying a value of <code>lambda</code> overrides this. It is better to supply
a decreasing sequence of <code>lambda</code> values than a single (small) value,
if not, the program will sort user-defined <code>lambda</code> sequence in
decreasing order automatically.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_lambda2">lambda2</code></td>
<td>
<p>regularization parameter <code class="reqn">\lambda_2</code> for the
quadratic penalty of the coefficients.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_pf">pf</code></td>
<td>
<p>L1 penalty factor of length <code class="reqn">p</code> used for adaptive LASSO or
adaptive elastic net. Separate L1 penalty weights can be applied to each
coefficient of <code class="reqn">\beta</code> to allow differential L1 shrinkage. Can
be 0 for some variables, which implies no L1 shrinkage, and results in
that variable always being included in the model. Default is 1 for all
variables (and implicitly infinity for variables listed in
<code>exclude</code>).</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_pf2">pf2</code></td>
<td>
<p>L2 penalty factor of length <code class="reqn">p</code> used for adaptive LASSO or
adaptive elastic net. Separate L2 penalty weights can be applied to each
coefficient of <code class="reqn">\beta</code> to allow differential L2 shrinkage. Can
be 0 for some variables, which implies no L2 shrinkage. Default is 1 for
all variables.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_exclude">exclude</code></td>
<td>
<p>indices of variables to be excluded from the model. Default
is none. Equivalent to an infinite penalty factor.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_dfmax">dfmax</code></td>
<td>
<p>limit the maximum number of variables in the model. Useful for
very large <code class="reqn">p</code>, if a partial path is desired. Default is <code class="reqn">p+1</code>.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_pmax">pmax</code></td>
<td>
<p>limit the maximum number of variables ever to be nonzero. For
example once <code class="reqn">\beta</code> enters the model, no matter how many times it
exits or re-enters model through the path, it will be counted only once.
Default is <code>min(dfmax*1.2,p)</code>.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_standardize">standardize</code></td>
<td>
<p>logical flag for variable standardization, prior to
fitting the model sequence. If <code>TRUE</code>, <code>x</code> matrix is normalized
such that <code>x</code> is centered (i.e.
<code class="reqn">\sum^N_{i=1}x_{ij}=0</code>), and sum squares of each column
<code class="reqn">\sum^N_{i=1}x_{ij}^2/N=1</code>. If <code>x</code> matrix is
standardized, the ending coefficients will be transformed back to the
original scale. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_intercept">intercept</code></td>
<td>
<p>logical flag to indicate whether to include or exclude the
intercept in the model.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_eps">eps</code></td>
<td>
<p>convergence threshold for coordinate majorization descent. Each
inner coordinate majorization descent loop continues until the relative
change in any coefficient (i.e., <code class="reqn">\max_j(\beta_j^{new}
-\beta_j^{old})^2</code>) is less than
<code>eps</code>. For HHSVM, i.e., <code>method="hhsvm"</code>, it is
<code class="reqn">\frac{2}{\delta}\max_j(\beta_j^{new}-\beta_j^{old})^2</code>. For expectile regression,
i.e., <code>method="er"</code>, it is <code class="reqn">2\max(1-\omega,\omega)
\max_j(\beta_j^{new}-\beta_j^{old})^2</code>. Defaults value is <code>1e-8</code>.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of outer-loop iterations allowed at fixed lambda
value. Default is 1e6. If models do not converge, consider increasing
<code>maxit</code>.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_delta">delta</code></td>
<td>
<p>the parameter <code class="reqn">\delta</code> in the HHSVM model. The value
must be greater than 0. Default is 2.</p>
</td></tr>
<tr><td><code id="gcdnet_+3A_omega">omega</code></td>
<td>
<p>the parameter <code class="reqn">\omega</code> in the expectile regression
model. The value must be in (0,1). Default is 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the objective function in <code>gcdnet</code> is </p>
<p style="text-align: center;"><code class="reqn">Loss(y,
  X, \beta)/N + \lambda_1\Vert\beta\Vert_1 +
  0.5\lambda_2\Vert\beta\Vert_2^2</code>
</p>
<p> where the penalty is a combination of L1 and L2
term. Users can specify the loss function to use, options include
Huberized squared hinge loss, Squared hinge loss, least square loss,
logistic regression and expectile regression loss. Users can also tweak
the penalty by choosing different <code class="reqn">lambda2</code> and penalty factor.
</p>
<p>For computing speed reason, if models are not converging or running slow,
consider increasing <code>eps</code>, decreasing <code>nlambda</code>, or increasing
<code>lambda.factor</code> before increasing <code>maxit</code>.
</p>
<p><strong>FAQ:</strong>
</p>
<p><b>Question: </b>&ldquo;<em>I couldn't get an idea how to specify an
option to get adaptive LASSO, how to specify an option to get elastic net
and adaptive elastic net? Could you please give me a quick hint?</em>&rdquo;
</p>
<p><b>Answer: </b> <code>lambda2</code> is the regularize parameter for L2 penalty
part. To use LASSO, set <code>lambda2=0</code>. To use elastic net, set
<code>lambda2</code> as nonzero.
</p>
<p><code>pf</code> is the L1 penalty factor of length <code class="reqn">p</code> (<code class="reqn">p</code> is the
number of predictors). Separate L1 penalty weights can be applied to each
coefficient to allow differential L1 shrinkage. Similiarly <code>pf2</code> is
the L2 penalty factor of length <code class="reqn">p</code>.
</p>
<p>To use adaptive LASSO, you should set <code>lambda2=0</code> and also specify
<code>pf</code> and <code>pf2</code>. To use adaptive elastic net, you should set
<code>lambda2</code> as nonzero and specify <code>pf</code> and <code>pf2</code>,
</p>
<p>For example:
</p>
<pre>
    library('gcdnet')
    # Dataset N = 100, p = 10
    x_log &lt;- matrix(rnorm(100*10),100,10)
    y_log &lt;- sample(c(-1,1),100,replace=TRUE)

    # LASSO
    m &lt;- gcdnet(x=x_log,y=y_log,lambda2=0,method="log")
    plot(m)

    # elastic net with lambda2 = 1
    m &lt;- gcdnet(x=x_log,y=y_log,lambda2=1,method="log")
    plot(m)

    # adaptive lasso with penalty factor
    # pf = 0.5 0.5 0.5 0.5 0.5 1.0 1.0 1.0 1.0 1.0
    m &lt;- gcdnet(x=x_log,y=y_log,lambda2=0,method="log",
                pf=c(rep(0.5,5),rep(1,5)))
    plot(m)

    # adaptive elastic net with lambda2 = 1 and penalty factor pf =
    # c(rep(0.5,5),rep(1,5)) pf2 = 3 3 3 3 3 1 1 1 1 1
    m &lt;- gcdnet(x=x_log,y=y_log,lambda2=1,method="log",
                pf=c(rep(0.5,5),rep(1,5)),
                pf2 = c(rep(3,5),rep(1,5)))
    plot(m)
  </pre>
<p><b>Question: </b>&ldquo;<em>what is the meaning of the parameter
<code>pf</code>? On the package documentation, it said <code>pf</code> is the penalty
weight applied to each coefficient of beta?</em>&rdquo;
</p>
<p><b>Answer: </b> Yes, <code>pf</code> and <code>pf2</code> are L1 and L2 penalty factor
of length <code class="reqn">p</code> used for adaptive LASSO or adaptive elastic net. 0
means that the feature (variable) is always excluded, 1 means that the
feature (variable) is included with weight 1.
</p>
<p><b>Question: </b>&ldquo;<em>Does gcdnet deal with both continuous and
categorical response variables?</em>&rdquo;
</p>
<p><b>Answer: </b> Yes, both are supported, you can use a continuous type
response variable with the least squares regression loss, or a categorical
type response with losses for classification problem.
</p>
<p><b>Question: </b>&ldquo;<em>Why does predict function not work? predict
should return the predicted probability of the positive class. Instead I
get:</em>&rdquo;
</p>
<pre>
    Error in as.matrix(as.matrix(cbind2(1, newx)) %*% nbeta):
    error in evaluating the argument 'x' in selecting a method for function 'as.matrix':
    Error in t(.Call(Csparse_dense_crossprod, y, t(x))):
    error in evaluating the argument 'x' in selecting a method for function 't':
    Error: Cholmod error 'X and/or Y have wrong dimensions' at
      file ../MatrixOps/cholmod_sdmult.c, line 90?
  </pre>
<p>&ldquo;<em>Using the Arcene dataset and executing the following code
will give the above error:</em>&rdquo;
</p>
<pre>
    library(gcdnet)
    arc &lt;- read.csv("arcene.csv", header=FALSE)
    fit &lt;- gcdnet(arc[,-10001], arc[,10001], standardize=FALSE,
                  method="logit")
    pred &lt;- rnorm(10000)
    predict(fit, pred, type="link")
  </pre>
<p><b>Answer: </b> It is actually NOT a bug of gcdnet. When make prediction
using a new matrix x, each observation of x should be arranged as a row of
a matrix. In your code, because &quot;pred&quot; is a vector, you need to convert
&quot;pred&quot; into a matrix, try the following code:
</p>
<pre>
     pred &lt;- rnorm(10000)
     pred &lt;- matrix(pred,1,10000)
     predict(fit, pred, type="link")
  </pre>


<h3>Value</h3>

<p>An object with S3 class <code><a href="#topic+gcdnet">gcdnet</a></code>. </p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call
that produced this object</p>
</td></tr> <tr><td><code>b0</code></td>
<td>
<p>intercept sequence of length
<code>length(lambda)</code></p>
</td></tr> <tr><td><code>beta</code></td>
<td>
<p>a <code>p*length(lambda)</code> matrix of
coefficients, stored as a sparse matrix (<code>dgCMatrix</code> class, the
standard class for sparse numeric matrices in the <code>Matrix</code> package.).
To convert it into normal type matrix use <code>as.matrix()</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>the actual sequence of <code>lambda</code> values used</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the number of nonzero coefficients for each value of
<code>lambda</code>.</p>
</td></tr> <tr><td><code>dim</code></td>
<td>
<p>dimension of coefficient matrix (ices)</p>
</td></tr>
<tr><td><code>npasses</code></td>
<td>
<p>total number of iterations (the most inner loop) summed
over all lambda values</p>
</td></tr> <tr><td><code>jerr</code></td>
<td>
<p>error flag, for warnings and errors, 0
if no error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br />
Maintainer: Yi Yang &lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>


<h3>See Also</h3>

<p><code>plot.gcdnet</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)
# 1. solution paths for the LASSO penalized least squares.
# To use LASSO set lambda2 = 0.

m1 &lt;- gcdnet(x = FHT$x, y = FHT$y_reg, lambda2 = 0, method = "ls")
plot(m1)

# 2. solution paths for the elastic net penalized HHSVM.
# lambda2 is the parameter controlling the L2 penalty.
m2 &lt;- gcdnet(x = FHT$x, y = FHT$y, delta = 1, lambda2 = 1, method = "hhsvm")
plot(m2)

# 3. solution paths for the adaptive LASSO penalized SVM
# with the squared hinge loss. To use the adaptive LASSO,
# set lambda2 = 0 and meanwhile specify the L1 penalty weights.
p &lt;- ncol(FHT$x)
# set the first three L1 penalty weights as 0.1 and the rest are 1
pf = c(0.1, 0.1, 0.1, rep(1, p-3))
m3 &lt;- gcdnet(x = FHT$x, y = FHT$y, pf = pf, lambda2 = 0, method = "sqsvm")
plot(m3)

# 4. solution paths for the adaptive elastic net penalized
# logistic regression.

p &lt;- ncol(FHT$x)
# set the first three L1 penalty weights as 10 and the rest are 1.
pf &lt;- c(10, 10, 10, rep(1, p-3))
# set the last three L2 penalty weights as 0.1 and the rest are 1.
pf2 &lt;- c(rep(1, p-3), 0.1, 0.1, 0.1)
# set the L2 penalty parameter lambda2=0.01.
m4 &lt;- gcdnet(x = FHT$x, y = FHT$y, pf = pf, pf2 = pf2,
             lambda2 = 0.01, method = "logit")
plot(m4)

# 5. solution paths for the LASSO penalized expectile regression
# with the asymmetric least square parameter omega=0.9.

m5 &lt;- gcdnet(x = FHT$x, y = FHT$y_reg, omega = 0.9,
             lambda2 = 0, method = "er")
plot(m5)

</code></pre>

<hr>
<h2 id='plot.cv.gcdnet'>Plot the cross-validation curve produced by cv.gcdnet</h2><span id='topic+plot.cv.gcdnet'></span>

<h3>Description</h3>

<p>Plots the cross-validation curve, and upper and lower standard deviation
curves, as a function of the <code>lambda</code> values used. This function is
modified based on the <code>plot.cv</code> function from the <code>glmnet</code>
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.gcdnet'
plot(x, sign.lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.gcdnet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+cv.gcdnet">cv.gcdnet</a></code> object</p>
</td></tr>
<tr><td><code id="plot.cv.gcdnet_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>either plot against <code>log(lambda)</code> (default) or its
negative if <code>sign.lambda=-1</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.gcdnet_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot is produced.
</p>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yi Yang &lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.gcdnet">cv.gcdnet</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# fit an elastic net penalized logistic regression with lambda2 = 1 for the
# L2 penalty. Use the logistic loss as the cross validation prediction loss.
# Use five-fold CV to choose the optimal lambda for the L1 penalty.
data(FHT)
set.seed(2011)
cv=cv.gcdnet(FHT$x, FHT$y, method ="logit", lambda2 = 1,
             pred.loss="loss", nfolds=5)
plot(cv)

</code></pre>

<hr>
<h2 id='plot.gcdnet'>Plot coefficients from a &quot;gcdnet&quot; object</h2><span id='topic+plot.gcdnet'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for a fitted
<code><a href="#topic+gcdnet">gcdnet</a></code> object. This function is modified based on the
<code>plot</code> function from the <code>glmnet</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcdnet'
plot(x, xvar = c("norm", "lambda"), color = FALSE, label = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcdnet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+gcdnet">gcdnet</a></code> model</p>
</td></tr>
<tr><td><code id="plot.gcdnet_+3A_xvar">xvar</code></td>
<td>
<p>what is on the X-axis. <code>"norm"</code> plots against the L1-norm
of the coefficients, <code>"lambda"</code> against the log-lambda sequence.</p>
</td></tr>
<tr><td><code id="plot.gcdnet_+3A_color">color</code></td>
<td>
<p>if <code>TRUE</code>, plot the curves with rainbow colors.
<code>FALSE</code> is gray colors. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.gcdnet_+3A_label">label</code></td>
<td>
<p>if <code>TRUE</code>, label the curves with variable sequence
numbers. Default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plot.gcdnet_+3A_...">...</code></td>
<td>
<p>other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced.
</p>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br /> Maintainer: Yi Yang
&lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)
m1 &lt;- gcdnet(x = FHT$x,y = FHT$y)
par(mfrow = c(1,3))
plot(m1) # plots against the L1-norm of the coefficients
plot(m1,xvar = "lambda",label = TRUE) # plots against the log-lambda sequence
plot(m1,color = TRUE)

</code></pre>

<hr>
<h2 id='predict'>Model predictions</h2><span id='topic+predict'></span>

<h3>Description</h3>

<p><code>predict</code> is a generic function for predictions from the results of
various model fitting functions. The function invokes particular
<em>methods</em> which depend on the <code><a href="base.html#topic+class">class</a></code> of the first
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>a model object for which prediction is desired.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the predictions produced.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by <code>predict</code> depends on the
class of its argument. See the documentation of the particular methods for
details of what is produced by that method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.gcdnet">predict.gcdnet</a></code>, <code><a href="#topic+predict.erpath">predict.erpath</a></code>,
<code><a href="#topic+predict.lspath">predict.lspath</a></code>, <code><a href="#topic+predict.hsvmpath">predict.hsvmpath</a></code>,
<code><a href="#topic+predict.logitpath">predict.logitpath</a></code>, <code><a href="#topic+predict.sqsvmpath">predict.sqsvmpath</a></code>.
</p>

<hr>
<h2 id='predict.cv.gcdnet'>Make predictions from a &quot;cv.gcdnet&quot; object.</h2><span id='topic+predict.cv.gcdnet'></span>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated gcdnet model, using
the stored <code>"gcdnet.fit"</code> object, and the optimal value chosen for
<code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.gcdnet'
predict(object, newx, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.gcdnet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+cv.gcdnet">cv.gcdnet</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.cv.gcdnet_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. Must be a matrix. See documentation for <code>predict.gcdnet</code>.</p>
</td></tr>
<tr><td><code id="predict.cv.gcdnet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the value <code>s="lambda.1se"</code>
stored on the CV object. Alternatively <code>s="lambda.min"</code> can be used.
If <code>s</code> is numeric, it is taken as the value(s) of <code>lambda</code> to be
used.</p>
</td></tr>
<tr><td><code id="predict.cv.gcdnet_+3A_...">...</code></td>
<td>
<p>not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation to
make a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on
to the <code><a href="#topic+predict">predict</a></code> method for <code><a href="#topic+gcdnet">gcdnet</a></code> objects.
</p>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yi Yang &lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.gcdnet">cv.gcdnet</a></code>, and <code><a href="#topic+coef.cv.gcdnet">coef.cv.gcdnet</a></code> methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)
set.seed(2011)
cv=cv.gcdnet(FHT$x, FHT$y, lambda2 = 1, pred.loss="misclass",
             lambda.factor=0.05, nfolds=5)
pre = predict(cv$gcdnet.fit, newx = FHT$x, s = cv$lambda.1se,
              type = "class")

</code></pre>

<hr>
<h2 id='predict.gcdnet'>Make predictions from a &quot;gcdnet&quot; object</h2><span id='topic+predict.gcdnet'></span><span id='topic+predict.hsvmpath'></span><span id='topic+predict.sqsvmpath'></span><span id='topic+predict.logitpath'></span><span id='topic+predict.lspath'></span><span id='topic+predict.erpath'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted values and
class labels from a fitted <code><a href="#topic+gcdnet">gcdnet</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcdnet'
predict(object, newx, s = NULL, type = c("class", "link"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gcdnet_+3A_object">object</code></td>
<td>
<p>fitted <code><a href="#topic+gcdnet">gcdnet</a></code> model object.</p>
</td></tr>
<tr><td><code id="predict.gcdnet_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. NOTE: <code>newx</code> must be a matrix, <code>predict</code> function does not
accept a vector or other formats of <code>newx</code>.</p>
</td></tr>
<tr><td><code id="predict.gcdnet_+3A_s">s</code></td>
<td>
<p>value(s) of the penalty parameter <code>lambda</code> at which
predictions are required. Default is the entire sequence used to create
the model.</p>
</td></tr>
<tr><td><code id="predict.gcdnet_+3A_type">type</code></td>
<td>
<p>type of prediction required. </p>
 <ul>
<li><p> Type <code>"link"</code>
gives the linear predictors for classification problems and gives
predicted response for regression problems. </p>
</li>
<li><p> Type <code>"class"</code>
produces the class label corresponding to the maximum probability. Only
available for classification problems.</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.gcdnet_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to predict.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>s</code> is the new vector at which predictions are requested. If <code>s</code>
is not in the lambda sequence used for fitting the model, the
<code>predict</code> function will use linear interpolation to make predictions.
The new values are interpolated using a fraction of predicted values from
both left and right <code>lambda</code> indices.
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yi Yang &lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef">coef</a></code> method
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)
m1 &lt;- gcdnet(x = FHT$x,y = FHT$y)
print(predict(m1, type = "class",newx = FHT$x[2:5, ]))

</code></pre>

<hr>
<h2 id='print.gcdnet'>Print a gcdnet object</h2><span id='topic+print.gcdnet'></span>

<h3>Description</h3>

<p>Print a summary of the gcdnet path at each step along the path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcdnet'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gcdnet_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+gcdnet">gcdnet</a></code> object</p>
</td></tr>
<tr><td><code id="print.gcdnet_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout</p>
</td></tr>
<tr><td><code id="print.gcdnet_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced the <code><a href="#topic+gcdnet">gcdnet</a></code> object is printed, followed
by a two-column matrix with columns <code>Df</code> and <code>Lambda</code>. The
<code>Df</code> column is the number of nonzero coefficients.
</p>


<h3>Value</h3>

<p>a two-column matrix, the first columns is the number of nonzero
coefficients and the second column is <code>Lambda</code>.
</p>


<h3>Author(s)</h3>

<p>Yi Yang, Yuwen Gu and Hui Zou<br />
</p>
<p>Maintainer: Yi Yang &lt;yi.yang6@mcgill.ca&gt;
</p>


<h3>References</h3>

<p>Yang, Y. and Zou, H. (2012).
&quot;An Efficient Algorithm for Computing The HHSVM and Its Generalizations.&quot;
<em>Journal of Computational and Graphical Statistics</em>, 22, 396-415.<br />
BugReport: <a href="https://github.com/emeryyi/gcdnet">https://github.com/emeryyi/gcdnet</a><br />
</p>
<p>Gu, Y., and Zou, H. (2016).
&quot;High-dimensional generalizations of asymmetric least squares regression and their applications.&quot;
<em>The Annals of Statistics</em>, 44(6), 2661â€“2694.<br />
</p>
<p>Friedman, J., Hastie, T., and Tibshirani, R. (2010).
&quot;Regularization paths for generalized linear models via coordinate descent.&quot;
<em>Journal of Statistical Software, 33, 1.</em><br />
<a href="https://www.jstatsoft.org/v33/i01/">https://www.jstatsoft.org/v33/i01/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FHT)
m1 &lt;- gcdnet(x = FHT$x, y = FHT$y, delta = 1, lambda2 = 0.1)
print(m1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
