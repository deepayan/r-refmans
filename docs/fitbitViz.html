<!DOCTYPE html><html lang="en"><head><title>Help for package fitbitViz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fitbitViz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base_url_request'><p>base function to return the data for the specified activity based on the url</p></a></li>
<li><a href='#compute_elapsed_time'><p>elapsed time in hours &amp; minutes &amp; seconds</p></a></li>
<li><a href='#crop_DEM'><p>Function to crop the AOI from the downloaded DEM .tif file</p></a></li>
<li><a href='#extend_AOI_buffer'><p>Extract the sf-object and raster extent based on a buffer (in meters)</p></a></li>
<li><a href='#extract_LOG_ID'><p>Extract the log-id (it's possible that I receive more than one id)</p></a></li>
<li><a href='#fitbit_data_type_by_date'><p>Fitbit data retrieval for Blood Oxygen Saturation, Heart Rate Variability, Breathing Rate, Temperature and Cardio Fitness Score (or VO2 Max) by Date</p></a></li>
<li><a href='#ggplot_each_date'><p>plot function for a single day (heart rate)</p></a></li>
<li><a href='#gps_lat_lon_to_LINESTRING'><p>Convert the GPS, TCX data to a LINESTRING</p></a></li>
<li><a href='#GPS_TCX_data'><p>The GPS-TCX data as a formated data.table</p></a></li>
<li><a href='#heart_rate_heatmap'><p>Heart Rate Intraday Heatmap (by extracting the 'min.', 'median' and 'max.' values of the day)</p></a></li>
<li><a href='#heart_rate_time_series'><p>heart rate activity time series</p></a></li>
<li><a href='#heart_rate_variability_sleep_time'><p>Heart Rate Variability during Sleep Time (the root mean square of successive differences)</p></a></li>
<li><a href='#inner_elapsed_time'><p>inner function of 'compute_elapsed_time'</p></a></li>
<li><a href='#leafGL_point_coords'><p>Create a Leafet map (including information pop-ups)</p></a></li>
<li><a href='#plot_data_type'><p>This plot function is used in the 'fitbit_data_type_by_date' internally to plot the 'spo2' and 'hrv' data types</p></a></li>
<li><a href='#rayshader_3d_DEM'><p>Rayshader 3-dimensional using the Copernicus DEM elevation data</p></a></li>
<li><a href='#refresh_token_app'><p>Refresh Token of an existing application</p></a></li>
<li><a href='#sleep_heatmap'><p>sleep data heatmap</p></a></li>
<li><a href='#sleep_single_day'><p>Sleep Data of single day</p></a></li>
<li><a href='#sleep_time_series'><p>Sleep Data Time Series</p></a></li>
<li><a href='#split_year_in_weeks'><p>function for the weeks (including the date-from and date-to)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'Fitbit' Visualizations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lampros Mouselimis &lt;mouselimislampros@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlampros/fitbitViz">https://github.com/mlampros/fitbitViz</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Connection to the 'Fitbit' Web API <a href="https://dev.fitbit.com/build/reference/web-api/">https://dev.fitbit.com/build/reference/web-api/</a> by including 'ggplot2' Visualizations, 'Leaflet' and 3-dimensional 'Rayshader' Maps. The 3-dimensional 'Rayshader' Map requires the installation of the 'CopernicusDEM' R package which includes the 30- and 90-meter elevation data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>update: apt-get -y update (deb)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glue, httr, jsonlite, ggplot2, lubridate, patchwork,
data.table, stats, viridis, scales, ggthemes, varian,
paletteer, XML, hms, leaflet, sf, rstudioapi, grDevices,
leafgl, raster (&ge; 3.6-3), terra, magrittr, rayshader, utils,
base64enc, lifecycle, reshape2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>CopernicusDEM, testthat (&ge; 3.0.0), knitr, rmarkdown, DT,
rgl, magick</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 07:40:05 UTC; lampros</td>
</tr>
<tr>
<td>Author:</td>
<td>Lampros Mouselimis
    <a href="https://orcid.org/0000-0002-8024-1546"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='base_url_request'>base function to return the data for the specified activity based on the url</h2><span id='topic+base_url_request'></span>

<h3>Description</h3>

<p>base function to return the data for the specified activity based on the url
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_url_request(
  url,
  oauth_token,
  show_nchar_case_error = 135,
  simplifyVector = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="base_url_request_+3A_url">url</code></td>
<td>
<p>a character string specifying the input url</p>
</td></tr>
<tr><td><code id="base_url_request_+3A_oauth_token">oauth_token</code></td>
<td>
<p>a character string specifying the authentication token</p>
</td></tr>
<tr><td><code id="base_url_request_+3A_show_nchar_case_error">show_nchar_case_error</code></td>
<td>
<p>an integer value specifying the number of characters to show in case of an error</p>
</td></tr>
<tr><td><code id="base_url_request_+3A_simplifyvector">simplifyVector</code></td>
<td>
<p>a boolean. Coerce JSON arrays containing only primitives into an atomic vector (see the documentation of the jsonlite::fromJSON() function)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class list
</p>

<hr>
<h2 id='compute_elapsed_time'>elapsed time in hours &amp; minutes &amp; seconds</h2><span id='topic+compute_elapsed_time'></span>

<h3>Description</h3>

<p>elapsed time in hours &amp; minutes &amp; seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_elapsed_time(time_start)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compute_elapsed_time_+3A_time_start">time_start</code></td>
<td>
<p>a numeric value specifying the start time</p>
</td></tr>
</table>


<h3>Value</h3>

<p>It does not return a value but only prints the time in form of a character string in the R session
</p>

<hr>
<h2 id='crop_DEM'>Function to crop the AOI from the downloaded DEM .tif file</h2><span id='topic+crop_DEM'></span>

<h3>Description</h3>

<p>Function to crop the AOI from the downloaded DEM .tif file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_DEM(tif_or_vrt_dem_file, sf_buffer_obj, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crop_DEM_+3A_tif_or_vrt_dem_file">tif_or_vrt_dem_file</code></td>
<td>
<p>a valid path to the elevation .tif or .vrt file</p>
</td></tr>
<tr><td><code id="crop_DEM_+3A_sf_buffer_obj">sf_buffer_obj</code></td>
<td>
<p>a simple features ('sf') object that will be used to crop the input elevation raster file ('tif_or_vrt_dem_file' parameter)</p>
</td></tr>
<tr><td><code id="crop_DEM_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class SpatRaster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#............................
# first extract the log-id(s)
#............................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

log_id = extract_LOG_ID(user_id = USER_ID,
                        token = token,
                        after_Date = '2021-03-13',
                        limit = 10,
                        sort = 'asc',
                        verbose = TRUE)
str(log_id)

#...................................
# then return the gps-ctx data.table
#...................................

res_tcx = GPS_TCX_data(log_id = log_id,
                       user_id = USER_ID,
                       token = token,
                       time_zone = 'Europe/Athens',
                       verbose = TRUE)
str(res_tcx)

#....................................................
# then compute the sf-object buffer and raster-extend
#....................................................

sf_rst_ext = extend_AOI_buffer(dat_gps_tcx = res_tcx,
                               buffer_in_meters = 1000,
                               CRS = 4326,
                               verbose = TRUE)
sf_rst_ext

#...............................................................
# Download the Copernicus DEM 30m elevation data because it has
# a better resolution, it takes a bit longer to download because
# the .tif file size is bigger
#...............................................................

dem_dir = tempdir()
# dem_dir

dem30 = CopernicusDEM::aoi_geom_save_tif_matches(sf_or_file = sf_rst_ext$sfc_obj,
                                                 dir_save_tifs = dem_dir,
                                                 resolution = 30,
                                                 crs_value = 4326,
                                                 threads = parallel::detectCores(),
                                                 verbose = TRUE)

TIF = list.files(dem_dir, pattern = '.tif', full.names = T)
# TIF

if (length(TIF) &gt; 1) {

  #....................................................
  # create a .VRT file if I have more than 1 .tif files
  #....................................................

  file_out = file.path(dem_dir, 'VRT_mosaic_FILE.vrt')

  vrt_dem30 = create_VRT_from_dir(dir_tifs = dem_dir,
                                  output_path_VRT = file_out,
                                  verbose = TRUE)
}

if (length(TIF) == 1) {

  #..................................................
  # if I have a single .tif file keep the first index
  #..................................................

  file_out = TIF[1]
}

raysh_rst = crop_DEM(tif_or_vrt_dem_file = file_out,
                     sf_buffer_obj = sf_rst_ext$sfc_obj,
                     verbose = TRUE)

terra::plot(raysh_rst)


## End(Not run)
</code></pre>

<hr>
<h2 id='extend_AOI_buffer'>Extract the sf-object and raster extent based on a buffer (in meters)</h2><span id='topic+extend_AOI_buffer'></span>

<h3>Description</h3>

<p>Extract the sf-object and raster extent based on a buffer (in meters)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_AOI_buffer(
  dat_gps_tcx,
  buffer_in_meters = 1000,
  CRS = 4326,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extend_AOI_buffer_+3A_dat_gps_tcx">dat_gps_tcx</code></td>
<td>
<p>this parameter corresponds to the output data.table of the 'GPS_TCX_data()' function</p>
</td></tr>
<tr><td><code id="extend_AOI_buffer_+3A_buffer_in_meters">buffer_in_meters</code></td>
<td>
<p>an integer value specifying the buffer in meters. The bounding box of the input coordinates (longitudes, latitudes) will be extended by that many meters. The default value is 1000 meters.</p>
</td></tr>
<tr><td><code id="extend_AOI_buffer_+3A_crs">CRS</code></td>
<td>
<p>an integer specifying the Coordinates Reference System. The recommended value for this data is 4326 (which is also the default value)</p>
</td></tr>
<tr><td><code id="extend_AOI_buffer_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create the buffer in meters using the 'sf' package I had to transform to another projection - by default I've used 7801 - as suggested in the following stackoverflow thread, https://stackoverflow.com/a/54754935/8302386
</p>


<h3>Value</h3>

<p>an object of class list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#............................
# first extract the log-id(s)
#............................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

log_id = extract_LOG_ID(user_id = USER_ID,
                        token = token,
                        after_Date = '2021-03-13',
                        limit = 10,
                        sort = 'asc',
                        verbose = TRUE)
str(log_id)

#...................................
# then return the gps-ctx data.table
#...................................

res_tcx = GPS_TCX_data(log_id = log_id,
                       user_id = USER_ID,
                       token = token,
                       time_zone = 'Europe/Athens',
                       verbose = TRUE)
str(res_tcx)

#....................................................
# then compute the sf-object buffer and raster-extend
#....................................................

sf_rst_ext = extend_AOI_buffer(dat_gps_tcx = res_tcx,
                               buffer_in_meters = 1000,
                               CRS = 4326,
                               verbose = TRUE)
sf_rst_ext


## End(Not run)
</code></pre>

<hr>
<h2 id='extract_LOG_ID'>Extract the log-id (it's possible that I receive more than one id)</h2><span id='topic+extract_LOG_ID'></span>

<h3>Description</h3>

<p>Extract the log-id (it's possible that I receive more than one id)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_LOG_ID(
  user_id,
  token,
  after_Date = "2021-03-13",
  limit = 10,
  sort = "asc",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_LOG_ID_+3A_user_id">user_id</code></td>
<td>
<p>a character string specifying the encoded ID of the user. For instance '99xxxx' of the following URL 'https://www.fitbit.com/user/99xxxx' of the user's account corresponds to the 'user_id'</p>
</td></tr>
<tr><td><code id="extract_LOG_ID_+3A_token">token</code></td>
<td>
<p>a character string specifying the secret token that a user receives when registers a new application in https://dev.fitbit.com/apps</p>
</td></tr>
<tr><td><code id="extract_LOG_ID_+3A_after_date">after_Date</code></td>
<td>
<p>a character string specifying the Date after which the log-ids will be returned. For instance, the date '2021-12-31' where the input order is 'year-month-day'</p>
</td></tr>
<tr><td><code id="extract_LOG_ID_+3A_limit">limit</code></td>
<td>
<p>an integer specifying the total of log-id's to return. The default value is 10</p>
</td></tr>
<tr><td><code id="extract_LOG_ID_+3A_sort">sort</code></td>
<td>
<p>a character string specifying the order ('asc', 'desc') based on which the output log-id's should be sorted</p>
</td></tr>
<tr><td><code id="extract_LOG_ID_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer specifying the log ID
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

log_id = extract_LOG_ID(user_id = USER_ID,
                        token = token,
                        after_Date = '2021-03-13',
                        limit = 10,
                        sort = 'asc',
                        verbose = TRUE)
log_id


## End(Not run)
</code></pre>

<hr>
<h2 id='fitbit_data_type_by_date'>Fitbit data retrieval for Blood Oxygen Saturation, Heart Rate Variability, Breathing Rate, Temperature and Cardio Fitness Score (or VO2 Max) by Date</h2><span id='topic+fitbit_data_type_by_date'></span>

<h3>Description</h3>

<p>Fitbit data retrieval for Blood Oxygen Saturation, Heart Rate Variability, Breathing Rate, Temperature and Cardio Fitness Score (or VO2 Max) by Date
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitbit_data_type_by_date(
  user_id,
  token,
  date,
  type = "spo2",
  plot = FALSE,
  show_nchar_case_error = 135
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitbit_data_type_by_date_+3A_user_id">user_id</code></td>
<td>
<p>a character string specifying the encoded ID of the user. For instance '99xxxx' of the following URL 'https://www.fitbit.com/user/99xxxx' of the user's account corresponds to the 'user_id'</p>
</td></tr>
<tr><td><code id="fitbit_data_type_by_date_+3A_token">token</code></td>
<td>
<p>a character string specifying the secret token that a user receives when registers a new application in https://dev.fitbit.com/apps</p>
</td></tr>
<tr><td><code id="fitbit_data_type_by_date_+3A_date">date</code></td>
<td>
<p>a character string specifying a Date. For instance, the date '2021-12-31' where the input order is 'year-month-day'</p>
</td></tr>
<tr><td><code id="fitbit_data_type_by_date_+3A_type">type</code></td>
<td>
<p>a character string specifying the fitbit data type. One of 'spo2', 'hrv', 'br', 'temp', 'cardioscore'. See the 'details' and 'references' sections for more information</p>
</td></tr>
<tr><td><code id="fitbit_data_type_by_date_+3A_plot">plot</code></td>
<td>
<p>a boolean. If TRUE then the minutes data will be plotted. This parameter is applicable only to the 'spo2' and 'hrv' types because they return minute data (see the details section for more information). The remaining types ('br', 'temp', 'cardioscore') return daily data.</p>
</td></tr>
<tr><td><code id="fitbit_data_type_by_date_+3A_show_nchar_case_error">show_nchar_case_error</code></td>
<td>
<p>an integer that specifies the number of characters that will be returned in case on an error. The default value is 135 characters.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>'spo2' (<em>Blood Oxygen Saturation</em>)</dt><dd><p>This endpoint returns the SpO2 intraday data for a single date. SpO2 applies specifically to a user's &quot;main sleep&quot;, which is the longest single period of time asleep on a given date. Spo2 values are calculated on a 5-minute exponentially-moving average</p>
</dd>
<dt>'hrv' (<em>Heart Rate Variability</em>)</dt><dd><p>This endpoint returns the Heart Rate Variability (HRV) intraday data for a single date. HRV data applies specifically to a user's &quot;main sleep&quot;, which is the longest single period of time asleep on a given date. It measures the HRV rate at various times and returns Root Mean Square of Successive Differences (rmssd), Low Frequency (LF), High Frequency (HF), and Coverage data for a given measurement. Rmssd measures short-term variability in your heart rate while asleep. LF and HF capture the power in interbeat interval fluctuations within either high frequency or low frequency bands. Finally, coverage refers to data completeness in terms of the number of interbeat intervals</p>
</dd>
<dt>'br' (<em>Breathing Rate</em>)</dt><dd><p>This endpoint returns intraday breathing rate data for a specified date. It measures the average breathing rate throughout the day and categories your breathing rate by sleep stage. Sleep stages vary between light sleep, deep sleep, REM sleep, and full sleep</p>
</dd>
<dt>'temp' (<em>Temperature</em>)</dt><dd><p>This endpoint returns the Temperature (Skin) data for a single date. It only returns a value for dates on which the Fitbit device was able to record Temperature (skin) data. Temperature (Skin) data applies specifically to a user's &quot;main sleep&quot;, which is the longest single period of time asleep on a given date</p>
</dd>
<dt>'cardioscore' (<em>Cardio Fitness Score or VO2 Max</em>)</dt><dd><p>The Cardio Fitness Score (also known as VO2 Max) endpoints are used for querying the maximum or optimum rate at which the user's heart, lungs, and muscles can effectively use oxygen during exercise</p>
</dd>
</dl>

<p>If the 'type' parameter is one of 'spo2' or 'hrv' and the 'plot' parameter is set to TRUE then the results will appear as a line plot. In case of 'hrv' a multiplot with the following variables will be displayed:
</p>

<dl>
<dt>'rmssd'</dt><dd><p><em>The Root Mean Square of Successive Differences (RMSSD) between heart beats. It measures short-term variability in the user's heart rate in milliseconds (ms)</em></p>
</dd>
<dt>'coverage'</dt><dd><p><em>Data completeness in terms of the number of interbeat intervals</em></p>
</dd>
<dt>'hf'</dt><dd><p><em>The power in interbeat interval fluctuations within the high frequency band (0.15 Hz - 0.4 Hz)</em></p>
</dd>
<dt>'lf'</dt><dd><p><em>The power in interbeat interval fluctuations within the low frequency band (0.04 Hz - 0.15 Hz)</em></p>
</dd>
</dl>



<h3>Value</h3>

<p>a data.frame
</p>


<h3>References</h3>

<p>https://dev.fitbit.com/build/reference/web-api/intraday/get-spo2-intraday-by-date/
</p>
<p>https://dev.fitbit.com/build/reference/web-api/intraday/get-hrv-intraday-by-date/
</p>
<p>https://dev.fitbit.com/build/reference/web-api/intraday/get-br-intraday-by-date/
</p>
<p>https://dev.fitbit.com/build/reference/web-api/temperature/get-temperature-skin-summary-by-date
</p>
<p>https://dev.fitbit.com/build/reference/web-api/cardio-fitness-score/get-vo2max-summary-by-date/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

res_type = fitbit_data_type_by_date(user_id = USER_ID,
                                    token = token,
                                    date = '2022-10-12',
                                    type = 'spo2',
                                    plot = TRUE,
                                    show_nchar_case_error = 135)
res_type


## End(Not run)
</code></pre>

<hr>
<h2 id='ggplot_each_date'>plot function for a single day (heart rate)</h2><span id='topic+ggplot_each_date'></span>

<h3>Description</h3>

<p>plot function for a single day (heart rate)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_each_date(date_intraday, date)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggplot_each_date_+3A_date_intraday">date_intraday</code></td>
<td>
<p>a data.table of Intraday Dates of heart rate measurements</p>
</td></tr>
<tr><td><code id="ggplot_each_date_+3A_date">date</code></td>
<td>
<p>a character string specifying a Date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot object of class ggplot2
</p>

<hr>
<h2 id='gps_lat_lon_to_LINESTRING'>Convert the GPS, TCX data to a LINESTRING</h2><span id='topic+gps_lat_lon_to_LINESTRING'></span>

<h3>Description</h3>

<p>Convert the GPS, TCX data to a LINESTRING
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gps_lat_lon_to_LINESTRING(
  dat_gps_tcx,
  CRS = 4326,
  verbose = FALSE,
  time_split_asc_desc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gps_lat_lon_to_LINESTRING_+3A_dat_gps_tcx">dat_gps_tcx</code></td>
<td>
<p>this parameter corresponds to the output data.table of the 'GPS_TCX_data()' function</p>
</td></tr>
<tr><td><code id="gps_lat_lon_to_LINESTRING_+3A_crs">CRS</code></td>
<td>
<p>an integer specifying the Coordinates Reference System. The recommended value for this data is 4326 (which is also the default value)</p>
</td></tr>
<tr><td><code id="gps_lat_lon_to_LINESTRING_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
<tr><td><code id="gps_lat_lon_to_LINESTRING_+3A_time_split_asc_desc">time_split_asc_desc</code></td>
<td>
<p>if NULL then the maximum altitude coordinates point will be used as a split point of the route, otherwise the user can give a lubridate 'hours-minutes-seconds' object such as: lubridate::hms('17:05:00')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Separate the Ascending and Descending coordinate points into 2 groups and give a different color to the Ascending and Descending routes
</p>


<h3>Value</h3>

<p>an object of class list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#............................
# first extract the log-id(s)
#............................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

log_id = extract_LOG_ID(user_id = USER_ID,
                        token = token,
                        after_Date = '2021-03-13',
                        limit = 10,
                        sort = 'asc',
                        verbose = TRUE)
str(log_id)

#...................................
# then return the gps-ctx data.table
#...................................

res_tcx = GPS_TCX_data(log_id = log_id,
                       user_id = USER_ID,
                       token = token,
                       time_zone = 'Europe/Athens',
                       verbose = TRUE)
str(res_tcx)


#..................................................................
# By using using the maximum altitude as a split point of the route
#..................................................................

linestring_dat_init = gps_lat_lon_to_LINESTRING(dat_gps_tcx = res_tcx,
                                                CRS = 4326,
                                                time_split_asc_desc = NULL,
                                                verbose = TRUE)

#.................................................................
# By using a customized split of the route (ascending, descending)
#.................................................................

linestring_dat_lubr = gps_lat_lon_to_LINESTRING(dat_gps_tcx = res_tcx,
                                                CRS = 4326,
                                                time_split_asc_desc = lubridate::hms('17:05:00'),
                                                verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='GPS_TCX_data'>The GPS-TCX data as a formated data.table</h2><span id='topic+GPS_TCX_data'></span>

<h3>Description</h3>

<p>The GPS-TCX data as a formated data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPS_TCX_data(
  log_id,
  user_id,
  token,
  time_zone = "Europe/Athens",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GPS_TCX_data_+3A_log_id">log_id</code></td>
<td>
<p>the returned log-id of the 'extract_LOG_ID()' function</p>
</td></tr>
<tr><td><code id="GPS_TCX_data_+3A_user_id">user_id</code></td>
<td>
<p>a character string specifying the encoded ID of the user. For instance '99xxxx' of the following URL 'https://www.fitbit.com/user/99xxxx' of the user's account corresponds to the 'user_id'</p>
</td></tr>
<tr><td><code id="GPS_TCX_data_+3A_token">token</code></td>
<td>
<p>a character string specifying the secret token that a user receives when registers a new application in https://dev.fitbit.com/apps</p>
</td></tr>
<tr><td><code id="GPS_TCX_data_+3A_time_zone">time_zone</code></td>
<td>
<p>a character string specifying the time zone parameter ('tz') as is defined in the 'lubridate::ymd_hms()' function</p>
</td></tr>
<tr><td><code id="GPS_TCX_data_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either NULL or an object of class data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#............................
# first extract the log-id(s)
#............................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

log_id = extract_LOG_ID(user_id = USER_ID,
                        token = token,
                        after_Date = '2021-03-13',
                        limit = 10,
                        sort = 'asc',
                        verbose = TRUE)
str(log_id)

#...................................
# then return the gps-ctx data.table
#...................................

res_tcx = GPS_TCX_data(log_id = log_id,
                       user_id = USER_ID,
                       token = token,
                       time_zone = 'Europe/Athens',
                       verbose = TRUE)
str(res_tcx)


## End(Not run)
</code></pre>

<hr>
<h2 id='heart_rate_heatmap'>Heart Rate Intraday Heatmap (by extracting the 'min.', 'median' and 'max.' values of the day)</h2><span id='topic+heart_rate_heatmap'></span>

<h3>Description</h3>

<p>Heart Rate Intraday Heatmap (by extracting the 'min.', 'median' and 'max.' values of the day)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heart_rate_heatmap(heart_rate_intraday_data, angle_x_axis = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heart_rate_heatmap_+3A_heart_rate_intraday_data">heart_rate_intraday_data</code></td>
<td>
<p>a list object specifying the intraday heart rate data (this is one of the sublists returned from the 'heart_rate_time_series' function)</p>
</td></tr>
<tr><td><code id="heart_rate_heatmap_+3A_angle_x_axis">angle_x_axis</code></td>
<td>
<p>an integer specifying the angle of the x-axis labels. The default values is 0 (it can take for instance values such as 45, 90 etc.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot object of class ggplot2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#...........................................
# first compute the heart rate intraday data
#...........................................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

heart_dat = heart_rate_time_series(user_id = USER_ID,
                                   token = token,
                                   date_start = '2021-03-09',
                                   date_end = '2021-03-16',
                                   time_start = '00:00',
                                   time_end = '23:59',
                                   detail_level = '1min',
                                   ggplot_intraday = TRUE,
                                   verbose = TRUE,
                                   show_nchar_case_error = 135)

#..........................................
# use the heart-rate-intraday data as input
# to the 'heart_rate_heatmap' function
#..........................................

hrt_heat = heart_rate_heatmap(heart_rate_intraday_data =  heart_dat$heart_rate_intraday,
                              angle_x_axis = 0)
hrt_heat


## End(Not run)
</code></pre>

<hr>
<h2 id='heart_rate_time_series'>heart rate activity time series</h2><span id='topic+heart_rate_time_series'></span>

<h3>Description</h3>

<p>heart rate activity time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heart_rate_time_series(
  user_id,
  token,
  date_start,
  date_end,
  time_start = "00:00",
  time_end = "23:59",
  detail_level = "1min",
  ggplot_intraday = FALSE,
  ggplot_ncol = NULL,
  ggplot_nrow = NULL,
  verbose = FALSE,
  show_nchar_case_error = 135
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heart_rate_time_series_+3A_user_id">user_id</code></td>
<td>
<p>a character string specifying the encoded ID of the user. For instance '99xxxx' of the following URL 'https://www.fitbit.com/user/99xxxx' of the user's account corresponds to the 'user_id'</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_token">token</code></td>
<td>
<p>a character string specifying the secret token that a user receives when registers a new application in https://dev.fitbit.com/apps</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_date_start">date_start</code></td>
<td>
<p>a character string specifying a start Date. For instance, the date '2021-12-31' where the input order is 'year-month-day'</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_date_end">date_end</code></td>
<td>
<p>a character string specifying a end Date. For instance, the date '2021-12-31' where the input order is 'year-month-day'</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_time_start">time_start</code></td>
<td>
<p>a character string specifying the start time. For instance, the time '00:00' where the input order is 'hours-minutes'</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_time_end">time_end</code></td>
<td>
<p>a character string specifying the end time. For instance, the time '23:59' where the input order is 'hours-minutes'</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_detail_level">detail_level</code></td>
<td>
<p>a character string specifying the detail level of the heart rate time series. It can be either '1min' or '1sec', for 1-minute and 1-second intervals</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_ggplot_intraday">ggplot_intraday</code></td>
<td>
<p>a boolean. If TRUE then the ggplot of the heart rate time series will be returned too</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_ggplot_ncol">ggplot_ncol</code></td>
<td>
<p>either NULL or an integer specifying the number of columns of the output ggplot</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_ggplot_nrow">ggplot_nrow</code></td>
<td>
<p>either NULL or an integer specifying the number of rows of the output ggplot</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
<tr><td><code id="heart_rate_time_series_+3A_show_nchar_case_error">show_nchar_case_error</code></td>
<td>
<p>an integer that specifies the number of characters that will be returned in case on an error. The default value is 135 characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

heart_dat = heart_rate_time_series(user_id = USER_ID,
                                   token = token,
                                   date_start = '2021-03-09',
                                   date_end = '2021-03-16',
                                   time_start = '00:00',
                                   time_end = '23:59',
                                   detail_level = '1min',
                                   ggplot_intraday = TRUE,
                                   verbose = TRUE,
                                   show_nchar_case_error = 135)
heart_dat$plt
heart_dat$heart_rate
heart_dat$heart_rate_intraday


## End(Not run)
</code></pre>

<hr>
<h2 id='heart_rate_variability_sleep_time'>Heart Rate Variability during Sleep Time (the root mean square of successive differences)</h2><span id='topic+heart_rate_variability_sleep_time'></span>

<h3>Description</h3>

<p>'r lifecycle::badge(&quot;deprecated&quot;)'
</p>
<p>This function was deprecated, so please use the 'fitbit_data_type_by_date()' function instead with the 'type' parameter set to 'hrv' (Heart Rate Variability). See the documentation and the example section of the 'fitbit_data_type_by_date()' function for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heart_rate_variability_sleep_time(
  heart_rate_data,
  sleep_begin = "00H 40M 0S",
  sleep_end = "08H 00M 0S",
  ggplot_hr_var = TRUE,
  angle_x_axis = 45
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heart_rate_variability_sleep_time_+3A_heart_rate_data">heart_rate_data</code></td>
<td>
<p>a list object. This is the output of the 'heart_rate_time_series()' function</p>
</td></tr>
<tr><td><code id="heart_rate_variability_sleep_time_+3A_sleep_begin">sleep_begin</code></td>
<td>
<p>a character string specifying the begin of the sleep time. For instance, the time &quot;00H 40M 0S&quot; where the input order is 'hours-minutes-seconds' and the format corresponds to the 'lubridate::hms()' function</p>
</td></tr>
<tr><td><code id="heart_rate_variability_sleep_time_+3A_sleep_end">sleep_end</code></td>
<td>
<p>a character string specifying the end of the sleep time. For instance, the time &quot;08H 00M 0S&quot; where the input order is 'hours-minutes-seconds' and the format corresponds to the 'lubridate::hms()' function</p>
</td></tr>
<tr><td><code id="heart_rate_variability_sleep_time_+3A_ggplot_hr_var">ggplot_hr_var</code></td>
<td>
<p>a boolean. If TRUE then the ggplot of the heart rate variability will be returned</p>
</td></tr>
<tr><td><code id="heart_rate_variability_sleep_time_+3A_angle_x_axis">angle_x_axis</code></td>
<td>
<p>an integer specifying the angle of the x-axis labels. The default values is 45 (it can take for instance values such as 0, 90 etc.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I use the '1min' rather than the '1sec' interval because it is consistent (it shows the 1-minute differences), whereas in case of '1sec' the difference between observations varies between 1 second and less than 60 seconds
</p>
<p>This function calculates the root mean square of successive differences (RMSSD) and a higher heart rate variability is linked with better health
</p>
<p>Based on the Fitbit application information weblink and the Wikipedia article (https://en.wikipedia.org/wiki/Heart_rate_variability) the heart rate variability is computed normally in ms (milliseconds)
</p>


<h3>Value</h3>

<p>an object of class list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#...........................................
# first compute the heart rate intraday data
#...........................................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

heart_dat = heart_rate_time_series(user_id = USER_ID,
                                   token = token,
                                   date_start = '2021-03-09',
                                   date_end = '2021-03-16',
                                   time_start = '00:00',
                                   time_end = '23:59',
                                   detail_level = '1min',
                                   ggplot_intraday = TRUE,
                                   verbose = TRUE,
                                   show_nchar_case_error = 135)

#.......................
# heart rate variability
#.......................

hrt_rt_var = heart_rate_variability_sleep_time(heart_rate_data = heart_dat,
                                               sleep_begin = "00H 40M 0S",
                                               sleep_end = "08H 00M 0S",
                                               ggplot_hr_var = TRUE,
                                               angle_x_axis = 25)

hrt_rt_var


## End(Not run)
</code></pre>

<hr>
<h2 id='inner_elapsed_time'>inner function of 'compute_elapsed_time'</h2><span id='topic+inner_elapsed_time'></span>

<h3>Description</h3>

<p>inner function of 'compute_elapsed_time'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_elapsed_time(secs, estimated = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inner_elapsed_time_+3A_secs">secs</code></td>
<td>
<p>a numeric value specifying the seconds</p>
</td></tr>
<tr><td><code id="inner_elapsed_time_+3A_estimated">estimated</code></td>
<td>
<p>a boolean. If TRUE then the output label becomes the 'Estimated time'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character string showing the estimated or elapsed time
</p>

<hr>
<h2 id='leafGL_point_coords'>Create a Leafet map (including information pop-ups)</h2><span id='topic+leafGL_point_coords'></span>

<h3>Description</h3>

<p>Create a Leafet map (including information pop-ups)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leafGL_point_coords(
  dat_gps_tcx,
  color_points_column = "AltitudeMeters",
  provider = leaflet::providers$Esri.WorldImagery,
  option_viewer = rstudioapi::viewer,
  CRS = 4326
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leafGL_point_coords_+3A_dat_gps_tcx">dat_gps_tcx</code></td>
<td>
<p>this parameter corresponds to the output data.table of the 'GPS_TCX_data()' function</p>
</td></tr>
<tr><td><code id="leafGL_point_coords_+3A_color_points_column">color_points_column</code></td>
<td>
<p>a character string specifying the column of the output data.table ('GPS_TCX_data()' function) that is used in the map-markers. The default value is 'AltitudeMeters' but it can be any column of type numeric</p>
</td></tr>
<tr><td><code id="leafGL_point_coords_+3A_provider">provider</code></td>
<td>
<p>either a character string specifying a leaflet provider (such as 'Esri.WorldImagery') or a direct call to the leaflet provider list (such as leaflet::providers$Esri.WorldImagery). The default value is leaflet::providers$Esri.WorldImagery</p>
</td></tr>
<tr><td><code id="leafGL_point_coords_+3A_option_viewer">option_viewer</code></td>
<td>
<p>either NULL or rstudioapi::viewer. If NULL then the output map will be shown in the web browser</p>
</td></tr>
<tr><td><code id="leafGL_point_coords_+3A_crs">CRS</code></td>
<td>
<p>an integer specifying the Coordinates Reference System. The recommended value for this data is 4326 (which is also the default value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a leaflet map of class 'leaflet'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#............................
# first extract the log-id(s)
#............................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

log_id = extract_LOG_ID(user_id = USER_ID,
                        token = token,
                        after_Date = '2021-03-13',
                        limit = 10,
                        sort = 'asc',
                        verbose = TRUE)
str(log_id)

#...................................
# then return the gps-ctx data.table
#...................................

res_tcx = GPS_TCX_data(log_id = log_id,
                       user_id = USER_ID,
                       token = token,
                       time_zone = 'Europe/Athens',
                       verbose = TRUE)
str(res_tcx)


#........................
# then visualize the data
#........................

res_lft = leafGL_point_coords(dat_gps_tcx = res_tcx,
                              color_points_column = 'AltitudeMeters',
                              provider = leaflet::providers$Esri.WorldImagery,
                              option_viewer = rstudioapi::viewer,
                              CRS = 4326)
res_lft


## End(Not run)
</code></pre>

<hr>
<h2 id='plot_data_type'>This plot function is used in the 'fitbit_data_type_by_date' internally to plot the 'spo2' and 'hrv' data types</h2><span id='topic+plot_data_type'></span>

<h3>Description</h3>

<p>This plot function is used in the 'fitbit_data_type_by_date' internally to plot the 'spo2' and 'hrv' data types
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_data_type(dat_type_min, type)
</code></pre>

<hr>
<h2 id='rayshader_3d_DEM'>Rayshader 3-dimensional using the Copernicus DEM elevation data</h2><span id='topic+rayshader_3d_DEM'></span>

<h3>Description</h3>

<p>Rayshader 3-dimensional using the Copernicus DEM elevation data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rayshader_3d_DEM(
  rst_buf,
  rst_ext,
  linestring_ASC_DESC = NULL,
  elevation_sample_points = NULL,
  zoom = 0.5,
  windowsize = c(1600, 1000),
  add_shadow_rescale_original = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rayshader_3d_DEM_+3A_rst_buf">rst_buf</code></td>
<td>
<p>this parameter corresponds to the 'sfc_obj' object of the 'extend_AOI_buffer()' function</p>
</td></tr>
<tr><td><code id="rayshader_3d_DEM_+3A_rst_ext">rst_ext</code></td>
<td>
<p>this parameter corresponds to the 'raster_obj_extent' object of the 'extend_AOI_buffer()' function</p>
</td></tr>
<tr><td><code id="rayshader_3d_DEM_+3A_linestring_asc_desc">linestring_ASC_DESC</code></td>
<td>
<p>If NULL then this parameter will be ignored. Otherwise, it can be an 'sf' object or a named list of length 2 (that corresponds to the output of the 'gps_lat_lon_to_LINESTRING()' function)</p>
</td></tr>
<tr><td><code id="rayshader_3d_DEM_+3A_elevation_sample_points">elevation_sample_points</code></td>
<td>
<p>if NULL then this parameter will be ignored. Otherwise, it corresponds to a data.table with column names 'latitude', 'longitude' and 'AltitudeMeters'. For instance, it can consist of 3 or 4 rows that will be displayed as vertical lines in the 3-dimensionsal map to visualize sample locations of the route (the latitudes and longitudes must exist in the output data.table of the 'GPS_TCX_data()' function)</p>
</td></tr>
<tr><td><code id="rayshader_3d_DEM_+3A_zoom">zoom</code></td>
<td>
<p>a float number. Lower values increase the 3-dimensional DEM output. The default value is 0.5</p>
</td></tr>
<tr><td><code id="rayshader_3d_DEM_+3A_windowsize">windowsize</code></td>
<td>
<p>a numeric vector specifying the window dimensions (x,y) of the output 3-dimensional map. The default vector is c(1600, 1000)</p>
</td></tr>
<tr><td><code id="rayshader_3d_DEM_+3A_add_shadow_rescale_original">add_shadow_rescale_original</code></td>
<td>
<p>a boolean. If TRUE, then 'hillshade' will be scaled to match the dimensions of 'shadowmap'. See also the 'rayshader::add_shadow()' function for more information.</p>
</td></tr>
<tr><td><code id="rayshader_3d_DEM_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>it doesn't return an object but it displays a 3-dimensional 'rayshader' object
</p>


<h3>References</h3>

<p>https://www.tylermw.com/a-step-by-step-guide-to-making-3d-maps-with-satellite-imagery-in-r/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#............................
# first extract the log-id(s)
#............................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

log_id = extract_LOG_ID(user_id = USER_ID,
                        token = token,
                        after_Date = '2021-03-13',
                        limit = 10,
                        sort = 'asc',
                        verbose = TRUE)
str(log_id)

#...................................
# then return the gps-ctx data.table
#...................................

res_tcx = GPS_TCX_data(log_id = log_id,
                       user_id = USER_ID,
                       token = token,
                       time_zone = 'Europe/Athens',
                       verbose = TRUE)
str(res_tcx)

#....................................................
# then compute the sf-object buffer and raster-extend
#....................................................

sf_rst_ext = extend_AOI_buffer(dat_gps_tcx = res_tcx,
                               buffer_in_meters = 1000,
                               CRS = 4326,
                               verbose = TRUE)
sf_rst_ext

#...............................................................
# Download the Copernicus DEM 30m elevation data because it has
# a better resolution, it takes a bit longer to download because
# the .tif file size is bigger
#...............................................................

dem_dir = tempdir()
# dem_dir

dem30 = CopernicusDEM::aoi_geom_save_tif_matches(sf_or_file = sf_rst_ext$sfc_obj,
                                                 dir_save_tifs = dem_dir,
                                                 resolution = 30,
                                                 crs_value = 4326,
                                                 threads = parallel::detectCores(),
                                                 verbose = TRUE)

TIF = list.files(dem_dir, pattern = '.tif', full.names = T)
# TIF

if (length(TIF) &gt; 1) {

  #....................................................
  # create a .VRT file if I have more than 1 .tif files
  #....................................................

  file_out = file.path(dem_dir, 'VRT_mosaic_FILE.vrt')

  vrt_dem30 = create_VRT_from_dir(dir_tifs = dem_dir,
                                  output_path_VRT = file_out,
                                  verbose = TRUE)
}

if (length(TIF) == 1) {

  #..................................................
  # if I have a single .tif file keep the first index
  #..................................................

  file_out = TIF[1]
}

raysh_rst = crop_DEM(tif_or_vrt_dem_file = file_out,
                     sf_buffer_obj = sf_rst_ext$sfc_obj,
                     verbose = TRUE)

# terra::plot(raysh_rst)


#................................................................
# create the 'elevation_sample_points' data.table parameter based
# on the min., middle  and max. altitude of the 'res_tcx' data
#................................................................

idx_3m = c(which.min(res_tcx$AltitudeMeters),
           as.integer(length(res_tcx$AltitudeMeters) / 2),
           which.max(res_tcx$AltitudeMeters))

cols_3m = c('latitude', 'longitude', 'AltitudeMeters')
dat_3m = res_tcx[idx_3m, ..cols_3m]
# dat_3m

#...............................................................
# Split the route in 2 parts based on the maximum altitude value
#...............................................................

linestring_dat = gps_lat_lon_to_LINESTRING(dat_gps_tcx = res_tcx,
                                           CRS = 4326,
                                           time_split_asc_desc = NULL,
                                           verbose = TRUE)

#.....................................................
# Conversion of the 'SpatRaster' to a raster object
# because the 'rayshader' package accepts only rasters
#.....................................................

rst_obj = raster::raster(raysh_rst)
raster::projection(rst_obj) &lt;- terra::crs(raysh_rst, proj = TRUE)


#.....................................
# open the 3-dimensional rayshader map
#.....................................

ray_out = rayshader_3d_DEM(rst_buf = rst_obj,
                           rst_ext = sf_rst_ext$raster_obj_extent,
                           linestring_ASC_DESC = linestring_dat,
                           elevation_sample_points = dat_3m,
                           zoom = 0.5,
                           windowsize = c(1600, 1000),
                           add_shadow_rescale_original = FALSE,
                           verbose = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='refresh_token_app'>Refresh Token of an existing application</h2><span id='topic+refresh_token_app'></span>

<h3>Description</h3>

<p>Refresh Token of an existing application
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refresh_token_app(client_id, client_secret, refresh_token)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="refresh_token_app_+3A_client_id">client_id</code></td>
<td>
<p>a character string specifying the 'client_id' of the registered (existing) Fitbit application</p>
</td></tr>
<tr><td><code id="refresh_token_app_+3A_client_secret">client_secret</code></td>
<td>
<p>a character string specifying the 'client_secret' of the registered (existing) Fitbit application</p>
</td></tr>
<tr><td><code id="refresh_token_app_+3A_refresh_token">refresh_token</code></td>
<td>
<p>a character string specifying the 'refresh_token' of the registered (existing) Fitbit application</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A registered Fitbit application has a time limit of 8 hours. Therefore, the user has to refresh the token after the expiration using the 'client_id', 'client_secret' and 'refresh_token' that it's available for the registered application.
Based on the Fitbit API Documentation &quot;After the Access Token expiration time has passed your requests will receive a 401 HTTP error. When this happens, your app should use the Refresh Token to get a new pair of tokens&quot;
</p>


<h3>Value</h3>

<p>a named list that includes access_token, expires_in, refresh_token, scope, token_type, user_id
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

# client id, client secret and refresh token of
# the existing Fitbit Application
Client_ID = 'xxxxxx'
Client_SECRET = 'xxxxxxxxxxxxxxxxxx'
Refresh_TOKEN = 'xxxxxxxxxxxxxxxxxxxxxxxx'

# refresh the token
res_token = refresh_token_app(client_id = Client_ID,
                              client_secret = Client_SECRET,
                              refresh_token = Refresh_TOKEN)

res_token

# use the updated token to a function

USER_ID = '99xxxx'
new_TOKEN = res_token$access_token,

res_type = fitbit_data_type_by_date(user_id = USER_ID,
                                    token = new_TOKEN,
                                    date = '2022-10-12',
                                    type = 'spo2',
                                    show_nchar_case_error = 135)

## End(Not run)
</code></pre>

<hr>
<h2 id='sleep_heatmap'>sleep data heatmap</h2><span id='topic+sleep_heatmap'></span>

<h3>Description</h3>

<p>sleep data heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sleep_heatmap(level_data, angle_x_axis = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sleep_heatmap_+3A_level_data">level_data</code></td>
<td>
<p>a data.table specifying the input level data</p>
</td></tr>
<tr><td><code id="sleep_heatmap_+3A_angle_x_axis">angle_x_axis</code></td>
<td>
<p>a float number specifying the angle of the x-axis text of the output ggplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot object of class ggplot2
</p>

<hr>
<h2 id='sleep_single_day'>Sleep Data of single day</h2><span id='topic+sleep_single_day'></span>

<h3>Description</h3>

<p>Sleep Data of single day
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sleep_single_day(
  user_id,
  token,
  date = "2021-03-09",
  ggplot_color_palette = "ggsci::blue_material",
  show_nchar_case_error = 135,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sleep_single_day_+3A_user_id">user_id</code></td>
<td>
<p>a character string specifying the encoded ID of the user. For instance '99xxxx' of the following URL 'https://www.fitbit.com/user/99xxxx' of the user's account corresponds to the 'user_id'</p>
</td></tr>
<tr><td><code id="sleep_single_day_+3A_token">token</code></td>
<td>
<p>a character string specifying the secret token that a user receives when registers a new application in https://dev.fitbit.com/apps</p>
</td></tr>
<tr><td><code id="sleep_single_day_+3A_date">date</code></td>
<td>
<p>a character string specifying the Date for which the sleep data should be returned. For instance, the date '2021-12-31' where the input order is 'year-month-day'</p>
</td></tr>
<tr><td><code id="sleep_single_day_+3A_ggplot_color_palette">ggplot_color_palette</code></td>
<td>
<p>a character string specifying the color palette to be used. For a full list of palettes used in the ggplot see:  https://pmassicotte.github.io/paletteer_gallery/ The following color-palettes were tested and work well: &quot;rcartocolor::Purp&quot;, &quot;rcartocolor::Teal&quot;</p>
</td></tr>
<tr><td><code id="sleep_single_day_+3A_show_nchar_case_error">show_nchar_case_error</code></td>
<td>
<p>an integer that specifies the number of characters that will be returned in case on an error. The default value is 135 characters.</p>
</td></tr>
<tr><td><code id="sleep_single_day_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

lst_out = sleep_single_day(user_id = USER_ID,
                           token = token,
                           date = '2021-03-09',
                           ggplot_color_palette = 'ggsci::blue_material',
                           show_nchar_case_error = 135,
                           verbose = TRUE)
str(lst_out)


## End(Not run)
</code></pre>

<hr>
<h2 id='sleep_time_series'>Sleep Data Time Series</h2><span id='topic+sleep_time_series'></span>

<h3>Description</h3>

<p>Sleep Data Time Series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sleep_time_series(
  user_id,
  token,
  date_start,
  date_end,
  ggplot_color_palette = "ggsci::blue_material",
  ggplot_ncol = NULL,
  ggplot_nrow = NULL,
  show_nchar_case_error = 135,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sleep_time_series_+3A_user_id">user_id</code></td>
<td>
<p>a character string specifying the encoded ID of the user. For instance '99xxxx' of the following URL 'https://www.fitbit.com/user/99xxxx' of the user's account corresponds to the 'user_id'</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_token">token</code></td>
<td>
<p>a character string specifying the secret token that a user receives when registers a new application in https://dev.fitbit.com/apps</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_date_start">date_start</code></td>
<td>
<p>a character string specifying the start Date for which the sleep data should be returned. For instance, the date '2021-12-31' where the input order is 'year-month-day'</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_date_end">date_end</code></td>
<td>
<p>a character string specifying the end Date for which the sleep data should be returned. For instance, the date '2021-12-31' where the input order is 'year-month-day'</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_ggplot_color_palette">ggplot_color_palette</code></td>
<td>
<p>a character string specifying the color palette to be used. For a full list of palettes used in the ggplot see:  https://pmassicotte.github.io/paletteer_gallery/ The following color-palettes were tested and work well: &quot;rcartocolor::Purp&quot;, &quot;rcartocolor::Teal&quot;</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_ggplot_ncol">ggplot_ncol</code></td>
<td>
<p>either NULL or an integer specifying the number of columns of the output ggplot</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_ggplot_nrow">ggplot_nrow</code></td>
<td>
<p>either NULL or an integer specifying the number of rows of the output ggplot</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_show_nchar_case_error">show_nchar_case_error</code></td>
<td>
<p>an integer that specifies the number of characters that will be returned in case on an error. The default value is 135 characters.</p>
</td></tr>
<tr><td><code id="sleep_time_series_+3A_verbose">verbose</code></td>
<td>
<p>a boolean. If TRUE then information will be printed out in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

require(fitbitViz)

#.........................................
# first compute the sleep time time series
#.........................................

USER_ID = '99xxxx'
token = 'my_long_web_api_token'

sleep_ts = sleep_time_series(user_id = USER_ID,
                             token = token,
                             date_start = '2021-03-09',
                             date_end = '2021-03-16',
                             ggplot_color_palette = 'ggsci::blue_material',
                             show_nchar_case_error = 135,
                             verbose = TRUE)

sleep_ts$plt_lev_segments
sleep_ts$plt_lev_heatmap
sleep_ts$heatmap_data


#...........................................
# (option to) save the ggplot to a .png file
#...........................................

png_file = tempfile(fileext = '.png')

ggplot2::ggsave(filename = png_file,
                plot = sleep_ts$plt_lev_segments,
                device = 'png',
                scale = 1,
                width = 35,
                height = 25,
                limitsize = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='split_year_in_weeks'>function for the weeks (including the date-from and date-to)</h2><span id='topic+split_year_in_weeks'></span>

<h3>Description</h3>

<p>function for the weeks (including the date-from and date-to)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_year_in_weeks(year)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_year_in_weeks_+3A_year">year</code></td>
<td>
<p>an integer value specifying the year</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sequence of Dates of class 'Date'
</p>


<h3>References</h3>

<p>https://statistics.berkeley.edu/computing/faqs/dates-and-times-r
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
