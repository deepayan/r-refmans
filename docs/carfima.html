<!DOCTYPE html><html><head><title>Help for package carfima</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {carfima}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#carfima-package'><p>Continuous-Time Fractionally Integrated ARMA Process for Irregularly Spaced Long-Memory Time Series Data</p></a></li>
<li><a href='#carfima'><p>Fitting a CARFIMA(p, H, q) model via frequentist or Bayesian machinery</p></a></li>
<li><a href='#carfima-internal'><p>Internal <code>carfima</code> functions</p></a></li>
<li><a href='#carfima.loglik'><p>Computing the log likelihood function of a CARFIMA(p, H, q) model</p></a></li>
<li><a href='#carfima.sim'><p>Simulating a CARFIMA(p, H, q) time series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-20</td>
</tr>
<tr>
<td>Title:</td>
<td>Continuous-Time Fractionally Integrated ARMA Process for
Irregularly Spaced Long-Memory Time Series Data</td>
</tr>
<tr>
<td>Author:</td>
<td>Hyungsuk Tak, Henghsiu Tsai, and Kisung You</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hyungsuk Tak &lt;hyungsuk.tak@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm(&ge; 1.0-11), DEoptim (&ge; 2.2-5), pracma (&ge; 2.2.9),
truncnorm (&ge; 1.0-8), invgamma (&ge; 1.1)</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a toolbox to fit a continuous-time fractionally integrated ARMA process (CARFIMA) on univariate and irregularly spaced time series data via both frequentist and Bayesian machinery. A general-order CARFIMA(p, H, q) model for p&gt;q is specified in Tsai and Chan (2005) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2005.00522.x">doi:10.1111/j.1467-9868.2005.00522.x</a>&gt; and it involves p+q+2 unknown model parameters, i.e., p AR parameters, q MA parameters, Hurst parameter H, and process uncertainty (standard deviation) sigma. Also, the model can account for heteroscedastic measurement errors, if the information about measurement error standard deviations is known. The package produces their maximum likelihood estimates and asymptotic uncertainties using a global optimizer called the differential evolution algorithm. It also produces posterior samples of the model parameters via Metropolis-Hastings within a Gibbs sampler equipped with adaptive Markov chain Monte Carlo. These fitting procedures, however, may produce numerical errors if p&gt;2. The toolbox also contains a function to simulate discrete time series data from CARFIMA(p, H, q) process given the model parameters and observation times. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-20 15:29:39 UTC; hyungsuktak</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-21 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='carfima-package'>Continuous-Time Fractionally Integrated ARMA Process for Irregularly Spaced Long-Memory Time Series Data</h2><span id='topic+carfima-package'></span>

<h3>Description</h3>

<p>The R package <span class="pkg">carfima</span> provides a toolbox to fit a continuous-time fractionally integrated ARMA process (CARFIMA) on univariate and irregularly spaced time series data via both frequentist and Bayesian machinery. A general-order CARFIMA(<code class="reqn">p, H, q</code>) model for <code class="reqn">p&gt;q</code> is specified in Tsai and Chan (2005). It involves <code class="reqn">p+q+2</code> unknown model parameters, i.e., <code class="reqn">p</code> AR parameters, <code class="reqn">q</code> MA parameters, Hurst parameter <code class="reqn">H</code>, and process uncertainty (standard deviation) <code class="reqn">\sigma</code>; see also <code><a href="#topic+carfima">carfima</a></code>. Also, the model can account for heteroscedastic measurement errors, if the information about measurement error standard deviations is known. The package produces their maximum likelihood estimates and asymptotic uncertainties using a global optimizer called the differential evolution algorithm. It also produces posterior samples of the model parameters via Metropolis-Hastings within a Gibbs sampler equipped with adaptive Markov chain Monte Carlo. These fitting procedures, however, may produce numerical errors if <code class="reqn">p&gt;2</code>. The toolbox also contains a function to simulate discrete time series data from CARFIMA(<code class="reqn">p, H, q</code>) process given the model parameters and observation times.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> carfima</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 2.0.2</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date: </td><td style="text-align: left;"> 2020-03-20</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
    Main functions: </td><td style="text-align: left;"> <code><a href="#topic+carfima">carfima</a></code>, <code><a href="#topic+carfima.loglik">carfima.loglik</a></code>, <code><a href="#topic+carfima.sim">carfima.sim</a></code></td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Hyungsuk Tak, Henghsiu Tsai, and Kisung You
</p>
<p>Maintainer: Hyungsuk Tak &lt;hyungsuk.tak@gmail.com&gt;
</p>


<h3>References</h3>

<p>H. Tsai and K.S. Chan (2005) &quot;Maximum Likelihood Estimation of Linear Continuous Time Long Memory Processes with Discrete Time Data,&quot; Journal of the Royal Statistical Society (Series B), 67 (5), 703-716. DOI: 10.1111/j.1467-9868.2005.00522.x
</p>
<p>H. Tsai and K.S. Chan (2000) &quot;A Note on the Covariance Structure of a Continuous-time ARMA Process,&quot; Statistica Sinica, 10, 989-998.<br /> Link: http://www3.stat.sinica.edu.tw/statistica/j10n3/j10n317/j10n317.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ##### Irregularly spaced observation time generation.

  length.time &lt;- 30
  time.temp &lt;- rexp(length.time, rate = 2)
  time &lt;- rep(NA, length.time + 1)
  time[1] &lt;- 0
  for (i in 2 : (length.time + 1)) {
    time[i] &lt;- time[i - 1] + time.temp[i - 1]
  }
  time &lt;- time[-1]

  ##### Data genration for CARFIMA(1, H, 0) based on the observation times. 

  parameter &lt;- c(-0.4, 0.8, 0.2) 
  # AR parameter alpha = -0.4
  # Hurst parameter = 0.8
  # Process uncertainty (standard deviation) sigma = 0.2

  me.sd &lt;- rep(0.05, length.time)
  # Known measurement error standard deviations 0.05 for all observations
  # If not known, remove the argument "measure.error = me.sd" in the following codes,
  # so that the default values (zero) are automatically assigned.

  y &lt;- carfima.sim(parameter = parameter, time = time, 
                   measure.error = me.sd, ar.p = 1, ma.q = 0)  

  ##### Fitting the CARFIMA(1, H, 0) model on the simulated data for MLEs.
  
  res &lt;- carfima(Y = y, time = time, measure.error = me.sd, 
                 method = "mle", ar.p = 1, ma.q = 0)
  
  # It takes a long time due to the differential evolution algorithm (global optimizer).
  # res$mle; res$se; res$AIC; res$fitted.values

  ##### Fitting the CARFIMA(1, H, 0) model on the simulated data for Bayesian inference.
  
  res &lt;- carfima(Y = y, time = time, measure.error = me.sd, 
                 method = "bayes", ar.p = 1, ma.q = 0, 
                 bayes.param.ini = parameter, 
                 bayes.param.scale = c(rep(0.2, length(parameter))), 
                 bayes.n.warm = 100, bayes.n.sample = 1000)
  
  # It takes a long time because the likelihood evaluation is computationally heavy.
  # The last number of bayes.param.scale is to update sigma2 (not sigma) on a log scale.
  # hist(res$param[, 1]); res$accept; res$AIC; res$fitted.values

  ##### Computing the log likelihood of the CARFIMA(1, H, 0) model given the parameters.
  loglik &lt;- carfima.loglik(Y = y, time = time, ar.p = 1, ma.q = 0,
                           measure.error = me.sd,
                           parameter = parameter, fitted = FALSE)
</code></pre>

<hr>
<h2 id='carfima'>Fitting a CARFIMA(p, H, q) model via frequentist or Bayesian machinery</h2><span id='topic+carfima'></span>

<h3>Description</h3>

<p>A general-order CARFIMA(<code class="reqn">p, H, q</code>) model for <code class="reqn">p&gt;q</code> is
</p>
<p style="text-align: center;"><code class="reqn">Y_t^{(p)} -\alpha_p Y_t^{(p-1)} -\cdots- \alpha_1 Y_t = \sigma(B_{t, H}^{(1)}+\beta_1B_{t, H}^{(2)}+\cdots+\beta_q B_{t, H}^{(q+1)}),</code>
</p>

<p>where <code class="reqn">B_{t, H} = B_t^H</code> is the standard fractional Brownian motion, <code class="reqn">H</code> is the Hurst parameter, and the superscript <code class="reqn">(j)</code> indicates <code class="reqn">j</code>-fold differentiation with respect to <code class="reqn">t</code>; see Equation (1) of Tsai and Chan (2005) for details. The model has <code class="reqn">p+q+2</code> unknown model parameters; <code class="reqn">p</code> <code class="reqn">\alpha_j</code>'s, <code class="reqn">q</code> <code class="reqn">\beta_j</code>'s, <code class="reqn">H</code>, and <code class="reqn">\sigma</code>. Also, the model can account for heteroscedastic measurement errors, if the information about measurement error standard deviations is known.<br />
</p>
<p>The function <code>carfima</code> fits the model, producing either their maximum likelihood estimates (MLEs) with their asymptotic uncertainties or their posterior samples according to its argument, <code>method</code>. The MLEs except <code class="reqn">\sigma</code> are obtained from a profile likelihood by a global optimizer called the differential evolution algorithm on restricted ranges, i.e., (-0.99, -0.01) for each <code class="reqn">\alpha_j</code>, (0, 100) for each <code class="reqn">\beta_j</code>, and (0.51, 0.99) for <code class="reqn">H</code>; the MLE of <code class="reqn">\sigma</code> is then deterministically computed. The corresponding asymptotic uncertainties are based on a numerical hessian matrix calculation at the MLEs (see function <code>hessian</code> in <span class="pkg">pracma</span>). It also computes the Akaike Information Criterion (AIC) that is <code class="reqn">-2</code>(log likelihood <code class="reqn">-p-q-2</code>). The function <code>carfima</code> becomes numerically unstable if <code class="reqn">p&gt;2</code>, and thus it may produce numerical errors.<br />
</p>
<p>The Bayesian approach uses independent prior distributions for the unknown model parameters; a Uniform(-0.9999, -0.0001) prior for each <code class="reqn">\alpha_j</code>, a Uniform(0, 100) prior for each <code class="reqn">\beta_j</code>, a Uniform(0.5001, 0.9999) prior for <code class="reqn">H</code> for long memory process, and finally an inverse-Gamma(shape = 2.01, scale = <code class="reqn">10^3</code>) prior for <code class="reqn">\sigma^2</code>. Posterior propriety holds because the prior distributions are jointly proper. It also adopts appropriate proposal density functions; a truncated Normal(current state, proposal scale) between -0.9999 and -0.0001 for each <code class="reqn">\alpha_j</code>, a truncated Normal(current state, proposal scale) between 0 and 100 for each <code class="reqn">\beta_j</code>, a truncated Normal(current state, proposal scale) between 0.5001 and 0.9999 for <code class="reqn">H</code>, and fianlly a Normal(log(current state), proposal scale on a log scale) for <code class="reqn">\sigma^2</code>, i.e., <code class="reqn">\sigma^2</code> is updated on a log scale. We sample the full posterior using Metropolis-Hastings within Gibbs sampler. It also adopts adaptive Markov chain Monte Carlo (MCMC) that updates the proposal scales every 100 iterations; if the acceptance rate of the most recent 100 proposals (at the end of the <code class="reqn">i</code>th 100 iterations) smaller than 0.3, then it multiplies <code class="reqn">\exp(-\min(0.1, 1/\sqrt{i}))</code> by the current proposal scale; if it is larger than 0.3, then it multiplies <code class="reqn">\exp(\min(0.1, 1/\sqrt{i}))</code> by the current proposal scale. The resulting Markov chain with this adaptive scheme converge to the stationary distribution because the adjustment factor, <code class="reqn">\exp(\pm\min(0.1, 1/\sqrt{i}))</code>, approaches unity as <code class="reqn">i</code> goes to infinity, satisfying the diminishing adaptation condition. The function <code>carfima</code> becomes numerically unstable if <code class="reqn">p&gt;2</code>, and thus it may produce numerical errors. The output returns the AIC for which we evaluate the log likelihood at the posterior medians of the unknown model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carfima(Y, time, measure.error, ar.p, ma.q, method = "mle", 
               bayes.param.ini, bayes.param.scale, bayes.n.warm, bayes.n.sample)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carfima_+3A_y">Y</code></td>
<td>

<p>A vector of length <code class="reqn">k</code> for the observed data.
</p>
</td></tr>
<tr><td><code id="carfima_+3A_time">time</code></td>
<td>

<p>A vector of length <code class="reqn">k</code> for the observation times.
</p>
</td></tr>
<tr><td><code id="carfima_+3A_measure.error">measure.error</code></td>
<td>

<p>(Optional) A vector for the <code class="reqn">k</code> measurement error standard deviations, if such information is available (especially for astronomical applications). A vector of zeros is automatically assigned, if nothing is specified.
</p>
</td></tr>
<tr><td><code id="carfima_+3A_ar.p">ar.p</code></td>
<td>

<p>A positive integer for the order of the AR model. <code>ar.p</code> must be greater than <code>ma.q</code>. If <code>ar.p</code> is greater than 2, numerical errors may occur.
</p>
</td></tr>
<tr><td><code id="carfima_+3A_ma.q">ma.q</code></td>
<td>

<p>A non-negative integer for the order of the MA model. <code>ma.q</code> must be smaller than <code>ar.p</code>.
</p>
</td></tr>
<tr><td><code id="carfima_+3A_method">method</code></td>
<td>

<p>Either &quot;mle&quot; or &quot;bayes&quot;. Method &quot;mle&quot; conducts the MLE-based inference, producing MLEs and asymptotic uncertainties of the model parameters. Method &quot;bayes&quot; draws posterior samples of the model parameters. 
</p>
</td></tr>
<tr><td><code id="carfima_+3A_bayes.param.ini">bayes.param.ini</code></td>
<td>

<p>Only if <code>method</code> is &quot;bayes&quot;. A vector of length <code class="reqn">p+q+2</code> for the initial values of <code class="reqn">p</code> <code class="reqn">\alpha_j</code>'s, <code class="reqn">q</code> <code class="reqn">\beta_j</code>'s, <code class="reqn">H</code>, and <code class="reqn">\sigma</code> to implement a Markov chain Monte Carlo method (Metropolis-Hastings within Gibbs sampler). When a CARFIMA(2, <code class="reqn">H</code>, 1) model is fitted, for example, users should set five initial values of <code class="reqn">\alpha_1</code>,  <code class="reqn">\alpha_2</code>, <code class="reqn">\beta_1</code>, <code class="reqn">H</code>, and <code class="reqn">\sigma</code>. 
</p>
</td></tr>
<tr><td><code id="carfima_+3A_bayes.param.scale">bayes.param.scale</code></td>
<td>

<p>Only if <code>method</code> is &quot;bayes&quot;. A vector of length <code class="reqn">p+q+2</code> for jumping (proposal) scales of the Metropolis-Hastings steps. Each number determines how far a Metropolis-Hastings step reaches out in each parameter space. Note that the last number of this vector is the jumping scale to update <code class="reqn">\sigma^2</code> on a log scale. The adaptive MCMC automatically adjusts these jumping scales during the run.
</p>
</td></tr>
<tr><td><code id="carfima_+3A_bayes.n.warm">bayes.n.warm</code></td>
<td>

<p>Only if <code>method</code> is &quot;bayes&quot;. A scalar for the number of burn-ins, i.e., the number of the first few iterations to be discarded to remove the effect of initial values.
</p>
</td></tr>
<tr><td><code id="carfima_+3A_bayes.n.sample">bayes.n.sample</code></td>
<td>

<p>Only if <code>method</code> is &quot;bayes&quot;. A scalar for the number of posterior samples for each parameter.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>carfiam</code> produces MLEs, their asymptotic uncertainties, and AIC if <code>method</code> is &quot;mle&quot;. It produces the posterior samples of the model parameters, acceptance rates, and AIC if <code>method</code> is &quot;bayes&quot;.
</p>


<h3>Value</h3>

<p>The outcome of <code>carfima</code> is composed of:
</p>
<table>
<tr><td><code>mle</code></td>
<td>
<p>If <code>method</code> is &quot;mle&quot;. Maximum likelihood estimates of the model parameters, <code class="reqn">p</code> <code class="reqn">\alpha_j</code>'s, <code class="reqn">q</code> <code class="reqn">\beta_j</code>'s, <code class="reqn">H</code>, and <code class="reqn">\sigma</code>. </p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>If <code>method</code> is &quot;mle&quot;. Asymptotic uncertainties (standard errors) of the MLEs.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>If <code>method</code> is &quot;bayes&quot;. An <code class="reqn">m</code> by <code class="reqn">(p+q+2)</code> matrix where <code class="reqn">m</code> is the number of posterior draws (<code>bayes.n.sample</code>) and the columns correspond to parameters, <code class="reqn">p</code> <code class="reqn">\alpha_j</code>'s, <code class="reqn">q</code> <code class="reqn">\beta_j</code>'s, <code class="reqn">H</code>, and <code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code>accept</code></td>
<td>
<p>If <code>method</code> is &quot;bayes&quot;. A vector of length <code class="reqn">p+q+2</code> for the acceptance rates of the Metropolis-Hastings steps.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>For both methods. Akaike Information Criterion, -2(log likelihood <code class="reqn">-p-q-2</code>). The log likelihood is evaluated at the MLEs if <code>method</code> is &quot;mle&quot; and at the posterior medians of the unknown model parameters if <code>method</code> is &quot;bayes&quot;.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>For both methods. A vector of length <code class="reqn">k</code> for the values of <code class="reqn">E(Y_{t_i}\vert Y_{&lt;t_i})</code>, <code class="reqn">i=1, 2, \ldots, k</code>, where <code class="reqn">k</code> is the number of observations and <code class="reqn">Y_{&lt;t_i}</code> represents all data observed before <code class="reqn">t_i</code>. Note that <code class="reqn">E(Y_{t_1}\vert Y_{&lt;t_1})=0</code>. MLEs of the model parameters are used to compute <code class="reqn">E(Y_{t_i}\vert Y_{&lt;t_i})</code>'s if <code>method</code> is &quot;mle&quot; and posterior medians of the model parameters are used if <code>method</code> is &quot;bayes&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Hyungsuk Tak, Henghsiu Tsai, Kisung You
</p>


<h3>References</h3>

<p>H. Tsai and K.S. Chan (2005) &quot;Maximum Likelihood Estimation of Linear Continuous Time Long Memory Processes with Discrete Time Data,&quot; Journal of the Royal Statistical Society (Series B), 67 (5), 703-716. DOI: 10.1111/j.1467-9868.2005.00522.x
</p>
<p>H. Tsai and K.S. Chan (2000) &quot;A Note on the Covariance Structure of a Continuous-time ARMA Process,&quot; Statistica Sinica, 10, 989-998. <br /> Link: http://www3.stat.sinica.edu.tw/statistica/j10n3/j10n317/j10n317.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ##### Irregularly spaced observation time generation.

  length.time &lt;- 30
  time.temp &lt;- rexp(length.time, rate = 2)
  time &lt;- rep(NA, length.time + 1)
  time[1] &lt;- 0
  for (i in 2 : (length.time + 1)) {
    time[i] &lt;- time[i - 1] + time.temp[i - 1]
  }
  time &lt;- time[-1]

  ##### Data genration for CARFIMA(1, H, 0) based on the observation times. 

  parameter &lt;- c(-0.4, 0.8, 0.2) 
  # AR parameter alpha = -0.4
  # Hurst parameter = 0.8
  # Process uncertainty (standard deviation) sigma = 0.2

  me.sd &lt;- rep(0.05, length.time)
  # Known measurement error standard deviations 0.05 for all observations
  # If not known, remove the argument "measure.error = me.sd" in the following codes,
  # so that the default values (zero) are automatically assigned.

  y &lt;- carfima.sim(parameter = parameter, time = time, 
                   measure.error = me.sd, ar.p = 1, ma.q = 0)  

  ##### Fitting the CARFIMA(1, H, 0) model on the simulated data for MLEs.
  
  res &lt;- carfima(Y = y, time = time, measure.error = me.sd, 
                 method = "mle", ar.p = 1, ma.q = 0)
  
  # It takes a long time due to the differential evolution algorithm (global optimizer).
  # res$mle; res$se; res$AIC; res$fitted.values

  ##### Fitting the CARFIMA(1, H, 0) model on the simulated data for Bayesian inference.
  
  res &lt;- carfima(Y = y, time = time, measure.error = me.sd, 
                 method = "bayes", ar.p = 1, ma.q = 0, 
                 bayes.param.ini = parameter, 
                 bayes.param.scale = c(rep(0.2, length(parameter))), 
                 bayes.n.warm = 100, bayes.n.sample = 1000)
  
  # It takes a long time because the likelihood evaluation is computationally heavy.
  # The last number of bayes.param.scale is to update sigma2 (not sigma) on a log scale.
  # hist(res$param[, 1]); res$accept; res$AIC; res$fitted.values

  ##### Computing the log likelihood of the CARFIMA(1, H, 0) model given the parameters.
  loglik &lt;- carfima.loglik(Y = y, time = time, ar.p = 1, ma.q = 0,
                           measure.error = me.sd,
                           parameter = parameter, fitted = FALSE)
</code></pre>

<hr>
<h2 id='carfima-internal'>Internal <code>carfima</code> functions</h2><span id='topic+g1'></span><span id='topic+g2'></span><span id='topic+B.mat'></span><span id='topic+V.mat.sigma'></span><span id='topic+V.mat'></span><span id='topic+Gamma.Y.sigma'></span><span id='topic+Gamma.Y'></span><span id='topic+carfima.loglik.nosigma'></span><span id='topic+carfima.bayes'></span>

<h3>Description</h3>

<p>Internal <code>carfima</code> functions</p>


<h3>Details</h3>

<p>These are not to be called by users.</p>

<hr>
<h2 id='carfima.loglik'>Computing the log likelihood function of a CARFIMA(p, H, q) model</h2><span id='topic+carfima.loglik'></span>

<h3>Description</h3>

<p>This function evaluates the log likelihood function of a CARFIMA(p, H, q) model as specified in Tsai and Chan (2005). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carfima.loglik(Y, time, measure.error, ar.p, ma.q, parameter, fitted = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carfima.loglik_+3A_y">Y</code></td>
<td>

<p>A vector for the <code class="reqn">k</code> observed data.
</p>
</td></tr>
<tr><td><code id="carfima.loglik_+3A_time">time</code></td>
<td>

<p>A vector for the <code class="reqn">k</code> observation times.
</p>
</td></tr>
<tr><td><code id="carfima.loglik_+3A_measure.error">measure.error</code></td>
<td>

<p>(Optional) A vector for the <code class="reqn">k</code> measurement error standard deviations, if such information is available (especially for astronomical applications). A vector of zeros is automatically assigned, if nothing is specified.
</p>
</td></tr>
<tr><td><code id="carfima.loglik_+3A_ar.p">ar.p</code></td>
<td>

<p>A positive integer for the order of the AR model. <code>ar.p</code> must be greater than <code>ma.q</code>. If <code>ar.p</code> is greater than 2, numerical errors may occur for both methods.
</p>
</td></tr>
<tr><td><code id="carfima.loglik_+3A_ma.q">ma.q</code></td>
<td>

<p>A non-negative integer for the order of the MA model. <code>ma.q</code> must be smaller than <code>ar.p</code>.
</p>
</td></tr>
<tr><td><code id="carfima.loglik_+3A_parameter">parameter</code></td>
<td>

<p>The values of the unknown parameters at which the log likelihood is evaluated. For example, users need to specify five values of <code class="reqn">\alpha_1</code>,  <code class="reqn">\alpha_2</code>, <code class="reqn">\beta_1</code>, <code class="reqn">H</code>, and <code class="reqn">\sigma</code> for CARFIMA(2, H, 1). 
</p>
</td></tr>
<tr><td><code id="carfima.loglik_+3A_fitted">fitted</code></td>
<td>

<p>If &quot;TRUE&quot;, fitted values and AIC are returned. If &quot;FALSE&quot;, a value of the log likelihood is returned. Default is &quot;FALSE&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>carfiam.loglik</code> computes the log likelihood of a CARFIMA(p, H, q) model via the innovation algorithm whose computational cost increases linearly as the size of the data increases; see Tsai and Chan (2005) for details.
</p>


<h3>Value</h3>

<p>The outcome of <code>carfima</code> is the value of the log likelihood if &quot;fitted = FALSE&quot; and both AIC and fitted values if &quot;fitted = TRUE&quot;.
</p>


<h3>Author(s)</h3>

<p>Hyungsuk Tak, Henghsiu Tsai, Kisung You
</p>


<h3>References</h3>

<p>H. Tsai and K.S. Chan (2005) &quot;Maximum Likelihood Estimation of Linear Continuous Time Long Memory Processes with Discrete Time Data,&quot; Journal of the Royal Statistical Society (Series B), 67 (5), 703-716. DOI: 10.1111/j.1467-9868.2005.00522.x
</p>
<p>H. Tsai and K.S. Chan (2000) &quot;A Note on the Covariance Structure of a Continuous-time ARMA Process,&quot; Statistica Sinica, 10, 989-998. <br /> Link: http://www3.stat.sinica.edu.tw/statistica/j10n3/j10n317/j10n317.htm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ##### Irregularly spaced observation time generation.


  length.time &lt;- 30
  time.temp &lt;- rexp(length.time, rate = 2)
  time &lt;- rep(NA, length.time + 1)
  time[1] &lt;- 0
  for (i in 2 : (length.time + 1)) {
    time[i] &lt;- time[i - 1] + time.temp[i - 1]
  }
  time &lt;- time[-1]

  ##### Data genration for CARFIMA(1, H, 0) based on the observation times. 

  parameter &lt;- c(-0.4, 0.8, 0.2) 
  # AR parameter alpha = -0.4
  # Hurst parameter = 0.8
  # Process uncertainty (standard deviation) sigma = 0.2

  me.sd &lt;- rep(0.05, length.time)
  # Known measurement error standard deviations 0.05 for all observations
  # If not known, remove the argument "measure.error = me.sd" in the following codes,
  # so that the default values (zero) are automatically assigned.

  y &lt;- carfima.sim(parameter = parameter, time = time, 
                   measure.error = me.sd, ar.p = 1, ma.q = 0)  

  ##### Computing the log likelihood of the CARFIMA(1, H, 0) model given the parameters.
  loglik &lt;- carfima.loglik(Y = y, time = time, ar.p = 1, ma.q = 0,
                           measure.error = me.sd,
                           parameter = parameter, fitted = FALSE)
</code></pre>

<hr>
<h2 id='carfima.sim'>Simulating a CARFIMA(p, H, q) time series</h2><span id='topic+carfima.sim'></span>

<h3>Description</h3>

<p>The funstion <code>carfima.sim</code> produces discrete time series data that follow a CARFIMA(p, H, q) model given the values for the model parameters and observation times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>carfima.sim(parameter, time, measure.error, ar.p, ma.q)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="carfima.sim_+3A_parameter">parameter</code></td>
<td>

<p>A vector of length <code class="reqn">p+q+2</code> for the generative values of the model parameters; <code class="reqn">p</code> values of <code class="reqn">\alpha_j</code>'s, <code class="reqn">q</code> values of <code class="reqn">\beta_j</code>'s, <code class="reqn">H</code>, and <code class="reqn">\sigma</code>.
</p>
</td></tr>
<tr><td><code id="carfima.sim_+3A_time">time</code></td>
<td>

<p>A vector for the <code class="reqn">k</code> observation times, either regularly or irregularly spaced.
</p>
</td></tr>
<tr><td><code id="carfima.sim_+3A_measure.error">measure.error</code></td>
<td>

<p>(Optional) A vector for the <code class="reqn">k</code> measurement error standard deviations, if such information is available (especially for astronomical applications). A vector of zeros is automatically assigned, if nothing is specified.
</p>
</td></tr>
<tr><td><code id="carfima.sim_+3A_ar.p">ar.p</code></td>
<td>

<p>A scalar for the order of the AR model.
</p>
</td></tr>
<tr><td><code id="carfima.sim_+3A_ma.q">ma.q</code></td>
<td>

<p>A scalar for the order of the MA model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces simulated discrete time series data following a CARFIMA(<code class="reqn">p, H, q</code>) model given the values for the model parameters and observation times. It first derives a <code class="reqn">k</code>-dimensional multivariate Gaussian distribution whose mean set to a vector of zeros, where <code class="reqn">k</code> is the number of observations. The covariance matrix is filled with Cov(<code class="reqn">Y_{t_i}</code>, <code class="reqn">Y_{t_j}</code>) and its closed-form formula is specified in Theorem 1(b) and 1(c) of Tsai and Chan (2005).
</p>


<h3>Value</h3>

<p>The outcome of <code>carfima.sim</code> is a vector for <code class="reqn">k</code> simulated data following a CARFIMA(<code class="reqn">p, H, q</code>) model given the values for the model parameters and observation times.
</p>


<h3>Author(s)</h3>

<p>Hyungsuk Tak, Henghsiu Tsai, Kisung You
</p>


<h3>References</h3>

<p>H. Tsai and K.S. Chan (2005) &quot;Maximum Likelihood Estimation of Linear Continuous Time Long Memory Processes with Discrete Time Data,&quot; Journal of the Royal Statistical Society (Series B), 67 (5), 703-716. DOI: 10.1111/j.1467-9868.2005.00522.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ##### Irregularly spaced observation time generation.

  length.time &lt;- 30
  time.temp &lt;- rexp(length.time, rate = 2)
  time &lt;- rep(NA, length.time + 1)
  time[1] &lt;- 0
  for (i in 2 : (length.time + 1)) {
    time[i] &lt;- time[i - 1] + time.temp[i - 1]
  }
  time &lt;- time[-1]

  ##### Data genration for CARFIMA(1, H, 0) based on the observation times. 

  parameter &lt;- c(-0.4, 0.8, 0.2) 
  # AR parameter alpha = -0.4
  # Hurst parameter = 0.8
  # Process uncertainty (standard deviation) sigma = 0.2

  me.sd &lt;- rep(0.05, length.time)
  # Known measurement error standard deviations 0.05 for all observations
  # If not known, remove the argument "measure.error = me.sd" in the following codes,
  # so that the default values (zero) are automatically assigned.

  y &lt;- carfima.sim(parameter = parameter, time = time, 
                   measure.error = me.sd, ar.p = 1, ma.q = 0)  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
