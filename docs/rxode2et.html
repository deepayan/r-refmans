<!DOCTYPE html><html><head><title>Help for package rxode2et</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rxode2et}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.clearPipe'><p>Clear/Set pipeline</p></a></li>
<li><a href='#.collectWarnings'><p>Collect warnings and just warn once.</p></a></li>
<li><a href='#.pipeRx'><p>Assign in the rxode2 pipeline</p></a></li>
<li><a href='#.s3register'><p>Register a method for a suggested dependency</p></a></li>
<li><a href='#.setRxode2'><p>This tells 'rxode2et' that 'rxode2' is available</p></a></li>
<li><a href='#add.dosing'><p>Add dosing to eventTable</p></a></li>
<li><a href='#add.sampling'><p>Add sampling to eventTable</p></a></li>
<li><a href='#as.et'><p>Coerce object to data.frame</p></a></li>
<li><a href='#et'><p>Event Table Function</p></a></li>
<li><a href='#etExpand'><p>Expand additional doses</p></a></li>
<li><a href='#etRbind'><p>Combining event tables</p></a></li>
<li><a href='#etRep'><p>Repeat an rxode2 event table</p></a></li>
<li><a href='#etSeq'><p>Sequence of event tables</p></a></li>
<li><a href='#eventTable'><p>Create an event table object</p></a></li>
<li><a href='#forderForceBase'><p>Force using base order for rxode2 radix sorting</p></a></li>
<li><a href='#is.rxEt'><p>Check to see if this is an rxEt object.</p></a></li>
<li><a href='#is.rxStackData'><p>Return if the object can be stacked</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rxCbindStudyIndividual'><p>Bind the study parameters and individual parameters</p></a></li>
<li><a href='#rxEtDispatchSolve'><p>Dispatch solve to 'rxode2' solve</p></a></li>
<li><a href='#rxEvid'><p>EVID formatting for tibble and other places.</p></a></li>
<li><a href='#rxRateDur'><p>Creates a rxRateDur object</p></a></li>
<li><a href='#rxReq'><p>Require namespace, otherwise throw error.</p></a></li>
<li><a href='#rxStack'><p>Stack a solved object for things like default ggplot2 plot</p></a></li>
<li><a href='#toTrialDuration'><p>Convert event data to trial duration data</p>
A helper function to create a custom event table.
The observation time will start from the first event time (baseline) and end at trial duration.
The interval is the spacing between each observation.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Event Table Functions for 'rxode2'</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.13</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the event table and support functions needed for
   'rxode2' (Wang, Hallow and  James (2016) &lt;<a href="https://doi.org/10.1002%2Fpsp4.12052">doi:10.1002/psp4.12052</a>&gt;) and 'nlmixr2'
    (Fidler et al (2019) &lt;<a href="https://doi.org/10.1002%2Fpsp4.12445">doi:10.1002/psp4.12445</a>&gt;).
    This split will reduce computational burden of recompiling 'rxode2'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nlmixr2.github.io/rxode2et/">https://nlmixr2.github.io/rxode2et/</a>,
<a href="https://github.com/nlmixr2/rxode2et/">https://github.com/nlmixr2/rxode2et/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nlmixr2/rxode2et/issues/">https://github.com/nlmixr2/rxode2et/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods, Rcpp, checkmate, rxode2random (&ge;
2.1.1), rxode2parse (&ge; 2.0.19), cli, crayon, magrittr, lotri</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), units, tibble, data.table, dplyr,
pillar, nlmixr2data, qs</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>rxode2random, rxode2parse, Rcpp</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-27 14:48:50 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew L. Fidler <a href="https://orcid.org/0000-0001-8538-6691"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Wenping Wang [ctb],
  Fuji Goro [ctb],
  Morwenn [ctb],
  Igor Kushnir [ctb],
  Omar Elashkar [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew L. Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-27 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.clearPipe'>Clear/Set pipeline</h2><span id='topic+.clearPipe'></span>

<h3>Description</h3>

<p>Clear/Set pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.clearPipe(
  rx = NULL,
  inits = NULL,
  events = NULL,
  params = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  sigma = NULL,
  dfObs = NULL,
  dfSub = NULL,
  nSub = NULL,
  nStud = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".clearPipe_+3A_rx">rx</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, clears rxode2 pipeline
</p>

<hr>
<h2 id='.collectWarnings'>Collect warnings and just warn once.</h2><span id='topic+.collectWarnings'></span>

<h3>Description</h3>

<p>Collect warnings and just warn once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.collectWarnings(expr, lst = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".collectWarnings_+3A_expr">expr</code></td>
<td>
<p>R expression</p>
</td></tr>
<tr><td><code id=".collectWarnings_+3A_lst">lst</code></td>
<td>
<p>When <code>TRUE</code> return a list with
list(object,warnings) instead of issuing the warnings.
Otherwise, when <code>FALSE</code> issue the warnings and return the
object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the expression or a list with the value of
the expression and a list of warning messages
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.pipeRx'>Assign in the rxode2 pipeline</h2><span id='topic+.pipeRx'></span><span id='topic+.pipeInits'></span><span id='topic+.pipeEvents'></span><span id='topic+.pipeParams'></span><span id='topic+.pipeKeep'></span><span id='topic+.pipeThetaMat'></span><span id='topic+.pipeOmega'></span><span id='topic+.pipeSigma'></span><span id='topic+.pipeDfObs'></span><span id='topic+.pipeDfSub'></span><span id='topic+.pipeNSub'></span><span id='topic+.pipeNStud'></span>

<h3>Description</h3>

<p>Assign in the rxode2 pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pipeRx(obj)

.pipeInits(obj)

.pipeEvents(obj)

.pipeParams(obj)

.pipeKeep(obj)

.pipeThetaMat(obj)

.pipeOmega(obj)

.pipeSigma(obj)

.pipeDfObs(obj)

.pipeDfSub(obj)

.pipeNSub(obj)

.pipeNStud(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".pipeRx_+3A_obj">obj</code></td>
<td>
<p>Object to assign.  If NA return the value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pipeline object (invisibly)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.s3register'>Register a method for a suggested dependency</h2><span id='topic+.s3register'></span>

<h3>Description</h3>

<p>Generally, the recommend way to register an S3 method is to use the
<code>S3Method()</code> namespace directive (often generated automatically by the
<code style="white-space: pre;">&#8288;@export&#8288;</code> roxygen2 tag). However, this technique requires that the generic
be in an imported package, and sometimes you want to suggest a package,
and only provide a method when that package is loaded. <code>s3_register()</code>
can be called from your package's <code>.onLoad()</code> to dynamically register
a method only if the generic's package is loaded. (To avoid taking a
dependency on vctrs for this one function, please feel free to copy
and paste the function source into your own package.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.s3register(generic, class, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".s3register_+3A_generic">generic</code></td>
<td>
<p>Name of the generic in the form <code>pkg::generic</code>.</p>
</td></tr>
<tr><td><code id=".s3register_+3A_class">class</code></td>
<td>
<p>Name of the class</p>
</td></tr>
<tr><td><code id=".s3register_+3A_method">method</code></td>
<td>
<p>Optionally, the implementation of the method. By default,
this will be found by looking for a function called <code>generic.class</code>
in the package environment.
</p>
<p>Note that providing <code>method</code> can be dangerous if you use
devtools. When the namespace of the method is reloaded by
<code>devtools::load_all()</code>, the function will keep inheriting from
the old namespace. This might cause crashes because of dangling
<code>.Call()</code> pointers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For R 3.5.0 and later, <code>s3_register()</code> is also useful when demonstrating
class creation in a vignette, since method lookup no longer always involves
the lexical scope. For R 3.6.0 and later, you can achieve a similar effect
by using &quot;delayed method registration&quot;, i.e. placing the following in your
<code>NAMESPACE</code> file:
</p>
<div class="sourceCode"><pre>if (getRversion() &gt;= "3.6.0") {
  S3method(package::generic, class)
}
</pre></div>


<h3>Value</h3>

<p>nothing; called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A typical use case is to dynamically register tibble/pillar methods
# for your class. That way you avoid creating a hard dependency on packages
# that are not essential, while still providing finer control over
# printing when they are used.

.onLoad &lt;- function(...) {
  .s3Register("pillar::pillar_shaft", "vctrs_vctr")
  .s3Register("tibble::type_sum", "vctrs_vctr")
}
</code></pre>

<hr>
<h2 id='.setRxode2'>This tells 'rxode2et' that 'rxode2' is available</h2><span id='topic+.setRxode2'></span>

<h3>Description</h3>

<p>This really should not be called by a user.  This call allows
'rxode2' solves to be a bit more flexible (and actually work!)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.setRxode2()
</code></pre>


<h3>Value</h3>

<p>Nothing called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='add.dosing'>Add dosing to eventTable</h2><span id='topic+add.dosing'></span>

<h3>Description</h3>

<p>This adds a dosing event to the event table.  This is provided for
piping syntax through magrittr.  It can also be accessed by <code>eventTable$add.dosing(...)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.dosing(
  eventTable,
  dose,
  nbr.doses = 1L,
  dosing.interval = 24,
  dosing.to = 1L,
  rate = NULL,
  amount.units = NA_character_,
  start.time = 0,
  do.sampling = FALSE,
  time.units = NA_character_,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.dosing_+3A_eventtable">eventTable</code></td>
<td>
<p>eventTable object; When accessed from object it would be <code style="white-space: pre;">&#8288;eventTable$&#8288;</code></p>
</td></tr>
<tr><td><code id="add.dosing_+3A_dose">dose</code></td>
<td>
<p>numeric scalar, dose amount in <code>amount.units</code>;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_nbr.doses">nbr.doses</code></td>
<td>
<p>integer, number of doses;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_dosing.interval">dosing.interval</code></td>
<td>
<p>required numeric scalar, time between doses
in <code>time.units</code>, defaults to 24 of
<code>time.units="hours"</code>;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_dosing.to">dosing.to</code></td>
<td>
<p>integer, compartment the dose goes into (first
compartment by default);</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_rate">rate</code></td>
<td>
<p>for infusions, the rate of infusion (default is
<code>NULL</code>, for bolus dosing;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_amount.units">amount.units</code></td>
<td>
<p>optional string indicating the dosing units.
Defaults to <code>NA</code> to indicate as per the original
<code>EventTable</code> definition.</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_start.time">start.time</code></td>
<td>
<p>required dosing start time;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_do.sampling">do.sampling</code></td>
<td>
<p>logical, should observation sampling records be
added at the dosing times? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_time.units">time.units</code></td>
<td>
<p>optional string indicating the time units.
Defaults to <code>"hours"</code> to indicate as per the original
<code>EventTable</code> definition.</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="#topic+et">et()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eventTable with updated dosing (note the event table will
be updated anyway)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>
<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306,
&lt;URL: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4728294/&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(units)

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100));


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") %&gt;%
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)


## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) %&gt;%
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))


## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) %&gt;%
     add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))



</code></pre>

<hr>
<h2 id='add.sampling'>Add sampling to eventTable</h2><span id='topic+add.sampling'></span>

<h3>Description</h3>

<p>This adds a dosing event to the event table.  This is provided for
piping syntax through magrittr.  It can also be accessed by
<code>eventTable$add.sampling()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.sampling(eventTable, time, time.units = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.sampling_+3A_eventtable">eventTable</code></td>
<td>
<p>An eventTable object. When accessed from object it would be <code style="white-space: pre;">&#8288;eventTable$&#8288;</code></p>
</td></tr>
<tr><td><code id="add.sampling_+3A_time">time</code></td>
<td>
<p>a vector of time values (in <code>time.units</code>).</p>
</td></tr>
<tr><td><code id="add.sampling_+3A_time.units">time.units</code></td>
<td>
<p>an optional string specifying the time
units. Defaults to the units specified when the
<code>EventTable</code> was initialized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eventTable with updated sampling.  (Note the event table
will be updated even if you don't reassign the eventTable)
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306,
&lt;URL: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4728294/&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(units)

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100));


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") %&gt;%
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)


## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) %&gt;%
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))


## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) %&gt;%
     add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))



</code></pre>

<hr>
<h2 id='as.et'>Coerce object to data.frame</h2><span id='topic+as.et'></span><span id='topic+as.et.default'></span>

<h3>Description</h3>

<p>Coerce object to data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.et(x, ...)

## Default S3 method:
as.et(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.et_+3A_x">x</code></td>
<td>
<p>Object to coerce to et.</p>
</td></tr>
<tr><td><code id="as.et_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event table
</p>

<hr>
<h2 id='et'>Event Table Function</h2><span id='topic+et'></span><span id='topic+et.rxode2'></span><span id='topic+et.function'></span><span id='topic+et.rxUi'></span><span id='topic+et.rxSolve'></span><span id='topic+et.rxParams'></span><span id='topic+et.default'></span>

<h3>Description</h3>

<p>Event Table Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>et(x, ..., envir = parent.frame())

## S3 method for class 'rxode2'
et(x, ..., envir = parent.frame())

## S3 method for class ''function''
et(x, ..., envir = parent.frame())

## S3 method for class 'rxUi'
et(x, ..., envir = parent.frame())

## S3 method for class 'rxSolve'
et(x, ..., envir = parent.frame())

## S3 method for class 'rxParams'
et(x, ..., envir = parent.frame())

## Default S3 method:
et(
  x,
  ...,
  time,
  amt,
  evid,
  cmt,
  ii,
  addl,
  ss,
  rate,
  dur,
  until,
  id,
  amountUnits,
  timeUnits,
  addSampling,
  envir = parent.frame(),
  by = NULL,
  length.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="et_+3A_x">x</code></td>
<td>
<p>This is the first argument supplied to the event table.
This is named to allow <code>et</code> to be used in a pipe-line
with arbitrary objects.</p>
</td></tr>
<tr><td><code id="et_+3A_...">...</code></td>
<td>
<p>Times or event tables.  They can also be one of the named arguments below.</p>
</td></tr>
<tr><td><code id="et_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> in which <code>expr</code> is to
be evaluated.  May also be <code>NULL</code>, a list, a data frame,
a pairlist or an integer as specified to <code><a href="base.html#topic+sys.call">sys.call</a></code>.</p>
</td></tr>
<tr><td><code id="et_+3A_time">time</code></td>
<td>
<p>Time is the time of the dose or the sampling times.
This can also be unspecified and is determined by the object
type (list or numeric/integer).</p>
</td></tr>
<tr><td><code id="et_+3A_amt">amt</code></td>
<td>
<p>Amount of the dose. If specified, this assumes a dosing
record, instead of a sampling record.</p>
</td></tr>
<tr><td><code id="et_+3A_evid">evid</code></td>
<td>
<p>Event ID; This can be:</p>

<table>
<tr>
 <td style="text-align: left;">
   Numeric Value </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> An observation. This can also be specified as <code>evid=obs</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> A dose observation.  This can also be specified as <code>evid=dose</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> A non-dose event. This can also be specified as <code>evid=other</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> A reset event.  This can also be specified as <code>evid=reset</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> Dose and reset event.  This can also be specified as <code>evid=doseReset</code> or <code>evid=resetDose</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note a reset event resets all the compartment values to zero and turns off all infusions.</p>
</td></tr>
<tr><td><code id="et_+3A_cmt">cmt</code></td>
<td>
<p>Compartment name or number.  If a number, this is an
integer starting at 1.  Negative compartments turn off a
compartment. If the compartment is a name, the compartment name
is changed to the correct state/compartment number before
running the simulation.  For a compartment named &quot;-cmt&quot; the
compartment is turned off.
</p>
<div class="sourceCode"><pre>Can also specify `cmt` as `dosing.to`,
`dose.to`, `doseTo`, `dosingTo`, and
`state`.
</pre></div></td></tr>
<tr><td><code id="et_+3A_ii">ii</code></td>
<td>
<p>When specifying a dose, this is the inter-dose interval
for <code>ss</code>, <code>addl</code> and <code>until</code> options (described below).</p>
</td></tr>
<tr><td><code id="et_+3A_addl">addl</code></td>
<td>
<p>The number of additional doses at a inter-dose
interval after one dose.</p>
</td></tr>
<tr><td><code id="et_+3A_ss">ss</code></td>
<td>
<p>Steady state flag;  It can be one of:</p>

<table>
<tr>
 <td style="text-align: left;">
   Value </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> This dose is not a steady state dose </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> This dose is a steady state dose with the between/inter-dose interval of <code>ii</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> Superposition steady state </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When <code>ss=2</code> the steady state dose that uses the super-position
principle to allow more complex steady states, like 10 mg in the
morning and 20 mg at night, or dosing at 8 am 12 pm and 8 pm
instead of every 12 hours.  Since it uses the super positioning
principle, it only makes sense when you know the kinetics are
linear.
</p>
<p>All other values of <code>SS</code> are currently invalid.</p>
</td></tr>
<tr><td><code id="et_+3A_rate">rate</code></td>
<td>
<p>When positive, this is the rate of infusion.  Otherwise:</p>

<table>
<tr>
 <td style="text-align: left;">
   Value </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> No infusion is on this record </td>
</tr>
<tr>
 <td style="text-align: left;">
   -1 </td><td style="text-align: left;"> Modeled rate (in rxode2:<code style="white-space: pre;">&#8288;rate(cmt) =&#8288;</code>); Can be <code>et(rate=model)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
   -2 </td><td style="text-align: left;"> Modeled duration (in rxode2: <code style="white-space: pre;">&#8288;dur(cmt) =&#8288;</code>); Can be<code>et(dur=model)</code> or <code>et(rate=dur)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When a modeled bioavailability is applied to positive rates
(<code>rate</code> &gt; 0), the duration of infusion is changed. This is
because the data specify the rate and amount, the only think that
modeled bioavailability can affect is duration.
</p>
<p>If instead you want the modeled bioavailability to increase the
rate of infusion instead of the duration of infusion, specify the
<code>dur</code> instead or model the duration with <code>rate=2</code>.</p>
</td></tr>
<tr><td><code id="et_+3A_dur">dur</code></td>
<td>
<p>Duration of infusion.  When <code>amt</code> and <code>dur</code>
are specified the rate is calculated from the two data items.
When <code>dur</code> is specified instead of <code>rate</code>, the
bioavailability changes will increase rate instead of
duration.</p>
</td></tr>
<tr><td><code id="et_+3A_until">until</code></td>
<td>
<p>This is the time until the dosing should end.  It can
be an easier way to figure out how many additional doses are
needed over your sampling period.</p>
</td></tr>
<tr><td><code id="et_+3A_id">id</code></td>
<td>
<p>A integer vector of IDs to add or remove from the event
table.  If the event table is identical for each ID, then you
may expand it to include all the IDs in this vector.  All the
negative IDs in this vector will be removed.</p>
</td></tr>
<tr><td><code id="et_+3A_amountunits">amountUnits</code></td>
<td>
<p>The units for the dosing records (<code>amt</code>)</p>
</td></tr>
<tr><td><code id="et_+3A_timeunits">timeUnits</code></td>
<td>
<p>The units for the time records (<code>time</code>)</p>
</td></tr>
<tr><td><code id="et_+3A_addsampling">addSampling</code></td>
<td>
<p>This is a boolean indicating if a sampling time
should be added at the same time as a dosing time.  By default
this is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="et_+3A_by">by</code></td>
<td>
<p>number: increment of the sequence.</p>
</td></tr>
<tr><td><code id="et_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence.  A
non-negative number, which for <code>seq</code> and <code>seq.int</code> will be
rounded up if fractional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306,
&lt;URL: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4728294/&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(units)

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100));


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") %&gt;%
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)


## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) %&gt;%
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))


## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) %&gt;%
     add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))



</code></pre>

<hr>
<h2 id='etExpand'>Expand additional doses</h2><span id='topic+etExpand'></span>

<h3>Description</h3>

<p>Expand additional doses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etExpand(et)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etExpand_+3A_et">et</code></td>
<td>
<p>Event table to expand additional doses for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New event table with <code>addl</code> doses expanded
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ev &lt;- et(amt = 3, ii = 24, until = 240)
print(ev)
etExpand(ev) # expands event table, but doesn't modify it

print(ev)

ev$expand() ## Expands the current event table and saves it in ev
</code></pre>

<hr>
<h2 id='etRbind'>Combining event tables</h2><span id='topic+etRbind'></span><span id='topic+rbind.rxEt'></span>

<h3>Description</h3>

<p>Combining event tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etRbind(
  ...,
  samples = c("use", "clear"),
  waitII = c("smart", "+ii"),
  id = c("merge", "unique")
)

## S3 method for class 'rxEt'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etRbind_+3A_...">...</code></td>
<td>
<p>The event tables and optionally time between event
tables, called waiting times in this help document.</p>
</td></tr>
<tr><td><code id="etRbind_+3A_samples">samples</code></td>
<td>
<p>How to handle samples when repeating an event
table.  The options are:
</p>

<ul>
<li> <p><code>"clear"</code> Clear sampling records before combining the datasets
</p>
</li>
<li> <p><code>"use"</code> Use the sampling records when combining the datasets
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRbind_+3A_waitii">waitII</code></td>
<td>
<p>This determines how waiting times between events are
handled. The options are:
</p>

<ul>
<li> <p><code>"smart"</code> This &quot;smart&quot; handling of waiting times is the
default option.  In this case, if the waiting time is above the
last observed inter-dose interval in the first combined event
table, then the actual time between doses is given by the wait
time.  If it is smaller than the last observed inter-dose
interval, the time between event tables is given by the inter-dose
interval + the waiting time between event tables.
</p>
</li>
<li> <p><code>"+ii"</code> In this case, the wait time is added to the
inter-dose interval no matter the length of the wait time or
inter-dose interval
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRbind_+3A_id">id</code></td>
<td>
<p>This is how rbind will handle IDs.  There are two different types of options:
</p>

<ul>
<li> <p><code>merge</code> with <code>id="merge"</code>, the IDs are merged together,
overlapping IDs would be merged into a single event table.
</p>
</li>
<li> <p><code>unique</code> with <code>id="unique"</code>, the IDs will be renumbered
so that the IDs in all the event tables are not overlapping.
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRbind_+3A_deparse.level">deparse.level</code></td>
<td>
<p>The <code>deparse.level</code> of a traditional
<code>rbind</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler
</p>
<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306,
&lt;URL: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4728294/&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(units)

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100));


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") %&gt;%
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)


## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) %&gt;%
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))


## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) %&gt;%
     add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))



</code></pre>

<hr>
<h2 id='etRep'>Repeat an rxode2 event table</h2><span id='topic+etRep'></span><span id='topic+rep.rxEt'></span>

<h3>Description</h3>

<p>Repeat an rxode2 event table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etRep(
  x,
  times = 1,
  length.out = NA,
  each = NA,
  n = NULL,
  wait = 0,
  id = integer(0),
  samples = c("clear", "use"),
  waitII = c("smart", "+ii"),
  ii = 24
)

## S3 method for class 'rxEt'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etRep_+3A_x">x</code></td>
<td>
<p>An rxode2 event table</p>
</td></tr>
<tr><td><code id="etRep_+3A_times">times</code></td>
<td>
<p>Number of times to repeat the event table</p>
</td></tr>
<tr><td><code id="etRep_+3A_length.out">length.out</code></td>
<td>
<p>Invalid with rxode2 event tables, will throw an
error if used.</p>
</td></tr>
<tr><td><code id="etRep_+3A_each">each</code></td>
<td>
<p>Invalid with rxode2 event tables, will throw an error
if used.</p>
</td></tr>
<tr><td><code id="etRep_+3A_n">n</code></td>
<td>
<p>The number of times to repeat the event table.  Overrides
<code>times</code>.</p>
</td></tr>
<tr><td><code id="etRep_+3A_wait">wait</code></td>
<td>
<p>Waiting time between each repeated event table.  By
default there is no waiting, or wait=0</p>
</td></tr>
<tr><td><code id="etRep_+3A_id">id</code></td>
<td>
<p>A integer vector of IDs to add or remove from the event
table.  If the event table is identical for each ID, then you
may expand it to include all the IDs in this vector.  All the
negative IDs in this vector will be removed.</p>
</td></tr>
<tr><td><code id="etRep_+3A_samples">samples</code></td>
<td>
<p>How to handle samples when repeating an event
table.  The options are:
</p>

<ul>
<li> <p><code>"clear"</code> Clear sampling records before combining the datasets
</p>
</li>
<li> <p><code>"use"</code> Use the sampling records when combining the datasets
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRep_+3A_waitii">waitII</code></td>
<td>
<p>This determines how waiting times between events are
handled. The options are:
</p>

<ul>
<li> <p><code>"smart"</code> This &quot;smart&quot; handling of waiting times is the
default option.  In this case, if the waiting time is above the
last observed inter-dose interval in the first combined event
table, then the actual time between doses is given by the wait
time.  If it is smaller than the last observed inter-dose
interval, the time between event tables is given by the inter-dose
interval + the waiting time between event tables.
</p>
</li>
<li> <p><code>"+ii"</code> In this case, the wait time is added to the
inter-dose interval no matter the length of the wait time or
inter-dose interval
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRep_+3A_ii">ii</code></td>
<td>
<p>When specifying a dose, this is the inter-dose interval
for <code>ss</code>, <code>addl</code> and <code>until</code> options (described below).</p>
</td></tr>
<tr><td><code id="etRep_+3A_...">...</code></td>
<td>
<p>Times or event tables.  They can also be one of the named arguments below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306,
&lt;URL: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4728294/&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(units)

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100));


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") %&gt;%
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)


## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) %&gt;%
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))


## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) %&gt;%
     add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))



</code></pre>

<hr>
<h2 id='etSeq'>Sequence of event tables</h2><span id='topic+etSeq'></span><span id='topic+seq.rxEt'></span>

<h3>Description</h3>

<p>This combines a sequence of event tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etSeq(..., samples = c("clear", "use"), waitII = c("smart", "+ii"), ii = 24)

## S3 method for class 'rxEt'
seq(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etSeq_+3A_...">...</code></td>
<td>
<p>The event tables and optionally time between event
tables, called waiting times in this help document.</p>
</td></tr>
<tr><td><code id="etSeq_+3A_samples">samples</code></td>
<td>
<p>How to handle samples when repeating an event
table.  The options are:
</p>

<ul>
<li> <p><code>"clear"</code> Clear sampling records before combining the datasets
</p>
</li>
<li> <p><code>"use"</code> Use the sampling records when combining the datasets
</p>
</li></ul>
</td></tr>
<tr><td><code id="etSeq_+3A_waitii">waitII</code></td>
<td>
<p>This determines how waiting times between events are
handled. The options are:
</p>

<ul>
<li> <p><code>"smart"</code> This &quot;smart&quot; handling of waiting times is the
default option.  In this case, if the waiting time is above the
last observed inter-dose interval in the first combined event
table, then the actual time between doses is given by the wait
time.  If it is smaller than the last observed inter-dose
interval, the time between event tables is given by the inter-dose
interval + the waiting time between event tables.
</p>
</li>
<li> <p><code>"+ii"</code> In this case, the wait time is added to the
inter-dose interval no matter the length of the wait time or
inter-dose interval
</p>
</li></ul>
</td></tr>
<tr><td><code id="etSeq_+3A_ii">ii</code></td>
<td>
<p>If there was no inter-dose intervals found in the event
table, assume that the interdose interval is given by this
<code>ii</code> value.  By default this is <code>24</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This <code>seq</code>uences all the event tables in added in the
argument list <code>...</code>.  By default when combining the event
tables the offset is at least by the last inter-dose interval in
the prior event table (or <code>ii</code>).  If you separate any of the
event tables by a number, the event tables will be separated at
least the wait time defined by that number or the last inter-dose
interval.
</p>


<h3>Value</h3>

<p>An event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306,
&lt;URL: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4728294/&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


library(units)

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100));


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") %&gt;%
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)


## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) %&gt;%
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))


## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") %&gt;% et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) %&gt;%
     add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))



</code></pre>

<hr>
<h2 id='eventTable'>Create an event table object</h2><span id='topic+eventTable'></span>

<h3>Description</h3>

<p>Initializes an object of class &lsquo;EventTable&rsquo; with methods for
adding and querying dosing and observation records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventTable(amount.units = NA, time.units = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventTable_+3A_amount.units">amount.units</code></td>
<td>
<p>string denoting the amount dosing units, e.g.,
&ldquo;mg&rdquo;, &ldquo;ug&rdquo;. Default to <code>NA</code> to denote
unspecified units.  It could also be a solved rxode2 object.  In
that case, eventTable(obj) returns the eventTable that was used
to solve the rxode2 object.</p>
</td></tr>
<tr><td><code id="eventTable_+3A_time.units">time.units</code></td>
<td>
<p>string denoting the time units, e.g.,
&ldquo;hours&rdquo;, &ldquo;days&rdquo;. Default to <code>"hours"</code>.
</p>
<p>An <code>eventTable</code> is an object that consists of a data.frame
storing ordered time-stamped events of an (unspecified) PK/PD
dynamic system, units (strings) for dosing and time records, plus a
list of functions to add and extract event records.
</p>
<p>Currently, events can be of two types: dosing events that represent
inputs to the system and sampling time events that represent
observations of the system with &lsquo;amount.units&rsquo; and
&lsquo;time.units&rsquo;, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified data.frame with the following accessible functions:
</p>

<ul>
<li> <p><code>get.EventTable()</code> returns the current event table
</p>
</li>
<li> <p><code><a href="#topic+add.dosing">add.dosing()</a></code>  adds dosing records to the event table.
</p>
</li>
<li> <p><code>get.dosing()</code> returns a data.frame of dosing records.
</p>
</li>
<li> <p><code>clear.dosing()</code> clears or deletes all dosing from event table
</p>
</li>
<li><p> '<code><a href="#topic+add.sampling">add.sampling()</a></code> adds sampling time observation records to the
event table.
</p>
</li>
<li> <p><code>get.sampling()</code>returns a data.frame of sampled observation records.
</p>
</li>
<li> <p><code>clear.sampling()</code> removes all sampling from event table.
</p>
</li>
<li> <p><code>get.obs.rec()</code> returns a logical vector indicating whether each
event record represents an observation or not.
</p>
</li>
<li> <p><code>get.nobs()</code> returns the number of observation (not dosing) records.
</p>
</li>
<li> <p><code>get.units()</code> returns a two-element character vector with the
dosing and time units, respectively
</p>
</li>
<li> <p><code>copy()</code> makes a copy of the current event table. To create
a copy of an event table object use <code>qd2 &lt;- qd$copy()</code>
</p>
</li>
<li> <p><code>expand()</code> Expands the event table for multi-subject solving.
This is done by <code>qd$expand(400)</code> for a 400 subject data expansion
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Fidler, Melissa Hallow and Wenping Wang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+et">et()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create dosing and observation (sampling) events
# QD 50mg dosing, 5 days followed by 25mg 5 days
#
qd &lt;- eventTable(amount.units = "mg", time.units = "days")
#
qd$add.dosing(dose = 50, nbr.doses = 5, dosing.interval = 1, do.sampling = FALSE)
#
# sample the system's drug amounts hourly the first day, then every 12 hours
# for the next 4 days
qd$add.sampling(seq(from = 0, to = 1, by = 1 / 24))
qd$add.sampling(seq(from = 1, to = 5, by = 12 / 24))
#
# print(qd$get.dosing())     # table of dosing records
print(qd$get.nobs()) # number of observation (not dosing) records
#
# BID dosing, 5 days
bid &lt;- eventTable("mg", "days") # only dosing
bid$add.dosing(
  dose = 10000, nbr.doses = 2 * 5,
  dosing.interval = 12, do.sampling = FALSE
)
#
# Use the copy() method to create a copy (clone) of an existing
# event table (simple assignments just create a new reference to
# the same event table object (closure)).
#
bid.ext &lt;- bid$copy() # three-day extension for a 2nd cohort
bid.ext$add.dosing(
  dose = 5000, nbr.doses = 2 * 3,
  start.time = 120, dosing.interval = 12, do.sampling = FALSE
)

# You can also use the Piping operator to create a table

qd2 &lt;- eventTable(amount.units = "mg", time.units = "days") %&gt;%
  add.dosing(dose = 50, nbr.doses = 5, dosing.interval = 1, do.sampling = FALSE) %&gt;%
  add.sampling(seq(from = 0, to = 1, by = 1 / 24)) %&gt;%
  add.sampling(seq(from = 1, to = 5, by = 12 / 24))
# print(qd2$get.dosing())     # table of dosing records
print(qd2$get.nobs()) # number of observation (not dosing) records

# Note that piping with %&gt;% will update the original table.

qd3 &lt;- qd2 %&gt;% add.sampling(seq(from = 5, to = 10, by = 6 / 24))
print(qd2$get.nobs())
print(qd3$get.nobs())
</code></pre>

<hr>
<h2 id='forderForceBase'>Force using base order for rxode2 radix sorting</h2><span id='topic+forderForceBase'></span>

<h3>Description</h3>

<p>Force using base order for rxode2 radix sorting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forderForceBase(forceBase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forderForceBase_+3A_forcebase">forceBase</code></td>
<td>
<p>boolean indicating if rxode2 should use R's
<code><a href="base.html#topic+order">order()</a></code> for radix sorting instead of
<code>data.table</code>'s parallel radix sorting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NILL; called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
forderForceBase(TRUE) # Use base `order` for rxode2 sorts
forderForceBase(FALSE) # Use `data.table` for rxode2 sorts

</code></pre>

<hr>
<h2 id='is.rxEt'>Check to see if this is an rxEt object.</h2><span id='topic+is.rxEt'></span>

<h3>Description</h3>

<p>Check to see if this is an rxEt object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rxEt(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rxEt_+3A_x">x</code></td>
<td>
<p>object to check to see if it is rxEt
</p>
<p>If this is an rxEt object that has expired strip all rxEt
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicating if this is a rxode2 event table
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='is.rxStackData'>Return if the object can be stacked</h2><span id='topic+is.rxStackData'></span>

<h3>Description</h3>

<p>Return if the object can be stacked
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rxStackData(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rxStackData_+3A_object">object</code></td>
<td>
<p>object to test if it can be stacked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean to tell if an object can be stacked using rxode2
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.rxStackData(NULL)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+lotri'></span><span id='topic+rxRmvn'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>lotri</dt><dd><p><code><a href="lotri.html#topic+lotri">lotri</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>rxode2random</dt><dd><p><code><a href="rxode2random.html#topic+rxRmvn">rxRmvn</a></code></p>
</dd>
</dl>


<h3>Value</h3>

<p> Inherited from parent routine </p>

<hr>
<h2 id='rxCbindStudyIndividual'>Bind the study parameters and individual parameters</h2><span id='topic+rxCbindStudyIndividual'></span>

<h3>Description</h3>

<p>Bind the study parameters and individual parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCbindStudyIndividual(studyParameters, individualParameters)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxCbindStudyIndividual_+3A_studyparameters">studyParameters</code></td>
<td>
<p>These are the study parameters, often can
be generated by sampling from a population.  This can be either
a matrix or a data frame</p>
</td></tr>
<tr><td><code id="rxCbindStudyIndividual_+3A_individualparameters">individualParameters</code></td>
<td>
<p>A data frame of individual parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame that can be used in rxode2 simulations
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Function for coverting coefficient of covariance into a variance
lognCv &lt;- function(x){log((x/100)^2+1)}

set.seed(32)

nSub  &lt;-  100
nStud  &lt;-  10

#define theta
theta &lt;- c(lka=log(0.5), # log ka
          lCl=log(5), # log Cl
          lV=log(300) # log V
          )

#define theta Matrix
thetaMat &lt;- lotri(lCl ~ lognCv(5),
                 lV  ~ lognCv(5),
                 lka ~ lognCv(5))


nev &lt;- nSub*nStud

ev1 &lt;- data.frame(COV1=rnorm(nev,50,30),COV2=rnorm(nev,75,10),
                  COV3=sample(c(1.0,2.0),nev,replace=TRUE))


tmat &lt;-rxRmvn(nStud, theta[dimnames(thetaMat)[[1]]], thetaMat)

rxCbindStudyIndividual(tmat, ev1)

</code></pre>

<hr>
<h2 id='rxEtDispatchSolve'>Dispatch solve to 'rxode2' solve</h2><span id='topic+rxEtDispatchSolve'></span><span id='topic+rxEtDispatchSolve.default'></span>

<h3>Description</h3>

<p>Dispatch solve to 'rxode2' solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxEtDispatchSolve(x, ...)

## Default S3 method:
rxEtDispatchSolve(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxEtDispatchSolve_+3A_x">x</code></td>
<td>
<p>rxode2 solve dispatch object</p>
</td></tr>
<tr><td><code id="rxEtDispatchSolve_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'rxode2'  is loaded, a solved object, otherwise an error
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxEvid'>EVID formatting for tibble and other places.</h2><span id='topic+rxEvid'></span><span id='topic+as.rxEvid'></span><span id='topic+c.rxEvid'></span><span id='topic++5B.rxEvid'></span><span id='topic+as.character.rxEvid'></span><span id='topic++5B+5B.rxEvid'></span><span id='topic+c.rxRateDur'></span><span id='topic+format.rxEvid'></span><span id='topic+format.rxRateDur'></span><span id='topic+print.rxEvid'></span>

<h3>Description</h3>

<p>This is to make an EVID more readable by non
pharmacometricians. It displays what each means and allows it to
be displayed in a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxEvid(x)

as.rxEvid(x)

## S3 method for class 'rxEvid'
c(x, ...)

## S3 method for class 'rxEvid'
x[...]

## S3 method for class 'rxEvid'
as.character(x, ...)

## S3 method for class 'rxEvid'
x[[...]]

## S3 method for class 'rxRateDur'
c(x, ...)

## S3 method for class 'rxEvid'
format(x, ...)

## S3 method for class 'rxRateDur'
format(x, ...)

## S3 method for class 'rxEvid'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxEvid_+3A_x">x</code></td>
<td>
<p>Item to be converted to a rxode2 EVID specification.</p>
</td></tr>
<tr><td><code id="rxEvid_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxEvid specification
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxEvid(1:7)
</code></pre>

<hr>
<h2 id='rxRateDur'>Creates a rxRateDur object</h2><span id='topic+rxRateDur'></span><span id='topic++5B.rxRateDur'></span><span id='topic+as.rxRateDur'></span><span id='topic+as.character.rxRateDur'></span><span id='topic++5B+5B.rxRateDur'></span>

<h3>Description</h3>

<p>This is primarily to display information about rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRateDur(x)

## S3 method for class 'rxRateDur'
x[...]

as.rxRateDur(x)

## S3 method for class 'rxRateDur'
as.character(x, ...)

## S3 method for class 'rxRateDur'
x[[...]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxRateDur_+3A_x">x</code></td>
<td>
<p>rxRateDur data</p>
</td></tr>
<tr><td><code id="rxRateDur_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxRateDur object
</p>

<hr>
<h2 id='rxReq'>Require namespace, otherwise throw error.</h2><span id='topic+rxReq'></span>

<h3>Description</h3>

<p>Require namespace, otherwise throw error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxReq(pkg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxReq_+3A_pkg">pkg</code></td>
<td>
<p>Package required for function to work.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxStack'>Stack a solved object for things like default ggplot2 plot</h2><span id='topic+rxStack'></span>

<h3>Description</h3>

<p>Stack a solved object for things like default ggplot2 plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxStack(data, vars = NULL, doSim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxStack_+3A_data">data</code></td>
<td>
<p>is a rxode2 object to be stacked.</p>
</td></tr>
<tr><td><code id="rxStack_+3A_vars">vars</code></td>
<td>
<p>Variables to include in stacked data; By default this
is all the variables when vars is NULL.
</p>
<p>When vars is <code>sim</code> and comes from a <code>rxode2</code> ui simulation with
multiple endpoints (ie it has a <code>CMT</code> in the simulation), it will
rework the data as if it was stacked based the value based on the
compartments in the multiple endpoint model.
</p>
<p>When the vars is <code>sim.endpoint1</code> it will subset the stack to
endpoint1, you can also have 'c(&quot;sim.endpoint1&quot;, &quot;sim.endpoint2&quot;)
and the &quot;stack&quot; will subset to endpoint1 and endpoint2.
</p>
<p>When you specify the <code>sim</code> type variables they have to be all
prefixed with <code>sim</code> otherwise, the stack will not treat them
differently.</p>
</td></tr>
<tr><td><code id="rxStack_+3A_dosim">doSim</code></td>
<td>
<p>boolean that determines if the &quot;sim&quot; variable in a
<code>rxSolve</code> dataset is actually &quot;stacking&quot; based on the endpoint
(<code>TRUE</code>) or simply treating <code>sim</code> as a variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stacked data with <code>value</code> and <code>trt</code>, where value is the values
and <code>trt</code> is the state and <code>lhs</code> variables.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='toTrialDuration'>Convert event data to trial duration data
A helper function to create a custom event table.
The observation time will start from the first event time (baseline) and end at trial duration.
The interval is the spacing between each observation.</h2><span id='topic+toTrialDuration'></span>

<h3>Description</h3>

<p>Convert event data to trial duration data
A helper function to create a custom event table.
The observation time will start from the first event time (baseline) and end at trial duration.
The interval is the spacing between each observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toTrialDuration(ev, trialEnd, interval, writeDir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toTrialDuration_+3A_ev">ev</code></td>
<td>
<p>event data</p>
</td></tr>
<tr><td><code id="toTrialDuration_+3A_trialend">trialEnd</code></td>
<td>
<p>extend trial duration. Must be same time unit as event data</p>
</td></tr>
<tr><td><code id="toTrialDuration_+3A_interval">interval</code></td>
<td>
<p>observation interval. Must be same time unit as event data</p>
</td></tr>
<tr><td><code id="toTrialDuration_+3A_writedir">writeDir</code></td>
<td>
<p>if not NULL, write the output to a csv file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Omar Elashkar
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Create event table with unique time for each ID
 ev = et(data.frame(id = rep(1:10, 3),  time = runif(min = 10, max = 20, n = 30)))

 # select the duration and spacing interval (assuming time is in years)
 toTrialDuration(ev, trialEnd = 1.5, interval = 0.2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
