<!DOCTYPE html><html><head><title>Help for package rmonad</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmonad}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rmonad'><p>rmonad: handling pipes, errors, and everything with monads</p></a></li>
<li><a href='#add_transitive_edges'><p>Find inputs to a nest</p></a></li>
<li><a href='#apply_rewriters'><p>Apply rewriters to an Rmonad</p></a></li>
<li><a href='#bind'><p>Apply f to the contents of a monad and merge messages</p></a></li>
<li><a href='#clear_cache'><p>Clear cached values and delete temporary files</p></a></li>
<li><a href='#const'><p>Ignore the first input, return the second</p></a></li>
<li><a href='#crunch'><p>Cache all large values that are stored in memory</p></a></li>
<li><a href='#esc'><p>Returns the value a monad holds</p></a></li>
<li><a href='#extract_metadata'><p>Extract docstring and meta data from an anonymous function</p></a></li>
<li><a href='#fail_cache'><p>Represent a dummy value for a node downstream of a failing node</p></a></li>
<li><a href='#false'><p>Return false for all input</p></a></li>
<li><a href='#false_as_error'><p>Make NULL values an error</p></a></li>
<li><a href='#first'><p>Given two arguments, return the first</p></a></li>
<li><a href='#get_dependency_matrix'><p>Get dependencies of local variables on inputs</p></a></li>
<li><a href='#gff'><p>Data for GFF processing vignette</p></a></li>
<li><a href='#infix'><p>Infix operators</p></a></li>
<li><a href='#is_rmonad'><p>Determine whether something is an Rmonad object</p></a></li>
<li><a href='#loop'><p>Apply an rmonad pipeline function to each element in a rmonad bound list</p></a></li>
<li><a href='#make_cacher'><p>Make Cacher object</p></a></li>
<li><a href='#make_recacher'><p>Make a function that takes an Rmonad and recaches it</p></a></li>
<li><a href='#memory_cache'><p>Store a value in memory</p></a></li>
<li><a href='#missues'><p>Tabulates all errors, warnings and notes</p></a></li>
<li><a href='#mtabulate'><p>Make tabular summary of a pipeline</p></a></li>
<li><a href='#no_cache'><p>Represent a value that has been deleted</p></a></li>
<li><a href='#nothing'><p>Do nothing</p></a></li>
<li><a href='#null_as_error'><p>Make NULL values an error</p></a></li>
<li><a href='#plot.Rmonad'><p>Render an Rmonad graph</p></a></li>
<li><a href='#print.Rmonad'><p>Rmonad print generic function</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#report'><p>Convert a pipeline to Rmarkdown</p></a></li>
<li><a href='#rmonad_checkers'><p>Vectorized existence checkers for public Rmonad fields</p></a></li>
<li><a href='#rmonad_getters'><p>Vectorized getters for public Rmonad fields</p></a></li>
<li><a href='#second'><p>Given two arguments, return the second</p></a></li>
<li><a href='#size'><p>Return the number of nodes in the workflow</p></a></li>
<li><a href='#splice_function'><p>Take a monadic bind operation's result and splice histories</p></a></li>
<li><a href='#tag'><p>Set the tag of an Rmonad object</p></a></li>
<li><a href='#toss'><p>Take input and do nothing with it</p></a></li>
<li><a href='#true'><p>Return true for all input</p></a></li>
<li><a href='#view'><p>Set the head of an Rmonad to a particular tag</p></a></li>
<li><a href='#viewID'><p>Move head to this id</p></a></li>
<li><a href='#viewIDs'><p>Return a list of Rmonad objects at these positions</p></a></li>
<li><a href='#views'><p>Get a list of Rmonad objects matching the given tag</p></a></li>
<li><a href='#void_cache'><p>Represent a value that has not been set</p></a></li>
<li><a href='#x_to_monad'><p>Conversions to monads</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.0</td>
</tr>
<tr>
<td>Title:</td>
<td>A Monadic Pipeline System</td>
</tr>
<tr>
<td>Description:</td>
<td>
    A monadic solution to pipeline analysis. All operations &ndash; and the errors,
    warnings and messages they emit &ndash; are merged into a directed graph. Infix
    binary operators mediate when values are stored, how exceptions are
    handled, and where pipelines branch and merge. The resulting structure may
    be queried for debugging or report generation. 'rmonad' complements, rather
    than competes with, non-monadic pipeline packages like 'magrittr' or
    'pipeR'. This work is funded by the NSF (award number 1546858).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/arendsee/rmonad">https://github.com/arendsee/rmonad</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arendsee/rmonad/issues">https://github.com/arendsee/rmonad/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, methods, magrittr, glue, pryr, digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, knitr, rmarkdown, readr, stringr, tidyr,
dplyr, Nozzle.R1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-13 20:22:36 UTC; zebulun.arendsee</td>
</tr>
<tr>
<td>Author:</td>
<td>Zebulun Arendsee [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zebulun Arendsee &lt;zbwrnz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-14 07:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rmonad'>rmonad: handling pipes, errors, and everything with monads</h2><span id='topic+rmonad'></span><span id='topic+rmonad-package'></span>

<h3>Description</h3>

<p>Rmonad merges blocks of code into a graph containing the history of all past
operations, and optionally their values. It consists mainly of a set of
monadic bind operators for controlling a pipeline and handling error. It
also contains functions for operating on monads, evaluating expressions into
monads, and extracting values from them. I will briefly introduce the most
useful of these here. For more information see the <code>introduction</code>
vignette.
</p>


<h3>Basic Operators</h3>


<dl>
<dt><code>%&gt;&gt;%</code></dt><dd><p>monadic bind: applies rhs function to the lhs value</p>
</dd>
<dt><code>%v&gt;%</code></dt><dd><p>monadic bind: store intermediate result</p>
</dd>
<dt><code>%*&gt;%</code></dt><dd><p>bind lhs list as arguments to right. The lhs may be
a literal list or a monad bound list.</p>
</dd>
<dt><code>%&gt;_%</code></dt><dd><p>perform rhs action, discard result, pass the lhs</p>
</dd>
<dt><code>%&gt;^%</code></dt><dd><p>Bind as a new branch, pass input on main. This
differs from <code>%&gt;_%</code> in that future operations do not depend on its
pass/fail status. Use <code>unbranch</code> to extract all branches from an
Rmonad object.</p>
</dd> 
<dt><code>%||%</code></dt><dd><p>if input is error, use rhs value instead</p>
</dd>
<dt><code>%|&gt;%</code></dt><dd><p>if input is error, run rhs on last passing result</p>
</dd>
<dt><code>%__%</code></dt><dd><p>keep parents from the lhs (errors ignored). This allows chaining of independent operations.</p>
</dd>
</dl>



<h3>Operators targeted for deprecation</h3>

<p><code>%^&gt;%</code> Monadic bind and record input in monad. Perform rhs operation
on lhs branches. I may deprecate this operator.
</p>


<h3>x to monad functions</h3>

<p><code>as_monad</code> - evaluate an expression into a monad (capturing error)
</p>
<p><code>funnel</code> - evaluate expressions into a list inside a monad
</p>


<h3>monad to monad functions</h3>

<p><code>forget</code> - erase parents from a monad
</p>
<p><code>combine</code> - combine a list of monads into a list in a monad
</p>


<h3>monad to x functions</h3>

<p><code>esc</code> - extract the result from a computation
</p>
<p><code>mtabulate</code> - summarize all steps in a pipeline into a table
</p>
<p><code>missues</code> - tabulate all warnings and errors from a pipeline 
</p>
<p><code>unbranch</code> - extract all branches from the pipeline
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# chain operations
cars %&gt;&gt;% colSums

# chain operations with intermediate storing
cars %v&gt;% colSums

# handle failing monad
iris %&gt;&gt;% colSums %|&gt;% head
cars %&gt;&gt;% colSums %|&gt;% head

# run an effect
cars %&gt;_% plot %&gt;&gt;% colSums

# return first successful operation
read.csv("a.csv") %||% iris %&gt;&gt;% head

# join two independent pipelines, preserving history
cars %&gt;&gt;% colSums %__% cars %&gt;&gt;% lapply(sd) %&gt;&gt;% unlist

# load an expression into a monad, catching errors
as_monad(stop("instant death"))

# convert multiple expressions into a list inside a monad
funnel(stop("oh no"), runif(5), sqrt(-1))
</code></pre>

<hr>
<h2 id='add_transitive_edges'>Find inputs to a nest</h2><span id='topic+add_transitive_edges'></span>

<h3>Description</h3>

<p>Find inputs to a nest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_transitive_edges(m, bv, deps, final)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_transitive_edges_+3A_m">m</code></td>
<td>
<p>The current monadic node</p>
</td></tr>
<tr><td><code id="add_transitive_edges_+3A_bv">bv</code></td>
<td>
<p>A named list of bound variables</p>
</td></tr>
<tr><td><code id="add_transitive_edges_+3A_deps">deps</code></td>
<td>
<p>A mapping local variables to bound variable dependencies</p>
</td></tr>
</table>

<hr>
<h2 id='apply_rewriters'>Apply rewriters to an Rmonad</h2><span id='topic+apply_rewriters'></span>

<h3>Description</h3>

<p>Rewriters are functions stored in an Rmonad's metadata list that operate on
an Rmonad after it has evaluated its code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_rewriters(x, meta = .single_meta(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_rewriters_+3A_x">x</code></td>
<td>
<p>The Rmonad</p>
</td></tr>
<tr><td><code id="apply_rewriters_+3A_meta">meta</code></td>
<td>
<p>A metadata list</p>
</td></tr>
</table>

<hr>
<h2 id='bind'>Apply f to the contents of a monad and merge messages</h2><span id='topic+bind'></span>

<h3>Description</h3>

<p>This function should not be used directly. Rather you should use the infix
operators. They all wrap this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind(x, f, entry_lhs_transform = entry_lhs_transform_default,
  bind_if = function(m) .single_OK(m), bind_else = default_bind_else,
  emit = emit_default, m_on_bind = function(x, ...) {     x },
  io_combine = default_combine, bind_args = function(m)
  list(.single_value(m, warn = FALSE)), parent_ids = function(m)
  list(.get_ids(m)[.single_id(m)]), expect_rhs_function = TRUE,
  envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_x">x</code></td>
<td>
<p>The input, may or may not be a monad report</p>
</td></tr>
<tr><td><code id="bind_+3A_f">f</code></td>
<td>
<p>A function of the value contained in x</p>
</td></tr>
<tr><td><code id="bind_+3A_entry_lhs_transform">entry_lhs_transform</code></td>
<td>
<p>f(m,x,...) a transform of the lhs called on entry</p>
</td></tr>
<tr><td><code id="bind_+3A_bind_if">bind_if</code></td>
<td>
<p>f(m) bind rhs to lhs if TRUE</p>
</td></tr>
<tr><td><code id="bind_+3A_bind_else">bind_else</code></td>
<td>
<p>f(m,f) action to take if bind_if is FALSE</p>
</td></tr>
<tr><td><code id="bind_+3A_emit">emit</code></td>
<td>
<p>f(i,o) Emit the input or the output</p>
</td></tr>
<tr><td><code id="bind_+3A_io_combine">io_combine</code></td>
<td>
<p>f(m,o) weave m and f(m) into final output</p>
</td></tr>
<tr><td><code id="bind_+3A_bind_args">bind_args</code></td>
<td>
<p>function to retrieve the arguments</p>
</td></tr>
<tr><td><code id="bind_+3A_.single_on_bind">.single_on_bind</code></td>
<td>
<p>f(m) Action to perform on input monad when binding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A monad report
</p>

<hr>
<h2 id='clear_cache'>Clear cached values and delete temporary files</h2><span id='topic+clear_cache'></span>

<h3>Description</h3>

<p>Clear cached values and delete temporary files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clear_cache(m, index = .get_ids(m))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clear_cache_+3A_m">m</code></td>
<td>
<p>Rmonad object</p>
</td></tr>
<tr><td><code id="clear_cache_+3A_index">index</code></td>
<td>
<p>indices to clear (all indices by default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rmonad object
</p>


<h3>See Also</h3>

<p>Other cache: <code><a href="#topic+fail_cache">fail_cache</a></code>,
<code><a href="#topic+make_cacher">make_cacher</a></code>, <code><a href="#topic+make_recacher">make_recacher</a></code>,
<code><a href="#topic+memory_cache">memory_cache</a></code>, <code><a href="#topic+no_cache">no_cache</a></code>,
<code><a href="#topic+void_cache">void_cache</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>256 %v&gt;% sqrt %&gt;&gt;% sqrt %&gt;&gt;% sqrt  -&gt; m
m
clear_cache(m)
</code></pre>

<hr>
<h2 id='const'>Ignore the first input, return the second</h2><span id='topic+const'></span>

<h3>Description</h3>

<p>This function can be used to change the value in the lhs of a monadic
sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>const(x, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="const_+3A_x">x</code></td>
<td>
<p>ignored value</p>
</td></tr>
<tr><td><code id="const_+3A_r">r</code></td>
<td>
<p>replacing value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper_functions: <code><a href="#topic+false_as_error">false_as_error</a></code>,
<code><a href="#topic+false">false</a></code>, <code><a href="#topic+null_as_error">null_as_error</a></code>,
<code><a href="#topic+toss">toss</a></code>, <code><a href="#topic+true">true</a></code>
</p>

<hr>
<h2 id='crunch'>Cache all large values that are stored in memory</h2><span id='topic+crunch'></span>

<h3>Description</h3>

<p>Cache all large values that are stored in memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crunch(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crunch_+3A_m">m</code></td>
<td>
<p>Rmonad object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(42)
m &lt;- as_monad(runif(1e6), tag="a") %&gt;&gt;%
     sqrt %&gt;% tag("b") %&gt;&gt;%
     log %&gt;% tag("c") %&gt;&gt;% prod(2) %&gt;&gt;% prod(3)
m1 &lt;- crunch(m)
get_value(m,  1:3) %&gt;% lapply(head)
get_value(m1, 1:3) %&gt;% lapply(head)

## End(Not run)
</code></pre>

<hr>
<h2 id='esc'>Returns the value a monad holds</h2><span id='topic+esc'></span>

<h3>Description</h3>

<p>If the monad is in the passing state, return the wrapped value. Otherwise,
raise an appropriate error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esc(m, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="esc_+3A_m">m</code></td>
<td>
<p>An Rmonad</p>
</td></tr>
<tr><td><code id="esc_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, print the exact messages that are raised, without
extra context.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Regardless of pass/fail status, <code>esc</code> raises all collected warnings and
prints all messages. Terminating a monadic sequence with <code>esc</code> should
obtain a result very close to running the same code outside the monad. The
main difference is that Rmonad appends the toplevel code that generated the
error.
</p>


<h3>See Also</h3>

<p>Other from_Rmonad: <code><a href="#topic+missues">missues</a></code>,
<code><a href="#topic+mtabulate">mtabulate</a></code>, <code><a href="#topic+report">report</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
256 %&gt;&gt;% sqrt %&gt;% esc
</code></pre>

<hr>
<h2 id='extract_metadata'>Extract docstring and meta data from an anonymous function</h2><span id='topic+extract_metadata'></span>

<h3>Description</h3>

<p>Currently the docstring must come first and the metadata list must come
second. Both must precede any other code in the function. These constraints
may be relaxed in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_metadata(expr, env = parent.frame(), skip_name = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_metadata_+3A_expr">expr</code></td>
<td>
<p>an expression with an optional docstring as the first statement</p>
</td></tr>
<tr><td><code id="extract_metadata_+3A_env">env</code></td>
<td>
<p>Environment in which to search for functions</p>
</td></tr>
<tr><td><code id="extract_metadata_+3A_skip_name">skip_name</code></td>
<td>
<p>Do not attempt to find function matching expressions of
type 'name'. If FALSE, then a function will by searched for with name
<code>expr</code> if <code>expr</code> is a name. This leads to <code>expr</code> being
evaluated, which raises errors outside the purview of Rmonad. For example,
<code>extract_metadata(stop("dying"))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of three elements, the expression with the docstring and
metadata removed, the docstring itself, and the metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## extract metadata from a block 
expr &lt;- substitute(
  {
    "this is the docstring"
    list(foo="this is meta data")
    5 * 32
  }
)
extract_metadata(expr)
</code></pre>

<hr>
<h2 id='fail_cache'>Represent a dummy value for a node downstream of a failing node</h2><span id='topic+fail_cache'></span>

<h3>Description</h3>

<p>Returns a ValueManager that represents a dummy value for a node downstream
of a failing node. Unlike <code>void_cache</code>, this presence of this manager
in a pipeline is not pathological, so does not raise a warning by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fail_cache()
</code></pre>


<h3>Value</h3>

<p>A function that represents an unrun node
</p>


<h3>See Also</h3>

<p>Other cache: <code><a href="#topic+clear_cache">clear_cache</a></code>,
<code><a href="#topic+make_cacher">make_cacher</a></code>, <code><a href="#topic+make_recacher">make_recacher</a></code>,
<code><a href="#topic+memory_cache">memory_cache</a></code>, <code><a href="#topic+no_cache">no_cache</a></code>,
<code><a href="#topic+void_cache">void_cache</a></code>
</p>

<hr>
<h2 id='false'>Return false for all input</h2><span id='topic+false'></span>

<h3>Description</h3>

<p>Return false for all input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>false(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="false_+3A_...">...</code></td>
<td>
<p>whatever</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper_functions: <code><a href="#topic+const">const</a></code>,
<code><a href="#topic+false_as_error">false_as_error</a></code>,
<code><a href="#topic+null_as_error">null_as_error</a></code>, <code><a href="#topic+toss">toss</a></code>,
<code><a href="#topic+true">true</a></code>
</p>

<hr>
<h2 id='false_as_error'>Make NULL values an error</h2><span id='topic+false_as_error'></span>

<h3>Description</h3>

<p>Make NULL values an error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>false_as_error(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="false_as_error_+3A_x">x</code></td>
<td>
<p>Input value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper_functions: <code><a href="#topic+const">const</a></code>,
<code><a href="#topic+false">false</a></code>, <code><a href="#topic+null_as_error">null_as_error</a></code>,
<code><a href="#topic+toss">toss</a></code>, <code><a href="#topic+true">true</a></code>
</p>

<hr>
<h2 id='first'>Given two arguments, return the first</h2><span id='topic+first'></span>

<h3>Description</h3>

<p>Given two arguments, return the first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="first_+3A_x">x</code></td>
<td>
<p>anything</p>
</td></tr>
<tr><td><code id="first_+3A_y">y</code></td>
<td>
<p>anything</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other help_functions: <code><a href="#topic+nothing">nothing</a></code>,
<code><a href="#topic+second">second</a></code>
</p>

<hr>
<h2 id='get_dependency_matrix'>Get dependencies of local variables on inputs</h2><span id='topic+get_dependency_matrix'></span>

<h3>Description</h3>

<p>Get dependencies of local variables on inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dependency_matrix(declarations, bound_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dependency_matrix_+3A_declarations">declarations</code></td>
<td>
<p>A list of declarations</p>
</td></tr>
<tr><td><code id="get_dependency_matrix_+3A_bound_vars">bound_vars</code></td>
<td>
<p>Character vector of variables names that are bound as
arguments to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical matrix
</p>

<hr>
<h2 id='gff'>Data for GFF processing vignette</h2><span id='topic+gff'></span>

<h3>Description</h3>

<p>Contains 4 files:
</p>

<ol>
<li><p> good - a valid GFF string
</p>
</li>
<li><p> not_a_gff1 - a string that is not a GFF file at all
</p>
</li>
<li><p> invalid_type - a table with invalid types
</p>
</li>
<li><p> good_result - the final pipeline produced using the good gff
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>gff
</code></pre>


<h3>Format</h3>

<p>List</p>

<hr>
<h2 id='infix'>Infix operators</h2><span id='topic+infix'></span><span id='topic++25+3E+3E+25'></span><span id='topic++25v+3E+25'></span><span id='topic++25+2A+3E+25'></span><span id='topic++25+3E_+25'></span><span id='topic++25+3E+5E+25'></span><span id='topic++25+5E+3E+25'></span><span id='topic++25+7C+3E+25'></span><span id='topic++25+7C+7C+25'></span><span id='topic++25__+25'></span>

<h3>Description</h3>

<p>Infix monadic sequence operators
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;&gt;% rhs

lhs %v&gt;% rhs

lhs %*&gt;% rhs

lhs %&gt;_% rhs

lhs %&gt;^% rhs

lhs %^&gt;% rhs

lhs %|&gt;% rhs

lhs %||% rhs

lhs %__% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infix_+3A_lhs">lhs</code></td>
<td>
<p>left hand side value</p>
</td></tr>
<tr><td><code id="infix_+3A_rhs">rhs</code></td>
<td>
<p>right hand side value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the main package help page (<code>?rmonad</code>) or the <code>intro</code> and
<code>cheatsheet</code> vignettes for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>256 %&gt;&gt;% sqrt
256 %v&gt;% sqrt
list(1,2,3) %*&gt;% sum
iris %&gt;_% plot %&gt;&gt;% summary 
1:10 %&gt;^% rgamma(10, 5) %&gt;^% rgamma(10, 6) %^&gt;% cor
1:10 %&gt;&gt;% colSums %|&gt;% sum
stop("die") %||% 4 %&gt;&gt;% sqrt
16 %&gt;&gt;% sqrt %__% 25 %&gt;&gt;% sqrt
</code></pre>

<hr>
<h2 id='is_rmonad'>Determine whether something is an Rmonad object</h2><span id='topic+is_rmonad'></span>

<h3>Description</h3>

<p>Determine whether something is an Rmonad object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_rmonad(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_rmonad_+3A_m">m</code></td>
<td>
<p>Rmonad object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical TRUE if m is an Rmonad
</p>

<hr>
<h2 id='loop'>Apply an rmonad pipeline function to each element in a rmonad bound list</h2><span id='topic+loop'></span>

<h3>Description</h3>

<p>Apply an rmonad pipeline function to each element in a rmonad bound list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop(m, FUN, looper = lapply, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loop_+3A_m">m</code></td>
<td>
<p>Rmonad object wrapping a vector</p>
</td></tr>
<tr><td><code id="loop_+3A_fun">FUN</code></td>
<td>
<p>function of an element from the vector stored in <code>m</code> that
returns an Rmonad object.</p>
</td></tr>
<tr><td><code id="loop_+3A_looper">looper</code></td>
<td>
<p>function that applies each element in the input vector to
<code>FUN</code>. The default it <code>lapply</code>.</p>
</td></tr>
<tr><td><code id="loop_+3A_...">...</code></td>
<td>
<p>Additional arguments sent to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rmonad object wrapping a vector of the values wrapped by the outputs
of <code>FUN</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- function(x) { x %&gt;&gt;% sqrt }
c(256, 6561) %v&gt;% sqrt %&gt;% loop(foo) %&gt;&gt;% lapply(sqrt)
</code></pre>

<hr>
<h2 id='make_cacher'>Make Cacher object</h2><span id='topic+make_cacher'></span>

<h3>Description</h3>

<p>Make Cacher object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_cacher(f_path = function() getOption("rmonad.cache_dir"),
  f_save = saveRDS, f_get = readRDS, f_del = unlink,
  f_ext = function(cls) ".Rdata")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_cacher_+3A_f_path">f_path</code></td>
<td>
<p>A function for finding the directory in which to cache results</p>
</td></tr>
<tr><td><code id="make_cacher_+3A_f_save">f_save</code></td>
<td>
<p>function of x and filename that saves x to the path filename</p>
</td></tr>
<tr><td><code id="make_cacher_+3A_f_get">f_get</code></td>
<td>
<p>function of filename that retrieves the cached data</p>
</td></tr>
<tr><td><code id="make_cacher_+3A_f_del">f_del</code></td>
<td>
<p>function of filename that deletes the cached data</p>
</td></tr>
<tr><td><code id="make_cacher_+3A_f_ext">f_ext</code></td>
<td>
<p>function of class(x) that determines the filename extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that builds a local cache function for a value
</p>


<h3>See Also</h3>

<p>Other cache: <code><a href="#topic+clear_cache">clear_cache</a></code>,
<code><a href="#topic+fail_cache">fail_cache</a></code>, <code><a href="#topic+make_recacher">make_recacher</a></code>,
<code><a href="#topic+memory_cache">memory_cache</a></code>, <code><a href="#topic+no_cache">no_cache</a></code>,
<code><a href="#topic+void_cache">void_cache</a></code>
</p>

<hr>
<h2 id='make_recacher'>Make a function that takes an Rmonad and recaches it</h2><span id='topic+make_recacher'></span>

<h3>Description</h3>

<p>Make a function that takes an Rmonad and recaches it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_recacher(cacher, preserve = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_recacher_+3A_cacher">cacher</code></td>
<td>
<p>A function of a data value</p>
</td></tr>
<tr><td><code id="make_recacher_+3A_preserve">preserve</code></td>
<td>
<p>logical Should the cached value be preserved across bind operations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that swaps the cache function of an Rmonad
</p>


<h3>See Also</h3>

<p>Other cache: <code><a href="#topic+clear_cache">clear_cache</a></code>,
<code><a href="#topic+fail_cache">fail_cache</a></code>, <code><a href="#topic+make_cacher">make_cacher</a></code>,
<code><a href="#topic+memory_cache">memory_cache</a></code>, <code><a href="#topic+no_cache">no_cache</a></code>,
<code><a href="#topic+void_cache">void_cache</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  recacher &lt;- make_recacher(make_local_cacher())
  m &lt;- iris %&gt;&gt;% summary %&gt;% recacher
  # load the data from a local file
  .single_value(m)

  recacher &lt;- make_recacher(memory_cache)
  m &lt;- iris %&gt;&gt;% summary %&gt;% recacher
  # load the data from memory
  .single_value(m)

## End(Not run)

add1 &lt;- function(x) x+1
add2 &lt;- function(x) x+2
add3 &lt;- function(x) x+3
cc &lt;- make_recacher(make_local_cacher())
3 %&gt;&gt;% add1 %&gt;% cc %&gt;&gt;% add2 %&gt;&gt;% add3 -&gt; m
m
</code></pre>

<hr>
<h2 id='memory_cache'>Store a value in memory</h2><span id='topic+memory_cache'></span>

<h3>Description</h3>

<p>Store a value in memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>memory_cache(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="memory_cache_+3A_x">x</code></td>
<td>
<p>Value to be stored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that returns a value stored in memory
</p>


<h3>See Also</h3>

<p>Other cache: <code><a href="#topic+clear_cache">clear_cache</a></code>,
<code><a href="#topic+fail_cache">fail_cache</a></code>, <code><a href="#topic+make_cacher">make_cacher</a></code>,
<code><a href="#topic+make_recacher">make_recacher</a></code>, <code><a href="#topic+no_cache">no_cache</a></code>,
<code><a href="#topic+void_cache">void_cache</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foo &lt;- 45
foo_proxy &lt;- memory_cache(foo)
foo
foo_proxy@get()
</code></pre>

<hr>
<h2 id='missues'>Tabulates all errors, warnings and notes</h2><span id='topic+missues'></span>

<h3>Description</h3>

<p>Tabulates all errors, warnings and notes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missues(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missues_+3A_m">m</code></td>
<td>
<p>An Rmonad</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other from_Rmonad: <code><a href="#topic+esc">esc</a></code>,
<code><a href="#topic+mtabulate">mtabulate</a></code>, <code><a href="#topic+report">report</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gff)
m &lt;- gff$good_result
missues(m)
</code></pre>

<hr>
<h2 id='mtabulate'>Make tabular summary of a pipeline</h2><span id='topic+mtabulate'></span>

<h3>Description</h3>

<p>Make tabular summary of a pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtabulate(m, code = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtabulate_+3A_m">m</code></td>
<td>
<p>An Rmonad</p>
</td></tr>
<tr><td><code id="mtabulate_+3A_code">code</code></td>
<td>
<p>logical Should the code by included?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other from_Rmonad: <code><a href="#topic+esc">esc</a></code>,
<code><a href="#topic+missues">missues</a></code>, <code><a href="#topic+report">report</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gff)
m &lt;- gff$good_result
mtabulate(m)
</code></pre>

<hr>
<h2 id='no_cache'>Represent a value that has been deleted</h2><span id='topic+no_cache'></span>

<h3>Description</h3>

<p>By default, the value of a node that has already been executed will be set
to this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no_cache()
</code></pre>


<h3>Value</h3>

<p>A function that represents a deleted value
</p>


<h3>See Also</h3>

<p>Other cache: <code><a href="#topic+clear_cache">clear_cache</a></code>,
<code><a href="#topic+fail_cache">fail_cache</a></code>, <code><a href="#topic+make_cacher">make_cacher</a></code>,
<code><a href="#topic+make_recacher">make_recacher</a></code>, <code><a href="#topic+memory_cache">memory_cache</a></code>,
<code><a href="#topic+void_cache">void_cache</a></code>
</p>

<hr>
<h2 id='nothing'>Do nothing</h2><span id='topic+nothing'></span>

<h3>Description</h3>

<p>Do nothing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nothing(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nothing_+3A_...">...</code></td>
<td>
<p>anything</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>See Also</h3>

<p>Other help_functions: <code><a href="#topic+first">first</a></code>,
<code><a href="#topic+second">second</a></code>
</p>

<hr>
<h2 id='null_as_error'>Make NULL values an error</h2><span id='topic+null_as_error'></span>

<h3>Description</h3>

<p>Currently not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_as_error(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_as_error_+3A_x">x</code></td>
<td>
<p>Input value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper_functions: <code><a href="#topic+const">const</a></code>,
<code><a href="#topic+false_as_error">false_as_error</a></code>, <code><a href="#topic+false">false</a></code>,
<code><a href="#topic+toss">toss</a></code>, <code><a href="#topic+true">true</a></code>
</p>

<hr>
<h2 id='plot.Rmonad'>Render an Rmonad graph</h2><span id='topic+plot.Rmonad'></span>

<h3>Description</h3>

<p>Convert the Rmonad object to a DiagrammeR graph and then render it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rmonad'
plot(x, y, label = NULL, color = "status", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Rmonad_+3A_x">x</code></td>
<td>
<p>An Rmonad object</p>
</td></tr>
<tr><td><code id="plot.Rmonad_+3A_y">y</code></td>
<td>
<p>This variable is currently ignored</p>
</td></tr>
<tr><td><code id="plot.Rmonad_+3A_label">label</code></td>
<td>
<p>The node labels. If NULL, the node labels will equal node ids.
It may be one of the strings ['code', 'time', 'space', 'value', 'depth']. If
'value' is selected, nodes with no value cached are represented with '-'.
Alternatively, it may be a function that maps a single Rmonad object to a
string.</p>
</td></tr>
<tr><td><code id="plot.Rmonad_+3A_color">color</code></td>
<td>
<p>How to color the nodes. Default is 'status', which colors green
for passing, orange for warning, and red for error. Alternatively, color can
be a function of an Rmonad object, which will be applied to each node.</p>
</td></tr>
<tr><td><code id="plot.Rmonad_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to plot.igraph. These arguments may
override rmonad plotting defaults and behavior specified by the 'label' and
'color' parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The nodes in the graph represent both a function and the function's output.
The edges are relationships between nodes. In an unnested pipeline, every
edge represents data flow from source to sink (solid black edges). Nested
pipelines contain three additional edge types: a transitive edge, where a
node is dependent on a value that was passed to its parent (dotted gray
line); a nest edge linking a node to the nested node that produced its value
(solid red line); a 'prior' edge for pipelines coupled with the <code>%__%</code>
operator (thick dotted blue line).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gff)
# default plot
plot(gff$good_result)
# turn off vertex labels and set vertex size
plot(gff$good_result, vertex.size=10, vertex.label=NA)
</code></pre>

<hr>
<h2 id='print.Rmonad'>Rmonad print generic function</h2><span id='topic+print.Rmonad'></span>

<h3>Description</h3>

<p>Rmonad print generic function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Rmonad'
print(x, verbose = FALSE, value = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Rmonad_+3A_x">x</code></td>
<td>
<p>An Rmonad object</p>
</td></tr>
<tr><td><code id="print.Rmonad_+3A_verbose">verbose</code></td>
<td>
<p>logical print verbose output (include benchmarking)</p>
</td></tr>
<tr><td><code id="print.Rmonad_+3A_value">value</code></td>
<td>
<p>logical print the value wrapped in the Rmonad</p>
</td></tr>
<tr><td><code id="print.Rmonad_+3A_...">...</code></td>
<td>
<p>Additional arguments (unused)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m1 &lt;- 256 %v&gt;% sqrt %&gt;&gt;% sqrt %&gt;&gt;% sqrt
print(m1)
print(m1, verbose=TRUE)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='report'>Convert a pipeline to Rmarkdown</h2><span id='topic+report'></span>

<h3>Description</h3>

<p>Plots an rmonad workflow, summarizes the nodes, lists issues, and lists
details for each node. This function is likely to change extensively in the
future. It should be seen as one example of the kind of report that can be
generated by rmonad, rather than THE report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(m, prefix = "report")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="report_+3A_m">m</code></td>
<td>
<p>An Rmonad</p>
</td></tr>
<tr><td><code id="report_+3A_prefix">prefix</code></td>
<td>
<p>A file prefix for the generated report</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other from_Rmonad: <code><a href="#topic+esc">esc</a></code>,
<code><a href="#topic+missues">missues</a></code>, <code><a href="#topic+mtabulate">mtabulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
report(-1:2 %&gt;&gt;% log %&gt;&gt;% sqrt %__% "asdf" %&gt;&gt;% sqrt)

## End(Not run)
</code></pre>

<hr>
<h2 id='rmonad_checkers'>Vectorized existence checkers for public Rmonad fields</h2><span id='topic+rmonad_checkers'></span><span id='topic+has_code'></span><span id='topic+has_tag'></span><span id='topic+has_error'></span><span id='topic+has_doc'></span><span id='topic+has_warnings'></span><span id='topic+has_notes'></span><span id='topic+has_meta'></span><span id='topic+has_time'></span><span id='topic+has_mem'></span><span id='topic+has_value'></span><span id='topic+has_parents'></span><span id='topic+has_dependents'></span><span id='topic+has_prior'></span><span id='topic+has_nest'></span><span id='topic+has_summary'></span>

<h3>Description</h3>

<p>Vectorized existence checkers for public Rmonad fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_code(m, ...)

has_tag(m, ...)

has_error(m, ...)

has_doc(m, ...)

has_warnings(m, ...)

has_notes(m, ...)

has_meta(m, ...)

has_time(m, ...)

has_mem(m, ...)

has_value(m, ...)

has_parents(m, ...)

has_dependents(m, ...)

has_prior(m, ...)

has_nest(m, ...)

has_summary(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmonad_checkers_+3A_m">m</code></td>
<td>
<p>An Rmonad object</p>
</td></tr>
<tr><td><code id="rmonad_checkers_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>get_*</code> functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(gff)
m &lt;- gff$good_result

has_code(m)
has_dependents(m)
has_doc(m)
has_error(m)
has_mem(m)
has_meta(m)
has_nest(m)
has_notes(m)
has_parents(m)
has_prior(m)
has_summary(m)
has_time(m)
has_value(m)
has_warnings(m)

# find root nodes
which(!has_parents(m))

# find terminal (output) nodes
which(!has_dependents(m))

# count number of independent chains
sum(has_prior(m)) + 1
</code></pre>

<hr>
<h2 id='rmonad_getters'>Vectorized getters for public Rmonad fields</h2><span id='topic+rmonad_getters'></span><span id='topic+get_parents'></span><span id='topic+get_dependents'></span><span id='topic+get_nest'></span><span id='topic+get_prior'></span><span id='topic+get_depth'></span><span id='topic+get_nest_depth'></span><span id='topic+get_value'></span><span id='topic+get_key'></span><span id='topic+get_id'></span><span id='topic+get_OK'></span><span id='topic+get_code'></span><span id='topic+get_tag'></span><span id='topic+get_error'></span><span id='topic+get_warnings'></span><span id='topic+get_notes'></span><span id='topic+get_doc'></span><span id='topic+get_meta'></span><span id='topic+get_time'></span><span id='topic+get_mem'></span><span id='topic+get_summary'></span>

<h3>Description</h3>

<p>Vectorized getters for public Rmonad fields
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parents(m, index = .get_ids(m), tag = NULL)

get_dependents(m, index = .get_ids(m), tag = NULL)

get_nest(m, index = .get_ids(m), tag = NULL)

get_prior(m, index = .get_ids(m), tag = NULL)

get_depth(m, index = .get_ids(m), tag = NULL)

get_nest_depth(m, index = .get_ids(m), tag = NULL)

get_value(m, index = .get_ids(m), tag = NULL, warn = TRUE)

get_key(m, index = .get_ids(m), tag = NULL)

get_id(m, index = .get_ids(m), tag = NULL)

get_OK(m, index = .get_ids(m), tag = NULL)

get_code(m, index = .get_ids(m), tag = NULL)

get_tag(m, index = .get_ids(m), tag = NULL)

get_error(m, index = .get_ids(m), tag = NULL)

get_warnings(m, index = .get_ids(m), tag = NULL)

get_notes(m, index = .get_ids(m), tag = NULL)

get_doc(m, index = .get_ids(m), tag = NULL)

get_meta(m, index = .get_ids(m), tag = NULL)

get_time(m, index = .get_ids(m), tag = NULL)

get_mem(m, index = .get_ids(m), tag = NULL)

get_summary(m, index = .get_ids(m), tag = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmonad_getters_+3A_m">m</code></td>
<td>
<p>An Rmonad object</p>
</td></tr>
<tr><td><code id="rmonad_getters_+3A_index">index</code></td>
<td>
<p>Selection of indices to extract (all by default). The indices
may be a vector of integers, node names, or igraph vertices
(<code>igraph.vs</code>).</p>
</td></tr>
<tr><td><code id="rmonad_getters_+3A_tag">tag</code></td>
<td>
<p>character vector specifying the tags that must be associated with extracted nodes</p>
</td></tr>
<tr><td><code id="rmonad_getters_+3A_warn">warn</code></td>
<td>
<p>logical In get_value, raise a warning on an attempt to access an uncached node</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(gff)
m &lt;- gff$good_result

# vectorized accessors for all stored slots
get_value(m, warn=FALSE)
get_OK(m)
get_code(m)
get_dependents(m)
get_doc(m)
get_error(m)
get_id(m)
get_mem(m)
get_meta(m)
get_nest(m)
get_nest_depth(m)
get_notes(m)
get_parents(m)
get_prior(m)
get_summary(m)
get_time(m)
get_warnings(m)

# get the code associated with long running functions
get_code(m)[get_time(m) &gt; 0.1]

# Calculate the average node degree
nparents &lt;- sapply(get_parents(m), length)
nchildren &lt;- sapply(get_dependents(m), length)
sum(nparents + nchildren) / size(m) 
</code></pre>

<hr>
<h2 id='second'>Given two arguments, return the second</h2><span id='topic+second'></span>

<h3>Description</h3>

<p>Given two arguments, return the second
</p>


<h3>Usage</h3>

<pre><code class='language-R'>second(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="second_+3A_x">x</code></td>
<td>
<p>anything</p>
</td></tr>
<tr><td><code id="second_+3A_y">y</code></td>
<td>
<p>anything</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other help_functions: <code><a href="#topic+first">first</a></code>,
<code><a href="#topic+nothing">nothing</a></code>
</p>

<hr>
<h2 id='size'>Return the number of nodes in the workflow</h2><span id='topic+size'></span>

<h3>Description</h3>

<p>Return the number of nodes in the workflow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="size_+3A_m">m</code></td>
<td>
<p>Rmonad object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- 256 %&gt;&gt;% sqrt %&gt;&gt;% sqrt
size(m)
</code></pre>

<hr>
<h2 id='splice_function'>Take a monadic bind operation's result and splice histories</h2><span id='topic+splice_function'></span>

<h3>Description</h3>

<p>We need to link input variables to the nodes in the nested pipeline that use
them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splice_function(f, m, ms, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splice_function_+3A_f">f</code></td>
<td>
<p>The function</p>
</td></tr>
<tr><td><code id="splice_function_+3A_m">m</code></td>
<td>
<p>The monadic result of running f(ms)</p>
</td></tr>
<tr><td><code id="splice_function_+3A_ms">ms</code></td>
<td>
<p>The list of inputs passed to f</p>
</td></tr>
<tr><td><code id="splice_function_+3A_...">...</code></td>
<td>
<p>additional arguments passed to add_transitive_edges</p>
</td></tr>
</table>

<hr>
<h2 id='tag'>Set the tag of an Rmonad object</h2><span id='topic+tag'></span>

<h3>Description</h3>

<p>Set the tag of an Rmonad object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tag(m, ..., index = m@head)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tag_+3A_m">m</code></td>
<td>
<p>Rmonad object</p>
</td></tr>
<tr><td><code id="tag_+3A_...">...</code></td>
<td>
<p>one or more tags for the given nodes</p>
</td></tr>
<tr><td><code id="tag_+3A_index">index</code></td>
<td>
<p>character or integer vector, specifying the nodes which will be
assigned the new tag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rmonad object with new tags
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
1 %&gt;&gt;% prod(2) %&gt;% tag('a/b') %&gt;&gt;% prod(3) %&gt;% get_tag

</code></pre>

<hr>
<h2 id='toss'>Take input and do nothing with it</h2><span id='topic+toss'></span>

<h3>Description</h3>

<p>Take input and do nothing with it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toss(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toss_+3A_...">...</code></td>
<td>
<p>whatever</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper_functions: <code><a href="#topic+const">const</a></code>,
<code><a href="#topic+false_as_error">false_as_error</a></code>, <code><a href="#topic+false">false</a></code>,
<code><a href="#topic+null_as_error">null_as_error</a></code>, <code><a href="#topic+true">true</a></code>
</p>

<hr>
<h2 id='true'>Return true for all input</h2><span id='topic+true'></span>

<h3>Description</h3>

<p>Return true for all input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>true(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="true_+3A_...">...</code></td>
<td>
<p>whatever</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other helper_functions: <code><a href="#topic+const">const</a></code>,
<code><a href="#topic+false_as_error">false_as_error</a></code>, <code><a href="#topic+false">false</a></code>,
<code><a href="#topic+null_as_error">null_as_error</a></code>, <code><a href="#topic+toss">toss</a></code>
</p>

<hr>
<h2 id='view'>Set the head of an Rmonad to a particular tag</h2><span id='topic+view'></span>

<h3>Description</h3>

<p>Will split on '/'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>view(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="view_+3A_m">m</code></td>
<td>
<p>Rmonad object</p>
</td></tr>
<tr><td><code id="view_+3A_...">...</code></td>
<td>
<p>one or more tag strings specifying a unique node in the pipeline</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Rmonad object with head reset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
m &lt;- 256 %v&gt;% sqrt %&gt;% tag('a', 'b') %v&gt;% sqrt
esc(view(m, 'a/b'))
funnel(view(m, 'a'), m) %*&gt;% sum
</code></pre>

<hr>
<h2 id='viewID'>Move head to this id</h2><span id='topic+viewID'></span>

<h3>Description</h3>

<p>Move head to this id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewID(m, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewID_+3A_m">m</code></td>
<td>
<p>rmonad object</p>
</td></tr>
<tr><td><code id="viewID_+3A_id">id</code></td>
<td>
<p>integer index</p>
</td></tr>
</table>

<hr>
<h2 id='viewIDs'>Return a list of Rmonad objects at these positions</h2><span id='topic+viewIDs'></span>

<h3>Description</h3>

<p>Return a list of Rmonad objects at these positions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewIDs(m, ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewIDs_+3A_m">m</code></td>
<td>
<p>rmonad object</p>
</td></tr>
<tr><td><code id="viewIDs_+3A_ids">ids</code></td>
<td>
<p>integer vector index</p>
</td></tr>
</table>

<hr>
<h2 id='views'>Get a list of Rmonad objects matching the given tag</h2><span id='topic+views'></span>

<h3>Description</h3>

<p>Get a list of Rmonad objects matching the given tag
</p>


<h3>Usage</h3>

<pre><code class='language-R'>views(m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="views_+3A_m">m</code></td>
<td>
<p>Rmonad object</p>
</td></tr>
<tr><td><code id="views_+3A_...">...</code></td>
<td>
<p>one or more tags</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of Rmonad objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
1 %&gt;&gt;% prod(2) %&gt;% tag('a/b') %&gt;&gt;%
       prod(2) %&gt;% tag('a/c') %&gt;&gt;%
       prod(2) %&gt;% tag('a/c') %&gt;&gt;%
       prod(2) %&gt;% tag('g/a') -&gt; m
views(m, 'a')
</code></pre>

<hr>
<h2 id='void_cache'>Represent a value that has not been set</h2><span id='topic+void_cache'></span>

<h3>Description</h3>

<p>This is the default value of RmonadData@value. It should always be replaced
shortly after the object is created, thus should only be encountered if 1)
the user is directly creating RmonadData objects (in which case they should
be spoken to sternly) or 2) there is a bug in rmonad.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>void_cache()
</code></pre>


<h3>Value</h3>

<p>A function that represents a void, uncached value
</p>


<h3>See Also</h3>

<p>Other cache: <code><a href="#topic+clear_cache">clear_cache</a></code>,
<code><a href="#topic+fail_cache">fail_cache</a></code>, <code><a href="#topic+make_cacher">make_cacher</a></code>,
<code><a href="#topic+make_recacher">make_recacher</a></code>, <code><a href="#topic+memory_cache">memory_cache</a></code>,
<code><a href="#topic+no_cache">no_cache</a></code>
</p>

<hr>
<h2 id='x_to_monad'>Conversions to monads</h2><span id='topic+x_to_monad'></span><span id='topic+as_monad'></span><span id='topic+funnel'></span><span id='topic+combine'></span>

<h3>Description</h3>

<p>These functions convert possibly non-monadic inputs into monads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_monad(expr, desc = NULL, tag = NULL, doc = .default_doc(),
  key = NULL, env = parent.frame(), lossy = FALSE)

funnel(..., env = parent.frame(), keep_history = TRUE)

combine(xs, keep_history = TRUE, desc = .default_code())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x_to_monad_+3A_expr">expr</code></td>
<td>
<p>An expression</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_desc">desc</code></td>
<td>
<p>A description of the monad (usually the producing code)</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_tag">tag</code></td>
<td>
<p>Character vector specifying the tag to associate with a node</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_doc">doc</code></td>
<td>
<p>A docstring to associate with the monad</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_key">key</code></td>
<td>
<p>16 byte raw vector</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_env">env</code></td>
<td>
<p>Evaluation environment</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_lossy">lossy</code></td>
<td>
<p>logical Should unnesting with record be done?</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_...">...</code></td>
<td>
<p>multiple expressions</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_keep_history">keep_history</code></td>
<td>
<p>merge the histories of all monads</p>
</td></tr>
<tr><td><code id="x_to_monad_+3A_xs">xs</code></td>
<td>
<p>A list of elements to join into a monad</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each of these functions, failure of any part causes failure of the
whole. Any non-monadic inputs will be converted to monads. Any exceptions
raised in the inputs will be caught.
</p>
<p><code>as_monad</code> evaluate a single expression into an Rmonad. If the value is
already an Rmonad, it will be nested.
</p>
<p><code>funnel</code> evaluates multiple arguments into one Rmonad. It can be used
within pipelines to create multi-input nodes (works well with <code>%*&gt;%</code>).
</p>
<p><code>combine</code> takes a list of Rmonads and joins the elements into one
Rmonad. The values of the original monadic containers joined into a list in
the child Rmonad. The list Rmonads are recorded as the new Rmonad's parents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_monad(stop(1))
as_monad(1:10)
as_monad(5 %&gt;&gt;% sqrt)

## merge failing inputs 
funnel( 1:10, stop(1), sqrt(-3:3) )

## join pipelines
b2 &lt;- letters[1:10] %&gt;&gt;% sqrt
b3 &lt;- -3:6 %&gt;&gt;% log
1:10 %&gt;% funnel(b2,b3) %&gt;&gt;%
  {data.frame(b1=.[[1]], b2=.[[2]], b3=.[[3]])}

z &lt;- list(
  x = rnorm(10) %&gt;&gt;% sqrt,
  y = 1 %&gt;&gt;% colSums
)
combine(z)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
