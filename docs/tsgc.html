<!DOCTYPE html><html lang="en"><head><title>Help for package tsgc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsgc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#argmax'><p>Return index and value of maximum</p></a></li>
<li><a href='#df2ldl'><p>Compute log growth rate of cumulated dataset</p></a></li>
<li><a href='#england'><p>Cumulative cases of Covid-19 in England.</p></a></li>
<li><a href='#FilterResults-class'><p>FilterResults</p></a></li>
<li><a href='#forecast_peak'><p>Returns forecast of number of periods until peak given</p>
<code>KFAS::KFS</code> output.</a></li>
<li><a href='#forecast.peak'><p>Returns forecast of number of periods until peak given estimated</p>
state variables <code class="reqn">\delta</code> and <code class="reqn">\gamma</code>.</a></li>
<li><a href='#gauteng'><p>Cumulative cases of Covid-19 in the South African province of Gauteng.</p></a></li>
<li><a href='#plot_forecast'><p>Plots forecast and realised values of the log cumulative growth rate</p></a></li>
<li><a href='#plot_gy_ci'><p>Plots the growth rates and slope of the log cumulative growth rate</p></a></li>
<li><a href='#plot_gy_components'><p>Plots the growth rates and slope of the log cumulative growth rate</p></a></li>
<li><a href='#plot_holdout'><p>Plots the forecast of new cases (the difference of the cumulated</p>
variable) over a holdout sample.</a></li>
<li><a href='#plot_new_cases'><p>Plots the forecast of new cases (the difference of the cumulated</p>
variable)</a></li>
<li><a href='#reinitialise_dataframe'><p>Reinitialise a data frame by subtracting the <code>reinit.date</code> row from</p>
all columns</a></li>
<li><a href='#SSModelBase-class'><p>Base class for estimating time-series growth curve models. Classes</p>
<code>SSModelDynamicGompertz</code> and <code>SSModelDynGompertzReinit</code> refer back
to this base class.</a></li>
<li><a href='#SSModelDynamicGompertz-class'><p>Class for dynamic Gompertz curve state space model object.</p></a></li>
<li><a href='#SSModelDynGompertzReinit-class'><p>Class for re-initialised dynamic Gompertz curve model</p></a></li>
<li><a href='#write_results'><p>Write a selection of relevant results to disc</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Time Series Methods Based on Growth Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'tsgc' package provides comprehensive tools for the analysis and forecasting of epidemic trajectories.
    It is designed to model the progression of an epidemic over time while accounting for the various uncertainties
    inherent in real-time data. Underpinned by a dynamic Gompertz model, the package adopts a state space approach,
    using the Kalman filter for flexible and robust estimation of the non-linear growth pattern commonly observed in
    epidemic data. The reinitialization feature enhances the modelâ€™s ability to adapt to the emergence of new waves.
    The forecasts generated by the package are of value to public health officials and researchers who need to
    understand and predict the course of an epidemic to inform decision-making. Beyond its application in public
    health, the package is also a useful resource for researchers and practitioners in fields where the trajectories
    of interest resemble those of epidemics, such as innovation diffusion. The package includes functionalities for
    data preprocessing, model fitting, and forecast visualization, as well as tools for evaluating forecast accuracy.
    The core methodologies implemented in 'tsgc' are based on well-established statistical techniques as described in
    Harvey and Kattuman (2020) &lt;<a href="https://doi.org/10.1162%2F99608f92.828f40de">doi:10.1162/99608f92.828f40de</a>&gt;, Harvey and Kattuman (2021)
    &lt;<a href="https://doi.org/10.1098%2Frsif.2021.0179">doi:10.1098/rsif.2021.0179</a>&gt;, and Ashby, Harvey, Kattuman, and Thamotheram (2024)
    <a href="https://www.jbs.cam.ac.uk/wp-content/uploads/2024/03/cchle-tsgc-paper-2024.pdf">https://www.jbs.cam.ac.uk/wp-content/uploads/2024/03/cchle-tsgc-paper-2024.pdf</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Craig-PT/tsgc">https://github.com/Craig-PT/tsgc</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggfortify, knitr, RColorBrewer, rmarkdown, ggforce,
gridExtra, latex2exp, here, timetk, testthat, purrr, kableExtra</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>KFAS, xts, ggplot2, ggthemes, zoo, magrittr, scales, dplyr,
tidyr, methods</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Craig-PT/tsgc/issues">https://github.com/Craig-PT/tsgc/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-19 22:05:29 UTC; ct</td>
</tr>
<tr>
<td>Author:</td>
<td>Craig Thamotheram [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Craig Thamotheram &lt;cpt@tacindex.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-26 12:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='argmax'>Return index and value of maximum</h2><span id='topic+argmax'></span>

<h3>Description</h3>

<p>Something similar to Python's argmax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argmax(x, decreasing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="argmax_+3A_x">x</code></td>
<td>
<p>Object to have its maximum found</p>
</td></tr>
<tr><td><code id="argmax_+3A_decreasing">decreasing</code></td>
<td>
<p>Logical value indicating whether <code>x</code> should be
ordered in decreasing order. Default is <code>TRUE</code>. Setting this to
<code>FALSE</code> would find the minimum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The maximum value and its index.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
argmax(gauteng)
</code></pre>

<hr>
<h2 id='df2ldl'>Compute log growth rate of cumulated dataset</h2><span id='topic+df2ldl'></span>

<h3>Description</h3>

<p>Helper method to compute the log growth rates of cumulated
variables. It will compute the log cumulative growth rate for each column in
the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2ldl(dt)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df2ldl_+3A_dt">dt</code></td>
<td>
<p>Cumulated data series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of log growth rates of the cumulated variable which has
been inputted via the parameter <code>dt</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
df2ldl(gauteng)


</code></pre>

<hr>
<h2 id='england'>Cumulative cases of Covid-19 in England.</h2><span id='topic+england'></span>

<h3>Description</h3>

<p>Cumulative cases of Covid-19 in England.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(england)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"xts"</code>;
</p>

<dl>
<dt>Cases</dt><dd><p>Cumulative cases of Covid-19</p>
</dd>
</dl>



<h3>References</h3>

<p>Downloaded from https://ukhsa-dashboard.data.gov.uk/topics/covid-19
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(england)
# plot daily cases
plot(diff(england))
</code></pre>

<hr>
<h2 id='FilterResults-class'>FilterResults</h2><span id='topic+FilterResults-class'></span><span id='topic+FilterResults'></span>

<h3>Description</h3>

<p>Class for estimated Dynamic Gompertz Curve model and contains
methods to extract smoothed/filtered estimates of the states, the level of
the incidence variable <code class="reqn">y</code>, and forecasts of <code class="reqn">y</code>.
</p>


<h3>Methods</h3>


<dl>
<dt><code>get_growth_y(smoothed = FALSE, return.components = FALSE)</code></dt><dd><p>Returns the growth rate of the incidence (<code class="reqn">y</code>) of the cumulated
variable (<code class="reqn">Y</code>). Computed as
</p>
<p style="text-align: center;"><code class="reqn">g_t = \exp\{\delta_t\}+\gamma_t.</code>
</p>



<h4>Parameters</h4>


<ul>
<li><p><code>smoothed</code> Logical value indicating whether to use the
smoothed estimates of <code class="reqn">\delta</code> and <code class="reqn">\gamma</code> to compute the
growth rate (<code>TRUE</code>), or the contemporaneous filtered estimates
(<code>FALSE</code>). Default is <code>FALSE</code>.
</p>
</li>
<li><p><code>return.components</code> Logical value indicating whether to
return the estimates of <code class="reqn">\delta</code> and <code class="reqn">\gamma</code> as well as
the estimates of the growth rate, or just the growth rate. Default is
<code>FALSE</code>.
</p>
</li></ul>



<h4>Return Value</h4>

<p><code>xts</code> object containing
smoothed/filtered growth rates and components (<code class="reqn">\delta</code> and
<code class="reqn">\gamma</code>), where applicable.</p>
</dd>
<dt><code>get_gy_ci(smoothed = FALSE, confidence_level = 0.68)</code></dt><dd><p>Returns the growth rate of the incidence (<code class="reqn">y</code>) of the cumulated
variable (<code class="reqn">Y</code>). Computed as
</p>
<p style="text-align: center;"><code class="reqn">g_t = \exp\{\delta_t\}+\gamma_t.</code>
</p>



<h4>Parameters</h4>


<ul>
<li><p><code>smoothed</code> Logical value indicating whether to use the
smoothed estimates of <code class="reqn">\delta</code> and <code class="reqn">\gamma</code> to compute the
growth rate (<code>TRUE</code>), or the contemporaneous filtered estimates
(<code>FALSE</code>). Default is <code>FALSE</code>.
</p>
</li>
<li><p><code>confidence_level</code> Confidence level for the confidence
interval.  Default is <code class="reqn">0.68</code>, which is one standard deviation for
a normally distributed random variable.
</p>
</li></ul>



<h4>Return Value</h4>

<p><code>xts</code> object containing smoothed/filtered
growth rates and upper and lower bounds for the confidence intervals.</p>
</dd>
<dt><code>predict_all(n.ahead, sea.on = FALSE, return.all = FALSE)</code></dt><dd><p>Returns forecasts of the incidence variable <code class="reqn">y</code>, the state variables
and the conditional covariance matrix
for the states.
</p>


<h4>Parameters</h4>


<ul>
<li><p><code>n.ahead</code> The number of forecasts you wish to create from
the end of your sample period.
</p>
</li>
<li><p><code>sea.on</code> Logical value indicating whether seasonal
components should be included in the
state-space model or not. Default is <code>TRUE</code>.
</p>
</li>
<li><p><code>return.all</code> Logical value indicating whether to return
all filtered estimates and forecasts
(<code>TRUE</code>) or only the forecasts (<code>FALSE</code>). Default is
<code>FALSE</code>.
</p>
</li></ul>



<h4>Return Value</h4>

<p><code>xts</code> object containing the forecast
(and filtered, where applicable) level
of <code class="reqn">y</code> (<code>y.hat</code>), <code class="reqn">\delta</code> (<code>level.t.t</code>),
<code class="reqn">\gamma</code> (<code>slope.t.t</code>), vector of states including the
seasonals where applicable (<code>a.t.t</code>) and covariance matrix of all
states including seasonals where applicable (<code>P.t.t</code>).</p>
</dd>
<dt><code>predict_level(
  y.cum,
  n.ahead,
  confidence_level,
  sea.on = FALSE,
  return.diff = FALSE
)</code></dt><dd><p>Forecast the cumulated variable or the incidence of it. This function returns
the forecast of the cumulated variable <code class="reqn">Y</code>, or the forecast of the incidence of the cumulated variable, <code class="reqn">y</code>. For
example, in the case of an epidemic, <code class="reqn">y</code> might be daily new cases of
the disease and
<code class="reqn">Y</code> the cumulative number of recorded infections.
</p>


<h4>Parameters</h4>


<ul>
<li><p><code>y.cum</code> The cumulated variable.
</p>
</li>
<li><p><code>n.ahead</code> The number of periods ahead you wish to forecast from
the end of the estimation window.
</p>
</li>
<li><p><code>confidence_level</code> The confidence level for the log growth
rate that should be used to compute
the forecast intervals of <code class="reqn">y</code>.
</p>
</li>
<li><p><code>return.diff</code> Logical value indicating whether to return the cumulated variable,
<code class="reqn">Y</code>, or the incidence of it,
<code class="reqn">y</code> (i.e., the first difference of the cumulated variable). Default is
<code>FALSE</code>.
</p>
</li></ul>



<h4>Return Value</h4>

<p><code>xts</code> object containing the point
forecasts and upper and lower bounds of
the forecast interval.</p>
</dd>
<dt><code>print_estimation_results()</code></dt><dd><p>Prints a table of estimated parameters in a format ready to paste into
LaTeX.</p>
</dd>
</dl>


<h3>References</h3>

<p>Harvey, A. C. and Kattuman, P. (2021). A Farewell to R:
Time Series Models for Tracking and
Forecasting Epidemics, Journal of the Royal Society Interface, vol 18(182):
20210179
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-20")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()
# Print estimation results
res$print_estimation_results()
# Forecast 7 days ahead from the end of the estimation window
res$predict_level(y.cum = gauteng[idx.est], n.ahead = 7,
  confidence_level = 0.68)
# Forecast 7 days ahead from the model and return filtered states
res$predict_all(n.ahead = 7, return.all = TRUE)
# Return the filtered growth rate and its components
res$get_growth_y(return.components = TRUE)
# Return smoothed growth rate of incidence variable and its confidence
# interval
res$get_gy_ci(smoothed = TRUE, confidence_level = 0.68)

</code></pre>

<hr>
<h2 id='forecast_peak'>Returns forecast of number of periods until peak given
<code>KFAS::KFS</code> output.</h2><span id='topic+forecast_peak'></span>

<h3>Description</h3>

<p>Since Harvey and Kattuman (2021) show that </p>
<p style="text-align: center;"><code class="reqn">g_{y,t+\ell|T}
= \exp\{\delta_{T|T}+\ell \gamma_{T|T}\}+\gamma_{T|T},</code>
</p>
<p> we can compute the
<code class="reqn">\ell</code> for which <code class="reqn">g_{y,t}=0</code> and then will fall below zero. This
<code class="reqn">\ell</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\ell = \frac{\ln(-\gamma_{T|T})-\delta_{T|T}}{\gamma_{T|T}}.</code>
</p>
<p> This is
predicated on <code class="reqn">\gamma_{T|T}&lt;0</code>, else there is super-exponential growth
and no peak in sight. Of course, it only makes sense to investigate an
upcoming peak for <code class="reqn">g_{y,T|T}&gt;0</code> (when cases are growing). The estimates
of <code class="reqn">\delta_{T|T}</code> and <code class="reqn">\gamma_{T|T}</code> are extracted from the
<code>KFS</code> object passed to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast_peak(kfs_out)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast_peak_+3A_kfs_out">kfs_out</code></td>
<td>
<p>The <code>KFAS::KFS</code> object for which the forecast peak is to
be calculated. This would be the <code>output</code> element of a model estimated
in the <code>SSModelDynamicGompertz</code> or <code>SSModelDynamic</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forecast of number of periods until peak.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-06")

res &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)$estimate()

forecast_peak(res$output)

</code></pre>

<hr>
<h2 id='forecast.peak'>Returns forecast of number of periods until peak given estimated
state variables <code class="reqn">\delta</code> and <code class="reqn">\gamma</code>.</h2><span id='topic+forecast.peak'></span>

<h3>Description</h3>

<p>Since Harvey and Kattuman (2021) show that
</p>
<p style="text-align: center;"><code class="reqn">g_{y,t+\ell|T} = \exp\{\delta_{T|T}+\ell \gamma_{T|T}\}+\gamma_{T|T},</code>
</p>

<p>we can compute the <code class="reqn">\ell</code> for which <code class="reqn">g_{y,t}=0</code> and then will fall
below zero. This <code class="reqn">\ell</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\ell = \frac{\ln(-\gamma_{T|T})-\delta_{T|T}}{\gamma_{T|T}}.</code>
</p>
<p> This is
predicated on <code class="reqn">\gamma_{T|T}&lt;0</code>, else there is super-exponential growth an
no peak in sight. Of course, it only makes sense to investigate an upcoming
peak for <code class="reqn">g_{y,T|T}&gt;0</code> (when cases are growing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast.peak(delta, gamma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast.peak_+3A_delta">delta</code></td>
<td>
<p>The estimate of <code class="reqn">\delta</code>, the level of <code class="reqn">\ln g</code>.</p>
</td></tr>
<tr><td><code id="forecast.peak_+3A_gamma">gamma</code></td>
<td>
<p>The estimate of <code class="reqn">\gamma</code>, the slope of <code class="reqn">\ln g</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Forecast of number of periods until peak.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Forecasts the peak of an epidemic with gamma &lt; 0 so that a peak is in
# sight.
forecast.peak(-2.87,-0.045)

# Does not return a result (returns an error as gamma &gt; 0)
try(forecast.peak(-2.87,0.045), silent=TRUE)

</code></pre>

<hr>
<h2 id='gauteng'>Cumulative cases of Covid-19 in the South African province of Gauteng.</h2><span id='topic+gauteng'></span>

<h3>Description</h3>

<p>Cumulative cases of Covid-19 in the South African province of Gauteng.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(gauteng)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"xts"</code>;
</p>

<dl>
<dt>Cases</dt><dd><p>Cumulative cases of Covid-19 from 10th March 2020</p>
</dd>
</dl>



<h3>References</h3>

<p>Downloaded from https://sacoronavirus.co.za/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gauteng)
# plot daily cases
plot(diff(gauteng))
</code></pre>

<hr>
<h2 id='plot_forecast'>Plots forecast and realised values of the log cumulative growth rate</h2><span id='topic+plot_forecast'></span>

<h3>Description</h3>

<p>Plots actual and filtered values of the log cumulative growth
rate (<code class="reqn">\ln(g_t)</code>) in the estimation sample and the forecast and realised
log cumulative growth rate out of the estimation sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_forecast(
  res,
  y.eval,
  n.ahead = 14,
  plt.start.date = NULL,
  title = "",
  caption = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_forecast_+3A_res">res</code></td>
<td>
<p>Results object estimated using the <code>estimate()</code> method.</p>
</td></tr>
<tr><td><code id="plot_forecast_+3A_y.eval">y.eval</code></td>
<td>
<p>The out-of-sample realisation of the log growth rate of the
cumulated variable (i.e. the actual values to which the forecasts should
be compared).</p>
</td></tr>
<tr><td><code id="plot_forecast_+3A_n.ahead">n.ahead</code></td>
<td>
<p>The number of time periods ahead from the end of the sample
to be forecast. The default is 14.</p>
</td></tr>
<tr><td><code id="plot_forecast_+3A_plt.start.date">plt.start.date</code></td>
<td>
<p>Plot start date. Default is <code>NULL</code> which is the
start of the estimation sample.</p>
</td></tr>
<tr><td><code id="plot_forecast_+3A_title">title</code></td>
<td>
<p>Plot title. Enter as text string.</p>
</td></tr>
<tr><td><code id="plot_forecast_+3A_caption">caption</code></td>
<td>
<p>Plot caption. Enter as text string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-20")
idx.eval &lt;- (zoo::index(gauteng) &gt;= as.Date("2020-07-20")) &amp;
     zoo::index(gauteng) &lt;= as.Date("2020-07-27")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()

# Plot forecast and realised log growth rate of cumulative cases
plot_forecast(res, y.eval = df2ldl(gauteng[idx.eval]), n.ahead = 7,
  title = "Forecast ln(g)", plt.start.date = as.Date("2020-07-13"))

</code></pre>

<hr>
<h2 id='plot_gy_ci'>Plots the growth rates and slope of the log cumulative growth rate</h2><span id='topic+plot_gy_ci'></span>

<h3>Description</h3>

<p>Plots the smoothed/filtered growth rate of the difference in the
cumulated variable (<code class="reqn">g_y</code>) and the associated confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gy_ci(
  res,
  plt.start.date = NULL,
  smoothed = FALSE,
  title = NULL,
  series.name = NULL,
  pad.right = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_gy_ci_+3A_res">res</code></td>
<td>
<p>Results object estimated using the <code>estimate()</code> method.</p>
</td></tr>
<tr><td><code id="plot_gy_ci_+3A_plt.start.date">plt.start.date</code></td>
<td>
<p>Plot start date. Default is <code>NULL</code> which is the
start of the estimation sample.</p>
</td></tr>
<tr><td><code id="plot_gy_ci_+3A_smoothed">smoothed</code></td>
<td>
<p>Logical value indicating whether to used the smoothed
estimates of <code class="reqn">\delta</code> and <code class="reqn">\gamma</code>. Default is <code>FALSE</code>, in
which case the filtered estimates are returned.</p>
</td></tr>
<tr><td><code id="plot_gy_ci_+3A_title">title</code></td>
<td>
<p>Title for plot. Enter as text string. <code>NULL</code>
(i.e. no title) by default.</p>
</td></tr>
<tr><td><code id="plot_gy_ci_+3A_series.name">series.name</code></td>
<td>
<p>The name of the series the growth rate is being computed
for. E.g. <code>'New cases'</code>.</p>
</td></tr>
<tr><td><code id="plot_gy_ci_+3A_pad.right">pad.right</code></td>
<td>
<p>Numerical value for the amount of time periods of blank
space you wish to leave on the right of the graph. Extends the horizontal
axis by the given number of time periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-20")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()

# Plot filtered gy, g and gamma
plot_gy_ci(res, plt.start.date = as.Date("2020-07-13"))

</code></pre>

<hr>
<h2 id='plot_gy_components'>Plots the growth rates and slope of the log cumulative growth rate</h2><span id='topic+plot_gy_components'></span>

<h3>Description</h3>

<p>Plots the smoothed/filtered growth rate of the difference in
the cumulated variable (<code class="reqn">g_y</code>), the smoothed/filtered growth rate of the
the cumulated variable (<code class="reqn">g</code>), and the smoothed/filtered slope of
<code class="reqn">\ln(g)</code>, <code class="reqn">\gamma</code>.
Following Harvey and Kattuman (2021), we compute <code class="reqn">g_{y,t}</code> as
</p>
<p style="text-align: center;"><code class="reqn">g_{y,t} = \exp(\delta_t) + \gamma_t.</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>plot_gy_components(res, plt.start.date = NULL, smoothed = FALSE, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_gy_components_+3A_res">res</code></td>
<td>
<p>Results object estimated using the <code>estimate()</code> method.</p>
</td></tr>
<tr><td><code id="plot_gy_components_+3A_plt.start.date">plt.start.date</code></td>
<td>
<p>Plot start date. Default is <code>NULL</code> which is the
start of the estimation sample.</p>
</td></tr>
<tr><td><code id="plot_gy_components_+3A_smoothed">smoothed</code></td>
<td>
<p>Logical value indicating whether to used the smoothed
estimates of <code class="reqn">\delta</code> and <code class="reqn">\gamma</code>. Default is <code>FALSE</code>, in
which case the filtered estimates are returned.</p>
</td></tr>
<tr><td><code id="plot_gy_components_+3A_title">title</code></td>
<td>
<p>Title for plot. Enter as text string. <code>NULL</code> (i.e. no
title) by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-20")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()

# Plot filtered gy, g and gamma
plot_gy_components(res, plt.start.date = as.Date("2020-07-06"))

</code></pre>

<hr>
<h2 id='plot_holdout'>Plots the forecast of new cases (the difference of the cumulated
variable) over a holdout sample.</h2><span id='topic+plot_holdout'></span>

<h3>Description</h3>

<p>Plots actual values of the difference in the cumulated variable,
the forecasts of the cumulated variable (both including and excluding the
seasonal component, where a seasonal is specified) and forecast intervals
around the forecasts, plus the actual outcomes from the holdout sample. The
forecast intervals are based on the prediction intervals for <code class="reqn">\ln(g_t)</code>.
Also reports the mean absolute percentage prediction error over the holdout
sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_holdout(
  res,
  Y,
  Y.eval,
  confidence.level = 0.68,
  date_format = "%Y-%m-%d",
  series.name = NULL,
  title = NULL,
  caption = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_holdout_+3A_res">res</code></td>
<td>
<p>Results object estimated using the <code>estimate()</code> method.</p>
</td></tr>
<tr><td><code id="plot_holdout_+3A_y">Y</code></td>
<td>
<p>Values of the cumulated variable to be used in the estimation
window.</p>
</td></tr>
<tr><td><code id="plot_holdout_+3A_y.eval">Y.eval</code></td>
<td>
<p>Values of the cumulated variable to be used in the holdout
sample (i.e. to which the forecasts should be compared to).</p>
</td></tr>
<tr><td><code id="plot_holdout_+3A_confidence.level">confidence.level</code></td>
<td>
<p>Width of prediction interval for <code class="reqn">\ln(g_t)</code> to
use in forecasts of <code class="reqn">y_t = \Delta Y_t</code>. Default is 0.68, which is
approximately one standard deviation for a Normal distribution.</p>
</td></tr>
<tr><td><code id="plot_holdout_+3A_date_format">date_format</code></td>
<td>
<p>Date format, e.g. <code>'%Y-%m-%d'</code>, which is the
default.</p>
</td></tr>
<tr><td><code id="plot_holdout_+3A_series.name">series.name</code></td>
<td>
<p>Name of the variable you are forecasting for the purposes
of a $y$-axis label. E.g. if <code>series.name = "Cases"</code> the <code class="reqn">y</code>-axis
will show &quot;New Cases&quot;.</p>
</td></tr>
<tr><td><code id="plot_holdout_+3A_title">title</code></td>
<td>
<p>Title for forecast plot. Enter as text string. <code>NULL</code>
(i.e. no title) by default.</p>
</td></tr>
<tr><td><code id="plot_holdout_+3A_caption">caption</code></td>
<td>
<p>Caption for forecast plot. Enter as text string. <code>NULL</code>
(i.e. no caption) by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-20")
idx.eval &lt;- (zoo::index(gauteng) &gt;= as.Date("2020-07-20")) &amp;
     zoo::index(gauteng) &lt;= as.Date("2020-07-27")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()

# Plot forecasts and outcomes over evaluation period
plot_holdout(res = res, Y = gauteng[idx.est], Y.eval = gauteng[idx.eval])

</code></pre>

<hr>
<h2 id='plot_new_cases'>Plots the forecast of new cases (the difference of the cumulated
variable)</h2><span id='topic+plot_new_cases'></span>

<h3>Description</h3>

<p>Plots actual values of the difference in the cumulated variable,
the forecasts of the cumulated variable (both including and excluding the
seasonal component, where a seasonal is specified) and forecast intervals
around the forecasts. The forecast intervals are based on the prediction
intervals for <code class="reqn">\ln(g_t)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_new_cases(
  res,
  Y,
  n.ahead,
  confidence.level = 0.68,
  date_format = "%Y-%m-%d",
  title = NULL,
  plt.start.date = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_new_cases_+3A_res">res</code></td>
<td>
<p>Results object estimated using the <code>estimate()</code> method.</p>
</td></tr>
<tr><td><code id="plot_new_cases_+3A_y">Y</code></td>
<td>
<p>Cumulated variable.</p>
</td></tr>
<tr><td><code id="plot_new_cases_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Number of forecasts (i.e. number of periods ahead to forecast
from end of estimation window).</p>
</td></tr>
<tr><td><code id="plot_new_cases_+3A_confidence.level">confidence.level</code></td>
<td>
<p>Width of prediction interval for <code class="reqn">\ln g_t</code> to
use in forecasts of <code class="reqn">y_t = \Delta Y_t</code>. Default is 0.68, which is
approximately one standard deviation for a Normal distribution.</p>
</td></tr>
<tr><td><code id="plot_new_cases_+3A_date_format">date_format</code></td>
<td>
<p>Date format. Default is <code>'%Y-%m-%d'</code>.</p>
</td></tr>
<tr><td><code id="plot_new_cases_+3A_title">title</code></td>
<td>
<p>Title for forecast plot. Enter as text string. <code>NULL</code>
(i.e. no title) by default.</p>
</td></tr>
<tr><td><code id="plot_new_cases_+3A_plt.start.date">plt.start.date</code></td>
<td>
<p>First date of actual data (from estimation sample) to
plot on graph.<code>NULL</code> (i.e. plots all data in estimation window) by
default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-20")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()

# Plot forecast of new cases 7 days ahead
plot_new_cases(res, Y = gauteng[idx.est], n.ahead = 7,
confidence.level = 0.68, date_format = "%Y-%m-%d",
title = "Forecast new cases", plt.start.date = as.Date("2020-07-13"))

</code></pre>

<hr>
<h2 id='reinitialise_dataframe'>Reinitialise a data frame by subtracting the <code>reinit.date</code> row from
all columns</h2><span id='topic+reinitialise_dataframe'></span>

<h3>Description</h3>

<p>Reinitialise a data frame by subtracting the <code>reinit.date</code> row from
all columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reinitialise_dataframe(dt, reinit.date)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reinitialise_dataframe_+3A_dt">dt</code></td>
<td>
<p>Cumulated data series.</p>
</td></tr>
<tr><td><code id="reinitialise_dataframe_+3A_reinit.date">reinit.date</code></td>
<td>
<p>Reinitialisation date. E.g. &lsquo;<span class="samp">&#8288;'2021-05-12'&#8288;</span>&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reinitialised data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
reinitialise_dataframe(gauteng,as.Date("2021-01-01"))

</code></pre>

<hr>
<h2 id='SSModelBase-class'>Base class for estimating time-series growth curve models. Classes
<code>SSModelDynamicGompertz</code> and <code>SSModelDynGompertzReinit</code> refer back
to this base class.</h2><span id='topic+SSModelBase-class'></span><span id='topic+SSModelBase'></span>

<h3>Description</h3>

<p>Base class for estimating time-series growth curve models. Classes
<code>SSModelDynamicGompertz</code> and <code>SSModelDynGompertzReinit</code> refer back
to this base class.
</p>


<h3>Methods</h3>


<dl>
<dt><code>estimate(sea.type = "trigonometric", sea.period = 7)</code></dt><dd><p>Estimates the dynamic Gompertz curve model when applied to an object of
class <code>SSModelDynamicGompertz</code> or <code>SSModelDynGompertzReinit</code>.
</p>


<h4>Parameters</h4>


<ul>
<li><p><code>sea.type</code> Seasonal type. Options are
<code>'trigonometric'</code> and <code>'none'</code>. <code>'trigonometric'</code> will
yield a model with a trigonometric seasonal component and
<code>'none'</code> will yield a model with no seasonal component.
</p>
</li>
<li><p><code>sea.period</code> The period of seasonality. For a
day-of-the-week effect with daily data, this would be 7. Not required
if <code>sea.type = 'none'</code>.
</p>
</li></ul>



<h4>Return Value</h4>

<p>An object of class <code>FilterResults</code>
containing the result output for the estimated dynamic Gompertz curve
model.</p>
</dd>
<dt><code>get_dynamic_gompertz_model(
  y,
  q = NULL,
  sea.type = "trigonometric",
  sea.period = 7,
  a1 = NULL,
  P1 = NULL,
  Q = NULL,
  H = NULL
)</code></dt><dd><p>Returns dynamic Gompertz curve model.
</p>


<h4>Parameters</h4>


<ul>
<li><p><code>y</code> The cumulated variable
</p>
</li>
<li><p><code>q</code> The signal-to-noise ratio (ratio of slope to irregular
variance). Defaults to <code>'NULL'</code>, in which case no signal-to-noise
ratio will be imposed. Instead, it will be estimated.
</p>
</li>
<li><p><code>sea.type</code> Seasonal type. Options are <code>'trigonometric'</code>
and <code>'none'</code>. <code>'trigonometric'</code> will yield a model with a
trigonometric seasonal component and <code>'none'</code> will yield a model
with no seasonal component.
</p>
</li>
<li><p><code>sea.period</code> The period of seasonality. For a day-of-the-week
effect with daily data, this would be 7. Not required if
<code>sea.type = 'none'</code>.
</p>
</li>
<li><p><code>a1</code> Optional parameter specifying the prior mean of the
states. Defaults to <code>'NULL'</code>. Leave as <code>'NULL'</code> for a diffuse
prior (no prior information). If a proper prior is to be specified, both
<code>a1</code> and <code>P1</code> must be given.
</p>
</li>
<li><p><code>P1</code> Optional parameter specifying the prior mean of the
states. Defaults to <code>'NULL'</code>. Leave as <code>'NULL'</code> for a diffuse
prior (no prior information). If a proper prior is to be specified,
both <code>a1</code> and <code>P1</code> must be given.
</p>
</li>
<li><p><code>Q</code> Optional parameter specifying the state error variances
where these are to be imposed rather than estimated. Defaults to
<code>'NULL'</code> which will see the variances estimated.
</p>
</li>
<li><p><code>H</code> Optional parameter specifying the irregular variance
where this is to be imposed rather than estimated. Defaults to
<code>'NULL'</code> which will see the variance estimated.
</p>
</li></ul>



<h4>Description</h4>

<p>The dynamic Gompertz with an integrated random walk (IRW) trend is
</p>
<p style="text-align: center;"><code class="reqn">\ln g_{t}=\delta_{t}+\varepsilon_{t},  \;\;\;\;
    \varepsilon_{t}\sim NID(0,\sigma_{\varepsilon }^{2}), \;\;\;\;
    t=2,...,T, </code>
</p>

<p>where <code class="reqn">Y_t</code> is the cumulated variable, <code class="reqn">y_t = \Delta Y_t</code>,
<code class="reqn">\ln g_{t}=\ln y_{t}-\ln Y_{t-1}</code> and
</p>
<p style="text-align: center;"><code class="reqn">\delta_{t} =\delta_{t-1}+\gamma_{t-1},</code>
</p>

<p style="text-align: center;"><code class="reqn">\gamma_{t} =\gamma_{t-1}+\zeta_{t}, \;\;\;\;
    \zeta_{t}\sim NID(0,\sigma_{\zeta }^{2}),</code>
</p>

<p>where the observation disturbances <code class="reqn">\varepsilon_{t}</code>  and slope
disturbances <code class="reqn">\zeta_{t}</code>, are iid Normal and mutually independent.
Note that, the larger the signal-to-noise ratio,
<code class="reqn">q_{\zeta }=\sigma_{\zeta }^{2}/\sigma_{\varepsilon }^{2}</code>,
the faster the slope changes in response to new observations. Conversely,
a lower signal-to-noise ratio induces smoothness.
</p>
<p>For the model without seasonal terms (<code>sea.type = 'none'</code>) the are
priors are
</p>
<p style="text-align: center;"><code class="reqn">\begin{pmatrix} \delta_1 \ \gamma_1 \end{pmatrix}
    \sim N(a_1,P_1)</code>
</p>
<p>.
The diffuse prior has <code class="reqn">P_1 = \kappa I_{2\times 2}</code> with
<code class="reqn">\kappa \to \infty</code>. Implementation of the diffuse prior is handled
by the package <code>KFAS</code> (Helske, 2017). Where the model has a seasonal
component (<code>sea.type = 'trigonometric'</code>), the vector of prior means
<code class="reqn">a_1</code> and the prior covariance matrix <code class="reqn">P_1</code> are extended
accordingly.
</p>
<p>See the vignette for details of the variance matrix <code class="reqn">Q</code>.
<code class="reqn">H = \sigma^2_{\varepsilon}</code>.
</p>

</dd>
<dt><code>update(pars, model, q, sea.type)</code></dt><dd><p>Update method for Kalman filter to implement the dynamic Gompertz curve
model.
A maximum of 3 parameters are used to set the observation noise
(1 parameter), the transition equation slope and seasonal noise. If q (signal
to noise ratio) is not null then the slope noise is set using this
ratio.
</p>


<h4>Parameters</h4>


<ul>
<li><p><code>pars</code> Vector of parameters.
</p>
</li>
<li><p><code>model</code> <code>KFS</code> model object.
</p>
</li>
<li><p><code>q</code> The signal-to-noise ratio (ratio of slope to irregular
variance).
</p>
</li>
<li><p><code>sea.type</code> Seasonal type. Options are
<code>'trigonometric'</code> and <code>'none'</code>.
</p>
</li></ul>



<h4>Return Value</h4>

<p><code>KFS</code> model object.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-06")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()
</code></pre>

<hr>
<h2 id='SSModelDynamicGompertz-class'>Class for dynamic Gompertz curve state space model object.</h2><span id='topic+SSModelDynamicGompertz-class'></span><span id='topic+SSModelDynamicGompertz'></span>

<h3>Description</h3>

<p>Class for dynamic Gompertz curve state space model object.
</p>


<h4>Methods</h4>

<p><code>get_model(y, q = NULL, sea.type = 'trigonometric', sea.period = 7)</code>
Retrieves the model object.
</p>


<h5>Parameters</h5>


<ul>
<li><p><code>y</code> The cumulated variable.
</p>
</li>
<li><p><code>q</code> The signal-to-noise ratio (ratio of slope to irregular
variance). Defaults to <code>'NULL'</code>, in which case no signal-to-noise ratio
will be imposed. Instead, it will be estimated.
</p>
</li>
<li><p><code>sea.type</code> Seasonal type. Options are <code>'trigonometric'</code> and
<code>'none'</code>. <code>'trigonometric'</code> will yield a model with a trigonometric
seasonal component and <code>'none'</code> will yield a model with no seasonal
component.
</p>
</li>
<li><p><code>sea.period</code>  The period of seasonality. For a day-of-the-week
effect with daily data, this would be 7. Not required if
<code>sea.type = 'none'</code>.
</p>
</li></ul>



<h5>Return Value</h5>

<p><code>KFS</code> model object.</p>




<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-06")

# Specify a model
model &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)
# Estimate a specified model
res &lt;- model$estimate()

</code></pre>

<hr>
<h2 id='SSModelDynGompertzReinit-class'>Class for re-initialised dynamic Gompertz curve model</h2><span id='topic+SSModelDynGompertzReinit-class'></span><span id='topic+SSModelDynGompertzReinit'></span>

<h3>Description</h3>

<p>This class allows the implementation of the reinitialisation
procedure described in the vignette and summarised below.
Let <code class="reqn">t=r</code> denote the re-initialization date and <code class="reqn">r_0</code> denote the
date at which the cumulative series is set to 0. As the growth rate of
cumulative cases is defined as <code class="reqn">g_t\equiv \frac{y_t}{Y_{t-1}}</code>, we have:
</p>
<p style="text-align: center;"><code class="reqn">\ln g_t = \ln y_t - \ln Y_{t-1} \;\;\;\; t=1, \ldots, r</code>
</p>

<p style="text-align: center;"><code class="reqn">\ln g_t^r = \ln y_t - \ln Y_{t-1}^r \;\;\;\; t=r+1, \ldots, T</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{t}^{r}=Y_{t-1}^{r}+y_{t}  \;\;\;\; t=r,\ldots,T</code>
</p>

<p>where <code class="reqn">Y_{t}^{r}</code> is the cumulative cases after re-initialization. We
choose to set the cumulative cases to zero at <code class="reqn">r_0=r-1, Y_{r-1}^{r}=0</code>,
such that the growth rate of cumulative cases is available from <code class="reqn">t=r+1</code>
onwards.
We reinitialise the model by specifying the prior distribution for the
initial states appropriately. See the vignette for details.
</p>


<h4>Methods</h4>


<ul>
<li><p><code>new(Y, q = NULL, reinit.date=NULL, original.results=NULL,
use.presample.info=TRUE)</code> Create an instance of the
<code>SSModelDynGompertzReinit</code> class.
</p>


<h5>Parameters</h5>


<ul>
<li><p><code>Y</code> The cumulated variable.
</p>
</li>
<li><p><code>q</code> The signal-to-noise ratio (ratio of slope to irregular
variance). Defaults to <code>'NULL'</code>, in which case no signal-to-noise
ratio will be imposed. Instead, it will be estimated.
</p>
</li>
<li><p><code>reinit.date</code> The reinitialisation date <code class="reqn">r</code>. Should be
specified as an object of class <code>"Date"</code>. Must be specified.
</p>
</li>
<li><p><code>original.results</code> Rather than re-estimating the model up
to the <code>reinit.date</code>, a <code>FilterResults</code> class object can be
specified here and the parameters for the reinitialisation will be taken
from this object. Default is <code>NULL</code>. This parameter is optional.
</p>
</li>
<li><p><code>use.presample.info</code>  Logical value denoting whether or
not to use information from before the reinitialisation date in the
reinitialisation procedure. Default is <code>TRUE</code>. If <code>FALSE</code>, the
model is estimated from scratch from the reinitialisation date and no
attempt to use information from before the reinitialisation date is made.
</p>
</li></ul>


</li>
<li><p><code>get_model(y, q=NULL, sea.type = NULL, sea.period)</code> Retrieves
the model object, which is a dynamic Gompertz curve model reinitialised at
<code>self$reinit.date</code>.
</p>


<h5>Parameters</h5>


<ul>
<li><p><code>y</code> The cumulated variable.
</p>
</li>
<li><p><code>q</code> The signal-to-noise ratio (ratio of slope to irregular
variance). Defaults to <code>'NULL'</code>, in which case no signal-to-noise ratio
will be imposed. Instead, it will be estimated.
</p>
</li>
<li><p><code>sea.type</code> Seasonal type. Options are <code>'trigonometric'</code> and
<code>'none'</code>. <code>'trigonometric'</code> will yield a model with a
trigonometric seasonal component and <code>'none'</code> will yield a model with
no seasonal component.
</p>
</li>
<li><p><code>sea.period</code>  The period of seasonality. For a day-of-the-week
effect with daily data, this would be 7. Not required if
<code>sea.type = 'none'</code>.
</p>
</li></ul>



<h5>Return Value</h5>

<p><code>KFS</code> model object.</p>

</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'>library(tsgc)
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2021-05-20")

# Specify a model
model.reinit &lt;- SSModelDynGompertzReinit$new(Y = gauteng[idx.est], q = 0.005,
  reinit.date = as.Date("2021-04-29"))
# Estimate a specified model
res.reinit &lt;- model.reinit$estimate()

## Alternatively, we could feed in a prior results object rather than a
## reinitialisation date. The results are identical to the above.

# Specify initial model
idx.orig &lt;- zoo::index(gauteng) &lt;= as.Date("2021-04-29")
model.orig &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.orig], q = 0.005)
res.orig &lt;- model.orig$estimate()
# Estimate a specified model
model.reinit2 &lt;- SSModelDynGompertzReinit$new(Y = gauteng[idx.est],
q = 0.005, reinit.date = as.Date("2021-04-29"), original.results = res.orig)
res.reinit2 &lt;- model.reinit2$estimate()

</code></pre>

<hr>
<h2 id='write_results'>Write a selection of relevant results to disc</h2><span id='topic+write_results'></span>

<h3>Description</h3>

<p>Function writes the following results to csv files which get
saved in the location specified in <code>res.dir</code>: forecast new cases or
incidence variable, <code class="reqn">y</code>; the filtered level and slope of <code class="reqn">\ln g</code>,
<code class="reqn">\delta</code> and <code class="reqn">\gamma</code>; filtered estimates of <code class="reqn">g_y</code> and the
confidence intervals for these estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_results(res, res.dir, Y, n.ahead, confidence.level)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_results_+3A_res">res</code></td>
<td>
<p>Results object estimated using the &lsquo;<span class="samp">&#8288;estimate()&#8288;</span>&rsquo; method.</p>
</td></tr>
<tr><td><code id="write_results_+3A_res.dir">res.dir</code></td>
<td>
<p>File path to save the results to.</p>
</td></tr>
<tr><td><code id="write_results_+3A_y">Y</code></td>
<td>
<p>Cumulated variable.</p>
</td></tr>
<tr><td><code id="write_results_+3A_n.ahead">n.ahead</code></td>
<td>
<p>Number of periods ahead to forecast.</p>
</td></tr>
<tr><td><code id="write_results_+3A_confidence.level">confidence.level</code></td>
<td>
<p>Confidence level to use for the confidence interval
on the forecasts <code class="reqn">\ln(g_t)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number of csv files saved in the directory specified in
<code>res.dir</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not run as do not wish to save to local disc when compiling documentation.
# Below will run if copied and pasted into console.
library(tsgc)
library(here)

res.dir &lt;- tempdir()
data(gauteng,package="tsgc")
idx.est &lt;- zoo::index(gauteng) &lt;= as.Date("2020-07-06")
res &lt;- SSModelDynamicGompertz$new(Y = gauteng[idx.est], q = 0.005)$estimate()

tsgc::write_results(
res=res, res.dir = res.dir, Y = gauteng[idx.est], n.ahead = 14,
confidence.level = 0.68
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
