<!DOCTYPE html><html><head><title>Help for package clustMD</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clustMD}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Byar'><p>Byar prostate cancer data set.</p></a></li>
<li><a href='#clustMD'><p>Model Based Clustering for Mixed Data</p></a></li>
<li><a href='#clustMD-package'><p>Model based clustering for mixed data: clustMD</p></a></li>
<li><a href='#clustMDlist'><p>Model Based Clustering for Mixed Data</p></a></li>
<li><a href='#clustMDparallel'><p>Run multiple clustMD models in parallel</p></a></li>
<li><a href='#clustMDparcoord'><p>Parallel coordinates plot adapted for <code>clustMD</code> output</p></a></li>
<li><a href='#dtmvnom'><p>Return the mean and covariance matrix of a truncated multivariate normal</p>
distribution</a></li>
<li><a href='#E.step'><p>E-step of the (MC)EM algorithm</p></a></li>
<li><a href='#getOutput_clustMDparallel'><p>Extracts relevant output from <code>clustMDparallel</code> object</p></a></li>
<li><a href='#M.step'><p>M-step of the (MC)EM algorithm</p></a></li>
<li><a href='#modal.value'><p>Calculate the mode of a sample</p></a></li>
<li><a href='#npars_clustMD'><p>Calculates the number of free parameters for the <code>clustMD</code> model.</p></a></li>
<li><a href='#ObsLogLikelihood'><p>Approximates the observed log likelihood.</p></a></li>
<li><a href='#patt.equal'><p>Check if response patterns are equal</p></a></li>
<li><a href='#perc.cutoffs'><p>Calculates the threshold parameters for ordinal variables.</p></a></li>
<li><a href='#plot.clustMD'><p>Plotting method for objects of class <code>clustMD</code></p></a></li>
<li><a href='#plot.clustMDparallel'><p>Summary plots for a clustMDparallel object</p></a></li>
<li><a href='#print.clustMD'><p>Print basic details of <code>clustMD</code> object.</p></a></li>
<li><a href='#print.clustMDparallel'><p>Print basic details of <code>clustMDparallel</code> object</p></a></li>
<li><a href='#qfun'><p>Helper internal function for <code>dtmvnom()</code></p></a></li>
<li><a href='#stable.probs'><p>Stable computation of the log of a sum</p></a></li>
<li><a href='#summary.clustMD'><p>Summarise <code>clustMD</code> object</p></a></li>
<li><a href='#summary.clustMDparallel'><p>Prints a summary of a clustMDparallel object to screen.</p></a></li>
<li><a href='#vec.outer'><p>Calculate the outer product of a vector with itself</p></a></li>
<li><a href='#z.moments'><p>Calculates the first and second moments of the latent data</p></a></li>
<li><a href='#z.moments_diag'><p>Calculates the first and second moments of the latent data for diagonal models</p></a></li>
<li><a href='#z.nom.diag'><p>Transforms Monte Carlo simulated data into categorical data. Calculates</p>
empirical moments of latent data given categorical responses.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Model Based Clustering for Mixed Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Model-based clustering of mixed data (i.e. data which consist of
    continuous, binary, ordinal or nominal variables) using a parsimonious
    mixture of latent Gaussian variable models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, mclust, reshape2, MASS, msm, mvtnorm, parallel,
truncnorm, viridis, stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-05-08 16:35:03 UTC; damien</td>
</tr>
<tr>
<td>Author:</td>
<td>Damien McParland [aut, cre],
  Isobel Claire Gormley [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Damien McParland &lt;damien.mcparland@ucd.ie&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-05-08 17:19:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='Byar'>Byar prostate cancer data set.</h2><span id='topic+Byar'></span>

<h3>Description</h3>

<p>A data set consisting of variables of mixed type measured on a group of
prostate cancer patients. Patients have either stage 3 or stage 4 prostate
cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Byar
</code></pre>


<h3>Format</h3>

<p>A data frame with 475 observations on the following 15 variables.
</p>

<dl>
<dt><code>Age</code></dt><dd><p>a numeric vector indicating the age of the patient.</p>
</dd>
<dt><code>Weight</code></dt><dd><p>a numeric vector indicating the weight of the patient.</p>
</dd>
<dt><code>Performance.rating</code></dt><dd><p>an ordinal variable indicating how active
the patient is: 0 - normal activity, 1 - in bed less than 50% of 
daytime, 2 - in bed more than 50% of daytime, 3 - confined to bed.</p>
</dd>
<dt><code>Cardiovascular.disease.history</code></dt><dd><p>a binary variable indicating
if the patient has a history of cardiovascular disease: 0 - no, 1 - 
yes.</p>
</dd>
<dt><code>Systolic.Blood.pressure</code></dt><dd><p>a numeric vector indicating the 
systolic blood pressure of the patient in units of ten.</p>
</dd>
<dt><code>Diastolic.blood.pressure</code></dt><dd><p>a numeric vector indicating the 
diastolic blood pressure of the patient in units of ten.</p>
</dd>
<dt><code>Electrocardiogram.code</code></dt><dd><p>a nominal variable indicating the 
electorcardiogram code: 0 - normal, 1 - benign, 2 - rythmic 
disturbances and electrolyte changes, 3 - heart blocks or conduction
defects, 4 - heart strain, 5 - old myocardial infarct, 6 - recent 
myocardial infarct.</p>
</dd>
<dt><code>Serum.haemoglobin</code></dt><dd><p>a numeric vector indicating the serum
haemoglobin levels of the patient measured in g/100ml.</p>
</dd>
<dt><code>Size.of.primary.tumour</code></dt><dd><p>a numeric vector indicating the 
estimated size of the patient's primary tumour in centimeters squared.</p>
</dd>
<dt><code>Index.of.tumour.stage.and.histolic.grade</code></dt><dd><p>a numeric vector 
indicating the combined index of tumour stage and histolic grade of the
patient.</p>
</dd>
<dt><code>Serum.prostatic.acid.phosphatase</code></dt><dd><p>a numeric vector indicating 
the serum prostatic acid phosphatase levels of the patient in 
King-Armstong units.</p>
</dd>
<dt><code>Bone.metastases</code></dt><dd><p>a binary vector indicating the presence of 
bone metastasis: 0 - no, 1 - yes.</p>
</dd>
<dt><code>Stage</code></dt><dd><p>the stage of the patient's prostate cancer.</p>
</dd>
<dt><code>Observation</code></dt><dd><p>a patient ID number.</p>
</dd>
<dt><code>SurvStat</code></dt><dd><p>the post trial survival status of the patient: 
0 - alive, 1 - dead from prostatic cancer, 2 - dead from heart or 
vascular disease, 3 - dead from cerebrovascular accident, 3 - dead form
pulmonary ebolus, 5 - dead from other cancer, 6 - dead from respiratory
disease, 7 - dead from other specific non-cancer cause, 8 - dead from 
other unspecified non-cancer cause, 9 - dead from unknown cause.</p>
</dd>
</dl>


<h3>Source</h3>

<p>Byar, D.P. and Green, S.B. (1980). The choice of treatment for 
cancer patients based on covariate information: applications to prostate
cancer. Bulletin du Cancer 67: 477-490.
</p>
<p>Hunt, L., Jorgensen, M. (1999). Mixture model clustering using the 
multimix program. Australia and New Zealand Journal of Statistics 41:
153-171.
</p>

<hr>
<h2 id='clustMD'>Model Based Clustering for Mixed Data</h2><span id='topic+clustMD'></span>

<h3>Description</h3>

<p>A function that fits the clustMD model to a data set consisting of any
combination of continuous, binary, ordinal and nominal variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustMD(X, G, CnsIndx, OrdIndx, Nnorms, MaxIter, model, store.params = FALSE,
  scale = FALSE, startCL = "hc_mclust", autoStop = FALSE, ma.band = 50,
  stop.tol = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustMD_+3A_x">X</code></td>
<td>
<p>a data matrix where the variables are ordered so that the 
continuous variables come first, the binary (coded 1 and 2) and
ordinal variables (coded 1, 2, ...) come second and the nominal
variables (coded 1, 2, ...) are in last position.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_g">G</code></td>
<td>
<p>the number of mixture components to be fitted.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables in the data set.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous, binary and ordinal
variables in the data set.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_nnorms">Nnorms</code></td>
<td>
<p>the number of Monte Carlo samples to be used for the 
intractable E-step in the presence of nominal data. Irrelevant if
there are no nominal variables.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_maxiter">MaxIter</code></td>
<td>
<p>the maximum number of iterations for which the (MC)EM 
algorithm should run.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_model">model</code></td>
<td>
<p>a string indicating which clustMD model is to be fitted. This
may be one of: <code>EII, VII, EEI, VEI, EVI, VVI</code> or <code>BD</code>.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_store.params">store.params</code></td>
<td>
<p>a logical argument indicating if the parameter estimates
at each iteration should be saved and returned by the clustMD function.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_scale">scale</code></td>
<td>
<p>a logical argument indicating if the continuous variables
should be standardised.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_startcl">startCL</code></td>
<td>
<p>a string indicating which clustering method should be used to
initialise the (MC)EM algorithm. This may be one of &quot;kmeans&quot; (K means
clustering), &quot;hclust&quot; (hierarchical clustering), &quot;mclust&quot; (finite 
mixture of Gaussian distributions), &quot;hc_mclust&quot; (model-based 
hierarchical clustering) or &quot;random&quot; (random cluster allocation).</p>
</td></tr>
<tr><td><code id="clustMD_+3A_autostop">autoStop</code></td>
<td>
<p>a logical argument indicating whether the (MC)EM algorithm
should use a stopping criterion to decide if convergence has been 
reached. Otherwise the algorithm will run for <code>MaxIter</code> iterations. 
</p>
<p>If only continuous variables are present the algorithm will use Aitken's
acceleration criterion with tolerance <code>stop.tol</code>.
</p>
<p>If categorical variables are present, the stopping criterion is based
on a moving average of the approximated log likelihood values. Let 
<code>t</code> denote the current interation. The average of the 
<code>ma.band</code> most recent approximated log likelihood values is 
compared to the average of another <code>ma.band</code> iterations with a lag
of 10 iterations. If this difference is less than the tolerance the
algorithm will be said to have converged.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_ma.band">ma.band</code></td>
<td>
<p>the number of iterations to be included in the moving average
calculation for the stopping criterion.</p>
</td></tr>
<tr><td><code id="clustMD_+3A_stop.tol">stop.tol</code></td>
<td>
<p>the tolerance of the (MC)EM stopping criterion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class clustMD is returned. The output components are as
follows:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>The covariance model fitted to the data.</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>The number of clusters fitted to the data.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The observed data matrix.</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>The cluster to which each observation belongs.</p>
</td></tr>
<tr><td><code>tau</code></td>
<td>
<p>A <code>N x G</code> matrix of the probabilities of 
each observation blonging to each cluster.</p>
</td></tr>
<tr><td><code>means</code></td>
<td>
<p>A <code>D x G</code> matrix of the cluster means. Where D is the 
dimension of the combined observed and latent continuous space.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>A <code>G x D</code> matrix containing the diagonal entries of the 
<code>A</code> matrix corresponding to each cluster.</p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>A <code>G x D</code> matrix of volume parameters corresponding
to each observed or latent dimension for each cluster.</p>
</td></tr>
<tr><td><code>Sigma</code></td>
<td>
<p>A <code>D x D x G</code> array of the covariance matrices for 
each cluster.</p>
</td></tr>
<tr><td><code>BIChat</code></td>
<td>
<p>The estimated Bayesian information criterion for the 
model fitted.</p>
</td></tr>
<tr><td><code>ICLhat</code></td>
<td>
<p>The estimated integrated classification likelihood criterion
for the model fitted.</p>
</td></tr>
<tr><td><code>paramlist</code></td>
<td>
<p>If store.params is <code>TRUE</code> then paramlist is a 
list of the stored parameter values in the order given above with 
the saved estimated likelihood values in last position.</p>
</td></tr>
<tr><td><code>Varnames</code></td>
<td>
<p>A character vector of names corresponding to the 
columns of <code>Y</code></p>
</td></tr>
<tr><td><code>Varnames_sht</code></td>
<td>
<p>A truncated version of <code>Varnames</code>. Used for
plotting.</p>
</td></tr>
<tr><td><code>likelihood.store</code></td>
<td>
<p>A vector containing the estimated log 
likelihood at each iteration.</p>
</td></tr>
</table>


<h3>References</h3>

<p>McParland, D. and Gormley, I.C. (2016). Model based clustering
for mixed data: clustMD. Advances in Data Analysis and Classification,
10 (2):155-169.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(Byar)
    # Transformation skewed variables
    Byar$Size.of.primary.tumour &lt;- sqrt(Byar$Size.of.primary.tumour)
    Byar$Serum.prostatic.acid.phosphatase &lt;- log(Byar$Serum.prostatic.acid.phosphatase)

    # Order variables (Continuous, ordinal, nominal)
    Y &lt;- as.matrix(Byar[, c(1, 2, 5, 6, 8, 9, 10, 11, 3, 4, 12, 7)])

    # Start categorical variables at 1 rather than 0
    Y[, 9:12] &lt;- Y[, 9:12] + 1

    # Standardise continuous variables
    Y[, 1:8] &lt;- scale(Y[, 1:8])

    # Merge categories of EKG variable for efficiency
    Yekg &lt;- rep(NA, nrow(Y))
    Yekg[Y[,12]==1] &lt;- 1
    Yekg[(Y[,12]==2)|(Y[,12]==3)|(Y[,12]==4)] &lt;- 2
    Yekg[(Y[,12]==5)|(Y[,12]==6)|(Y[,12]==7)] &lt;- 3
    Y[, 12] &lt;- Yekg

    ## Not run: 
    res &lt;- clustMD(X = Y, G = 3, CnsIndx = 8, OrdIndx = 11, Nnorms = 20000,
    MaxIter = 500, model = "EVI", store.params = FALSE, scale = TRUE, 
    startCL = "kmeans", autoStop= TRUE, ma.band=30, stop.tol=0.0001)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='clustMD-package'>Model based clustering for mixed data: clustMD</h2><span id='topic+clustMD-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Model-based clustering of mixed data (i.e. data that consist of continuous,
binary, ordinal or nominal variables) using a parsimonious mixture of latent
Gaussian variable models.
</p>


<h3>Author(s)</h3>

<p>Damien McParland
</p>
<p>Damien McParland &lt;damien.mcparland@ucd.ie&gt;
Isobel Claire Gormley &lt;claire.gormley@ucd.ie&gt;
</p>


<h3>References</h3>

<p>McParland, D. and Gormley, I.C. (2016). Model based clustering 
for mixed data: clustMD. Advances in Data Analysis and Classification, 
10 (2):155-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='clustMDlist'>Model Based Clustering for Mixed Data</h2><span id='topic+clustMDlist'></span>

<h3>Description</h3>

<p>A function that fits the clustMD model to a data set consisting of any
combination of continuous, binary, ordinal and nominal variables. This
function is a wrapper for <code><a href="#topic+clustMD">clustMD</a></code> that takes arguments as a
list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustMDlist(arglist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustMDlist_+3A_arglist">arglist</code></td>
<td>
<p>a list of input arguments for <code>clustMD</code>. See 
<code><a href="#topic+clustMD">clustMD</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>clustMD</code> object. See <code><a href="#topic+clustMD">clustMD</a></code>.
</p>


<h3>References</h3>

<p>McParland, D. and Gormley, I.C. (2016). Model based clustering
for mixed data: clustMD. Advances in Data Analysis and Classification,
10 (2):155-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(Byar)

    # Transformation skewed variables
    Byar$Size.of.primary.tumour &lt;- sqrt(Byar$Size.of.primary.tumour)
    Byar$Serum.prostatic.acid.phosphatase &lt;- 
    log(Byar$Serum.prostatic.acid.phosphatase)

    # Order variables (Continuous, ordinal, nominal)
    Y &lt;- as.matrix(Byar[, c(1, 2, 5, 6, 8, 9, 10, 11, 3, 4, 12, 7)])

    # Start categorical variables at 1 rather than 0
    Y[, 9:12] &lt;- Y[, 9:12] + 1

    # Standardise continuous variables
    Y[, 1:8] &lt;- scale(Y[, 1:8])

    # Merge categories of EKG variable for efficiency
    Yekg &lt;- rep(NA, nrow(Y))
    Yekg[Y[,12]==1] &lt;- 1
    Yekg[(Y[,12]==2)|(Y[,12]==3)|(Y[,12]==4)] &lt;- 2
    Yekg[(Y[,12]==5)|(Y[,12]==6)|(Y[,12]==7)] &lt;- 3
    Y[, 12] &lt;- Yekg

    argList &lt;- list(X=Y, G=3, CnsIndx=8, OrdIndx=11, Nnorms=20000,
    MaxIter=500, model="EVI", store.params=FALSE, scale=TRUE, 
    startCL="kmeans", autoStop=FALSE, ma.band=50, stop.tol=NA)

    ## Not run: 
    res &lt;- clustMDlist(argList)
    
## End(Not run)

</code></pre>

<hr>
<h2 id='clustMDparallel'>Run multiple clustMD models in parallel</h2><span id='topic+clustMDparallel'></span>

<h3>Description</h3>

<p>This function allows the user to run multiple clustMD models in parallel.
The inputs are similar to <code>clustMD()</code> except <code>G</code> is now a vector
containing the the numbers of components the user would like to fit and 
<code>models</code> is a vector of strings indicating the covariance models the 
user would like to fit for each element of G. The user can specify the 
number of cores to be used or let the function detect the number available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustMDparallel(X, CnsIndx, OrdIndx, G, models, Nnorms, MaxIter, store.params,
  scale, startCL = "hc_mclust", Ncores = NULL, autoStop = FALSE,
  ma.band = 50, stop.tol = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustMDparallel_+3A_x">X</code></td>
<td>
<p>a data matrix where the variables are ordered so that the 
continuous variables come first, the binary (coded 1 and 2) and ordinal
variables (coded 1, 2,...) come second and the nominal variables 
(coded 1, 2,...) are in last position.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables in the data set.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous, binary and ordinal 
variables in the data set.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_g">G</code></td>
<td>
<p>a vector containing the numbers of mixture components to be fitted.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_models">models</code></td>
<td>
<p>a vector of strings indicating which clustMD models are to be
fitted. This may be one of: <code>EII, VII, EEI, VEI, EVI, VVI</code> or 
<code>BD</code>.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_nnorms">Nnorms</code></td>
<td>
<p>the number of Monte Carlo samples to be used for the 
intractable E-step in the presence of nominal data.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_maxiter">MaxIter</code></td>
<td>
<p>the maximum number of iterations for which the (MC)EM 
algorithm should run.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_store.params">store.params</code></td>
<td>
<p>a logical variable indicating if the parameter estimates
at each iteration should be saved and returned by the <code>clustMD</code>
function.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_scale">scale</code></td>
<td>
<p>a logical variable indicating if the continuous variables 
should be standardised.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_startcl">startCL</code></td>
<td>
<p>a string indicating which clustering method should be used to
initialise the (MC)EM algorithm. This may be one of &quot;kmeans&quot; (K means 
clustering), &quot;hclust&quot; (hierarchical clustering), &quot;mclust&quot; (finite 
mixture of Gaussian distributions), &quot;hc_mclust&quot; (model-based 
hierarchical clustering) or &quot;random&quot; (random cluster allocation).</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_ncores">Ncores</code></td>
<td>
<p>the number of cores the user would like to use. Must be less
than or equal to the number of cores available.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_autostop">autoStop</code></td>
<td>
<p>a logical argument indicating whether the (MC)EM algorithm
should use a stopping criterion to decide if convergence has been 
reached. Otherwise the algorithm will run for <code>MaxIter</code> iterations. 
</p>
<p>If only continuous variables are present the algorithm will use Aitken's
acceleration criterion with tolerance <code>stop.tol</code>. 
</p>
<p>If categorical variables are present, the stopping criterion is based
on a moving average of the approximated log likelihood values. let $t$
denote the current interation. The average of the <code>ma.band</code> most
recent approximated log likelihood values is compared to the average of
another <code>ma.band</code> iterations with a lag of 10 iterations.
If this difference is less than the tolerance the algorithm will be 
said to have converged.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_ma.band">ma.band</code></td>
<td>
<p>the number of iterations to be included in the moving average
stopping criterion.</p>
</td></tr>
<tr><td><code id="clustMDparallel_+3A_stop.tol">stop.tol</code></td>
<td>
<p>the tolerance of the (MC)EM stopping criterion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>clustMDparallel</code> is returned. The output 
components are as follows:
</p>
<table>
<tr><td><code>BICarray</code></td>
<td>
<p>A matrix indicating the estimated BIC values for each
of the models fitted.</p>
</td></tr>
<tr><td><code>results</code></td>
<td>
<p>A list containing the output for each of the models 
fitted. Each entry of this list is a <code>clustMD</code> object. If the 
algorithm failed to fit a particular model, the corresponding entry 
of <code>results</code> will be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>McParland, D. and Gormley, I.C. (2016). Model based clustering 
for mixed data: clustMD. Advances in Data Analysis and Classification, 
10 (2):155-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(Byar)

    # Transformation skewed variables
    Byar$Size.of.primary.tumour &lt;- sqrt(Byar$Size.of.primary.tumour)
    Byar$Serum.prostatic.acid.phosphatase &lt;- 
    log(Byar$Serum.prostatic.acid.phosphatase)

    # Order variables (Continuous, ordinal, nominal)
    Y &lt;- as.matrix(Byar[, c(1, 2, 5, 6, 8, 9, 10, 11, 3, 4, 12, 7)])

    # Start categorical variables at 1 rather than 0
    Y[, 9:12] &lt;- Y[, 9:12] + 1

    # Standardise continuous variables
    Y[, 1:8] &lt;- scale(Y[, 1:8])

    # Merge categories of EKG variable for efficiency
    Yekg &lt;- rep(NA, nrow(Y))
    Yekg[Y[,12]==1] &lt;- 1
    Yekg[(Y[,12]==2)|(Y[,12]==3)|(Y[,12]==4)] &lt;- 2
    Yekg[(Y[,12]==5)|(Y[,12]==6)|(Y[,12]==7)] &lt;- 3
    Y[, 12] &lt;- Yekg

    ## Not run: 
    res &lt;- clustMDparallel(X = Y, G = 1:3, CnsIndx = 8, OrdIndx = 11, Nnorms = 20000,
    MaxIter = 500, models = c("EVI", "EII", "VII"), store.params = FALSE, scale = TRUE, 
    startCL = "kmeans", autoStop= TRUE, ma.band=30, stop.tol=0.0001)
  
    res$BICarray

## End(Not run)

</code></pre>

<hr>
<h2 id='clustMDparcoord'>Parallel coordinates plot adapted for <code>clustMD</code> output</h2><span id='topic+clustMDparcoord'></span>

<h3>Description</h3>

<p>Produces a parallel coordinates plot as <code>parcoord</code> in the <code>MASS</code>
library with some minor adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clustMDparcoord(x, col = 1, xlabels = NULL, lty = 1, var.label = FALSE,
  xlab = "", ylab = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clustMDparcoord_+3A_x">x</code></td>
<td>
<p>a matrix or data frame who columns represent variables. Missing 
values are allowed.</p>
</td></tr>
<tr><td><code id="clustMDparcoord_+3A_col">col</code></td>
<td>
<p>a vector of colours, recycled as necessary for each observation.</p>
</td></tr>
<tr><td><code id="clustMDparcoord_+3A_xlabels">xlabels</code></td>
<td>
<p>a character vector of variable names for the x axis.</p>
</td></tr>
<tr><td><code id="clustMDparcoord_+3A_lty">lty</code></td>
<td>
<p>a vector of line types, recycled as necessary for each
observation.</p>
</td></tr>
<tr><td><code id="clustMDparcoord_+3A_var.label">var.label</code></td>
<td>
<p>if TRUE, each variable's axis is labelled with maximum and
minimum values.</p>
</td></tr>
<tr><td><code id="clustMDparcoord_+3A_xlab">xlab</code></td>
<td>
<p>label for the X axis.</p>
</td></tr>
<tr><td><code id="clustMDparcoord_+3A_ylab">ylab</code></td>
<td>
<p>label for the Y axis.</p>
</td></tr>
<tr><td><code id="clustMDparcoord_+3A_...">...</code></td>
<td>
<p>further graphics parameters which are passed to <code>matplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parallel coordinates plot is drawn with one line for each cluster.
</p>


<h3>References</h3>

<p>Wegman, E. J. (1990) Hyperdimensional data analysis using 
parallel coordinates. Journal of the American Statistical Association 
85, 664-675.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002) Modern Applied Statistics with
S. Fourth edition. Springer.
</p>

<hr>
<h2 id='dtmvnom'>Return the mean and covariance matrix of a truncated multivariate normal
distribution</h2><span id='topic+dtmvnom'></span>

<h3>Description</h3>

<p>This function returns the mean and covariance matrix of a truncated 
multivariate normal distribution. It takes as inputs a vector of lower 
thresholds and another of upper thresholds along with the mean and 
covariance matrix of the untruncated distribution. This function follows
the method proposed by Kan \&amp; Robotti (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtmvnom(a, b, mu, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtmvnom_+3A_a">a</code></td>
<td>
<p>a vector of lower thresholds.</p>
</td></tr>
<tr><td><code id="dtmvnom_+3A_b">b</code></td>
<td>
<p>a vector of upper thresholds.</p>
</td></tr>
<tr><td><code id="dtmvnom_+3A_mu">mu</code></td>
<td>
<p>the mean of the untruncated distribution.</p>
</td></tr>
<tr><td><code id="dtmvnom_+3A_s">S</code></td>
<td>
<p>the covariance matrix of the untruncated distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of two elements. The first element, <code>tmean</code>, is
the mean of the truncated multivariate normal distribution. The second 
element, <code>tvar</code>, is the covariance matrix of the truncated 
distribution.
</p>


<h3>References</h3>

<p>Kan, R., &amp; Robotti, C. (2016). On Moments of Folded and 
Truncated Multivariate  Normal Distributions. Available at SSRN.
</p>

<hr>
<h2 id='E.step'>E-step of the (MC)EM algorithm</h2><span id='topic+E.step'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>E.step(N, G, D, CnsIndx, OrdIndx, zlimits, mu, Sigma, Y, J, K, norms, nom.ind.Z,
  patt.indx, pi.vec, model, perc.cut)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="E.step_+3A_n">N</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="E.step_+3A_g">G</code></td>
<td>
<p>number of mixture components.</p>
</td></tr>
<tr><td><code id="E.step_+3A_d">D</code></td>
<td>
<p>dimension of the latent data.</p>
</td></tr>
<tr><td><code id="E.step_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables.</p>
</td></tr>
<tr><td><code id="E.step_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous and ordinal (including
binary) variables.</p>
</td></tr>
<tr><td><code id="E.step_+3A_zlimits">zlimits</code></td>
<td>
<p>the truncation points for the latent data.</p>
</td></tr>
<tr><td><code id="E.step_+3A_mu">mu</code></td>
<td>
<p>a D x G matrix of means.</p>
</td></tr>
<tr><td><code id="E.step_+3A_sigma">Sigma</code></td>
<td>
<p>a D x D x G array of covariance parameters.</p>
</td></tr>
<tr><td><code id="E.step_+3A_y">Y</code></td>
<td>
<p>an N x J data matrix.</p>
</td></tr>
<tr><td><code id="E.step_+3A_j">J</code></td>
<td>
<p>the number of observed variables.</p>
</td></tr>
<tr><td><code id="E.step_+3A_k">K</code></td>
<td>
<p>the number of levels for each variable.</p>
</td></tr>
<tr><td><code id="E.step_+3A_norms">norms</code></td>
<td>
<p>a matrix of standard normal deviates.</p>
</td></tr>
<tr><td><code id="E.step_+3A_nom.ind.z">nom.ind.Z</code></td>
<td>
<p>the latent dimensions corresponding to each nominal 
variable.</p>
</td></tr>
<tr><td><code id="E.step_+3A_patt.indx">patt.indx</code></td>
<td>
<p>a list of length equal to the number of observed response 
patterns. Each entry of the list details the observations for which that
response pattern was observed.</p>
</td></tr>
<tr><td><code id="E.step_+3A_pi.vec">pi.vec</code></td>
<td>
<p>mixing weights.</p>
</td></tr>
<tr><td><code id="E.step_+3A_model">model</code></td>
<td>
<p>the covariance model fitted to the data.</p>
</td></tr>
<tr><td><code id="E.step_+3A_perc.cut">perc.cut</code></td>
<td>
<p>threshold parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for clustMD function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='getOutput_clustMDparallel'>Extracts relevant output from <code>clustMDparallel</code> object</h2><span id='topic+getOutput_clustMDparallel'></span>

<h3>Description</h3>

<p>This function takes a <code>clustMDparallel</code> object, a number of clusters
and a covariance model as inputs. It then returns the output corresponding
to that model. If the particular model is not contained in the 
<code>clustMDparallel</code> object then the function returns an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getOutput_clustMDparallel(resParallel, nClus, covModel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getOutput_clustMDparallel_+3A_resparallel">resParallel</code></td>
<td>
<p>a <code>clustMDparallel</code> object.</p>
</td></tr>
<tr><td><code id="getOutput_clustMDparallel_+3A_nclus">nClus</code></td>
<td>
<p>the number of clusters in the desired output.</p>
</td></tr>
<tr><td><code id="getOutput_clustMDparallel_+3A_covmodel">covModel</code></td>
<td>
<p>the covariance model of the desired output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>clustMD</code> object containing the output for the relevant 
model.
</p>

<hr>
<h2 id='M.step'>M-step of the (MC)EM algorithm</h2><span id='topic+M.step'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M.step(tau, N, sumTauEz, J, OrdIndx, D, G, Y, CnsIndx, sumTauS, model, a,
  nom.ind.Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="M.step_+3A_tau">tau</code></td>
<td>
<p>a <code>N x G</code> matrix of cluster membership probabilities.</p>
</td></tr>
<tr><td><code id="M.step_+3A_n">N</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="M.step_+3A_sumtauez">sumTauEz</code></td>
<td>
<p>the sum across all observations of observed and expected 
latent continuous values mutiplied by the posterior probability of 
belonging to each cluster.</p>
</td></tr>
<tr><td><code id="M.step_+3A_j">J</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code id="M.step_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous and ordinal (including
binary) variables.</p>
</td></tr>
<tr><td><code id="M.step_+3A_d">D</code></td>
<td>
<p>dimension of the latent data.</p>
</td></tr>
<tr><td><code id="M.step_+3A_g">G</code></td>
<td>
<p>the number of mixture components.</p>
</td></tr>
<tr><td><code id="M.step_+3A_y">Y</code></td>
<td>
<p>a <code>N x J</code> data matrix.</p>
</td></tr>
<tr><td><code id="M.step_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables.</p>
</td></tr>
<tr><td><code id="M.step_+3A_sumtaus">sumTauS</code></td>
<td>
<p>the sum across all observations of outer product of observed
and expected latent continuous values mutiplied by the posterior 
probability of belonging to each cluster.</p>
</td></tr>
<tr><td><code id="M.step_+3A_model">model</code></td>
<td>
<p>which <code>clustMD</code> covariance model is fitted.</p>
</td></tr>
<tr><td><code id="M.step_+3A_a">a</code></td>
<td>
<p>a <code>G x D</code> matrix of the entries of A.</p>
</td></tr>
<tr><td><code id="M.step_+3A_nom.ind.z">nom.ind.Z</code></td>
<td>
<p>the latent dimensions corresponding to each nominal variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for <code>clustMD</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='modal.value'>Calculate the mode of a sample</h2><span id='topic+modal.value'></span>

<h3>Description</h3>

<p>Calculate the mode of a sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modal.value(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modal.value_+3A_x">x</code></td>
<td>
<p>a vector containing the sample values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mode of the sample. In the case of a tie, the minimum is 
returned.
</p>

<hr>
<h2 id='npars_clustMD'>Calculates the number of free parameters for the <code>clustMD</code> model.</h2><span id='topic+npars_clustMD'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npars_clustMD(model, D, G, J, CnsIndx, OrdIndx, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npars_clustMD_+3A_model">model</code></td>
<td>
<p>the <code>clustMD</code> covariance model fitted.</p>
</td></tr>
<tr><td><code id="npars_clustMD_+3A_d">D</code></td>
<td>
<p>the dimension of the latent data.</p>
</td></tr>
<tr><td><code id="npars_clustMD_+3A_g">G</code></td>
<td>
<p>the number of mixture components.</p>
</td></tr>
<tr><td><code id="npars_clustMD_+3A_j">J</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code id="npars_clustMD_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables.</p>
</td></tr>
<tr><td><code id="npars_clustMD_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous and ordinal (including
binary) variables.</p>
</td></tr>
<tr><td><code id="npars_clustMD_+3A_k">K</code></td>
<td>
<p>a vector indicating the number of levels of each categorical 
variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for <code>clustMD</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='ObsLogLikelihood'>Approximates the observed log likelihood.</h2><span id='topic+ObsLogLikelihood'></span>

<h3>Description</h3>

<p>Approximates the observed log likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ObsLogLikelihood(N, CnsIndx, G, Y, mu, Sigma, pi.vec, patt.indx, zlimits, J,
  OrdIndx, probs.nom, model, perc.cut, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ObsLogLikelihood_+3A_n">N</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_g">G</code></td>
<td>
<p>the number of mixture components.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_y">Y</code></td>
<td>
<p>an <code>N x J</code> data matrix.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_mu">mu</code></td>
<td>
<p>a <code>D x G</code> matrix of means.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_sigma">Sigma</code></td>
<td>
<p>a <code>D x D x G</code> array of covariance parameters.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_pi.vec">pi.vec</code></td>
<td>
<p>the mixing weights.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_patt.indx">patt.indx</code></td>
<td>
<p>a list of length equal to the number of observed response 
patterns. Each entry of the list details the observations for which that
response pattern was observed.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_zlimits">zlimits</code></td>
<td>
<p>the truncation points for the latent data.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_j">J</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous and ordinal (including
binary) variables.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_probs.nom">probs.nom</code></td>
<td>
<p>an array containing the response probabilities for each
nominal variable for each cluster</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_model">model</code></td>
<td>
<p>the covariance model fitted to the data.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_perc.cut">perc.cut</code></td>
<td>
<p>threshold parameters.</p>
</td></tr>
<tr><td><code id="ObsLogLikelihood_+3A_k">K</code></td>
<td>
<p>the number of levels for each variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for <code>clustMD</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='patt.equal'>Check if response patterns are equal</h2><span id='topic+patt.equal'></span>

<h3>Description</h3>

<p>Checks whether response patterns are equal or not and returns <code>TRUE</code>
or <code>FALSE</code> reprectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patt.equal(x, patt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patt.equal_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="patt.equal_+3A_patt">patt</code></td>
<td>
<p>a vector to compare <code>x</code> to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> and <code>patt</code> are exactly the same
and <code>FALSE</code> otherwise.
</p>


<h3>Note</h3>

<p>Used internally in clustMD function.
</p>

<hr>
<h2 id='perc.cutoffs'>Calculates the threshold parameters for ordinal variables.</h2><span id='topic+perc.cutoffs'></span>

<h3>Description</h3>

<p>Calculates the threshold parameters for ordinal variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perc.cutoffs(CnsIndx, OrdIndx, Y, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perc.cutoffs_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables.</p>
</td></tr>
<tr><td><code id="perc.cutoffs_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous and ordinal (including
binary) variables.</p>
</td></tr>
<tr><td><code id="perc.cutoffs_+3A_y">Y</code></td>
<td>
<p>an <code>N x J</code> data matrix.</p>
</td></tr>
<tr><td><code id="perc.cutoffs_+3A_n">N</code></td>
<td>
<p>number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for <code>clustMD</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='plot.clustMD'>Plotting method for objects of class <code>clustMD</code></h2><span id='topic+plot.clustMD'></span>

<h3>Description</h3>

<p>Plots a parallel coordinates plot and dot plot of the estimated cluster 
means, a barplot of the variances by cluster for diagonal covariance models
or a heatmap of the covariance matrix for non-diagonal covariance 
structures, and a histogram of the clustering uncertainties for each 
observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustMD'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clustMD_+3A_x">x</code></td>
<td>
<p>a <code>clustMD</code> object.</p>
</td></tr>
<tr><td><code id="plot.clustMD_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints graphical summaries of the fitted model as detailed above.
</p>


<h3>References</h3>

<p>McParland, D. and Gormley, I.C. (2016). Model based clustering 
for mixed data: clustMD. Advances in Data Analysis and Classification, 
10 (2):155-169.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='plot.clustMDparallel'>Summary plots for a clustMDparallel object</h2><span id='topic+plot.clustMDparallel'></span>

<h3>Description</h3>

<p>Produces a line plot of the estimated BIC values corresponding to each 
covariance model against the number of clusters fitted. For the optimal model
according to this criteria, a parallel coordinates plot of the cluster means
is produced along with a barchart or heatmap of the covariance matrices for
each cluster and a histogram of the clustering uncertainties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustMDparallel'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clustMDparallel_+3A_x">x</code></td>
<td>
<p>a <code>clustMDparallel</code> object.</p>
</td></tr>
<tr><td><code id="plot.clustMDparallel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a number of plots as detailed above.
</p>

<hr>
<h2 id='print.clustMD'>Print basic details of <code>clustMD</code> object.</h2><span id='topic+print.clustMD'></span>

<h3>Description</h3>

<p>Prints a short summary of a <code>clustMD</code> object to screen. Details the
number of clusters fitted as well as the covariance model and the estimated
BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustMD'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.clustMD_+3A_x">x</code></td>
<td>
<p>a <code>clustMD</code> object.</p>
</td></tr>
<tr><td><code id="print.clustMD_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary details, as described above, to screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='print.clustMDparallel'>Print basic details of <code>clustMDparallel</code> object</h2><span id='topic+print.clustMDparallel'></span>

<h3>Description</h3>

<p>Prints basic details of <code>clustMDparallel</code> object. Outputs the different
numbers of clusters and the different covariance structures fitted to the
data. It also states which model was optimal according to the estimated BIC
criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustMDparallel'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.clustMDparallel_+3A_x">x</code></td>
<td>
<p>a <code>clustMDparallel</code> object.</p>
</td></tr>
<tr><td><code id="print.clustMDparallel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints details described above to screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='qfun'>Helper internal function for <code>dtmvnom()</code></h2><span id='topic+qfun'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qfun(a, b, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qfun_+3A_a">a</code></td>
<td>
<p>a vector of lower thresholds.</p>
</td></tr>
<tr><td><code id="qfun_+3A_b">b</code></td>
<td>
<p>a vector of upper thresholds.</p>
</td></tr>
<tr><td><code id="qfun_+3A_s">S</code></td>
<td>
<p>the covariance matrix of the untruncated distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for dtmvnom function.
</p>


<h3>References</h3>

<p>Kan, R., &amp; Robotti, C. (2016). On Moments of Folded and 
Truncated Multivariate  Normal Distributions. Available at SSRN.
</p>

<hr>
<h2 id='stable.probs'>Stable computation of the log of a sum</h2><span id='topic+stable.probs'></span>

<h3>Description</h3>

<p>Function takes a numeric vector and returns the log of the sum of the
elements of that vector. Calculations are done on the log scale for 
stability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stable.probs(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stable.probs_+3A_s">s</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log of the sum of the elements of <code>s</code>
</p>

<hr>
<h2 id='summary.clustMD'>Summarise <code>clustMD</code> object</h2><span id='topic+summary.clustMD'></span>

<h3>Description</h3>

<p>Prints a summary of a <code>clustMD</code> object to screen. Details the number
of clusters fitted as well as the covariance model and the estimated BIC.
Also prints a table detailing the number of observations in each cluster and
a matrix of the cluster means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustMD'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.clustMD_+3A_object">object</code></td>
<td>
<p>a <code>clustMD</code> object.</p>
</td></tr>
<tr><td><code id="summary.clustMD_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints summary of <code>clustMD</code> object to screen, as detailed above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='summary.clustMDparallel'>Prints a summary of a clustMDparallel object to screen.</h2><span id='topic+summary.clustMDparallel'></span>

<h3>Description</h3>

<p>Prints the different numbers of clusters and covariance models fitted and
indicates the optimal model according to the estimated BIC criterion. The
estimated BIC for the optimal model is printed to screen along with a table
of the cluster membership and the matrix of cluster means for this optimal
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clustMDparallel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.clustMDparallel_+3A_object">object</code></td>
<td>
<p>a <code>clustMDparallel</code> object.</p>
</td></tr>
<tr><td><code id="summary.clustMDparallel_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints a summary of the <code>clustMDparallel</code> object to screen, as
detailed above.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='vec.outer'>Calculate the outer product of a vector with itself</h2><span id='topic+vec.outer'></span>

<h3>Description</h3>

<p>This function calculates the outer product of a vector with itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec.outer(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec.outer_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the outer product of the vector <code>x</code> with itself.
</p>

<hr>
<h2 id='z.moments'>Calculates the first and second moments of the latent data</h2><span id='topic+z.moments'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z.moments(D, G, N, CnsIndx, OrdIndx, zlimits, mu, Sigma, Y, J, K, norms,
  nom.ind.Z, patt.indx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z.moments_+3A_d">D</code></td>
<td>
<p>dimension of the latent data.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_g">G</code></td>
<td>
<p>number of mixture components.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_n">N</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous and ordinal (including
binary) variables.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_zlimits">zlimits</code></td>
<td>
<p>the truncation points for the latent data.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_mu">mu</code></td>
<td>
<p>a <code>D x G</code> matrix of means.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_sigma">Sigma</code></td>
<td>
<p>a <code>D x D x G</code> array of covariance parameters.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_y">Y</code></td>
<td>
<p>an <code>N x J</code> data matrix.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_j">J</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_k">K</code></td>
<td>
<p>the number of levels for each variable.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_norms">norms</code></td>
<td>
<p>a matrix of standard normal deviates.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_nom.ind.z">nom.ind.Z</code></td>
<td>
<p>the latent dimensions corresponding to each nominal
variable.</p>
</td></tr>
<tr><td><code id="z.moments_+3A_patt.indx">patt.indx</code></td>
<td>
<p>a list of length equal to the number of observed response 
patterns. Each entry of the list details the observations for which that
response pattern was observed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for <code>clustMD</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='z.moments_diag'>Calculates the first and second moments of the latent data for diagonal models</h2><span id='topic+z.moments_diag'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z.moments_diag(D, G, N, CnsIndx, OrdIndx, zlimits, mu, Sigma, Y, J, K, norms,
  nom.ind.Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z.moments_diag_+3A_d">D</code></td>
<td>
<p>dimension of the latent data.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_g">G</code></td>
<td>
<p>number of mixture components.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_n">N</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_cnsindx">CnsIndx</code></td>
<td>
<p>the number of continuous variables.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_ordindx">OrdIndx</code></td>
<td>
<p>the sum of the number of continuous and ordinal (including
binary) variables.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_zlimits">zlimits</code></td>
<td>
<p>the truncation points for the latent data.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_mu">mu</code></td>
<td>
<p>a <code>D x G</code> matrix of means.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_sigma">Sigma</code></td>
<td>
<p>a <code>D x D x G</code> array of covariance parameters.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_y">Y</code></td>
<td>
<p>an <code>N x J</code> data matrix.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_j">J</code></td>
<td>
<p>the number of variables.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_k">K</code></td>
<td>
<p>the number of levels for each variable.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_norms">norms</code></td>
<td>
<p>a matrix of standard normal deviates.</p>
</td></tr>
<tr><td><code id="z.moments_diag_+3A_nom.ind.z">nom.ind.Z</code></td>
<td>
<p>the latent dimensions corresponding to each nominal 
variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for clustMD function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

<hr>
<h2 id='z.nom.diag'>Transforms Monte Carlo simulated data into categorical data. Calculates
empirical moments of latent data given categorical responses.</h2><span id='topic+z.nom.diag'></span>

<h3>Description</h3>

<p>Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z.nom.diag(Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z.nom.diag_+3A_z">Z</code></td>
<td>
<p>a matrix of Monte Carlo simulated data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output required for <code>clustMD</code> function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clustMD">clustMD</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
