<!DOCTYPE html><html lang="en"><head><title>Help for package scattermore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {scattermore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_kernel_histogram'><p>apply_kernel_histogram</p></a></li>
<li><a href='#apply_kernel_rgbwt'><p>apply_kernel_rgbwt</p></a></li>
<li><a href='#blend_rgba_float'><p>blend_rgba_float</p></a></li>
<li><a href='#geom_scattermore'><p>geom_scattermore</p></a></li>
<li><a href='#geom_scattermost'><p>geom_scattermost</p></a></li>
<li><a href='#GeomScattermore'><p>The actual geom for scattermore</p></a></li>
<li><a href='#GeomScattermost'><p>The actual geom for scattermost</p></a></li>
<li><a href='#histogram_to_rgbwt'><p>histogram_to_rgbwt</p></a></li>
<li><a href='#merge_rgbwt'><p>merge_rgbwt</p></a></li>
<li><a href='#rgba_float_to_rgba_int'><p>rgba_float_to_rgba_int</p></a></li>
<li><a href='#rgba_int_to_raster'><p>rgba_int_to_raster</p></a></li>
<li><a href='#rgbwt_to_rgba_float'><p>rgbwt_to_rgba_float</p></a></li>
<li><a href='#rgbwt_to_rgba_int'><p>rgbwt_to_rgba_int</p></a></li>
<li><a href='#scatter_lines_histogram'><p>scatter_lines_histogram</p></a></li>
<li><a href='#scatter_lines_rgbwt'><p>scatter_lines_rgbwt</p></a></li>
<li><a href='#scatter_points_histogram'><p>scatter_points_histogram</p></a></li>
<li><a href='#scatter_points_rgbwt'><p>scatter_points_rgbwt</p></a></li>
<li><a href='#scattermore'><p>scattermore</p></a></li>
<li><a href='#scattermoreplot'><p>scattermoreplot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Scatterplots with More Points</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>C-based conversion of large scatterplot data to rasters plus other 
             operations such as data blurring or data alpha blending. Speeds up 
             plotting of data with millions of points.</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, scales, grid, grDevices, graphics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 17:47:59 UTC; exa</td>
</tr>
<tr>
<td>Author:</td>
<td>Tereza Kulichova [aut],
  Mirek Kratochvil <a href="https://orcid.org/0000-0001-7356-4075"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mirek Kratochvil &lt;exa.exa@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-12 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_kernel_histogram'>apply_kernel_histogram</h2><span id='topic+apply_kernel_histogram'></span>

<h3>Description</h3>

<p>Apply a kernel to the given histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_kernel_histogram(
  fhistogram,
  filter = "circle",
  mask = default_kernel(filter, radius, sigma),
  radius = 2,
  sigma = radius/2,
  threads = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_kernel_histogram_+3A_fhistogram">fhistogram</code></td>
<td>
<p>Matrix or array interpreted as histogram of floating-point values.</p>
</td></tr>
<tr><td><code id="apply_kernel_histogram_+3A_filter">filter</code></td>
<td>
<p>Use the pre-defined filter, either <code>circle</code>, <code>square</code>, <code>gauss</code>. Defaults to <code>circle</code>.</p>
</td></tr>
<tr><td><code id="apply_kernel_histogram_+3A_mask">mask</code></td>
<td>
<p>Custom kernel used for blurring, overrides <code>filter</code>. Must be a square matrix of odd size.</p>
</td></tr>
<tr><td><code id="apply_kernel_histogram_+3A_radius">radius</code></td>
<td>
<p>Radius of the kernel (counted without the &quot;middle&quot; pixel&quot;), defaults to 2. The generated kernel matrix will be a square with (2*radius+1) pixels on each side.</p>
</td></tr>
<tr><td><code id="apply_kernel_histogram_+3A_sigma">sigma</code></td>
<td>
<p>Radius of the Gaussian function selected by <code>filter</code>, defaults to <code>radius/2</code>.</p>
</td></tr>
<tr><td><code id="apply_kernel_histogram_+3A_threads">threads</code></td>
<td>
<p>Number of parallel threads (default 0 chooses hardware concurrency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2D matrix with the histogram processed by the kernel application.
</p>

<hr>
<h2 id='apply_kernel_rgbwt'>apply_kernel_rgbwt</h2><span id='topic+apply_kernel_rgbwt'></span>

<h3>Description</h3>

<p>Apply a kernel to the given RGBWT raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_kernel_rgbwt(
  fRGBWT,
  filter = "circle",
  mask = default_kernel(filter, radius, sigma),
  radius = 2,
  sigma = radius/2,
  threads = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_kernel_rgbwt_+3A_frgbwt">fRGBWT</code></td>
<td>
<p>RGBWT array with channels <code>red</code>, <code>green</code>, <code>blue</code>, <code>weight</code> and <code>transparency</code>. The dimension should be N times M times 5.</p>
</td></tr>
<tr><td><code id="apply_kernel_rgbwt_+3A_filter">filter</code></td>
<td>
<p>Use the pre-defined filter, either <code>circle</code>, <code>square</code>, <code>gauss</code>. Defaults to <code>circle</code>.</p>
</td></tr>
<tr><td><code id="apply_kernel_rgbwt_+3A_mask">mask</code></td>
<td>
<p>Custom kernel used for blurring, overrides <code>filter</code>. Must be a square matrix of odd size.</p>
</td></tr>
<tr><td><code id="apply_kernel_rgbwt_+3A_radius">radius</code></td>
<td>
<p>Radius of the kernel (counted without the &quot;middle&quot; pixel&quot;), defaults to 2. The generated kernel matrix will be a square with (2*radius+1) pixels on each side.</p>
</td></tr>
<tr><td><code id="apply_kernel_rgbwt_+3A_sigma">sigma</code></td>
<td>
<p>Radius of the Gaussian function selected by <code>filter</code>, defaults to <code>radius/2</code>.</p>
</td></tr>
<tr><td><code id="apply_kernel_rgbwt_+3A_threads">threads</code></td>
<td>
<p>Number of parallel threads (default 0 chooses hardware concurrency).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGBWT matrix.
</p>

<hr>
<h2 id='blend_rgba_float'>blend_rgba_float</h2><span id='topic+blend_rgba_float'></span>

<h3>Description</h3>

<p>Blend RGBA matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blend_rgba_float(fRGBA_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blend_rgba_float_+3A_frgba_list">fRGBA_list</code></td>
<td>
<p>List of floating-point RGBA arrays with premultiplied alpha (each of the same size N-by-M-by-4). The &quot;first&quot; matrix in the list is the one that will be rendered on &quot;top&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Blended RGBA matrix.
</p>

<hr>
<h2 id='geom_scattermore'>geom_scattermore</h2><span id='topic+geom_scattermore'></span>

<h3>Description</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> integration. This cooperates with the rest of ggplot
(so you can use it to e.g. add rasterized scatterplots to vector output in
order to reduce PDF size). Note that the ggplot processing overhead still dominates
the plotting time. Use <code><a href="#topic+geom_scattermost">geom_scattermost()</a></code> to tradeoff some niceness and
circumvent ggplot logic to gain speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_scattermore(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  interpolate = FALSE,
  pointsize = 0,
  pixels = c(512, 512)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_scattermore_+3A_mapping">mapping</code>, <code id="geom_scattermore_+3A_data">data</code>, <code id="geom_scattermore_+3A_stat">stat</code>, <code id="geom_scattermore_+3A_position">position</code>, <code id="geom_scattermore_+3A_inherit.aes">inherit.aes</code>, <code id="geom_scattermore_+3A_show.legend">show.legend</code>, <code id="geom_scattermore_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="ggplot2.html#topic+layer">ggplot2::layer()</a></code></p>
</td></tr>
<tr><td><code id="geom_scattermore_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NA values, just as with <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_scattermore_+3A_interpolate">interpolate</code></td>
<td>
<p>Default FALSE, passed to <code><a href="grid.html#topic+grid.raster">grid::rasterGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_scattermore_+3A_pointsize">pointsize</code></td>
<td>
<p>Radius of rasterized point. Use <code>0</code> for single pixels (fastest).</p>
</td></tr>
<tr><td><code id="geom_scattermore_+3A_pixels">pixels</code></td>
<td>
<p>Vector with X and Y resolution of the raster, default <code>c(512,512)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepts aesthetics <code>x</code>, <code>y</code>, <code>colour</code> and <code>alpha</code>. Point size is fixed for
all points. Due to rasterization properties it is often beneficial to try
non-integer point sizes, e.g. <code>3.2</code> looks much better than <code>3</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(scattermore)
ggplot(data.frame(x = rnorm(1e6), y = rexp(1e6))) +
  geom_scattermore(aes(x, y, color = x),
    pointsize = 3,
    alpha = 0.1,
    pixels = c(1000, 1000),
    interpolate = TRUE
  ) +
  scale_color_viridis_c()
</code></pre>

<hr>
<h2 id='geom_scattermost'>geom_scattermost</h2><span id='topic+geom_scattermost'></span>

<h3>Description</h3>

<p>Totally non-ggplotish version of <code><a href="#topic+geom_scattermore">geom_scattermore()</a></code>, but faster. It avoids
most of the ggplot processing by bypassing the largest portion of data
around any ggplot functionality, leaving only enough data to set up axes and
limits correctly. If you need to break speed records, use this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_scattermost(
  xy,
  color = "black",
  interpolate = FALSE,
  pointsize = 0,
  pixels = c(512, 512)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_scattermost_+3A_xy">xy</code></td>
<td>
<p>2-column object with data, as in <code><a href="#topic+scattermore">scattermore()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_scattermost_+3A_color">color</code></td>
<td>
<p>Color vector (or a single color).</p>
</td></tr>
<tr><td><code id="geom_scattermost_+3A_interpolate">interpolate</code></td>
<td>
<p>Default FALSE, passed to <code><a href="grid.html#topic+grid.raster">grid::rasterGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_scattermost_+3A_pointsize">pointsize</code></td>
<td>
<p>Radius of rasterized point. Use <code>0</code> for single pixels (fastest).</p>
</td></tr>
<tr><td><code id="geom_scattermost_+3A_pixels">pixels</code></td>
<td>
<p>Vector with X and Y resolution of the raster, default <code>c(512,512)</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
library(scattermore)
d &lt;- data.frame(x = rnorm(1000000), y = rnorm(1000000))
x_rng &lt;- range(d$x)
ggplot() +
  geom_scattermost(cbind(d$x, d$y),
    color = heat.colors(100, alpha = .01)
    [1 + 99 * (d$x - x_rng[1]) / diff(x_rng)],
    pointsize = 2.5,
    pixels = c(1000, 1000),
    interpolate = TRUE
  )
</code></pre>

<hr>
<h2 id='GeomScattermore'>The actual geom for scattermore</h2><span id='topic+GeomScattermore'></span>

<h3>Description</h3>

<p>The actual geom for scattermore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomScattermore
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomScattermore</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 6.
</p>

<hr>
<h2 id='GeomScattermost'>The actual geom for scattermost</h2><span id='topic+GeomScattermost'></span>

<h3>Description</h3>

<p>The actual geom for scattermost
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GeomScattermost
</code></pre>


<h3>Format</h3>

<p>An object of class <code>GeomScattermost</code> (inherits from <code>Geom</code>, <code>ggproto</code>, <code>gg</code>) of length 4.
</p>

<hr>
<h2 id='histogram_to_rgbwt'>histogram_to_rgbwt</h2><span id='topic+histogram_to_rgbwt'></span>

<h3>Description</h3>

<p>Colorize given histogram with input palette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histogram_to_rgbwt(
  fhistogram,
  RGBA = grDevices::col2rgb(col, alpha = T),
  col = grDevices::hcl.colors(10),
  zlim = c(min(fhistogram), max(fhistogram))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="histogram_to_rgbwt_+3A_fhistogram">fhistogram</code></td>
<td>
<p>Matrix or 2D array with the histogram of values.</p>
</td></tr>
<tr><td><code id="histogram_to_rgbwt_+3A_rgba">RGBA</code></td>
<td>
<p>4-by-N matrix floating-point R, G, B and A channels for the palette. Overrides <code>col</code>.</p>
</td></tr>
<tr><td><code id="histogram_to_rgbwt_+3A_col">col</code></td>
<td>
<p>Colors to use for coloring.</p>
</td></tr>
<tr><td><code id="histogram_to_rgbwt_+3A_zlim">zlim</code></td>
<td>
<p>Values to use as extreme values of the histogram</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGBWT matrix.
</p>

<hr>
<h2 id='merge_rgbwt'>merge_rgbwt</h2><span id='topic+merge_rgbwt'></span>

<h3>Description</h3>

<p>Merge RGBWT matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_rgbwt(fRGBWT_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_rgbwt_+3A_frgbwt_list">fRGBWT_list</code></td>
<td>
<p>List of RGBWT arrays. The order of the matrices does not matter (except for negligible floating-point rounding and other robustness errors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Merged RGBWT matrix.
</p>

<hr>
<h2 id='rgba_float_to_rgba_int'>rgba_float_to_rgba_int</h2><span id='topic+rgba_float_to_rgba_int'></span>

<h3>Description</h3>

<p>Convert a float RGBA bitmap with pre-multiplied alpha to integer RGBA bitmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgba_float_to_rgba_int(fRGBA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgba_float_to_rgba_int_+3A_frgba">fRGBA</code></td>
<td>
<p>RGBA bitmap in N-by-M-by-4 array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGBA matrix. The output <em>is not premultiplied</em> by alpha.
</p>

<hr>
<h2 id='rgba_int_to_raster'>rgba_int_to_raster</h2><span id='topic+rgba_int_to_raster'></span>

<h3>Description</h3>

<p>Create a raster from the given RGBA matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgba_int_to_raster(i32RGBA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgba_int_to_raster_+3A_i32rgba">i32RGBA</code></td>
<td>
<p>Integer RGBA matrix (with all values between 0 and 255).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix converted to raster.
</p>

<hr>
<h2 id='rgbwt_to_rgba_float'>rgbwt_to_rgba_float</h2><span id='topic+rgbwt_to_rgba_float'></span>

<h3>Description</h3>

<p>Convert RGBWT matrix to floating-point RGBA matrix, suitable for alpha-blending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgbwt_to_rgba_float(fRGBWT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgbwt_to_rgba_float_+3A_frgbwt">fRGBWT</code></td>
<td>
<p>The RGBWT matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RGBA matrix, output <em>is premultiplied</em> by alpha.
</p>

<hr>
<h2 id='rgbwt_to_rgba_int'>rgbwt_to_rgba_int</h2><span id='topic+rgbwt_to_rgba_int'></span>

<h3>Description</h3>

<p>Convert a RGBWT matrix to an integer RGBA matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgbwt_to_rgba_int(fRGBWT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgbwt_to_rgba_int_+3A_frgbwt">fRGBWT</code></td>
<td>
<p>The RGBWT matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RGBA matrix. The output <em>is not premultiplied</em> by alpha.
</p>

<hr>
<h2 id='scatter_lines_histogram'>scatter_lines_histogram</h2><span id='topic+scatter_lines_histogram'></span>

<h3>Description</h3>

<p>Render lines into a histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter_lines_histogram(
  xy,
  xlim = c(min(xy[, c(1, 3)]), max(xy[, c(1, 3)])),
  ylim = c(min(xy[, c(2, 4)]), max(xy[, c(2, 4)])),
  out_size = c(512L, 512L),
  skip_start_pixel = FALSE,
  skip_end_pixel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter_lines_histogram_+3A_xy">xy</code></td>
<td>
<p>4-column matrix with point coordinates.
Each row contains X and Y coordinates of line start and X and Y coordinates of line end, in this order.</p>
</td></tr>
<tr><td><code id="scatter_lines_histogram_+3A_xlim">xlim</code>, <code id="scatter_lines_histogram_+3A_ylim">ylim</code></td>
<td>
<p>2-element vector of rendered area limits (position of the first pixel on the
left/top, and the last pixel on the right/bottom).
You can flip the image coordinate system by flipping the <code style="white-space: pre;">&#8288;*lim&#8288;</code> vectors.</p>
</td></tr>
<tr><td><code id="scatter_lines_histogram_+3A_out_size">out_size</code></td>
<td>
<p>2-element vector size of the result raster, defaults to <code>c(512L,512L)</code>.</p>
</td></tr>
<tr><td><code id="scatter_lines_histogram_+3A_skip_start_pixel">skip_start_pixel</code></td>
<td>
<p>TRUE if the start pixel of the lines should be omitted, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scatter_lines_histogram_+3A_skip_end_pixel">skip_end_pixel</code></td>
<td>
<p>TRUE if the end pixel of a line should be omitted, defaults to <code>TRUE</code>.
(When plotting long ribbons of connected lines, this prevents counting the connecting pixels twice.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Histogram with the rendered lines.
</p>

<hr>
<h2 id='scatter_lines_rgbwt'>scatter_lines_rgbwt</h2><span id='topic+scatter_lines_rgbwt'></span>

<h3>Description</h3>

<p>Render lines into a RGBWT bitmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter_lines_rgbwt(
  xy,
  xlim = c(min(xy[, c(1, 3)]), max(xy[, c(1, 3)])),
  ylim = c(min(xy[, c(2, 4)]), max(xy[, c(2, 4)])),
  out_size = c(512L, 512L),
  RGBA = c(0, 0, 0, 255),
  skip_start_pixel = FALSE,
  skip_end_pixel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter_lines_rgbwt_+3A_xy">xy</code></td>
<td>
<p>4-column matrix with point coordinates.
Each row contains X and Y coordinates of line start and X and Y coordinates of line end, in this order.</p>
</td></tr>
<tr><td><code id="scatter_lines_rgbwt_+3A_xlim">xlim</code>, <code id="scatter_lines_rgbwt_+3A_ylim">ylim</code></td>
<td>
<p>2-element vector of rendered area limits (position of the first pixel on the
left/top, and the last pixel on the right/bottom).
You can flip the image coordinate system by flipping the <code style="white-space: pre;">&#8288;*lim&#8288;</code> vectors.</p>
</td></tr>
<tr><td><code id="scatter_lines_rgbwt_+3A_out_size">out_size</code></td>
<td>
<p>2-element vector size of the result raster, defaults to <code>c(512L,512L)</code>.</p>
</td></tr>
<tr><td><code id="scatter_lines_rgbwt_+3A_rgba">RGBA</code></td>
<td>
<p>Vector of 4 elements with integral RGBA color for the lines, defaults to <code>c(0,0,0,255)</code>.</p>
</td></tr>
<tr><td><code id="scatter_lines_rgbwt_+3A_skip_start_pixel">skip_start_pixel</code></td>
<td>
<p>TRUE if the start pixel of the lines should be omitted, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="scatter_lines_rgbwt_+3A_skip_end_pixel">skip_end_pixel</code></td>
<td>
<p>TRUE if the end pixel of a line should be omitted, defaults to <code>TRUE</code>.
(When plotting long ribbons of connected lines, this prevents counting the connecting pixels twice.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines plotted in RGBWT bitmap.
</p>

<hr>
<h2 id='scatter_points_histogram'>scatter_points_histogram</h2><span id='topic+scatter_points_histogram'></span>

<h3>Description</h3>

<p>Render a 2D histogram with given points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter_points_histogram(
  xy,
  xlim = c(min(xy[, 1]), max(xy[, 1])),
  ylim = c(min(xy[, 2]), max(xy[, 2])),
  out_size = c(512L, 512L)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter_points_histogram_+3A_xy">xy</code></td>
<td>
<p>2-column matrix with point coordinates (X and Y).</p>
</td></tr>
<tr><td><code id="scatter_points_histogram_+3A_xlim">xlim</code>, <code id="scatter_points_histogram_+3A_ylim">ylim</code></td>
<td>
<p>2-element vector of rendered area limits (position of the first pixel on the
left/top, and the last pixel on the right/bottom).
You can flip the image coordinate system by flipping the <code style="white-space: pre;">&#8288;*lim&#8288;</code> vectors.</p>
</td></tr>
<tr><td><code id="scatter_points_histogram_+3A_out_size">out_size</code></td>
<td>
<p>2-element vector size of the result raster, defaults to <code>c(512L,512L)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2D histogram with the points &quot;counted&quot; in appropriate pixels.
</p>

<hr>
<h2 id='scatter_points_rgbwt'>scatter_points_rgbwt</h2><span id='topic+scatter_points_rgbwt'></span>

<h3>Description</h3>

<p>Render colored points into a RGBWT bitmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter_points_rgbwt(
  xy,
  xlim = c(min(xy[, 1]), max(xy[, 1])),
  ylim = c(min(xy[, 2]), max(xy[, 2])),
  out_size = c(512, 512),
  RGBA = c(0, 0, 0, 255),
  map = NULL,
  palette = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter_points_rgbwt_+3A_xy">xy</code></td>
<td>
<p>2-column matrix with N point coordinates (X and Y) in rows.</p>
</td></tr>
<tr><td><code id="scatter_points_rgbwt_+3A_xlim">xlim</code>, <code id="scatter_points_rgbwt_+3A_ylim">ylim</code></td>
<td>
<p>2-element vector of rendered area limits (position of the first pixel on the
left/top, and the last pixel on the right/bottom).
You can flip the image coordinate system by flipping the <code style="white-space: pre;">&#8288;*lim&#8288;</code> vectors.</p>
</td></tr>
<tr><td><code id="scatter_points_rgbwt_+3A_out_size">out_size</code></td>
<td>
<p>2-element vector size of the result raster, defaults to <code>c(512L,512L)</code>.</p>
</td></tr>
<tr><td><code id="scatter_points_rgbwt_+3A_rgba">RGBA</code></td>
<td>
<p>Point colors. Either a 4-element vector that specifies the same color for all points,
or 4-by-N matrix that specifies color for each of the individual points.
Color is specified using integer RGBA; i.e. the default black is <code>c(0,0,0,255)</code>.</p>
</td></tr>
<tr><td><code id="scatter_points_rgbwt_+3A_map">map</code></td>
<td>
<p>Vector with N integer indices to <code>palette</code>. Overrides RGBA-based coloring.</p>
</td></tr>
<tr><td><code id="scatter_points_rgbwt_+3A_palette">palette</code></td>
<td>
<p>Matrix 4-by-K matrix of RGBA colors used as a palette lookup for the <code>map</code>
that gives the point colors. K is at least <code>max(map)</code>.
Notably, using a palette may be faster than filling and processing the whole RGBA matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A RGBWT array with the rendered points.
</p>

<hr>
<h2 id='scattermore'>scattermore</h2><span id='topic+scattermore'></span>

<h3>Description</h3>

<p>Convert points to raster scatterplot rather quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scattermore(
  xy,
  size = c(512, 512),
  xlim = c(min(xy[, 1]), max(xy[, 1])),
  ylim = c(min(xy[, 2]), max(xy[, 2])),
  rgba = c(0L, 0L, 0L, 255L),
  cex = 0,
  output.raster = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scattermore_+3A_xy">xy</code></td>
<td>
<p>2-column float matrix with point coordinates. As usual with
rasters in R, X axis grows right, and Y axis grows DOWN.
Flipping <code>ylim</code> causes the usual mathematical behavior.</p>
</td></tr>
<tr><td><code id="scattermore_+3A_size">size</code></td>
<td>
<p>2-element vector integer size of the result raster,
defaults to <code>c(512,512)</code>.</p>
</td></tr>
<tr><td><code id="scattermore_+3A_xlim">xlim</code>, <code id="scattermore_+3A_ylim">ylim</code></td>
<td>
<p>Float limits as usual (position of the first pixel on the
left/top, and the last pixel on the right/bottom). You can
easily flip the top/bottom to the &quot;usual&quot; mathematical
system by flipping the <code>ylim</code> vector.</p>
</td></tr>
<tr><td><code id="scattermore_+3A_rgba">rgba</code></td>
<td>
<p>4-row matrix with color values of 0-255, or just a single 4-item
vector for <code>c(r,g,b,a)</code>. Best created with <code>col2rgb(..., alpha=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="scattermore_+3A_cex">cex</code></td>
<td>
<p>Additional point radius in pixels, 0=single-pixel dots (fastest)</p>
</td></tr>
<tr><td><code id="scattermore_+3A_output.raster">output.raster</code></td>
<td>
<p>Output R-style raster (as.raster)? Default TRUE. Raw
array output can be used much faster,
e.g. for use with png::writePNG.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Raster with the result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(scattermore)
plot(scattermore(cbind(rnorm(1e6), rnorm(1e6)), rgba = c(64, 128, 192, 10)))
</code></pre>

<hr>
<h2 id='scattermoreplot'>scattermoreplot</h2><span id='topic+scattermoreplot'></span>

<h3>Description</h3>

<p>Convenience base-graphics-like layer around scattermore. Currently only works with linear axes!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scattermoreplot(
  x,
  y,
  xlim,
  ylim,
  size,
  col = grDevices::rgb(0, 0, 0, 1),
  cex = 0,
  pch = NULL,
  xlab,
  ylab,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scattermoreplot_+3A_x">x</code>, <code id="scattermoreplot_+3A_y">y</code>, <code id="scattermoreplot_+3A_xlim">xlim</code>, <code id="scattermoreplot_+3A_ylim">ylim</code>, <code id="scattermoreplot_+3A_xlab">xlab</code>, <code id="scattermoreplot_+3A_ylab">ylab</code>, <code id="scattermoreplot_+3A_...">...</code></td>
<td>
<p>used as in <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> or forwarded to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
<tr><td><code id="scattermoreplot_+3A_size">size</code></td>
<td>
<p>forwarded to <code><a href="#topic+scattermore">scattermore()</a></code>, or auto-derived from device and plot size if missing (the estimate is not pixel-perfect on most devices, but gets pretty close)</p>
</td></tr>
<tr><td><code id="scattermoreplot_+3A_col">col</code></td>
<td>
<p>point color(s)</p>
</td></tr>
<tr><td><code id="scattermoreplot_+3A_cex">cex</code></td>
<td>
<p>forwarded to <code><a href="#topic+scattermore">scattermore()</a></code></p>
</td></tr>
<tr><td><code id="scattermoreplot_+3A_pch">pch</code></td>
<td>
<p>ignored (to improve compatibility with <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># plot an actual rainbow
library(scattermore)
d &lt;- data.frame(s = qlogis(1:1e6 / (1e6 + 1), 6, 0.5), t = rnorm(1e6, pi / 2, 0.5))
scattermoreplot(
  d$s * cos(d$t),
  d$s * sin(d$t),
  col = rainbow(1e6, alpha = .05)[c((9e5 + 1):1e6, 1:9e5)],
  main = "scattermore demo"
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
