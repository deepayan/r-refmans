<!DOCTYPE html><html><head><title>Help for package spNetwork</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spNetwork}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptive_bw'><p>Adaptive bandwidth</p></a></li>
<li><a href='#adaptive_bw_1d'><p>Adaptive bw in one dimension</p></a></li>
<li><a href='#adaptive_bw_tnkde'><p>Adaptive bandwidth for TNDE</p></a></li>
<li><a href='#adaptive_bw_tnkde_cpp'><p>The exposed function to calculate adaptive bandwidth with space-time</p>
interaction for TNKDE (INTERNAL)</a></li>
<li><a href='#adaptive_bw_tnkde.mc'><p>Adaptive bandwidth for TNDE (multicore)</p></a></li>
<li><a href='#adaptive_bw.mc'><p>Adaptive bandwidth (multicore)</p></a></li>
<li><a href='#add_center_lines'><p>Add center vertex to lines</p></a></li>
<li><a href='#add_vertices_lines'><p>Add vertices to a feature collection of linestrings</p></a></li>
<li><a href='#aggregate_points'><p>Events aggregation</p></a></li>
<li><a href='#bike_accidents'><p>Road accidents including a bicyle in Montreal in 2016</p></a></li>
<li><a href='#build_graph'><p>Network generation</p></a></li>
<li><a href='#build_graph_directed'><p>Directed network generation</p></a></li>
<li><a href='#build_grid'><p>Spatial grid</p></a></li>
<li><a href='#build_quadtree'><p>Build a quadtree</p></a></li>
<li><a href='#bw_checks'><p>Check function for parameters in bandwidth selection methods</p></a></li>
<li><a href='#bw_cv_likelihood_calc'><p>Bandwidth selection by likelihood cross validation</p></a></li>
<li><a href='#bw_cv_likelihood_calc_tkde'><p>Bandwidth selection for Temporal Kernel density estimate by likelihood cross validation</p></a></li>
<li><a href='#bw_cv_likelihood_calc.mc'><p>Bandwidth selection by likelihood cross validation (multicore)</p></a></li>
<li><a href='#bw_cvl_calc'><p>Bandwidth selection by Cronie and Van Lieshout's Criterion</p></a></li>
<li><a href='#bw_cvl_calc.mc'><p>Bandwidth selection by Cronie and Van Lieshout's Criterion (multicore version)</p></a></li>
<li><a href='#bw_tnkde_corr_factor'><p>Time and Network bandwidth correction calculation</p></a></li>
<li><a href='#bws_tnkde_cv_likelihood_calc'><p>Bandwidth selection by likelihood cross validation for temporal NKDE</p></a></li>
<li><a href='#bws_tnkde_cv_likelihood_calc.mc'><p>Bandwidth selection by likelihood cross validation for temporal NKDE (multicore)</p></a></li>
<li><a href='#calc_gamma'><p>Gamma parameter for Abramson’s adaptive bandwidth</p></a></li>
<li><a href='#calc_isochrones'><p>Isochrones calculation</p></a></li>
<li><a href='#check_geometries'><p>Geometry sanity check</p></a></li>
<li><a href='#clean_events'><p>Clean events geometries</p></a></li>
<li><a href='#closest_points'><p>Find closest points</p></a></li>
<li><a href='#continuousfunction'><p>The main function to calculate continuous NKDE (with ARMADILO and sparse matrix)</p></a></li>
<li><a href='#continuousWorker'><p>The worker function to calculate continuous NKDE (with ARMADILLO and integer matrix)</p></a></li>
<li><a href='#continuousWorker_sparse'><p>The worker function to calculate continuous NKDE (with ARMADILLO and sparse matrix)</p></a></li>
<li><a href='#correction_factor'><p>Border correction for NKDE</p></a></li>
<li><a href='#correction_factor_time'><p>Time extent correction for NKDE</p></a></li>
<li><a href='#corrfactor_continuous'><p>A function to calculate the necessary information to apply the</p>
Diggle correction factor with a continuous method</a></li>
<li><a href='#corrfactor_continuous_sparse'><p>A function to calculate the necessary information to apply the</p>
Diggle correction factor with a continuous method (sparse)</a></li>
<li><a href='#corrfactor_discontinuous'><p>A function to calculate the necessary informations to apply the</p>
Diggle correction factor with a discontinuous method</a></li>
<li><a href='#corrfactor_discontinuous_sparse'><p>A function to calculate the necessary information to apply the</p>
Diggle correction factor with a discontinuous method (sparse)</a></li>
<li><a href='#corrfactor_simple'><p>Simple NKDE border correction</p></a></li>
<li><a href='#cosine_kernel'><p>Cosine kernel</p></a></li>
<li><a href='#cosine_kernel_cpp'><p>c++ cosine kernel</p></a></li>
<li><a href='#cosine_kernelos'><p>c++ cosine kernel for one distance</p></a></li>
<li><a href='#cross_gfunc_cpp'><p>c++ cross g function</p></a></li>
<li><a href='#cross_kfunc_cpp'><p>c++ cross k function</p></a></li>
<li><a href='#cross_kfunctions'><p>Network cross k and g functions (maturing)</p></a></li>
<li><a href='#cross_kfunctions.mc'><p>Network cross k and g functions (multicore, maturing)</p></a></li>
<li><a href='#cut_lines_at_distance'><p>Cut lines at a specified distance</p></a></li>
<li><a href='#direct_lines'><p>Make a network directed</p></a></li>
<li><a href='#discontinuousfunction'><p>The main function to calculate discontinuous NKDE (ARMA and sparse matrix)</p></a></li>
<li><a href='#discontinuousWorker_int'><p>The worker function to calculate discontinuous NKDE (with ARMADILLO and Integer matrix)</p></a></li>
<li><a href='#discontinuousWorker_sparse'><p>The worker function to calculate discontinuous NKDE (with ARMADILLO and sparse matrix)</p></a></li>
<li><a href='#dist_mat_dupl'><p>Distance matrix with dupicated</p></a></li>
<li><a href='#epanechnikov_kernel'><p>Epanechnikov kernel</p></a></li>
<li><a href='#epanechnikov_kernel_cpp'><p>c++ epanechnikov kernel</p></a></li>
<li><a href='#epanechnikov_kernelos'><p>c++ epanechnikov kernel for one distance</p></a></li>
<li><a href='#esc_kernel_loo_nkde'><p>The worker function to calculate continuous TNKDE likelihood cv</p></a></li>
<li><a href='#esc_kernel_loo_tnkde'><p>The worker function to calculate continuous TNKDE likelihood cv</p></a></li>
<li><a href='#esd_kernel_loo_nkde'><p>The worker function to calculate discontinuous TNKDE likelihood cv</p></a></li>
<li><a href='#esd_kernel_loo_tnkde'><p>The worker function to calculate discontinuous TNKDE likelihood cv</p></a></li>
<li><a href='#ess_kernel'><p>Worker for simple NKDE algorithm</p></a></li>
<li><a href='#ess_kernel_loo_nkde'><p>The worker function to calculate simple NKDE likelihood cv</p></a></li>
<li><a href='#ess_kernel_loo_tnkde'><p>The worker function to calculate simple TNKDE likelihood cv</p></a></li>
<li><a href='#g_nt_func_cpp'><p>c++ g space-time function</p></a></li>
<li><a href='#gaussian_kernel'><p>Gaussian kernel</p></a></li>
<li><a href='#gaussian_kernel_cpp'><p>c++ gaussian kernel</p></a></li>
<li><a href='#gaussian_kernel_scaled'><p>Scaled gaussian kernel</p></a></li>
<li><a href='#gaussian_kernel_scaled_cpp'><p>c++ scale gaussian kernel</p></a></li>
<li><a href='#gaussian_kernel_scaledos'><p>c++ scaled gaussian kernel for one distance</p></a></li>
<li><a href='#gaussian_kernelos'><p>c++ gaussian kernel for one distance</p></a></li>
<li><a href='#gfunc_cpp'><p>c++ g function</p></a></li>
<li><a href='#gm_mean'><p>Geometric mean</p></a></li>
<li><a href='#graph_checking'><p>Topological error</p></a></li>
<li><a href='#heal_edges'><p>Heal edges</p></a></li>
<li><a href='#is_projected'><p>Projection test</p></a></li>
<li><a href='#k_nt_func_cpp'><p>c++ k space-time function</p></a></li>
<li><a href='#k_nt_functions'><p>Network k and g functions for spatio-temporal data (experimental, NOT READY FOR USE)</p></a></li>
<li><a href='#k_nt_functions.mc'><p>Network k and g functions for spatio-temporal data (multicore, experimental, NOT READY FOR USE)</p></a></li>
<li><a href='#kfunc_cpp'><p>c++ k function</p></a></li>
<li><a href='#kfunctions'><p>Network k and g functions (maturing)</p></a></li>
<li><a href='#kfunctions.mc'><p>Network k and g functions (multicore, maturing)</p></a></li>
<li><a href='#lines_center'><p>Centre points of lines</p></a></li>
<li><a href='#lines_coordinates_as_list'><p>Lines coordinates as list</p></a></li>
<li><a href='#lines_direction'><p>Unify lines direction</p></a></li>
<li><a href='#lines_extremities'><p>Get lines extremities</p></a></li>
<li><a href='#lines_points_along'><p>Points along lines</p></a></li>
<li><a href='#list_coordinates_as_lines'><p>List of coordinates as lines</p></a></li>
<li><a href='#lixelize_lines'><p>Cut lines into lixels</p></a></li>
<li><a href='#lixelize_lines.mc'><p>Cut lines into lixels (multicore)</p></a></li>
<li><a href='#main_network_mtl'><p>Primary road network of Montreal</p></a></li>
<li><a href='#mtl_libraries'><p>Libraries of Montreal</p></a></li>
<li><a href='#mtl_network'><p>Road network of Montreal</p></a></li>
<li><a href='#mtl_theatres'><p>Theatres of Montreal</p></a></li>
<li><a href='#nearest_lines'><p>Nearest line for points</p></a></li>
<li><a href='#nearestPointOnLine'><p>Nearest point on Line</p></a></li>
<li><a href='#nearestPointOnSegment'><p>Nearest point on segment</p></a></li>
<li><a href='#network_knn'><p>K-nearest points on network</p></a></li>
<li><a href='#network_knn_worker'><p>worker function for K-nearest points on network</p></a></li>
<li><a href='#network_knn.mc'><p>K-nearest points on network (multicore version)</p></a></li>
<li><a href='#network_listw'><p>Network distance listw</p></a></li>
<li><a href='#network_listw_worker'><p>network_listw worker</p></a></li>
<li><a href='#network_listw.mc'><p>Network distance listw (multicore)</p></a></li>
<li><a href='#nkde'><p>Network Kernel density estimate</p></a></li>
<li><a href='#nkde_get_loo_values'><p>The exposed function to calculate NKDE likelihood cv</p></a></li>
<li><a href='#nkde_worker'><p>NKDE worker</p></a></li>
<li><a href='#nkde_worker_bw_sel'><p>Bandwidth selection by likelihood cross validation worker function</p></a></li>
<li><a href='#nkde.mc'><p>Network Kernel density estimate (multicore)</p></a></li>
<li><a href='#plot_graph'><p>Plot graph</p></a></li>
<li><a href='#prepare_data'><p>Prior data preparation</p></a></li>
<li><a href='#prepare_elements_netlistw'><p>Data preparation for network_listw</p></a></li>
<li><a href='#quartic_kernel'><p>Quartic kernel</p></a></li>
<li><a href='#quartic_kernel_cpp'><p>c++ quartic kernel</p></a></li>
<li><a href='#quartic_kernelos'><p>c++ quartic kernel for one distance</p></a></li>
<li><a href='#randomize_distmatrix'><p>Points on network randomization</p></a></li>
<li><a href='#randomize_distmatrix2'><p>Points on network randomization simplified</p></a></li>
<li><a href='#remove_loop_lines'><p>Remove loops</p></a></li>
<li><a href='#remove_mirror_edges'><p>Remove mirror edges</p></a></li>
<li><a href='#reverse_lines'><p>Reverse lines</p></a></li>
<li><a href='#sanity_check_knn'><p>Sanity check for the knn functions</p></a></li>
<li><a href='#select_dist_function'><p>Select the distance to weight function</p></a></li>
<li><a href='#select_kernel'><p>Select kernel function</p></a></li>
<li><a href='#simple_lines'><p>LineString to simple Line</p></a></li>
<li><a href='#simple_nkde'><p>Simple NKDE algorithm</p></a></li>
<li><a href='#simple_tnkde'><p>Simple TNKDE algorithm</p></a></li>
<li><a href='#simplify_network'><p>Simplify a network</p></a></li>
<li><a href='#small_mtl_network'><p>Smaller subset road network of Montreal</p></a></li>
<li><a href='#snapPointsToLines2'><p>Snap points to lines</p></a></li>
<li><a href='#sp_char_index'><p>Coordinates to unique character vector</p></a></li>
<li><a href='#spatial_index'><p>An object (c++ pointer) to do some spatial query of rectanlges (internal)</p></a></li>
<li><a href='#spatial_index$new'><p>Constructor method for a spatial_index object</p></a></li>
<li><a href='#spatial_index$tree_request'><p>spatial request on rtree index (internal)</p></a></li>
<li><a href='#spatial_request'><p>Spatial request</p></a></li>
<li><a href='#split_border'><p>Split boundary of polygon</p></a></li>
<li><a href='#split_by_grid'><p>Split data with a grid</p></a></li>
<li><a href='#split_by_grid_abw'><p>Split data with a grid for the adaptive bw function</p></a></li>
<li><a href='#split_by_grid_abw.mc'><p>Split data with a grid for the adaptive bw function (multicore)</p></a></li>
<li><a href='#split_by_grid.mc'><p>Split data with a grid (multicore)</p></a></li>
<li><a href='#split_graph_components'><p>Split graph components</p></a></li>
<li><a href='#split_lines_at_vertex'><p>Split lines at vertices in a feature collection of linestrings</p></a></li>
<li><a href='#spNetwork-package'><p>spNetwork: Spatial Analysis on Network</p></a></li>
<li><a href='#st_bbox_by_feature'><p>Obtain all the bounding boxes of a feature collection</p></a></li>
<li><a href='#st_bbox_geom'><p>sf geometry bbox</p></a></li>
<li><a href='#surrounding_points'><p>Points along polygon boundary</p></a></li>
<li><a href='#tkde'><p>Temporal Kernel density estimate</p></a></li>
<li><a href='#tnkde'><p>Temporal Network Kernel density estimate</p></a></li>
<li><a href='#tnkde_get_loo_values'><p>The exposed function to calculate TNKDE likelihood cv</p></a></li>
<li><a href='#tnkde_worker'><p>TNKDE worker</p></a></li>
<li><a href='#tnkde_worker_bw_sel'><p>Worker function fo Bandwidth selection by likelihood cross validation for temporal NKDE</p></a></li>
<li><a href='#tnkde.mc'><p>Temporal Network Kernel density estimate (multicore)</p></a></li>
<li><a href='#tnkdecontinuousfunction'><p>The main function to calculate continuous TNKDE (with ARMADILO and sparse matrix)</p></a></li>
<li><a href='#tnkdediscontinuousfunction'><p>The main function to calculate discontinuous NKDE (ARMA and Integer matrix)</p></a></li>
<li><a href='#tnkdediscontinuousfunctionsparse'><p>The main function to calculate discontinuous NKDE (ARMA and sparse matrix)</p></a></li>
<li><a href='#triangle_kernel'><p>triangle kernel</p></a></li>
<li><a href='#triangle_kernel_cpp'><p>c++ triangle kernel</p></a></li>
<li><a href='#triangle_kernelos'><p>c++ triangle kernel for one distance</p></a></li>
<li><a href='#tricube_kernel'><p>Tricube kernel</p></a></li>
<li><a href='#tricube_kernel_cpp'><p>c++ tricube kernel</p></a></li>
<li><a href='#tricube_kernelos'><p>c++ tricube kernel for one distance</p></a></li>
<li><a href='#trim_lines_at'><p>Helper for isochrones lines cutting</p></a></li>
<li><a href='#triweight_kernel'><p>Triweight kernel</p></a></li>
<li><a href='#triweight_kernel_cpp'><p>c++ triweight kernel</p></a></li>
<li><a href='#triweight_kernelos'><p>c++ triweight kernel for one distance</p></a></li>
<li><a href='#uniform_kernel'><p>Uniform kernel</p></a></li>
<li><a href='#uniform_kernel_cpp'><p>c++ uniform kernel</p></a></li>
<li><a href='#uniform_kernelos'><p>c++ uniform kernel for one distance</p></a></li>
<li><a href='#worker_adaptive_bw_tnkde'><p>Worker function for adaptive bandwidth for TNDE</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Analysis on Network</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.3.8</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform spatial analysis on network.
    Implement several methods for spatial analysis on network: Network Kernel Density estimation, 
    building of spatial matrices based on network distance ('listw' objects from 'spdep' package), K functions estimation 
    for point pattern analysis on network, k nearest neighbours on network, reachable area calculation, and graph generation
    References: Okabe et al (2019) &lt;<a href="https://doi.org/10.1080%2F13658810802475491">doi:10.1080/13658810802475491</a>&gt;;
    Okabe et al (2012, ISBN:978-0470770818);Baddeley et al (2015, ISBN:9781482210200).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>spdep (&ge; 1.1.2), igraph (&ge; 1.2.6), cubature (&ge; 2.0.4.1),
future.apply (&ge; 1.4.0), methods (&ge; 1.7.1), ggplot2 (&ge;
3.3.0), progressr (&ge; 0.4.0), data.table (&ge; 1.12.8), Rcpp (&ge;
1.0.4.6), Rdpack (&ge; 2.1.1), dbscan (&ge; 1.1-8), sf (&ge; 1.0-3),
dplyr (&ge; 0.8.3), abind (&ge; 1.4-5)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>future (&ge; 1.16.0), testthat (&ge; 3.0.0), kableExtra (&ge;
1.1.0), RColorBrewer (&ge; 1.1-2), classInt (&ge; 0.4-3), reshape2
(&ge; 1.4.3), rlang (&ge; 0.4.6), rgl (&ge; 0.107.14), tmap (&ge;
3.3-1), smoothr (&ge; 0.2.2), concaveman (&ge; 1.1.0), covr (&ge;
3.5.1), knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jeremygelb.github.io/spNetwork/">https://jeremygelb.github.io/spNetwork/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/JeremyGelb/spNetwork/issues">https://github.com/JeremyGelb/spNetwork/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress, RcppArmadillo, BH</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-23 01:03:25 UTC; Gelb</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy Gelb <a href="https://orcid.org/0000-0002-7114-2714"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Philippe Apparicio
    <a href="https://orcid.org/0000-0001-6466-9342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeremy Gelb &lt;jeremy.gelb@ucs.inrs.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 11:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptive_bw'>Adaptive bandwidth</h2><span id='topic+adaptive_bw'></span>

<h3>Description</h3>

<p>Function to calculate Adaptive bandwidths according to Abramson’s smoothing regimen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_bw(
  grid,
  events,
  lines,
  bw,
  trim_bw,
  method,
  kernel_name,
  max_depth,
  tol,
  digits,
  sparse,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_bw_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events points</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_bw">bw</code></td>
<td>
<p>The fixed kernel bandwidth</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_trim_bw">trim_bw</code></td>
<td>
<p>The maximum size of local bandiwidths</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum recursion depth</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse matrix should be used</p>
</td></tr>
<tr><td><code id="adaptive_bw_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if update messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the local bandwidths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='adaptive_bw_1d'>Adaptive bw in one dimension</h2><span id='topic+adaptive_bw_1d'></span>

<h3>Description</h3>

<p>Calculate adaptive bandwidths in one dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_bw_1d(events, w, bw, kernel_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_bw_1d_+3A_events">events</code></td>
<td>
<p>A numeric vector representing the moments of occurrence of events</p>
</td></tr>
<tr><td><code id="adaptive_bw_1d_+3A_w">w</code></td>
<td>
<p>The weight of the events</p>
</td></tr>
<tr><td><code id="adaptive_bw_1d_+3A_bw">bw</code></td>
<td>
<p>A float, the bandiwdth to use</p>
</td></tr>
<tr><td><code id="adaptive_bw_1d_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
</table>

<hr>
<h2 id='adaptive_bw_tnkde'>Adaptive bandwidth for TNDE</h2><span id='topic+adaptive_bw_tnkde'></span>

<h3>Description</h3>

<p>Function to calculate Adaptive bandwidths according to Abramson’s smoothing regimen
for TNKDE with a space-time interaction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_bw_tnkde(
  grid,
  events_loc,
  events,
  lines,
  bw_net,
  bw_time,
  trim_bw_net,
  trim_bw_time,
  method,
  kernel_name,
  max_depth,
  div,
  tol,
  digits,
  sparse,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_bw_tnkde_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events points</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_bw_net">bw_net</code></td>
<td>
<p>The fixed kernel bandwidth for the network dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_bw_time">bw_time</code></td>
<td>
<p>The fixed kernel bandwidth for the time dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_trim_bw_net">trim_bw_net</code></td>
<td>
<p>The maximum size of local bandiwidths for network dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_trim_bw_time">trim_bw_time</code></td>
<td>
<p>The maximum size of local bandiwidths for time dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum recursion depth</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_div">div</code></td>
<td>
<p>The divisor to use for kernels</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse matrix should be used</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if update messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the local bandwidths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='adaptive_bw_tnkde_cpp'>The exposed function to calculate adaptive bandwidth with space-time
interaction for TNKDE (INTERNAL)</h2><span id='topic+adaptive_bw_tnkde_cpp'></span>

<h3>Description</h3>

<p>The exposed function to calculate adaptive bandwidth with space-time
interaction for TNKDE (INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_bw_tnkde_cpp(
  method,
  neighbour_list,
  sel_events,
  sel_events_wid,
  sel_events_time,
  events,
  events_wid,
  events_time,
  weights,
  bws_net,
  bws_time,
  kernel_name,
  line_list,
  max_depth,
  min_tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_method">method</code></td>
<td>
<p>a string, one of &quot;simple&quot;, &quot;continuous&quot;, &quot;discontinuous&quot;</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_sel_events">sel_events</code></td>
<td>
<p>a Numeric vector indicating the selected events (id of nodes)</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_sel_events_wid">sel_events_wid</code></td>
<td>
<p>a Numeric Vector indicating the unique if of the selected events</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_sel_events_time">sel_events_time</code></td>
<td>
<p>a Numeric Vector indicating the time of the selected events</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_events_wid">events_wid</code></td>
<td>
<p>a NumericVector indicating the unique id of all the events</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_events_time">events_time</code></td>
<td>
<p>a NumericVector indicating the timestamp of each event</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_weights">weights</code></td>
<td>
<p>a cube with the weights associated with each event for each
bws_net and bws_time.</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_bws_time">bws_time</code></td>
<td>
<p>an arma::vec with the time bandwidths to consider</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_kernel_name">kernel_name</code></td>
<td>
<p>a string with the name of the kernel to use</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame describing the lines</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde_cpp_+3A_min_tol">min_tol</code></td>
<td>
<p>a double indicating by how much 0 in density values must be replaced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector witht the estimated density at each event location
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='adaptive_bw_tnkde.mc'>Adaptive bandwidth for TNDE (multicore)</h2><span id='topic+adaptive_bw_tnkde.mc'></span>

<h3>Description</h3>

<p>Function to calculate Adaptive bandwidths according to Abramson’s smoothing regimen
for TNKDE with a space-time interaction with multicore support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_bw_tnkde.mc(
  grid,
  events_loc,
  events,
  lines,
  bw_net,
  bw_time,
  trim_bw_net,
  trim_bw_time,
  method,
  kernel_name,
  max_depth,
  div,
  tol,
  digits,
  sparse,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events points</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_bw_net">bw_net</code></td>
<td>
<p>The fixed kernel bandwidth for the network dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_bw_time">bw_time</code></td>
<td>
<p>The fixed kernel bandwidth for the time dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_trim_bw_net">trim_bw_net</code></td>
<td>
<p>The maximum size of local bandiwidths for network dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_trim_bw_time">trim_bw_time</code></td>
<td>
<p>The maximum size of local bandiwidths for time dimension</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum recursion depth</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_div">div</code></td>
<td>
<p>The divisor to use for kernels</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse matrix should be used</p>
</td></tr>
<tr><td><code id="adaptive_bw_tnkde.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if update messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the local bandwidths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='adaptive_bw.mc'>Adaptive bandwidth (multicore)</h2><span id='topic+adaptive_bw.mc'></span>

<h3>Description</h3>

<p>Function to calculate Adaptive bandwidths according to
Abramson’s smoothing regimen with multicore support
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adaptive_bw.mc(
  grid,
  events,
  lines,
  bw,
  trim_bw,
  method,
  kernel_name,
  max_depth,
  tol,
  digits,
  sparse,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adaptive_bw.mc_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_bw">bw</code></td>
<td>
<p>The fixed kernel bandwidth</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_trim_bw">trim_bw</code></td>
<td>
<p>The maximum size of local bandwidths</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum recursion depth</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse matrix should be used</p>
</td></tr>
<tr><td><code id="adaptive_bw.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if update messages should be printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the local bandwidths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='add_center_lines'>Add center vertex to lines</h2><span id='topic+add_center_lines'></span>

<h3>Description</h3>

<p>Add to each feature of a feature collection of lines an additional vertex at its
center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_center_lines(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_center_lines_+3A_lines">lines</code></td>
<td>
<p>The feature collection of linestrings to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='add_vertices_lines'>Add vertices to a feature collection of linestrings</h2><span id='topic+add_vertices_lines'></span>

<h3>Description</h3>

<p>Add vertices (feature collection of points) to their nearest lines
(feature collection of linestrings), may fail if the line geometries are self intersecting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_vertices_lines(lines, points, nearest_lines_idx, mindist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_vertices_lines_+3A_lines">lines</code></td>
<td>
<p>The feature collection of linestrings to modify</p>
</td></tr>
<tr><td><code id="add_vertices_lines_+3A_points">points</code></td>
<td>
<p>The feature collection of points to add to as vertex to the lines</p>
</td></tr>
<tr><td><code id="add_vertices_lines_+3A_nearest_lines_idx">nearest_lines_idx</code></td>
<td>
<p>For each point, the index of the nearest line</p>
</td></tr>
<tr><td><code id="add_vertices_lines_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance between one point and the extremity of
the line to add the point as a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='aggregate_points'>Events aggregation</h2><span id='topic+aggregate_points'></span>

<h3>Description</h3>

<p>Function to aggregate points within a radius.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_points(points, maxdist, weight = "weight")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregate_points_+3A_points">points</code></td>
<td>
<p>The feature collection of points to contract (must have a weight column)</p>
</td></tr>
<tr><td><code id="aggregate_points_+3A_maxdist">maxdist</code></td>
<td>
<p>The distance to use</p>
</td></tr>
<tr><td><code id="aggregate_points_+3A_weight">weight</code></td>
<td>
<p>The name of the column to use as weight (default is &quot;weight&quot;).
The values of the aggregated points for this column will be summed. For all
the other columns, only the max value is retained.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to aggregate points within a radius. This
is done by using the dbscan algorithm. This process is
repeated until no more modification is applied.
</p>


<h3>Value</h3>

<p>A new feature collection of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bike_accidents)
bike_accidents$weight &lt;- 1
agg_points &lt;- aggregate_points(bike_accidents, 5)
</code></pre>

<hr>
<h2 id='bike_accidents'>Road accidents including a bicyle in Montreal in 2016</h2><span id='topic+bike_accidents'></span>

<h3>Description</h3>

<p>A feature collection (sf object) representing road accidents including a
cyclist in Montreal in 2016. The EPSG is 3797, and the data comes from the
Montreal OpenData website. It is only a small subset in central districts used to demonstrate the
main functions of spNetwork.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bike_accidents
</code></pre>


<h3>Format</h3>

<p>A sf object with 347 rows and 4 variables
</p>

<dl>
<dt>NB_VICTIME</dt><dd><p>the number of victims</p>
</dd>
<dt>AN</dt><dd><p>the year of the accident</p>
</dd>
<dt>Date</dt><dd><p>the date of the accident (yyyy/mm/dd)</p>
</dd>
<dt>geom</dt><dd><p>the geometry (points)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://donnees.montreal.ca/ville-de-montreal/collisions-routieres&gt;
</p>

<hr>
<h2 id='build_graph'>Network generation</h2><span id='topic+build_graph'></span>

<h3>Description</h3>

<p>Generate an igraph object from a feature collection of linestrings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_graph(lines, digits, line_weight, attrs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_graph_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines</p>
</td></tr>
<tr><td><code id="build_graph_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep from the coordinates</p>
</td></tr>
<tr><td><code id="build_graph_+3A_line_weight">line_weight</code></td>
<td>
<p>The name of the column giving the weight of the lines</p>
</td></tr>
<tr><td><code id="build_graph_+3A_attrs">attrs</code></td>
<td>
<p>A boolean indicating if the original lines' attributes should be
stored in the final object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to generate an undirected graph object (igraph
object). It uses the coordinates of the linestrings extremities to create
the nodes of the graph. This is why the number of digits in the coordinates
is important. Too high precision (high number of digits) might break some
connections.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p> graph: an igraph object;
</p>
</li>
<li><p> linelist: the dataframe used to build the graph;
</p>
</li>
<li><p> lines: the original feature collection of linestrings;
</p>
</li>
<li><p> spvertices: a feature collection of points representing the vertices
of the graph;
</p>
</li>
<li><p> digits : the number of digits kept for the coordinates.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(mtl_network)
mtl_network$length &lt;- as.numeric(sf::st_length(mtl_network))
graph_result &lt;- build_graph(mtl_network, 2, "length", attrs = TRUE)
</code></pre>

<hr>
<h2 id='build_graph_directed'>Directed network generation</h2><span id='topic+build_graph_directed'></span>

<h3>Description</h3>

<p>Generate a directed igraph object from a feature collection of linestrings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_graph_directed(lines, digits, line_weight, direction, attrs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_graph_directed_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings</p>
</td></tr>
<tr><td><code id="build_graph_directed_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep from the coordinates</p>
</td></tr>
<tr><td><code id="build_graph_directed_+3A_line_weight">line_weight</code></td>
<td>
<p>The name of the column giving the weight of the lines</p>
</td></tr>
<tr><td><code id="build_graph_directed_+3A_direction">direction</code></td>
<td>
<p>A column name indicating authorized travelling direction on
lines. if NULL, then all lines can be used in both directions. Must be the
name of a column otherwise. The values of the column must be &quot;FT&quot; (From -
To), &quot;TF&quot; (To - From) or &quot;Both&quot;</p>
</td></tr>
<tr><td><code id="build_graph_directed_+3A_attrs">attrs</code></td>
<td>
<p>A boolean indicating if the original lines' attributes should be
stored in the final object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to generate a directed graph object (igraph
object). It uses the coordinates of the linestrings extremities to create
the nodes of the graph. This is why the number of digits in the coordinates
is important. Too high precision (high number of digits) might break some
connections. The column used to indicate directions can only have the
following values: &quot;FT&quot; (From-To), &quot;TF&quot; (To-From) and &quot;Both&quot;.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p> graph: an igraph object;
</p>
</li>
<li><p> linelist: the dataframe used to build the graph;
</p>
</li>
<li><p> lines: the original feature collection of lines;
</p>
</li>
<li><p> spvertices: a feature collection of points representing the vertices
of the graph;
</p>
</li>
<li><p> digits : the number of digits kept for the coordinates.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
mtl_network$length &lt;- as.numeric(sf::st_length(mtl_network))
mtl_network$direction &lt;- "Both"
mtl_network[6, "direction"] &lt;- "TF"
mtl_network_directed &lt;- lines_direction(mtl_network, "direction")
graph_result &lt;- build_graph_directed(lines = mtl_network_directed,
        digits = 2,
        line_weight = "length",
        direction = "direction",
        attrs = TRUE)

</code></pre>

<hr>
<h2 id='build_grid'>Spatial grid</h2><span id='topic+build_grid'></span>

<h3>Description</h3>

<p>Generate a grid of a specified shape in the bbox of a Spatial object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_grid(grid_shape, spatial)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_grid_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A numeric vector of length 2 indicating the number
of rows and the numbers of columns of the grid</p>
</td></tr>
<tr><td><code id="build_grid_+3A_spatial">spatial</code></td>
<td>
<p>A list of spatial feature collections objects (package sf)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of polygons representing the grid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='build_quadtree'>Build a quadtree</h2><span id='topic+build_quadtree'></span>

<h3>Description</h3>

<p>Generate a quadtree object from package SearchTrees, useful to speed up
spatial requesting (INTERNAL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_quadtree(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_quadtree_+3A_data">data</code></td>
<td>
<p>a feature collection of linestrings or a feature collection of points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spatial_index object (pointer to a c++ instance)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='bw_checks'>Check function for parameters in bandwidth selection methods</h2><span id='topic+bw_checks'></span>

<h3>Description</h3>

<p>A check function for bandwidth selection methods raising an error if a parameter is not valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_checks(
  check,
  lines,
  samples,
  events,
  kernel_name,
  method,
  bw_net_range = NULL,
  bw_time_range = NULL,
  bw_net_step = NULL,
  bw_time_step = NULL,
  diggle_correction = FALSE,
  study_area = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_checks_+3A_check">check</code></td>
<td>
<p>A boolean indicating if the geometries must be checked</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points representing the sample location</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_events">events</code></td>
<td>
<p>a feature collection of points representing the events</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_method">method</code></td>
<td>
<p>The name of the NKDE to use</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_bw_net_range">bw_net_range</code></td>
<td>
<p>The range for the network bandwidth to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_bw_time_range">bw_time_range</code></td>
<td>
<p>The range for the time bandwidth to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_bw_net_step">bw_net_step</code></td>
<td>
<p>The step between each network bandwidth to calculate, given as a float</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_bw_time_step">bw_time_step</code></td>
<td>
<p>The step between each time bandwidth to calculate, given as a float</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bw_checks_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='bw_cv_likelihood_calc'>Bandwidth selection by likelihood cross validation</h2><span id='topic+bw_cv_likelihood_calc'></span>

<h3>Description</h3>

<p>Calculate for multiple bandwidth the cross validation likelihood to
select an appropriate bandwidth in a data-driven approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_cv_likelihood_calc(
  bw_range,
  bw_step,
  lines,
  events,
  w,
  kernel_name,
  method,
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  grid_shape = c(1, 1),
  sub_sample = 1,
  zero_strat = "min_double",
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_cv_likelihood_calc_+3A_bw_range">bw_range</code></td>
<td>
<p>The range of the bandwidths to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_bw_step">bw_step</code></td>
<td>
<p>The step between each bandwidth to calculate given as a float</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_sub_sample">sub_sample</code></td>
<td>
<p>A float between 0 and 1 indicating the percentage of quadra
to keep in the calculus. For large datasets, it may be useful to limit the
bandwidth evaluation and thus reduce calculation time.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_zero_strat">zero_strat</code></td>
<td>
<p>A string indicating what to do when density is 0 when calculating LOO density estimate for an isolated event.
&quot;min_double&quot; (default) replace the 0 value by the minimum double possible on the machine. &quot;remove&quot; will remove them from the final
score. The first approach penalizes more strongly the small bandwidths.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the likelihood cross validation score for several
bandwidths in order to find the most appropriate one. The general idea is to find the
bandwidth that would produce the most similar results if one event was removed from
the dataset (leave one out cross validation). We use here the shortcut formula as
described by the package spatstat (Baddeley et al. 2021).
</p>
<p>LCV(h) = sum[i] log(lambda[-i](x[i]))
</p>
<p>Where the sum is taken for all events x[i] and where lambda[-i](x[i]) is the leave-one-out kernel
estimate at x[i] for a bandwidth h. A higher value indicates a better bandwidth.
</p>


<h3>Value</h3>

<p>A dataframe with two columns, one for the bandwidths and the second for
the cross validation score (the lower the better).
</p>


<h3>References</h3>


<p>Baddeley A, Turner R, Rubak E (2021).
<em>spatstat: Spatial Point Pattern Analysis, Model-Fitting, Simulation, Tests</em>.
R package version 2.1-0, <a href="https://CRAN.R-project.org/package=spatstat">https://CRAN.R-project.org/package=spatstat</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
data(bike_accidents)
cv_scores &lt;- bw_cv_likelihood_calc(c(200,800),50,
                               mtl_network, bike_accidents,
                               rep(1,nrow(bike_accidents)),
                               "quartic", "simple",
                               diggle_correction = FALSE, study_area = NULL,
                               max_depth = 8,
                               digits=2, tol=0.1, agg=5,
                               sparse=TRUE, grid_shape=c(1,1),
                               sub_sample = 1, verbose=TRUE, check=TRUE)

</code></pre>

<hr>
<h2 id='bw_cv_likelihood_calc_tkde'>Bandwidth selection for Temporal Kernel density estimate by likelihood cross validation</h2><span id='topic+bw_cv_likelihood_calc_tkde'></span>

<h3>Description</h3>

<p>Calculate the likelihood cross validation score for several bandwidths for the
Temporal Kernel density
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_cv_likelihood_calc_tkde(events, w, bws, kernel_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_cv_likelihood_calc_tkde_+3A_events">events</code></td>
<td>
<p>A numeric vector representing the moments of occurrence of events</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_tkde_+3A_w">w</code></td>
<td>
<p>The weight of the events</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_tkde_+3A_bws">bws</code></td>
<td>
<p>A numeric vector, the bandwidths to use</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc_tkde_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the cross validation scores (the higher the better).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bike_accidents)
bike_accidents$Date &lt;- as.POSIXct(bike_accidents$Date, format = "%Y/%m/%d")
start &lt;- min(bike_accidents$Date)
diff &lt;- as.integer(difftime(bike_accidents$Date , start, units = "days"))
w &lt;- rep(1,length(diff))
scores &lt;- bw_cv_likelihood_calc_tkde(diff, w, seq(10,60,10), "quartic")
</code></pre>

<hr>
<h2 id='bw_cv_likelihood_calc.mc'>Bandwidth selection by likelihood cross validation (multicore)</h2><span id='topic+bw_cv_likelihood_calc.mc'></span>

<h3>Description</h3>

<p>Calculate for multiple bandwidth the cross validation likelihood to
select an appropriate bandwidth in a data-driven approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_cv_likelihood_calc.mc(
  bw_range,
  bw_step,
  lines,
  events,
  w,
  kernel_name,
  method,
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  grid_shape = c(1, 1),
  sub_sample = 1,
  zero_strat = "min_double",
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_bw_range">bw_range</code></td>
<td>
<p>The range of the bandwidths to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_bw_step">bw_step</code></td>
<td>
<p>The step between each bandwidth to calculate given as a float</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_sub_sample">sub_sample</code></td>
<td>
<p>A float between 0 and 1 indicating the percentage of quadra
to keep in the calculus. For large datasets, it may be useful to limit the
bandwidth evaluation and thus reduce calculation time.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_zero_strat">zero_strat</code></td>
<td>
<p>A string indicating what to do when density is 0 when calculating LOO density estimate for an isolated event.
&quot;min_double&quot; (default) replace the 0 value by the minimum double possible on the machine. &quot;remove&quot; will remove them from the final
score. The first approach penalizes more strongly the small bandwidths.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="bw_cv_likelihood_calc.mc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the function bw_cv_likelihood_calc for more details. The calculation is split
according to the parameter grid_shape. If grid_shape = c(1,1), then parallel processing cannot be used.
</p>


<h3>Value</h3>

<p>A dataframe with two columns, one for the bandwidths and the second for
the cross validation score (the lower the better).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
data(bike_accidents)
future::plan(future::multisession(workers=1))
cv_scores &lt;- bw_cv_likelihood_calc.mc(c(200,800),50,
                               mtl_network, bike_accidents,
                               rep(1,nrow(bike_accidents)),
                               "quartic", "simple",
                               diggle_correction = FALSE, study_area = NULL,
                               max_depth = 8,
                               digits=2, tol=0.1, agg=5,
                               sparse=TRUE, grid_shape=c(1,1),
                               sub_sample = 1, verbose=TRUE, check=TRUE)
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='bw_cvl_calc'>Bandwidth selection by Cronie and Van Lieshout's Criterion</h2><span id='topic+bw_cvl_calc'></span>

<h3>Description</h3>

<p>Calculate for multiple bandwidth the Cronie and Van Lieshout's Criterion to
select an appropriate bandwidth in a data-driven approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_cvl_calc(
  bw_range,
  bw_step,
  lines,
  events,
  w,
  kernel_name,
  method,
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  zero_strat = "min_double",
  grid_shape = c(1, 1),
  sub_sample = 1,
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_cvl_calc_+3A_bw_range">bw_range</code></td>
<td>
<p>The range of the bandwidths to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_bw_step">bw_step</code></td>
<td>
<p>The step between each bandwidth to calculate given as a float</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_zero_strat">zero_strat</code></td>
<td>
<p>A string indicating what to do when density is 0 when calculating LOO density estimate for an isolated event.
&quot;min_double&quot; (default) replace the 0 value by the minimum double possible on the machine. &quot;remove&quot; will remove them from the final
score. The first approach penalizes more strongly the small bandwidths.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_sub_sample">sub_sample</code></td>
<td>
<p>A float between 0 and 1 indicating the percentage of quadra
to keep in the calculus. For large datasets, it may be useful to limit the
bandwidth evaluation and thus reduce calculation time.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Cronie and Van Lieshout's Criterion (Cronie and Van Lieshout 2018)
find the optimal bandwidth by minimizing the difference between the size of the observation
window and the sum of the reciprocal of the estimated kernel density at the
events locations. In the network case, the size of the study area is the sum
of the length of each line in the network. Thus, it is important to only
use the necessary parts of the network.
</p>


<h3>Value</h3>

<p>A dataframe with two columns, one for the bandwidths and the second for
the Cronie and Van Lieshout's Criterion.
</p>


<h3>References</h3>


<p>Cronie O, Van Lieshout MNM (2018).
&ldquo;A non-model-based approach to bandwidth selection for kernel estimators of spatial intensity functions.&rdquo;
<em>Biometrika</em>, <b>105</b>(2), 455&ndash;462.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
data(bike_accidents)
cv_scores &lt;- bw_cvl_calc(c(200,400),50,
                               mtl_network, bike_accidents,
                               rep(1,nrow(bike_accidents)),
                               "quartic", "discontinuous",
                               diggle_correction = FALSE, study_area = NULL,
                               max_depth = 8,
                               digits=2, tol=0.1, agg=5,
                               sparse=TRUE, grid_shape=c(1,1),
                               sub_sample = 1, verbose=TRUE, check=TRUE)

</code></pre>

<hr>
<h2 id='bw_cvl_calc.mc'>Bandwidth selection by Cronie and Van Lieshout's Criterion (multicore version)</h2><span id='topic+bw_cvl_calc.mc'></span>

<h3>Description</h3>

<p>Calculate for multiple bandwidths the Cronie and Van Lieshout's Criterion to
select an appropriate bandwidth in a data-driven approach. A plan from the package future can be used
to split the work across several cores. The different cells generated in accordance with the
argument grid_shape are used for the parallelization. So if only one cell is
generated (grid_shape = c(1,1)), the function will use only one core. The progress bar
displays the progression for the cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_cvl_calc.mc(
  bw_range,
  bw_step,
  lines,
  events,
  w,
  kernel_name,
  method,
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  zero_strat = "min_double",
  grid_shape = c(1, 1),
  sub_sample = 1,
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_cvl_calc.mc_+3A_bw_range">bw_range</code></td>
<td>
<p>The range of the bandwidths to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_bw_step">bw_step</code></td>
<td>
<p>The step between each bandwidth to calculate given as a float</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_zero_strat">zero_strat</code></td>
<td>
<p>A string indicating what to do when density is 0 when calculating LOO density estimate for an isolated event.
&quot;min_double&quot; (default) replace the 0 value by the minimum double possible on the machine. &quot;remove&quot; will remove them from the final
score. The first approach penalizes more strongly the small bandwidths.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_sub_sample">sub_sample</code></td>
<td>
<p>A float between 0 and 1 indicating the percentage of quadra
to keep in the calculus. For large datasets, it may be useful to limit the
bandwidth evaluation and thus reduce calculation time.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="bw_cvl_calc.mc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details, see help(bw_cvl_calc)
</p>


<h3>Value</h3>

<p>A dataframe with two columns, one for the bandwidths and the second for
the Cronie and Van Lieshout's Criterion.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
data(bike_accidents)
future::plan(future::multisession(workers=1))
cv_scores &lt;- bw_cvl_calc.mc(c(200,400),50,
                               mtl_network, bike_accidents,
                               rep(1,nrow(bike_accidents)),
                               "quartic", "discontinuous",
                               diggle_correction = FALSE, study_area = NULL,
                               max_depth = 8,
                               digits=2, tol=0.1, agg=5,
                               sparse=TRUE, grid_shape=c(1,1),
                               sub_sample = 1, verbose=TRUE, check=TRUE)
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='bw_tnkde_corr_factor'>Time and Network bandwidth correction calculation</h2><span id='topic+bw_tnkde_corr_factor'></span>

<h3>Description</h3>

<p>Caclulating the border correction factor for both time and network bandwidths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_tnkde_corr_factor(
  net_bws,
  time_bws,
  diggle_correction,
  study_area,
  events,
  events_loc,
  lines,
  method,
  kernel_name,
  tol,
  digits,
  max_depth,
  sparse
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_tnkde_corr_factor_+3A_net_bws">net_bws</code></td>
<td>
<p>A vector of network bandwidths</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_time_bws">time_bws</code></td>
<td>
<p>A vector of time bandwidths</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_events_loc">events_loc</code></td>
<td>
<p>A feature collection of points representing the unique location of events</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying lines of the network</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_method">method</code></td>
<td>
<p>The name of the NKDE to use</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_tol">tol</code></td>
<td>
<p>float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_digits">digits</code></td>
<td>
<p>An integer, the number of digits to keep for the spatial coordinates</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximal depth for continuous or discontinuous NKDE</p>
</td></tr>
<tr><td><code id="bw_tnkde_corr_factor_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='bws_tnkde_cv_likelihood_calc'>Bandwidth selection by likelihood cross validation for temporal NKDE</h2><span id='topic+bws_tnkde_cv_likelihood_calc'></span>

<h3>Description</h3>

<p>Calculate for multiple network and time bandwidths the cross validation likelihood to
select an appropriate bandwidth in a data-driven approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws_tnkde_cv_likelihood_calc(
  bw_net_range,
  bw_net_step,
  bw_time_range,
  bw_time_step,
  lines,
  events,
  time_field,
  w,
  kernel_name,
  method,
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  zero_strat = "min_double",
  grid_shape = c(1, 1),
  sub_sample = 1,
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_bw_net_range">bw_net_range</code></td>
<td>
<p>The range for the network bandwidth to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_bw_net_step">bw_net_step</code></td>
<td>
<p>The step between each network bandwidth to calculate, given as a float</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_bw_time_range">bw_time_range</code></td>
<td>
<p>The range for the time bandwidth to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_bw_time_step">bw_time_step</code></td>
<td>
<p>The step between each time bandwidth to calculate, given as a float</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_time_field">time_field</code></td>
<td>
<p>The name of the field in events indicating when the events occurred. It must be a numeric field</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_zero_strat">zero_strat</code></td>
<td>
<p>A string indicating what to do when density is 0 when calculating LOO density estimate for an isolated event.
&quot;min_double&quot; (default) replace the 0 value by the minimum double possible on the machine. &quot;remove&quot; will remove them from the final
score. The first approach penalizes more strongly the small bandwidths.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_sub_sample">sub_sample</code></td>
<td>
<p>A float between 0 and 1 indicating the percentage of quadra
to keep in the calculus. For large datasets, it may be useful to limit the
bandwidth evaluation and thus reduce calculation time.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the likelihood cross validation score for several time and network
bandwidths in order to find the most appropriate one. The general idea is to find the pair of
bandwidths that would produce the most similar results if one event is removed from
the dataset (leave one out cross validation). We use here the shortcut formula as
described by the package spatstat (Baddeley et al. 2021).
</p>
<p>LCV(h) = sum[i] log(lambda[-i](x[i]))
</p>
<p>Where the sum is taken for all events x[i] and where lambda[-i](x[i]) is the leave-one-out kernel
estimate at x[i] for a bandwidth h. A lower value indicates a better bandwidth.
</p>


<h3>Value</h3>

<p>A matrix with the cross validation score.  Each row corresponds to a network
bandwidth and each column to a time bandwidth (the higher the better).
</p>


<h3>References</h3>


<p>Baddeley A, Turner R, Rubak E (2021).
<em>spatstat: Spatial Point Pattern Analysis, Model-Fitting, Simulation, Tests</em>.
R package version 2.1-0, <a href="https://CRAN.R-project.org/package=spatstat">https://CRAN.R-project.org/package=spatstat</a>.

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading the data
data(mtl_network)
data(bike_accidents)

# converting the Date field to a numeric field (counting days)
bike_accidents$Time &lt;- as.POSIXct(bike_accidents$Date, format = "%Y/%m/%d")
bike_accidents$Time &lt;- difftime(bike_accidents$Time, min(bike_accidents$Time), units = "days")
bike_accidents$Time &lt;- as.numeric(bike_accidents$Time)
bike_accidents &lt;- subset(bike_accidents, bike_accidents$Time&gt;=89)

# calculating the cross validation values
cv_scores &lt;- bws_tnkde_cv_likelihood_calc(
  bw_net_range = c(100,1000),
  bw_net_step = 100,
  bw_time_range = c(10,60),
  bw_time_step = 5,
  lines = mtl_network,
  events = bike_accidents,
  time_field = "Time",
  w = rep(1, nrow(bike_accidents)),
  kernel_name = "quartic",
  method = "discontinuous",
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 10,
  digits = 2,
  tol = 0.1,
  agg = 15,
  sparse=TRUE,
  grid_shape=c(1,1),
  sub_sample=1,
  verbose = FALSE,
  check = TRUE)

</code></pre>

<hr>
<h2 id='bws_tnkde_cv_likelihood_calc.mc'>Bandwidth selection by likelihood cross validation for temporal NKDE (multicore)</h2><span id='topic+bws_tnkde_cv_likelihood_calc.mc'></span>

<h3>Description</h3>

<p>Calculate for multiple network and time bandwidths the cross validation likelihood to
select an appropriate bandwidth in a data-driven approach with multicore support
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws_tnkde_cv_likelihood_calc.mc(
  bw_net_range,
  bw_net_step,
  bw_time_range,
  bw_time_step,
  lines,
  events,
  time_field,
  w,
  kernel_name,
  method,
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  zero_strat = "min_double",
  grid_shape = c(1, 1),
  sub_sample = 1,
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_bw_net_range">bw_net_range</code></td>
<td>
<p>The range for the network bandwidth to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_bw_net_step">bw_net_step</code></td>
<td>
<p>The step between each network bandwidth to calculate, given as a float</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_bw_time_range">bw_time_range</code></td>
<td>
<p>The range for the time bandwidth to consider, given as a numeric
vector of two values: c(bandwidth_min, bandwidth_max)</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_bw_time_step">bw_time_step</code></td>
<td>
<p>The step between each time bandwidth to calculate, given as a float</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_time_field">time_field</code></td>
<td>
<p>The name of the field in events indicating when the events occurred. It must be a numeric field</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_zero_strat">zero_strat</code></td>
<td>
<p>A string indicating what to do when density is 0 when calculating LOO density estimate for an isolated event.
&quot;min_double&quot; (default) replace the 0 value by the minimum double possible on the machine. &quot;remove&quot; will remove them from the final
score. The first approach penalizes more strongly the small bandwidths.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_sub_sample">sub_sample</code></td>
<td>
<p>A float between 0 and 1 indicating the percentage of quadra
to keep in the calculus. For large datasets, it may be useful to limit the
bandwidth evaluation and thus reduce calculation time.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="bws_tnkde_cv_likelihood_calc.mc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the function bws_tnkde_cv_likelihood_calc for more details. Note that the calculation is split
according to the grid_shape argument. If the grid_shape is c(1,1) then only one process can be used.
</p>


<h3>Value</h3>

<p>A matrix with the cross validation score.  Each row corresponds to a network
bandwidth and each column to a time bandwidth (the higher the better).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading the data
data(mtl_network)
data(bike_accidents)

# converting the Date field to a numeric field (counting days)
bike_accidents$Time &lt;- as.POSIXct(bike_accidents$Date, format = "%Y/%m/%d")
bike_accidents$Time &lt;- difftime(bike_accidents$Time, min(bike_accidents$Time), units = "days")
bike_accidents$Time &lt;- as.numeric(bike_accidents$Time)
bike_accidents &lt;- subset(bike_accidents, bike_accidents$Time&gt;=89)

future::plan(future::multisession(workers=1))

# calculating the cross validation values
cv_scores &lt;- bws_tnkde_cv_likelihood_calc.mc(
  bw_net_range = c(100,1000),
  bw_net_step = 100,
  bw_time_range = c(10,60),
  bw_time_step = 5,
  lines = mtl_network,
  events = bike_accidents,
  time_field = "Time",
  w = rep(1, nrow(bike_accidents)),
  kernel_name = "quartic",
  method = "discontinuous",
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 10,
  digits = 2,
  tol = 0.1,
  agg = 15,
  sparse=TRUE,
  grid_shape=c(1,1),
  sub_sample=1,
  verbose = FALSE,
  check = TRUE)

## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='calc_gamma'>Gamma parameter for Abramson’s adaptive bandwidth</h2><span id='topic+calc_gamma'></span>

<h3>Description</h3>

<p>Function to calculate the gamma parameter in Abramson’s
smoothing regimen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_gamma(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_gamma_+3A_k">k</code></td>
<td>
<p>a vector of numeric values (the estimated kernel densities)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the gamma parameter in Abramson’s smoothing regimen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='calc_isochrones'>Isochrones calculation</h2><span id='topic+calc_isochrones'></span>

<h3>Description</h3>

<p>Calculate isochrones on a network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_isochrones(
  lines,
  dists,
  start_points,
  donught = FALSE,
  mindist = 1,
  weight = NULL,
  direction = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_isochrones_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines representing the edges of the network</p>
</td></tr>
<tr><td><code id="calc_isochrones_+3A_dists">dists</code></td>
<td>
<p>A vector of the size of the desired isochrones</p>
</td></tr>
<tr><td><code id="calc_isochrones_+3A_start_points">start_points</code></td>
<td>
<p>A feature collection of points representing the starting
points if the isochrones</p>
</td></tr>
<tr><td><code id="calc_isochrones_+3A_donught">donught</code></td>
<td>
<p>A boolean indicating if the returned lines must overlap for
each distance (FALSE, default) or if the lines must be cut between each
distance step (TRUE).</p>
</td></tr>
<tr><td><code id="calc_isochrones_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance between two points. When two points are
too close, they might end up snapped at the same location on a line.
Default is 1.</p>
</td></tr>
<tr><td><code id="calc_isochrones_+3A_weight">weight</code></td>
<td>
<p>The name of the column in lines to use an edge weight. If NULL,
the geographical length is used. Note that if lines are split during the
network creation, the weight column is recalculated proportionally to the new lines
length.</p>
</td></tr>
<tr><td><code id="calc_isochrones_+3A_direction">direction</code></td>
<td>
<p>The name of the column indicating authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions (undirected). The values of the column must be &quot;FT&quot; (From - To),
&quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An isochrone is the set of reachable lines around a node in a network within
a specified distance (or time). This function perform dynamic segmentation to return the
part of the edges reached and not only the fully covered edges. Several start points and
several distances can be given. The network can also be directed. The lines returned
by the function are the most accurate representation of the isochrones. However, if
polygons are required for mapping, the vignette &quot;Calculating isochrones&quot; shows
how to create smooth polygons from the returned sets of lines.
</p>


<h3>Value</h3>

<p>A feature collection of lines representing the isochrones with the
following columns
</p>

<ul>
<li><p> point_id: the index of the point at the centre of the isochrone;
</p>
</li>
<li><p> distance: the size of the isochrone
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
# creating a simple network
wkt_lines &lt;- c(
  "LINESTRING (0.0 0.0, 5.0 0.0)",
  "LINESTRING (0.0 -5.0, 5.0 -5.0)",
  "LINESTRING (5.0 0.0, 5.0 5.0)",
  "LINESTRING (5.0 -5.0, 5.0 -10.0)",
  "LINESTRING (5.0 0.0, 5.0 -5.0)",
  "LINESTRING (5.0 0.0, 10.0 0.0)",
  "LINESTRING (5.0 -5.0, 10.0 -5.0)",
  "LINESTRING (10.0 0, 10.0 -5.0)",
  "LINESTRING (10.0 -10.0, 10.0 -5.0)",
  "LINESTRING (15.0 -5.0, 10.0 -5.0)",
  "LINESTRING (10.0 0.0, 15.0 0.0)",
  "LINESTRING (10.0 0.0, 10.0 5.0)")

linesdf &lt;- data.frame(wkt = wkt_lines,
                      id = paste("l",1:length(wkt_lines),sep=""))

lines &lt;- st_as_sf(linesdf, wkt = "wkt")

# and the definition of the starting point
start_points &lt;- data.frame(x=c(5),
                           y=c(-2.5))
start_points &lt;- st_as_sf(start_points, coords = c("x","y"))

# setting the directions

lines$direction &lt;- "Both"
lines[6,"direction"] &lt;- "TF"

isochrones &lt;- calc_isochrones(lines,dists = c(10,12),
                              donught = TRUE,
                              start_points = start_points,
                              direction = "direction")
</code></pre>

<hr>
<h2 id='check_geometries'>Geometry sanity check</h2><span id='topic+check_geometries'></span>

<h3>Description</h3>

<p>Function to check if the geometries given by the user are valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_geometries(lines, samples, events, study_area)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_geometries_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines</p>
</td></tr>
<tr><td><code id="check_geometries_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points (the samples)</p>
</td></tr>
<tr><td><code id="check_geometries_+3A_events">events</code></td>
<td>
<p>A feature collection of points (the events)</p>
</td></tr>
<tr><td><code id="check_geometries_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons (the study_area)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if all the checks are passed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='clean_events'>Clean events geometries</h2><span id='topic+clean_events'></span>

<h3>Description</h3>

<p>Function to avoid having events at the same location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_events(events, digits = 5, agg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_events_+3A_events">events</code></td>
<td>
<p>The feature collection of points to contract (must have a weight column)</p>
</td></tr>
<tr><td><code id="clean_events_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="clean_events_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the points must be aggregated within a distance.
if NULL, then the points are aggregated by rounding the coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new feature collection of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='closest_points'>Find closest points</h2><span id='topic+closest_points'></span>

<h3>Description</h3>

<p>Solve the nearest neighbour problem for two feature collections of points
This is a simple wrap-up of the dbscan::kNN function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest_points(origins, targets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest_points_+3A_origins">origins</code></td>
<td>
<p>a feature collection of points</p>
</td></tr>
<tr><td><code id="closest_points_+3A_targets">targets</code></td>
<td>
<p>a feature collection of points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for each origin point, the index of the nearest target point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtl_libraries)
data(mtl_theatres)
close_libs &lt;- closest_points(mtl_theatres, mtl_libraries)
</code></pre>

<hr>
<h2 id='continuousfunction'>The main function to calculate continuous NKDE (with ARMADILO and sparse matrix)</h2><span id='topic+continuousfunction'></span><span id='topic+continuous_nkde_cpp_arma_sparse'></span><span id='topic+continuous_nkde_cpp_arma'></span>

<h3>Description</h3>

<p>The main function to calculate continuous NKDE (with ARMADILO and sparse matrix)
</p>
<p>The main function to calculate continuous NKDE (with ARMADILO and integer matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous_nkde_cpp_arma_sparse(
  neighbour_list,
  events,
  weights,
  samples,
  bws,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div = "bw"
)

continuous_nkde_cpp_arma(
  neighbour_list,
  events,
  weights,
  samples,
  bws,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div = "bw"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuousfunction_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of the weight of each event</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_samples">samples</code></td>
<td>
<p>a DataFrame of the samples (with spatial coordinates and belonging edge)</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_bws">bws</code></td>
<td>
<p>the kernel bandwidths for each event</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_kernel_name">kernel_name</code></td>
<td>
<p>the name of the kernel to use</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_nodes">nodes</code></td>
<td>
<p>a DataFrame representing the nodes of the graph (with spatial coordinates)</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the function must print its progress</p>
</td></tr>
<tr><td><code id="continuousfunction_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of events within the radius around each sampling point), &quot;bw&quot; (the bandwidth) &quot;none&quot; (the simple sum).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a DataFrame with two columns : the kernel values (sum_k) and the number of events for each sample (n)
</p>
<p>a DataFrame with two columns : the kernel values (sum_k) and the number of events for each sample (n)
</p>

<hr>
<h2 id='continuousWorker'>The worker function to calculate continuous NKDE (with ARMADILLO and integer matrix)</h2><span id='topic+continuousWorker'></span>

<h3>Description</h3>

<p>The worker function to calculate continuous NKDE (with ARMADILLO and integer matrix)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuousWorker_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_samples_k">samples_k</code></td>
<td>
<p>a numeric vector of the actual kernel values, updates at
each recursion</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_v">v</code></td>
<td>
<p>the actual node to consider for the recursion (int)</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_bw">bw</code></td>
<td>
<p>the kernel bandwidth</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_samples_edgeid">samples_edgeid</code></td>
<td>
<p>a vector associating each sample to an edge</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_samples_x">samples_x</code></td>
<td>
<p>a vector with x coordinates of each sample</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_samples_y">samples_y</code></td>
<td>
<p>a vector with y coordinates of each sample</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_nodes_x">nodes_x</code></td>
<td>
<p>a vector with x coordinates of each node</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_nodes_y">nodes_y</code></td>
<td>
<p>a vector with y coordinates of each node</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="continuousWorker_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the kernel values calculated for each samples from
the first node given
</p>

<hr>
<h2 id='continuousWorker_sparse'>The worker function to calculate continuous NKDE (with ARMADILLO and sparse matrix)</h2><span id='topic+continuousWorker_sparse'></span>

<h3>Description</h3>

<p>The worker function to calculate continuous NKDE (with ARMADILLO and sparse matrix)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="continuousWorker_sparse_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_samples_k">samples_k</code></td>
<td>
<p>a numeric vector of the actual kernel values, updates at
each recursion</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_v">v</code></td>
<td>
<p>the actual node to consider for the recursion (int)</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_bw">bw</code></td>
<td>
<p>the kernel bandwidth</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_samples_edgeid">samples_edgeid</code></td>
<td>
<p>a vector associating each sample to an edge</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_samples_x">samples_x</code></td>
<td>
<p>a vector with x coordinates of each sample</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_samples_y">samples_y</code></td>
<td>
<p>a vector with y coordinates of each sample</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_nodes_x">nodes_x</code></td>
<td>
<p>a vector with x coordinates of each node</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_nodes_y">nodes_y</code></td>
<td>
<p>a vector with y coordinates of each node</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="continuousWorker_sparse_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the kernel values calculated for each samples from
the first node given
</p>

<hr>
<h2 id='correction_factor'>Border correction for NKDE</h2><span id='topic+correction_factor'></span>

<h3>Description</h3>

<p>Function to calculate the border correction factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correction_factor(
  study_area,
  events,
  lines,
  method,
  bws,
  kernel_name,
  tol,
  digits,
  max_depth,
  sparse
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correction_factor_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons or a polygon, the limit
of the study area.</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events on the
network.</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_lines">lines</code></td>
<td>
<p>The lines used to create the network</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see details for more information)</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_bws">bws</code></td>
<td>
<p>The kernel bandwidth (in meters) for each event</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_tol">tol</code></td>
<td>
<p>When adding the events and the sampling points to the network, the
minimum distance between these points and the lines extremities. When
points are closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep in the spatial coordinates. It
ensures that topology is good when building the network. Default is 3</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_max_depth">max_depth</code></td>
<td>
<p>When using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has a lot of
small edges (area with a lot of intersections and a lot of events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 8 should yield good
estimates. A larger value can be used without problem for the discontinuous
method. For the continuous method, a larger value will strongly impact
calculation speed.</p>
</td></tr>
<tr><td><code id="correction_factor_+3A_sparse">sparse</code></td>
<td>
<p>A boolean indicating if sparse or regular matrix should be
used by the Rcpp functions. Regular matrices are faster, but require more
memory and could lead to error, in particular with multiprocessing. Sparse
matrices are slower, but require much less memory.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the correction factor values for each event
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='correction_factor_time'>Time extent correction for NKDE</h2><span id='topic+correction_factor_time'></span>

<h3>Description</h3>

<p>Function to calculate the time extent correction factor in tnkde.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correction_factor_time(events_time, samples_time, bws_time, kernel_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correction_factor_time_+3A_events_time">events_time</code></td>
<td>
<p>A numeric vector representing when the events occurred</p>
</td></tr>
<tr><td><code id="correction_factor_time_+3A_samples_time">samples_time</code></td>
<td>
<p>A numeric vector representing when the densities will
be sampled</p>
</td></tr>
<tr><td><code id="correction_factor_time_+3A_bws_time">bws_time</code></td>
<td>
<p>A numeric vector with the temporal bandwidths</p>
</td></tr>
<tr><td><code id="correction_factor_time_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the correction factor values for each event
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='corrfactor_continuous'>A function to calculate the necessary information to apply the
Diggle correction factor with a continuous method</h2><span id='topic+corrfactor_continuous'></span>

<h3>Description</h3>

<p>A function to calculate the necessary information to apply the
Diggle correction factor with a continuous method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrfactor_continuous(neighbour_list, events, line_list, bws, max_depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrfactor_continuous_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_+3A_bws">bws</code></td>
<td>
<p>the kernel bandwidth for each event</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of dataframes, used to calculate the Diggel correction factor
</p>

<hr>
<h2 id='corrfactor_continuous_sparse'>A function to calculate the necessary information to apply the
Diggle correction factor with a continuous method (sparse)</h2><span id='topic+corrfactor_continuous_sparse'></span>

<h3>Description</h3>

<p>A function to calculate the necessary information to apply the
Diggle correction factor with a continuous method (sparse)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrfactor_continuous_sparse(neighbour_list, events, line_list, bws, max_depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrfactor_continuous_sparse_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_sparse_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_sparse_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_sparse_+3A_bws">bws</code></td>
<td>
<p>the kernel bandwidth for each event</p>
</td></tr>
<tr><td><code id="corrfactor_continuous_sparse_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of dataframes, used to calculate the Diggel correction factor
</p>

<hr>
<h2 id='corrfactor_discontinuous'>A function to calculate the necessary informations to apply the
Diggle correction factor with a discontinuous method</h2><span id='topic+corrfactor_discontinuous'></span>

<h3>Description</h3>

<p>A function to calculate the necessary informations to apply the
Diggle correction factor with a discontinuous method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrfactor_discontinuous(neighbour_list, events, line_list, bws, max_depth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrfactor_discontinuous_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_+3A_bws">bws</code></td>
<td>
<p>the kernel bandwidth for each event</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of dataframes, used to calculate the Diggel correction factor
</p>

<hr>
<h2 id='corrfactor_discontinuous_sparse'>A function to calculate the necessary information to apply the
Diggle correction factor with a discontinuous method (sparse)</h2><span id='topic+corrfactor_discontinuous_sparse'></span>

<h3>Description</h3>

<p>A function to calculate the necessary information to apply the
Diggle correction factor with a discontinuous method (sparse)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrfactor_discontinuous_sparse(
  neighbour_list,
  events,
  line_list,
  bws,
  max_depth
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrfactor_discontinuous_sparse_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_sparse_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_sparse_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_sparse_+3A_bws">bws</code></td>
<td>
<p>the kernel bandwidth for each event</p>
</td></tr>
<tr><td><code id="corrfactor_discontinuous_sparse_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of dataframes, used to calculate the Diggel correction factor
</p>

<hr>
<h2 id='corrfactor_simple'>Simple NKDE border correction</h2><span id='topic+corrfactor_simple'></span>

<h3>Description</h3>

<p>A function to calculate the Diggle correction factor with the
simple NKDE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrfactor_simple(graph, events, edges, bws)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corrfactor_simple_+3A_graph">graph</code></td>
<td>
<p>The graph (igraph) used to calculate distances between nodes</p>
</td></tr>
<tr><td><code id="corrfactor_simple_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events</p>
</td></tr>
<tr><td><code id="corrfactor_simple_+3A_edges">edges</code></td>
<td>
<p>A feature collection of lines representing the edges of the graph</p>
</td></tr>
<tr><td><code id="corrfactor_simple_+3A_bws">bws</code></td>
<td>
<p>A vector of the bandwidths for each event</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the correction factor values
</p>

<hr>
<h2 id='cosine_kernel'>Cosine kernel</h2><span id='topic+cosine_kernel'></span>

<h3>Description</h3>

<p>Function implementing the cosine kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosine_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosine_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="cosine_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='cosine_kernel_cpp'>c++ cosine kernel</h2><span id='topic+cosine_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ cosine kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosine_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosine_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="cosine_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='cosine_kernelos'>c++ cosine kernel for one distance</h2><span id='topic+cosine_kernelos'></span>

<h3>Description</h3>

<p>c++ cosine kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosine_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosine_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="cosine_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='cross_gfunc_cpp'>c++ cross g function</h2><span id='topic+cross_gfunc_cpp'></span>

<h3>Description</h3>

<p>c++ cross g function (INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_gfunc_cpp(dist_mat, start, end, step, width, Lt, na, nb, wa, wb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_gfunc_cpp_+3A_dist_mat">dist_mat</code></td>
<td>
<p>A matrix with the distances between points</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_start">start</code></td>
<td>
<p>A float, the start value for evaluating the g-function</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_end">end</code></td>
<td>
<p>A float, the last value for evaluating the g-function</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_step">step</code></td>
<td>
<p>A float, the jump between two evaluations of the k-function</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_width">width</code></td>
<td>
<p>The width of each donut</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_lt">Lt</code></td>
<td>
<p>The total length of the network</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_na">na</code></td>
<td>
<p>The number of points in set A</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_nb">nb</code></td>
<td>
<p>The number of points in set B</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_wa">wa</code></td>
<td>
<p>The weight of the points in set A (coincident points)</p>
</td></tr>
<tr><td><code id="cross_gfunc_cpp_+3A_wb">wb</code></td>
<td>
<p>The weight of the points in set B (coincident points)</p>
</td></tr>
</table>

<hr>
<h2 id='cross_kfunc_cpp'>c++ cross k function</h2><span id='topic+cross_kfunc_cpp'></span>

<h3>Description</h3>

<p>c++ cross k function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_kfunc_cpp(dist_mat, start, end, step, Lt, na, nb, wa, wb)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_kfunc_cpp_+3A_dist_mat">dist_mat</code></td>
<td>
<p>A square matrix with the distances between points</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_start">start</code></td>
<td>
<p>A float, the start value for evaluating the k-function</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_end">end</code></td>
<td>
<p>A float, the last value for evaluating the k-function</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_step">step</code></td>
<td>
<p>A float, the jump between two evaluations of the k-function</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_lt">Lt</code></td>
<td>
<p>The total length of the network</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_na">na</code></td>
<td>
<p>The number of points in set A</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_nb">nb</code></td>
<td>
<p>The number of points in set B</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_wa">wa</code></td>
<td>
<p>The weight of the points in set A (coincident points)</p>
</td></tr>
<tr><td><code id="cross_kfunc_cpp_+3A_wb">wb</code></td>
<td>
<p>The weight of the points in set B (coincident points)</p>
</td></tr>
</table>

<hr>
<h2 id='cross_kfunctions'>Network cross k and g functions (maturing)</h2><span id='topic+cross_kfunctions'></span>

<h3>Description</h3>

<p>Calculate the cross k and g functions for a set of points on a
network. (maturing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_kfunctions(
  lines,
  pointsA,
  pointsB,
  start,
  end,
  step,
  width,
  nsim,
  conf_int = 0.05,
  digits = 2,
  tol = 0.1,
  resolution = NULL,
  agg = NULL,
  verbose = TRUE,
  return_sims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_kfunctions_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_pointsa">pointsA</code></td>
<td>
<p>A feature collection of points representing the points to which the
distances are calculated.</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_pointsb">pointsB</code></td>
<td>
<p>A feature collection of points representing the points from which
the distances are calculated.</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_start">start</code></td>
<td>
<p>A double, the lowest distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_end">end</code></td>
<td>
<p>A double, the highest distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_step">step</code></td>
<td>
<p>A double, the step between two evaluations of the k and g
function. start, end and step are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_width">width</code></td>
<td>
<p>The width of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of Monte Carlo simulations
to perform for inference</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_conf_int">conf_int</code></td>
<td>
<p>A double indicating the width confidence interval (default =
0.05) calculated on the Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to retain from the
spatial coordinates</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_tol">tol</code></td>
<td>
<p>When adding the points to the network, specify the minimum
distance between these points and the lines' extremities. When points are
closer, they are added at the extremity of the lines</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_resolution">resolution</code></td>
<td>
<p>When simulating random points on the network, selecting a
resolution will reduce greatly the calculation time. When resolution is null
the random points can occur everywhere on the graph. If a value is specified,
the edges are split according to this value and the random points can only be
vertices on the new network</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a distance.
If NULL, the events are aggregated only by rounding the coordinates</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if progress messages should be displayed</p>
</td></tr>
<tr><td><code id="cross_kfunctions_+3A_return_sims">return_sims</code></td>
<td>
<p>a boolean indicating if the simulated k and g values must also
be returned as matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross k-function is a method to characterize the dispersion of a
set of points (A) around a second set of points (B). For each point in B,
the numbers of other points in A in subsequent radii are calculated. This
empirical cross k-function can be more or less clustered than a cross
k-function obtained if the points in A were randomly located around points
in B. In a network, the network distance is used instead of the Euclidean
distance. This function uses Monte Carlo simulations to assess if the
points are clustered or dispersed and gives the results as a line plot. If
the line of the observed cross k-function is higher than the shaded area
representing the values of the simulations, then the points in A are more
clustered around points in B than what we can expect from randomness and
vice-versa. The function also calculates the cross g-function, a modified
version of the cross k-function using rings instead of disks. The width of
the ring must be chosen. The main interest is to avoid the cumulative
effect of the classical k-function. Note that the cross k-function of
points A around B is not necessarily the same as the cross k-function of
points B around A. This function is maturing, it works as expected (unit
tests) but will probably be modified in the future releases (gain speed,
advanced features, etc.).
</p>


<h3>Value</h3>

<p>A list with the following values : <br /> </p>
 <ul>
<li><p>plotk A
ggplot2 object representing the values of the cross k-function
</p>
</li>
<li><p>plotg A ggplot2 object representing the values of the cross
g-function </p>
</li>
<li><p>values A DataFrame with the values used to build the
plots </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(main_network_mtl)
data(mtl_libraries)
data(mtl_theatres)
result &lt;- cross_kfunctions(main_network_mtl, mtl_theatres, mtl_libraries,
                           start = 0, end = 2500, step = 10, width = 250,
                           nsim = 50, conf_int = 0.05, digits = 2,
                           tol = 0.1, agg = NULL, verbose = FALSE)

</code></pre>

<hr>
<h2 id='cross_kfunctions.mc'>Network cross k and g functions (multicore, maturing)</h2><span id='topic+cross_kfunctions.mc'></span>

<h3>Description</h3>

<p>Calculate the cross k and g functions for a set of points on a
network with multicore support. (maturing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_kfunctions.mc(
  lines,
  pointsA,
  pointsB,
  start,
  end,
  step,
  width,
  nsim,
  conf_int = 0.05,
  digits = 2,
  tol = 0.1,
  resolution = NULL,
  agg = NULL,
  verbose = TRUE,
  return_sims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_kfunctions.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_pointsa">pointsA</code></td>
<td>
<p>A feature collection of points representing the points to which the
distances are calculated.</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_pointsb">pointsB</code></td>
<td>
<p>A feature collection of points representing the points from which
the distances are calculated.</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_start">start</code></td>
<td>
<p>A double, the lowest distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_end">end</code></td>
<td>
<p>A double, the highest distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_step">step</code></td>
<td>
<p>A double, the step between two evaluations of the k and g
function. start, end and step are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_width">width</code></td>
<td>
<p>The width of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of Monte Carlo simulations
to perform for inference</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_conf_int">conf_int</code></td>
<td>
<p>A double indicating the width confidence interval (default =
0.05) calculated on the Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to retain from the
spatial coordinates</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_tol">tol</code></td>
<td>
<p>When adding the points to the network, specify the minimum
distance between these points and the lines' extremities. When points are
closer, they are added at the extremity of the lines</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_resolution">resolution</code></td>
<td>
<p>When simulating random points on the network, selecting a
resolution will reduce greatly the calculation time. When resolution is null
the random points can occur everywhere on the graph. If a value is specified,
the edges are split according to this value and the random points can only be
vertices on the new network</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a distance.
If NULL, the events are aggregated only by rounding the coordinates</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if progress messages should be displayed</p>
</td></tr>
<tr><td><code id="cross_kfunctions.mc_+3A_return_sims">return_sims</code></td>
<td>
<p>a boolean indicating if the simulated k and g values must also
be returned as matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following values : <br /> </p>
 <ul>
<li><p>plotk A
ggplot2 object representing the values of the cross k-function
</p>
</li>
<li><p>plotg A ggplot2 object representing the values of the cross
g-function </p>
</li>
<li><p>values A DataFrame with the values used to build the
plots </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(main_network_mtl)
data(mtl_libraries)
data(mtl_theatres)
future::plan(future::multisession(workers=1))
result &lt;- cross_kfunctions.mc(main_network_mtl, mtl_libraries, mtl_theatres,
                           start = 0, end = 2500, step = 10, width = 250,
                           nsim = 50, conf_int = 0.05, digits = 2,
                           tol = 0.1, agg = NULL, verbose = TRUE)
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='cut_lines_at_distance'>Cut lines at a specified distance</h2><span id='topic+cut_lines_at_distance'></span>

<h3>Description</h3>

<p>Cut lines in a feature collection of linestrings at a specified distance from the
begining of the lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_lines_at_distance(lines, dists)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cut_lines_at_distance_+3A_lines">lines</code></td>
<td>
<p>The feature collection of linestrings to cut</p>
</td></tr>
<tr><td><code id="cut_lines_at_distance_+3A_dists">dists</code></td>
<td>
<p>A vector of distances, if only one value is given,
each line will be cut at that distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is an interal function, no example provided
</code></pre>

<hr>
<h2 id='direct_lines'>Make a network directed</h2><span id='topic+direct_lines'></span>

<h3>Description</h3>

<p>Function to create complementary lines for a directed network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct_lines(lines, direction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct_lines_+3A_lines">lines</code></td>
<td>
<p>The original feature collection of linestrings</p>
</td></tr>
<tr><td><code id="direct_lines_+3A_direction">direction</code></td>
<td>
<p>A vector of integers. 0 indicates a bidirectional line and 1
an unidirectional line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings with some lines duplicated according to
direction
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='discontinuousfunction'>The main function to calculate discontinuous NKDE (ARMA and sparse matrix)</h2><span id='topic+discontinuousfunction'></span><span id='topic+discontinuous_nkde_cpp_arma_sparse'></span><span id='topic+discontinuous_nkde_cpp_arma'></span>

<h3>Description</h3>

<p>The main function to calculate discontinuous NKDE (ARMA and sparse matrix)
</p>
<p>The main function to calculate discontinuous NKDE (ARMA and Integer matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discontinuous_nkde_cpp_arma_sparse(
  neighbour_list,
  events,
  weights,
  samples,
  bws,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div = "bw"
)

discontinuous_nkde_cpp_arma(
  neighbour_list,
  events,
  weights,
  samples,
  bws,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div = "bw"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discontinuousfunction_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of the weight of each event</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_samples">samples</code></td>
<td>
<p>a DataFrame of the samples (with spatial coordinates and belonging edge)</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_bws">bws</code></td>
<td>
<p>the kernel bandwidth for each event</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_kernel_name">kernel_name</code></td>
<td>
<p>the name of the kernel function to use</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_nodes">nodes</code></td>
<td>
<p>a DataFrame representing the nodes of the graph (with spatial coordinates)</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the function must print its progress</p>
</td></tr>
<tr><td><code id="discontinuousfunction_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of events within the radius around each sampling point), &quot;bw&quot; (the bandwidth) &quot;none&quot; (the simple sum).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a DataFrame with two columns : the kernel values (sum_k) and the number of events for each sample (n)
</p>
<p>a DataFrame with two columns : the kernel values (sum_k) and the number of events for each sample (n)
</p>

<hr>
<h2 id='discontinuousWorker_int'>The worker function to calculate discontinuous NKDE (with ARMADILLO and Integer matrix)</h2><span id='topic+discontinuousWorker_int'></span>

<h3>Description</h3>

<p>The worker function to calculate discontinuous NKDE (with ARMADILLO and Integer matrix)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="discontinuousWorker_int_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_v">v</code></td>
<td>
<p>the actual node to consider for the recursion (int)</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_bw">bw</code></td>
<td>
<p>the kernel bandiwdth</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_samples_edgeid">samples_edgeid</code></td>
<td>
<p>a vector associating each sample to an edge</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_samples_x">samples_x</code></td>
<td>
<p>a vector with x coordinates of each sample</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_samples_ya">samples_ya</code></td>
<td>
<p>vector with y coordinates of each sample</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_nodes_x">nodes_x</code></td>
<td>
<p>a vector with x coordinates of each node</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_nodes_y">nodes_y</code></td>
<td>
<p>a vector with y coordinates of each node</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="discontinuousWorker_int_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the kernel values calculated for each samples from
the first node given
</p>

<hr>
<h2 id='discontinuousWorker_sparse'>The worker function to calculate discontinuous NKDE (with ARMADILLO and sparse matrix)</h2><span id='topic+discontinuousWorker_sparse'></span>

<h3>Description</h3>

<p>The worker function to calculate discontinuous NKDE (with ARMADILLO and sparse matrix)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="discontinuousWorker_sparse_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_v">v</code></td>
<td>
<p>the actual node to consider for the recursion (int)</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_bw">bw</code></td>
<td>
<p>the kernel bandiwdth</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_samples_edgeid">samples_edgeid</code></td>
<td>
<p>a vector associating each sample to an edge</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_samples_x">samples_x</code></td>
<td>
<p>a vector with x coordinates of each sample</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_samples_ya">samples_ya</code></td>
<td>
<p>vector with y coordinates of each sample</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_nodes_x">nodes_x</code></td>
<td>
<p>a vector with x coordinates of each node</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_nodes_y">nodes_y</code></td>
<td>
<p>a vector with y coordinates of each node</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="discontinuousWorker_sparse_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the kernel values calculated for each samples from
the first node given
</p>

<hr>
<h2 id='dist_mat_dupl'>Distance matrix with dupicated</h2><span id='topic+dist_mat_dupl'></span>

<h3>Description</h3>

<p>Function to Create a distance matrix when some vertices are duplicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_mat_dupl(graph, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_mat_dupl_+3A_graph">graph</code></td>
<td>
<p>The Graph to use</p>
</td></tr>
<tr><td><code id="dist_mat_dupl_+3A_start">start</code></td>
<td>
<p>The vertices to use as starting points</p>
</td></tr>
<tr><td><code id="dist_mat_dupl_+3A_end">end</code></td>
<td>
<p>The vertices to use as ending points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the distances between the vertices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='epanechnikov_kernel'>Epanechnikov kernel</h2><span id='topic+epanechnikov_kernel'></span>

<h3>Description</h3>

<p>Function implementing the epanechnikov kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epanechnikov_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epanechnikov_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="epanechnikov_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='epanechnikov_kernel_cpp'>c++ epanechnikov kernel</h2><span id='topic+epanechnikov_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ epanechnikov kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epanechnikov_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epanechnikov_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="epanechnikov_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='epanechnikov_kernelos'>c++ epanechnikov kernel for one distance</h2><span id='topic+epanechnikov_kernelos'></span>

<h3>Description</h3>

<p>c++ epanechnikov kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epanechnikov_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="epanechnikov_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="epanechnikov_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='esc_kernel_loo_nkde'>The worker function to calculate continuous TNKDE likelihood cv</h2><span id='topic+esc_kernel_loo_nkde'></span>

<h3>Description</h3>

<p>The worker function to calculate continuous TNKDE likelihood cv (INTERNAL)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="esc_kernel_loo_nkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_v">v</code></td>
<td>
<p>the actual node to consider (int)</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_nkde_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cube with the impact of the event v on each other events for
each pair of bandwidths (cube(bws_net, bws_time, events))
</p>

<hr>
<h2 id='esc_kernel_loo_tnkde'>The worker function to calculate continuous TNKDE likelihood cv</h2><span id='topic+esc_kernel_loo_tnkde'></span>

<h3>Description</h3>

<p>The worker function to calculate continuous TNKDE likelihood cv (INTERNAL)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_time_events">time_events</code></td>
<td>
<p>a NumericVector indicating the timestamp of each event</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_v">v</code></td>
<td>
<p>the actual node to consider (int)</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_v_time">v_time</code></td>
<td>
<p>the time of v (double)</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_bws_time">bws_time</code></td>
<td>
<p>an arma::vec with the time bandwidths to consider</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="esc_kernel_loo_tnkde_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cube with the impact of the event v on each other event for
each pair of bandwidths (cube(bws_net, bws_time, events))
</p>

<hr>
<h2 id='esd_kernel_loo_nkde'>The worker function to calculate discontinuous TNKDE likelihood cv</h2><span id='topic+esd_kernel_loo_nkde'></span>

<h3>Description</h3>

<p>The worker function to calculate discontinuous TNKDE likelihood cv (INTERNAL)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="esd_kernel_loo_nkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_v">v</code></td>
<td>
<p>the actual node to consider (int)</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_nkde_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cube with the impact of the event v on each other events for
each pair of bandwidths (cube(bws_net, bws_time, events))
</p>

<hr>
<h2 id='esd_kernel_loo_tnkde'>The worker function to calculate discontinuous TNKDE likelihood cv</h2><span id='topic+esd_kernel_loo_tnkde'></span>

<h3>Description</h3>

<p>The worker function to calculate discontinuous TNKDE likelihood cv (INTERNAL)
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_time_events">time_events</code></td>
<td>
<p>a NumericVector indicating the timestamp of each event</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_v">v</code></td>
<td>
<p>the actual node to consider (int)</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_v_time">v_time</code></td>
<td>
<p>the time of v (double)</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_bws_time">bws_time</code></td>
<td>
<p>an arma::vec with the time bandwidths to consider</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="esd_kernel_loo_tnkde_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cube with the impact of the event v on each other event for
each pair of bandwidths (cube(bws_net, bws_time, events))
</p>

<hr>
<h2 id='ess_kernel'>Worker for simple NKDE algorithm</h2><span id='topic+ess_kernel'></span>

<h3>Description</h3>

<p>The worker function to perform the simple nkde.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ess_kernel(
  graph,
  y,
  bw,
  kernel_func,
  samples,
  nodes,
  edges,
  sample_tree,
  edges_tree
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_kernel_+3A_graph">graph</code></td>
<td>
<p>a graph object from igraph representing the network</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_y">y</code></td>
<td>
<p>the index of the actual event</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_bw">bw</code></td>
<td>
<p>a float indicating the kernel bandwidth (in meters)</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a function obtained with the function select_kernel</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_samples">samples</code></td>
<td>
<p>a a feature collection of points representing the sampling points. The
samples must be snapped on the network. A column edge_id must indicate for
each sample on which edge it is snapped.</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_nodes">nodes</code></td>
<td>
<p>a a feature collection of points representing the nodes of the network</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_edges">edges</code></td>
<td>
<p>a a feature collection of linestrings representing the edges of the network</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_sample_tree">sample_tree</code></td>
<td>
<p>a quadtree object, the spatial index of the samples</p>
</td></tr>
<tr><td><code id="ess_kernel_+3A_edges_tree">edges_tree</code></td>
<td>
<p>a quadtree object, the spatial index of the edges</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='ess_kernel_loo_nkde'>The worker function to calculate simple NKDE likelihood cv</h2><span id='topic+ess_kernel_loo_nkde'></span>

<h3>Description</h3>

<p>The worker function to calculate simple NKDE likelihood cv
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_kernel_loo_nkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_v">v</code></td>
<td>
<p>the actual node to consider (int)</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_nkde_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the impact of the event v on each other events for
each pair of bandwidths (mat(event, bws_net))
</p>

<hr>
<h2 id='ess_kernel_loo_tnkde'>The worker function to calculate simple TNKDE likelihood cv</h2><span id='topic+ess_kernel_loo_tnkde'></span>

<h3>Description</h3>

<p>The worker function to calculate simple TNKDE likelihood cv
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a cpp pointer function (selected with the kernel name)</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_edge_mat">edge_mat</code></td>
<td>
<p>matrix, to find the id of each edge given two neighbours.</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_time_events">time_events</code></td>
<td>
<p>a NumericVector indicating the timestamp of each event</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_v">v</code></td>
<td>
<p>the actual node to consider (int)</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_v_time">v_time</code></td>
<td>
<p>the time of v (double)</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_bws_time">bws_time</code></td>
<td>
<p>an arma::vec with the time bandwidths to consider</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_line_weights">line_weights</code></td>
<td>
<p>a vector with the length of the edges</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_depth">depth</code></td>
<td>
<p>the actual recursion depth</p>
</td></tr>
<tr><td><code id="ess_kernel_loo_tnkde_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a cube with the impact of the event v on each other event for
each pair of bandwidths (cube(bws_net, bws_time, events))
</p>

<hr>
<h2 id='g_nt_func_cpp'>c++ g space-time function</h2><span id='topic+g_nt_func_cpp'></span>

<h3>Description</h3>

<p>c++ g space-time function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>g_nt_func_cpp(
  dist_mat_net,
  dist_mat_time,
  start_net,
  end_net,
  step_net,
  width_net,
  start_time,
  end_time,
  step_time,
  width_time,
  Lt,
  Tt,
  n,
  w
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="g_nt_func_cpp_+3A_dist_mat_net">dist_mat_net</code></td>
<td>
<p>A square matrix with the distances between points on the network</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_dist_mat_time">dist_mat_time</code></td>
<td>
<p>A square matrix with the distances between points in time</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_start_net">start_net</code></td>
<td>
<p>A float, the start value for evaluating the g-function on the network</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_end_net">end_net</code></td>
<td>
<p>A float, the last value for evaluating the g-function on the network</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_step_net">step_net</code></td>
<td>
<p>A float, the jump between two evaluations of the g-function on the network</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_width_net">width_net</code></td>
<td>
<p>The width of each donut on the network</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_start_time">start_time</code></td>
<td>
<p>A float, the start value for evaluating the g-function in time</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_end_time">end_time</code></td>
<td>
<p>A float, the last value for evaluating the g-function in time</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_step_time">step_time</code></td>
<td>
<p>A float, the jump between two evaluations of the g-function in time</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_width_time">width_time</code></td>
<td>
<p>The width of each donut in time</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_lt">Lt</code></td>
<td>
<p>The total length of the network</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_n">n</code></td>
<td>
<p>The number of points</p>
</td></tr>
<tr><td><code id="g_nt_func_cpp_+3A_w">w</code></td>
<td>
<p>The weight of the points (coincident points)</p>
</td></tr>
</table>

<hr>
<h2 id='gaussian_kernel'>Gaussian kernel</h2><span id='topic+gaussian_kernel'></span>

<h3>Description</h3>

<p>Function implementing the gaussian kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="gaussian_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='gaussian_kernel_cpp'>c++ gaussian kernel</h2><span id='topic+gaussian_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ gaussian kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="gaussian_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='gaussian_kernel_scaled'>Scaled gaussian kernel</h2><span id='topic+gaussian_kernel_scaled'></span>

<h3>Description</h3>

<p>Function implementing the scaled gaussian kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernel_scaled(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_kernel_scaled_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="gaussian_kernel_scaled_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='gaussian_kernel_scaled_cpp'>c++ scale gaussian kernel</h2><span id='topic+gaussian_kernel_scaled_cpp'></span>

<h3>Description</h3>

<p>c++ scale gaussian kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernel_scaled_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_kernel_scaled_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="gaussian_kernel_scaled_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='gaussian_kernel_scaledos'>c++ scaled gaussian kernel for one distance</h2><span id='topic+gaussian_kernel_scaledos'></span>

<h3>Description</h3>

<p>c++ scaled gaussian kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernel_scaledos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_kernel_scaledos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="gaussian_kernel_scaledos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='gaussian_kernelos'>c++ gaussian kernel for one distance</h2><span id='topic+gaussian_kernelos'></span>

<h3>Description</h3>

<p>c++ gaussian kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussian_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussian_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="gaussian_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='gfunc_cpp'>c++ g function</h2><span id='topic+gfunc_cpp'></span>

<h3>Description</h3>

<p>c++ g function (INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfunc_cpp(dist_mat, start, end, step, width, Lt, n, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfunc_cpp_+3A_dist_mat">dist_mat</code></td>
<td>
<p>A square matrix with the distances between points</p>
</td></tr>
<tr><td><code id="gfunc_cpp_+3A_start">start</code></td>
<td>
<p>A float, the start value for evaluating the g-function</p>
</td></tr>
<tr><td><code id="gfunc_cpp_+3A_end">end</code></td>
<td>
<p>A float, the last value for evaluating the g-function</p>
</td></tr>
<tr><td><code id="gfunc_cpp_+3A_step">step</code></td>
<td>
<p>A float, the jump between two evaluations of the k-function</p>
</td></tr>
<tr><td><code id="gfunc_cpp_+3A_width">width</code></td>
<td>
<p>The width of each donut</p>
</td></tr>
<tr><td><code id="gfunc_cpp_+3A_lt">Lt</code></td>
<td>
<p>The total length of the network</p>
</td></tr>
<tr><td><code id="gfunc_cpp_+3A_n">n</code></td>
<td>
<p>The number of points</p>
</td></tr>
<tr><td><code id="gfunc_cpp_+3A_w">w</code></td>
<td>
<p>The weight of the points (coincident points)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of the g function evaluated at the required distances
</p>

<hr>
<h2 id='gm_mean'>Geometric mean</h2><span id='topic+gm_mean'></span>

<h3>Description</h3>

<p>Function to calculate the geometric mean.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm_mean(x, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gm_mean_+3A_x">x</code></td>
<td>
<p>A vector of numeric values</p>
</td></tr>
<tr><td><code id="gm_mean_+3A_na.rm">na.rm</code></td>
<td>
<p>A boolean indicating if we filter the NA values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The geometric mean of x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='graph_checking'>Topological error</h2><span id='topic+graph_checking'></span>

<h3>Description</h3>

<p>A utility function to find topological errors in a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_checking(lines, digits, max_search = 5, tol = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_checking_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="graph_checking_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to retain for
coordinates</p>
</td></tr>
<tr><td><code id="graph_checking_+3A_max_search">max_search</code></td>
<td>
<p>The maximum number of nearest neighbour to search to find
close_nodes</p>
</td></tr>
<tr><td><code id="graph_checking_+3A_tol">tol</code></td>
<td>
<p>The minimum distance expected between two nodes. If two nodes are
closer, they are returned in the result of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to check for three common problems in
networks: disconnected components, dangle nodes and close nodes. When a
network has disconnected components, this means that several unconnected
graphs are composing the overall network. This can be caused by topological
errors in the dataset. Dangle nodes are nodes connected to only one other
node. This type of node can be normal at the border of a network, but can
also be caused by topological errors. Close nodes are nodes that are not
coincident, but so close that they probably should be coincident.
</p>


<h3>Value</h3>

<p>A list with three elements. The first is a feature collection of points
indicating for each node of the network to which component it belongs. The
second is a feature collection of points with nodes that are too close one of
each other. The third is a feature collection of points with the dangle nodes of
the network.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_netowrk)
topo_errors &lt;- graph_checking(mtl_network, 2)

</code></pre>

<hr>
<h2 id='heal_edges'>Heal edges</h2><span id='topic+heal_edges'></span>

<h3>Description</h3>

<p>Merge Lines if they form a longer linestring without external intersections (experimental)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heal_edges(lines, digits = 3, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heal_edges_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings</p>
</td></tr>
<tr><td><code id="heal_edges_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to keep in coordinates</p>
</td></tr>
<tr><td><code id="heal_edges_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating if a progress bar should be displayed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings with the eventually merged geometries. Note
that if lines are merged, only the attributes of the first line are preserved
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='is_projected'>Projection test</h2><span id='topic+is_projected'></span>

<h3>Description</h3>

<p>Check if a feature collection is in a projected CRS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_projected(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_projected_+3A_obj">obj</code></td>
<td>
<p>A feature collection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='k_nt_func_cpp'>c++ k space-time function</h2><span id='topic+k_nt_func_cpp'></span>

<h3>Description</h3>

<p>c++ k space-time function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_nt_func_cpp(
  dist_mat_net,
  dist_mat_time,
  start_net,
  end_net,
  step_net,
  start_time,
  end_time,
  step_time,
  Lt,
  Tt,
  n,
  w
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k_nt_func_cpp_+3A_dist_mat_net">dist_mat_net</code></td>
<td>
<p>A square matrix with the distances between points (network)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_dist_mat_time">dist_mat_time</code></td>
<td>
<p>A square matrix with the distances between points (time)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_start_net">start_net</code></td>
<td>
<p>A float, the start value for evaluating the k-function (network)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_end_net">end_net</code></td>
<td>
<p>A float, the last value for evaluating the k-function (network)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_step_net">step_net</code></td>
<td>
<p>A float, the jump between two evaluations of the k-function (network)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_start_time">start_time</code></td>
<td>
<p>A float, the start value for evaluating the k-function (time)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_end_time">end_time</code></td>
<td>
<p>A float, the last value for evaluating the k-function (time)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_step_time">step_time</code></td>
<td>
<p>A float, the jump between two evaluations of the k-function (time)</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_lt">Lt</code></td>
<td>
<p>The total length of the network</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_tt">Tt</code></td>
<td>
<p>The total duration of study area</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_n">n</code></td>
<td>
<p>The number of points</p>
</td></tr>
<tr><td><code id="k_nt_func_cpp_+3A_w">w</code></td>
<td>
<p>The weight of the points (coincident points)</p>
</td></tr>
</table>

<hr>
<h2 id='k_nt_functions'>Network k and g functions for spatio-temporal data (experimental, NOT READY FOR USE)</h2><span id='topic+k_nt_functions'></span>

<h3>Description</h3>

<p>Calculate the k and g functions for a set of points on a
network and in time (experimental, NOT READY FOR USE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_nt_functions(
  lines,
  points,
  points_time,
  start_net,
  end_net,
  step_net,
  width_net,
  start_time,
  end_time,
  step_time,
  width_time,
  nsim,
  conf_int = 0.05,
  digits = 2,
  tol = 0.1,
  resolution = NULL,
  agg = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k_nt_functions_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_points">points</code></td>
<td>
<p>A feature collection of points representing the points on the
network. These points will be snapped on their nearest line</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_points_time">points_time</code></td>
<td>
<p>A numeric vector indicating when the point occured</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_start_net">start_net</code></td>
<td>
<p>A double, the lowest network distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_end_net">end_net</code></td>
<td>
<p>A double, the highest network distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_step_net">step_net</code></td>
<td>
<p>A double, the step between two evaluations of the k and g for the network distance
function. start_net, end_net and step_net are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_width_net">width_net</code></td>
<td>
<p>The width (network distance) of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_start_time">start_time</code></td>
<td>
<p>A double, the lowest time distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_end_time">end_time</code></td>
<td>
<p>A double, the highest time distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_step_time">step_time</code></td>
<td>
<p>A double, the step between two evaluations of the k and g for the time distance
function. start_time, end_time and step_time are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_width_time">width_time</code></td>
<td>
<p>The width (time distance) of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of Monte Carlo simulations
to perform for inference</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_conf_int">conf_int</code></td>
<td>
<p>A double indicating the width confidence interval (default =
0.05) calculated on the Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to retain from the
spatial coordinates</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_tol">tol</code></td>
<td>
<p>When adding the points to the network, specify the minimum
distance between these points and the lines' extremities. When points are
closer, they are added at the extremity of the lines</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_resolution">resolution</code></td>
<td>
<p>When simulating random points on the network, selecting a
resolution will reduce greatly the calculation time. When resolution is null
the random points can occur everywhere on the graph. If a value is specified,
the edges are split according to this value and the random points can only be
vertices on the new network</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a distance.
If NULL, the events are aggregated only by rounding the coordinates</p>
</td></tr>
<tr><td><code id="k_nt_functions_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if progress messages should be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-function is a method to characterize the dispersion of a set
of points. For each point, the numbers of other points in subsequent radii
are calculated in both space and time. This empirical k-function can be more or less clustered
than a k-function obtained if the points were randomly located . In
a network, the network distance is used instead of the Euclidean distance.
This function uses Monte Carlo simulations to assess if the points are
clustered or dispersed. The function also calculates the
g-function, a modified version of the k-function using rings instead of
disks. The width of the ring must be chosen. The main interest is to avoid
the cumulative effect of the classical k-function. This function is maturing,
it works as expected (unit tests) but will probably be modified in the
future releases (gain speed, advanced features, etc.).
</p>


<h3>Value</h3>

<p>A list with the following values : <br />
</p>

<ul>
<li><p>obs_k A matrix with the observed k-values
</p>
</li>
<li><p>lower_k A matrix with the lower bounds of the simulated k-values
</p>
</li>
<li><p>upper_k A matrix with the upper bounds of the simulated k-values
</p>
</li>
<li><p>obs_g A matrix with the observed g-values
</p>
</li>
<li><p>lower_g A matrix with the lower bounds of the simulated g-values
</p>
</li>
<li><p>upper_g A matrix with the upper bounds of the simulated g-values
</p>
</li>
<li><p>distances_net A vector with the used network distances
</p>
</li>
<li><p>distances_time A vector with the used time distances
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
data(bike_accidents)

# converting the Date field to a numeric field (counting days)
bike_accidents$Time &lt;- as.POSIXct(bike_accidents$Date, format = "%Y/%m/%d")
start &lt;- as.POSIXct("2016/01/01", format = "%Y/%m/%d")
bike_accidents$Time &lt;- difftime(bike_accidents$Time, start, units = "days")
bike_accidents$Time &lt;- as.numeric(bike_accidents$Time)

values &lt;- k_nt_functions(
      lines =  mtl_network,
      points = bike_accidents,
      points_time = bike_accidents$Time,
      start_net = 0 ,
      end_net = 2000,
      step_net = 10,
      width_net = 200,
      start_time = 0,
      end_time = 360,
      step_time = 7,
      width_time = 14,
      nsim = 50,
      conf_int = 0.05,
      digits = 2,
      tol = 0.1,
      resolution = NULL,
      agg = 15,
      verbose = TRUE)

</code></pre>

<hr>
<h2 id='k_nt_functions.mc'>Network k and g functions for spatio-temporal data (multicore, experimental, NOT READY FOR USE)</h2><span id='topic+k_nt_functions.mc'></span>

<h3>Description</h3>

<p>Calculate the k and g functions for a set of points on a
network and in time (multicore, experimental, NOT READY FOR USE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>k_nt_functions.mc(
  lines,
  points,
  points_time,
  start_net,
  end_net,
  step_net,
  width_net,
  start_time,
  end_time,
  step_time,
  width_time,
  nsim,
  conf_int = 0.05,
  digits = 2,
  tol = 0.1,
  resolution = NULL,
  agg = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="k_nt_functions.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_points">points</code></td>
<td>
<p>A feature collection of points representing the points on the
network. These points will be snapped on their nearest line</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_points_time">points_time</code></td>
<td>
<p>A numeric vector indicating when the point occured</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_start_net">start_net</code></td>
<td>
<p>A double, the lowest network distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_end_net">end_net</code></td>
<td>
<p>A double, the highest network distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_step_net">step_net</code></td>
<td>
<p>A double, the step between two evaluations of the k and g for the network distance
function. start_net, end_net and step_net are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_width_net">width_net</code></td>
<td>
<p>The width (network distance) of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_start_time">start_time</code></td>
<td>
<p>A double, the lowest time distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_end_time">end_time</code></td>
<td>
<p>A double, the highest time distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_step_time">step_time</code></td>
<td>
<p>A double, the step between two evaluations of the k and g for the time distance
function. start_time, end_time and step_time are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_width_time">width_time</code></td>
<td>
<p>The width (time distance) of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of Monte Carlo simulations
to perform for inference</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_conf_int">conf_int</code></td>
<td>
<p>A double indicating the width confidence interval (default =
0.05) calculated on the Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to retain from the
spatial coordinates</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_tol">tol</code></td>
<td>
<p>When adding the points to the network, specify the minimum
distance between these points and the lines' extremities. When points are
closer, they are added at the extremity of the lines</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_resolution">resolution</code></td>
<td>
<p>When simulating random points on the network, selecting a
resolution will reduce greatly the calculation time. When resolution is null
the random points can occur everywhere on the graph. If a value is specified,
the edges are split according to this value and the random points can only be
vertices on the new network</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a distance.
If NULL, the events are aggregated only by rounding the coordinates</p>
</td></tr>
<tr><td><code id="k_nt_functions.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if progress messages should be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-function is a method to characterize the dispersion of a set
of points. For each point, the numbers of other points in subsequent radii
are calculated. This empirical k-function can be more or less clustered
than a k-function obtained if the points were randomly located in space. In
a network, the network distance is used instead of the Euclidean distance.
This function uses Monte Carlo simulations to assess if the points are
clustered or dispersed, and gives the results as a line plot. If the line
of the observed k-function is higher than the shaded area representing the
values of the simulations, then the points are more clustered than what we
can expect from randomness and vice-versa. The function also calculates the
g-function, a modified version of the k-function using rings instead of
disks. The width of the ring must be chosen. The main interest is to avoid
the cumulative effect of the classical k-function. This function is maturing,
it works as expected (unit tests) but will probably be modified in the
future releases (gain speed, advanced features, etc.).
</p>


<h3>Value</h3>

<p>A list with the following values : <br />
</p>

<ul>
<li><p>obs_k A matrix with the observed k-values
</p>
</li>
<li><p>lower_k A matrix with the lower bounds of the simulated k-values
</p>
</li>
<li><p>upper_k A matrix with the upper bounds of the simulated k-values
</p>
</li>
<li><p>obs_g A matrix with the observed g-values
</p>
</li>
<li><p>lower_g A matrix with the lower bounds of the simulated g-values
</p>
</li>
<li><p>upper_g A matrix with the upper bounds of the simulated g-values
</p>
</li>
<li><p>distances_net A vector with the used network distances
</p>
</li>
<li><p>distances_time A vector with the used time distances
</p>
</li></ul>


<hr>
<h2 id='kfunc_cpp'>c++ k function</h2><span id='topic+kfunc_cpp'></span>

<h3>Description</h3>

<p>c++ k function (INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfunc_cpp(dist_mat, start, end, step, Lt, n, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfunc_cpp_+3A_dist_mat">dist_mat</code></td>
<td>
<p>A square matrix with the distances between points</p>
</td></tr>
<tr><td><code id="kfunc_cpp_+3A_start">start</code></td>
<td>
<p>A float, the start value for evaluating the k-function</p>
</td></tr>
<tr><td><code id="kfunc_cpp_+3A_end">end</code></td>
<td>
<p>A float, the last value for evaluating the k-function</p>
</td></tr>
<tr><td><code id="kfunc_cpp_+3A_step">step</code></td>
<td>
<p>A float, the jump between two evaluations of the k-function</p>
</td></tr>
<tr><td><code id="kfunc_cpp_+3A_lt">Lt</code></td>
<td>
<p>The total length of the network</p>
</td></tr>
<tr><td><code id="kfunc_cpp_+3A_n">n</code></td>
<td>
<p>The number of points</p>
</td></tr>
<tr><td><code id="kfunc_cpp_+3A_w">w</code></td>
<td>
<p>The weight of the points (coincident points)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the values of the k function evaluated at the required distances
</p>

<hr>
<h2 id='kfunctions'>Network k and g functions (maturing)</h2><span id='topic+kfunctions'></span>

<h3>Description</h3>

<p>Calculate the k and g functions for a set of points on a
network (maturing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfunctions(
  lines,
  points,
  start,
  end,
  step,
  width,
  nsim,
  conf_int = 0.05,
  digits = 2,
  tol = 0.1,
  resolution = NULL,
  agg = NULL,
  verbose = TRUE,
  return_sims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfunctions_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_points">points</code></td>
<td>
<p>A feature collection of points representing the points on the
network. These points will be snapped on their nearest line</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_start">start</code></td>
<td>
<p>A double, the lowest distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_end">end</code></td>
<td>
<p>A double, the highest distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_step">step</code></td>
<td>
<p>A double, the step between two evaluations of the k and g
function. start, end and step are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_width">width</code></td>
<td>
<p>The width of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of Monte Carlo simulations
to perform for inference</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_conf_int">conf_int</code></td>
<td>
<p>A double indicating the width confidence interval (default =
0.05) calculated on the Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to retain from the
spatial coordinates</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_tol">tol</code></td>
<td>
<p>When adding the points to the network, specify the minimum
distance between these points and the lines' extremities. When points are
closer, they are added at the extremity of the lines</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_resolution">resolution</code></td>
<td>
<p>When simulating random points on the network, selecting a
resolution will reduce greatly the calculation time. When resolution is null
the random points can occur everywhere on the graph. If a value is specified,
the edges are split according to this value and the random points can only be
vertices on the new network</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a distance.
If NULL, the events are aggregated only by rounding the coordinates</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if progress messages should be displayed</p>
</td></tr>
<tr><td><code id="kfunctions_+3A_return_sims">return_sims</code></td>
<td>
<p>a boolean indicating if the simulated k and g values must also
be returned as matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k-function is a method to characterize the dispersion of a set
of points. For each point, the numbers of other points in subsequent radii
are calculated. This empirical k-function can be more or less clustered
than a k-function obtained if the points were randomly located in space. In
a network, the network distance is used instead of the Euclidean distance.
This function uses Monte Carlo simulations to assess if the points are
clustered or dispersed, and gives the results as a line plot. If the line
of the observed k-function is higher than the shaded area representing the
values of the simulations, then the points are more clustered than what we
can expect from randomness and vice-versa. The function also calculates the
g-function, a modified version of the k-function using rings instead of
disks. The width of the ring must be chosen. The main interest is to avoid
the cumulative effect of the classical k-function. This function is maturing,
it works as expected (unit tests) but will probably be modified in the
future releases (gain speed, advanced features, etc.).
</p>


<h3>Value</h3>

<p>A list with the following values : <br /> </p>
 <ul>
<li><p>plotk A
ggplot2 object representing the values of the k-function </p>
</li>
<li><p>plotg A
ggplot2 object representing the values of the g-function </p>
</li>
<li><p>values A
DataFrame with the values used to build the plots </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(main_network_mtl)
data(mtl_libraries)
result &lt;- kfunctions(main_network_mtl, mtl_libraries,
     start = 0, end = 2500, step = 10,
     width = 200, nsim = 50,
     conf_int = 0.05, tol = 0.1, agg = NULL,
     verbose = FALSE)

</code></pre>

<hr>
<h2 id='kfunctions.mc'>Network k and g functions (multicore, maturing)</h2><span id='topic+kfunctions.mc'></span>

<h3>Description</h3>

<p>Calculate the k and g functions for a set of points on a network
with multicore support. For details, please see the function kfunctions.
(maturing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfunctions.mc(
  lines,
  points,
  start,
  end,
  step,
  width,
  nsim,
  conf_int = 0.05,
  digits = 2,
  tol = 0.1,
  resolution = 50,
  agg = NULL,
  verbose = TRUE,
  return_sims = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfunctions.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_points">points</code></td>
<td>
<p>A feature collection of points representing the points on the
network. These points will be snapped on their nearest line</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_start">start</code></td>
<td>
<p>A double, the lowest distance used to evaluate the k and g functions</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_end">end</code></td>
<td>
<p>A double, the highest distance used to evaluate  the k and g functions</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_step">step</code></td>
<td>
<p>A double, the step between two evaluations of the k and g
function. start, end and step are used to create a vector of distances with the function seq</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_width">width</code></td>
<td>
<p>The width of each donut for the g-function. Half of the width is applied on
both sides of the considered distance</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_nsim">nsim</code></td>
<td>
<p>An integer indicating the number of Monte Carlo simulations
to perform for inference</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_conf_int">conf_int</code></td>
<td>
<p>A double indicating the width confidence interval (default =
0.05) calculated on the Monte Carlo simulations</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to retain from the
spatial coordinates</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_tol">tol</code></td>
<td>
<p>When adding the points to the network, specify the minimum
distance between these points and the lines' extremities. When points are
closer, they are added at the extremity of the lines</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_resolution">resolution</code></td>
<td>
<p>When simulating random points on the network, selecting a
resolution will reduce greatly the calculation time. When resolution is null
the random points can occur everywhere on the graph. If a value is specified,
the edges are split according to this value and the random points can only be
vertices on the new network</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a distance.
If NULL, the events are aggregated only by rounding the coordinates</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if progress messages should be displayed</p>
</td></tr>
<tr><td><code id="kfunctions.mc_+3A_return_sims">return_sims</code></td>
<td>
<p>a boolean indicating if the simulated k and g values must also
be returned as matrices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details, please look at the function kfunctions.
</p>


<h3>Value</h3>

<p>A list with the following values : <br /> </p>
 <ul>
<li><p>plotk A
ggplot2 object representing the values of the k-function </p>
</li>
<li><p>plotg A
ggplot2 object representing the values of the g-function </p>
</li>
<li><p>values A
DataFrame with the values used to build the plots </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(main_network_mtl)
data(mtl_libraries)
future::plan(future::multisession(workers=1))
result &lt;- kfunctions.mc(main_network_mtl, mtl_libraries,
     start = 0, end = 2500, step = 10,
     width = 200, nsim = 50,
     conf_int = 0.05, tol = 0.1, agg = NULL,
     verbose = FALSE)
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='lines_center'>Centre points of lines</h2><span id='topic+lines_center'></span>

<h3>Description</h3>

<p>Generate a feature collection of points at the centre of the
lines of a feature collection of linestrings. The length of the lines is
used to determine their centres.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_center(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_center_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
centers &lt;- lines_center(mtl_network)

</code></pre>

<hr>
<h2 id='lines_coordinates_as_list'>Lines coordinates as list</h2><span id='topic+lines_coordinates_as_list'></span>

<h3>Description</h3>

<p>A function to get the coordinates of some lines as a list of matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_coordinates_as_list(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_coordinates_as_list_+3A_lines">lines</code></td>
<td>
<p>A sf object with linestring type geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='lines_direction'>Unify lines direction</h2><span id='topic+lines_direction'></span>

<h3>Description</h3>

<p>A function to deal with the directions of lines. It ensures
that only From-To situation are present by reverting To-From lines. For
the lines labelled as To-From, the order of their vertices is reverted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_direction(lines, field)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_direction_+3A_lines">lines</code></td>
<td>
<p>A sf object with linestring type geometries</p>
</td></tr>
<tr><td><code id="lines_direction_+3A_field">field</code></td>
<td>
<p>Indicate a field giving information about authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sf object with linestring type geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtl_network)
mtl_network$length &lt;- as.numeric(sf::st_length(mtl_network))
mtl_network$direction &lt;- "Both"
mtl_network[6, "direction"] &lt;- "TF"
mtl_network_directed &lt;- lines_direction(mtl_network, "direction")
</code></pre>

<hr>
<h2 id='lines_extremities'>Get lines extremities</h2><span id='topic+lines_extremities'></span>

<h3>Description</h3>

<p>Generate a feature collection of points with the first and last vertex
of each line in a feature collection of linestrings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_extremities(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_extremities_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings (simple Linestrings)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='lines_points_along'>Points along lines</h2><span id='topic+lines_points_along'></span>

<h3>Description</h3>

<p>Generate a feature collection of points along the lines of
feature collection of Linestrings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lines_points_along(lines, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines_points_along_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings to use</p>
</td></tr>
<tr><td><code id="lines_points_along_+3A_dist">dist</code></td>
<td>
<p>The distance between the points along the lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
new_pts &lt;- lines_points_along(mtl_network,50)

</code></pre>

<hr>
<h2 id='list_coordinates_as_lines'>List of coordinates as lines</h2><span id='topic+list_coordinates_as_lines'></span>

<h3>Description</h3>

<p>A function to convert a list of matrices to as sf object with linestring geometry type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_coordinates_as_lines(coord_list, crs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_coordinates_as_lines_+3A_coord_list">coord_list</code></td>
<td>
<p>A list of matrices</p>
</td></tr>
<tr><td><code id="list_coordinates_as_lines_+3A_crs">crs</code></td>
<td>
<p>The CRS to use to create the lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sf object with linestring type geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='lixelize_lines'>Cut lines into lixels</h2><span id='topic+lixelize_lines'></span>

<h3>Description</h3>

<p>Cut the lines of a feature collection of linestrings into lixels with a specified minimal
distance may fail if the line geometries are self intersecting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lixelize_lines(lines, lx_length, mindist = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lixelize_lines_+3A_lines">lines</code></td>
<td>
<p>The sf object with linestring geometry type to modify</p>
</td></tr>
<tr><td><code id="lixelize_lines_+3A_lx_length">lx_length</code></td>
<td>
<p>The length of a lixel</p>
</td></tr>
<tr><td><code id="lixelize_lines_+3A_mindist">mindist</code></td>
<td>
<p>The minimum length of a lixel. After cut, if the length of the
final lixel is shorter than the minimum distance, then it is added to the
previous lixel. if NULL, then mindist = maxdist/10. Note that the segments
that are already shorter than the minimum distance are not modified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An sf object with linestring geometry type
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
lixels &lt;- lixelize_lines(mtl_network,150,50)

</code></pre>

<hr>
<h2 id='lixelize_lines.mc'>Cut lines into lixels (multicore)</h2><span id='topic+lixelize_lines.mc'></span>

<h3>Description</h3>

<p>Cut the lines of a feature collection of linestrings into lixels with a specified minimal
distance may fail if the line geometries are self intersecting with
multicore support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lixelize_lines.mc(
  lines,
  lx_length,
  mindist = NULL,
  verbose = TRUE,
  chunk_size = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lixelize_lines.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings to convert to lixels</p>
</td></tr>
<tr><td><code id="lixelize_lines.mc_+3A_lx_length">lx_length</code></td>
<td>
<p>The length of a lixel</p>
</td></tr>
<tr><td><code id="lixelize_lines.mc_+3A_mindist">mindist</code></td>
<td>
<p>The minimum length of a lixel. After cut, if the length of the
final lixel is shorter than the minimum distance, then it is added to the
previous lixel. If NULL, then mindist = maxdist/10</p>
</td></tr>
<tr><td><code id="lixelize_lines.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if a progress bar must be displayed</p>
</td></tr>
<tr><td><code id="lixelize_lines.mc_+3A_chunk_size">chunk_size</code></td>
<td>
<p>The size of a chunk used for multiprocessing. Default is
100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
future::plan(future::multisession(workers=1))
lixels &lt;- lixelize_lines.mc(mtl_network,150,50)
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")){
future::plan(future::sequential)
}

</code></pre>

<hr>
<h2 id='main_network_mtl'>Primary road network of Montreal</h2><span id='topic+main_network_mtl'></span>

<h3>Description</h3>

<p>A feature collection (sf object) representing the primary road network of Montreal. The EPSG is 3797, and the data comes from the
Montreal OpenData website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>main_network_mtl
</code></pre>


<h3>Format</h3>

<p>A sf object with 2945 rows and 2 variables
</p>

<dl>
<dt>TYPE</dt><dd><p>the type of road</p>
</dd>
<dt>geom</dt><dd><p>the geometry (linestrings)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://donnees.montreal.ca/ville-de-montreal/geobase&gt;
</p>

<hr>
<h2 id='mtl_libraries'>Libraries of Montreal</h2><span id='topic+mtl_libraries'></span>

<h3>Description</h3>

<p>A feature collection (sf object) representing the libraries of Montreal. The EPSG is 3797 and the data comes from the
Montreal OpenData website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtl_libraries
</code></pre>


<h3>Format</h3>

<p>A sf object with 55 rows and 3 variables.
</p>

<dl>
<dt>CP</dt><dd><p>the postal code</p>
</dd>
<dt>NAME</dt><dd><p>the name of the library</p>
</dd>
<dt>geom</dt><dd><p>the geometry (points)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://donnees.montreal.ca/ville-de-montreal/lieux-culturels&gt;
</p>

<hr>
<h2 id='mtl_network'>Road network of Montreal</h2><span id='topic+mtl_network'></span>

<h3>Description</h3>

<p>A feature collection (sf object) representing the road network of Montreal. The EPSG is 3797, and the data comes from the
Montreal OpenData website. It is only a small subset in central districts used to demonstrate the
main functions of spNetwork.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtl_network
</code></pre>


<h3>Format</h3>

<p>A sf object with 2945 rows and 2 variables
</p>

<dl>
<dt>ClsRte</dt><dd><p>the category of the road</p>
</dd>
<dt>geom</dt><dd><p>the geometry (linestrings)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://donnees.montreal.ca/ville-de-montreal/geobase&gt;
</p>

<hr>
<h2 id='mtl_theatres'>Theatres of Montreal</h2><span id='topic+mtl_theatres'></span>

<h3>Description</h3>

<p>A feature collection (sf object) representing the theatres of Montreal. The EPSG is 3797 and the data comes from the
Montreal OpenData website.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtl_theatres
</code></pre>


<h3>Format</h3>

<p>A sf object with 54 rows and 3 variables.
</p>

<dl>
<dt>CP</dt><dd><p>the postal code</p>
</dd>
<dt>NAME</dt><dd><p>the name of the theatre</p>
</dd>
<dt>geom</dt><dd><p>the geometry (points)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://donnees.montreal.ca/ville-de-montreal/lieux-culturels&gt;
</p>

<hr>
<h2 id='nearest_lines'>Nearest line for points</h2><span id='topic+nearest_lines'></span>

<h3>Description</h3>

<p>Find for each point its nearest LineString
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearest_lines(points, lines, snap_dist = 300, max_iter = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearest_lines_+3A_points">points</code></td>
<td>
<p>A feature collection of points</p>
</td></tr>
<tr><td><code id="nearest_lines_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings</p>
</td></tr>
<tr><td><code id="nearest_lines_+3A_snap_dist">snap_dist</code></td>
<td>
<p>A distance (float) given to find for each point its
nearest line in a spatial index. A too big value will produce
unnecessary distance calculations and a too short value will lead to
more iterations to find neighbours. In extrem cases, a too short value
could lead to points not associated with lines (index = -1).</p>
</td></tr>
<tr><td><code id="nearest_lines_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer indicating how many iteration the search
algorithm must perform in the spatial index to find lines close to a
point. At each iteration, the snap_dist is doubled to find candidates.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># this is an internal function, no example provided
</code></pre>

<hr>
<h2 id='nearestPointOnLine'>Nearest point on Line</h2><span id='topic+nearestPointOnLine'></span>

<h3>Description</h3>

<p>Find the nearest projected point on a LineString (from maptools)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestPointOnLine(coordsLine, coordsPoint)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestPointOnLine_+3A_coordsline">coordsLine</code></td>
<td>
<p>The coordinates of the line (matrix)</p>
</td></tr>
<tr><td><code id="nearestPointOnLine_+3A_coordspoint">coordsPoint</code></td>
<td>
<p>The coordinates of the point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the coordinates of the projected point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='nearestPointOnSegment'>Nearest point on segment</h2><span id='topic+nearestPointOnSegment'></span>

<h3>Description</h3>

<p>Find the nearest projected point on a segment (from maptools)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestPointOnSegment(s, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestPointOnSegment_+3A_s">s</code></td>
<td>
<p>The coordinates of the segment</p>
</td></tr>
<tr><td><code id="nearestPointOnSegment_+3A_p">p</code></td>
<td>
<p>The coordinates of the point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the coordinates of the projected point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='network_knn'>K-nearest points on network</h2><span id='topic+network_knn'></span>

<h3>Description</h3>

<p>Calculate the K-nearest points for a set of points on a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_knn(
  origins,
  lines,
  k,
  destinations = NULL,
  maxdistance = 0,
  snap_dist = Inf,
  line_weight = "length",
  direction = NULL,
  grid_shape = c(1, 1),
  verbose = FALSE,
  digits = 3,
  tol = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_knn_+3A_origins">origins</code></td>
<td>
<p>A feature collection of points, for each point, its k nearest
neighbours will be found on the network.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network</p>
</td></tr>
<tr><td><code id="network_knn_+3A_k">k</code></td>
<td>
<p>An integer indicating the number of neighbours to find.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_destinations">destinations</code></td>
<td>
<p>A feature collection of points, might be used if the neighbours
must be found in a separate set of points NULL if the neighbours must be found in
origins.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_maxdistance">maxdistance</code></td>
<td>
<p>The maximum distance between two observations to
consider them as neighbours. It is useful only if a grid is used, a
lower value will reduce calculating time, but one must be sure that the
k nearest neighbours are within this radius. Otherwise NAs will be present
in the results.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_snap_dist">snap_dist</code></td>
<td>
<p>The maximum distance to snap the start and end points on
the network.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_line_weight">line_weight</code></td>
<td>
<p>The weighting to use for lines. Default is &quot;length&quot;
(the geographical length), but can be the name of a column. The value is
considered proportional to the geographical length of the lines.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_direction">direction</code></td>
<td>
<p>The name of a column indicating authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of length 2 indicating the shape of the grid to
use for splitting the dataset. Default is c(1,1), so all the calculation is
done in one go. It might be necessary to split it if the dataset is large.</p>
</td></tr>
<tr><td><code id="network_knn_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its
progress</p>
</td></tr>
<tr><td><code id="network_knn_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td></tr>
<tr><td><code id="network_knn_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the points and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The k nearest neighbours of each point are found by using the network distance.
The results could not be exact if some points share the exact same location. As an example,
consider the following case. If A and B are two points at the exact same location, and C is
a third point close to A and B. If the 1 nearest neighbour is requested for C, the function
could return either A or B but not both. When such situation happens, a warning is raised by
the function.
</p>


<h3>Value</h3>

<p>A list with two matrices, one with the index of the neighbours and
one with the distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
    data(main_network_mtl)
    data(mtl_libraries)
    results &lt;- network_knn(mtl_libraries, main_network_mtl,
        k = 3, maxdistance = 1000, line_weight = "length",
        grid_shape=c(1,1), verbose = FALSE)

</code></pre>

<hr>
<h2 id='network_knn_worker'>worker function for K-nearest points on network</h2><span id='topic+network_knn_worker'></span>

<h3>Description</h3>

<p>The worker the K-nearest points for a set of points on a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_knn_worker(
  points,
  lines,
  k,
  direction = NULL,
  use_dest = FALSE,
  verbose = verbose,
  digits = digits,
  tol = tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_knn_worker_+3A_points">points</code></td>
<td>
<p>A feature collection of points, for each point, its k nearest
neighbours will be found on the network.</p>
</td></tr>
<tr><td><code id="network_knn_worker_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines representing the network</p>
</td></tr>
<tr><td><code id="network_knn_worker_+3A_k">k</code></td>
<td>
<p>An integer indicating the number of neighbours to find..</p>
</td></tr>
<tr><td><code id="network_knn_worker_+3A_direction">direction</code></td>
<td>
<p>Indicates a field providing information about authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="network_knn_worker_+3A_use_dest">use_dest</code></td>
<td>
<p>A boolean indicating if the origins and separations are
separated (TRUE), FALSE if only origins are used.</p>
</td></tr>
<tr><td><code id="network_knn_worker_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its
progress</p>
</td></tr>
<tr><td><code id="network_knn_worker_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain in the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td></tr>
<tr><td><code id="network_knn_worker_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when points are
added as vertices to lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two matrices, one with the index of the neighbours and
one with the distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='network_knn.mc'>K-nearest points on network (multicore version)</h2><span id='topic+network_knn.mc'></span>

<h3>Description</h3>

<p>Calculate the K-nearest points for a set of points on a network with multicore support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_knn.mc(
  origins,
  lines,
  k,
  destinations = NULL,
  maxdistance = 0,
  snap_dist = Inf,
  line_weight = "length",
  direction = NULL,
  grid_shape = c(1, 1),
  verbose = FALSE,
  digits = 3,
  tol = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_knn.mc_+3A_origins">origins</code></td>
<td>
<p>A feature collection of points, for each point, its k nearest
neighbours will be found on the network.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_k">k</code></td>
<td>
<p>An integer indicating the number of neighbours to find.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_destinations">destinations</code></td>
<td>
<p>A feature collection of points, might be used if the neighbours
must be found in a separate set of points NULL if the neighbours must be found in
origins.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_maxdistance">maxdistance</code></td>
<td>
<p>The maximum distance between two observations to
consider them as neighbours. It is useful only if a grid is used, a
lower value will reduce calculating time, but one must be sure that the
k nearest neighbours are within this radius. Otherwise NAs will be present
in the results.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_snap_dist">snap_dist</code></td>
<td>
<p>The maximum distance to snap the start and end points on
the network.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_line_weight">line_weight</code></td>
<td>
<p>The weighting to use for lines. Default is &quot;length&quot;
(the geographical length), but can be the name of a column. The value is
considered proportional to the geographical length of the lines.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_direction">direction</code></td>
<td>
<p>The name of a column indicating authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of length 2 indicating the shape of the grid to
use for splitting the dataset. Default is c(1,1), so all the calculation is
done in one go. It might be necessary to split it if the dataset is large.</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its
progress</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td></tr>
<tr><td><code id="network_knn.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the points and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two matrices, one with the index of the neighbours and
one with the distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(main_network_mtl)
data(mtl_libraries)
future::plan(future::multisession(workers=1))
results &lt;- network_knn.mc(mtl_libraries, main_network_mtl,
    k = 3, maxdistance = 1000, line_weight = "length",
    grid_shape=c(1,1), verbose = FALSE)
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='network_listw'>Network distance listw</h2><span id='topic+network_listw'></span>

<h3>Description</h3>

<p>Generate listw object (spdep like) based on network distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_listw(
  origins,
  lines,
  maxdistance,
  method = "centroid",
  point_dist = NULL,
  snap_dist = Inf,
  line_weight = "length",
  mindist = 10,
  direction = NULL,
  dist_func = "inverse",
  matrice_type = "B",
  grid_shape = c(1, 1),
  verbose = FALSE,
  digits = 3,
  tol = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_listw_+3A_origins">origins</code></td>
<td>
<p>A feature collection of lines, points, or polygons
for which the spatial neighbouring list will be built</p>
</td></tr>
<tr><td><code id="network_listw_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines representing the network</p>
</td></tr>
<tr><td><code id="network_listw_+3A_maxdistance">maxdistance</code></td>
<td>
<p>The maximum distance between two observations to
consider them as neighbours.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_method">method</code></td>
<td>
<p>A string indicating how the starting points will be built.
If 'centroid' is used, then the centre of lines or polygons is used. If
'pointsalong' is used, then points will be placed along polygons' borders or
along lines as starting and end points. If 'ends' is used (only for lines)
the first and last vertices of lines are used as starting and ending points.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_point_dist">point_dist</code></td>
<td>
<p>A float, defining the distance between points when the
method 'pointsalong' is selected.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_snap_dist">snap_dist</code></td>
<td>
<p>The maximum distance to snap the start and end points on
the network.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_line_weight">line_weight</code></td>
<td>
<p>The weighting to use for lines. Default is &quot;length&quot;
(the geographical length), but can be the name of a column. The value is
considered proportional to the geographical length of the lines.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance between two different observations.
It is important for it to be different from 0 when a W style is used.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_direction">direction</code></td>
<td>
<p>Indicates a field providing information about authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_dist_func">dist_func</code></td>
<td>
<p>Indicates the function to use to convert the distance
between observation in spatial weights. Can be 'identity', 'inverse',
'squared inverse' or a function with one parameter x that will be
vectorized internally</p>
</td></tr>
<tr><td><code id="network_listw_+3A_matrice_type">matrice_type</code></td>
<td>
<p>The type of the weighting scheme. Can be 'B' for Binary,
'W' for row weighted, or 'I' (identity), see the documentation of spdep::nb2listw for details</p>
</td></tr>
<tr><td><code id="network_listw_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of length 2 indicating the shape of the grid to
use for splitting the dataset. Default is c(1,1), so all the calculation is
done in one go. It might be necessary to split it if the dataset is large.</p>
</td></tr>
<tr><td><code id="network_listw_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its
progress</p>
</td></tr>
<tr><td><code id="network_listw_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain in the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td></tr>
<tr><td><code id="network_listw_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when points are
added as vertices to lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A listw object (spdep like) if matrice_type is &quot;B&quot; or &quot;W&quot;. If
matrice_type is I, then a list with a nblist object and a list of weights
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
listw &lt;- network_listw(mtl_network, mtl_network, maxdistance = 500,
        method = "centroid", line_weight = "length",
        dist_func = 'squared inverse', matrice_type='B', grid_shape = c(2,2))

</code></pre>

<hr>
<h2 id='network_listw_worker'>network_listw worker</h2><span id='topic+network_listw_worker'></span>

<h3>Description</h3>

<p>The worker function of network_listw.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_listw_worker(
  points,
  lines,
  maxdistance,
  dist_func,
  direction = NULL,
  mindist = 10,
  matrice_type = "B",
  verbose = FALSE,
  digits = 3,
  tol = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_listw_worker_+3A_points">points</code></td>
<td>
<p>A feature collection of points corresponding to start and end
points. It must have a column fid, grouping the points if necessary.</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines representing the network</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_maxdistance">maxdistance</code></td>
<td>
<p>The maximum distance between two observation to
consider them as neighbours.</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_dist_func">dist_func</code></td>
<td>
<p>A vectorized function converting spatial distances into
weights.</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_direction">direction</code></td>
<td>
<p>Indicate a field giving information about authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance between two different observations.
It is important for it to be different from 0 when a W style is used.</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_matrice_type">matrice_type</code></td>
<td>
<p>The type of the weighting scheme. Can be 'B' for Binary,
'W' for row weighted, or 'I' (identity), see the documentation of spdep::nb2listw for details</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its
progress</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_digits">digits</code></td>
<td>
<p>the number of digits to keep in the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td></tr>
<tr><td><code id="network_listw_worker_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when points are
added as vertices to lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of neihbours as weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='network_listw.mc'>Network distance listw (multicore)</h2><span id='topic+network_listw.mc'></span>

<h3>Description</h3>

<p>Generate listw object (spdep like) based on network distances with multicore support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>network_listw.mc(
  origins,
  lines,
  maxdistance,
  method = "centroid",
  point_dist = NULL,
  snap_dist = Inf,
  line_weight = "length",
  mindist = 10,
  direction = NULL,
  dist_func = "inverse",
  matrice_type = "B",
  grid_shape = c(1, 1),
  verbose = FALSE,
  digits = 3,
  tol = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="network_listw.mc_+3A_origins">origins</code></td>
<td>
<p>A feature collection of linestrings, points or polygons for
which the spatial neighbouring list will be built.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_maxdistance">maxdistance</code></td>
<td>
<p>The maximum distance between two observations to consider
them as neighbours.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_method">method</code></td>
<td>
<p>A string indicating how the starting points will be built. If
'centroid' is used, then the centre of lines or polygons is used. If
'pointsalong' is used, then points will be placed along polygons' borders
or along lines as starting and end points. If 'ends' is used (only for
lines) the first and last vertices of lines are used as starting and ending
points.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_point_dist">point_dist</code></td>
<td>
<p>A float, defining the distance between points when the
method pointsalong is selected.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_snap_dist">snap_dist</code></td>
<td>
<p>the maximum distance to snap the start and end points on the
network.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_line_weight">line_weight</code></td>
<td>
<p>The weights to use for lines. Default is &quot;length&quot; (the
geographical length), but can be the name of a column. The value is
considered proportional with the geographical length of the lines.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance between two different observations. It is
important for it to be different from 0 when a W style is used.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_direction">direction</code></td>
<td>
<p>Indicates a field giving information about authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_dist_func">dist_func</code></td>
<td>
<p>Indicates the function to use to convert the distance
between observation in spatial weights. Can be 'identity', 'inverse',
'squared inverse' or a function with one parameter x that will be
vectorized internally</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_matrice_type">matrice_type</code></td>
<td>
<p>The type of the weighting scheme. Can be 'B' for Binary,
'W' for row weighted, or 'I' (identity) see the documentation of
spdep::nb2listw for details</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of length 2 indicating the shape of the grid to
use for splitting the dataset. Default is c(1,1), so all the calculation is
done in one go. It might be necessary to split it if the dataset is large.</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its progress</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain in the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td></tr>
<tr><td><code id="network_listw.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when points are added as
vertices to lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A listw object (spdep like) if matrice_type is &quot;B&quot; or &quot;W&quot;. If
matrice_type is I, then a list with a nblist object and a list of weights
is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
future::plan(future::multisession(workers=1))
listw &lt;- network_listw.mc(mtl_network,mtl_network,maxdistance=500,
        method = "centroid", line_weight = "length",
        dist_func = 'squared inverse', matrice_type='B', grid_shape = c(2,2))
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='nkde'>Network Kernel density estimate</h2><span id='topic+nkde'></span>

<h3>Description</h3>

<p>Calculate the Network Kernel Density Estimate based on a network of lines,
sampling points, and events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nkde(
  lines,
  events,
  w,
  samples,
  kernel_name,
  bw,
  adaptive = FALSE,
  trim_bw = NULL,
  method,
  div = "bw",
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  grid_shape = c(1, 1),
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nkde_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="nkde_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="nkde_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="nkde_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points representing the locations for
which the densities will be estimated.</p>
</td></tr>
<tr><td><code id="nkde_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="nkde_+3A_bw">bw</code></td>
<td>
<p>The kernel bandwidth (using the scale of the lines), can be a
single float or a numeric vector if a different bandwidth must be used
for each event.</p>
</td></tr>
<tr><td><code id="nkde_+3A_adaptive">adaptive</code></td>
<td>
<p>A Boolean, indicating if an adaptive bandwidth must be
used</p>
</td></tr>
<tr><td><code id="nkde_+3A_trim_bw">trim_bw</code></td>
<td>
<p>A float, indicating the maximum value for the adaptive
bandwidth</p>
</td></tr>
<tr><td><code id="nkde_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="nkde_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwidth)
&quot;none&quot; (the simple sum).</p>
</td></tr>
<tr><td><code id="nkde_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="nkde_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="nkde_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="nkde_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="nkde_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="nkde_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="nkde_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="nkde_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="nkde_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="nkde_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>**The three NKDE methods**<br />
Estimating the density of a point process is commonly done by using an
ordinary two-dimensional kernel density function. However, there are numerous
cases for which the events do not occur in a two-dimensional space but on a
network (like car crashes, outdoor crimes, leaks in pipelines, etc.). New
methods were developed to adapt the methodology to networks, three of them
are available in this package. </p>
 <ul>
<li><p>method=&quot;simple&quot;This first
method was presented by (Xie and Yan 2008) and proposes an
intuitive solution. The distances between events and sampling points are
replaced by network distances, and the formula of the kernel is adapted to
calculate the density over a linear unit instead of an areal unit.
</p>
</li>
<li><p>method=&quot;discontinuous&quot;The previous method has been criticized by
(Okabe et al. 2009), arguing that the estimator proposed
is biased, leading to an overestimation of density in events hot-spots. More
specifically, the simple method does not conserve mass and the induced kernel
is not a probability density along the network. They thus proposed a
discontinuous version of the kernel function on network, which equally
&quot;divides&quot; the mass density of an event at intersections
</p>
</li>
<li><p>method=&quot;continuous&quot;If the discontinuous method is unbiased, it leads
to a discontinuous kernel function which is a bit counter-intuitive.
Okabe et al. (2009) proposed another version of
the kernel, which divides the mass of the density at intersections but adjusts
the density before the intersection to make the function continuous. </p>
</li></ul>
<p> The
three methods are available because, even though that the simple method is
less precise statistically speaking, it might be more intuitive. From a
purely geographical view, it might be seen as a sort of distance decay
function as used in Geographically Weighted Regression.<br /> <br /><br /> **adaptive bandwidth**<br />
It is possible to use adaptive bandwidth instead of fixed
bandwidth. Adaptive bandwidths are calculated using the Abramson’s smoothing
regimen (Abramson 1982). To do so, an original
fixed bandwidth must be specified (bw parameter), and is used to estimate the
priory densitiy at event locations. These densities are then used to
calculate local bandwidth. The maximum size of the local bandwidth can be
limited with the parameter trim_bw. For more details, see the vignettes.
<br /><br /> **Optimization parameters**<br /> The grid_shape parameter allows to
split the calculus of the NKDE according to a grid dividing the study area.
It might be necessary for big dataset to reduce the memory used. If the
grid_shape is c(1,1), then a full network is built for the area. If the
grid_shape is c(2,2), then the area is split in 4 rectangles. For each
rectangle, the sample points falling in the rectangle are used, the events
and the lines in a radius of the bandwidth length are used. The results are
combined at the end and ordered to match the original order of the samples.
<br /><br /> The geographical coordinates of the start and end of lines are used to
build the network. To avoid troubles with digits, we truncate the coordinates
according to the digit parameter. A minimal loss of precision is expected but
results in a fast construction of the network. <br /><br /> To calculate the
distances on the network, all the events are added as vertices. To reduce the
size of the network, it is possible to reduce the number of vertices by
adding the events at the extremity of the lines if they are close to them.
This is controlled by the parameter tol. <br /><br /> In the same way, it is
possible to limit the number of vertices by aggregating the events that are
close to each other. In that case, the weights of the aggregated events are
summed. According to an aggregation distance, a buffer is drawn around the
fist event, all events falling in that buffer are aggregated to the first
event, forming a new event. The coordinates of this new event are the means of
the original events coordinates. This procedure is repeated until no events
are aggregated. The aggregation distance can be fixed with the parameter agg.
<br /><br /> When using the continuous and discontinuous kernel, the density is
reduced at each intersection crossed. In the discontinuous case, after 5
intersections with four directions each, the density value is divided by 243
leading to very small values. In the same situation but with the continuous
NKDE, the density value is divided by approximately 7.6. The max_depth
parameters allows the user to control the maximum depth of these two NKDE.
The base value is 15, but a value of 10 would yield very close estimates. A
lower value might have a critical impact on speed when the bandwidth is large.
<br /><br /> When using the continuous and discontinuous kernel, the connections
between graph nodes are stored in a matrix. This matrix is typically sparse,
and so a sparse matrix object is used to limit memory use. If the network is
small (typically when the grid used to split the data has small rectangles)
then a classical matrix could be used instead of a sparse one. It
significantly increases speed, but could lead to memory issues.
</p>


<h3>Value</h3>

<p>A vector of values, they are the density estimates at sampling points
</p>


<h3>References</h3>

 <p>Abramson IS (1982).
&ldquo;On bandwidth variation in kernel estimates-a square root law.&rdquo;
<em>The annals of Statistics</em>, 1217&ndash;1223.<br /><br /> Okabe A, Satoh T, Sugihara K (2009).
&ldquo;A kernel density estimation method for networks, its computational method and a GIS-based tool.&rdquo;
<em>International Journal of Geographical Information Science</em>, <b>23</b>(1), 7&ndash;32.<br /><br /> Xie Z, Yan J (2008).
&ldquo;Kernel density estimation of traffic accidents in a network space.&rdquo;
<em>Computers, environment and urban systems</em>, <b>32</b>(5), 396&ndash;406. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
data(bike_accidents)
lixels &lt;- lixelize_lines(mtl_network,200,mindist = 50)
samples &lt;- lines_center(lixels)
densities &lt;- nkde(mtl_network,
                  events = bike_accidents,
                  w = rep(1,nrow(bike_accidents)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, div= "bw",
                  adaptive = FALSE,
                  method = "discontinuous", digits = 1, tol = 1,
                  agg = 15,
                  grid_shape = c(1,1),
                  verbose=FALSE)

</code></pre>

<hr>
<h2 id='nkde_get_loo_values'>The exposed function to calculate NKDE likelihood cv</h2><span id='topic+nkde_get_loo_values'></span>

<h3>Description</h3>

<p>The exposed function to calculate NKDE likelihood cv (INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nkde_get_loo_values(
  method,
  neighbour_list,
  sel_events,
  sel_events_wid,
  events,
  events_wid,
  weights,
  bws_net,
  kernel_name,
  line_list,
  max_depth,
  cvl
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nkde_get_loo_values_+3A_method">method</code></td>
<td>
<p>a string, one of &quot;simple&quot;, &quot;continuous&quot;, &quot;discontinuous&quot;</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_sel_events">sel_events</code></td>
<td>
<p>a Numeric vector indicating the selected events (id of nodes)</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_sel_events_wid">sel_events_wid</code></td>
<td>
<p>a Numeric Vector indicating the unique if of the selected events</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_events_wid">events_wid</code></td>
<td>
<p>a NumericVector indicating the unique id of all the events</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_weights">weights</code></td>
<td>
<p>a matrix with the weights associated with each event (row) for each
bws_net (cols).</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_kernel_name">kernel_name</code></td>
<td>
<p>a string with the name of the kernel to use</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame describing the lines</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
<tr><td><code id="nkde_get_loo_values_+3A_cvl">cvl</code></td>
<td>
<p>a boolean indicating if the Cronie (TRUE) or CV likelihood (FALSE) must be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with the CV score for each bandwidth and the densities if required
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='nkde_worker'>NKDE worker</h2><span id='topic+nkde_worker'></span>

<h3>Description</h3>

<p>The worker function for nkde and nkde.mc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nkde_worker(
  lines,
  events,
  samples,
  kernel_name,
  bw,
  bws,
  method,
  div,
  digits,
  tol,
  sparse,
  max_depth,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nkde_worker_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network. The
geometries must be simple lines (may crash if some geometries
are invalid)</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events on the
network. The points will be snapped on the network.</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points representing the locations for
which the densities will be estimated.</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_bw">bw</code></td>
<td>
<p>The global kernel bandwidth</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_bws">bws</code></td>
<td>
<p>The kernel bandwidth (in meters) for each event</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see details for more information)</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwidth)
&quot;none&quot; (the simple sum).</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep in the spatial coordinates. It
ensures that topology is good when building the network. Default is 3</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_tol">tol</code></td>
<td>
<p>When adding the events and the sampling points to the network,
the minimum distance between these points and the lines extremities. When
points are closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. Regular matrices are faster, but require more
memory and could lead to error, in particular with multiprocessing. Sparse
matrices are slower, but require much less memory.</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_max_depth">max_depth</code></td>
<td>
<p>When using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has a lot of
small edges (area with a lot of intersections and a lot of events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 8 should yield good
estimates. A larger value can be used without problem for the discontinuous
method. For the continuous method, a larger value will strongly impact
calculation speed.</p>
</td></tr>
<tr><td><code id="nkde_worker_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the nkde values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='nkde_worker_bw_sel'>Bandwidth selection by likelihood cross validation worker function</h2><span id='topic+nkde_worker_bw_sel'></span>

<h3>Description</h3>

<p>worker function for calculating for multiple bandwidth the cross validation likelihood to
select an appropriate bandwidth in a data-driven approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nkde_worker_bw_sel(
  lines,
  quad_events,
  events_loc,
  events,
  w,
  kernel_name,
  bws_net,
  method,
  div,
  digits,
  tol,
  sparse,
  max_depth,
  zero_strat = "min_double",
  verbose = FALSE,
  cvl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nkde_worker_bw_sel_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_quad_events">quad_events</code></td>
<td>
<p>a feature collection of points indicating for which events the densities must be calculated</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_events_loc">events_loc</code></td>
<td>
<p>A feature collection of points representing the location of the events</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events. Multiple events can share
the same location. They are linked by the goid column</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_w">w</code></td>
<td>
<p>A numeric matrix with the weight of the events for each bandwdith</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use (string)</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_bws_net">bws_net</code></td>
<td>
<p>A numeric vector with the network bandwidths</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_method">method</code></td>
<td>
<p>The type of NKDE to use (string)</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_zero_strat">zero_strat</code></td>
<td>
<p>A string indicating what to do when density is 0 when calculating LOO density estimate for an isolated event.
&quot;min_double&quot; (default) replace the 0 value by the minimum double possible on the machine. &quot;remove&quot; will remove them from the final
score. The first approach penalizes more strongly the small bandwidths.</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_verbose">verbose</code></td>
<td>
<p>A boolean</p>
</td></tr>
<tr><td><code id="nkde_worker_bw_sel_+3A_cvl">cvl</code></td>
<td>
<p>A boolean indicating if the cvl method (TRUE) or the loo (FALSE) method must be used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='nkde.mc'>Network Kernel density estimate (multicore)</h2><span id='topic+nkde.mc'></span>

<h3>Description</h3>

<p>Calculate the Network Kernel Density Estimate based on a network of lines,
sampling points, and events with multicore support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nkde.mc(
  lines,
  events,
  w,
  samples,
  kernel_name,
  bw,
  adaptive = FALSE,
  trim_bw = NULL,
  method,
  div = "bw",
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  grid_shape = c(1, 1),
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nkde.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points representing the locations for
which the densities will be estimated.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_bw">bw</code></td>
<td>
<p>The kernel bandwidth (using the scale of the lines), can be a
single float or a numeric vector if a different bandwidth must be used
for each event.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_adaptive">adaptive</code></td>
<td>
<p>A Boolean, indicating if an adaptive bandwidth must be
used</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_trim_bw">trim_bw</code></td>
<td>
<p>A float, indicating the maximum value for the adaptive
bandwidth</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwidth)
&quot;none&quot; (the simple sum).</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="nkde.mc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details, see help(nkde)
</p>


<h3>Value</h3>

<p>A vector of values, they are the density estimates at sampling
points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
data(bike_accidents)
future::plan(future::multisession(workers=1))
lixels &lt;- lixelize_lines(mtl_network,200,mindist = 50)
samples &lt;- lines_center(lixels)
densities &lt;- nkde.mc(mtl_network,
                  events = bike_accidents,
                  w = rep(1,nrow(bike_accidents)),
                  samples = samples,
                  kernel_name = "quartic",
                  bw = 300, div= "bw",
                  adaptive = FALSE, agg = 15,
                  method = "discontinuous", digits = 1, tol = 1,
                  grid_shape = c(3,3),
                  verbose=FALSE)
## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='plot_graph'>Plot graph</h2><span id='topic+plot_graph'></span>

<h3>Description</h3>

<p>Function to plot a graph (useful to check connectivity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_graph(graph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_graph_+3A_graph">graph</code></td>
<td>
<p>A graph object (produced with build_graph)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='prepare_data'>Prior data preparation</h2><span id='topic+prepare_data'></span>

<h3>Description</h3>

<p>A simple function to prepare data before the NKDE calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_data(samples, lines, events, w, digits, tol, agg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_data_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points representing the samples points</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_lines">lines</code></td>
<td>
<p>A feature collection of Linestrings representing the network</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events points</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_w">w</code></td>
<td>
<p>A numeric vector representing the weight of the events</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="prepare_data_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the points must be aggregated within a distance.
if NULL, then the points are aggregated by rounding the coordinates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the data prepared for the rest of the operations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='prepare_elements_netlistw'>Data preparation for network_listw</h2><span id='topic+prepare_elements_netlistw'></span>

<h3>Description</h3>

<p>Function to prepare selected points and selected lines during
the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_elements_netlistw(is, grid, snapped_points, lines, maxdistance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_elements_netlistw_+3A_is">is</code></td>
<td>
<p>The indices of the quadras to use in the grid</p>
</td></tr>
<tr><td><code id="prepare_elements_netlistw_+3A_grid">grid</code></td>
<td>
<p>A feature collection of polygons representing the quadras to split
calculus</p>
</td></tr>
<tr><td><code id="prepare_elements_netlistw_+3A_snapped_points">snapped_points</code></td>
<td>
<p>The start and end points snapped to the lines</p>
</td></tr>
<tr><td><code id="prepare_elements_netlistw_+3A_lines">lines</code></td>
<td>
<p>The lines representing the network</p>
</td></tr>
<tr><td><code id="prepare_elements_netlistw_+3A_maxdistance">maxdistance</code></td>
<td>
<p>The maximum distance between two observation to considere
them as neighbours.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements : selected points and selected lines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='quartic_kernel'>Quartic kernel</h2><span id='topic+quartic_kernel'></span>

<h3>Description</h3>

<p>Function implementing the quartic kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartic_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartic_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="quartic_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='quartic_kernel_cpp'>c++ quartic kernel</h2><span id='topic+quartic_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ quartic kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartic_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartic_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="quartic_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='quartic_kernelos'>c++ quartic kernel for one distance</h2><span id='topic+quartic_kernelos'></span>

<h3>Description</h3>

<p>c++ quartic kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quartic_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quartic_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="quartic_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='randomize_distmatrix'>Points on network randomization</h2><span id='topic+randomize_distmatrix'></span>

<h3>Description</h3>

<p>Randomize location of points on a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_distmatrix(graph, edge_df, n, start_vert = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomize_distmatrix_+3A_graph">graph</code></td>
<td>
<p>An graph object from igraph</p>
</td></tr>
<tr><td><code id="randomize_distmatrix_+3A_edge_df">edge_df</code></td>
<td>
<p>A DataFrame describing the edges</p>
</td></tr>
<tr><td><code id="randomize_distmatrix_+3A_n">n</code></td>
<td>
<p>The number of point</p>
</td></tr>
<tr><td><code id="randomize_distmatrix_+3A_start_vert">start_vert</code></td>
<td>
<p>The vertices from which the distances will be calculated.
if null, then the distances are calculated from the generated locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the distances between points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='randomize_distmatrix2'>Points on network randomization simplified</h2><span id='topic+randomize_distmatrix2'></span>

<h3>Description</h3>

<p>Randomize location of points on a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomize_distmatrix2(graph, edge_df, n, resolution, nsim, start_vert = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomize_distmatrix2_+3A_graph">graph</code></td>
<td>
<p>An graph object from igraph</p>
</td></tr>
<tr><td><code id="randomize_distmatrix2_+3A_edge_df">edge_df</code></td>
<td>
<p>A DataFrame describing the edges</p>
</td></tr>
<tr><td><code id="randomize_distmatrix2_+3A_n">n</code></td>
<td>
<p>The number of point</p>
</td></tr>
<tr><td><code id="randomize_distmatrix2_+3A_resolution">resolution</code></td>
<td>
<p>The maximum size of the network edges</p>
</td></tr>
<tr><td><code id="randomize_distmatrix2_+3A_nsim">nsim</code></td>
<td>
<p>The number of distance matrices to generate</p>
</td></tr>
<tr><td><code id="randomize_distmatrix2_+3A_start_vert">start_vert</code></td>
<td>
<p>The vertices from which the distances will be calculated.
if null, then the distances are calculated from the generated locations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the distances between points
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='remove_loop_lines'>Remove loops</h2><span id='topic+remove_loop_lines'></span>

<h3>Description</h3>

<p>Remove from a sf object with linestring type geometries the lines that have the
same starting and ending point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_loop_lines(lines, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_loop_lines_+3A_lines">lines</code></td>
<td>
<p>A sf object with linestring type geometries</p>
</td></tr>
<tr><td><code id="remove_loop_lines_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to keep for the
spatial coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sf object with linestring type geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='remove_mirror_edges'>Remove mirror edges</h2><span id='topic+remove_mirror_edges'></span>

<h3>Description</h3>

<p>Keep unique edges based on start and end point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_mirror_edges(lines, keep_shortest = TRUE, digits = 3, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_mirror_edges_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings</p>
</td></tr>
<tr><td><code id="remove_mirror_edges_+3A_keep_shortest">keep_shortest</code></td>
<td>
<p>A boolean, if TRUE, then the shortest line is keeped if
several lines have the same starting point and ending point. if FALSE, then the
longest line is keeped.</p>
</td></tr>
<tr><td><code id="remove_mirror_edges_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to keep in coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings with the mirror edges removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='reverse_lines'>Reverse lines</h2><span id='topic+reverse_lines'></span>

<h3>Description</h3>

<p>A function to reverse the order of the vertices of lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_lines(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reverse_lines_+3A_lines">lines</code></td>
<td>
<p>A sf object with linestring type geometries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sf object with linestring type geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='sanity_check_knn'>Sanity check for the knn functions</h2><span id='topic+sanity_check_knn'></span>

<h3>Description</h3>

<p>Check if all the parameters are valid for the knn functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanity_check_knn(
  origins,
  destinations,
  lines,
  k,
  maxdistance,
  snap_dist,
  line_weight,
  direction,
  grid_shape,
  verbose,
  digits,
  tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanity_check_knn_+3A_origins">origins</code></td>
<td>
<p>A a feature collection of points, for each point, its k nearest
neighbours will be found on the network.</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_destinations">destinations</code></td>
<td>
<p>A a feature collection of points, might be used if the neighbours
must be found in a separate dataset. NULL if the neighbours must be found in
origins.</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_lines">lines</code></td>
<td>
<p>A a feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_k">k</code></td>
<td>
<p>An integer indicating the number of neighbours to find..</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_maxdistance">maxdistance</code></td>
<td>
<p>The maximum distance between two observations to
consider them as neighbours. It is useful only if a grid is used, a
lower value will reduce calculating time, but one must be sure that the
k nearest neighbours are within this radius. Otherwise NAs will be present
in the final matrices.</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_snap_dist">snap_dist</code></td>
<td>
<p>The maximum distance to snap the start and end points on
the network.</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_line_weight">line_weight</code></td>
<td>
<p>The weighting to use for lines. Default is &quot;length&quot;
(the geographical length), but can be the name of a column. The value is
considered proportional to the geographical length of the lines.</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_direction">direction</code></td>
<td>
<p>Indicates a field providing information about authorized
travelling direction on lines. if NULL, then all lines can be used in both
directions. Must be the name of a column otherwise. The values of the
column must be &quot;FT&quot; (From - To), &quot;TF&quot; (To - From) or &quot;Both&quot;.</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of length 2 indicating the shape of the grid to
use for splitting the dataset. Default is c(1,1), so all the calculation is
done in one go. It might be necessary to split it if the dataset is large.</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean indicating if the function should print its
progress</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain in the spatial coordinates (
simplification used to reduce risk of topological error)</p>
</td></tr>
<tr><td><code id="sanity_check_knn_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when points are
added as vertices to lines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two matrices, one with the index of the neighbours and
one with the distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='select_dist_function'>Select the distance to weight function</h2><span id='topic+select_dist_function'></span>

<h3>Description</h3>

<p>Select a function to convert distance to weights
if a function is provided, this function will be vectorized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_dist_function(dist_func = "inverse")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_dist_function_+3A_dist_func">dist_func</code></td>
<td>
<p>Could be a name in c('inverse', 'identity',
'squared inverse') or a function with only one parameter x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vectorized function used to convert distance into spatial weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='select_kernel'>Select kernel function</h2><span id='topic+select_kernel'></span>

<h3>Description</h3>

<p>select the kernel function with its name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_kernel(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_kernel_+3A_name">name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A kernel function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='simple_lines'>LineString to simple Line</h2><span id='topic+simple_lines'></span>

<h3>Description</h3>

<p>Split the polylines of a feature collection of linestrings in simple
segments at each vertex. The values of the columns are duplicated for each segment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_lines(lines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_lines_+3A_lines">lines</code></td>
<td>
<p>The featue collection of linestrings to modify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An featue collection of linestrings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
new_lines &lt;- simple_lines(mtl_network)

</code></pre>

<hr>
<h2 id='simple_nkde'>Simple NKDE algorithm</h2><span id='topic+simple_nkde'></span>

<h3>Description</h3>

<p>Function to perform the simple nkde.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_nkde(graph, events, samples, bws, kernel_func, nodes, edges, div = "bw")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_nkde_+3A_graph">graph</code></td>
<td>
<p>a graph object from igraph representing the network</p>
</td></tr>
<tr><td><code id="simple_nkde_+3A_events">events</code></td>
<td>
<p>a feature collection of points representing the events. It must be
snapped on the network, and be nodes of the network. A column vertex_id
must indicate for each event its corresponding node</p>
</td></tr>
<tr><td><code id="simple_nkde_+3A_samples">samples</code></td>
<td>
<p>a a feature collection of points representing the sampling points.
The samples must be snapped on the network. A column edge_id must indicate
for each sample on which edge it is snapped.</p>
</td></tr>
<tr><td><code id="simple_nkde_+3A_bws">bws</code></td>
<td>
<p>a vector indicating the kernel bandwidth (in meters) for each
event</p>
</td></tr>
<tr><td><code id="simple_nkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a function obtained with the function select_kernel</p>
</td></tr>
<tr><td><code id="simple_nkde_+3A_nodes">nodes</code></td>
<td>
<p>a a feature collection of points representing the nodes of the network</p>
</td></tr>
<tr><td><code id="simple_nkde_+3A_edges">edges</code></td>
<td>
<p>a a feature collection of linestrings representing the edges of the network</p>
</td></tr>
<tr><td><code id="simple_nkde_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of events within the radius around each sampling point), &quot;bw&quot; (the bandwidth) &quot;none&quot; (the simple sum).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with two columns. sum_k is the sum for each sample point
of the kernel values. n is the number of events influencing each sample
point
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='simple_tnkde'>Simple TNKDE algorithm</h2><span id='topic+simple_tnkde'></span>

<h3>Description</h3>

<p>Function to perform the simple tnkde.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_tnkde(
  graph,
  events,
  samples,
  samples_time,
  bws_net,
  bws_time,
  kernel_func,
  nodes,
  edges,
  div
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_tnkde_+3A_graph">graph</code></td>
<td>
<p>a graph object from igraph representing the network</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_events">events</code></td>
<td>
<p>a feature collection of points representing the events. It must be
snapped on the network, and be nodes of the network. A column vertex_id
must indicate for each event its corresponding node</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_samples">samples</code></td>
<td>
<p>a feature collection of points representing the sampling points.
The samples must be snapped on the network. A column edge_id must indicate
for each sample on which edge it is snapped.</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_samples_time">samples_time</code></td>
<td>
<p>a numeric vector indicating when the densities must be
sampled</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_bws_net">bws_net</code></td>
<td>
<p>a vector indicating the network kernel bandwidth (in meters) for each
event</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_bws_time">bws_time</code></td>
<td>
<p>a vector indicating the time kernel bandwidth for each
event</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_kernel_func">kernel_func</code></td>
<td>
<p>a function obtained with the function select_kernel</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_nodes">nodes</code></td>
<td>
<p>a feature collection of points representing the nodes of the network</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_edges">edges</code></td>
<td>
<p>a feature collection of linestrings representing the edges of the network</p>
</td></tr>
<tr><td><code id="simple_tnkde_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwidth)
&quot;none&quot; (the simple sum).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two matrices. The first one ins the matrix of the densities,
the rows are the samples and the columns the time. The second has the same
dimensions and contains the number of events influencing each sample
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='simplify_network'>Simplify a network</h2><span id='topic+simplify_network'></span>

<h3>Description</h3>

<p>Simplify a network by applying two corrections: Healing edges and
Removing mirror edges (experimental).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_network(
  lines,
  digits = 3,
  heal = TRUE,
  mirror = TRUE,
  keep_shortest = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_network_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings</p>
</td></tr>
<tr><td><code id="simplify_network_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the number of digits to keep in coordinates</p>
</td></tr>
<tr><td><code id="simplify_network_+3A_heal">heal</code></td>
<td>
<p>A boolean indicating if the healing operation must be performed</p>
</td></tr>
<tr><td><code id="simplify_network_+3A_mirror">mirror</code></td>
<td>
<p>A boolean indicating if the mirror edges must be removed</p>
</td></tr>
<tr><td><code id="simplify_network_+3A_keep_shortest">keep_shortest</code></td>
<td>
<p>A boolean, if TRUE, then the shortest line is kept from
mirror edges. if FALSE, then the longest line is kept.</p>
</td></tr>
<tr><td><code id="simplify_network_+3A_verbose">verbose</code></td>
<td>
<p>A boolean indicating if messages and a progress bar should be displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Healing is the operation to merge two connected linestring if the are
intersecting at one extremity and do not intersect any other linestring. It helps
to reduce the complexity of the network and thus can reduce calculation time.
Removing mirror edges is the operation to remove edges that have the same
extremities. If two edges start at the same point and end at the same point,
they do not add information in the network and one can be removed to simplify
the network. One can decide to keep the longest of the two edges or the shortest.
NOTE: the edge healing does not consider lines directions currently!
</p>


<h3>Value</h3>

<p>A feature collection of linestrings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtl_network)
edited_lines &lt;- simplify_network(mtl_network, digits = 3, verbose = FALSE)

</code></pre>

<hr>
<h2 id='small_mtl_network'>Smaller subset road network of Montreal</h2><span id='topic+small_mtl_network'></span>

<h3>Description</h3>

<p>A feature collection (sf object) representing the road network of Montreal. The EPSG is 3797, and the data comes from the
Montreal OpenData website. It is only a small extract in central districts used to demonstrate the
main functions of spNetwork. It is mainly used internally for tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>small_mtl_network
</code></pre>


<h3>Format</h3>

<p>A sf object with 1244 rows and 2 variables
</p>

<dl>
<dt>TYPE</dt><dd><p>the type of road</p>
</dd>
<dt>geom</dt><dd><p>the geometry (linestrings)</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://donnees.montreal.ca/ville-de-montreal/geobase&gt;
</p>

<hr>
<h2 id='snapPointsToLines2'>Snap points to lines</h2><span id='topic+snapPointsToLines2'></span>

<h3>Description</h3>

<p>Snap points to their nearest lines (edited from maptools)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>snapPointsToLines2(points, lines, idField = NA, snap_dist = 300, max_iter = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="snapPointsToLines2_+3A_points">points</code></td>
<td>
<p>A feature collection of points</p>
</td></tr>
<tr><td><code id="snapPointsToLines2_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings</p>
</td></tr>
<tr><td><code id="snapPointsToLines2_+3A_idfield">idField</code></td>
<td>
<p>The name of the column to use as index for the lines</p>
</td></tr>
<tr><td><code id="snapPointsToLines2_+3A_snap_dist">snap_dist</code></td>
<td>
<p>A distance (float) given to find for each point its
nearest line in a spatial index. A too big value will produce
unnecessary distance calculations and a too short value will lead to
more iterations to find neighbours. In extrem cases, a too short value
could lead to points not associated with lines (index = -1).</p>
</td></tr>
<tr><td><code id="snapPointsToLines2_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer indicating how many iteration the search
algorithm must perform in the spatial index to find lines close to a
point. At each iteration, the snap_dist is doubled to find candidates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of points with the projected geometries
</p>


<h3>Examples</h3>

<pre><code class='language-R'># reading the data
data(mtl_network)
data(bike_accidents)
mtl_network$LineID &lt;- 1:nrow(mtl_network)
# snapping point to lines
snapped_points &lt;- snapPointsToLines2(bike_accidents,
    mtl_network,
    "LineID"
)
</code></pre>

<hr>
<h2 id='sp_char_index'>Coordinates to unique character vector</h2><span id='topic+sp_char_index'></span>

<h3>Description</h3>

<p>Generate a character vector based on a coordinates matrix and
the maximum number of digits to keep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_char_index(coords, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_char_index_+3A_coords">coords</code></td>
<td>
<p>A n * 2 matrix representing the coordinates</p>
</td></tr>
<tr><td><code id="sp_char_index_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep from the coordinates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector character vector of length n
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='spatial_index'>An object (c++ pointer) to do some spatial query of rectanlges (internal)</h2><span id='topic+spatial_index'></span>

<h3>Description</h3>

<p>An object (c++ pointer) that uses the geometry
index library from boost to perform spatial queries
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_index_+3A_x">x</code></td>
<td>
<p>- A numeric matrix with 4 columns (minX, minY, maxX, maxY)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new instance of the spatial_index class (c++ pointer)
</p>

<hr>
<h2 id='spatial_index+24new'>Constructor method for a spatial_index object</h2><span id='topic+spatial_index+24new'></span>

<h3>Description</h3>

<p>An object (c++ pointer) that uses the geometry
index library from boost to perform spatial queries
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_index+2B24new_+3A_x">x</code></td>
<td>
<p>- A numeric matrix with 4 columns (minX, minY, maxX, maxY)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new instance of the spatial_index class (c++ pointer)
</p>

<hr>
<h2 id='spatial_index+24tree_request'>spatial request on rtree index (internal)</h2><span id='topic+spatial_index+24tree_request'></span>

<h3>Description</h3>

<p>A method to get the boxes in the rtree intersecting another box
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_index+2B24tree_request_+3A_reqbbox">reqBbox</code></td>
<td>
<p>- A numeric vector with 4 values (minX, minY, maxX, maxY)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an IntegerVector with the indices of the intersected boxes
</p>

<hr>
<h2 id='spatial_request'>Spatial request</h2><span id='topic+spatial_request'></span>

<h3>Description</h3>

<p>Use a quadtree index to perform spatial request.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_request(geometry, tree, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_request_+3A_geometry">geometry</code></td>
<td>
<p>sf like object (feature collection or simple geometry)</p>
</td></tr>
<tr><td><code id="spatial_request_+3A_tree">tree</code></td>
<td>
<p>a tree object from package SearchTrees</p>
</td></tr>
<tr><td><code id="spatial_request_+3A_data">data</code></td>
<td>
<p>the original data used to build the tree object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a subset of data, intersecting geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='split_border'>Split boundary of polygon</h2><span id='topic+split_border'></span>

<h3>Description</h3>

<p>A function to cut the boundary of the study area into chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_border(polygon, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_border_+3A_polygon">polygon</code></td>
<td>
<p>The polygon representing the study area</p>
</td></tr>
<tr><td><code id="split_border_+3A_bw">bw</code></td>
<td>
<p>The maximum bandwidth</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings
</p>

<hr>
<h2 id='split_by_grid'>Split data with a grid</h2><span id='topic+split_by_grid'></span>

<h3>Description</h3>

<p>Function to split the dataset according to a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by_grid(grid, samples, events, lines, bw, tol, digits, split_all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_by_grid_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="split_by_grid_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points representing the samples points</p>
</td></tr>
<tr><td><code id="split_by_grid_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events points</p>
</td></tr>
<tr><td><code id="split_by_grid_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="split_by_grid_+3A_bw">bw</code></td>
<td>
<p>The kernel bandwidth (used to avoid edge effect)</p>
</td></tr>
<tr><td><code id="split_by_grid_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="split_by_grid_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="split_by_grid_+3A_split_all">split_all</code></td>
<td>
<p>A boolean indicating if we must split the lines at each vertex
(TRUE) or only at event vertices (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the split dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='split_by_grid_abw'>Split data with a grid for the adaptive bw function</h2><span id='topic+split_by_grid_abw'></span>

<h3>Description</h3>

<p>Function to split the dataset according to a grid for the
adaptive bw function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by_grid_abw(grid, events, lines, bw, tol, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_by_grid_abw_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="split_by_grid_abw_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events</p>
</td></tr>
<tr><td><code id="split_by_grid_abw_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines representing the network</p>
</td></tr>
<tr><td><code id="split_by_grid_abw_+3A_bw">bw</code></td>
<td>
<p>The kernel bandwidth (used to avoid edge effect)</p>
</td></tr>
<tr><td><code id="split_by_grid_abw_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="split_by_grid_abw_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the split dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='split_by_grid_abw.mc'>Split data with a grid for the adaptive bw function (multicore)</h2><span id='topic+split_by_grid_abw.mc'></span>

<h3>Description</h3>

<p>Function to split the dataset according to a grid for the
adaptive bw function with multicore support
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by_grid_abw.mc(grid, events, lines, bw, tol, digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_by_grid_abw.mc_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="split_by_grid_abw.mc_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events points</p>
</td></tr>
<tr><td><code id="split_by_grid_abw.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of lines representing the network</p>
</td></tr>
<tr><td><code id="split_by_grid_abw.mc_+3A_bw">bw</code></td>
<td>
<p>The kernel bandwidth (used to avoid edge effect)</p>
</td></tr>
<tr><td><code id="split_by_grid_abw.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="split_by_grid_abw.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the split dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='split_by_grid.mc'>Split data with a grid (multicore)</h2><span id='topic+split_by_grid.mc'></span>

<h3>Description</h3>

<p>Function to split the dataset according to a grid with multicore support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_by_grid.mc(
  grid,
  samples,
  events,
  lines,
  bw,
  tol,
  digits,
  split_all = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_by_grid.mc_+3A_grid">grid</code></td>
<td>
<p>A spatial grid to split the data within</p>
</td></tr>
<tr><td><code id="split_by_grid.mc_+3A_samples">samples</code></td>
<td>
<p>A feature collection of points representing the samples points</p>
</td></tr>
<tr><td><code id="split_by_grid.mc_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events points</p>
</td></tr>
<tr><td><code id="split_by_grid.mc_+3A_lines">lines</code></td>
<td>
<p>A feautre collection of linestrings representing the network</p>
</td></tr>
<tr><td><code id="split_by_grid.mc_+3A_bw">bw</code></td>
<td>
<p>The kernel bandwidth (used to avoid edge effect)</p>
</td></tr>
<tr><td><code id="split_by_grid.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the spatial tolerance when snapping events on
lines</p>
</td></tr>
<tr><td><code id="split_by_grid.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep</p>
</td></tr>
<tr><td><code id="split_by_grid.mc_+3A_split_all">split_all</code></td>
<td>
<p>A boolean indicating if we must split the lines at each vertex
(TRUE) or only at event vertices (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the split dataset
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='split_graph_components'>Split graph components</h2><span id='topic+split_graph_components'></span>

<h3>Description</h3>

<p>Function to split the results of build_graph and build_graph_directed
into their sub components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_graph_components(graph_result)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_graph_components_+3A_graph_result">graph_result</code></td>
<td>
<p>A list typically obtained from the function build_graph or build_graph_directed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists, the graph_result split for each graph component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtl_network)
mtl_network$length &lt;- as.numeric(sf::st_length(mtl_network))
graph_result &lt;- build_graph(mtl_network, 2, "length", attrs = TRUE)
sub_elements &lt;- split_graph_components(graph_result)
</code></pre>

<hr>
<h2 id='split_lines_at_vertex'>Split lines at vertices in a feature collection of linestrings</h2><span id='topic+split_lines_at_vertex'></span>

<h3>Description</h3>

<p>Split lines (feature collection of linestrings) at their nearest vertices
(feature collection of points), may fail if the line geometries are self intersecting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_lines_at_vertex(lines, points, nearest_lines_idx, mindist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_lines_at_vertex_+3A_lines">lines</code></td>
<td>
<p>The feature collection of linestrings to split</p>
</td></tr>
<tr><td><code id="split_lines_at_vertex_+3A_points">points</code></td>
<td>
<p>The feature collection of points to add to as vertex to the lines</p>
</td></tr>
<tr><td><code id="split_lines_at_vertex_+3A_nearest_lines_idx">nearest_lines_idx</code></td>
<td>
<p>For each point, the index of the nearest line</p>
</td></tr>
<tr><td><code id="split_lines_at_vertex_+3A_mindist">mindist</code></td>
<td>
<p>The minimum distance between one point and the extremity of
the line to add the point as a vertex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of linestrings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# reading the data
data(mtl_network)
data(bike_accidents)
# aggregating points within a 5 metres radius
bike_accidents$weight &lt;- 1
agg_points &lt;- aggregate_points(bike_accidents, 5)
mtl_network$LineID &lt;- 1:nrow(mtl_network)
# snapping point to lines
snapped_points &lt;- snapPointsToLines2(agg_points,
    mtl_network,
    "LineID"
)
# splitting lines
new_lines &lt;- split_lines_at_vertex(mtl_network, snapped_points,
    snapped_points$nearest_line_id, 1)

</code></pre>

<hr>
<h2 id='spNetwork-package'>spNetwork: Spatial Analysis on Network</h2><span id='topic+spNetwork'></span><span id='topic+spNetwork-package'></span>

<h3>Description</h3>

<p>Perform spatial analysis on network. Implement several methods for spatial analysis on network: Network Kernel Density estimation, building of spatial matrices based on network distance ('listw' objects from 'spdep' package), K functions estimation for point pattern analysis on network, k nearest neighbours on network, reachable area calculation, and graph generation References: Okabe et al (2019) <a href="https://doi.org/10.1080/13658810802475491">doi:10.1080/13658810802475491</a>; Okabe et al (2012, ISBN:978-0470770818);Baddeley et al (2015, ISBN:9781482210200).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jeremy Gelb <a href="mailto:jeremy.gelb@ucs.inrs.ca">jeremy.gelb@ucs.inrs.ca</a> (<a href="https://orcid.org/0000-0002-7114-2714">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Philippe Apparicio <a href="mailto:philippe.apparicio@ucs.inrs.ca">philippe.apparicio@ucs.inrs.ca</a> (<a href="https://orcid.org/0000-0001-6466-9342">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://jeremygelb.github.io/spNetwork/">https://jeremygelb.github.io/spNetwork/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/JeremyGelb/spNetwork/issues">https://github.com/JeremyGelb/spNetwork/issues</a>
</p>
</li></ul>


<hr>
<h2 id='st_bbox_by_feature'>Obtain all the bounding boxes of a feature collection</h2><span id='topic+st_bbox_by_feature'></span>

<h3>Description</h3>

<p>Obtain all the bounding boxes of a feature collection (INTERNAL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_bbox_by_feature(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_bbox_by_feature_+3A_x">x</code></td>
<td>
<p>a feature collection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix (xmin, ymin, xmax, ymax)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='st_bbox_geom'>sf geometry bbox</h2><span id='topic+st_bbox_geom'></span>

<h3>Description</h3>

<p>Generate polygon as the bounding box of a feature collection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>st_bbox_geom(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="st_bbox_geom_+3A_x">x</code></td>
<td>
<p>A feature collection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of polygons
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='surrounding_points'>Points along polygon boundary</h2><span id='topic+surrounding_points'></span>

<h3>Description</h3>

<p>Generate a feature collection of points by placing points along the border of
polygons of a feature collection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrounding_points(polygons, dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrounding_points_+3A_polygons">polygons</code></td>
<td>
<p>A feature collection of polygons</p>
</td></tr>
<tr><td><code id="surrounding_points_+3A_dist">dist</code></td>
<td>
<p>The distance between the points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of points representing the points arrond the polygond
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='tkde'>Temporal Kernel density estimate</h2><span id='topic+tkde'></span>

<h3>Description</h3>

<p>Calculate the Temporal kernel density estimate based on sampling points in
time and events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tkde(events, w, samples, bw, kernel_name, adaptive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tkde_+3A_events">events</code></td>
<td>
<p>A numeric vector representing the moments of occurrence of events</p>
</td></tr>
<tr><td><code id="tkde_+3A_w">w</code></td>
<td>
<p>The weight of the events</p>
</td></tr>
<tr><td><code id="tkde_+3A_samples">samples</code></td>
<td>
<p>A numeric vector representing the moments to sample</p>
</td></tr>
<tr><td><code id="tkde_+3A_bw">bw</code></td>
<td>
<p>A float, the bandwidth to use</p>
</td></tr>
<tr><td><code id="tkde_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="tkde_+3A_adaptive">adaptive</code></td>
<td>
<p>Boolean</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the density values at the requested timestamps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bike_accidents)
bike_accidents$Date &lt;- as.POSIXct(bike_accidents$Date, format = "%Y/%m/%d")
start &lt;- min(bike_accidents$Date)
diff &lt;- as.integer(difftime(bike_accidents$Date , start, units = "days"))
density &lt;- tkde(diff, rep(1,length(diff)), seq(0,max(diff),1), 2, "quartic")
</code></pre>

<hr>
<h2 id='tnkde'>Temporal Network Kernel density estimate</h2><span id='topic+tnkde'></span>

<h3>Description</h3>

<p>Calculate the Temporal Network Kernel Density Estimate based on a network of lines,
sampling points in space and times, and events in space and time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnkde(
  lines,
  events,
  time_field,
  w,
  samples_loc,
  samples_time,
  kernel_name,
  bw_net,
  bw_time,
  adaptive = FALSE,
  adaptive_separate = TRUE,
  trim_bw_net = NULL,
  trim_bw_time = NULL,
  method,
  div = "bw",
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  grid_shape = c(1, 1),
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkde_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_time_field">time_field</code></td>
<td>
<p>The name of the field in events indicating when the events
occurred. It must be a numeric field</p>
</td></tr>
<tr><td><code id="tnkde_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="tnkde_+3A_samples_loc">samples_loc</code></td>
<td>
<p>A feature collection of points representing the locations for
which the densities will be estimated.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_samples_time">samples_time</code></td>
<td>
<p>A numeric vector indicating when the densities will be sampled</p>
</td></tr>
<tr><td><code id="tnkde_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_bw_net">bw_net</code></td>
<td>
<p>The network kernel bandwidth (using the scale of the lines),
can be a single float or a numeric vector if a different bandwidth must be
used for each event.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_bw_time">bw_time</code></td>
<td>
<p>The time kernel bandwidth, can be a single float or a numeric
vector if a different bandwidth must be used for each event.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_adaptive">adaptive</code></td>
<td>
<p>A Boolean, indicating if an adaptive bandwidth must be used.
Both spatial and temporal bandwidths are adapted but separately.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_adaptive_separate">adaptive_separate</code></td>
<td>
<p>A boolean indicating if the adaptive bandwidths
for the time and the network dimensions must be calculated separately (TRUE) or in
interaction (FALSE)</p>
</td></tr>
<tr><td><code id="tnkde_+3A_trim_bw_net">trim_bw_net</code></td>
<td>
<p>A float, indicating the maximum value for the adaptive
network bandwidth</p>
</td></tr>
<tr><td><code id="tnkde_+3A_trim_bw_time">trim_bw_time</code></td>
<td>
<p>A float, indicating the maximum value for the adaptive
time bandwidth</p>
</td></tr>
<tr><td><code id="tnkde_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="tnkde_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwith)
&quot;none&quot; (the simple sum).</p>
</td></tr>
<tr><td><code id="tnkde_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="tnkde_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="tnkde_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>**Temporal Network Kernel Density Estimate**<br />
The TNKDE is an extension of the NKDE considering both the location of events on the network and
in time. Thus, density estimation (density sampling) can be done along lines of the network and
at different time. It can be used with the three NKDE (simple, discontinuous and continuous).
<br /><br />
**density in time and space**<br />
Two bandwidths must be provided, one for the network distance and one for the
time distance. They are both used to calculate the contribution of each event
to each sampling point. Let us consider one event E and a sample S. dnet(E,S)
is the contribution to network density of E at S location and dtime(E,S) is
the contribution to time density of E at S time. The total contribution is
thus dnet(E,S) * dtime(E,S). If one of the two densities is 0, then the total
density is 0 because the sampling point is out of the covered area by the
event in time or in the network space.
<br /><br />
</p>
<p>**adaptive bandwidth**<br />
It is possible to use an adaptive bandwidth both on the network and in time.
Adaptive bandwidths are calculated using the Abramson’s smoothing regimen
(Abramson 1982). To do so, the original fixed
bandwidths must be specified (bw_net and bw_time parameters).
The maximum size of the two local bandwidths can be limited with
the parameters trim_bw_net and trim_bw_time.
<br /><br />
</p>
<p>**Diggle correction factor**<br />
A set of events can be limited in both space (limits of the study
area) and time ( beginning and ending of the data collection period). These
limits induce lower densities at the border of the set of events, because
they are not sampled outside the limits. It is possible to apply the Diggle
correction factor (Diggle 1985) in both the
network and time spaces to minimize this effect.
<br /><br />
</p>
<p>**Separated or simultaneous adaptive bandwidth**<br />
When the parameter adaptive is TRUE, one can choose between using separated
calculation of network and temporal bandwidths, and calculating them
simultaneously. In the first case (default), the network bandwidths are
determined for each event by considering only their locations and the time
bandwidths are determined by considering only there time stamps. In the second
case, for each event, the spatio-temporal density at its location on the
network and in time is estimated and used to determine both the network and
temporal bandwidths. This second approach must be preferred if the events are
characterized by a high level of spatio-temporal autocorrelation.
</p>


<h3>Value</h3>

<p>A matrix with the estimated density for each sample point (rows) at
each timestamp (columns). If adaptive = TRUE, the function returns a list
with two slots: k (the matrix with the density values) and events (a
feature collection of points with the local bandwidths).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading the data
data(mtl_network)
data(bike_accidents)

# converting the Date field to a numeric field (counting days)
bike_accidents$Time &lt;- as.POSIXct(bike_accidents$Date, format = "%Y/%m/%d")
start &lt;- as.POSIXct("2016/01/01", format = "%Y/%m/%d")
bike_accidents$Time &lt;- difftime(bike_accidents$Time, start, units = "days")
bike_accidents$Time &lt;- as.numeric(bike_accidents$Time)

# creating sample points
lixels &lt;- lixelize_lines(mtl_network, 50)
sample_points &lt;- lines_center(lixels)

# choosing sample in times (every 10 days)
sample_time &lt;- seq(0, max(bike_accidents$Time), 10)

# calculating the densities
tnkde_densities &lt;- tnkde(lines = mtl_network,
    events = bike_accidents, time_field = "Time",
    w = rep(1, nrow(bike_accidents)),
    samples_loc = sample_points,
    samples_time = sample_time,
    kernel_name = "quartic",
    bw_net = 700, bw_time = 60, adaptive = TRUE,
    trim_bw_net = 900, trim_bw_time = 80,
    method = "discontinuous", div = "bw",
    max_depth = 10, digits = 2, tol = 0.01,
    agg = 15, grid_shape = c(1,1),
    verbose  = FALSE)

</code></pre>

<hr>
<h2 id='tnkde_get_loo_values'>The exposed function to calculate TNKDE likelihood cv</h2><span id='topic+tnkde_get_loo_values'></span>

<h3>Description</h3>

<p>The exposed function to calculate TNKDE likelihood cv (INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnkde_get_loo_values(
  method,
  neighbour_list,
  sel_events,
  sel_events_wid,
  sel_events_time,
  events,
  events_wid,
  events_time,
  weights,
  bws_net,
  bws_time,
  kernel_name,
  line_list,
  max_depth,
  min_tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkde_get_loo_values_+3A_method">method</code></td>
<td>
<p>a string, one of &quot;simple&quot;, &quot;continuous&quot;, &quot;discontinuous&quot;</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a List, giving for each node an IntegerVector with
its neighbours</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_sel_events">sel_events</code></td>
<td>
<p>a Numeric vector indicating the selected events (id of nodes)</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_sel_events_wid">sel_events_wid</code></td>
<td>
<p>a Numeric Vector indicating the unique if of the selected events</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_sel_events_time">sel_events_time</code></td>
<td>
<p>a Numeric Vector indicating the time of the selected events</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_events">events</code></td>
<td>
<p>a NumericVector indicating the nodes in the graph being events</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_events_wid">events_wid</code></td>
<td>
<p>a NumericVector indicating the unique id of all the events</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_events_time">events_time</code></td>
<td>
<p>a NumericVector indicating the timestamp of each event</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_weights">weights</code></td>
<td>
<p>a cube with the weights associated with each event for each
bws_net and bws_time.</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_bws_net">bws_net</code></td>
<td>
<p>an arma::vec with the network bandwidths to consider</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_bws_time">bws_time</code></td>
<td>
<p>an arma::vec with the time bandwidths to consider</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_kernel_name">kernel_name</code></td>
<td>
<p>a string with the name of the kernel to use</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame describing the lines</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth</p>
</td></tr>
<tr><td><code id="tnkde_get_loo_values_+3A_min_tol">min_tol</code></td>
<td>
<p>a double indicating by how much 0 in density values must be replaced</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the CV score for each pair of bandiwdths
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='tnkde_worker'>TNKDE worker</h2><span id='topic+tnkde_worker'></span>

<h3>Description</h3>

<p>The worker function for tnkde and tnkde.mc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnkde_worker(
  lines,
  events_loc,
  events,
  samples_loc,
  samples_time,
  kernel_name,
  bw_net,
  bw_time,
  bws_net,
  bws_time,
  method,
  div,
  digits,
  tol,
  sparse,
  max_depth,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkde_worker_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings with the sampling points. The
geometries must be simple Linestrings (may crash if some geometries
are invalid)</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_events_loc">events_loc</code></td>
<td>
<p>A feature collection of points representing the aggergated events on the
network. The points will be snapped on the network.</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the base events on the
network</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_samples_loc">samples_loc</code></td>
<td>
<p>A feature collection of points representing the locations for
which the densities will be estimated.</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_samples_time">samples_time</code></td>
<td>
<p>A numeric vector representing when each density will be
estimated</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_bw_net">bw_net</code></td>
<td>
<p>The global network kernel bandwidth</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_bw_time">bw_time</code></td>
<td>
<p>The global time kernel bandwidth</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_bws_net">bws_net</code></td>
<td>
<p>The network kernel bandwidth (in meters) for each event</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_bws_time">bws_time</code></td>
<td>
<p>The time bandwidth for each event</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see details for more information)</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwidth)
&quot;none&quot; (the simple sum).</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_digits">digits</code></td>
<td>
<p>The number of digits to keep in the spatial coordinates. It
ensures that topology is good when building the network. Default is 3</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_tol">tol</code></td>
<td>
<p>When adding the events and the sampling points to the network,
the minimum distance between these points and the lines extremities. When
points are closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. Regular matrices are faster, but require more
memory and could lead to error, in particular with multiprocessing. Sparse
matrices are slower, but require much less memory.</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_max_depth">max_depth</code></td>
<td>
<p>When using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has a lot of
small edges (area with a lot of intersections and a lot of events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 8 should yield good
estimates. A larger value can be used without problem for the discontinuous
method. For the continuous method, a larger value will strongly impact
calculation speed.</p>
</td></tr>
<tr><td><code id="tnkde_worker_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix with the nkde values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='tnkde_worker_bw_sel'>Worker function fo Bandwidth selection by likelihood cross validation for temporal NKDE</h2><span id='topic+tnkde_worker_bw_sel'></span>

<h3>Description</h3>

<p>Calculate for multiple network and time bandwidths the cross validation likelihood to
select an appropriate bandwidth in a data-driven approach (INTERNAL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnkde_worker_bw_sel(
  lines,
  quad_events,
  events_loc,
  events,
  w,
  kernel_name,
  bws_net,
  bws_time,
  method,
  div,
  digits,
  tol,
  sparse,
  max_depth,
  verbose = FALSE,
  cvl = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkde_worker_bw_sel_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_quad_events">quad_events</code></td>
<td>
<p>a feature collection of points indicating for which events the densities must be calculated</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_events_loc">events_loc</code></td>
<td>
<p>A feature collection of points representing the location of the events</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events. Multiple events can share
the same location. They are linked by the goid column</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_w">w</code></td>
<td>
<p>A numeric array with the weight of the events for each pair of bandwidth</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use (string)</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_bws_net">bws_net</code></td>
<td>
<p>A numeric vector with the network bandwidths</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_bws_time">bws_time</code></td>
<td>
<p>A numeric vector with the time bandwidths</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_method">method</code></td>
<td>
<p>The type of NKDE to use (string)</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_div">div</code></td>
<td>
<p>The type of divisor (not used currently)</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_max_depth">max_depth</code></td>
<td>
<p>The maximum depth of recursion</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_verbose">verbose</code></td>
<td>
<p>A boolean</p>
</td></tr>
<tr><td><code id="tnkde_worker_bw_sel_+3A_cvl">cvl</code></td>
<td>
<p>A boolean indicating if the cvl method (TRUE) or the loo (FALSE) method must be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with the CV score for each pair of bandiwdths (rows and lines) for each event (slices)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no example provided, this is an internal function
</code></pre>

<hr>
<h2 id='tnkde.mc'>Temporal Network Kernel density estimate (multicore)</h2><span id='topic+tnkde.mc'></span>

<h3>Description</h3>

<p>Calculate the Temporal Network Kernel Density Estimate based on a network of lines,
sampling points in space and times, and events in space and time with multicore support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tnkde.mc(
  lines,
  events,
  time_field,
  w,
  samples_loc,
  samples_time,
  kernel_name,
  bw_net,
  bw_time,
  adaptive = FALSE,
  adaptive_separate = TRUE,
  trim_bw_net = NULL,
  trim_bw_time = NULL,
  method,
  div = "bw",
  diggle_correction = FALSE,
  study_area = NULL,
  max_depth = 15,
  digits = 5,
  tol = 0.1,
  agg = NULL,
  sparse = TRUE,
  grid_shape = c(1, 1),
  verbose = TRUE,
  check = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkde.mc_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying network. The
geometries must be simple Linestrings (may crash if some geometries
are invalid) without MultiLineSring.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_events">events</code></td>
<td>
<p>events A feature collection of points representing the events on the
network. The points will be snapped on the network to their closest line.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_time_field">time_field</code></td>
<td>
<p>The name of the field in events indicating when the events
occurred. It must be a numeric field</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_w">w</code></td>
<td>
<p>A vector representing the weight of each event</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_samples_loc">samples_loc</code></td>
<td>
<p>A feature collection of points representing the locations for
which the densities will be estimated.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_samples_time">samples_time</code></td>
<td>
<p>A numeric vector indicating when the densities will be sampled</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use. Must be one of triangle,
gaussian, tricube, cosine, triweight, quartic, epanechnikov or uniform.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_bw_net">bw_net</code></td>
<td>
<p>The network kernel bandwidth (using the scale of the lines),
can be a single float or a numeric vector if a different bandwidth must be
used for each event.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_bw_time">bw_time</code></td>
<td>
<p>The time kernel bandwidth, can be a single float or a numeric
vector if a different bandwidth must be used for each event.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_adaptive">adaptive</code></td>
<td>
<p>A Boolean, indicating if an adaptive bandwidth must be used.
Both spatial and temporal bandwidths are adapted but separately.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_adaptive_separate">adaptive_separate</code></td>
<td>
<p>A boolean indicating if the adaptive bandwidths for
the time and the network dimensions must be calculated separately (TRUE) or
in interaction (FALSE)</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_trim_bw_net">trim_bw_net</code></td>
<td>
<p>A float, indicating the maximum value for the adaptive
network bandwidth</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_trim_bw_time">trim_bw_time</code></td>
<td>
<p>A float, indicating the maximum value for the adaptive
time bandwidth</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_method">method</code></td>
<td>
<p>The method to use when calculating the NKDE, must be one of
simple / discontinuous / continuous (see nkde details for more information)</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwith)
&quot;none&quot; (the simple sum).</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_diggle_correction">diggle_correction</code></td>
<td>
<p>A Boolean indicating if the correction factor
for edge effect must be used.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_study_area">study_area</code></td>
<td>
<p>A feature collection of polygons 
representing the limits of the study area.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_max_depth">max_depth</code></td>
<td>
<p>when using the continuous and discontinuous methods, the
calculation time and memory use can go wild  if the network has many
small edges (area with many of intersections and many events). To
avoid it, it is possible to set here a maximum depth. Considering that the
kernel is divided at intersections, a value of 10 should yield good
estimates in most cases. A larger value can be used without a problem for the
discontinuous method. For the continuous method, a larger value will
strongly impact calculation speed.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too high a
precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_agg">agg</code></td>
<td>
<p>A double indicating if the events must be aggregated within a
distance. If NULL, the events are aggregated only by rounding the
coordinates.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_grid_shape">grid_shape</code></td>
<td>
<p>A vector of two values indicating how the study area
must be split when performing the calculus. Default is c(1,1) (no split). A finer grid could
reduce memory usage and increase speed when a large dataset is used. When using
multiprocessing, the work in each grid is dispatched between the workers.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
<tr><td><code id="tnkde.mc_+3A_check">check</code></td>
<td>
<p>A Boolean indicating if the geometry checks must be run before
the operation. This might take some times, but it will ensure that the CRS
of the provided objects are valid and identical, and that geometries are valid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details, see help(tnkde) and help(nkde)
</p>


<h3>Value</h3>

<p>A matrix with the estimated density for each sample point (rows) at
each timestamp (columns). If adaptive = TRUE, the function returns a list
with two slots: k (the matrix with the density values) and events (a
feature collection of points with the local bandwidths).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading the data
data(mtl_network)
data(bike_accidents)

# converting the Date field to a numeric field (counting days)
bike_accidents$Time &lt;- as.POSIXct(bike_accidents$Date, format = "%Y/%m/%d")
start &lt;- as.POSIXct("2016/01/01", format = "%Y/%m/%d")
bike_accidents$Time &lt;- difftime(bike_accidents$Time, start, units = "days")
bike_accidents$Time &lt;- as.numeric(bike_accidents$Time)

# creating sample points
lixels &lt;- lixelize_lines(mtl_network, 50)
sample_points &lt;- lines_center(lixels)

# choosing sample in times (every 10 days)
sample_time &lt;- seq(0, max(bike_accidents$Time), 10)

future::plan(future::multisession(workers=1))

# calculating the densities
tnkde_densities &lt;- tnkde.mc(lines = mtl_network,
    events = bike_accidents, time_field = "Time",
    w = rep(1, nrow(bike_accidents)),
    samples_loc = sample_points,
    samples_time = sample_time,
    kernel_name = "quartic",
    bw_net = 700, bw_time = 60, adaptive = TRUE,
    trim_bw_net = 900, trim_bw_time = 80,
    method = "discontinuous", div = "bw",
    max_depth = 10, digits = 2, tol = 0.01,
    agg = 15, grid_shape = c(1,1),
    verbose  = FALSE)

## make sure any open connections are closed afterward
if (!inherits(future::plan(), "sequential")) future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='tnkdecontinuousfunction'>The main function to calculate continuous TNKDE (with ARMADILO and sparse matrix)</h2><span id='topic+tnkdecontinuousfunction'></span><span id='topic+continuous_tnkde_cpp_arma_sparse'></span><span id='topic+continuous_tnkde_cpp_arma'></span>

<h3>Description</h3>

<p>The main function to calculate continuous TNKDE (with ARMADILO and sparse matrix)
</p>
<p>The main function to calculate continuous TNKDE (with ARMADILO and integer matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continuous_tnkde_cpp_arma_sparse(
  neighbour_list,
  events,
  events_time,
  weights,
  samples,
  samples_time,
  bws_net,
  bws_time,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div
)

continuous_tnkde_cpp_arma(
  neighbour_list,
  events,
  events_time,
  weights,
  samples,
  samples_time,
  bws_net,
  bws_time,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkdecontinuousfunction_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_events_time">events_time</code></td>
<td>
<p>a numeric vector with the time for the events</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of the weight of each event</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_samples">samples</code></td>
<td>
<p>a DataFrame of the samples (with spatial coordinates and belonging edge)</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_samples_time">samples_time</code></td>
<td>
<p>a NumericVector indicating when to do the samples</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_bws_net">bws_net</code></td>
<td>
<p>the network kernel bandwidths for each event</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_bws_time">bws_time</code></td>
<td>
<p>the time kernel bandwidths for each event</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_kernel_name">kernel_name</code></td>
<td>
<p>the name of the kernel to use</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_nodes">nodes</code></td>
<td>
<p>a DataFrame representing the nodes of the graph (with spatial coordinates)</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the function must print its progress</p>
</td></tr>
<tr><td><code id="tnkdecontinuousfunction_+3A_div">div</code></td>
<td>
<p>a string indicating how to standardize the kernel values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a List with two matrices: the kernel values (sum_k) and the number of events for each sample (n)
</p>
<p>a List with two matrices: the kernel values (sum_k) and the number of events for each sample (n)
</p>

<hr>
<h2 id='tnkdediscontinuousfunction'>The main function to calculate discontinuous NKDE (ARMA and Integer matrix)</h2><span id='topic+tnkdediscontinuousfunction'></span><span id='topic+discontinuous_tnkde_cpp_arma'></span>

<h3>Description</h3>

<p>The main function to calculate discontinuous NKDE (ARMA and Integer matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discontinuous_tnkde_cpp_arma(
  neighbour_list,
  events,
  weights,
  events_time,
  samples,
  samples_time,
  bws_net,
  bws_time,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div = "bw"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkdediscontinuousfunction_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of the weight of each event</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_events_time">events_time</code></td>
<td>
<p>a numeric vector with the time for the events</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_samples">samples</code></td>
<td>
<p>a DataFrame of the samples (with spatial coordinates and belonging edge)</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_samples_time">samples_time</code></td>
<td>
<p>a NumericVector indicating when to do the samples</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_bws_net">bws_net</code></td>
<td>
<p>the network kernel bandwidths for each event</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_kernel_name">kernel_name</code></td>
<td>
<p>the name of the kernel function to use</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_nodes">nodes</code></td>
<td>
<p>a DataFrame representing the nodes of the graph (with spatial coordinates)</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the function must print its progress</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunction_+3A_div">div</code></td>
<td>
<p>a string indicating how to standardize the kernel values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a List with two matrices: the kernel values (sum_k) and the number of events for each sample (n)
</p>

<hr>
<h2 id='tnkdediscontinuousfunctionsparse'>The main function to calculate discontinuous NKDE (ARMA and sparse matrix)</h2><span id='topic+tnkdediscontinuousfunctionsparse'></span><span id='topic+discontinuous_tnkde_cpp_arma_sparse'></span>

<h3>Description</h3>

<p>The main function to calculate discontinuous NKDE (ARMA and sparse matrix)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discontinuous_tnkde_cpp_arma_sparse(
  neighbour_list,
  events,
  weights,
  events_time,
  samples,
  samples_time,
  bws_net,
  bws_time,
  kernel_name,
  nodes,
  line_list,
  max_depth,
  verbose,
  div = "bw"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_neighbour_list">neighbour_list</code></td>
<td>
<p>a list of the neighbours of each node</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_events">events</code></td>
<td>
<p>a numeric vector of the node id of each event</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of the weight of each event</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_events_time">events_time</code></td>
<td>
<p>a numeric vector with the time for the events</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_samples">samples</code></td>
<td>
<p>a DataFrame of the samples (with spatial coordinates and belonging edge)</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_samples_time">samples_time</code></td>
<td>
<p>a NumericVector indicating when to do the samples</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_bws_net">bws_net</code></td>
<td>
<p>the network kernel bandwidths for each event</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_kernel_name">kernel_name</code></td>
<td>
<p>the name of the kernel function to use</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_nodes">nodes</code></td>
<td>
<p>a DataFrame representing the nodes of the graph (with spatial coordinates)</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_line_list">line_list</code></td>
<td>
<p>a DataFrame representing the lines of the graph</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_max_depth">max_depth</code></td>
<td>
<p>the maximum recursion depth (after which recursion is stopped)</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_verbose">verbose</code></td>
<td>
<p>a boolean indicating if the function must print its progress</p>
</td></tr>
<tr><td><code id="tnkdediscontinuousfunctionsparse_+3A_div">div</code></td>
<td>
<p>a string indicating how to standardize the kernel values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a List with two matrices: the kernel values (sum_k) and the number of events for each sample (n)
</p>

<hr>
<h2 id='triangle_kernel'>triangle kernel</h2><span id='topic+triangle_kernel'></span>

<h3>Description</h3>

<p>Function implementing the triangle kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="triangle_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='triangle_kernel_cpp'>c++ triangle kernel</h2><span id='topic+triangle_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ triangle kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="triangle_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='triangle_kernelos'>c++ triangle kernel for one distance</h2><span id='topic+triangle_kernelos'></span>

<h3>Description</h3>

<p>c++ triangle kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="triangle_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='tricube_kernel'>Tricube kernel</h2><span id='topic+tricube_kernel'></span>

<h3>Description</h3>

<p>Function implementing the tricube kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tricube_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tricube_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="tricube_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='tricube_kernel_cpp'>c++ tricube kernel</h2><span id='topic+tricube_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ tricube kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tricube_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tricube_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="tricube_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='tricube_kernelos'>c++ tricube kernel for one distance</h2><span id='topic+tricube_kernelos'></span>

<h3>Description</h3>

<p>c++ tricube kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tricube_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tricube_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="tricube_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='trim_lines_at'>Helper for isochrones lines cutting</h2><span id='topic+trim_lines_at'></span>

<h3>Description</h3>

<p>last operation for isochrone calculation, cutting the lines at
their begining and ending. This is a worker function for calc_isochrones.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim_lines_at(df1, graph_result, d, dd, i, donught)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_lines_at_+3A_df1">df1</code></td>
<td>
<p>A features collection of linestrings with some specific fields.</p>
</td></tr>
<tr><td><code id="trim_lines_at_+3A_graph_result">graph_result</code></td>
<td>
<p>A list produced by the functions build_graph_directed or build_graph.</p>
</td></tr>
<tr><td><code id="trim_lines_at_+3A_d">d</code></td>
<td>
<p>the end distance of this isochrones.</p>
</td></tr>
<tr><td><code id="trim_lines_at_+3A_dd">dd</code></td>
<td>
<p>the start distance of this isochrones.</p>
</td></tr>
<tr><td><code id="trim_lines_at_+3A_i">i</code></td>
<td>
<p>the actual iteration.</p>
</td></tr>
<tr><td><code id="trim_lines_at_+3A_donught">donught</code></td>
<td>
<p>A boolean indicating if the returned isochrone will be plained or a donught.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A feature collection of lines
</p>

<hr>
<h2 id='triweight_kernel'>Triweight kernel</h2><span id='topic+triweight_kernel'></span>

<h3>Description</h3>

<p>Function implementing the triweight kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triweight_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triweight_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="triweight_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='triweight_kernel_cpp'>c++ triweight kernel</h2><span id='topic+triweight_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ triweight kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triweight_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triweight_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="triweight_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='triweight_kernelos'>c++ triweight kernel for one distance</h2><span id='topic+triweight_kernelos'></span>

<h3>Description</h3>

<p>c++ triweight kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triweight_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triweight_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="triweight_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='uniform_kernel'>Uniform kernel</h2><span id='topic+uniform_kernel'></span>

<h3>Description</h3>

<p>Function implementing the uniform kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform_kernel(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform_kernel_+3A_d">d</code></td>
<td>
<p>The distance from the event</p>
</td></tr>
<tr><td><code id="uniform_kernel_+3A_bw">bw</code></td>
<td>
<p>The bandwidth used for the kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

<hr>
<h2 id='uniform_kernel_cpp'>c++ uniform kernel</h2><span id='topic+uniform_kernel_cpp'></span>

<h3>Description</h3>

<p>c++ uniform kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform_kernel_cpp(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform_kernel_cpp_+3A_d">d</code></td>
<td>
<p>a vector of distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="uniform_kernel_cpp_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='uniform_kernelos'>c++ uniform kernel for one distance</h2><span id='topic+uniform_kernelos'></span>

<h3>Description</h3>

<p>c++ uniform kernel for one distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniform_kernelos(d, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniform_kernelos_+3A_d">d</code></td>
<td>
<p>a double, the distances for which the density must be calculated</p>
</td></tr>
<tr><td><code id="uniform_kernelos_+3A_bw">bw</code></td>
<td>
<p>a double representing the size of the kernel bandwidth</p>
</td></tr>
</table>

<hr>
<h2 id='worker_adaptive_bw_tnkde'>Worker function for adaptive bandwidth for TNDE</h2><span id='topic+worker_adaptive_bw_tnkde'></span>

<h3>Description</h3>

<p>The worker function to calculate Adaptive bandwidths according
to Abramson’s smoothing regimen for TNKDE with a space-time interaction (INTERNAL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worker_adaptive_bw_tnkde(
  lines,
  quad_events,
  events_loc,
  events,
  w,
  kernel_name,
  bw_net,
  bw_time,
  method,
  div,
  digits,
  tol,
  sparse,
  max_depth,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_lines">lines</code></td>
<td>
<p>A feature collection of linestrings representing the underlying
network</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_quad_events">quad_events</code></td>
<td>
<p>a feature collection of points indicating for which events
the densities must be calculated</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_events_loc">events_loc</code></td>
<td>
<p>A feature collection of points representing the location of
the events</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_events">events</code></td>
<td>
<p>A feature collection of points representing the events.
Multiple events can share the same location. They are linked by the goid
column</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_w">w</code></td>
<td>
<p>A numeric vector with the weight of the events</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_kernel_name">kernel_name</code></td>
<td>
<p>The name of the kernel to use (string)</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_bw_net">bw_net</code></td>
<td>
<p>A float indicating the fixed network bandwidth</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_bw_time">bw_time</code></td>
<td>
<p>A float indicating the fixed time bandwidth</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_method">method</code></td>
<td>
<p>The type of NKDE to use (string)</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_div">div</code></td>
<td>
<p>The divisor to use for the kernel. Must be &quot;n&quot; (the number of
events within the radius around each sampling point), &quot;bw&quot; (the bandwidth)
&quot;none&quot; (the simple sum).</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_digits">digits</code></td>
<td>
<p>The number of digits to retain from the spatial coordinates. It
ensures that topology is good when building the network. Default is 3. Too
high a precision (high number of digits) might break some connections</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_tol">tol</code></td>
<td>
<p>A float indicating the minimum distance between the events and the
lines' extremities when adding the point to the network. When points are
closer, they are added at the extremity of the lines.</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_sparse">sparse</code></td>
<td>
<p>A Boolean indicating if sparse or regular matrices should be
used by the Rcpp functions. These matrices are used to store edge indices
between two nodes in a graph. Regular matrices are faster, but require more
memory, in particular with multiprocessing. Sparse matrices are slower (a
bit), but require much less memory.</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_max_depth">max_depth</code></td>
<td>
<p>An integer, the maximum depth to reach for continuous and
discontinuous NKDE</p>
</td></tr>
<tr><td><code id="worker_adaptive_bw_tnkde_+3A_verbose">verbose</code></td>
<td>
<p>A Boolean, indicating if the function should print messages
about the process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the local bandwidths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#This is an internal function, no example provided
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
